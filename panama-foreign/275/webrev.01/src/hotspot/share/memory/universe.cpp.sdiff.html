<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/universe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/universe.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  71 #include &quot;runtime/init.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/sharedRuntime.hpp&quot;
  75 #include &quot;runtime/synchronizer.hpp&quot;
  76 #include &quot;runtime/thread.inline.hpp&quot;
  77 #include &quot;runtime/timerTrace.hpp&quot;
  78 #include &quot;runtime/vmOperations.hpp&quot;
  79 #include &quot;services/memoryService.hpp&quot;
  80 #include &quot;utilities/align.hpp&quot;
  81 #include &quot;utilities/autoRestore.hpp&quot;
  82 #include &quot;utilities/copy.hpp&quot;
  83 #include &quot;utilities/debug.hpp&quot;
  84 #include &quot;utilities/events.hpp&quot;
  85 #include &quot;utilities/formatBuffer.hpp&quot;
  86 #include &quot;utilities/hashtable.inline.hpp&quot;
  87 #include &quot;utilities/macros.hpp&quot;
  88 #include &quot;utilities/ostream.hpp&quot;
  89 #include &quot;utilities/preserveException.hpp&quot;
  90 
<span class="line-removed">  91 #define PRIMITIVE_MIRRORS_DO(func) \</span>
<span class="line-removed">  92   func(_int_mirror)    \</span>
<span class="line-removed">  93   func(_float_mirror)  \</span>
<span class="line-removed">  94   func(_double_mirror) \</span>
<span class="line-removed">  95   func(_byte_mirror)   \</span>
<span class="line-removed">  96   func(_bool_mirror)   \</span>
<span class="line-removed">  97   func(_char_mirror)   \</span>
<span class="line-removed">  98   func(_long_mirror)   \</span>
<span class="line-removed">  99   func(_short_mirror)  \</span>
<span class="line-removed"> 100   func(_void_mirror)</span>
<span class="line-removed"> 101 </span>
<span class="line-removed"> 102 #define DEFINE_PRIMITIVE_MIRROR(m) \</span>
<span class="line-removed"> 103     oop Universe::m  = NULL;</span>
<span class="line-removed"> 104 </span>
 105 // Known objects
<span class="line-removed"> 106 PRIMITIVE_MIRRORS_DO(DEFINE_PRIMITIVE_MIRROR)</span>
 107 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
 108 Klass* Universe::_objectArrayKlassObj                 = NULL;
<span class="line-modified"> 109 oop Universe::_mirrors[T_VOID+1]                      = { NULL /*, NULL...*/ };</span>
 110 
 111 OopHandle Universe::_main_thread_group;
 112 OopHandle Universe::_system_thread_group;
 113 OopHandle Universe::_the_empty_class_array;
 114 OopHandle Universe::_the_null_string;
 115 OopHandle Universe::_the_min_jint_string;
 116 
 117 OopHandle Universe::_the_null_sentinel;
 118 
 119 // _out_of_memory_errors is an objArray
 120 enum OutOfMemoryInstance { _oom_java_heap,
 121                            _oom_c_heap,
 122                            _oom_metaspace,
 123                            _oom_class_metaspace,
 124                            _oom_array_size,
 125                            _oom_gc_overhead_limit,
 126                            _oom_realloc_objects,
 127                            _oom_retry,
 128                            _oom_count };
 129 
 130 OopHandle Universe::_out_of_memory_errors;
 131 OopHandle Universe::_delayed_stack_overflow_error_message;
 132 OopHandle Universe::_preallocated_out_of_memory_error_array;
 133 volatile jint Universe::_preallocated_out_of_memory_error_avail_count = 0;
 134 
 135 OopHandle Universe::_null_ptr_exception_instance;
 136 OopHandle Universe::_arithmetic_exception_instance;
 137 OopHandle Universe::_virtual_machine_error_instance;
 138 
<span class="line-modified"> 139 oop Universe::_reference_pending_list = NULL;</span>
 140 
 141 Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
 142 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 143 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 144 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
 145 LatestMethodCache* Universe::_throw_no_such_method_error_cache = NULL;
 146 LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;
 147 
 148 bool Universe::_verify_in_progress                    = false;
 149 long Universe::verify_flags                           = Universe::Verify_All;
 150 
 151 Array&lt;int&gt;* Universe::_the_empty_int_array            = NULL;
 152 Array&lt;u2&gt;* Universe::_the_empty_short_array           = NULL;
 153 Array&lt;Klass*&gt;* Universe::_the_empty_klass_array     = NULL;
 154 Array&lt;InstanceKlass*&gt;* Universe::_the_empty_instance_klass_array  = NULL;
 155 Array&lt;Method*&gt;* Universe::_the_empty_method_array   = NULL;
 156 
 157 // These variables are guarded by FullGCALot_lock.
 158 debug_only(OopHandle Universe::_fullgc_alot_dummy_array;)
 159 debug_only(int Universe::_fullgc_alot_dummy_next = 0;)
</pre>
<hr />
<pre>
 180 
 181 objArrayOop Universe::the_empty_class_array ()  {
 182   return (objArrayOop)_the_empty_class_array.resolve();
 183 }
 184 
 185 oop Universe::main_thread_group()                 { return _main_thread_group.resolve(); }
 186 void Universe::set_main_thread_group(oop group)   { _main_thread_group = OopHandle(vm_global(), group); }
 187 
 188 oop Universe::system_thread_group()               { return _system_thread_group.resolve(); }
 189 void Universe::set_system_thread_group(oop group) { _system_thread_group = OopHandle(vm_global(), group); }
 190 
 191 oop Universe::the_null_string()                   { return _the_null_string.resolve(); }
 192 oop Universe::the_min_jint_string()               { return _the_min_jint_string.resolve(); }
 193 
 194 oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception_instance.resolve(); }
 195 oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception_instance.resolve(); }
 196 oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error_instance.resolve(); }
 197 
 198 oop Universe::the_null_sentinel()                 { return _the_null_sentinel.resolve(); }
 199 





























 200 void Universe::basic_type_classes_do(void f(Klass*)) {
 201   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 202     f(_typeArrayKlassObjs[i]);
 203   }
 204 }
 205 
 206 void Universe::basic_type_classes_do(KlassClosure *closure) {
 207   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 208     closure-&gt;do_klass(_typeArrayKlassObjs[i]);
 209   }
 210 }
 211 
<span class="line-removed"> 212 #define DO_PRIMITIVE_MIRROR(m) \</span>
<span class="line-removed"> 213   f-&gt;do_oop((oop*) &amp;m);</span>
<span class="line-removed"> 214 </span>
 215 void Universe::oops_do(OopClosure* f) {
<span class="line-removed"> 216   PRIMITIVE_MIRRORS_DO(DO_PRIMITIVE_MIRROR);</span>
 217 
<span class="line-removed"> 218   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {</span>
<span class="line-removed"> 219     f-&gt;do_oop(&amp;_mirrors[i]);</span>
<span class="line-removed"> 220   }</span>
<span class="line-removed"> 221   assert(_mirrors[0] == NULL &amp;&amp; _mirrors[T_BOOLEAN - 1] == NULL, &quot;checking&quot;);</span>
<span class="line-removed"> 222 </span>
<span class="line-removed"> 223   f-&gt;do_oop(&amp;_reference_pending_list);</span>
 224   ThreadsSMRSupport::exiting_threads_oops_do(f);
 225 }
 226 
 227 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
 228   it-&gt;push(&amp;_klass);
 229 }
 230 
 231 void Universe::metaspace_pointers_do(MetaspaceClosure* it) {
 232   for (int i = 0; i &lt; T_LONG+1; i++) {
 233     it-&gt;push(&amp;_typeArrayKlassObjs[i]);
 234   }
 235   it-&gt;push(&amp;_objectArrayKlassObj);
 236 
 237   it-&gt;push(&amp;_the_empty_int_array);
 238   it-&gt;push(&amp;_the_empty_short_array);
 239   it-&gt;push(&amp;_the_empty_klass_array);
 240   it-&gt;push(&amp;_the_empty_instance_klass_array);
 241   it-&gt;push(&amp;_the_empty_method_array);
 242   it-&gt;push(&amp;_the_array_interfaces_array);
 243 
 244   _finalizer_register_cache-&gt;metaspace_pointers_do(it);
 245   _loader_addClass_cache-&gt;metaspace_pointers_do(it);
 246   _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
 247   _throw_no_such_method_error_cache-&gt;metaspace_pointers_do(it);
 248   _do_stack_walk_cache-&gt;metaspace_pointers_do(it);
 249 }
 250 
<span class="line-removed"> 251 #define ASSERT_MIRROR_NULL(m) \</span>
<span class="line-removed"> 252   assert(m == NULL, &quot;archived mirrors should be NULL&quot;);</span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254 #define SERIALIZE_MIRROR(m) \</span>
<span class="line-removed"> 255   f-&gt;do_oop(&amp;m); \</span>
<span class="line-removed"> 256   if (m != NULL) { java_lang_Class::update_archived_primitive_mirror_native_pointers(m); }</span>
<span class="line-removed"> 257 </span>
 258 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 259 void Universe::serialize(SerializeClosure* f) {
 260 






















 261   for (int i = 0; i &lt; T_LONG+1; i++) {
 262     f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
 263   }
 264 
 265   f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);
<span class="line-removed"> 266 </span>
<span class="line-removed"> 267 #if INCLUDE_CDS_JAVA_HEAP</span>
<span class="line-removed"> 268   DEBUG_ONLY(if (DumpSharedSpaces &amp;&amp; !HeapShared::is_heap_object_archiving_allowed()) {</span>
<span class="line-removed"> 269       PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NULL);</span>
<span class="line-removed"> 270     });</span>
<span class="line-removed"> 271   PRIMITIVE_MIRRORS_DO(SERIALIZE_MIRROR);</span>
<span class="line-removed"> 272 #endif</span>
<span class="line-removed"> 273 </span>
 274   f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
 275   f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
 276   f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
 277   f-&gt;do_ptr((void**)&amp;_the_empty_method_array);
 278   f-&gt;do_ptr((void**)&amp;_the_empty_klass_array);
 279   f-&gt;do_ptr((void**)&amp;_the_empty_instance_klass_array);
 280   _finalizer_register_cache-&gt;serialize(f);
 281   _loader_addClass_cache-&gt;serialize(f);
 282   _throw_illegal_access_error_cache-&gt;serialize(f);
 283   _throw_no_such_method_error_cache-&gt;serialize(f);
 284   _do_stack_walk_cache-&gt;serialize(f);
 285 }
 286 

 287 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
 288   if (size &lt; alignment || size % alignment != 0) {
 289     vm_exit_during_initialization(
 290       err_msg(&quot;Size of %s (&quot; UINTX_FORMAT &quot; bytes) must be aligned to &quot; UINTX_FORMAT &quot; bytes&quot;, name, size, alignment));
 291   }
 292 }
 293 
 294 void initialize_basic_type_klass(Klass* k, TRAPS) {
 295   Klass* ok = SystemDictionary::Object_klass();
 296 #if INCLUDE_CDS
 297   if (UseSharedSpaces) {
 298     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 299     assert(k-&gt;super() == ok, &quot;u3&quot;);
 300     if (k-&gt;is_instance_klass()) {
 301       InstanceKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), NULL, CHECK);
 302     } else {
 303       ArrayKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), CHECK);
 304     }
 305   } else
 306 #endif
 307   {
 308     k-&gt;initialize_supers(ok, NULL, CHECK);
 309   }
 310   k-&gt;append_to_sibling_list();
 311 }
 312 
 313 void Universe::genesis(TRAPS) {
 314   ResourceMark rm(THREAD);

 315 
 316   { AutoModifyRestore&lt;bool&gt; temporarily(_bootstrapping, true);
 317 
 318     { MutexLocker mc(THREAD, Compile_lock);
 319 
 320       java_lang_Class::allocate_fixup_lists();
 321 
 322       // determine base vtable size; without that we cannot create the array klasses
 323       compute_base_vtable_size();
 324 
 325       if (!UseSharedSpaces) {
 326         for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 327           _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);
 328         }
 329 
 330         ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
 331 
 332         _the_array_interfaces_array     = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 2, NULL, CHECK);
 333         _the_empty_int_array            = MetadataFactory::new_array&lt;int&gt;(null_cld, 0, CHECK);
 334         _the_empty_short_array          = MetadataFactory::new_array&lt;u2&gt;(null_cld, 0, CHECK);
</pre>
<hr />
<pre>
 362       // Set up shared interfaces array.  (Do this before supers are set up.)
 363       _the_array_interfaces_array-&gt;at_put(0, SystemDictionary::Cloneable_klass());
 364       _the_array_interfaces_array-&gt;at_put(1, SystemDictionary::Serializable_klass());
 365     }
 366 
 367     initialize_basic_type_klass(boolArrayKlassObj(), CHECK);
 368     initialize_basic_type_klass(charArrayKlassObj(), CHECK);
 369     initialize_basic_type_klass(floatArrayKlassObj(), CHECK);
 370     initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);
 371     initialize_basic_type_klass(byteArrayKlassObj(), CHECK);
 372     initialize_basic_type_klass(shortArrayKlassObj(), CHECK);
 373     initialize_basic_type_klass(intArrayKlassObj(), CHECK);
 374     initialize_basic_type_klass(longArrayKlassObj(), CHECK);
 375   } // end of core bootstrapping
 376 
 377   {
 378     Handle tns = java_lang_String::create_from_str(&quot;&lt;null_sentinel&gt;&quot;, CHECK);
 379     _the_null_sentinel = OopHandle(vm_global(), tns());
 380   }
 381 



 382   // Maybe this could be lifted up now that object array can be initialized
 383   // during the bootstrapping.
 384 
 385   // OLD
 386   // Initialize _objectArrayKlass after core bootstraping to make
 387   // sure the super class is set up properly for _objectArrayKlass.
 388   // ---
 389   // NEW
 390   // Since some of the old system object arrays have been converted to
 391   // ordinary object arrays, _objectArrayKlass will be loaded when
 392   // SystemDictionary::initialize(CHECK); is run. See the extra check
 393   // for Object_klass_loaded in objArrayKlassKlass::allocate_objArray_klass_impl.
 394   _objectArrayKlassObj = InstanceKlass::
 395     cast(SystemDictionary::Object_klass())-&gt;array_klass(1, CHECK);
 396   // OLD
 397   // Add the class to the class hierarchy manually to make sure that
 398   // its vtable is initialized after core bootstrapping is completed.
 399   // ---
 400   // New
 401   // Have already been initialized.
</pre>
<hr />
<pre>
 418     int i = 0;
 419     while (i &lt; size) {
 420         // Allocate dummy in old generation
 421       oop dummy = SystemDictionary::Object_klass()-&gt;allocate_instance(CHECK);
 422       dummy_array-&gt;obj_at_put(i++, dummy);
 423     }
 424     {
 425       // Only modify the global variable inside the mutex.
 426       // If we had a race to here, the other dummy_array instances
 427       // and their elements just get dropped on the floor, which is fine.
 428       MutexLocker ml(THREAD, FullGCALot_lock);
 429       if (_fullgc_alot_dummy_array.is_empty()) {
 430         _fullgc_alot_dummy_array = OopHandle(vm_global(), dummy_array());
 431       }
 432     }
 433     assert(i == ((objArrayOop)_fullgc_alot_dummy_array.resolve())-&gt;length(), &quot;just checking&quot;);
 434   }
 435   #endif
 436 }
 437 
<span class="line-removed"> 438 #define ASSERT_MIRROR_NOT_NULL(m) \</span>
<span class="line-removed"> 439   assert(m != NULL, &quot;archived mirrors should not be NULL&quot;);</span>
<span class="line-removed"> 440 </span>
 441 void Universe::initialize_basic_type_mirrors(TRAPS) {
 442 #if INCLUDE_CDS_JAVA_HEAP
 443     if (UseSharedSpaces &amp;&amp;
 444         HeapShared::open_archive_heap_region_mapped() &amp;&amp;
<span class="line-modified"> 445         _int_mirror != NULL) {</span>
 446       assert(HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
<span class="line-modified"> 447       PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NOT_NULL);</span>







 448     } else
<span class="line-modified"> 449       // _int_mirror could be NULL if archived heap is not mapped.</span>
 450 #endif
 451     {
<span class="line-modified"> 452       _int_mirror     =</span>
<span class="line-modified"> 453         java_lang_Class::create_basic_type_mirror(&quot;int&quot;,    T_INT, CHECK);</span>
<span class="line-modified"> 454       _float_mirror   =</span>
<span class="line-modified"> 455         java_lang_Class::create_basic_type_mirror(&quot;float&quot;,  T_FLOAT,   CHECK);</span>
<span class="line-modified"> 456       _double_mirror  =</span>
<span class="line-modified"> 457         java_lang_Class::create_basic_type_mirror(&quot;double&quot;, T_DOUBLE,  CHECK);</span>
<span class="line-modified"> 458       _byte_mirror    =</span>
<span class="line-removed"> 459         java_lang_Class::create_basic_type_mirror(&quot;byte&quot;,   T_BYTE, CHECK);</span>
<span class="line-removed"> 460       _bool_mirror    =</span>
<span class="line-removed"> 461         java_lang_Class::create_basic_type_mirror(&quot;boolean&quot;,T_BOOLEAN, CHECK);</span>
<span class="line-removed"> 462       _char_mirror    =</span>
<span class="line-removed"> 463         java_lang_Class::create_basic_type_mirror(&quot;char&quot;,   T_CHAR, CHECK);</span>
<span class="line-removed"> 464       _long_mirror    =</span>
<span class="line-removed"> 465         java_lang_Class::create_basic_type_mirror(&quot;long&quot;,   T_LONG, CHECK);</span>
<span class="line-removed"> 466       _short_mirror   =</span>
<span class="line-removed"> 467         java_lang_Class::create_basic_type_mirror(&quot;short&quot;,  T_SHORT,   CHECK);</span>
<span class="line-removed"> 468       _void_mirror    =</span>
<span class="line-removed"> 469         java_lang_Class::create_basic_type_mirror(&quot;void&quot;,   T_VOID, CHECK);</span>
 470     }
<span class="line-removed"> 471 </span>
<span class="line-removed"> 472     _mirrors[T_INT]     = _int_mirror;</span>
<span class="line-removed"> 473     _mirrors[T_FLOAT]   = _float_mirror;</span>
<span class="line-removed"> 474     _mirrors[T_DOUBLE]  = _double_mirror;</span>
<span class="line-removed"> 475     _mirrors[T_BYTE]    = _byte_mirror;</span>
<span class="line-removed"> 476     _mirrors[T_BOOLEAN] = _bool_mirror;</span>
<span class="line-removed"> 477     _mirrors[T_CHAR]    = _char_mirror;</span>
<span class="line-removed"> 478     _mirrors[T_LONG]    = _long_mirror;</span>
<span class="line-removed"> 479     _mirrors[T_SHORT]   = _short_mirror;</span>
<span class="line-removed"> 480     _mirrors[T_VOID]    = _void_mirror;</span>
<span class="line-removed"> 481   //_mirrors[T_OBJECT]  = _object_klass-&gt;java_mirror();</span>
<span class="line-removed"> 482   //_mirrors[T_ARRAY]   = _object_klass-&gt;java_mirror();</span>
 483 }
 484 
 485 void Universe::fixup_mirrors(TRAPS) {
 486   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
 487   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
 488   // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note
 489   // that the number of objects allocated at this point is very small.
 490   assert(SystemDictionary::Class_klass_loaded(), &quot;java.lang.Class should be loaded&quot;);
 491   HandleMark hm(THREAD);
 492 
 493   if (!UseSharedSpaces) {
 494     // Cache the start of the static fields
 495     InstanceMirrorKlass::init_offset_of_static_fields();
 496   }
 497 
 498   GrowableArray &lt;Klass*&gt;* list = java_lang_Class::fixup_mirror_list();
 499   int list_length = list-&gt;length();
 500   for (int i = 0; i &lt; list_length; i++) {
 501     Klass* k = list-&gt;at(i);
 502     assert(k-&gt;is_klass(), &quot;List should only hold classes&quot;);
 503     EXCEPTION_MARK;
 504     java_lang_Class::fixup_mirror(k, CATCH);
 505   }
 506   delete java_lang_Class::fixup_mirror_list();
 507   java_lang_Class::set_fixup_mirror_list(NULL);
 508 }
 509 
 510 #define assert_pll_locked(test) \
 511   assert(Heap_lock-&gt;test(), &quot;Reference pending list access requires lock&quot;)
 512 
 513 #define assert_pll_ownership() assert_pll_locked(owned_by_self)
 514 
 515 oop Universe::reference_pending_list() {
 516   if (Thread::current()-&gt;is_VM_thread()) {
 517     assert_pll_locked(is_locked);
 518   } else {
 519     assert_pll_ownership();
 520   }
<span class="line-modified"> 521   return _reference_pending_list;</span>
 522 }
 523 
 524 void Universe::clear_reference_pending_list() {
 525   assert_pll_ownership();
<span class="line-modified"> 526   _reference_pending_list = NULL;</span>
 527 }
 528 
 529 bool Universe::has_reference_pending_list() {
 530   assert_pll_ownership();
<span class="line-modified"> 531   return _reference_pending_list != NULL;</span>
 532 }
 533 
 534 oop Universe::swap_reference_pending_list(oop list) {
 535   assert_pll_locked(is_locked);
<span class="line-modified"> 536   return Atomic::xchg(&amp;_reference_pending_list, list);</span>
 537 }
 538 
 539 #undef assert_pll_locked
 540 #undef assert_pll_ownership
 541 
 542 void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {
 543   // init vtable of k and all subclasses
 544   ko-&gt;vtable().initialize_vtable(false, CHECK);
 545   if (ko-&gt;is_instance_klass()) {
 546     for (Klass* sk = ko-&gt;subklass();
 547          sk != NULL;
 548          sk = sk-&gt;next_sibling()) {
 549       reinitialize_vtable_of(sk, CHECK);
 550     }
 551   }
 552 }
 553 
 554 void Universe::reinitialize_vtables(TRAPS) {
 555   // The vtables are initialized by starting at java.lang.Object and
 556   // initializing through the subclass links, so that the super
</pre>
<hr />
<pre>
1128 bool Universe::should_verify_subset(uint subset) {
1129   if (verify_flags &amp; subset) {
1130     return true;
1131   }
1132   return false;
1133 }
1134 
1135 void Universe::verify(VerifyOption option, const char* prefix) {
1136   // The use of _verify_in_progress is a temporary work around for
1137   // 6320749.  Don&#39;t bother with a creating a class to set and clear
1138   // it since it is only used in this method and the control flow is
1139   // straight forward.
1140   _verify_in_progress = true;
1141 
1142   COMPILER2_PRESENT(
1143     assert(!DerivedPointerTable::is_active(),
1144          &quot;DPT should not be active during verification &quot;
1145          &quot;(of thread stacks below)&quot;);
1146   )
1147 
<span class="line-modified">1148   ResourceMark rm;</span>
<span class="line-modified">1149   HandleMark hm;  // Handles created during verification can be zapped</span>

1150   _verify_count++;
1151 
1152   FormatBuffer&lt;&gt; title(&quot;Verifying %s&quot;, prefix);
1153   GCTraceTime(Info, gc, verify) tm(title.buffer());
1154   if (should_verify_subset(Verify_Threads)) {
1155     log_debug(gc, verify)(&quot;Threads&quot;);
1156     Threads::verify();
1157   }
1158   if (should_verify_subset(Verify_Heap)) {
1159     log_debug(gc, verify)(&quot;Heap&quot;);
1160     heap()-&gt;verify(option);
1161   }
1162   if (should_verify_subset(Verify_SymbolTable)) {
1163     log_debug(gc, verify)(&quot;SymbolTable&quot;);
1164     SymbolTable::verify();
1165   }
1166   if (should_verify_subset(Verify_StringTable)) {
1167     log_debug(gc, verify)(&quot;StringTable&quot;);
1168     StringTable::verify();
1169   }
</pre>
</td>
<td>
<hr />
<pre>
  71 #include &quot;runtime/init.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/sharedRuntime.hpp&quot;
  75 #include &quot;runtime/synchronizer.hpp&quot;
  76 #include &quot;runtime/thread.inline.hpp&quot;
  77 #include &quot;runtime/timerTrace.hpp&quot;
  78 #include &quot;runtime/vmOperations.hpp&quot;
  79 #include &quot;services/memoryService.hpp&quot;
  80 #include &quot;utilities/align.hpp&quot;
  81 #include &quot;utilities/autoRestore.hpp&quot;
  82 #include &quot;utilities/copy.hpp&quot;
  83 #include &quot;utilities/debug.hpp&quot;
  84 #include &quot;utilities/events.hpp&quot;
  85 #include &quot;utilities/formatBuffer.hpp&quot;
  86 #include &quot;utilities/hashtable.inline.hpp&quot;
  87 #include &quot;utilities/macros.hpp&quot;
  88 #include &quot;utilities/ostream.hpp&quot;
  89 #include &quot;utilities/preserveException.hpp&quot;
  90 














  91 // Known objects

  92 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
  93 Klass* Universe::_objectArrayKlassObj                 = NULL;
<span class="line-modified">  94 OopHandle Universe::_mirrors[T_VOID+1];</span>
  95 
  96 OopHandle Universe::_main_thread_group;
  97 OopHandle Universe::_system_thread_group;
  98 OopHandle Universe::_the_empty_class_array;
  99 OopHandle Universe::_the_null_string;
 100 OopHandle Universe::_the_min_jint_string;
 101 
 102 OopHandle Universe::_the_null_sentinel;
 103 
 104 // _out_of_memory_errors is an objArray
 105 enum OutOfMemoryInstance { _oom_java_heap,
 106                            _oom_c_heap,
 107                            _oom_metaspace,
 108                            _oom_class_metaspace,
 109                            _oom_array_size,
 110                            _oom_gc_overhead_limit,
 111                            _oom_realloc_objects,
 112                            _oom_retry,
 113                            _oom_count };
 114 
 115 OopHandle Universe::_out_of_memory_errors;
 116 OopHandle Universe::_delayed_stack_overflow_error_message;
 117 OopHandle Universe::_preallocated_out_of_memory_error_array;
 118 volatile jint Universe::_preallocated_out_of_memory_error_avail_count = 0;
 119 
 120 OopHandle Universe::_null_ptr_exception_instance;
 121 OopHandle Universe::_arithmetic_exception_instance;
 122 OopHandle Universe::_virtual_machine_error_instance;
 123 
<span class="line-modified"> 124 OopHandle Universe::_reference_pending_list;</span>
 125 
 126 Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
 127 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 128 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 129 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
 130 LatestMethodCache* Universe::_throw_no_such_method_error_cache = NULL;
 131 LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;
 132 
 133 bool Universe::_verify_in_progress                    = false;
 134 long Universe::verify_flags                           = Universe::Verify_All;
 135 
 136 Array&lt;int&gt;* Universe::_the_empty_int_array            = NULL;
 137 Array&lt;u2&gt;* Universe::_the_empty_short_array           = NULL;
 138 Array&lt;Klass*&gt;* Universe::_the_empty_klass_array     = NULL;
 139 Array&lt;InstanceKlass*&gt;* Universe::_the_empty_instance_klass_array  = NULL;
 140 Array&lt;Method*&gt;* Universe::_the_empty_method_array   = NULL;
 141 
 142 // These variables are guarded by FullGCALot_lock.
 143 debug_only(OopHandle Universe::_fullgc_alot_dummy_array;)
 144 debug_only(int Universe::_fullgc_alot_dummy_next = 0;)
</pre>
<hr />
<pre>
 165 
 166 objArrayOop Universe::the_empty_class_array ()  {
 167   return (objArrayOop)_the_empty_class_array.resolve();
 168 }
 169 
 170 oop Universe::main_thread_group()                 { return _main_thread_group.resolve(); }
 171 void Universe::set_main_thread_group(oop group)   { _main_thread_group = OopHandle(vm_global(), group); }
 172 
 173 oop Universe::system_thread_group()               { return _system_thread_group.resolve(); }
 174 void Universe::set_system_thread_group(oop group) { _system_thread_group = OopHandle(vm_global(), group); }
 175 
 176 oop Universe::the_null_string()                   { return _the_null_string.resolve(); }
 177 oop Universe::the_min_jint_string()               { return _the_min_jint_string.resolve(); }
 178 
 179 oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception_instance.resolve(); }
 180 oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception_instance.resolve(); }
 181 oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error_instance.resolve(); }
 182 
 183 oop Universe::the_null_sentinel()                 { return _the_null_sentinel.resolve(); }
 184 
<span class="line-added"> 185 oop Universe::int_mirror()                        { return check_mirror(_mirrors[T_INT].resolve()); }</span>
<span class="line-added"> 186 oop Universe::float_mirror()                      { return check_mirror(_mirrors[T_FLOAT].resolve()); }</span>
<span class="line-added"> 187 oop Universe::double_mirror()                     { return check_mirror(_mirrors[T_DOUBLE].resolve()); }</span>
<span class="line-added"> 188 oop Universe::byte_mirror()                       { return check_mirror(_mirrors[T_BYTE].resolve()); }</span>
<span class="line-added"> 189 oop Universe::bool_mirror()                       { return check_mirror(_mirrors[T_BOOLEAN].resolve()); }</span>
<span class="line-added"> 190 oop Universe::char_mirror()                       { return check_mirror(_mirrors[T_CHAR].resolve()); }</span>
<span class="line-added"> 191 oop Universe::long_mirror()                       { return check_mirror(_mirrors[T_LONG].resolve()); }</span>
<span class="line-added"> 192 oop Universe::short_mirror()                      { return check_mirror(_mirrors[T_SHORT].resolve()); }</span>
<span class="line-added"> 193 oop Universe::void_mirror()                       { return check_mirror(_mirrors[T_VOID].resolve()); }</span>
<span class="line-added"> 194 </span>
<span class="line-added"> 195 oop Universe::java_mirror(BasicType t) {</span>
<span class="line-added"> 196   assert((uint)t &lt; T_VOID+1, &quot;range check&quot;);</span>
<span class="line-added"> 197   return check_mirror(_mirrors[t].resolve());</span>
<span class="line-added"> 198 }</span>
<span class="line-added"> 199 </span>
<span class="line-added"> 200 // Used by CDS dumping</span>
<span class="line-added"> 201 void Universe::replace_mirror(BasicType t, oop new_mirror) {</span>
<span class="line-added"> 202   Universe::_mirrors[t].replace(new_mirror);</span>
<span class="line-added"> 203 }</span>
<span class="line-added"> 204 </span>
<span class="line-added"> 205 // Not sure why CDS has to do this</span>
<span class="line-added"> 206 void Universe::clear_basic_type_mirrors() {</span>
<span class="line-added"> 207   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {</span>
<span class="line-added"> 208     if (!is_reference_type((BasicType)i)) {</span>
<span class="line-added"> 209       Universe::_mirrors[i].replace(NULL);</span>
<span class="line-added"> 210     }</span>
<span class="line-added"> 211   }</span>
<span class="line-added"> 212 }</span>
<span class="line-added"> 213 </span>
 214 void Universe::basic_type_classes_do(void f(Klass*)) {
 215   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 216     f(_typeArrayKlassObjs[i]);
 217   }
 218 }
 219 
 220 void Universe::basic_type_classes_do(KlassClosure *closure) {
 221   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 222     closure-&gt;do_klass(_typeArrayKlassObjs[i]);
 223   }
 224 }
 225 



 226 void Universe::oops_do(OopClosure* f) {

 227 






 228   ThreadsSMRSupport::exiting_threads_oops_do(f);
 229 }
 230 
 231 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
 232   it-&gt;push(&amp;_klass);
 233 }
 234 
 235 void Universe::metaspace_pointers_do(MetaspaceClosure* it) {
 236   for (int i = 0; i &lt; T_LONG+1; i++) {
 237     it-&gt;push(&amp;_typeArrayKlassObjs[i]);
 238   }
 239   it-&gt;push(&amp;_objectArrayKlassObj);
 240 
 241   it-&gt;push(&amp;_the_empty_int_array);
 242   it-&gt;push(&amp;_the_empty_short_array);
 243   it-&gt;push(&amp;_the_empty_klass_array);
 244   it-&gt;push(&amp;_the_empty_instance_klass_array);
 245   it-&gt;push(&amp;_the_empty_method_array);
 246   it-&gt;push(&amp;_the_array_interfaces_array);
 247 
 248   _finalizer_register_cache-&gt;metaspace_pointers_do(it);
 249   _loader_addClass_cache-&gt;metaspace_pointers_do(it);
 250   _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
 251   _throw_no_such_method_error_cache-&gt;metaspace_pointers_do(it);
 252   _do_stack_walk_cache-&gt;metaspace_pointers_do(it);
 253 }
 254 







 255 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 256 void Universe::serialize(SerializeClosure* f) {
 257 
<span class="line-added"> 258 #if INCLUDE_CDS_JAVA_HEAP</span>
<span class="line-added"> 259   {</span>
<span class="line-added"> 260     oop mirror_oop;</span>
<span class="line-added"> 261     for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {</span>
<span class="line-added"> 262       if (f-&gt;reading()) {</span>
<span class="line-added"> 263         f-&gt;do_oop(&amp;mirror_oop); // read from archive</span>
<span class="line-added"> 264         assert(oopDesc::is_oop_or_null(mirror_oop), &quot;is oop&quot;);</span>
<span class="line-added"> 265         // Only create an OopHandle for non-null mirrors</span>
<span class="line-added"> 266         if (mirror_oop != NULL) {</span>
<span class="line-added"> 267           _mirrors[i] = OopHandle(vm_global(), mirror_oop);</span>
<span class="line-added"> 268         }</span>
<span class="line-added"> 269       } else {</span>
<span class="line-added"> 270         mirror_oop = _mirrors[i].resolve();</span>
<span class="line-added"> 271         f-&gt;do_oop(&amp;mirror_oop); // write to archive</span>
<span class="line-added"> 272       }</span>
<span class="line-added"> 273       if (mirror_oop != NULL) { // may be null if archived heap is disabled</span>
<span class="line-added"> 274         java_lang_Class::update_archived_primitive_mirror_native_pointers(mirror_oop);</span>
<span class="line-added"> 275       }</span>
<span class="line-added"> 276     }</span>
<span class="line-added"> 277   }</span>
<span class="line-added"> 278 #endif</span>
<span class="line-added"> 279 </span>
 280   for (int i = 0; i &lt; T_LONG+1; i++) {
 281     f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
 282   }
 283 
 284   f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);








 285   f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
 286   f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
 287   f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
 288   f-&gt;do_ptr((void**)&amp;_the_empty_method_array);
 289   f-&gt;do_ptr((void**)&amp;_the_empty_klass_array);
 290   f-&gt;do_ptr((void**)&amp;_the_empty_instance_klass_array);
 291   _finalizer_register_cache-&gt;serialize(f);
 292   _loader_addClass_cache-&gt;serialize(f);
 293   _throw_illegal_access_error_cache-&gt;serialize(f);
 294   _throw_no_such_method_error_cache-&gt;serialize(f);
 295   _do_stack_walk_cache-&gt;serialize(f);
 296 }
 297 
<span class="line-added"> 298 </span>
 299 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
 300   if (size &lt; alignment || size % alignment != 0) {
 301     vm_exit_during_initialization(
 302       err_msg(&quot;Size of %s (&quot; UINTX_FORMAT &quot; bytes) must be aligned to &quot; UINTX_FORMAT &quot; bytes&quot;, name, size, alignment));
 303   }
 304 }
 305 
 306 void initialize_basic_type_klass(Klass* k, TRAPS) {
 307   Klass* ok = SystemDictionary::Object_klass();
 308 #if INCLUDE_CDS
 309   if (UseSharedSpaces) {
 310     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 311     assert(k-&gt;super() == ok, &quot;u3&quot;);
 312     if (k-&gt;is_instance_klass()) {
 313       InstanceKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), NULL, CHECK);
 314     } else {
 315       ArrayKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), CHECK);
 316     }
 317   } else
 318 #endif
 319   {
 320     k-&gt;initialize_supers(ok, NULL, CHECK);
 321   }
 322   k-&gt;append_to_sibling_list();
 323 }
 324 
 325 void Universe::genesis(TRAPS) {
 326   ResourceMark rm(THREAD);
<span class="line-added"> 327   HandleMark   hm(THREAD);</span>
 328 
 329   { AutoModifyRestore&lt;bool&gt; temporarily(_bootstrapping, true);
 330 
 331     { MutexLocker mc(THREAD, Compile_lock);
 332 
 333       java_lang_Class::allocate_fixup_lists();
 334 
 335       // determine base vtable size; without that we cannot create the array klasses
 336       compute_base_vtable_size();
 337 
 338       if (!UseSharedSpaces) {
 339         for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 340           _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);
 341         }
 342 
 343         ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
 344 
 345         _the_array_interfaces_array     = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 2, NULL, CHECK);
 346         _the_empty_int_array            = MetadataFactory::new_array&lt;int&gt;(null_cld, 0, CHECK);
 347         _the_empty_short_array          = MetadataFactory::new_array&lt;u2&gt;(null_cld, 0, CHECK);
</pre>
<hr />
<pre>
 375       // Set up shared interfaces array.  (Do this before supers are set up.)
 376       _the_array_interfaces_array-&gt;at_put(0, SystemDictionary::Cloneable_klass());
 377       _the_array_interfaces_array-&gt;at_put(1, SystemDictionary::Serializable_klass());
 378     }
 379 
 380     initialize_basic_type_klass(boolArrayKlassObj(), CHECK);
 381     initialize_basic_type_klass(charArrayKlassObj(), CHECK);
 382     initialize_basic_type_klass(floatArrayKlassObj(), CHECK);
 383     initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);
 384     initialize_basic_type_klass(byteArrayKlassObj(), CHECK);
 385     initialize_basic_type_klass(shortArrayKlassObj(), CHECK);
 386     initialize_basic_type_klass(intArrayKlassObj(), CHECK);
 387     initialize_basic_type_klass(longArrayKlassObj(), CHECK);
 388   } // end of core bootstrapping
 389 
 390   {
 391     Handle tns = java_lang_String::create_from_str(&quot;&lt;null_sentinel&gt;&quot;, CHECK);
 392     _the_null_sentinel = OopHandle(vm_global(), tns());
 393   }
 394 
<span class="line-added"> 395   // Create a handle for reference_pending_list</span>
<span class="line-added"> 396   _reference_pending_list = OopHandle(vm_global(), NULL);</span>
<span class="line-added"> 397 </span>
 398   // Maybe this could be lifted up now that object array can be initialized
 399   // during the bootstrapping.
 400 
 401   // OLD
 402   // Initialize _objectArrayKlass after core bootstraping to make
 403   // sure the super class is set up properly for _objectArrayKlass.
 404   // ---
 405   // NEW
 406   // Since some of the old system object arrays have been converted to
 407   // ordinary object arrays, _objectArrayKlass will be loaded when
 408   // SystemDictionary::initialize(CHECK); is run. See the extra check
 409   // for Object_klass_loaded in objArrayKlassKlass::allocate_objArray_klass_impl.
 410   _objectArrayKlassObj = InstanceKlass::
 411     cast(SystemDictionary::Object_klass())-&gt;array_klass(1, CHECK);
 412   // OLD
 413   // Add the class to the class hierarchy manually to make sure that
 414   // its vtable is initialized after core bootstrapping is completed.
 415   // ---
 416   // New
 417   // Have already been initialized.
</pre>
<hr />
<pre>
 434     int i = 0;
 435     while (i &lt; size) {
 436         // Allocate dummy in old generation
 437       oop dummy = SystemDictionary::Object_klass()-&gt;allocate_instance(CHECK);
 438       dummy_array-&gt;obj_at_put(i++, dummy);
 439     }
 440     {
 441       // Only modify the global variable inside the mutex.
 442       // If we had a race to here, the other dummy_array instances
 443       // and their elements just get dropped on the floor, which is fine.
 444       MutexLocker ml(THREAD, FullGCALot_lock);
 445       if (_fullgc_alot_dummy_array.is_empty()) {
 446         _fullgc_alot_dummy_array = OopHandle(vm_global(), dummy_array());
 447       }
 448     }
 449     assert(i == ((objArrayOop)_fullgc_alot_dummy_array.resolve())-&gt;length(), &quot;just checking&quot;);
 450   }
 451   #endif
 452 }
 453 



 454 void Universe::initialize_basic_type_mirrors(TRAPS) {
 455 #if INCLUDE_CDS_JAVA_HEAP
 456     if (UseSharedSpaces &amp;&amp;
 457         HeapShared::open_archive_heap_region_mapped() &amp;&amp;
<span class="line-modified"> 458         _mirrors[T_INT].resolve() != NULL) {</span>
 459       assert(HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
<span class="line-modified"> 460 </span>
<span class="line-added"> 461       // check that all mirrors are mapped also</span>
<span class="line-added"> 462       for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {</span>
<span class="line-added"> 463         if (!is_reference_type((BasicType)i)) {</span>
<span class="line-added"> 464           oop m = _mirrors[i].resolve();</span>
<span class="line-added"> 465           assert(m != NULL, &quot;archived mirrors should not be NULL&quot;);</span>
<span class="line-added"> 466         }</span>
<span class="line-added"> 467       }</span>
 468     } else
<span class="line-modified"> 469       // _mirror[T_INT} could be NULL if archived heap is not mapped.</span>
 470 #endif
 471     {
<span class="line-modified"> 472       for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {</span>
<span class="line-modified"> 473         BasicType bt = (BasicType)i;</span>
<span class="line-modified"> 474         if (!is_reference_type(bt)) {</span>
<span class="line-modified"> 475           oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);</span>
<span class="line-modified"> 476           _mirrors[i] = OopHandle(vm_global(), m);</span>
<span class="line-modified"> 477         }</span>
<span class="line-modified"> 478       }</span>











 479     }












 480 }
 481 
 482 void Universe::fixup_mirrors(TRAPS) {
 483   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
 484   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
 485   // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note
 486   // that the number of objects allocated at this point is very small.
 487   assert(SystemDictionary::Class_klass_loaded(), &quot;java.lang.Class should be loaded&quot;);
 488   HandleMark hm(THREAD);
 489 
 490   if (!UseSharedSpaces) {
 491     // Cache the start of the static fields
 492     InstanceMirrorKlass::init_offset_of_static_fields();
 493   }
 494 
 495   GrowableArray &lt;Klass*&gt;* list = java_lang_Class::fixup_mirror_list();
 496   int list_length = list-&gt;length();
 497   for (int i = 0; i &lt; list_length; i++) {
 498     Klass* k = list-&gt;at(i);
 499     assert(k-&gt;is_klass(), &quot;List should only hold classes&quot;);
 500     EXCEPTION_MARK;
 501     java_lang_Class::fixup_mirror(k, CATCH);
 502   }
 503   delete java_lang_Class::fixup_mirror_list();
 504   java_lang_Class::set_fixup_mirror_list(NULL);
 505 }
 506 
 507 #define assert_pll_locked(test) \
 508   assert(Heap_lock-&gt;test(), &quot;Reference pending list access requires lock&quot;)
 509 
 510 #define assert_pll_ownership() assert_pll_locked(owned_by_self)
 511 
 512 oop Universe::reference_pending_list() {
 513   if (Thread::current()-&gt;is_VM_thread()) {
 514     assert_pll_locked(is_locked);
 515   } else {
 516     assert_pll_ownership();
 517   }
<span class="line-modified"> 518   return _reference_pending_list.resolve();</span>
 519 }
 520 
 521 void Universe::clear_reference_pending_list() {
 522   assert_pll_ownership();
<span class="line-modified"> 523   _reference_pending_list.replace(NULL);</span>
 524 }
 525 
 526 bool Universe::has_reference_pending_list() {
 527   assert_pll_ownership();
<span class="line-modified"> 528   return _reference_pending_list.peek() != NULL;</span>
 529 }
 530 
 531 oop Universe::swap_reference_pending_list(oop list) {
 532   assert_pll_locked(is_locked);
<span class="line-modified"> 533   return _reference_pending_list.xchg(list);</span>
 534 }
 535 
 536 #undef assert_pll_locked
 537 #undef assert_pll_ownership
 538 
 539 void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {
 540   // init vtable of k and all subclasses
 541   ko-&gt;vtable().initialize_vtable(false, CHECK);
 542   if (ko-&gt;is_instance_klass()) {
 543     for (Klass* sk = ko-&gt;subklass();
 544          sk != NULL;
 545          sk = sk-&gt;next_sibling()) {
 546       reinitialize_vtable_of(sk, CHECK);
 547     }
 548   }
 549 }
 550 
 551 void Universe::reinitialize_vtables(TRAPS) {
 552   // The vtables are initialized by starting at java.lang.Object and
 553   // initializing through the subclass links, so that the super
</pre>
<hr />
<pre>
1125 bool Universe::should_verify_subset(uint subset) {
1126   if (verify_flags &amp; subset) {
1127     return true;
1128   }
1129   return false;
1130 }
1131 
1132 void Universe::verify(VerifyOption option, const char* prefix) {
1133   // The use of _verify_in_progress is a temporary work around for
1134   // 6320749.  Don&#39;t bother with a creating a class to set and clear
1135   // it since it is only used in this method and the control flow is
1136   // straight forward.
1137   _verify_in_progress = true;
1138 
1139   COMPILER2_PRESENT(
1140     assert(!DerivedPointerTable::is_active(),
1141          &quot;DPT should not be active during verification &quot;
1142          &quot;(of thread stacks below)&quot;);
1143   )
1144 
<span class="line-modified">1145   Thread* thread = Thread::current();</span>
<span class="line-modified">1146   ResourceMark rm(thread);</span>
<span class="line-added">1147   HandleMark hm(thread);  // Handles created during verification can be zapped</span>
1148   _verify_count++;
1149 
1150   FormatBuffer&lt;&gt; title(&quot;Verifying %s&quot;, prefix);
1151   GCTraceTime(Info, gc, verify) tm(title.buffer());
1152   if (should_verify_subset(Verify_Threads)) {
1153     log_debug(gc, verify)(&quot;Threads&quot;);
1154     Threads::verify();
1155   }
1156   if (should_verify_subset(Verify_Heap)) {
1157     log_debug(gc, verify)(&quot;Heap&quot;);
1158     heap()-&gt;verify(option);
1159   }
1160   if (should_verify_subset(Verify_SymbolTable)) {
1161     log_debug(gc, verify)(&quot;SymbolTable&quot;);
1162     SymbolTable::verify();
1163   }
1164   if (should_verify_subset(Verify_StringTable)) {
1165     log_debug(gc, verify)(&quot;StringTable&quot;);
1166     StringTable::verify();
1167   }
</pre>
</td>
</tr>
</table>
<center><a href="metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>