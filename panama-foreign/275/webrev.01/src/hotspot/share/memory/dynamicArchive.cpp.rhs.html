<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/dynamicArchive.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  31 #include &quot;logging/log.hpp&quot;
  32 #include &quot;memory/archiveUtils.inline.hpp&quot;
  33 #include &quot;memory/dynamicArchive.hpp&quot;
  34 #include &quot;memory/metadataFactory.hpp&quot;
  35 #include &quot;memory/metaspace.hpp&quot;
  36 #include &quot;memory/metaspaceClosure.hpp&quot;
  37 #include &quot;memory/metaspaceShared.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;oops/compressedOops.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  42 #include &quot;runtime/handles.inline.hpp&quot;
  43 #include &quot;runtime/os.inline.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;runtime/vmThread.hpp&quot;
  46 #include &quot;runtime/vmOperations.hpp&quot;
  47 #include &quot;utilities/bitMap.inline.hpp&quot;
  48 
  49 #ifndef O_BINARY       // if defined (Win32) use binary files.
  50 #define O_BINARY 0     // otherwise do nothing.
  51 #endif
  52 
  53 class DynamicArchiveBuilder : ResourceObj {
  54   static unsigned my_hash(const address&amp; a) {
  55     return primitive_hash&lt;address&gt;(a);
  56   }
  57   static bool my_equals(const address&amp; a0, const address&amp; a1) {
  58     return primitive_equals&lt;address&gt;(a0, a1);
  59   }
  60   typedef ResourceHashtable&lt;
  61       address, address,
  62       DynamicArchiveBuilder::my_hash,   // solaris compiler doesn&#39;t like: primitive_hash&lt;address&gt;
  63       DynamicArchiveBuilder::my_equals, // solaris compiler doesn&#39;t like: primitive_equals&lt;address&gt;
  64       16384, ResourceObj::C_HEAP&gt; RelocationTable;
  65   RelocationTable _new_loc_table;
  66 
  67   static intx _buffer_to_target_delta;
  68 
  69   DumpRegion* _current_dump_space;
  70 
  71   static size_t reserve_alignment() {
  72     return os::vm_allocation_granularity();
  73   }
  74 
  75   static const int _total_dump_regions = 3;
  76   int _num_dump_regions_used;
  77 
  78 public:
  79   void mark_pointer(address* ptr_loc) {
  80     ArchivePtrMarker::mark_pointer(ptr_loc);
  81   }
  82 
  83   DumpRegion* current_dump_space() const {
  84     return _current_dump_space;
  85   }
  86 
  87   bool is_in_buffer_space(address p) const {
  88     return (_alloc_bottom &lt;= p &amp;&amp; p &lt; (address)current_dump_space()-&gt;top());
  89   }
  90 
  91   template &lt;typename T&gt; bool is_in_target_space(T target_obj) const {
  92     address buff_obj = address(target_obj) - _buffer_to_target_delta;
  93     return is_in_buffer_space(buff_obj);
  94   }
  95 
  96   template &lt;typename T&gt; bool is_in_buffer_space(T obj) const {
  97     return is_in_buffer_space(address(obj));
  98   }
  99 
 100   template &lt;typename T&gt; T to_target_no_check(T obj) const {
 101     return (T)(address(obj) + _buffer_to_target_delta);
 102   }
 103 
 104   template &lt;typename T&gt; T to_target(T obj) const {
 105     assert(is_in_buffer_space(obj), &quot;must be&quot;);
 106     return (T)(address(obj) + _buffer_to_target_delta);
 107   }
 108 
 109   template &lt;typename T&gt; T get_new_loc(T obj) {
 110     address* pp = _new_loc_table.get((address)obj);
 111     if (pp == NULL) {
 112       // Excluded klasses are not copied
 113       return NULL;
 114     } else {
 115       return (T)*pp;
 116     }
 117   }
 118 
 119   address get_new_loc(MetaspaceClosure::Ref* ref) {
 120     return get_new_loc(ref-&gt;obj());
 121   }
 122 
 123   template &lt;typename T&gt; bool has_new_loc(T obj) {
 124     address* pp = _new_loc_table.get((address)obj);
 125     return pp != NULL;
 126   }
 127 
 128   static int dynamic_dump_method_comparator(Method* a, Method* b) {
 129     Symbol* a_name = a-&gt;name();
 130     Symbol* b_name = b-&gt;name();
 131 
 132     if (a_name == b_name) {
 133       return 0;
 134     }
 135 
 136     if (!MetaspaceShared::is_in_shared_metaspace(a_name)) {
 137       // a_name points to a Symbol in the top archive.
 138       // When this method is called, a_name is still pointing to the output space.
 139       // Translate it to point to the output space, so that it can be compared with
 140       // Symbols in the base archive.
 141       a_name = (Symbol*)(address(a_name) + _buffer_to_target_delta);
 142     }
 143     if (!MetaspaceShared::is_in_shared_metaspace(b_name)) {
 144       b_name = (Symbol*)(address(b_name) + _buffer_to_target_delta);
 145     }
 146 
 147     return a_name-&gt;fast_compare(b_name);
 148   }
 149 
 150 protected:
 151   enum FollowMode {
 152     make_a_copy, point_to_it, set_to_null
 153   };
 154 
 155 public:
 156   void copy(MetaspaceClosure::Ref* ref, bool read_only) {
 157     int bytes = ref-&gt;size() * BytesPerWord;
 158     address old_obj = ref-&gt;obj();
 159     address new_obj = copy_impl(ref, read_only, bytes);
 160 
 161     assert(new_obj != NULL, &quot;must be&quot;);
 162     assert(new_obj != old_obj, &quot;must be&quot;);
 163     bool isnew = _new_loc_table.put(old_obj, new_obj);
 164     assert(isnew, &quot;must be&quot;);
 165   }
 166 
 167   // Make a shallow copy of each eligible MetaspaceObj into the buffer.
 168   class ShallowCopier: public UniqueMetaspaceClosure {
 169     DynamicArchiveBuilder* _builder;
 170     bool _read_only;
 171   public:
 172     ShallowCopier(DynamicArchiveBuilder* shuffler, bool read_only)
 173       : _builder(shuffler), _read_only(read_only) {}
 174 
 175     virtual bool do_unique_ref(Ref* orig_obj, bool read_only) {
 176       // This method gets called on each *original* object
 177       // reachable from _builder-&gt;iterate_roots(). Each orig_obj is
 178       // called exactly once.
 179       FollowMode mode = _builder-&gt;follow_ref(orig_obj);
 180 
 181       if (mode == point_to_it) {
 182         if (read_only == _read_only) {
 183           log_debug(cds, dynamic)(&quot;ptr : &quot; PTR_FORMAT &quot; %s&quot;, p2i(orig_obj-&gt;obj()),
 184                                   MetaspaceObj::type_name(orig_obj-&gt;msotype()));
 185           address p = orig_obj-&gt;obj();
 186           bool isnew = _builder-&gt;_new_loc_table.put(p, p);
 187           assert(isnew, &quot;must be&quot;);
 188         }
 189         return false;
 190       }
 191 
 192       if (mode == set_to_null) {
 193         log_debug(cds, dynamic)(&quot;nul : &quot; PTR_FORMAT &quot; %s&quot;, p2i(orig_obj-&gt;obj()),
 194                                 MetaspaceObj::type_name(orig_obj-&gt;msotype()));
 195         return false;
 196       }
 197 
 198       if (read_only == _read_only) {
 199         // Make a shallow copy of orig_obj in a buffer (maintained
 200         // by copy_impl in a subclass of DynamicArchiveBuilder).
 201         _builder-&gt;copy(orig_obj, read_only);
 202       }
 203       return true;
 204     }
 205   };
 206 
 207   // Relocate all embedded pointer fields within a MetaspaceObj&#39;s shallow copy
 208   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
 209     DynamicArchiveBuilder* _builder;
 210   public:
 211     ShallowCopyEmbeddedRefRelocator(DynamicArchiveBuilder* shuffler)
 212       : _builder(shuffler) {}
 213 
 214     // This method gets called on each *original* object reachable
 215     // from _builder-&gt;iterate_roots(). Each orig_obj is
 216     // called exactly once.
 217     virtual bool do_unique_ref(Ref* orig_ref, bool read_only) {
 218       FollowMode mode = _builder-&gt;follow_ref(orig_ref);
 219 
 220       if (mode == point_to_it) {
 221         // We did not make a copy of this object
 222         // and we have nothing to update
 223         assert(_builder-&gt;get_new_loc(orig_ref) == NULL ||
 224                _builder-&gt;get_new_loc(orig_ref) == orig_ref-&gt;obj(), &quot;must be&quot;);
 225         return false;
 226       }
 227 
 228       if (mode == set_to_null) {
 229         // We did not make a copy of this object
 230         // and we have nothing to update
 231         assert(!_builder-&gt;has_new_loc(orig_ref-&gt;obj()), &quot;must not be copied or pointed to&quot;);
 232         return false;
 233       }
 234 
 235       // - orig_obj points to the original object.
 236       // - new_obj points to the shallow copy (created by ShallowCopier)
 237       //   of orig_obj. new_obj is NULL if the orig_obj is excluded
 238       address orig_obj = orig_ref-&gt;obj();
 239       address new_obj  = _builder-&gt;get_new_loc(orig_ref);
 240 
 241       assert(new_obj != orig_obj, &quot;must be&quot;);
 242 #ifdef ASSERT
 243       if (new_obj == NULL) {
 244         if (orig_ref-&gt;msotype() == MetaspaceObj::ClassType) {
 245           Klass* k = (Klass*)orig_obj;
 246           assert(k-&gt;is_instance_klass() &amp;&amp;
 247                  SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k)),
 248                  &quot;orig_obj must be excluded Class&quot;);
 249         }
 250       }
 251 #endif
 252 
 253       log_debug(cds, dynamic)(&quot;Relocating &quot; PTR_FORMAT &quot; %s&quot;, p2i(new_obj),
 254                               MetaspaceObj::type_name(orig_ref-&gt;msotype()));
 255       if (new_obj != NULL) {
 256         EmbeddedRefUpdater updater(_builder, orig_obj, new_obj);
 257         orig_ref-&gt;metaspace_pointers_do(&amp;updater);
 258       }
 259 
 260       return true; // keep recursing until every object is visited exactly once.
 261     }
 262 
 263     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
 264       assert(type == _method_entry_ref, &quot;only special type allowed for now&quot;);
 265       address obj = ref-&gt;obj();
 266       address new_obj = _builder-&gt;get_new_loc(ref);
 267       size_t offset = pointer_delta(p, obj,  sizeof(u1));
 268       intptr_t* new_p = (intptr_t*)(new_obj + offset);
 269       assert(*p == *new_p, &quot;must be a copy&quot;);
 270       ArchivePtrMarker::mark_pointer((address*)new_p);
 271     }
 272   };
 273 
 274   class EmbeddedRefUpdater: public MetaspaceClosure {
 275     DynamicArchiveBuilder* _builder;
 276     address _orig_obj;
 277     address _new_obj;
 278   public:
 279     EmbeddedRefUpdater(DynamicArchiveBuilder* shuffler, address orig_obj, address new_obj) :
 280       _builder(shuffler), _orig_obj(orig_obj), _new_obj(new_obj) {}
 281 
 282     // This method gets called once for each pointer field F of orig_obj.
 283     // We update new_obj-&gt;F to point to the new location of orig_obj-&gt;F.
 284     //
 285     // Example: Klass*  0x100 is copied to 0x400
 286     //          Symbol* 0x200 is copied to 0x500
 287     //
 288     // Let orig_obj == 0x100; and
 289     //     new_obj  == 0x400; and
 290     //     ((Klass*)orig_obj)-&gt;_name == 0x200;
 291     // Then this function effectively assigns
 292     //     ((Klass*)new_obj)-&gt;_name = 0x500;
 293     virtual bool do_ref(Ref* ref, bool read_only) {
 294       address new_pointee = NULL;
 295 
 296       if (ref-&gt;not_null()) {
 297         address old_pointee = ref-&gt;obj();
 298 
 299         FollowMode mode = _builder-&gt;follow_ref(ref);
 300         if (mode == point_to_it) {
 301           new_pointee = old_pointee;
 302         } else if (mode == set_to_null) {
 303           new_pointee = NULL;
 304         } else {
 305           new_pointee = _builder-&gt;get_new_loc(old_pointee);
 306         }
 307       }
 308 
 309       const char* kind = MetaspaceObj::type_name(ref-&gt;msotype());
 310       // offset of this field inside the original object
 311       intx offset = (address)ref-&gt;addr() - _orig_obj;
 312       _builder-&gt;update_pointer((address*)(_new_obj + offset), new_pointee, kind, offset);
 313 
 314       // We can&#39;t mark the pointer here, because DynamicArchiveBuilder::sort_methods
 315       // may re-layout the [iv]tables, which would change the offset(s) in an InstanceKlass
 316       // that would contain pointers. Therefore, we must mark the pointers after
 317       // sort_methods(), using PointerMarker.
 318       return false; // Do not recurse.
 319     }
 320   };
 321 
 322   class ExternalRefUpdater: public MetaspaceClosure {
 323     DynamicArchiveBuilder* _builder;
 324 
 325   public:
 326     ExternalRefUpdater(DynamicArchiveBuilder* shuffler) : _builder(shuffler) {}
 327 
 328     virtual bool do_ref(Ref* ref, bool read_only) {
 329       // ref is a pointer that lives OUTSIDE of the buffer, but points to an object inside the buffer
 330       if (ref-&gt;not_null()) {
 331         address new_loc = _builder-&gt;get_new_loc(ref);
 332         const char* kind = MetaspaceObj::type_name(ref-&gt;msotype());
 333         _builder-&gt;update_pointer(ref-&gt;addr(), new_loc, kind, 0);
 334         _builder-&gt;mark_pointer(ref-&gt;addr());
 335       }
 336       return false; // Do not recurse.
 337     }
 338   };
 339 
 340   class PointerMarker: public UniqueMetaspaceClosure {
 341     DynamicArchiveBuilder* _builder;
 342 
 343   public:
 344     PointerMarker(DynamicArchiveBuilder* shuffler) : _builder(shuffler) {}
 345 
 346     virtual bool do_unique_ref(Ref* ref, bool read_only) {
 347       if (_builder-&gt;is_in_buffer_space(ref-&gt;obj())) {
 348         EmbeddedRefMarker ref_marker(_builder);
 349         ref-&gt;metaspace_pointers_do(&amp;ref_marker);
 350         return true; // keep recursing until every buffered object is visited exactly once.
 351       } else {
 352         return false;
 353       }
 354     }
 355   };
 356 
 357   class EmbeddedRefMarker: public MetaspaceClosure {
 358     DynamicArchiveBuilder* _builder;
 359 
 360   public:
 361     EmbeddedRefMarker(DynamicArchiveBuilder* shuffler) : _builder(shuffler) {}
 362     virtual bool do_ref(Ref* ref, bool read_only) {
 363       if (ref-&gt;not_null()) {
 364         _builder-&gt;mark_pointer(ref-&gt;addr());
 365       }
 366       return false; // Do not recurse.
 367     }
 368   };
 369 
 370   void update_pointer(address* addr, address value, const char* kind, uintx offset, bool is_mso_pointer=true) {
 371     // Propagate the the mask bits to the new value -- see comments above MetaspaceClosure::obj()
 372     if (is_mso_pointer) {
 373       const uintx FLAG_MASK = 0x03;
 374       uintx mask_bits = uintx(*addr) &amp; FLAG_MASK;
 375       value = (address)(uintx(value) | mask_bits);
 376     }
 377 
 378     if (*addr != value) {
 379       log_debug(cds, dynamic)(&quot;Update (%18s*) %3d [&quot; PTR_FORMAT &quot;] &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT,
 380                               kind, int(offset), p2i(addr), p2i(*addr), p2i(value));
 381       *addr = value;
 382     }
 383   }
 384 
 385 private:
 386   GrowableArray&lt;Symbol*&gt;* _symbols; // symbols to dump
 387   GrowableArray&lt;InstanceKlass*&gt;* _klasses; // klasses to dump
 388 
 389   void append(InstanceKlass* k) { _klasses-&gt;append(k); }
 390   void append(Symbol* s)        { _symbols-&gt;append(s); }
 391 
 392   class GatherKlassesAndSymbols : public UniqueMetaspaceClosure {
 393     DynamicArchiveBuilder* _builder;
 394     bool _read_only;
 395 
 396   public:
 397     GatherKlassesAndSymbols(DynamicArchiveBuilder* builder)
 398       : _builder(builder) {}
 399 
 400     virtual bool do_unique_ref(Ref* ref, bool read_only) {
 401       if (_builder-&gt;follow_ref(ref) != make_a_copy) {
 402         return false;
 403       }
 404       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
 405         Klass* klass = (Klass*)ref-&gt;obj();
 406         assert(klass-&gt;is_klass(), &quot;must be&quot;);
 407         if (klass-&gt;is_instance_klass()) {
 408           InstanceKlass* ik = InstanceKlass::cast(klass);
 409           assert(!SystemDictionaryShared::is_excluded_class(ik), &quot;must be&quot;);
 410           _builder-&gt;append(ik);
 411           _builder-&gt;_estimated_metsapceobj_bytes += BytesPerWord; // See RunTimeSharedClassInfo::get_for()
 412         }
 413       } else if (ref-&gt;msotype() == MetaspaceObj::SymbolType) {
 414         _builder-&gt;append((Symbol*)ref-&gt;obj());
 415       }
 416 
 417       int bytes = ref-&gt;size() * BytesPerWord;
 418       _builder-&gt;_estimated_metsapceobj_bytes += bytes;
 419 
 420       return true;
 421     }
 422   };
 423 
 424   FollowMode follow_ref(MetaspaceClosure::Ref *ref) {
 425     address obj = ref-&gt;obj();
 426     if (MetaspaceShared::is_in_shared_metaspace(obj)) {
 427       // Don&#39;t dump existing shared metadata again.
 428       return point_to_it;
 429     } else if (ref-&gt;msotype() == MetaspaceObj::MethodDataType) {
 430       return set_to_null;
 431     } else {
 432       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
 433         Klass* klass = (Klass*)ref-&gt;obj();
 434         assert(klass-&gt;is_klass(), &quot;must be&quot;);
 435         if (klass-&gt;is_instance_klass()) {
 436           InstanceKlass* ik = InstanceKlass::cast(klass);
 437           if (SystemDictionaryShared::is_excluded_class(ik)) {
 438             ResourceMark rm;
 439             log_debug(cds, dynamic)(&quot;Skipping class (excluded): %s&quot;, klass-&gt;external_name());
 440             return set_to_null;
 441           }
 442         } else if (klass-&gt;is_array_klass()) {
 443           // Don&#39;t support archiving of array klasses for now.
 444           ResourceMark rm;
 445           log_debug(cds, dynamic)(&quot;Skipping class (array): %s&quot;, klass-&gt;external_name());
 446           return set_to_null;
 447         }
 448       }
 449 
 450       return make_a_copy;
 451     }
 452   }
 453 
 454   address copy_impl(MetaspaceClosure::Ref* ref, bool read_only, int bytes) {
 455     if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
 456       // Save a pointer immediate in front of an InstanceKlass, so
 457       // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
 458       // without building another hashtable. See RunTimeSharedClassInfo::get_for()
 459       // in systemDictionaryShared.cpp.
 460       address obj = ref-&gt;obj();
 461       Klass* klass = (Klass*)obj;
 462       if (klass-&gt;is_instance_klass()) {
 463         SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
 464         current_dump_space()-&gt;allocate(sizeof(address), BytesPerWord);
 465       }
 466     }
 467     address p = (address)current_dump_space()-&gt;allocate(bytes);
 468     address obj = ref-&gt;obj();
 469     log_debug(cds, dynamic)(&quot;COPY: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %5d %s&quot;,
 470                             p2i(obj), p2i(p), bytes,
 471                             MetaspaceObj::type_name(ref-&gt;msotype()));
 472     memcpy(p, obj, bytes);
 473     intptr_t* archived_vtable = MetaspaceShared::get_archived_cpp_vtable(ref-&gt;msotype(), p);
 474     if (archived_vtable != NULL) {
 475       update_pointer((address*)p, (address)archived_vtable, &quot;vtb&quot;, 0, /*is_mso_pointer*/false);
 476       mark_pointer((address*)p);
 477     }
 478 
 479     return (address)p;
 480   }
 481 
 482   DynamicArchiveHeader *_header;
 483   address _alloc_bottom;
 484   address _last_verified_top;
 485   size_t _other_region_used_bytes;
 486 
 487   // Conservative estimate for number of bytes needed for:
 488   size_t _estimated_metsapceobj_bytes;   // all archived MetsapceObj&#39;s.
 489   size_t _estimated_hashtable_bytes;     // symbol table and dictionaries
 490   size_t _estimated_trampoline_bytes;    // method entry trampolines
 491 
 492   size_t estimate_archive_size();
 493   size_t estimate_trampoline_size();
 494   size_t estimate_class_file_size();
 495   address reserve_space_and_init_buffer_to_target_delta();
 496   void init_header(address addr);
 497   void release_header();
 498   void make_trampolines();
 499   void make_klasses_shareable();
 500   void sort_methods(InstanceKlass* ik) const;
 501   void set_symbols_permanent();
 502   void relocate_buffer_to_target();
 503   void write_archive(char* serialized_data);
 504 
 505   void init_first_dump_space(address reserved_bottom) {
 506     DumpRegion* mc_space = MetaspaceShared::misc_code_dump_space();
 507     DumpRegion* rw_space = MetaspaceShared::read_write_dump_space();
 508 
 509     // Use the same MC-&gt;RW-&gt;RO ordering as in the base archive.
 510     MetaspaceShared::init_shared_dump_space(mc_space);
 511     _current_dump_space = mc_space;
 512     _last_verified_top = reserved_bottom;
 513     _num_dump_regions_used = 1;
 514   }
 515 
 516   void reserve_buffers_for_trampolines() {
 517     size_t n = _estimated_trampoline_bytes;
 518     assert(n &gt;= SharedRuntime::trampoline_size(), &quot;dont want to be empty&quot;);
 519     MetaspaceShared::misc_code_space_alloc(n);
 520   }
 521 
 522 public:
 523   DynamicArchiveBuilder() {
 524     _klasses = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;InstanceKlass*&gt;(100, mtClass);
 525     _symbols = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Symbol*&gt;(1000, mtClass);
 526 
 527     _estimated_metsapceobj_bytes = 0;
 528     _estimated_hashtable_bytes = 0;
 529     _estimated_trampoline_bytes = 0;
 530 
 531     _num_dump_regions_used = 0;
 532   }
 533 
 534   void start_dump_space(DumpRegion* next) {
 535     address bottom = _last_verified_top;
 536     address top = (address)(current_dump_space()-&gt;top());
 537     _other_region_used_bytes += size_t(top - bottom);
 538 
 539     MetaspaceShared::pack_dump_space(current_dump_space(), next, MetaspaceShared::shared_rs());
 540     _current_dump_space = next;
 541     _num_dump_regions_used ++;
 542 
 543     _last_verified_top = (address)(current_dump_space()-&gt;top());
 544   }
 545 
 546   void verify_estimate_size(size_t estimate, const char* which) {
 547     address bottom = _last_verified_top;
 548     address top = (address)(current_dump_space()-&gt;top());
 549     size_t used = size_t(top - bottom) + _other_region_used_bytes;
 550     int diff = int(estimate) - int(used);
 551 
 552     log_info(cds)(&quot;%s estimate = &quot; SIZE_FORMAT &quot; used = &quot; SIZE_FORMAT &quot;; diff = %d bytes&quot;, which, estimate, used, diff);
 553     assert(diff &gt;= 0, &quot;Estimate is too small&quot;);
 554 
 555     _last_verified_top = top;
 556     _other_region_used_bytes = 0;
 557   }
 558 
 559   // Do this before and after the archive dump to see if any corruption
 560   // is caused by dynamic dumping.
 561   void verify_universe(const char* info) {
 562     if (VerifyBeforeExit) {
 563       log_info(cds)(&quot;Verify %s&quot;, info);
<a name="1" id="anc1"></a>
 564       // Among other things, this ensures that Eden top is correct.
 565       Universe::heap()-&gt;prepare_for_verify();
 566       Universe::verify(info);
 567     }
 568   }
 569 
 570   void doit() {
 571     verify_universe(&quot;Before CDS dynamic dump&quot;);
 572     DEBUG_ONLY(SystemDictionaryShared::NoClassLoadingMark nclm);
 573     SystemDictionaryShared::check_excluded_classes();
 574 
 575     {
 576       ResourceMark rm;
 577       GatherKlassesAndSymbols gatherer(this);
 578 
 579       SystemDictionaryShared::dumptime_classes_do(&amp;gatherer);
 580       SymbolTable::metaspace_pointers_do(&amp;gatherer);
 581       FileMapInfo::metaspace_pointers_do(&amp;gatherer);
 582 
 583       gatherer.finish();
 584     }
 585 
 586     // rw space starts ...
 587     address reserved_bottom = reserve_space_and_init_buffer_to_target_delta();
 588     init_header(reserved_bottom);
 589 
 590     CHeapBitMap ptrmap;
 591     ArchivePtrMarker::initialize(&amp;ptrmap, (address*)reserved_bottom, (address*)current_dump_space()-&gt;top());
 592 
 593     reserve_buffers_for_trampolines();
 594     verify_estimate_size(_estimated_trampoline_bytes, &quot;Trampolines&quot;);
 595 
 596     start_dump_space(MetaspaceShared::read_write_dump_space());
 597 
 598     log_info(cds, dynamic)(&quot;Copying %d klasses and %d symbols&quot;,
 599                            _klasses-&gt;length(), _symbols-&gt;length());
 600 
 601     {
 602       assert(current_dump_space() == MetaspaceShared::read_write_dump_space(),
 603              &quot;Current dump space is not rw space&quot;);
 604       // shallow-copy RW objects, if necessary
 605       ResourceMark rm;
 606       ShallowCopier rw_copier(this, false);
 607       iterate_roots(&amp;rw_copier);
 608     }
 609 
 610     // ro space starts ...
 611     DumpRegion* ro_space = MetaspaceShared::read_only_dump_space();
 612     {
 613       start_dump_space(ro_space);
 614 
 615       // shallow-copy RO objects, if necessary
 616       ResourceMark rm;
 617       ShallowCopier ro_copier(this, true);
 618       iterate_roots(&amp;ro_copier);
 619     }
 620 
 621     {
 622       log_info(cds)(&quot;Relocating embedded pointers ... &quot;);
 623       ResourceMark rm;
 624       ShallowCopyEmbeddedRefRelocator emb_reloc(this);
 625       iterate_roots(&amp;emb_reloc);
 626     }
 627 
 628     {
 629       log_info(cds)(&quot;Relocating external roots ... &quot;);
 630       ResourceMark rm;
 631       ExternalRefUpdater ext_reloc(this);
 632       iterate_roots(&amp;ext_reloc);
 633     }
 634 
 635     verify_estimate_size(_estimated_metsapceobj_bytes, &quot;MetaspaceObjs&quot;);
 636 
 637     char* serialized_data;
 638     {
 639       set_symbols_permanent();
 640 
 641       // Write the symbol table and system dictionaries to the RO space.
 642       // Note that these tables still point to the *original* objects
 643       // (because they were not processed by ExternalRefUpdater), so
 644       // they would need to call DynamicArchive::original_to_target() to
 645       // get the correct addresses.
 646       assert(current_dump_space() == ro_space, &quot;Must be RO space&quot;);
 647       SymbolTable::write_to_archive(false);
 648       SystemDictionaryShared::write_to_archive(false);
 649 
 650       serialized_data = ro_space-&gt;top();
 651       WriteClosure wc(ro_space);
 652       SymbolTable::serialize_shared_table_header(&amp;wc, false);
 653       SystemDictionaryShared::serialize_dictionary_headers(&amp;wc, false);
 654     }
 655 
 656     verify_estimate_size(_estimated_hashtable_bytes, &quot;Hashtables&quot;);
 657 
 658     make_trampolines();
 659     make_klasses_shareable();
 660 
 661     {
 662       log_info(cds)(&quot;Adjust lambda proxy class dictionary&quot;);
 663       SystemDictionaryShared::adjust_lambda_proxy_class_dictionary();
 664     }
 665 
 666     {
 667       log_info(cds)(&quot;Final relocation of pointers ... &quot;);
 668       ResourceMark rm;
 669       PointerMarker marker(this);
 670       iterate_roots(&amp;marker);
 671       relocate_buffer_to_target();
 672     }
 673 
 674     write_archive(serialized_data);
 675     release_header();
 676 
 677     assert(_num_dump_regions_used == _total_dump_regions, &quot;must be&quot;);
 678     verify_universe(&quot;After CDS dynamic dump&quot;);
 679   }
 680 
 681   void iterate_roots(MetaspaceClosure* it) {
 682     int i;
 683     int num_klasses = _klasses-&gt;length();
 684     for (i = 0; i &lt; num_klasses; i++) {
 685       it-&gt;push(&amp;_klasses-&gt;at(i));
 686     }
 687 
 688     int num_symbols = _symbols-&gt;length();
 689     for (i = 0; i &lt; num_symbols; i++) {
 690       it-&gt;push(&amp;_symbols-&gt;at(i));
 691     }
 692 
 693     FileMapInfo::metaspace_pointers_do(it);
 694 
 695     // Do not call these again, as we have already collected all the classes and symbols
 696     // that we want to archive. Also, these calls would corrupt the tables when
 697     // ExternalRefUpdater is used.
 698     //
 699     // SystemDictionaryShared::dumptime_classes_do(it);
 700     // SymbolTable::metaspace_pointers_do(it);
 701 
 702     it-&gt;finish();
 703   }
 704 };
 705 
 706 intx DynamicArchiveBuilder::_buffer_to_target_delta;
 707 
 708 
 709 size_t DynamicArchiveBuilder::estimate_archive_size() {
 710   // size of the symbol table and two dictionaries, plus the RunTimeSharedClassInfo&#39;s
 711   _estimated_hashtable_bytes = 0;
 712   _estimated_hashtable_bytes += SymbolTable::estimate_size_for_archive();
 713   _estimated_hashtable_bytes += SystemDictionaryShared::estimate_size_for_archive();
 714 
 715   _estimated_trampoline_bytes = estimate_trampoline_size();
 716 
 717   size_t total = 0;
 718 
 719   total += _estimated_metsapceobj_bytes;
 720   total += _estimated_hashtable_bytes;
 721   total += _estimated_trampoline_bytes;
 722 
 723   // allow fragmentation at the end of each dump region
 724   total += _total_dump_regions * reserve_alignment();
 725 
 726   return align_up(total, reserve_alignment());
 727 }
 728 
 729 address DynamicArchiveBuilder::reserve_space_and_init_buffer_to_target_delta() {
 730   size_t total = estimate_archive_size();
 731   ReservedSpace rs(total);
 732   if (!rs.is_reserved()) {
 733     log_error(cds, dynamic)(&quot;Failed to reserve %d bytes of output buffer.&quot;, (int)total);
 734     vm_direct_exit(0);
 735   }
 736 
 737   address buffer_base = (address)rs.base();
 738   log_info(cds, dynamic)(&quot;Reserved output buffer space at    : &quot; PTR_FORMAT &quot; [%d bytes]&quot;,
 739                          p2i(buffer_base), (int)total);
 740   MetaspaceShared::set_shared_rs(rs);
 741 
 742   // At run time, we will mmap the dynamic archive at target_space_bottom.
 743   // However, at dump time, we may not be able to write into the target_space,
 744   // as it&#39;s occupied by dynamically loaded Klasses. So we allocate a buffer
 745   // at an arbitrary location chosen by the OS. We will write all the dynamically
 746   // archived classes into this buffer. At the final stage of dumping, we relocate
 747   // all pointers that are inside the buffer_space to point to their (runtime)
 748   // target location inside thetarget_space.
 749   address target_space_bottom =
 750     (address)align_up(MetaspaceShared::shared_metaspace_top(), reserve_alignment());
 751   _buffer_to_target_delta = intx(target_space_bottom) - intx(buffer_base);
 752 
 753   log_info(cds, dynamic)(&quot;Target archive space at            : &quot; PTR_FORMAT, p2i(target_space_bottom));
 754   log_info(cds, dynamic)(&quot;Buffer-space to target-space delta : &quot; PTR_FORMAT, p2i((address)_buffer_to_target_delta));
 755 
 756   return buffer_base;
 757 }
 758 
 759 void DynamicArchiveBuilder::init_header(address reserved_bottom) {
 760   _alloc_bottom = reserved_bottom;
 761   _last_verified_top = reserved_bottom;
 762   _other_region_used_bytes = 0;
 763 
 764   init_first_dump_space(reserved_bottom);
 765 
 766   FileMapInfo* mapinfo = new FileMapInfo(false);
 767   assert(FileMapInfo::dynamic_info() == mapinfo, &quot;must be&quot;);
 768   _header = mapinfo-&gt;dynamic_header();
 769 
 770   Thread* THREAD = Thread::current();
 771   FileMapInfo* base_info = FileMapInfo::current_info();
 772   _header-&gt;set_base_header_crc(base_info-&gt;crc());
 773   for (int i = 0; i &lt; MetaspaceShared::n_regions; i++) {
 774     _header-&gt;set_base_region_crc(i, base_info-&gt;space_crc(i));
 775   }
 776   _header-&gt;populate(base_info, os::vm_allocation_granularity());
 777 }
 778 
 779 void DynamicArchiveBuilder::release_header() {
 780   // We temporarily allocated a dynamic FileMapInfo for dumping, which makes it appear we
 781   // have mapped a dynamic archive, but we actually have not. We are in a safepoint now.
 782   // Let&#39;s free it so that if class loading happens after we leave the safepoint, nothing
 783   // bad will happen.
 784   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be&quot;);
 785   FileMapInfo *mapinfo = FileMapInfo::dynamic_info();
 786   assert(mapinfo != NULL &amp;&amp; _header == mapinfo-&gt;dynamic_header(), &quot;must be&quot;);
 787   delete mapinfo;
 788   assert(!DynamicArchive::is_mapped(), &quot;must be&quot;);
 789   _header = NULL;
 790 }
 791 
 792 size_t DynamicArchiveBuilder::estimate_trampoline_size() {
 793   size_t total = 0;
 794   size_t each_method_bytes =
 795     align_up(SharedRuntime::trampoline_size(), BytesPerWord) +
 796     align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);
 797 
 798   for (int i = 0; i &lt; _klasses-&gt;length(); i++) {
 799     InstanceKlass* ik = _klasses-&gt;at(i);
 800     Array&lt;Method*&gt;* methods = ik-&gt;methods();
 801     total += each_method_bytes * methods-&gt;length();
 802   }
 803   if (total == 0) {
 804     // We have nothing to archive, but let&#39;s avoid having an empty region.
 805     total = SharedRuntime::trampoline_size();
 806   }
 807   return total;
 808 }
 809 
 810 void DynamicArchiveBuilder::make_trampolines() {
 811   DumpRegion* mc_space = MetaspaceShared::misc_code_dump_space();
 812   char* p = mc_space-&gt;base();
 813   for (int i = 0; i &lt; _klasses-&gt;length(); i++) {
 814     InstanceKlass* ik = _klasses-&gt;at(i);
 815     Array&lt;Method*&gt;* methods = ik-&gt;methods();
 816     for (int j = 0; j &lt; methods-&gt;length(); j++) {
 817       Method* m = methods-&gt;at(j);
 818       address c2i_entry_trampoline = (address)p;
 819       p += SharedRuntime::trampoline_size();
 820       assert(p &gt;= mc_space-&gt;base() &amp;&amp; p &lt;= mc_space-&gt;top(), &quot;must be&quot;);
 821       m-&gt;set_from_compiled_entry(to_target(c2i_entry_trampoline));
 822 
 823       AdapterHandlerEntry** adapter_trampoline =(AdapterHandlerEntry**)p;
 824       p += sizeof(AdapterHandlerEntry*);
 825       assert(p &gt;= mc_space-&gt;base() &amp;&amp; p &lt;= mc_space-&gt;top(), &quot;must be&quot;);
 826       *adapter_trampoline = NULL;
 827       m-&gt;set_adapter_trampoline(to_target(adapter_trampoline));
 828     }
 829   }
 830 
 831   guarantee(p &lt;= mc_space-&gt;top(), &quot;Estimate of trampoline size is insufficient&quot;);
 832 }
 833 
 834 void DynamicArchiveBuilder::make_klasses_shareable() {
 835   int i, count = _klasses-&gt;length();
 836 
 837   InstanceKlass::disable_method_binary_search();
 838   for (i = 0; i &lt; count; i++) {
 839     InstanceKlass* ik = _klasses-&gt;at(i);
 840     sort_methods(ik);
 841   }
 842 
 843   for (i = 0; i &lt; count; i++) {
 844     InstanceKlass* ik = _klasses-&gt;at(i);
 845     ik-&gt;assign_class_loader_type();
 846 
 847     MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread::current(), ik);
 848     ik-&gt;remove_unshareable_info();
 849 
 850     assert(ik-&gt;array_klasses() == NULL, &quot;sanity&quot;);
 851 
 852     if (log_is_enabled(Debug, cds, dynamic)) {
 853       ResourceMark rm;
 854       log_debug(cds, dynamic)(&quot;klasses[%4i] = &quot; PTR_FORMAT &quot; %s&quot;, i, p2i(to_target(ik)), ik-&gt;external_name());
 855     }
 856   }
 857 }
 858 
 859 // The address order of the copied Symbols may be different than when the original
 860 // klasses were created. Re-sort all the tables. See Method::sort_methods().
 861 void DynamicArchiveBuilder::sort_methods(InstanceKlass* ik) const {
 862   assert(ik != NULL, &quot;DynamicArchiveBuilder currently doesn&#39;t support dumping the base archive&quot;);
 863   if (MetaspaceShared::is_in_shared_metaspace(ik)) {
 864     // We have reached a supertype that&#39;s already in the base archive
 865     return;
 866   }
 867 
 868   if (ik-&gt;java_mirror() == NULL) {
 869     // NULL mirror means this class has already been visited and methods are already sorted
 870     return;
 871   }
 872   ik-&gt;remove_java_mirror();
 873 
 874   if (log_is_enabled(Debug, cds, dynamic)) {
 875     ResourceMark rm;
 876     log_debug(cds, dynamic)(&quot;sorting methods for &quot; PTR_FORMAT &quot; %s&quot;, p2i(to_target(ik)), ik-&gt;external_name());
 877   }
 878 
 879   // Make sure all supertypes have been sorted
 880   sort_methods(ik-&gt;java_super());
 881   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
 882   int len = interfaces-&gt;length();
 883   for (int i = 0; i &lt; len; i++) {
 884     sort_methods(interfaces-&gt;at(i));
 885   }
 886 
 887 #ifdef ASSERT
 888   if (ik-&gt;methods() != NULL) {
 889     for (int m = 0; m &lt; ik-&gt;methods()-&gt;length(); m++) {
 890       Symbol* name = ik-&gt;methods()-&gt;at(m)-&gt;name();
 891       assert(MetaspaceShared::is_in_shared_metaspace(name) || is_in_buffer_space(name), &quot;must be&quot;);
 892     }
 893   }
 894   if (ik-&gt;default_methods() != NULL) {
 895     for (int m = 0; m &lt; ik-&gt;default_methods()-&gt;length(); m++) {
 896       Symbol* name = ik-&gt;default_methods()-&gt;at(m)-&gt;name();
 897       assert(MetaspaceShared::is_in_shared_metaspace(name) || is_in_buffer_space(name), &quot;must be&quot;);
 898     }
 899   }
 900 #endif
 901 
 902   Thread* THREAD = Thread::current();
 903   Method::sort_methods(ik-&gt;methods(), /*set_idnums=*/true, dynamic_dump_method_comparator);
 904   if (ik-&gt;default_methods() != NULL) {
 905     Method::sort_methods(ik-&gt;default_methods(), /*set_idnums=*/false, dynamic_dump_method_comparator);
 906   }
 907   ik-&gt;vtable().initialize_vtable(true, THREAD); assert(!HAS_PENDING_EXCEPTION, &quot;cannot fail&quot;);
 908   ik-&gt;itable().initialize_itable(true, THREAD); assert(!HAS_PENDING_EXCEPTION, &quot;cannot fail&quot;);
 909 }
 910 
 911 void DynamicArchiveBuilder::set_symbols_permanent() {
 912   int count = _symbols-&gt;length();
 913   for (int i=0; i&lt;count; i++) {
 914     Symbol* s = _symbols-&gt;at(i);
 915     s-&gt;set_permanent();
 916 
 917     if (log_is_enabled(Trace, cds, dynamic)) {
 918       ResourceMark rm;
 919       log_trace(cds, dynamic)(&quot;symbols[%4i] = &quot; PTR_FORMAT &quot; %s&quot;, i, p2i(to_target(s)), s-&gt;as_quoted_ascii());
 920     }
 921   }
 922 }
 923 
 924 class RelocateBufferToTarget: public BitMapClosure {
 925   DynamicArchiveBuilder *_builder;
 926   address* _buffer_bottom;
 927   intx _buffer_to_target_delta;
 928  public:
 929   RelocateBufferToTarget(DynamicArchiveBuilder* builder, address* bottom, intx delta) :
 930     _builder(builder), _buffer_bottom(bottom), _buffer_to_target_delta(delta) {}
 931 
 932   bool do_bit(size_t offset) {
 933     address* p = _buffer_bottom + offset;
 934     assert(_builder-&gt;is_in_buffer_space(p), &quot;pointer must live in buffer space&quot;);
 935 
 936     address old_ptr = *p;
 937     if (_builder-&gt;is_in_buffer_space(old_ptr)) {
 938       address new_ptr = old_ptr + _buffer_to_target_delta;
 939       log_trace(cds, dynamic)(&quot;Final patch: @%6d [&quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot;] &quot; PTR_FORMAT &quot; =&gt; &quot; PTR_FORMAT,
 940                               (int)offset, p2i(p), p2i(_builder-&gt;to_target(p)),
 941                               p2i(old_ptr), p2i(new_ptr));
 942       *p = new_ptr;
 943     }
 944 
 945     return true; // keep iterating
 946   }
 947 };
 948 
 949 void DynamicArchiveBuilder::relocate_buffer_to_target() {
 950   RelocateBufferToTarget patcher(this, (address*)_alloc_bottom, _buffer_to_target_delta);
 951   ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
 952 
 953   Array&lt;u8&gt;* table = FileMapInfo::saved_shared_path_table().table();
 954   SharedPathTable runtime_table(to_target(table), FileMapInfo::shared_path_table().size());
 955   _header-&gt;set_shared_path_table(runtime_table);
 956 
 957   address relocatable_base = (address)SharedBaseAddress;
 958   address relocatable_end = (address)(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
 959 
 960   intx addr_delta = MetaspaceShared::final_delta();
 961   if (addr_delta == 0) {
 962     ArchivePtrMarker::compact(relocatable_base, relocatable_end);
 963   } else {
 964     // The base archive is NOT mapped at MetaspaceShared::requested_base_address() (due to ASLR).
 965     // This means that the current content of the dynamic archive is based on a random
 966     // address. Let&#39;s relocate all the pointers, so that it can be mapped to
 967     // MetaspaceShared::requested_base_address() without runtime relocation.
 968     //
 969     // Note: both the base and dynamic archive are written with
 970     // FileMapHeader::_requested_base_address == MetaspaceShared::requested_base_address()
 971 
 972     // Patch all pointers that are marked by ptrmap within this region,
 973     // where we have just dumped all the metaspace data.
 974     address patch_base = (address)_alloc_bottom;
 975     address patch_end  = (address)current_dump_space()-&gt;top();
 976 
 977     // the current value of the pointers to be patched must be within this
 978     // range (i.e., must point to either the top archive (as currently mapped), or to the
 979     // (targeted address of) the top archive)
 980     address valid_old_base = relocatable_base;
 981     address valid_old_end  = relocatable_end;
 982     size_t base_plus_top_size = valid_old_end - valid_old_base;
 983     size_t top_size = patch_end - patch_base;
 984     size_t base_size = base_plus_top_size - top_size;
 985     assert(base_plus_top_size &gt; base_size, &quot;no overflow&quot;);
 986     assert(base_plus_top_size &gt; top_size, &quot;no overflow&quot;);
 987 
 988     // after patching, the pointers must point inside this range
 989     // (the requested location of the archive, as mapped at runtime).
 990     address valid_new_base = (address)MetaspaceShared::requested_base_address();
 991     address valid_new_end  = valid_new_base + base_plus_top_size;
 992 
 993     log_debug(cds)(&quot;Relocating archive from [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] to &quot;
 994                    &quot;[&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;], delta = &quot; INTX_FORMAT &quot; bytes&quot;,
 995                    p2i(patch_base + base_size), p2i(patch_end),
 996                    p2i(valid_new_base + base_size), p2i(valid_new_end), addr_delta);
 997 
 998     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
 999                                       valid_new_base, valid_new_end, addr_delta, ArchivePtrMarker::ptrmap());
1000     ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
1001     ArchivePtrMarker::compact(patcher.max_non_null_offset());
1002   }
1003 }
1004 
1005 void DynamicArchiveBuilder::write_archive(char* serialized_data) {
1006   int num_klasses = _klasses-&gt;length();
1007   int num_symbols = _symbols-&gt;length();
1008 
1009   _header-&gt;set_serialized_data(to_target(serialized_data));
1010 
1011   FileMapInfo* dynamic_info = FileMapInfo::dynamic_info();
1012   assert(dynamic_info != NULL, &quot;Sanity&quot;);
1013 
1014   // Now write the archived data including the file offsets.
1015   const char* archive_name = Arguments::GetSharedDynamicArchivePath();
1016   dynamic_info-&gt;open_for_write(archive_name);
1017   MetaspaceShared::write_core_archive_regions(dynamic_info, NULL, NULL);
1018   dynamic_info-&gt;set_final_requested_base((char*)MetaspaceShared::requested_base_address());
1019   dynamic_info-&gt;set_header_crc(dynamic_info-&gt;compute_header_crc());
1020   dynamic_info-&gt;write_header();
1021   dynamic_info-&gt;close();
1022 
1023   address base = to_target(_alloc_bottom);
1024   address top  = address(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
1025   size_t file_size = pointer_delta(top, base, sizeof(char));
1026 
1027   base += MetaspaceShared::final_delta();
1028   top += MetaspaceShared::final_delta();
1029   log_info(cds, dynamic)(&quot;Written dynamic archive &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT
1030                          &quot; [&quot; SIZE_FORMAT &quot; bytes header, &quot; SIZE_FORMAT &quot; bytes total]&quot;,
1031                          p2i(base), p2i(top), _header-&gt;header_size(), file_size);
1032   log_info(cds, dynamic)(&quot;%d klasses; %d symbols&quot;, num_klasses, num_symbols);
1033 }
1034 
1035 
1036 class VM_PopulateDynamicDumpSharedSpace: public VM_Operation {
1037   DynamicArchiveBuilder* _builder;
1038 public:
1039   VM_PopulateDynamicDumpSharedSpace(DynamicArchiveBuilder* builder) : _builder(builder) {}
1040   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1041   void doit() {
1042     ResourceMark rm;
1043     if (SystemDictionaryShared::empty_dumptime_table()) {
1044       log_warning(cds, dynamic)(&quot;There is no class to be included in the dynamic archive.&quot;);
1045       return;
1046     }
1047     if (AllowArchivingWithJavaAgent) {
1048       warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1049               &quot;for testing purposes only and should not be used in a production environment&quot;);
1050     }
1051     FileMapInfo::check_nonempty_dir_in_shared_path_table();
1052 
1053     _builder-&gt;doit();
1054   }
1055 };
1056 
1057 
1058 void DynamicArchive::dump() {
1059   if (Arguments::GetSharedDynamicArchivePath() == NULL) {
1060     log_warning(cds, dynamic)(&quot;SharedDynamicArchivePath is not specified&quot;);
1061     return;
1062   }
1063 
1064   DynamicArchiveBuilder builder;
1065   _builder = &amp;builder;
1066   VM_PopulateDynamicDumpSharedSpace op(&amp;builder);
1067   VMThread::execute(&amp;op);
1068   _builder = NULL;
1069 }
1070 
1071 address DynamicArchive::original_to_buffer_impl(address orig_obj) {
1072   assert(DynamicDumpSharedSpaces, &quot;must be&quot;);
1073   address buff_obj = _builder-&gt;get_new_loc(orig_obj);
1074   assert(buff_obj != NULL, &quot;orig_obj must be used by the dynamic archive&quot;);
1075   assert(buff_obj != orig_obj, &quot;call this only when you know orig_obj must be copied and not just referenced&quot;);
1076   assert(_builder-&gt;is_in_buffer_space(buff_obj), &quot;must be&quot;);
1077   return buff_obj;
1078 }
1079 
1080 address DynamicArchive::buffer_to_target_impl(address buff_obj) {
1081   assert(DynamicDumpSharedSpaces, &quot;must be&quot;);
1082   assert(_builder-&gt;is_in_buffer_space(buff_obj), &quot;must be&quot;);
1083   return _builder-&gt;to_target(buff_obj);
1084 }
1085 
1086 address DynamicArchive::original_to_target_impl(address orig_obj) {
1087   assert(DynamicDumpSharedSpaces, &quot;must be&quot;);
1088   if (MetaspaceShared::is_in_shared_metaspace(orig_obj)) {
1089     // This happens when the top archive points to a Symbol* in the base archive.
1090     return orig_obj;
1091   }
1092   address buff_obj = _builder-&gt;get_new_loc(orig_obj);
1093   assert(buff_obj != NULL, &quot;orig_obj must be used by the dynamic archive&quot;);
1094   if (buff_obj == orig_obj) {
1095     // We are storing a pointer to an original object into the dynamic buffer. E.g.,
1096     // a Symbol* that used by both the base and top archives.
1097     assert(MetaspaceShared::is_in_shared_metaspace(orig_obj), &quot;must be&quot;);
1098     return orig_obj;
1099   } else {
1100     return _builder-&gt;to_target(buff_obj);
1101   }
1102 }
1103 
1104 uintx DynamicArchive::object_delta_uintx(void* buff_obj) {
1105   assert(DynamicDumpSharedSpaces, &quot;must be&quot;);
1106   address target_obj = _builder-&gt;to_target_no_check(address(buff_obj));
1107   assert(uintx(target_obj) &gt;= SharedBaseAddress, &quot;must be&quot;);
1108   return uintx(target_obj) - SharedBaseAddress;
1109 }
1110 
1111 bool DynamicArchive::is_in_target_space(void *obj) {
1112   assert(DynamicDumpSharedSpaces, &quot;must be&quot;);
1113   return _builder-&gt;is_in_target_space(obj);
1114 }
1115 
1116 
1117 DynamicArchiveBuilder* DynamicArchive::_builder = NULL;
1118 
1119 
1120 bool DynamicArchive::validate(FileMapInfo* dynamic_info) {
1121   assert(!dynamic_info-&gt;is_static(), &quot;must be&quot;);
1122   // Check if the recorded base archive matches with the current one
1123   FileMapInfo* base_info = FileMapInfo::current_info();
1124   DynamicArchiveHeader* dynamic_header = dynamic_info-&gt;dynamic_header();
1125 
1126   // Check the header crc
1127   if (dynamic_header-&gt;base_header_crc() != base_info-&gt;crc()) {
1128     FileMapInfo::fail_continue(&quot;Dynamic archive cannot be used: static archive header checksum verification failed.&quot;);
1129     return false;
1130   }
1131 
1132   // Check each space&#39;s crc
1133   for (int i = 0; i &lt; MetaspaceShared::n_regions; i++) {
1134     if (dynamic_header-&gt;base_region_crc(i) != base_info-&gt;space_crc(i)) {
1135       FileMapInfo::fail_continue(&quot;Dynamic archive cannot be used: static archive region #%d checksum verification failed.&quot;, i);
1136       return false;
1137     }
1138   }
1139 
1140   return true;
1141 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>