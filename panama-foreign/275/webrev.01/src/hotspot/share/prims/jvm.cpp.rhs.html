<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/javaAssertions.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/stringTable.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;
  54 #include &quot;oops/instanceKlass.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/recordComponent.hpp&quot;
  57 #include &quot;oops/objArrayKlass.hpp&quot;
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;prims/jvm_misc.hpp&quot;
  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;prims/nativeLookup.hpp&quot;
  64 #include &quot;prims/stackwalk.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/init.hpp&quot;
  69 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  70 #include &quot;runtime/deoptimization.hpp&quot;
  71 #include &quot;runtime/handshake.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/os.inline.hpp&quot;
  77 #include &quot;runtime/perfData.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/synchronizer.hpp&quot;
  80 #include &quot;runtime/thread.inline.hpp&quot;
  81 #include &quot;runtime/threadSMR.hpp&quot;
  82 #include &quot;runtime/vframe.inline.hpp&quot;
  83 #include &quot;runtime/vmOperations.hpp&quot;
  84 #include &quot;runtime/vm_version.hpp&quot;
  85 #include &quot;services/attachListener.hpp&quot;
  86 #include &quot;services/management.hpp&quot;
  87 #include &quot;services/threadService.hpp&quot;
  88 #include &quot;utilities/copy.hpp&quot;
  89 #include &quot;utilities/defaultStream.hpp&quot;
  90 #include &quot;utilities/dtrace.hpp&quot;
  91 #include &quot;utilities/events.hpp&quot;
  92 #include &quot;utilities/histogram.hpp&quot;
  93 #include &quot;utilities/macros.hpp&quot;
  94 #include &quot;utilities/utf8.hpp&quot;
  95 #if INCLUDE_CDS
  96 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  97 #endif
  98 #if INCLUDE_JFR
  99 #include &quot;jfr/jfr.hpp&quot;
 100 #endif
 101 
 102 #include &lt;errno.h&gt;
 103 
 104 /*
 105   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 106   such ctors and calls MUST NOT come between an oop declaration/init and its
 107   usage because if objects are move this may cause various memory stomps, bus
 108   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 109   failures&quot;:
 110 
 111       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 112           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 113 
 114           // Object address to be held directly in mirror &amp; not visible to GC
 115           oop mirror = JNIHandles::resolve_non_null(ofClass);
 116 
 117           // If this ctor can hit a safepoint, moving objects around, then
 118           ComplexConstructor foo;
 119 
 120           // Boom! mirror may point to JUNK instead of the intended object
 121           (some dereference of mirror)
 122 
 123           // Here&#39;s another call that may block for GC, making mirror stale
 124           MutexLocker ml(some_lock);
 125 
 126           // And here&#39;s an initializer that can result in a stale oop
 127           // all in one step.
 128           oop o = call_that_can_throw_exception(TRAPS);
 129 
 130 
 131   The solution is to keep the oop declaration BELOW the ctor or function
 132   call that might cause a GC, do another resolve to reassign the oop, or
 133   consider use of a Handle instead of an oop so there is immunity from object
 134   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 135   and thus can only support use of handles passed in.
 136 */
 137 
 138 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 139   ResourceMark rm;
 140   int line_number = -1;
 141   const char * source_file = NULL;
 142   const char * trace = &quot;explicit&quot;;
 143   InstanceKlass* caller = NULL;
 144   JavaThread* jthread = (JavaThread*) THREAD;
 145   if (jthread-&gt;has_last_Java_frame()) {
 146     vframeStream vfst(jthread);
 147 
 148     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 149     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 150     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 151     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 152     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 153 
 154     Method* last_caller = NULL;
 155 
 156     while (!vfst.at_end()) {
 157       Method* m = vfst.method();
 158       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 159           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 160           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 161         break;
 162       }
 163       last_caller = m;
 164       vfst.next();
 165     }
 166     // if this is called from Class.forName0 and that is called from Class.forName,
 167     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 168     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 169     bool found_it = false;
 170     if (!vfst.at_end() &amp;&amp;
 171         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 172         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 173       vfst.next();
 174       if (!vfst.at_end() &amp;&amp;
 175           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 176           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 177         vfst.next();
 178         found_it = true;
 179       }
 180     } else if (last_caller != NULL &amp;&amp;
 181                last_caller-&gt;method_holder()-&gt;name() ==
 182                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 183                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 184       found_it = true;
 185     } else if (!vfst.at_end()) {
 186       if (vfst.method()-&gt;is_native()) {
 187         // JNI call
 188         found_it = true;
 189       }
 190     }
 191     if (found_it &amp;&amp; !vfst.at_end()) {
 192       // found the caller
 193       caller = vfst.method()-&gt;method_holder();
 194       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 195       if (line_number == -1) {
 196         // show method name if it&#39;s a native method
 197         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 198       }
 199       Symbol* s = caller-&gt;source_file_name();
 200       if (s != NULL) {
 201         source_file = s-&gt;as_C_string();
 202       }
 203     }
 204   }
 205   if (caller != NULL) {
 206     if (to_class != caller) {
 207       const char * from = caller-&gt;external_name();
 208       const char * to = to_class-&gt;external_name();
 209       // print in a single call to reduce interleaving between threads
 210       if (source_file != NULL) {
 211         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 212       } else {
 213         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 214       }
 215     }
 216   }
 217 }
 218 
 219 void trace_class_resolution(Klass* to_class) {
 220   EXCEPTION_MARK;
 221   trace_class_resolution_impl(to_class, THREAD);
 222   if (HAS_PENDING_EXCEPTION) {
 223     CLEAR_PENDING_EXCEPTION;
 224   }
 225 }
 226 
 227 // Wrapper to trace JVM functions
 228 
 229 #ifdef ASSERT
 230   Histogram* JVMHistogram;
 231   volatile int JVMHistogram_lock = 0;
 232 
 233   class JVMHistogramElement : public HistogramElement {
 234     public:
 235      JVMHistogramElement(const char* name);
 236   };
 237 
 238   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 239     _name = elementName;
 240     uintx count = 0;
 241 
 242     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 243       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 244         count +=1;
 245         if ( (WarnOnStalledSpinLock &gt; 0)
 246           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 247           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 248         }
 249       }
 250      }
 251 
 252     if(JVMHistogram == NULL)
 253       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 254 
 255     JVMHistogram-&gt;add_element(this);
 256     Atomic::dec(&amp;JVMHistogram_lock);
 257   }
 258 
 259   #define JVMCountWrapper(arg) \
 260       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 261       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 262 
 263   #define JVMWrapper(arg) JVMCountWrapper(arg);
 264 #else
 265   #define JVMWrapper(arg)
 266 #endif
 267 
 268 
 269 // Interface version /////////////////////////////////////////////////////////////////////
 270 
 271 
 272 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 273   return JVM_INTERFACE_VERSION;
 274 JVM_END
 275 
 276 
 277 // java.lang.System //////////////////////////////////////////////////////////////////////
 278 
 279 
 280 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 281   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 282   return os::javaTimeMillis();
 283 JVM_END
 284 
 285 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 286   JVMWrapper(&quot;JVM_NanoTime&quot;);
 287   return os::javaTimeNanos();
 288 JVM_END
 289 
 290 // The function below is actually exposed by jdk.internal.misc.VM and not
 291 // java.lang.System, but we choose to keep it here so that it stays next
 292 // to JVM_CurrentTimeMillis and JVM_NanoTime
 293 
 294 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 295 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 296 
 297 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 298   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 299   jlong seconds;
 300   jlong nanos;
 301 
 302   os::javaTimeSystemUTC(seconds, nanos);
 303 
 304   // We&#39;re going to verify that the result can fit in a long.
 305   // For that we need the difference in seconds between &#39;seconds&#39;
 306   // and &#39;offset_secs&#39; to be such that:
 307   //     |seconds - offset_secs| &lt; (2^63/10^9)
 308   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 309   // which makes |seconds - offset_secs| &lt; 2^33
 310   // and we will prefer +/- 2^32 as the maximum acceptable diff
 311   // as 2^32 has a more natural feel than 2^33...
 312   //
 313   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 314   // sentinel value (-1) which the caller should take as an
 315   // exception value indicating that the offset given to us is
 316   // too far from range of the current time - leading to too big
 317   // a nano adjustment. The caller is expected to recover by
 318   // computing a more accurate offset and calling this method
 319   // again. (For the record 2^32 secs is ~136 years, so that
 320   // should rarely happen)
 321   //
 322   jlong diff = seconds - offset_secs;
 323   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 324      return -1; // sentinel value: the offset is too far off the target
 325   }
 326 
 327   // return the adjustment. If you compute a time by adding
 328   // this number of nanoseconds along with the number of seconds
 329   // in the offset you should get the current UTC time.
 330   return (diff * (jlong)1000000000) + nanos;
 331 JVM_END
 332 
 333 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 334                                jobject dst, jint dst_pos, jint length))
 335   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 336   // Check if we have null pointers
 337   if (src == NULL || dst == NULL) {
 338     THROW(vmSymbols::java_lang_NullPointerException());
 339   }
 340   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 341   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 342   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 343   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 344   // Do copy
 345   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 346 JVM_END
 347 
 348 
 349 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 350   JavaValue r(T_OBJECT);
 351   // public synchronized Object put(Object key, Object value);
 352   HandleMark hm(THREAD);
 353   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 354   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 355   JavaCalls::call_virtual(&amp;r,
 356                           props,
 357                           SystemDictionary::Properties_klass(),
 358                           vmSymbols::put_name(),
 359                           vmSymbols::object_object_object_signature(),
 360                           key_str,
 361                           value_str,
 362                           THREAD);
 363 }
 364 
 365 
 366 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 367 
 368 /*
 369  * Return all of the system properties in a Java String array with alternating
 370  * names and values from the jvm SystemProperty.
 371  * Which includes some internal and all commandline -D defined properties.
 372  */
 373 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 374   JVMWrapper(&quot;JVM_GetProperties&quot;);
 375   ResourceMark rm(THREAD);
 376   HandleMark hm(THREAD);
 377   int ndx = 0;
 378   int fixedCount = 2;
 379 
 380   SystemProperty* p = Arguments::system_properties();
 381   int count = Arguments::PropertyList_count(p);
 382 
 383   // Allocate result String array
 384   InstanceKlass* ik = SystemDictionary::String_klass();
 385   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 386   objArrayHandle result_h(THREAD, r);
 387 
 388   while (p != NULL) {
 389     const char * key = p-&gt;key();
 390     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 391         const char * value = p-&gt;value();
 392         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 393         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 394         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 395         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 396         ndx++;
 397     }
 398     p = p-&gt;next();
 399   }
 400 
 401   // Convert the -XX:MaxDirectMemorySize= command line flag
 402   // to the sun.nio.MaxDirectMemorySize property.
 403   // Do this after setting user properties to prevent people
 404   // from setting the value with a -D option, as requested.
 405   // Leave empty if not supplied
 406   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 407     char as_chars[256];
 408     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 409     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 410     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 411     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 412     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 413     ndx++;
 414   }
 415 
 416   // JVM monitoring and management support
 417   // Add the sun.management.compiler property for the compiler&#39;s name
 418   {
 419 #undef CSIZE
 420 #if defined(_LP64) || defined(_WIN64)
 421   #define CSIZE &quot;64-Bit &quot;
 422 #else
 423   #define CSIZE
 424 #endif // 64bit
 425 
 426 #ifdef TIERED
 427     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 428 #else
 429 #if defined(COMPILER1)
 430     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 431 #elif defined(COMPILER2)
 432     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 433 #elif INCLUDE_JVMCI
 434     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 435 #else
 436     const char* compiler_name = &quot;&quot;;
 437 #endif // compilers
 438 #endif // TIERED
 439 
 440     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 441         (Arguments::mode() != Arguments::_int)) {
 442       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 443       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 444       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 445       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 446       ndx++;
 447     }
 448   }
 449 
 450   return (jobjectArray) JNIHandles::make_local(THREAD, result_h());
 451 JVM_END
 452 
 453 
 454 /*
 455  * Return the temporary directory that the VM uses for the attach
 456  * and perf data files.
 457  *
 458  * It is important that this directory is well-known and the
 459  * same for all VM instances. It cannot be affected by configuration
 460  * variables such as java.io.tmpdir.
 461  */
 462 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 463   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 464   HandleMark hm(THREAD);
 465   const char* temp_dir = os::get_temp_directory();
 466   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 467   return (jstring) JNIHandles::make_local(THREAD, h());
 468 JVM_END
 469 
 470 
 471 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 472 
 473 extern volatile jint vm_created;
 474 
 475 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 476   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
 477   // Link all classes for dynamic CDS dumping before vm exit.
 478   if (DynamicDumpSharedSpaces) {
 479     MetaspaceShared::link_and_cleanup_shared_classes(THREAD);
 480   }
 481   EventShutdown event;
 482   if (event.should_commit()) {
 483     event.set_reason(&quot;Shutdown requested from Java&quot;);
 484     event.commit();
 485   }
 486 JVM_END
 487 
 488 
 489 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 490   before_exit(thread);
 491   vm_exit(code);
 492 JVM_END
 493 
 494 
 495 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 496   JVMWrapper(&quot;JVM_GC&quot;);
 497   if (!DisableExplicitGC) {
 498     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 499   }
 500 JVM_END
 501 
 502 
 503 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 504   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 505   return Universe::heap()-&gt;millis_since_last_gc();
 506 JVM_END
 507 
 508 
 509 static inline jlong convert_size_t_to_jlong(size_t val) {
 510   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 511   NOT_LP64 (return (jlong)val;)
 512   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 513 }
 514 
 515 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 516   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 517   size_t n = Universe::heap()-&gt;capacity();
 518   return convert_size_t_to_jlong(n);
 519 JVM_END
 520 
 521 
 522 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 523   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 524   size_t n = Universe::heap()-&gt;unused();
 525   return convert_size_t_to_jlong(n);
 526 JVM_END
 527 
 528 
 529 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 530   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 531   size_t n = Universe::heap()-&gt;max_capacity();
 532   return convert_size_t_to_jlong(n);
 533 JVM_END
 534 
 535 
 536 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 537   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 538   return os::active_processor_count();
 539 JVM_END
 540 
<a name="1" id="anc1"></a><span class="line-modified"> 541 JVM_ENTRY_NO_ENV(jboolean, JVM_IsUseContainerSupport(void))</span>
<span class="line-added"> 542   JVMWrapper(&quot;JVM_IsUseContainerSupport&quot;);</span>
<span class="line-added"> 543 #ifdef LINUX</span>
<span class="line-added"> 544   if (UseContainerSupport) {</span>
<span class="line-added"> 545     return JNI_TRUE;</span>
<span class="line-added"> 546   }</span>
<span class="line-added"> 547 #endif</span>
<span class="line-added"> 548   return JNI_FALSE;</span>
<span class="line-added"> 549 JVM_END</span>
 550 
 551 // java.lang.Throwable //////////////////////////////////////////////////////
 552 
 553 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 554   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 555   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 556   java_lang_Throwable::fill_in_stack_trace(exception);
 557 JVM_END
 558 
 559 // java.lang.NullPointerException ///////////////////////////////////////////
 560 
 561 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 562   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 563 
 564   oop exc = JNIHandles::resolve_non_null(throwable);
 565 
 566   Method* method;
 567   int bci;
 568   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 569     return NULL;
 570   }
 571   if (method-&gt;is_native()) {
 572     return NULL;
 573   }
 574 
 575   stringStream ss;
 576   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 577   if (ok) {
 578     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_NULL);
 579     return (jstring) JNIHandles::make_local(THREAD, result);
 580   } else {
 581     return NULL;
 582   }
 583 JVM_END
 584 
 585 // java.lang.StackTraceElement //////////////////////////////////////////////
 586 
 587 
 588 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 589   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 590   Handle exception(THREAD, JNIHandles::resolve(throwable));
 591   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 592   objArrayHandle stack_trace(THREAD, st);
 593   // Fill in the allocated stack trace
 594   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 595 JVM_END
 596 
 597 
 598 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 599   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 600   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 601   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 602   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 603 JVM_END
 604 
 605 
 606 // java.lang.StackWalker //////////////////////////////////////////////////////
 607 
 608 
 609 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 610                                      jint skip_frames, jint frame_count, jint start_index,
 611                                      jobjectArray frames))
 612   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 613   JavaThread* jt = (JavaThread*) THREAD;
 614   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 615     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 616   }
 617 
 618   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 619 
 620   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 621   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 622   // be null.
 623   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 624   objArrayHandle frames_array_h(THREAD, fa);
 625 
 626   int limit = start_index + frame_count;
 627   if (frames_array_h-&gt;length() &lt; limit) {
 628     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 629   }
 630 
 631   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, frame_count,
 632                                start_index, frames_array_h, CHECK_NULL);
 633   return JNIHandles::make_local(THREAD, result);
 634 JVM_END
 635 
 636 
 637 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 638                                   jint frame_count, jint start_index,
 639                                   jobjectArray frames))
 640   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 641 
 642   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 643   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 644   // be null.
 645   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 646   objArrayHandle frames_array_h(THREAD, fa);
 647 
 648   int limit = start_index+frame_count;
 649   if (frames_array_h-&gt;length() &lt; limit) {
 650     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 651   }
 652 
 653   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 654   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 655                                    start_index, frames_array_h, THREAD);
 656 JVM_END
 657 
 658 // java.lang.Object ///////////////////////////////////////////////
 659 
 660 
 661 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 662   JVMWrapper(&quot;JVM_IHashCode&quot;);
 663   // as implemented in the classic virtual machine; return 0 if object is NULL
 664   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 665 JVM_END
 666 
 667 
 668 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 669   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 670   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 671   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 672   if (JvmtiExport::should_post_monitor_wait()) {
 673     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 674 
 675     // The current thread already owns the monitor and it has not yet
 676     // been added to the wait queue so the current thread cannot be
 677     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 678     // event handler cannot accidentally consume an unpark() meant for
 679     // the ParkEvent associated with this ObjectMonitor.
 680   }
 681   ObjectSynchronizer::wait(obj, ms, CHECK);
 682 JVM_END
 683 
 684 
 685 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 686   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 687   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 688   ObjectSynchronizer::notify(obj, CHECK);
 689 JVM_END
 690 
 691 
 692 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 693   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 694   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 695   ObjectSynchronizer::notifyall(obj, CHECK);
 696 JVM_END
 697 
 698 
 699 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 700   JVMWrapper(&quot;JVM_Clone&quot;);
 701   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 702   Klass* klass = obj-&gt;klass();
 703   JvmtiVMObjectAllocEventCollector oam;
 704 
 705 #ifdef ASSERT
 706   // Just checking that the cloneable flag is set correct
 707   if (obj-&gt;is_array()) {
 708     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 709   } else {
 710     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 711     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 712     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 713   }
 714 #endif
 715 
 716   // Check if class of obj supports the Cloneable interface.
 717   // All arrays are considered to be cloneable (See JLS 20.1.5).
 718   // All j.l.r.Reference classes are considered non-cloneable.
 719   if (!klass-&gt;is_cloneable() ||
 720       (klass-&gt;is_instance_klass() &amp;&amp;
 721        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 722     ResourceMark rm(THREAD);
 723     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 724   }
 725 
 726   // Make shallow object copy
 727   const int size = obj-&gt;size();
 728   oop new_obj_oop = NULL;
 729   if (obj-&gt;is_array()) {
 730     const int length = ((arrayOop)obj())-&gt;length();
 731     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 732                                                    /* do_zero */ true, CHECK_NULL);
 733   } else {
 734     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 735   }
 736 
 737   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 738 
 739   Handle new_obj(THREAD, new_obj_oop);
 740   // Caution: this involves a java upcall, so the clone should be
 741   // &quot;gc-robust&quot; by this stage.
 742   if (klass-&gt;has_finalizer()) {
 743     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 744     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 745     new_obj = Handle(THREAD, new_obj_oop);
 746   }
 747 
 748   return JNIHandles::make_local(THREAD, new_obj());
 749 JVM_END
 750 
 751 // java.io.File ///////////////////////////////////////////////////////////////
 752 
 753 JVM_LEAF(char*, JVM_NativePath(char* path))
 754   JVMWrapper(&quot;JVM_NativePath&quot;);
 755   return os::native_path(path);
 756 JVM_END
 757 
 758 
 759 // Misc. class handling ///////////////////////////////////////////////////////////
 760 
 761 
 762 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 763   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 764 
 765   // Getting the class of the caller frame.
 766   //
 767   // The call stack at this point looks something like this:
 768   //
 769   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 770   // [1] [ @CallerSensitive API.method                                   ]
 771   // [.] [ (skipped intermediate frames)                                 ]
 772   // [n] [ caller                                                        ]
 773   vframeStream vfst(thread);
 774   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 775   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 776     Method* m = vfst.method();
 777     assert(m != NULL, &quot;sanity&quot;);
 778     switch (n) {
 779     case 0:
 780       // This must only be called from Reflection.getCallerClass
 781       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 782         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 783       }
 784       // fall-through
 785     case 1:
 786       // Frame 0 and 1 must be caller sensitive.
 787       if (!m-&gt;caller_sensitive()) {
 788         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 789       }
 790       break;
 791     default:
 792       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 793         // We have reached the desired frame; return the holder class.
 794         return (jclass) JNIHandles::make_local(THREAD, m-&gt;method_holder()-&gt;java_mirror());
 795       }
 796       break;
 797     }
 798   }
 799   return NULL;
 800 JVM_END
 801 
 802 
 803 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 804   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 805   oop mirror = NULL;
 806   BasicType t = name2type(utf);
 807   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 808     mirror = Universe::java_mirror(t);
 809   }
 810   if (mirror == NULL) {
 811     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 812   } else {
 813     return (jclass) JNIHandles::make_local(THREAD, mirror);
 814   }
 815 JVM_END
 816 
 817 
 818 // Returns a class loaded by the bootstrap class loader; or null
 819 // if not found.  ClassNotFoundException is not thrown.
 820 // FindClassFromBootLoader is exported to the launcher for windows.
 821 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 822                                               const char* name))
 823   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 824 
 825   // Java libraries should ensure that name is never null or illegal.
 826   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 827     // It&#39;s impossible to create this class;  the name cannot fit
 828     // into the constant pool.
 829     return NULL;
 830   }
 831   assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false), &quot;illegal UTF name&quot;);
 832 
 833   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 834   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 835   if (k == NULL) {
 836     return NULL;
 837   }
 838 
 839   if (log_is_enabled(Debug, class, resolve)) {
 840     trace_class_resolution(k);
 841   }
 842   return (jclass) JNIHandles::make_local(THREAD, k-&gt;java_mirror());
 843 JVM_END
 844 
 845 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 846 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 847                                           jboolean init, jobject loader,
 848                                           jclass caller))
 849   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 850 
 851   TempNewSymbol h_name =
 852        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 853                                            CHECK_NULL);
 854 
 855   oop loader_oop = JNIHandles::resolve(loader);
 856   oop from_class = JNIHandles::resolve(caller);
 857   oop protection_domain = NULL;
 858   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 859   // NPE. Put it in another way, the bootstrap class loader has all permission and
 860   // thus no checkPackageAccess equivalence in the VM class loader.
 861   // The caller is also passed as NULL by the java code if there is no security
 862   // manager to avoid the performance cost of getting the calling class.
 863   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 864     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 865   }
 866 
 867   Handle h_loader(THREAD, loader_oop);
 868   Handle h_prot(THREAD, protection_domain);
 869   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 870                                                h_prot, false, THREAD);
 871 
 872   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 873     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 874   }
 875   return result;
 876 JVM_END
 877 
 878 // Currently only called from the old verifier.
 879 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 880                                          jboolean init, jclass from))
 881   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 882   TempNewSymbol h_name =
 883        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 884                                            CHECK_NULL);
 885   oop from_class_oop = JNIHandles::resolve(from);
 886   Klass* from_class = (from_class_oop == NULL)
 887                            ? (Klass*)NULL
 888                            : java_lang_Class::as_Klass(from_class_oop);
 889   oop class_loader = NULL;
 890   oop protection_domain = NULL;
 891   if (from_class != NULL) {
 892     class_loader = from_class-&gt;class_loader();
 893     protection_domain = from_class-&gt;protection_domain();
 894   }
 895   Handle h_loader(THREAD, class_loader);
 896   Handle h_prot  (THREAD, protection_domain);
 897   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 898                                                h_prot, true, thread);
 899 
 900   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 901     // this function is generally only used for class loading during verification.
 902     ResourceMark rm;
 903     oop from_mirror = JNIHandles::resolve_non_null(from);
 904     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 905     const char * from_name = from_class-&gt;external_name();
 906 
 907     oop mirror = JNIHandles::resolve_non_null(result);
 908     Klass* to_class = java_lang_Class::as_Klass(mirror);
 909     const char * to = to_class-&gt;external_name();
 910     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 911   }
 912 
 913   return result;
 914 JVM_END
 915 
 916 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 917   if (loader.is_null()) {
 918     return;
 919   }
 920 
 921   // check whether the current caller thread holds the lock or not.
 922   // If not, increment the corresponding counter
 923   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 924       ObjectSynchronizer::owner_self) {
 925     counter-&gt;inc();
 926   }
 927 }
 928 
 929 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 930 static jclass jvm_define_class_common(const char *name,
 931                                       jobject loader, const jbyte *buf,
 932                                       jsize len, jobject pd, const char *source,
 933                                       TRAPS) {
 934   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 935 
 936   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 937   JavaThread* jt = (JavaThread*) THREAD;
 938 
 939   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 940                              ClassLoader::perf_define_appclass_selftime(),
 941                              ClassLoader::perf_define_appclasses(),
 942                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 943                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 944                              PerfClassTraceTime::DEFINE_CLASS);
 945 
 946   if (UsePerfData) {
 947     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 948   }
 949 
 950   // Class resolution will get the class name from the .class stream if the name is null.
 951   TempNewSymbol class_name = name == NULL ? NULL :
 952        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
 953                                            CHECK_NULL);
 954 
 955   ResourceMark rm(THREAD);
 956   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 957   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 958   if (UsePerfData) {
 959     is_lock_held_by_thread(class_loader,
 960                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 961                            THREAD);
 962   }
 963   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 964   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 965                                                    class_loader,
 966                                                    protection_domain,
 967                                                    &amp;st,
 968                                                    CHECK_NULL);
 969 
 970   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 971     trace_class_resolution(k);
 972   }
 973 
 974   return (jclass) JNIHandles::make_local(THREAD, k-&gt;java_mirror());
 975 }
 976 
 977 enum {
 978   NESTMATE              = java_lang_invoke_MemberName::MN_NESTMATE_CLASS,
 979   HIDDEN_CLASS          = java_lang_invoke_MemberName::MN_HIDDEN_CLASS,
 980   STRONG_LOADER_LINK    = java_lang_invoke_MemberName::MN_STRONG_LOADER_LINK,
 981   ACCESS_VM_ANNOTATIONS = java_lang_invoke_MemberName::MN_ACCESS_VM_ANNOTATIONS
 982 };
 983 
 984 /*
 985  * Define a class with the specified flags that indicates if it&#39;s a nestmate,
 986  * hidden, or strongly referenced from class loader.
 987  */
 988 static jclass jvm_lookup_define_class(jclass lookup, const char *name,
 989                                       const jbyte *buf, jsize len, jobject pd,
 990                                       jboolean init, int flags, jobject classData, TRAPS) {
 991   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 992   ResourceMark rm(THREAD);
 993 
 994   Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));
 995   // Lookup class must be a non-null instance
 996   if (lookup_k == NULL) {
 997     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
 998   }
 999   assert(lookup_k-&gt;is_instance_klass(), &quot;Lookup class must be an instance klass&quot;);
1000 
1001   Handle class_loader (THREAD, lookup_k-&gt;class_loader());
1002 
1003   bool is_nestmate = (flags &amp; NESTMATE) == NESTMATE;
1004   bool is_hidden = (flags &amp; HIDDEN_CLASS) == HIDDEN_CLASS;
1005   bool is_strong = (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK;
1006   bool vm_annotations = (flags &amp; ACCESS_VM_ANNOTATIONS) == ACCESS_VM_ANNOTATIONS;
1007 
1008   InstanceKlass* host_class = NULL;
1009   if (is_nestmate) {
1010     host_class = InstanceKlass::cast(lookup_k)-&gt;nest_host(CHECK_NULL);
1011   }
1012 
1013   log_info(class, nestmates)(&quot;LookupDefineClass: %s - %s%s, %s, %s, %s&quot;,
1014                              name,
1015                              is_nestmate ? &quot;with dynamic nest-host &quot; : &quot;non-nestmate&quot;,
1016                              is_nestmate ? host_class-&gt;external_name() : &quot;&quot;,
1017                              is_hidden ? &quot;hidden&quot; : &quot;not hidden&quot;,
1018                              is_strong ? &quot;strong&quot; : &quot;weak&quot;,
1019                              vm_annotations ? &quot;with vm annotations&quot; : &quot;without vm annotation&quot;);
1020 
1021   if (!is_hidden) {
1022     // classData is only applicable for hidden classes
1023     if (classData != NULL) {
1024       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;classData is only applicable for hidden classes&quot;);
1025     }
1026     if (is_nestmate) {
1027       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;dynamic nestmate is only applicable for hidden classes&quot;);
1028     }
1029     if (!is_strong) {
1030       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;an ordinary class must be strongly referenced by its defining loader&quot;);
1031     }
1032     if (vm_annotations) {
1033       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;vm annotations only allowed for hidden classes&quot;);
1034     }
1035     if (flags != STRONG_LOADER_LINK) {
1036       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1037                   err_msg(&quot;invalid flag 0x%x&quot;, flags));
1038     }
1039   }
1040 
1041   // Class resolution will get the class name from the .class stream if the name is null.
1042   TempNewSymbol class_name = name == NULL ? NULL :
1043        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
1044                                            CHECK_NULL);
1045 
1046   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
1047   const char* source = is_nestmate ? host_class-&gt;external_name() : &quot;__JVM_LookupDefineClass__&quot;;
1048   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
1049 
1050   Klass* defined_k;
1051   InstanceKlass* ik = NULL;
1052   if (!is_hidden) {
1053     defined_k = SystemDictionary::resolve_from_stream(class_name,
1054                                                       class_loader,
1055                                                       protection_domain,
1056                                                       &amp;st,
1057                                                       CHECK_NULL);
1058 
1059     if (log_is_enabled(Debug, class, resolve) &amp;&amp; defined_k != NULL) {
1060       trace_class_resolution(defined_k);
1061     }
1062     ik = InstanceKlass::cast(defined_k);
1063   } else { // hidden
1064     Handle classData_h(THREAD, JNIHandles::resolve(classData));
1065     ClassLoadInfo cl_info(protection_domain,
1066                           NULL, // unsafe_anonymous_host
1067                           NULL, // cp_patches
1068                           host_class,
1069                           classData_h,
1070                           is_hidden,
1071                           is_strong,
1072                           vm_annotations);
1073     defined_k = SystemDictionary::parse_stream(class_name,
1074                                                class_loader,
1075                                                &amp;st,
1076                                                cl_info,
1077                                                CHECK_NULL);
1078     if (defined_k == NULL) {
1079       THROW_MSG_0(vmSymbols::java_lang_Error(), &quot;Failure to define a hidden class&quot;);
1080     }
1081 
1082     ik = InstanceKlass::cast(defined_k);
1083 
1084     // The hidden class loader data has been artificially been kept alive to
1085     // this point. The mirror and any instances of this class have to keep
1086     // it alive afterwards.
1087     ik-&gt;class_loader_data()-&gt;dec_keep_alive();
1088 
1089     if (is_nestmate &amp;&amp; log_is_enabled(Debug, class, nestmates)) {
1090       ModuleEntry* module = ik-&gt;module();
1091       const char * module_name = module-&gt;is_named() ? module-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
1092       log_debug(class, nestmates)(&quot;Dynamic nestmate: %s/%s, nest_host %s, %s&quot;,
1093                                   module_name,
1094                                   ik-&gt;external_name(),
1095                                   host_class-&gt;external_name(),
1096                                   ik-&gt;is_hidden() ? &quot;is hidden&quot; : &quot;is not hidden&quot;);
1097     }
1098   }
1099   assert(Reflection::is_same_class_package(lookup_k, defined_k),
1100          &quot;lookup class and defined class are in different packages&quot;);
1101 
1102   if (init) {
1103     ik-&gt;initialize(CHECK_NULL);
1104   } else {
1105     ik-&gt;link_class(CHECK_NULL);
1106   }
1107 
1108   return (jclass) JNIHandles::make_local(THREAD, defined_k-&gt;java_mirror());
1109 }
1110 
1111 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
1112   JVMWrapper(&quot;JVM_DefineClass&quot;);
1113 
1114   return jvm_define_class_common(name, loader, buf, len, pd, NULL, THREAD);
1115 JVM_END
1116 
1117 /*
1118  * Define a class with the specified lookup class.
1119  *  lookup:  Lookup class
1120  *  name:    the name of the class
1121  *  buf:     class bytes
1122  *  len:     length of class bytes
1123  *  pd:      protection domain
1124  *  init:    initialize the class
1125  *  flags:   properties of the class
1126  *  classData: private static pre-initialized field
1127  */
1128 JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
1129           jsize len, jobject pd, jboolean initialize, int flags, jobject classData))
1130   JVMWrapper(&quot;JVM_LookupDefineClass&quot;);
1131 
1132   if (lookup == NULL) {
1133     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
1134   }
1135 
1136   assert(buf != NULL, &quot;buf must not be NULL&quot;);
1137 
1138   return jvm_lookup_define_class(lookup, name, buf, len, pd, initialize, flags, classData, THREAD);
1139 JVM_END
1140 
1141 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
1142   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
1143 
1144   return jvm_define_class_common(name, loader, buf, len, pd, source, THREAD);
1145 JVM_END
1146 
1147 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1148   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1149   ResourceMark rm(THREAD);
1150 
1151   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1152   char* str = java_lang_String::as_utf8_string(h_name());
1153 
1154   // Sanity check, don&#39;t expect null
1155   if (str == NULL) return NULL;
1156 
1157   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1158   char* p = (char*)str;
1159   while (*p != &#39;\0&#39;) {
1160     if (*p == &#39;.&#39;) {
1161       *p = &#39;/&#39;;
1162     }
1163     p++;
1164   }
1165 
1166   const int str_len = (int)(p - str);
1167   if (str_len &gt; Symbol::max_length()) {
1168     // It&#39;s impossible to create this class;  the name cannot fit
1169     // into the constant pool.
1170     return NULL;
1171   }
1172   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1173 
1174   // Security Note:
1175   //   The Java level wrapper will perform the necessary security check allowing
1176   //   us to pass the NULL as the initiating class loader.
1177   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1178   if (UsePerfData) {
1179     is_lock_held_by_thread(h_loader,
1180                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1181                            THREAD);
1182   }
1183 
1184   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1185                                                               h_loader,
1186                                                               Handle(),
1187                                                               CHECK_NULL);
1188 #if INCLUDE_CDS
1189   if (k == NULL) {
1190     // If the class is not already loaded, try to see if it&#39;s in the shared
1191     // archive for the current classloader (h_loader).
1192     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1193   }
1194 #endif
1195   return (k == NULL) ? NULL :
1196             (jclass) JNIHandles::make_local(THREAD, k-&gt;java_mirror());
1197 JVM_END
1198 
1199 // Module support //////////////////////////////////////////////////////////////////////////////
1200 
1201 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1202                                  jstring location, jobjectArray packages))
1203   JVMWrapper(&quot;JVM_DefineModule&quot;);
1204   Modules::define_module(module, is_open, version, location, packages, CHECK);
1205 JVM_END
1206 
1207 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1208   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1209   Modules::set_bootloader_unnamed_module(module, CHECK);
1210 JVM_END
1211 
1212 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module))
1213   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1214   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1215 JVM_END
1216 
1217 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package))
1218   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1219   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1220 JVM_END
1221 
1222 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package))
1223   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1224   Modules::add_module_exports(from_module, package, NULL, CHECK);
1225 JVM_END
1226 
1227 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1228   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1229   Modules::add_reads_module(from_module, source_module, CHECK);
1230 JVM_END
1231 
1232 // Reflection support //////////////////////////////////////////////////////////////////////////////
1233 
1234 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1235   assert (cls != NULL, &quot;illegal class&quot;);
1236   JVMWrapper(&quot;JVM_InitClassName&quot;);
1237   JvmtiVMObjectAllocEventCollector oam;
1238   ResourceMark rm(THREAD);
1239   HandleMark hm(THREAD);
1240   Handle java_class(THREAD, JNIHandles::resolve(cls));
1241   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1242   return (jstring) JNIHandles::make_local(THREAD, result);
1243 JVM_END
1244 
1245 
1246 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1247   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1248   JvmtiVMObjectAllocEventCollector oam;
1249   oop mirror = JNIHandles::resolve_non_null(cls);
1250 
1251   // Special handling for primitive objects
1252   if (java_lang_Class::is_primitive(mirror)) {
1253     // Primitive objects does not have any interfaces
1254     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1255     return (jobjectArray) JNIHandles::make_local(THREAD, r);
1256   }
1257 
1258   Klass* klass = java_lang_Class::as_Klass(mirror);
1259   // Figure size of result array
1260   int size;
1261   if (klass-&gt;is_instance_klass()) {
1262     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();
1263   } else {
1264     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1265     size = 2;
1266   }
1267 
1268   // Allocate result array
1269   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1270   objArrayHandle result (THREAD, r);
1271   // Fill in result
1272   if (klass-&gt;is_instance_klass()) {
1273     // Regular instance klass, fill in all local interfaces
1274     for (int index = 0; index &lt; size; index++) {
1275       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);
1276       result-&gt;obj_at_put(index, k-&gt;java_mirror());
1277     }
1278   } else {
1279     // All arrays implement java.lang.Cloneable and java.io.Serializable
1280     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1281     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1282   }
1283   return (jobjectArray) JNIHandles::make_local(THREAD, result());
1284 JVM_END
1285 
1286 
1287 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1288   JVMWrapper(&quot;JVM_IsInterface&quot;);
1289   oop mirror = JNIHandles::resolve_non_null(cls);
1290   if (java_lang_Class::is_primitive(mirror)) {
1291     return JNI_FALSE;
1292   }
1293   Klass* k = java_lang_Class::as_Klass(mirror);
1294   jboolean result = k-&gt;is_interface();
1295   assert(!result || k-&gt;is_instance_klass(),
1296          &quot;all interfaces are instance types&quot;);
1297   // The compiler intrinsic for isInterface tests the
1298   // Klass::_access_flags bits in the same way.
1299   return result;
1300 JVM_END
1301 
1302 JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))
1303   JVMWrapper(&quot;JVM_IsHiddenClass&quot;);
1304   oop mirror = JNIHandles::resolve_non_null(cls);
1305   if (java_lang_Class::is_primitive(mirror)) {
1306     return JNI_FALSE;
1307   }
1308   Klass* k = java_lang_Class::as_Klass(mirror);
1309   return k-&gt;is_hidden();
1310 JVM_END
1311 
1312 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1313   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1314   JvmtiVMObjectAllocEventCollector oam;
<a name="2" id="anc2"></a><span class="line-modified">1315   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">1316   if (java_lang_Class::is_primitive(mirror)) {</span>
1317     // There are no signers for primitive types
1318     return NULL;
1319   }
1320 
<a name="3" id="anc3"></a><span class="line-modified">1321   objArrayHandle signers(THREAD, java_lang_Class::signers(mirror));</span>
1322 
1323   // If there are no signers set in the class, or if the class
1324   // is an array, return NULL.
1325   if (signers == NULL) return NULL;
1326 
1327   // copy of the signers array
1328   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1329   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1330   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1331     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1332   }
1333 
1334   // return the copy
1335   return (jobjectArray) JNIHandles::make_local(THREAD, signers_copy);
1336 JVM_END
1337 
1338 
1339 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1340   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
<a name="4" id="anc4"></a><span class="line-modified">1341   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">1342   if (!java_lang_Class::is_primitive(mirror)) {</span>
1343     // This call is ignored for primitive types and arrays.
1344     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1345     // be called with an array.  Only the bootstrap loader creates arrays.
<a name="5" id="anc5"></a><span class="line-modified">1346     Klass* k = java_lang_Class::as_Klass(mirror);</span>
1347     if (k-&gt;is_instance_klass()) {
1348       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1349     }
1350   }
1351 JVM_END
1352 
1353 
1354 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1355   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
<a name="6" id="anc6"></a><span class="line-modified">1356   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">1357   if (mirror == NULL) {</span>
1358     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1359   }
1360 
<a name="7" id="anc7"></a><span class="line-modified">1361   if (java_lang_Class::is_primitive(mirror)) {</span>
1362     // Primitive types does not have a protection domain.
1363     return NULL;
1364   }
1365 
<a name="8" id="anc8"></a><span class="line-modified">1366   oop pd = java_lang_Class::protection_domain(mirror);</span>
1367   return (jobject) JNIHandles::make_local(THREAD, pd);
1368 JVM_END
1369 
1370 
1371 // Returns the inherited_access_control_context field of the running thread.
1372 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1373   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1374   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1375   return JNIHandles::make_local(THREAD, result);
1376 JVM_END
1377 
1378 class RegisterArrayForGC {
1379  private:
1380   JavaThread *_thread;
1381  public:
1382   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1383     _thread = thread;
1384     _thread-&gt;register_array_for_gc(array);
1385   }
1386 
1387   ~RegisterArrayForGC() {
1388     _thread-&gt;register_array_for_gc(NULL);
1389   }
1390 };
1391 
1392 
1393 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1394   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1395   if (!UsePrivilegedStack) return NULL;
1396 
1397   ResourceMark rm(THREAD);
1398   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1399   JvmtiVMObjectAllocEventCollector oam;
1400 
1401   // count the protection domains on the execution stack. We collapse
1402   // duplicate consecutive protection domains into a single one, as
1403   // well as stopping when we hit a privileged frame.
1404 
1405   oop previous_protection_domain = NULL;
1406   Handle privileged_context(thread, NULL);
1407   bool is_privileged = false;
1408   oop protection_domain = NULL;
1409 
1410   // Iterate through Java frames
1411   vframeStream vfst(thread);
1412   for(; !vfst.at_end(); vfst.next()) {
1413     // get method of frame
1414     Method* method = vfst.method();
1415 
1416     // stop at the first privileged frame
1417     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1418       method-&gt;name() == vmSymbols::executePrivileged_name())
1419     {
1420       // this frame is privileged
1421       is_privileged = true;
1422 
1423       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1424 
1425       StackValueCollection* locals = priv-&gt;locals();
1426       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1427       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1428       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1429       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1430       privileged_context    = ctx_sv-&gt;get_obj();
1431       Handle caller         = clr_sv-&gt;get_obj();
1432 
1433       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1434       protection_domain  = caller_klass-&gt;protection_domain();
1435     } else {
1436       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1437     }
1438 
1439     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1440       local_array-&gt;push(protection_domain);
1441       previous_protection_domain = protection_domain;
1442     }
1443 
1444     if (is_privileged) break;
1445   }
1446 
1447 
1448   // either all the domains on the stack were system domains, or
1449   // we had a privileged system domain
1450   if (local_array-&gt;is_empty()) {
1451     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1452 
1453     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1454     return JNIHandles::make_local(THREAD, result);
1455   }
1456 
1457   // the resource area must be registered in case of a gc
1458   RegisterArrayForGC ragc(thread, local_array);
1459   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1460                                                  local_array-&gt;length(), CHECK_NULL);
1461   objArrayHandle h_context(thread, context);
1462   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1463     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1464   }
1465 
1466   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1467 
1468   return JNIHandles::make_local(THREAD, result);
1469 JVM_END
1470 
1471 
1472 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1473   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1474   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1475   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1476 JVM_END
1477 
1478 
1479 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1480   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1481   oop mirror = JNIHandles::resolve_non_null(cls);
1482   return (jboolean) java_lang_Class::is_primitive(mirror);
1483 JVM_END
1484 
1485 
1486 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1487   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
<a name="9" id="anc9"></a><span class="line-modified">1488   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">1489   if (java_lang_Class::is_primitive(mirror)) {</span>
1490     // Primitive type
1491     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1492   }
1493 
<a name="10" id="anc10"></a><span class="line-modified">1494   Klass* k = java_lang_Class::as_Klass(mirror);</span>
1495   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1496   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1497   return k-&gt;modifier_flags();
1498 JVM_END
1499 
1500 
1501 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1502 
1503 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1504   JvmtiVMObjectAllocEventCollector oam;
1505   // ofClass is a reference to a java_lang_Class object. The mirror object
1506   // of an InstanceKlass
<a name="11" id="anc11"></a><span class="line-modified">1507   oop ofMirror = JNIHandles::resolve_non_null(ofClass);</span>
<span class="line-modified">1508   if (java_lang_Class::is_primitive(ofMirror) ||</span>
<span class="line-modified">1509       ! java_lang_Class::as_Klass(ofMirror)-&gt;is_instance_klass()) {</span>
1510     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1511     return (jobjectArray)JNIHandles::make_local(THREAD, result);
1512   }
1513 
<a name="12" id="anc12"></a><span class="line-modified">1514   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));</span>
1515   InnerClassesIterator iter(k);
1516 
1517   if (iter.length() == 0) {
1518     // Neither an inner nor outer class
1519     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1520     return (jobjectArray)JNIHandles::make_local(THREAD, result);
1521   }
1522 
1523   // find inner class info
1524   constantPoolHandle cp(thread, k-&gt;constants());
1525   int length = iter.length();
1526 
1527   // Allocate temp. result array
1528   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1529   objArrayHandle result (THREAD, r);
1530   int members = 0;
1531 
1532   for (; !iter.done(); iter.next()) {
1533     int ioff = iter.inner_class_info_index();
1534     int ooff = iter.outer_class_info_index();
1535 
1536     if (ioff != 0 &amp;&amp; ooff != 0) {
1537       // Check to see if the name matches the class we&#39;re looking for
1538       // before attempting to find the class.
1539       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1540         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1541         if (outer_klass == k) {
1542            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1543            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1544 
1545            // Throws an exception if outer klass has not declared k as
1546            // an inner klass
1547            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1548 
1549            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1550            members++;
1551         }
1552       }
1553     }
1554   }
1555 
1556   if (members != length) {
1557     // Return array of right length
1558     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1559     for(int i = 0; i &lt; members; i++) {
1560       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1561     }
1562     return (jobjectArray)JNIHandles::make_local(THREAD, res);
1563   }
1564 
1565   return (jobjectArray)JNIHandles::make_local(THREAD, result());
1566 JVM_END
1567 
1568 
1569 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1570 {
1571   // ofClass is a reference to a java_lang_Class object.
<a name="13" id="anc13"></a><span class="line-modified">1572   oop ofMirror = JNIHandles::resolve_non_null(ofClass);</span>
<span class="line-modified">1573   if (java_lang_Class::is_primitive(ofMirror)) {</span>
<span class="line-added">1574     return NULL;</span>
<span class="line-added">1575   }</span>
<span class="line-added">1576   Klass* klass = java_lang_Class::as_Klass(ofMirror);</span>
<span class="line-added">1577   if (!klass-&gt;is_instance_klass()) {</span>
1578     return NULL;
1579   }
1580 
1581   bool inner_is_member = false;
1582   Klass* outer_klass
<a name="14" id="anc14"></a><span class="line-modified">1583     = InstanceKlass::cast(klass)-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);</span>

1584   if (outer_klass == NULL)  return NULL;  // already a top-level class
1585   if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
1586   return (jclass) JNIHandles::make_local(THREAD, outer_klass-&gt;java_mirror());
1587 }
1588 JVM_END
1589 
1590 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1591 {
1592   oop mirror = JNIHandles::resolve_non_null(cls);
<a name="15" id="anc15"></a><span class="line-modified">1593   if (java_lang_Class::is_primitive(mirror)) {</span>

1594     return NULL;
1595   }
<a name="16" id="anc16"></a><span class="line-modified">1596   Klass* klass = java_lang_Class::as_Klass(mirror);</span>
<span class="line-added">1597   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added">1598     return NULL;</span>
<span class="line-added">1599   }</span>
<span class="line-added">1600   InstanceKlass* k = InstanceKlass::cast(klass);</span>
1601   int ooff = 0, noff = 0;
1602   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1603     if (noff != 0) {
1604       constantPoolHandle i_cp(thread, k-&gt;constants());
1605       Symbol* name = i_cp-&gt;symbol_at(noff);
1606       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1607       return (jstring) JNIHandles::make_local(THREAD, str());
1608     }
1609   }
1610   return NULL;
1611 }
1612 JVM_END
1613 
1614 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1615   assert (cls != NULL, &quot;illegal class&quot;);
1616   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1617   JvmtiVMObjectAllocEventCollector oam;
1618   ResourceMark rm(THREAD);
<a name="17" id="anc17"></a><span class="line-added">1619   oop mirror = JNIHandles::resolve_non_null(cls);</span>
1620   // Return null for arrays and primatives
<a name="18" id="anc18"></a><span class="line-modified">1621   if (!java_lang_Class::is_primitive(mirror)) {</span>
<span class="line-modified">1622     Klass* k = java_lang_Class::as_Klass(mirror);</span>
1623     if (k-&gt;is_instance_klass()) {
1624       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1625       if (sym == NULL) return NULL;
1626       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1627       return (jstring) JNIHandles::make_local(THREAD, str());
1628     }
1629   }
1630   return NULL;
1631 JVM_END
1632 
1633 
1634 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1635   assert (cls != NULL, &quot;illegal class&quot;);
1636   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
<a name="19" id="anc19"></a><span class="line-modified">1637   oop mirror = JNIHandles::resolve_non_null(cls);</span>
1638   // Return null for arrays and primitives
<a name="20" id="anc20"></a><span class="line-modified">1639   if (!java_lang_Class::is_primitive(mirror)) {</span>
<span class="line-modified">1640     Klass* k = java_lang_Class::as_Klass(mirror);</span>
1641     if (k-&gt;is_instance_klass()) {
1642       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1643       return (jbyteArray) JNIHandles::make_local(THREAD, a);
1644     }
1645   }
1646   return NULL;
1647 JVM_END
1648 
1649 
1650 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1651   // some of this code was adapted from from jni_FromReflectedField
1652 
1653   oop reflected = JNIHandles::resolve_non_null(field);
1654   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1655   Klass* k    = java_lang_Class::as_Klass(mirror);
1656   int slot      = java_lang_reflect_Field::slot(reflected);
1657   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1658 
1659   InstanceKlass* ik = InstanceKlass::cast(k);
1660   intptr_t offset = ik-&gt;field_offset(slot);
1661 
1662   if (modifiers &amp; JVM_ACC_STATIC) {
1663     // for static fields we only look in the current class
1664     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1665       assert(false, &quot;cannot find static field&quot;);
1666       return false;
1667     }
1668   } else {
1669     // for instance fields we start with the current class and work
1670     // our way up through the superclass chain
1671     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1672       assert(false, &quot;cannot find instance field&quot;);
1673       return false;
1674     }
1675   }
1676   return true;
1677 }
1678 
1679 static Method* jvm_get_method_common(jobject method) {
1680   // some of this code was adapted from from jni_FromReflectedMethod
1681 
1682   oop reflected = JNIHandles::resolve_non_null(method);
1683   oop mirror    = NULL;
1684   int slot      = 0;
1685 
1686   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1687     mirror = java_lang_reflect_Constructor::clazz(reflected);
1688     slot   = java_lang_reflect_Constructor::slot(reflected);
1689   } else {
1690     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1691            &quot;wrong type&quot;);
1692     mirror = java_lang_reflect_Method::clazz(reflected);
1693     slot   = java_lang_reflect_Method::slot(reflected);
1694   }
1695   Klass* k = java_lang_Class::as_Klass(mirror);
1696 
1697   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1698   assert(m != NULL, &quot;cannot find method&quot;);
1699   return m;  // caller has to deal with NULL in product mode
1700 }
1701 
1702 /* Type use annotations support (JDK 1.8) */
1703 
1704 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1705   assert (cls != NULL, &quot;illegal class&quot;);
1706   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1707   ResourceMark rm(THREAD);
1708   // Return null for arrays and primitives
1709   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1710     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1711     if (k-&gt;is_instance_klass()) {
1712       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1713       if (type_annotations != NULL) {
1714         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1715         return (jbyteArray) JNIHandles::make_local(THREAD, a);
1716       }
1717     }
1718   }
1719   return NULL;
1720 JVM_END
1721 
1722 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1723   assert (method != NULL, &quot;illegal method&quot;);
1724   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1725 
1726   // method is a handle to a java.lang.reflect.Method object
1727   Method* m = jvm_get_method_common(method);
1728   if (m == NULL) {
1729     return NULL;
1730   }
1731 
1732   AnnotationArray* type_annotations = m-&gt;type_annotations();
1733   if (type_annotations != NULL) {
1734     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1735     return (jbyteArray) JNIHandles::make_local(THREAD, a);
1736   }
1737 
1738   return NULL;
1739 JVM_END
1740 
1741 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1742   assert (field != NULL, &quot;illegal field&quot;);
1743   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1744 
1745   fieldDescriptor fd;
1746   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1747   if (!gotFd) {
1748     return NULL;
1749   }
1750 
1751   return (jbyteArray) JNIHandles::make_local(THREAD, Annotations::make_java_array(fd.type_annotations(), THREAD));
1752 JVM_END
1753 
1754 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1755   if (!cp-&gt;is_within_bounds(index)) {
1756     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1757   }
1758 }
1759 
1760 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1761 {
1762   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1763   // method is a handle to a java.lang.reflect.Method object
1764   Method* method_ptr = jvm_get_method_common(method);
1765   methodHandle mh (THREAD, method_ptr);
1766   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1767   const int num_params = mh-&gt;method_parameters_length();
1768 
1769   if (num_params &lt; 0) {
1770     // A -1 return value from method_parameters_length means there is no
1771     // parameter data.  Return null to indicate this to the reflection
1772     // API.
1773     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1774     return (jobjectArray)NULL;
1775   } else {
1776     // Otherwise, we return something up to reflection, even if it is
1777     // a zero-length array.  Why?  Because in some cases this can
1778     // trigger a MalformedParametersException.
1779 
1780     // make sure all the symbols are properly formatted
1781     for (int i = 0; i &lt; num_params; i++) {
1782       MethodParametersElement* params = mh-&gt;method_parameters_start();
1783       int index = params[i].name_cp_index;
1784       constantPoolHandle cp(THREAD, mh-&gt;constants());
1785       bounds_check(cp, index, CHECK_NULL);
1786 
1787       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1788         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1789                     &quot;Wrong type at constant pool index&quot;);
1790       }
1791 
1792     }
1793 
1794     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1795     objArrayHandle result (THREAD, result_oop);
1796 
1797     for (int i = 0; i &lt; num_params; i++) {
1798       MethodParametersElement* params = mh-&gt;method_parameters_start();
1799       // For a 0 index, give a NULL symbol
1800       Symbol* sym = 0 != params[i].name_cp_index ?
1801         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1802       int flags = params[i].flags;
1803       oop param = Reflection::new_parameter(reflected_method, i, sym,
1804                                             flags, CHECK_NULL);
1805       result-&gt;obj_at_put(i, param);
1806     }
1807     return (jobjectArray)JNIHandles::make_local(THREAD, result());
1808   }
1809 }
1810 JVM_END
1811 
1812 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1813 
1814 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1815 {
1816   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1817   JvmtiVMObjectAllocEventCollector oam;
1818 
<a name="21" id="anc21"></a><span class="line-added">1819   oop ofMirror = JNIHandles::resolve_non_null(ofClass);</span>
1820   // Exclude primitive types and array types
<a name="22" id="anc22"></a><span class="line-modified">1821   if (java_lang_Class::is_primitive(ofMirror) ||</span>
<span class="line-modified">1822       java_lang_Class::as_Klass(ofMirror)-&gt;is_array_klass()) {</span>
1823     // Return empty array
1824     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1825     return (jobjectArray) JNIHandles::make_local(THREAD, res);
1826   }
1827 
<a name="23" id="anc23"></a><span class="line-modified">1828   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));</span>
1829   constantPoolHandle cp(THREAD, k-&gt;constants());
1830 
1831   // Ensure class is linked
1832   k-&gt;link_class(CHECK_NULL);
1833 
1834   // Allocate result
1835   int num_fields;
1836 
1837   if (publicOnly) {
1838     num_fields = 0;
1839     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1840       if (fs.access_flags().is_public()) ++num_fields;
1841     }
1842   } else {
1843     num_fields = k-&gt;java_fields_count();
1844   }
1845 
1846   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1847   objArrayHandle result (THREAD, r);
1848 
1849   int out_idx = 0;
1850   fieldDescriptor fd;
1851   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1852     if (!publicOnly || fs.access_flags().is_public()) {
1853       fd.reinitialize(k, fs.index());
1854       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1855       result-&gt;obj_at_put(out_idx, field);
1856       ++out_idx;
1857     }
1858   }
1859   assert(out_idx == num_fields, &quot;just checking&quot;);
1860   return (jobjectArray) JNIHandles::make_local(THREAD, result());
1861 }
1862 JVM_END
1863 
1864 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1865 {
1866   JVMWrapper(&quot;JVM_IsRecord&quot;);
1867   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1868   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1869     InstanceKlass* ik = InstanceKlass::cast(k);
1870     return ik-&gt;is_record();
1871   } else {
1872     return false;
1873   }
1874 }
1875 JVM_END
1876 
1877 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1878 {
1879   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1880   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1881   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1882   InstanceKlass* ik = InstanceKlass::cast(c);
1883 
1884   if (ik-&gt;is_record()) {
1885     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1886     assert(components != NULL, &quot;components should not be NULL&quot;);
1887     {
1888       JvmtiVMObjectAllocEventCollector oam;
1889       constantPoolHandle cp(THREAD, ik-&gt;constants());
1890       int length = components-&gt;length();
1891       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1892       objArrayOop record_components =
1893         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1894       objArrayHandle components_h (THREAD, record_components);
1895 
1896       for (int x = 0; x &lt; length; x++) {
1897         RecordComponent* component = components-&gt;at(x);
1898         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1899         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1900         components_h-&gt;obj_at_put(x, component_oop);
1901       }
1902       return (jobjectArray)JNIHandles::make_local(THREAD, components_h());
1903     }
1904   }
1905 
1906   // Return empty array if ofClass is not a record.
1907   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1908   return (jobjectArray)JNIHandles::make_local(THREAD, result);
1909 }
1910 JVM_END
1911 
1912 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1913   if (want_constructor) {
1914     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1915   } else {
1916     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1917   }
1918 }
1919 
1920 static jobjectArray get_class_declared_methods_helper(
1921                                   JNIEnv *env,
1922                                   jclass ofClass, jboolean publicOnly,
1923                                   bool want_constructor,
1924                                   Klass* klass, TRAPS) {
1925 
1926   JvmtiVMObjectAllocEventCollector oam;
1927 
<a name="24" id="anc24"></a><span class="line-added">1928   oop ofMirror = JNIHandles::resolve_non_null(ofClass);</span>
1929   // Exclude primitive types and array types
<a name="25" id="anc25"></a><span class="line-modified">1930   if (java_lang_Class::is_primitive(ofMirror)</span>
<span class="line-modified">1931       || java_lang_Class::as_Klass(ofMirror)-&gt;is_array_klass()) {</span>
1932     // Return empty array
1933     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1934     return (jobjectArray) JNIHandles::make_local(THREAD, res);
1935   }
1936 
<a name="26" id="anc26"></a><span class="line-modified">1937   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));</span>
1938 
1939   // Ensure class is linked
1940   k-&gt;link_class(CHECK_NULL);
1941 
1942   Array&lt;Method*&gt;* methods = k-&gt;methods();
1943   int methods_length = methods-&gt;length();
1944 
1945   // Save original method_idnum in case of redefinition, which can change
1946   // the idnum of obsolete methods.  The new method will have the same idnum
1947   // but if we refresh the methods array, the counts will be wrong.
1948   ResourceMark rm(THREAD);
1949   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1950   int num_methods = 0;
1951 
1952   for (int i = 0; i &lt; methods_length; i++) {
1953     methodHandle method(THREAD, methods-&gt;at(i));
1954     if (select_method(method, want_constructor)) {
1955       if (!publicOnly || method-&gt;is_public()) {
1956         idnums-&gt;push(method-&gt;method_idnum());
1957         ++num_methods;
1958       }
1959     }
1960   }
1961 
1962   // Allocate result
1963   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1964   objArrayHandle result (THREAD, r);
1965 
1966   // Now just put the methods that we selected above, but go by their idnum
1967   // in case of redefinition.  The methods can be redefined at any safepoint,
1968   // so above when allocating the oop array and below when creating reflect
1969   // objects.
1970   for (int i = 0; i &lt; num_methods; i++) {
1971     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1972     if (method.is_null()) {
1973       // Method may have been deleted and seems this API can handle null
1974       // Otherwise should probably put a method that throws NSME
1975       result-&gt;obj_at_put(i, NULL);
1976     } else {
1977       oop m;
1978       if (want_constructor) {
1979         m = Reflection::new_constructor(method, CHECK_NULL);
1980       } else {
1981         m = Reflection::new_method(method, false, CHECK_NULL);
1982       }
1983       result-&gt;obj_at_put(i, m);
1984     }
1985   }
1986 
1987   return (jobjectArray) JNIHandles::make_local(THREAD, result());
1988 }
1989 
1990 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1991 {
1992   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1993   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1994                                            /*want_constructor*/ false,
1995                                            SystemDictionary::reflect_Method_klass(), THREAD);
1996 }
1997 JVM_END
1998 
1999 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2000 {
2001   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
2002   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2003                                            /*want_constructor*/ true,
2004                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
2005 }
2006 JVM_END
2007 
2008 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
2009 {
2010   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
<a name="27" id="anc27"></a><span class="line-modified">2011   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">2012   if (java_lang_Class::is_primitive(mirror)) {</span>
2013     // Primitive type
2014     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
2015   }
2016 
<a name="28" id="anc28"></a><span class="line-modified">2017   Klass* k = java_lang_Class::as_Klass(mirror);</span>
2018   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
2019 }
2020 JVM_END
2021 
2022 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
2023 {
2024   JVMWrapper(&quot;JVM_AreNestMates&quot;);
2025   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2026   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2027   InstanceKlass* ck = InstanceKlass::cast(c);
2028   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
2029   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
2030   InstanceKlass* mk = InstanceKlass::cast(m);
2031   return ck-&gt;has_nestmate_access_to(mk, THREAD);
2032 }
2033 JVM_END
2034 
2035 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
2036 {
2037   // current is not a primitive or array class
2038   JVMWrapper(&quot;JVM_GetNestHost&quot;);
2039   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2040   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2041   InstanceKlass* ck = InstanceKlass::cast(c);
2042   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2043   return (jclass) (host == NULL ? NULL :
2044                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
2045 }
2046 JVM_END
2047 
2048 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
2049 {
2050   // current is not a primitive or array class
2051   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
2052   ResourceMark rm(THREAD);
2053   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2054   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2055   InstanceKlass* ck = InstanceKlass::cast(c);
2056   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2057 
2058   log_trace(class, nestmates)(&quot;Calling GetNestMembers for type %s with nest-host %s&quot;,
2059                               ck-&gt;external_name(), host-&gt;external_name());
2060   {
2061     JvmtiVMObjectAllocEventCollector oam;
2062     Array&lt;u2&gt;* members = host-&gt;nest_members();
2063     int length = members == NULL ? 0 : members-&gt;length();
2064 
2065     log_trace(class, nestmates)(&quot; - host has %d listed nest members&quot;, length);
2066 
2067     // nest host is first in the array so make it one bigger
2068     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2069                                              length + 1, CHECK_NULL);
2070     objArrayHandle result(THREAD, r);
2071     result-&gt;obj_at_put(0, host-&gt;java_mirror());
2072     if (length != 0) {
2073       int count = 0;
2074       for (int i = 0; i &lt; length; i++) {
2075         int cp_index = members-&gt;at(i);
2076         Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, THREAD);
2077         if (HAS_PENDING_EXCEPTION) {
2078           if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {
2079             return NULL; // propagate VMEs
2080           }
2081           if (log_is_enabled(Trace, class, nestmates)) {
2082             stringStream ss;
2083             char* target_member_class = host-&gt;constants()-&gt;klass_name_at(cp_index)-&gt;as_C_string();
2084             ss.print(&quot; - resolution of nest member %s failed: &quot;, target_member_class);
2085             java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);
2086             log_trace(class, nestmates)(&quot;%s&quot;, ss.as_string());
2087           }
2088           CLEAR_PENDING_EXCEPTION;
2089           continue;
2090         }
2091         if (k-&gt;is_instance_klass()) {
2092           InstanceKlass* ik = InstanceKlass::cast(k);
2093           InstanceKlass* nest_host_k = ik-&gt;nest_host(CHECK_NULL);
2094           if (nest_host_k == host) {
2095             result-&gt;obj_at_put(count+1, k-&gt;java_mirror());
2096             count++;
2097             log_trace(class, nestmates)(&quot; - [%d] = %s&quot;, count, ik-&gt;external_name());
2098           } else {
2099             log_trace(class, nestmates)(&quot; - skipping member %s with different host %s&quot;,
2100                                         ik-&gt;external_name(), nest_host_k-&gt;external_name());
2101           }
2102         } else {
2103           log_trace(class, nestmates)(&quot; - skipping member %s that is not an instance class&quot;,
2104                                       k-&gt;external_name());
2105         }
2106       }
2107       if (count &lt; length) {
2108         // we had invalid entries so we need to compact the array
2109         log_trace(class, nestmates)(&quot; - compacting array from length %d to %d&quot;,
2110                                     length + 1, count + 1);
2111 
2112         objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2113                                                   count + 1, CHECK_NULL);
2114         objArrayHandle result2(THREAD, r2);
2115         for (int i = 0; i &lt; count + 1; i++) {
2116           result2-&gt;obj_at_put(i, result-&gt;obj_at(i));
2117         }
2118         return (jobjectArray)JNIHandles::make_local(THREAD, result2());
2119       }
2120     }
2121     else {
2122       assert(host == ck || ck-&gt;is_hidden(), &quot;must be singleton nest or dynamic nestmate&quot;);
2123     }
2124     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2125   }
2126 }
2127 JVM_END
2128 
2129 JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))
2130 {
2131   JVMWrapper(&quot;JVM_GetPermittedSubclasses&quot;);
<a name="29" id="anc29"></a><span class="line-modified">2132   oop mirror = JNIHandles::resolve_non_null(current);</span>
<span class="line-modified">2133   assert(!java_lang_Class::is_primitive(mirror), &quot;should not be&quot;);</span>
<span class="line-added">2134   Klass* c = java_lang_Class::as_Klass(mirror);</span>
2135   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2136   InstanceKlass* ik = InstanceKlass::cast(c);
2137   {
2138     JvmtiVMObjectAllocEventCollector oam;
2139     Array&lt;u2&gt;* subclasses = ik-&gt;permitted_subclasses();
2140     int length = subclasses == NULL ? 0 : subclasses-&gt;length();
2141     objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
2142                                              length, CHECK_NULL);
2143     objArrayHandle result(THREAD, r);
2144     for (int i = 0; i &lt; length; i++) {
2145       int cp_index = subclasses-&gt;at(i);
2146       // This returns &lt;package-name&gt;/&lt;class-name&gt;.
2147       Symbol* klass_name = ik-&gt;constants()-&gt;klass_name_at(cp_index);
2148       assert(klass_name != NULL, &quot;Unexpected null klass_name&quot;);
2149       Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2150       result-&gt;obj_at_put(i, perm_subtype_h());
2151     }
2152     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2153   }
2154 }
2155 JVM_END
2156 
2157 // Constant pool access //////////////////////////////////////////////////////////
2158 
2159 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
2160 {
2161   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
2162   JvmtiVMObjectAllocEventCollector oam;
<a name="30" id="anc30"></a><span class="line-modified">2163   oop mirror = JNIHandles::resolve_non_null(cls);</span>
2164   // Return null for primitives and arrays
<a name="31" id="anc31"></a><span class="line-modified">2165   if (!java_lang_Class::is_primitive(mirror)) {</span>
<span class="line-modified">2166     Klass* k = java_lang_Class::as_Klass(mirror);</span>
2167     if (k-&gt;is_instance_klass()) {
2168       InstanceKlass* k_h = InstanceKlass::cast(k);
2169       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
2170       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
2171       return JNIHandles::make_local(THREAD, jcp());
2172     }
2173   }
2174   return NULL;
2175 }
2176 JVM_END
2177 
2178 
2179 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
2180 {
2181   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
2182   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2183   return cp-&gt;length();
2184 }
2185 JVM_END
2186 
2187 
2188 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2189 {
2190   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
2191   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2192   bounds_check(cp, index, CHECK_NULL);
2193   constantTag tag = cp-&gt;tag_at(index);
2194   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2195     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2196   }
2197   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
2198   return (jclass) JNIHandles::make_local(THREAD, k-&gt;java_mirror());
2199 }
2200 JVM_END
2201 
2202 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2203 {
2204   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
2205   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2206   bounds_check(cp, index, CHECK_NULL);
2207   constantTag tag = cp-&gt;tag_at(index);
2208   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2209     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2210   }
2211   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2212   if (k == NULL) return NULL;
2213   return (jclass) JNIHandles::make_local(THREAD, k-&gt;java_mirror());
2214 }
2215 JVM_END
2216 
2217 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2218   constantTag tag = cp-&gt;tag_at(index);
2219   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2220     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2221   }
2222   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2223   Klass* k_o;
2224   if (force_resolution) {
2225     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2226   } else {
2227     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2228     if (k_o == NULL) return NULL;
2229   }
2230   InstanceKlass* k = InstanceKlass::cast(k_o);
2231   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2232   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2233   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2234   if (m.is_null()) {
2235     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2236   }
2237   oop method;
2238   if (!m-&gt;is_initializer() || m-&gt;is_static()) {
2239     method = Reflection::new_method(m, true, CHECK_NULL);
2240   } else {
2241     method = Reflection::new_constructor(m, CHECK_NULL);
2242   }
2243   return JNIHandles::make_local(THREAD, method);
2244 }
2245 
2246 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2247 {
2248   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2249   JvmtiVMObjectAllocEventCollector oam;
2250   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2251   bounds_check(cp, index, CHECK_NULL);
2252   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2253   return res;
2254 }
2255 JVM_END
2256 
2257 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2258 {
2259   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2260   JvmtiVMObjectAllocEventCollector oam;
2261   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2262   bounds_check(cp, index, CHECK_NULL);
2263   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2264   return res;
2265 }
2266 JVM_END
2267 
2268 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2269   constantTag tag = cp-&gt;tag_at(index);
2270   if (!tag.is_field()) {
2271     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2272   }
2273   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2274   Klass* k_o;
2275   if (force_resolution) {
2276     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2277   } else {
2278     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2279     if (k_o == NULL) return NULL;
2280   }
2281   InstanceKlass* k = InstanceKlass::cast(k_o);
2282   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2283   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2284   fieldDescriptor fd;
2285   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2286   if (target_klass == NULL) {
2287     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2288   }
2289   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2290   return JNIHandles::make_local(THREAD, field);
2291 }
2292 
2293 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2294 {
2295   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2296   JvmtiVMObjectAllocEventCollector oam;
2297   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2298   bounds_check(cp, index, CHECK_NULL);
2299   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2300   return res;
2301 }
2302 JVM_END
2303 
2304 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2305 {
2306   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2307   JvmtiVMObjectAllocEventCollector oam;
2308   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2309   bounds_check(cp, index, CHECK_NULL);
2310   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2311   return res;
2312 }
2313 JVM_END
2314 
2315 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2316 {
2317   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2318   JvmtiVMObjectAllocEventCollector oam;
2319   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2320   bounds_check(cp, index, CHECK_NULL);
2321   constantTag tag = cp-&gt;tag_at(index);
2322   if (!tag.is_field_or_method()) {
2323     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2324   }
2325   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2326   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2327   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2328   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2329   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2330   objArrayHandle dest(THREAD, dest_o);
2331   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2332   dest-&gt;obj_at_put(0, str());
2333   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2334   dest-&gt;obj_at_put(1, str());
2335   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2336   dest-&gt;obj_at_put(2, str());
2337   return (jobjectArray) JNIHandles::make_local(THREAD, dest());
2338 }
2339 JVM_END
2340 
2341 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2342 {
2343   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2344   JvmtiVMObjectAllocEventCollector oam;
2345   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2346   bounds_check(cp, index, CHECK_0);
2347   constantTag tag = cp-&gt;tag_at(index);
2348   if (!tag.is_field_or_method()) {
2349     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2350   }
2351   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2352 }
2353 JVM_END
2354 
2355 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2356 {
2357   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2358   JvmtiVMObjectAllocEventCollector oam;
2359   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2360   bounds_check(cp, index, CHECK_0);
2361   constantTag tag = cp-&gt;tag_at(index);
2362   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2363     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2364   }
2365   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2366 }
2367 JVM_END
2368 
2369 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2370 {
2371   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2372   JvmtiVMObjectAllocEventCollector oam;
2373   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2374   bounds_check(cp, index, CHECK_NULL);
2375   constantTag tag = cp-&gt;tag_at(index);
2376   if (!tag.is_name_and_type()) {
2377     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2378   }
2379   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2380   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2381   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2382   objArrayHandle dest(THREAD, dest_o);
2383   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2384   dest-&gt;obj_at_put(0, str());
2385   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2386   dest-&gt;obj_at_put(1, str());
2387   return (jobjectArray) JNIHandles::make_local(THREAD, dest());
2388 }
2389 JVM_END
2390 
2391 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2392 {
2393   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2394   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2395   bounds_check(cp, index, CHECK_0);
2396   constantTag tag = cp-&gt;tag_at(index);
2397   if (!tag.is_int()) {
2398     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2399   }
2400   return cp-&gt;int_at(index);
2401 }
2402 JVM_END
2403 
2404 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2405 {
2406   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2407   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2408   bounds_check(cp, index, CHECK_(0L));
2409   constantTag tag = cp-&gt;tag_at(index);
2410   if (!tag.is_long()) {
2411     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2412   }
2413   return cp-&gt;long_at(index);
2414 }
2415 JVM_END
2416 
2417 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2418 {
2419   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2420   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2421   bounds_check(cp, index, CHECK_(0.0f));
2422   constantTag tag = cp-&gt;tag_at(index);
2423   if (!tag.is_float()) {
2424     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2425   }
2426   return cp-&gt;float_at(index);
2427 }
2428 JVM_END
2429 
2430 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2431 {
2432   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2433   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2434   bounds_check(cp, index, CHECK_(0.0));
2435   constantTag tag = cp-&gt;tag_at(index);
2436   if (!tag.is_double()) {
2437     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2438   }
2439   return cp-&gt;double_at(index);
2440 }
2441 JVM_END
2442 
2443 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2444 {
2445   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2446   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2447   bounds_check(cp, index, CHECK_NULL);
2448   constantTag tag = cp-&gt;tag_at(index);
2449   if (!tag.is_string()) {
2450     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2451   }
2452   oop str = cp-&gt;string_at(index, CHECK_NULL);
2453   return (jstring) JNIHandles::make_local(THREAD, str);
2454 }
2455 JVM_END
2456 
2457 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2458 {
2459   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2460   JvmtiVMObjectAllocEventCollector oam;
2461   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2462   bounds_check(cp, index, CHECK_NULL);
2463   constantTag tag = cp-&gt;tag_at(index);
2464   if (!tag.is_symbol()) {
2465     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2466   }
2467   Symbol* sym = cp-&gt;symbol_at(index);
2468   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2469   return (jstring) JNIHandles::make_local(THREAD, str());
2470 }
2471 JVM_END
2472 
2473 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2474 {
2475   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2476   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2477   bounds_check(cp, index, CHECK_0);
2478   constantTag tag = cp-&gt;tag_at(index);
2479   jbyte result = tag.value();
2480   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2481   // they are changed to the corresponding tags from the JVM spec, so that java code in
2482   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2483   if (tag.is_klass_or_reference()) {
2484       result = JVM_CONSTANT_Class;
2485   } else if (tag.is_string_index()) {
2486       result = JVM_CONSTANT_String;
2487   } else if (tag.is_method_type_in_error()) {
2488       result = JVM_CONSTANT_MethodType;
2489   } else if (tag.is_method_handle_in_error()) {
2490       result = JVM_CONSTANT_MethodHandle;
2491   } else if (tag.is_dynamic_constant_in_error()) {
2492       result = JVM_CONSTANT_Dynamic;
2493   }
2494   return result;
2495 }
2496 JVM_END
2497 
2498 // Assertion support. //////////////////////////////////////////////////////////
2499 
2500 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2501   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2502   assert(cls != NULL, &quot;bad class&quot;);
2503 
2504   oop r = JNIHandles::resolve(cls);
2505   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2506   if (java_lang_Class::is_primitive(r)) return false;
2507 
2508   Klass* k = java_lang_Class::as_Klass(r);
2509   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2510   if (!k-&gt;is_instance_klass()) return false;
2511 
2512   ResourceMark rm(THREAD);
2513   const char* name = k-&gt;name()-&gt;as_C_string();
2514   bool system_class = k-&gt;class_loader() == NULL;
2515   return JavaAssertions::enabled(name, system_class);
2516 
2517 JVM_END
2518 
2519 
2520 // Return a new AssertionStatusDirectives object with the fields filled in with
2521 // command-line assertion arguments (i.e., -ea, -da).
2522 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2523   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2524   JvmtiVMObjectAllocEventCollector oam;
2525   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2526   return JNIHandles::make_local(THREAD, asd);
2527 JVM_END
2528 
2529 // Verification ////////////////////////////////////////////////////////////////////////////////
2530 
2531 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2532 
2533 // RedefineClasses support: bug 6214132 caused verification to fail.
2534 // All functions from this section should call the jvmtiThreadSate function:
2535 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2536 // The function returns a Klass* of the _scratch_class if the verifier
2537 // was invoked in the middle of the class redefinition.
2538 // Otherwise it returns its argument value which is the _the_class Klass*.
2539 // Please, refer to the description in the jvmtiThreadSate.hpp.
2540 
2541 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2542   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2543   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2544   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2545   return k-&gt;name()-&gt;as_utf8();
2546 JVM_END
2547 
2548 
2549 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2550   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2551   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2552   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2553   // types will have length zero if this is not an InstanceKlass
2554   // (length is determined by call to JVM_GetClassCPEntriesCount)
2555   if (k-&gt;is_instance_klass()) {
2556     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2557     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2558       constantTag tag = cp-&gt;tag_at(index);
2559       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2560     }
2561   }
2562 JVM_END
2563 
2564 
2565 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2566   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2567   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2568   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2569   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2570 JVM_END
2571 
2572 
2573 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2574   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2575   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2576   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2577   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2578 JVM_END
2579 
2580 
2581 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2582   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2583   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2584   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2585   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2586 JVM_END
2587 
2588 
2589 // The following methods, used for the verifier, are never called with
2590 // array klasses, so a direct cast to InstanceKlass is safe.
2591 // Typically, these methods are called in a loop with bounds determined
2592 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2593 // zero for arrays.
2594 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2595   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2596   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2597   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2598   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2599   int length = method-&gt;checked_exceptions_length();
2600   if (length &gt; 0) {
2601     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2602     for (int i = 0; i &lt; length; i++) {
2603       exceptions[i] = table[i].class_cp_index;
2604     }
2605   }
2606 JVM_END
2607 
2608 
2609 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2610   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2611   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2612   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2613   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2614   return method-&gt;checked_exceptions_length();
2615 JVM_END
2616 
2617 
2618 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2619   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2620   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2621   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2622   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2623   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2624 JVM_END
2625 
2626 
2627 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2628   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2629   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2630   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2631   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2632   return method-&gt;code_size();
2633 JVM_END
2634 
2635 
2636 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2637   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2638   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2639   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2640   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2641   ExceptionTable extable(method);
2642   entry-&gt;start_pc   = extable.start_pc(entry_index);
2643   entry-&gt;end_pc     = extable.end_pc(entry_index);
2644   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2645   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2646 JVM_END
2647 
2648 
2649 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2650   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2651   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2652   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2653   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2654   return method-&gt;exception_table_length();
2655 JVM_END
2656 
2657 
2658 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2659   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2660   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2661   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2662   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2663   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2664 JVM_END
2665 
2666 
2667 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2668   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2669   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2670   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2671   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2672 JVM_END
2673 
2674 
2675 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2676   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2677   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2678   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2679   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2680   return method-&gt;max_locals();
2681 JVM_END
2682 
2683 
2684 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2685   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2686   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2687   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2688   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2689   return method-&gt;size_of_parameters();
2690 JVM_END
2691 
2692 
2693 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2694   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2695   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2696   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2697   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2698   return method-&gt;verifier_max_stack();
2699 JVM_END
2700 
2701 
2702 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2703   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2704   ResourceMark rm(THREAD);
2705   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2706   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2707   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2708   return method-&gt;name() == vmSymbols::object_initializer_name();
2709 JVM_END
2710 
2711 
2712 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2713   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2714   ResourceMark rm(THREAD);
2715   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2716   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2717   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2718   return method-&gt;is_overpass();
2719 JVM_END
2720 
2721 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2722   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2723   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2724   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2725   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2726   return method-&gt;name()-&gt;as_utf8();
2727 JVM_END
2728 
2729 
2730 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2731   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2732   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2733   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2734   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2735   return method-&gt;signature()-&gt;as_utf8();
2736 JVM_END
2737 
2738 /**
2739  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2740  * read entries in the constant pool.  Since the old verifier always
2741  * works on a copy of the code, it will not see any rewriting that
2742  * may possibly occur in the middle of verification.  So it is important
2743  * that nothing it calls tries to use the cpCache instead of the raw
2744  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2745  */
2746 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2747   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2748   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2749   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2750   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2751   switch (cp-&gt;tag_at(cp_index).value()) {
2752     case JVM_CONSTANT_Fieldref:
2753       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2754     default:
2755       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2756   }
2757   ShouldNotReachHere();
2758   return NULL;
2759 JVM_END
2760 
2761 
2762 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2763   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2764   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2765   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2766   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2767   switch (cp-&gt;tag_at(cp_index).value()) {
2768     case JVM_CONSTANT_InterfaceMethodref:
2769     case JVM_CONSTANT_Methodref:
2770       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2771     default:
2772       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2773   }
2774   ShouldNotReachHere();
2775   return NULL;
2776 JVM_END
2777 
2778 
2779 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2780   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2781   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2782   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2783   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2784   switch (cp-&gt;tag_at(cp_index).value()) {
2785     case JVM_CONSTANT_InterfaceMethodref:
2786     case JVM_CONSTANT_Methodref:
2787       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2788     default:
2789       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2790   }
2791   ShouldNotReachHere();
2792   return NULL;
2793 JVM_END
2794 
2795 
2796 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2797   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2798   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2799   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2800   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2801   switch (cp-&gt;tag_at(cp_index).value()) {
2802     case JVM_CONSTANT_Fieldref:
2803       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2804     default:
2805       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2806   }
2807   ShouldNotReachHere();
2808   return NULL;
2809 JVM_END
2810 
2811 
2812 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2813   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2814   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2815   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2816   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2817   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2818   return classname-&gt;as_utf8();
2819 JVM_END
2820 
2821 
2822 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2823   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2824   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2825   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2826   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2827   switch (cp-&gt;tag_at(cp_index).value()) {
2828     case JVM_CONSTANT_Fieldref: {
2829       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2830       Symbol* classname = cp-&gt;klass_name_at(class_index);
2831       return classname-&gt;as_utf8();
2832     }
2833     default:
2834       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2835   }
2836   ShouldNotReachHere();
2837   return NULL;
2838 JVM_END
2839 
2840 
2841 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2842   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2843   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2844   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2845   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2846   switch (cp-&gt;tag_at(cp_index).value()) {
2847     case JVM_CONSTANT_Methodref:
2848     case JVM_CONSTANT_InterfaceMethodref: {
2849       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2850       Symbol* classname = cp-&gt;klass_name_at(class_index);
2851       return classname-&gt;as_utf8();
2852     }
2853     default:
2854       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2855   }
2856   ShouldNotReachHere();
2857   return NULL;
2858 JVM_END
2859 
2860 
2861 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2862   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2863   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2864   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2865   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2866   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2867   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2868   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2869   switch (cp-&gt;tag_at(cp_index).value()) {
2870     case JVM_CONSTANT_Fieldref: {
2871       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2872       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2873       InstanceKlass* ik = InstanceKlass::cast(k_called);
2874       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2875         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2876           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2877         }
2878       }
2879       return -1;
2880     }
2881     default:
2882       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2883   }
2884   ShouldNotReachHere();
2885   return 0;
2886 JVM_END
2887 
2888 
2889 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2890   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2891   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2892   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2893   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2894   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2895   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2896   switch (cp-&gt;tag_at(cp_index).value()) {
2897     case JVM_CONSTANT_Methodref:
2898     case JVM_CONSTANT_InterfaceMethodref: {
2899       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2900       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2901       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2902       int methods_count = methods-&gt;length();
2903       for (int i = 0; i &lt; methods_count; i++) {
2904         Method* method = methods-&gt;at(i);
2905         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2906             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2907         }
2908       }
2909       return -1;
2910     }
2911     default:
2912       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2913   }
2914   ShouldNotReachHere();
2915   return 0;
2916 JVM_END
2917 
2918 
2919 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2920 
2921 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2922   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2923 JVM_END
2924 
2925 
2926 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2927   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2928   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2929   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2930   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2931   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2932   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2933 JVM_END
2934 
2935 // Printing support //////////////////////////////////////////////////
2936 extern &quot;C&quot; {
2937 
2938 ATTRIBUTE_PRINTF(3, 0)
2939 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2940   // Reject count values that are negative signed values converted to
2941   // unsigned; see bug 4399518, 4417214
2942   if ((intptr_t)count &lt;= 0) return -1;
2943 
2944   int result = os::vsnprintf(str, count, fmt, args);
2945   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
2946     result = -1;
2947   }
2948 
2949   return result;
2950 }
2951 
2952 ATTRIBUTE_PRINTF(3, 4)
2953 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
2954   va_list args;
2955   int len;
2956   va_start(args, fmt);
2957   len = jio_vsnprintf(str, count, fmt, args);
2958   va_end(args);
2959   return len;
2960 }
2961 
2962 ATTRIBUTE_PRINTF(2, 3)
2963 int jio_fprintf(FILE* f, const char *fmt, ...) {
2964   int len;
2965   va_list args;
2966   va_start(args, fmt);
2967   len = jio_vfprintf(f, fmt, args);
2968   va_end(args);
2969   return len;
2970 }
2971 
2972 ATTRIBUTE_PRINTF(2, 0)
2973 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
2974   if (Arguments::vfprintf_hook() != NULL) {
2975      return Arguments::vfprintf_hook()(f, fmt, args);
2976   } else {
2977     return vfprintf(f, fmt, args);
2978   }
2979 }
2980 
2981 ATTRIBUTE_PRINTF(1, 2)
2982 JNIEXPORT int jio_printf(const char *fmt, ...) {
2983   int len;
2984   va_list args;
2985   va_start(args, fmt);
2986   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
2987   va_end(args);
2988   return len;
2989 }
2990 
2991 // HotSpot specific jio method
2992 void jio_print(const char* s, size_t len) {
2993   // Try to make this function as atomic as possible.
2994   if (Arguments::vfprintf_hook() != NULL) {
2995     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
2996   } else {
2997     // Make an unused local variable to avoid warning from gcc compiler.
2998     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
2999   }
3000 }
3001 
3002 } // Extern C
3003 
3004 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
3005 
3006 // In most of the JVM thread support functions we need to access the
3007 // thread through a ThreadsListHandle to prevent it from exiting and
3008 // being reclaimed while we try to operate on it. The exceptions to this
3009 // rule are when operating on the current thread, or if the monitor of
3010 // the target java.lang.Thread is locked at the Java level - in both
3011 // cases the target cannot exit.
3012 
3013 static void thread_entry(JavaThread* thread, TRAPS) {
3014   HandleMark hm(THREAD);
3015   Handle obj(THREAD, thread-&gt;threadObj());
3016   JavaValue result(T_VOID);
3017   JavaCalls::call_virtual(&amp;result,
3018                           obj,
3019                           SystemDictionary::Thread_klass(),
3020                           vmSymbols::run_method_name(),
3021                           vmSymbols::void_method_signature(),
3022                           THREAD);
3023 }
3024 
3025 
3026 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
3027   JVMWrapper(&quot;JVM_StartThread&quot;);
3028   JavaThread *native_thread = NULL;
3029 
3030   // We cannot hold the Threads_lock when we throw an exception,
3031   // due to rank ordering issues. Example:  we might need to grab the
3032   // Heap_lock while we construct the exception.
3033   bool throw_illegal_thread_state = false;
3034 
3035   // We must release the Threads_lock before we can post a jvmti event
3036   // in Thread::start.
3037   {
3038     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
3039     // we operate.
3040     MutexLocker mu(Threads_lock);
3041 
3042     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
3043     // re-starting an already started thread, so we should usually find
3044     // that the JavaThread is null. However for a JNI attached thread
3045     // there is a small window between the Thread object being created
3046     // (with its JavaThread set) and the update to its threadStatus, so we
3047     // have to check for this
3048     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
3049       throw_illegal_thread_state = true;
3050     } else {
3051       // We could also check the stillborn flag to see if this thread was already stopped, but
3052       // for historical reasons we let the thread detect that itself when it starts running
3053 
3054       jlong size =
3055              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
3056       // Allocate the C++ Thread structure and create the native thread.  The
3057       // stack size retrieved from java is 64-bit signed, but the constructor takes
3058       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
3059       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
3060       //  - Avoid passing negative values which would result in really large stacks.
3061       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
3062       size_t sz = size &gt; 0 ? (size_t) size : 0;
3063       native_thread = new JavaThread(&amp;thread_entry, sz);
3064 
3065       // At this point it may be possible that no osthread was created for the
3066       // JavaThread due to lack of memory. Check for this situation and throw
3067       // an exception if necessary. Eventually we may want to change this so
3068       // that we only grab the lock if the thread was created successfully -
3069       // then we can also do this check and throw the exception in the
3070       // JavaThread constructor.
3071       if (native_thread-&gt;osthread() != NULL) {
3072         // Note: the current thread is not being used within &quot;prepare&quot;.
3073         native_thread-&gt;prepare(jthread);
3074       }
3075     }
3076   }
3077 
3078   if (throw_illegal_thread_state) {
3079     THROW(vmSymbols::java_lang_IllegalThreadStateException());
3080   }
3081 
3082   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
3083 
3084   if (native_thread-&gt;osthread() == NULL) {
3085     // No one should hold a reference to the &#39;native_thread&#39;.
3086     native_thread-&gt;smr_delete();
3087     if (JvmtiExport::should_post_resource_exhausted()) {
3088       JvmtiExport::post_resource_exhausted(
3089         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
3090         os::native_thread_creation_failed_msg());
3091     }
3092     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
3093               os::native_thread_creation_failed_msg());
3094   }
3095 
3096 #if INCLUDE_JFR
3097   if (Jfr::is_recording() &amp;&amp; EventThreadStart::is_enabled() &amp;&amp;
3098       EventThreadStart::is_stacktrace_enabled()) {
3099     JfrThreadLocal* tl = native_thread-&gt;jfr_thread_local();
3100     // skip Thread.start() and Thread.start0()
3101     tl-&gt;set_cached_stack_trace_id(JfrStackTraceRepository::record(thread, 2));
3102   }
3103 #endif
3104 
3105   Thread::start(native_thread);
3106 
3107 JVM_END
3108 
3109 
3110 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
3111 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
3112 // but is thought to be reliable and simple. In the case, where the receiver is the
3113 // same thread as the sender, no VM_Operation is needed.
3114 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
3115   JVMWrapper(&quot;JVM_StopThread&quot;);
3116 
3117   // A nested ThreadsListHandle will grab the Threads_lock so create
3118   // tlh before we resolve throwable.
3119   ThreadsListHandle tlh(thread);
3120   oop java_throwable = JNIHandles::resolve(throwable);
3121   if (java_throwable == NULL) {
3122     THROW(vmSymbols::java_lang_NullPointerException());
3123   }
3124   oop java_thread = NULL;
3125   JavaThread* receiver = NULL;
3126   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3127   Events::log_exception(thread,
3128                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
3129                         p2i(receiver), p2i(java_thread), p2i(throwable));
3130 
3131   if (is_alive) {
3132     // jthread refers to a live JavaThread.
3133     if (thread == receiver) {
3134       // Exception is getting thrown at self so no VM_Operation needed.
3135       THROW_OOP(java_throwable);
3136     } else {
3137       // Use a VM_Operation to throw the exception.
3138       Thread::send_async_exception(java_thread, java_throwable);
3139     }
3140   } else {
3141     // Either:
3142     // - target thread has not been started before being stopped, or
3143     // - target thread already terminated
3144     // We could read the threadStatus to determine which case it is
3145     // but that is overkill as it doesn&#39;t matter. We must set the
3146     // stillborn flag for the first case, and if the thread has already
3147     // exited setting this flag has no effect.
3148     java_lang_Thread::set_stillborn(java_thread);
3149   }
3150 JVM_END
3151 
3152 
3153 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
3154   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
3155 
3156   oop thread_oop = JNIHandles::resolve_non_null(jthread);
3157   return java_lang_Thread::is_alive(thread_oop);
3158 JVM_END
3159 
3160 
3161 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
3162   JVMWrapper(&quot;JVM_SuspendThread&quot;);
3163 
3164   ThreadsListHandle tlh(thread);
3165   JavaThread* receiver = NULL;
3166   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3167   if (is_alive) {
3168     // jthread refers to a live JavaThread.
3169     {
3170       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
3171       if (receiver-&gt;is_external_suspend()) {
3172         // Don&#39;t allow nested external suspend requests. We can&#39;t return
3173         // an error from this interface so just ignore the problem.
3174         return;
3175       }
3176       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
3177         return;
3178       }
3179       receiver-&gt;set_external_suspend();
3180     }
3181 
3182     // java_suspend() will catch threads in the process of exiting
3183     // and will ignore them.
3184     receiver-&gt;java_suspend();
3185 
3186     // It would be nice to have the following assertion in all the
3187     // time, but it is possible for a racing resume request to have
3188     // resumed this thread right after we suspended it. Temporarily
3189     // enable this assertion if you are chasing a different kind of
3190     // bug.
3191     //
3192     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
3193     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
3194   }
3195 JVM_END
3196 
3197 
3198 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
3199   JVMWrapper(&quot;JVM_ResumeThread&quot;);
3200 
3201   ThreadsListHandle tlh(thread);
3202   JavaThread* receiver = NULL;
3203   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3204   if (is_alive) {
3205     // jthread refers to a live JavaThread.
3206 
3207     // This is the original comment for this Threads_lock grab:
3208     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
3209     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
3210     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
3211     //   looks at it.
3212     //
3213     // The above comment dates back to when we had both internal and
3214     // external suspend APIs that shared a common underlying mechanism.
3215     // External suspend is now entirely cooperative and doesn&#39;t share
3216     // anything with internal suspend. That said, there are some
3217     // assumptions in the VM that an external resume grabs the
3218     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
3219     // resolve the assumptions that exist elsewhere.
3220     //
3221     MutexLocker ml(Threads_lock);
3222     receiver-&gt;java_resume();
3223   }
3224 JVM_END
3225 
3226 
3227 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3228   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3229 
3230   ThreadsListHandle tlh(thread);
3231   oop java_thread = NULL;
3232   JavaThread* receiver = NULL;
3233   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3234   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3235 
3236   if (is_alive) {
3237     // jthread refers to a live JavaThread.
3238     Thread::set_priority(receiver, (ThreadPriority)prio);
3239   }
3240   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3241   // priority set in the java.lang.Thread object above will be pushed
3242   // down when it does start.
3243 JVM_END
3244 
3245 
3246 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3247   JVMWrapper(&quot;JVM_Yield&quot;);
3248   if (os::dont_yield()) return;
3249   HOTSPOT_THREAD_YIELD();
3250   os::naked_yield();
3251 JVM_END
3252 
3253 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3254   assert(event != NULL, &quot;invariant&quot;);
3255   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3256   event-&gt;set_time(millis);
3257   event-&gt;commit();
3258 }
3259 
3260 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3261   JVMWrapper(&quot;JVM_Sleep&quot;);
3262 
3263   if (millis &lt; 0) {
3264     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3265   }
3266 
3267   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3268     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3269   }
3270 
3271   // Save current thread state and restore it at the end of this block.
3272   // And set new thread state to SLEEPING.
3273   JavaThreadSleepState jtss(thread);
3274 
3275   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3276   EventThreadSleep event;
3277 
3278   if (millis == 0) {
3279     os::naked_yield();
3280   } else {
3281     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3282     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3283     if (!thread-&gt;sleep(millis)) { // interrupted
3284       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3285       // us while we were sleeping. We do not overwrite those.
3286       if (!HAS_PENDING_EXCEPTION) {
3287         if (event.should_commit()) {
3288           post_thread_sleep_event(&amp;event, millis);
3289         }
3290         HOTSPOT_THREAD_SLEEP_END(1);
3291 
3292         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3293         // to properly restore the thread state.  That&#39;s likely wrong.
3294         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3295       }
3296     }
3297     thread-&gt;osthread()-&gt;set_state(old_state);
3298   }
3299   if (event.should_commit()) {
3300     post_thread_sleep_event(&amp;event, millis);
3301   }
3302   HOTSPOT_THREAD_SLEEP_END(0);
3303 JVM_END
3304 
3305 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3306   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3307   oop jthread = thread-&gt;threadObj();
3308   assert(jthread != NULL, &quot;no current thread!&quot;);
3309   return JNIHandles::make_local(THREAD, jthread);
3310 JVM_END
3311 
3312 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3313   JVMWrapper(&quot;JVM_Interrupt&quot;);
3314 
3315   ThreadsListHandle tlh(thread);
3316   JavaThread* receiver = NULL;
3317   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3318   if (is_alive) {
3319     // jthread refers to a live JavaThread.
3320     receiver-&gt;interrupt();
3321   }
3322 JVM_END
3323 
3324 
3325 // Return true iff the current thread has locked the object passed in
3326 
3327 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3328   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3329   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3330   if (obj == NULL) {
3331     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3332   }
3333   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3334   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3335 JVM_END
3336 
3337 
3338 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3339   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3340   VM_PrintThreads op;
3341   VMThread::execute(&amp;op);
3342   if (JvmtiExport::should_post_data_dump()) {
3343     JvmtiExport::post_data_dump();
3344   }
3345 JVM_END
3346 
3347 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3348   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3349 
3350   // We don&#39;t use a ThreadsListHandle here because the current thread
3351   // must be alive.
3352   oop java_thread = JNIHandles::resolve_non_null(jthread);
3353   JavaThread* thr = java_lang_Thread::thread(java_thread);
3354   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3355     // Thread naming is only supported for the current thread and
3356     // we don&#39;t set the name of an attached thread to avoid stepping
3357     // on other programs.
3358     ResourceMark rm(thread);
3359     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3360     os::set_native_thread_name(thread_name);
3361   }
3362 JVM_END
3363 
3364 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3365 
3366 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3367   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3368   ResourceMark rm(THREAD);
3369   JvmtiVMObjectAllocEventCollector oam;
3370   vframeStream vfst(thread);
3371 
3372   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3373     // This must only be called from SecurityManager.getClassContext
3374     Method* m = vfst.method();
3375     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3376           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3377           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3378       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3379     }
3380   }
3381 
3382   // Collect method holders
3383   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3384   for (; !vfst.at_end(); vfst.security_next()) {
3385     Method* m = vfst.method();
3386     // Native frames are not returned
3387     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3388       Klass* holder = m-&gt;method_holder();
3389       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3390       klass_array-&gt;append(holder);
3391     }
3392   }
3393 
3394   // Create result array of type [Ljava/lang/Class;
3395   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3396   // Fill in mirrors corresponding to method holders
3397   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3398     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3399   }
3400 
3401   return (jobjectArray) JNIHandles::make_local(THREAD, result);
3402 JVM_END
3403 
3404 
3405 // java.lang.Package ////////////////////////////////////////////////////////////////
3406 
3407 
3408 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3409   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3410   ResourceMark rm(THREAD);
3411   JvmtiVMObjectAllocEventCollector oam;
3412   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3413   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3414 return (jstring) JNIHandles::make_local(THREAD, result);
3415 JVM_END
3416 
3417 
3418 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3419   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3420   JvmtiVMObjectAllocEventCollector oam;
3421   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3422   return (jobjectArray) JNIHandles::make_local(THREAD, result);
3423 JVM_END
3424 
3425 
3426 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3427 
3428 
3429 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3430   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3431 
3432   MonitorLocker ml(Heap_lock);
3433   oop ref = Universe::reference_pending_list();
3434   if (ref != NULL) {
3435     Universe::clear_reference_pending_list();
3436   }
3437   return JNIHandles::make_local(THREAD, ref);
3438 JVM_END
3439 
3440 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3441   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3442   MonitorLocker ml(Heap_lock);
3443   return Universe::has_reference_pending_list();
3444 JVM_END
3445 
3446 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3447   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3448   MonitorLocker ml(Heap_lock);
3449   while (!Universe::has_reference_pending_list()) {
3450     ml.wait();
3451   }
3452 JVM_END
3453 
3454 
3455 // ObjectInputStream ///////////////////////////////////////////////////////////////
3456 
3457 // Return the first user-defined class loader up the execution stack, or null
3458 // if only code from the bootstrap or platform class loader is on the stack.
3459 
3460 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3461   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3462     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3463     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3464     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3465       return JNIHandles::make_local(THREAD, loader);
3466     }
3467   }
3468   return NULL;
3469 JVM_END
3470 
3471 
3472 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3473 
3474 
3475 // resolve array handle and check arguments
3476 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3477   if (arr == NULL) {
3478     THROW_0(vmSymbols::java_lang_NullPointerException());
3479   }
3480   oop a = JNIHandles::resolve_non_null(arr);
3481   if (!a-&gt;is_array()) {
3482     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3483   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3484     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3485   }
3486   return arrayOop(a);
3487 }
3488 
3489 
3490 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3491   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3492   arrayOop a = check_array(env, arr, false, CHECK_0);
3493   return a-&gt;length();
3494 JVM_END
3495 
3496 
3497 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3498   JVMWrapper(&quot;JVM_Array_Get&quot;);
3499   JvmtiVMObjectAllocEventCollector oam;
3500   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3501   jvalue value;
3502   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3503   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3504   return JNIHandles::make_local(THREAD, box);
3505 JVM_END
3506 
3507 
3508 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3509   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3510   jvalue value;
3511   value.i = 0; // to initialize value before getting used in CHECK
3512   arrayOop a = check_array(env, arr, true, CHECK_(value));
3513   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3514   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3515   BasicType wide_type = (BasicType) wCode;
3516   if (type != wide_type) {
3517     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3518   }
3519   return value;
3520 JVM_END
3521 
3522 
3523 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3524   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3525   arrayOop a = check_array(env, arr, false, CHECK);
3526   oop box = JNIHandles::resolve(val);
3527   jvalue value;
3528   value.i = 0; // to initialize value before getting used in CHECK
3529   BasicType value_type;
3530   if (a-&gt;is_objArray()) {
3531     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3532     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3533   } else {
3534     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3535   }
3536   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3537 JVM_END
3538 
3539 
3540 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3541   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3542   arrayOop a = check_array(env, arr, true, CHECK);
3543   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3544   BasicType value_type = (BasicType) vCode;
3545   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3546 JVM_END
3547 
3548 
3549 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3550   JVMWrapper(&quot;JVM_NewArray&quot;);
3551   JvmtiVMObjectAllocEventCollector oam;
3552   oop element_mirror = JNIHandles::resolve(eltClass);
3553   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3554   return JNIHandles::make_local(THREAD, result);
3555 JVM_END
3556 
3557 
3558 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3559   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3560   JvmtiVMObjectAllocEventCollector oam;
3561   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3562   oop element_mirror = JNIHandles::resolve(eltClass);
3563   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3564   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3565   return JNIHandles::make_local(THREAD, result);
3566 JVM_END
3567 
3568 
3569 // Library support ///////////////////////////////////////////////////////////////////////////
3570 
3571 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3572   //%note jvm_ct
3573   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3574   char ebuf[1024];
3575   void *load_result;
3576   {
3577     ThreadToNativeFromVM ttnfvm(thread);
3578     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3579   }
3580   if (load_result == NULL) {
3581     char msg[1024];
3582     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3583     // Since &#39;ebuf&#39; may contain a string encoded using
3584     // platform encoding scheme, we need to pass
3585     // Exceptions::unsafe_to_utf8 to the new_exception method
3586     // as the last argument. See bug 6367357.
3587     Handle h_exception =
3588       Exceptions::new_exception(thread,
3589                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3590                                 msg, Exceptions::unsafe_to_utf8);
3591 
3592     THROW_HANDLE_0(h_exception);
3593   }
3594   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));
3595   return load_result;
3596 JVM_END
3597 
3598 
3599 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3600   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3601   os::dll_unload(handle);
3602   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));
3603 JVM_END
3604 
3605 
3606 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3607   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3608   void* find_result = os::dll_lookup(handle, name);
3609   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,
3610                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,
3611                     name, p2i(handle));
3612   return find_result;
3613 JVM_END
3614 
3615 
3616 // JNI version ///////////////////////////////////////////////////////////////////////////////
3617 
3618 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3619   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3620   return Threads::is_supported_jni_version_including_1_1(version);
3621 JVM_END
3622 
3623 
3624 // String support ///////////////////////////////////////////////////////////////////////////
3625 
3626 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3627   JVMWrapper(&quot;JVM_InternString&quot;);
3628   JvmtiVMObjectAllocEventCollector oam;
3629   if (str == NULL) return NULL;
3630   oop string = JNIHandles::resolve_non_null(str);
3631   oop result = StringTable::intern(string, CHECK_NULL);
3632   return (jstring) JNIHandles::make_local(THREAD, result);
3633 JVM_END
3634 
3635 
3636 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3637 
3638 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3639 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3640 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3641 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3642 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3643 
3644 
3645 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3646   VM_Exit::block_if_vm_exited();
3647   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3648   return new os::PlatformMutex();
3649 }
3650 
3651 
3652 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3653   VM_Exit::block_if_vm_exited();
3654   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3655   delete ((os::PlatformMutex*) mon);
3656 }
3657 
3658 
3659 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3660   VM_Exit::block_if_vm_exited();
3661   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3662   ((os::PlatformMutex*) mon)-&gt;lock();
3663   return 0;
3664 }
3665 
3666 
3667 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3668   VM_Exit::block_if_vm_exited();
3669   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3670   ((os::PlatformMutex*) mon)-&gt;unlock();
3671 }
3672 
3673 
3674 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3675 
3676 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3677                                     Handle loader, Handle protection_domain,
3678                                     jboolean throwError, TRAPS) {
3679   // Security Note:
3680   //   The Java level wrapper will perform the necessary security check allowing
3681   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3682   //   the checkPackageAccess relative to the initiating class loader via the
3683   //   protection_domain. The protection_domain is passed as NULL by the java code
3684   //   if there is no security manager in 3-arg Class.forName().
3685   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3686 
3687   // Check if we should initialize the class
3688   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3689     klass-&gt;initialize(CHECK_NULL);
3690   }
3691   return (jclass) JNIHandles::make_local(THREAD, klass-&gt;java_mirror());
3692 }
3693 
3694 
3695 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3696 
3697 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3698   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3699   Handle method_handle;
3700   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3701     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3702     Handle receiver(THREAD, JNIHandles::resolve(obj));
3703     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3704     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3705     jobject res = JNIHandles::make_local(THREAD, result);
3706     if (JvmtiExport::should_post_vm_object_alloc()) {
3707       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3708       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3709       if (java_lang_Class::is_primitive(ret_type)) {
3710         // Only for primitive type vm allocates memory for java object.
3711         // See box() method.
3712         JvmtiExport::post_vm_object_alloc(thread, result);
3713       }
3714     }
3715     return res;
3716   } else {
3717     THROW_0(vmSymbols::java_lang_StackOverflowError());
3718   }
3719 JVM_END
3720 
3721 
3722 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3723   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3724   oop constructor_mirror = JNIHandles::resolve(c);
3725   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3726   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3727   jobject res = JNIHandles::make_local(THREAD, result);
3728   if (JvmtiExport::should_post_vm_object_alloc()) {
3729     JvmtiExport::post_vm_object_alloc(thread, result);
3730   }
3731   return res;
3732 JVM_END
3733 
3734 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3735 
3736 JVM_LEAF(jboolean, JVM_SupportsCX8())
3737   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3738   return VM_Version::supports_cx8();
3739 JVM_END
3740 
3741 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3742   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3743   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3744   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3745   HeapShared::initialize_from_archived_subgraph(k);
3746 JVM_END
3747 
3748 JVM_ENTRY(void, JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env,
3749                                               jclass caller,
3750                                               jstring invokedName,
3751                                               jobject invokedType,
3752                                               jobject methodType,
3753                                               jobject implMethodMember,
3754                                               jobject instantiatedMethodType,
3755                                               jclass lambdaProxyClass))
3756   JVMWrapper(&quot;JVM_RegisterLambdaProxyClassForArchiving&quot;);
3757 #if INCLUDE_CDS
3758   if (!DynamicDumpSharedSpaces) {
3759     return;
3760   }
3761 
3762   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
3763   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);
3764   if (caller_ik-&gt;is_hidden() || caller_ik-&gt;is_unsafe_anonymous()) {
3765     // VM anonymous classes and hidden classes not of type lambda proxy classes are currently not being archived.
3766     // If the caller_ik is of one of the above types, the corresponding lambda proxy class won&#39;t be
3767     // registered for archiving.
3768     return;
3769   }
3770   Klass* lambda_k = java_lang_Class::as_Klass(JNIHandles::resolve(lambdaProxyClass));
3771   InstanceKlass* lambda_ik = InstanceKlass::cast(lambda_k);
3772   assert(lambda_ik-&gt;is_hidden(), &quot;must be a hidden class&quot;);
3773   assert(!lambda_ik-&gt;is_non_strong_hidden(), &quot;expected a strong hidden class&quot;);
3774 
3775   Symbol* invoked_name = NULL;
3776   if (invokedName != NULL) {
3777     invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));
3778   }
3779   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));
3780   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);
3781 
3782   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));
3783   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);
3784 
3785   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));
3786   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);
3787   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());
3788 
3789   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
3790   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
3791 
3792   SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,
3793                                                  method_type, m, instantiated_method_type);
3794 #endif // INCLUDE_CDS
3795 JVM_END
3796 
3797 JVM_ENTRY(jclass, JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env,
3798                                                         jclass caller,
3799                                                         jstring invokedName,
3800                                                         jobject invokedType,
3801                                                         jobject methodType,
3802                                                         jobject implMethodMember,
3803                                                         jobject instantiatedMethodType,
3804                                                         jboolean initialize))
3805   JVMWrapper(&quot;JVM_LookupLambdaProxyClassFromArchive&quot;);
3806 #if INCLUDE_CDS
3807   if (!DynamicArchive::is_mapped()) {
3808     return NULL;
3809   }
3810 
3811   if (invokedName == NULL || invokedType == NULL || methodType == NULL ||
3812       implMethodMember == NULL || instantiatedMethodType == NULL) {
3813     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
3814   }
3815 
3816   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
3817   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);
3818   if (!caller_ik-&gt;is_shared()) {
3819     // there won&#39;t be a shared lambda class if the caller_ik is not in the shared archive.
3820     return NULL;
3821   }
3822 
3823   Symbol* invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));
3824   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));
3825   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);
3826 
3827   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));
3828   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);
3829 
3830   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));
3831   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);
3832   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());
3833 
3834   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
3835   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
3836 
3837   InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, invoked_name, invoked_type,
3838                                                                                    method_type, m, instantiated_method_type);
3839   jclass jcls = NULL;
3840   if (lambda_ik != NULL) {
3841     InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, initialize, THREAD);
3842     jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(THREAD, loaded_lambda-&gt;java_mirror());
3843   }
3844   return jcls;
3845 #else
3846   return NULL;
3847 #endif // INCLUDE_CDS
3848 JVM_END
3849 
3850 JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))
3851     JVMWrapper(&quot;JVM_IsCDSDumpingEnable&quot;);
3852     return DynamicDumpSharedSpaces;
3853 JVM_END
3854 
3855 JVM_ENTRY(jboolean, JVM_IsCDSSharingEnabled(JNIEnv* env))
3856     JVMWrapper(&quot;JVM_IsCDSSharingEnable&quot;);
3857     return UseSharedSpaces;
3858 JVM_END
3859 
3860 JVM_ENTRY_NO_ENV(jlong, JVM_GetRandomSeedForCDSDump())
3861   JVMWrapper(&quot;JVM_GetRandomSeedForCDSDump&quot;);
3862   if (DumpSharedSpaces) {
3863     const char* release = Abstract_VM_Version::vm_release();
3864     const char* dbg_level = Abstract_VM_Version::jdk_debug_level();
3865     const char* version = VM_Version::internal_vm_info_string();
3866     jlong seed = (jlong)(java_lang_String::hash_code((const jbyte*)release, (int)strlen(release)) ^
3867                          java_lang_String::hash_code((const jbyte*)dbg_level, (int)strlen(dbg_level)) ^
3868                          java_lang_String::hash_code((const jbyte*)version, (int)strlen(version)));
3869     seed += (jlong)Abstract_VM_Version::vm_major_version();
3870     seed += (jlong)Abstract_VM_Version::vm_minor_version();
3871     seed += (jlong)Abstract_VM_Version::vm_security_version();
3872     seed += (jlong)Abstract_VM_Version::vm_patch_version();
3873     if (seed == 0) { // don&#39;t let this ever be zero.
3874       seed = 0x87654321;
3875     }
3876     log_debug(cds)(&quot;JVM_GetRandomSeedForCDSDump() = &quot; JLONG_FORMAT, seed);
3877     return seed;
3878   } else {
3879     return 0;
3880   }
3881 JVM_END
3882 
3883 // Returns an array of all live Thread objects (VM internal JavaThreads,
3884 // jvmti agent threads, and JNI attaching threads  are skipped)
3885 // See CR 6404306 regarding JNI attaching threads
3886 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3887   ResourceMark rm(THREAD);
3888   ThreadsListEnumerator tle(THREAD, false, false);
3889   JvmtiVMObjectAllocEventCollector oam;
3890 
3891   int num_threads = tle.num_threads();
3892   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3893   objArrayHandle threads_ah(THREAD, r);
3894 
3895   for (int i = 0; i &lt; num_threads; i++) {
3896     Handle h = tle.get_threadObj(i);
3897     threads_ah-&gt;obj_at_put(i, h());
3898   }
3899 
3900   return (jobjectArray) JNIHandles::make_local(THREAD, threads_ah());
3901 JVM_END
3902 
3903 
3904 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3905 // Return StackTraceElement[][], each element is the stack trace of a thread in
3906 // the corresponding entry in the given threads array
3907 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3908   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3909   JvmtiVMObjectAllocEventCollector oam;
3910 
3911   // Check if threads is null
3912   if (threads == NULL) {
3913     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3914   }
3915 
3916   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3917   objArrayHandle ah(THREAD, a);
3918   int num_threads = ah-&gt;length();
3919   // check if threads is non-empty array
3920   if (num_threads == 0) {
3921     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3922   }
3923 
3924   // check if threads is not an array of objects of Thread class
3925   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3926   if (k != SystemDictionary::Thread_klass()) {
3927     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3928   }
3929 
3930   ResourceMark rm(THREAD);
3931 
3932   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3933   for (int i = 0; i &lt; num_threads; i++) {
3934     oop thread_obj = ah-&gt;obj_at(i);
3935     instanceHandle h(THREAD, (instanceOop) thread_obj);
3936     thread_handle_array-&gt;append(h);
3937   }
3938 
3939   // The JavaThread references in thread_handle_array are validated
3940   // in VM_ThreadDump::doit().
3941   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
3942   return (jobjectArray)JNIHandles::make_local(THREAD, stacktraces());
3943 
3944 JVM_END
3945 
3946 // JVM monitoring and management support
3947 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
3948   return Management::get_jmm_interface(version);
3949 JVM_END
3950 
3951 // com.sun.tools.attach.VirtualMachine agent properties support
3952 //
3953 // Initialize the agent properties with the properties maintained in the VM
3954 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
3955   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
3956   ResourceMark rm;
3957 
3958   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
3959 
3960   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
3961   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
3962   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
3963   return properties;
3964 JVM_END
3965 
3966 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
3967 {
3968   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
3969   JvmtiVMObjectAllocEventCollector oam;
3970 
3971   if (ofClass == NULL) {
3972     return NULL;
3973   }
3974   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
3975   // Special handling for primitive objects
3976   if (java_lang_Class::is_primitive(mirror())) {
3977     return NULL;
3978   }
3979   Klass* k = java_lang_Class::as_Klass(mirror());
3980   if (!k-&gt;is_instance_klass()) {
3981     return NULL;
3982   }
3983   InstanceKlass* ik = InstanceKlass::cast(k);
3984   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
3985   if (encl_method_class_idx == 0) {
3986     return NULL;
3987   }
3988   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
3989   objArrayHandle dest(THREAD, dest_o);
3990   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3991   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3992   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3993   if (encl_method_method_idx != 0) {
3994     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3995                         extract_low_short_from_int(
3996                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3997     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3998     dest-&gt;obj_at_put(1, str());
3999     sym = ik-&gt;constants()-&gt;symbol_at(
4000               extract_high_short_from_int(
4001                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
4002     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
4003     dest-&gt;obj_at_put(2, str());
4004   }
4005   return (jobjectArray) JNIHandles::make_local(THREAD, dest());
4006 }
4007 JVM_END
4008 
4009 // Returns an array of java.lang.String objects containing the input arguments to the VM.
4010 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
4011   ResourceMark rm(THREAD);
4012 
4013   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
4014     return NULL;
4015   }
4016 
4017   char** vm_flags = Arguments::jvm_flags_array();
4018   char** vm_args = Arguments::jvm_args_array();
4019   int num_flags = Arguments::num_jvm_flags();
4020   int num_args = Arguments::num_jvm_args();
4021 
4022   InstanceKlass* ik = SystemDictionary::String_klass();
4023   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
4024   objArrayHandle result_h(THREAD, r);
4025 
4026   int index = 0;
4027   for (int j = 0; j &lt; num_flags; j++, index++) {
4028     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
4029     result_h-&gt;obj_at_put(index, h());
4030   }
4031   for (int i = 0; i &lt; num_args; i++, index++) {
4032     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
4033     result_h-&gt;obj_at_put(index, h());
4034   }
4035   return (jobjectArray) JNIHandles::make_local(THREAD, result_h());
4036 JVM_END
4037 
4038 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
4039   return os::get_signal_number(name);
4040 JVM_END
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>