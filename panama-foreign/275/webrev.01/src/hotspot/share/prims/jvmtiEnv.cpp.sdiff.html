<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnter.xsl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.xsl.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEnv.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 643     Arguments::append_sysclasspath(segment);
 644     return JVMTI_ERROR_NONE;
 645   } else if (use_version_1_0_semantics()) {
 646     // This JvmtiEnv requested version 1.0 semantics and this function
 647     // is only allowed in the ONLOAD phase in version 1.0 so we need to
 648     // return an error here.
 649     return JVMTI_ERROR_WRONG_PHASE;
 650   } else if (phase == JVMTI_PHASE_LIVE) {
 651     // The phase is checked by the wrapper that called this function,
 652     // but this thread could be racing with the thread that is
 653     // terminating the VM so we check one more time.
 654 
 655     // create the zip entry
 656     ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, true);
 657     if (zip_entry == NULL) {
 658       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 659     }
 660 
 661     // lock the loader
 662     Thread* thread = Thread::current();
<span class="line-modified"> 663     HandleMark hm;</span>
 664     Handle loader_lock = Handle(thread, SystemDictionary::system_loader_lock());
 665 
 666     ObjectLocker ol(loader_lock, thread);
 667 
 668     // add the jar file to the bootclasspath
 669     log_info(class, load)(&quot;opened: %s&quot;, zip_entry-&gt;name());
 670 #if INCLUDE_CDS
 671     ClassLoaderExt::append_boot_classpath(zip_entry);
 672 #else
 673     ClassLoader::add_to_boot_append_entries(zip_entry);
 674 #endif
 675     return JVMTI_ERROR_NONE;
 676   } else {
 677     return JVMTI_ERROR_WRONG_PHASE;
 678   }
 679 
 680 } /* end AddToBootstrapClassLoaderSearch */
 681 
 682 
 683 // segment - pre-checked for NULL
 684 jvmtiError
 685 JvmtiEnv::AddToSystemClassLoaderSearch(const char* segment) {
 686   jvmtiPhase phase = get_phase();
 687 
 688   if (phase == JVMTI_PHASE_ONLOAD) {
 689     for (SystemProperty* p = Arguments::system_properties(); p != NULL; p = p-&gt;next()) {
 690       if (strcmp(&quot;java.class.path&quot;, p-&gt;key()) == 0) {
 691         p-&gt;append_value(segment);
 692         break;
 693       }
 694     }
 695     return JVMTI_ERROR_NONE;
 696   } else if (phase == JVMTI_PHASE_LIVE) {
 697     // The phase is checked by the wrapper that called this function,
 698     // but this thread could be racing with the thread that is
 699     // terminating the VM so we check one more time.
<span class="line-modified"> 700     HandleMark hm;</span>

 701 
 702     // create the zip entry (which will open the zip file and hence
 703     // check that the segment is indeed a zip file).
 704     ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, false);
 705     if (zip_entry == NULL) {
 706       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 707     }
 708     delete zip_entry;   // no longer needed
 709 
 710     // lock the loader
<span class="line-removed"> 711     Thread* THREAD = Thread::current();</span>
 712     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
<span class="line-removed"> 713 </span>
 714     ObjectLocker ol(loader, THREAD);
 715 
 716     // need the path as java.lang.String
 717     Handle path = java_lang_String::create_from_platform_dependent_str(segment, THREAD);
 718     if (HAS_PENDING_EXCEPTION) {
 719       CLEAR_PENDING_EXCEPTION;
 720       return JVMTI_ERROR_INTERNAL;
 721     }
 722 
 723     // Invoke the appendToClassPathForInstrumentation method - if the method
 724     // is not found it means the loader doesn&#39;t support adding to the class path
 725     // in the live phase.
 726     {
 727       JavaValue res(T_VOID);
 728       JavaCalls::call_special(&amp;res,
 729                               loader,
 730                               loader-&gt;klass(),
 731                               vmSymbols::appendToClassPathForInstrumentation_name(),
 732                               vmSymbols::appendToClassPathForInstrumentation_signature(),
 733                               path,
</pre>
<hr />
<pre>
 898   *thread_state_ptr = state;
 899   return JVMTI_ERROR_NONE;
 900 } /* end GetThreadState */
 901 
 902 
 903 // thread_ptr - pre-checked for NULL
 904 jvmtiError
 905 JvmtiEnv::GetCurrentThread(jthread* thread_ptr) {
 906   JavaThread* current_thread  = JavaThread::current();
 907   *thread_ptr = (jthread)JNIHandles::make_local(current_thread, current_thread-&gt;threadObj());
 908   return JVMTI_ERROR_NONE;
 909 } /* end GetCurrentThread */
 910 
 911 
 912 // threads_count_ptr - pre-checked for NULL
 913 // threads_ptr - pre-checked for NULL
 914 jvmtiError
 915 JvmtiEnv::GetAllThreads(jint* threads_count_ptr, jthread** threads_ptr) {
 916   int nthreads        = 0;
 917   Handle *thread_objs = NULL;
<span class="line-modified"> 918   ResourceMark rm;</span>
<span class="line-modified"> 919   HandleMark hm;</span>

 920 
 921   // enumerate threads (including agent threads)
<span class="line-modified"> 922   ThreadsListEnumerator tle(Thread::current(), true);</span>
 923   nthreads = tle.num_threads();
 924   *threads_count_ptr = nthreads;
 925 
 926   if (nthreads == 0) {
 927     *threads_ptr = NULL;
 928     return JVMTI_ERROR_NONE;
 929   }
 930 
 931   thread_objs = NEW_RESOURCE_ARRAY(Handle, nthreads);
 932   NULL_CHECK(thread_objs, JVMTI_ERROR_OUT_OF_MEMORY);
 933 
 934   for (int i = 0; i &lt; nthreads; i++) {
 935     thread_objs[i] = Handle(tle.get_threadObj(i));
 936   }
 937 
 938   jthread *jthreads  = new_jthreadArray(nthreads, thread_objs);
 939   NULL_CHECK(jthreads, JVMTI_ERROR_OUT_OF_MEMORY);
 940 
 941   *threads_ptr = jthreads;
 942   return JVMTI_ERROR_NONE;
</pre>
<hr />
<pre>
1108   jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &amp;java_thread, NULL);
1109   if (err != JVMTI_ERROR_NONE) {
1110     return err;
1111   }
1112   // Really this should be a Java call to Thread.interrupt to ensure the same
1113   // semantics, however historically this has not been done for some reason.
1114   // So we continue with that (which means we don&#39;t interact with any Java-level
1115   // Interruptible object) but we must set the Java-level interrupted state.
1116   java_lang_Thread::set_interrupted(JNIHandles::resolve(thread), true);
1117   java_thread-&gt;interrupt();
1118 
1119   return JVMTI_ERROR_NONE;
1120 } /* end InterruptThread */
1121 
1122 
1123 // Threads_lock NOT held
1124 // thread - NOT pre-checked
1125 // info_ptr - pre-checked for NULL
1126 jvmtiError
1127 JvmtiEnv::GetThreadInfo(jthread thread, jvmtiThreadInfo* info_ptr) {
<span class="line-removed">1128   ResourceMark rm;</span>
<span class="line-removed">1129   HandleMark hm;</span>
<span class="line-removed">1130 </span>
1131   JavaThread* current_thread = JavaThread::current();



1132   ThreadsListHandle tlh(current_thread);
1133 
1134   // if thread is NULL the current thread is used
1135   oop thread_oop = NULL;
1136   if (thread == NULL) {
1137     thread_oop = current_thread-&gt;threadObj();
1138     if (thread_oop == NULL || !thread_oop-&gt;is_a(SystemDictionary::Thread_klass())) {
1139       return JVMTI_ERROR_INVALID_THREAD;
1140     }
1141   } else {
1142     JavaThread* java_thread = NULL;
1143     jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &amp;java_thread, &amp;thread_oop);
1144     if (err != JVMTI_ERROR_NONE) {
1145       // We got an error code so we don&#39;t have a JavaThread *, but
1146       // only return an error from here if we didn&#39;t get a valid
1147       // thread_oop.
1148       if (thread_oop == NULL) {
1149         return err;
1150       }
1151       // We have a valid thread_oop so we can return some thread info.
</pre>
<hr />
<pre>
1383   // Allocate memory to store global-refs to the thread groups.
1384   // Assume this area is freed by caller.
1385   *groups_ptr = (jthreadGroup *) jvmtiMalloc((sizeof(jthreadGroup)) * (*group_count_ptr));
1386 
1387   NULL_CHECK(*groups_ptr, JVMTI_ERROR_OUT_OF_MEMORY);
1388 
1389   // Convert oop to Handle, then convert Handle to global-ref.
1390   {
1391     HandleMark hm(current_thread);
1392     Handle system_thread_group(current_thread, Universe::system_thread_group());
1393     *groups_ptr[0] = jni_reference(system_thread_group);
1394   }
1395 
1396   return JVMTI_ERROR_NONE;
1397 } /* end GetTopThreadGroups */
1398 
1399 
1400 // info_ptr - pre-checked for NULL
1401 jvmtiError
1402 JvmtiEnv::GetThreadGroupInfo(jthreadGroup group, jvmtiThreadGroupInfo* info_ptr) {
<span class="line-modified">1403   ResourceMark rm;</span>
<span class="line-modified">1404   HandleMark hm;</span>
<span class="line-modified">1405 </span>
<span class="line-removed">1406   JavaThread* current_thread = JavaThread::current();</span>
1407 
1408   Handle group_obj (current_thread, JNIHandles::resolve_external_guard(group));
1409   NULL_CHECK(group_obj(), JVMTI_ERROR_INVALID_THREAD_GROUP);
1410 
1411   const char* name;
1412   Handle parent_group;
1413   bool is_daemon;
1414   ThreadPriority max_priority;
1415 
1416   name         = java_lang_ThreadGroup::name(group_obj());
1417   parent_group = Handle(current_thread, java_lang_ThreadGroup::parent(group_obj()));
1418   is_daemon    = java_lang_ThreadGroup::is_daemon(group_obj());
1419   max_priority = java_lang_ThreadGroup::maxPriority(group_obj());
1420 
1421   info_ptr-&gt;is_daemon    = is_daemon;
1422   info_ptr-&gt;max_priority = max_priority;
1423   info_ptr-&gt;parent       = jni_reference(parent_group);
1424 
1425   if (name != NULL) {
1426     info_ptr-&gt;name = (char*)jvmtiMalloc(strlen(name)+1);
</pre>
<hr />
<pre>
1601     }
1602   }
1603   return err;
1604 } /* end GetThreadListStackTraces */
1605 
1606 
1607 // Threads_lock NOT held, java_thread not protected by lock
1608 // java_thread - pre-checked
1609 // count_ptr - pre-checked for NULL
1610 jvmtiError
1611 JvmtiEnv::GetFrameCount(JavaThread* java_thread, jint* count_ptr) {
1612   jvmtiError err = JVMTI_ERROR_NONE;
1613 
1614   // retrieve or create JvmtiThreadState.
1615   JvmtiThreadState* state = JvmtiThreadState::state_for(java_thread);
1616   if (state == NULL) {
1617     return JVMTI_ERROR_THREAD_NOT_ALIVE;
1618   }
1619 
1620   // It is only safe to perform the direct operation on the current
<span class="line-modified">1621   // thread. All other usage needs to use a vm-safepoint-op for safety.</span>
1622   if (java_thread == JavaThread::current()) {
1623     err = get_frame_count(state, count_ptr);
1624   } else {
<span class="line-modified">1625     // get java stack frame count at safepoint.</span>
<span class="line-modified">1626     VM_GetFrameCount op(this, state, count_ptr);</span>
<span class="line-modified">1627     VMThread::execute(&amp;op);</span>
<span class="line-modified">1628     err = op.result();</span>
1629   }
1630   return err;
1631 } /* end GetFrameCount */
1632 
1633 
1634 // Threads_lock NOT held, java_thread not protected by lock
1635 // java_thread - pre-checked
1636 jvmtiError
1637 JvmtiEnv::PopFrame(JavaThread* java_thread) {
1638   JavaThread* current_thread  = JavaThread::current();
1639   HandleMark hm(current_thread);
1640   uint32_t debug_bits = 0;
1641 
1642   // retrieve or create the state
1643   JvmtiThreadState* state = JvmtiThreadState::state_for(java_thread);
1644   if (state == NULL) {
1645     return JVMTI_ERROR_THREAD_NOT_ALIVE;
1646   }
1647 
1648   // Check if java_thread is fully suspended
</pre>
<hr />
<pre>
1731     // Set pending step flag for this popframe and it is cleared when next
1732     // step event is posted.
1733     state-&gt;set_pending_step_for_popframe();
1734   }
1735 
1736   return JVMTI_ERROR_NONE;
1737 } /* end PopFrame */
1738 
1739 
1740 // Threads_lock NOT held, java_thread not protected by lock
1741 // java_thread - pre-checked
1742 // java_thread - unchecked
1743 // depth - pre-checked as non-negative
1744 // method_ptr - pre-checked for NULL
1745 // location_ptr - pre-checked for NULL
1746 jvmtiError
1747 JvmtiEnv::GetFrameLocation(JavaThread* java_thread, jint depth, jmethodID* method_ptr, jlocation* location_ptr) {
1748   jvmtiError err = JVMTI_ERROR_NONE;
1749 
1750   // It is only safe to perform the direct operation on the current
<span class="line-modified">1751   // thread. All other usage needs to use a vm-safepoint-op for safety.</span>
1752   if (java_thread == JavaThread::current()) {
1753     err = get_frame_location(java_thread, depth, method_ptr, location_ptr);
1754   } else {
<span class="line-modified">1755     // JVMTI get java stack frame location at safepoint.</span>
<span class="line-modified">1756     VM_GetFrameLocation op(this, java_thread, depth, method_ptr, location_ptr);</span>
<span class="line-modified">1757     VMThread::execute(&amp;op);</span>
<span class="line-modified">1758     err = op.result();</span>
1759   }
1760   return err;
1761 } /* end GetFrameLocation */
1762 
1763 
1764 // Threads_lock NOT held, java_thread not protected by lock
1765 // java_thread - pre-checked
1766 // java_thread - unchecked
1767 // depth - pre-checked as non-negative
1768 jvmtiError
1769 JvmtiEnv::NotifyFramePop(JavaThread* java_thread, jint depth) {
1770   jvmtiError err = JVMTI_ERROR_NONE;
1771   ResourceMark rm;
1772   uint32_t debug_bits = 0;
1773 
1774   JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread);
1775   if (state == NULL) {
1776     return JVMTI_ERROR_THREAD_NOT_ALIVE;
1777   }
1778 
</pre>
<hr />
<pre>
2233 // java_thread - pre-checked
2234 // java_thread - unchecked
2235 // depth - pre-checked as non-negative
2236 jvmtiError
2237 JvmtiEnv::SetLocalDouble(JavaThread* java_thread, jint depth, jint slot, jdouble value) {
2238   // rm object is created to clean up the javaVFrame created in
2239   // doit_prologue(), but after doit() is finished with it.
2240   ResourceMark rm;
2241   jvalue val;
2242   val.d = value;
2243   VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, val);
2244   VMThread::execute(&amp;op);
2245   return op.result();
2246 } /* end SetLocalDouble */
2247 
2248 
2249   //
2250   // Breakpoint functions
2251   //
2252 
<span class="line-modified">2253 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
2254 jvmtiError
<span class="line-modified">2255 JvmtiEnv::SetBreakpoint(Method* method_oop, jlocation location) {</span>
<span class="line-modified">2256   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
2257   if (location &lt; 0) {   // simple invalid location check first
2258     return JVMTI_ERROR_INVALID_LOCATION;
2259   }
2260   // verify that the breakpoint is not past the end of the method
<span class="line-modified">2261   if (location &gt;= (jlocation) method_oop-&gt;code_size()) {</span>
2262     return JVMTI_ERROR_INVALID_LOCATION;
2263   }
2264 
2265   ResourceMark rm;
<span class="line-modified">2266   JvmtiBreakpoint bp(method_oop, location);</span>
2267   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
2268   if (jvmti_breakpoints.set(bp) == JVMTI_ERROR_DUPLICATE)
2269     return JVMTI_ERROR_DUPLICATE;
2270 
2271   if (TraceJVMTICalls) {
2272     jvmti_breakpoints.print();
2273   }
2274 
2275   return JVMTI_ERROR_NONE;
2276 } /* end SetBreakpoint */
2277 
2278 
<span class="line-modified">2279 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
2280 jvmtiError
<span class="line-modified">2281 JvmtiEnv::ClearBreakpoint(Method* method_oop, jlocation location) {</span>
<span class="line-modified">2282   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
2283 
2284   if (location &lt; 0) {   // simple invalid location check first
2285     return JVMTI_ERROR_INVALID_LOCATION;
2286   }
2287 
2288   // verify that the breakpoint is not past the end of the method
<span class="line-modified">2289   if (location &gt;= (jlocation) method_oop-&gt;code_size()) {</span>
2290     return JVMTI_ERROR_INVALID_LOCATION;
2291   }
2292 
<span class="line-modified">2293   JvmtiBreakpoint bp(method_oop, location);</span>
2294 
2295   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
2296   if (jvmti_breakpoints.clear(bp) == JVMTI_ERROR_NOT_FOUND)
2297     return JVMTI_ERROR_NOT_FOUND;
2298 
2299   if (TraceJVMTICalls) {
2300     jvmti_breakpoints.print();
2301   }
2302 
2303   return JVMTI_ERROR_NONE;
2304 } /* end ClearBreakpoint */
2305 
2306 
2307   //
2308   // Watched Field functions
2309   //
2310 
2311 jvmtiError
2312 JvmtiEnv::SetFieldAccessWatch(fieldDescriptor* fdesc_ptr) {
2313   // make sure we haven&#39;t set this watch before
</pre>
<hr />
<pre>
2499   }
2500   Klass* k = java_lang_Class::as_Klass(k_mirror);
2501   NULL_CHECK(k, JVMTI_ERROR_INVALID_CLASS);
2502 
2503   // Return CLASS_NOT_PREPARED error as per JVMTI spec.
2504   if (!(k-&gt;jvmti_class_status() &amp; (JVMTI_CLASS_STATUS_PREPARED|JVMTI_CLASS_STATUS_ARRAY) )) {
2505     return JVMTI_ERROR_CLASS_NOT_PREPARED;
2506   }
2507 
2508   if (!k-&gt;is_instance_klass()) {
2509     *method_count_ptr = 0;
2510     *methods_ptr = (jmethodID*) jvmtiMalloc(0 * sizeof(jmethodID));
2511     return JVMTI_ERROR_NONE;
2512   }
2513   InstanceKlass* ik = InstanceKlass::cast(k);
2514   // Allocate the result and fill it in
2515   int result_length = ik-&gt;methods()-&gt;length();
2516   jmethodID* result_list = (jmethodID*)jvmtiMalloc(result_length * sizeof(jmethodID));
2517   int index;
2518   bool jmethodids_found = true;
<span class="line-modified">2519 </span>
<span class="line-modified">2520   if (JvmtiExport::can_maintain_original_method_order()) {</span>
<span class="line-modified">2521     // Use the original method ordering indices stored in the class, so we can emit</span>
<span class="line-modified">2522     // jmethodIDs in the order they appeared in the class file</span>
<span class="line-modified">2523     for (index = 0; index &lt; result_length; index++) {</span>
<span class="line-modified">2524       Method* m = ik-&gt;methods()-&gt;at(index);</span>
<span class="line-modified">2525       int original_index = ik-&gt;method_ordering()-&gt;at(index);</span>
<span class="line-modified">2526       assert(original_index &gt;= 0 &amp;&amp; original_index &lt; result_length, &quot;invalid original method index&quot;);</span>
<span class="line-modified">2527       jmethodID id;</span>
<span class="line-modified">2528       if (jmethodids_found) {</span>
<span class="line-modified">2529         id = m-&gt;find_jmethod_id_or_null();</span>
<span class="line-modified">2530         if (id == NULL) {</span>
<span class="line-modified">2531           // If we find an uninitialized value, make sure there is</span>
<span class="line-modified">2532           // enough space for all the uninitialized values we might</span>
<span class="line-modified">2533           // find.</span>
<span class="line-modified">2534           ik-&gt;ensure_space_for_methodids(index);</span>
<span class="line-modified">2535           jmethodids_found = false;</span>
<span class="line-modified">2536           id = m-&gt;jmethod_id();</span>
<span class="line-modified">2537         }</span>
<span class="line-modified">2538       } else {</span>



2539         id = m-&gt;jmethod_id();
2540       }
<span class="line-modified">2541       result_list[original_index] = id;</span>

2542     }
<span class="line-modified">2543   } else {</span>
<span class="line-modified">2544     // otherwise just copy in any order</span>
<span class="line-modified">2545     for (index = 0; index &lt; result_length; index++) {</span>
<span class="line-modified">2546       Method* m = ik-&gt;methods()-&gt;at(index);</span>
<span class="line-modified">2547       jmethodID id;</span>
<span class="line-modified">2548       if (jmethodids_found) {</span>
<span class="line-modified">2549         id = m-&gt;find_jmethod_id_or_null();</span>
<span class="line-modified">2550         if (id == NULL) {</span>
<span class="line-modified">2551           // If we find an uninitialized value, make sure there is</span>
<span class="line-modified">2552           // enough space for all the uninitialized values we might</span>
<span class="line-modified">2553           // find.</span>
<span class="line-removed">2554           ik-&gt;ensure_space_for_methodids(index);</span>
<span class="line-removed">2555           jmethodids_found = false;</span>
<span class="line-removed">2556           id = m-&gt;jmethod_id();</span>
<span class="line-removed">2557         }</span>
2558       } else {
<span class="line-modified">2559         id = m-&gt;jmethod_id();</span>
2560       }
<span class="line-removed">2561       result_list[index] = id;</span>
2562     }




2563   }
<span class="line-removed">2564   // Fill in return value.</span>
<span class="line-removed">2565   *method_count_ptr = result_length;</span>
<span class="line-removed">2566   *methods_ptr = result_list;</span>
2567 
2568   return JVMTI_ERROR_NONE;
2569 } /* end GetClassMethods */
2570 
2571 
2572 // k_mirror - may be primitive, this must be checked
2573 // field_count_ptr - pre-checked for NULL
2574 // fields_ptr - pre-checked for NULL
2575 jvmtiError
2576 JvmtiEnv::GetClassFields(oop k_mirror, jint* field_count_ptr, jfieldID** fields_ptr) {
2577   if (java_lang_Class::is_primitive(k_mirror)) {
2578     *field_count_ptr = 0;
2579     *fields_ptr = (jfieldID*) jvmtiMalloc(0 * sizeof(jfieldID));
2580     return JVMTI_ERROR_NONE;
2581   }
2582   JavaThread* current_thread = JavaThread::current();
2583   HandleMark hm(current_thread);
2584   Klass* k = java_lang_Class::as_Klass(k_mirror);
2585   NULL_CHECK(k, JVMTI_ERROR_INVALID_CLASS);
2586 
</pre>
<hr />
<pre>
2928   AccessFlags resultFlags = fdesc_ptr-&gt;access_flags();
2929   jint result = resultFlags.as_int();
2930   *modifiers_ptr = result;
2931 
2932   return JVMTI_ERROR_NONE;
2933 } /* end GetFieldModifiers */
2934 
2935 
2936 // is_synthetic_ptr - pre-checked for NULL
2937 jvmtiError
2938 JvmtiEnv::IsFieldSynthetic(fieldDescriptor* fdesc_ptr, jboolean* is_synthetic_ptr) {
2939   *is_synthetic_ptr = fdesc_ptr-&gt;is_synthetic();
2940   return JVMTI_ERROR_NONE;
2941 } /* end IsFieldSynthetic */
2942 
2943 
2944   //
2945   // Method functions
2946   //
2947 
<span class="line-modified">2948 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
2949 // name_ptr - NULL is a valid value, must be checked
2950 // signature_ptr - NULL is a valid value, must be checked
2951 // generic_ptr - NULL is a valid value, must be checked
2952 jvmtiError
<span class="line-modified">2953 JvmtiEnv::GetMethodName(Method* method_oop, char** name_ptr, char** signature_ptr, char** generic_ptr) {</span>
<span class="line-modified">2954   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
2955   JavaThread* current_thread  = JavaThread::current();
2956 
2957   ResourceMark rm(current_thread); // get the utf8 name and signature
2958   if (name_ptr == NULL) {
2959     // just don&#39;t return the name
2960   } else {
<span class="line-modified">2961     const char* utf8_name = (const char *) method_oop-&gt;name()-&gt;as_utf8();</span>
2962     *name_ptr = (char *) jvmtiMalloc(strlen(utf8_name)+1);
2963     strcpy(*name_ptr, utf8_name);
2964   }
2965   if (signature_ptr == NULL) {
2966     // just don&#39;t return the signature
2967   } else {
<span class="line-modified">2968     const char* utf8_signature = (const char *) method_oop-&gt;signature()-&gt;as_utf8();</span>
2969     *signature_ptr = (char *) jvmtiMalloc(strlen(utf8_signature) + 1);
2970     strcpy(*signature_ptr, utf8_signature);
2971   }
2972 
2973   if (generic_ptr != NULL) {
2974     *generic_ptr = NULL;
<span class="line-modified">2975     Symbol* soop = method_oop-&gt;generic_signature();</span>
2976     if (soop != NULL) {
2977       const char* gen_sig = soop-&gt;as_C_string();
2978       if (gen_sig != NULL) {
2979         jvmtiError err = allocate(strlen(gen_sig) + 1, (unsigned char **)generic_ptr);
2980         if (err != JVMTI_ERROR_NONE) {
2981           return err;
2982         }
2983         strcpy(*generic_ptr, gen_sig);
2984       }
2985     }
2986   }
2987   return JVMTI_ERROR_NONE;
2988 } /* end GetMethodName */
2989 
2990 
<span class="line-modified">2991 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
2992 // declaring_class_ptr - pre-checked for NULL
2993 jvmtiError
<span class="line-modified">2994 JvmtiEnv::GetMethodDeclaringClass(Method* method_oop, jclass* declaring_class_ptr) {</span>
<span class="line-modified">2995   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">2996   (*declaring_class_ptr) = get_jni_class_non_null(method_oop-&gt;method_holder());</span>
2997   return JVMTI_ERROR_NONE;
2998 } /* end GetMethodDeclaringClass */
2999 
3000 
<span class="line-modified">3001 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3002 // modifiers_ptr - pre-checked for NULL
3003 jvmtiError
<span class="line-modified">3004 JvmtiEnv::GetMethodModifiers(Method* method_oop, jint* modifiers_ptr) {</span>
<span class="line-modified">3005   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">3006   (*modifiers_ptr) = method_oop-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;</span>
3007   return JVMTI_ERROR_NONE;
3008 } /* end GetMethodModifiers */
3009 
3010 
<span class="line-modified">3011 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3012 // max_ptr - pre-checked for NULL
3013 jvmtiError
<span class="line-modified">3014 JvmtiEnv::GetMaxLocals(Method* method_oop, jint* max_ptr) {</span>
<span class="line-modified">3015   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
3016   // get max stack
<span class="line-modified">3017   (*max_ptr) = method_oop-&gt;max_locals();</span>
3018   return JVMTI_ERROR_NONE;
3019 } /* end GetMaxLocals */
3020 
3021 
<span class="line-modified">3022 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3023 // size_ptr - pre-checked for NULL
3024 jvmtiError
<span class="line-modified">3025 JvmtiEnv::GetArgumentsSize(Method* method_oop, jint* size_ptr) {</span>
<span class="line-modified">3026   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
3027   // get size of arguments
3028 
<span class="line-modified">3029   (*size_ptr) = method_oop-&gt;size_of_parameters();</span>
3030   return JVMTI_ERROR_NONE;
3031 } /* end GetArgumentsSize */
3032 
3033 
<span class="line-modified">3034 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3035 // entry_count_ptr - pre-checked for NULL
3036 // table_ptr - pre-checked for NULL
3037 jvmtiError
<span class="line-modified">3038 JvmtiEnv::GetLineNumberTable(Method* method_oop, jint* entry_count_ptr, jvmtiLineNumberEntry** table_ptr) {</span>
<span class="line-modified">3039   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">3040   if (!method_oop-&gt;has_linenumber_table()) {</span>
3041     return (JVMTI_ERROR_ABSENT_INFORMATION);
3042   }
3043 
3044   // The line number table is compressed so we don&#39;t know how big it is until decompressed.
3045   // Decompression is really fast so we just do it twice.
3046 
3047   // Compute size of table
3048   jint num_entries = 0;
<span class="line-modified">3049   CompressedLineNumberReadStream stream(method_oop-&gt;compressed_linenumber_table());</span>
3050   while (stream.read_pair()) {
3051     num_entries++;
3052   }
3053   jvmtiLineNumberEntry *jvmti_table =
3054             (jvmtiLineNumberEntry *)jvmtiMalloc(num_entries * (sizeof(jvmtiLineNumberEntry)));
3055 
3056   // Fill jvmti table
3057   if (num_entries &gt; 0) {
3058     int index = 0;
<span class="line-modified">3059     CompressedLineNumberReadStream stream(method_oop-&gt;compressed_linenumber_table());</span>
3060     while (stream.read_pair()) {
3061       jvmti_table[index].start_location = (jlocation) stream.bci();
3062       jvmti_table[index].line_number = (jint) stream.line();
3063       index++;
3064     }
3065     assert(index == num_entries, &quot;sanity check&quot;);
3066   }
3067 
3068   // Set up results
3069   (*entry_count_ptr) = num_entries;
3070   (*table_ptr) = jvmti_table;
3071 
3072   return JVMTI_ERROR_NONE;
3073 } /* end GetLineNumberTable */
3074 
3075 
<span class="line-modified">3076 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3077 // start_location_ptr - pre-checked for NULL
3078 // end_location_ptr - pre-checked for NULL
3079 jvmtiError
<span class="line-modified">3080 JvmtiEnv::GetMethodLocation(Method* method_oop, jlocation* start_location_ptr, jlocation* end_location_ptr) {</span>
3081 
<span class="line-modified">3082   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
3083   // get start and end location
<span class="line-modified">3084   (*end_location_ptr) = (jlocation) (method_oop-&gt;code_size() - 1);</span>
<span class="line-modified">3085   if (method_oop-&gt;code_size() == 0) {</span>
3086     // there is no code so there is no start location
3087     (*start_location_ptr) = (jlocation)(-1);
3088   } else {
3089     (*start_location_ptr) = (jlocation)(0);
3090   }
3091 
3092   return JVMTI_ERROR_NONE;
3093 } /* end GetMethodLocation */
3094 
3095 
<span class="line-modified">3096 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3097 // entry_count_ptr - pre-checked for NULL
3098 // table_ptr - pre-checked for NULL
3099 jvmtiError
<span class="line-modified">3100 JvmtiEnv::GetLocalVariableTable(Method* method_oop, jint* entry_count_ptr, jvmtiLocalVariableEntry** table_ptr) {</span>
3101 
<span class="line-modified">3102   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
3103   JavaThread* current_thread  = JavaThread::current();
3104 
3105   // does the klass have any local variable information?
<span class="line-modified">3106   InstanceKlass* ik = method_oop-&gt;method_holder();</span>
3107   if (!ik-&gt;access_flags().has_localvariable_table()) {
3108     return (JVMTI_ERROR_ABSENT_INFORMATION);
3109   }
3110 
<span class="line-modified">3111   ConstantPool* constants = method_oop-&gt;constants();</span>
3112   NULL_CHECK(constants, JVMTI_ERROR_ABSENT_INFORMATION);
3113 
3114   // in the vm localvariable table representation, 6 consecutive elements in the table
3115   // represent a 6-tuple of shorts
3116   // [start_pc, length, name_index, descriptor_index, signature_index, index]
<span class="line-modified">3117   jint num_entries = method_oop-&gt;localvariable_table_length();</span>
3118   jvmtiLocalVariableEntry *jvmti_table = (jvmtiLocalVariableEntry *)
3119                 jvmtiMalloc(num_entries * (sizeof(jvmtiLocalVariableEntry)));
3120 
3121   if (num_entries &gt; 0) {
<span class="line-modified">3122     LocalVariableTableElement* table = method_oop-&gt;localvariable_table_start();</span>
3123     for (int i = 0; i &lt; num_entries; i++) {
3124       // get the 5 tuple information from the vm table
3125       jlocation start_location = (jlocation) table[i].start_bci;
3126       jint length = (jint) table[i].length;
3127       int name_index = (int) table[i].name_cp_index;
3128       int signature_index = (int) table[i].descriptor_cp_index;
3129       int generic_signature_index = (int) table[i].signature_cp_index;
3130       jint slot = (jint) table[i].slot;
3131 
3132       // get utf8 name and signature
3133       char *name_buf = NULL;
3134       char *sig_buf = NULL;
3135       char *gen_sig_buf = NULL;
3136       {
3137         ResourceMark rm(current_thread);
3138 
3139         const char *utf8_name = (const char *) constants-&gt;symbol_at(name_index)-&gt;as_utf8();
3140         name_buf = (char *) jvmtiMalloc(strlen(utf8_name)+1);
3141         strcpy(name_buf, utf8_name);
3142 
</pre>
<hr />
<pre>
3153       }
3154 
3155       // fill in the jvmti local variable table
3156       jvmti_table[i].start_location = start_location;
3157       jvmti_table[i].length = length;
3158       jvmti_table[i].name = name_buf;
3159       jvmti_table[i].signature = sig_buf;
3160       jvmti_table[i].generic_signature = gen_sig_buf;
3161       jvmti_table[i].slot = slot;
3162     }
3163   }
3164 
3165   // set results
3166   (*entry_count_ptr) = num_entries;
3167   (*table_ptr) = jvmti_table;
3168 
3169   return JVMTI_ERROR_NONE;
3170 } /* end GetLocalVariableTable */
3171 
3172 
<span class="line-modified">3173 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3174 // bytecode_count_ptr - pre-checked for NULL
3175 // bytecodes_ptr - pre-checked for NULL
3176 jvmtiError
<span class="line-modified">3177 JvmtiEnv::GetBytecodes(Method* method_oop, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {</span>
<span class="line-modified">3178   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
3179 
<span class="line-modified">3180   HandleMark hm;</span>
<span class="line-modified">3181   methodHandle method(Thread::current(), method_oop);</span>
<span class="line-removed">3182   jint size = (jint)method-&gt;code_size();</span>
3183   jvmtiError err = allocate(size, bytecodes_ptr);
3184   if (err != JVMTI_ERROR_NONE) {
3185     return err;
3186   }
3187 
3188   (*bytecode_count_ptr) = size;
3189   // get byte codes
<span class="line-modified">3190   JvmtiClassFileReconstituter::copy_bytecodes(method, *bytecodes_ptr);</span>
3191 
3192   return JVMTI_ERROR_NONE;
3193 } /* end GetBytecodes */
3194 
3195 
<span class="line-modified">3196 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3197 // is_native_ptr - pre-checked for NULL
3198 jvmtiError
<span class="line-modified">3199 JvmtiEnv::IsMethodNative(Method* method_oop, jboolean* is_native_ptr) {</span>
<span class="line-modified">3200   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">3201   (*is_native_ptr) = method_oop-&gt;is_native();</span>
3202   return JVMTI_ERROR_NONE;
3203 } /* end IsMethodNative */
3204 
3205 
<span class="line-modified">3206 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3207 // is_synthetic_ptr - pre-checked for NULL
3208 jvmtiError
<span class="line-modified">3209 JvmtiEnv::IsMethodSynthetic(Method* method_oop, jboolean* is_synthetic_ptr) {</span>
<span class="line-modified">3210   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">3211   (*is_synthetic_ptr) = method_oop-&gt;is_synthetic();</span>
3212   return JVMTI_ERROR_NONE;
3213 } /* end IsMethodSynthetic */
3214 
3215 
<span class="line-modified">3216 // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
3217 // is_obsolete_ptr - pre-checked for NULL
3218 jvmtiError
<span class="line-modified">3219 JvmtiEnv::IsMethodObsolete(Method* method_oop, jboolean* is_obsolete_ptr) {</span>
3220   if (use_version_1_0_semantics() &amp;&amp;
3221       get_capabilities()-&gt;can_redefine_classes == 0) {
3222     // This JvmtiEnv requested version 1.0 semantics and this function
3223     // requires the can_redefine_classes capability in version 1.0 so
3224     // we need to return an error here.
3225     return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
3226   }
3227 
<span class="line-modified">3228   if (method_oop == NULL || method_oop-&gt;is_obsolete()) {</span>
3229     *is_obsolete_ptr = true;
3230   } else {
3231     *is_obsolete_ptr = false;
3232   }
3233   return JVMTI_ERROR_NONE;
3234 } /* end IsMethodObsolete */
3235 
3236   //
3237   // Raw Monitor functions
3238   //
3239 
3240 // name - pre-checked for NULL
3241 // monitor_ptr - pre-checked for NULL
3242 jvmtiError
3243 JvmtiEnv::CreateRawMonitor(const char* name, jrawMonitorID* monitor_ptr) {
3244   JvmtiRawMonitor* rmonitor = new JvmtiRawMonitor(name);
3245   NULL_CHECK(rmonitor, JVMTI_ERROR_OUT_OF_MEMORY);
3246 
3247   *monitor_ptr = (jrawMonitorID)rmonitor;
3248 
</pre>
</td>
<td>
<hr />
<pre>
 643     Arguments::append_sysclasspath(segment);
 644     return JVMTI_ERROR_NONE;
 645   } else if (use_version_1_0_semantics()) {
 646     // This JvmtiEnv requested version 1.0 semantics and this function
 647     // is only allowed in the ONLOAD phase in version 1.0 so we need to
 648     // return an error here.
 649     return JVMTI_ERROR_WRONG_PHASE;
 650   } else if (phase == JVMTI_PHASE_LIVE) {
 651     // The phase is checked by the wrapper that called this function,
 652     // but this thread could be racing with the thread that is
 653     // terminating the VM so we check one more time.
 654 
 655     // create the zip entry
 656     ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, true);
 657     if (zip_entry == NULL) {
 658       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 659     }
 660 
 661     // lock the loader
 662     Thread* thread = Thread::current();
<span class="line-modified"> 663     HandleMark hm(thread);</span>
 664     Handle loader_lock = Handle(thread, SystemDictionary::system_loader_lock());
 665 
 666     ObjectLocker ol(loader_lock, thread);
 667 
 668     // add the jar file to the bootclasspath
 669     log_info(class, load)(&quot;opened: %s&quot;, zip_entry-&gt;name());
 670 #if INCLUDE_CDS
 671     ClassLoaderExt::append_boot_classpath(zip_entry);
 672 #else
 673     ClassLoader::add_to_boot_append_entries(zip_entry);
 674 #endif
 675     return JVMTI_ERROR_NONE;
 676   } else {
 677     return JVMTI_ERROR_WRONG_PHASE;
 678   }
 679 
 680 } /* end AddToBootstrapClassLoaderSearch */
 681 
 682 
 683 // segment - pre-checked for NULL
 684 jvmtiError
 685 JvmtiEnv::AddToSystemClassLoaderSearch(const char* segment) {
 686   jvmtiPhase phase = get_phase();
 687 
 688   if (phase == JVMTI_PHASE_ONLOAD) {
 689     for (SystemProperty* p = Arguments::system_properties(); p != NULL; p = p-&gt;next()) {
 690       if (strcmp(&quot;java.class.path&quot;, p-&gt;key()) == 0) {
 691         p-&gt;append_value(segment);
 692         break;
 693       }
 694     }
 695     return JVMTI_ERROR_NONE;
 696   } else if (phase == JVMTI_PHASE_LIVE) {
 697     // The phase is checked by the wrapper that called this function,
 698     // but this thread could be racing with the thread that is
 699     // terminating the VM so we check one more time.
<span class="line-modified"> 700     Thread* THREAD = Thread::current();</span>
<span class="line-added"> 701     HandleMark hm(THREAD);</span>
 702 
 703     // create the zip entry (which will open the zip file and hence
 704     // check that the segment is indeed a zip file).
 705     ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, false);
 706     if (zip_entry == NULL) {
 707       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 708     }
 709     delete zip_entry;   // no longer needed
 710 
 711     // lock the loader

 712     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());

 713     ObjectLocker ol(loader, THREAD);
 714 
 715     // need the path as java.lang.String
 716     Handle path = java_lang_String::create_from_platform_dependent_str(segment, THREAD);
 717     if (HAS_PENDING_EXCEPTION) {
 718       CLEAR_PENDING_EXCEPTION;
 719       return JVMTI_ERROR_INTERNAL;
 720     }
 721 
 722     // Invoke the appendToClassPathForInstrumentation method - if the method
 723     // is not found it means the loader doesn&#39;t support adding to the class path
 724     // in the live phase.
 725     {
 726       JavaValue res(T_VOID);
 727       JavaCalls::call_special(&amp;res,
 728                               loader,
 729                               loader-&gt;klass(),
 730                               vmSymbols::appendToClassPathForInstrumentation_name(),
 731                               vmSymbols::appendToClassPathForInstrumentation_signature(),
 732                               path,
</pre>
<hr />
<pre>
 897   *thread_state_ptr = state;
 898   return JVMTI_ERROR_NONE;
 899 } /* end GetThreadState */
 900 
 901 
 902 // thread_ptr - pre-checked for NULL
 903 jvmtiError
 904 JvmtiEnv::GetCurrentThread(jthread* thread_ptr) {
 905   JavaThread* current_thread  = JavaThread::current();
 906   *thread_ptr = (jthread)JNIHandles::make_local(current_thread, current_thread-&gt;threadObj());
 907   return JVMTI_ERROR_NONE;
 908 } /* end GetCurrentThread */
 909 
 910 
 911 // threads_count_ptr - pre-checked for NULL
 912 // threads_ptr - pre-checked for NULL
 913 jvmtiError
 914 JvmtiEnv::GetAllThreads(jint* threads_count_ptr, jthread** threads_ptr) {
 915   int nthreads        = 0;
 916   Handle *thread_objs = NULL;
<span class="line-modified"> 917   Thread* current_thread = Thread::current();</span>
<span class="line-modified"> 918   ResourceMark rm(current_thread);</span>
<span class="line-added"> 919   HandleMark hm(current_thread);</span>
 920 
 921   // enumerate threads (including agent threads)
<span class="line-modified"> 922   ThreadsListEnumerator tle(current_thread, true);</span>
 923   nthreads = tle.num_threads();
 924   *threads_count_ptr = nthreads;
 925 
 926   if (nthreads == 0) {
 927     *threads_ptr = NULL;
 928     return JVMTI_ERROR_NONE;
 929   }
 930 
 931   thread_objs = NEW_RESOURCE_ARRAY(Handle, nthreads);
 932   NULL_CHECK(thread_objs, JVMTI_ERROR_OUT_OF_MEMORY);
 933 
 934   for (int i = 0; i &lt; nthreads; i++) {
 935     thread_objs[i] = Handle(tle.get_threadObj(i));
 936   }
 937 
 938   jthread *jthreads  = new_jthreadArray(nthreads, thread_objs);
 939   NULL_CHECK(jthreads, JVMTI_ERROR_OUT_OF_MEMORY);
 940 
 941   *threads_ptr = jthreads;
 942   return JVMTI_ERROR_NONE;
</pre>
<hr />
<pre>
1108   jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &amp;java_thread, NULL);
1109   if (err != JVMTI_ERROR_NONE) {
1110     return err;
1111   }
1112   // Really this should be a Java call to Thread.interrupt to ensure the same
1113   // semantics, however historically this has not been done for some reason.
1114   // So we continue with that (which means we don&#39;t interact with any Java-level
1115   // Interruptible object) but we must set the Java-level interrupted state.
1116   java_lang_Thread::set_interrupted(JNIHandles::resolve(thread), true);
1117   java_thread-&gt;interrupt();
1118 
1119   return JVMTI_ERROR_NONE;
1120 } /* end InterruptThread */
1121 
1122 
1123 // Threads_lock NOT held
1124 // thread - NOT pre-checked
1125 // info_ptr - pre-checked for NULL
1126 jvmtiError
1127 JvmtiEnv::GetThreadInfo(jthread thread, jvmtiThreadInfo* info_ptr) {



1128   JavaThread* current_thread = JavaThread::current();
<span class="line-added">1129   ResourceMark rm(current_thread);</span>
<span class="line-added">1130   HandleMark hm(current_thread);</span>
<span class="line-added">1131 </span>
1132   ThreadsListHandle tlh(current_thread);
1133 
1134   // if thread is NULL the current thread is used
1135   oop thread_oop = NULL;
1136   if (thread == NULL) {
1137     thread_oop = current_thread-&gt;threadObj();
1138     if (thread_oop == NULL || !thread_oop-&gt;is_a(SystemDictionary::Thread_klass())) {
1139       return JVMTI_ERROR_INVALID_THREAD;
1140     }
1141   } else {
1142     JavaThread* java_thread = NULL;
1143     jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &amp;java_thread, &amp;thread_oop);
1144     if (err != JVMTI_ERROR_NONE) {
1145       // We got an error code so we don&#39;t have a JavaThread *, but
1146       // only return an error from here if we didn&#39;t get a valid
1147       // thread_oop.
1148       if (thread_oop == NULL) {
1149         return err;
1150       }
1151       // We have a valid thread_oop so we can return some thread info.
</pre>
<hr />
<pre>
1383   // Allocate memory to store global-refs to the thread groups.
1384   // Assume this area is freed by caller.
1385   *groups_ptr = (jthreadGroup *) jvmtiMalloc((sizeof(jthreadGroup)) * (*group_count_ptr));
1386 
1387   NULL_CHECK(*groups_ptr, JVMTI_ERROR_OUT_OF_MEMORY);
1388 
1389   // Convert oop to Handle, then convert Handle to global-ref.
1390   {
1391     HandleMark hm(current_thread);
1392     Handle system_thread_group(current_thread, Universe::system_thread_group());
1393     *groups_ptr[0] = jni_reference(system_thread_group);
1394   }
1395 
1396   return JVMTI_ERROR_NONE;
1397 } /* end GetTopThreadGroups */
1398 
1399 
1400 // info_ptr - pre-checked for NULL
1401 jvmtiError
1402 JvmtiEnv::GetThreadGroupInfo(jthreadGroup group, jvmtiThreadGroupInfo* info_ptr) {
<span class="line-modified">1403   Thread* current_thread = Thread::current();</span>
<span class="line-modified">1404   ResourceMark rm(current_thread);</span>
<span class="line-modified">1405   HandleMark hm(current_thread);</span>

1406 
1407   Handle group_obj (current_thread, JNIHandles::resolve_external_guard(group));
1408   NULL_CHECK(group_obj(), JVMTI_ERROR_INVALID_THREAD_GROUP);
1409 
1410   const char* name;
1411   Handle parent_group;
1412   bool is_daemon;
1413   ThreadPriority max_priority;
1414 
1415   name         = java_lang_ThreadGroup::name(group_obj());
1416   parent_group = Handle(current_thread, java_lang_ThreadGroup::parent(group_obj()));
1417   is_daemon    = java_lang_ThreadGroup::is_daemon(group_obj());
1418   max_priority = java_lang_ThreadGroup::maxPriority(group_obj());
1419 
1420   info_ptr-&gt;is_daemon    = is_daemon;
1421   info_ptr-&gt;max_priority = max_priority;
1422   info_ptr-&gt;parent       = jni_reference(parent_group);
1423 
1424   if (name != NULL) {
1425     info_ptr-&gt;name = (char*)jvmtiMalloc(strlen(name)+1);
</pre>
<hr />
<pre>
1600     }
1601   }
1602   return err;
1603 } /* end GetThreadListStackTraces */
1604 
1605 
1606 // Threads_lock NOT held, java_thread not protected by lock
1607 // java_thread - pre-checked
1608 // count_ptr - pre-checked for NULL
1609 jvmtiError
1610 JvmtiEnv::GetFrameCount(JavaThread* java_thread, jint* count_ptr) {
1611   jvmtiError err = JVMTI_ERROR_NONE;
1612 
1613   // retrieve or create JvmtiThreadState.
1614   JvmtiThreadState* state = JvmtiThreadState::state_for(java_thread);
1615   if (state == NULL) {
1616     return JVMTI_ERROR_THREAD_NOT_ALIVE;
1617   }
1618 
1619   // It is only safe to perform the direct operation on the current
<span class="line-modified">1620   // thread. All other usage needs to use a direct handshake for safety.</span>
1621   if (java_thread == JavaThread::current()) {
1622     err = get_frame_count(state, count_ptr);
1623   } else {
<span class="line-modified">1624     // get java stack frame count with handshake.</span>
<span class="line-modified">1625     GetFrameCountClosure op(this, state, count_ptr);</span>
<span class="line-modified">1626     bool executed = Handshake::execute_direct(&amp;op, java_thread);</span>
<span class="line-modified">1627     err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;</span>
1628   }
1629   return err;
1630 } /* end GetFrameCount */
1631 
1632 
1633 // Threads_lock NOT held, java_thread not protected by lock
1634 // java_thread - pre-checked
1635 jvmtiError
1636 JvmtiEnv::PopFrame(JavaThread* java_thread) {
1637   JavaThread* current_thread  = JavaThread::current();
1638   HandleMark hm(current_thread);
1639   uint32_t debug_bits = 0;
1640 
1641   // retrieve or create the state
1642   JvmtiThreadState* state = JvmtiThreadState::state_for(java_thread);
1643   if (state == NULL) {
1644     return JVMTI_ERROR_THREAD_NOT_ALIVE;
1645   }
1646 
1647   // Check if java_thread is fully suspended
</pre>
<hr />
<pre>
1730     // Set pending step flag for this popframe and it is cleared when next
1731     // step event is posted.
1732     state-&gt;set_pending_step_for_popframe();
1733   }
1734 
1735   return JVMTI_ERROR_NONE;
1736 } /* end PopFrame */
1737 
1738 
1739 // Threads_lock NOT held, java_thread not protected by lock
1740 // java_thread - pre-checked
1741 // java_thread - unchecked
1742 // depth - pre-checked as non-negative
1743 // method_ptr - pre-checked for NULL
1744 // location_ptr - pre-checked for NULL
1745 jvmtiError
1746 JvmtiEnv::GetFrameLocation(JavaThread* java_thread, jint depth, jmethodID* method_ptr, jlocation* location_ptr) {
1747   jvmtiError err = JVMTI_ERROR_NONE;
1748 
1749   // It is only safe to perform the direct operation on the current
<span class="line-modified">1750   // thread. All other usage needs to use a direct handshake for safety.</span>
1751   if (java_thread == JavaThread::current()) {
1752     err = get_frame_location(java_thread, depth, method_ptr, location_ptr);
1753   } else {
<span class="line-modified">1754     // JVMTI get java stack frame location via direct handshake.</span>
<span class="line-modified">1755     GetFrameLocationClosure op(this, depth, method_ptr, location_ptr);</span>
<span class="line-modified">1756     bool executed = Handshake::execute_direct(&amp;op, java_thread);</span>
<span class="line-modified">1757     err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;</span>
1758   }
1759   return err;
1760 } /* end GetFrameLocation */
1761 
1762 
1763 // Threads_lock NOT held, java_thread not protected by lock
1764 // java_thread - pre-checked
1765 // java_thread - unchecked
1766 // depth - pre-checked as non-negative
1767 jvmtiError
1768 JvmtiEnv::NotifyFramePop(JavaThread* java_thread, jint depth) {
1769   jvmtiError err = JVMTI_ERROR_NONE;
1770   ResourceMark rm;
1771   uint32_t debug_bits = 0;
1772 
1773   JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread);
1774   if (state == NULL) {
1775     return JVMTI_ERROR_THREAD_NOT_ALIVE;
1776   }
1777 
</pre>
<hr />
<pre>
2232 // java_thread - pre-checked
2233 // java_thread - unchecked
2234 // depth - pre-checked as non-negative
2235 jvmtiError
2236 JvmtiEnv::SetLocalDouble(JavaThread* java_thread, jint depth, jint slot, jdouble value) {
2237   // rm object is created to clean up the javaVFrame created in
2238   // doit_prologue(), but after doit() is finished with it.
2239   ResourceMark rm;
2240   jvalue val;
2241   val.d = value;
2242   VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, val);
2243   VMThread::execute(&amp;op);
2244   return op.result();
2245 } /* end SetLocalDouble */
2246 
2247 
2248   //
2249   // Breakpoint functions
2250   //
2251 
<span class="line-modified">2252 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
2253 jvmtiError
<span class="line-modified">2254 JvmtiEnv::SetBreakpoint(Method* method, jlocation location) {</span>
<span class="line-modified">2255   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
2256   if (location &lt; 0) {   // simple invalid location check first
2257     return JVMTI_ERROR_INVALID_LOCATION;
2258   }
2259   // verify that the breakpoint is not past the end of the method
<span class="line-modified">2260   if (location &gt;= (jlocation) method-&gt;code_size()) {</span>
2261     return JVMTI_ERROR_INVALID_LOCATION;
2262   }
2263 
2264   ResourceMark rm;
<span class="line-modified">2265   JvmtiBreakpoint bp(method, location);</span>
2266   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
2267   if (jvmti_breakpoints.set(bp) == JVMTI_ERROR_DUPLICATE)
2268     return JVMTI_ERROR_DUPLICATE;
2269 
2270   if (TraceJVMTICalls) {
2271     jvmti_breakpoints.print();
2272   }
2273 
2274   return JVMTI_ERROR_NONE;
2275 } /* end SetBreakpoint */
2276 
2277 
<span class="line-modified">2278 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
2279 jvmtiError
<span class="line-modified">2280 JvmtiEnv::ClearBreakpoint(Method* method, jlocation location) {</span>
<span class="line-modified">2281   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
2282 
2283   if (location &lt; 0) {   // simple invalid location check first
2284     return JVMTI_ERROR_INVALID_LOCATION;
2285   }
2286 
2287   // verify that the breakpoint is not past the end of the method
<span class="line-modified">2288   if (location &gt;= (jlocation) method-&gt;code_size()) {</span>
2289     return JVMTI_ERROR_INVALID_LOCATION;
2290   }
2291 
<span class="line-modified">2292   JvmtiBreakpoint bp(method, location);</span>
2293 
2294   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
2295   if (jvmti_breakpoints.clear(bp) == JVMTI_ERROR_NOT_FOUND)
2296     return JVMTI_ERROR_NOT_FOUND;
2297 
2298   if (TraceJVMTICalls) {
2299     jvmti_breakpoints.print();
2300   }
2301 
2302   return JVMTI_ERROR_NONE;
2303 } /* end ClearBreakpoint */
2304 
2305 
2306   //
2307   // Watched Field functions
2308   //
2309 
2310 jvmtiError
2311 JvmtiEnv::SetFieldAccessWatch(fieldDescriptor* fdesc_ptr) {
2312   // make sure we haven&#39;t set this watch before
</pre>
<hr />
<pre>
2498   }
2499   Klass* k = java_lang_Class::as_Klass(k_mirror);
2500   NULL_CHECK(k, JVMTI_ERROR_INVALID_CLASS);
2501 
2502   // Return CLASS_NOT_PREPARED error as per JVMTI spec.
2503   if (!(k-&gt;jvmti_class_status() &amp; (JVMTI_CLASS_STATUS_PREPARED|JVMTI_CLASS_STATUS_ARRAY) )) {
2504     return JVMTI_ERROR_CLASS_NOT_PREPARED;
2505   }
2506 
2507   if (!k-&gt;is_instance_klass()) {
2508     *method_count_ptr = 0;
2509     *methods_ptr = (jmethodID*) jvmtiMalloc(0 * sizeof(jmethodID));
2510     return JVMTI_ERROR_NONE;
2511   }
2512   InstanceKlass* ik = InstanceKlass::cast(k);
2513   // Allocate the result and fill it in
2514   int result_length = ik-&gt;methods()-&gt;length();
2515   jmethodID* result_list = (jmethodID*)jvmtiMalloc(result_length * sizeof(jmethodID));
2516   int index;
2517   bool jmethodids_found = true;
<span class="line-modified">2518   int skipped = 0;  // skip overpass methods</span>
<span class="line-modified">2519 </span>
<span class="line-modified">2520   for (index = 0; index &lt; result_length; index++) {</span>
<span class="line-modified">2521     Method* m = ik-&gt;methods()-&gt;at(index);</span>
<span class="line-modified">2522     // Depending on can_maintain_original_method_order capability use the original</span>
<span class="line-modified">2523     // method ordering indices stored in the class, so we can emit jmethodIDs in</span>
<span class="line-modified">2524     // the order they appeared in the class file or just copy in current order.</span>
<span class="line-modified">2525     int result_index = JvmtiExport::can_maintain_original_method_order() ? ik-&gt;method_ordering()-&gt;at(index) : index;</span>
<span class="line-modified">2526     assert(result_index &gt;= 0 &amp;&amp; result_index &lt; result_length, &quot;invalid original method index&quot;);</span>
<span class="line-modified">2527     if (m-&gt;is_overpass()) {</span>
<span class="line-modified">2528       result_list[result_index] = NULL;</span>
<span class="line-modified">2529       skipped++;</span>
<span class="line-modified">2530       continue;</span>
<span class="line-modified">2531     }</span>
<span class="line-modified">2532     jmethodID id;</span>
<span class="line-modified">2533     if (jmethodids_found) {</span>
<span class="line-modified">2534       id = m-&gt;find_jmethod_id_or_null();</span>
<span class="line-modified">2535       if (id == NULL) {</span>
<span class="line-modified">2536         // If we find an uninitialized value, make sure there is</span>
<span class="line-modified">2537         // enough space for all the uninitialized values we might</span>
<span class="line-added">2538         // find.</span>
<span class="line-added">2539         ik-&gt;ensure_space_for_methodids(index);</span>
<span class="line-added">2540         jmethodids_found = false;</span>
2541         id = m-&gt;jmethod_id();
2542       }
<span class="line-modified">2543     } else {</span>
<span class="line-added">2544       id = m-&gt;jmethod_id();</span>
2545     }
<span class="line-modified">2546     result_list[result_index] = id;</span>
<span class="line-modified">2547   }</span>
<span class="line-modified">2548 </span>
<span class="line-modified">2549   // Fill in return value.</span>
<span class="line-modified">2550   if (skipped &gt; 0) {</span>
<span class="line-modified">2551     // copy results skipping NULL methodIDs</span>
<span class="line-modified">2552     *methods_ptr = (jmethodID*)jvmtiMalloc((result_length - skipped) * sizeof(jmethodID));</span>
<span class="line-modified">2553     *method_count_ptr = result_length - skipped;</span>
<span class="line-modified">2554     for (index = 0, skipped = 0; index &lt; result_length; index++) {</span>
<span class="line-modified">2555       if (result_list[index] == NULL) {</span>
<span class="line-modified">2556         skipped++;</span>




2557       } else {
<span class="line-modified">2558         (*methods_ptr)[index - skipped] = result_list[index];</span>
2559       }

2560     }
<span class="line-added">2561     deallocate((unsigned char *)result_list);</span>
<span class="line-added">2562   } else {</span>
<span class="line-added">2563     *method_count_ptr = result_length;</span>
<span class="line-added">2564     *methods_ptr = result_list;</span>
2565   }



2566 
2567   return JVMTI_ERROR_NONE;
2568 } /* end GetClassMethods */
2569 
2570 
2571 // k_mirror - may be primitive, this must be checked
2572 // field_count_ptr - pre-checked for NULL
2573 // fields_ptr - pre-checked for NULL
2574 jvmtiError
2575 JvmtiEnv::GetClassFields(oop k_mirror, jint* field_count_ptr, jfieldID** fields_ptr) {
2576   if (java_lang_Class::is_primitive(k_mirror)) {
2577     *field_count_ptr = 0;
2578     *fields_ptr = (jfieldID*) jvmtiMalloc(0 * sizeof(jfieldID));
2579     return JVMTI_ERROR_NONE;
2580   }
2581   JavaThread* current_thread = JavaThread::current();
2582   HandleMark hm(current_thread);
2583   Klass* k = java_lang_Class::as_Klass(k_mirror);
2584   NULL_CHECK(k, JVMTI_ERROR_INVALID_CLASS);
2585 
</pre>
<hr />
<pre>
2927   AccessFlags resultFlags = fdesc_ptr-&gt;access_flags();
2928   jint result = resultFlags.as_int();
2929   *modifiers_ptr = result;
2930 
2931   return JVMTI_ERROR_NONE;
2932 } /* end GetFieldModifiers */
2933 
2934 
2935 // is_synthetic_ptr - pre-checked for NULL
2936 jvmtiError
2937 JvmtiEnv::IsFieldSynthetic(fieldDescriptor* fdesc_ptr, jboolean* is_synthetic_ptr) {
2938   *is_synthetic_ptr = fdesc_ptr-&gt;is_synthetic();
2939   return JVMTI_ERROR_NONE;
2940 } /* end IsFieldSynthetic */
2941 
2942 
2943   //
2944   // Method functions
2945   //
2946 
<span class="line-modified">2947 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
2948 // name_ptr - NULL is a valid value, must be checked
2949 // signature_ptr - NULL is a valid value, must be checked
2950 // generic_ptr - NULL is a valid value, must be checked
2951 jvmtiError
<span class="line-modified">2952 JvmtiEnv::GetMethodName(Method* method, char** name_ptr, char** signature_ptr, char** generic_ptr) {</span>
<span class="line-modified">2953   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
2954   JavaThread* current_thread  = JavaThread::current();
2955 
2956   ResourceMark rm(current_thread); // get the utf8 name and signature
2957   if (name_ptr == NULL) {
2958     // just don&#39;t return the name
2959   } else {
<span class="line-modified">2960     const char* utf8_name = (const char *) method-&gt;name()-&gt;as_utf8();</span>
2961     *name_ptr = (char *) jvmtiMalloc(strlen(utf8_name)+1);
2962     strcpy(*name_ptr, utf8_name);
2963   }
2964   if (signature_ptr == NULL) {
2965     // just don&#39;t return the signature
2966   } else {
<span class="line-modified">2967     const char* utf8_signature = (const char *) method-&gt;signature()-&gt;as_utf8();</span>
2968     *signature_ptr = (char *) jvmtiMalloc(strlen(utf8_signature) + 1);
2969     strcpy(*signature_ptr, utf8_signature);
2970   }
2971 
2972   if (generic_ptr != NULL) {
2973     *generic_ptr = NULL;
<span class="line-modified">2974     Symbol* soop = method-&gt;generic_signature();</span>
2975     if (soop != NULL) {
2976       const char* gen_sig = soop-&gt;as_C_string();
2977       if (gen_sig != NULL) {
2978         jvmtiError err = allocate(strlen(gen_sig) + 1, (unsigned char **)generic_ptr);
2979         if (err != JVMTI_ERROR_NONE) {
2980           return err;
2981         }
2982         strcpy(*generic_ptr, gen_sig);
2983       }
2984     }
2985   }
2986   return JVMTI_ERROR_NONE;
2987 } /* end GetMethodName */
2988 
2989 
<span class="line-modified">2990 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
2991 // declaring_class_ptr - pre-checked for NULL
2992 jvmtiError
<span class="line-modified">2993 JvmtiEnv::GetMethodDeclaringClass(Method* method, jclass* declaring_class_ptr) {</span>
<span class="line-modified">2994   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">2995   (*declaring_class_ptr) = get_jni_class_non_null(method-&gt;method_holder());</span>
2996   return JVMTI_ERROR_NONE;
2997 } /* end GetMethodDeclaringClass */
2998 
2999 
<span class="line-modified">3000 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3001 // modifiers_ptr - pre-checked for NULL
3002 jvmtiError
<span class="line-modified">3003 JvmtiEnv::GetMethodModifiers(Method* method, jint* modifiers_ptr) {</span>
<span class="line-modified">3004   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">3005   (*modifiers_ptr) = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;</span>
3006   return JVMTI_ERROR_NONE;
3007 } /* end GetMethodModifiers */
3008 
3009 
<span class="line-modified">3010 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3011 // max_ptr - pre-checked for NULL
3012 jvmtiError
<span class="line-modified">3013 JvmtiEnv::GetMaxLocals(Method* method, jint* max_ptr) {</span>
<span class="line-modified">3014   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
3015   // get max stack
<span class="line-modified">3016   (*max_ptr) = method-&gt;max_locals();</span>
3017   return JVMTI_ERROR_NONE;
3018 } /* end GetMaxLocals */
3019 
3020 
<span class="line-modified">3021 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3022 // size_ptr - pre-checked for NULL
3023 jvmtiError
<span class="line-modified">3024 JvmtiEnv::GetArgumentsSize(Method* method, jint* size_ptr) {</span>
<span class="line-modified">3025   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
3026   // get size of arguments
3027 
<span class="line-modified">3028   (*size_ptr) = method-&gt;size_of_parameters();</span>
3029   return JVMTI_ERROR_NONE;
3030 } /* end GetArgumentsSize */
3031 
3032 
<span class="line-modified">3033 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3034 // entry_count_ptr - pre-checked for NULL
3035 // table_ptr - pre-checked for NULL
3036 jvmtiError
<span class="line-modified">3037 JvmtiEnv::GetLineNumberTable(Method* method, jint* entry_count_ptr, jvmtiLineNumberEntry** table_ptr) {</span>
<span class="line-modified">3038   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">3039   if (!method-&gt;has_linenumber_table()) {</span>
3040     return (JVMTI_ERROR_ABSENT_INFORMATION);
3041   }
3042 
3043   // The line number table is compressed so we don&#39;t know how big it is until decompressed.
3044   // Decompression is really fast so we just do it twice.
3045 
3046   // Compute size of table
3047   jint num_entries = 0;
<span class="line-modified">3048   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());</span>
3049   while (stream.read_pair()) {
3050     num_entries++;
3051   }
3052   jvmtiLineNumberEntry *jvmti_table =
3053             (jvmtiLineNumberEntry *)jvmtiMalloc(num_entries * (sizeof(jvmtiLineNumberEntry)));
3054 
3055   // Fill jvmti table
3056   if (num_entries &gt; 0) {
3057     int index = 0;
<span class="line-modified">3058     CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());</span>
3059     while (stream.read_pair()) {
3060       jvmti_table[index].start_location = (jlocation) stream.bci();
3061       jvmti_table[index].line_number = (jint) stream.line();
3062       index++;
3063     }
3064     assert(index == num_entries, &quot;sanity check&quot;);
3065   }
3066 
3067   // Set up results
3068   (*entry_count_ptr) = num_entries;
3069   (*table_ptr) = jvmti_table;
3070 
3071   return JVMTI_ERROR_NONE;
3072 } /* end GetLineNumberTable */
3073 
3074 
<span class="line-modified">3075 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3076 // start_location_ptr - pre-checked for NULL
3077 // end_location_ptr - pre-checked for NULL
3078 jvmtiError
<span class="line-modified">3079 JvmtiEnv::GetMethodLocation(Method* method, jlocation* start_location_ptr, jlocation* end_location_ptr) {</span>
3080 
<span class="line-modified">3081   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
3082   // get start and end location
<span class="line-modified">3083   (*end_location_ptr) = (jlocation) (method-&gt;code_size() - 1);</span>
<span class="line-modified">3084   if (method-&gt;code_size() == 0) {</span>
3085     // there is no code so there is no start location
3086     (*start_location_ptr) = (jlocation)(-1);
3087   } else {
3088     (*start_location_ptr) = (jlocation)(0);
3089   }
3090 
3091   return JVMTI_ERROR_NONE;
3092 } /* end GetMethodLocation */
3093 
3094 
<span class="line-modified">3095 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3096 // entry_count_ptr - pre-checked for NULL
3097 // table_ptr - pre-checked for NULL
3098 jvmtiError
<span class="line-modified">3099 JvmtiEnv::GetLocalVariableTable(Method* method, jint* entry_count_ptr, jvmtiLocalVariableEntry** table_ptr) {</span>
3100 
<span class="line-modified">3101   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
3102   JavaThread* current_thread  = JavaThread::current();
3103 
3104   // does the klass have any local variable information?
<span class="line-modified">3105   InstanceKlass* ik = method-&gt;method_holder();</span>
3106   if (!ik-&gt;access_flags().has_localvariable_table()) {
3107     return (JVMTI_ERROR_ABSENT_INFORMATION);
3108   }
3109 
<span class="line-modified">3110   ConstantPool* constants = method-&gt;constants();</span>
3111   NULL_CHECK(constants, JVMTI_ERROR_ABSENT_INFORMATION);
3112 
3113   // in the vm localvariable table representation, 6 consecutive elements in the table
3114   // represent a 6-tuple of shorts
3115   // [start_pc, length, name_index, descriptor_index, signature_index, index]
<span class="line-modified">3116   jint num_entries = method-&gt;localvariable_table_length();</span>
3117   jvmtiLocalVariableEntry *jvmti_table = (jvmtiLocalVariableEntry *)
3118                 jvmtiMalloc(num_entries * (sizeof(jvmtiLocalVariableEntry)));
3119 
3120   if (num_entries &gt; 0) {
<span class="line-modified">3121     LocalVariableTableElement* table = method-&gt;localvariable_table_start();</span>
3122     for (int i = 0; i &lt; num_entries; i++) {
3123       // get the 5 tuple information from the vm table
3124       jlocation start_location = (jlocation) table[i].start_bci;
3125       jint length = (jint) table[i].length;
3126       int name_index = (int) table[i].name_cp_index;
3127       int signature_index = (int) table[i].descriptor_cp_index;
3128       int generic_signature_index = (int) table[i].signature_cp_index;
3129       jint slot = (jint) table[i].slot;
3130 
3131       // get utf8 name and signature
3132       char *name_buf = NULL;
3133       char *sig_buf = NULL;
3134       char *gen_sig_buf = NULL;
3135       {
3136         ResourceMark rm(current_thread);
3137 
3138         const char *utf8_name = (const char *) constants-&gt;symbol_at(name_index)-&gt;as_utf8();
3139         name_buf = (char *) jvmtiMalloc(strlen(utf8_name)+1);
3140         strcpy(name_buf, utf8_name);
3141 
</pre>
<hr />
<pre>
3152       }
3153 
3154       // fill in the jvmti local variable table
3155       jvmti_table[i].start_location = start_location;
3156       jvmti_table[i].length = length;
3157       jvmti_table[i].name = name_buf;
3158       jvmti_table[i].signature = sig_buf;
3159       jvmti_table[i].generic_signature = gen_sig_buf;
3160       jvmti_table[i].slot = slot;
3161     }
3162   }
3163 
3164   // set results
3165   (*entry_count_ptr) = num_entries;
3166   (*table_ptr) = jvmti_table;
3167 
3168   return JVMTI_ERROR_NONE;
3169 } /* end GetLocalVariableTable */
3170 
3171 
<span class="line-modified">3172 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3173 // bytecode_count_ptr - pre-checked for NULL
3174 // bytecodes_ptr - pre-checked for NULL
3175 jvmtiError
<span class="line-modified">3176 JvmtiEnv::GetBytecodes(Method* method, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {</span>
<span class="line-modified">3177   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
3178 
<span class="line-modified">3179   methodHandle mh(Thread::current(), method);</span>
<span class="line-modified">3180   jint size = (jint)mh-&gt;code_size();</span>

3181   jvmtiError err = allocate(size, bytecodes_ptr);
3182   if (err != JVMTI_ERROR_NONE) {
3183     return err;
3184   }
3185 
3186   (*bytecode_count_ptr) = size;
3187   // get byte codes
<span class="line-modified">3188   JvmtiClassFileReconstituter::copy_bytecodes(mh, *bytecodes_ptr);</span>
3189 
3190   return JVMTI_ERROR_NONE;
3191 } /* end GetBytecodes */
3192 
3193 
<span class="line-modified">3194 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3195 // is_native_ptr - pre-checked for NULL
3196 jvmtiError
<span class="line-modified">3197 JvmtiEnv::IsMethodNative(Method* method, jboolean* is_native_ptr) {</span>
<span class="line-modified">3198   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">3199   (*is_native_ptr) = method-&gt;is_native();</span>
3200   return JVMTI_ERROR_NONE;
3201 } /* end IsMethodNative */
3202 
3203 
<span class="line-modified">3204 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3205 // is_synthetic_ptr - pre-checked for NULL
3206 jvmtiError
<span class="line-modified">3207 JvmtiEnv::IsMethodSynthetic(Method* method, jboolean* is_synthetic_ptr) {</span>
<span class="line-modified">3208   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">3209   (*is_synthetic_ptr) = method-&gt;is_synthetic();</span>
3210   return JVMTI_ERROR_NONE;
3211 } /* end IsMethodSynthetic */
3212 
3213 
<span class="line-modified">3214 // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
3215 // is_obsolete_ptr - pre-checked for NULL
3216 jvmtiError
<span class="line-modified">3217 JvmtiEnv::IsMethodObsolete(Method* method, jboolean* is_obsolete_ptr) {</span>
3218   if (use_version_1_0_semantics() &amp;&amp;
3219       get_capabilities()-&gt;can_redefine_classes == 0) {
3220     // This JvmtiEnv requested version 1.0 semantics and this function
3221     // requires the can_redefine_classes capability in version 1.0 so
3222     // we need to return an error here.
3223     return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
3224   }
3225 
<span class="line-modified">3226   if (method == NULL || method-&gt;is_obsolete()) {</span>
3227     *is_obsolete_ptr = true;
3228   } else {
3229     *is_obsolete_ptr = false;
3230   }
3231   return JVMTI_ERROR_NONE;
3232 } /* end IsMethodObsolete */
3233 
3234   //
3235   // Raw Monitor functions
3236   //
3237 
3238 // name - pre-checked for NULL
3239 // monitor_ptr - pre-checked for NULL
3240 jvmtiError
3241 JvmtiEnv::CreateRawMonitor(const char* name, jrawMonitorID* monitor_ptr) {
3242   JvmtiRawMonitor* rmonitor = new JvmtiRawMonitor(name);
3243   NULL_CHECK(rmonitor, JVMTI_ERROR_OUT_OF_MEMORY);
3244 
3245   *monitor_ptr = (jrawMonitorID)rmonitor;
3246 
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnter.xsl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.xsl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>