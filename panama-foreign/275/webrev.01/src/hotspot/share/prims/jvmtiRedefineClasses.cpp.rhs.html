<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/verifier.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;interpreter/oopMapCache.hpp&quot;
  37 #include &quot;interpreter/rewriter.hpp&quot;
  38 #include &quot;jfr/jfrEvents.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/metadataFactory.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/annotations.hpp&quot;
  45 #include &quot;oops/constantPool.hpp&quot;
  46 #include &quot;oops/fieldStreams.inline.hpp&quot;
  47 #include &quot;oops/klassVtable.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;oops/recordComponent.hpp&quot;
  50 #include &quot;prims/jvmtiImpl.hpp&quot;
  51 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  53 #include &quot;prims/resolvedMethodTable.hpp&quot;
  54 #include &quot;prims/methodComparator.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/relocator.hpp&quot;
  60 #include &quot;runtime/safepointVerifiers.hpp&quot;
  61 #include &quot;utilities/bitMap.inline.hpp&quot;
  62 #include &quot;utilities/events.hpp&quot;
  63 
  64 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  65 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  67 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  68 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  69 Method**  VM_RedefineClasses::_added_methods        = NULL;
  70 int       VM_RedefineClasses::_matching_methods_length = 0;
  71 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  72 int       VM_RedefineClasses::_added_methods_length    = 0;
  73 
  74 // This flag is global as the constructor does not reset it:
  75 bool      VM_RedefineClasses::_has_redefined_Object = false;
  76 u8        VM_RedefineClasses::_id_counter = 0;
  77 
  78 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  79                                        const jvmtiClassDefinition *class_defs,
  80                                        JvmtiClassLoadKind class_load_kind) {
  81   _class_count = class_count;
  82   _class_defs = class_defs;
  83   _class_load_kind = class_load_kind;
  84   _any_class_has_resolved_methods = false;
  85   _res = JVMTI_ERROR_NONE;
  86   _the_class = NULL;
  87   _id = next_id();
  88 }
  89 
  90 static inline InstanceKlass* get_ik(jclass def) {
  91   oop mirror = JNIHandles::resolve_non_null(def);
  92   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  93 }
  94 
  95 // If any of the classes are being redefined, wait
  96 // Parallel constant pool merging leads to indeterminate constant pools.
  97 void VM_RedefineClasses::lock_classes() {
  98   MonitorLocker ml(RedefineClasses_lock);
  99   bool has_redefined;
 100   do {
 101     has_redefined = false;
 102     // Go through classes each time until none are being redefined.
 103     for (int i = 0; i &lt; _class_count; i++) {
 104       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
 105         ml.wait();
 106         has_redefined = true;
 107         break;  // for loop
 108       }
 109     }
 110   } while (has_redefined);
 111   for (int i = 0; i &lt; _class_count; i++) {
 112     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(true);
 113   }
 114   ml.notify_all();
 115 }
 116 
 117 void VM_RedefineClasses::unlock_classes() {
 118   MonitorLocker ml(RedefineClasses_lock);
 119   for (int i = 0; i &lt; _class_count; i++) {
 120     assert(get_ik(_class_defs[i].klass)-&gt;is_being_redefined(),
 121            &quot;should be being redefined to get here&quot;);
 122     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(false);
 123   }
 124   ml.notify_all();
 125 }
 126 
 127 bool VM_RedefineClasses::doit_prologue() {
 128   if (_class_count == 0) {
 129     _res = JVMTI_ERROR_NONE;
 130     return false;
 131   }
 132   if (_class_defs == NULL) {
 133     _res = JVMTI_ERROR_NULL_POINTER;
 134     return false;
 135   }
 136 
 137   for (int i = 0; i &lt; _class_count; i++) {
 138     if (_class_defs[i].klass == NULL) {
 139       _res = JVMTI_ERROR_INVALID_CLASS;
 140       return false;
 141     }
 142     if (_class_defs[i].class_byte_count == 0) {
 143       _res = JVMTI_ERROR_INVALID_CLASS_FORMAT;
 144       return false;
 145     }
 146     if (_class_defs[i].class_bytes == NULL) {
 147       _res = JVMTI_ERROR_NULL_POINTER;
 148       return false;
 149     }
 150 
 151     oop mirror = JNIHandles::resolve_non_null(_class_defs[i].klass);
 152     // classes for primitives, arrays, hidden and vm unsafe anonymous classes
 153     // cannot be redefined.
 154     if (!is_modifiable_class(mirror)) {
 155       _res = JVMTI_ERROR_UNMODIFIABLE_CLASS;
 156       return false;
 157     }
 158   }
 159 
 160   // Start timer after all the sanity checks; not quite accurate, but
 161   // better than adding a bunch of stop() calls.
 162   if (log_is_enabled(Info, redefine, class, timer)) {
 163     _timer_vm_op_prologue.start();
 164   }
 165 
 166   lock_classes();
 167   // We first load new class versions in the prologue, because somewhere down the
 168   // call chain it is required that the current thread is a Java thread.
 169   _res = load_new_class_versions(Thread::current());
 170   if (_res != JVMTI_ERROR_NONE) {
 171     // free any successfully created classes, since none are redefined
 172     for (int i = 0; i &lt; _class_count; i++) {
 173       if (_scratch_classes[i] != NULL) {
 174         ClassLoaderData* cld = _scratch_classes[i]-&gt;class_loader_data();
 175         // Free the memory for this class at class unloading time.  Not before
 176         // because CMS might think this is still live.
 177         InstanceKlass* ik = get_ik(_class_defs[i].klass);
 178         if (ik-&gt;get_cached_class_file() == _scratch_classes[i]-&gt;get_cached_class_file()) {
 179           // Don&#39;t double-free cached_class_file copied from the original class if error.
 180           _scratch_classes[i]-&gt;set_cached_class_file(NULL);
 181         }
 182         cld-&gt;add_to_deallocate_list(InstanceKlass::cast(_scratch_classes[i]));
 183       }
 184     }
 185     // Free os::malloc allocated memory in load_new_class_version.
 186     os::free(_scratch_classes);
 187     _timer_vm_op_prologue.stop();
 188     unlock_classes();
 189     return false;
 190   }
 191 
 192   _timer_vm_op_prologue.stop();
 193   return true;
 194 }
 195 
 196 void VM_RedefineClasses::doit() {
 197   Thread *thread = Thread::current();
 198 
 199 #if INCLUDE_CDS
 200   if (UseSharedSpaces) {
 201     // Sharing is enabled so we remap the shared readonly space to
 202     // shared readwrite, private just in case we need to redefine
 203     // a shared class. We do the remap during the doit() phase of
 204     // the safepoint to be safer.
 205     if (!MetaspaceShared::remap_shared_readonly_as_readwrite()) {
 206       log_info(redefine, class, load)(&quot;failed to remap shared readonly space to readwrite, private&quot;);
 207       _res = JVMTI_ERROR_INTERNAL;
 208       return;
 209     }
 210   }
 211 #endif
 212 
 213   // Mark methods seen on stack and everywhere else so old methods are not
 214   // cleaned up if they&#39;re on the stack.
 215   MetadataOnStackMark md_on_stack(/*walk_all_metadata*/true, /*redefinition_walk*/true);
 216   HandleMark hm(thread);   // make sure any handles created are deleted
 217                            // before the stack walk again.
 218 
 219   for (int i = 0; i &lt; _class_count; i++) {
 220     redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);
 221   }
 222 
 223   // Flush all compiled code that depends on the classes redefined.
 224   flush_dependent_code();
 225 
 226   // Adjust constantpool caches and vtables for all classes
 227   // that reference methods of the evolved classes.
 228   // Have to do this after all classes are redefined and all methods that
 229   // are redefined are marked as old.
 230   AdjustAndCleanMetadata adjust_and_clean_metadata(thread);
 231   ClassLoaderDataGraph::classes_do(&amp;adjust_and_clean_metadata);
 232 
 233   // JSR-292 support
 234   if (_any_class_has_resolved_methods) {
 235     bool trace_name_printed = false;
 236     ResolvedMethodTable::adjust_method_entries(&amp;trace_name_printed);
 237   }
 238 
 239   // Increment flag indicating that some invariants are no longer true.
 240   // See jvmtiExport.hpp for detailed explanation.
 241   JvmtiExport::increment_redefinition_count();
 242 
 243   // check_class() is optionally called for product bits, but is
 244   // always called for non-product bits.
 245 #ifdef PRODUCT
 246   if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
 247 #endif
 248     log_trace(redefine, class, obsolete, metadata)(&quot;calling check_class&quot;);
 249     CheckClass check_class(thread);
 250     ClassLoaderDataGraph::classes_do(&amp;check_class);
 251 #ifdef PRODUCT
 252   }
 253 #endif
 254 
 255   // Clean up any metadata now unreferenced while MetadataOnStackMark is set.
 256   ClassLoaderDataGraph::clean_deallocate_lists(false);
 257 }
 258 
 259 void VM_RedefineClasses::doit_epilogue() {
 260   unlock_classes();
 261 
 262   // Free os::malloc allocated memory.
 263   os::free(_scratch_classes);
 264 
 265   // Reset the_class to null for error printing.
 266   _the_class = NULL;
 267 
 268   if (log_is_enabled(Info, redefine, class, timer)) {
 269     // Used to have separate timers for &quot;doit&quot; and &quot;all&quot;, but the timer
 270     // overhead skewed the measurements.
 271     julong doit_time = _timer_rsc_phase1.milliseconds() +
 272                        _timer_rsc_phase2.milliseconds();
 273     julong all_time = _timer_vm_op_prologue.milliseconds() + doit_time;
 274 
 275     log_info(redefine, class, timer)
 276       (&quot;vm_op: all=&quot; JULONG_FORMAT &quot;  prologue=&quot; JULONG_FORMAT &quot;  doit=&quot; JULONG_FORMAT,
 277        all_time, (julong)_timer_vm_op_prologue.milliseconds(), doit_time);
 278     log_info(redefine, class, timer)
 279       (&quot;redefine_single_class: phase1=&quot; JULONG_FORMAT &quot;  phase2=&quot; JULONG_FORMAT,
 280        (julong)_timer_rsc_phase1.milliseconds(), (julong)_timer_rsc_phase2.milliseconds());
 281   }
 282 }
 283 
 284 bool VM_RedefineClasses::is_modifiable_class(oop klass_mirror) {
 285   // classes for primitives cannot be redefined
 286   if (java_lang_Class::is_primitive(klass_mirror)) {
 287     return false;
 288   }
 289   Klass* k = java_lang_Class::as_Klass(klass_mirror);
 290   // classes for arrays cannot be redefined
 291   if (k == NULL || !k-&gt;is_instance_klass()) {
 292     return false;
 293   }
 294 
 295   // Cannot redefine or retransform a hidden or an unsafe anonymous class.
 296   if (InstanceKlass::cast(k)-&gt;is_hidden() ||
 297       InstanceKlass::cast(k)-&gt;is_unsafe_anonymous()) {
 298     return false;
 299   }
 300   return true;
 301 }
 302 
 303 // Append the current entry at scratch_i in scratch_cp to *merge_cp_p
 304 // where the end of *merge_cp_p is specified by *merge_cp_length_p. For
 305 // direct CP entries, there is just the current entry to append. For
 306 // indirect and double-indirect CP entries, there are zero or more
 307 // referenced CP entries along with the current entry to append.
 308 // Indirect and double-indirect CP entries are handled by recursive
 309 // calls to append_entry() as needed. The referenced CP entries are
 310 // always appended to *merge_cp_p before the referee CP entry. These
 311 // referenced CP entries may already exist in *merge_cp_p in which case
 312 // there is nothing extra to append and only the current entry is
 313 // appended.
 314 void VM_RedefineClasses::append_entry(const constantPoolHandle&amp; scratch_cp,
 315        int scratch_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p,
 316        TRAPS) {
 317 
 318   // append is different depending on entry tag type
 319   switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 320 
 321     // The old verifier is implemented outside the VM. It loads classes,
 322     // but does not resolve constant pool entries directly so we never
 323     // see Class entries here with the old verifier. Similarly the old
 324     // verifier does not like Class entries in the input constant pool.
 325     // The split-verifier is implemented in the VM so it can optionally
 326     // and directly resolve constant pool entries to load classes. The
 327     // split-verifier can accept either Class entries or UnresolvedClass
 328     // entries in the input constant pool. We revert the appended copy
 329     // back to UnresolvedClass so that either verifier will be happy
 330     // with the constant pool entry.
 331     //
 332     // this is an indirect CP entry so it needs special handling
 333     case JVM_CONSTANT_Class:
 334     case JVM_CONSTANT_UnresolvedClass:
 335     {
 336       int name_i = scratch_cp-&gt;klass_name_index_at(scratch_i);
 337       int new_name_i = find_or_append_indirect_entry(scratch_cp, name_i, merge_cp_p,
 338                                                      merge_cp_length_p, THREAD);
 339 
 340       if (new_name_i != name_i) {
 341         log_trace(redefine, class, constantpool)
 342           (&quot;Class entry@%d name_index change: %d to %d&quot;,
 343            *merge_cp_length_p, name_i, new_name_i);
 344       }
 345 
 346       (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(*merge_cp_length_p, new_name_i);
 347       if (scratch_i != *merge_cp_length_p) {
 348         // The new entry in *merge_cp_p is at a different index than
 349         // the new entry in scratch_cp so we need to map the index values.
 350         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 351       }
 352       (*merge_cp_length_p)++;
 353     } break;
 354 
 355     // these are direct CP entries so they can be directly appended,
 356     // but double and long take two constant pool entries
 357     case JVM_CONSTANT_Double:  // fall through
 358     case JVM_CONSTANT_Long:
 359     {
 360       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 361         THREAD);
 362 
 363       if (scratch_i != *merge_cp_length_p) {
 364         // The new entry in *merge_cp_p is at a different index than
 365         // the new entry in scratch_cp so we need to map the index values.
 366         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 367       }
 368       (*merge_cp_length_p) += 2;
 369     } break;
 370 
 371     // these are direct CP entries so they can be directly appended
 372     case JVM_CONSTANT_Float:   // fall through
 373     case JVM_CONSTANT_Integer: // fall through
 374     case JVM_CONSTANT_Utf8:    // fall through
 375 
 376     // This was an indirect CP entry, but it has been changed into
 377     // Symbol*s so this entry can be directly appended.
 378     case JVM_CONSTANT_String:      // fall through
 379     {
 380       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 381         THREAD);
 382 
 383       if (scratch_i != *merge_cp_length_p) {
 384         // The new entry in *merge_cp_p is at a different index than
 385         // the new entry in scratch_cp so we need to map the index values.
 386         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 387       }
 388       (*merge_cp_length_p)++;
 389     } break;
 390 
 391     // this is an indirect CP entry so it needs special handling
 392     case JVM_CONSTANT_NameAndType:
 393     {
 394       int name_ref_i = scratch_cp-&gt;name_ref_index_at(scratch_i);
 395       int new_name_ref_i = find_or_append_indirect_entry(scratch_cp, name_ref_i, merge_cp_p,
 396                                                          merge_cp_length_p, THREAD);
 397 
 398       int signature_ref_i = scratch_cp-&gt;signature_ref_index_at(scratch_i);
 399       int new_signature_ref_i = find_or_append_indirect_entry(scratch_cp, signature_ref_i,
 400                                                               merge_cp_p, merge_cp_length_p,
 401                                                               THREAD);
 402 
 403       // If the referenced entries already exist in *merge_cp_p, then
 404       // both new_name_ref_i and new_signature_ref_i will both be 0.
 405       // In that case, all we are appending is the current entry.
 406       if (new_name_ref_i != name_ref_i) {
 407         log_trace(redefine, class, constantpool)
 408           (&quot;NameAndType entry@%d name_ref_index change: %d to %d&quot;,
 409            *merge_cp_length_p, name_ref_i, new_name_ref_i);
 410       }
 411       if (new_signature_ref_i != signature_ref_i) {
 412         log_trace(redefine, class, constantpool)
 413           (&quot;NameAndType entry@%d signature_ref_index change: %d to %d&quot;,
 414            *merge_cp_length_p, signature_ref_i, new_signature_ref_i);
 415       }
 416 
 417       (*merge_cp_p)-&gt;name_and_type_at_put(*merge_cp_length_p,
 418         new_name_ref_i, new_signature_ref_i);
 419       if (scratch_i != *merge_cp_length_p) {
 420         // The new entry in *merge_cp_p is at a different index than
 421         // the new entry in scratch_cp so we need to map the index values.
 422         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 423       }
 424       (*merge_cp_length_p)++;
 425     } break;
 426 
 427     // this is a double-indirect CP entry so it needs special handling
 428     case JVM_CONSTANT_Fieldref:           // fall through
 429     case JVM_CONSTANT_InterfaceMethodref: // fall through
 430     case JVM_CONSTANT_Methodref:
 431     {
 432       int klass_ref_i = scratch_cp-&gt;uncached_klass_ref_index_at(scratch_i);
 433       int new_klass_ref_i = find_or_append_indirect_entry(scratch_cp, klass_ref_i,
 434                                                           merge_cp_p, merge_cp_length_p, THREAD);
 435 
 436       int name_and_type_ref_i = scratch_cp-&gt;uncached_name_and_type_ref_index_at(scratch_i);
 437       int new_name_and_type_ref_i = find_or_append_indirect_entry(scratch_cp, name_and_type_ref_i,
 438                                                           merge_cp_p, merge_cp_length_p, THREAD);
 439 
 440       const char *entry_name = NULL;
 441       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 442       case JVM_CONSTANT_Fieldref:
 443         entry_name = &quot;Fieldref&quot;;
 444         (*merge_cp_p)-&gt;field_at_put(*merge_cp_length_p, new_klass_ref_i,
 445           new_name_and_type_ref_i);
 446         break;
 447       case JVM_CONSTANT_InterfaceMethodref:
 448         entry_name = &quot;IFMethodref&quot;;
 449         (*merge_cp_p)-&gt;interface_method_at_put(*merge_cp_length_p,
 450           new_klass_ref_i, new_name_and_type_ref_i);
 451         break;
 452       case JVM_CONSTANT_Methodref:
 453         entry_name = &quot;Methodref&quot;;
 454         (*merge_cp_p)-&gt;method_at_put(*merge_cp_length_p, new_klass_ref_i,
 455           new_name_and_type_ref_i);
 456         break;
 457       default:
 458         guarantee(false, &quot;bad switch&quot;);
 459         break;
 460       }
 461 
 462       if (klass_ref_i != new_klass_ref_i) {
 463         log_trace(redefine, class, constantpool)
 464           (&quot;%s entry@%d class_index changed: %d to %d&quot;, entry_name, *merge_cp_length_p, klass_ref_i, new_klass_ref_i);
 465       }
 466       if (name_and_type_ref_i != new_name_and_type_ref_i) {
 467         log_trace(redefine, class, constantpool)
 468           (&quot;%s entry@%d name_and_type_index changed: %d to %d&quot;,
 469            entry_name, *merge_cp_length_p, name_and_type_ref_i, new_name_and_type_ref_i);
 470       }
 471 
 472       if (scratch_i != *merge_cp_length_p) {
 473         // The new entry in *merge_cp_p is at a different index than
 474         // the new entry in scratch_cp so we need to map the index values.
 475         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 476       }
 477       (*merge_cp_length_p)++;
 478     } break;
 479 
 480     // this is an indirect CP entry so it needs special handling
 481     case JVM_CONSTANT_MethodType:
 482     {
 483       int ref_i = scratch_cp-&gt;method_type_index_at(scratch_i);
 484       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 485                                                     merge_cp_length_p, THREAD);
 486       if (new_ref_i != ref_i) {
 487         log_trace(redefine, class, constantpool)
 488           (&quot;MethodType entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 489       }
 490       (*merge_cp_p)-&gt;method_type_index_at_put(*merge_cp_length_p, new_ref_i);
 491       if (scratch_i != *merge_cp_length_p) {
 492         // The new entry in *merge_cp_p is at a different index than
 493         // the new entry in scratch_cp so we need to map the index values.
 494         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 495       }
 496       (*merge_cp_length_p)++;
 497     } break;
 498 
 499     // this is an indirect CP entry so it needs special handling
 500     case JVM_CONSTANT_MethodHandle:
 501     {
 502       int ref_kind = scratch_cp-&gt;method_handle_ref_kind_at(scratch_i);
 503       int ref_i = scratch_cp-&gt;method_handle_index_at(scratch_i);
 504       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 505                                                     merge_cp_length_p, THREAD);
 506       if (new_ref_i != ref_i) {
 507         log_trace(redefine, class, constantpool)
 508           (&quot;MethodHandle entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 509       }
 510       (*merge_cp_p)-&gt;method_handle_index_at_put(*merge_cp_length_p, ref_kind, new_ref_i);
 511       if (scratch_i != *merge_cp_length_p) {
 512         // The new entry in *merge_cp_p is at a different index than
 513         // the new entry in scratch_cp so we need to map the index values.
 514         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 515       }
 516       (*merge_cp_length_p)++;
 517     } break;
 518 
 519     // this is an indirect CP entry so it needs special handling
 520     case JVM_CONSTANT_Dynamic:  // fall through
 521     case JVM_CONSTANT_InvokeDynamic:
 522     {
 523       // Index of the bootstrap specifier in the operands array
 524       int old_bs_i = scratch_cp-&gt;bootstrap_methods_attribute_index(scratch_i);
 525       int new_bs_i = find_or_append_operand(scratch_cp, old_bs_i, merge_cp_p,
 526                                             merge_cp_length_p, THREAD);
 527       // The bootstrap method NameAndType_info index
 528       int old_ref_i = scratch_cp-&gt;bootstrap_name_and_type_ref_index_at(scratch_i);
 529       int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 530                                                     merge_cp_length_p, THREAD);
 531       if (new_bs_i != old_bs_i) {
 532         log_trace(redefine, class, constantpool)
 533           (&quot;Dynamic entry@%d bootstrap_method_attr_index change: %d to %d&quot;,
 534            *merge_cp_length_p, old_bs_i, new_bs_i);
 535       }
 536       if (new_ref_i != old_ref_i) {
 537         log_trace(redefine, class, constantpool)
 538           (&quot;Dynamic entry@%d name_and_type_index change: %d to %d&quot;, *merge_cp_length_p, old_ref_i, new_ref_i);
 539       }
 540 
 541       if (scratch_cp-&gt;tag_at(scratch_i).is_dynamic_constant())
 542         (*merge_cp_p)-&gt;dynamic_constant_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 543       else
 544         (*merge_cp_p)-&gt;invoke_dynamic_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 545       if (scratch_i != *merge_cp_length_p) {
 546         // The new entry in *merge_cp_p is at a different index than
 547         // the new entry in scratch_cp so we need to map the index values.
 548         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 549       }
 550       (*merge_cp_length_p)++;
 551     } break;
 552 
 553     // At this stage, Class or UnresolvedClass could be in scratch_cp, but not
 554     // ClassIndex
 555     case JVM_CONSTANT_ClassIndex: // fall through
 556 
 557     // Invalid is used as the tag for the second constant pool entry
 558     // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
 559     // not be seen by itself.
 560     case JVM_CONSTANT_Invalid: // fall through
 561 
 562     // At this stage, String could be here, but not StringIndex
 563     case JVM_CONSTANT_StringIndex: // fall through
 564 
 565     // At this stage JVM_CONSTANT_UnresolvedClassInError should not be
 566     // here
 567     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 568 
 569     default:
 570     {
 571       // leave a breadcrumb
 572       jbyte bad_value = scratch_cp-&gt;tag_at(scratch_i).value();
 573       ShouldNotReachHere();
 574     } break;
 575   } // end switch tag value
 576 } // end append_entry()
 577 
 578 
 579 int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle&amp; scratch_cp,
 580       int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 581 
 582   int new_ref_i = ref_i;
 583   bool match = (ref_i &lt; *merge_cp_length_p) &amp;&amp;
 584                scratch_cp-&gt;compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
 585 
 586   if (!match) {
 587     // forward reference in *merge_cp_p or not a direct match
 588     int found_i = scratch_cp-&gt;find_matching_entry(ref_i, *merge_cp_p, THREAD);
 589     if (found_i != 0) {
 590       guarantee(found_i != ref_i, &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
 591       // Found a matching entry somewhere else in *merge_cp_p so just need a mapping entry.
 592       new_ref_i = found_i;
 593       map_index(scratch_cp, ref_i, found_i);
 594     } else {
 595       // no match found so we have to append this entry to *merge_cp_p
 596       append_entry(scratch_cp, ref_i, merge_cp_p, merge_cp_length_p, THREAD);
 597       // The above call to append_entry() can only append one entry
 598       // so the post call query of *merge_cp_length_p is only for
 599       // the sake of consistency.
 600       new_ref_i = *merge_cp_length_p - 1;
 601     }
 602   }
 603 
 604   return new_ref_i;
 605 } // end find_or_append_indirect_entry()
 606 
 607 
 608 // Append a bootstrap specifier into the merge_cp operands that is semantically equal
 609 // to the scratch_cp operands bootstrap specifier passed by the old_bs_i index.
 610 // Recursively append new merge_cp entries referenced by the new bootstrap specifier.
 611 void VM_RedefineClasses::append_operand(const constantPoolHandle&amp; scratch_cp, int old_bs_i,
 612        constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 613 
 614   int old_ref_i = scratch_cp-&gt;operand_bootstrap_method_ref_index_at(old_bs_i);
 615   int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 616                                                 merge_cp_length_p, THREAD);
 617   if (new_ref_i != old_ref_i) {
 618     log_trace(redefine, class, constantpool)
 619       (&quot;operands entry@%d bootstrap method ref_index change: %d to %d&quot;, _operands_cur_length, old_ref_i, new_ref_i);
 620   }
 621 
 622   Array&lt;u2&gt;* merge_ops = (*merge_cp_p)-&gt;operands();
 623   int new_bs_i = _operands_cur_length;
 624   // We have _operands_cur_length == 0 when the merge_cp operands is empty yet.
 625   // However, the operand_offset_at(0) was set in the extend_operands() call.
 626   int new_base = (new_bs_i == 0) ? (*merge_cp_p)-&gt;operand_offset_at(0)
 627                                  : (*merge_cp_p)-&gt;operand_next_offset_at(new_bs_i - 1);
 628   int argc     = scratch_cp-&gt;operand_argument_count_at(old_bs_i);
 629 
 630   ConstantPool::operand_offset_at_put(merge_ops, _operands_cur_length, new_base);
 631   merge_ops-&gt;at_put(new_base++, new_ref_i);
 632   merge_ops-&gt;at_put(new_base++, argc);
 633 
 634   for (int i = 0; i &lt; argc; i++) {
 635     int old_arg_ref_i = scratch_cp-&gt;operand_argument_index_at(old_bs_i, i);
 636     int new_arg_ref_i = find_or_append_indirect_entry(scratch_cp, old_arg_ref_i, merge_cp_p,
 637                                                       merge_cp_length_p, THREAD);
 638     merge_ops-&gt;at_put(new_base++, new_arg_ref_i);
 639     if (new_arg_ref_i != old_arg_ref_i) {
 640       log_trace(redefine, class, constantpool)
 641         (&quot;operands entry@%d bootstrap method argument ref_index change: %d to %d&quot;,
 642          _operands_cur_length, old_arg_ref_i, new_arg_ref_i);
 643     }
 644   }
 645   if (old_bs_i != _operands_cur_length) {
 646     // The bootstrap specifier in *merge_cp_p is at a different index than
 647     // that in scratch_cp so we need to map the index values.
 648     map_operand_index(old_bs_i, new_bs_i);
 649   }
 650   _operands_cur_length++;
 651 } // end append_operand()
 652 
 653 
 654 int VM_RedefineClasses::find_or_append_operand(const constantPoolHandle&amp; scratch_cp,
 655       int old_bs_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 656 
 657   int new_bs_i = old_bs_i; // bootstrap specifier index
 658   bool match = (old_bs_i &lt; _operands_cur_length) &amp;&amp;
 659                scratch_cp-&gt;compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i, THREAD);
 660 
 661   if (!match) {
 662     // forward reference in *merge_cp_p or not a direct match
 663     int found_i = scratch_cp-&gt;find_matching_operand(old_bs_i, *merge_cp_p,
 664                                                     _operands_cur_length, THREAD);
 665     if (found_i != -1) {
 666       guarantee(found_i != old_bs_i, &quot;compare_operand_to() and find_matching_operand() disagree&quot;);
 667       // found a matching operand somewhere else in *merge_cp_p so just need a mapping
 668       new_bs_i = found_i;
 669       map_operand_index(old_bs_i, found_i);
 670     } else {
 671       // no match found so we have to append this bootstrap specifier to *merge_cp_p
 672       append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p, THREAD);
 673       new_bs_i = _operands_cur_length - 1;
 674     }
 675   }
 676   return new_bs_i;
 677 } // end find_or_append_operand()
 678 
 679 
 680 void VM_RedefineClasses::finalize_operands_merge(const constantPoolHandle&amp; merge_cp, TRAPS) {
 681   if (merge_cp-&gt;operands() == NULL) {
 682     return;
 683   }
 684   // Shrink the merge_cp operands
 685   merge_cp-&gt;shrink_operands(_operands_cur_length, CHECK);
 686 
 687   if (log_is_enabled(Trace, redefine, class, constantpool)) {
 688     // don&#39;t want to loop unless we are tracing
 689     int count = 0;
 690     for (int i = 1; i &lt; _operands_index_map_p-&gt;length(); i++) {
 691       int value = _operands_index_map_p-&gt;at(i);
 692       if (value != -1) {
 693         log_trace(redefine, class, constantpool)(&quot;operands_index_map[%d]: old=%d new=%d&quot;, count, i, value);
 694         count++;
 695       }
 696     }
 697   }
 698   // Clean-up
 699   _operands_index_map_p = NULL;
 700   _operands_cur_length = 0;
 701   _operands_index_map_count = 0;
 702 } // end finalize_operands_merge()
 703 
 704 // Symbol* comparator for qsort
 705 // The caller must have an active ResourceMark.
 706 static int symcmp(const void* a, const void* b) {
 707   char* astr = (*(Symbol**)a)-&gt;as_C_string();
 708   char* bstr = (*(Symbol**)b)-&gt;as_C_string();
 709   return strcmp(astr, bstr);
 710 }
 711 
 712 // The caller must have an active ResourceMark.
 713 static jvmtiError check_attribute_arrays(const char* attr_name,
 714            InstanceKlass* the_class, InstanceKlass* scratch_class,
 715            Array&lt;u2&gt;* the_array, Array&lt;u2&gt;* scr_array) {
 716   bool the_array_exists = the_array != Universe::the_empty_short_array();
 717   bool scr_array_exists = scr_array != Universe::the_empty_short_array();
 718 
 719   int array_len = the_array-&gt;length();
 720   if (the_array_exists &amp;&amp; scr_array_exists) {
 721     if (array_len != scr_array-&gt;length()) {
 722       log_trace(redefine, class)
 723         (&quot;redefined class %s attribute change error: %s len=%d changed to len=%d&quot;,
 724          the_class-&gt;external_name(), attr_name, array_len, scr_array-&gt;length());
 725       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 726     }
 727 
 728     // The order of entries in the attribute array is not specified so we
 729     // have to explicitly check for the same contents. We do this by copying
 730     // the referenced symbols into their own arrays, sorting them and then
 731     // comparing each element pair.
 732 
 733     Symbol** the_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, array_len);
 734     Symbol** scr_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, array_len);
 735 
 736     if (the_syms == NULL || scr_syms == NULL) {
 737       return JVMTI_ERROR_OUT_OF_MEMORY;
 738     }
 739 
 740     for (int i = 0; i &lt; array_len; i++) {
 741       int the_cp_index = the_array-&gt;at(i);
 742       int scr_cp_index = scr_array-&gt;at(i);
 743       the_syms[i] = the_class-&gt;constants()-&gt;klass_name_at(the_cp_index);
 744       scr_syms[i] = scratch_class-&gt;constants()-&gt;klass_name_at(scr_cp_index);
 745     }
 746 
 747     qsort(the_syms, array_len, sizeof(Symbol*), symcmp);
 748     qsort(scr_syms, array_len, sizeof(Symbol*), symcmp);
 749 
 750     for (int i = 0; i &lt; array_len; i++) {
 751       if (the_syms[i] != scr_syms[i]) {
 752         log_trace(redefine, class)
 753           (&quot;redefined class %s attribute change error: %s[%d]: %s changed to %s&quot;,
 754            the_class-&gt;external_name(), attr_name, i,
 755            the_syms[i]-&gt;as_C_string(), scr_syms[i]-&gt;as_C_string());
 756         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 757       }
 758     }
 759   } else if (the_array_exists ^ scr_array_exists) {
 760     const char* action_str = (the_array_exists) ? &quot;removed&quot; : &quot;added&quot;;
 761     log_trace(redefine, class)
 762       (&quot;redefined class %s attribute change error: %s attribute %s&quot;,
 763        the_class-&gt;external_name(), attr_name, action_str);
 764     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 765   }
 766   return JVMTI_ERROR_NONE;
 767 }
 768 
 769 static jvmtiError check_nest_attributes(InstanceKlass* the_class,
 770                                         InstanceKlass* scratch_class) {
 771   // Check whether the class NestHost attribute has been changed.
 772   Thread* thread = Thread::current();
 773   ResourceMark rm(thread);
 774   u2 the_nest_host_idx = the_class-&gt;nest_host_index();
 775   u2 scr_nest_host_idx = scratch_class-&gt;nest_host_index();
 776 
 777   if (the_nest_host_idx != 0 &amp;&amp; scr_nest_host_idx != 0) {
 778     Symbol* the_sym = the_class-&gt;constants()-&gt;klass_name_at(the_nest_host_idx);
 779     Symbol* scr_sym = scratch_class-&gt;constants()-&gt;klass_name_at(scr_nest_host_idx);
 780     if (the_sym != scr_sym) {
 781       log_trace(redefine, class, nestmates)
 782         (&quot;redefined class %s attribute change error: NestHost class: %s replaced with: %s&quot;,
 783          the_class-&gt;external_name(), the_sym-&gt;as_C_string(), scr_sym-&gt;as_C_string());
 784       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 785     }
 786   } else if ((the_nest_host_idx == 0) ^ (scr_nest_host_idx == 0)) {
 787     const char* action_str = (the_nest_host_idx != 0) ? &quot;removed&quot; : &quot;added&quot;;
 788     log_trace(redefine, class, nestmates)
 789       (&quot;redefined class %s attribute change error: NestHost attribute %s&quot;,
 790        the_class-&gt;external_name(), action_str);
 791     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 792   }
 793 
 794   // Check whether the class NestMembers attribute has been changed.
 795   return check_attribute_arrays(&quot;NestMembers&quot;,
 796                                 the_class, scratch_class,
 797                                 the_class-&gt;nest_members(),
 798                                 scratch_class-&gt;nest_members());
 799 }
 800 
 801 // Return an error status if the class Record attribute was changed.
 802 static jvmtiError check_record_attribute(InstanceKlass* the_class, InstanceKlass* scratch_class) {
 803   // Get lists of record components.
 804   Array&lt;RecordComponent*&gt;* the_record = the_class-&gt;record_components();
 805   Array&lt;RecordComponent*&gt;* scr_record = scratch_class-&gt;record_components();
 806   bool the_record_exists = the_record != NULL;
 807   bool scr_record_exists = scr_record != NULL;
 808 
 809   if (the_record_exists &amp;&amp; scr_record_exists) {
 810     int the_num_components = the_record-&gt;length();
 811     int scr_num_components = scr_record-&gt;length();
 812     if (the_num_components != scr_num_components) {
 813       log_trace(redefine, class, record)
 814         (&quot;redefined class %s attribute change error: Record num_components=%d changed to num_components=%d&quot;,
 815          the_class-&gt;external_name(), the_num_components, scr_num_components);
 816       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 817     }
 818 
 819     // Compare each field in each record component.
 820     ConstantPool* the_cp =  the_class-&gt;constants();
 821     ConstantPool* scr_cp =  scratch_class-&gt;constants();
 822     for (int x = 0; x &lt; the_num_components; x++) {
 823       RecordComponent* the_component = the_record-&gt;at(x);
 824       RecordComponent* scr_component = scr_record-&gt;at(x);
 825       const Symbol* const the_name = the_cp-&gt;symbol_at(the_component-&gt;name_index());
 826       const Symbol* const scr_name = scr_cp-&gt;symbol_at(scr_component-&gt;name_index());
 827       const Symbol* const the_descr = the_cp-&gt;symbol_at(the_component-&gt;descriptor_index());
 828       const Symbol* const scr_descr = scr_cp-&gt;symbol_at(scr_component-&gt;descriptor_index());
 829       if (the_name != scr_name || the_descr != scr_descr) {
 830         log_trace(redefine, class, record)
 831           (&quot;redefined class %s attribute change error: Record name_index, descriptor_index, and/or attributes_count changed&quot;,
 832            the_class-&gt;external_name());
 833         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 834       }
 835 
 836       int the_gen_sig = the_component-&gt;generic_signature_index();
 837       int scr_gen_sig = scr_component-&gt;generic_signature_index();
 838       const Symbol* const the_gen_sig_sym = (the_gen_sig == 0 ? NULL :
 839         the_cp-&gt;symbol_at(the_component-&gt;generic_signature_index()));
 840       const Symbol* const scr_gen_sig_sym = (scr_gen_sig == 0 ? NULL :
 841         scr_cp-&gt;symbol_at(scr_component-&gt;generic_signature_index()));
 842       if (the_gen_sig_sym != scr_gen_sig_sym) {
 843         log_trace(redefine, class, record)
 844           (&quot;redefined class %s attribute change error: Record generic_signature attribute changed&quot;,
 845            the_class-&gt;external_name());
 846         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 847       }
 848 
 849       // It&#39;s okay if a record component&#39;s annotations were changed.
 850     }
 851 
 852   } else if (the_record_exists ^ scr_record_exists) {
 853     const char* action_str = (the_record_exists) ? &quot;removed&quot; : &quot;added&quot;;
 854     log_trace(redefine, class, record)
 855       (&quot;redefined class %s attribute change error: Record attribute %s&quot;,
 856        the_class-&gt;external_name(), action_str);
 857     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 858   }
 859 
 860   return JVMTI_ERROR_NONE;
 861 }
 862 
 863 
 864 static jvmtiError check_permitted_subclasses_attribute(InstanceKlass* the_class,
 865                                                        InstanceKlass* scratch_class) {
 866   Thread* thread = Thread::current();
 867   ResourceMark rm(thread);
 868 
 869   // Check whether the class PermittedSubclasses attribute has been changed.
 870   return check_attribute_arrays(&quot;PermittedSubclasses&quot;,
 871                                 the_class, scratch_class,
 872                                 the_class-&gt;permitted_subclasses(),
 873                                 scratch_class-&gt;permitted_subclasses());
 874 }
 875 
 876 static bool can_add_or_delete(Method* m) {
 877       // Compatibility mode
 878   return (AllowRedefinitionToAddDeleteMethods &amp;&amp;
 879           (m-&gt;is_private() &amp;&amp; (m-&gt;is_static() || m-&gt;is_final())));
 880 }
 881 
 882 jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
 883              InstanceKlass* the_class,
 884              InstanceKlass* scratch_class) {
 885   int i;
 886 
 887   // Check superclasses, or rather their names, since superclasses themselves can be
 888   // requested to replace.
 889   // Check for NULL superclass first since this might be java.lang.Object
 890   if (the_class-&gt;super() != scratch_class-&gt;super() &amp;&amp;
 891       (the_class-&gt;super() == NULL || scratch_class-&gt;super() == NULL ||
 892        the_class-&gt;super()-&gt;name() !=
 893        scratch_class-&gt;super()-&gt;name())) {
 894     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 895   }
 896 
 897   // Check if the number, names and order of directly implemented interfaces are the same.
 898   // I think in principle we should just check if the sets of names of directly implemented
 899   // interfaces are the same, i.e. the order of declaration (which, however, if changed in the
 900   // .java file, also changes in .class file) should not matter. However, comparing sets is
 901   // technically a bit more difficult, and, more importantly, I am not sure at present that the
 902   // order of interfaces does not matter on the implementation level, i.e. that the VM does not
 903   // rely on it somewhere.
 904   Array&lt;InstanceKlass*&gt;* k_interfaces = the_class-&gt;local_interfaces();
 905   Array&lt;InstanceKlass*&gt;* k_new_interfaces = scratch_class-&gt;local_interfaces();
 906   int n_intfs = k_interfaces-&gt;length();
 907   if (n_intfs != k_new_interfaces-&gt;length()) {
 908     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 909   }
 910   for (i = 0; i &lt; n_intfs; i++) {
 911     if (k_interfaces-&gt;at(i)-&gt;name() !=
 912         k_new_interfaces-&gt;at(i)-&gt;name()) {
 913       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 914     }
 915   }
 916 
 917   // Check whether class is in the error init state.
 918   if (the_class-&gt;is_in_error_state()) {
 919     // TBD #5057930: special error code is needed in 1.6
 920     return JVMTI_ERROR_INVALID_CLASS;
 921   }
 922 
 923   // Check whether the nest-related attributes have been changed.
 924   jvmtiError err = check_nest_attributes(the_class, scratch_class);
 925   if (err != JVMTI_ERROR_NONE) {
 926     return err;
 927   }
 928 
 929   // Check whether the Record attribute has been changed.
 930   err = check_record_attribute(the_class, scratch_class);
 931   if (err != JVMTI_ERROR_NONE) {
 932     return err;
 933   }
 934 
 935   // Check whether the PermittedSubclasses attribute has been changed.
 936   err = check_permitted_subclasses_attribute(the_class, scratch_class);
 937   if (err != JVMTI_ERROR_NONE) {
 938     return err;
 939   }
 940 
 941   // Check whether class modifiers are the same.
 942   jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
 943   jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
 944   if (old_flags != new_flags) {
 945     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
 946   }
 947 
 948   // Check if the number, names, types and order of fields declared in these classes
 949   // are the same.
 950   JavaFieldStream old_fs(the_class);
 951   JavaFieldStream new_fs(scratch_class);
 952   for (; !old_fs.done() &amp;&amp; !new_fs.done(); old_fs.next(), new_fs.next()) {
 953     // access
 954     old_flags = old_fs.access_flags().as_short();
 955     new_flags = new_fs.access_flags().as_short();
 956     if ((old_flags ^ new_flags) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS) {
 957       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 958     }
 959     // offset
 960     if (old_fs.offset() != new_fs.offset()) {
 961       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 962     }
 963     // name and signature
 964     Symbol* name_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.name_index());
 965     Symbol* sig_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.signature_index());
 966     Symbol* name_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.name_index());
 967     Symbol* sig_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.signature_index());
 968     if (name_sym1 != name_sym2 || sig_sym1 != sig_sym2) {
 969       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 970     }
 971   }
 972 
 973   // If both streams aren&#39;t done then we have a differing number of
 974   // fields.
 975   if (!old_fs.done() || !new_fs.done()) {
 976     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 977   }
 978 
 979   // Do a parallel walk through the old and new methods. Detect
 980   // cases where they match (exist in both), have been added in
 981   // the new methods, or have been deleted (exist only in the
 982   // old methods).  The class file parser places methods in order
 983   // by method name, but does not order overloaded methods by
 984   // signature.  In order to determine what fate befell the methods,
 985   // this code places the overloaded new methods that have matching
 986   // old methods in the same order as the old methods and places
 987   // new overloaded methods at the end of overloaded methods of
 988   // that name. The code for this order normalization is adapted
 989   // from the algorithm used in InstanceKlass::find_method().
 990   // Since we are swapping out of order entries as we find them,
 991   // we only have to search forward through the overloaded methods.
 992   // Methods which are added and have the same name as an existing
 993   // method (but different signature) will be put at the end of
 994   // the methods with that name, and the name mismatch code will
 995   // handle them.
 996   Array&lt;Method*&gt;* k_old_methods(the_class-&gt;methods());
 997   Array&lt;Method*&gt;* k_new_methods(scratch_class-&gt;methods());
 998   int n_old_methods = k_old_methods-&gt;length();
 999   int n_new_methods = k_new_methods-&gt;length();
1000   Thread* thread = Thread::current();
1001 
1002   int ni = 0;
1003   int oi = 0;
1004   while (true) {
1005     Method* k_old_method;
1006     Method* k_new_method;
1007     enum { matched, added, deleted, undetermined } method_was = undetermined;
1008 
1009     if (oi &gt;= n_old_methods) {
1010       if (ni &gt;= n_new_methods) {
1011         break; // we&#39;ve looked at everything, done
1012       }
1013       // New method at the end
1014       k_new_method = k_new_methods-&gt;at(ni);
1015       method_was = added;
1016     } else if (ni &gt;= n_new_methods) {
1017       // Old method, at the end, is deleted
1018       k_old_method = k_old_methods-&gt;at(oi);
1019       method_was = deleted;
1020     } else {
1021       // There are more methods in both the old and new lists
1022       k_old_method = k_old_methods-&gt;at(oi);
1023       k_new_method = k_new_methods-&gt;at(ni);
1024       if (k_old_method-&gt;name() != k_new_method-&gt;name()) {
1025         // Methods are sorted by method name, so a mismatch means added
1026         // or deleted
1027         if (k_old_method-&gt;name()-&gt;fast_compare(k_new_method-&gt;name()) &gt; 0) {
1028           method_was = added;
1029         } else {
1030           method_was = deleted;
1031         }
1032       } else if (k_old_method-&gt;signature() == k_new_method-&gt;signature()) {
1033         // Both the name and signature match
1034         method_was = matched;
1035       } else {
1036         // The name matches, but the signature doesn&#39;t, which means we have to
1037         // search forward through the new overloaded methods.
1038         int nj;  // outside the loop for post-loop check
1039         for (nj = ni + 1; nj &lt; n_new_methods; nj++) {
1040           Method* m = k_new_methods-&gt;at(nj);
1041           if (k_old_method-&gt;name() != m-&gt;name()) {
1042             // reached another method name so no more overloaded methods
1043             method_was = deleted;
1044             break;
1045           }
1046           if (k_old_method-&gt;signature() == m-&gt;signature()) {
1047             // found a match so swap the methods
1048             k_new_methods-&gt;at_put(ni, m);
1049             k_new_methods-&gt;at_put(nj, k_new_method);
1050             k_new_method = m;
1051             method_was = matched;
1052             break;
1053           }
1054         }
1055 
1056         if (nj &gt;= n_new_methods) {
1057           // reached the end without a match; so method was deleted
1058           method_was = deleted;
1059         }
1060       }
1061     }
1062 
1063     switch (method_was) {
1064     case matched:
1065       // methods match, be sure modifiers do too
1066       old_flags = (jushort) k_old_method-&gt;access_flags().get_flags();
1067       new_flags = (jushort) k_new_method-&gt;access_flags().get_flags();
1068       if ((old_flags ^ new_flags) &amp; ~(JVM_ACC_NATIVE)) {
1069         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
1070       }
1071       {
1072         u2 new_num = k_new_method-&gt;method_idnum();
1073         u2 old_num = k_old_method-&gt;method_idnum();
1074         if (new_num != old_num) {
1075           Method* idnum_owner = scratch_class-&gt;method_with_idnum(old_num);
1076           if (idnum_owner != NULL) {
1077             // There is already a method assigned this idnum -- switch them
1078             // Take current and original idnum from the new_method
1079             idnum_owner-&gt;set_method_idnum(new_num);
1080             idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1081           }
1082           // Take current and original idnum from the old_method
1083           k_new_method-&gt;set_method_idnum(old_num);
1084           k_new_method-&gt;set_orig_method_idnum(k_old_method-&gt;orig_method_idnum());
1085           if (thread-&gt;has_pending_exception()) {
1086             return JVMTI_ERROR_OUT_OF_MEMORY;
1087           }
1088         }
1089       }
1090       log_trace(redefine, class, normalize)
1091         (&quot;Method matched: new: %s [%d] == old: %s [%d]&quot;,
1092          k_new_method-&gt;name_and_sig_as_C_string(), ni, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1093       // advance to next pair of methods
1094       ++oi;
1095       ++ni;
1096       break;
1097     case added:
1098       // method added, see if it is OK
1099       if (!can_add_or_delete(k_new_method)) {
1100         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1101       }
1102       {
1103         u2 num = the_class-&gt;next_method_idnum();
1104         if (num == ConstMethod::UNSET_IDNUM) {
1105           // cannot add any more methods
1106           return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1107         }
1108         u2 new_num = k_new_method-&gt;method_idnum();
1109         Method* idnum_owner = scratch_class-&gt;method_with_idnum(num);
1110         if (idnum_owner != NULL) {
1111           // There is already a method assigned this idnum -- switch them
1112           // Take current and original idnum from the new_method
1113           idnum_owner-&gt;set_method_idnum(new_num);
1114           idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1115         }
1116         k_new_method-&gt;set_method_idnum(num);
1117         k_new_method-&gt;set_orig_method_idnum(num);
1118         if (thread-&gt;has_pending_exception()) {
1119           return JVMTI_ERROR_OUT_OF_MEMORY;
1120         }
1121       }
1122       log_trace(redefine, class, normalize)
1123         (&quot;Method added: new: %s [%d]&quot;, k_new_method-&gt;name_and_sig_as_C_string(), ni);
1124       ++ni; // advance to next new method
1125       break;
1126     case deleted:
1127       // method deleted, see if it is OK
1128       if (!can_add_or_delete(k_old_method)) {
1129         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1130       }
1131       log_trace(redefine, class, normalize)
1132         (&quot;Method deleted: old: %s [%d]&quot;, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1133       ++oi; // advance to next old method
1134       break;
1135     default:
1136       ShouldNotReachHere();
1137     }
1138   }
1139 
1140   return JVMTI_ERROR_NONE;
1141 }
1142 
1143 
1144 // Find new constant pool index value for old constant pool index value
1145 // by seaching the index map. Returns zero (0) if there is no mapped
1146 // value for the old constant pool index.
1147 int VM_RedefineClasses::find_new_index(int old_index) {
1148   if (_index_map_count == 0) {
1149     // map is empty so nothing can be found
1150     return 0;
1151   }
1152 
1153   if (old_index &lt; 1 || old_index &gt;= _index_map_p-&gt;length()) {
1154     // The old_index is out of range so it is not mapped. This should
1155     // not happen in regular constant pool merging use, but it can
1156     // happen if a corrupt annotation is processed.
1157     return 0;
1158   }
1159 
1160   int value = _index_map_p-&gt;at(old_index);
1161   if (value == -1) {
1162     // the old_index is not mapped
1163     return 0;
1164   }
1165 
1166   return value;
1167 } // end find_new_index()
1168 
1169 
1170 // Find new bootstrap specifier index value for old bootstrap specifier index
1171 // value by seaching the index map. Returns unused index (-1) if there is
1172 // no mapped value for the old bootstrap specifier index.
1173 int VM_RedefineClasses::find_new_operand_index(int old_index) {
1174   if (_operands_index_map_count == 0) {
1175     // map is empty so nothing can be found
1176     return -1;
1177   }
1178 
1179   if (old_index == -1 || old_index &gt;= _operands_index_map_p-&gt;length()) {
1180     // The old_index is out of range so it is not mapped.
1181     // This should not happen in regular constant pool merging use.
1182     return -1;
1183   }
1184 
1185   int value = _operands_index_map_p-&gt;at(old_index);
1186   if (value == -1) {
1187     // the old_index is not mapped
1188     return -1;
1189   }
1190 
1191   return value;
1192 } // end find_new_operand_index()
1193 
1194 
1195 // Returns true if the current mismatch is due to a resolved/unresolved
1196 // class pair. Otherwise, returns false.
1197 bool VM_RedefineClasses::is_unresolved_class_mismatch(const constantPoolHandle&amp; cp1,
1198        int index1, const constantPoolHandle&amp; cp2, int index2) {
1199 
1200   jbyte t1 = cp1-&gt;tag_at(index1).value();
1201   if (t1 != JVM_CONSTANT_Class &amp;&amp; t1 != JVM_CONSTANT_UnresolvedClass) {
1202     return false;  // wrong entry type; not our special case
1203   }
1204 
1205   jbyte t2 = cp2-&gt;tag_at(index2).value();
1206   if (t2 != JVM_CONSTANT_Class &amp;&amp; t2 != JVM_CONSTANT_UnresolvedClass) {
1207     return false;  // wrong entry type; not our special case
1208   }
1209 
1210   if (t1 == t2) {
1211     return false;  // not a mismatch; not our special case
1212   }
1213 
1214   char *s1 = cp1-&gt;klass_name_at(index1)-&gt;as_C_string();
1215   char *s2 = cp2-&gt;klass_name_at(index2)-&gt;as_C_string();
1216   if (strcmp(s1, s2) != 0) {
1217     return false;  // strings don&#39;t match; not our special case
1218   }
1219 
1220   return true;  // made it through the gauntlet; this is our special case
1221 } // end is_unresolved_class_mismatch()
1222 
1223 
<a name="1" id="anc1"></a><span class="line-added">1224 // The bug 6214132 caused the verification to fail.</span>
<span class="line-added">1225 // 1. What&#39;s done in RedefineClasses() before verification:</span>
<span class="line-added">1226 //  a) A reference to the class being redefined (_the_class) and a</span>
<span class="line-added">1227 //     reference to new version of the class (_scratch_class) are</span>
<span class="line-added">1228 //     saved here for use during the bytecode verification phase of</span>
<span class="line-added">1229 //     RedefineClasses.</span>
<span class="line-added">1230 //  b) The _java_mirror field from _the_class is copied to the</span>
<span class="line-added">1231 //     _java_mirror field in _scratch_class. This means that a jclass</span>
<span class="line-added">1232 //     returned for _the_class or _scratch_class will refer to the</span>
<span class="line-added">1233 //     same Java mirror. The verifier will see the &quot;one true mirror&quot;</span>
<span class="line-added">1234 //     for the class being verified.</span>
<span class="line-added">1235 // 2. See comments in JvmtiThreadState for what is done during verification.</span>
<span class="line-added">1236 </span>
<span class="line-added">1237 class RedefineVerifyMark : public StackObj {</span>
<span class="line-added">1238  private:</span>
<span class="line-added">1239   JvmtiThreadState* _state;</span>
<span class="line-added">1240   Klass*            _scratch_class;</span>
<span class="line-added">1241   Handle            _scratch_mirror;</span>
<span class="line-added">1242 </span>
<span class="line-added">1243  public:</span>
<span class="line-added">1244 </span>
<span class="line-added">1245   RedefineVerifyMark(Klass* the_class, Klass* scratch_class,</span>
<span class="line-added">1246                      JvmtiThreadState* state) : _state(state), _scratch_class(scratch_class)</span>
<span class="line-added">1247   {</span>
<span class="line-added">1248     _state-&gt;set_class_versions_map(the_class, scratch_class);</span>
<span class="line-added">1249     _scratch_mirror = Handle(_state-&gt;get_thread(), _scratch_class-&gt;java_mirror());</span>
<span class="line-added">1250     _scratch_class-&gt;replace_java_mirror(the_class-&gt;java_mirror());</span>
<span class="line-added">1251   }</span>
<span class="line-added">1252 </span>
<span class="line-added">1253   ~RedefineVerifyMark() {</span>
<span class="line-added">1254     // Restore the scratch class&#39;s mirror, so when scratch_class is removed</span>
<span class="line-added">1255     // the correct mirror pointing to it can be cleared.</span>
<span class="line-added">1256     _scratch_class-&gt;replace_java_mirror(_scratch_mirror());</span>
<span class="line-added">1257     _state-&gt;clear_class_versions_map();</span>
<span class="line-added">1258   }</span>
<span class="line-added">1259 };</span>
<span class="line-added">1260 </span>
<span class="line-added">1261 </span>
1262 jvmtiError VM_RedefineClasses::load_new_class_versions(TRAPS) {
1263 
1264   // For consistency allocate memory using os::malloc wrapper.
1265   _scratch_classes = (InstanceKlass**)
1266     os::malloc(sizeof(InstanceKlass*) * _class_count, mtClass);
1267   if (_scratch_classes == NULL) {
1268     return JVMTI_ERROR_OUT_OF_MEMORY;
1269   }
1270   // Zero initialize the _scratch_classes array.
1271   for (int i = 0; i &lt; _class_count; i++) {
1272     _scratch_classes[i] = NULL;
1273   }
1274 
1275   ResourceMark rm(THREAD);
1276 
1277   JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());
1278   // state can only be NULL if the current thread is exiting which
1279   // should not happen since we&#39;re trying to do a RedefineClasses
1280   guarantee(state != NULL, &quot;exiting thread calling load_new_class_versions&quot;);
1281   for (int i = 0; i &lt; _class_count; i++) {
1282     // Create HandleMark so that any handles created while loading new class
1283     // versions are deleted. Constant pools are deallocated while merging
1284     // constant pools
1285     HandleMark hm(THREAD);
1286     InstanceKlass* the_class = get_ik(_class_defs[i].klass);
1287     Symbol*  the_class_sym = the_class-&gt;name();
1288 
1289     log_debug(redefine, class, load)
1290       (&quot;loading name=%s kind=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
1291        the_class-&gt;external_name(), _class_load_kind, os::available_memory() &gt;&gt; 10);
1292 
1293     ClassFileStream st((u1*)_class_defs[i].class_bytes,
1294                        _class_defs[i].class_byte_count,
1295                        &quot;__VM_RedefineClasses__&quot;,
1296                        ClassFileStream::verify);
1297 
1298     // Parse the stream.
1299     Handle the_class_loader(THREAD, the_class-&gt;class_loader());
1300     Handle protection_domain(THREAD, the_class-&gt;protection_domain());
1301     // Set redefined class handle in JvmtiThreadState class.
1302     // This redefined class is sent to agent event handler for class file
1303     // load hook event.
1304     state-&gt;set_class_being_redefined(the_class, _class_load_kind);
1305 
1306     ClassLoadInfo cl_info(protection_domain);
1307     InstanceKlass* scratch_class = SystemDictionary::parse_stream(
1308                                                       the_class_sym,
1309                                                       the_class_loader,
1310                                                       &amp;st,
1311                                                       cl_info,
1312                                                       THREAD);
1313     // Clear class_being_redefined just to be sure.
1314     state-&gt;clear_class_being_redefined();
1315 
1316     // TODO: if this is retransform, and nothing changed we can skip it
1317 
1318     // Need to clean up allocated InstanceKlass if there&#39;s an error so assign
1319     // the result here. Caller deallocates all the scratch classes in case of
1320     // an error.
1321     _scratch_classes[i] = scratch_class;
1322 
1323     if (HAS_PENDING_EXCEPTION) {
1324       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1325       log_info(redefine, class, load, exceptions)(&quot;parse_stream exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1326       CLEAR_PENDING_EXCEPTION;
1327 
1328       if (ex_name == vmSymbols::java_lang_UnsupportedClassVersionError()) {
1329         return JVMTI_ERROR_UNSUPPORTED_VERSION;
1330       } else if (ex_name == vmSymbols::java_lang_ClassFormatError()) {
1331         return JVMTI_ERROR_INVALID_CLASS_FORMAT;
1332       } else if (ex_name == vmSymbols::java_lang_ClassCircularityError()) {
1333         return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
1334       } else if (ex_name == vmSymbols::java_lang_NoClassDefFoundError()) {
1335         // The message will be &quot;XXX (wrong name: YYY)&quot;
1336         return JVMTI_ERROR_NAMES_DONT_MATCH;
1337       } else if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1338         return JVMTI_ERROR_OUT_OF_MEMORY;
1339       } else {  // Just in case more exceptions can be thrown..
1340         return JVMTI_ERROR_FAILS_VERIFICATION;
1341       }
1342     }
1343 
1344     // Ensure class is linked before redefine
1345     if (!the_class-&gt;is_linked()) {
1346       the_class-&gt;link_class(THREAD);
1347       if (HAS_PENDING_EXCEPTION) {
1348         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1349         oop message = java_lang_Throwable::message(PENDING_EXCEPTION);
1350         if (message != NULL) {
1351           char* ex_msg = java_lang_String::as_utf8_string(message);
1352           log_info(redefine, class, load, exceptions)(&quot;link_class exception: &#39;%s %s&#39;&quot;,
1353                    ex_name-&gt;as_C_string(), ex_msg);
1354         } else {
1355           log_info(redefine, class, load, exceptions)(&quot;link_class exception: &#39;%s&#39;&quot;,
1356                    ex_name-&gt;as_C_string());
1357         }
1358         CLEAR_PENDING_EXCEPTION;
1359         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1360           return JVMTI_ERROR_OUT_OF_MEMORY;
1361         } else if (ex_name == vmSymbols::java_lang_NoClassDefFoundError()) {
1362           return JVMTI_ERROR_INVALID_CLASS;
1363         } else {
1364           return JVMTI_ERROR_INTERNAL;
1365         }
1366       }
1367     }
1368 
1369     // Do the validity checks in compare_and_normalize_class_versions()
1370     // before verifying the byte codes. By doing these checks first, we
1371     // limit the number of functions that require redirection from
1372     // the_class to scratch_class. In particular, we don&#39;t have to
1373     // modify JNI GetSuperclass() and thus won&#39;t change its performance.
1374     jvmtiError res = compare_and_normalize_class_versions(the_class,
1375                        scratch_class);
1376     if (res != JVMTI_ERROR_NONE) {
1377       return res;
1378     }
1379 
1380     // verify what the caller passed us
1381     {
1382       // The bug 6214132 caused the verification to fail.
1383       // Information about the_class and scratch_class is temporarily
1384       // recorded into jvmtiThreadState. This data is used to redirect
1385       // the_class to scratch_class in the JVM_* functions called by the
1386       // verifier. Please, refer to jvmtiThreadState.hpp for the detailed
1387       // description.
1388       RedefineVerifyMark rvm(the_class, scratch_class, state);
1389       Verifier::verify(scratch_class, true, THREAD);
1390     }
1391 
1392     if (HAS_PENDING_EXCEPTION) {
1393       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1394       log_info(redefine, class, load, exceptions)(&quot;verify_byte_codes exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1395       CLEAR_PENDING_EXCEPTION;
1396       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1397         return JVMTI_ERROR_OUT_OF_MEMORY;
1398       } else {
1399         // tell the caller the bytecodes are bad
1400         return JVMTI_ERROR_FAILS_VERIFICATION;
1401       }
1402     }
1403 
1404     res = merge_cp_and_rewrite(the_class, scratch_class, THREAD);
1405     if (HAS_PENDING_EXCEPTION) {
1406       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1407       log_info(redefine, class, load, exceptions)(&quot;merge_cp_and_rewrite exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1408       CLEAR_PENDING_EXCEPTION;
1409       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1410         return JVMTI_ERROR_OUT_OF_MEMORY;
1411       } else {
1412         return JVMTI_ERROR_INTERNAL;
1413       }
1414     }
1415 
1416     if (VerifyMergedCPBytecodes) {
1417       // verify what we have done during constant pool merging
1418       {
1419         RedefineVerifyMark rvm(the_class, scratch_class, state);
1420         Verifier::verify(scratch_class, true, THREAD);
1421       }
1422 
1423       if (HAS_PENDING_EXCEPTION) {
1424         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1425         log_info(redefine, class, load, exceptions)
1426           (&quot;verify_byte_codes post merge-CP exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1427         CLEAR_PENDING_EXCEPTION;
1428         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1429           return JVMTI_ERROR_OUT_OF_MEMORY;
1430         } else {
1431           // tell the caller that constant pool merging screwed up
1432           return JVMTI_ERROR_INTERNAL;
1433         }
1434       }
1435     }
1436 
1437     Rewriter::rewrite(scratch_class, THREAD);
1438     if (!HAS_PENDING_EXCEPTION) {
1439       scratch_class-&gt;link_methods(THREAD);
1440     }
1441     if (HAS_PENDING_EXCEPTION) {
1442       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1443       log_info(redefine, class, load, exceptions)
1444         (&quot;Rewriter::rewrite or link_methods exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1445       CLEAR_PENDING_EXCEPTION;
1446       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1447         return JVMTI_ERROR_OUT_OF_MEMORY;
1448       } else {
1449         return JVMTI_ERROR_INTERNAL;
1450       }
1451     }
1452 
1453     log_debug(redefine, class, load)
1454       (&quot;loaded name=%s (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;, the_class-&gt;external_name(), os::available_memory() &gt;&gt; 10);
1455   }
1456 
1457   return JVMTI_ERROR_NONE;
1458 }
1459 
1460 
1461 // Map old_index to new_index as needed. scratch_cp is only needed
1462 // for log calls.
1463 void VM_RedefineClasses::map_index(const constantPoolHandle&amp; scratch_cp,
1464        int old_index, int new_index) {
1465   if (find_new_index(old_index) != 0) {
1466     // old_index is already mapped
1467     return;
1468   }
1469 
1470   if (old_index == new_index) {
1471     // no mapping is needed
1472     return;
1473   }
1474 
1475   _index_map_p-&gt;at_put(old_index, new_index);
1476   _index_map_count++;
1477 
1478   log_trace(redefine, class, constantpool)
1479     (&quot;mapped tag %d at index %d to %d&quot;, scratch_cp-&gt;tag_at(old_index).value(), old_index, new_index);
1480 } // end map_index()
1481 
1482 
1483 // Map old_index to new_index as needed.
1484 void VM_RedefineClasses::map_operand_index(int old_index, int new_index) {
1485   if (find_new_operand_index(old_index) != -1) {
1486     // old_index is already mapped
1487     return;
1488   }
1489 
1490   if (old_index == new_index) {
1491     // no mapping is needed
1492     return;
1493   }
1494 
1495   _operands_index_map_p-&gt;at_put(old_index, new_index);
1496   _operands_index_map_count++;
1497 
1498   log_trace(redefine, class, constantpool)(&quot;mapped bootstrap specifier at index %d to %d&quot;, old_index, new_index);
1499 } // end map_index()
1500 
1501 
1502 // Merge old_cp and scratch_cp and return the results of the merge via
1503 // merge_cp_p. The number of entries in *merge_cp_p is returned via
1504 // merge_cp_length_p. The entries in old_cp occupy the same locations
1505 // in *merge_cp_p. Also creates a map of indices from entries in
1506 // scratch_cp to the corresponding entry in *merge_cp_p. Index map
1507 // entries are only created for entries in scratch_cp that occupy a
1508 // different location in *merged_cp_p.
1509 bool VM_RedefineClasses::merge_constant_pools(const constantPoolHandle&amp; old_cp,
1510        const constantPoolHandle&amp; scratch_cp, constantPoolHandle *merge_cp_p,
1511        int *merge_cp_length_p, TRAPS) {
1512 
1513   if (merge_cp_p == NULL) {
1514     assert(false, &quot;caller must provide scratch constantPool&quot;);
1515     return false; // robustness
1516   }
1517   if (merge_cp_length_p == NULL) {
1518     assert(false, &quot;caller must provide scratch CP length&quot;);
1519     return false; // robustness
1520   }
1521   // Worst case we need old_cp-&gt;length() + scratch_cp()-&gt;length(),
1522   // but the caller might be smart so make sure we have at least
1523   // the minimum.
1524   if ((*merge_cp_p)-&gt;length() &lt; old_cp-&gt;length()) {
1525     assert(false, &quot;merge area too small&quot;);
1526     return false; // robustness
1527   }
1528 
1529   log_info(redefine, class, constantpool)(&quot;old_cp_len=%d, scratch_cp_len=%d&quot;, old_cp-&gt;length(), scratch_cp-&gt;length());
1530 
1531   {
1532     // Pass 0:
1533     // The old_cp is copied to *merge_cp_p; this means that any code
1534     // using old_cp does not have to change. This work looks like a
1535     // perfect fit for ConstantPool*::copy_cp_to(), but we need to
1536     // handle one special case:
1537     // - revert JVM_CONSTANT_Class to JVM_CONSTANT_UnresolvedClass
1538     // This will make verification happy.
1539 
1540     int old_i;  // index into old_cp
1541 
1542     // index zero (0) is not used in constantPools
1543     for (old_i = 1; old_i &lt; old_cp-&gt;length(); old_i++) {
1544       // leave debugging crumb
1545       jbyte old_tag = old_cp-&gt;tag_at(old_i).value();
1546       switch (old_tag) {
1547       case JVM_CONSTANT_Class:
1548       case JVM_CONSTANT_UnresolvedClass:
1549         // revert the copy to JVM_CONSTANT_UnresolvedClass
1550         // May be resolving while calling this so do the same for
1551         // JVM_CONSTANT_UnresolvedClass (klass_name_at() deals with transition)
1552         (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(old_i,
1553           old_cp-&gt;klass_name_index_at(old_i));
1554         break;
1555 
1556       case JVM_CONSTANT_Double:
1557       case JVM_CONSTANT_Long:
1558         // just copy the entry to *merge_cp_p, but double and long take
1559         // two constant pool entries
1560         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);
1561         old_i++;
1562         break;
1563 
1564       default:
1565         // just copy the entry to *merge_cp_p
1566         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);
1567         break;
1568       }
1569     } // end for each old_cp entry
1570 
1571     ConstantPool::copy_operands(old_cp, *merge_cp_p, CHECK_false);
1572     (*merge_cp_p)-&gt;extend_operands(scratch_cp, CHECK_false);
1573 
1574     // We don&#39;t need to sanity check that *merge_cp_length_p is within
1575     // *merge_cp_p bounds since we have the minimum on-entry check above.
1576     (*merge_cp_length_p) = old_i;
1577   }
1578 
1579   // merge_cp_len should be the same as old_cp-&gt;length() at this point
1580   // so this trace message is really a &quot;warm-and-breathing&quot; message.
1581   log_debug(redefine, class, constantpool)(&quot;after pass 0: merge_cp_len=%d&quot;, *merge_cp_length_p);
1582 
1583   int scratch_i;  // index into scratch_cp
1584   {
1585     // Pass 1a:
1586     // Compare scratch_cp entries to the old_cp entries that we have
1587     // already copied to *merge_cp_p. In this pass, we are eliminating
1588     // exact duplicates (matching entry at same index) so we only
1589     // compare entries in the common indice range.
1590     int increment = 1;
1591     int pass1a_length = MIN2(old_cp-&gt;length(), scratch_cp-&gt;length());
1592     for (scratch_i = 1; scratch_i &lt; pass1a_length; scratch_i += increment) {
1593       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1594       case JVM_CONSTANT_Double:
1595       case JVM_CONSTANT_Long:
1596         // double and long take two constant pool entries
1597         increment = 2;
1598         break;
1599 
1600       default:
1601         increment = 1;
1602         break;
1603       }
1604 
1605       bool match = scratch_cp-&gt;compare_entry_to(scratch_i, *merge_cp_p,
1606         scratch_i, CHECK_false);
1607       if (match) {
1608         // found a match at the same index so nothing more to do
1609         continue;
1610       } else if (is_unresolved_class_mismatch(scratch_cp, scratch_i,
1611                                               *merge_cp_p, scratch_i)) {
1612         // The mismatch in compare_entry_to() above is because of a
1613         // resolved versus unresolved class entry at the same index
1614         // with the same string value. Since Pass 0 reverted any
1615         // class entries to unresolved class entries in *merge_cp_p,
1616         // we go with the unresolved class entry.
1617         continue;
1618       }
1619 
1620       int found_i = scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p,
1621         CHECK_false);
1622       if (found_i != 0) {
1623         guarantee(found_i != scratch_i,
1624           &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
1625 
1626         // Found a matching entry somewhere else in *merge_cp_p so
1627         // just need a mapping entry.
1628         map_index(scratch_cp, scratch_i, found_i);
1629         continue;
1630       }
1631 
1632       // The find_matching_entry() call above could fail to find a match
1633       // due to a resolved versus unresolved class or string entry situation
1634       // like we solved above with the is_unresolved_*_mismatch() calls.
1635       // However, we would have to call is_unresolved_*_mismatch() over
1636       // all of *merge_cp_p (potentially) and that doesn&#39;t seem to be
1637       // worth the time.
1638 
1639       // No match found so we have to append this entry and any unique
1640       // referenced entries to *merge_cp_p.
1641       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
1642         CHECK_false);
1643     }
1644   }
1645 
1646   log_debug(redefine, class, constantpool)
1647     (&quot;after pass 1a: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1648      *merge_cp_length_p, scratch_i, _index_map_count);
1649 
1650   if (scratch_i &lt; scratch_cp-&gt;length()) {
1651     // Pass 1b:
1652     // old_cp is smaller than scratch_cp so there are entries in
1653     // scratch_cp that we have not yet processed. We take care of
1654     // those now.
1655     int increment = 1;
1656     for (; scratch_i &lt; scratch_cp-&gt;length(); scratch_i += increment) {
1657       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1658       case JVM_CONSTANT_Double:
1659       case JVM_CONSTANT_Long:
1660         // double and long take two constant pool entries
1661         increment = 2;
1662         break;
1663 
1664       default:
1665         increment = 1;
1666         break;
1667       }
1668 
1669       int found_i =
1670         scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p, CHECK_false);
1671       if (found_i != 0) {
1672         // Found a matching entry somewhere else in *merge_cp_p so
1673         // just need a mapping entry.
1674         map_index(scratch_cp, scratch_i, found_i);
1675         continue;
1676       }
1677 
1678       // No match found so we have to append this entry and any unique
1679       // referenced entries to *merge_cp_p.
1680       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
1681         CHECK_false);
1682     }
1683 
1684     log_debug(redefine, class, constantpool)
1685       (&quot;after pass 1b: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1686        *merge_cp_length_p, scratch_i, _index_map_count);
1687   }
1688   finalize_operands_merge(*merge_cp_p, THREAD);
1689 
1690   return true;
1691 } // end merge_constant_pools()
1692 
1693 
1694 // Scoped object to clean up the constant pool(s) created for merging
1695 class MergeCPCleaner {
1696   ClassLoaderData*   _loader_data;
1697   ConstantPool*      _cp;
1698   ConstantPool*      _scratch_cp;
1699  public:
1700   MergeCPCleaner(ClassLoaderData* loader_data, ConstantPool* merge_cp) :
1701                  _loader_data(loader_data), _cp(merge_cp), _scratch_cp(NULL) {}
1702   ~MergeCPCleaner() {
1703     _loader_data-&gt;add_to_deallocate_list(_cp);
1704     if (_scratch_cp != NULL) {
1705       _loader_data-&gt;add_to_deallocate_list(_scratch_cp);
1706     }
1707   }
1708   void add_scratch_cp(ConstantPool* scratch_cp) { _scratch_cp = scratch_cp; }
1709 };
1710 
1711 // Merge constant pools between the_class and scratch_class and
1712 // potentially rewrite bytecodes in scratch_class to use the merged
1713 // constant pool.
1714 jvmtiError VM_RedefineClasses::merge_cp_and_rewrite(
1715              InstanceKlass* the_class, InstanceKlass* scratch_class,
1716              TRAPS) {
1717   // worst case merged constant pool length is old and new combined
1718   int merge_cp_length = the_class-&gt;constants()-&gt;length()
1719         + scratch_class-&gt;constants()-&gt;length();
1720 
1721   // Constant pools are not easily reused so we allocate a new one
1722   // each time.
1723   // merge_cp is created unsafe for concurrent GC processing.  It
1724   // should be marked safe before discarding it. Even though
1725   // garbage,  if it crosses a card boundary, it may be scanned
1726   // in order to find the start of the first complete object on the card.
1727   ClassLoaderData* loader_data = the_class-&gt;class_loader_data();
1728   ConstantPool* merge_cp_oop =
1729     ConstantPool::allocate(loader_data,
1730                            merge_cp_length,
1731                            CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1732   MergeCPCleaner cp_cleaner(loader_data, merge_cp_oop);
1733 
1734   HandleMark hm(THREAD);  // make sure handles are cleared before
1735                           // MergeCPCleaner clears out merge_cp_oop
1736   constantPoolHandle merge_cp(THREAD, merge_cp_oop);
1737 
1738   // Get constants() from the old class because it could have been rewritten
1739   // while we were at a safepoint allocating a new constant pool.
1740   constantPoolHandle old_cp(THREAD, the_class-&gt;constants());
1741   constantPoolHandle scratch_cp(THREAD, scratch_class-&gt;constants());
1742 
1743   // If the length changed, the class was redefined out from under us. Return
1744   // an error.
1745   if (merge_cp_length != the_class-&gt;constants()-&gt;length()
1746          + scratch_class-&gt;constants()-&gt;length()) {
1747     return JVMTI_ERROR_INTERNAL;
1748   }
1749 
1750   // Update the version number of the constant pools (may keep scratch_cp)
1751   merge_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1752   scratch_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1753 
1754   ResourceMark rm(THREAD);
1755   _index_map_count = 0;
1756   _index_map_p = new intArray(scratch_cp-&gt;length(), scratch_cp-&gt;length(), -1);
1757 
1758   _operands_cur_length = ConstantPool::operand_array_length(old_cp-&gt;operands());
1759   _operands_index_map_count = 0;
1760   int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp-&gt;operands());
1761   _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);
1762 
1763   // reference to the cp holder is needed for copy_operands()
1764   merge_cp-&gt;set_pool_holder(scratch_class);
1765   bool result = merge_constant_pools(old_cp, scratch_cp, &amp;merge_cp,
1766                   &amp;merge_cp_length, THREAD);
1767   merge_cp-&gt;set_pool_holder(NULL);
1768 
1769   if (!result) {
1770     // The merge can fail due to memory allocation failure or due
1771     // to robustness checks.
1772     return JVMTI_ERROR_INTERNAL;
1773   }
1774 
1775   // Save fields from the old_cp.
1776   merge_cp-&gt;copy_fields(old_cp());
1777   scratch_cp-&gt;copy_fields(old_cp());
1778 
1779   log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
1780 
1781   if (_index_map_count == 0) {
1782     // there is nothing to map between the new and merged constant pools
1783 
1784     if (old_cp-&gt;length() == scratch_cp-&gt;length()) {
1785       // The old and new constant pools are the same length and the
1786       // index map is empty. This means that the three constant pools
1787       // are equivalent (but not the same). Unfortunately, the new
1788       // constant pool has not gone through link resolution nor have
1789       // the new class bytecodes gone through constant pool cache
1790       // rewriting so we can&#39;t use the old constant pool with the new
1791       // class.
1792 
1793       // toss the merged constant pool at return
1794     } else if (old_cp-&gt;length() &lt; scratch_cp-&gt;length()) {
1795       // The old constant pool has fewer entries than the new constant
1796       // pool and the index map is empty. This means the new constant
1797       // pool is a superset of the old constant pool. However, the old
1798       // class bytecodes have already gone through constant pool cache
1799       // rewriting so we can&#39;t use the new constant pool with the old
1800       // class.
1801 
1802       // toss the merged constant pool at return
1803     } else {
1804       // The old constant pool has more entries than the new constant
1805       // pool and the index map is empty. This means that both the old
1806       // and merged constant pools are supersets of the new constant
1807       // pool.
1808 
1809       // Replace the new constant pool with a shrunken copy of the
1810       // merged constant pool
1811       set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1812                             CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1813       // The new constant pool replaces scratch_cp so have cleaner clean it up.
1814       // It can&#39;t be cleaned up while there are handles to it.
1815       cp_cleaner.add_scratch_cp(scratch_cp());
1816     }
1817   } else {
1818     if (log_is_enabled(Trace, redefine, class, constantpool)) {
1819       // don&#39;t want to loop unless we are tracing
1820       int count = 0;
1821       for (int i = 1; i &lt; _index_map_p-&gt;length(); i++) {
1822         int value = _index_map_p-&gt;at(i);
1823 
1824         if (value != -1) {
1825           log_trace(redefine, class, constantpool)(&quot;index_map[%d]: old=%d new=%d&quot;, count, i, value);
1826           count++;
1827         }
1828       }
1829     }
1830 
1831     // We have entries mapped between the new and merged constant pools
1832     // so we have to rewrite some constant pool references.
1833     if (!rewrite_cp_refs(scratch_class, THREAD)) {
1834       return JVMTI_ERROR_INTERNAL;
1835     }
1836 
1837     // Replace the new constant pool with a shrunken copy of the
1838     // merged constant pool so now the rewritten bytecodes have
1839     // valid references; the previous new constant pool will get
1840     // GCed.
1841     set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1842                           CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1843     // The new constant pool replaces scratch_cp so have cleaner clean it up.
1844     // It can&#39;t be cleaned up while there are handles to it.
1845     cp_cleaner.add_scratch_cp(scratch_cp());
1846   }
1847 
1848   return JVMTI_ERROR_NONE;
1849 } // end merge_cp_and_rewrite()
1850 
1851 
1852 // Rewrite constant pool references in klass scratch_class.
1853 bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,
1854        TRAPS) {
1855 
1856   // rewrite constant pool references in the nest attributes:
1857   if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
1858     // propagate failure back to caller
1859     return false;
1860   }
1861 
1862   // rewrite constant pool references in the Record attribute:
1863   if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {
1864     // propagate failure back to caller
1865     return false;
1866   }
1867 
1868   // rewrite constant pool references in the PermittedSubclasses attribute:
1869   if (!rewrite_cp_refs_in_permitted_subclasses_attribute(scratch_class)) {
1870     // propagate failure back to caller
1871     return false;
1872   }
1873 
1874   // rewrite constant pool references in the methods:
1875   if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
1876     // propagate failure back to caller
1877     return false;
1878   }
1879 
1880   // rewrite constant pool references in the class_annotations:
1881   if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {
1882     // propagate failure back to caller
1883     return false;
1884   }
1885 
1886   // rewrite constant pool references in the fields_annotations:
1887   if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {
1888     // propagate failure back to caller
1889     return false;
1890   }
1891 
1892   // rewrite constant pool references in the methods_annotations:
1893   if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {
1894     // propagate failure back to caller
1895     return false;
1896   }
1897 
1898   // rewrite constant pool references in the methods_parameter_annotations:
1899   if (!rewrite_cp_refs_in_methods_parameter_annotations(scratch_class,
1900          THREAD)) {
1901     // propagate failure back to caller
1902     return false;
1903   }
1904 
1905   // rewrite constant pool references in the methods_default_annotations:
1906   if (!rewrite_cp_refs_in_methods_default_annotations(scratch_class,
1907          THREAD)) {
1908     // propagate failure back to caller
1909     return false;
1910   }
1911 
1912   // rewrite constant pool references in the class_type_annotations:
1913   if (!rewrite_cp_refs_in_class_type_annotations(scratch_class, THREAD)) {
1914     // propagate failure back to caller
1915     return false;
1916   }
1917 
1918   // rewrite constant pool references in the fields_type_annotations:
1919   if (!rewrite_cp_refs_in_fields_type_annotations(scratch_class, THREAD)) {
1920     // propagate failure back to caller
1921     return false;
1922   }
1923 
1924   // rewrite constant pool references in the methods_type_annotations:
1925   if (!rewrite_cp_refs_in_methods_type_annotations(scratch_class, THREAD)) {
1926     // propagate failure back to caller
1927     return false;
1928   }
1929 
1930   // There can be type annotations in the Code part of a method_info attribute.
1931   // These annotations are not accessible, even by reflection.
1932   // Currently they are not even parsed by the ClassFileParser.
1933   // If runtime access is added they will also need to be rewritten.
1934 
1935   // rewrite source file name index:
1936   u2 source_file_name_idx = scratch_class-&gt;source_file_name_index();
1937   if (source_file_name_idx != 0) {
1938     u2 new_source_file_name_idx = find_new_index(source_file_name_idx);
1939     if (new_source_file_name_idx != 0) {
1940       scratch_class-&gt;set_source_file_name_index(new_source_file_name_idx);
1941     }
1942   }
1943 
1944   // rewrite class generic signature index:
1945   u2 generic_signature_index = scratch_class-&gt;generic_signature_index();
1946   if (generic_signature_index != 0) {
1947     u2 new_generic_signature_index = find_new_index(generic_signature_index);
1948     if (new_generic_signature_index != 0) {
1949       scratch_class-&gt;set_generic_signature_index(new_generic_signature_index);
1950     }
1951   }
1952 
1953   return true;
1954 } // end rewrite_cp_refs()
1955 
1956 // Rewrite constant pool references in the NestHost and NestMembers attributes.
1957 bool VM_RedefineClasses::rewrite_cp_refs_in_nest_attributes(
1958        InstanceKlass* scratch_class) {
1959 
1960   u2 cp_index = scratch_class-&gt;nest_host_index();
1961   if (cp_index != 0) {
1962     scratch_class-&gt;set_nest_host_index(find_new_index(cp_index));
1963   }
1964   Array&lt;u2&gt;* nest_members = scratch_class-&gt;nest_members();
1965   for (int i = 0; i &lt; nest_members-&gt;length(); i++) {
1966     u2 cp_index = nest_members-&gt;at(i);
1967     nest_members-&gt;at_put(i, find_new_index(cp_index));
1968   }
1969   return true;
1970 }
1971 
1972 // Rewrite constant pool references in the Record attribute.
1973 bool VM_RedefineClasses::rewrite_cp_refs_in_record_attribute(
1974        InstanceKlass* scratch_class, TRAPS) {
1975   Array&lt;RecordComponent*&gt;* components = scratch_class-&gt;record_components();
1976   if (components != NULL) {
1977     for (int i = 0; i &lt; components-&gt;length(); i++) {
1978       RecordComponent* component = components-&gt;at(i);
1979       u2 cp_index = component-&gt;name_index();
1980       component-&gt;set_name_index(find_new_index(cp_index));
1981       cp_index = component-&gt;descriptor_index();
1982       component-&gt;set_descriptor_index(find_new_index(cp_index));
1983       cp_index = component-&gt;generic_signature_index();
1984       if (cp_index != 0) {
1985         component-&gt;set_generic_signature_index(find_new_index(cp_index));
1986       }
1987 
1988       AnnotationArray* annotations = component-&gt;annotations();
1989       if (annotations != NULL &amp;&amp; annotations-&gt;length() != 0) {
1990         int byte_i = 0;  // byte index into annotations
1991         if (!rewrite_cp_refs_in_annotations_typeArray(annotations, byte_i, THREAD)) {
1992           log_debug(redefine, class, annotation)(&quot;bad record_component_annotations at %d&quot;, i);
1993           // propagate failure back to caller
1994           return false;
1995         }
1996       }
1997 
1998       AnnotationArray* type_annotations = component-&gt;type_annotations();
1999       if (type_annotations != NULL &amp;&amp; type_annotations-&gt;length() != 0) {
2000         int byte_i = 0;  // byte index into annotations
2001         if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {
2002           log_debug(redefine, class, annotation)(&quot;bad record_component_type_annotations at %d&quot;, i);
2003           // propagate failure back to caller
2004           return false;
2005         }
2006       }
2007     }
2008   }
2009   return true;
2010 }
2011 
2012 // Rewrite constant pool references in the PermittedSubclasses attribute.
2013 bool VM_RedefineClasses::rewrite_cp_refs_in_permitted_subclasses_attribute(
2014        InstanceKlass* scratch_class) {
2015 
2016   Array&lt;u2&gt;* permitted_subclasses = scratch_class-&gt;permitted_subclasses();
2017   assert(permitted_subclasses != NULL, &quot;unexpected null permitted_subclasses&quot;);
2018   for (int i = 0; i &lt; permitted_subclasses-&gt;length(); i++) {
2019     u2 cp_index = permitted_subclasses-&gt;at(i);
2020     permitted_subclasses-&gt;at_put(i, find_new_index(cp_index));
2021   }
2022   return true;
2023 }
2024 
2025 // Rewrite constant pool references in the methods.
2026 bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
2027        InstanceKlass* scratch_class, TRAPS) {
2028 
2029   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
2030 
2031   if (methods == NULL || methods-&gt;length() == 0) {
2032     // no methods so nothing to do
2033     return true;
2034   }
2035 
2036   // rewrite constant pool references in the methods:
2037   for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
2038     methodHandle method(THREAD, methods-&gt;at(i));
2039     methodHandle new_method;
2040     rewrite_cp_refs_in_method(method, &amp;new_method, THREAD);
2041     if (!new_method.is_null()) {
2042       // the method has been replaced so save the new method version
2043       // even in the case of an exception.  original method is on the
2044       // deallocation list.
2045       methods-&gt;at_put(i, new_method());
2046     }
2047     if (HAS_PENDING_EXCEPTION) {
2048       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
2049       log_info(redefine, class, load, exceptions)(&quot;rewrite_cp_refs_in_method exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
2050       // Need to clear pending exception here as the super caller sets
2051       // the JVMTI_ERROR_INTERNAL if the returned value is false.
2052       CLEAR_PENDING_EXCEPTION;
2053       return false;
2054     }
2055   }
2056 
2057   return true;
2058 }
2059 
2060 
2061 // Rewrite constant pool references in the specific method. This code
2062 // was adapted from Rewriter::rewrite_method().
2063 void VM_RedefineClasses::rewrite_cp_refs_in_method(methodHandle method,
2064        methodHandle *new_method_p, TRAPS) {
2065 
2066   *new_method_p = methodHandle();  // default is no new method
2067 
2068   // We cache a pointer to the bytecodes here in code_base. If GC
2069   // moves the Method*, then the bytecodes will also move which
2070   // will likely cause a crash. We create a NoSafepointVerifier
2071   // object to detect whether we pass a possible safepoint in this
2072   // code block.
2073   NoSafepointVerifier nsv;
2074 
2075   // Bytecodes and their length
2076   address code_base = method-&gt;code_base();
2077   int code_length = method-&gt;code_size();
2078 
2079   int bc_length;
2080   for (int bci = 0; bci &lt; code_length; bci += bc_length) {
2081     address bcp = code_base + bci;
2082     Bytecodes::Code c = (Bytecodes::Code)(*bcp);
2083 
2084     bc_length = Bytecodes::length_for(c);
2085     if (bc_length == 0) {
2086       // More complicated bytecodes report a length of zero so
2087       // we have to try again a slightly different way.
2088       bc_length = Bytecodes::length_at(method(), bcp);
2089     }
2090 
2091     assert(bc_length != 0, &quot;impossible bytecode length&quot;);
2092 
2093     switch (c) {
2094       case Bytecodes::_ldc:
2095       {
2096         int cp_index = *(bcp + 1);
2097         int new_index = find_new_index(cp_index);
2098 
2099         if (StressLdcRewrite &amp;&amp; new_index == 0) {
2100           // If we are stressing ldc -&gt; ldc_w rewriting, then we
2101           // always need a new_index value.
2102           new_index = cp_index;
2103         }
2104         if (new_index != 0) {
2105           // the original index is mapped so we have more work to do
2106           if (!StressLdcRewrite &amp;&amp; new_index &lt;= max_jubyte) {
2107             // The new value can still use ldc instead of ldc_w
2108             // unless we are trying to stress ldc -&gt; ldc_w rewriting
2109             log_trace(redefine, class, constantpool)
2110               (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2111             *(bcp + 1) = new_index;
2112           } else {
2113             log_trace(redefine, class, constantpool)
2114               (&quot;%s-&gt;ldc_w@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2115             // the new value needs ldc_w instead of ldc
2116             u_char inst_buffer[4]; // max instruction size is 4 bytes
2117             bcp = (address)inst_buffer;
2118             // construct new instruction sequence
2119             *bcp = Bytecodes::_ldc_w;
2120             bcp++;
2121             // Rewriter::rewrite_method() does not rewrite ldc -&gt; ldc_w.
2122             // See comment below for difference between put_Java_u2()
2123             // and put_native_u2().
2124             Bytes::put_Java_u2(bcp, new_index);
2125 
2126             Relocator rc(method, NULL /* no RelocatorListener needed */);
2127             methodHandle m;
2128             {
2129               PauseNoSafepointVerifier pnsv(&amp;nsv);
2130 
2131               // ldc is 2 bytes and ldc_w is 3 bytes
2132               m = rc.insert_space_at(bci, 3, inst_buffer, CHECK);
2133             }
2134 
2135             // return the new method so that the caller can update
2136             // the containing class
2137             *new_method_p = method = m;
2138             // switch our bytecode processing loop from the old method
2139             // to the new method
2140             code_base = method-&gt;code_base();
2141             code_length = method-&gt;code_size();
2142             bcp = code_base + bci;
2143             c = (Bytecodes::Code)(*bcp);
2144             bc_length = Bytecodes::length_for(c);
2145             assert(bc_length != 0, &quot;sanity check&quot;);
2146           } // end we need ldc_w instead of ldc
2147         } // end if there is a mapped index
2148       } break;
2149 
2150       // these bytecodes have a two-byte constant pool index
2151       case Bytecodes::_anewarray      : // fall through
2152       case Bytecodes::_checkcast      : // fall through
2153       case Bytecodes::_getfield       : // fall through
2154       case Bytecodes::_getstatic      : // fall through
2155       case Bytecodes::_instanceof     : // fall through
2156       case Bytecodes::_invokedynamic  : // fall through
2157       case Bytecodes::_invokeinterface: // fall through
2158       case Bytecodes::_invokespecial  : // fall through
2159       case Bytecodes::_invokestatic   : // fall through
2160       case Bytecodes::_invokevirtual  : // fall through
2161       case Bytecodes::_ldc_w          : // fall through
2162       case Bytecodes::_ldc2_w         : // fall through
2163       case Bytecodes::_multianewarray : // fall through
2164       case Bytecodes::_new            : // fall through
2165       case Bytecodes::_putfield       : // fall through
2166       case Bytecodes::_putstatic      :
2167       {
2168         address p = bcp + 1;
2169         int cp_index = Bytes::get_Java_u2(p);
2170         int new_index = find_new_index(cp_index);
2171         if (new_index != 0) {
2172           // the original index is mapped so update w/ new value
2173           log_trace(redefine, class, constantpool)
2174             (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c),p2i(bcp), cp_index, new_index);
2175           // Rewriter::rewrite_method() uses put_native_u2() in this
2176           // situation because it is reusing the constant pool index
2177           // location for a native index into the ConstantPoolCache.
2178           // Since we are updating the constant pool index prior to
2179           // verification and ConstantPoolCache initialization, we
2180           // need to keep the new index in Java byte order.
2181           Bytes::put_Java_u2(p, new_index);
2182         }
2183       } break;
2184       default:
2185         break;
2186     }
2187   } // end for each bytecode
2188 
2189   // We also need to rewrite the parameter name indexes, if there is
2190   // method parameter data present
2191   if(method-&gt;has_method_parameters()) {
2192     const int len = method-&gt;method_parameters_length();
2193     MethodParametersElement* elem = method-&gt;method_parameters_start();
2194 
2195     for (int i = 0; i &lt; len; i++) {
2196       const u2 cp_index = elem[i].name_cp_index;
2197       const u2 new_cp_index = find_new_index(cp_index);
2198       if (new_cp_index != 0) {
2199         elem[i].name_cp_index = new_cp_index;
2200       }
2201     }
2202   }
2203 } // end rewrite_cp_refs_in_method()
2204 
2205 
2206 // Rewrite constant pool references in the class_annotations field.
2207 bool VM_RedefineClasses::rewrite_cp_refs_in_class_annotations(
2208        InstanceKlass* scratch_class, TRAPS) {
2209 
2210   AnnotationArray* class_annotations = scratch_class-&gt;class_annotations();
2211   if (class_annotations == NULL || class_annotations-&gt;length() == 0) {
2212     // no class_annotations so nothing to do
2213     return true;
2214   }
2215 
2216   log_debug(redefine, class, annotation)(&quot;class_annotations length=%d&quot;, class_annotations-&gt;length());
2217 
2218   int byte_i = 0;  // byte index into class_annotations
2219   return rewrite_cp_refs_in_annotations_typeArray(class_annotations, byte_i,
2220            THREAD);
2221 }
2222 
2223 
2224 // Rewrite constant pool references in an annotations typeArray. This
2225 // &quot;structure&quot; is adapted from the RuntimeVisibleAnnotations_attribute
2226 // that is described in section 4.8.15 of the 2nd-edition of the VM spec:
2227 //
2228 // annotations_typeArray {
2229 //   u2 num_annotations;
2230 //   annotation annotations[num_annotations];
2231 // }
2232 //
2233 bool VM_RedefineClasses::rewrite_cp_refs_in_annotations_typeArray(
2234        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2235 
2236   if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2237     // not enough room for num_annotations field
2238     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2239     return false;
2240   }
2241 
2242   u2 num_annotations = Bytes::get_Java_u2((address)
2243                          annotations_typeArray-&gt;adr_at(byte_i_ref));
2244   byte_i_ref += 2;
2245 
2246   log_debug(redefine, class, annotation)(&quot;num_annotations=%d&quot;, num_annotations);
2247 
2248   int calc_num_annotations = 0;
2249   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2250     if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2251            byte_i_ref, THREAD)) {
2252       log_debug(redefine, class, annotation)(&quot;bad annotation_struct at %d&quot;, calc_num_annotations);
2253       // propagate failure back to caller
2254       return false;
2255     }
2256   }
2257   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2258 
2259   return true;
2260 } // end rewrite_cp_refs_in_annotations_typeArray()
2261 
2262 
2263 // Rewrite constant pool references in the annotation struct portion of
2264 // an annotations_typeArray. This &quot;structure&quot; is from section 4.8.15 of
2265 // the 2nd-edition of the VM spec:
2266 //
2267 // struct annotation {
2268 //   u2 type_index;
2269 //   u2 num_element_value_pairs;
2270 //   {
2271 //     u2 element_name_index;
2272 //     element_value value;
2273 //   } element_value_pairs[num_element_value_pairs];
2274 // }
2275 //
2276 bool VM_RedefineClasses::rewrite_cp_refs_in_annotation_struct(
2277        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2278   if ((byte_i_ref + 2 + 2) &gt; annotations_typeArray-&gt;length()) {
2279     // not enough room for smallest annotation_struct
2280     log_debug(redefine, class, annotation)(&quot;length() is too small for annotation_struct&quot;);
2281     return false;
2282   }
2283 
2284   u2 type_index = rewrite_cp_ref_in_annotation_data(annotations_typeArray,
2285                     byte_i_ref, &quot;type_index&quot;, THREAD);
2286 
2287   u2 num_element_value_pairs = Bytes::get_Java_u2((address)
2288                                  annotations_typeArray-&gt;adr_at(byte_i_ref));
2289   byte_i_ref += 2;
2290 
2291   log_debug(redefine, class, annotation)
2292     (&quot;type_index=%d  num_element_value_pairs=%d&quot;, type_index, num_element_value_pairs);
2293 
2294   int calc_num_element_value_pairs = 0;
2295   for (; calc_num_element_value_pairs &lt; num_element_value_pairs;
2296        calc_num_element_value_pairs++) {
2297     if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2298       // not enough room for another element_name_index, let alone
2299       // the rest of another component
2300       log_debug(redefine, class, annotation)(&quot;length() is too small for element_name_index&quot;);
2301       return false;
2302     }
2303 
2304     u2 element_name_index = rewrite_cp_ref_in_annotation_data(
2305                               annotations_typeArray, byte_i_ref,
2306                               &quot;element_name_index&quot;, THREAD);
2307 
2308     log_debug(redefine, class, annotation)(&quot;element_name_index=%d&quot;, element_name_index);
2309 
2310     if (!rewrite_cp_refs_in_element_value(annotations_typeArray,
2311            byte_i_ref, THREAD)) {
2312       log_debug(redefine, class, annotation)(&quot;bad element_value at %d&quot;, calc_num_element_value_pairs);
2313       // propagate failure back to caller
2314       return false;
2315     }
2316   } // end for each component
2317   assert(num_element_value_pairs == calc_num_element_value_pairs,
2318     &quot;sanity check&quot;);
2319 
2320   return true;
2321 } // end rewrite_cp_refs_in_annotation_struct()
2322 
2323 
2324 // Rewrite a constant pool reference at the current position in
2325 // annotations_typeArray if needed. Returns the original constant
2326 // pool reference if a rewrite was not needed or the new constant
2327 // pool reference if a rewrite was needed.
2328 u2 VM_RedefineClasses::rewrite_cp_ref_in_annotation_data(
2329      AnnotationArray* annotations_typeArray, int &amp;byte_i_ref,
2330      const char * trace_mesg, TRAPS) {
2331 
2332   address cp_index_addr = (address)
2333     annotations_typeArray-&gt;adr_at(byte_i_ref);
2334   u2 old_cp_index = Bytes::get_Java_u2(cp_index_addr);
2335   u2 new_cp_index = find_new_index(old_cp_index);
2336   if (new_cp_index != 0) {
2337     log_debug(redefine, class, annotation)(&quot;mapped old %s=%d&quot;, trace_mesg, old_cp_index);
2338     Bytes::put_Java_u2(cp_index_addr, new_cp_index);
2339     old_cp_index = new_cp_index;
2340   }
2341   byte_i_ref += 2;
2342   return old_cp_index;
2343 }
2344 
2345 
2346 // Rewrite constant pool references in the element_value portion of an
2347 // annotations_typeArray. This &quot;structure&quot; is from section 4.8.15.1 of
2348 // the 2nd-edition of the VM spec:
2349 //
2350 // struct element_value {
2351 //   u1 tag;
2352 //   union {
2353 //     u2 const_value_index;
2354 //     {
2355 //       u2 type_name_index;
2356 //       u2 const_name_index;
2357 //     } enum_const_value;
2358 //     u2 class_info_index;
2359 //     annotation annotation_value;
2360 //     struct {
2361 //       u2 num_values;
2362 //       element_value values[num_values];
2363 //     } array_value;
2364 //   } value;
2365 // }
2366 //
2367 bool VM_RedefineClasses::rewrite_cp_refs_in_element_value(
2368        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2369 
2370   if ((byte_i_ref + 1) &gt; annotations_typeArray-&gt;length()) {
2371     // not enough room for a tag let alone the rest of an element_value
2372     log_debug(redefine, class, annotation)(&quot;length() is too small for a tag&quot;);
2373     return false;
2374   }
2375 
2376   u1 tag = annotations_typeArray-&gt;at(byte_i_ref);
2377   byte_i_ref++;
2378   log_debug(redefine, class, annotation)(&quot;tag=&#39;%c&#39;&quot;, tag);
2379 
2380   switch (tag) {
2381     // These BaseType tag values are from Table 4.2 in VM spec:
2382     case JVM_SIGNATURE_BYTE:
2383     case JVM_SIGNATURE_CHAR:
2384     case JVM_SIGNATURE_DOUBLE:
2385     case JVM_SIGNATURE_FLOAT:
2386     case JVM_SIGNATURE_INT:
2387     case JVM_SIGNATURE_LONG:
2388     case JVM_SIGNATURE_SHORT:
2389     case JVM_SIGNATURE_BOOLEAN:
2390 
2391     // The remaining tag values are from Table 4.8 in the 2nd-edition of
2392     // the VM spec:
2393     case &#39;s&#39;:
2394     {
2395       // For the above tag values (including the BaseType values),
2396       // value.const_value_index is right union field.
2397 
2398       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2399         // not enough room for a const_value_index
2400         log_debug(redefine, class, annotation)(&quot;length() is too small for a const_value_index&quot;);
2401         return false;
2402       }
2403 
2404       u2 const_value_index = rewrite_cp_ref_in_annotation_data(
2405                                annotations_typeArray, byte_i_ref,
2406                                &quot;const_value_index&quot;, THREAD);
2407 
2408       log_debug(redefine, class, annotation)(&quot;const_value_index=%d&quot;, const_value_index);
2409     } break;
2410 
2411     case &#39;e&#39;:
2412     {
2413       // for the above tag value, value.enum_const_value is right union field
2414 
2415       if ((byte_i_ref + 4) &gt; annotations_typeArray-&gt;length()) {
2416         // not enough room for a enum_const_value
2417         log_debug(redefine, class, annotation)(&quot;length() is too small for a enum_const_value&quot;);
2418         return false;
2419       }
2420 
2421       u2 type_name_index = rewrite_cp_ref_in_annotation_data(
2422                              annotations_typeArray, byte_i_ref,
2423                              &quot;type_name_index&quot;, THREAD);
2424 
2425       u2 const_name_index = rewrite_cp_ref_in_annotation_data(
2426                               annotations_typeArray, byte_i_ref,
2427                               &quot;const_name_index&quot;, THREAD);
2428 
2429       log_debug(redefine, class, annotation)
2430         (&quot;type_name_index=%d  const_name_index=%d&quot;, type_name_index, const_name_index);
2431     } break;
2432 
2433     case &#39;c&#39;:
2434     {
2435       // for the above tag value, value.class_info_index is right union field
2436 
2437       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2438         // not enough room for a class_info_index
2439         log_debug(redefine, class, annotation)(&quot;length() is too small for a class_info_index&quot;);
2440         return false;
2441       }
2442 
2443       u2 class_info_index = rewrite_cp_ref_in_annotation_data(
2444                               annotations_typeArray, byte_i_ref,
2445                               &quot;class_info_index&quot;, THREAD);
2446 
2447       log_debug(redefine, class, annotation)(&quot;class_info_index=%d&quot;, class_info_index);
2448     } break;
2449 
2450     case &#39;@&#39;:
2451       // For the above tag value, value.attr_value is the right union
2452       // field. This is a nested annotation.
2453       if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2454              byte_i_ref, THREAD)) {
2455         // propagate failure back to caller
2456         return false;
2457       }
2458       break;
2459 
2460     case JVM_SIGNATURE_ARRAY:
2461     {
2462       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2463         // not enough room for a num_values field
2464         log_debug(redefine, class, annotation)(&quot;length() is too small for a num_values field&quot;);
2465         return false;
2466       }
2467 
2468       // For the above tag value, value.array_value is the right union
2469       // field. This is an array of nested element_value.
2470       u2 num_values = Bytes::get_Java_u2((address)
2471                         annotations_typeArray-&gt;adr_at(byte_i_ref));
2472       byte_i_ref += 2;
2473       log_debug(redefine, class, annotation)(&quot;num_values=%d&quot;, num_values);
2474 
2475       int calc_num_values = 0;
2476       for (; calc_num_values &lt; num_values; calc_num_values++) {
2477         if (!rewrite_cp_refs_in_element_value(
2478                annotations_typeArray, byte_i_ref, THREAD)) {
2479           log_debug(redefine, class, annotation)(&quot;bad nested element_value at %d&quot;, calc_num_values);
2480           // propagate failure back to caller
2481           return false;
2482         }
2483       }
2484       assert(num_values == calc_num_values, &quot;sanity check&quot;);
2485     } break;
2486 
2487     default:
2488       log_debug(redefine, class, annotation)(&quot;bad tag=0x%x&quot;, tag);
2489       return false;
2490   } // end decode tag field
2491 
2492   return true;
2493 } // end rewrite_cp_refs_in_element_value()
2494 
2495 
2496 // Rewrite constant pool references in a fields_annotations field.
2497 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_annotations(
2498        InstanceKlass* scratch_class, TRAPS) {
2499 
2500   Array&lt;AnnotationArray*&gt;* fields_annotations = scratch_class-&gt;fields_annotations();
2501 
2502   if (fields_annotations == NULL || fields_annotations-&gt;length() == 0) {
2503     // no fields_annotations so nothing to do
2504     return true;
2505   }
2506 
2507   log_debug(redefine, class, annotation)(&quot;fields_annotations length=%d&quot;, fields_annotations-&gt;length());
2508 
2509   for (int i = 0; i &lt; fields_annotations-&gt;length(); i++) {
2510     AnnotationArray* field_annotations = fields_annotations-&gt;at(i);
2511     if (field_annotations == NULL || field_annotations-&gt;length() == 0) {
2512       // this field does not have any annotations so skip it
2513       continue;
2514     }
2515 
2516     int byte_i = 0;  // byte index into field_annotations
2517     if (!rewrite_cp_refs_in_annotations_typeArray(field_annotations, byte_i,
2518            THREAD)) {
2519       log_debug(redefine, class, annotation)(&quot;bad field_annotations at %d&quot;, i);
2520       // propagate failure back to caller
2521       return false;
2522     }
2523   }
2524 
2525   return true;
2526 } // end rewrite_cp_refs_in_fields_annotations()
2527 
2528 
2529 // Rewrite constant pool references in a methods_annotations field.
2530 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_annotations(
2531        InstanceKlass* scratch_class, TRAPS) {
2532 
2533   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2534     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2535     AnnotationArray* method_annotations = m-&gt;constMethod()-&gt;method_annotations();
2536 
2537     if (method_annotations == NULL || method_annotations-&gt;length() == 0) {
2538       // this method does not have any annotations so skip it
2539       continue;
2540     }
2541 
2542     int byte_i = 0;  // byte index into method_annotations
2543     if (!rewrite_cp_refs_in_annotations_typeArray(method_annotations, byte_i,
2544            THREAD)) {
2545       log_debug(redefine, class, annotation)(&quot;bad method_annotations at %d&quot;, i);
2546       // propagate failure back to caller
2547       return false;
2548     }
2549   }
2550 
2551   return true;
2552 } // end rewrite_cp_refs_in_methods_annotations()
2553 
2554 
2555 // Rewrite constant pool references in a methods_parameter_annotations
2556 // field. This &quot;structure&quot; is adapted from the
2557 // RuntimeVisibleParameterAnnotations_attribute described in section
2558 // 4.8.17 of the 2nd-edition of the VM spec:
2559 //
2560 // methods_parameter_annotations_typeArray {
2561 //   u1 num_parameters;
2562 //   {
2563 //     u2 num_annotations;
2564 //     annotation annotations[num_annotations];
2565 //   } parameter_annotations[num_parameters];
2566 // }
2567 //
2568 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_parameter_annotations(
2569        InstanceKlass* scratch_class, TRAPS) {
2570 
2571   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2572     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2573     AnnotationArray* method_parameter_annotations = m-&gt;constMethod()-&gt;parameter_annotations();
2574     if (method_parameter_annotations == NULL
2575         || method_parameter_annotations-&gt;length() == 0) {
2576       // this method does not have any parameter annotations so skip it
2577       continue;
2578     }
2579 
2580     if (method_parameter_annotations-&gt;length() &lt; 1) {
2581       // not enough room for a num_parameters field
2582       log_debug(redefine, class, annotation)(&quot;length() is too small for a num_parameters field at %d&quot;, i);
2583       return false;
2584     }
2585 
2586     int byte_i = 0;  // byte index into method_parameter_annotations
2587 
2588     u1 num_parameters = method_parameter_annotations-&gt;at(byte_i);
2589     byte_i++;
2590 
2591     log_debug(redefine, class, annotation)(&quot;num_parameters=%d&quot;, num_parameters);
2592 
2593     int calc_num_parameters = 0;
2594     for (; calc_num_parameters &lt; num_parameters; calc_num_parameters++) {
2595       if (!rewrite_cp_refs_in_annotations_typeArray(
2596              method_parameter_annotations, byte_i, THREAD)) {
2597         log_debug(redefine, class, annotation)(&quot;bad method_parameter_annotations at %d&quot;, calc_num_parameters);
2598         // propagate failure back to caller
2599         return false;
2600       }
2601     }
2602     assert(num_parameters == calc_num_parameters, &quot;sanity check&quot;);
2603   }
2604 
2605   return true;
2606 } // end rewrite_cp_refs_in_methods_parameter_annotations()
2607 
2608 
2609 // Rewrite constant pool references in a methods_default_annotations
2610 // field. This &quot;structure&quot; is adapted from the AnnotationDefault_attribute
2611 // that is described in section 4.8.19 of the 2nd-edition of the VM spec:
2612 //
2613 // methods_default_annotations_typeArray {
2614 //   element_value default_value;
2615 // }
2616 //
2617 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_default_annotations(
2618        InstanceKlass* scratch_class, TRAPS) {
2619 
2620   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2621     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2622     AnnotationArray* method_default_annotations = m-&gt;constMethod()-&gt;default_annotations();
2623     if (method_default_annotations == NULL
2624         || method_default_annotations-&gt;length() == 0) {
2625       // this method does not have any default annotations so skip it
2626       continue;
2627     }
2628 
2629     int byte_i = 0;  // byte index into method_default_annotations
2630 
2631     if (!rewrite_cp_refs_in_element_value(
2632            method_default_annotations, byte_i, THREAD)) {
2633       log_debug(redefine, class, annotation)(&quot;bad default element_value at %d&quot;, i);
2634       // propagate failure back to caller
2635       return false;
2636     }
2637   }
2638 
2639   return true;
2640 } // end rewrite_cp_refs_in_methods_default_annotations()
2641 
2642 
2643 // Rewrite constant pool references in a class_type_annotations field.
2644 bool VM_RedefineClasses::rewrite_cp_refs_in_class_type_annotations(
2645        InstanceKlass* scratch_class, TRAPS) {
2646 
2647   AnnotationArray* class_type_annotations = scratch_class-&gt;class_type_annotations();
2648   if (class_type_annotations == NULL || class_type_annotations-&gt;length() == 0) {
2649     // no class_type_annotations so nothing to do
2650     return true;
2651   }
2652 
2653   log_debug(redefine, class, annotation)(&quot;class_type_annotations length=%d&quot;, class_type_annotations-&gt;length());
2654 
2655   int byte_i = 0;  // byte index into class_type_annotations
2656   return rewrite_cp_refs_in_type_annotations_typeArray(class_type_annotations,
2657       byte_i, &quot;ClassFile&quot;, THREAD);
2658 } // end rewrite_cp_refs_in_class_type_annotations()
2659 
2660 
2661 // Rewrite constant pool references in a fields_type_annotations field.
2662 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_type_annotations(
2663        InstanceKlass* scratch_class, TRAPS) {
2664 
2665   Array&lt;AnnotationArray*&gt;* fields_type_annotations = scratch_class-&gt;fields_type_annotations();
2666   if (fields_type_annotations == NULL || fields_type_annotations-&gt;length() == 0) {
2667     // no fields_type_annotations so nothing to do
2668     return true;
2669   }
2670 
2671   log_debug(redefine, class, annotation)(&quot;fields_type_annotations length=%d&quot;, fields_type_annotations-&gt;length());
2672 
2673   for (int i = 0; i &lt; fields_type_annotations-&gt;length(); i++) {
2674     AnnotationArray* field_type_annotations = fields_type_annotations-&gt;at(i);
2675     if (field_type_annotations == NULL || field_type_annotations-&gt;length() == 0) {
2676       // this field does not have any annotations so skip it
2677       continue;
2678     }
2679 
2680     int byte_i = 0;  // byte index into field_type_annotations
2681     if (!rewrite_cp_refs_in_type_annotations_typeArray(field_type_annotations,
2682            byte_i, &quot;field_info&quot;, THREAD)) {
2683       log_debug(redefine, class, annotation)(&quot;bad field_type_annotations at %d&quot;, i);
2684       // propagate failure back to caller
2685       return false;
2686     }
2687   }
2688 
2689   return true;
2690 } // end rewrite_cp_refs_in_fields_type_annotations()
2691 
2692 
2693 // Rewrite constant pool references in a methods_type_annotations field.
2694 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_type_annotations(
2695        InstanceKlass* scratch_class, TRAPS) {
2696 
2697   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2698     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2699     AnnotationArray* method_type_annotations = m-&gt;constMethod()-&gt;type_annotations();
2700 
2701     if (method_type_annotations == NULL || method_type_annotations-&gt;length() == 0) {
2702       // this method does not have any annotations so skip it
2703       continue;
2704     }
2705 
2706     log_debug(redefine, class, annotation)(&quot;methods type_annotations length=%d&quot;, method_type_annotations-&gt;length());
2707 
2708     int byte_i = 0;  // byte index into method_type_annotations
2709     if (!rewrite_cp_refs_in_type_annotations_typeArray(method_type_annotations,
2710            byte_i, &quot;method_info&quot;, THREAD)) {
2711       log_debug(redefine, class, annotation)(&quot;bad method_type_annotations at %d&quot;, i);
2712       // propagate failure back to caller
2713       return false;
2714     }
2715   }
2716 
2717   return true;
2718 } // end rewrite_cp_refs_in_methods_type_annotations()
2719 
2720 
2721 // Rewrite constant pool references in a type_annotations
2722 // field. This &quot;structure&quot; is adapted from the
2723 // RuntimeVisibleTypeAnnotations_attribute described in
2724 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2725 //
2726 // type_annotations_typeArray {
2727 //   u2              num_annotations;
2728 //   type_annotation annotations[num_annotations];
2729 // }
2730 //
2731 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotations_typeArray(
2732        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2733        const char * location_mesg, TRAPS) {
2734 
2735   if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2736     // not enough room for num_annotations field
2737     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2738     return false;
2739   }
2740 
2741   u2 num_annotations = Bytes::get_Java_u2((address)
2742                          type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2743   byte_i_ref += 2;
2744 
2745   log_debug(redefine, class, annotation)(&quot;num_type_annotations=%d&quot;, num_annotations);
2746 
2747   int calc_num_annotations = 0;
2748   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2749     if (!rewrite_cp_refs_in_type_annotation_struct(type_annotations_typeArray,
2750            byte_i_ref, location_mesg, THREAD)) {
2751       log_debug(redefine, class, annotation)(&quot;bad type_annotation_struct at %d&quot;, calc_num_annotations);
2752       // propagate failure back to caller
2753       return false;
2754     }
2755   }
2756   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2757 
2758   if (byte_i_ref != type_annotations_typeArray-&gt;length()) {
2759     log_debug(redefine, class, annotation)
2760       (&quot;read wrong amount of bytes at end of processing type_annotations_typeArray (%d of %d bytes were read)&quot;,
2761        byte_i_ref, type_annotations_typeArray-&gt;length());
2762     return false;
2763   }
2764 
2765   return true;
2766 } // end rewrite_cp_refs_in_type_annotations_typeArray()
2767 
2768 
2769 // Rewrite constant pool references in a type_annotation
2770 // field. This &quot;structure&quot; is adapted from the
2771 // RuntimeVisibleTypeAnnotations_attribute described in
2772 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2773 //
2774 // type_annotation {
2775 //   u1 target_type;
2776 //   union {
2777 //     type_parameter_target;
2778 //     supertype_target;
2779 //     type_parameter_bound_target;
2780 //     empty_target;
2781 //     method_formal_parameter_target;
2782 //     throws_target;
2783 //     localvar_target;
2784 //     catch_target;
2785 //     offset_target;
2786 //     type_argument_target;
2787 //   } target_info;
2788 //   type_path target_path;
2789 //   annotation anno;
2790 // }
2791 //
2792 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotation_struct(
2793        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2794        const char * location_mesg, TRAPS) {
2795 
2796   if (!skip_type_annotation_target(type_annotations_typeArray,
2797          byte_i_ref, location_mesg, THREAD)) {
2798     return false;
2799   }
2800 
2801   if (!skip_type_annotation_type_path(type_annotations_typeArray,
2802          byte_i_ref, THREAD)) {
2803     return false;
2804   }
2805 
2806   if (!rewrite_cp_refs_in_annotation_struct(type_annotations_typeArray,
2807          byte_i_ref, THREAD)) {
2808     return false;
2809   }
2810 
2811   return true;
2812 } // end rewrite_cp_refs_in_type_annotation_struct()
2813 
2814 
2815 // Read, verify and skip over the target_type and target_info part
2816 // so that rewriting can continue in the later parts of the struct.
2817 //
2818 // u1 target_type;
2819 // union {
2820 //   type_parameter_target;
2821 //   supertype_target;
2822 //   type_parameter_bound_target;
2823 //   empty_target;
2824 //   method_formal_parameter_target;
2825 //   throws_target;
2826 //   localvar_target;
2827 //   catch_target;
2828 //   offset_target;
2829 //   type_argument_target;
2830 // } target_info;
2831 //
2832 bool VM_RedefineClasses::skip_type_annotation_target(
2833        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2834        const char * location_mesg, TRAPS) {
2835 
2836   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2837     // not enough room for a target_type let alone the rest of a type_annotation
2838     log_debug(redefine, class, annotation)(&quot;length() is too small for a target_type&quot;);
2839     return false;
2840   }
2841 
2842   u1 target_type = type_annotations_typeArray-&gt;at(byte_i_ref);
2843   byte_i_ref += 1;
2844   log_debug(redefine, class, annotation)(&quot;target_type=0x%.2x&quot;, target_type);
2845   log_debug(redefine, class, annotation)(&quot;location=%s&quot;, location_mesg);
2846 
2847   // Skip over target_info
2848   switch (target_type) {
2849     case 0x00:
2850     // kind: type parameter declaration of generic class or interface
2851     // location: ClassFile
2852     case 0x01:
2853     // kind: type parameter declaration of generic method or constructor
2854     // location: method_info
2855 
2856     {
2857       // struct:
2858       // type_parameter_target {
2859       //   u1 type_parameter_index;
2860       // }
2861       //
2862       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2863         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_target&quot;);
2864         return false;
2865       }
2866 
2867       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2868       byte_i_ref += 1;
2869 
2870       log_debug(redefine, class, annotation)(&quot;type_parameter_target: type_parameter_index=%d&quot;, type_parameter_index);
2871     } break;
2872 
2873     case 0x10:
2874     // kind: type in extends clause of class or interface declaration
2875     //       (including the direct superclass of an unsafe anonymous class declaration),
2876     //       or in implements clause of interface declaration
2877     // location: ClassFile
2878 
2879     {
2880       // struct:
2881       // supertype_target {
2882       //   u2 supertype_index;
2883       // }
2884       //
2885       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2886         log_debug(redefine, class, annotation)(&quot;length() is too small for a supertype_target&quot;);
2887         return false;
2888       }
2889 
2890       u2 supertype_index = Bytes::get_Java_u2((address)
2891                              type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2892       byte_i_ref += 2;
2893 
2894       log_debug(redefine, class, annotation)(&quot;supertype_target: supertype_index=%d&quot;, supertype_index);
2895     } break;
2896 
2897     case 0x11:
2898     // kind: type in bound of type parameter declaration of generic class or interface
2899     // location: ClassFile
2900     case 0x12:
2901     // kind: type in bound of type parameter declaration of generic method or constructor
2902     // location: method_info
2903 
2904     {
2905       // struct:
2906       // type_parameter_bound_target {
2907       //   u1 type_parameter_index;
2908       //   u1 bound_index;
2909       // }
2910       //
2911       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2912         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_bound_target&quot;);
2913         return false;
2914       }
2915 
2916       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2917       byte_i_ref += 1;
2918       u1 bound_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2919       byte_i_ref += 1;
2920 
2921       log_debug(redefine, class, annotation)
2922         (&quot;type_parameter_bound_target: type_parameter_index=%d, bound_index=%d&quot;, type_parameter_index, bound_index);
2923     } break;
2924 
2925     case 0x13:
2926     // kind: type in field declaration
2927     // location: field_info
2928     case 0x14:
2929     // kind: return type of method, or type of newly constructed object
2930     // location: method_info
2931     case 0x15:
2932     // kind: receiver type of method or constructor
2933     // location: method_info
2934 
2935     {
2936       // struct:
2937       // empty_target {
2938       // }
2939       //
2940       log_debug(redefine, class, annotation)(&quot;empty_target&quot;);
2941     } break;
2942 
2943     case 0x16:
2944     // kind: type in formal parameter declaration of method, constructor, or lambda expression
2945     // location: method_info
2946 
2947     {
2948       // struct:
2949       // formal_parameter_target {
2950       //   u1 formal_parameter_index;
2951       // }
2952       //
2953       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2954         log_debug(redefine, class, annotation)(&quot;length() is too small for a formal_parameter_target&quot;);
2955         return false;
2956       }
2957 
2958       u1 formal_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2959       byte_i_ref += 1;
2960 
2961       log_debug(redefine, class, annotation)
2962         (&quot;formal_parameter_target: formal_parameter_index=%d&quot;, formal_parameter_index);
2963     } break;
2964 
2965     case 0x17:
2966     // kind: type in throws clause of method or constructor
2967     // location: method_info
2968 
2969     {
2970       // struct:
2971       // throws_target {
2972       //   u2 throws_type_index
2973       // }
2974       //
2975       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2976         log_debug(redefine, class, annotation)(&quot;length() is too small for a throws_target&quot;);
2977         return false;
2978       }
2979 
2980       u2 throws_type_index = Bytes::get_Java_u2((address)
2981                                type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2982       byte_i_ref += 2;
2983 
2984       log_debug(redefine, class, annotation)(&quot;throws_target: throws_type_index=%d&quot;, throws_type_index);
2985     } break;
2986 
2987     case 0x40:
2988     // kind: type in local variable declaration
2989     // location: Code
2990     case 0x41:
2991     // kind: type in resource variable declaration
2992     // location: Code
2993 
2994     {
2995       // struct:
2996       // localvar_target {
2997       //   u2 table_length;
2998       //   struct {
2999       //     u2 start_pc;
3000       //     u2 length;
3001       //     u2 index;
3002       //   } table[table_length];
3003       // }
3004       //
3005       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
3006         // not enough room for a table_length let alone the rest of a localvar_target
3007         log_debug(redefine, class, annotation)(&quot;length() is too small for a localvar_target table_length&quot;);
3008         return false;
3009       }
3010 
3011       u2 table_length = Bytes::get_Java_u2((address)
3012                           type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3013       byte_i_ref += 2;
3014 
3015       log_debug(redefine, class, annotation)(&quot;localvar_target: table_length=%d&quot;, table_length);
3016 
3017       int table_struct_size = 2 + 2 + 2; // 3 u2 variables per table entry
3018       int table_size = table_length * table_struct_size;
3019 
3020       if ((byte_i_ref + table_size) &gt; type_annotations_typeArray-&gt;length()) {
3021         // not enough room for a table
3022         log_debug(redefine, class, annotation)(&quot;length() is too small for a table array of length %d&quot;, table_length);
3023         return false;
3024       }
3025 
3026       // Skip over table
3027       byte_i_ref += table_size;
3028     } break;
3029 
3030     case 0x42:
3031     // kind: type in exception parameter declaration
3032     // location: Code
3033 
3034     {
3035       // struct:
3036       // catch_target {
3037       //   u2 exception_table_index;
3038       // }
3039       //
3040       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
3041         log_debug(redefine, class, annotation)(&quot;length() is too small for a catch_target&quot;);
3042         return false;
3043       }
3044 
3045       u2 exception_table_index = Bytes::get_Java_u2((address)
3046                                    type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3047       byte_i_ref += 2;
3048 
3049       log_debug(redefine, class, annotation)(&quot;catch_target: exception_table_index=%d&quot;, exception_table_index);
3050     } break;
3051 
3052     case 0x43:
3053     // kind: type in instanceof expression
3054     // location: Code
3055     case 0x44:
3056     // kind: type in new expression
3057     // location: Code
3058     case 0x45:
3059     // kind: type in method reference expression using ::new
3060     // location: Code
3061     case 0x46:
3062     // kind: type in method reference expression using ::Identifier
3063     // location: Code
3064 
3065     {
3066       // struct:
3067       // offset_target {
3068       //   u2 offset;
3069       // }
3070       //
3071       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
3072         log_debug(redefine, class, annotation)(&quot;length() is too small for a offset_target&quot;);
3073         return false;
3074       }
3075 
3076       u2 offset = Bytes::get_Java_u2((address)
3077                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3078       byte_i_ref += 2;
3079 
3080       log_debug(redefine, class, annotation)(&quot;offset_target: offset=%d&quot;, offset);
3081     } break;
3082 
3083     case 0x47:
3084     // kind: type in cast expression
3085     // location: Code
3086     case 0x48:
3087     // kind: type argument for generic constructor in new expression or
3088     //       explicit constructor invocation statement
3089     // location: Code
3090     case 0x49:
3091     // kind: type argument for generic method in method invocation expression
3092     // location: Code
3093     case 0x4A:
3094     // kind: type argument for generic constructor in method reference expression using ::new
3095     // location: Code
3096     case 0x4B:
3097     // kind: type argument for generic method in method reference expression using ::Identifier
3098     // location: Code
3099 
3100     {
3101       // struct:
3102       // type_argument_target {
3103       //   u2 offset;
3104       //   u1 type_argument_index;
3105       // }
3106       //
3107       if ((byte_i_ref + 3) &gt; type_annotations_typeArray-&gt;length()) {
3108         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_argument_target&quot;);
3109         return false;
3110       }
3111 
3112       u2 offset = Bytes::get_Java_u2((address)
3113                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3114       byte_i_ref += 2;
3115       u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3116       byte_i_ref += 1;
3117 
3118       log_debug(redefine, class, annotation)
3119         (&quot;type_argument_target: offset=%d, type_argument_index=%d&quot;, offset, type_argument_index);
3120     } break;
3121 
3122     default:
3123       log_debug(redefine, class, annotation)(&quot;unknown target_type&quot;);
3124 #ifdef ASSERT
3125       ShouldNotReachHere();
3126 #endif
3127       return false;
3128   }
3129 
3130   return true;
3131 } // end skip_type_annotation_target()
3132 
3133 
3134 // Read, verify and skip over the type_path part so that rewriting
3135 // can continue in the later parts of the struct.
3136 //
3137 // type_path {
3138 //   u1 path_length;
3139 //   {
3140 //     u1 type_path_kind;
3141 //     u1 type_argument_index;
3142 //   } path[path_length];
3143 // }
3144 //
3145 bool VM_RedefineClasses::skip_type_annotation_type_path(
3146        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
3147 
3148   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
3149     // not enough room for a path_length let alone the rest of the type_path
3150     log_debug(redefine, class, annotation)(&quot;length() is too small for a type_path&quot;);
3151     return false;
3152   }
3153 
3154   u1 path_length = type_annotations_typeArray-&gt;at(byte_i_ref);
3155   byte_i_ref += 1;
3156 
3157   log_debug(redefine, class, annotation)(&quot;type_path: path_length=%d&quot;, path_length);
3158 
3159   int calc_path_length = 0;
3160   for (; calc_path_length &lt; path_length; calc_path_length++) {
3161     if ((byte_i_ref + 1 + 1) &gt; type_annotations_typeArray-&gt;length()) {
3162       // not enough room for a path
3163       log_debug(redefine, class, annotation)
3164         (&quot;length() is too small for path entry %d of %d&quot;, calc_path_length, path_length);
3165       return false;
3166     }
3167 
3168     u1 type_path_kind = type_annotations_typeArray-&gt;at(byte_i_ref);
3169     byte_i_ref += 1;
3170     u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3171     byte_i_ref += 1;
3172 
3173     log_debug(redefine, class, annotation)
3174       (&quot;type_path: path[%d]: type_path_kind=%d, type_argument_index=%d&quot;,
3175        calc_path_length, type_path_kind, type_argument_index);
3176 
3177     if (type_path_kind &gt; 3 || (type_path_kind != 3 &amp;&amp; type_argument_index != 0)) {
3178       // not enough room for a path
3179       log_debug(redefine, class, annotation)(&quot;inconsistent type_path values&quot;);
3180       return false;
3181     }
3182   }
3183   assert(path_length == calc_path_length, &quot;sanity check&quot;);
3184 
3185   return true;
3186 } // end skip_type_annotation_type_path()
3187 
3188 
3189 // Rewrite constant pool references in the method&#39;s stackmap table.
3190 // These &quot;structures&quot; are adapted from the StackMapTable_attribute that
3191 // is described in section 4.8.4 of the 6.0 version of the VM spec
3192 // (dated 2005.10.26):
3193 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3194 //
3195 // stack_map {
3196 //   u2 number_of_entries;
3197 //   stack_map_frame entries[number_of_entries];
3198 // }
3199 //
3200 void VM_RedefineClasses::rewrite_cp_refs_in_stack_map_table(
3201        const methodHandle&amp; method, TRAPS) {
3202 
3203   if (!method-&gt;has_stackmap_table()) {
3204     return;
3205   }
3206 
3207   AnnotationArray* stackmap_data = method-&gt;stackmap_data();
3208   address stackmap_p = (address)stackmap_data-&gt;adr_at(0);
3209   address stackmap_end = stackmap_p + stackmap_data-&gt;length();
3210 
3211   assert(stackmap_p + 2 &lt;= stackmap_end, &quot;no room for number_of_entries&quot;);
3212   u2 number_of_entries = Bytes::get_Java_u2(stackmap_p);
3213   stackmap_p += 2;
3214 
3215   log_debug(redefine, class, stackmap)(&quot;number_of_entries=%u&quot;, number_of_entries);
3216 
3217   // walk through each stack_map_frame
3218   u2 calc_number_of_entries = 0;
3219   for (; calc_number_of_entries &lt; number_of_entries; calc_number_of_entries++) {
3220     // The stack_map_frame structure is a u1 frame_type followed by
3221     // 0 or more bytes of data:
3222     //
3223     // union stack_map_frame {
3224     //   same_frame;
3225     //   same_locals_1_stack_item_frame;
3226     //   same_locals_1_stack_item_frame_extended;
3227     //   chop_frame;
3228     //   same_frame_extended;
3229     //   append_frame;
3230     //   full_frame;
3231     // }
3232 
3233     assert(stackmap_p + 1 &lt;= stackmap_end, &quot;no room for frame_type&quot;);
3234     u1 frame_type = *stackmap_p;
3235     stackmap_p++;
3236 
3237     // same_frame {
3238     //   u1 frame_type = SAME; /* 0-63 */
3239     // }
3240     if (frame_type &lt;= 63) {
3241       // nothing more to do for same_frame
3242     }
3243 
3244     // same_locals_1_stack_item_frame {
3245     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM; /* 64-127 */
3246     //   verification_type_info stack[1];
3247     // }
3248     else if (frame_type &gt;= 64 &amp;&amp; frame_type &lt;= 127) {
3249       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3250         calc_number_of_entries, frame_type, THREAD);
3251     }
3252 
3253     // reserved for future use
3254     else if (frame_type &gt;= 128 &amp;&amp; frame_type &lt;= 246) {
3255       // nothing more to do for reserved frame_types
3256     }
3257 
3258     // same_locals_1_stack_item_frame_extended {
3259     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED; /* 247 */
3260     //   u2 offset_delta;
3261     //   verification_type_info stack[1];
3262     // }
3263     else if (frame_type == 247) {
3264       stackmap_p += 2;
3265       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3266         calc_number_of_entries, frame_type, THREAD);
3267     }
3268 
3269     // chop_frame {
3270     //   u1 frame_type = CHOP; /* 248-250 */
3271     //   u2 offset_delta;
3272     // }
3273     else if (frame_type &gt;= 248 &amp;&amp; frame_type &lt;= 250) {
3274       stackmap_p += 2;
3275     }
3276 
3277     // same_frame_extended {
3278     //   u1 frame_type = SAME_FRAME_EXTENDED; /* 251*/
3279     //   u2 offset_delta;
3280     // }
3281     else if (frame_type == 251) {
3282       stackmap_p += 2;
3283     }
3284 
3285     // append_frame {
3286     //   u1 frame_type = APPEND; /* 252-254 */
3287     //   u2 offset_delta;
3288     //   verification_type_info locals[frame_type - 251];
3289     // }
3290     else if (frame_type &gt;= 252 &amp;&amp; frame_type &lt;= 254) {
3291       assert(stackmap_p + 2 &lt;= stackmap_end,
3292         &quot;no room for offset_delta&quot;);
3293       stackmap_p += 2;
3294       u1 len = frame_type - 251;
3295       for (u1 i = 0; i &lt; len; i++) {
3296         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3297           calc_number_of_entries, frame_type, THREAD);
3298       }
3299     }
3300 
3301     // full_frame {
3302     //   u1 frame_type = FULL_FRAME; /* 255 */
3303     //   u2 offset_delta;
3304     //   u2 number_of_locals;
3305     //   verification_type_info locals[number_of_locals];
3306     //   u2 number_of_stack_items;
3307     //   verification_type_info stack[number_of_stack_items];
3308     // }
3309     else if (frame_type == 255) {
3310       assert(stackmap_p + 2 + 2 &lt;= stackmap_end,
3311         &quot;no room for smallest full_frame&quot;);
3312       stackmap_p += 2;
3313 
3314       u2 number_of_locals = Bytes::get_Java_u2(stackmap_p);
3315       stackmap_p += 2;
3316 
3317       for (u2 locals_i = 0; locals_i &lt; number_of_locals; locals_i++) {
3318         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3319           calc_number_of_entries, frame_type, THREAD);
3320       }
3321 
3322       // Use the largest size for the number_of_stack_items, but only get
3323       // the right number of bytes.
3324       u2 number_of_stack_items = Bytes::get_Java_u2(stackmap_p);
3325       stackmap_p += 2;
3326 
3327       for (u2 stack_i = 0; stack_i &lt; number_of_stack_items; stack_i++) {
3328         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3329           calc_number_of_entries, frame_type, THREAD);
3330       }
3331     }
3332   } // end while there is a stack_map_frame
3333   assert(number_of_entries == calc_number_of_entries, &quot;sanity check&quot;);
3334 } // end rewrite_cp_refs_in_stack_map_table()
3335 
3336 
3337 // Rewrite constant pool references in the verification type info
3338 // portion of the method&#39;s stackmap table. These &quot;structures&quot; are
3339 // adapted from the StackMapTable_attribute that is described in
3340 // section 4.8.4 of the 6.0 version of the VM spec (dated 2005.10.26):
3341 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3342 //
3343 // The verification_type_info structure is a u1 tag followed by 0 or
3344 // more bytes of data:
3345 //
3346 // union verification_type_info {
3347 //   Top_variable_info;
3348 //   Integer_variable_info;
3349 //   Float_variable_info;
3350 //   Long_variable_info;
3351 //   Double_variable_info;
3352 //   Null_variable_info;
3353 //   UninitializedThis_variable_info;
3354 //   Object_variable_info;
3355 //   Uninitialized_variable_info;
3356 // }
3357 //
3358 void VM_RedefineClasses::rewrite_cp_refs_in_verification_type_info(
3359        address&amp; stackmap_p_ref, address stackmap_end, u2 frame_i,
3360        u1 frame_type, TRAPS) {
3361 
3362   assert(stackmap_p_ref + 1 &lt;= stackmap_end, &quot;no room for tag&quot;);
3363   u1 tag = *stackmap_p_ref;
3364   stackmap_p_ref++;
3365 
3366   switch (tag) {
3367   // Top_variable_info {
3368   //   u1 tag = ITEM_Top; /* 0 */
3369   // }
3370   // verificationType.hpp has zero as ITEM_Bogus instead of ITEM_Top
3371   case 0:  // fall through
3372 
3373   // Integer_variable_info {
3374   //   u1 tag = ITEM_Integer; /* 1 */
3375   // }
3376   case ITEM_Integer:  // fall through
3377 
3378   // Float_variable_info {
3379   //   u1 tag = ITEM_Float; /* 2 */
3380   // }
3381   case ITEM_Float:  // fall through
3382 
3383   // Double_variable_info {
3384   //   u1 tag = ITEM_Double; /* 3 */
3385   // }
3386   case ITEM_Double:  // fall through
3387 
3388   // Long_variable_info {
3389   //   u1 tag = ITEM_Long; /* 4 */
3390   // }
3391   case ITEM_Long:  // fall through
3392 
3393   // Null_variable_info {
3394   //   u1 tag = ITEM_Null; /* 5 */
3395   // }
3396   case ITEM_Null:  // fall through
3397 
3398   // UninitializedThis_variable_info {
3399   //   u1 tag = ITEM_UninitializedThis; /* 6 */
3400   // }
3401   case ITEM_UninitializedThis:
3402     // nothing more to do for the above tag types
3403     break;
3404 
3405   // Object_variable_info {
3406   //   u1 tag = ITEM_Object; /* 7 */
3407   //   u2 cpool_index;
3408   // }
3409   case ITEM_Object:
3410   {
3411     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for cpool_index&quot;);
3412     u2 cpool_index = Bytes::get_Java_u2(stackmap_p_ref);
3413     u2 new_cp_index = find_new_index(cpool_index);
3414     if (new_cp_index != 0) {
3415       log_debug(redefine, class, stackmap)(&quot;mapped old cpool_index=%d&quot;, cpool_index);
3416       Bytes::put_Java_u2(stackmap_p_ref, new_cp_index);
3417       cpool_index = new_cp_index;
3418     }
3419     stackmap_p_ref += 2;
3420 
3421     log_debug(redefine, class, stackmap)
3422       (&quot;frame_i=%u, frame_type=%u, cpool_index=%d&quot;, frame_i, frame_type, cpool_index);
3423   } break;
3424 
3425   // Uninitialized_variable_info {
3426   //   u1 tag = ITEM_Uninitialized; /* 8 */
3427   //   u2 offset;
3428   // }
3429   case ITEM_Uninitialized:
3430     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for offset&quot;);
3431     stackmap_p_ref += 2;
3432     break;
3433 
3434   default:
3435     log_debug(redefine, class, stackmap)(&quot;frame_i=%u, frame_type=%u, bad tag=0x%x&quot;, frame_i, frame_type, tag);
3436     ShouldNotReachHere();
3437     break;
3438   } // end switch (tag)
3439 } // end rewrite_cp_refs_in_verification_type_info()
3440 
3441 
3442 // Change the constant pool associated with klass scratch_class to
3443 // scratch_cp. If shrink is true, then scratch_cp_length elements
3444 // are copied from scratch_cp to a smaller constant pool and the
3445 // smaller constant pool is associated with scratch_class.
3446 void VM_RedefineClasses::set_new_constant_pool(
3447        ClassLoaderData* loader_data,
3448        InstanceKlass* scratch_class, constantPoolHandle scratch_cp,
3449        int scratch_cp_length, TRAPS) {
3450   assert(scratch_cp-&gt;length() &gt;= scratch_cp_length, &quot;sanity check&quot;);
3451 
3452   // scratch_cp is a merged constant pool and has enough space for a
3453   // worst case merge situation. We want to associate the minimum
3454   // sized constant pool with the klass to save space.
3455   ConstantPool* cp = ConstantPool::allocate(loader_data, scratch_cp_length, CHECK);
3456   constantPoolHandle smaller_cp(THREAD, cp);
3457 
3458   // preserve version() value in the smaller copy
3459   int version = scratch_cp-&gt;version();
3460   assert(version != 0, &quot;sanity check&quot;);
3461   smaller_cp-&gt;set_version(version);
3462 
3463   // attach klass to new constant pool
3464   // reference to the cp holder is needed for copy_operands()
3465   smaller_cp-&gt;set_pool_holder(scratch_class);
3466 
3467   smaller_cp-&gt;copy_fields(scratch_cp());
3468 
3469   scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
3470   if (HAS_PENDING_EXCEPTION) {
3471     // Exception is handled in the caller
3472     loader_data-&gt;add_to_deallocate_list(smaller_cp());
3473     return;
3474   }
3475   scratch_cp = smaller_cp;
3476 
3477   // attach new constant pool to klass
3478   scratch_class-&gt;set_constants(scratch_cp());
3479   scratch_cp-&gt;initialize_unresolved_klasses(loader_data, CHECK);
3480 
3481   int i;  // for portability
3482 
3483   // update each field in klass to use new constant pool indices as needed
3484   for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {
3485     jshort cur_index = fs.name_index();
3486     jshort new_index = find_new_index(cur_index);
3487     if (new_index != 0) {
3488       log_trace(redefine, class, constantpool)(&quot;field-name_index change: %d to %d&quot;, cur_index, new_index);
3489       fs.set_name_index(new_index);
3490     }
3491     cur_index = fs.signature_index();
3492     new_index = find_new_index(cur_index);
3493     if (new_index != 0) {
3494       log_trace(redefine, class, constantpool)(&quot;field-signature_index change: %d to %d&quot;, cur_index, new_index);
3495       fs.set_signature_index(new_index);
3496     }
3497     cur_index = fs.initval_index();
3498     new_index = find_new_index(cur_index);
3499     if (new_index != 0) {
3500       log_trace(redefine, class, constantpool)(&quot;field-initval_index change: %d to %d&quot;, cur_index, new_index);
3501       fs.set_initval_index(new_index);
3502     }
3503     cur_index = fs.generic_signature_index();
3504     new_index = find_new_index(cur_index);
3505     if (new_index != 0) {
3506       log_trace(redefine, class, constantpool)(&quot;field-generic_signature change: %d to %d&quot;, cur_index, new_index);
3507       fs.set_generic_signature_index(new_index);
3508     }
3509   } // end for each field
3510 
3511   // Update constant pool indices in the inner classes info to use
3512   // new constant indices as needed. The inner classes info is a
3513   // quadruple:
3514   // (inner_class_info, outer_class_info, inner_name, inner_access_flags)
3515   InnerClassesIterator iter(scratch_class);
3516   for (; !iter.done(); iter.next()) {
3517     int cur_index = iter.inner_class_info_index();
3518     if (cur_index == 0) {
3519       continue;  // JVM spec. allows null inner class refs so skip it
3520     }
3521     int new_index = find_new_index(cur_index);
3522     if (new_index != 0) {
3523       log_trace(redefine, class, constantpool)(&quot;inner_class_info change: %d to %d&quot;, cur_index, new_index);
3524       iter.set_inner_class_info_index(new_index);
3525     }
3526     cur_index = iter.outer_class_info_index();
3527     new_index = find_new_index(cur_index);
3528     if (new_index != 0) {
3529       log_trace(redefine, class, constantpool)(&quot;outer_class_info change: %d to %d&quot;, cur_index, new_index);
3530       iter.set_outer_class_info_index(new_index);
3531     }
3532     cur_index = iter.inner_name_index();
3533     new_index = find_new_index(cur_index);
3534     if (new_index != 0) {
3535       log_trace(redefine, class, constantpool)(&quot;inner_name change: %d to %d&quot;, cur_index, new_index);
3536       iter.set_inner_name_index(new_index);
3537     }
3538   } // end for each inner class
3539 
3540   // Attach each method in klass to the new constant pool and update
3541   // to use new constant pool indices as needed:
3542   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
3543   for (i = methods-&gt;length() - 1; i &gt;= 0; i--) {
3544     methodHandle method(THREAD, methods-&gt;at(i));
3545     method-&gt;set_constants(scratch_cp());
3546 
3547     int new_index = find_new_index(method-&gt;name_index());
3548     if (new_index != 0) {
3549       log_trace(redefine, class, constantpool)
3550         (&quot;method-name_index change: %d to %d&quot;, method-&gt;name_index(), new_index);
3551       method-&gt;set_name_index(new_index);
3552     }
3553     new_index = find_new_index(method-&gt;signature_index());
3554     if (new_index != 0) {
3555       log_trace(redefine, class, constantpool)
3556         (&quot;method-signature_index change: %d to %d&quot;, method-&gt;signature_index(), new_index);
3557       method-&gt;set_signature_index(new_index);
3558     }
3559     new_index = find_new_index(method-&gt;generic_signature_index());
3560     if (new_index != 0) {
3561       log_trace(redefine, class, constantpool)
3562         (&quot;method-generic_signature_index change: %d to %d&quot;, method-&gt;generic_signature_index(), new_index);
3563       method-&gt;set_generic_signature_index(new_index);
3564     }
3565 
3566     // Update constant pool indices in the method&#39;s checked exception
3567     // table to use new constant indices as needed.
3568     int cext_length = method-&gt;checked_exceptions_length();
3569     if (cext_length &gt; 0) {
3570       CheckedExceptionElement * cext_table =
3571         method-&gt;checked_exceptions_start();
3572       for (int j = 0; j &lt; cext_length; j++) {
3573         int cur_index = cext_table[j].class_cp_index;
3574         int new_index = find_new_index(cur_index);
3575         if (new_index != 0) {
3576           log_trace(redefine, class, constantpool)(&quot;cext-class_cp_index change: %d to %d&quot;, cur_index, new_index);
3577           cext_table[j].class_cp_index = (u2)new_index;
3578         }
3579       } // end for each checked exception table entry
3580     } // end if there are checked exception table entries
3581 
3582     // Update each catch type index in the method&#39;s exception table
3583     // to use new constant pool indices as needed. The exception table
3584     // holds quadruple entries of the form:
3585     //   (beg_bci, end_bci, handler_bci, klass_index)
3586 
3587     ExceptionTable ex_table(method());
3588     int ext_length = ex_table.length();
3589 
3590     for (int j = 0; j &lt; ext_length; j ++) {
3591       int cur_index = ex_table.catch_type_index(j);
3592       int new_index = find_new_index(cur_index);
3593       if (new_index != 0) {
3594         log_trace(redefine, class, constantpool)(&quot;ext-klass_index change: %d to %d&quot;, cur_index, new_index);
3595         ex_table.set_catch_type_index(j, new_index);
3596       }
3597     } // end for each exception table entry
3598 
3599     // Update constant pool indices in the method&#39;s local variable
3600     // table to use new constant indices as needed. The local variable
3601     // table hold sextuple entries of the form:
3602     // (start_pc, length, name_index, descriptor_index, signature_index, slot)
3603     int lvt_length = method-&gt;localvariable_table_length();
3604     if (lvt_length &gt; 0) {
3605       LocalVariableTableElement * lv_table =
3606         method-&gt;localvariable_table_start();
3607       for (int j = 0; j &lt; lvt_length; j++) {
3608         int cur_index = lv_table[j].name_cp_index;
3609         int new_index = find_new_index(cur_index);
3610         if (new_index != 0) {
3611           log_trace(redefine, class, constantpool)(&quot;lvt-name_cp_index change: %d to %d&quot;, cur_index, new_index);
3612           lv_table[j].name_cp_index = (u2)new_index;
3613         }
3614         cur_index = lv_table[j].descriptor_cp_index;
3615         new_index = find_new_index(cur_index);
3616         if (new_index != 0) {
3617           log_trace(redefine, class, constantpool)(&quot;lvt-descriptor_cp_index change: %d to %d&quot;, cur_index, new_index);
3618           lv_table[j].descriptor_cp_index = (u2)new_index;
3619         }
3620         cur_index = lv_table[j].signature_cp_index;
3621         new_index = find_new_index(cur_index);
3622         if (new_index != 0) {
3623           log_trace(redefine, class, constantpool)(&quot;lvt-signature_cp_index change: %d to %d&quot;, cur_index, new_index);
3624           lv_table[j].signature_cp_index = (u2)new_index;
3625         }
3626       } // end for each local variable table entry
3627     } // end if there are local variable table entries
3628 
3629     rewrite_cp_refs_in_stack_map_table(method, THREAD);
3630   } // end for each method
3631 } // end set_new_constant_pool()
3632 
3633 
3634 // Unevolving classes may point to methods of the_class directly
3635 // from their constant pool caches, itables, and/or vtables. We
3636 // use the ClassLoaderDataGraph::classes_do() facility and this helper
3637 // to fix up these pointers.  MethodData also points to old methods and
3638 // must be cleaned.
3639 
3640 // Adjust cpools and vtables closure
3641 void VM_RedefineClasses::AdjustAndCleanMetadata::do_klass(Klass* k) {
3642 
3643   // This is a very busy routine. We don&#39;t want too much tracing
3644   // printed out.
3645   bool trace_name_printed = false;
3646 
3647   // If the class being redefined is java.lang.Object, we need to fix all
3648   // array class vtables also. The _has_redefined_Object flag is global.
3649   // Once the java.lang.Object has been redefined (by the current or one
3650   // of the previous VM_RedefineClasses operations) we have to always
3651   // adjust method entries for array classes.
3652   if (k-&gt;is_array_klass() &amp;&amp; _has_redefined_Object) {
3653     k-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3654 
3655   } else if (k-&gt;is_instance_klass()) {
3656     HandleMark hm(_thread);
3657     InstanceKlass *ik = InstanceKlass::cast(k);
3658 
3659     // Clean MethodData of this class&#39;s methods so they don&#39;t refer to
3660     // old methods that are no longer running.
3661     Array&lt;Method*&gt;* methods = ik-&gt;methods();
3662     int num_methods = methods-&gt;length();
3663     for (int index = 0; index &lt; num_methods; ++index) {
3664       if (methods-&gt;at(index)-&gt;method_data() != NULL) {
3665         methods-&gt;at(index)-&gt;method_data()-&gt;clean_weak_method_links();
3666       }
3667     }
3668 
3669     // Adjust all vtables, default methods and itables, to clean out old methods.
3670     ResourceMark rm(_thread);
3671     if (ik-&gt;vtable_length() &gt; 0) {
3672       ik-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3673       ik-&gt;adjust_default_methods(&amp;trace_name_printed);
3674     }
3675 
3676     if (ik-&gt;itable_length() &gt; 0) {
3677       ik-&gt;itable().adjust_method_entries(&amp;trace_name_printed);
3678     }
3679 
3680     // The constant pools in other classes (other_cp) can refer to
3681     // old methods.  We have to update method information in
3682     // other_cp&#39;s cache. If other_cp has a previous version, then we
3683     // have to repeat the process for each previous version. The
3684     // constant pool cache holds the Method*s for non-virtual
3685     // methods and for virtual, final methods.
3686     //
3687     // Special case: if the current class is being redefined by the current
3688     // VM_RedefineClasses operation, then new_cp has already been attached
3689     // to the_class and old_cp has already been added as a previous version.
3690     // The new_cp doesn&#39;t have any cached references to old methods so it
3691     // doesn&#39;t need to be updated and we could optimize by skipping it.
3692     // However, the current class can be marked as being redefined by another
3693     // VM_RedefineClasses operation which has already executed its doit_prologue
3694     // and needs cpcache method entries adjusted. For simplicity, the cpcache
3695     // update is done unconditionally. It should result in doing nothing for
3696     // classes being redefined by the current VM_RedefineClasses operation.
3697     // Method entries in the previous version(s) are adjusted as well.
3698     ConstantPoolCache* cp_cache;
3699 
3700     // this klass&#39; constant pool cache may need adjustment
3701     ConstantPool* other_cp = ik-&gt;constants();
3702     cp_cache = other_cp-&gt;cache();
3703     if (cp_cache != NULL) {
3704       cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3705     }
3706 
3707     // the previous versions&#39; constant pool caches may need adjustment
3708     for (InstanceKlass* pv_node = ik-&gt;previous_versions();
3709          pv_node != NULL;
3710          pv_node = pv_node-&gt;previous_versions()) {
3711       cp_cache = pv_node-&gt;constants()-&gt;cache();
3712       if (cp_cache != NULL) {
3713         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3714       }
3715     }
3716   }
3717 }
3718 
3719 void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {
3720   for (int j = 0; j &lt; _matching_methods_length; ++j) {
3721     Method* old_method = _matching_old_methods[j];
3722     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
3723     if (jmid != NULL) {
3724       // There is a jmethodID, change it to point to the new method
3725       methodHandle new_method_h(thread, _matching_new_methods[j]);
3726       Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
3727       assert(Method::resolve_jmethod_id(jmid) == _matching_new_methods[j],
3728              &quot;should be replaced&quot;);
3729     }
3730   }
3731 }
3732 
3733 int VM_RedefineClasses::check_methods_and_mark_as_obsolete() {
3734   int emcp_method_count = 0;
3735   int obsolete_count = 0;
3736   int old_index = 0;
3737   for (int j = 0; j &lt; _matching_methods_length; ++j, ++old_index) {
3738     Method* old_method = _matching_old_methods[j];
3739     Method* new_method = _matching_new_methods[j];
3740     Method* old_array_method;
3741 
3742     // Maintain an old_index into the _old_methods array by skipping
3743     // deleted methods
3744     while ((old_array_method = _old_methods-&gt;at(old_index)) != old_method) {
3745       ++old_index;
3746     }
3747 
3748     if (MethodComparator::methods_EMCP(old_method, new_method)) {
3749       // The EMCP definition from JSR-163 requires the bytecodes to be
3750       // the same with the exception of constant pool indices which may
3751       // differ. However, the constants referred to by those indices
3752       // must be the same.
3753       //
3754       // We use methods_EMCP() for comparison since constant pool
3755       // merging can remove duplicate constant pool entries that were
3756       // present in the old method and removed from the rewritten new
3757       // method. A faster binary comparison function would consider the
3758       // old and new methods to be different when they are actually
3759       // EMCP.
3760       //
3761       // The old and new methods are EMCP and you would think that we
3762       // could get rid of one of them here and now and save some space.
3763       // However, the concept of EMCP only considers the bytecodes and
3764       // the constant pool entries in the comparison. Other things,
3765       // e.g., the line number table (LNT) or the local variable table
3766       // (LVT) don&#39;t count in the comparison. So the new (and EMCP)
3767       // method can have a new LNT that we need so we can&#39;t just
3768       // overwrite the new method with the old method.
3769       //
3770       // When this routine is called, we have already attached the new
3771       // methods to the_class so the old methods are effectively
3772       // overwritten. However, if an old method is still executing,
3773       // then the old method cannot be collected until sometime after
3774       // the old method call has returned. So the overwriting of old
3775       // methods by new methods will save us space except for those
3776       // (hopefully few) old methods that are still executing.
3777       //
3778       // A method refers to a ConstMethod* and this presents another
3779       // possible avenue to space savings. The ConstMethod* in the
3780       // new method contains possibly new attributes (LNT, LVT, etc).
3781       // At first glance, it seems possible to save space by replacing
3782       // the ConstMethod* in the old method with the ConstMethod*
3783       // from the new method. The old and new methods would share the
3784       // same ConstMethod* and we would save the space occupied by
3785       // the old ConstMethod*. However, the ConstMethod* contains
3786       // a back reference to the containing method. Sharing the
3787       // ConstMethod* between two methods could lead to confusion in
3788       // the code that uses the back reference. This would lead to
3789       // brittle code that could be broken in non-obvious ways now or
3790       // in the future.
3791       //
3792       // Another possibility is to copy the ConstMethod* from the new
3793       // method to the old method and then overwrite the new method with
3794       // the old method. Since the ConstMethod* contains the bytecodes
3795       // for the method embedded in the oop, this option would change
3796       // the bytecodes out from under any threads executing the old
3797       // method and make the thread&#39;s bcp invalid. Since EMCP requires
3798       // that the bytecodes be the same modulo constant pool indices, it
3799       // is straight forward to compute the correct new bcp in the new
3800       // ConstMethod* from the old bcp in the old ConstMethod*. The
3801       // time consuming part would be searching all the frames in all
3802       // of the threads to find all of the calls to the old method.
3803       //
3804       // It looks like we will have to live with the limited savings
3805       // that we get from effectively overwriting the old methods
3806       // when the new methods are attached to the_class.
3807 
3808       // Count number of methods that are EMCP.  The method will be marked
3809       // old but not obsolete if it is EMCP.
3810       emcp_method_count++;
3811 
3812       // An EMCP method is _not_ obsolete. An obsolete method has a
3813       // different jmethodID than the current method. An EMCP method
3814       // has the same jmethodID as the current method. Having the
3815       // same jmethodID for all EMCP versions of a method allows for
3816       // a consistent view of the EMCP methods regardless of which
3817       // EMCP method you happen to have in hand. For example, a
3818       // breakpoint set in one EMCP method will work for all EMCP
3819       // versions of the method including the current one.
3820     } else {
3821       // mark obsolete methods as such
3822       old_method-&gt;set_is_obsolete();
3823       obsolete_count++;
3824 
3825       // obsolete methods need a unique idnum so they become new entries in
3826       // the jmethodID cache in InstanceKlass
3827       assert(old_method-&gt;method_idnum() == new_method-&gt;method_idnum(), &quot;must match&quot;);
3828       u2 num = InstanceKlass::cast(_the_class)-&gt;next_method_idnum();
3829       if (num != ConstMethod::UNSET_IDNUM) {
3830         old_method-&gt;set_method_idnum(num);
3831       }
3832 
3833       // With tracing we try not to &quot;yack&quot; too much. The position of
3834       // this trace assumes there are fewer obsolete methods than
3835       // EMCP methods.
3836       if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3837         ResourceMark rm;
3838         log_trace(redefine, class, obsolete, mark)
3839           (&quot;mark %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3840       }
3841     }
3842     old_method-&gt;set_is_old();
3843   }
3844   for (int i = 0; i &lt; _deleted_methods_length; ++i) {
3845     Method* old_method = _deleted_methods[i];
3846 
3847     assert(!old_method-&gt;has_vtable_index(),
3848            &quot;cannot delete methods with vtable entries&quot;);;
3849 
3850     // Mark all deleted methods as old, obsolete and deleted
3851     old_method-&gt;set_is_deleted();
3852     old_method-&gt;set_is_old();
3853     old_method-&gt;set_is_obsolete();
3854     ++obsolete_count;
3855     // With tracing we try not to &quot;yack&quot; too much. The position of
3856     // this trace assumes there are fewer obsolete methods than
3857     // EMCP methods.
3858     if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3859       ResourceMark rm;
3860       log_trace(redefine, class, obsolete, mark)
3861         (&quot;mark deleted %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3862     }
3863   }
3864   assert((emcp_method_count + obsolete_count) == _old_methods-&gt;length(),
3865     &quot;sanity check&quot;);
3866   log_trace(redefine, class, obsolete, mark)(&quot;EMCP_cnt=%d, obsolete_cnt=%d&quot;, emcp_method_count, obsolete_count);
3867   return emcp_method_count;
3868 }
3869 
3870 // This internal class transfers the native function registration from old methods
3871 // to new methods.  It is designed to handle both the simple case of unchanged
3872 // native methods and the complex cases of native method prefixes being added and/or
3873 // removed.
3874 // It expects only to be used during the VM_RedefineClasses op (a safepoint).
3875 //
3876 // This class is used after the new methods have been installed in &quot;the_class&quot;.
3877 //
3878 // So, for example, the following must be handled.  Where &#39;m&#39; is a method and
3879 // a number followed by an underscore is a prefix.
3880 //
3881 //                                      Old Name    New Name
3882 // Simple transfer to new method        m       -&gt;  m
3883 // Add prefix                           m       -&gt;  1_m
3884 // Remove prefix                        1_m     -&gt;  m
3885 // Simultaneous add of prefixes         m       -&gt;  3_2_1_m
3886 // Simultaneous removal of prefixes     3_2_1_m -&gt;  m
3887 // Simultaneous add and remove          1_m     -&gt;  2_m
3888 // Same, caused by prefix removal only  3_2_1_m -&gt;  3_2_m
3889 //
3890 class TransferNativeFunctionRegistration {
3891  private:
3892   InstanceKlass* the_class;
3893   int prefix_count;
3894   char** prefixes;
3895 
3896   // Recursively search the binary tree of possibly prefixed method names.
3897   // Iteration could be used if all agents were well behaved. Full tree walk is
3898   // more resilent to agents not cleaning up intermediate methods.
3899   // Branch at each depth in the binary tree is:
3900   //    (1) without the prefix.
3901   //    (2) with the prefix.
3902   // where &#39;prefix&#39; is the prefix at that &#39;depth&#39; (first prefix, second prefix,...)
3903   Method* search_prefix_name_space(int depth, char* name_str, size_t name_len,
3904                                      Symbol* signature) {
3905     TempNewSymbol name_symbol = SymbolTable::probe(name_str, (int)name_len);
3906     if (name_symbol != NULL) {
3907       Method* method = the_class-&gt;lookup_method(name_symbol, signature);
3908       if (method != NULL) {
3909         // Even if prefixed, intermediate methods must exist.
3910         if (method-&gt;is_native()) {
3911           // Wahoo, we found a (possibly prefixed) version of the method, return it.
3912           return method;
3913         }
3914         if (depth &lt; prefix_count) {
3915           // Try applying further prefixes (other than this one).
3916           method = search_prefix_name_space(depth+1, name_str, name_len, signature);
3917           if (method != NULL) {
3918             return method; // found
3919           }
3920 
3921           // Try adding this prefix to the method name and see if it matches
3922           // another method name.
3923           char* prefix = prefixes[depth];
3924           size_t prefix_len = strlen(prefix);
3925           size_t trial_len = name_len + prefix_len;
3926           char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);
3927           strcpy(trial_name_str, prefix);
3928           strcat(trial_name_str, name_str);
3929           method = search_prefix_name_space(depth+1, trial_name_str, trial_len,
3930                                             signature);
3931           if (method != NULL) {
3932             // If found along this branch, it was prefixed, mark as such
3933             method-&gt;set_is_prefixed_native();
3934             return method; // found
3935           }
3936         }
3937       }
3938     }
3939     return NULL;  // This whole branch bore nothing
3940   }
3941 
3942   // Return the method name with old prefixes stripped away.
3943   char* method_name_without_prefixes(Method* method) {
3944     Symbol* name = method-&gt;name();
3945     char* name_str = name-&gt;as_utf8();
3946 
3947     // Old prefixing may be defunct, strip prefixes, if any.
3948     for (int i = prefix_count-1; i &gt;= 0; i--) {
3949       char* prefix = prefixes[i];
3950       size_t prefix_len = strlen(prefix);
3951       if (strncmp(prefix, name_str, prefix_len) == 0) {
3952         name_str += prefix_len;
3953       }
3954     }
3955     return name_str;
3956   }
3957 
3958   // Strip any prefixes off the old native method, then try to find a
3959   // (possibly prefixed) new native that matches it.
3960   Method* strip_and_search_for_new_native(Method* method) {
3961     ResourceMark rm;
3962     char* name_str = method_name_without_prefixes(method);
3963     return search_prefix_name_space(0, name_str, strlen(name_str),
3964                                     method-&gt;signature());
3965   }
3966 
3967  public:
3968 
3969   // Construct a native method transfer processor for this class.
3970   TransferNativeFunctionRegistration(InstanceKlass* _the_class) {
3971     assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3972 
3973     the_class = _the_class;
3974     prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
3975   }
3976 
3977   // Attempt to transfer any of the old or deleted methods that are native
3978   void transfer_registrations(Method** old_methods, int methods_length) {
3979     for (int j = 0; j &lt; methods_length; j++) {
3980       Method* old_method = old_methods[j];
3981 
3982       if (old_method-&gt;is_native() &amp;&amp; old_method-&gt;has_native_function()) {
3983         Method* new_method = strip_and_search_for_new_native(old_method);
3984         if (new_method != NULL) {
3985           // Actually set the native function in the new method.
3986           // Redefine does not send events (except CFLH), certainly not this
3987           // behind the scenes re-registration.
3988           new_method-&gt;set_native_function(old_method-&gt;native_function(),
3989                               !Method::native_bind_event_is_interesting);
3990         }
3991       }
3992     }
3993   }
3994 };
3995 
3996 // Don&#39;t lose the association between a native method and its JNI function.
3997 void VM_RedefineClasses::transfer_old_native_function_registrations(InstanceKlass* the_class) {
3998   TransferNativeFunctionRegistration transfer(the_class);
3999   transfer.transfer_registrations(_deleted_methods, _deleted_methods_length);
4000   transfer.transfer_registrations(_matching_old_methods, _matching_methods_length);
4001 }
4002 
4003 // Deoptimize all compiled code that depends on this class.
4004 //
4005 // If the can_redefine_classes capability is obtained in the onload
4006 // phase then the compiler has recorded all dependencies from startup.
4007 // In that case we need only deoptimize and throw away all compiled code
4008 // that depends on the class.
4009 //
4010 // If can_redefine_classes is obtained sometime after the onload
4011 // phase then the dependency information may be incomplete. In that case
4012 // the first call to RedefineClasses causes all compiled code to be
4013 // thrown away. As can_redefine_classes has been obtained then
4014 // all future compilations will record dependencies so second and
4015 // subsequent calls to RedefineClasses need only throw away code
4016 // that depends on the class.
4017 //
4018 
4019 // First step is to walk the code cache for each class redefined and mark
4020 // dependent methods.  Wait until all classes are processed to deoptimize everything.
4021 void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {
4022   assert_locked_or_safepoint(Compile_lock);
4023 
4024   // All dependencies have been recorded from startup or this is a second or
4025   // subsequent use of RedefineClasses
4026   if (JvmtiExport::all_dependencies_are_recorded()) {
4027     CodeCache::mark_for_evol_deoptimization(ik);
4028   }
4029 }
4030 
4031 void VM_RedefineClasses::flush_dependent_code() {
4032   assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
4033 
4034   bool deopt_needed;
4035 
4036   // This is the first redefinition, mark all the nmethods for deoptimization
4037   if (!JvmtiExport::all_dependencies_are_recorded()) {
4038     log_debug(redefine, class, nmethod)(&quot;Marked all nmethods for deopt&quot;);
4039     CodeCache::mark_all_nmethods_for_evol_deoptimization();
4040     deopt_needed = true;
4041   } else {
4042     int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
4043     log_debug(redefine, class, nmethod)(&quot;Marked %d dependent nmethods for deopt&quot;, deopt);
4044     deopt_needed = (deopt != 0);
4045   }
4046 
4047   if (deopt_needed) {
4048     CodeCache::flush_evol_dependents();
4049   }
4050 
4051   // From now on we know that the dependency information is complete
4052   JvmtiExport::set_all_dependencies_are_recorded(true);
4053 }
4054 
4055 void VM_RedefineClasses::compute_added_deleted_matching_methods() {
4056   Method* old_method;
4057   Method* new_method;
4058 
4059   _matching_old_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
4060   _matching_new_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
4061   _added_methods        = NEW_RESOURCE_ARRAY(Method*, _new_methods-&gt;length());
4062   _deleted_methods      = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
4063 
4064   _matching_methods_length = 0;
4065   _deleted_methods_length  = 0;
4066   _added_methods_length    = 0;
4067 
4068   int nj = 0;
4069   int oj = 0;
4070   while (true) {
4071     if (oj &gt;= _old_methods-&gt;length()) {
4072       if (nj &gt;= _new_methods-&gt;length()) {
4073         break; // we&#39;ve looked at everything, done
4074       }
4075       // New method at the end
4076       new_method = _new_methods-&gt;at(nj);
4077       _added_methods[_added_methods_length++] = new_method;
4078       ++nj;
4079     } else if (nj &gt;= _new_methods-&gt;length()) {
4080       // Old method, at the end, is deleted
4081       old_method = _old_methods-&gt;at(oj);
4082       _deleted_methods[_deleted_methods_length++] = old_method;
4083       ++oj;
4084     } else {
4085       old_method = _old_methods-&gt;at(oj);
4086       new_method = _new_methods-&gt;at(nj);
4087       if (old_method-&gt;name() == new_method-&gt;name()) {
4088         if (old_method-&gt;signature() == new_method-&gt;signature()) {
4089           _matching_old_methods[_matching_methods_length  ] = old_method;
4090           _matching_new_methods[_matching_methods_length++] = new_method;
4091           ++nj;
4092           ++oj;
4093         } else {
4094           // added overloaded have already been moved to the end,
4095           // so this is a deleted overloaded method
4096           _deleted_methods[_deleted_methods_length++] = old_method;
4097           ++oj;
4098         }
4099       } else { // names don&#39;t match
4100         if (old_method-&gt;name()-&gt;fast_compare(new_method-&gt;name()) &gt; 0) {
4101           // new method
4102           _added_methods[_added_methods_length++] = new_method;
4103           ++nj;
4104         } else {
4105           // deleted method
4106           _deleted_methods[_deleted_methods_length++] = old_method;
4107           ++oj;
4108         }
4109       }
4110     }
4111   }
4112   assert(_matching_methods_length + _deleted_methods_length == _old_methods-&gt;length(), &quot;sanity&quot;);
4113   assert(_matching_methods_length + _added_methods_length == _new_methods-&gt;length(), &quot;sanity&quot;);
4114 }
4115 
4116 
4117 void VM_RedefineClasses::swap_annotations(InstanceKlass* the_class,
4118                                           InstanceKlass* scratch_class) {
4119   // Swap annotation fields values
4120   Annotations* old_annotations = the_class-&gt;annotations();
4121   the_class-&gt;set_annotations(scratch_class-&gt;annotations());
4122   scratch_class-&gt;set_annotations(old_annotations);
4123 }
4124 
4125 
4126 // Install the redefinition of a class:
4127 //    - house keeping (flushing breakpoints and caches, deoptimizing
4128 //      dependent compiled code)
4129 //    - replacing parts in the_class with parts from scratch_class
4130 //    - adding a weak reference to track the obsolete but interesting
4131 //      parts of the_class
4132 //    - adjusting constant pool caches and vtables in other classes
4133 //      that refer to methods in the_class. These adjustments use the
4134 //      ClassLoaderDataGraph::classes_do() facility which only allows
4135 //      a helper method to be specified. The interesting parameters
4136 //      that we would like to pass to the helper method are saved in
4137 //      static global fields in the VM operation.
4138 void VM_RedefineClasses::redefine_single_class(jclass the_jclass,
4139        InstanceKlass* scratch_class, TRAPS) {
4140 
4141   HandleMark hm(THREAD);   // make sure handles from this call are freed
4142 
4143   if (log_is_enabled(Info, redefine, class, timer)) {
4144     _timer_rsc_phase1.start();
4145   }
4146 
4147   InstanceKlass* the_class = get_ik(the_jclass);
4148 
4149   // Set a flag to control and optimize adjusting method entries
4150   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
4151 
4152   // Remove all breakpoints in methods of this class
4153   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
4154   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
4155 
4156   // Mark all compiled code that depends on this class
4157   mark_dependent_code(the_class);
4158 
4159   _old_methods = the_class-&gt;methods();
4160   _new_methods = scratch_class-&gt;methods();
4161   _the_class = the_class;
4162   compute_added_deleted_matching_methods();
4163   update_jmethod_ids(THREAD);
4164 
4165   _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
4166 
4167   // Attach new constant pool to the original klass. The original
4168   // klass still refers to the old constant pool (for now).
4169   scratch_class-&gt;constants()-&gt;set_pool_holder(the_class);
4170 
4171 #if 0
4172   // In theory, with constant pool merging in place we should be able
4173   // to save space by using the new, merged constant pool in place of
4174   // the old constant pool(s). By &quot;pool(s)&quot; I mean the constant pool in
4175   // the klass version we are replacing now and any constant pool(s) in
4176   // previous versions of klass. Nice theory, doesn&#39;t work in practice.
4177   // When this code is enabled, even simple programs throw NullPointer
4178   // exceptions. I&#39;m guessing that this is caused by some constant pool
4179   // cache difference between the new, merged constant pool and the
4180   // constant pool that was just being used by the klass. I&#39;m keeping
4181   // this code around to archive the idea, but the code has to remain
4182   // disabled for now.
4183 
4184   // Attach each old method to the new constant pool. This can be
4185   // done here since we are past the bytecode verification and
4186   // constant pool optimization phases.
4187   for (int i = _old_methods-&gt;length() - 1; i &gt;= 0; i--) {
4188     Method* method = _old_methods-&gt;at(i);
4189     method-&gt;set_constants(scratch_class-&gt;constants());
4190   }
4191 
4192   // NOTE: this doesn&#39;t work because you can redefine the same class in two
4193   // threads, each getting their own constant pool data appended to the
4194   // original constant pool.  In order for the new methods to work when they
4195   // become old methods, they need to keep their updated copy of the constant pool.
4196 
4197   {
4198     // walk all previous versions of the klass
4199     InstanceKlass *ik = the_class;
4200     PreviousVersionWalker pvw(ik);
4201     do {
4202       ik = pvw.next_previous_version();
4203       if (ik != NULL) {
4204 
4205         // attach previous version of klass to the new constant pool
4206         ik-&gt;set_constants(scratch_class-&gt;constants());
4207 
4208         // Attach each method in the previous version of klass to the
4209         // new constant pool
4210         Array&lt;Method*&gt;* prev_methods = ik-&gt;methods();
4211         for (int i = prev_methods-&gt;length() - 1; i &gt;= 0; i--) {
4212           Method* method = prev_methods-&gt;at(i);
4213           method-&gt;set_constants(scratch_class-&gt;constants());
4214         }
4215       }
4216     } while (ik != NULL);
4217   }
4218 #endif
4219 
4220   // Replace methods and constantpool
4221   the_class-&gt;set_methods(_new_methods);
4222   scratch_class-&gt;set_methods(_old_methods);     // To prevent potential GCing of the old methods,
4223                                           // and to be able to undo operation easily.
4224 
4225   Array&lt;int&gt;* old_ordering = the_class-&gt;method_ordering();
4226   the_class-&gt;set_method_ordering(scratch_class-&gt;method_ordering());
4227   scratch_class-&gt;set_method_ordering(old_ordering);
4228 
4229   ConstantPool* old_constants = the_class-&gt;constants();
4230   the_class-&gt;set_constants(scratch_class-&gt;constants());
4231   scratch_class-&gt;set_constants(old_constants);  // See the previous comment.
4232 #if 0
4233   // We are swapping the guts of &quot;the new class&quot; with the guts of &quot;the
4234   // class&quot;. Since the old constant pool has just been attached to &quot;the
4235   // new class&quot;, it seems logical to set the pool holder in the old
4236   // constant pool also. However, doing this will change the observable
4237   // class hierarchy for any old methods that are still executing. A
4238   // method can query the identity of its &quot;holder&quot; and this query uses
4239   // the method&#39;s constant pool link to find the holder. The change in
4240   // holding class from &quot;the class&quot; to &quot;the new class&quot; can confuse
4241   // things.
4242   //
4243   // Setting the old constant pool&#39;s holder will also cause
4244   // verification done during vtable initialization below to fail.
4245   // During vtable initialization, the vtable&#39;s class is verified to be
4246   // a subtype of the method&#39;s holder. The vtable&#39;s class is &quot;the
4247   // class&quot; and the method&#39;s holder is gotten from the constant pool
4248   // link in the method itself. For &quot;the class&quot;&#39;s directly implemented
4249   // methods, the method holder is &quot;the class&quot; itself (as gotten from
4250   // the new constant pool). The check works fine in this case. The
4251   // check also works fine for methods inherited from super classes.
4252   //
4253   // Miranda methods are a little more complicated. A miranda method is
4254   // provided by an interface when the class implementing the interface
4255   // does not provide its own method.  These interfaces are implemented
4256   // internally as an InstanceKlass. These special instanceKlasses
4257   // share the constant pool of the class that &quot;implements&quot; the
4258   // interface. By sharing the constant pool, the method holder of a
4259   // miranda method is the class that &quot;implements&quot; the interface. In a
4260   // non-redefine situation, the subtype check works fine. However, if
4261   // the old constant pool&#39;s pool holder is modified, then the check
4262   // fails because there is no class hierarchy relationship between the
4263   // vtable&#39;s class and &quot;the new class&quot;.
4264 
4265   old_constants-&gt;set_pool_holder(scratch_class());
4266 #endif
4267 
4268   // track number of methods that are EMCP for add_previous_version() call below
4269   int emcp_method_count = check_methods_and_mark_as_obsolete();
4270   transfer_old_native_function_registrations(the_class);
4271 
4272   // The class file bytes from before any retransformable agents mucked
4273   // with them was cached on the scratch class, move to the_class.
4274   // Note: we still want to do this if nothing needed caching since it
4275   // should get cleared in the_class too.
4276   if (the_class-&gt;get_cached_class_file() == 0) {
4277     // the_class doesn&#39;t have a cache yet so copy it
4278     the_class-&gt;set_cached_class_file(scratch_class-&gt;get_cached_class_file());
4279   }
4280   else if (scratch_class-&gt;get_cached_class_file() !=
4281            the_class-&gt;get_cached_class_file()) {
4282     // The same class can be present twice in the scratch classes list or there
4283     // are multiple concurrent RetransformClasses calls on different threads.
4284     // In such cases we have to deallocate scratch_class cached_class_file.
4285     os::free(scratch_class-&gt;get_cached_class_file());
4286   }
4287 
4288   // NULL out in scratch class to not delete twice.  The class to be redefined
4289   // always owns these bytes.
4290   scratch_class-&gt;set_cached_class_file(NULL);
4291 
4292   // Replace inner_classes
4293   Array&lt;u2&gt;* old_inner_classes = the_class-&gt;inner_classes();
4294   the_class-&gt;set_inner_classes(scratch_class-&gt;inner_classes());
4295   scratch_class-&gt;set_inner_classes(old_inner_classes);
4296 
4297   // Initialize the vtable and interface table after
4298   // methods have been rewritten
4299   // no exception should happen here since we explicitly
4300   // do not check loader constraints.
4301   // compare_and_normalize_class_versions has already checked:
4302   //  - classloaders unchanged, signatures unchanged
4303   //  - all instanceKlasses for redefined classes reused &amp; contents updated
4304   the_class-&gt;vtable().initialize_vtable(false, THREAD);
4305   the_class-&gt;itable().initialize_itable(false, THREAD);
4306   assert(!HAS_PENDING_EXCEPTION || (THREAD-&gt;pending_exception()-&gt;is_a(SystemDictionary::ThreadDeath_klass())), &quot;redefine exception&quot;);
4307 
4308   // Leave arrays of jmethodIDs and itable index cache unchanged
4309 
4310   // Copy the &quot;source file name&quot; attribute from new class version
4311   the_class-&gt;set_source_file_name_index(
4312     scratch_class-&gt;source_file_name_index());
4313 
4314   // Copy the &quot;source debug extension&quot; attribute from new class version
4315   the_class-&gt;set_source_debug_extension(
4316     scratch_class-&gt;source_debug_extension(),
4317     scratch_class-&gt;source_debug_extension() == NULL ? 0 :
4318     (int)strlen(scratch_class-&gt;source_debug_extension()));
4319 
4320   // Use of javac -g could be different in the old and the new
4321   if (scratch_class-&gt;access_flags().has_localvariable_table() !=
4322       the_class-&gt;access_flags().has_localvariable_table()) {
4323 
4324     AccessFlags flags = the_class-&gt;access_flags();
4325     if (scratch_class-&gt;access_flags().has_localvariable_table()) {
4326       flags.set_has_localvariable_table();
4327     } else {
4328       flags.clear_has_localvariable_table();
4329     }
4330     the_class-&gt;set_access_flags(flags);
4331   }
4332 
4333   swap_annotations(the_class, scratch_class);
4334 
4335   // Replace CP indexes for class and name+type of enclosing method
4336   u2 old_class_idx  = the_class-&gt;enclosing_method_class_index();
4337   u2 old_method_idx = the_class-&gt;enclosing_method_method_index();
4338   the_class-&gt;set_enclosing_method_indices(
4339     scratch_class-&gt;enclosing_method_class_index(),
4340     scratch_class-&gt;enclosing_method_method_index());
4341   scratch_class-&gt;set_enclosing_method_indices(old_class_idx, old_method_idx);
4342 
4343   // Replace fingerprint data
4344   the_class-&gt;set_has_passed_fingerprint_check(scratch_class-&gt;has_passed_fingerprint_check());
4345   the_class-&gt;store_fingerprint(scratch_class-&gt;get_stored_fingerprint());
4346 
4347   the_class-&gt;set_has_been_redefined();
4348 
4349   if (!the_class-&gt;should_be_initialized()) {
4350     // Class was already initialized, so AOT has only seen the original version.
4351     // We need to let AOT look at it again.
4352     AOTLoader::load_for_klass(the_class, THREAD);
4353   }
4354 
4355   // keep track of previous versions of this class
4356   the_class-&gt;add_previous_version(scratch_class, emcp_method_count);
4357 
4358   _timer_rsc_phase1.stop();
4359   if (log_is_enabled(Info, redefine, class, timer)) {
4360     _timer_rsc_phase2.start();
4361   }
4362 
4363   if (the_class-&gt;oop_map_cache() != NULL) {
4364     // Flush references to any obsolete methods from the oop map cache
4365     // so that obsolete methods are not pinned.
4366     the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
4367   }
4368 
4369   increment_class_counter((InstanceKlass *)the_class, THREAD);
4370 
4371   if (EventClassRedefinition::is_enabled()) {
4372     EventClassRedefinition event;
4373     event.set_classModificationCount(java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4374     event.set_redefinedClass(the_class);
4375     event.set_redefinitionId(_id);
4376     event.commit();
4377   }
4378 
4379   {
4380     ResourceMark rm(THREAD);
4381     // increment the classRedefinedCount field in the_class and in any
4382     // direct and indirect subclasses of the_class
4383     log_info(redefine, class, load)
4384       (&quot;redefined name=%s, count=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
4385        the_class-&gt;external_name(), java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()), os::available_memory() &gt;&gt; 10);
4386     Events::log_redefinition(THREAD, &quot;redefined class name=%s, count=%d&quot;,
4387                              the_class-&gt;external_name(),
4388                              java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4389 
4390   }
4391   _timer_rsc_phase2.stop();
4392 
4393 } // end redefine_single_class()
4394 
4395 
4396 // Increment the classRedefinedCount field in the specific InstanceKlass
4397 // and in all direct and indirect subclasses.
4398 void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {
4399   oop class_mirror = ik-&gt;java_mirror();
4400   Klass* class_oop = java_lang_Class::as_Klass(class_mirror);
4401   int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
4402   java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
4403 
4404   if (class_oop != _the_class) {
4405     // _the_class count is printed at end of redefine_single_class()
4406     log_debug(redefine, class, subclass)(&quot;updated count in subclass=%s to %d&quot;, ik-&gt;external_name(), new_count);
4407   }
4408 
4409   for (Klass *subk = ik-&gt;subklass(); subk != NULL;
4410        subk = subk-&gt;next_sibling()) {
4411     if (subk-&gt;is_instance_klass()) {
4412       // Only update instanceKlasses
4413       InstanceKlass *subik = InstanceKlass::cast(subk);
4414       // recursively do subclasses of the current subclass
4415       increment_class_counter(subik, THREAD);
4416     }
4417   }
4418 }
4419 
4420 void VM_RedefineClasses::CheckClass::do_klass(Klass* k) {
4421   bool no_old_methods = true;  // be optimistic
4422 
4423   // Both array and instance classes have vtables.
4424   // a vtable should never contain old or obsolete methods
4425   ResourceMark rm(_thread);
4426   if (k-&gt;vtable_length() &gt; 0 &amp;&amp;
4427       !k-&gt;vtable().check_no_old_or_obsolete_entries()) {
4428     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4429       log_trace(redefine, class, obsolete, metadata)
4430         (&quot;klassVtable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4431          k-&gt;signature_name());
4432       k-&gt;vtable().dump_vtable();
4433     }
4434     no_old_methods = false;
4435   }
4436 
4437   if (k-&gt;is_instance_klass()) {
4438     HandleMark hm(_thread);
4439     InstanceKlass *ik = InstanceKlass::cast(k);
4440 
4441     // an itable should never contain old or obsolete methods
4442     if (ik-&gt;itable_length() &gt; 0 &amp;&amp;
4443         !ik-&gt;itable().check_no_old_or_obsolete_entries()) {
4444       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4445         log_trace(redefine, class, obsolete, metadata)
4446           (&quot;klassItable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4447            ik-&gt;signature_name());
4448         ik-&gt;itable().dump_itable();
4449       }
4450       no_old_methods = false;
4451     }
4452 
4453     // the constant pool cache should never contain non-deleted old or obsolete methods
4454     if (ik-&gt;constants() != NULL &amp;&amp;
4455         ik-&gt;constants()-&gt;cache() != NULL &amp;&amp;
4456         !ik-&gt;constants()-&gt;cache()-&gt;check_no_old_or_obsolete_entries()) {
4457       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4458         log_trace(redefine, class, obsolete, metadata)
4459           (&quot;cp-cache::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4460            ik-&gt;signature_name());
4461         ik-&gt;constants()-&gt;cache()-&gt;dump_cache();
4462       }
4463       no_old_methods = false;
4464     }
4465   }
4466 
4467   // print and fail guarantee if old methods are found.
4468   if (!no_old_methods) {
4469     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4470       dump_methods();
4471     } else {
4472       log_trace(redefine, class)(&quot;Use the &#39;-Xlog:redefine+class*:&#39; option &quot;
4473         &quot;to see more info about the following guarantee() failure.&quot;);
4474     }
4475     guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
4476   }
4477 }
4478 
4479 u8 VM_RedefineClasses::next_id() {
4480   while (true) {
4481     u8 id = _id_counter;
4482     u8 next_id = id + 1;
4483     u8 result = Atomic::cmpxchg(&amp;_id_counter, id, next_id);
4484     if (result == id) {
4485       return next_id;
4486     }
4487   }
4488 }
4489 
4490 void VM_RedefineClasses::dump_methods() {
4491   int j;
4492   log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
4493   for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
4494     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4495     Method* m = _old_methods-&gt;at(j);
4496     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4497     m-&gt;access_flags().print_on(&amp;log_stream);
4498     log_stream.print(&quot; --  &quot;);
4499     m-&gt;print_name(&amp;log_stream);
4500     log_stream.cr();
4501   }
4502   log_trace(redefine, class, dump)(&quot;_new_methods --&quot;);
4503   for (j = 0; j &lt; _new_methods-&gt;length(); ++j) {
4504     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4505     Method* m = _new_methods-&gt;at(j);
4506     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4507     m-&gt;access_flags().print_on(&amp;log_stream);
4508     log_stream.print(&quot; --  &quot;);
4509     m-&gt;print_name(&amp;log_stream);
4510     log_stream.cr();
4511   }
4512   log_trace(redefine, class, dump)(&quot;_matching_methods --&quot;);
4513   for (j = 0; j &lt; _matching_methods_length; ++j) {
4514     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4515     Method* m = _matching_old_methods[j];
4516     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4517     m-&gt;access_flags().print_on(&amp;log_stream);
4518     log_stream.print(&quot; --  &quot;);
4519     m-&gt;print_name();
4520     log_stream.cr();
4521 
4522     m = _matching_new_methods[j];
4523     log_stream.print(&quot;      (%5d)  &quot;, m-&gt;vtable_index());
4524     m-&gt;access_flags().print_on(&amp;log_stream);
4525     log_stream.cr();
4526   }
4527   log_trace(redefine, class, dump)(&quot;_deleted_methods --&quot;);
4528   for (j = 0; j &lt; _deleted_methods_length; ++j) {
4529     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4530     Method* m = _deleted_methods[j];
4531     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4532     m-&gt;access_flags().print_on(&amp;log_stream);
4533     log_stream.print(&quot; --  &quot;);
4534     m-&gt;print_name(&amp;log_stream);
4535     log_stream.cr();
4536   }
4537   log_trace(redefine, class, dump)(&quot;_added_methods --&quot;);
4538   for (j = 0; j &lt; _added_methods_length; ++j) {
4539     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4540     Method* m = _added_methods[j];
4541     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4542     m-&gt;access_flags().print_on(&amp;log_stream);
4543     log_stream.print(&quot; --  &quot;);
4544     m-&gt;print_name(&amp;log_stream);
4545     log_stream.cr();
4546   }
4547 }
4548 
4549 void VM_RedefineClasses::print_on_error(outputStream* st) const {
4550   VM_Operation::print_on_error(st);
4551   if (_the_class != NULL) {
4552     ResourceMark rm;
4553     st-&gt;print_cr(&quot;, redefining class %s&quot;, _the_class-&gt;external_name());
4554   }
4555 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>