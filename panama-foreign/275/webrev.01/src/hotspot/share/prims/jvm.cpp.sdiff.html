<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jni.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnter.xsl.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 521 
 522 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 523   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 524   size_t n = Universe::heap()-&gt;unused();
 525   return convert_size_t_to_jlong(n);
 526 JVM_END
 527 
 528 
 529 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 530   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 531   size_t n = Universe::heap()-&gt;max_capacity();
 532   return convert_size_t_to_jlong(n);
 533 JVM_END
 534 
 535 
 536 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 537   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 538   return os::active_processor_count();
 539 JVM_END
 540 
<span class="line-modified"> 541 </span>








 542 
 543 // java.lang.Throwable //////////////////////////////////////////////////////
 544 
 545 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 546   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 547   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 548   java_lang_Throwable::fill_in_stack_trace(exception);
 549 JVM_END
 550 
 551 // java.lang.NullPointerException ///////////////////////////////////////////
 552 
 553 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 554   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 555 
 556   oop exc = JNIHandles::resolve_non_null(throwable);
 557 
 558   Method* method;
 559   int bci;
 560   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 561     return NULL;
</pre>
<hr />
<pre>
1287   assert(!result || k-&gt;is_instance_klass(),
1288          &quot;all interfaces are instance types&quot;);
1289   // The compiler intrinsic for isInterface tests the
1290   // Klass::_access_flags bits in the same way.
1291   return result;
1292 JVM_END
1293 
1294 JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))
1295   JVMWrapper(&quot;JVM_IsHiddenClass&quot;);
1296   oop mirror = JNIHandles::resolve_non_null(cls);
1297   if (java_lang_Class::is_primitive(mirror)) {
1298     return JNI_FALSE;
1299   }
1300   Klass* k = java_lang_Class::as_Klass(mirror);
1301   return k-&gt;is_hidden();
1302 JVM_END
1303 
1304 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1305   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1306   JvmtiVMObjectAllocEventCollector oam;
<span class="line-modified">1307   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {</span>

1308     // There are no signers for primitive types
1309     return NULL;
1310   }
1311 
<span class="line-modified">1312   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));</span>
1313 
1314   // If there are no signers set in the class, or if the class
1315   // is an array, return NULL.
1316   if (signers == NULL) return NULL;
1317 
1318   // copy of the signers array
1319   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1320   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1321   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1322     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1323   }
1324 
1325   // return the copy
1326   return (jobjectArray) JNIHandles::make_local(THREAD, signers_copy);
1327 JVM_END
1328 
1329 
1330 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1331   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
<span class="line-modified">1332   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {</span>

1333     // This call is ignored for primitive types and arrays.
1334     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1335     // be called with an array.  Only the bootstrap loader creates arrays.
<span class="line-modified">1336     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));</span>
1337     if (k-&gt;is_instance_klass()) {
1338       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1339     }
1340   }
1341 JVM_END
1342 
1343 
1344 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1345   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
<span class="line-modified">1346   if (JNIHandles::resolve(cls) == NULL) {</span>

1347     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1348   }
1349 
<span class="line-modified">1350   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {</span>
1351     // Primitive types does not have a protection domain.
1352     return NULL;
1353   }
1354 
<span class="line-modified">1355   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));</span>
1356   return (jobject) JNIHandles::make_local(THREAD, pd);
1357 JVM_END
1358 
1359 
1360 // Returns the inherited_access_control_context field of the running thread.
1361 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1362   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1363   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1364   return JNIHandles::make_local(THREAD, result);
1365 JVM_END
1366 
1367 class RegisterArrayForGC {
1368  private:
1369   JavaThread *_thread;
1370  public:
1371   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1372     _thread = thread;
1373     _thread-&gt;register_array_for_gc(array);
1374   }
1375 
</pre>
<hr />
<pre>
1457   return JNIHandles::make_local(THREAD, result);
1458 JVM_END
1459 
1460 
1461 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1462   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1463   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1464   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1465 JVM_END
1466 
1467 
1468 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1469   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1470   oop mirror = JNIHandles::resolve_non_null(cls);
1471   return (jboolean) java_lang_Class::is_primitive(mirror);
1472 JVM_END
1473 
1474 
1475 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1476   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
<span class="line-modified">1477   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {</span>

1478     // Primitive type
1479     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1480   }
1481 
<span class="line-modified">1482   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));</span>
1483   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1484   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1485   return k-&gt;modifier_flags();
1486 JVM_END
1487 
1488 
1489 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1490 
1491 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1492   JvmtiVMObjectAllocEventCollector oam;
1493   // ofClass is a reference to a java_lang_Class object. The mirror object
1494   // of an InstanceKlass
<span class="line-modified">1495 </span>
<span class="line-modified">1496   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||</span>
<span class="line-modified">1497       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {</span>
1498     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1499     return (jobjectArray)JNIHandles::make_local(THREAD, result);
1500   }
1501 
<span class="line-modified">1502   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));</span>
1503   InnerClassesIterator iter(k);
1504 
1505   if (iter.length() == 0) {
1506     // Neither an inner nor outer class
1507     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1508     return (jobjectArray)JNIHandles::make_local(THREAD, result);
1509   }
1510 
1511   // find inner class info
1512   constantPoolHandle cp(thread, k-&gt;constants());
1513   int length = iter.length();
1514 
1515   // Allocate temp. result array
1516   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1517   objArrayHandle result (THREAD, r);
1518   int members = 0;
1519 
1520   for (; !iter.done(); iter.next()) {
1521     int ioff = iter.inner_class_info_index();
1522     int ooff = iter.outer_class_info_index();
</pre>
<hr />
<pre>
1540       }
1541     }
1542   }
1543 
1544   if (members != length) {
1545     // Return array of right length
1546     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1547     for(int i = 0; i &lt; members; i++) {
1548       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1549     }
1550     return (jobjectArray)JNIHandles::make_local(THREAD, res);
1551   }
1552 
1553   return (jobjectArray)JNIHandles::make_local(THREAD, result());
1554 JVM_END
1555 
1556 
1557 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1558 {
1559   // ofClass is a reference to a java_lang_Class object.
<span class="line-modified">1560   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||</span>
<span class="line-modified">1561       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {</span>




1562     return NULL;
1563   }
1564 
1565   bool inner_is_member = false;
1566   Klass* outer_klass
<span class="line-modified">1567     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))</span>
<span class="line-removed">1568                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);</span>
1569   if (outer_klass == NULL)  return NULL;  // already a top-level class
1570   if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
1571   return (jclass) JNIHandles::make_local(THREAD, outer_klass-&gt;java_mirror());
1572 }
1573 JVM_END
1574 
1575 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1576 {
1577   oop mirror = JNIHandles::resolve_non_null(cls);
<span class="line-modified">1578   if (java_lang_Class::is_primitive(mirror) ||</span>
<span class="line-removed">1579       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {</span>
1580     return NULL;
1581   }
<span class="line-modified">1582   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));</span>




1583   int ooff = 0, noff = 0;
1584   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1585     if (noff != 0) {
1586       constantPoolHandle i_cp(thread, k-&gt;constants());
1587       Symbol* name = i_cp-&gt;symbol_at(noff);
1588       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1589       return (jstring) JNIHandles::make_local(THREAD, str());
1590     }
1591   }
1592   return NULL;
1593 }
1594 JVM_END
1595 
1596 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1597   assert (cls != NULL, &quot;illegal class&quot;);
1598   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1599   JvmtiVMObjectAllocEventCollector oam;
1600   ResourceMark rm(THREAD);

1601   // Return null for arrays and primatives
<span class="line-modified">1602   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {</span>
<span class="line-modified">1603     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));</span>
1604     if (k-&gt;is_instance_klass()) {
1605       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1606       if (sym == NULL) return NULL;
1607       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1608       return (jstring) JNIHandles::make_local(THREAD, str());
1609     }
1610   }
1611   return NULL;
1612 JVM_END
1613 
1614 
1615 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1616   assert (cls != NULL, &quot;illegal class&quot;);
1617   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
<span class="line-modified">1618 </span>
1619   // Return null for arrays and primitives
<span class="line-modified">1620   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {</span>
<span class="line-modified">1621     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));</span>
1622     if (k-&gt;is_instance_klass()) {
1623       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1624       return (jbyteArray) JNIHandles::make_local(THREAD, a);
1625     }
1626   }
1627   return NULL;
1628 JVM_END
1629 
1630 
1631 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1632   // some of this code was adapted from from jni_FromReflectedField
1633 
1634   oop reflected = JNIHandles::resolve_non_null(field);
1635   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1636   Klass* k    = java_lang_Class::as_Klass(mirror);
1637   int slot      = java_lang_reflect_Field::slot(reflected);
1638   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1639 
1640   InstanceKlass* ik = InstanceKlass::cast(k);
1641   intptr_t offset = ik-&gt;field_offset(slot);
</pre>
<hr />
<pre>
1780       // For a 0 index, give a NULL symbol
1781       Symbol* sym = 0 != params[i].name_cp_index ?
1782         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1783       int flags = params[i].flags;
1784       oop param = Reflection::new_parameter(reflected_method, i, sym,
1785                                             flags, CHECK_NULL);
1786       result-&gt;obj_at_put(i, param);
1787     }
1788     return (jobjectArray)JNIHandles::make_local(THREAD, result());
1789   }
1790 }
1791 JVM_END
1792 
1793 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1794 
1795 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1796 {
1797   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1798   JvmtiVMObjectAllocEventCollector oam;
1799 

1800   // Exclude primitive types and array types
<span class="line-modified">1801   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||</span>
<span class="line-modified">1802       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {</span>
1803     // Return empty array
1804     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1805     return (jobjectArray) JNIHandles::make_local(THREAD, res);
1806   }
1807 
<span class="line-modified">1808   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));</span>
1809   constantPoolHandle cp(THREAD, k-&gt;constants());
1810 
1811   // Ensure class is linked
1812   k-&gt;link_class(CHECK_NULL);
1813 
1814   // Allocate result
1815   int num_fields;
1816 
1817   if (publicOnly) {
1818     num_fields = 0;
1819     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1820       if (fs.access_flags().is_public()) ++num_fields;
1821     }
1822   } else {
1823     num_fields = k-&gt;java_fields_count();
1824   }
1825 
1826   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1827   objArrayHandle result (THREAD, r);
1828 
</pre>
<hr />
<pre>
1888   return (jobjectArray)JNIHandles::make_local(THREAD, result);
1889 }
1890 JVM_END
1891 
1892 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1893   if (want_constructor) {
1894     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1895   } else {
1896     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1897   }
1898 }
1899 
1900 static jobjectArray get_class_declared_methods_helper(
1901                                   JNIEnv *env,
1902                                   jclass ofClass, jboolean publicOnly,
1903                                   bool want_constructor,
1904                                   Klass* klass, TRAPS) {
1905 
1906   JvmtiVMObjectAllocEventCollector oam;
1907 

1908   // Exclude primitive types and array types
<span class="line-modified">1909   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))</span>
<span class="line-modified">1910       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {</span>
1911     // Return empty array
1912     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1913     return (jobjectArray) JNIHandles::make_local(THREAD, res);
1914   }
1915 
<span class="line-modified">1916   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));</span>
1917 
1918   // Ensure class is linked
1919   k-&gt;link_class(CHECK_NULL);
1920 
1921   Array&lt;Method*&gt;* methods = k-&gt;methods();
1922   int methods_length = methods-&gt;length();
1923 
1924   // Save original method_idnum in case of redefinition, which can change
1925   // the idnum of obsolete methods.  The new method will have the same idnum
1926   // but if we refresh the methods array, the counts will be wrong.
1927   ResourceMark rm(THREAD);
1928   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1929   int num_methods = 0;
1930 
1931   for (int i = 0; i &lt; methods_length; i++) {
1932     methodHandle method(THREAD, methods-&gt;at(i));
1933     if (select_method(method, want_constructor)) {
1934       if (!publicOnly || method-&gt;is_public()) {
1935         idnums-&gt;push(method-&gt;method_idnum());
1936         ++num_methods;
</pre>
<hr />
<pre>
1970 {
1971   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1972   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1973                                            /*want_constructor*/ false,
1974                                            SystemDictionary::reflect_Method_klass(), THREAD);
1975 }
1976 JVM_END
1977 
1978 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1979 {
1980   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
1981   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1982                                            /*want_constructor*/ true,
1983                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
1984 }
1985 JVM_END
1986 
1987 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
1988 {
1989   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
<span class="line-modified">1990   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {</span>

1991     // Primitive type
1992     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1993   }
1994 
<span class="line-modified">1995   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));</span>
1996   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
1997 }
1998 JVM_END
1999 
2000 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
2001 {
2002   JVMWrapper(&quot;JVM_AreNestMates&quot;);
2003   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2004   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2005   InstanceKlass* ck = InstanceKlass::cast(c);
2006   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
2007   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
2008   InstanceKlass* mk = InstanceKlass::cast(m);
2009   return ck-&gt;has_nestmate_access_to(mk, THREAD);
2010 }
2011 JVM_END
2012 
2013 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
2014 {
2015   // current is not a primitive or array class
</pre>
<hr />
<pre>
2090         objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2091                                                   count + 1, CHECK_NULL);
2092         objArrayHandle result2(THREAD, r2);
2093         for (int i = 0; i &lt; count + 1; i++) {
2094           result2-&gt;obj_at_put(i, result-&gt;obj_at(i));
2095         }
2096         return (jobjectArray)JNIHandles::make_local(THREAD, result2());
2097       }
2098     }
2099     else {
2100       assert(host == ck || ck-&gt;is_hidden(), &quot;must be singleton nest or dynamic nestmate&quot;);
2101     }
2102     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2103   }
2104 }
2105 JVM_END
2106 
2107 JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))
2108 {
2109   JVMWrapper(&quot;JVM_GetPermittedSubclasses&quot;);
<span class="line-modified">2110   assert(!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(current)), &quot;should not be&quot;);</span>
<span class="line-modified">2111   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));</span>

2112   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2113   InstanceKlass* ik = InstanceKlass::cast(c);
2114   {
2115     JvmtiVMObjectAllocEventCollector oam;
2116     Array&lt;u2&gt;* subclasses = ik-&gt;permitted_subclasses();
2117     int length = subclasses == NULL ? 0 : subclasses-&gt;length();
2118     objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
2119                                              length, CHECK_NULL);
2120     objArrayHandle result(THREAD, r);
2121     for (int i = 0; i &lt; length; i++) {
2122       int cp_index = subclasses-&gt;at(i);
2123       // This returns &lt;package-name&gt;/&lt;class-name&gt;.
2124       Symbol* klass_name = ik-&gt;constants()-&gt;klass_name_at(cp_index);
2125       assert(klass_name != NULL, &quot;Unexpected null klass_name&quot;);
2126       Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2127       result-&gt;obj_at_put(i, perm_subtype_h());
2128     }
2129     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2130   }
2131 }
2132 JVM_END
2133 
2134 // Constant pool access //////////////////////////////////////////////////////////
2135 
2136 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
2137 {
2138   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
2139   JvmtiVMObjectAllocEventCollector oam;
<span class="line-modified">2140 </span>
2141   // Return null for primitives and arrays
<span class="line-modified">2142   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {</span>
<span class="line-modified">2143     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));</span>
2144     if (k-&gt;is_instance_klass()) {
2145       InstanceKlass* k_h = InstanceKlass::cast(k);
2146       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
2147       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
2148       return JNIHandles::make_local(THREAD, jcp());
2149     }
2150   }
2151   return NULL;
2152 }
2153 JVM_END
2154 
2155 
2156 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
2157 {
2158   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
2159   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2160   return cp-&gt;length();
2161 }
2162 JVM_END
2163 
</pre>
</td>
<td>
<hr />
<pre>
 521 
 522 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 523   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 524   size_t n = Universe::heap()-&gt;unused();
 525   return convert_size_t_to_jlong(n);
 526 JVM_END
 527 
 528 
 529 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 530   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 531   size_t n = Universe::heap()-&gt;max_capacity();
 532   return convert_size_t_to_jlong(n);
 533 JVM_END
 534 
 535 
 536 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 537   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 538   return os::active_processor_count();
 539 JVM_END
 540 
<span class="line-modified"> 541 JVM_ENTRY_NO_ENV(jboolean, JVM_IsUseContainerSupport(void))</span>
<span class="line-added"> 542   JVMWrapper(&quot;JVM_IsUseContainerSupport&quot;);</span>
<span class="line-added"> 543 #ifdef LINUX</span>
<span class="line-added"> 544   if (UseContainerSupport) {</span>
<span class="line-added"> 545     return JNI_TRUE;</span>
<span class="line-added"> 546   }</span>
<span class="line-added"> 547 #endif</span>
<span class="line-added"> 548   return JNI_FALSE;</span>
<span class="line-added"> 549 JVM_END</span>
 550 
 551 // java.lang.Throwable //////////////////////////////////////////////////////
 552 
 553 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 554   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 555   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 556   java_lang_Throwable::fill_in_stack_trace(exception);
 557 JVM_END
 558 
 559 // java.lang.NullPointerException ///////////////////////////////////////////
 560 
 561 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 562   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 563 
 564   oop exc = JNIHandles::resolve_non_null(throwable);
 565 
 566   Method* method;
 567   int bci;
 568   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 569     return NULL;
</pre>
<hr />
<pre>
1295   assert(!result || k-&gt;is_instance_klass(),
1296          &quot;all interfaces are instance types&quot;);
1297   // The compiler intrinsic for isInterface tests the
1298   // Klass::_access_flags bits in the same way.
1299   return result;
1300 JVM_END
1301 
1302 JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))
1303   JVMWrapper(&quot;JVM_IsHiddenClass&quot;);
1304   oop mirror = JNIHandles::resolve_non_null(cls);
1305   if (java_lang_Class::is_primitive(mirror)) {
1306     return JNI_FALSE;
1307   }
1308   Klass* k = java_lang_Class::as_Klass(mirror);
1309   return k-&gt;is_hidden();
1310 JVM_END
1311 
1312 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1313   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1314   JvmtiVMObjectAllocEventCollector oam;
<span class="line-modified">1315   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">1316   if (java_lang_Class::is_primitive(mirror)) {</span>
1317     // There are no signers for primitive types
1318     return NULL;
1319   }
1320 
<span class="line-modified">1321   objArrayHandle signers(THREAD, java_lang_Class::signers(mirror));</span>
1322 
1323   // If there are no signers set in the class, or if the class
1324   // is an array, return NULL.
1325   if (signers == NULL) return NULL;
1326 
1327   // copy of the signers array
1328   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1329   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1330   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1331     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1332   }
1333 
1334   // return the copy
1335   return (jobjectArray) JNIHandles::make_local(THREAD, signers_copy);
1336 JVM_END
1337 
1338 
1339 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1340   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
<span class="line-modified">1341   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">1342   if (!java_lang_Class::is_primitive(mirror)) {</span>
1343     // This call is ignored for primitive types and arrays.
1344     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1345     // be called with an array.  Only the bootstrap loader creates arrays.
<span class="line-modified">1346     Klass* k = java_lang_Class::as_Klass(mirror);</span>
1347     if (k-&gt;is_instance_klass()) {
1348       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1349     }
1350   }
1351 JVM_END
1352 
1353 
1354 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1355   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
<span class="line-modified">1356   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">1357   if (mirror == NULL) {</span>
1358     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1359   }
1360 
<span class="line-modified">1361   if (java_lang_Class::is_primitive(mirror)) {</span>
1362     // Primitive types does not have a protection domain.
1363     return NULL;
1364   }
1365 
<span class="line-modified">1366   oop pd = java_lang_Class::protection_domain(mirror);</span>
1367   return (jobject) JNIHandles::make_local(THREAD, pd);
1368 JVM_END
1369 
1370 
1371 // Returns the inherited_access_control_context field of the running thread.
1372 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1373   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1374   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1375   return JNIHandles::make_local(THREAD, result);
1376 JVM_END
1377 
1378 class RegisterArrayForGC {
1379  private:
1380   JavaThread *_thread;
1381  public:
1382   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1383     _thread = thread;
1384     _thread-&gt;register_array_for_gc(array);
1385   }
1386 
</pre>
<hr />
<pre>
1468   return JNIHandles::make_local(THREAD, result);
1469 JVM_END
1470 
1471 
1472 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1473   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1474   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1475   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1476 JVM_END
1477 
1478 
1479 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1480   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1481   oop mirror = JNIHandles::resolve_non_null(cls);
1482   return (jboolean) java_lang_Class::is_primitive(mirror);
1483 JVM_END
1484 
1485 
1486 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1487   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
<span class="line-modified">1488   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">1489   if (java_lang_Class::is_primitive(mirror)) {</span>
1490     // Primitive type
1491     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1492   }
1493 
<span class="line-modified">1494   Klass* k = java_lang_Class::as_Klass(mirror);</span>
1495   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1496   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1497   return k-&gt;modifier_flags();
1498 JVM_END
1499 
1500 
1501 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1502 
1503 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1504   JvmtiVMObjectAllocEventCollector oam;
1505   // ofClass is a reference to a java_lang_Class object. The mirror object
1506   // of an InstanceKlass
<span class="line-modified">1507   oop ofMirror = JNIHandles::resolve_non_null(ofClass);</span>
<span class="line-modified">1508   if (java_lang_Class::is_primitive(ofMirror) ||</span>
<span class="line-modified">1509       ! java_lang_Class::as_Klass(ofMirror)-&gt;is_instance_klass()) {</span>
1510     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1511     return (jobjectArray)JNIHandles::make_local(THREAD, result);
1512   }
1513 
<span class="line-modified">1514   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));</span>
1515   InnerClassesIterator iter(k);
1516 
1517   if (iter.length() == 0) {
1518     // Neither an inner nor outer class
1519     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1520     return (jobjectArray)JNIHandles::make_local(THREAD, result);
1521   }
1522 
1523   // find inner class info
1524   constantPoolHandle cp(thread, k-&gt;constants());
1525   int length = iter.length();
1526 
1527   // Allocate temp. result array
1528   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1529   objArrayHandle result (THREAD, r);
1530   int members = 0;
1531 
1532   for (; !iter.done(); iter.next()) {
1533     int ioff = iter.inner_class_info_index();
1534     int ooff = iter.outer_class_info_index();
</pre>
<hr />
<pre>
1552       }
1553     }
1554   }
1555 
1556   if (members != length) {
1557     // Return array of right length
1558     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1559     for(int i = 0; i &lt; members; i++) {
1560       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1561     }
1562     return (jobjectArray)JNIHandles::make_local(THREAD, res);
1563   }
1564 
1565   return (jobjectArray)JNIHandles::make_local(THREAD, result());
1566 JVM_END
1567 
1568 
1569 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1570 {
1571   // ofClass is a reference to a java_lang_Class object.
<span class="line-modified">1572   oop ofMirror = JNIHandles::resolve_non_null(ofClass);</span>
<span class="line-modified">1573   if (java_lang_Class::is_primitive(ofMirror)) {</span>
<span class="line-added">1574     return NULL;</span>
<span class="line-added">1575   }</span>
<span class="line-added">1576   Klass* klass = java_lang_Class::as_Klass(ofMirror);</span>
<span class="line-added">1577   if (!klass-&gt;is_instance_klass()) {</span>
1578     return NULL;
1579   }
1580 
1581   bool inner_is_member = false;
1582   Klass* outer_klass
<span class="line-modified">1583     = InstanceKlass::cast(klass)-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);</span>

1584   if (outer_klass == NULL)  return NULL;  // already a top-level class
1585   if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
1586   return (jclass) JNIHandles::make_local(THREAD, outer_klass-&gt;java_mirror());
1587 }
1588 JVM_END
1589 
1590 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1591 {
1592   oop mirror = JNIHandles::resolve_non_null(cls);
<span class="line-modified">1593   if (java_lang_Class::is_primitive(mirror)) {</span>

1594     return NULL;
1595   }
<span class="line-modified">1596   Klass* klass = java_lang_Class::as_Klass(mirror);</span>
<span class="line-added">1597   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added">1598     return NULL;</span>
<span class="line-added">1599   }</span>
<span class="line-added">1600   InstanceKlass* k = InstanceKlass::cast(klass);</span>
1601   int ooff = 0, noff = 0;
1602   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1603     if (noff != 0) {
1604       constantPoolHandle i_cp(thread, k-&gt;constants());
1605       Symbol* name = i_cp-&gt;symbol_at(noff);
1606       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1607       return (jstring) JNIHandles::make_local(THREAD, str());
1608     }
1609   }
1610   return NULL;
1611 }
1612 JVM_END
1613 
1614 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1615   assert (cls != NULL, &quot;illegal class&quot;);
1616   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1617   JvmtiVMObjectAllocEventCollector oam;
1618   ResourceMark rm(THREAD);
<span class="line-added">1619   oop mirror = JNIHandles::resolve_non_null(cls);</span>
1620   // Return null for arrays and primatives
<span class="line-modified">1621   if (!java_lang_Class::is_primitive(mirror)) {</span>
<span class="line-modified">1622     Klass* k = java_lang_Class::as_Klass(mirror);</span>
1623     if (k-&gt;is_instance_klass()) {
1624       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1625       if (sym == NULL) return NULL;
1626       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1627       return (jstring) JNIHandles::make_local(THREAD, str());
1628     }
1629   }
1630   return NULL;
1631 JVM_END
1632 
1633 
1634 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1635   assert (cls != NULL, &quot;illegal class&quot;);
1636   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
<span class="line-modified">1637   oop mirror = JNIHandles::resolve_non_null(cls);</span>
1638   // Return null for arrays and primitives
<span class="line-modified">1639   if (!java_lang_Class::is_primitive(mirror)) {</span>
<span class="line-modified">1640     Klass* k = java_lang_Class::as_Klass(mirror);</span>
1641     if (k-&gt;is_instance_klass()) {
1642       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1643       return (jbyteArray) JNIHandles::make_local(THREAD, a);
1644     }
1645   }
1646   return NULL;
1647 JVM_END
1648 
1649 
1650 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1651   // some of this code was adapted from from jni_FromReflectedField
1652 
1653   oop reflected = JNIHandles::resolve_non_null(field);
1654   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1655   Klass* k    = java_lang_Class::as_Klass(mirror);
1656   int slot      = java_lang_reflect_Field::slot(reflected);
1657   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1658 
1659   InstanceKlass* ik = InstanceKlass::cast(k);
1660   intptr_t offset = ik-&gt;field_offset(slot);
</pre>
<hr />
<pre>
1799       // For a 0 index, give a NULL symbol
1800       Symbol* sym = 0 != params[i].name_cp_index ?
1801         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1802       int flags = params[i].flags;
1803       oop param = Reflection::new_parameter(reflected_method, i, sym,
1804                                             flags, CHECK_NULL);
1805       result-&gt;obj_at_put(i, param);
1806     }
1807     return (jobjectArray)JNIHandles::make_local(THREAD, result());
1808   }
1809 }
1810 JVM_END
1811 
1812 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1813 
1814 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1815 {
1816   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1817   JvmtiVMObjectAllocEventCollector oam;
1818 
<span class="line-added">1819   oop ofMirror = JNIHandles::resolve_non_null(ofClass);</span>
1820   // Exclude primitive types and array types
<span class="line-modified">1821   if (java_lang_Class::is_primitive(ofMirror) ||</span>
<span class="line-modified">1822       java_lang_Class::as_Klass(ofMirror)-&gt;is_array_klass()) {</span>
1823     // Return empty array
1824     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1825     return (jobjectArray) JNIHandles::make_local(THREAD, res);
1826   }
1827 
<span class="line-modified">1828   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));</span>
1829   constantPoolHandle cp(THREAD, k-&gt;constants());
1830 
1831   // Ensure class is linked
1832   k-&gt;link_class(CHECK_NULL);
1833 
1834   // Allocate result
1835   int num_fields;
1836 
1837   if (publicOnly) {
1838     num_fields = 0;
1839     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1840       if (fs.access_flags().is_public()) ++num_fields;
1841     }
1842   } else {
1843     num_fields = k-&gt;java_fields_count();
1844   }
1845 
1846   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1847   objArrayHandle result (THREAD, r);
1848 
</pre>
<hr />
<pre>
1908   return (jobjectArray)JNIHandles::make_local(THREAD, result);
1909 }
1910 JVM_END
1911 
1912 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1913   if (want_constructor) {
1914     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1915   } else {
1916     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1917   }
1918 }
1919 
1920 static jobjectArray get_class_declared_methods_helper(
1921                                   JNIEnv *env,
1922                                   jclass ofClass, jboolean publicOnly,
1923                                   bool want_constructor,
1924                                   Klass* klass, TRAPS) {
1925 
1926   JvmtiVMObjectAllocEventCollector oam;
1927 
<span class="line-added">1928   oop ofMirror = JNIHandles::resolve_non_null(ofClass);</span>
1929   // Exclude primitive types and array types
<span class="line-modified">1930   if (java_lang_Class::is_primitive(ofMirror)</span>
<span class="line-modified">1931       || java_lang_Class::as_Klass(ofMirror)-&gt;is_array_klass()) {</span>
1932     // Return empty array
1933     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1934     return (jobjectArray) JNIHandles::make_local(THREAD, res);
1935   }
1936 
<span class="line-modified">1937   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));</span>
1938 
1939   // Ensure class is linked
1940   k-&gt;link_class(CHECK_NULL);
1941 
1942   Array&lt;Method*&gt;* methods = k-&gt;methods();
1943   int methods_length = methods-&gt;length();
1944 
1945   // Save original method_idnum in case of redefinition, which can change
1946   // the idnum of obsolete methods.  The new method will have the same idnum
1947   // but if we refresh the methods array, the counts will be wrong.
1948   ResourceMark rm(THREAD);
1949   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1950   int num_methods = 0;
1951 
1952   for (int i = 0; i &lt; methods_length; i++) {
1953     methodHandle method(THREAD, methods-&gt;at(i));
1954     if (select_method(method, want_constructor)) {
1955       if (!publicOnly || method-&gt;is_public()) {
1956         idnums-&gt;push(method-&gt;method_idnum());
1957         ++num_methods;
</pre>
<hr />
<pre>
1991 {
1992   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1993   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1994                                            /*want_constructor*/ false,
1995                                            SystemDictionary::reflect_Method_klass(), THREAD);
1996 }
1997 JVM_END
1998 
1999 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2000 {
2001   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
2002   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2003                                            /*want_constructor*/ true,
2004                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
2005 }
2006 JVM_END
2007 
2008 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
2009 {
2010   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
<span class="line-modified">2011   oop mirror = JNIHandles::resolve_non_null(cls);</span>
<span class="line-added">2012   if (java_lang_Class::is_primitive(mirror)) {</span>
2013     // Primitive type
2014     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
2015   }
2016 
<span class="line-modified">2017   Klass* k = java_lang_Class::as_Klass(mirror);</span>
2018   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
2019 }
2020 JVM_END
2021 
2022 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
2023 {
2024   JVMWrapper(&quot;JVM_AreNestMates&quot;);
2025   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2026   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2027   InstanceKlass* ck = InstanceKlass::cast(c);
2028   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
2029   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
2030   InstanceKlass* mk = InstanceKlass::cast(m);
2031   return ck-&gt;has_nestmate_access_to(mk, THREAD);
2032 }
2033 JVM_END
2034 
2035 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
2036 {
2037   // current is not a primitive or array class
</pre>
<hr />
<pre>
2112         objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2113                                                   count + 1, CHECK_NULL);
2114         objArrayHandle result2(THREAD, r2);
2115         for (int i = 0; i &lt; count + 1; i++) {
2116           result2-&gt;obj_at_put(i, result-&gt;obj_at(i));
2117         }
2118         return (jobjectArray)JNIHandles::make_local(THREAD, result2());
2119       }
2120     }
2121     else {
2122       assert(host == ck || ck-&gt;is_hidden(), &quot;must be singleton nest or dynamic nestmate&quot;);
2123     }
2124     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2125   }
2126 }
2127 JVM_END
2128 
2129 JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))
2130 {
2131   JVMWrapper(&quot;JVM_GetPermittedSubclasses&quot;);
<span class="line-modified">2132   oop mirror = JNIHandles::resolve_non_null(current);</span>
<span class="line-modified">2133   assert(!java_lang_Class::is_primitive(mirror), &quot;should not be&quot;);</span>
<span class="line-added">2134   Klass* c = java_lang_Class::as_Klass(mirror);</span>
2135   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2136   InstanceKlass* ik = InstanceKlass::cast(c);
2137   {
2138     JvmtiVMObjectAllocEventCollector oam;
2139     Array&lt;u2&gt;* subclasses = ik-&gt;permitted_subclasses();
2140     int length = subclasses == NULL ? 0 : subclasses-&gt;length();
2141     objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
2142                                              length, CHECK_NULL);
2143     objArrayHandle result(THREAD, r);
2144     for (int i = 0; i &lt; length; i++) {
2145       int cp_index = subclasses-&gt;at(i);
2146       // This returns &lt;package-name&gt;/&lt;class-name&gt;.
2147       Symbol* klass_name = ik-&gt;constants()-&gt;klass_name_at(cp_index);
2148       assert(klass_name != NULL, &quot;Unexpected null klass_name&quot;);
2149       Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2150       result-&gt;obj_at_put(i, perm_subtype_h());
2151     }
2152     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2153   }
2154 }
2155 JVM_END
2156 
2157 // Constant pool access //////////////////////////////////////////////////////////
2158 
2159 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
2160 {
2161   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
2162   JvmtiVMObjectAllocEventCollector oam;
<span class="line-modified">2163   oop mirror = JNIHandles::resolve_non_null(cls);</span>
2164   // Return null for primitives and arrays
<span class="line-modified">2165   if (!java_lang_Class::is_primitive(mirror)) {</span>
<span class="line-modified">2166     Klass* k = java_lang_Class::as_Klass(mirror);</span>
2167     if (k-&gt;is_instance_klass()) {
2168       InstanceKlass* k_h = InstanceKlass::cast(k);
2169       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
2170       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
2171       return JNIHandles::make_local(THREAD, jcp());
2172     }
2173   }
2174   return NULL;
2175 }
2176 JVM_END
2177 
2178 
2179 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
2180 {
2181   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
2182   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2183   return cp-&gt;length();
2184 }
2185 JVM_END
2186 
</pre>
</td>
</tr>
</table>
<center><a href="jni.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnter.xsl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>