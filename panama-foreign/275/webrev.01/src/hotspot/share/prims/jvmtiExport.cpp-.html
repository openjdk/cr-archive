<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jvmtiExport.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/moduleEntry.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;code/nmethod.hpp&quot;
  30 #include &quot;code/pcDesc.hpp&quot;
  31 #include &quot;code/scopeDesc.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;logging/logStream.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/oopHandle.inline.hpp&quot;
  43 #include &quot;prims/jvmtiCodeBlobEvents.hpp&quot;
  44 #include &quot;prims/jvmtiEventController.hpp&quot;
  45 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  46 #include &quot;prims/jvmtiExport.hpp&quot;
  47 #include &quot;prims/jvmtiImpl.hpp&quot;
  48 #include &quot;prims/jvmtiManageCapabilities.hpp&quot;
  49 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
  50 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  51 #include &quot;prims/jvmtiTagMap.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  53 #include &quot;runtime/arguments.hpp&quot;
  54 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  57 #include &quot;runtime/javaCalls.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/objectMonitor.hpp&quot;
  60 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  61 #include &quot;runtime/os.inline.hpp&quot;
  62 #include &quot;runtime/safepointVerifiers.hpp&quot;
  63 #include &quot;runtime/serviceThread.hpp&quot;
  64 #include &quot;runtime/thread.inline.hpp&quot;
  65 #include &quot;runtime/threadSMR.hpp&quot;
  66 #include &quot;runtime/vframe.inline.hpp&quot;
  67 #include &quot;utilities/macros.hpp&quot;
  68 
  69 #ifdef JVMTI_TRACE
  70 #define EVT_TRACE(evt,out) if ((JvmtiTrace::event_trace_flags(evt) &amp; JvmtiTrace::SHOW_EVENT_SENT) != 0) { SafeResourceMark rm; log_trace(jvmti) out; }
  71 #define EVT_TRIG_TRACE(evt,out) if ((JvmtiTrace::event_trace_flags(evt) &amp; JvmtiTrace::SHOW_EVENT_TRIGGER) != 0) { SafeResourceMark rm; log_trace(jvmti) out; }
  72 #else
  73 #define EVT_TRIG_TRACE(evt,out)
  74 #define EVT_TRACE(evt,out)
  75 #endif
  76 
  77 ///////////////////////////////////////////////////////////////
  78 //
  79 // JvmtiEventTransition
  80 //
  81 // TO DO --
  82 //  more handle purging
  83 
  84 // Use this for JavaThreads and state is  _thread_in_vm.
  85 class JvmtiJavaThreadEventTransition : StackObj {
  86 private:
  87   ResourceMark _rm;
  88   ThreadToNativeFromVM _transition;
  89   HandleMark _hm;
  90 
  91 public:
  92   JvmtiJavaThreadEventTransition(JavaThread *thread) :
  93     _rm(),
  94     _transition(thread),
  95     _hm(thread)  {};
  96 };
  97 
  98 // For JavaThreads which are not in _thread_in_vm state
  99 // and other system threads use this.
 100 class JvmtiThreadEventTransition : StackObj {
 101 private:
 102   ResourceMark _rm;
 103   HandleMark _hm;
 104   JavaThreadState _saved_state;
 105   JavaThread *_jthread;
 106 
 107 public:
 108   JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm() {
 109     if (thread-&gt;is_Java_thread()) {
 110        _jthread = (JavaThread *)thread;
 111        _saved_state = _jthread-&gt;thread_state();
 112        if (_saved_state == _thread_in_Java) {
 113          ThreadStateTransition::transition_from_java(_jthread, _thread_in_native);
 114        } else {
 115          ThreadStateTransition::transition(_jthread, _saved_state, _thread_in_native);
 116        }
 117     } else {
 118       _jthread = NULL;
 119     }
 120   }
 121 
 122   ~JvmtiThreadEventTransition() {
 123     if (_jthread != NULL)
 124       ThreadStateTransition::transition_from_native(_jthread, _saved_state);
 125   }
 126 };
 127 
 128 
 129 ///////////////////////////////////////////////////////////////
 130 //
 131 // JvmtiEventMark
 132 //
 133 
 134 class JvmtiEventMark : public StackObj {
 135 private:
 136   JavaThread *_thread;
 137   JNIEnv* _jni_env;
 138   JvmtiThreadState::ExceptionState _saved_exception_state;
 139 #if 0
 140   JNIHandleBlock* _hblock;
 141 #endif
 142 
 143 public:
 144   JvmtiEventMark(JavaThread *thread) :  _thread(thread),
 145                                         _jni_env(thread-&gt;jni_environment()),
 146                                         _saved_exception_state(JvmtiThreadState::ES_CLEARED) {
 147 #if 0
 148     _hblock = thread-&gt;active_handles();
 149     _hblock-&gt;clear_thoroughly(); // so we can be safe
 150 #else
 151     // we want to use the code above - but that needs the JNIHandle changes - later...
 152     // for now, steal JNI push local frame code
 153     JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
 154     // we are before an event.
 155     // Save current jvmti thread exception state.
 156     if (state != NULL) {
 157       _saved_exception_state = state-&gt;get_exception_state();
 158     }
 159 
 160     JNIHandleBlock* old_handles = thread-&gt;active_handles();
 161     JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 162     assert(new_handles != NULL, &quot;should not be NULL&quot;);
 163     new_handles-&gt;set_pop_frame_link(old_handles);
 164     thread-&gt;set_active_handles(new_handles);
 165 #endif
 166     assert(thread == JavaThread::current(), &quot;thread must be current!&quot;);
 167     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
 168   };
 169 
 170   ~JvmtiEventMark() {
 171 #if 0
 172     _hblock-&gt;clear(); // for consistency with future correct behavior
 173 #else
 174     // we want to use the code above - but that needs the JNIHandle changes - later...
 175     // for now, steal JNI pop local frame code
 176     JNIHandleBlock* old_handles = _thread-&gt;active_handles();
 177     JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 178     assert(new_handles != NULL, &quot;should not be NULL&quot;);
 179     _thread-&gt;set_active_handles(new_handles);
 180     // Note that we set the pop_frame_link to NULL explicitly, otherwise
 181     // the release_block call will release the blocks.
 182     old_handles-&gt;set_pop_frame_link(NULL);
 183     JNIHandleBlock::release_block(old_handles, _thread); // may block
 184 #endif
 185 
 186     JvmtiThreadState* state = _thread-&gt;jvmti_thread_state();
 187     // we are continuing after an event.
 188     if (state != NULL) {
 189       // Restore the jvmti thread exception state.
 190       state-&gt;restore_exception_state(_saved_exception_state);
 191     }
 192   }
 193 
 194 #if 0
 195   jobject to_jobject(oop obj) { return obj == NULL? NULL : _hblock-&gt;allocate_handle_fast(obj); }
 196 #else
 197   // we want to use the code above - but that needs the JNIHandle changes - later...
 198   // for now, use regular make_local
 199   jobject to_jobject(oop obj) { return JNIHandles::make_local(_thread,obj); }
 200 #endif
 201 
 202   jclass to_jclass(Klass* klass) { return (klass == NULL ? NULL : (jclass)to_jobject(klass-&gt;java_mirror())); }
 203 
 204   jmethodID to_jmethodID(const methodHandle&amp; method) { return method-&gt;jmethod_id(); }
 205 
 206   JNIEnv* jni_env() { return _jni_env; }
 207 };
 208 
 209 class JvmtiThreadEventMark : public JvmtiEventMark {
 210 private:
 211   jthread _jt;
 212 
 213 public:
 214   JvmtiThreadEventMark(JavaThread *thread) :
 215     JvmtiEventMark(thread) {
 216     _jt = (jthread)(to_jobject(thread-&gt;threadObj()));
 217   };
 218  jthread jni_thread() { return _jt; }
 219 };
 220 
 221 class JvmtiClassEventMark : public JvmtiThreadEventMark {
 222 private:
 223   jclass _jc;
 224 
 225 public:
 226   JvmtiClassEventMark(JavaThread *thread, Klass* klass) :
 227     JvmtiThreadEventMark(thread) {
 228     _jc = to_jclass(klass);
 229   };
 230   jclass jni_class() { return _jc; }
 231 };
 232 
 233 class JvmtiMethodEventMark : public JvmtiThreadEventMark {
 234 private:
 235   jmethodID _mid;
 236 
 237 public:
 238   JvmtiMethodEventMark(JavaThread *thread, const methodHandle&amp; method) :
 239     JvmtiThreadEventMark(thread),
 240     _mid(to_jmethodID(method)) {};
 241   jmethodID jni_methodID() { return _mid; }
 242 };
 243 
 244 class JvmtiLocationEventMark : public JvmtiMethodEventMark {
 245 private:
 246   jlocation _loc;
 247 
 248 public:
 249   JvmtiLocationEventMark(JavaThread *thread, const methodHandle&amp; method, address location) :
 250     JvmtiMethodEventMark(thread, method),
 251     _loc(location - method-&gt;code_base()) {};
 252   jlocation location() { return _loc; }
 253 };
 254 
 255 class JvmtiExceptionEventMark : public JvmtiLocationEventMark {
 256 private:
 257   jobject _exc;
 258 
 259 public:
 260   JvmtiExceptionEventMark(JavaThread *thread, const methodHandle&amp; method, address location, Handle exception) :
 261     JvmtiLocationEventMark(thread, method, location),
 262     _exc(to_jobject(exception())) {};
 263   jobject exception() { return _exc; }
 264 };
 265 
 266 class JvmtiClassFileLoadEventMark : public JvmtiThreadEventMark {
 267 private:
 268   const char *_class_name;
 269   jobject _jloader;
 270   jobject _protection_domain;
 271   jclass  _class_being_redefined;
 272 
 273 public:
 274   JvmtiClassFileLoadEventMark(JavaThread *thread, Symbol* name,
 275      Handle class_loader, Handle prot_domain, Klass* class_being_redefined) : JvmtiThreadEventMark(thread) {
 276       _class_name = name != NULL? name-&gt;as_utf8() : NULL;
 277       _jloader = (jobject)to_jobject(class_loader());
 278       _protection_domain = (jobject)to_jobject(prot_domain());
 279       if (class_being_redefined == NULL) {
 280         _class_being_redefined = NULL;
 281       } else {
 282         _class_being_redefined = (jclass)to_jclass(class_being_redefined);
 283       }
 284   };
 285   const char *class_name() {
 286     return _class_name;
 287   }
 288   jobject jloader() {
 289     return _jloader;
 290   }
 291   jobject protection_domain() {
 292     return _protection_domain;
 293   }
 294   jclass class_being_redefined() {
 295     return _class_being_redefined;
 296   }
 297 };
 298 
 299 //////////////////////////////////////////////////////////////////////////////
 300 
 301 int               JvmtiExport::_field_access_count                        = 0;
 302 int               JvmtiExport::_field_modification_count                  = 0;
 303 
 304 bool              JvmtiExport::_can_access_local_variables                = false;
 305 bool              JvmtiExport::_can_hotswap_or_post_breakpoint            = false;
 306 bool              JvmtiExport::_can_modify_any_class                      = false;
 307 bool              JvmtiExport::_can_walk_any_space                        = false;
 308 
 309 uint64_t          JvmtiExport::_redefinition_count                        = 0;
 310 bool              JvmtiExport::_all_dependencies_are_recorded             = false;
 311 
 312 //
 313 // field access management
 314 //
 315 
 316 // interpreter generator needs the address of the counter
 317 address JvmtiExport::get_field_access_count_addr() {
 318   // We don&#39;t grab a lock because we don&#39;t want to
 319   // serialize field access between all threads. This means that a
 320   // thread on another processor can see the wrong count value and
 321   // may either miss making a needed call into post_field_access()
 322   // or will make an unneeded call into post_field_access(). We pay
 323   // this price to avoid slowing down the VM when we aren&#39;t watching
 324   // field accesses.
 325   // Other access/mutation safe by virtue of being in VM state.
 326   return (address)(&amp;_field_access_count);
 327 }
 328 
 329 //
 330 // field modification management
 331 //
 332 
 333 // interpreter generator needs the address of the counter
 334 address JvmtiExport::get_field_modification_count_addr() {
 335   // We don&#39;t grab a lock because we don&#39;t
 336   // want to serialize field modification between all threads. This
 337   // means that a thread on another processor can see the wrong
 338   // count value and may either miss making a needed call into
 339   // post_field_modification() or will make an unneeded call into
 340   // post_field_modification(). We pay this price to avoid slowing
 341   // down the VM when we aren&#39;t watching field modifications.
 342   // Other access/mutation safe by virtue of being in VM state.
 343   return (address)(&amp;_field_modification_count);
 344 }
 345 
 346 
 347 ///////////////////////////////////////////////////////////////
 348 // Functions needed by java.lang.instrument for starting up javaagent.
 349 ///////////////////////////////////////////////////////////////
 350 
 351 jint
 352 JvmtiExport::get_jvmti_interface(JavaVM *jvm, void **penv, jint version) {
 353   // The JVMTI_VERSION_INTERFACE_JVMTI part of the version number
 354   // has already been validated in JNI GetEnv().
 355   int major, minor, micro;
 356 
 357   // micro version doesn&#39;t matter here (yet?)
 358   decode_version_values(version, &amp;major, &amp;minor, &amp;micro);
 359   switch (major) {
 360     case 1:
 361       switch (minor) {
 362         case 0:  // version 1.0.&lt;micro&gt; is recognized
 363         case 1:  // version 1.1.&lt;micro&gt; is recognized
 364         case 2:  // version 1.2.&lt;micro&gt; is recognized
 365           break;
 366 
 367         default:
 368           return JNI_EVERSION;  // unsupported minor version number
 369       }
 370       break;
 371     case 9:
 372       switch (minor) {
 373         case 0:  // version 9.0.&lt;micro&gt; is recognized
 374           break;
 375         default:
 376           return JNI_EVERSION;  // unsupported minor version number
 377       }
 378       break;
 379     case 11:
 380       switch (minor) {
 381         case 0:  // version 11.0.&lt;micro&gt; is recognized
 382           break;
 383         default:
 384           return JNI_EVERSION;  // unsupported minor version number
 385       }
 386       break;
 387     default:
 388       // Starting from 13 we do not care about minor version anymore
 389       if (major &lt; 13 || major &gt; Abstract_VM_Version::vm_major_version()) {
 390         return JNI_EVERSION;  // unsupported major version number
 391       }
 392   }
 393 
 394   if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {
 395     JavaThread* current_thread = JavaThread::current();
 396     // transition code: native to VM
 397     ThreadInVMfromNative __tiv(current_thread);
 398     VM_ENTRY_BASE(jvmtiEnv*, JvmtiExport::get_jvmti_interface, current_thread)
 399     debug_only(VMNativeEntryWrapper __vew;)
 400 
 401     JvmtiEnv *jvmti_env = JvmtiEnv::create_a_jvmti(version);
 402     *penv = jvmti_env-&gt;jvmti_external();  // actual type is jvmtiEnv* -- not to be confused with JvmtiEnv*
 403     return JNI_OK;
 404 
 405   } else if (JvmtiEnv::get_phase() == JVMTI_PHASE_ONLOAD) {
 406     // not live, no thread to transition
 407     JvmtiEnv *jvmti_env = JvmtiEnv::create_a_jvmti(version);
 408     *penv = jvmti_env-&gt;jvmti_external();  // actual type is jvmtiEnv* -- not to be confused with JvmtiEnv*
 409     return JNI_OK;
 410 
 411   } else {
 412     // Called at the wrong time
 413     *penv = NULL;
 414     return JNI_EDETACHED;
 415   }
 416 }
 417 
 418 void
 419 JvmtiExport::add_default_read_edges(Handle h_module, TRAPS) {
 420   if (!Universe::is_module_initialized()) {
 421     return; // extra safety
 422   }
 423   assert(!h_module.is_null(), &quot;module should always be set&quot;);
 424 
 425   // Invoke the transformedByAgent method
 426   JavaValue result(T_VOID);
 427   JavaCalls::call_static(&amp;result,
 428                          SystemDictionary::module_Modules_klass(),
 429                          vmSymbols::transformedByAgent_name(),
 430                          vmSymbols::transformedByAgent_signature(),
 431                          h_module,
 432                          THREAD);
 433 
 434   if (HAS_PENDING_EXCEPTION) {
 435     LogTarget(Trace, jvmti) log;
 436     LogStream log_stream(log);
 437     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 438     log_stream.cr();
 439     CLEAR_PENDING_EXCEPTION;
 440     return;
 441   }
 442 }
 443 
 444 jvmtiError
 445 JvmtiExport::add_module_reads(Handle module, Handle to_module, TRAPS) {
 446   if (!Universe::is_module_initialized()) {
 447     return JVMTI_ERROR_NONE; // extra safety
 448   }
 449   assert(!module.is_null(), &quot;module should always be set&quot;);
 450   assert(!to_module.is_null(), &quot;to_module should always be set&quot;);
 451 
 452   // Invoke the addReads method
 453   JavaValue result(T_VOID);
 454   JavaCalls::call_static(&amp;result,
 455                          SystemDictionary::module_Modules_klass(),
 456                          vmSymbols::addReads_name(),
 457                          vmSymbols::addReads_signature(),
 458                          module,
 459                          to_module,
 460                          THREAD);
 461 
 462   if (HAS_PENDING_EXCEPTION) {
 463     LogTarget(Trace, jvmti) log;
 464     LogStream log_stream(log);
 465     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 466     log_stream.cr();
 467     CLEAR_PENDING_EXCEPTION;
 468     return JVMTI_ERROR_INTERNAL;
 469   }
 470   return JVMTI_ERROR_NONE;
 471 }
 472 
 473 jvmtiError
 474 JvmtiExport::add_module_exports(Handle module, Handle pkg_name, Handle to_module, TRAPS) {
 475   if (!Universe::is_module_initialized()) {
 476     return JVMTI_ERROR_NONE; // extra safety
 477   }
 478   assert(!module.is_null(), &quot;module should always be set&quot;);
 479   assert(!to_module.is_null(), &quot;to_module should always be set&quot;);
 480   assert(!pkg_name.is_null(), &quot;pkg_name should always be set&quot;);
 481 
 482   // Invoke the addExports method
 483   JavaValue result(T_VOID);
 484   JavaCalls::call_static(&amp;result,
 485                          SystemDictionary::module_Modules_klass(),
 486                          vmSymbols::addExports_name(),
 487                          vmSymbols::addExports_signature(),
 488                          module,
 489                          pkg_name,
 490                          to_module,
 491                          THREAD);
 492 
 493   if (HAS_PENDING_EXCEPTION) {
 494     Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 495     LogTarget(Trace, jvmti) log;
 496     LogStream log_stream(log);
 497     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 498     log_stream.cr();
 499     CLEAR_PENDING_EXCEPTION;
 500     if (ex_name == vmSymbols::java_lang_IllegalArgumentException()) {
 501       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 502     }
 503     return JVMTI_ERROR_INTERNAL;
 504   }
 505   return JVMTI_ERROR_NONE;
 506 }
 507 
 508 jvmtiError
 509 JvmtiExport::add_module_opens(Handle module, Handle pkg_name, Handle to_module, TRAPS) {
 510   if (!Universe::is_module_initialized()) {
 511     return JVMTI_ERROR_NONE; // extra safety
 512   }
 513   assert(!module.is_null(), &quot;module should always be set&quot;);
 514   assert(!to_module.is_null(), &quot;to_module should always be set&quot;);
 515   assert(!pkg_name.is_null(), &quot;pkg_name should always be set&quot;);
 516 
 517   // Invoke the addOpens method
 518   JavaValue result(T_VOID);
 519   JavaCalls::call_static(&amp;result,
 520                          SystemDictionary::module_Modules_klass(),
 521                          vmSymbols::addOpens_name(),
 522                          vmSymbols::addExports_signature(),
 523                          module,
 524                          pkg_name,
 525                          to_module,
 526                          THREAD);
 527 
 528   if (HAS_PENDING_EXCEPTION) {
 529     Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 530     LogTarget(Trace, jvmti) log;
 531     LogStream log_stream(log);
 532     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 533     log_stream.cr();
 534     CLEAR_PENDING_EXCEPTION;
 535     if (ex_name == vmSymbols::java_lang_IllegalArgumentException()) {
 536       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
 537     }
 538     return JVMTI_ERROR_INTERNAL;
 539   }
 540   return JVMTI_ERROR_NONE;
 541 }
 542 
 543 jvmtiError
 544 JvmtiExport::add_module_uses(Handle module, Handle service, TRAPS) {
 545   if (!Universe::is_module_initialized()) {
 546     return JVMTI_ERROR_NONE; // extra safety
 547   }
 548   assert(!module.is_null(), &quot;module should always be set&quot;);
 549   assert(!service.is_null(), &quot;service should always be set&quot;);
 550 
 551   // Invoke the addUses method
 552   JavaValue result(T_VOID);
 553   JavaCalls::call_static(&amp;result,
 554                          SystemDictionary::module_Modules_klass(),
 555                          vmSymbols::addUses_name(),
 556                          vmSymbols::addUses_signature(),
 557                          module,
 558                          service,
 559                          THREAD);
 560 
 561   if (HAS_PENDING_EXCEPTION) {
 562     LogTarget(Trace, jvmti) log;
 563     LogStream log_stream(log);
 564     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 565     log_stream.cr();
 566     CLEAR_PENDING_EXCEPTION;
 567     return JVMTI_ERROR_INTERNAL;
 568   }
 569   return JVMTI_ERROR_NONE;
 570 }
 571 
 572 jvmtiError
 573 JvmtiExport::add_module_provides(Handle module, Handle service, Handle impl_class, TRAPS) {
 574   if (!Universe::is_module_initialized()) {
 575     return JVMTI_ERROR_NONE; // extra safety
 576   }
 577   assert(!module.is_null(), &quot;module should always be set&quot;);
 578   assert(!service.is_null(), &quot;service should always be set&quot;);
 579   assert(!impl_class.is_null(), &quot;impl_class should always be set&quot;);
 580 
 581   // Invoke the addProvides method
 582   JavaValue result(T_VOID);
 583   JavaCalls::call_static(&amp;result,
 584                          SystemDictionary::module_Modules_klass(),
 585                          vmSymbols::addProvides_name(),
 586                          vmSymbols::addProvides_signature(),
 587                          module,
 588                          service,
 589                          impl_class,
 590                          THREAD);
 591 
 592   if (HAS_PENDING_EXCEPTION) {
 593     LogTarget(Trace, jvmti) log;
 594     LogStream log_stream(log);
 595     java_lang_Throwable::print(PENDING_EXCEPTION, &amp;log_stream);
 596     log_stream.cr();
 597     CLEAR_PENDING_EXCEPTION;
 598     return JVMTI_ERROR_INTERNAL;
 599   }
 600   return JVMTI_ERROR_NONE;
 601 }
 602 
 603 void
 604 JvmtiExport::decode_version_values(jint version, int * major, int * minor,
 605                                    int * micro) {
 606   *major = (version &amp; JVMTI_VERSION_MASK_MAJOR) &gt;&gt; JVMTI_VERSION_SHIFT_MAJOR;
 607   *minor = (version &amp; JVMTI_VERSION_MASK_MINOR) &gt;&gt; JVMTI_VERSION_SHIFT_MINOR;
 608   *micro = (version &amp; JVMTI_VERSION_MASK_MICRO) &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 609 }
 610 
 611 void JvmtiExport::enter_primordial_phase() {
 612   JvmtiEnvBase::set_phase(JVMTI_PHASE_PRIMORDIAL);
 613 }
 614 
 615 void JvmtiExport::enter_early_start_phase() {
 616   set_early_vmstart_recorded(true);
 617 }
 618 
 619 void JvmtiExport::enter_start_phase() {
 620   JvmtiEnvBase::set_phase(JVMTI_PHASE_START);
 621 }
 622 
 623 void JvmtiExport::enter_onload_phase() {
 624   JvmtiEnvBase::set_phase(JVMTI_PHASE_ONLOAD);
 625 }
 626 
 627 void JvmtiExport::enter_live_phase() {
 628   JvmtiEnvBase::set_phase(JVMTI_PHASE_LIVE);
 629 }
 630 
 631 //
 632 // JVMTI events that the VM posts to the debugger and also startup agent
 633 // and call the agent&#39;s premain() for java.lang.instrument.
 634 //
 635 
 636 void JvmtiExport::post_early_vm_start() {
 637   EVT_TRIG_TRACE(JVMTI_EVENT_VM_START, (&quot;Trg Early VM start event triggered&quot; ));
 638 
 639   // can now enable some events
 640   JvmtiEventController::vm_start();
 641 
 642   JvmtiEnvIterator it;
 643   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 644     // Only early vmstart envs post early VMStart event
 645     if (env-&gt;early_vmstart_env() &amp;&amp; env-&gt;is_enabled(JVMTI_EVENT_VM_START)) {
 646       EVT_TRACE(JVMTI_EVENT_VM_START, (&quot;Evt Early VM start event sent&quot; ));
 647       JavaThread *thread  = JavaThread::current();
 648       JvmtiThreadEventMark jem(thread);
 649       JvmtiJavaThreadEventTransition jet(thread);
 650       jvmtiEventVMStart callback = env-&gt;callbacks()-&gt;VMStart;
 651       if (callback != NULL) {
 652         (*callback)(env-&gt;jvmti_external(), jem.jni_env());
 653       }
 654     }
 655   }
 656 }
 657 
 658 void JvmtiExport::post_vm_start() {
 659   EVT_TRIG_TRACE(JVMTI_EVENT_VM_START, (&quot;Trg VM start event triggered&quot; ));
 660 
 661   // can now enable some events
 662   JvmtiEventController::vm_start();
 663 
 664   JvmtiEnvIterator it;
 665   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 666     // Early vmstart envs do not post normal VMStart event
 667     if (!env-&gt;early_vmstart_env() &amp;&amp; env-&gt;is_enabled(JVMTI_EVENT_VM_START)) {
 668       EVT_TRACE(JVMTI_EVENT_VM_START, (&quot;Evt VM start event sent&quot; ));
 669 
 670       JavaThread *thread  = JavaThread::current();
 671       JvmtiThreadEventMark jem(thread);
 672       JvmtiJavaThreadEventTransition jet(thread);
 673       jvmtiEventVMStart callback = env-&gt;callbacks()-&gt;VMStart;
 674       if (callback != NULL) {
 675         (*callback)(env-&gt;jvmti_external(), jem.jni_env());
 676       }
 677     }
 678   }
 679 }
 680 
 681 
 682 void JvmtiExport::post_vm_initialized() {
 683   EVT_TRIG_TRACE(JVMTI_EVENT_VM_INIT, (&quot;Trg VM init event triggered&quot; ));
 684 
 685   // can now enable events
 686   JvmtiEventController::vm_init();
 687 
 688   JvmtiEnvIterator it;
 689   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 690     if (env-&gt;is_enabled(JVMTI_EVENT_VM_INIT)) {
 691       EVT_TRACE(JVMTI_EVENT_VM_INIT, (&quot;Evt VM init event sent&quot; ));
 692 
 693       JavaThread *thread  = JavaThread::current();
 694       JvmtiThreadEventMark jem(thread);
 695       JvmtiJavaThreadEventTransition jet(thread);
 696       jvmtiEventVMInit callback = env-&gt;callbacks()-&gt;VMInit;
 697       if (callback != NULL) {
 698         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread());
 699       }
 700     }
 701   }
 702 }
 703 
 704 
 705 void JvmtiExport::post_vm_death() {
 706   EVT_TRIG_TRACE(JVMTI_EVENT_VM_DEATH, (&quot;Trg VM death event triggered&quot; ));
 707 
 708   JvmtiEnvIterator it;
 709   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 710     if (env-&gt;is_enabled(JVMTI_EVENT_VM_DEATH)) {
 711       EVT_TRACE(JVMTI_EVENT_VM_DEATH, (&quot;Evt VM death event sent&quot; ));
 712 
 713       JavaThread *thread  = JavaThread::current();
 714       JvmtiEventMark jem(thread);
 715       JvmtiJavaThreadEventTransition jet(thread);
 716       jvmtiEventVMDeath callback = env-&gt;callbacks()-&gt;VMDeath;
 717       if (callback != NULL) {
 718         (*callback)(env-&gt;jvmti_external(), jem.jni_env());
 719       }
 720     }
 721   }
 722 
 723   JvmtiEnvBase::set_phase(JVMTI_PHASE_DEAD);
 724   JvmtiEventController::vm_death();
 725 }
 726 
 727 char**
 728 JvmtiExport::get_all_native_method_prefixes(int* count_ptr) {
 729   // Have to grab JVMTI thread state lock to be sure environment doesn&#39;t
 730   // go away while we iterate them.  No locks during VM bring-up.
 731   if (Threads::number_of_threads() == 0 || SafepointSynchronize::is_at_safepoint()) {
 732     return JvmtiEnvBase::get_all_native_method_prefixes(count_ptr);
 733   } else {
 734     MutexLocker mu(JvmtiThreadState_lock);
 735     return JvmtiEnvBase::get_all_native_method_prefixes(count_ptr);
 736   }
 737 }
 738 
 739 // Convert an external thread reference to a JavaThread found on the
 740 // specified ThreadsList. The ThreadsListHandle in the caller &quot;protects&quot;
 741 // the returned JavaThread *.
 742 //
 743 // If thread_oop_p is not NULL, then the caller wants to use the oop
 744 // after this call so the oop is returned. On success, *jt_pp is set
 745 // to the converted JavaThread * and JVMTI_ERROR_NONE is returned.
 746 // On error, returns various JVMTI_ERROR_* values.
 747 //
 748 jvmtiError
 749 JvmtiExport::cv_external_thread_to_JavaThread(ThreadsList * t_list,
 750                                               jthread thread,
 751                                               JavaThread ** jt_pp,
 752                                               oop * thread_oop_p) {
 753   assert(t_list != NULL, &quot;must have a ThreadsList&quot;);
 754   assert(jt_pp != NULL, &quot;must have a return JavaThread pointer&quot;);
 755   // thread_oop_p is optional so no assert()
 756 
 757   oop thread_oop = JNIHandles::resolve_external_guard(thread);
 758   if (thread_oop == NULL) {
 759     // NULL jthread, GC&#39;ed jthread or a bad JNI handle.
 760     return JVMTI_ERROR_INVALID_THREAD;
 761   }
 762   // Looks like an oop at this point.
 763 
 764   if (!thread_oop-&gt;is_a(SystemDictionary::Thread_klass())) {
 765     // The oop is not a java.lang.Thread.
 766     return JVMTI_ERROR_INVALID_THREAD;
 767   }
 768   // Looks like a java.lang.Thread oop at this point.
 769 
 770   if (thread_oop_p != NULL) {
 771     // Return the oop to the caller; the caller may still want
 772     // the oop even if this function returns an error.
 773     *thread_oop_p = thread_oop;
 774   }
 775 
 776   JavaThread * java_thread = java_lang_Thread::thread(thread_oop);
 777   if (java_thread == NULL) {
 778     // The java.lang.Thread does not contain a JavaThread * so it has
 779     // not yet run or it has died.
 780     return JVMTI_ERROR_THREAD_NOT_ALIVE;
 781   }
 782   // Looks like a live JavaThread at this point.
 783 
 784   // We do not check the EnableThreadSMRExtraValidityChecks option
 785   // for this includes() call because JVM/TI&#39;s spec is tighter.
 786   if (!t_list-&gt;includes(java_thread)) {
 787     // Not on the JavaThreads list so it is not alive.
 788     return JVMTI_ERROR_THREAD_NOT_ALIVE;
 789   }
 790 
 791   // Return a live JavaThread that is &quot;protected&quot; by the
 792   // ThreadsListHandle in the caller.
 793   *jt_pp = java_thread;
 794 
 795   return JVMTI_ERROR_NONE;
 796 }
 797 
 798 // Convert an oop to a JavaThread found on the specified ThreadsList.
 799 // The ThreadsListHandle in the caller &quot;protects&quot; the returned
 800 // JavaThread *.
 801 //
 802 // On success, *jt_pp is set to the converted JavaThread * and
 803 // JVMTI_ERROR_NONE is returned. On error, returns various
 804 // JVMTI_ERROR_* values.
 805 //
 806 jvmtiError
 807 JvmtiExport::cv_oop_to_JavaThread(ThreadsList * t_list, oop thread_oop,
 808                                   JavaThread ** jt_pp) {
 809   assert(t_list != NULL, &quot;must have a ThreadsList&quot;);
 810   assert(thread_oop != NULL, &quot;must have an oop&quot;);
 811   assert(jt_pp != NULL, &quot;must have a return JavaThread pointer&quot;);
 812 
 813   if (!thread_oop-&gt;is_a(SystemDictionary::Thread_klass())) {
 814     // The oop is not a java.lang.Thread.
 815     return JVMTI_ERROR_INVALID_THREAD;
 816   }
 817   // Looks like a java.lang.Thread oop at this point.
 818 
 819   JavaThread * java_thread = java_lang_Thread::thread(thread_oop);
 820   if (java_thread == NULL) {
 821     // The java.lang.Thread does not contain a JavaThread * so it has
 822     // not yet run or it has died.
 823     return JVMTI_ERROR_THREAD_NOT_ALIVE;
 824   }
 825   // Looks like a live JavaThread at this point.
 826 
 827   // We do not check the EnableThreadSMRExtraValidityChecks option
 828   // for this includes() call because JVM/TI&#39;s spec is tighter.
 829   if (!t_list-&gt;includes(java_thread)) {
 830     // Not on the JavaThreads list so it is not alive.
 831     return JVMTI_ERROR_THREAD_NOT_ALIVE;
 832   }
 833 
 834   // Return a live JavaThread that is &quot;protected&quot; by the
 835   // ThreadsListHandle in the caller.
 836   *jt_pp = java_thread;
 837 
 838   return JVMTI_ERROR_NONE;
 839 }
 840 
 841 class JvmtiClassFileLoadHookPoster : public StackObj {
 842  private:
 843   Symbol*            _h_name;
 844   Handle               _class_loader;
 845   Handle               _h_protection_domain;
 846   unsigned char **     _data_ptr;
 847   unsigned char **     _end_ptr;
 848   JavaThread *         _thread;
 849   jint                 _curr_len;
 850   unsigned char *      _curr_data;
 851   JvmtiEnv *           _curr_env;
 852   JvmtiCachedClassFileData ** _cached_class_file_ptr;
 853   JvmtiThreadState *   _state;
 854   Klass*               _class_being_redefined;
 855   JvmtiClassLoadKind   _load_kind;
 856   bool                 _has_been_modified;
 857 
 858  public:
 859   inline JvmtiClassFileLoadHookPoster(Symbol* h_name, Handle class_loader,
 860                                       Handle h_protection_domain,
 861                                       unsigned char **data_ptr, unsigned char **end_ptr,
 862                                       JvmtiCachedClassFileData **cache_ptr) {
 863     _h_name = h_name;
 864     _class_loader = class_loader;
 865     _h_protection_domain = h_protection_domain;
 866     _data_ptr = data_ptr;
 867     _end_ptr = end_ptr;
 868     _thread = JavaThread::current();
 869     _curr_len = *end_ptr - *data_ptr;
 870     _curr_data = *data_ptr;
 871     _curr_env = NULL;
 872     _cached_class_file_ptr = cache_ptr;
 873     _has_been_modified = false;
 874 
 875     _state = _thread-&gt;jvmti_thread_state();
 876     if (_state != NULL) {
 877       _class_being_redefined = _state-&gt;get_class_being_redefined();
 878       _load_kind = _state-&gt;get_class_load_kind();
 879       Klass* klass = (_class_being_redefined == NULL) ? NULL : _class_being_redefined;
 880       if (_load_kind != jvmti_class_load_kind_load &amp;&amp; klass != NULL) {
 881         ModuleEntry* module_entry = InstanceKlass::cast(klass)-&gt;module();
 882         assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
 883         if (module_entry-&gt;is_named() &amp;&amp;
 884             module_entry-&gt;module() != NULL &amp;&amp;
 885             !module_entry-&gt;has_default_read_edges()) {
 886           if (!module_entry-&gt;set_has_default_read_edges()) {
 887             // We won a potential race.
 888             // Add read edges to the unnamed modules of the bootstrap and app class loaders
 889             Handle class_module(_thread, module_entry-&gt;module()); // Obtain j.l.r.Module
 890             JvmtiExport::add_default_read_edges(class_module, _thread);
 891           }
 892         }
 893       }
 894       // Clear class_being_redefined flag here. The action
 895       // from agent handler could generate a new class file load
 896       // hook event and if it is not cleared the new event generated
 897       // from regular class file load could have this stale redefined
 898       // class handle info.
 899       _state-&gt;clear_class_being_redefined();
 900     } else {
 901       // redefine and retransform will always set the thread state
 902       _class_being_redefined = NULL;
 903       _load_kind = jvmti_class_load_kind_load;
 904     }
 905   }
 906 
 907   void post() {
 908     post_all_envs();
 909     copy_modified_data();
 910   }
 911 
 912   bool has_been_modified() { return _has_been_modified; }
 913 
 914  private:
 915   void post_all_envs() {
 916     if (_load_kind != jvmti_class_load_kind_retransform) {
 917       // for class load and redefine,
 918       // call the non-retransformable agents
 919       JvmtiEnvIterator it;
 920       for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 921         if (!env-&gt;is_retransformable() &amp;&amp; env-&gt;is_enabled(JVMTI_EVENT_CLASS_FILE_LOAD_HOOK)) {
 922           // non-retransformable agents cannot retransform back,
 923           // so no need to cache the original class file bytes
 924           post_to_env(env, false);
 925         }
 926       }
 927     }
 928     JvmtiEnvIterator it;
 929     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
 930       // retransformable agents get all events
 931       if (env-&gt;is_retransformable() &amp;&amp; env-&gt;is_enabled(JVMTI_EVENT_CLASS_FILE_LOAD_HOOK)) {
 932         // retransformable agents need to cache the original class file
 933         // bytes if changes are made via the ClassFileLoadHook
 934         post_to_env(env, true);
 935       }
 936     }
 937   }
 938 
 939   void post_to_env(JvmtiEnv* env, bool caching_needed) {
 940     if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL &amp;&amp; !env-&gt;early_class_hook_env()) {
 941       return;
 942     }
 943     unsigned char *new_data = NULL;
 944     jint new_len = 0;
 945     JvmtiClassFileLoadEventMark jem(_thread, _h_name, _class_loader,
 946                                     _h_protection_domain,
 947                                     _class_being_redefined);
 948     JvmtiJavaThreadEventTransition jet(_thread);
 949     jvmtiEventClassFileLoadHook callback = env-&gt;callbacks()-&gt;ClassFileLoadHook;
 950     if (callback != NULL) {
 951       (*callback)(env-&gt;jvmti_external(), jem.jni_env(),
 952                   jem.class_being_redefined(),
 953                   jem.jloader(), jem.class_name(),
 954                   jem.protection_domain(),
 955                   _curr_len, _curr_data,
 956                   &amp;new_len, &amp;new_data);
 957     }
 958     if (new_data != NULL) {
 959       // this agent has modified class data.
 960       _has_been_modified = true;
 961       if (caching_needed &amp;&amp; *_cached_class_file_ptr == NULL) {
 962         // data has been changed by the new retransformable agent
 963         // and it hasn&#39;t already been cached, cache it
 964         JvmtiCachedClassFileData *p;
 965         p = (JvmtiCachedClassFileData *)os::malloc(
 966           offset_of(JvmtiCachedClassFileData, data) + _curr_len, mtInternal);
 967         if (p == NULL) {
 968           vm_exit_out_of_memory(offset_of(JvmtiCachedClassFileData, data) + _curr_len,
 969             OOM_MALLOC_ERROR,
 970             &quot;unable to allocate cached copy of original class bytes&quot;);
 971         }
 972         p-&gt;length = _curr_len;
 973         memcpy(p-&gt;data, _curr_data, _curr_len);
 974         *_cached_class_file_ptr = p;
 975       }
 976 
 977       if (_curr_data != *_data_ptr) {
 978         // curr_data is previous agent modified class data.
 979         // And this has been changed by the new agent so
 980         // we can delete it now.
 981         _curr_env-&gt;Deallocate(_curr_data);
 982       }
 983 
 984       // Class file data has changed by the current agent.
 985       _curr_data = new_data;
 986       _curr_len = new_len;
 987       // Save the current agent env we need this to deallocate the
 988       // memory allocated by this agent.
 989       _curr_env = env;
 990     }
 991   }
 992 
 993   void copy_modified_data() {
 994     // if one of the agent has modified class file data.
 995     // Copy modified class data to new resources array.
 996     if (_curr_data != *_data_ptr) {
 997       *_data_ptr = NEW_RESOURCE_ARRAY(u1, _curr_len);
 998       memcpy(*_data_ptr, _curr_data, _curr_len);
 999       *_end_ptr = *_data_ptr + _curr_len;
1000       _curr_env-&gt;Deallocate(_curr_data);
1001     }
1002   }
1003 };
1004 
1005 bool JvmtiExport::is_early_phase() {
1006   return JvmtiEnvBase::get_phase() &lt;= JVMTI_PHASE_PRIMORDIAL;
1007 }
1008 
1009 bool JvmtiExport::has_early_class_hook_env() {
1010   JvmtiEnvIterator it;
1011   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1012     if (env-&gt;early_class_hook_env()) {
1013       return true;
1014     }
1015   }
1016   return false;
1017 }
1018 
1019 bool JvmtiExport::_should_post_class_file_load_hook = false;
1020 
1021 // this entry is for class file load hook on class load, redefine and retransform
1022 bool JvmtiExport::post_class_file_load_hook(Symbol* h_name,
1023                                             Handle class_loader,
1024                                             Handle h_protection_domain,
1025                                             unsigned char **data_ptr,
1026                                             unsigned char **end_ptr,
1027                                             JvmtiCachedClassFileData **cache_ptr) {
1028   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1029     return false;
1030   }
1031 
1032   JvmtiClassFileLoadHookPoster poster(h_name, class_loader,
1033                                       h_protection_domain,
1034                                       data_ptr, end_ptr,
1035                                       cache_ptr);
1036   poster.post();
1037   return poster.has_been_modified();
1038 }
1039 
1040 void JvmtiExport::report_unsupported(bool on) {
1041   // If any JVMTI service is turned on, we need to exit before native code
1042   // tries to access nonexistant services.
1043   if (on) {
1044     vm_exit_during_initialization(&quot;Java Kernel does not support JVMTI.&quot;);
1045   }
1046 }
1047 
1048 
1049 static inline Klass* oop_to_klass(oop obj) {
1050   Klass* k = obj-&gt;klass();
1051 
1052   // if the object is a java.lang.Class then return the java mirror
1053   if (k == SystemDictionary::Class_klass()) {
1054     if (!java_lang_Class::is_primitive(obj)) {
1055       k = java_lang_Class::as_Klass(obj);
1056       assert(k != NULL, &quot;class for non-primitive mirror must exist&quot;);
1057     }
1058   }
1059   return k;
1060 }
1061 
1062 class JvmtiObjectAllocEventMark : public JvmtiClassEventMark  {
1063  private:
1064    jobject _jobj;
1065    jlong    _size;
1066  public:
1067    JvmtiObjectAllocEventMark(JavaThread *thread, oop obj) : JvmtiClassEventMark(thread, oop_to_klass(obj)) {
1068      _jobj = (jobject)to_jobject(obj);
1069      _size = obj-&gt;size() * wordSize;
1070    };
1071    jobject jni_jobject() { return _jobj; }
1072    jlong size() { return _size; }
1073 };
1074 
1075 class JvmtiCompiledMethodLoadEventMark : public JvmtiMethodEventMark {
1076  private:
1077   jint _code_size;
1078   const void *_code_data;
1079   jint _map_length;
1080   jvmtiAddrLocationMap *_map;
1081   const void *_compile_info;
1082  public:
1083   JvmtiCompiledMethodLoadEventMark(JavaThread *thread, nmethod *nm, void* compile_info_ptr = NULL)
1084           : JvmtiMethodEventMark(thread,methodHandle(thread, nm-&gt;method())) {
1085     _code_data = nm-&gt;insts_begin();
1086     _code_size = nm-&gt;insts_size();
1087     _compile_info = compile_info_ptr; // Set void pointer of compiledMethodLoad Event. Default value is NULL.
1088     JvmtiCodeBlobEvents::build_jvmti_addr_location_map(nm, &amp;_map, &amp;_map_length);
1089   }
1090   ~JvmtiCompiledMethodLoadEventMark() {
1091      FREE_C_HEAP_ARRAY(jvmtiAddrLocationMap, _map);
1092   }
1093 
1094   jint code_size() { return _code_size; }
1095   const void *code_data() { return _code_data; }
1096   jint map_length() { return _map_length; }
1097   const jvmtiAddrLocationMap* map() { return _map; }
1098   const void *compile_info() { return _compile_info; }
1099 };
1100 
1101 
1102 
1103 class JvmtiMonitorEventMark : public JvmtiThreadEventMark {
1104 private:
1105   jobject _jobj;
1106 public:
1107   JvmtiMonitorEventMark(JavaThread *thread, oop object)
1108           : JvmtiThreadEventMark(thread){
1109      _jobj = to_jobject(object);
1110   }
1111   jobject jni_object() { return _jobj; }
1112 };
1113 
1114 ///////////////////////////////////////////////////////////////
1115 //
1116 // pending CompiledMethodUnload support
1117 //
1118 
1119 void JvmtiExport::post_compiled_method_unload(
1120        jmethodID method, const void *code_begin) {
1121   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1122     return;
1123   }
1124   JavaThread* thread = JavaThread::current();
1125   EVT_TRIG_TRACE(JVMTI_EVENT_COMPILED_METHOD_UNLOAD,
1126                  (&quot;[%s] method compile unload event triggered&quot;,
1127                   JvmtiTrace::safe_get_thread_name(thread)));
1128 
1129   // post the event for each environment that has this event enabled.
1130   JvmtiEnvIterator it;
1131   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1132     if (env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_UNLOAD)) {
1133       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1134         continue;
1135       }
1136       EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_UNLOAD,
1137                 (&quot;[%s] class compile method unload event sent jmethodID &quot; PTR_FORMAT,
1138                  JvmtiTrace::safe_get_thread_name(thread), p2i(method)));
1139 
1140       ResourceMark rm(thread);
1141 
1142       JvmtiEventMark jem(thread);
1143       JvmtiJavaThreadEventTransition jet(thread);
1144       jvmtiEventCompiledMethodUnload callback = env-&gt;callbacks()-&gt;CompiledMethodUnload;
1145       if (callback != NULL) {
1146         (*callback)(env-&gt;jvmti_external(), method, code_begin);
1147       }
1148     }
1149   }
1150 }
1151 
1152 ///////////////////////////////////////////////////////////////
1153 //
1154 // JvmtiExport
1155 //
1156 
1157 void JvmtiExport::post_raw_breakpoint(JavaThread *thread, Method* method, address location) {
1158   HandleMark hm(thread);
1159   methodHandle mh(thread, method);
1160 
1161   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1162   if (state == NULL) {
1163     return;
1164   }
1165   EVT_TRIG_TRACE(JVMTI_EVENT_BREAKPOINT, (&quot;[%s] Trg Breakpoint triggered&quot;,
1166                       JvmtiTrace::safe_get_thread_name(thread)));
1167   JvmtiEnvThreadStateIterator it(state);
1168   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1169     ets-&gt;compare_and_set_current_location(mh(), location, JVMTI_EVENT_BREAKPOINT);
1170     if (!ets-&gt;breakpoint_posted() &amp;&amp; ets-&gt;is_enabled(JVMTI_EVENT_BREAKPOINT)) {
1171       ThreadState old_os_state = thread-&gt;osthread()-&gt;get_state();
1172       thread-&gt;osthread()-&gt;set_state(BREAKPOINTED);
1173       EVT_TRACE(JVMTI_EVENT_BREAKPOINT, (&quot;[%s] Evt Breakpoint sent %s.%s @ &quot; INTX_FORMAT,
1174                      JvmtiTrace::safe_get_thread_name(thread),
1175                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1176                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1177                      location - mh()-&gt;code_base() ));
1178 
1179       JvmtiEnv *env = ets-&gt;get_env();
1180       JvmtiLocationEventMark jem(thread, mh, location);
1181       JvmtiJavaThreadEventTransition jet(thread);
1182       jvmtiEventBreakpoint callback = env-&gt;callbacks()-&gt;Breakpoint;
1183       if (callback != NULL) {
1184         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1185                     jem.jni_methodID(), jem.location());
1186       }
1187 
1188       ets-&gt;set_breakpoint_posted();
1189       thread-&gt;osthread()-&gt;set_state(old_os_state);
1190     }
1191   }
1192 }
1193 
1194 //////////////////////////////////////////////////////////////////////////////
1195 
1196 bool              JvmtiExport::_can_get_source_debug_extension            = false;
1197 bool              JvmtiExport::_can_maintain_original_method_order        = false;
1198 bool              JvmtiExport::_can_post_interpreter_events               = false;
1199 bool              JvmtiExport::_can_post_on_exceptions                    = false;
1200 bool              JvmtiExport::_can_post_breakpoint                       = false;
1201 bool              JvmtiExport::_can_post_field_access                     = false;
1202 bool              JvmtiExport::_can_post_field_modification               = false;
1203 bool              JvmtiExport::_can_post_method_entry                     = false;
1204 bool              JvmtiExport::_can_post_method_exit                      = false;
1205 bool              JvmtiExport::_can_pop_frame                             = false;
1206 bool              JvmtiExport::_can_force_early_return                    = false;
1207 bool              JvmtiExport::_can_get_owned_monitor_info                = false;
1208 
1209 bool              JvmtiExport::_early_vmstart_recorded                    = false;
1210 
1211 bool              JvmtiExport::_should_post_single_step                   = false;
1212 bool              JvmtiExport::_should_post_field_access                  = false;
1213 bool              JvmtiExport::_should_post_field_modification            = false;
1214 bool              JvmtiExport::_should_post_class_load                    = false;
1215 bool              JvmtiExport::_should_post_class_prepare                 = false;
1216 bool              JvmtiExport::_should_post_class_unload                  = false;
1217 bool              JvmtiExport::_should_post_thread_life                   = false;
1218 bool              JvmtiExport::_should_clean_up_heap_objects              = false;
1219 bool              JvmtiExport::_should_post_native_method_bind            = false;
1220 bool              JvmtiExport::_should_post_dynamic_code_generated        = false;
1221 bool              JvmtiExport::_should_post_data_dump                     = false;
1222 bool              JvmtiExport::_should_post_compiled_method_load          = false;
1223 bool              JvmtiExport::_should_post_compiled_method_unload        = false;
1224 bool              JvmtiExport::_should_post_monitor_contended_enter       = false;
1225 bool              JvmtiExport::_should_post_monitor_contended_entered     = false;
1226 bool              JvmtiExport::_should_post_monitor_wait                  = false;
1227 bool              JvmtiExport::_should_post_monitor_waited                = false;
1228 bool              JvmtiExport::_should_post_garbage_collection_start      = false;
1229 bool              JvmtiExport::_should_post_garbage_collection_finish     = false;
1230 bool              JvmtiExport::_should_post_object_free                   = false;
1231 bool              JvmtiExport::_should_post_resource_exhausted            = false;
1232 bool              JvmtiExport::_should_post_vm_object_alloc               = false;
1233 bool              JvmtiExport::_should_post_sampled_object_alloc          = false;
1234 bool              JvmtiExport::_should_post_on_exceptions                 = false;
1235 
1236 ////////////////////////////////////////////////////////////////////////////////////////////////
1237 
1238 
1239 //
1240 // JVMTI single step management
1241 //
1242 void JvmtiExport::at_single_stepping_point(JavaThread *thread, Method* method, address location) {
1243   assert(JvmtiExport::should_post_single_step(), &quot;must be single stepping&quot;);
1244 
1245   HandleMark hm(thread);
1246   methodHandle mh(thread, method);
1247 
1248   // update information about current location and post a step event
1249   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1250   if (state == NULL) {
1251     return;
1252   }
1253   EVT_TRIG_TRACE(JVMTI_EVENT_SINGLE_STEP, (&quot;[%s] Trg Single Step triggered&quot;,
1254                       JvmtiTrace::safe_get_thread_name(thread)));
1255   if (!state-&gt;hide_single_stepping()) {
1256     if (state-&gt;is_pending_step_for_popframe()) {
1257       state-&gt;process_pending_step_for_popframe();
1258     }
1259     if (state-&gt;is_pending_step_for_earlyret()) {
1260       state-&gt;process_pending_step_for_earlyret();
1261     }
1262     JvmtiExport::post_single_step(thread, mh(), location);
1263   }
1264 }
1265 
1266 
1267 void JvmtiExport::expose_single_stepping(JavaThread *thread) {
1268   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1269   if (state != NULL) {
1270     state-&gt;clear_hide_single_stepping();
1271   }
1272 }
1273 
1274 
1275 bool JvmtiExport::hide_single_stepping(JavaThread *thread) {
1276   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1277   if (state != NULL &amp;&amp; state-&gt;is_enabled(JVMTI_EVENT_SINGLE_STEP)) {
1278     state-&gt;set_hide_single_stepping();
1279     return true;
1280   } else {
1281     return false;
1282   }
1283 }
1284 
1285 void JvmtiExport::post_class_load(JavaThread *thread, Klass* klass) {
1286   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1287     return;
1288   }
1289   HandleMark hm(thread);
1290 
1291   EVT_TRIG_TRACE(JVMTI_EVENT_CLASS_LOAD, (&quot;[%s] Trg Class Load triggered&quot;,
1292                       JvmtiTrace::safe_get_thread_name(thread)));
1293   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
1294   if (state == NULL) {
1295     return;
1296   }
1297   JvmtiEnvThreadStateIterator it(state);
1298   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1299     if (ets-&gt;is_enabled(JVMTI_EVENT_CLASS_LOAD)) {
1300       JvmtiEnv *env = ets-&gt;get_env();
1301       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1302         continue;
1303       }
1304       EVT_TRACE(JVMTI_EVENT_CLASS_LOAD, (&quot;[%s] Evt Class Load sent %s&quot;,
1305                                          JvmtiTrace::safe_get_thread_name(thread),
1306                                          klass==NULL? &quot;NULL&quot; : klass-&gt;external_name() ));
1307       JvmtiClassEventMark jem(thread, klass);
1308       JvmtiJavaThreadEventTransition jet(thread);
1309       jvmtiEventClassLoad callback = env-&gt;callbacks()-&gt;ClassLoad;
1310       if (callback != NULL) {
1311         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_class());
1312       }
1313     }
1314   }
1315 }
1316 
1317 
1318 void JvmtiExport::post_class_prepare(JavaThread *thread, Klass* klass) {
1319   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1320     return;
1321   }
1322   HandleMark hm(thread);
1323 
1324   EVT_TRIG_TRACE(JVMTI_EVENT_CLASS_PREPARE, (&quot;[%s] Trg Class Prepare triggered&quot;,
1325                       JvmtiTrace::safe_get_thread_name(thread)));
1326   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
1327   if (state == NULL) {
1328     return;
1329   }
1330   JvmtiEnvThreadStateIterator it(state);
1331   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1332     if (ets-&gt;is_enabled(JVMTI_EVENT_CLASS_PREPARE)) {
1333       JvmtiEnv *env = ets-&gt;get_env();
1334       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1335         continue;
1336       }
1337       EVT_TRACE(JVMTI_EVENT_CLASS_PREPARE, (&quot;[%s] Evt Class Prepare sent %s&quot;,
1338                                             JvmtiTrace::safe_get_thread_name(thread),
1339                                             klass==NULL? &quot;NULL&quot; : klass-&gt;external_name() ));
1340       JvmtiClassEventMark jem(thread, klass);
1341       JvmtiJavaThreadEventTransition jet(thread);
1342       jvmtiEventClassPrepare callback = env-&gt;callbacks()-&gt;ClassPrepare;
1343       if (callback != NULL) {
1344         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_class());
1345       }
1346     }
1347   }
1348 }
1349 
1350 void JvmtiExport::post_class_unload(Klass* klass) {
1351   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1352     return;
1353   }
1354 
1355   // postings to the service thread so that it can perform them in a safe
1356   // context and in-order.
1357   ResourceMark rm;
1358   // JvmtiDeferredEvent copies the string.
1359   JvmtiDeferredEvent event = JvmtiDeferredEvent::class_unload_event(klass-&gt;name()-&gt;as_C_string());
1360   ServiceThread::enqueue_deferred_event(&amp;event);
1361 }
1362 
1363 
1364 void JvmtiExport::post_class_unload_internal(const char* name) {
1365   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1366     return;
1367   }
1368   assert(Thread::current()-&gt;is_service_thread(), &quot;must be called from ServiceThread&quot;);
1369   JavaThread *thread = JavaThread::current();
1370   HandleMark hm(thread);
1371 
1372   EVT_TRIG_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Trg Class Unload triggered&quot; ));
1373   if (JvmtiEventController::is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
1374 
1375     JvmtiEnvIterator it;
1376     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1377       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1378         continue;
1379       }
1380       if (env-&gt;is_enabled((jvmtiEvent)EXT_EVENT_CLASS_UNLOAD)) {
1381         EVT_TRACE(EXT_EVENT_CLASS_UNLOAD, (&quot;[?] Evt Class Unload sent %s&quot;, name));
1382 
1383         JvmtiEventMark jem(thread);
1384         JvmtiJavaThreadEventTransition jet(thread);
1385         jvmtiExtensionEvent callback = env-&gt;ext_callbacks()-&gt;ClassUnload;
1386         if (callback != NULL) {
1387           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), name);
1388         }
1389       }
1390     }
1391   }
1392 }
1393 
1394 
1395 void JvmtiExport::post_thread_start(JavaThread *thread) {
1396   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1397     return;
1398   }
1399   assert(thread-&gt;thread_state() == _thread_in_vm, &quot;must be in vm state&quot;);
1400 
1401   EVT_TRIG_TRACE(JVMTI_EVENT_THREAD_START, (&quot;[%s] Trg Thread Start event triggered&quot;,
1402                       JvmtiTrace::safe_get_thread_name(thread)));
1403 
1404   // do JVMTI thread initialization (if needed)
1405   JvmtiEventController::thread_started(thread);
1406 
1407   // Do not post thread start event for hidden java thread.
1408   if (JvmtiEventController::is_enabled(JVMTI_EVENT_THREAD_START) &amp;&amp;
1409       !thread-&gt;is_hidden_from_external_view()) {
1410     JvmtiEnvIterator it;
1411     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1412       if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1413         continue;
1414       }
1415       if (env-&gt;is_enabled(JVMTI_EVENT_THREAD_START)) {
1416         EVT_TRACE(JVMTI_EVENT_THREAD_START, (&quot;[%s] Evt Thread Start event sent&quot;,
1417                      JvmtiTrace::safe_get_thread_name(thread) ));
1418 
1419         JvmtiThreadEventMark jem(thread);
1420         JvmtiJavaThreadEventTransition jet(thread);
1421         jvmtiEventThreadStart callback = env-&gt;callbacks()-&gt;ThreadStart;
1422         if (callback != NULL) {
1423           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread());
1424         }
1425       }
1426     }
1427   }
1428 }
1429 
1430 
1431 void JvmtiExport::post_thread_end(JavaThread *thread) {
1432   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
1433     return;
1434   }
1435   EVT_TRIG_TRACE(JVMTI_EVENT_THREAD_END, (&quot;[%s] Trg Thread End event triggered&quot;,
1436                       JvmtiTrace::safe_get_thread_name(thread)));
1437 
1438   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1439   if (state == NULL) {
1440     return;
1441   }
1442 
1443   // Do not post thread end event for hidden java thread.
1444   if (state-&gt;is_enabled(JVMTI_EVENT_THREAD_END) &amp;&amp;
1445       !thread-&gt;is_hidden_from_external_view()) {
1446 
1447     JvmtiEnvThreadStateIterator it(state);
1448     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1449       if (ets-&gt;is_enabled(JVMTI_EVENT_THREAD_END)) {
1450         JvmtiEnv *env = ets-&gt;get_env();
1451         if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) {
1452           continue;
1453         }
1454         EVT_TRACE(JVMTI_EVENT_THREAD_END, (&quot;[%s] Evt Thread End event sent&quot;,
1455                      JvmtiTrace::safe_get_thread_name(thread) ));
1456 
1457         JvmtiThreadEventMark jem(thread);
1458         JvmtiJavaThreadEventTransition jet(thread);
1459         jvmtiEventThreadEnd callback = env-&gt;callbacks()-&gt;ThreadEnd;
1460         if (callback != NULL) {
1461           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread());
1462         }
1463       }
1464     }
1465   }
1466 }
1467 
1468 void JvmtiExport::post_object_free(JvmtiEnv* env, jlong tag) {
1469   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be executed at safepoint&quot;);
1470   assert(env-&gt;is_enabled(JVMTI_EVENT_OBJECT_FREE), &quot;checking&quot;);
1471 
1472   EVT_TRIG_TRACE(JVMTI_EVENT_OBJECT_FREE, (&quot;[?] Trg Object Free triggered&quot; ));
1473   EVT_TRACE(JVMTI_EVENT_OBJECT_FREE, (&quot;[?] Evt Object Free sent&quot;));
1474 
1475   jvmtiEventObjectFree callback = env-&gt;callbacks()-&gt;ObjectFree;
1476   if (callback != NULL) {
1477     (*callback)(env-&gt;jvmti_external(), tag);
1478   }
1479 }
1480 
1481 void JvmtiExport::post_resource_exhausted(jint resource_exhausted_flags, const char* description) {
1482 
1483   JavaThread *thread  = JavaThread::current();
1484 
1485   // JDK-8213834: handlers of ResourceExhausted may attempt some analysis
1486   // which often requires running java.
1487   // This will cause problems on threads not able to run java, e.g. compiler
1488   // threads. To forestall these problems, we therefore suppress sending this
1489   // event from threads which are not able to run java.
1490   if (!thread-&gt;can_call_java()) {
1491     return;
1492   }
1493 
1494   EVT_TRIG_TRACE(JVMTI_EVENT_RESOURCE_EXHAUSTED, (&quot;Trg resource exhausted event triggered&quot; ));
1495 
1496   JvmtiEnvIterator it;
1497   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
1498     if (env-&gt;is_enabled(JVMTI_EVENT_RESOURCE_EXHAUSTED)) {
1499       EVT_TRACE(JVMTI_EVENT_RESOURCE_EXHAUSTED, (&quot;Evt resource exhausted event sent&quot; ));
1500 
1501       JvmtiThreadEventMark jem(thread);
1502       JvmtiJavaThreadEventTransition jet(thread);
1503       jvmtiEventResourceExhausted callback = env-&gt;callbacks()-&gt;ResourceExhausted;
1504       if (callback != NULL) {
1505         (*callback)(env-&gt;jvmti_external(), jem.jni_env(),
1506                     resource_exhausted_flags, NULL, description);
1507       }
1508     }
1509   }
1510 }
1511 
1512 void JvmtiExport::post_method_entry(JavaThread *thread, Method* method, frame current_frame) {
1513   HandleMark hm(thread);
1514   methodHandle mh(thread, method);
1515 
1516   EVT_TRIG_TRACE(JVMTI_EVENT_METHOD_ENTRY, (&quot;[%s] Trg Method Entry triggered %s.%s&quot;,
1517                      JvmtiTrace::safe_get_thread_name(thread),
1518                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1519                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1520 
1521   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
1522   if (state == NULL || !state-&gt;is_interp_only_mode()) {
1523     // for any thread that actually wants method entry, interp_only_mode is set
1524     return;
1525   }
1526 
1527   state-&gt;incr_cur_stack_depth();
1528 
1529   if (state-&gt;is_enabled(JVMTI_EVENT_METHOD_ENTRY)) {
1530     JvmtiEnvThreadStateIterator it(state);
1531     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1532       if (ets-&gt;is_enabled(JVMTI_EVENT_METHOD_ENTRY)) {
1533         EVT_TRACE(JVMTI_EVENT_METHOD_ENTRY, (&quot;[%s] Evt Method Entry sent %s.%s&quot;,
1534                                              JvmtiTrace::safe_get_thread_name(thread),
1535                                              (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1536                                              (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1537 
1538         JvmtiEnv *env = ets-&gt;get_env();
1539         JvmtiMethodEventMark jem(thread, mh);
1540         JvmtiJavaThreadEventTransition jet(thread);
1541         jvmtiEventMethodEntry callback = env-&gt;callbacks()-&gt;MethodEntry;
1542         if (callback != NULL) {
1543           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_methodID());
1544         }
1545       }
1546     }
1547   }
1548 }
1549 
1550 void JvmtiExport::post_method_exit(JavaThread *thread, Method* method, frame current_frame) {
1551   HandleMark hm(thread);
1552   methodHandle mh(thread, method);
1553 
1554   EVT_TRIG_TRACE(JVMTI_EVENT_METHOD_EXIT, (&quot;[%s] Trg Method Exit triggered %s.%s&quot;,
1555                      JvmtiTrace::safe_get_thread_name(thread),
1556                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1557                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1558 
1559   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1560   if (state == NULL || !state-&gt;is_interp_only_mode()) {
1561     // for any thread that actually wants method exit, interp_only_mode is set
1562     return;
1563   }
1564 
1565   // return a flag when a method terminates by throwing an exception
1566   // i.e. if an exception is thrown and it&#39;s not caught by the current method
1567   bool exception_exit = state-&gt;is_exception_detected() &amp;&amp; !state-&gt;is_exception_caught();
1568 
1569 
1570   if (state-&gt;is_enabled(JVMTI_EVENT_METHOD_EXIT)) {
1571     Handle result;
1572     jvalue value;
1573     value.j = 0L;
1574 
1575     // if the method hasn&#39;t been popped because of an exception then we populate
1576     // the return_value parameter for the callback. At this point we only have
1577     // the address of a &quot;raw result&quot; and we just call into the interpreter to
1578     // convert this into a jvalue.
1579     if (!exception_exit) {
1580       oop oop_result;
1581       BasicType type = current_frame.interpreter_frame_result(&amp;oop_result, &amp;value);
1582       if (is_reference_type(type)) {
1583         result = Handle(thread, oop_result);
1584       }
1585     }
1586 
1587     JvmtiEnvThreadStateIterator it(state);
1588     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1589       if (ets-&gt;is_enabled(JVMTI_EVENT_METHOD_EXIT)) {
1590         EVT_TRACE(JVMTI_EVENT_METHOD_EXIT, (&quot;[%s] Evt Method Exit sent %s.%s&quot;,
1591                                             JvmtiTrace::safe_get_thread_name(thread),
1592                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1593                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1594 
1595         JvmtiEnv *env = ets-&gt;get_env();
1596         JvmtiMethodEventMark jem(thread, mh);
1597         if (result.not_null()) {
1598           value.l = JNIHandles::make_local(thread, result());
1599         }
1600         JvmtiJavaThreadEventTransition jet(thread);
1601         jvmtiEventMethodExit callback = env-&gt;callbacks()-&gt;MethodExit;
1602         if (callback != NULL) {
1603           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1604                       jem.jni_methodID(), exception_exit,  value);
1605         }
1606       }
1607     }
1608   }
1609 
1610   JvmtiEnvThreadStateIterator it(state);
1611   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1612     if (ets-&gt;has_frame_pops()) {
1613       int cur_frame_number = state-&gt;cur_stack_depth();
1614 
1615       if (ets-&gt;is_frame_pop(cur_frame_number)) {
1616         // we have a NotifyFramePop entry for this frame.
1617         // now check that this env/thread wants this event
1618         if (ets-&gt;is_enabled(JVMTI_EVENT_FRAME_POP)) {
1619           EVT_TRACE(JVMTI_EVENT_FRAME_POP, (&quot;[%s] Evt Frame Pop sent %s.%s&quot;,
1620                                             JvmtiTrace::safe_get_thread_name(thread),
1621                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1622                                             (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string() ));
1623 
1624           // we also need to issue a frame pop event for this frame
1625           JvmtiEnv *env = ets-&gt;get_env();
1626           JvmtiMethodEventMark jem(thread, mh);
1627           JvmtiJavaThreadEventTransition jet(thread);
1628           jvmtiEventFramePop callback = env-&gt;callbacks()-&gt;FramePop;
1629           if (callback != NULL) {
1630             (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1631                         jem.jni_methodID(), exception_exit);
1632           }
1633         }
1634         // remove the frame&#39;s entry
1635         ets-&gt;clear_frame_pop(cur_frame_number);
1636       }
1637     }
1638   }
1639 
1640   state-&gt;decr_cur_stack_depth();
1641 }
1642 
1643 
1644 // Todo: inline this for optimization
1645 void JvmtiExport::post_single_step(JavaThread *thread, Method* method, address location) {
1646   HandleMark hm(thread);
1647   methodHandle mh(thread, method);
1648 
1649   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1650   if (state == NULL) {
1651     return;
1652   }
1653   JvmtiEnvThreadStateIterator it(state);
1654   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1655     ets-&gt;compare_and_set_current_location(mh(), location, JVMTI_EVENT_SINGLE_STEP);
1656     if (!ets-&gt;single_stepping_posted() &amp;&amp; ets-&gt;is_enabled(JVMTI_EVENT_SINGLE_STEP)) {
1657       EVT_TRACE(JVMTI_EVENT_SINGLE_STEP, (&quot;[%s] Evt Single Step sent %s.%s @ &quot; INTX_FORMAT,
1658                     JvmtiTrace::safe_get_thread_name(thread),
1659                     (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1660                     (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1661                     location - mh()-&gt;code_base() ));
1662 
1663       JvmtiEnv *env = ets-&gt;get_env();
1664       JvmtiLocationEventMark jem(thread, mh, location);
1665       JvmtiJavaThreadEventTransition jet(thread);
1666       jvmtiEventSingleStep callback = env-&gt;callbacks()-&gt;SingleStep;
1667       if (callback != NULL) {
1668         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1669                     jem.jni_methodID(), jem.location());
1670       }
1671 
1672       ets-&gt;set_single_stepping_posted();
1673     }
1674   }
1675 }
1676 
1677 void JvmtiExport::post_exception_throw(JavaThread *thread, Method* method, address location, oop exception) {
1678   HandleMark hm(thread);
1679   methodHandle mh(thread, method);
1680   Handle exception_handle(thread, exception);
1681 
1682   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1683   if (state == NULL) {
1684     return;
1685   }
1686 
1687   EVT_TRIG_TRACE(JVMTI_EVENT_EXCEPTION, (&quot;[%s] Trg Exception thrown triggered&quot;,
1688                       JvmtiTrace::safe_get_thread_name(thread)));
1689   if (!state-&gt;is_exception_detected()) {
1690     state-&gt;set_exception_detected();
1691     JvmtiEnvThreadStateIterator it(state);
1692     for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1693       if (ets-&gt;is_enabled(JVMTI_EVENT_EXCEPTION) &amp;&amp; (exception != NULL)) {
1694 
1695         EVT_TRACE(JVMTI_EVENT_EXCEPTION,
1696                      (&quot;[%s] Evt Exception thrown sent %s.%s @ &quot; INTX_FORMAT,
1697                       JvmtiTrace::safe_get_thread_name(thread),
1698                       (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1699                       (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1700                       location - mh()-&gt;code_base() ));
1701 
1702         JvmtiEnv *env = ets-&gt;get_env();
1703         JvmtiExceptionEventMark jem(thread, mh, location, exception_handle);
1704 
1705         // It&#39;s okay to clear these exceptions here because we duplicate
1706         // this lookup in InterpreterRuntime::exception_handler_for_exception.
1707         EXCEPTION_MARK;
1708 
1709         bool should_repeat;
1710         vframeStream st(thread);
1711         assert(!st.at_end(), &quot;cannot be at end&quot;);
1712         Method* current_method = NULL;
1713         // A GC may occur during the Method::fast_exception_handler_bci_for()
1714         // call below if it needs to load the constraint class. Using a
1715         // methodHandle to keep the &#39;current_method&#39; from being deallocated
1716         // if GC happens.
1717         methodHandle current_mh = methodHandle(thread, current_method);
1718         int current_bci = -1;
1719         do {
1720           current_method = st.method();
1721           current_mh = methodHandle(thread, current_method);
1722           current_bci = st.bci();
1723           do {
1724             should_repeat = false;
1725             Klass* eh_klass = exception_handle()-&gt;klass();
1726             current_bci = Method::fast_exception_handler_bci_for(
1727               current_mh, eh_klass, current_bci, THREAD);
1728             if (HAS_PENDING_EXCEPTION) {
1729               exception_handle = Handle(thread, PENDING_EXCEPTION);
1730               CLEAR_PENDING_EXCEPTION;
1731               should_repeat = true;
1732             }
1733           } while (should_repeat &amp;&amp; (current_bci != -1));
1734           st.next();
1735         } while ((current_bci &lt; 0) &amp;&amp; (!st.at_end()));
1736 
1737         jmethodID catch_jmethodID;
1738         if (current_bci &lt; 0) {
1739           catch_jmethodID = 0;
1740           current_bci = 0;
1741         } else {
1742           catch_jmethodID = jem.to_jmethodID(current_mh);
1743         }
1744 
1745         JvmtiJavaThreadEventTransition jet(thread);
1746         jvmtiEventException callback = env-&gt;callbacks()-&gt;Exception;
1747         if (callback != NULL) {
1748           (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1749                       jem.jni_methodID(), jem.location(),
1750                       jem.exception(),
1751                       catch_jmethodID, current_bci);
1752         }
1753       }
1754     }
1755   }
1756 
1757   // frames may get popped because of this throw, be safe - invalidate cached depth
1758   state-&gt;invalidate_cur_stack_depth();
1759 }
1760 
1761 
1762 void JvmtiExport::notice_unwind_due_to_exception(JavaThread *thread, Method* method, address location, oop exception, bool in_handler_frame) {
1763   HandleMark hm(thread);
1764   methodHandle mh(thread, method);
1765   Handle exception_handle(thread, exception);
1766 
1767   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1768   if (state == NULL) {
1769     return;
1770   }
1771   EVT_TRIG_TRACE(JVMTI_EVENT_EXCEPTION_CATCH,
1772                     (&quot;[%s] Trg unwind_due_to_exception triggered %s.%s @ %s&quot; INTX_FORMAT &quot; - %s&quot;,
1773                      JvmtiTrace::safe_get_thread_name(thread),
1774                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1775                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1776                      location==0? &quot;no location:&quot; : &quot;&quot;,
1777                      location==0? 0 : location - mh()-&gt;code_base(),
1778                      in_handler_frame? &quot;in handler frame&quot; : &quot;not handler frame&quot; ));
1779 
1780   if (state-&gt;is_exception_detected()) {
1781 
1782     state-&gt;invalidate_cur_stack_depth();
1783     if (!in_handler_frame) {
1784       // Not in exception handler.
1785       if(state-&gt;is_interp_only_mode()) {
1786         // method exit and frame pop events are posted only in interp mode.
1787         // When these events are enabled code should be in running in interp mode.
1788         JvmtiExport::post_method_exit(thread, method, thread-&gt;last_frame());
1789         // The cached cur_stack_depth might have changed from the
1790         // operations of frame pop or method exit. We are not 100% sure
1791         // the cached cur_stack_depth is still valid depth so invalidate
1792         // it.
1793         state-&gt;invalidate_cur_stack_depth();
1794       }
1795     } else {
1796       // In exception handler frame. Report exception catch.
1797       assert(location != NULL, &quot;must be a known location&quot;);
1798       // Update cur_stack_depth - the frames above the current frame
1799       // have been unwound due to this exception:
1800       assert(!state-&gt;is_exception_caught(), &quot;exception must not be caught yet.&quot;);
1801       state-&gt;set_exception_caught();
1802 
1803       JvmtiEnvThreadStateIterator it(state);
1804       for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1805         if (ets-&gt;is_enabled(JVMTI_EVENT_EXCEPTION_CATCH) &amp;&amp; (exception_handle() != NULL)) {
1806           EVT_TRACE(JVMTI_EVENT_EXCEPTION_CATCH,
1807                      (&quot;[%s] Evt ExceptionCatch sent %s.%s @ &quot; INTX_FORMAT,
1808                       JvmtiTrace::safe_get_thread_name(thread),
1809                       (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1810                       (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1811                       location - mh()-&gt;code_base() ));
1812 
1813           JvmtiEnv *env = ets-&gt;get_env();
1814           JvmtiExceptionEventMark jem(thread, mh, location, exception_handle);
1815           JvmtiJavaThreadEventTransition jet(thread);
1816           jvmtiEventExceptionCatch callback = env-&gt;callbacks()-&gt;ExceptionCatch;
1817           if (callback != NULL) {
1818             (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1819                       jem.jni_methodID(), jem.location(),
1820                       jem.exception());
1821           }
1822         }
1823       }
1824     }
1825   }
1826 }
1827 
1828 oop JvmtiExport::jni_GetField_probe(JavaThread *thread, jobject jobj, oop obj,
1829                                     Klass* klass, jfieldID fieldID, bool is_static) {
1830   if (*((int *)get_field_access_count_addr()) &gt; 0 &amp;&amp; thread-&gt;has_last_Java_frame()) {
1831     // At least one field access watch is set so we have more work
1832     // to do. This wrapper is used by entry points that allow us
1833     // to create handles in post_field_access_by_jni().
1834     post_field_access_by_jni(thread, obj, klass, fieldID, is_static);
1835     // event posting can block so refetch oop if we were passed a jobj
1836     if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);
1837   }
1838   return obj;
1839 }
1840 
1841 oop JvmtiExport::jni_GetField_probe_nh(JavaThread *thread, jobject jobj, oop obj,
1842                                        Klass* klass, jfieldID fieldID, bool is_static) {
1843   if (*((int *)get_field_access_count_addr()) &gt; 0 &amp;&amp; thread-&gt;has_last_Java_frame()) {
1844     // At least one field access watch is set so we have more work
1845     // to do. This wrapper is used by &quot;quick&quot; entry points that don&#39;t
1846     // allow us to create handles in post_field_access_by_jni(). We
1847     // override that with a ResetNoHandleMark.
1848     ResetNoHandleMark rnhm;
1849     post_field_access_by_jni(thread, obj, klass, fieldID, is_static);
1850     // event posting can block so refetch oop if we were passed a jobj
1851     if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);
1852   }
1853   return obj;
1854 }
1855 
1856 void JvmtiExport::post_field_access_by_jni(JavaThread *thread, oop obj,
1857                                            Klass* klass, jfieldID fieldID, bool is_static) {
1858   // We must be called with a Java context in order to provide reasonable
1859   // values for the klazz, method, and location fields. The callers of this
1860   // function don&#39;t make the call unless there is a Java context.
1861   assert(thread-&gt;has_last_Java_frame(), &quot;must be called with a Java context&quot;);
1862 
1863   ResourceMark rm;
1864   fieldDescriptor fd;
1865   // if get_field_descriptor finds fieldID to be invalid, then we just bail
1866   bool valid_fieldID = JvmtiEnv::get_field_descriptor(klass, fieldID, &amp;fd);
1867   assert(valid_fieldID == true,&quot;post_field_access_by_jni called with invalid fieldID&quot;);
1868   if (!valid_fieldID) return;
1869   // field accesses are not watched so bail
1870   if (!fd.is_field_access_watched()) return;
1871 
1872   HandleMark hm(thread);
1873   Handle h_obj;
1874   if (!is_static) {
1875     // non-static field accessors have an object, but we need a handle
1876     assert(obj != NULL, &quot;non-static needs an object&quot;);
1877     h_obj = Handle(thread, obj);
1878   }
1879   post_field_access(thread,
1880                     thread-&gt;last_frame().interpreter_frame_method(),
1881                     thread-&gt;last_frame().interpreter_frame_bcp(),
1882                     klass, h_obj, fieldID);
1883 }
1884 
1885 void JvmtiExport::post_field_access(JavaThread *thread, Method* method,
1886   address location, Klass* field_klass, Handle object, jfieldID field) {
1887 
1888   HandleMark hm(thread);
1889   methodHandle mh(thread, method);
1890 
1891   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
1892   if (state == NULL) {
1893     return;
1894   }
1895   EVT_TRIG_TRACE(JVMTI_EVENT_FIELD_ACCESS, (&quot;[%s] Trg Field Access event triggered&quot;,
1896                       JvmtiTrace::safe_get_thread_name(thread)));
1897   JvmtiEnvThreadStateIterator it(state);
1898   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
1899     if (ets-&gt;is_enabled(JVMTI_EVENT_FIELD_ACCESS)) {
1900       EVT_TRACE(JVMTI_EVENT_FIELD_ACCESS, (&quot;[%s] Evt Field Access event sent %s.%s @ &quot; INTX_FORMAT,
1901                      JvmtiTrace::safe_get_thread_name(thread),
1902                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
1903                      (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
1904                      location - mh()-&gt;code_base() ));
1905 
1906       JvmtiEnv *env = ets-&gt;get_env();
1907       JvmtiLocationEventMark jem(thread, mh, location);
1908       jclass field_jclass = jem.to_jclass(field_klass);
1909       jobject field_jobject = jem.to_jobject(object());
1910       JvmtiJavaThreadEventTransition jet(thread);
1911       jvmtiEventFieldAccess callback = env-&gt;callbacks()-&gt;FieldAccess;
1912       if (callback != NULL) {
1913         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
1914                     jem.jni_methodID(), jem.location(),
1915                     field_jclass, field_jobject, field);
1916       }
1917     }
1918   }
1919 }
1920 
1921 oop JvmtiExport::jni_SetField_probe(JavaThread *thread, jobject jobj, oop obj,
1922                                     Klass* klass, jfieldID fieldID, bool is_static,
1923                                     char sig_type, jvalue *value) {
1924   if (*((int *)get_field_modification_count_addr()) &gt; 0 &amp;&amp; thread-&gt;has_last_Java_frame()) {
1925     // At least one field modification watch is set so we have more work
1926     // to do. This wrapper is used by entry points that allow us
1927     // to create handles in post_field_modification_by_jni().
1928     post_field_modification_by_jni(thread, obj, klass, fieldID, is_static, sig_type, value);
1929     // event posting can block so refetch oop if we were passed a jobj
1930     if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);
1931   }
1932   return obj;
1933 }
1934 
1935 oop JvmtiExport::jni_SetField_probe_nh(JavaThread *thread, jobject jobj, oop obj,
1936                                        Klass* klass, jfieldID fieldID, bool is_static,
1937                                        char sig_type, jvalue *value) {
1938   if (*((int *)get_field_modification_count_addr()) &gt; 0 &amp;&amp; thread-&gt;has_last_Java_frame()) {
1939     // At least one field modification watch is set so we have more work
1940     // to do. This wrapper is used by &quot;quick&quot; entry points that don&#39;t
1941     // allow us to create handles in post_field_modification_by_jni(). We
1942     // override that with a ResetNoHandleMark.
1943     ResetNoHandleMark rnhm;
1944     post_field_modification_by_jni(thread, obj, klass, fieldID, is_static, sig_type, value);
1945     // event posting can block so refetch oop if we were passed a jobj
1946     if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);
1947   }
1948   return obj;
1949 }
1950 
1951 void JvmtiExport::post_field_modification_by_jni(JavaThread *thread, oop obj,
1952                                                  Klass* klass, jfieldID fieldID, bool is_static,
1953                                                  char sig_type, jvalue *value) {
1954   // We must be called with a Java context in order to provide reasonable
1955   // values for the klazz, method, and location fields. The callers of this
1956   // function don&#39;t make the call unless there is a Java context.
1957   assert(thread-&gt;has_last_Java_frame(), &quot;must be called with Java context&quot;);
1958 
1959   ResourceMark rm;
1960   fieldDescriptor fd;
1961   // if get_field_descriptor finds fieldID to be invalid, then we just bail
1962   bool valid_fieldID = JvmtiEnv::get_field_descriptor(klass, fieldID, &amp;fd);
1963   assert(valid_fieldID == true,&quot;post_field_modification_by_jni called with invalid fieldID&quot;);
1964   if (!valid_fieldID) return;
1965   // field modifications are not watched so bail
1966   if (!fd.is_field_modification_watched()) return;
1967 
1968   HandleMark hm(thread);
1969 
1970   Handle h_obj;
1971   if (!is_static) {
1972     // non-static field accessors have an object, but we need a handle
1973     assert(obj != NULL, &quot;non-static needs an object&quot;);
1974     h_obj = Handle(thread, obj);
1975   }
1976   post_field_modification(thread,
1977                           thread-&gt;last_frame().interpreter_frame_method(),
1978                           thread-&gt;last_frame().interpreter_frame_bcp(),
1979                           klass, h_obj, fieldID, sig_type, value);
1980 }
1981 
1982 void JvmtiExport::post_raw_field_modification(JavaThread *thread, Method* method,
1983   address location, Klass* field_klass, Handle object, jfieldID field,
1984   char sig_type, jvalue *value) {
1985 
1986   if (sig_type == JVM_SIGNATURE_INT || sig_type == JVM_SIGNATURE_BOOLEAN ||
1987       sig_type == JVM_SIGNATURE_BYTE || sig_type == JVM_SIGNATURE_CHAR ||
1988       sig_type == JVM_SIGNATURE_SHORT) {
1989     // &#39;I&#39; instructions are used for byte, char, short and int.
1990     // determine which it really is, and convert
1991     fieldDescriptor fd;
1992     bool found = JvmtiEnv::get_field_descriptor(field_klass, field, &amp;fd);
1993     // should be found (if not, leave as is)
1994     if (found) {
1995       jint ival = value-&gt;i;
1996       // convert value from int to appropriate type
1997       switch (fd.field_type()) {
1998       case T_BOOLEAN:
1999         sig_type = JVM_SIGNATURE_BOOLEAN;
2000         value-&gt;i = 0; // clear it
2001         value-&gt;z = (jboolean)ival;
2002         break;
2003       case T_BYTE:
2004         sig_type = JVM_SIGNATURE_BYTE;
2005         value-&gt;i = 0; // clear it
2006         value-&gt;b = (jbyte)ival;
2007         break;
2008       case T_CHAR:
2009         sig_type = JVM_SIGNATURE_CHAR;
2010         value-&gt;i = 0; // clear it
2011         value-&gt;c = (jchar)ival;
2012         break;
2013       case T_SHORT:
2014         sig_type = JVM_SIGNATURE_SHORT;
2015         value-&gt;i = 0; // clear it
2016         value-&gt;s = (jshort)ival;
2017         break;
2018       case T_INT:
2019         // nothing to do
2020         break;
2021       default:
2022         // this is an integer instruction, should be one of above
2023         ShouldNotReachHere();
2024         break;
2025       }
2026     }
2027   }
2028 
2029   assert(sig_type != JVM_SIGNATURE_ARRAY, &quot;array should have sig_type == &#39;L&#39;&quot;);
2030   bool handle_created = false;
2031 
2032   // convert oop to JNI handle.
2033   if (sig_type == JVM_SIGNATURE_CLASS) {
2034     handle_created = true;
2035     value-&gt;l = (jobject)JNIHandles::make_local(thread, (oop)value-&gt;l);
2036   }
2037 
2038   post_field_modification(thread, method, location, field_klass, object, field, sig_type, value);
2039 
2040   // Destroy the JNI handle allocated above.
2041   if (handle_created) {
2042     JNIHandles::destroy_local(value-&gt;l);
2043   }
2044 }
2045 
2046 void JvmtiExport::post_field_modification(JavaThread *thread, Method* method,
2047   address location, Klass* field_klass, Handle object, jfieldID field,
2048   char sig_type, jvalue *value_ptr) {
2049 
2050   HandleMark hm(thread);
2051   methodHandle mh(thread, method);
2052 
2053   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2054   if (state == NULL) {
2055     return;
2056   }
2057   EVT_TRIG_TRACE(JVMTI_EVENT_FIELD_MODIFICATION,
2058                      (&quot;[%s] Trg Field Modification event triggered&quot;,
2059                       JvmtiTrace::safe_get_thread_name(thread)));
2060 
2061   JvmtiEnvThreadStateIterator it(state);
2062   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2063     if (ets-&gt;is_enabled(JVMTI_EVENT_FIELD_MODIFICATION)) {
2064       EVT_TRACE(JVMTI_EVENT_FIELD_MODIFICATION,
2065                    (&quot;[%s] Evt Field Modification event sent %s.%s @ &quot; INTX_FORMAT,
2066                     JvmtiTrace::safe_get_thread_name(thread),
2067                     (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;klass_name()-&gt;as_C_string(),
2068                     (mh() == NULL) ? &quot;NULL&quot; : mh()-&gt;name()-&gt;as_C_string(),
2069                     location - mh()-&gt;code_base() ));
2070 
2071       JvmtiEnv *env = ets-&gt;get_env();
2072       JvmtiLocationEventMark jem(thread, mh, location);
2073       jclass field_jclass = jem.to_jclass(field_klass);
2074       jobject field_jobject = jem.to_jobject(object());
2075       JvmtiJavaThreadEventTransition jet(thread);
2076       jvmtiEventFieldModification callback = env-&gt;callbacks()-&gt;FieldModification;
2077       if (callback != NULL) {
2078         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2079                     jem.jni_methodID(), jem.location(),
2080                     field_jclass, field_jobject, field, sig_type, *value_ptr);
2081       }
2082     }
2083   }
2084 }
2085 
2086 void JvmtiExport::post_native_method_bind(Method* method, address* function_ptr) {
2087   JavaThread* thread = JavaThread::current();
2088   assert(thread-&gt;thread_state() == _thread_in_vm, &quot;must be in vm state&quot;);
2089 
2090   HandleMark hm(thread);
2091   methodHandle mh(thread, method);
2092 
2093   EVT_TRIG_TRACE(JVMTI_EVENT_NATIVE_METHOD_BIND, (&quot;[%s] Trg Native Method Bind event triggered&quot;,
2094                       JvmtiTrace::safe_get_thread_name(thread)));
2095 
2096   if (JvmtiEventController::is_enabled(JVMTI_EVENT_NATIVE_METHOD_BIND)) {
2097     JvmtiEnvIterator it;
2098     for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2099       if (env-&gt;is_enabled(JVMTI_EVENT_NATIVE_METHOD_BIND)) {
2100         EVT_TRACE(JVMTI_EVENT_NATIVE_METHOD_BIND, (&quot;[%s] Evt Native Method Bind event sent&quot;,
2101                      JvmtiTrace::safe_get_thread_name(thread) ));
2102 
2103         JvmtiMethodEventMark jem(thread, mh);
2104         JvmtiJavaThreadEventTransition jet(thread);
2105         JNIEnv* jni_env = (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL) ? NULL : jem.jni_env();
2106         jvmtiEventNativeMethodBind callback = env-&gt;callbacks()-&gt;NativeMethodBind;
2107         if (callback != NULL) {
2108           (*callback)(env-&gt;jvmti_external(), jni_env, jem.jni_thread(),
2109                       jem.jni_methodID(), (void*)(*function_ptr), (void**)function_ptr);
2110         }
2111       }
2112     }
2113   }
2114 }
2115 
2116 // Returns a record containing inlining information for the given nmethod
2117 jvmtiCompiledMethodLoadInlineRecord* create_inline_record(nmethod* nm) {
2118   jint numstackframes = 0;
2119   jvmtiCompiledMethodLoadInlineRecord* record = (jvmtiCompiledMethodLoadInlineRecord*)NEW_RESOURCE_OBJ(jvmtiCompiledMethodLoadInlineRecord);
2120   record-&gt;header.kind = JVMTI_CMLR_INLINE_INFO;
2121   record-&gt;header.next = NULL;
2122   record-&gt;header.majorinfoversion = JVMTI_CMLR_MAJOR_VERSION_1;
2123   record-&gt;header.minorinfoversion = JVMTI_CMLR_MINOR_VERSION_0;
2124   record-&gt;numpcs = 0;
2125   for(PcDesc* p = nm-&gt;scopes_pcs_begin(); p &lt; nm-&gt;scopes_pcs_end(); p++) {
2126    if(p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null) continue;
2127    record-&gt;numpcs++;
2128   }
2129   record-&gt;pcinfo = (PCStackInfo*)(NEW_RESOURCE_ARRAY(PCStackInfo, record-&gt;numpcs));
2130   int scope = 0;
2131   for(PcDesc* p = nm-&gt;scopes_pcs_begin(); p &lt; nm-&gt;scopes_pcs_end(); p++) {
2132     if(p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null) continue;
2133     void* pc_address = (void*)p-&gt;real_pc(nm);
2134     assert(pc_address != NULL, &quot;pc_address must be non-null&quot;);
2135     record-&gt;pcinfo[scope].pc = pc_address;
2136     numstackframes=0;
2137     for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
2138       numstackframes++;
2139     }
2140     assert(numstackframes != 0, &quot;numstackframes must be nonzero.&quot;);
2141     record-&gt;pcinfo[scope].methods = (jmethodID *)NEW_RESOURCE_ARRAY(jmethodID, numstackframes);
2142     record-&gt;pcinfo[scope].bcis = (jint *)NEW_RESOURCE_ARRAY(jint, numstackframes);
2143     record-&gt;pcinfo[scope].numstackframes = numstackframes;
2144     int stackframe = 0;
2145     for(ScopeDesc* sd = nm-&gt;scope_desc_at(p-&gt;real_pc(nm));sd != NULL;sd = sd-&gt;sender()) {
2146       // sd-&gt;method() can be NULL for stubs but not for nmethods. To be completely robust, include an assert that we should never see a null sd-&gt;method()
2147       guarantee(sd-&gt;method() != NULL, &quot;sd-&gt;method() cannot be null.&quot;);
2148       record-&gt;pcinfo[scope].methods[stackframe] = sd-&gt;method()-&gt;jmethod_id();
2149       record-&gt;pcinfo[scope].bcis[stackframe] = sd-&gt;bci();
2150       stackframe++;
2151     }
2152     scope++;
2153   }
2154   return record;
2155 }
2156 
2157 void JvmtiExport::post_compiled_method_load(nmethod *nm) {
2158   guarantee(!nm-&gt;is_unloading(), &quot;nmethod isn&#39;t unloaded or unloading&quot;);
2159   if (JvmtiEnv::get_phase() &lt; JVMTI_PHASE_PRIMORDIAL) {
2160     return;
2161   }
2162   JavaThread* thread = JavaThread::current();
2163 
2164   EVT_TRIG_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,
2165                  (&quot;[%s] method compile load event triggered&quot;,
2166                  JvmtiTrace::safe_get_thread_name(thread)));
2167 
2168   JvmtiEnvIterator it;
2169   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2170     post_compiled_method_load(env, nm);
2171   }
2172 }
2173 
2174 // post a COMPILED_METHOD_LOAD event for a given environment
2175 void JvmtiExport::post_compiled_method_load(JvmtiEnv* env, nmethod *nm) {
2176   if (env-&gt;phase() == JVMTI_PHASE_PRIMORDIAL || !env-&gt;is_enabled(JVMTI_EVENT_COMPILED_METHOD_LOAD)) {
2177     return;
2178   }
2179   jvmtiEventCompiledMethodLoad callback = env-&gt;callbacks()-&gt;CompiledMethodLoad;
2180   if (callback == NULL) {
2181     return;
2182   }
2183   JavaThread* thread = JavaThread::current();
2184 
2185   EVT_TRACE(JVMTI_EVENT_COMPILED_METHOD_LOAD,
2186            (&quot;[%s] method compile load event sent %s.%s  &quot;,
2187             JvmtiTrace::safe_get_thread_name(thread),
2188             (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;klass_name()-&gt;as_C_string(),
2189             (nm-&gt;method() == NULL) ? &quot;NULL&quot; : nm-&gt;method()-&gt;name()-&gt;as_C_string()));
2190   ResourceMark rm(thread);
2191   HandleMark hm(thread);
2192 
2193   // Add inlining information
2194   jvmtiCompiledMethodLoadInlineRecord* inlinerecord = create_inline_record(nm);
2195   // Pass inlining information through the void pointer
2196   JvmtiCompiledMethodLoadEventMark jem(thread, nm, inlinerecord);
2197   JvmtiJavaThreadEventTransition jet(thread);
2198   (*callback)(env-&gt;jvmti_external(), jem.jni_methodID(),
2199               jem.code_size(), jem.code_data(), jem.map_length(),
2200               jem.map(), jem.compile_info());
2201 }
2202 
2203 void JvmtiExport::post_dynamic_code_generated_internal(const char *name, const void *code_begin, const void *code_end) {
2204   assert(name != NULL &amp;&amp; name[0] != &#39;\0&#39;, &quot;sanity check&quot;);
2205 
2206   JavaThread* thread = JavaThread::current();
2207   // In theory everyone coming thru here is in_vm but we need to be certain
2208   // because a callee will do a vm-&gt;native transition
2209   ThreadInVMfromUnknown __tiv;
2210 
2211   EVT_TRIG_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2212                  (&quot;[%s] method dynamic code generated event triggered&quot;,
2213                  JvmtiTrace::safe_get_thread_name(thread)));
2214   JvmtiEnvIterator it;
2215   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2216     if (env-&gt;is_enabled(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
2217       EVT_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2218                 (&quot;[%s] dynamic code generated event sent for %s&quot;,
2219                 JvmtiTrace::safe_get_thread_name(thread), name));
2220       JvmtiEventMark jem(thread);
2221       JvmtiJavaThreadEventTransition jet(thread);
2222       jint length = (jint)pointer_delta(code_end, code_begin, sizeof(char));
2223       jvmtiEventDynamicCodeGenerated callback = env-&gt;callbacks()-&gt;DynamicCodeGenerated;
2224       if (callback != NULL) {
2225         (*callback)(env-&gt;jvmti_external(), name, (void*)code_begin, length);
2226       }
2227     }
2228   }
2229 }
2230 
2231 void JvmtiExport::post_dynamic_code_generated(const char *name, const void *code_begin, const void *code_end) {
2232   jvmtiPhase phase = JvmtiEnv::get_phase();
2233   if (phase == JVMTI_PHASE_PRIMORDIAL || phase == JVMTI_PHASE_START) {
2234     post_dynamic_code_generated_internal(name, code_begin, code_end);
2235   } else {
2236     // It may not be safe to post the event from this thread.  Defer all
2237     // postings to the service thread so that it can perform them in a safe
2238     // context and in-order.
2239     JvmtiDeferredEvent event = JvmtiDeferredEvent::dynamic_code_generated_event(
2240         name, code_begin, code_end);
2241     ServiceThread::enqueue_deferred_event(&amp;event);
2242   }
2243 }
2244 
2245 
2246 // post a DYNAMIC_CODE_GENERATED event for a given environment
2247 // used by GenerateEvents
2248 void JvmtiExport::post_dynamic_code_generated(JvmtiEnv* env, const char *name,
2249                                               const void *code_begin, const void *code_end)
2250 {
2251   JavaThread* thread = JavaThread::current();
2252   EVT_TRIG_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2253                  (&quot;[%s] dynamic code generated event triggered (by GenerateEvents)&quot;,
2254                   JvmtiTrace::safe_get_thread_name(thread)));
2255   if (env-&gt;is_enabled(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
2256     EVT_TRACE(JVMTI_EVENT_DYNAMIC_CODE_GENERATED,
2257               (&quot;[%s] dynamic code generated event sent for %s&quot;,
2258                JvmtiTrace::safe_get_thread_name(thread), name));
2259     JvmtiEventMark jem(thread);
2260     JvmtiJavaThreadEventTransition jet(thread);
2261     jint length = (jint)pointer_delta(code_end, code_begin, sizeof(char));
2262     jvmtiEventDynamicCodeGenerated callback = env-&gt;callbacks()-&gt;DynamicCodeGenerated;
2263     if (callback != NULL) {
2264       (*callback)(env-&gt;jvmti_external(), name, (void*)code_begin, length);
2265     }
2266   }
2267 }
2268 
2269 // post a DynamicCodeGenerated event while holding locks in the VM.
2270 void JvmtiExport::post_dynamic_code_generated_while_holding_locks(const char* name,
2271                                                                   address code_begin, address code_end)
2272 {
2273   // register the stub with the current dynamic code event collector
2274   // Cannot take safepoint here so do not use state_for to get
2275   // jvmti thread state.
2276   JvmtiThreadState* state = JavaThread::current()-&gt;jvmti_thread_state();
2277   // state can only be NULL if the current thread is exiting which
2278   // should not happen since we&#39;re trying to post an event
2279   guarantee(state != NULL, &quot;attempt to register stub via an exiting thread&quot;);
2280   JvmtiDynamicCodeEventCollector* collector = state-&gt;get_dynamic_code_event_collector();
2281   guarantee(collector != NULL, &quot;attempt to register stub without event collector&quot;);
2282   collector-&gt;register_stub(name, code_begin, code_end);
2283 }
2284 
2285 // Collect all the vm internally allocated objects which are visible to java world
2286 void JvmtiExport::record_vm_internal_object_allocation(oop obj) {
2287   Thread* thread = Thread::current_or_null();
2288   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2289     // Can not take safepoint here.
2290     NoSafepointVerifier no_sfpt;
2291     // Cannot take safepoint here so do not use state_for to get
2292     // jvmti thread state.
2293     JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
2294     if (state != NULL) {
2295       // state is non NULL when VMObjectAllocEventCollector is enabled.
2296       JvmtiVMObjectAllocEventCollector *collector;
2297       collector = state-&gt;get_vm_object_alloc_event_collector();
2298       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2299         // Don&#39;t record classes as these will be notified via the ClassLoad
2300         // event.
2301         if (obj-&gt;klass() != SystemDictionary::Class_klass()) {
2302           collector-&gt;record_allocation(obj);
2303         }
2304       }
2305     }
2306   }
2307 }
2308 
2309 // Collect all the sampled allocated objects.
2310 void JvmtiExport::record_sampled_internal_object_allocation(oop obj) {
2311   Thread* thread = Thread::current_or_null();
2312   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2313     // Can not take safepoint here.
2314     NoSafepointVerifier no_sfpt;
2315     // Cannot take safepoint here so do not use state_for to get
2316     // jvmti thread state.
2317     JvmtiThreadState *state = ((JavaThread*)thread)-&gt;jvmti_thread_state();
2318     if (state != NULL) {
2319       // state is non NULL when SampledObjectAllocEventCollector is enabled.
2320       JvmtiSampledObjectAllocEventCollector *collector;
2321       collector = state-&gt;get_sampled_object_alloc_event_collector();
2322 
2323       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2324         collector-&gt;record_allocation(obj);
2325       }
2326     }
2327   }
2328 }
2329 
2330 void JvmtiExport::post_garbage_collection_finish() {
2331   Thread *thread = Thread::current(); // this event is posted from VM-Thread.
2332   EVT_TRIG_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH,
2333                  (&quot;[%s] garbage collection finish event triggered&quot;,
2334                   JvmtiTrace::safe_get_thread_name(thread)));
2335   JvmtiEnvIterator it;
2336   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2337     if (env-&gt;is_enabled(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH)) {
2338       EVT_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH,
2339                 (&quot;[%s] garbage collection finish event sent&quot;,
2340                  JvmtiTrace::safe_get_thread_name(thread)));
2341       JvmtiThreadEventTransition jet(thread);
2342       // JNIEnv is NULL here because this event is posted from VM Thread
2343       jvmtiEventGarbageCollectionFinish callback = env-&gt;callbacks()-&gt;GarbageCollectionFinish;
2344       if (callback != NULL) {
2345         (*callback)(env-&gt;jvmti_external());
2346       }
2347     }
2348   }
2349 }
2350 
2351 void JvmtiExport::post_garbage_collection_start() {
2352   Thread* thread = Thread::current(); // this event is posted from vm-thread.
2353   EVT_TRIG_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_START,
2354                  (&quot;[%s] garbage collection start event triggered&quot;,
2355                   JvmtiTrace::safe_get_thread_name(thread)));
2356   JvmtiEnvIterator it;
2357   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2358     if (env-&gt;is_enabled(JVMTI_EVENT_GARBAGE_COLLECTION_START)) {
2359       EVT_TRACE(JVMTI_EVENT_GARBAGE_COLLECTION_START,
2360                 (&quot;[%s] garbage collection start event sent&quot;,
2361                  JvmtiTrace::safe_get_thread_name(thread)));
2362       JvmtiThreadEventTransition jet(thread);
2363       // JNIEnv is NULL here because this event is posted from VM Thread
2364       jvmtiEventGarbageCollectionStart callback = env-&gt;callbacks()-&gt;GarbageCollectionStart;
2365       if (callback != NULL) {
2366         (*callback)(env-&gt;jvmti_external());
2367       }
2368     }
2369   }
2370 }
2371 
2372 void JvmtiExport::post_data_dump() {
2373   Thread *thread = Thread::current();
2374   EVT_TRIG_TRACE(JVMTI_EVENT_DATA_DUMP_REQUEST,
2375                  (&quot;[%s] data dump request event triggered&quot;,
2376                   JvmtiTrace::safe_get_thread_name(thread)));
2377   JvmtiEnvIterator it;
2378   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2379     if (env-&gt;is_enabled(JVMTI_EVENT_DATA_DUMP_REQUEST)) {
2380       EVT_TRACE(JVMTI_EVENT_DATA_DUMP_REQUEST,
2381                 (&quot;[%s] data dump request event sent&quot;,
2382                  JvmtiTrace::safe_get_thread_name(thread)));
2383      JvmtiThreadEventTransition jet(thread);
2384      // JNIEnv is NULL here because this event is posted from VM Thread
2385      jvmtiEventDataDumpRequest callback = env-&gt;callbacks()-&gt;DataDumpRequest;
2386      if (callback != NULL) {
2387        (*callback)(env-&gt;jvmti_external());
2388      }
2389     }
2390   }
2391 }
2392 
2393 void JvmtiExport::post_monitor_contended_enter(JavaThread *thread, ObjectMonitor *obj_mntr) {
2394   oop object = (oop)obj_mntr-&gt;object();
2395   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2396   if (state == NULL) {
2397     return;
2398   }
2399 
2400   HandleMark hm(thread);
2401   Handle h(thread, object);
2402 
2403   EVT_TRIG_TRACE(JVMTI_EVENT_MONITOR_CONTENDED_ENTER,
2404                      (&quot;[%s] monitor contended enter event triggered&quot;,
2405                       JvmtiTrace::safe_get_thread_name(thread)));
2406 
2407   JvmtiEnvThreadStateIterator it(state);
2408   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2409     if (ets-&gt;is_enabled(JVMTI_EVENT_MONITOR_CONTENDED_ENTER)) {
2410       EVT_TRACE(JVMTI_EVENT_MONITOR_CONTENDED_ENTER,
2411                    (&quot;[%s] monitor contended enter event sent&quot;,
2412                     JvmtiTrace::safe_get_thread_name(thread)));
2413       JvmtiMonitorEventMark  jem(thread, h());
2414       JvmtiEnv *env = ets-&gt;get_env();
2415       JvmtiThreadEventTransition jet(thread);
2416       jvmtiEventMonitorContendedEnter callback = env-&gt;callbacks()-&gt;MonitorContendedEnter;
2417       if (callback != NULL) {
2418         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_object());
2419       }
2420     }
2421   }
2422 }
2423 
2424 void JvmtiExport::post_monitor_contended_entered(JavaThread *thread, ObjectMonitor *obj_mntr) {
2425   oop object = (oop)obj_mntr-&gt;object();
2426   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2427   if (state == NULL) {
2428     return;
2429   }
2430 
2431   HandleMark hm(thread);
2432   Handle h(thread, object);
2433 
2434   EVT_TRIG_TRACE(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,
2435                      (&quot;[%s] monitor contended entered event triggered&quot;,
2436                       JvmtiTrace::safe_get_thread_name(thread)));
2437 
2438   JvmtiEnvThreadStateIterator it(state);
2439   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2440     if (ets-&gt;is_enabled(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED)) {
2441       EVT_TRACE(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,
2442                    (&quot;[%s] monitor contended enter event sent&quot;,
2443                     JvmtiTrace::safe_get_thread_name(thread)));
2444       JvmtiMonitorEventMark  jem(thread, h());
2445       JvmtiEnv *env = ets-&gt;get_env();
2446       JvmtiThreadEventTransition jet(thread);
2447       jvmtiEventMonitorContendedEntered callback = env-&gt;callbacks()-&gt;MonitorContendedEntered;
2448       if (callback != NULL) {
2449         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(), jem.jni_object());
2450       }
2451     }
2452   }
2453 }
2454 
2455 void JvmtiExport::post_monitor_wait(JavaThread *thread, oop object,
2456                                           jlong timeout) {
2457   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2458   if (state == NULL) {
2459     return;
2460   }
2461 
2462   HandleMark hm(thread);
2463   Handle h(thread, object);
2464 
2465   EVT_TRIG_TRACE(JVMTI_EVENT_MONITOR_WAIT,
2466                      (&quot;[%s] monitor wait event triggered&quot;,
2467                       JvmtiTrace::safe_get_thread_name(thread)));
2468 
2469   JvmtiEnvThreadStateIterator it(state);
2470   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2471     if (ets-&gt;is_enabled(JVMTI_EVENT_MONITOR_WAIT)) {
2472       EVT_TRACE(JVMTI_EVENT_MONITOR_WAIT,
2473                    (&quot;[%s] monitor wait event sent&quot;,
2474                     JvmtiTrace::safe_get_thread_name(thread)));
2475       JvmtiMonitorEventMark  jem(thread, h());
2476       JvmtiEnv *env = ets-&gt;get_env();
2477       JvmtiThreadEventTransition jet(thread);
2478       jvmtiEventMonitorWait callback = env-&gt;callbacks()-&gt;MonitorWait;
2479       if (callback != NULL) {
2480         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2481                     jem.jni_object(), timeout);
2482       }
2483     }
2484   }
2485 }
2486 
2487 void JvmtiExport::post_monitor_waited(JavaThread *thread, ObjectMonitor *obj_mntr, jboolean timed_out) {
2488   oop object = (oop)obj_mntr-&gt;object();
2489   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2490   if (state == NULL) {
2491     return;
2492   }
2493 
2494   HandleMark hm(thread);
2495   Handle h(thread, object);
2496 
2497   EVT_TRIG_TRACE(JVMTI_EVENT_MONITOR_WAITED,
2498                      (&quot;[%s] monitor waited event triggered&quot;,
2499                       JvmtiTrace::safe_get_thread_name(thread)));
2500 
2501   JvmtiEnvThreadStateIterator it(state);
2502   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2503     if (ets-&gt;is_enabled(JVMTI_EVENT_MONITOR_WAITED)) {
2504       EVT_TRACE(JVMTI_EVENT_MONITOR_WAITED,
2505                    (&quot;[%s] monitor waited event sent&quot;,
2506                     JvmtiTrace::safe_get_thread_name(thread)));
2507       JvmtiMonitorEventMark  jem(thread, h());
2508       JvmtiEnv *env = ets-&gt;get_env();
2509       JvmtiThreadEventTransition jet(thread);
2510       jvmtiEventMonitorWaited callback = env-&gt;callbacks()-&gt;MonitorWaited;
2511       if (callback != NULL) {
2512         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2513                     jem.jni_object(), timed_out);
2514       }
2515     }
2516   }
2517 }
2518 
2519 void JvmtiExport::post_vm_object_alloc(JavaThread *thread, oop object) {
2520   EVT_TRIG_TRACE(JVMTI_EVENT_VM_OBJECT_ALLOC, (&quot;[%s] Trg vm object alloc triggered&quot;,
2521                       JvmtiTrace::safe_get_thread_name(thread)));
2522   if (object == NULL) {
2523     return;
2524   }
2525   HandleMark hm(thread);
2526   Handle h(thread, object);
2527   JvmtiEnvIterator it;
2528   for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
2529     if (env-&gt;is_enabled(JVMTI_EVENT_VM_OBJECT_ALLOC)) {
2530       EVT_TRACE(JVMTI_EVENT_VM_OBJECT_ALLOC, (&quot;[%s] Evt vmobject alloc sent %s&quot;,
2531                                          JvmtiTrace::safe_get_thread_name(thread),
2532                                          object==NULL? &quot;NULL&quot; : object-&gt;klass()-&gt;external_name()));
2533 
2534       JvmtiObjectAllocEventMark jem(thread, h());
2535       JvmtiJavaThreadEventTransition jet(thread);
2536       jvmtiEventVMObjectAlloc callback = env-&gt;callbacks()-&gt;VMObjectAlloc;
2537       if (callback != NULL) {
2538         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2539                     jem.jni_jobject(), jem.jni_class(), jem.size());
2540       }
2541     }
2542   }
2543 }
2544 
2545 void JvmtiExport::post_sampled_object_alloc(JavaThread *thread, oop object) {
2546   JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
2547   if (state == NULL) {
2548     return;
2549   }
2550 
2551   EVT_TRIG_TRACE(JVMTI_EVENT_SAMPLED_OBJECT_ALLOC,
2552                  (&quot;[%s] Trg sampled object alloc triggered&quot;,
2553                   JvmtiTrace::safe_get_thread_name(thread)));
2554   if (object == NULL) {
2555     return;
2556   }
2557   HandleMark hm(thread);
2558   Handle h(thread, object);
2559 
2560   JvmtiEnvThreadStateIterator it(state);
2561   for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {
2562     if (ets-&gt;is_enabled(JVMTI_EVENT_SAMPLED_OBJECT_ALLOC)) {
2563       EVT_TRACE(JVMTI_EVENT_SAMPLED_OBJECT_ALLOC,
2564                 (&quot;[%s] Evt sampled object alloc sent %s&quot;,
2565                  JvmtiTrace::safe_get_thread_name(thread),
2566                  object == NULL ? &quot;NULL&quot; : object-&gt;klass()-&gt;external_name()));
2567 
2568       JvmtiEnv *env = ets-&gt;get_env();
2569       JvmtiObjectAllocEventMark jem(thread, h());
2570       JvmtiJavaThreadEventTransition jet(thread);
2571       jvmtiEventSampledObjectAlloc callback = env-&gt;callbacks()-&gt;SampledObjectAlloc;
2572       if (callback != NULL) {
2573         (*callback)(env-&gt;jvmti_external(), jem.jni_env(), jem.jni_thread(),
2574                     jem.jni_jobject(), jem.jni_class(), jem.size());
2575       }
2576     }
2577   }
2578 }
2579 
2580 ////////////////////////////////////////////////////////////////////////////////////////////////
2581 
2582 void JvmtiExport::cleanup_thread(JavaThread* thread) {
2583   assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
2584   MutexLocker mu(thread, JvmtiThreadState_lock);
2585 
2586   if (thread-&gt;jvmti_thread_state() != NULL) {
2587     // This has to happen after the thread state is removed, which is
2588     // why it is not in post_thread_end_event like its complement
2589     // Maybe both these functions should be rolled into the posts?
2590     JvmtiEventController::thread_ended(thread);
2591   }
2592 }
2593 
2594 void JvmtiExport::clear_detected_exception(JavaThread* thread) {
2595   assert(JavaThread::current() == thread, &quot;thread is not current&quot;);
2596 
2597   JvmtiThreadState* state = thread-&gt;jvmti_thread_state();
2598   if (state != NULL) {
2599     state-&gt;clear_exception_state();
2600   }
2601 }
2602 
2603 void JvmtiExport::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
2604   JvmtiTagMap::weak_oops_do(is_alive, f);
2605 }
2606 
2607 // Onload raw monitor transition.
2608 void JvmtiExport::transition_pending_onload_raw_monitors() {
2609   JvmtiPendingMonitors::transition_raw_monitors();
2610 }
2611 
2612 ////////////////////////////////////////////////////////////////////////////////////////////////
2613 #if INCLUDE_SERVICES
2614 // Attach is disabled if SERVICES is not included
2615 
2616 // type for the Agent_OnAttach entry point
2617 extern &quot;C&quot; {
2618   typedef jint (JNICALL *OnAttachEntry_t)(JavaVM*, char *, void *);
2619 }
2620 
2621 jint JvmtiExport::load_agent_library(const char *agent, const char *absParam,
2622                                      const char *options, outputStream* st) {
2623   char ebuf[1024] = {0};
2624   char buffer[JVM_MAXPATHLEN];
2625   void* library = NULL;
2626   jint result = JNI_ERR;
2627   const char *on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;
2628   size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);
2629 
2630   // The abs paramter should be &quot;true&quot; or &quot;false&quot;
2631   bool is_absolute_path = (absParam != NULL) &amp;&amp; (strcmp(absParam,&quot;true&quot;)==0);
2632 
2633   // Initially marked as invalid. It will be set to valid if we can find the agent
2634   AgentLibrary *agent_lib = new AgentLibrary(agent, options, is_absolute_path, NULL);
2635 
2636   // Check for statically linked in agent. If not found then if the path is
2637   // absolute we attempt to load the library. Otherwise we try to load it
2638   // from the standard dll directory.
2639 
2640   if (!os::find_builtin_agent(agent_lib, on_attach_symbols, num_symbol_entries)) {
2641     if (is_absolute_path) {
2642       library = os::dll_load(agent, ebuf, sizeof ebuf);
2643     } else {
2644       // Try to load the agent from the standard dll directory
2645       if (os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(),
2646                              agent)) {
2647         library = os::dll_load(buffer, ebuf, sizeof ebuf);
2648       }
2649       if (library == NULL) {
2650         // not found - try OS default library path
2651         if (os::dll_build_name(buffer, sizeof(buffer), agent)) {
2652           library = os::dll_load(buffer, ebuf, sizeof ebuf);
2653         }
2654       }
2655     }
2656     if (library != NULL) {
2657       agent_lib-&gt;set_os_lib(library);
2658       agent_lib-&gt;set_valid();
2659     }
2660   }
2661   // If the library was loaded then we attempt to invoke the Agent_OnAttach
2662   // function
2663   if (agent_lib-&gt;valid()) {
2664     // Lookup the Agent_OnAttach function
2665     OnAttachEntry_t on_attach_entry = NULL;
2666     on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,
2667        os::find_agent_function(agent_lib, false, on_attach_symbols, num_symbol_entries));
2668     if (on_attach_entry == NULL) {
2669       // Agent_OnAttach missing - unload library
2670       if (!agent_lib-&gt;is_static_lib()) {
2671         os::dll_unload(library);
2672       }
2673       st-&gt;print_cr(&quot;%s is not available in %s&quot;,
2674                    on_attach_symbols[0], agent_lib-&gt;name());
2675       delete agent_lib;
2676     } else {
2677       // Invoke the Agent_OnAttach function
2678       JavaThread* THREAD = JavaThread::current();
2679       {
2680         extern struct JavaVM_ main_vm;
2681         JvmtiThreadEventMark jem(THREAD);
2682         JvmtiJavaThreadEventTransition jet(THREAD);
2683 
2684         result = (*on_attach_entry)(&amp;main_vm, (char*)options, NULL);
2685       }
2686 
2687       // Agent_OnAttach may have used JNI
2688       if (HAS_PENDING_EXCEPTION) {
2689         CLEAR_PENDING_EXCEPTION;
2690       }
2691 
2692       // If OnAttach returns JNI_OK then we add it to the list of
2693       // agent libraries so that we can call Agent_OnUnload later.
2694       if (result == JNI_OK) {
2695         Arguments::add_loaded_agent(agent_lib);
2696       } else {
2697         delete agent_lib;
2698       }
2699 
2700       // Agent_OnAttach executed so completion status is JNI_OK
2701       st-&gt;print_cr(&quot;return code: %d&quot;, result);
2702       result = JNI_OK;
2703     }
2704   } else {
2705     st-&gt;print_cr(&quot;%s was not loaded.&quot;, agent);
2706     if (*ebuf != &#39;\0&#39;) {
2707       st-&gt;print_cr(&quot;%s&quot;, ebuf);
2708     }
2709   }
2710   return result;
2711 }
2712 
2713 #endif // INCLUDE_SERVICES
2714 ////////////////////////////////////////////////////////////////////////////////////////////////
2715 
2716 // Setup current current thread for event collection.
2717 void JvmtiEventCollector::setup_jvmti_thread_state() {
2718   // set this event collector to be the current one.
2719   JvmtiThreadState* state = JvmtiThreadState::state_for(JavaThread::current());
2720   // state can only be NULL if the current thread is exiting which
2721   // should not happen since we&#39;re trying to configure for event collection
2722   guarantee(state != NULL, &quot;exiting thread called setup_jvmti_thread_state&quot;);
2723   if (is_vm_object_alloc_event()) {
2724     JvmtiVMObjectAllocEventCollector *prev = state-&gt;get_vm_object_alloc_event_collector();
2725 
2726     // If we have a previous collector and it is disabled, it means this allocation came from a
2727     // callback induced VM Object allocation, do not register this collector then.
2728     if (prev &amp;&amp; !prev-&gt;is_enabled()) {
2729       return;
2730     }
2731     _prev = prev;
2732     state-&gt;set_vm_object_alloc_event_collector((JvmtiVMObjectAllocEventCollector *)this);
2733   } else if (is_dynamic_code_event()) {
2734     _prev = state-&gt;get_dynamic_code_event_collector();
2735     state-&gt;set_dynamic_code_event_collector((JvmtiDynamicCodeEventCollector *)this);
2736   } else if (is_sampled_object_alloc_event()) {
2737     JvmtiSampledObjectAllocEventCollector *prev = state-&gt;get_sampled_object_alloc_event_collector();
2738 
2739     if (prev) {
2740       // JvmtiSampledObjectAllocEventCollector wants only one active collector
2741       // enabled. This allows to have a collector detect a user code requiring
2742       // a sample in the callback.
2743       return;
2744     }
2745     state-&gt;set_sampled_object_alloc_event_collector((JvmtiSampledObjectAllocEventCollector*) this);
2746   }
2747 
2748   _unset_jvmti_thread_state = true;
2749 }
2750 
2751 // Unset current event collection in this thread and reset it with previous
2752 // collector.
2753 void JvmtiEventCollector::unset_jvmti_thread_state() {
2754   if (!_unset_jvmti_thread_state) {
2755     return;
2756   }
2757 
2758   JvmtiThreadState* state = JavaThread::current()-&gt;jvmti_thread_state();
2759   if (state != NULL) {
2760     // restore the previous event collector (if any)
2761     if (is_vm_object_alloc_event()) {
2762       if (state-&gt;get_vm_object_alloc_event_collector() == this) {
2763         state-&gt;set_vm_object_alloc_event_collector((JvmtiVMObjectAllocEventCollector *)_prev);
2764       } else {
2765         // this thread&#39;s jvmti state was created during the scope of
2766         // the event collector.
2767       }
2768     } else if (is_dynamic_code_event()) {
2769       if (state-&gt;get_dynamic_code_event_collector() == this) {
2770         state-&gt;set_dynamic_code_event_collector((JvmtiDynamicCodeEventCollector *)_prev);
2771       } else {
2772         // this thread&#39;s jvmti state was created during the scope of
2773         // the event collector.
2774       }
2775     } else if (is_sampled_object_alloc_event()) {
2776       if (state-&gt;get_sampled_object_alloc_event_collector() == this) {
2777         state-&gt;set_sampled_object_alloc_event_collector((JvmtiSampledObjectAllocEventCollector*)_prev);
2778       } else {
2779         // this thread&#39;s jvmti state was created during the scope of
2780         // the event collector.
2781       }
2782     }
2783   }
2784 }
2785 
2786 // create the dynamic code event collector
2787 JvmtiDynamicCodeEventCollector::JvmtiDynamicCodeEventCollector() : _code_blobs(NULL) {
2788   if (JvmtiExport::should_post_dynamic_code_generated()) {
2789     setup_jvmti_thread_state();
2790   }
2791 }
2792 
2793 // iterate over any code blob descriptors collected and post a
2794 // DYNAMIC_CODE_GENERATED event to the profiler.
2795 JvmtiDynamicCodeEventCollector::~JvmtiDynamicCodeEventCollector() {
2796   assert(!JavaThread::current()-&gt;owns_locks(), &quot;all locks must be released to post deferred events&quot;);
2797  // iterate over any code blob descriptors that we collected
2798  if (_code_blobs != NULL) {
2799    for (int i=0; i&lt;_code_blobs-&gt;length(); i++) {
2800      JvmtiCodeBlobDesc* blob = _code_blobs-&gt;at(i);
2801      JvmtiExport::post_dynamic_code_generated(blob-&gt;name(), blob-&gt;code_begin(), blob-&gt;code_end());
2802      FreeHeap(blob);
2803    }
2804    delete _code_blobs;
2805  }
2806  unset_jvmti_thread_state();
2807 }
2808 
2809 // register a stub
2810 void JvmtiDynamicCodeEventCollector::register_stub(const char* name, address start, address end) {
2811  if (_code_blobs == NULL) {
2812    _code_blobs = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;JvmtiCodeBlobDesc*&gt;(1, mtServiceability);
2813  }
2814  _code_blobs-&gt;append(new JvmtiCodeBlobDesc(name, start, end));
2815 }
2816 
2817 // Setup current thread to record vm allocated objects.
2818 JvmtiObjectAllocEventCollector::JvmtiObjectAllocEventCollector() :
2819     _allocated(NULL), _enable(false), _post_callback(NULL) {
2820 }
2821 
2822 // Post vm_object_alloc event for vm allocated objects visible to java
2823 // world.
2824 void JvmtiObjectAllocEventCollector::generate_call_for_allocated() {
2825   if (_allocated) {
2826     set_enabled(false);
2827     for (int i = 0; i &lt; _allocated-&gt;length(); i++) {
2828       oop obj = _allocated-&gt;at(i).resolve();
2829       _post_callback(JavaThread::current(), obj);
2830       // Release OopHandle
2831       _allocated-&gt;at(i).release(Universe::vm_global());
2832 
2833     }
2834     delete _allocated, _allocated = NULL;
2835   }
2836 }
2837 
2838 void JvmtiObjectAllocEventCollector::record_allocation(oop obj) {
2839   assert(is_enabled(), &quot;Object alloc event collector is not enabled&quot;);
2840   if (_allocated == NULL) {
2841     _allocated = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;OopHandle&gt;(1, mtServiceability);
2842   }
2843   _allocated-&gt;push(OopHandle(Universe::vm_global(), obj));
2844 }
2845 
2846 // Disable collection of VMObjectAlloc events
2847 NoJvmtiVMObjectAllocMark::NoJvmtiVMObjectAllocMark() : _collector(NULL) {
2848   // a no-op if VMObjectAlloc event is not enabled
2849   if (!JvmtiExport::should_post_vm_object_alloc()) {
2850     return;
2851   }
2852   Thread* thread = Thread::current_or_null();
2853   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread())  {
2854     JavaThread* current_thread = (JavaThread*)thread;
2855     JvmtiThreadState *state = current_thread-&gt;jvmti_thread_state();
2856     if (state != NULL) {
2857       JvmtiVMObjectAllocEventCollector *collector;
2858       collector = state-&gt;get_vm_object_alloc_event_collector();
2859       if (collector != NULL &amp;&amp; collector-&gt;is_enabled()) {
2860         _collector = collector;
2861         _collector-&gt;set_enabled(false);
2862       }
2863     }
2864   }
2865 }
2866 
2867 // Re-Enable collection of VMObjectAlloc events (if previously enabled)
2868 NoJvmtiVMObjectAllocMark::~NoJvmtiVMObjectAllocMark() {
2869   if (was_enabled()) {
2870     _collector-&gt;set_enabled(true);
2871   }
2872 };
2873 
2874 // Setup current thread to record vm allocated objects.
2875 JvmtiVMObjectAllocEventCollector::JvmtiVMObjectAllocEventCollector() {
2876   if (JvmtiExport::should_post_vm_object_alloc()) {
2877     _enable = true;
2878     setup_jvmti_thread_state();
2879     _post_callback = JvmtiExport::post_vm_object_alloc;
2880   }
2881 }
2882 
2883 JvmtiVMObjectAllocEventCollector::~JvmtiVMObjectAllocEventCollector() {
2884   if (_enable) {
2885     generate_call_for_allocated();
2886   }
2887   unset_jvmti_thread_state();
2888 }
2889 
2890 bool JvmtiSampledObjectAllocEventCollector::object_alloc_is_safe_to_sample() {
2891   Thread* thread = Thread::current();
2892   // Really only sample allocations if this is a JavaThread and not the compiler
2893   // thread.
2894   if (!thread-&gt;is_Java_thread() || thread-&gt;is_Compiler_thread()) {
2895     return false;
2896   }
2897 
2898   if (MultiArray_lock-&gt;owner() == thread) {
2899     return false;
2900   }
2901   return true;
2902 }
2903 
2904 // Setup current thread to record sampled allocated objects.
2905 JvmtiSampledObjectAllocEventCollector::JvmtiSampledObjectAllocEventCollector() {
2906   if (JvmtiExport::should_post_sampled_object_alloc()) {
2907     if (!object_alloc_is_safe_to_sample()) {
2908       return;
2909     }
2910 
2911     _enable = true;
2912     setup_jvmti_thread_state();
2913     _post_callback = JvmtiExport::post_sampled_object_alloc;
2914   }
2915 }
2916 
2917 JvmtiSampledObjectAllocEventCollector::~JvmtiSampledObjectAllocEventCollector() {
2918   if (!_enable) {
2919     return;
2920   }
2921 
2922   generate_call_for_allocated();
2923   unset_jvmti_thread_state();
2924 
2925   // Unset the sampling collector as present in assertion mode only.
2926   assert(Thread::current()-&gt;is_Java_thread(),
2927          &quot;Should always be in a Java thread&quot;);
2928 }
2929 
2930 JvmtiGCMarker::JvmtiGCMarker() {
2931   // if there aren&#39;t any JVMTI environments then nothing to do
2932   if (!JvmtiEnv::environments_might_exist()) {
2933     return;
2934   }
2935 
2936   if (JvmtiExport::should_post_garbage_collection_start()) {
2937     JvmtiExport::post_garbage_collection_start();
2938   }
2939 
2940   if (SafepointSynchronize::is_at_safepoint()) {
2941     // Do clean up tasks that need to be done at a safepoint
2942     JvmtiEnvBase::check_for_periodic_clean_up();
2943   }
2944 }
2945 
2946 JvmtiGCMarker::~JvmtiGCMarker() {
2947   // if there aren&#39;t any JVMTI environments then nothing to do
2948   if (!JvmtiEnv::environments_might_exist()) {
2949     return;
2950   }
2951 
2952   // JVMTI notify gc finish
2953   if (JvmtiExport::should_post_garbage_collection_finish()) {
2954     JvmtiExport::post_garbage_collection_finish();
2955   }
2956 }
    </pre>
  </body>
</html>