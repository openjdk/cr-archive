<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvmtiEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnter.xsl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.xsl.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiEnv.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 658,11 ***</span>
        return JVMTI_ERROR_ILLEGAL_ARGUMENT;
      }
  
      // lock the loader
      Thread* thread = Thread::current();
<span class="line-modified">!     HandleMark hm;</span>
      Handle loader_lock = Handle(thread, SystemDictionary::system_loader_lock());
  
      ObjectLocker ol(loader_lock, thread);
  
      // add the jar file to the bootclasspath
<span class="line-new-header">--- 658,11 ---</span>
        return JVMTI_ERROR_ILLEGAL_ARGUMENT;
      }
  
      // lock the loader
      Thread* thread = Thread::current();
<span class="line-modified">!     HandleMark hm(thread);</span>
      Handle loader_lock = Handle(thread, SystemDictionary::system_loader_lock());
  
      ObjectLocker ol(loader_lock, thread);
  
      // add the jar file to the bootclasspath
</pre>
<hr />
<pre>
<span class="line-old-header">*** 695,24 ***</span>
      return JVMTI_ERROR_NONE;
    } else if (phase == JVMTI_PHASE_LIVE) {
      // The phase is checked by the wrapper that called this function,
      // but this thread could be racing with the thread that is
      // terminating the VM so we check one more time.
<span class="line-modified">!     HandleMark hm;</span>
  
      // create the zip entry (which will open the zip file and hence
      // check that the segment is indeed a zip file).
      ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, false);
      if (zip_entry == NULL) {
        return JVMTI_ERROR_ILLEGAL_ARGUMENT;
      }
      delete zip_entry;   // no longer needed
  
      // lock the loader
<span class="line-removed">-     Thread* THREAD = Thread::current();</span>
      Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
<span class="line-removed">- </span>
      ObjectLocker ol(loader, THREAD);
  
      // need the path as java.lang.String
      Handle path = java_lang_String::create_from_platform_dependent_str(segment, THREAD);
      if (HAS_PENDING_EXCEPTION) {
<span class="line-new-header">--- 695,23 ---</span>
      return JVMTI_ERROR_NONE;
    } else if (phase == JVMTI_PHASE_LIVE) {
      // The phase is checked by the wrapper that called this function,
      // but this thread could be racing with the thread that is
      // terminating the VM so we check one more time.
<span class="line-modified">!     Thread* THREAD = Thread::current();</span>
<span class="line-added">+     HandleMark hm(THREAD);</span>
  
      // create the zip entry (which will open the zip file and hence
      // check that the segment is indeed a zip file).
      ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, false);
      if (zip_entry == NULL) {
        return JVMTI_ERROR_ILLEGAL_ARGUMENT;
      }
      delete zip_entry;   // no longer needed
  
      // lock the loader
      Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
      ObjectLocker ol(loader, THREAD);
  
      // need the path as java.lang.String
      Handle path = java_lang_String::create_from_platform_dependent_str(segment, THREAD);
      if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 913,15 ***</span>
  // threads_ptr - pre-checked for NULL
  jvmtiError
  JvmtiEnv::GetAllThreads(jint* threads_count_ptr, jthread** threads_ptr) {
    int nthreads        = 0;
    Handle *thread_objs = NULL;
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   HandleMark hm;</span>
  
    // enumerate threads (including agent threads)
<span class="line-modified">!   ThreadsListEnumerator tle(Thread::current(), true);</span>
    nthreads = tle.num_threads();
    *threads_count_ptr = nthreads;
  
    if (nthreads == 0) {
      *threads_ptr = NULL;
<span class="line-new-header">--- 912,16 ---</span>
  // threads_ptr - pre-checked for NULL
  jvmtiError
  JvmtiEnv::GetAllThreads(jint* threads_count_ptr, jthread** threads_ptr) {
    int nthreads        = 0;
    Handle *thread_objs = NULL;
<span class="line-modified">!   Thread* current_thread = Thread::current();</span>
<span class="line-modified">!   ResourceMark rm(current_thread);</span>
<span class="line-added">+   HandleMark hm(current_thread);</span>
  
    // enumerate threads (including agent threads)
<span class="line-modified">!   ThreadsListEnumerator tle(current_thread, true);</span>
    nthreads = tle.num_threads();
    *threads_count_ptr = nthreads;
  
    if (nthreads == 0) {
      *threads_ptr = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1123,14 ***</span>
  // Threads_lock NOT held
  // thread - NOT pre-checked
  // info_ptr - pre-checked for NULL
  jvmtiError
  JvmtiEnv::GetThreadInfo(jthread thread, jvmtiThreadInfo* info_ptr) {
<span class="line-removed">-   ResourceMark rm;</span>
<span class="line-removed">-   HandleMark hm;</span>
<span class="line-removed">- </span>
    JavaThread* current_thread = JavaThread::current();
    ThreadsListHandle tlh(current_thread);
  
    // if thread is NULL the current thread is used
    oop thread_oop = NULL;
    if (thread == NULL) {
<span class="line-new-header">--- 1123,14 ---</span>
  // Threads_lock NOT held
  // thread - NOT pre-checked
  // info_ptr - pre-checked for NULL
  jvmtiError
  JvmtiEnv::GetThreadInfo(jthread thread, jvmtiThreadInfo* info_ptr) {
    JavaThread* current_thread = JavaThread::current();
<span class="line-added">+   ResourceMark rm(current_thread);</span>
<span class="line-added">+   HandleMark hm(current_thread);</span>
<span class="line-added">+ </span>
    ThreadsListHandle tlh(current_thread);
  
    // if thread is NULL the current thread is used
    oop thread_oop = NULL;
    if (thread == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1398,14 ***</span>
  
  
  // info_ptr - pre-checked for NULL
  jvmtiError
  JvmtiEnv::GetThreadGroupInfo(jthreadGroup group, jvmtiThreadGroupInfo* info_ptr) {
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   HandleMark hm;</span>
<span class="line-modified">! </span>
<span class="line-removed">-   JavaThread* current_thread = JavaThread::current();</span>
  
    Handle group_obj (current_thread, JNIHandles::resolve_external_guard(group));
    NULL_CHECK(group_obj(), JVMTI_ERROR_INVALID_THREAD_GROUP);
  
    const char* name;
<span class="line-new-header">--- 1398,13 ---</span>
  
  
  // info_ptr - pre-checked for NULL
  jvmtiError
  JvmtiEnv::GetThreadGroupInfo(jthreadGroup group, jvmtiThreadGroupInfo* info_ptr) {
<span class="line-modified">!   Thread* current_thread = Thread::current();</span>
<span class="line-modified">!   ResourceMark rm(current_thread);</span>
<span class="line-modified">!   HandleMark hm(current_thread);</span>
  
    Handle group_obj (current_thread, JNIHandles::resolve_external_guard(group));
    NULL_CHECK(group_obj(), JVMTI_ERROR_INVALID_THREAD_GROUP);
  
    const char* name;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1616,18 ***</span>
    if (state == NULL) {
      return JVMTI_ERROR_THREAD_NOT_ALIVE;
    }
  
    // It is only safe to perform the direct operation on the current
<span class="line-modified">!   // thread. All other usage needs to use a vm-safepoint-op for safety.</span>
    if (java_thread == JavaThread::current()) {
      err = get_frame_count(state, count_ptr);
    } else {
<span class="line-modified">!     // get java stack frame count at safepoint.</span>
<span class="line-modified">!     VM_GetFrameCount op(this, state, count_ptr);</span>
<span class="line-modified">!     VMThread::execute(&amp;op);</span>
<span class="line-modified">!     err = op.result();</span>
    }
    return err;
  } /* end GetFrameCount */
  
  
<span class="line-new-header">--- 1615,18 ---</span>
    if (state == NULL) {
      return JVMTI_ERROR_THREAD_NOT_ALIVE;
    }
  
    // It is only safe to perform the direct operation on the current
<span class="line-modified">!   // thread. All other usage needs to use a direct handshake for safety.</span>
    if (java_thread == JavaThread::current()) {
      err = get_frame_count(state, count_ptr);
    } else {
<span class="line-modified">!     // get java stack frame count with handshake.</span>
<span class="line-modified">!     GetFrameCountClosure op(this, state, count_ptr);</span>
<span class="line-modified">!     bool executed = Handshake::execute_direct(&amp;op, java_thread);</span>
<span class="line-modified">!     err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;</span>
    }
    return err;
  } /* end GetFrameCount */
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1746,18 ***</span>
  jvmtiError
  JvmtiEnv::GetFrameLocation(JavaThread* java_thread, jint depth, jmethodID* method_ptr, jlocation* location_ptr) {
    jvmtiError err = JVMTI_ERROR_NONE;
  
    // It is only safe to perform the direct operation on the current
<span class="line-modified">!   // thread. All other usage needs to use a vm-safepoint-op for safety.</span>
    if (java_thread == JavaThread::current()) {
      err = get_frame_location(java_thread, depth, method_ptr, location_ptr);
    } else {
<span class="line-modified">!     // JVMTI get java stack frame location at safepoint.</span>
<span class="line-modified">!     VM_GetFrameLocation op(this, java_thread, depth, method_ptr, location_ptr);</span>
<span class="line-modified">!     VMThread::execute(&amp;op);</span>
<span class="line-modified">!     err = op.result();</span>
    }
    return err;
  } /* end GetFrameLocation */
  
  
<span class="line-new-header">--- 1745,18 ---</span>
  jvmtiError
  JvmtiEnv::GetFrameLocation(JavaThread* java_thread, jint depth, jmethodID* method_ptr, jlocation* location_ptr) {
    jvmtiError err = JVMTI_ERROR_NONE;
  
    // It is only safe to perform the direct operation on the current
<span class="line-modified">!   // thread. All other usage needs to use a direct handshake for safety.</span>
    if (java_thread == JavaThread::current()) {
      err = get_frame_location(java_thread, depth, method_ptr, location_ptr);
    } else {
<span class="line-modified">!     // JVMTI get java stack frame location via direct handshake.</span>
<span class="line-modified">!     GetFrameLocationClosure op(this, depth, method_ptr, location_ptr);</span>
<span class="line-modified">!     bool executed = Handshake::execute_direct(&amp;op, java_thread);</span>
<span class="line-modified">!     err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;</span>
    }
    return err;
  } /* end GetFrameLocation */
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2248,24 ***</span>
  
    //
    // Breakpoint functions
    //
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  jvmtiError
<span class="line-modified">! JvmtiEnv::SetBreakpoint(Method* method_oop, jlocation location) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
    if (location &lt; 0) {   // simple invalid location check first
      return JVMTI_ERROR_INVALID_LOCATION;
    }
    // verify that the breakpoint is not past the end of the method
<span class="line-modified">!   if (location &gt;= (jlocation) method_oop-&gt;code_size()) {</span>
      return JVMTI_ERROR_INVALID_LOCATION;
    }
  
    ResourceMark rm;
<span class="line-modified">!   JvmtiBreakpoint bp(method_oop, location);</span>
    JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
    if (jvmti_breakpoints.set(bp) == JVMTI_ERROR_DUPLICATE)
      return JVMTI_ERROR_DUPLICATE;
  
    if (TraceJVMTICalls) {
<span class="line-new-header">--- 2247,24 ---</span>
  
    //
    // Breakpoint functions
    //
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  jvmtiError
<span class="line-modified">! JvmtiEnv::SetBreakpoint(Method* method, jlocation location) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
    if (location &lt; 0) {   // simple invalid location check first
      return JVMTI_ERROR_INVALID_LOCATION;
    }
    // verify that the breakpoint is not past the end of the method
<span class="line-modified">!   if (location &gt;= (jlocation) method-&gt;code_size()) {</span>
      return JVMTI_ERROR_INVALID_LOCATION;
    }
  
    ResourceMark rm;
<span class="line-modified">!   JvmtiBreakpoint bp(method, location);</span>
    JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
    if (jvmti_breakpoints.set(bp) == JVMTI_ERROR_DUPLICATE)
      return JVMTI_ERROR_DUPLICATE;
  
    if (TraceJVMTICalls) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2274,25 ***</span>
  
    return JVMTI_ERROR_NONE;
  } /* end SetBreakpoint */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  jvmtiError
<span class="line-modified">! JvmtiEnv::ClearBreakpoint(Method* method_oop, jlocation location) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
  
    if (location &lt; 0) {   // simple invalid location check first
      return JVMTI_ERROR_INVALID_LOCATION;
    }
  
    // verify that the breakpoint is not past the end of the method
<span class="line-modified">!   if (location &gt;= (jlocation) method_oop-&gt;code_size()) {</span>
      return JVMTI_ERROR_INVALID_LOCATION;
    }
  
<span class="line-modified">!   JvmtiBreakpoint bp(method_oop, location);</span>
  
    JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
    if (jvmti_breakpoints.clear(bp) == JVMTI_ERROR_NOT_FOUND)
      return JVMTI_ERROR_NOT_FOUND;
  
<span class="line-new-header">--- 2273,25 ---</span>
  
    return JVMTI_ERROR_NONE;
  } /* end SetBreakpoint */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  jvmtiError
<span class="line-modified">! JvmtiEnv::ClearBreakpoint(Method* method, jlocation location) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
  
    if (location &lt; 0) {   // simple invalid location check first
      return JVMTI_ERROR_INVALID_LOCATION;
    }
  
    // verify that the breakpoint is not past the end of the method
<span class="line-modified">!   if (location &gt;= (jlocation) method-&gt;code_size()) {</span>
      return JVMTI_ERROR_INVALID_LOCATION;
    }
  
<span class="line-modified">!   JvmtiBreakpoint bp(method, location);</span>
  
    JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
    if (jvmti_breakpoints.clear(bp) == JVMTI_ERROR_NOT_FOUND)
      return JVMTI_ERROR_NOT_FOUND;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2514,58 ***</span>
    // Allocate the result and fill it in
    int result_length = ik-&gt;methods()-&gt;length();
    jmethodID* result_list = (jmethodID*)jvmtiMalloc(result_length * sizeof(jmethodID));
    int index;
    bool jmethodids_found = true;
<span class="line-modified">! </span>
<span class="line-modified">!   if (JvmtiExport::can_maintain_original_method_order()) {</span>
<span class="line-modified">!     // Use the original method ordering indices stored in the class, so we can emit</span>
<span class="line-modified">!     // jmethodIDs in the order they appeared in the class file</span>
<span class="line-modified">!     for (index = 0; index &lt; result_length; index++) {</span>
<span class="line-modified">!       Method* m = ik-&gt;methods()-&gt;at(index);</span>
<span class="line-modified">!       int original_index = ik-&gt;method_ordering()-&gt;at(index);</span>
<span class="line-modified">!       assert(original_index &gt;= 0 &amp;&amp; original_index &lt; result_length, &quot;invalid original method index&quot;);</span>
<span class="line-modified">!       jmethodID id;</span>
<span class="line-modified">!       if (jmethodids_found) {</span>
<span class="line-modified">!         id = m-&gt;find_jmethod_id_or_null();</span>
<span class="line-modified">!         if (id == NULL) {</span>
<span class="line-modified">!           // If we find an uninitialized value, make sure there is</span>
<span class="line-modified">!           // enough space for all the uninitialized values we might</span>
<span class="line-modified">!           // find.</span>
<span class="line-modified">!           ik-&gt;ensure_space_for_methodids(index);</span>
<span class="line-modified">!           jmethodids_found = false;</span>
<span class="line-modified">!           id = m-&gt;jmethod_id();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       } else {</span>
          id = m-&gt;jmethod_id();
        }
<span class="line-modified">!       result_list[original_index] = id;</span>
      }
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     // otherwise just copy in any order</span>
<span class="line-modified">!     for (index = 0; index &lt; result_length; index++) {</span>
<span class="line-modified">!       Method* m = ik-&gt;methods()-&gt;at(index);</span>
<span class="line-modified">!       jmethodID id;</span>
<span class="line-modified">!       if (jmethodids_found) {</span>
<span class="line-modified">!         id = m-&gt;find_jmethod_id_or_null();</span>
<span class="line-modified">!         if (id == NULL) {</span>
<span class="line-modified">!           // If we find an uninitialized value, make sure there is</span>
<span class="line-modified">!           // enough space for all the uninitialized values we might</span>
<span class="line-modified">!           // find.</span>
<span class="line-removed">-           ik-&gt;ensure_space_for_methodids(index);</span>
<span class="line-removed">-           jmethodids_found = false;</span>
<span class="line-removed">-           id = m-&gt;jmethod_id();</span>
<span class="line-removed">-         }</span>
        } else {
<span class="line-modified">!         id = m-&gt;jmethod_id();</span>
        }
<span class="line-removed">-       result_list[index] = id;</span>
      }
    }
<span class="line-removed">-   // Fill in return value.</span>
<span class="line-removed">-   *method_count_ptr = result_length;</span>
<span class="line-removed">-   *methods_ptr = result_list;</span>
  
    return JVMTI_ERROR_NONE;
  } /* end GetClassMethods */
  
  
<span class="line-new-header">--- 2513,58 ---</span>
    // Allocate the result and fill it in
    int result_length = ik-&gt;methods()-&gt;length();
    jmethodID* result_list = (jmethodID*)jvmtiMalloc(result_length * sizeof(jmethodID));
    int index;
    bool jmethodids_found = true;
<span class="line-modified">!   int skipped = 0;  // skip overpass methods</span>
<span class="line-modified">! </span>
<span class="line-modified">!   for (index = 0; index &lt; result_length; index++) {</span>
<span class="line-modified">!     Method* m = ik-&gt;methods()-&gt;at(index);</span>
<span class="line-modified">!     // Depending on can_maintain_original_method_order capability use the original</span>
<span class="line-modified">!     // method ordering indices stored in the class, so we can emit jmethodIDs in</span>
<span class="line-modified">!     // the order they appeared in the class file or just copy in current order.</span>
<span class="line-modified">!     int result_index = JvmtiExport::can_maintain_original_method_order() ? ik-&gt;method_ordering()-&gt;at(index) : index;</span>
<span class="line-modified">!     assert(result_index &gt;= 0 &amp;&amp; result_index &lt; result_length, &quot;invalid original method index&quot;);</span>
<span class="line-modified">!     if (m-&gt;is_overpass()) {</span>
<span class="line-modified">!       result_list[result_index] = NULL;</span>
<span class="line-modified">!       skipped++;</span>
<span class="line-modified">!       continue;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     jmethodID id;</span>
<span class="line-modified">!     if (jmethodids_found) {</span>
<span class="line-modified">!       id = m-&gt;find_jmethod_id_or_null();</span>
<span class="line-modified">!       if (id == NULL) {</span>
<span class="line-modified">!         // If we find an uninitialized value, make sure there is</span>
<span class="line-modified">!         // enough space for all the uninitialized values we might</span>
<span class="line-added">+         // find.</span>
<span class="line-added">+         ik-&gt;ensure_space_for_methodids(index);</span>
<span class="line-added">+         jmethodids_found = false;</span>
          id = m-&gt;jmethod_id();
        }
<span class="line-modified">!     } else {</span>
<span class="line-added">+       id = m-&gt;jmethod_id();</span>
      }
<span class="line-modified">!     result_list[result_index] = id;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Fill in return value.</span>
<span class="line-modified">!   if (skipped &gt; 0) {</span>
<span class="line-modified">!     // copy results skipping NULL methodIDs</span>
<span class="line-modified">!     *methods_ptr = (jmethodID*)jvmtiMalloc((result_length - skipped) * sizeof(jmethodID));</span>
<span class="line-modified">!     *method_count_ptr = result_length - skipped;</span>
<span class="line-modified">!     for (index = 0, skipped = 0; index &lt; result_length; index++) {</span>
<span class="line-modified">!       if (result_list[index] == NULL) {</span>
<span class="line-modified">!         skipped++;</span>
        } else {
<span class="line-modified">!         (*methods_ptr)[index - skipped] = result_list[index];</span>
        }
      }
<span class="line-added">+     deallocate((unsigned char *)result_list);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     *method_count_ptr = result_length;</span>
<span class="line-added">+     *methods_ptr = result_list;</span>
    }
  
    return JVMTI_ERROR_NONE;
  } /* end GetClassMethods */
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2943,38 ***</span>
  
    //
    // Method functions
    //
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // name_ptr - NULL is a valid value, must be checked
  // signature_ptr - NULL is a valid value, must be checked
  // generic_ptr - NULL is a valid value, must be checked
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMethodName(Method* method_oop, char** name_ptr, char** signature_ptr, char** generic_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
    JavaThread* current_thread  = JavaThread::current();
  
    ResourceMark rm(current_thread); // get the utf8 name and signature
    if (name_ptr == NULL) {
      // just don&#39;t return the name
    } else {
<span class="line-modified">!     const char* utf8_name = (const char *) method_oop-&gt;name()-&gt;as_utf8();</span>
      *name_ptr = (char *) jvmtiMalloc(strlen(utf8_name)+1);
      strcpy(*name_ptr, utf8_name);
    }
    if (signature_ptr == NULL) {
      // just don&#39;t return the signature
    } else {
<span class="line-modified">!     const char* utf8_signature = (const char *) method_oop-&gt;signature()-&gt;as_utf8();</span>
      *signature_ptr = (char *) jvmtiMalloc(strlen(utf8_signature) + 1);
      strcpy(*signature_ptr, utf8_signature);
    }
  
    if (generic_ptr != NULL) {
      *generic_ptr = NULL;
<span class="line-modified">!     Symbol* soop = method_oop-&gt;generic_signature();</span>
      if (soop != NULL) {
        const char* gen_sig = soop-&gt;as_C_string();
        if (gen_sig != NULL) {
          jvmtiError err = allocate(strlen(gen_sig) + 1, (unsigned char **)generic_ptr);
          if (err != JVMTI_ERROR_NONE) {
<span class="line-new-header">--- 2942,38 ---</span>
  
    //
    // Method functions
    //
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // name_ptr - NULL is a valid value, must be checked
  // signature_ptr - NULL is a valid value, must be checked
  // generic_ptr - NULL is a valid value, must be checked
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMethodName(Method* method, char** name_ptr, char** signature_ptr, char** generic_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
    JavaThread* current_thread  = JavaThread::current();
  
    ResourceMark rm(current_thread); // get the utf8 name and signature
    if (name_ptr == NULL) {
      // just don&#39;t return the name
    } else {
<span class="line-modified">!     const char* utf8_name = (const char *) method-&gt;name()-&gt;as_utf8();</span>
      *name_ptr = (char *) jvmtiMalloc(strlen(utf8_name)+1);
      strcpy(*name_ptr, utf8_name);
    }
    if (signature_ptr == NULL) {
      // just don&#39;t return the signature
    } else {
<span class="line-modified">!     const char* utf8_signature = (const char *) method-&gt;signature()-&gt;as_utf8();</span>
      *signature_ptr = (char *) jvmtiMalloc(strlen(utf8_signature) + 1);
      strcpy(*signature_ptr, utf8_signature);
    }
  
    if (generic_ptr != NULL) {
      *generic_ptr = NULL;
<span class="line-modified">!     Symbol* soop = method-&gt;generic_signature();</span>
      if (soop != NULL) {
        const char* gen_sig = soop-&gt;as_C_string();
        if (gen_sig != NULL) {
          jvmtiError err = allocate(strlen(gen_sig) + 1, (unsigned char **)generic_ptr);
          if (err != JVMTI_ERROR_NONE) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2986,79 ***</span>
    }
    return JVMTI_ERROR_NONE;
  } /* end GetMethodName */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // declaring_class_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMethodDeclaringClass(Method* method_oop, jclass* declaring_class_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   (*declaring_class_ptr) = get_jni_class_non_null(method_oop-&gt;method_holder());</span>
    return JVMTI_ERROR_NONE;
  } /* end GetMethodDeclaringClass */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // modifiers_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMethodModifiers(Method* method_oop, jint* modifiers_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   (*modifiers_ptr) = method_oop-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;</span>
    return JVMTI_ERROR_NONE;
  } /* end GetMethodModifiers */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // max_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMaxLocals(Method* method_oop, jint* max_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
    // get max stack
<span class="line-modified">!   (*max_ptr) = method_oop-&gt;max_locals();</span>
    return JVMTI_ERROR_NONE;
  } /* end GetMaxLocals */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // size_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetArgumentsSize(Method* method_oop, jint* size_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
    // get size of arguments
  
<span class="line-modified">!   (*size_ptr) = method_oop-&gt;size_of_parameters();</span>
    return JVMTI_ERROR_NONE;
  } /* end GetArgumentsSize */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // entry_count_ptr - pre-checked for NULL
  // table_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetLineNumberTable(Method* method_oop, jint* entry_count_ptr, jvmtiLineNumberEntry** table_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   if (!method_oop-&gt;has_linenumber_table()) {</span>
      return (JVMTI_ERROR_ABSENT_INFORMATION);
    }
  
    // The line number table is compressed so we don&#39;t know how big it is until decompressed.
    // Decompression is really fast so we just do it twice.
  
    // Compute size of table
    jint num_entries = 0;
<span class="line-modified">!   CompressedLineNumberReadStream stream(method_oop-&gt;compressed_linenumber_table());</span>
    while (stream.read_pair()) {
      num_entries++;
    }
    jvmtiLineNumberEntry *jvmti_table =
              (jvmtiLineNumberEntry *)jvmtiMalloc(num_entries * (sizeof(jvmtiLineNumberEntry)));
  
    // Fill jvmti table
    if (num_entries &gt; 0) {
      int index = 0;
<span class="line-modified">!     CompressedLineNumberReadStream stream(method_oop-&gt;compressed_linenumber_table());</span>
      while (stream.read_pair()) {
        jvmti_table[index].start_location = (jlocation) stream.bci();
        jvmti_table[index].line_number = (jint) stream.line();
        index++;
      }
<span class="line-new-header">--- 2985,79 ---</span>
    }
    return JVMTI_ERROR_NONE;
  } /* end GetMethodName */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // declaring_class_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMethodDeclaringClass(Method* method, jclass* declaring_class_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   (*declaring_class_ptr) = get_jni_class_non_null(method-&gt;method_holder());</span>
    return JVMTI_ERROR_NONE;
  } /* end GetMethodDeclaringClass */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // modifiers_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMethodModifiers(Method* method, jint* modifiers_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   (*modifiers_ptr) = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;</span>
    return JVMTI_ERROR_NONE;
  } /* end GetMethodModifiers */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // max_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMaxLocals(Method* method, jint* max_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
    // get max stack
<span class="line-modified">!   (*max_ptr) = method-&gt;max_locals();</span>
    return JVMTI_ERROR_NONE;
  } /* end GetMaxLocals */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // size_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetArgumentsSize(Method* method, jint* size_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
    // get size of arguments
  
<span class="line-modified">!   (*size_ptr) = method-&gt;size_of_parameters();</span>
    return JVMTI_ERROR_NONE;
  } /* end GetArgumentsSize */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // entry_count_ptr - pre-checked for NULL
  // table_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetLineNumberTable(Method* method, jint* entry_count_ptr, jvmtiLineNumberEntry** table_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   if (!method-&gt;has_linenumber_table()) {</span>
      return (JVMTI_ERROR_ABSENT_INFORMATION);
    }
  
    // The line number table is compressed so we don&#39;t know how big it is until decompressed.
    // Decompression is really fast so we just do it twice.
  
    // Compute size of table
    jint num_entries = 0;
<span class="line-modified">!   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());</span>
    while (stream.read_pair()) {
      num_entries++;
    }
    jvmtiLineNumberEntry *jvmti_table =
              (jvmtiLineNumberEntry *)jvmtiMalloc(num_entries * (sizeof(jvmtiLineNumberEntry)));
  
    // Fill jvmti table
    if (num_entries &gt; 0) {
      int index = 0;
<span class="line-modified">!     CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());</span>
      while (stream.read_pair()) {
        jvmti_table[index].start_location = (jlocation) stream.bci();
        jvmti_table[index].line_number = (jint) stream.line();
        index++;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3071,57 ***</span>
  
    return JVMTI_ERROR_NONE;
  } /* end GetLineNumberTable */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // start_location_ptr - pre-checked for NULL
  // end_location_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMethodLocation(Method* method_oop, jlocation* start_location_ptr, jlocation* end_location_ptr) {</span>
  
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
    // get start and end location
<span class="line-modified">!   (*end_location_ptr) = (jlocation) (method_oop-&gt;code_size() - 1);</span>
<span class="line-modified">!   if (method_oop-&gt;code_size() == 0) {</span>
      // there is no code so there is no start location
      (*start_location_ptr) = (jlocation)(-1);
    } else {
      (*start_location_ptr) = (jlocation)(0);
    }
  
    return JVMTI_ERROR_NONE;
  } /* end GetMethodLocation */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // entry_count_ptr - pre-checked for NULL
  // table_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetLocalVariableTable(Method* method_oop, jint* entry_count_ptr, jvmtiLocalVariableEntry** table_ptr) {</span>
  
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
    JavaThread* current_thread  = JavaThread::current();
  
    // does the klass have any local variable information?
<span class="line-modified">!   InstanceKlass* ik = method_oop-&gt;method_holder();</span>
    if (!ik-&gt;access_flags().has_localvariable_table()) {
      return (JVMTI_ERROR_ABSENT_INFORMATION);
    }
  
<span class="line-modified">!   ConstantPool* constants = method_oop-&gt;constants();</span>
    NULL_CHECK(constants, JVMTI_ERROR_ABSENT_INFORMATION);
  
    // in the vm localvariable table representation, 6 consecutive elements in the table
    // represent a 6-tuple of shorts
    // [start_pc, length, name_index, descriptor_index, signature_index, index]
<span class="line-modified">!   jint num_entries = method_oop-&gt;localvariable_table_length();</span>
    jvmtiLocalVariableEntry *jvmti_table = (jvmtiLocalVariableEntry *)
                  jvmtiMalloc(num_entries * (sizeof(jvmtiLocalVariableEntry)));
  
    if (num_entries &gt; 0) {
<span class="line-modified">!     LocalVariableTableElement* table = method_oop-&gt;localvariable_table_start();</span>
      for (int i = 0; i &lt; num_entries; i++) {
        // get the 5 tuple information from the vm table
        jlocation start_location = (jlocation) table[i].start_bci;
        jint length = (jint) table[i].length;
        int name_index = (int) table[i].name_cp_index;
<span class="line-new-header">--- 3070,57 ---</span>
  
    return JVMTI_ERROR_NONE;
  } /* end GetLineNumberTable */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // start_location_ptr - pre-checked for NULL
  // end_location_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetMethodLocation(Method* method, jlocation* start_location_ptr, jlocation* end_location_ptr) {</span>
  
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
    // get start and end location
<span class="line-modified">!   (*end_location_ptr) = (jlocation) (method-&gt;code_size() - 1);</span>
<span class="line-modified">!   if (method-&gt;code_size() == 0) {</span>
      // there is no code so there is no start location
      (*start_location_ptr) = (jlocation)(-1);
    } else {
      (*start_location_ptr) = (jlocation)(0);
    }
  
    return JVMTI_ERROR_NONE;
  } /* end GetMethodLocation */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // entry_count_ptr - pre-checked for NULL
  // table_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetLocalVariableTable(Method* method, jint* entry_count_ptr, jvmtiLocalVariableEntry** table_ptr) {</span>
  
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
    JavaThread* current_thread  = JavaThread::current();
  
    // does the klass have any local variable information?
<span class="line-modified">!   InstanceKlass* ik = method-&gt;method_holder();</span>
    if (!ik-&gt;access_flags().has_localvariable_table()) {
      return (JVMTI_ERROR_ABSENT_INFORMATION);
    }
  
<span class="line-modified">!   ConstantPool* constants = method-&gt;constants();</span>
    NULL_CHECK(constants, JVMTI_ERROR_ABSENT_INFORMATION);
  
    // in the vm localvariable table representation, 6 consecutive elements in the table
    // represent a 6-tuple of shorts
    // [start_pc, length, name_index, descriptor_index, signature_index, index]
<span class="line-modified">!   jint num_entries = method-&gt;localvariable_table_length();</span>
    jvmtiLocalVariableEntry *jvmti_table = (jvmtiLocalVariableEntry *)
                  jvmtiMalloc(num_entries * (sizeof(jvmtiLocalVariableEntry)));
  
    if (num_entries &gt; 0) {
<span class="line-modified">!     LocalVariableTableElement* table = method-&gt;localvariable_table_start();</span>
      for (int i = 0; i &lt; num_entries; i++) {
        // get the 5 tuple information from the vm table
        jlocation start_location = (jlocation) table[i].start_bci;
        jint length = (jint) table[i].length;
        int name_index = (int) table[i].name_cp_index;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3168,66 ***</span>
  
    return JVMTI_ERROR_NONE;
  } /* end GetLocalVariableTable */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // bytecode_count_ptr - pre-checked for NULL
  // bytecodes_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetBytecodes(Method* method_oop, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
  
<span class="line-modified">!   HandleMark hm;</span>
<span class="line-modified">!   methodHandle method(Thread::current(), method_oop);</span>
<span class="line-removed">-   jint size = (jint)method-&gt;code_size();</span>
    jvmtiError err = allocate(size, bytecodes_ptr);
    if (err != JVMTI_ERROR_NONE) {
      return err;
    }
  
    (*bytecode_count_ptr) = size;
    // get byte codes
<span class="line-modified">!   JvmtiClassFileReconstituter::copy_bytecodes(method, *bytecodes_ptr);</span>
  
    return JVMTI_ERROR_NONE;
  } /* end GetBytecodes */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // is_native_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::IsMethodNative(Method* method_oop, jboolean* is_native_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   (*is_native_ptr) = method_oop-&gt;is_native();</span>
    return JVMTI_ERROR_NONE;
  } /* end IsMethodNative */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // is_synthetic_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::IsMethodSynthetic(Method* method_oop, jboolean* is_synthetic_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method_oop, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   (*is_synthetic_ptr) = method_oop-&gt;is_synthetic();</span>
    return JVMTI_ERROR_NONE;
  } /* end IsMethodSynthetic */
  
  
<span class="line-modified">! // method_oop - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // is_obsolete_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::IsMethodObsolete(Method* method_oop, jboolean* is_obsolete_ptr) {</span>
    if (use_version_1_0_semantics() &amp;&amp;
        get_capabilities()-&gt;can_redefine_classes == 0) {
      // This JvmtiEnv requested version 1.0 semantics and this function
      // requires the can_redefine_classes capability in version 1.0 so
      // we need to return an error here.
      return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
    }
  
<span class="line-modified">!   if (method_oop == NULL || method_oop-&gt;is_obsolete()) {</span>
      *is_obsolete_ptr = true;
    } else {
      *is_obsolete_ptr = false;
    }
    return JVMTI_ERROR_NONE;
<span class="line-new-header">--- 3167,65 ---</span>
  
    return JVMTI_ERROR_NONE;
  } /* end GetLocalVariableTable */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // bytecode_count_ptr - pre-checked for NULL
  // bytecodes_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::GetBytecodes(Method* method, jint* bytecode_count_ptr, unsigned char** bytecodes_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
  
<span class="line-modified">!   methodHandle mh(Thread::current(), method);</span>
<span class="line-modified">!   jint size = (jint)mh-&gt;code_size();</span>
    jvmtiError err = allocate(size, bytecodes_ptr);
    if (err != JVMTI_ERROR_NONE) {
      return err;
    }
  
    (*bytecode_count_ptr) = size;
    // get byte codes
<span class="line-modified">!   JvmtiClassFileReconstituter::copy_bytecodes(mh, *bytecodes_ptr);</span>
  
    return JVMTI_ERROR_NONE;
  } /* end GetBytecodes */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // is_native_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::IsMethodNative(Method* method, jboolean* is_native_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   (*is_native_ptr) = method-&gt;is_native();</span>
    return JVMTI_ERROR_NONE;
  } /* end IsMethodNative */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // is_synthetic_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::IsMethodSynthetic(Method* method, jboolean* is_synthetic_ptr) {</span>
<span class="line-modified">!   NULL_CHECK(method, JVMTI_ERROR_INVALID_METHODID);</span>
<span class="line-modified">!   (*is_synthetic_ptr) = method-&gt;is_synthetic();</span>
    return JVMTI_ERROR_NONE;
  } /* end IsMethodSynthetic */
  
  
<span class="line-modified">! // method - pre-checked for validity, but may be NULL meaning obsolete method</span>
  // is_obsolete_ptr - pre-checked for NULL
  jvmtiError
<span class="line-modified">! JvmtiEnv::IsMethodObsolete(Method* method, jboolean* is_obsolete_ptr) {</span>
    if (use_version_1_0_semantics() &amp;&amp;
        get_capabilities()-&gt;can_redefine_classes == 0) {
      // This JvmtiEnv requested version 1.0 semantics and this function
      // requires the can_redefine_classes capability in version 1.0 so
      // we need to return an error here.
      return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
    }
  
<span class="line-modified">!   if (method == NULL || method-&gt;is_obsolete()) {</span>
      *is_obsolete_ptr = true;
    } else {
      *is_obsolete_ptr = false;
    }
    return JVMTI_ERROR_NONE;
</pre>
<center><a href="jvmtiEnter.xsl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.xsl.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>