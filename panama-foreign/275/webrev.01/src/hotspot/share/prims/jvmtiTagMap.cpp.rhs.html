<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiTagMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  32 #include &quot;logging/log.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/access.inline.hpp&quot;
  37 #include &quot;oops/arrayOop.inline.hpp&quot;
  38 #include &quot;oops/constantPool.inline.hpp&quot;
  39 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;prims/jvmtiEventController.hpp&quot;
  45 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  46 #include &quot;prims/jvmtiExport.hpp&quot;
  47 #include &quot;prims/jvmtiImpl.hpp&quot;
  48 #include &quot;prims/jvmtiTagMap.hpp&quot;
  49 #include &quot;runtime/biasedLocking.hpp&quot;
  50 #include &quot;runtime/frame.inline.hpp&quot;
  51 #include &quot;runtime/handles.inline.hpp&quot;
  52 #include &quot;runtime/javaCalls.hpp&quot;
  53 #include &quot;runtime/jniHandles.inline.hpp&quot;
  54 #include &quot;runtime/mutex.hpp&quot;
  55 #include &quot;runtime/mutexLocker.hpp&quot;
  56 #include &quot;runtime/reflectionUtils.hpp&quot;
  57 #include &quot;runtime/thread.inline.hpp&quot;
  58 #include &quot;runtime/threadSMR.hpp&quot;
  59 #include &quot;runtime/vframe.hpp&quot;
  60 #include &quot;runtime/vmThread.hpp&quot;
  61 #include &quot;runtime/vmOperations.hpp&quot;
  62 #include &quot;utilities/macros.hpp&quot;
  63 #if INCLUDE_ZGC
  64 #include &quot;gc/z/zGlobals.hpp&quot;
  65 #endif
  66 
  67 // JvmtiTagHashmapEntry
  68 //
  69 // Each entry encapsulates a reference to the tagged object
  70 // and the tag value. In addition an entry includes a next pointer which
  71 // is used to chain entries together.
  72 
  73 class JvmtiTagHashmapEntry : public CHeapObj&lt;mtInternal&gt; {
  74  private:
  75   friend class JvmtiTagMap;
  76 
  77   oop _object;                          // tagged object
  78   jlong _tag;                           // the tag
  79   JvmtiTagHashmapEntry* _next;          // next on the list
  80 
  81   inline void init(oop object, jlong tag) {
  82     _object = object;
  83     _tag = tag;
  84     _next = NULL;
  85   }
  86 
  87   // constructor
  88   JvmtiTagHashmapEntry(oop object, jlong tag) { init(object, tag); }
  89 
  90  public:
  91 
  92   // accessor methods
  93   inline oop* object_addr() { return &amp;_object; }
  94   inline oop object()       { return NativeAccess&lt;ON_PHANTOM_OOP_REF&gt;::oop_load(object_addr()); }
  95   // Peek at the object without keeping it alive. The returned object must be
  96   // kept alive using a normal access if it leaks out of a thread transition from VM.
  97   inline oop object_peek()  {
  98     return NativeAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(object_addr());
  99   }
 100 
 101   inline oop object_raw() {
 102     return RawAccess&lt;&gt;::oop_load(object_addr());
 103   }
 104 
 105   inline jlong tag() const  { return _tag; }
 106 
 107   inline void set_tag(jlong tag) {
 108     assert(tag != 0, &quot;can&#39;t be zero&quot;);
 109     _tag = tag;
 110   }
 111 
 112   inline bool equals(oop object) {
 113     return object == object_peek();
 114   }
 115 
 116   inline JvmtiTagHashmapEntry* next() const        { return _next; }
 117   inline void set_next(JvmtiTagHashmapEntry* next) { _next = next; }
 118 };
 119 
 120 
 121 // JvmtiTagHashmap
 122 //
 123 // A hashmap is essentially a table of pointers to entries. Entries
 124 // are hashed to a location, or position in the table, and then
 125 // chained from that location. The &quot;key&quot; for hashing is address of
 126 // the object, or oop. The &quot;value&quot; is the tag value.
 127 //
 128 // A hashmap maintains a count of the number entries in the hashmap
 129 // and resizes if the number of entries exceeds a given threshold.
 130 // The threshold is specified as a percentage of the size - for
 131 // example a threshold of 0.75 will trigger the hashmap to resize
 132 // if the number of entries is &gt;75% of table size.
 133 //
 134 // A hashmap provides functions for adding, removing, and finding
 135 // entries. It also provides a function to iterate over all entries
 136 // in the hashmap.
 137 
 138 class JvmtiTagHashmap : public CHeapObj&lt;mtInternal&gt; {
 139  private:
 140   friend class JvmtiTagMap;
 141 
 142   enum {
 143     small_trace_threshold  = 10000,                  // threshold for tracing
 144     medium_trace_threshold = 100000,
 145     large_trace_threshold  = 1000000,
 146     initial_trace_threshold = small_trace_threshold
 147   };
 148 
 149   static int _sizes[];                  // array of possible hashmap sizes
 150   int _size;                            // actual size of the table
 151   int _size_index;                      // index into size table
 152 
 153   int _entry_count;                     // number of entries in the hashmap
 154 
 155   float _load_factor;                   // load factor as a % of the size
 156   int _resize_threshold;                // computed threshold to trigger resizing.
 157   bool _resizing_enabled;               // indicates if hashmap can resize
 158 
 159   int _trace_threshold;                 // threshold for trace messages
 160 
 161   JvmtiTagHashmapEntry** _table;        // the table of entries.
 162 
 163   // private accessors
 164   int resize_threshold() const                  { return _resize_threshold; }
 165   int trace_threshold() const                   { return _trace_threshold; }
 166 
 167   // initialize the hashmap
 168   void init(int size_index=0, float load_factor=4.0f) {
 169     int initial_size =  _sizes[size_index];
 170     _size_index = size_index;
 171     _size = initial_size;
 172     _entry_count = 0;
 173     _trace_threshold = initial_trace_threshold;
 174     _load_factor = load_factor;
 175     _resize_threshold = (int)(_load_factor * _size);
 176     _resizing_enabled = true;
 177     size_t s = initial_size * sizeof(JvmtiTagHashmapEntry*);
 178     _table = (JvmtiTagHashmapEntry**)os::malloc(s, mtInternal);
 179     if (_table == NULL) {
 180       vm_exit_out_of_memory(s, OOM_MALLOC_ERROR,
 181         &quot;unable to allocate initial hashtable for jvmti object tags&quot;);
 182     }
 183     for (int i=0; i&lt;initial_size; i++) {
 184       _table[i] = NULL;
 185     }
 186   }
 187 
 188   // hash a given key (oop) with the specified size
 189   static unsigned int hash(oop key, int size) {
 190     const oop obj = Access&lt;&gt;::resolve(key);
 191     const unsigned int hash = Universe::heap()-&gt;hash_oop(obj);
 192     return hash % size;
 193   }
 194 
 195   // hash a given key (oop)
 196   unsigned int hash(oop key) {
 197     return hash(key, _size);
 198   }
 199 
 200   // resize the hashmap - allocates a large table and re-hashes
 201   // all entries into the new table.
 202   void resize() {
 203     int new_size_index = _size_index+1;
 204     int new_size = _sizes[new_size_index];
 205     if (new_size &lt; 0) {
 206       // hashmap already at maximum capacity
 207       return;
 208     }
 209 
 210     // allocate new table
 211     size_t s = new_size * sizeof(JvmtiTagHashmapEntry*);
 212     JvmtiTagHashmapEntry** new_table = (JvmtiTagHashmapEntry**)os::malloc(s, mtInternal);
 213     if (new_table == NULL) {
 214       warning(&quot;unable to allocate larger hashtable for jvmti object tags&quot;);
 215       set_resizing_enabled(false);
 216       return;
 217     }
 218 
 219     // initialize new table
 220     int i;
 221     for (i=0; i&lt;new_size; i++) {
 222       new_table[i] = NULL;
 223     }
 224 
 225     // rehash all entries into the new table
 226     for (i=0; i&lt;_size; i++) {
 227       JvmtiTagHashmapEntry* entry = _table[i];
 228       while (entry != NULL) {
 229         JvmtiTagHashmapEntry* next = entry-&gt;next();
 230         oop key = entry-&gt;object_peek();
 231         assert(key != NULL, &quot;jni weak reference cleared!!&quot;);
 232         unsigned int h = hash(key, new_size);
 233         JvmtiTagHashmapEntry* anchor = new_table[h];
 234         if (anchor == NULL) {
 235           new_table[h] = entry;
 236           entry-&gt;set_next(NULL);
 237         } else {
 238           entry-&gt;set_next(anchor);
 239           new_table[h] = entry;
 240         }
 241         entry = next;
 242       }
 243     }
 244 
 245     // free old table and update settings.
 246     os::free((void*)_table);
 247     _table = new_table;
 248     _size_index = new_size_index;
 249     _size = new_size;
 250 
 251     // compute new resize threshold
 252     _resize_threshold = (int)(_load_factor * _size);
 253   }
 254 
 255 
 256   // internal remove function - remove an entry at a given position in the
 257   // table.
 258   inline void remove(JvmtiTagHashmapEntry* prev, int pos, JvmtiTagHashmapEntry* entry) {
 259     assert(pos &gt;= 0 &amp;&amp; pos &lt; _size, &quot;out of range&quot;);
 260     if (prev == NULL) {
 261       _table[pos] = entry-&gt;next();
 262     } else {
 263       prev-&gt;set_next(entry-&gt;next());
 264     }
 265     assert(_entry_count &gt; 0, &quot;checking&quot;);
 266     _entry_count--;
 267   }
 268 
 269   // resizing switch
 270   bool is_resizing_enabled() const          { return _resizing_enabled; }
 271   void set_resizing_enabled(bool enable)    { _resizing_enabled = enable; }
 272 
 273   // debugging
 274   void print_memory_usage();
 275   void compute_next_trace_threshold();
 276 
 277  public:
 278 
 279   // create a JvmtiTagHashmap of a preferred size and optionally a load factor.
 280   // The preferred size is rounded down to an actual size.
 281   JvmtiTagHashmap(int size, float load_factor=0.0f) {
 282     int i=0;
 283     while (_sizes[i] &lt; size) {
 284       if (_sizes[i] &lt; 0) {
 285         assert(i &gt; 0, &quot;sanity check&quot;);
 286         i--;
 287         break;
 288       }
 289       i++;
 290     }
 291 
 292     // if a load factor is specified then use it, otherwise use default
 293     if (load_factor &gt; 0.01f) {
 294       init(i, load_factor);
 295     } else {
 296       init(i);
 297     }
 298   }
 299 
 300   // create a JvmtiTagHashmap with default settings
 301   JvmtiTagHashmap() {
 302     init();
 303   }
 304 
 305   // release table when JvmtiTagHashmap destroyed
 306   ~JvmtiTagHashmap() {
 307     if (_table != NULL) {
 308       os::free((void*)_table);
 309       _table = NULL;
 310     }
 311   }
 312 
 313   // accessors
 314   int size() const                              { return _size; }
 315   JvmtiTagHashmapEntry** table() const          { return _table; }
 316   int entry_count() const                       { return _entry_count; }
 317 
 318   // find an entry in the hashmap, returns NULL if not found.
 319   inline JvmtiTagHashmapEntry* find(oop key) {
 320     unsigned int h = hash(key);
 321     JvmtiTagHashmapEntry* entry = _table[h];
 322     while (entry != NULL) {
 323       if (entry-&gt;equals(key)) {
 324          return entry;
 325       }
 326       entry = entry-&gt;next();
 327     }
 328     return NULL;
 329   }
 330 
 331 
 332   // add a new entry to hashmap
 333   inline void add(oop key, JvmtiTagHashmapEntry* entry) {
 334     assert(key != NULL, &quot;checking&quot;);
 335     assert(find(key) == NULL, &quot;duplicate detected&quot;);
 336     unsigned int h = hash(key);
 337     JvmtiTagHashmapEntry* anchor = _table[h];
 338     if (anchor == NULL) {
 339       _table[h] = entry;
 340       entry-&gt;set_next(NULL);
 341     } else {
 342       entry-&gt;set_next(anchor);
 343       _table[h] = entry;
 344     }
 345 
 346     _entry_count++;
 347     if (log_is_enabled(Debug, jvmti, objecttagging) &amp;&amp; entry_count() &gt;= trace_threshold()) {
 348       print_memory_usage();
 349       compute_next_trace_threshold();
 350     }
 351 
 352     // if the number of entries exceed the threshold then resize
 353     if (entry_count() &gt; resize_threshold() &amp;&amp; is_resizing_enabled()) {
 354       resize();
 355     }
 356   }
 357 
 358   // remove an entry with the given key.
 359   inline JvmtiTagHashmapEntry* remove(oop key) {
 360     unsigned int h = hash(key);
 361     JvmtiTagHashmapEntry* entry = _table[h];
 362     JvmtiTagHashmapEntry* prev = NULL;
 363     while (entry != NULL) {
 364       if (entry-&gt;equals(key)) {
 365         break;
 366       }
 367       prev = entry;
 368       entry = entry-&gt;next();
 369     }
 370     if (entry != NULL) {
 371       remove(prev, h, entry);
 372     }
 373     return entry;
 374   }
 375 
 376   // iterate over all entries in the hashmap
 377   void entry_iterate(JvmtiTagHashmapEntryClosure* closure);
 378 };
 379 
 380 // possible hashmap sizes - odd primes that roughly double in size.
 381 // To avoid excessive resizing the odd primes from 4801-76831 and
 382 // 76831-307261 have been removed. The list must be terminated by -1.
 383 int JvmtiTagHashmap::_sizes[] =  { 4801, 76831, 307261, 614563, 1228891,
 384     2457733, 4915219, 9830479, 19660831, 39321619, 78643219, -1 };
 385 
 386 
 387 // A supporting class for iterating over all entries in Hashmap
 388 class JvmtiTagHashmapEntryClosure {
 389  public:
 390   virtual void do_entry(JvmtiTagHashmapEntry* entry) = 0;
 391 };
 392 
 393 
 394 // iterate over all entries in the hashmap
 395 void JvmtiTagHashmap::entry_iterate(JvmtiTagHashmapEntryClosure* closure) {
 396   for (int i=0; i&lt;_size; i++) {
 397     JvmtiTagHashmapEntry* entry = _table[i];
 398     JvmtiTagHashmapEntry* prev = NULL;
 399     while (entry != NULL) {
 400       // obtain the next entry before invoking do_entry - this is
 401       // necessary because do_entry may remove the entry from the
 402       // hashmap.
 403       JvmtiTagHashmapEntry* next = entry-&gt;next();
 404       closure-&gt;do_entry(entry);
 405       entry = next;
 406      }
 407   }
 408 }
 409 
 410 // debugging
 411 void JvmtiTagHashmap::print_memory_usage() {
 412   intptr_t p = (intptr_t)this;
 413   tty-&gt;print(&quot;[JvmtiTagHashmap @ &quot; INTPTR_FORMAT, p);
 414 
 415   // table + entries in KB
 416   int hashmap_usage = (size()*sizeof(JvmtiTagHashmapEntry*) +
 417     entry_count()*sizeof(JvmtiTagHashmapEntry))/K;
 418 
 419   int weak_globals_usage = (int)(JNIHandles::weak_global_handle_memory_usage()/K);
 420   tty-&gt;print_cr(&quot;, %d entries (%d KB) &lt;JNI weak globals: %d KB&gt;]&quot;,
 421     entry_count(), hashmap_usage, weak_globals_usage);
 422 }
 423 
 424 // compute threshold for the next trace message
 425 void JvmtiTagHashmap::compute_next_trace_threshold() {
 426   _trace_threshold = entry_count();
 427   if (trace_threshold() &lt; medium_trace_threshold) {
 428     _trace_threshold += small_trace_threshold;
 429   } else {
 430     if (trace_threshold() &lt; large_trace_threshold) {
 431       _trace_threshold += medium_trace_threshold;
 432     } else {
 433       _trace_threshold += large_trace_threshold;
 434     }
 435   }
 436 }
 437 
 438 // create a JvmtiTagMap
 439 JvmtiTagMap::JvmtiTagMap(JvmtiEnv* env) :
 440   _env(env),
 441   _lock(Mutex::nonleaf+2, &quot;JvmtiTagMap._lock&quot;, false),
 442   _free_entries(NULL),
 443   _free_entries_count(0)
 444 {
 445   assert(JvmtiThreadState_lock-&gt;is_locked(), &quot;sanity check&quot;);
 446   assert(((JvmtiEnvBase *)env)-&gt;tag_map() == NULL, &quot;tag map already exists for environment&quot;);
 447 
 448   _hashmap = new JvmtiTagHashmap();
 449 
 450   // finally add us to the environment
 451   ((JvmtiEnvBase *)env)-&gt;release_set_tag_map(this);
 452 }
 453 
 454 
 455 // destroy a JvmtiTagMap
 456 JvmtiTagMap::~JvmtiTagMap() {
 457 
 458   // no lock acquired as we assume the enclosing environment is
 459   // also being destroryed.
 460   ((JvmtiEnvBase *)_env)-&gt;set_tag_map(NULL);
 461 
 462   JvmtiTagHashmapEntry** table = _hashmap-&gt;table();
 463   for (int j = 0; j &lt; _hashmap-&gt;size(); j++) {
 464     JvmtiTagHashmapEntry* entry = table[j];
 465     while (entry != NULL) {
 466       JvmtiTagHashmapEntry* next = entry-&gt;next();
 467       delete entry;
 468       entry = next;
 469     }
 470   }
 471 
 472   // finally destroy the hashmap
 473   delete _hashmap;
 474   _hashmap = NULL;
 475 
 476   // remove any entries on the free list
 477   JvmtiTagHashmapEntry* entry = _free_entries;
 478   while (entry != NULL) {
 479     JvmtiTagHashmapEntry* next = entry-&gt;next();
 480     delete entry;
 481     entry = next;
 482   }
 483   _free_entries = NULL;
 484 }
 485 
 486 // create a hashmap entry
 487 // - if there&#39;s an entry on the (per-environment) free list then this
 488 // is returned. Otherwise an new entry is allocated.
 489 JvmtiTagHashmapEntry* JvmtiTagMap::create_entry(oop ref, jlong tag) {
 490   assert(Thread::current()-&gt;is_VM_thread() || is_locked(), &quot;checking&quot;);
 491 
 492   // ref was read with AS_NO_KEEPALIVE, or equivalent.
 493   // The object needs to be kept alive when it is published.
 494   Universe::heap()-&gt;keep_alive(ref);
 495 
 496   JvmtiTagHashmapEntry* entry;
 497   if (_free_entries == NULL) {
 498     entry = new JvmtiTagHashmapEntry(ref, tag);
 499   } else {
 500     assert(_free_entries_count &gt; 0, &quot;mismatched _free_entries_count&quot;);
 501     _free_entries_count--;
 502     entry = _free_entries;
 503     _free_entries = entry-&gt;next();
 504     entry-&gt;init(ref, tag);
 505   }
 506   return entry;
 507 }
 508 
 509 // destroy an entry by returning it to the free list
 510 void JvmtiTagMap::destroy_entry(JvmtiTagHashmapEntry* entry) {
 511   assert(SafepointSynchronize::is_at_safepoint() || is_locked(), &quot;checking&quot;);
 512   // limit the size of the free list
 513   if (_free_entries_count &gt;= max_free_entries) {
 514     delete entry;
 515   } else {
 516     entry-&gt;set_next(_free_entries);
 517     _free_entries = entry;
 518     _free_entries_count++;
 519   }
 520 }
 521 
 522 // returns the tag map for the given environments. If the tag map
 523 // doesn&#39;t exist then it is created.
 524 JvmtiTagMap* JvmtiTagMap::tag_map_for(JvmtiEnv* env) {
 525   JvmtiTagMap* tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map_acquire();
 526   if (tag_map == NULL) {
 527     MutexLocker mu(JvmtiThreadState_lock);
 528     tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map();
 529     if (tag_map == NULL) {
 530       tag_map = new JvmtiTagMap(env);
 531     }
 532   } else {
 533     DEBUG_ONLY(Thread::current()-&gt;check_possible_safepoint());
 534   }
 535   return tag_map;
 536 }
 537 
 538 // iterate over all entries in the tag map.
 539 void JvmtiTagMap::entry_iterate(JvmtiTagHashmapEntryClosure* closure) {
 540   hashmap()-&gt;entry_iterate(closure);
 541 }
 542 
 543 // returns true if the hashmaps are empty
 544 bool JvmtiTagMap::is_empty() {
 545   assert(SafepointSynchronize::is_at_safepoint() || is_locked(), &quot;checking&quot;);
 546   return hashmap()-&gt;entry_count() == 0;
 547 }
 548 
 549 
 550 // Return the tag value for an object, or 0 if the object is
 551 // not tagged
 552 //
 553 static inline jlong tag_for(JvmtiTagMap* tag_map, oop o) {
 554   JvmtiTagHashmapEntry* entry = tag_map-&gt;hashmap()-&gt;find(o);
 555   if (entry == NULL) {
 556     return 0;
 557   } else {
 558     return entry-&gt;tag();
 559   }
 560 }
 561 
 562 
 563 // A CallbackWrapper is a support class for querying and tagging an object
 564 // around a callback to a profiler. The constructor does pre-callback
 565 // work to get the tag value, klass tag value, ... and the destructor
 566 // does the post-callback work of tagging or untagging the object.
 567 //
 568 // {
 569 //   CallbackWrapper wrapper(tag_map, o);
 570 //
 571 //   (*callback)(wrapper.klass_tag(), wrapper.obj_size(), wrapper.obj_tag_p(), ...)
 572 //
 573 // } // wrapper goes out of scope here which results in the destructor
 574 //      checking to see if the object has been tagged, untagged, or the
 575 //      tag value has changed.
 576 //
 577 class CallbackWrapper : public StackObj {
 578  private:
 579   JvmtiTagMap* _tag_map;
 580   JvmtiTagHashmap* _hashmap;
 581   JvmtiTagHashmapEntry* _entry;
 582   oop _o;
 583   jlong _obj_size;
 584   jlong _obj_tag;
 585   jlong _klass_tag;
 586 
 587  protected:
 588   JvmtiTagMap* tag_map() const      { return _tag_map; }
 589 
 590   // invoked post-callback to tag, untag, or update the tag of an object
 591   void inline post_callback_tag_update(oop o, JvmtiTagHashmap* hashmap,
 592                                        JvmtiTagHashmapEntry* entry, jlong obj_tag);
 593  public:
 594   CallbackWrapper(JvmtiTagMap* tag_map, oop o) {
 595     assert(Thread::current()-&gt;is_VM_thread() || tag_map-&gt;is_locked(),
 596            &quot;MT unsafe or must be VM thread&quot;);
 597 
 598     // object to tag
 599     _o = o;
 600 
 601     // object size
 602     _obj_size = (jlong)_o-&gt;size() * wordSize;
 603 
 604     // record the context
 605     _tag_map = tag_map;
 606     _hashmap = tag_map-&gt;hashmap();
 607     _entry = _hashmap-&gt;find(_o);
 608 
 609     // get object tag
 610     _obj_tag = (_entry == NULL) ? 0 : _entry-&gt;tag();
 611 
 612     // get the class and the class&#39;s tag value
 613     assert(SystemDictionary::Class_klass()-&gt;is_mirror_instance_klass(), &quot;Is not?&quot;);
 614 
 615     _klass_tag = tag_for(tag_map, _o-&gt;klass()-&gt;java_mirror());
 616   }
 617 
 618   ~CallbackWrapper() {
 619     post_callback_tag_update(_o, _hashmap, _entry, _obj_tag);
 620   }
 621 
 622   inline jlong* obj_tag_p()                     { return &amp;_obj_tag; }
 623   inline jlong obj_size() const                 { return _obj_size; }
 624   inline jlong obj_tag() const                  { return _obj_tag; }
 625   inline jlong klass_tag() const                { return _klass_tag; }
 626 };
 627 
 628 
 629 
 630 // callback post-callback to tag, untag, or update the tag of an object
 631 void inline CallbackWrapper::post_callback_tag_update(oop o,
 632                                                       JvmtiTagHashmap* hashmap,
 633                                                       JvmtiTagHashmapEntry* entry,
 634                                                       jlong obj_tag) {
 635   if (entry == NULL) {
 636     if (obj_tag != 0) {
 637       // callback has tagged the object
 638       assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 639       entry = tag_map()-&gt;create_entry(o, obj_tag);
 640       hashmap-&gt;add(o, entry);
 641     }
 642   } else {
 643     // object was previously tagged - the callback may have untagged
 644     // the object or changed the tag value
 645     if (obj_tag == 0) {
 646 
 647       JvmtiTagHashmapEntry* entry_removed = hashmap-&gt;remove(o);
 648       assert(entry_removed == entry, &quot;checking&quot;);
 649       tag_map()-&gt;destroy_entry(entry);
 650 
 651     } else {
 652       if (obj_tag != entry-&gt;tag()) {
 653          entry-&gt;set_tag(obj_tag);
 654       }
 655     }
 656   }
 657 }
 658 
 659 // An extended CallbackWrapper used when reporting an object reference
 660 // to the agent.
 661 //
 662 // {
 663 //   TwoOopCallbackWrapper wrapper(tag_map, referrer, o);
 664 //
 665 //   (*callback)(wrapper.klass_tag(),
 666 //               wrapper.obj_size(),
 667 //               wrapper.obj_tag_p()
 668 //               wrapper.referrer_tag_p(), ...)
 669 //
 670 // } // wrapper goes out of scope here which results in the destructor
 671 //      checking to see if the referrer object has been tagged, untagged,
 672 //      or the tag value has changed.
 673 //
 674 class TwoOopCallbackWrapper : public CallbackWrapper {
 675  private:
 676   bool _is_reference_to_self;
 677   JvmtiTagHashmap* _referrer_hashmap;
 678   JvmtiTagHashmapEntry* _referrer_entry;
 679   oop _referrer;
 680   jlong _referrer_obj_tag;
 681   jlong _referrer_klass_tag;
 682   jlong* _referrer_tag_p;
 683 
 684   bool is_reference_to_self() const             { return _is_reference_to_self; }
 685 
 686  public:
 687   TwoOopCallbackWrapper(JvmtiTagMap* tag_map, oop referrer, oop o) :
 688     CallbackWrapper(tag_map, o)
 689   {
 690     // self reference needs to be handled in a special way
 691     _is_reference_to_self = (referrer == o);
 692 
 693     if (_is_reference_to_self) {
 694       _referrer_klass_tag = klass_tag();
 695       _referrer_tag_p = obj_tag_p();
 696     } else {
 697       _referrer = referrer;
 698       // record the context
 699       _referrer_hashmap = tag_map-&gt;hashmap();
 700       _referrer_entry = _referrer_hashmap-&gt;find(_referrer);
 701 
 702       // get object tag
 703       _referrer_obj_tag = (_referrer_entry == NULL) ? 0 : _referrer_entry-&gt;tag();
 704       _referrer_tag_p = &amp;_referrer_obj_tag;
 705 
 706       // get referrer class tag.
 707       _referrer_klass_tag = tag_for(tag_map, _referrer-&gt;klass()-&gt;java_mirror());
 708     }
 709   }
 710 
 711   ~TwoOopCallbackWrapper() {
 712     if (!is_reference_to_self()){
 713       post_callback_tag_update(_referrer,
 714                                _referrer_hashmap,
 715                                _referrer_entry,
 716                                _referrer_obj_tag);
 717     }
 718   }
 719 
 720   // address of referrer tag
 721   // (for a self reference this will return the same thing as obj_tag_p())
 722   inline jlong* referrer_tag_p()        { return _referrer_tag_p; }
 723 
 724   // referrer&#39;s class tag
 725   inline jlong referrer_klass_tag()     { return _referrer_klass_tag; }
 726 };
 727 
 728 // tag an object
 729 //
 730 // This function is performance critical. If many threads attempt to tag objects
 731 // around the same time then it&#39;s possible that the Mutex associated with the
 732 // tag map will be a hot lock.
 733 void JvmtiTagMap::set_tag(jobject object, jlong tag) {
 734   MutexLocker ml(lock());
 735 
 736   // resolve the object
 737   oop o = JNIHandles::resolve_non_null(object);
 738 
 739   // see if the object is already tagged
 740   JvmtiTagHashmap* hashmap = _hashmap;
 741   JvmtiTagHashmapEntry* entry = hashmap-&gt;find(o);
 742 
 743   // if the object is not already tagged then we tag it
 744   if (entry == NULL) {
 745     if (tag != 0) {
 746       entry = create_entry(o, tag);
 747       hashmap-&gt;add(o, entry);
 748     } else {
 749       // no-op
 750     }
 751   } else {
 752     // if the object is already tagged then we either update
 753     // the tag (if a new tag value has been provided)
 754     // or remove the object if the new tag value is 0.
 755     if (tag == 0) {
 756       hashmap-&gt;remove(o);
 757       destroy_entry(entry);
 758     } else {
 759       entry-&gt;set_tag(tag);
 760     }
 761   }
 762 }
 763 
 764 // get the tag for an object
 765 jlong JvmtiTagMap::get_tag(jobject object) {
 766   MutexLocker ml(lock());
 767 
 768   // resolve the object
 769   oop o = JNIHandles::resolve_non_null(object);
 770 
 771   return tag_for(this, o);
 772 }
 773 
 774 
 775 // Helper class used to describe the static or instance fields of a class.
 776 // For each field it holds the field index (as defined by the JVMTI specification),
 777 // the field type, and the offset.
 778 
 779 class ClassFieldDescriptor: public CHeapObj&lt;mtInternal&gt; {
 780  private:
 781   int _field_index;
 782   int _field_offset;
 783   char _field_type;
 784  public:
 785   ClassFieldDescriptor(int index, char type, int offset) :
 786     _field_index(index), _field_offset(offset), _field_type(type) {
 787   }
 788   int field_index()  const  { return _field_index; }
 789   char field_type()  const  { return _field_type; }
 790   int field_offset() const  { return _field_offset; }
 791 };
 792 
 793 class ClassFieldMap: public CHeapObj&lt;mtInternal&gt; {
 794  private:
 795   enum {
 796     initial_field_count = 5
 797   };
 798 
 799   // list of field descriptors
 800   GrowableArray&lt;ClassFieldDescriptor*&gt;* _fields;
 801 
 802   // constructor
 803   ClassFieldMap();
 804 
 805   // add a field
 806   void add(int index, char type, int offset);
 807 
 808   // returns the field count for the given class
 809   static int compute_field_count(InstanceKlass* ik);
 810 
 811  public:
 812   ~ClassFieldMap();
 813 
 814   // access
 815   int field_count()                     { return _fields-&gt;length(); }
 816   ClassFieldDescriptor* field_at(int i) { return _fields-&gt;at(i); }
 817 
 818   // functions to create maps of static or instance fields
 819   static ClassFieldMap* create_map_of_static_fields(Klass* k);
 820   static ClassFieldMap* create_map_of_instance_fields(oop obj);
 821 };
 822 
 823 ClassFieldMap::ClassFieldMap() {
 824   _fields = new (ResourceObj::C_HEAP, mtServiceability)
 825     GrowableArray&lt;ClassFieldDescriptor*&gt;(initial_field_count, mtServiceability);
 826 }
 827 
 828 ClassFieldMap::~ClassFieldMap() {
 829   for (int i=0; i&lt;_fields-&gt;length(); i++) {
 830     delete _fields-&gt;at(i);
 831   }
 832   delete _fields;
 833 }
 834 
 835 void ClassFieldMap::add(int index, char type, int offset) {
 836   ClassFieldDescriptor* field = new ClassFieldDescriptor(index, type, offset);
 837   _fields-&gt;append(field);
 838 }
 839 
 840 // Returns a heap allocated ClassFieldMap to describe the static fields
 841 // of the given class.
 842 //
 843 ClassFieldMap* ClassFieldMap::create_map_of_static_fields(Klass* k) {
<a name="1" id="anc1"></a>
 844   InstanceKlass* ik = InstanceKlass::cast(k);
 845 
 846   // create the field map
 847   ClassFieldMap* field_map = new ClassFieldMap();
 848 
 849   FilteredFieldStream f(ik, false, false);
 850   int max_field_index = f.field_count()-1;
 851 
 852   int index = 0;
 853   for (FilteredFieldStream fld(ik, true, true); !fld.eos(); fld.next(), index++) {
 854     // ignore instance fields
 855     if (!fld.access_flags().is_static()) {
 856       continue;
 857     }
 858     field_map-&gt;add(max_field_index - index, fld.signature()-&gt;char_at(0), fld.offset());
 859   }
 860   return field_map;
 861 }
 862 
 863 // Returns a heap allocated ClassFieldMap to describe the instance fields
 864 // of the given class. All instance fields are included (this means public
 865 // and private fields declared in superclasses and superinterfaces too).
 866 //
 867 ClassFieldMap* ClassFieldMap::create_map_of_instance_fields(oop obj) {
<a name="2" id="anc2"></a>
 868   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
 869 
 870   // create the field map
 871   ClassFieldMap* field_map = new ClassFieldMap();
 872 
 873   FilteredFieldStream f(ik, false, false);
 874 
 875   int max_field_index = f.field_count()-1;
 876 
 877   int index = 0;
 878   for (FilteredFieldStream fld(ik, false, false); !fld.eos(); fld.next(), index++) {
 879     // ignore static fields
 880     if (fld.access_flags().is_static()) {
 881       continue;
 882     }
 883     field_map-&gt;add(max_field_index - index, fld.signature()-&gt;char_at(0), fld.offset());
 884   }
 885 
 886   return field_map;
 887 }
 888 
 889 // Helper class used to cache a ClassFileMap for the instance fields of
 890 // a cache. A JvmtiCachedClassFieldMap can be cached by an InstanceKlass during
 891 // heap iteration and avoid creating a field map for each object in the heap
 892 // (only need to create the map when the first instance of a class is encountered).
 893 //
 894 class JvmtiCachedClassFieldMap : public CHeapObj&lt;mtInternal&gt; {
 895  private:
 896    enum {
 897      initial_class_count = 200
 898    };
 899   ClassFieldMap* _field_map;
 900 
 901   ClassFieldMap* field_map() const          { return _field_map; }
 902 
 903   JvmtiCachedClassFieldMap(ClassFieldMap* field_map);
 904   ~JvmtiCachedClassFieldMap();
 905 
 906   static GrowableArray&lt;InstanceKlass*&gt;* _class_list;
 907   static void add_to_class_list(InstanceKlass* ik);
 908 
 909  public:
 910   // returns the field map for a given object (returning map cached
 911   // by InstanceKlass if possible
 912   static ClassFieldMap* get_map_of_instance_fields(oop obj);
 913 
 914   // removes the field map from all instanceKlasses - should be
 915   // called before VM operation completes
 916   static void clear_cache();
 917 
 918   // returns the number of ClassFieldMap cached by instanceKlasses
 919   static int cached_field_map_count();
 920 };
 921 
 922 GrowableArray&lt;InstanceKlass*&gt;* JvmtiCachedClassFieldMap::_class_list;
 923 
 924 JvmtiCachedClassFieldMap::JvmtiCachedClassFieldMap(ClassFieldMap* field_map) {
 925   _field_map = field_map;
 926 }
 927 
 928 JvmtiCachedClassFieldMap::~JvmtiCachedClassFieldMap() {
 929   if (_field_map != NULL) {
 930     delete _field_map;
 931   }
 932 }
 933 
 934 // Marker class to ensure that the class file map cache is only used in a defined
 935 // scope.
 936 class ClassFieldMapCacheMark : public StackObj {
 937  private:
 938    static bool _is_active;
 939  public:
 940    ClassFieldMapCacheMark() {
 941      assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 942      assert(JvmtiCachedClassFieldMap::cached_field_map_count() == 0, &quot;cache not empty&quot;);
 943      assert(!_is_active, &quot;ClassFieldMapCacheMark cannot be nested&quot;);
 944      _is_active = true;
 945    }
 946    ~ClassFieldMapCacheMark() {
 947      JvmtiCachedClassFieldMap::clear_cache();
 948      _is_active = false;
 949    }
 950    static bool is_active() { return _is_active; }
 951 };
 952 
 953 bool ClassFieldMapCacheMark::_is_active;
 954 
 955 
 956 // record that the given InstanceKlass is caching a field map
 957 void JvmtiCachedClassFieldMap::add_to_class_list(InstanceKlass* ik) {
 958   if (_class_list == NULL) {
 959     _class_list = new (ResourceObj::C_HEAP, mtServiceability)
 960       GrowableArray&lt;InstanceKlass*&gt;(initial_class_count, mtServiceability);
 961   }
 962   _class_list-&gt;push(ik);
 963 }
 964 
 965 // returns the instance field map for the given object
 966 // (returns field map cached by the InstanceKlass if possible)
 967 ClassFieldMap* JvmtiCachedClassFieldMap::get_map_of_instance_fields(oop obj) {
 968   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 969   assert(ClassFieldMapCacheMark::is_active(), &quot;ClassFieldMapCacheMark not active&quot;);
 970 
 971   Klass* k = obj-&gt;klass();
 972   InstanceKlass* ik = InstanceKlass::cast(k);
 973 
 974   // return cached map if possible
 975   JvmtiCachedClassFieldMap* cached_map = ik-&gt;jvmti_cached_class_field_map();
 976   if (cached_map != NULL) {
 977     assert(cached_map-&gt;field_map() != NULL, &quot;missing field list&quot;);
 978     return cached_map-&gt;field_map();
 979   } else {
 980     ClassFieldMap* field_map = ClassFieldMap::create_map_of_instance_fields(obj);
 981     cached_map = new JvmtiCachedClassFieldMap(field_map);
 982     ik-&gt;set_jvmti_cached_class_field_map(cached_map);
 983     add_to_class_list(ik);
 984     return field_map;
 985   }
 986 }
 987 
 988 // remove the fields maps cached from all instanceKlasses
 989 void JvmtiCachedClassFieldMap::clear_cache() {
 990   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 991   if (_class_list != NULL) {
 992     for (int i = 0; i &lt; _class_list-&gt;length(); i++) {
 993       InstanceKlass* ik = _class_list-&gt;at(i);
 994       JvmtiCachedClassFieldMap* cached_map = ik-&gt;jvmti_cached_class_field_map();
 995       assert(cached_map != NULL, &quot;should not be NULL&quot;);
 996       ik-&gt;set_jvmti_cached_class_field_map(NULL);
 997       delete cached_map;  // deletes the encapsulated field map
 998     }
 999     delete _class_list;
1000     _class_list = NULL;
1001   }
1002 }
1003 
1004 // returns the number of ClassFieldMap cached by instanceKlasses
1005 int JvmtiCachedClassFieldMap::cached_field_map_count() {
1006   return (_class_list == NULL) ? 0 : _class_list-&gt;length();
1007 }
1008 
1009 // helper function to indicate if an object is filtered by its tag or class tag
1010 static inline bool is_filtered_by_heap_filter(jlong obj_tag,
1011                                               jlong klass_tag,
1012                                               int heap_filter) {
1013   // apply the heap filter
1014   if (obj_tag != 0) {
1015     // filter out tagged objects
1016     if (heap_filter &amp; JVMTI_HEAP_FILTER_TAGGED) return true;
1017   } else {
1018     // filter out untagged objects
1019     if (heap_filter &amp; JVMTI_HEAP_FILTER_UNTAGGED) return true;
1020   }
1021   if (klass_tag != 0) {
1022     // filter out objects with tagged classes
1023     if (heap_filter &amp; JVMTI_HEAP_FILTER_CLASS_TAGGED) return true;
1024   } else {
1025     // filter out objects with untagged classes.
1026     if (heap_filter &amp; JVMTI_HEAP_FILTER_CLASS_UNTAGGED) return true;
1027   }
1028   return false;
1029 }
1030 
1031 // helper function to indicate if an object is filtered by a klass filter
1032 static inline bool is_filtered_by_klass_filter(oop obj, Klass* klass_filter) {
1033   if (klass_filter != NULL) {
1034     if (obj-&gt;klass() != klass_filter) {
1035       return true;
1036     }
1037   }
1038   return false;
1039 }
1040 
1041 // helper function to tell if a field is a primitive field or not
1042 static inline bool is_primitive_field_type(char type) {
1043   return (type != JVM_SIGNATURE_CLASS &amp;&amp; type != JVM_SIGNATURE_ARRAY);
1044 }
1045 
1046 // helper function to copy the value from location addr to jvalue.
1047 static inline void copy_to_jvalue(jvalue *v, address addr, jvmtiPrimitiveType value_type) {
1048   switch (value_type) {
1049     case JVMTI_PRIMITIVE_TYPE_BOOLEAN : { v-&gt;z = *(jboolean*)addr; break; }
1050     case JVMTI_PRIMITIVE_TYPE_BYTE    : { v-&gt;b = *(jbyte*)addr;    break; }
1051     case JVMTI_PRIMITIVE_TYPE_CHAR    : { v-&gt;c = *(jchar*)addr;    break; }
1052     case JVMTI_PRIMITIVE_TYPE_SHORT   : { v-&gt;s = *(jshort*)addr;   break; }
1053     case JVMTI_PRIMITIVE_TYPE_INT     : { v-&gt;i = *(jint*)addr;     break; }
1054     case JVMTI_PRIMITIVE_TYPE_LONG    : { v-&gt;j = *(jlong*)addr;    break; }
1055     case JVMTI_PRIMITIVE_TYPE_FLOAT   : { v-&gt;f = *(jfloat*)addr;   break; }
1056     case JVMTI_PRIMITIVE_TYPE_DOUBLE  : { v-&gt;d = *(jdouble*)addr;  break; }
1057     default: ShouldNotReachHere();
1058   }
1059 }
1060 
1061 // helper function to invoke string primitive value callback
1062 // returns visit control flags
1063 static jint invoke_string_value_callback(jvmtiStringPrimitiveValueCallback cb,
1064                                          CallbackWrapper* wrapper,
1065                                          oop str,
1066                                          void* user_data)
1067 {
1068   assert(str-&gt;klass() == SystemDictionary::String_klass(), &quot;not a string&quot;);
1069 
1070   typeArrayOop s_value = java_lang_String::value(str);
1071 
1072   // JDK-6584008: the value field may be null if a String instance is
1073   // partially constructed.
1074   if (s_value == NULL) {
1075     return 0;
1076   }
1077   // get the string value and length
1078   // (string value may be offset from the base)
1079   int s_len = java_lang_String::length(str);
1080   bool is_latin1 = java_lang_String::is_latin1(str);
1081   jchar* value;
1082   if (s_len &gt; 0) {
1083     if (!is_latin1) {
1084       value = s_value-&gt;char_at_addr(0);
1085     } else {
1086       // Inflate latin1 encoded string to UTF16
1087       jchar* buf = NEW_C_HEAP_ARRAY(jchar, s_len, mtInternal);
1088       for (int i = 0; i &lt; s_len; i++) {
1089         buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
1090       }
1091       value = &amp;buf[0];
1092     }
1093   } else {
1094     // Don&#39;t use char_at_addr(0) if length is 0
1095     value = (jchar*) s_value-&gt;base(T_CHAR);
1096   }
1097 
1098   // invoke the callback
1099   jint res = (*cb)(wrapper-&gt;klass_tag(),
1100                    wrapper-&gt;obj_size(),
1101                    wrapper-&gt;obj_tag_p(),
1102                    value,
1103                    (jint)s_len,
1104                    user_data);
1105 
1106   if (is_latin1 &amp;&amp; s_len &gt; 0) {
1107     FREE_C_HEAP_ARRAY(jchar, value);
1108   }
1109   return res;
1110 }
1111 
1112 // helper function to invoke string primitive value callback
1113 // returns visit control flags
1114 static jint invoke_array_primitive_value_callback(jvmtiArrayPrimitiveValueCallback cb,
1115                                                   CallbackWrapper* wrapper,
1116                                                   oop obj,
1117                                                   void* user_data)
1118 {
1119   assert(obj-&gt;is_typeArray(), &quot;not a primitive array&quot;);
1120 
1121   // get base address of first element
1122   typeArrayOop array = typeArrayOop(obj);
1123   BasicType type = TypeArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1124   void* elements = array-&gt;base(type);
1125 
1126   // jvmtiPrimitiveType is defined so this mapping is always correct
1127   jvmtiPrimitiveType elem_type = (jvmtiPrimitiveType)type2char(type);
1128 
1129   return (*cb)(wrapper-&gt;klass_tag(),
1130                wrapper-&gt;obj_size(),
1131                wrapper-&gt;obj_tag_p(),
1132                (jint)array-&gt;length(),
1133                elem_type,
1134                elements,
1135                user_data);
1136 }
1137 
1138 // helper function to invoke the primitive field callback for all static fields
1139 // of a given class
1140 static jint invoke_primitive_field_callback_for_static_fields
1141   (CallbackWrapper* wrapper,
1142    oop obj,
1143    jvmtiPrimitiveFieldCallback cb,
1144    void* user_data)
1145 {
1146   // for static fields only the index will be set
1147   static jvmtiHeapReferenceInfo reference_info = { 0 };
1148 
1149   assert(obj-&gt;klass() == SystemDictionary::Class_klass(), &quot;not a class&quot;);
1150   if (java_lang_Class::is_primitive(obj)) {
1151     return 0;
1152   }
1153   Klass* klass = java_lang_Class::as_Klass(obj);
1154 
1155   // ignore classes for object and type arrays
1156   if (!klass-&gt;is_instance_klass()) {
1157     return 0;
1158   }
1159 
1160   // ignore classes which aren&#39;t linked yet
1161   InstanceKlass* ik = InstanceKlass::cast(klass);
1162   if (!ik-&gt;is_linked()) {
1163     return 0;
1164   }
1165 
1166   // get the field map
1167   ClassFieldMap* field_map = ClassFieldMap::create_map_of_static_fields(klass);
1168 
1169   // invoke the callback for each static primitive field
1170   for (int i=0; i&lt;field_map-&gt;field_count(); i++) {
1171     ClassFieldDescriptor* field = field_map-&gt;field_at(i);
1172 
1173     // ignore non-primitive fields
1174     char type = field-&gt;field_type();
1175     if (!is_primitive_field_type(type)) {
1176       continue;
1177     }
1178     // one-to-one mapping
1179     jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
1180 
1181     // get offset and field value
1182     int offset = field-&gt;field_offset();
1183     address addr = cast_from_oop&lt;address&gt;(klass-&gt;java_mirror()) + offset;
1184     jvalue value;
1185     copy_to_jvalue(&amp;value, addr, value_type);
1186 
1187     // field index
1188     reference_info.field.index = field-&gt;field_index();
1189 
1190     // invoke the callback
1191     jint res = (*cb)(JVMTI_HEAP_REFERENCE_STATIC_FIELD,
1192                      &amp;reference_info,
1193                      wrapper-&gt;klass_tag(),
1194                      wrapper-&gt;obj_tag_p(),
1195                      value,
1196                      value_type,
1197                      user_data);
1198     if (res &amp; JVMTI_VISIT_ABORT) {
1199       delete field_map;
1200       return res;
1201     }
1202   }
1203 
1204   delete field_map;
1205   return 0;
1206 }
1207 
1208 // helper function to invoke the primitive field callback for all instance fields
1209 // of a given object
1210 static jint invoke_primitive_field_callback_for_instance_fields(
1211   CallbackWrapper* wrapper,
1212   oop obj,
1213   jvmtiPrimitiveFieldCallback cb,
1214   void* user_data)
1215 {
1216   // for instance fields only the index will be set
1217   static jvmtiHeapReferenceInfo reference_info = { 0 };
1218 
1219   // get the map of the instance fields
1220   ClassFieldMap* fields = JvmtiCachedClassFieldMap::get_map_of_instance_fields(obj);
1221 
1222   // invoke the callback for each instance primitive field
1223   for (int i=0; i&lt;fields-&gt;field_count(); i++) {
1224     ClassFieldDescriptor* field = fields-&gt;field_at(i);
1225 
1226     // ignore non-primitive fields
1227     char type = field-&gt;field_type();
1228     if (!is_primitive_field_type(type)) {
1229       continue;
1230     }
1231     // one-to-one mapping
1232     jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
1233 
1234     // get offset and field value
1235     int offset = field-&gt;field_offset();
1236     address addr = cast_from_oop&lt;address&gt;(obj) + offset;
1237     jvalue value;
1238     copy_to_jvalue(&amp;value, addr, value_type);
1239 
1240     // field index
1241     reference_info.field.index = field-&gt;field_index();
1242 
1243     // invoke the callback
1244     jint res = (*cb)(JVMTI_HEAP_REFERENCE_FIELD,
1245                      &amp;reference_info,
1246                      wrapper-&gt;klass_tag(),
1247                      wrapper-&gt;obj_tag_p(),
1248                      value,
1249                      value_type,
1250                      user_data);
1251     if (res &amp; JVMTI_VISIT_ABORT) {
1252       return res;
1253     }
1254   }
1255   return 0;
1256 }
1257 
1258 
1259 // VM operation to iterate over all objects in the heap (both reachable
1260 // and unreachable)
1261 class VM_HeapIterateOperation: public VM_Operation {
1262  private:
1263   ObjectClosure* _blk;
1264  public:
1265   VM_HeapIterateOperation(ObjectClosure* blk) { _blk = blk; }
1266 
1267   VMOp_Type type() const { return VMOp_HeapIterateOperation; }
1268   void doit() {
1269     // allows class files maps to be cached during iteration
1270     ClassFieldMapCacheMark cm;
1271 
1272     // make sure that heap is parsable (fills TLABs with filler objects)
1273     Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
1274 
1275     // Verify heap before iteration - if the heap gets corrupted then
1276     // JVMTI&#39;s IterateOverHeap will crash.
1277     if (VerifyBeforeIteration) {
1278       Universe::verify();
1279     }
1280 
1281     // do the iteration
1282     Universe::heap()-&gt;object_iterate(_blk);
1283   }
1284 
1285 };
1286 
1287 
1288 // An ObjectClosure used to support the deprecated IterateOverHeap and
1289 // IterateOverInstancesOfClass functions
1290 class IterateOverHeapObjectClosure: public ObjectClosure {
1291  private:
1292   JvmtiTagMap* _tag_map;
1293   Klass* _klass;
1294   jvmtiHeapObjectFilter _object_filter;
1295   jvmtiHeapObjectCallback _heap_object_callback;
1296   const void* _user_data;
1297 
1298   // accessors
1299   JvmtiTagMap* tag_map() const                    { return _tag_map; }
1300   jvmtiHeapObjectFilter object_filter() const     { return _object_filter; }
1301   jvmtiHeapObjectCallback object_callback() const { return _heap_object_callback; }
1302   Klass* klass() const                            { return _klass; }
1303   const void* user_data() const                   { return _user_data; }
1304 
1305   // indicates if iteration has been aborted
1306   bool _iteration_aborted;
1307   bool is_iteration_aborted() const               { return _iteration_aborted; }
1308   void set_iteration_aborted(bool aborted)        { _iteration_aborted = aborted; }
1309 
1310  public:
1311   IterateOverHeapObjectClosure(JvmtiTagMap* tag_map,
1312                                Klass* klass,
1313                                jvmtiHeapObjectFilter object_filter,
1314                                jvmtiHeapObjectCallback heap_object_callback,
1315                                const void* user_data) :
1316     _tag_map(tag_map),
1317     _klass(klass),
1318     _object_filter(object_filter),
1319     _heap_object_callback(heap_object_callback),
1320     _user_data(user_data),
1321     _iteration_aborted(false)
1322   {
1323   }
1324 
1325   void do_object(oop o);
1326 };
1327 
1328 // invoked for each object in the heap
1329 void IterateOverHeapObjectClosure::do_object(oop o) {
1330   // check if iteration has been halted
1331   if (is_iteration_aborted()) return;
1332 
1333   // instanceof check when filtering by klass
1334   if (klass() != NULL &amp;&amp; !o-&gt;is_a(klass())) {
1335     return;
1336   }
1337   // prepare for the calllback
1338   CallbackWrapper wrapper(tag_map(), o);
1339 
1340   // if the object is tagged and we&#39;re only interested in untagged objects
1341   // then don&#39;t invoke the callback. Similiarly, if the object is untagged
1342   // and we&#39;re only interested in tagged objects we skip the callback.
1343   if (wrapper.obj_tag() != 0) {
1344     if (object_filter() == JVMTI_HEAP_OBJECT_UNTAGGED) return;
1345   } else {
1346     if (object_filter() == JVMTI_HEAP_OBJECT_TAGGED) return;
1347   }
1348 
1349   // invoke the agent&#39;s callback
1350   jvmtiIterationControl control = (*object_callback())(wrapper.klass_tag(),
1351                                                        wrapper.obj_size(),
1352                                                        wrapper.obj_tag_p(),
1353                                                        (void*)user_data());
1354   if (control == JVMTI_ITERATION_ABORT) {
1355     set_iteration_aborted(true);
1356   }
1357 }
1358 
1359 // An ObjectClosure used to support the IterateThroughHeap function
1360 class IterateThroughHeapObjectClosure: public ObjectClosure {
1361  private:
1362   JvmtiTagMap* _tag_map;
1363   Klass* _klass;
1364   int _heap_filter;
1365   const jvmtiHeapCallbacks* _callbacks;
1366   const void* _user_data;
1367 
1368   // accessor functions
1369   JvmtiTagMap* tag_map() const                     { return _tag_map; }
1370   int heap_filter() const                          { return _heap_filter; }
1371   const jvmtiHeapCallbacks* callbacks() const      { return _callbacks; }
1372   Klass* klass() const                             { return _klass; }
1373   const void* user_data() const                    { return _user_data; }
1374 
1375   // indicates if the iteration has been aborted
1376   bool _iteration_aborted;
1377   bool is_iteration_aborted() const                { return _iteration_aborted; }
1378 
1379   // used to check the visit control flags. If the abort flag is set
1380   // then we set the iteration aborted flag so that the iteration completes
1381   // without processing any further objects
1382   bool check_flags_for_abort(jint flags) {
1383     bool is_abort = (flags &amp; JVMTI_VISIT_ABORT) != 0;
1384     if (is_abort) {
1385       _iteration_aborted = true;
1386     }
1387     return is_abort;
1388   }
1389 
1390  public:
1391   IterateThroughHeapObjectClosure(JvmtiTagMap* tag_map,
1392                                   Klass* klass,
1393                                   int heap_filter,
1394                                   const jvmtiHeapCallbacks* heap_callbacks,
1395                                   const void* user_data) :
1396     _tag_map(tag_map),
1397     _klass(klass),
1398     _heap_filter(heap_filter),
1399     _callbacks(heap_callbacks),
1400     _user_data(user_data),
1401     _iteration_aborted(false)
1402   {
1403   }
1404 
1405   void do_object(oop o);
1406 };
1407 
1408 // invoked for each object in the heap
1409 void IterateThroughHeapObjectClosure::do_object(oop obj) {
1410   // check if iteration has been halted
1411   if (is_iteration_aborted()) return;
1412 
1413   // apply class filter
1414   if (is_filtered_by_klass_filter(obj, klass())) return;
1415 
1416   // prepare for callback
1417   CallbackWrapper wrapper(tag_map(), obj);
1418 
1419   // check if filtered by the heap filter
1420   if (is_filtered_by_heap_filter(wrapper.obj_tag(), wrapper.klass_tag(), heap_filter())) {
1421     return;
1422   }
1423 
1424   // for arrays we need the length, otherwise -1
1425   bool is_array = obj-&gt;is_array();
1426   int len = is_array ? arrayOop(obj)-&gt;length() : -1;
1427 
1428   // invoke the object callback (if callback is provided)
1429   if (callbacks()-&gt;heap_iteration_callback != NULL) {
1430     jvmtiHeapIterationCallback cb = callbacks()-&gt;heap_iteration_callback;
1431     jint res = (*cb)(wrapper.klass_tag(),
1432                      wrapper.obj_size(),
1433                      wrapper.obj_tag_p(),
1434                      (jint)len,
1435                      (void*)user_data());
1436     if (check_flags_for_abort(res)) return;
1437   }
1438 
1439   // for objects and classes we report primitive fields if callback provided
1440   if (callbacks()-&gt;primitive_field_callback != NULL &amp;&amp; obj-&gt;is_instance()) {
1441     jint res;
1442     jvmtiPrimitiveFieldCallback cb = callbacks()-&gt;primitive_field_callback;
1443     if (obj-&gt;klass() == SystemDictionary::Class_klass()) {
1444       res = invoke_primitive_field_callback_for_static_fields(&amp;wrapper,
1445                                                                     obj,
1446                                                                     cb,
1447                                                                     (void*)user_data());
1448     } else {
1449       res = invoke_primitive_field_callback_for_instance_fields(&amp;wrapper,
1450                                                                       obj,
1451                                                                       cb,
1452                                                                       (void*)user_data());
1453     }
1454     if (check_flags_for_abort(res)) return;
1455   }
1456 
1457   // string callback
1458   if (!is_array &amp;&amp;
1459       callbacks()-&gt;string_primitive_value_callback != NULL &amp;&amp;
1460       obj-&gt;klass() == SystemDictionary::String_klass()) {
1461     jint res = invoke_string_value_callback(
1462                 callbacks()-&gt;string_primitive_value_callback,
1463                 &amp;wrapper,
1464                 obj,
1465                 (void*)user_data() );
1466     if (check_flags_for_abort(res)) return;
1467   }
1468 
1469   // array callback
1470   if (is_array &amp;&amp;
1471       callbacks()-&gt;array_primitive_value_callback != NULL &amp;&amp;
1472       obj-&gt;is_typeArray()) {
1473     jint res = invoke_array_primitive_value_callback(
1474                callbacks()-&gt;array_primitive_value_callback,
1475                &amp;wrapper,
1476                obj,
1477                (void*)user_data() );
1478     if (check_flags_for_abort(res)) return;
1479   }
1480 };
1481 
1482 
1483 // Deprecated function to iterate over all objects in the heap
1484 void JvmtiTagMap::iterate_over_heap(jvmtiHeapObjectFilter object_filter,
1485                                     Klass* klass,
1486                                     jvmtiHeapObjectCallback heap_object_callback,
1487                                     const void* user_data)
1488 {
1489   MutexLocker ml(Heap_lock);
1490   IterateOverHeapObjectClosure blk(this,
1491                                    klass,
1492                                    object_filter,
1493                                    heap_object_callback,
1494                                    user_data);
1495   VM_HeapIterateOperation op(&amp;blk);
1496   VMThread::execute(&amp;op);
1497 }
1498 
1499 
1500 // Iterates over all objects in the heap
1501 void JvmtiTagMap::iterate_through_heap(jint heap_filter,
1502                                        Klass* klass,
1503                                        const jvmtiHeapCallbacks* callbacks,
1504                                        const void* user_data)
1505 {
1506   MutexLocker ml(Heap_lock);
1507   IterateThroughHeapObjectClosure blk(this,
1508                                       klass,
1509                                       heap_filter,
1510                                       callbacks,
1511                                       user_data);
1512   VM_HeapIterateOperation op(&amp;blk);
1513   VMThread::execute(&amp;op);
1514 }
1515 
1516 // support class for get_objects_with_tags
1517 
1518 class TagObjectCollector : public JvmtiTagHashmapEntryClosure {
1519  private:
1520   JvmtiEnv* _env;
1521   jlong* _tags;
1522   jint _tag_count;
1523 
1524   GrowableArray&lt;jobject&gt;* _object_results;  // collected objects (JNI weak refs)
1525   GrowableArray&lt;uint64_t&gt;* _tag_results;    // collected tags
1526 
1527  public:
1528   TagObjectCollector(JvmtiEnv* env, const jlong* tags, jint tag_count) {
1529     _env = env;
1530     _tags = (jlong*)tags;
1531     _tag_count = tag_count;
1532     _object_results = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;jobject&gt;(1, mtServiceability);
1533     _tag_results = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;uint64_t&gt;(1, mtServiceability);
1534   }
1535 
1536   ~TagObjectCollector() {
1537     delete _object_results;
1538     delete _tag_results;
1539   }
1540 
1541   // for each tagged object check if the tag value matches
1542   // - if it matches then we create a JNI local reference to the object
1543   // and record the reference and tag value.
1544   //
1545   void do_entry(JvmtiTagHashmapEntry* entry) {
1546     for (int i=0; i&lt;_tag_count; i++) {
1547       if (_tags[i] == entry-&gt;tag()) {
1548         // The reference in this tag map could be the only (implicitly weak)
1549         // reference to that object. If we hand it out, we need to keep it live wrt
1550         // SATB marking similar to other j.l.ref.Reference referents. This is
1551         // achieved by using a phantom load in the object() accessor.
1552         oop o = entry-&gt;object();
1553         assert(o != NULL &amp;&amp; Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);
1554         jobject ref = JNIHandles::make_local(JavaThread::current(), o);
1555         _object_results-&gt;append(ref);
1556         _tag_results-&gt;append((uint64_t)entry-&gt;tag());
1557       }
1558     }
1559   }
1560 
1561   // return the results from the collection
1562   //
1563   jvmtiError result(jint* count_ptr, jobject** object_result_ptr, jlong** tag_result_ptr) {
1564     jvmtiError error;
1565     int count = _object_results-&gt;length();
1566     assert(count &gt;= 0, &quot;sanity check&quot;);
1567 
1568     // if object_result_ptr is not NULL then allocate the result and copy
1569     // in the object references.
1570     if (object_result_ptr != NULL) {
1571       error = _env-&gt;Allocate(count * sizeof(jobject), (unsigned char**)object_result_ptr);
1572       if (error != JVMTI_ERROR_NONE) {
1573         return error;
1574       }
1575       for (int i=0; i&lt;count; i++) {
1576         (*object_result_ptr)[i] = _object_results-&gt;at(i);
1577       }
1578     }
1579 
1580     // if tag_result_ptr is not NULL then allocate the result and copy
1581     // in the tag values.
1582     if (tag_result_ptr != NULL) {
1583       error = _env-&gt;Allocate(count * sizeof(jlong), (unsigned char**)tag_result_ptr);
1584       if (error != JVMTI_ERROR_NONE) {
1585         if (object_result_ptr != NULL) {
1586           _env-&gt;Deallocate((unsigned char*)object_result_ptr);
1587         }
1588         return error;
1589       }
1590       for (int i=0; i&lt;count; i++) {
1591         (*tag_result_ptr)[i] = (jlong)_tag_results-&gt;at(i);
1592       }
1593     }
1594 
1595     *count_ptr = count;
1596     return JVMTI_ERROR_NONE;
1597   }
1598 };
1599 
1600 // return the list of objects with the specified tags
1601 jvmtiError JvmtiTagMap::get_objects_with_tags(const jlong* tags,
1602   jint count, jint* count_ptr, jobject** object_result_ptr, jlong** tag_result_ptr) {
1603 
1604   TagObjectCollector collector(env(), tags, count);
1605   {
1606     // iterate over all tagged objects
1607     MutexLocker ml(lock());
1608     entry_iterate(&amp;collector);
1609   }
1610   return collector.result(count_ptr, object_result_ptr, tag_result_ptr);
1611 }
1612 
1613 
1614 // ObjectMarker is used to support the marking objects when walking the
1615 // heap.
1616 //
1617 // This implementation uses the existing mark bits in an object for
1618 // marking. Objects that are marked must later have their headers restored.
1619 // As most objects are unlocked and don&#39;t have their identity hash computed
1620 // we don&#39;t have to save their headers. Instead we save the headers that
1621 // are &quot;interesting&quot;. Later when the headers are restored this implementation
1622 // restores all headers to their initial value and then restores the few
1623 // objects that had interesting headers.
1624 //
1625 // Future work: This implementation currently uses growable arrays to save
1626 // the oop and header of interesting objects. As an optimization we could
1627 // use the same technique as the GC and make use of the unused area
1628 // between top() and end().
1629 //
1630 
1631 // An ObjectClosure used to restore the mark bits of an object
1632 class RestoreMarksClosure : public ObjectClosure {
1633  public:
1634   void do_object(oop o) {
1635     if (o != NULL) {
1636       markWord mark = o-&gt;mark();
1637       if (mark.is_marked()) {
1638         o-&gt;init_mark();
1639       }
1640     }
1641   }
1642 };
1643 
1644 // ObjectMarker provides the mark and visited functions
1645 class ObjectMarker : AllStatic {
1646  private:
1647   // saved headers
1648   static GrowableArray&lt;oop&gt;* _saved_oop_stack;
1649   static GrowableArray&lt;markWord&gt;* _saved_mark_stack;
1650   static bool _needs_reset;                  // do we need to reset mark bits?
1651 
1652  public:
1653   static void init();                       // initialize
1654   static void done();                       // clean-up
1655 
1656   static inline void mark(oop o);           // mark an object
1657   static inline bool visited(oop o);        // check if object has been visited
1658 
1659   static inline bool needs_reset()            { return _needs_reset; }
1660   static inline void set_needs_reset(bool v)  { _needs_reset = v; }
1661 };
1662 
1663 GrowableArray&lt;oop&gt;* ObjectMarker::_saved_oop_stack = NULL;
1664 GrowableArray&lt;markWord&gt;* ObjectMarker::_saved_mark_stack = NULL;
1665 bool ObjectMarker::_needs_reset = true;  // need to reset mark bits by default
1666 
1667 // initialize ObjectMarker - prepares for object marking
1668 void ObjectMarker::init() {
1669   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
1670 
1671   // prepare heap for iteration
1672   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
1673 
1674   // create stacks for interesting headers
1675   _saved_mark_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;markWord&gt;(4000, mtServiceability);
1676   _saved_oop_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;oop&gt;(4000, mtServiceability);
1677 
1678   if (UseBiasedLocking) {
1679     BiasedLocking::preserve_marks();
1680   }
1681 }
1682 
1683 // Object marking is done so restore object headers
1684 void ObjectMarker::done() {
1685   // iterate over all objects and restore the mark bits to
1686   // their initial value
1687   RestoreMarksClosure blk;
1688   if (needs_reset()) {
1689     Universe::heap()-&gt;object_iterate(&amp;blk);
1690   } else {
1691     // We don&#39;t need to reset mark bits on this call, but reset the
1692     // flag to the default for the next call.
1693     set_needs_reset(true);
1694   }
1695 
1696   // now restore the interesting headers
1697   for (int i = 0; i &lt; _saved_oop_stack-&gt;length(); i++) {
1698     oop o = _saved_oop_stack-&gt;at(i);
1699     markWord mark = _saved_mark_stack-&gt;at(i);
1700     o-&gt;set_mark(mark);
1701   }
1702 
1703   if (UseBiasedLocking) {
1704     BiasedLocking::restore_marks();
1705   }
1706 
1707   // free the stacks
1708   delete _saved_oop_stack;
1709   delete _saved_mark_stack;
1710 }
1711 
1712 // mark an object
1713 inline void ObjectMarker::mark(oop o) {
1714   assert(Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);
1715   assert(!o-&gt;mark().is_marked(), &quot;should only mark an object once&quot;);
1716 
1717   // object&#39;s mark word
1718   markWord mark = o-&gt;mark();
1719 
1720   if (o-&gt;mark_must_be_preserved(mark)) {
1721     _saved_mark_stack-&gt;push(mark);
1722     _saved_oop_stack-&gt;push(o);
1723   }
1724 
1725   // mark the object
1726   o-&gt;set_mark(markWord::prototype().set_marked());
1727 }
1728 
1729 // return true if object is marked
1730 inline bool ObjectMarker::visited(oop o) {
1731   return o-&gt;mark().is_marked();
1732 }
1733 
1734 // Stack allocated class to help ensure that ObjectMarker is used
1735 // correctly. Constructor initializes ObjectMarker, destructor calls
1736 // ObjectMarker&#39;s done() function to restore object headers.
1737 class ObjectMarkerController : public StackObj {
1738  public:
1739   ObjectMarkerController() {
1740     ObjectMarker::init();
1741   }
1742   ~ObjectMarkerController() {
1743     ObjectMarker::done();
1744   }
1745 };
1746 
1747 
1748 // helper to map a jvmtiHeapReferenceKind to an old style jvmtiHeapRootKind
1749 // (not performance critical as only used for roots)
1750 static jvmtiHeapRootKind toJvmtiHeapRootKind(jvmtiHeapReferenceKind kind) {
1751   switch (kind) {
1752     case JVMTI_HEAP_REFERENCE_JNI_GLOBAL:   return JVMTI_HEAP_ROOT_JNI_GLOBAL;
1753     case JVMTI_HEAP_REFERENCE_SYSTEM_CLASS: return JVMTI_HEAP_ROOT_SYSTEM_CLASS;
1754     case JVMTI_HEAP_REFERENCE_MONITOR:      return JVMTI_HEAP_ROOT_MONITOR;
1755     case JVMTI_HEAP_REFERENCE_STACK_LOCAL:  return JVMTI_HEAP_ROOT_STACK_LOCAL;
1756     case JVMTI_HEAP_REFERENCE_JNI_LOCAL:    return JVMTI_HEAP_ROOT_JNI_LOCAL;
1757     case JVMTI_HEAP_REFERENCE_THREAD:       return JVMTI_HEAP_ROOT_THREAD;
1758     case JVMTI_HEAP_REFERENCE_OTHER:        return JVMTI_HEAP_ROOT_OTHER;
1759     default: ShouldNotReachHere();          return JVMTI_HEAP_ROOT_OTHER;
1760   }
1761 }
1762 
1763 // Base class for all heap walk contexts. The base class maintains a flag
1764 // to indicate if the context is valid or not.
1765 class HeapWalkContext {
1766  private:
1767   bool _valid;
1768  public:
1769   HeapWalkContext(bool valid)                   { _valid = valid; }
1770   void invalidate()                             { _valid = false; }
1771   bool is_valid() const                         { return _valid; }
1772 };
1773 
1774 // A basic heap walk context for the deprecated heap walking functions.
1775 // The context for a basic heap walk are the callbacks and fields used by
1776 // the referrer caching scheme.
1777 class BasicHeapWalkContext: public HeapWalkContext {
1778  private:
1779   jvmtiHeapRootCallback _heap_root_callback;
1780   jvmtiStackReferenceCallback _stack_ref_callback;
1781   jvmtiObjectReferenceCallback _object_ref_callback;
1782 
1783   // used for caching
1784   oop _last_referrer;
1785   jlong _last_referrer_tag;
1786 
1787  public:
1788   BasicHeapWalkContext() : HeapWalkContext(false) { }
1789 
1790   BasicHeapWalkContext(jvmtiHeapRootCallback heap_root_callback,
1791                        jvmtiStackReferenceCallback stack_ref_callback,
1792                        jvmtiObjectReferenceCallback object_ref_callback) :
1793     HeapWalkContext(true),
1794     _heap_root_callback(heap_root_callback),
1795     _stack_ref_callback(stack_ref_callback),
1796     _object_ref_callback(object_ref_callback),
1797     _last_referrer(NULL),
1798     _last_referrer_tag(0) {
1799   }
1800 
1801   // accessors
1802   jvmtiHeapRootCallback heap_root_callback() const         { return _heap_root_callback; }
1803   jvmtiStackReferenceCallback stack_ref_callback() const   { return _stack_ref_callback; }
1804   jvmtiObjectReferenceCallback object_ref_callback() const { return _object_ref_callback;  }
1805 
1806   oop last_referrer() const               { return _last_referrer; }
1807   void set_last_referrer(oop referrer)    { _last_referrer = referrer; }
1808   jlong last_referrer_tag() const         { return _last_referrer_tag; }
1809   void set_last_referrer_tag(jlong value) { _last_referrer_tag = value; }
1810 };
1811 
1812 // The advanced heap walk context for the FollowReferences functions.
1813 // The context is the callbacks, and the fields used for filtering.
1814 class AdvancedHeapWalkContext: public HeapWalkContext {
1815  private:
1816   jint _heap_filter;
1817   Klass* _klass_filter;
1818   const jvmtiHeapCallbacks* _heap_callbacks;
1819 
1820  public:
1821   AdvancedHeapWalkContext() : HeapWalkContext(false) { }
1822 
1823   AdvancedHeapWalkContext(jint heap_filter,
1824                            Klass* klass_filter,
1825                            const jvmtiHeapCallbacks* heap_callbacks) :
1826     HeapWalkContext(true),
1827     _heap_filter(heap_filter),
1828     _klass_filter(klass_filter),
1829     _heap_callbacks(heap_callbacks) {
1830   }
1831 
1832   // accessors
1833   jint heap_filter() const         { return _heap_filter; }
1834   Klass* klass_filter() const      { return _klass_filter; }
1835 
1836   const jvmtiHeapReferenceCallback heap_reference_callback() const {
1837     return _heap_callbacks-&gt;heap_reference_callback;
1838   };
1839   const jvmtiPrimitiveFieldCallback primitive_field_callback() const {
1840     return _heap_callbacks-&gt;primitive_field_callback;
1841   }
1842   const jvmtiArrayPrimitiveValueCallback array_primitive_value_callback() const {
1843     return _heap_callbacks-&gt;array_primitive_value_callback;
1844   }
1845   const jvmtiStringPrimitiveValueCallback string_primitive_value_callback() const {
1846     return _heap_callbacks-&gt;string_primitive_value_callback;
1847   }
1848 };
1849 
1850 // The CallbackInvoker is a class with static functions that the heap walk can call
1851 // into to invoke callbacks. It works in one of two modes. The &quot;basic&quot; mode is
1852 // used for the deprecated IterateOverReachableObjects functions. The &quot;advanced&quot;
1853 // mode is for the newer FollowReferences function which supports a lot of
1854 // additional callbacks.
1855 class CallbackInvoker : AllStatic {
1856  private:
1857   // heap walk styles
1858   enum { basic, advanced };
1859   static int _heap_walk_type;
1860   static bool is_basic_heap_walk()           { return _heap_walk_type == basic; }
1861   static bool is_advanced_heap_walk()        { return _heap_walk_type == advanced; }
1862 
1863   // context for basic style heap walk
1864   static BasicHeapWalkContext _basic_context;
1865   static BasicHeapWalkContext* basic_context() {
1866     assert(_basic_context.is_valid(), &quot;invalid&quot;);
1867     return &amp;_basic_context;
1868   }
1869 
1870   // context for advanced style heap walk
1871   static AdvancedHeapWalkContext _advanced_context;
1872   static AdvancedHeapWalkContext* advanced_context() {
1873     assert(_advanced_context.is_valid(), &quot;invalid&quot;);
1874     return &amp;_advanced_context;
1875   }
1876 
1877   // context needed for all heap walks
1878   static JvmtiTagMap* _tag_map;
1879   static const void* _user_data;
1880   static GrowableArray&lt;oop&gt;* _visit_stack;
1881 
1882   // accessors
1883   static JvmtiTagMap* tag_map()                        { return _tag_map; }
1884   static const void* user_data()                       { return _user_data; }
1885   static GrowableArray&lt;oop&gt;* visit_stack()             { return _visit_stack; }
1886 
1887   // if the object hasn&#39;t been visited then push it onto the visit stack
1888   // so that it will be visited later
1889   static inline bool check_for_visit(oop obj) {
1890     if (!ObjectMarker::visited(obj)) visit_stack()-&gt;push(obj);
1891     return true;
1892   }
1893 
1894   // invoke basic style callbacks
1895   static inline bool invoke_basic_heap_root_callback
1896     (jvmtiHeapRootKind root_kind, oop obj);
1897   static inline bool invoke_basic_stack_ref_callback
1898     (jvmtiHeapRootKind root_kind, jlong thread_tag, jint depth, jmethodID method,
1899      int slot, oop obj);
1900   static inline bool invoke_basic_object_reference_callback
1901     (jvmtiObjectReferenceKind ref_kind, oop referrer, oop referree, jint index);
1902 
1903   // invoke advanced style callbacks
1904   static inline bool invoke_advanced_heap_root_callback
1905     (jvmtiHeapReferenceKind ref_kind, oop obj);
1906   static inline bool invoke_advanced_stack_ref_callback
1907     (jvmtiHeapReferenceKind ref_kind, jlong thread_tag, jlong tid, int depth,
1908      jmethodID method, jlocation bci, jint slot, oop obj);
1909   static inline bool invoke_advanced_object_reference_callback
1910     (jvmtiHeapReferenceKind ref_kind, oop referrer, oop referree, jint index);
1911 
1912   // used to report the value of primitive fields
1913   static inline bool report_primitive_field
1914     (jvmtiHeapReferenceKind ref_kind, oop obj, jint index, address addr, char type);
1915 
1916  public:
1917   // initialize for basic mode
1918   static void initialize_for_basic_heap_walk(JvmtiTagMap* tag_map,
1919                                              GrowableArray&lt;oop&gt;* visit_stack,
1920                                              const void* user_data,
1921                                              BasicHeapWalkContext context);
1922 
1923   // initialize for advanced mode
1924   static void initialize_for_advanced_heap_walk(JvmtiTagMap* tag_map,
1925                                                 GrowableArray&lt;oop&gt;* visit_stack,
1926                                                 const void* user_data,
1927                                                 AdvancedHeapWalkContext context);
1928 
1929    // functions to report roots
1930   static inline bool report_simple_root(jvmtiHeapReferenceKind kind, oop o);
1931   static inline bool report_jni_local_root(jlong thread_tag, jlong tid, jint depth,
1932     jmethodID m, oop o);
1933   static inline bool report_stack_ref_root(jlong thread_tag, jlong tid, jint depth,
1934     jmethodID method, jlocation bci, jint slot, oop o);
1935 
1936   // functions to report references
1937   static inline bool report_array_element_reference(oop referrer, oop referree, jint index);
1938   static inline bool report_class_reference(oop referrer, oop referree);
1939   static inline bool report_class_loader_reference(oop referrer, oop referree);
1940   static inline bool report_signers_reference(oop referrer, oop referree);
1941   static inline bool report_protection_domain_reference(oop referrer, oop referree);
1942   static inline bool report_superclass_reference(oop referrer, oop referree);
1943   static inline bool report_interface_reference(oop referrer, oop referree);
1944   static inline bool report_static_field_reference(oop referrer, oop referree, jint slot);
1945   static inline bool report_field_reference(oop referrer, oop referree, jint slot);
1946   static inline bool report_constant_pool_reference(oop referrer, oop referree, jint index);
1947   static inline bool report_primitive_array_values(oop array);
1948   static inline bool report_string_value(oop str);
1949   static inline bool report_primitive_instance_field(oop o, jint index, address value, char type);
1950   static inline bool report_primitive_static_field(oop o, jint index, address value, char type);
1951 };
1952 
1953 // statics
1954 int CallbackInvoker::_heap_walk_type;
1955 BasicHeapWalkContext CallbackInvoker::_basic_context;
1956 AdvancedHeapWalkContext CallbackInvoker::_advanced_context;
1957 JvmtiTagMap* CallbackInvoker::_tag_map;
1958 const void* CallbackInvoker::_user_data;
1959 GrowableArray&lt;oop&gt;* CallbackInvoker::_visit_stack;
1960 
1961 // initialize for basic heap walk (IterateOverReachableObjects et al)
1962 void CallbackInvoker::initialize_for_basic_heap_walk(JvmtiTagMap* tag_map,
1963                                                      GrowableArray&lt;oop&gt;* visit_stack,
1964                                                      const void* user_data,
1965                                                      BasicHeapWalkContext context) {
1966   _tag_map = tag_map;
1967   _visit_stack = visit_stack;
1968   _user_data = user_data;
1969   _basic_context = context;
1970   _advanced_context.invalidate();       // will trigger assertion if used
1971   _heap_walk_type = basic;
1972 }
1973 
1974 // initialize for advanced heap walk (FollowReferences)
1975 void CallbackInvoker::initialize_for_advanced_heap_walk(JvmtiTagMap* tag_map,
1976                                                         GrowableArray&lt;oop&gt;* visit_stack,
1977                                                         const void* user_data,
1978                                                         AdvancedHeapWalkContext context) {
1979   _tag_map = tag_map;
1980   _visit_stack = visit_stack;
1981   _user_data = user_data;
1982   _advanced_context = context;
1983   _basic_context.invalidate();      // will trigger assertion if used
1984   _heap_walk_type = advanced;
1985 }
1986 
1987 
1988 // invoke basic style heap root callback
1989 inline bool CallbackInvoker::invoke_basic_heap_root_callback(jvmtiHeapRootKind root_kind, oop obj) {
1990   // if we heap roots should be reported
1991   jvmtiHeapRootCallback cb = basic_context()-&gt;heap_root_callback();
1992   if (cb == NULL) {
1993     return check_for_visit(obj);
1994   }
1995 
1996   CallbackWrapper wrapper(tag_map(), obj);
1997   jvmtiIterationControl control = (*cb)(root_kind,
1998                                         wrapper.klass_tag(),
1999                                         wrapper.obj_size(),
2000                                         wrapper.obj_tag_p(),
2001                                         (void*)user_data());
2002   // push root to visit stack when following references
2003   if (control == JVMTI_ITERATION_CONTINUE &amp;&amp;
2004       basic_context()-&gt;object_ref_callback() != NULL) {
2005     visit_stack()-&gt;push(obj);
2006   }
2007   return control != JVMTI_ITERATION_ABORT;
2008 }
2009 
2010 // invoke basic style stack ref callback
2011 inline bool CallbackInvoker::invoke_basic_stack_ref_callback(jvmtiHeapRootKind root_kind,
2012                                                              jlong thread_tag,
2013                                                              jint depth,
2014                                                              jmethodID method,
2015                                                              int slot,
2016                                                              oop obj) {
2017   // if we stack refs should be reported
2018   jvmtiStackReferenceCallback cb = basic_context()-&gt;stack_ref_callback();
2019   if (cb == NULL) {
2020     return check_for_visit(obj);
2021   }
2022 
2023   CallbackWrapper wrapper(tag_map(), obj);
2024   jvmtiIterationControl control = (*cb)(root_kind,
2025                                         wrapper.klass_tag(),
2026                                         wrapper.obj_size(),
2027                                         wrapper.obj_tag_p(),
2028                                         thread_tag,
2029                                         depth,
2030                                         method,
2031                                         slot,
2032                                         (void*)user_data());
2033   // push root to visit stack when following references
2034   if (control == JVMTI_ITERATION_CONTINUE &amp;&amp;
2035       basic_context()-&gt;object_ref_callback() != NULL) {
2036     visit_stack()-&gt;push(obj);
2037   }
2038   return control != JVMTI_ITERATION_ABORT;
2039 }
2040 
2041 // invoke basic style object reference callback
2042 inline bool CallbackInvoker::invoke_basic_object_reference_callback(jvmtiObjectReferenceKind ref_kind,
2043                                                                     oop referrer,
2044                                                                     oop referree,
2045                                                                     jint index) {
2046 
2047   BasicHeapWalkContext* context = basic_context();
2048 
2049   // callback requires the referrer&#39;s tag. If it&#39;s the same referrer
2050   // as the last call then we use the cached value.
2051   jlong referrer_tag;
2052   if (referrer == context-&gt;last_referrer()) {
2053     referrer_tag = context-&gt;last_referrer_tag();
2054   } else {
2055     referrer_tag = tag_for(tag_map(), referrer);
2056   }
2057 
2058   // do the callback
2059   CallbackWrapper wrapper(tag_map(), referree);
2060   jvmtiObjectReferenceCallback cb = context-&gt;object_ref_callback();
2061   jvmtiIterationControl control = (*cb)(ref_kind,
2062                                         wrapper.klass_tag(),
2063                                         wrapper.obj_size(),
2064                                         wrapper.obj_tag_p(),
2065                                         referrer_tag,
2066                                         index,
2067                                         (void*)user_data());
2068 
2069   // record referrer and referrer tag. For self-references record the
2070   // tag value from the callback as this might differ from referrer_tag.
2071   context-&gt;set_last_referrer(referrer);
2072   if (referrer == referree) {
2073     context-&gt;set_last_referrer_tag(*wrapper.obj_tag_p());
2074   } else {
2075     context-&gt;set_last_referrer_tag(referrer_tag);
2076   }
2077 
2078   if (control == JVMTI_ITERATION_CONTINUE) {
2079     return check_for_visit(referree);
2080   } else {
2081     return control != JVMTI_ITERATION_ABORT;
2082   }
2083 }
2084 
2085 // invoke advanced style heap root callback
2086 inline bool CallbackInvoker::invoke_advanced_heap_root_callback(jvmtiHeapReferenceKind ref_kind,
2087                                                                 oop obj) {
2088   AdvancedHeapWalkContext* context = advanced_context();
2089 
2090   // check that callback is provided
2091   jvmtiHeapReferenceCallback cb = context-&gt;heap_reference_callback();
2092   if (cb == NULL) {
2093     return check_for_visit(obj);
2094   }
2095 
2096   // apply class filter
2097   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2098     return check_for_visit(obj);
2099   }
2100 
2101   // setup the callback wrapper
2102   CallbackWrapper wrapper(tag_map(), obj);
2103 
2104   // apply tag filter
2105   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2106                                  wrapper.klass_tag(),
2107                                  context-&gt;heap_filter())) {
2108     return check_for_visit(obj);
2109   }
2110 
2111   // for arrays we need the length, otherwise -1
2112   jint len = (jint)(obj-&gt;is_array() ? arrayOop(obj)-&gt;length() : -1);
2113 
2114   // invoke the callback
2115   jint res  = (*cb)(ref_kind,
2116                     NULL, // referrer info
2117                     wrapper.klass_tag(),
2118                     0,    // referrer_class_tag is 0 for heap root
2119                     wrapper.obj_size(),
2120                     wrapper.obj_tag_p(),
2121                     NULL, // referrer_tag_p
2122                     len,
2123                     (void*)user_data());
2124   if (res &amp; JVMTI_VISIT_ABORT) {
2125     return false;// referrer class tag
2126   }
2127   if (res &amp; JVMTI_VISIT_OBJECTS) {
2128     check_for_visit(obj);
2129   }
2130   return true;
2131 }
2132 
2133 // report a reference from a thread stack to an object
2134 inline bool CallbackInvoker::invoke_advanced_stack_ref_callback(jvmtiHeapReferenceKind ref_kind,
2135                                                                 jlong thread_tag,
2136                                                                 jlong tid,
2137                                                                 int depth,
2138                                                                 jmethodID method,
2139                                                                 jlocation bci,
2140                                                                 jint slot,
2141                                                                 oop obj) {
2142   AdvancedHeapWalkContext* context = advanced_context();
2143 
2144   // check that callback is provider
2145   jvmtiHeapReferenceCallback cb = context-&gt;heap_reference_callback();
2146   if (cb == NULL) {
2147     return check_for_visit(obj);
2148   }
2149 
2150   // apply class filter
2151   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2152     return check_for_visit(obj);
2153   }
2154 
2155   // setup the callback wrapper
2156   CallbackWrapper wrapper(tag_map(), obj);
2157 
2158   // apply tag filter
2159   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2160                                  wrapper.klass_tag(),
2161                                  context-&gt;heap_filter())) {
2162     return check_for_visit(obj);
2163   }
2164 
2165   // setup the referrer info
2166   jvmtiHeapReferenceInfo reference_info;
2167   reference_info.stack_local.thread_tag = thread_tag;
2168   reference_info.stack_local.thread_id = tid;
2169   reference_info.stack_local.depth = depth;
2170   reference_info.stack_local.method = method;
2171   reference_info.stack_local.location = bci;
2172   reference_info.stack_local.slot = slot;
2173 
2174   // for arrays we need the length, otherwise -1
2175   jint len = (jint)(obj-&gt;is_array() ? arrayOop(obj)-&gt;length() : -1);
2176 
2177   // call into the agent
2178   int res = (*cb)(ref_kind,
2179                   &amp;reference_info,
2180                   wrapper.klass_tag(),
2181                   0,    // referrer_class_tag is 0 for heap root (stack)
2182                   wrapper.obj_size(),
2183                   wrapper.obj_tag_p(),
2184                   NULL, // referrer_tag is 0 for root
2185                   len,
2186                   (void*)user_data());
2187 
2188   if (res &amp; JVMTI_VISIT_ABORT) {
2189     return false;
2190   }
2191   if (res &amp; JVMTI_VISIT_OBJECTS) {
2192     check_for_visit(obj);
2193   }
2194   return true;
2195 }
2196 
2197 // This mask is used to pass reference_info to a jvmtiHeapReferenceCallback
2198 // only for ref_kinds defined by the JVM TI spec. Otherwise, NULL is passed.
2199 #define REF_INFO_MASK  ((1 &lt;&lt; JVMTI_HEAP_REFERENCE_FIELD)         \
2200                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_STATIC_FIELD)  \
2201                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT) \
2202                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_CONSTANT_POOL) \
2203                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_STACK_LOCAL)   \
2204                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_JNI_LOCAL))
2205 
2206 // invoke the object reference callback to report a reference
2207 inline bool CallbackInvoker::invoke_advanced_object_reference_callback(jvmtiHeapReferenceKind ref_kind,
2208                                                                        oop referrer,
2209                                                                        oop obj,
2210                                                                        jint index)
2211 {
2212   // field index is only valid field in reference_info
2213   static jvmtiHeapReferenceInfo reference_info = { 0 };
2214 
2215   AdvancedHeapWalkContext* context = advanced_context();
2216 
2217   // check that callback is provider
2218   jvmtiHeapReferenceCallback cb = context-&gt;heap_reference_callback();
2219   if (cb == NULL) {
2220     return check_for_visit(obj);
2221   }
2222 
2223   // apply class filter
2224   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2225     return check_for_visit(obj);
2226   }
2227 
2228   // setup the callback wrapper
2229   TwoOopCallbackWrapper wrapper(tag_map(), referrer, obj);
2230 
2231   // apply tag filter
2232   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2233                                  wrapper.klass_tag(),
2234                                  context-&gt;heap_filter())) {
2235     return check_for_visit(obj);
2236   }
2237 
2238   // field index is only valid field in reference_info
2239   reference_info.field.index = index;
2240 
2241   // for arrays we need the length, otherwise -1
2242   jint len = (jint)(obj-&gt;is_array() ? arrayOop(obj)-&gt;length() : -1);
2243 
2244   // invoke the callback
2245   int res = (*cb)(ref_kind,
2246                   (REF_INFO_MASK &amp; (1 &lt;&lt; ref_kind)) ? &amp;reference_info : NULL,
2247                   wrapper.klass_tag(),
2248                   wrapper.referrer_klass_tag(),
2249                   wrapper.obj_size(),
2250                   wrapper.obj_tag_p(),
2251                   wrapper.referrer_tag_p(),
2252                   len,
2253                   (void*)user_data());
2254 
2255   if (res &amp; JVMTI_VISIT_ABORT) {
2256     return false;
2257   }
2258   if (res &amp; JVMTI_VISIT_OBJECTS) {
2259     check_for_visit(obj);
2260   }
2261   return true;
2262 }
2263 
2264 // report a &quot;simple root&quot;
2265 inline bool CallbackInvoker::report_simple_root(jvmtiHeapReferenceKind kind, oop obj) {
2266   assert(kind != JVMTI_HEAP_REFERENCE_STACK_LOCAL &amp;&amp;
2267          kind != JVMTI_HEAP_REFERENCE_JNI_LOCAL, &quot;not a simple root&quot;);
2268 
2269   if (is_basic_heap_walk()) {
2270     // map to old style root kind
2271     jvmtiHeapRootKind root_kind = toJvmtiHeapRootKind(kind);
2272     return invoke_basic_heap_root_callback(root_kind, obj);
2273   } else {
2274     assert(is_advanced_heap_walk(), &quot;wrong heap walk type&quot;);
2275     return invoke_advanced_heap_root_callback(kind, obj);
2276   }
2277 }
2278 
2279 
2280 // invoke the primitive array values
2281 inline bool CallbackInvoker::report_primitive_array_values(oop obj) {
2282   assert(obj-&gt;is_typeArray(), &quot;not a primitive array&quot;);
2283 
2284   AdvancedHeapWalkContext* context = advanced_context();
2285   assert(context-&gt;array_primitive_value_callback() != NULL, &quot;no callback&quot;);
2286 
2287   // apply class filter
2288   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2289     return true;
2290   }
2291 
2292   CallbackWrapper wrapper(tag_map(), obj);
2293 
2294   // apply tag filter
2295   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2296                                  wrapper.klass_tag(),
2297                                  context-&gt;heap_filter())) {
2298     return true;
2299   }
2300 
2301   // invoke the callback
2302   int res = invoke_array_primitive_value_callback(context-&gt;array_primitive_value_callback(),
2303                                                   &amp;wrapper,
2304                                                   obj,
2305                                                   (void*)user_data());
2306   return (!(res &amp; JVMTI_VISIT_ABORT));
2307 }
2308 
2309 // invoke the string value callback
2310 inline bool CallbackInvoker::report_string_value(oop str) {
2311   assert(str-&gt;klass() == SystemDictionary::String_klass(), &quot;not a string&quot;);
2312 
2313   AdvancedHeapWalkContext* context = advanced_context();
2314   assert(context-&gt;string_primitive_value_callback() != NULL, &quot;no callback&quot;);
2315 
2316   // apply class filter
2317   if (is_filtered_by_klass_filter(str, context-&gt;klass_filter())) {
2318     return true;
2319   }
2320 
2321   CallbackWrapper wrapper(tag_map(), str);
2322 
2323   // apply tag filter
2324   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2325                                  wrapper.klass_tag(),
2326                                  context-&gt;heap_filter())) {
2327     return true;
2328   }
2329 
2330   // invoke the callback
2331   int res = invoke_string_value_callback(context-&gt;string_primitive_value_callback(),
2332                                          &amp;wrapper,
2333                                          str,
2334                                          (void*)user_data());
2335   return (!(res &amp; JVMTI_VISIT_ABORT));
2336 }
2337 
2338 // invoke the primitive field callback
2339 inline bool CallbackInvoker::report_primitive_field(jvmtiHeapReferenceKind ref_kind,
2340                                                     oop obj,
2341                                                     jint index,
2342                                                     address addr,
2343                                                     char type)
2344 {
2345   // for primitive fields only the index will be set
2346   static jvmtiHeapReferenceInfo reference_info = { 0 };
2347 
2348   AdvancedHeapWalkContext* context = advanced_context();
2349   assert(context-&gt;primitive_field_callback() != NULL, &quot;no callback&quot;);
2350 
2351   // apply class filter
2352   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2353     return true;
2354   }
2355 
2356   CallbackWrapper wrapper(tag_map(), obj);
2357 
2358   // apply tag filter
2359   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2360                                  wrapper.klass_tag(),
2361                                  context-&gt;heap_filter())) {
2362     return true;
2363   }
2364 
2365   // the field index in the referrer
2366   reference_info.field.index = index;
2367 
2368   // map the type
2369   jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
2370 
2371   // setup the jvalue
2372   jvalue value;
2373   copy_to_jvalue(&amp;value, addr, value_type);
2374 
2375   jvmtiPrimitiveFieldCallback cb = context-&gt;primitive_field_callback();
2376   int res = (*cb)(ref_kind,
2377                   &amp;reference_info,
2378                   wrapper.klass_tag(),
2379                   wrapper.obj_tag_p(),
2380                   value,
2381                   value_type,
2382                   (void*)user_data());
2383   return (!(res &amp; JVMTI_VISIT_ABORT));
2384 }
2385 
2386 
2387 // instance field
2388 inline bool CallbackInvoker::report_primitive_instance_field(oop obj,
2389                                                              jint index,
2390                                                              address value,
2391                                                              char type) {
2392   return report_primitive_field(JVMTI_HEAP_REFERENCE_FIELD,
2393                                 obj,
2394                                 index,
2395                                 value,
2396                                 type);
2397 }
2398 
2399 // static field
2400 inline bool CallbackInvoker::report_primitive_static_field(oop obj,
2401                                                            jint index,
2402                                                            address value,
2403                                                            char type) {
2404   return report_primitive_field(JVMTI_HEAP_REFERENCE_STATIC_FIELD,
2405                                 obj,
2406                                 index,
2407                                 value,
2408                                 type);
2409 }
2410 
2411 // report a JNI local (root object) to the profiler
2412 inline bool CallbackInvoker::report_jni_local_root(jlong thread_tag, jlong tid, jint depth, jmethodID m, oop obj) {
2413   if (is_basic_heap_walk()) {
2414     return invoke_basic_stack_ref_callback(JVMTI_HEAP_ROOT_JNI_LOCAL,
2415                                            thread_tag,
2416                                            depth,
2417                                            m,
2418                                            -1,
2419                                            obj);
2420   } else {
2421     return invoke_advanced_stack_ref_callback(JVMTI_HEAP_REFERENCE_JNI_LOCAL,
2422                                               thread_tag, tid,
2423                                               depth,
2424                                               m,
2425                                               (jlocation)-1,
2426                                               -1,
2427                                               obj);
2428   }
2429 }
2430 
2431 
2432 // report a local (stack reference, root object)
2433 inline bool CallbackInvoker::report_stack_ref_root(jlong thread_tag,
2434                                                    jlong tid,
2435                                                    jint depth,
2436                                                    jmethodID method,
2437                                                    jlocation bci,
2438                                                    jint slot,
2439                                                    oop obj) {
2440   if (is_basic_heap_walk()) {
2441     return invoke_basic_stack_ref_callback(JVMTI_HEAP_ROOT_STACK_LOCAL,
2442                                            thread_tag,
2443                                            depth,
2444                                            method,
2445                                            slot,
2446                                            obj);
2447   } else {
2448     return invoke_advanced_stack_ref_callback(JVMTI_HEAP_REFERENCE_STACK_LOCAL,
2449                                               thread_tag,
2450                                               tid,
2451                                               depth,
2452                                               method,
2453                                               bci,
2454                                               slot,
2455                                               obj);
2456   }
2457 }
2458 
2459 // report an object referencing a class.
2460 inline bool CallbackInvoker::report_class_reference(oop referrer, oop referree) {
2461   if (is_basic_heap_walk()) {
2462     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CLASS, referrer, referree, -1);
2463   } else {
2464     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_CLASS, referrer, referree, -1);
2465   }
2466 }
2467 
2468 // report a class referencing its class loader.
2469 inline bool CallbackInvoker::report_class_loader_reference(oop referrer, oop referree) {
2470   if (is_basic_heap_walk()) {
2471     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CLASS_LOADER, referrer, referree, -1);
2472   } else {
2473     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_CLASS_LOADER, referrer, referree, -1);
2474   }
2475 }
2476 
2477 // report a class referencing its signers.
2478 inline bool CallbackInvoker::report_signers_reference(oop referrer, oop referree) {
2479   if (is_basic_heap_walk()) {
2480     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_SIGNERS, referrer, referree, -1);
2481   } else {
2482     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_SIGNERS, referrer, referree, -1);
2483   }
2484 }
2485 
2486 // report a class referencing its protection domain..
2487 inline bool CallbackInvoker::report_protection_domain_reference(oop referrer, oop referree) {
2488   if (is_basic_heap_walk()) {
2489     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_PROTECTION_DOMAIN, referrer, referree, -1);
2490   } else {
2491     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN, referrer, referree, -1);
2492   }
2493 }
2494 
2495 // report a class referencing its superclass.
2496 inline bool CallbackInvoker::report_superclass_reference(oop referrer, oop referree) {
2497   if (is_basic_heap_walk()) {
2498     // Send this to be consistent with past implementation
2499     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CLASS, referrer, referree, -1);
2500   } else {
2501     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_SUPERCLASS, referrer, referree, -1);
2502   }
2503 }
2504 
2505 // report a class referencing one of its interfaces.
2506 inline bool CallbackInvoker::report_interface_reference(oop referrer, oop referree) {
2507   if (is_basic_heap_walk()) {
2508     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_INTERFACE, referrer, referree, -1);
2509   } else {
2510     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_INTERFACE, referrer, referree, -1);
2511   }
2512 }
2513 
2514 // report a class referencing one of its static fields.
2515 inline bool CallbackInvoker::report_static_field_reference(oop referrer, oop referree, jint slot) {
2516   if (is_basic_heap_walk()) {
2517     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_STATIC_FIELD, referrer, referree, slot);
2518   } else {
2519     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_STATIC_FIELD, referrer, referree, slot);
2520   }
2521 }
2522 
2523 // report an array referencing an element object
2524 inline bool CallbackInvoker::report_array_element_reference(oop referrer, oop referree, jint index) {
2525   if (is_basic_heap_walk()) {
2526     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_ARRAY_ELEMENT, referrer, referree, index);
2527   } else {
2528     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT, referrer, referree, index);
2529   }
2530 }
2531 
2532 // report an object referencing an instance field object
2533 inline bool CallbackInvoker::report_field_reference(oop referrer, oop referree, jint slot) {
2534   if (is_basic_heap_walk()) {
2535     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_FIELD, referrer, referree, slot);
2536   } else {
2537     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_FIELD, referrer, referree, slot);
2538   }
2539 }
2540 
2541 // report an array referencing an element object
2542 inline bool CallbackInvoker::report_constant_pool_reference(oop referrer, oop referree, jint index) {
2543   if (is_basic_heap_walk()) {
2544     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CONSTANT_POOL, referrer, referree, index);
2545   } else {
2546     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_CONSTANT_POOL, referrer, referree, index);
2547   }
2548 }
2549 
2550 // A supporting closure used to process simple roots
2551 class SimpleRootsClosure : public OopClosure {
2552  private:
2553   jvmtiHeapReferenceKind _kind;
2554   bool _continue;
2555 
2556   jvmtiHeapReferenceKind root_kind()    { return _kind; }
2557 
2558  public:
2559   void set_kind(jvmtiHeapReferenceKind kind) {
2560     _kind = kind;
2561     _continue = true;
2562   }
2563 
2564   inline bool stopped() {
2565     return !_continue;
2566   }
2567 
2568   void do_oop(oop* obj_p) {
2569     // iteration has terminated
2570     if (stopped()) {
2571       return;
2572     }
2573 
2574     oop o = NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(obj_p);
2575     // ignore null
2576     if (o == NULL) {
2577       return;
2578     }
2579 
2580     assert(Universe::heap()-&gt;is_in(o), &quot;should be impossible&quot;);
2581 
2582     jvmtiHeapReferenceKind kind = root_kind();
2583 
2584     // invoke the callback
2585     _continue = CallbackInvoker::report_simple_root(kind, o);
2586 
2587   }
2588   virtual void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
2589 };
2590 
2591 // A supporting closure used to process JNI locals
2592 class JNILocalRootsClosure : public OopClosure {
2593  private:
2594   jlong _thread_tag;
2595   jlong _tid;
2596   jint _depth;
2597   jmethodID _method;
2598   bool _continue;
2599  public:
2600   void set_context(jlong thread_tag, jlong tid, jint depth, jmethodID method) {
2601     _thread_tag = thread_tag;
2602     _tid = tid;
2603     _depth = depth;
2604     _method = method;
2605     _continue = true;
2606   }
2607 
2608   inline bool stopped() {
2609     return !_continue;
2610   }
2611 
2612   void do_oop(oop* obj_p) {
2613     // iteration has terminated
2614     if (stopped()) {
2615       return;
2616     }
2617 
2618     oop o = *obj_p;
2619     // ignore null
2620     if (o == NULL) {
2621       return;
2622     }
2623 
2624     // invoke the callback
2625     _continue = CallbackInvoker::report_jni_local_root(_thread_tag, _tid, _depth, _method, o);
2626   }
2627   virtual void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
2628 };
2629 
2630 
2631 // A VM operation to iterate over objects that are reachable from
2632 // a set of roots or an initial object.
2633 //
2634 // For VM_HeapWalkOperation the set of roots used is :-
2635 //
2636 // - All JNI global references
2637 // - All inflated monitors
2638 // - All classes loaded by the boot class loader (or all classes
2639 //     in the event that class unloading is disabled)
2640 // - All java threads
2641 // - For each java thread then all locals and JNI local references
2642 //      on the thread&#39;s execution stack
2643 // - All visible/explainable objects from Universes::oops_do
2644 //
2645 class VM_HeapWalkOperation: public VM_Operation {
2646  private:
2647   enum {
2648     initial_visit_stack_size = 4000
2649   };
2650 
2651   bool _is_advanced_heap_walk;                      // indicates FollowReferences
2652   JvmtiTagMap* _tag_map;
2653   Handle _initial_object;
2654   GrowableArray&lt;oop&gt;* _visit_stack;                 // the visit stack
2655 
2656   bool _collecting_heap_roots;                      // are we collecting roots
2657   bool _following_object_refs;                      // are we following object references
2658 
2659   bool _reporting_primitive_fields;                 // optional reporting
2660   bool _reporting_primitive_array_values;
2661   bool _reporting_string_values;
2662 
2663   GrowableArray&lt;oop&gt;* create_visit_stack() {
2664     return new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;oop&gt;(initial_visit_stack_size, mtServiceability);
2665   }
2666 
2667   // accessors
2668   bool is_advanced_heap_walk() const               { return _is_advanced_heap_walk; }
2669   JvmtiTagMap* tag_map() const                     { return _tag_map; }
2670   Handle initial_object() const                    { return _initial_object; }
2671 
2672   bool is_following_references() const             { return _following_object_refs; }
2673 
2674   bool is_reporting_primitive_fields()  const      { return _reporting_primitive_fields; }
2675   bool is_reporting_primitive_array_values() const { return _reporting_primitive_array_values; }
2676   bool is_reporting_string_values() const          { return _reporting_string_values; }
2677 
2678   GrowableArray&lt;oop&gt;* visit_stack() const          { return _visit_stack; }
2679 
2680   // iterate over the various object types
2681   inline bool iterate_over_array(oop o);
2682   inline bool iterate_over_type_array(oop o);
2683   inline bool iterate_over_class(oop o);
2684   inline bool iterate_over_object(oop o);
2685 
2686   // root collection
2687   inline bool collect_simple_roots();
2688   inline bool collect_stack_roots();
2689   inline bool collect_stack_roots(JavaThread* java_thread, JNILocalRootsClosure* blk);
2690 
2691   // visit an object
2692   inline bool visit(oop o);
2693 
2694  public:
2695   VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2696                        Handle initial_object,
2697                        BasicHeapWalkContext callbacks,
2698                        const void* user_data);
2699 
2700   VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2701                        Handle initial_object,
2702                        AdvancedHeapWalkContext callbacks,
2703                        const void* user_data);
2704 
2705   ~VM_HeapWalkOperation();
2706 
2707   VMOp_Type type() const { return VMOp_HeapWalkOperation; }
2708   void doit();
2709 };
2710 
2711 
2712 VM_HeapWalkOperation::VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2713                                            Handle initial_object,
2714                                            BasicHeapWalkContext callbacks,
2715                                            const void* user_data) {
2716   _is_advanced_heap_walk = false;
2717   _tag_map = tag_map;
2718   _initial_object = initial_object;
2719   _following_object_refs = (callbacks.object_ref_callback() != NULL);
2720   _reporting_primitive_fields = false;
2721   _reporting_primitive_array_values = false;
2722   _reporting_string_values = false;
2723   _visit_stack = create_visit_stack();
2724 
2725 
2726   CallbackInvoker::initialize_for_basic_heap_walk(tag_map, _visit_stack, user_data, callbacks);
2727 }
2728 
2729 VM_HeapWalkOperation::VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2730                                            Handle initial_object,
2731                                            AdvancedHeapWalkContext callbacks,
2732                                            const void* user_data) {
2733   _is_advanced_heap_walk = true;
2734   _tag_map = tag_map;
2735   _initial_object = initial_object;
2736   _following_object_refs = true;
2737   _reporting_primitive_fields = (callbacks.primitive_field_callback() != NULL);;
2738   _reporting_primitive_array_values = (callbacks.array_primitive_value_callback() != NULL);;
2739   _reporting_string_values = (callbacks.string_primitive_value_callback() != NULL);;
2740   _visit_stack = create_visit_stack();
2741 
2742   CallbackInvoker::initialize_for_advanced_heap_walk(tag_map, _visit_stack, user_data, callbacks);
2743 }
2744 
2745 VM_HeapWalkOperation::~VM_HeapWalkOperation() {
2746   if (_following_object_refs) {
2747     assert(_visit_stack != NULL, &quot;checking&quot;);
2748     delete _visit_stack;
2749     _visit_stack = NULL;
2750   }
2751 }
2752 
2753 // an array references its class and has a reference to
2754 // each element in the array
2755 inline bool VM_HeapWalkOperation::iterate_over_array(oop o) {
2756   objArrayOop array = objArrayOop(o);
2757 
2758   // array reference to its class
2759   oop mirror = ObjArrayKlass::cast(array-&gt;klass())-&gt;java_mirror();
2760   if (!CallbackInvoker::report_class_reference(o, mirror)) {
2761     return false;
2762   }
2763 
2764   // iterate over the array and report each reference to a
2765   // non-null element
2766   for (int index=0; index&lt;array-&gt;length(); index++) {
2767     oop elem = array-&gt;obj_at(index);
2768     if (elem == NULL) {
2769       continue;
2770     }
2771 
2772     // report the array reference o[index] = elem
2773     if (!CallbackInvoker::report_array_element_reference(o, elem, index)) {
2774       return false;
2775     }
2776   }
2777   return true;
2778 }
2779 
2780 // a type array references its class
2781 inline bool VM_HeapWalkOperation::iterate_over_type_array(oop o) {
2782   Klass* k = o-&gt;klass();
2783   oop mirror = k-&gt;java_mirror();
2784   if (!CallbackInvoker::report_class_reference(o, mirror)) {
2785     return false;
2786   }
2787 
2788   // report the array contents if required
2789   if (is_reporting_primitive_array_values()) {
2790     if (!CallbackInvoker::report_primitive_array_values(o)) {
2791       return false;
2792     }
2793   }
2794   return true;
2795 }
2796 
2797 #ifdef ASSERT
2798 // verify that a static oop field is in range
2799 static inline bool verify_static_oop(InstanceKlass* ik,
2800                                      oop mirror, int offset) {
2801   address obj_p = cast_from_oop&lt;address&gt;(mirror) + offset;
2802   address start = (address)InstanceMirrorKlass::start_of_static_fields(mirror);
2803   address end = start + (java_lang_Class::static_oop_field_count(mirror) * heapOopSize);
2804   assert(end &gt;= start, &quot;sanity check&quot;);
2805 
2806   if (obj_p &gt;= start &amp;&amp; obj_p &lt; end) {
2807     return true;
2808   } else {
2809     return false;
2810   }
2811 }
2812 #endif // #ifdef ASSERT
2813 
2814 // a class references its super class, interfaces, class loader, ...
2815 // and finally its static fields
2816 inline bool VM_HeapWalkOperation::iterate_over_class(oop java_class) {
2817   int i;
2818   Klass* klass = java_lang_Class::as_Klass(java_class);
2819 
2820   if (klass-&gt;is_instance_klass()) {
2821     InstanceKlass* ik = InstanceKlass::cast(klass);
2822 
2823     // Ignore the class if it hasn&#39;t been initialized yet
2824     if (!ik-&gt;is_linked()) {
2825       return true;
2826     }
2827 
2828     // get the java mirror
2829     oop mirror = klass-&gt;java_mirror();
2830 
2831     // super (only if something more interesting than java.lang.Object)
2832     InstanceKlass* java_super = ik-&gt;java_super();
2833     if (java_super != NULL &amp;&amp; java_super != SystemDictionary::Object_klass()) {
2834       oop super = java_super-&gt;java_mirror();
2835       if (!CallbackInvoker::report_superclass_reference(mirror, super)) {
2836         return false;
2837       }
2838     }
2839 
2840     // class loader
2841     oop cl = ik-&gt;class_loader();
2842     if (cl != NULL) {
2843       if (!CallbackInvoker::report_class_loader_reference(mirror, cl)) {
2844         return false;
2845       }
2846     }
2847 
2848     // protection domain
2849     oop pd = ik-&gt;protection_domain();
2850     if (pd != NULL) {
2851       if (!CallbackInvoker::report_protection_domain_reference(mirror, pd)) {
2852         return false;
2853       }
2854     }
2855 
2856     // signers
2857     oop signers = ik-&gt;signers();
2858     if (signers != NULL) {
2859       if (!CallbackInvoker::report_signers_reference(mirror, signers)) {
2860         return false;
2861       }
2862     }
2863 
2864     // references from the constant pool
2865     {
2866       ConstantPool* pool = ik-&gt;constants();
2867       for (int i = 1; i &lt; pool-&gt;length(); i++) {
2868         constantTag tag = pool-&gt;tag_at(i).value();
2869         if (tag.is_string() || tag.is_klass() || tag.is_unresolved_klass()) {
2870           oop entry;
2871           if (tag.is_string()) {
2872             entry = pool-&gt;resolved_string_at(i);
2873             // If the entry is non-null it is resolved.
2874             if (entry == NULL) {
2875               continue;
2876             }
2877           } else if (tag.is_klass()) {
2878             entry = pool-&gt;resolved_klass_at(i)-&gt;java_mirror();
2879           } else {
2880             // Code generated by JIT and AOT compilers might not resolve constant
2881             // pool entries.  Treat them as resolved if they are loaded.
2882             assert(tag.is_unresolved_klass(), &quot;must be&quot;);
2883             constantPoolHandle cp(Thread::current(), pool);
2884             Klass* klass = ConstantPool::klass_at_if_loaded(cp, i);
2885             if (klass == NULL) {
2886               continue;
2887             }
2888             entry = klass-&gt;java_mirror();
2889           }
2890           if (!CallbackInvoker::report_constant_pool_reference(mirror, entry, (jint)i)) {
2891             return false;
2892           }
2893         }
2894       }
2895     }
2896 
2897     // interfaces
2898     // (These will already have been reported as references from the constant pool
2899     //  but are specified by IterateOverReachableObjects and must be reported).
2900     Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
2901     for (i = 0; i &lt; interfaces-&gt;length(); i++) {
2902       oop interf = interfaces-&gt;at(i)-&gt;java_mirror();
2903       if (interf == NULL) {
2904         continue;
2905       }
2906       if (!CallbackInvoker::report_interface_reference(mirror, interf)) {
2907         return false;
2908       }
2909     }
2910 
2911     // iterate over the static fields
2912 
2913     ClassFieldMap* field_map = ClassFieldMap::create_map_of_static_fields(klass);
2914     for (i=0; i&lt;field_map-&gt;field_count(); i++) {
2915       ClassFieldDescriptor* field = field_map-&gt;field_at(i);
2916       char type = field-&gt;field_type();
2917       if (!is_primitive_field_type(type)) {
2918         oop fld_o = mirror-&gt;obj_field(field-&gt;field_offset());
2919         assert(verify_static_oop(ik, mirror, field-&gt;field_offset()), &quot;sanity check&quot;);
2920         if (fld_o != NULL) {
2921           int slot = field-&gt;field_index();
2922           if (!CallbackInvoker::report_static_field_reference(mirror, fld_o, slot)) {
2923             delete field_map;
2924             return false;
2925           }
2926         }
2927       } else {
2928          if (is_reporting_primitive_fields()) {
2929            address addr = cast_from_oop&lt;address&gt;(mirror) + field-&gt;field_offset();
2930            int slot = field-&gt;field_index();
2931            if (!CallbackInvoker::report_primitive_static_field(mirror, slot, addr, type)) {
2932              delete field_map;
2933              return false;
2934           }
2935         }
2936       }
2937     }
2938     delete field_map;
2939 
2940     return true;
2941   }
2942 
2943   return true;
2944 }
2945 
2946 // an object references a class and its instance fields
2947 // (static fields are ignored here as we report these as
2948 // references from the class).
2949 inline bool VM_HeapWalkOperation::iterate_over_object(oop o) {
2950   // reference to the class
2951   if (!CallbackInvoker::report_class_reference(o, o-&gt;klass()-&gt;java_mirror())) {
2952     return false;
2953   }
2954 
2955   // iterate over instance fields
2956   ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o);
2957   for (int i=0; i&lt;field_map-&gt;field_count(); i++) {
2958     ClassFieldDescriptor* field = field_map-&gt;field_at(i);
2959     char type = field-&gt;field_type();
2960     if (!is_primitive_field_type(type)) {
2961       oop fld_o = o-&gt;obj_field_access&lt;AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF&gt;(field-&gt;field_offset());
2962       // ignore any objects that aren&#39;t visible to profiler
2963       if (fld_o != NULL) {
2964         assert(Universe::heap()-&gt;is_in(fld_o), &quot;unsafe code should not &quot;
2965                &quot;have references to Klass* anymore&quot;);
2966         int slot = field-&gt;field_index();
2967         if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {
2968           return false;
2969         }
2970       }
2971     } else {
2972       if (is_reporting_primitive_fields()) {
2973         // primitive instance field
2974         address addr = cast_from_oop&lt;address&gt;(o) + field-&gt;field_offset();
2975         int slot = field-&gt;field_index();
2976         if (!CallbackInvoker::report_primitive_instance_field(o, slot, addr, type)) {
2977           return false;
2978         }
2979       }
2980     }
2981   }
2982 
2983   // if the object is a java.lang.String
2984   if (is_reporting_string_values() &amp;&amp;
2985       o-&gt;klass() == SystemDictionary::String_klass()) {
2986     if (!CallbackInvoker::report_string_value(o)) {
2987       return false;
2988     }
2989   }
2990   return true;
2991 }
2992 
2993 
2994 // Collects all simple (non-stack) roots except for threads;
2995 // threads are handled in collect_stack_roots() as an optimization.
2996 // if there&#39;s a heap root callback provided then the callback is
2997 // invoked for each simple root.
2998 // if an object reference callback is provided then all simple
2999 // roots are pushed onto the marking stack so that they can be
3000 // processed later
3001 //
3002 inline bool VM_HeapWalkOperation::collect_simple_roots() {
3003   SimpleRootsClosure blk;
3004 
3005   // JNI globals
3006   blk.set_kind(JVMTI_HEAP_REFERENCE_JNI_GLOBAL);
3007   JNIHandles::oops_do(&amp;blk);
3008   if (blk.stopped()) {
3009     return false;
3010   }
3011 
3012   // Preloaded classes and loader from the system dictionary
3013   blk.set_kind(JVMTI_HEAP_REFERENCE_SYSTEM_CLASS);
3014   CLDToOopClosure cld_closure(&amp;blk, false);
3015   ClassLoaderDataGraph::always_strong_cld_do(&amp;cld_closure);
3016   if (blk.stopped()) {
3017     return false;
3018   }
3019 
3020   // Inflated monitors
3021   blk.set_kind(JVMTI_HEAP_REFERENCE_MONITOR);
3022   ObjectSynchronizer::oops_do(&amp;blk);
3023   if (blk.stopped()) {
3024     return false;
3025   }
3026 
3027   // threads are now handled in collect_stack_roots()
3028 
3029   // Other kinds of roots maintained by HotSpot
3030   // Many of these won&#39;t be visible but others (such as instances of important
3031   // exceptions) will be visible.
3032   blk.set_kind(JVMTI_HEAP_REFERENCE_OTHER);
3033   Universe::oops_do(&amp;blk);
3034   if (blk.stopped()) {
3035     return false;
3036   }
3037 
3038   return true;
3039 }
3040 
3041 // Walk the stack of a given thread and find all references (locals
3042 // and JNI calls) and report these as stack references
3043 inline bool VM_HeapWalkOperation::collect_stack_roots(JavaThread* java_thread,
3044                                                       JNILocalRootsClosure* blk)
3045 {
3046   oop threadObj = java_thread-&gt;threadObj();
3047   assert(threadObj != NULL, &quot;sanity check&quot;);
3048 
3049   // only need to get the thread&#39;s tag once per thread
3050   jlong thread_tag = tag_for(_tag_map, threadObj);
3051 
3052   // also need the thread id
3053   jlong tid = java_lang_Thread::thread_id(threadObj);
3054 
3055 
3056   if (java_thread-&gt;has_last_Java_frame()) {
3057 
3058     // vframes are resource allocated
3059     Thread* current_thread = Thread::current();
3060     ResourceMark rm(current_thread);
3061     HandleMark hm(current_thread);
3062 
3063     RegisterMap reg_map(java_thread);
3064     frame f = java_thread-&gt;last_frame();
3065     vframe* vf = vframe::new_vframe(&amp;f, &amp;reg_map, java_thread);
3066 
3067     bool is_top_frame = true;
3068     int depth = 0;
3069     frame* last_entry_frame = NULL;
3070 
3071     while (vf != NULL) {
3072       if (vf-&gt;is_java_frame()) {
3073 
3074         // java frame (interpreted, compiled, ...)
3075         javaVFrame *jvf = javaVFrame::cast(vf);
3076 
3077         // the jmethodID
3078         jmethodID method = jvf-&gt;method()-&gt;jmethod_id();
3079 
3080         if (!(jvf-&gt;method()-&gt;is_native())) {
3081           jlocation bci = (jlocation)jvf-&gt;bci();
3082           StackValueCollection* locals = jvf-&gt;locals();
3083           for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
3084             if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
3085               oop o = locals-&gt;obj_at(slot)();
3086               if (o == NULL) {
3087                 continue;
3088               }
3089 
3090               // stack reference
3091               if (!CallbackInvoker::report_stack_ref_root(thread_tag, tid, depth, method,
3092                                                    bci, slot, o)) {
3093                 return false;
3094               }
3095             }
3096           }
3097 
3098           StackValueCollection* exprs = jvf-&gt;expressions();
3099           for (int index=0; index &lt; exprs-&gt;size(); index++) {
3100             if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
3101               oop o = exprs-&gt;obj_at(index)();
3102               if (o == NULL) {
3103                 continue;
3104               }
3105 
3106               // stack reference
3107               if (!CallbackInvoker::report_stack_ref_root(thread_tag, tid, depth, method,
3108                                                    bci, locals-&gt;size() + index, o)) {
3109                 return false;
3110               }
3111             }
3112           }
3113 
3114           // Follow oops from compiled nmethod
3115           if (jvf-&gt;cb() != NULL &amp;&amp; jvf-&gt;cb()-&gt;is_nmethod()) {
3116             blk-&gt;set_context(thread_tag, tid, depth, method);
3117             jvf-&gt;cb()-&gt;as_nmethod()-&gt;oops_do(blk);
3118           }
3119         } else {
3120           blk-&gt;set_context(thread_tag, tid, depth, method);
3121           if (is_top_frame) {
3122             // JNI locals for the top frame.
3123             java_thread-&gt;active_handles()-&gt;oops_do(blk);
3124           } else {
3125             if (last_entry_frame != NULL) {
3126               // JNI locals for the entry frame
3127               assert(last_entry_frame-&gt;is_entry_frame(), &quot;checking&quot;);
3128               last_entry_frame-&gt;entry_frame_call_wrapper()-&gt;handles()-&gt;oops_do(blk);
3129             }
3130           }
3131         }
3132         last_entry_frame = NULL;
3133         depth++;
3134       } else {
3135         // externalVFrame - for an entry frame then we report the JNI locals
3136         // when we find the corresponding javaVFrame
3137         frame* fr = vf-&gt;frame_pointer();
3138         assert(fr != NULL, &quot;sanity check&quot;);
3139         if (fr-&gt;is_entry_frame()) {
3140           last_entry_frame = fr;
3141         }
3142       }
3143 
3144       vf = vf-&gt;sender();
3145       is_top_frame = false;
3146     }
3147   } else {
3148     // no last java frame but there may be JNI locals
3149     blk-&gt;set_context(thread_tag, tid, 0, (jmethodID)NULL);
3150     java_thread-&gt;active_handles()-&gt;oops_do(blk);
3151   }
3152   return true;
3153 }
3154 
3155 
3156 // Collects the simple roots for all threads and collects all
3157 // stack roots - for each thread it walks the execution
3158 // stack to find all references and local JNI refs.
3159 inline bool VM_HeapWalkOperation::collect_stack_roots() {
3160   JNILocalRootsClosure blk;
3161   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
3162     oop threadObj = thread-&gt;threadObj();
3163     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
3164       // Collect the simple root for this thread before we
3165       // collect its stack roots
3166       if (!CallbackInvoker::report_simple_root(JVMTI_HEAP_REFERENCE_THREAD,
3167                                                threadObj)) {
3168         return false;
3169       }
3170       if (!collect_stack_roots(thread, &amp;blk)) {
3171         return false;
3172       }
3173     }
3174   }
3175   return true;
3176 }
3177 
3178 // visit an object
3179 // first mark the object as visited
3180 // second get all the outbound references from this object (in other words, all
3181 // the objects referenced by this object).
3182 //
3183 bool VM_HeapWalkOperation::visit(oop o) {
3184   // mark object as visited
3185   assert(!ObjectMarker::visited(o), &quot;can&#39;t visit same object more than once&quot;);
3186   ObjectMarker::mark(o);
3187 
3188   // instance
3189   if (o-&gt;is_instance()) {
3190     if (o-&gt;klass() == SystemDictionary::Class_klass()) {
3191       if (!java_lang_Class::is_primitive(o)) {
3192         // a java.lang.Class
3193         return iterate_over_class(o);
3194       }
3195     } else {
3196       return iterate_over_object(o);
3197     }
3198   }
3199 
3200   // object array
3201   if (o-&gt;is_objArray()) {
3202     return iterate_over_array(o);
3203   }
3204 
3205   // type array
3206   if (o-&gt;is_typeArray()) {
3207     return iterate_over_type_array(o);
3208   }
3209 
3210   return true;
3211 }
3212 
3213 void VM_HeapWalkOperation::doit() {
3214   ResourceMark rm;
3215   ObjectMarkerController marker;
3216   ClassFieldMapCacheMark cm;
3217 
3218   assert(visit_stack()-&gt;is_empty(), &quot;visit stack must be empty&quot;);
3219 
3220   // the heap walk starts with an initial object or the heap roots
3221   if (initial_object().is_null()) {
3222     // If either collect_stack_roots() or collect_simple_roots()
3223     // returns false at this point, then there are no mark bits
3224     // to reset.
3225     ObjectMarker::set_needs_reset(false);
3226 
3227     // Calling collect_stack_roots() before collect_simple_roots()
3228     // can result in a big performance boost for an agent that is
3229     // focused on analyzing references in the thread stacks.
3230     if (!collect_stack_roots()) return;
3231 
3232     if (!collect_simple_roots()) return;
3233 
3234     // no early return so enable heap traversal to reset the mark bits
3235     ObjectMarker::set_needs_reset(true);
3236   } else {
3237     visit_stack()-&gt;push(initial_object()());
3238   }
3239 
3240   // object references required
3241   if (is_following_references()) {
3242 
3243     // visit each object until all reachable objects have been
3244     // visited or the callback asked to terminate the iteration.
3245     while (!visit_stack()-&gt;is_empty()) {
3246       oop o = visit_stack()-&gt;pop();
3247       if (!ObjectMarker::visited(o)) {
3248         if (!visit(o)) {
3249           break;
3250         }
3251       }
3252     }
3253   }
3254 }
3255 
3256 // iterate over all objects that are reachable from a set of roots
3257 void JvmtiTagMap::iterate_over_reachable_objects(jvmtiHeapRootCallback heap_root_callback,
3258                                                  jvmtiStackReferenceCallback stack_ref_callback,
3259                                                  jvmtiObjectReferenceCallback object_ref_callback,
3260                                                  const void* user_data) {
3261   MutexLocker ml(Heap_lock);
3262   BasicHeapWalkContext context(heap_root_callback, stack_ref_callback, object_ref_callback);
3263   VM_HeapWalkOperation op(this, Handle(), context, user_data);
3264   VMThread::execute(&amp;op);
3265 }
3266 
3267 // iterate over all objects that are reachable from a given object
3268 void JvmtiTagMap::iterate_over_objects_reachable_from_object(jobject object,
3269                                                              jvmtiObjectReferenceCallback object_ref_callback,
3270                                                              const void* user_data) {
3271   oop obj = JNIHandles::resolve(object);
3272   Handle initial_object(Thread::current(), obj);
3273 
3274   MutexLocker ml(Heap_lock);
3275   BasicHeapWalkContext context(NULL, NULL, object_ref_callback);
3276   VM_HeapWalkOperation op(this, initial_object, context, user_data);
3277   VMThread::execute(&amp;op);
3278 }
3279 
3280 // follow references from an initial object or the GC roots
3281 void JvmtiTagMap::follow_references(jint heap_filter,
3282                                     Klass* klass,
3283                                     jobject object,
3284                                     const jvmtiHeapCallbacks* callbacks,
3285                                     const void* user_data)
3286 {
3287   oop obj = JNIHandles::resolve(object);
3288   Handle initial_object(Thread::current(), obj);
3289 
3290   MutexLocker ml(Heap_lock);
3291   AdvancedHeapWalkContext context(heap_filter, klass, callbacks);
3292   VM_HeapWalkOperation op(this, initial_object, context, user_data);
3293   VMThread::execute(&amp;op);
3294 }
3295 
3296 
3297 void JvmtiTagMap::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
3298   // No locks during VM bring-up (0 threads) and no safepoints after main
3299   // thread creation and before VMThread creation (1 thread); initial GC
3300   // verification can happen in that window which gets to here.
3301   assert(Threads::number_of_threads() &lt;= 1 ||
3302          SafepointSynchronize::is_at_safepoint(),
3303          &quot;must be executed at a safepoint&quot;);
3304   if (JvmtiEnv::environments_might_exist()) {
3305     JvmtiEnvIterator it;
3306     for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
3307       JvmtiTagMap* tag_map = env-&gt;tag_map_acquire();
3308       if (tag_map != NULL &amp;&amp; !tag_map-&gt;is_empty()) {
3309         tag_map-&gt;do_weak_oops(is_alive, f);
3310       }
3311     }
3312   }
3313 }
3314 
3315 void JvmtiTagMap::do_weak_oops(BoolObjectClosure* is_alive, OopClosure* f) {
3316 
3317   // does this environment have the OBJECT_FREE event enabled
3318   bool post_object_free = env()-&gt;is_enabled(JVMTI_EVENT_OBJECT_FREE);
3319 
3320   // counters used for trace message
3321   int freed = 0;
3322   int moved = 0;
3323 
3324   JvmtiTagHashmap* hashmap = this-&gt;hashmap();
3325 
3326   // reenable sizing (if disabled)
3327   hashmap-&gt;set_resizing_enabled(true);
3328 
3329   // if the hashmap is empty then we can skip it
3330   if (hashmap-&gt;_entry_count == 0) {
3331     return;
3332   }
3333 
3334   // now iterate through each entry in the table
3335 
3336   JvmtiTagHashmapEntry** table = hashmap-&gt;table();
3337   int size = hashmap-&gt;size();
3338 
3339   JvmtiTagHashmapEntry* delayed_add = NULL;
3340 
3341   for (int pos = 0; pos &lt; size; ++pos) {
3342     JvmtiTagHashmapEntry* entry = table[pos];
3343     JvmtiTagHashmapEntry* prev = NULL;
3344 
3345     while (entry != NULL) {
3346       JvmtiTagHashmapEntry* next = entry-&gt;next();
3347 
3348       // has object been GC&#39;ed
3349       if (!is_alive-&gt;do_object_b(entry-&gt;object_raw())) {
3350         // grab the tag
3351         jlong tag = entry-&gt;tag();
3352         guarantee(tag != 0, &quot;checking&quot;);
3353 
3354         // remove GC&#39;ed entry from hashmap and return the
3355         // entry to the free list
3356         hashmap-&gt;remove(prev, pos, entry);
3357         destroy_entry(entry);
3358 
3359         // post the event to the profiler
3360         if (post_object_free) {
3361           JvmtiExport::post_object_free(env(), tag);
3362         }
3363 
3364         ++freed;
3365       } else {
3366         f-&gt;do_oop(entry-&gt;object_addr());
3367         oop new_oop = entry-&gt;object_raw();
3368 
3369         // if the object has moved then re-hash it and move its
3370         // entry to its new location.
3371         unsigned int new_pos = JvmtiTagHashmap::hash(new_oop, size);
3372         if (new_pos != (unsigned int)pos) {
3373           if (prev == NULL) {
3374             table[pos] = next;
3375           } else {
3376             prev-&gt;set_next(next);
3377           }
3378           if (new_pos &lt; (unsigned int)pos) {
3379             entry-&gt;set_next(table[new_pos]);
3380             table[new_pos] = entry;
3381           } else {
3382             // Delay adding this entry to it&#39;s new position as we&#39;d end up
3383             // hitting it again during this iteration.
3384             entry-&gt;set_next(delayed_add);
3385             delayed_add = entry;
3386           }
3387           moved++;
3388         } else {
3389           // object didn&#39;t move
3390           prev = entry;
3391         }
3392       }
3393 
3394       entry = next;
3395     }
3396   }
3397 
3398   // Re-add all the entries which were kept aside
3399   while (delayed_add != NULL) {
3400     JvmtiTagHashmapEntry* next = delayed_add-&gt;next();
3401     unsigned int pos = JvmtiTagHashmap::hash(delayed_add-&gt;object_raw(), size);
3402     delayed_add-&gt;set_next(table[pos]);
3403     table[pos] = delayed_add;
3404     delayed_add = next;
3405   }
3406 
3407   log_debug(jvmti, objecttagging)(&quot;(%d-&gt;%d, %d freed, %d total moves)&quot;,
3408                                   hashmap-&gt;_entry_count + freed, hashmap-&gt;_entry_count, freed, moved);
3409 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>