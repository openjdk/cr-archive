<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
  72 #include &quot;utilities/utf8.hpp&quot;
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  75 #endif
  76 
  77 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  78   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  79 
  80 #if INCLUDE_CDS
  81 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  82   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  83 #endif
  84 
  85 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  86   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  87 
  88 InjectedField JavaClasses::_injected_fields[] = {
  89   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  90 };
  91 
  92 // Register native methods of Object
  93 void java_lang_Object::register_natives(TRAPS) {
  94   InstanceKlass* obj = SystemDictionary::Object_klass();
  95   Method::register_native(obj, vmSymbols::hashCode_name(),
  96                           vmSymbols::void_int_signature(), (address) &amp;JVM_IHashCode, CHECK);
  97   Method::register_native(obj, vmSymbols::wait_name(),
  98                           vmSymbols::long_void_signature(), (address) &amp;JVM_MonitorWait, CHECK);
  99   Method::register_native(obj, vmSymbols::notify_name(),
 100                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotify, CHECK);
 101   Method::register_native(obj, vmSymbols::notifyAll_name(),
 102                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotifyAll, CHECK);
 103   Method::register_native(obj, vmSymbols::clone_name(),
 104                           vmSymbols::void_object_signature(), (address) &amp;JVM_Clone, THREAD);
 105 }
 106 
 107 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
 108   return _injected_fields[id].compute_offset();
 109 }
 110 
 111 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
 112   *field_count = 0;
 113 
 114   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
 115   if (sid == vmSymbols::NO_SID) {
 116     // Only well known classes can inject fields
 117     return NULL;
 118   }
 119 
 120   int count = 0;
 121   int start = -1;
 122 
 123 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 124   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 125     count++;                                                       \
 126     if (start == -1) start = klass##_##name##_enum;                \
 127   }
 128   ALL_INJECTED_FIELDS(LOOKUP_INJECTED_FIELD);
 129 #undef LOOKUP_INJECTED_FIELD
 130 
 131   if (start != -1) {
 132     *field_count = count;
 133     return _injected_fields + start;
 134   }
 135   return NULL;
 136 }
 137 
 138 
 139 // Helpful routine for computing field offsets at run time rather than hardcoding them
 140 // Finds local fields only, including static fields.  Static field offsets are from the
 141 // beginning of the mirror.
 142 static void compute_offset(int &amp;dest_offset,
 143                            InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,
 144                            bool is_static = false) {
 145   fieldDescriptor fd;
 146   if (ik == NULL) {
 147     ResourceMark rm;
 148     log_error(class)(&quot;Mismatch JDK version for field: %s type: %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 149     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;);
 150   }
 151 
 152   if (!ik-&gt;find_local_field(name_symbol, signature_symbol, &amp;fd) || fd.is_static() != is_static) {
 153     ResourceMark rm;
 154     log_error(class)(&quot;Invalid layout of %s field: %s type: %s&quot;, ik-&gt;external_name(),
 155                      name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 156 #ifndef PRODUCT
 157     // Prints all fields and offsets
 158     Log(class) lt;
 159     LogStream ls(lt.error());
 160     ik-&gt;print_on(&amp;ls);
 161 #endif //PRODUCT
 162     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 163   }
 164   dest_offset = fd.offset();
 165 }
 166 
 167 // Overloading to pass name as a string.
 168 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 169                            const char* name_string, Symbol* signature_symbol,
 170                            bool is_static = false) {
 171   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 172   if (name == NULL) {
 173     ResourceMark rm;
 174     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 175     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 176   }
 177   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 178 }
 179 
 180 
 181 #if INCLUDE_CDS
 182 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 183   f-&gt;do_u4((u4*)&amp;offset)
 184 #endif
 185 
 186 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 187   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 188 
 189 
 190 // java_lang_String
 191 
 192 int java_lang_String::_value_offset;
 193 int java_lang_String::_hash_offset;
 194 int java_lang_String::_hashIsZero_offset;
 195 int java_lang_String::_coder_offset;
 196 
 197 bool java_lang_String::_initialized;
 198 
 199 bool java_lang_String::is_instance(oop obj) {
 200   return is_instance_inlined(obj);
 201 }
 202 
 203 #define STRING_FIELDS_DO(macro) \
 204   macro(_value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 205   macro(_hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
 206   macro(_hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \
 207   macro(_coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);
 208 
 209 void java_lang_String::compute_offsets() {
 210   if (_initialized) {
 211     return;
 212   }
 213 
 214   InstanceKlass* k = SystemDictionary::String_klass();
 215   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 216 
 217   _initialized = true;
 218 }
 219 
 220 #if INCLUDE_CDS
 221 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 222   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 223   f-&gt;do_bool(&amp;_initialized);
 224 }
 225 #endif
 226 
 227 class CompactStringsFixup : public FieldClosure {
 228 private:
 229   bool _value;
 230 
 231 public:
 232   CompactStringsFixup(bool value) : _value(value) {}
 233 
 234   void do_field(fieldDescriptor* fd) {
 235     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 236       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 237       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 238       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 239       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 240     }
 241   }
 242 };
 243 
 244 void java_lang_String::set_compact_strings(bool value) {
 245   CompactStringsFixup fix(value);
 246   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 247 }
 248 
 249 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 250   assert(_initialized, &quot;Must be initialized&quot;);
 251   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 252 
 253   // Create the String object first, so there&#39;s a chance that the String
 254   // and the char array it points to end up in the same cache line.
 255   oop obj;
 256   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 257 
 258   // Create the char array.  The String object must be handlized here
 259   // because GC can happen as a result of the allocation attempt.
 260   Handle h_obj(THREAD, obj);
 261   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 262   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 263 
 264   // Point the String at the char array
 265   obj = h_obj();
 266   set_value(obj, buffer);
 267   // No need to zero the offset, allocation zero&#39;ed the entire String object
 268   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 269   return h_obj;
 270 }
 271 
 272 Handle java_lang_String::create_from_unicode(const jchar* unicode, int length, TRAPS) {
 273   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 274   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 275   typeArrayOop buffer = value(h_obj());
 276   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 277   if (is_latin1) {
 278     for (int index = 0; index &lt; length; index++) {
 279       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 280     }
 281   } else {
 282     for (int index = 0; index &lt; length; index++) {
 283       buffer-&gt;char_at_put(index, unicode[index]);
 284     }
 285   }
 286 
 287 #ifdef ASSERT
 288   {
 289     ResourceMark rm;
 290     char* expected = UNICODE::as_utf8(unicode, length);
 291     char* actual = as_utf8_string(h_obj());
 292     if (strcmp(expected, actual) != 0) {
 293       fatal(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 294     }
 295   }
 296 #endif
 297 
 298   return h_obj;
 299 }
 300 
 301 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 302   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);
 303   return h_obj();
 304 }
 305 
 306 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 307   if (utf8_str == NULL) {
 308     return Handle();
 309   }
 310   bool has_multibyte, is_latin1;
 311   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 312   if (!CompactStrings) {
 313     has_multibyte = true;
 314     is_latin1 = false;
 315   }
 316 
 317   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 318   if (length &gt; 0) {
 319     if (!has_multibyte) {
 320       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 321       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 322     } else if (is_latin1) {
 323       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 324     } else {
 325       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 326     }
 327   }
 328 
 329 #ifdef ASSERT
 330   // This check is too strict when the input string is not a valid UTF8.
 331   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 332   if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {
 333     ResourceMark rm;
 334     const char* expected = utf8_str;
 335     char* actual = as_utf8_string(h_obj());
 336     if (strcmp(expected, actual) != 0) {
 337       fatal(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 338     }
 339   }
 340 #endif
 341 
 342   return h_obj;
 343 }
 344 
 345 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 346   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);
 347   return h_obj();
 348 }
 349 
 350 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 351   const char* utf8_str = (char*)symbol-&gt;bytes();
 352   int utf8_len = symbol-&gt;utf8_length();
 353 
 354   bool has_multibyte, is_latin1;
 355   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 356   if (!CompactStrings) {
 357     has_multibyte = true;
 358     is_latin1 = false;
 359   }
 360 
 361   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 362   if (length &gt; 0) {
 363     if (!has_multibyte) {
 364       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 365       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 366     } else if (is_latin1) {
 367       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 368     } else {
 369       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 370     }
 371   }
 372 
 373 #ifdef ASSERT
 374   {
 375     ResourceMark rm;
 376     const char* expected = symbol-&gt;as_utf8();
 377     char* actual = as_utf8_string(h_obj());
 378     if (strncmp(expected, actual, utf8_len) != 0) {
 379       fatal(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 380     }
 381   }
 382 #endif
 383 
 384   return h_obj;
 385 }
 386 
 387 // Converts a C string to a Java String based on current encoding
 388 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 389   assert(str != NULL, &quot;bad arguments&quot;);
 390 
 391   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);
 392   static to_java_string_fn_t _to_java_string_fn = NULL;
 393 
 394   if (_to_java_string_fn == NULL) {
 395     void *lib_handle = os::native_java_library();
 396     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));
 397 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)
 398     if (_to_java_string_fn == NULL) {
 399       // On 32 bit Windows, also try __stdcall decorated name
 400       _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;_JNU_NewStringPlatform@8&quot;));
 401     }
 402 #endif
 403     if (_to_java_string_fn == NULL) {
 404       fatal(&quot;JNU_NewStringPlatform missing&quot;);
 405     }
 406   }
 407 
 408   jstring js = NULL;
 409   {
 410     assert(THREAD-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 411     JavaThread* thread = (JavaThread*)THREAD;
 412     HandleMark hm(thread);
 413     ThreadToNativeFromVM ttn(thread);
 414     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 415   }
 416 
 417   Handle native_platform_string(THREAD, JNIHandles::resolve(js));
 418   JNIHandles::destroy_local(js);  // destroy local JNIHandle.
 419   return native_platform_string;
 420 }
 421 
 422 // Converts a Java String to a native C string that can be used for
 423 // native OS calls.
 424 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 425   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 426   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 427 
 428   if (_to_platform_string_fn == NULL) {
 429     void *lib_handle = os::native_java_library();
 430     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 431     if (_to_platform_string_fn == NULL) {
 432       fatal(&quot;GetStringPlatformChars missing&quot;);
 433     }
 434   }
 435 
 436   char *native_platform_string;
 437   { JavaThread* thread = (JavaThread*)THREAD;
 438     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 439     jstring js = (jstring) JNIHandles::make_local(thread, java_string());
 440     bool is_copy;
 441     HandleMark hm(thread);
 442     ThreadToNativeFromVM ttn(thread);
 443     JNIEnv *env = thread-&gt;jni_environment();
 444     native_platform_string = (_to_platform_string_fn)(env, js, &amp;is_copy);
 445     assert(is_copy == JNI_TRUE, &quot;is_copy value changed&quot;);
 446     JNIHandles::destroy_local(js);
 447   }
 448   return native_platform_string;
 449 }
 450 
 451 Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {
 452   oop          obj    = java_string();
 453   // Typical usage is to convert all &#39;/&#39; to &#39;.&#39; in string.
 454   typeArrayOop value  = java_lang_String::value(obj);
 455   int          length = java_lang_String::length(obj, value);
 456   bool      is_latin1 = java_lang_String::is_latin1(obj);
 457 
 458   // First check if any from_char exist
 459   int index; // Declared outside, used later
 460   for (index = 0; index &lt; length; index++) {
 461     jchar c = !is_latin1 ? value-&gt;char_at(index) :
 462                   ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 463     if (c == from_char) {
 464       break;
 465     }
 466   }
 467   if (index == length) {
 468     // No from_char, so do not copy.
 469     return java_string;
 470   }
 471 
 472   // Check if result string will be latin1
 473   bool to_is_latin1 = false;
 474 
 475   // Replacement char must be latin1
 476   if (CompactStrings &amp;&amp; UNICODE::is_latin1(to_char)) {
 477     if (is_latin1) {
 478       // Source string is latin1 as well
 479       to_is_latin1 = true;
 480     } else if (!UNICODE::is_latin1(from_char)) {
 481       // We are replacing an UTF16 char. Scan string to
 482       // check if result can be latin1 encoded.
 483       to_is_latin1 = true;
 484       for (index = 0; index &lt; length; index++) {
 485         jchar c = value-&gt;char_at(index);
 486         if (c != from_char &amp;&amp; !UNICODE::is_latin1(c)) {
 487           to_is_latin1 = false;
 488           break;
 489         }
 490       }
 491     }
 492   }
 493 
 494   // Create new UNICODE (or byte) buffer. Must handlize value because GC
 495   // may happen during String and char array creation.
 496   typeArrayHandle h_value(THREAD, value);
 497   Handle string = basic_create(length, to_is_latin1, CHECK_NH);
 498   typeArrayOop from_buffer = h_value();
 499   typeArrayOop to_buffer = java_lang_String::value(string());
 500 
 501   // Copy contents
 502   for (index = 0; index &lt; length; index++) {
 503     jchar c = (!is_latin1) ? from_buffer-&gt;char_at(index) :
 504                     ((jchar) from_buffer-&gt;byte_at(index)) &amp; 0xff;
 505     if (c == from_char) {
 506       c = to_char;
 507     }
 508     if (!to_is_latin1) {
 509       to_buffer-&gt;char_at_put(index, c);
 510     } else {
 511       to_buffer-&gt;byte_at_put(index, (jbyte) c);
 512     }
 513   }
 514   return string;
 515 }
 516 
 517 jchar* java_lang_String::as_unicode_string(oop java_string, int&amp; length, TRAPS) {
 518   typeArrayOop value  = java_lang_String::value(java_string);
 519                length = java_lang_String::length(java_string, value);
 520   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 521 
 522   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 523   if (result != NULL) {
 524     if (!is_latin1) {
 525       for (int index = 0; index &lt; length; index++) {
 526         result[index] = value-&gt;char_at(index);
 527       }
 528     } else {
 529       for (int index = 0; index &lt; length; index++) {
 530         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 531       }
 532     }
 533   } else {
 534     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 535   }
 536   return result;
 537 }
 538 
 539 unsigned int java_lang_String::hash_code(oop java_string) {
 540   // The hash and hashIsZero fields are subject to a benign data race,
 541   // making it crucial to ensure that any observable result of the
 542   // calculation in this method stays correct under any possible read of
 543   // these fields. Necessary restrictions to allow this to be correct
 544   // without explicit memory fences or similar concurrency primitives is
 545   // that we can ever only write to one of these two fields for a given
 546   // String instance, and that the computation is idempotent and derived
 547   // from immutable state
 548   assert(_initialized &amp;&amp; (_hash_offset &gt; 0) &amp;&amp; (_hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 549   if (java_lang_String::hash_is_set(java_string)) {
 550     return java_string-&gt;int_field(_hash_offset);
 551   }
 552 
 553   typeArrayOop value = java_lang_String::value(java_string);
 554   int         length = java_lang_String::length(java_string, value);
 555   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 556 
 557   unsigned int hash = 0;
 558   if (length &gt; 0) {
 559     if (is_latin1) {
 560       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 561     } else {
 562       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 563     }
 564   }
 565 
 566   if (hash != 0) {
 567     java_string-&gt;int_field_put(_hash_offset, hash);
 568   } else {
 569     java_string-&gt;bool_field_put(_hashIsZero_offset, true);
 570   }
 571   return hash;
 572 }
 573 
 574 char* java_lang_String::as_quoted_ascii(oop java_string) {
 575   typeArrayOop value  = java_lang_String::value(java_string);
 576   int          length = java_lang_String::length(java_string, value);
 577   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 578 
 579   if (length == 0) return NULL;
 580 
 581   char* result;
 582   int result_length;
 583   if (!is_latin1) {
 584     jchar* base = value-&gt;char_at_addr(0);
 585     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 586     result = NEW_RESOURCE_ARRAY(char, result_length);
 587     UNICODE::as_quoted_ascii(base, length, result, result_length);
 588   } else {
 589     jbyte* base = value-&gt;byte_at_addr(0);
 590     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 591     result = NEW_RESOURCE_ARRAY(char, result_length);
 592     UNICODE::as_quoted_ascii(base, length, result, result_length);
 593   }
 594   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 595   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 596   return result;
 597 }
 598 
 599 Symbol* java_lang_String::as_symbol(oop java_string) {
 600   typeArrayOop value  = java_lang_String::value(java_string);
 601   int          length = java_lang_String::length(java_string, value);
 602   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 603   if (!is_latin1) {
 604     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 605     Symbol* sym = SymbolTable::new_symbol(base, length);
 606     return sym;
 607   } else {
 608     ResourceMark rm;
 609     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 610     const char* base = UNICODE::as_utf8(position, length);
 611     Symbol* sym = SymbolTable::new_symbol(base, length);
 612     return sym;
 613   }
 614 }
 615 
 616 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 617   typeArrayOop value  = java_lang_String::value(java_string);
 618   int          length = java_lang_String::length(java_string, value);
 619   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 620   if (!is_latin1) {
 621     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 622     return SymbolTable::probe_unicode(base, length);
 623   } else {
 624     ResourceMark rm;
 625     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 626     const char* base = UNICODE::as_utf8(position, length);
 627     return SymbolTable::probe(base, length);
 628   }
 629 }
 630 
 631 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 632   assert(value_equals(value, java_lang_String::value(java_string)),
 633          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 634   int length = java_lang_String::length(java_string, value);
 635   if (length == 0) {
 636     return 0;
 637   }
 638   if (!java_lang_String::is_latin1(java_string)) {
 639     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 640   } else {
 641     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 642   }
 643 }
 644 
 645 int java_lang_String::utf8_length(oop java_string) {
 646   typeArrayOop value = java_lang_String::value(java_string);
 647   return utf8_length(java_string, value);
 648 }
 649 
 650 char* java_lang_String::as_utf8_string(oop java_string) {
 651   int length;
 652   return as_utf8_string(java_string, length);
 653 }
 654 
 655 char* java_lang_String::as_utf8_string(oop java_string, int&amp; length) {
 656   typeArrayOop value = java_lang_String::value(java_string);
 657   length             = java_lang_String::length(java_string, value);
 658   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 659   if (!is_latin1) {
 660     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 661     return UNICODE::as_utf8(position, length);
 662   } else {
 663     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 664     return UNICODE::as_utf8(position, length);
 665   }
 666 }
 667 
 668 // Uses a provided buffer if it&#39;s sufficiently large, otherwise allocates
 669 // a resource array to fit
 670 char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; utf8_len) {
 671   typeArrayOop value = java_lang_String::value(java_string);
 672   int            len = java_lang_String::length(java_string, value);
 673   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 674   if (!is_latin1) {
 675     jchar *position = (len == 0) ? NULL : value-&gt;char_at_addr(0);
 676     utf8_len = UNICODE::utf8_length(position, len);
 677     if (utf8_len &gt;= buflen) {
 678       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 679     }
 680     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 681   } else {
 682     jbyte *position = (len == 0) ? NULL : value-&gt;byte_at_addr(0);
 683     utf8_len = UNICODE::utf8_length(position, len);
 684     if (utf8_len &gt;= buflen) {
 685       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 686     }
 687     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 688   }
 689 }
 690 
 691 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 692   assert(value_equals(value, java_lang_String::value(java_string)),
 693          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 694   int     length = java_lang_String::length(java_string, value);
 695   bool is_latin1 = java_lang_String::is_latin1(java_string);
 696   if (!is_latin1) {
 697     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 698     return UNICODE::as_utf8(position, length, buf, buflen);
 699   } else {
 700     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 701     return UNICODE::as_utf8(position, length, buf, buflen);
 702   }
 703 }
 704 
 705 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 706   typeArrayOop value = java_lang_String::value(java_string);
 707   return as_utf8_string(java_string, value, buf, buflen);
 708 }
 709 
 710 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
 711   typeArrayOop value  = java_lang_String::value(java_string);
 712   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 713   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 714   if (!is_latin1) {
 715     jchar* position = value-&gt;char_at_addr(start);
 716     return UNICODE::as_utf8(position, len);
 717   } else {
 718     jbyte* position = value-&gt;byte_at_addr(start);
 719     return UNICODE::as_utf8(position, len);
 720   }
 721 }
 722 
 723 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {
 724   assert(value_equals(value, java_lang_String::value(java_string)),
 725          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 726   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 727   bool is_latin1 = java_lang_String::is_latin1(java_string);
 728   if (!is_latin1) {
 729     jchar* position = value-&gt;char_at_addr(start);
 730     return UNICODE::as_utf8(position, len, buf, buflen);
 731   } else {
 732     jbyte* position = value-&gt;byte_at_addr(start);
 733     return UNICODE::as_utf8(position, len, buf, buflen);
 734   }
 735 }
 736 
 737 bool java_lang_String::equals(oop java_string, const jchar* chars, int len) {
 738   assert(java_string-&gt;klass() == SystemDictionary::String_klass(),
 739          &quot;must be java_string&quot;);
 740   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
 741   int length = java_lang_String::length(java_string, value);
 742   if (length != len) {
 743     return false;
 744   }
 745   bool is_latin1 = java_lang_String::is_latin1(java_string);
 746   if (!is_latin1) {
 747     for (int i = 0; i &lt; len; i++) {
 748       if (value-&gt;char_at(i) != chars[i]) {
 749         return false;
 750       }
 751     }
 752   } else {
 753     for (int i = 0; i &lt; len; i++) {
 754       if ((((jchar) value-&gt;byte_at(i)) &amp; 0xff) != chars[i]) {
 755         return false;
 756       }
 757     }
 758   }
 759   return true;
 760 }
 761 
 762 bool java_lang_String::equals(oop str1, oop str2) {
 763   assert(str1-&gt;klass() == SystemDictionary::String_klass(),
 764          &quot;must be java String&quot;);
 765   assert(str2-&gt;klass() == SystemDictionary::String_klass(),
 766          &quot;must be java String&quot;);
 767   typeArrayOop value1    = java_lang_String::value_no_keepalive(str1);
 768   bool         is_latin1 = java_lang_String::is_latin1(str1);
 769   typeArrayOop value2    = java_lang_String::value_no_keepalive(str2);
 770   bool         is_latin2 = java_lang_String::is_latin1(str2);
 771 
 772   if (is_latin1 != is_latin2) {
 773     // Strings with different coders are never equal.
 774     return false;
 775   }
 776   return value_equals(value1, value2);
 777 }
 778 
 779 void java_lang_String::print(oop java_string, outputStream* st) {
 780   assert(java_string-&gt;klass() == SystemDictionary::String_klass(), &quot;must be java_string&quot;);
 781   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 782 
 783   if (value == NULL) {
 784     // This can happen if, e.g., printing a String
 785     // object before its initializer has been called
 786     st-&gt;print(&quot;NULL&quot;);
 787     return;
 788   }
 789 
 790   int length = java_lang_String::length(java_string, value);
 791   bool is_latin1 = java_lang_String::is_latin1(java_string);
 792 
 793   st-&gt;print(&quot;\&quot;&quot;);
 794   for (int index = 0; index &lt; length; index++) {
 795     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 796                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 797   }
 798   st-&gt;print(&quot;\&quot;&quot;);
 799 }
 800 
 801 // java_lang_Class
 802 
 803 int java_lang_Class::_klass_offset;
 804 int java_lang_Class::_array_klass_offset;
 805 int java_lang_Class::_oop_size_offset;
 806 int java_lang_Class::_static_oop_field_count_offset;
 807 int java_lang_Class::_class_loader_offset;
 808 int java_lang_Class::_module_offset;
 809 int java_lang_Class::_protection_domain_offset;
 810 int java_lang_Class::_component_mirror_offset;
 811 int java_lang_Class::_init_lock_offset;
 812 int java_lang_Class::_signers_offset;
 813 int java_lang_Class::_name_offset;
 814 int java_lang_Class::_source_file_offset;
 815 int java_lang_Class::_classData_offset;
 816 int java_lang_Class::_classRedefinedCount_offset;
 817 
 818 bool java_lang_Class::_offsets_computed = false;
 819 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
 820 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
 821 
 822 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 823   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 824   if (fd-&gt;has_initial_value()) {
 825     BasicType t = fd-&gt;field_type();
 826     switch (t) {
 827       case T_BYTE:
 828         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 829               break;
 830       case T_BOOLEAN:
 831         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 832               break;
 833       case T_CHAR:
 834         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 835               break;
 836       case T_SHORT:
 837         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 838               break;
 839       case T_INT:
 840         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 841         break;
 842       case T_FLOAT:
 843         mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
 844         break;
 845       case T_DOUBLE:
 846         mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
 847         break;
 848       case T_LONG:
 849         mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
 850         break;
 851       case T_OBJECT:
 852         {
 853           assert(fd-&gt;signature() == vmSymbols::string_signature(),
 854                  &quot;just checking&quot;);
 855           if (DumpSharedSpaces &amp;&amp; HeapShared::is_archived_object(mirror())) {
 856             // Archive the String field and update the pointer.
 857             oop s = mirror()-&gt;obj_field(fd-&gt;offset());
 858             oop archived_s = StringTable::create_archived_string(s, CHECK);
 859             mirror()-&gt;obj_field_put(fd-&gt;offset(), archived_s);
 860           } else {
 861             oop string = fd-&gt;string_initial_value(CHECK);
 862             mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
 863           }
 864         }
 865         break;
 866       default:
 867         THROW_MSG(vmSymbols::java_lang_ClassFormatError(),
 868                   &quot;Illegal ConstantValue attribute in class file&quot;);
 869     }
 870   }
 871 }
 872 
 873 
 874 void java_lang_Class::fixup_mirror(Klass* k, TRAPS) {
 875   assert(InstanceMirrorKlass::offset_of_static_fields() != 0, &quot;must have been computed already&quot;);
 876 
 877   // If the offset was read from the shared archive, it was fixed up already
 878   if (!k-&gt;is_shared()) {
 879     if (k-&gt;is_instance_klass()) {
 880       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 881       // offsets were computed without the size added it.  Go back and
 882       // update all the static field offsets to included the size.
 883       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 884         if (fs.access_flags().is_static()) {
 885           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 886           fs.set_offset(real_offset);
 887         }
 888       }
 889     }
 890   }
 891 
 892   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 893     if (HeapShared::open_archive_heap_region_mapped()) {
 894       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 895       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 896       return;
 897     } else {
 898       k-&gt;clear_java_mirror_handle();
 899       k-&gt;clear_has_raw_archived_mirror();
 900     }
 901   }
 902   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 903 }
 904 
 905 void java_lang_Class::initialize_mirror_fields(Klass* k,
 906                                                Handle mirror,
 907                                                Handle protection_domain,
 908                                                Handle classData,
 909                                                TRAPS) {
 910   // Allocate a simple java object for a lock.
 911   // This needs to be a java object because during class initialization
 912   // it can be held across a java call.
 913   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 914   set_init_lock(mirror(), r);
 915 
 916   // Set protection domain also
 917   set_protection_domain(mirror(), protection_domain());
 918 
 919   // Initialize static fields
 920   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 921 
 922  // Set classData
 923   set_class_data(mirror(), classData());
 924 }
 925 
 926 // Set the java.lang.Module module field in the java_lang_Class mirror
 927 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 928   if (module.is_null()) {
 929     // During startup, the module may be NULL only if java.base has not been defined yet.
 930     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 931     // for java.base is known. But note that since we captured the NULL module another
 932     // thread may have completed that initialization.
 933 
 934     bool javabase_was_defined = false;
 935     {
 936       MutexLocker m1(THREAD, Module_lock);
 937       // Keep list of classes needing java.base module fixup
 938       if (!ModuleEntryTable::javabase_defined()) {
 939         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 940         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 941         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 942         fixup_module_field_list()-&gt;push(k);
 943       } else {
 944         javabase_was_defined = true;
 945       }
 946     }
 947 
 948     // If java.base was already defined then patch this particular class with java.base.
 949     if (javabase_was_defined) {
 950       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 951       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 952              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 953       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 954       set_module(mirror(), javabase_handle());
 955     }
 956   } else {
 957     assert(Universe::is_module_initialized() ||
 958            (ModuleEntryTable::javabase_defined() &amp;&amp;
 959             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),
 960            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 961     set_module(mirror(), module());
 962   }
 963 }
 964 
 965 // Statically allocate fixup lists because they always get created.
 966 void java_lang_Class::allocate_fixup_lists() {
 967   GrowableArray&lt;Klass*&gt;* mirror_list =
 968     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, mtClass);
 969   set_fixup_mirror_list(mirror_list);
 970 
 971   GrowableArray&lt;Klass*&gt;* module_list =
 972     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, mtModule);
 973   set_fixup_module_field_list(module_list);
 974 }
 975 
 976 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 977                                     Handle module, Handle protection_domain,
 978                                     Handle classData, TRAPS) {
 979   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 980   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 981 
 982   // Use this moment of initialization to cache modifier_flags also,
 983   // to support Class.getModifiers().  Instance classes recalculate
 984   // the cached flags after the class file is parsed, but before the
 985   // class is put into the system dictionary.
 986   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 987   k-&gt;set_modifier_flags(computed_modifiers);
 988   // Class_klass has to be loaded because it is used to allocate
 989   // the mirror.
 990   if (SystemDictionary::Class_klass_loaded()) {
 991     // Allocate mirror (java.lang.Class instance)
 992     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 993     Handle mirror(THREAD, mirror_oop);
 994     Handle comp_mirror;
 995 
 996     // Setup indirection from mirror-&gt;klass
 997     java_lang_Class::set_klass(mirror(), k);
 998 
 999     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
1000     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
1001 
1002     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
1003 
1004     // It might also have a component mirror.  This mirror must already exist.
1005     if (k-&gt;is_array_klass()) {
1006       if (k-&gt;is_typeArray_klass()) {
1007         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
1008         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
1009       } else {
1010         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1011         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1012         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1013         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1014       }
1015       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1016 
1017       // Two-way link between the array klass and its component mirror:
1018       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1019       set_component_mirror(mirror(), comp_mirror());
1020       // See below for ordering dependencies between field array_klass in component mirror
1021       // and java_mirror in this klass.
1022     } else {
1023       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1024 
1025       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1026       if (HAS_PENDING_EXCEPTION) {
1027         // If any of the fields throws an exception like OOM remove the klass field
1028         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
1029         // This mirror looks like a primitive type, which logically it is because it
1030         // it represents no class.
1031         java_lang_Class::set_klass(mirror(), NULL);
1032         return;
1033       }
1034     }
1035 
1036     // set the classLoader field in the java_lang_Class instance
1037     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1038     set_class_loader(mirror(), class_loader());
1039 
1040     // Setup indirection from klass-&gt;mirror
1041     // after any exceptions can happen during allocations.
1042     k-&gt;set_java_mirror(mirror);
1043 
1044     // Set the module field in the java_lang_Class instance.  This must be done
1045     // after the mirror is set.
1046     set_mirror_module_field(k, mirror, module, THREAD);
1047 
1048     if (comp_mirror() != NULL) {
1049       // Set after k-&gt;java_mirror() is published, because compiled code running
1050       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1051       release_set_array_klass(comp_mirror(), k);
1052     }
1053   } else {
1054     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1055     fixup_mirror_list()-&gt;push(k);
1056   }
1057 }
1058 
1059 #if INCLUDE_CDS_JAVA_HEAP
1060 // Clears mirror fields. Static final fields with initial values are reloaded
1061 // from constant pool. The object identity hash is in the object header and is
1062 // not affected.
1063 class ResetMirrorField: public FieldClosure {
1064  private:
1065   Handle _m;
1066 
1067  public:
1068   ResetMirrorField(Handle mirror) : _m(mirror) {}
1069 
1070   void do_field(fieldDescriptor* fd) {
1071     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1072     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
1073 
1074     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
1075       initialize_static_field(fd, _m, Thread::current());
1076       return;
1077     }
1078 
1079     BasicType ft = fd-&gt;field_type();
1080     switch (ft) {
1081       case T_BYTE:
1082         _m()-&gt;byte_field_put(fd-&gt;offset(), 0);
1083         break;
1084       case T_CHAR:
1085         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
1086         break;
1087       case T_DOUBLE:
1088         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
1089         break;
1090       case T_FLOAT:
1091         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
1092         break;
1093       case T_INT:
1094         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
1095         break;
1096       case T_LONG:
1097         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
1098         break;
1099       case T_SHORT:
1100         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
1101         break;
1102       case T_BOOLEAN:
1103         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1104         break;
1105       case T_ARRAY:
1106       case T_OBJECT: {
1107         // It might be useful to cache the String field, but
1108         // for now just clear out any reference field
1109         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1110         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1111         break;
1112       }
1113       default:
1114         ShouldNotReachHere();
1115         break;
1116      }
1117   }
1118 };
1119 
1120 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1121   assert(HeapShared::is_heap_object_archiving_allowed(),
1122          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1123 
1124   for (int t = T_BOOLEAN; t &lt; T_VOID+1; t++) {
1125     BasicType bt = (BasicType)t;
1126     oop m = Universe::_mirrors[t].resolve();
1127     if (m != NULL) {
1128       // Update the field at _array_klass_offset to point to the relocated array klass.
1129       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1130       assert(archived_m != NULL, &quot;sanity&quot;);
1131       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1132       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1133       if (ak != NULL) {
1134         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);
1135         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1136       }
1137 
1138       // Clear the fields. Just to be safe
1139       Klass *k = m-&gt;klass();
1140       Handle archived_mirror_h(THREAD, archived_m);
1141       ResetMirrorField reset(archived_mirror_h);
1142       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1143 
1144       log_trace(cds, heap, mirror)(
1145         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1146         type2name(bt), p2i(m), p2i(archived_m));
1147 
1148       Universe::replace_mirror(bt, archived_m);
1149     }
1150   }
1151 }
1152 //
1153 // After the mirror object is successfully archived, the archived
1154 // klass is set with _has_archived_raw_mirror flag.
1155 //
1156 // The _has_archived_raw_mirror flag is cleared at runtime when the
1157 // archived mirror is restored. If archived java heap data cannot
1158 // be used at runtime, new mirror object is created for the shared
1159 // class. The _has_archived_raw_mirror is cleared also during the process.
1160 oop java_lang_Class::archive_mirror(Klass* k, TRAPS) {
1161   assert(HeapShared::is_heap_object_archiving_allowed(),
1162          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1163 
1164   // Mirror is already archived
1165   if (k-&gt;has_raw_archived_mirror()) {
1166     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1167     return k-&gt;archived_java_mirror_raw();
1168   }
1169 
1170   // No mirror
1171   oop mirror = k-&gt;java_mirror();
1172   if (mirror == NULL) {
1173     return NULL;
1174   }
1175 
1176   if (k-&gt;is_instance_klass()) {
1177     InstanceKlass *ik = InstanceKlass::cast(k);
1178     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1179 
1180     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1181           ik-&gt;is_shared_app_class())) {
1182       // Archiving mirror for classes from non-builtin loaders is not
1183       // supported. Clear the _java_mirror within the archived class.
1184       k-&gt;clear_java_mirror_handle();
1185       return NULL;
1186     }
1187   }
1188 
1189   // Now start archiving the mirror object
1190   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1191   if (archived_mirror == NULL) {
1192     return NULL;
1193   }
1194 
1195   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1196   if (archived_mirror == NULL) {
1197     return NULL;
1198   }
1199 
1200   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1201 
1202   k-&gt;set_has_raw_archived_mirror();
1203 
1204   ResourceMark rm;
1205   log_trace(cds, heap, mirror)(
1206     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1207     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1208 
1209   return archived_mirror;
1210 }
1211 
1212 // The process is based on create_mirror().
1213 oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,
1214                                              oop archived_mirror,
1215                                              Thread *THREAD) {
1216   // Clear nonstatic fields in archived mirror. Some of the fields will be set
1217   // to archived metadata and objects below.
1218   Klass *c = archived_mirror-&gt;klass();
1219   Handle archived_mirror_h(THREAD, archived_mirror);
1220   ResetMirrorField reset(archived_mirror_h);
1221   InstanceKlass::cast(c)-&gt;do_nonstatic_fields(&amp;reset);
1222 
1223   if (k-&gt;is_array_klass()) {
1224     oop archived_comp_mirror;
1225     if (k-&gt;is_typeArray_klass()) {
1226       // The primitive type mirrors are already archived. Get the archived mirror.
1227       oop comp_mirror = java_lang_Class::component_mirror(mirror);
1228       archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);
1229       assert(archived_comp_mirror != NULL, &quot;Must be&quot;);
1230     } else {
1231       assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1232       Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1233       assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1234       archived_comp_mirror = archive_mirror(element_klass, THREAD);
1235       if (archived_comp_mirror == NULL) {
1236         return NULL;
1237       }
1238     }
1239     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1240   } else {
1241     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1242 
1243     // Reset local static fields in the mirror
1244     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1245 
1246     java_lang_Class:set_init_lock(archived_mirror, NULL);
1247 
1248     set_protection_domain(archived_mirror, NULL);
1249   }
1250 
1251   // clear class loader and mirror_module_field
1252   set_class_loader(archived_mirror, NULL);
1253   set_module(archived_mirror, NULL);
1254 
1255   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1256   // klass. Updated the field in the archived mirror to point to the relocated
1257   // klass in the archive.
1258   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);
1259   log_debug(cds, heap, mirror)(
1260     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1261     p2i(as_Klass(mirror)), p2i(reloc_k));
1262   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1263 
1264   // The field at _array_klass_offset is pointing to the original one dimension
1265   // higher array klass if exists. Relocate the pointer.
1266   Klass *arr = array_klass_acquire(mirror);
1267   if (arr != NULL) {
1268     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);
1269     log_debug(cds, heap, mirror)(
1270       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1271       p2i(arr), p2i(reloc_arr));
1272     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1273   }
1274   return archived_mirror;
1275 }
1276 
1277 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {
1278   if (MetaspaceShared::relocation_delta() != 0) {
1279     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);
1280 
1281     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1282     if (ak != NULL) {
1283       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1284           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1285     }
1286   }
1287 }
1288 
1289 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
1290   assert(MetaspaceShared::relocation_delta() != 0, &quot;must be&quot;);
1291 
1292   Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));
1293   archived_mirror-&gt;metadata_field_put(_klass_offset,
1294       (Klass*)(address(k) + MetaspaceShared::relocation_delta()));
1295 
1296   Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1297   if (ak != NULL) {
1298     archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1299         (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1300   }
1301 }
1302 
1303 
1304 // Returns true if the mirror is updated, false if no archived mirror
1305 // data is present. After the archived mirror object is restored, the
1306 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1307 bool java_lang_Class::restore_archived_mirror(Klass *k,
1308                                               Handle class_loader, Handle module,
1309                                               Handle protection_domain, TRAPS) {
1310   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1311   // see more details in SystemDictionary::resolve_well_known_classes().
1312   if (!SystemDictionary::Class_klass_loaded()) {
1313     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1314     fixup_mirror_list()-&gt;push(k);
1315     return true;
1316   }
1317 
1318   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1319   if (m == NULL) {
1320     return false;
1321   }
1322 
1323   // mirror is archived, restore
1324   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));
1325   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
1326   assert(as_Klass(m) == k, &quot;must be&quot;);
1327   Handle mirror(THREAD, m);
1328 
1329   if (!k-&gt;is_array_klass()) {
1330     // - local static final fields with initial values were initialized at dump time
1331 
1332     // create the init_lock
1333     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1334     set_init_lock(mirror(), r);
1335 
1336     if (protection_domain.not_null()) {
1337       set_protection_domain(mirror(), protection_domain());
1338     }
1339   }
1340 
1341   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1342   if (class_loader.not_null()) {
1343     set_class_loader(mirror(), class_loader());
1344   }
1345 
1346   k-&gt;set_java_mirror(mirror);
1347   k-&gt;clear_has_raw_archived_mirror();
1348 
1349   set_mirror_module_field(k, mirror, module, THREAD);
1350 
1351   if (log_is_enabled(Trace, cds, heap, mirror)) {
1352     ResourceMark rm(THREAD);
1353     log_trace(cds, heap, mirror)(
1354         &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));
1355   }
1356 
1357   return true;
1358 }
1359 #endif // INCLUDE_CDS_JAVA_HEAP
1360 
1361 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1362   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1363   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1364 }
1365 
1366 int  java_lang_Class::oop_size(oop java_class) {
1367   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1368   int size = java_class-&gt;int_field(_oop_size_offset);
1369   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1370   return size;
1371 }
1372 
1373 
1374 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1375   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1376   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1377   *(int*)(((char*)java_class) + _oop_size_offset) = size;
1378 }
1379 
1380 int  java_lang_Class::static_oop_field_count(oop java_class) {
1381   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1382   return java_class-&gt;int_field(_static_oop_field_count_offset);
1383 }
1384 
1385 int  java_lang_Class::static_oop_field_count_raw(oop java_class) {
1386   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1387   return java_class-&gt;int_field_raw(_static_oop_field_count_offset);
1388 }
1389 
1390 void java_lang_Class::set_static_oop_field_count(oop java_class, int size) {
1391   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1392   java_class-&gt;int_field_put(_static_oop_field_count_offset, size);
1393 }
1394 
1395 oop java_lang_Class::protection_domain(oop java_class) {
1396   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1397   return java_class-&gt;obj_field(_protection_domain_offset);
1398 }
1399 void java_lang_Class::set_protection_domain(oop java_class, oop pd) {
1400   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1401   java_class-&gt;obj_field_put(_protection_domain_offset, pd);
1402 }
1403 
1404 void java_lang_Class::set_component_mirror(oop java_class, oop comp_mirror) {
1405   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1406     java_class-&gt;obj_field_put(_component_mirror_offset, comp_mirror);
1407   }
1408 oop java_lang_Class::component_mirror(oop java_class) {
1409   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1410   return java_class-&gt;obj_field(_component_mirror_offset);
1411 }
1412 
1413 oop java_lang_Class::init_lock(oop java_class) {
1414   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1415   return java_class-&gt;obj_field(_init_lock_offset);
1416 }
1417 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1418   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1419   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1420 }
1421 
1422 objArrayOop java_lang_Class::signers(oop java_class) {
1423   assert(_signers_offset != 0, &quot;must be set&quot;);
1424   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1425 }
1426 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1427   assert(_signers_offset != 0, &quot;must be set&quot;);
1428   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1429 }
1430 
1431 oop java_lang_Class::class_data(oop java_class) {
1432   assert(_classData_offset != 0, &quot;must be set&quot;);
1433   return java_class-&gt;obj_field(_classData_offset);
1434 }
1435 void java_lang_Class::set_class_data(oop java_class, oop class_data) {
1436   assert(_classData_offset != 0, &quot;must be set&quot;);
1437   java_class-&gt;obj_field_put(_classData_offset, class_data);
1438 }
1439 
1440 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
1441   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);
1442   java_class-&gt;obj_field_put(_class_loader_offset, loader);
1443 }
1444 
1445 oop java_lang_Class::class_loader(oop java_class) {
1446   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1447   return java_class-&gt;obj_field(_class_loader_offset);
1448 }
1449 
1450 oop java_lang_Class::module(oop java_class) {
1451   assert(_module_offset != 0, &quot;must be set&quot;);
1452   return java_class-&gt;obj_field(_module_offset);
1453 }
1454 
1455 void java_lang_Class::set_module(oop java_class, oop module) {
1456   assert(_module_offset != 0, &quot;must be set&quot;);
1457   java_class-&gt;obj_field_put(_module_offset, module);
1458 }
1459 
1460 oop java_lang_Class::name(Handle java_class, TRAPS) {
1461   assert(_name_offset != 0, &quot;must be set&quot;);
1462   oop o = java_class-&gt;obj_field(_name_offset);
1463   if (o == NULL) {
1464     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1465     java_class-&gt;obj_field_put(_name_offset, o);
1466   }
1467   return o;
1468 }
1469 
1470 oop java_lang_Class::source_file(oop java_class) {
1471   assert(_source_file_offset != 0, &quot;must be set&quot;);
1472   return java_class-&gt;obj_field(_source_file_offset);
1473 }
1474 
1475 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1476   assert(_source_file_offset != 0, &quot;must be set&quot;);
1477   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1478 }
1479 
1480 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1481   // This should be improved by adding a field at the Java level or by
1482   // introducing a new VM klass (see comment in ClassFileParser)
1483   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1484   if (type != T_VOID) {
1485     Klass* aklass = Universe::typeArrayKlassObj(type);
1486     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1487     release_set_array_klass(java_class, aklass);
1488   }
1489 #ifdef ASSERT
1490   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1491   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1492 #endif
1493   return java_class;
1494 }
1495 
1496 
1497 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1498   //%note memory_2
1499   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1500   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1501   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1502   return k;
1503 }
1504 
1505 
1506 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1507   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1508   java_class-&gt;metadata_field_put(_klass_offset, klass);
1509 }
1510 
1511 
1512 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1513   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1514   Symbol* name = NULL;
1515   bool is_instance = false;
1516   if (is_primitive(java_class)) {
1517     name = vmSymbols::type_signature(primitive_type(java_class));
1518   } else {
1519     Klass* k = as_Klass(java_class);
1520     is_instance = k-&gt;is_instance_klass();
1521     name = k-&gt;name();
1522   }
1523   if (name == NULL) {
1524     st-&gt;print(&quot;&lt;null&gt;&quot;);
1525     return;
1526   }
1527   if (is_instance)  st-&gt;print(&quot;L&quot;);
1528   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1529   if (is_instance)  st-&gt;print(&quot;;&quot;);
1530 }
1531 
1532 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1533   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1534   Symbol* name;
1535   if (is_primitive(java_class)) {
1536     name = vmSymbols::type_signature(primitive_type(java_class));
1537     // Because this can create a new symbol, the caller has to decrement
1538     // the refcount, so make adjustment here and below for symbols returned
1539     // that are not created or incremented due to a successful lookup.
1540     name-&gt;increment_refcount();
1541   } else {
1542     Klass* k = as_Klass(java_class);
1543     if (!k-&gt;is_instance_klass()) {
1544       name = k-&gt;name();
1545       name-&gt;increment_refcount();
1546     } else {
1547       ResourceMark rm;
1548       const char* sigstr = k-&gt;signature_name();
1549       int         siglen = (int) strlen(sigstr);
1550       if (!intern_if_not_found) {
1551         name = SymbolTable::probe(sigstr, siglen);
1552       } else {
1553         name = SymbolTable::new_symbol(sigstr, siglen);
1554       }
1555     }
1556   }
1557   return name;
1558 }
1559 
1560 // Returns the Java name for this Java mirror (Resource allocated)
1561 // See Klass::external_name().
1562 // For primitive type Java mirrors, its type name is returned.
1563 const char* java_lang_Class::as_external_name(oop java_class) {
1564   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1565   const char* name = NULL;
1566   if (is_primitive(java_class)) {
1567     name = type2name(primitive_type(java_class));
1568   } else {
1569     name = as_Klass(java_class)-&gt;external_name();
1570   }
1571   if (name == NULL) {
1572     name = &quot;&lt;null&gt;&quot;;
1573   }
1574   return name;
1575 }
1576 
1577 Klass* java_lang_Class::array_klass_acquire(oop java_class) {
1578   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1579   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1580   return k;
1581 }
1582 
1583 
1584 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1585   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1586   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1587 }
1588 
1589 
1590 BasicType java_lang_Class::primitive_type(oop java_class) {
1591   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1592   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1593   BasicType type = T_VOID;
1594   if (ak != NULL) {
1595     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1596     type = ArrayKlass::cast(ak)-&gt;element_type();
1597   } else {
1598     assert(java_class == Universe::void_mirror(), &quot;only valid non-array primitive&quot;);
1599   }
1600   assert(Universe::java_mirror(type) == java_class, &quot;must be consistent&quot;);
1601   return type;
1602 }
1603 
1604 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1605   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1606   if (is_primitive(java_class)) {
1607     if (reference_klass != NULL)
1608       (*reference_klass) = NULL;
1609     return primitive_type(java_class);
1610   } else {
1611     if (reference_klass != NULL)
1612       (*reference_klass) = as_Klass(java_class);
1613     return T_OBJECT;
1614   }
1615 }
1616 
1617 
1618 oop java_lang_Class::primitive_mirror(BasicType t) {
1619   oop mirror = Universe::java_mirror(t);
1620   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1621   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1622   return mirror;
1623 }
1624 
1625 #define CLASS_FIELDS_DO(macro) \
1626   macro(_classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1627   macro(_class_loader_offset,        k, &quot;classLoader&quot;,         classloader_signature, false); \
1628   macro(_component_mirror_offset,    k, &quot;componentType&quot;,       class_signature,       false); \
1629   macro(_module_offset,              k, &quot;module&quot;,              module_signature,      false); \
1630   macro(_name_offset,                k, &quot;name&quot;,                string_signature,      false); \
1631   macro(_classData_offset,           k, &quot;classData&quot;,           object_signature,      false);
1632 
1633 void java_lang_Class::compute_offsets() {
1634   if (_offsets_computed) {
1635     return;
1636   }
1637 
1638   _offsets_computed = true;
1639 
1640   InstanceKlass* k = SystemDictionary::Class_klass();
1641   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1642 
1643   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1644   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1645   // GC treats them the same.
1646   _init_lock_offset = _component_mirror_offset;
1647 
1648   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1649 }
1650 
1651 #if INCLUDE_CDS
1652 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
1653   f-&gt;do_bool(&amp;_offsets_computed);
1654   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1655 
1656   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1657 
1658   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1659 }
1660 #endif
1661 
1662 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
1663   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);
1664   return the_class_mirror-&gt;int_field(_classRedefinedCount_offset);
1665 }
1666 
1667 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
1668   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);
1669   the_class_mirror-&gt;int_field_put(_classRedefinedCount_offset, value);
1670 }
1671 
1672 
1673 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1674 //       platform thread structure, and a eetop offset which was used for thread
1675 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1676 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1677 //       instead of the privateInfo_offset.
1678 //
1679 // Note: The stackSize field is only present starting in 1.4.
1680 
1681 int java_lang_Thread::_name_offset;
1682 int java_lang_Thread::_group_offset;
1683 int java_lang_Thread::_contextClassLoader_offset;
1684 int java_lang_Thread::_inheritedAccessControlContext_offset;
1685 int java_lang_Thread::_priority_offset;
1686 int java_lang_Thread::_eetop_offset;
1687 int java_lang_Thread::_interrupted_offset;
1688 int java_lang_Thread::_daemon_offset;
1689 int java_lang_Thread::_stillborn_offset;
1690 int java_lang_Thread::_stackSize_offset;
1691 int java_lang_Thread::_tid_offset;
1692 int java_lang_Thread::_thread_status_offset;
1693 int java_lang_Thread::_park_blocker_offset;
1694 
1695 #define THREAD_FIELDS_DO(macro) \
1696   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1697   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1698   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1699   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1700   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1701   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1702   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1703   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1704   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1705   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1706   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1707   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1708   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1709 
1710 void java_lang_Thread::compute_offsets() {
1711   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1712 
1713   InstanceKlass* k = SystemDictionary::Thread_klass();
1714   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1715 }
1716 
1717 #if INCLUDE_CDS
1718 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1719   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1720 }
1721 #endif
1722 
1723 JavaThread* java_lang_Thread::thread(oop java_thread) {
1724   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1725 }
1726 
1727 
1728 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1729   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1730 }
1731 
1732 bool java_lang_Thread::interrupted(oop java_thread) {
1733   // Make sure the caller can safely access oops.
1734   assert(Thread::current()-&gt;is_VM_thread() ||
1735          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1736           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1737          &quot;Unsafe access to oop&quot;);
1738   return java_thread-&gt;bool_field_volatile(_interrupted_offset);
1739 }
1740 
1741 void java_lang_Thread::set_interrupted(oop java_thread, bool val) {
1742   // Make sure the caller can safely access oops.
1743   assert(Thread::current()-&gt;is_VM_thread() ||
1744          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1745           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1746          &quot;Unsafe access to oop&quot;);
1747   java_thread-&gt;bool_field_put_volatile(_interrupted_offset, val);
1748 }
1749 
1750 
1751 oop java_lang_Thread::name(oop java_thread) {
1752   return java_thread-&gt;obj_field(_name_offset);
1753 }
1754 
1755 
1756 void java_lang_Thread::set_name(oop java_thread, oop name) {
1757   java_thread-&gt;obj_field_put(_name_offset, name);
1758 }
1759 
1760 
1761 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1762   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
1763 }
1764 
1765 
1766 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1767   java_thread-&gt;int_field_put(_priority_offset, priority);
1768 }
1769 
1770 
1771 oop java_lang_Thread::threadGroup(oop java_thread) {
1772   return java_thread-&gt;obj_field(_group_offset);
1773 }
1774 
1775 
1776 bool java_lang_Thread::is_stillborn(oop java_thread) {
1777   return java_thread-&gt;bool_field(_stillborn_offset) != 0;
1778 }
1779 
1780 
1781 // We never have reason to turn the stillborn bit off
1782 void java_lang_Thread::set_stillborn(oop java_thread) {
1783   java_thread-&gt;bool_field_put(_stillborn_offset, true);
1784 }
1785 
1786 
1787 bool java_lang_Thread::is_alive(oop java_thread) {
1788   JavaThread* thr = java_lang_Thread::thread(java_thread);
1789   return (thr != NULL);
1790 }
1791 
1792 
1793 bool java_lang_Thread::is_daemon(oop java_thread) {
1794   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1795 }
1796 
1797 
1798 void java_lang_Thread::set_daemon(oop java_thread) {
1799   java_thread-&gt;bool_field_put(_daemon_offset, true);
1800 }
1801 
1802 oop java_lang_Thread::context_class_loader(oop java_thread) {
1803   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1804 }
1805 
1806 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1807   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1808 }
1809 
1810 
1811 jlong java_lang_Thread::stackSize(oop java_thread) {
1812   return java_thread-&gt;long_field(_stackSize_offset);
1813 }
1814 
1815 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1816 void java_lang_Thread::set_thread_status(oop java_thread,
1817                                          java_lang_Thread::ThreadStatus status) {
1818   java_thread-&gt;int_field_put(_thread_status_offset, status);
1819 }
1820 
1821 // Read thread status value from threadStatus field in java.lang.Thread java class.
1822 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1823   // Make sure the caller is operating on behalf of the VM or is
1824   // running VM code (state == _thread_in_vm).
1825   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1826          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1827          &quot;Java Thread is not running in vm&quot;);
1828   return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1829 }
1830 
1831 
1832 jlong java_lang_Thread::thread_id(oop java_thread) {
1833   return java_thread-&gt;long_field(_tid_offset);
1834 }
1835 
1836 oop java_lang_Thread::park_blocker(oop java_thread) {
1837   return java_thread-&gt;obj_field(_park_blocker_offset);
1838 }
1839 
1840 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1841   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1842   switch (status) {
1843     case NEW                      : return &quot;NEW&quot;;
1844     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1845     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1846     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1847     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1848     case PARKED                   : return &quot;WAITING (parking)&quot;;
1849     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1850     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1851     case TERMINATED               : return &quot;TERMINATED&quot;;
1852     default                       : return &quot;UNKNOWN&quot;;
1853   };
1854 }
1855 int java_lang_ThreadGroup::_parent_offset;
1856 int java_lang_ThreadGroup::_name_offset;
1857 int java_lang_ThreadGroup::_threads_offset;
1858 int java_lang_ThreadGroup::_groups_offset;
1859 int java_lang_ThreadGroup::_maxPriority_offset;
1860 int java_lang_ThreadGroup::_destroyed_offset;
1861 int java_lang_ThreadGroup::_daemon_offset;
1862 int java_lang_ThreadGroup::_nthreads_offset;
1863 int java_lang_ThreadGroup::_ngroups_offset;
1864 
1865 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1866   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1867   return java_thread_group-&gt;obj_field(_parent_offset);
1868 }
1869 
1870 // (&quot;name as oop&quot; accessor is not necessary)
1871 
1872 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1873   oop name = java_thread_group-&gt;obj_field(_name_offset);
1874   // ThreadGroup.name can be null
1875   if (name != NULL) {
1876     return java_lang_String::as_utf8_string(name);
1877   }
1878   return NULL;
1879 }
1880 
1881 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1882   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1883   return java_thread_group-&gt;int_field(_nthreads_offset);
1884 }
1885 
1886 objArrayOop java_lang_ThreadGroup::threads(oop java_thread_group) {
1887   oop threads = java_thread_group-&gt;obj_field(_threads_offset);
1888   assert(threads != NULL, &quot;threadgroups should have threads&quot;);
1889   assert(threads-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1890   return objArrayOop(threads);
1891 }
1892 
1893 int java_lang_ThreadGroup::ngroups(oop java_thread_group) {
1894   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1895   return java_thread_group-&gt;int_field(_ngroups_offset);
1896 }
1897 
1898 objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {
1899   oop groups = java_thread_group-&gt;obj_field(_groups_offset);
1900   assert(groups == NULL || groups-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1901   return objArrayOop(groups);
1902 }
1903 
1904 ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {
1905   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1906   return (ThreadPriority) java_thread_group-&gt;int_field(_maxPriority_offset);
1907 }
1908 
1909 bool java_lang_ThreadGroup::is_destroyed(oop java_thread_group) {
1910   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1911   return java_thread_group-&gt;bool_field(_destroyed_offset) != 0;
1912 }
1913 
1914 bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {
1915   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1916   return java_thread_group-&gt;bool_field(_daemon_offset) != 0;
1917 }
1918 
1919 #define THREADGROUP_FIELDS_DO(macro) \
1920   macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,       false); \
1921   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,            false); \
1922   macro(_threads_offset,     k, vmSymbols::threads_name(),     thread_array_signature,      false); \
1923   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
1924   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
1925   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
1926   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
1927   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
1928   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
1929 
1930 void java_lang_ThreadGroup::compute_offsets() {
1931   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
1932 
1933   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
1934   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1935 }
1936 
1937 #if INCLUDE_CDS
1938 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
1939   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1940 }
1941 #endif
1942 
1943 // java_lang_Throwable
1944 
1945 int java_lang_Throwable::_backtrace_offset;
1946 int java_lang_Throwable::_detailMessage_offset;
1947 int java_lang_Throwable::_stackTrace_offset;
1948 int java_lang_Throwable::_depth_offset;
1949 int java_lang_Throwable::_static_unassigned_stacktrace_offset;
1950 
1951 #define THROWABLE_FIELDS_DO(macro) \
1952   macro(_backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \
1953   macro(_detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \
1954   macro(_stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \
1955   macro(_depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \
1956   macro(_static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)
1957 
1958 void java_lang_Throwable::compute_offsets() {
1959   InstanceKlass* k = SystemDictionary::Throwable_klass();
1960   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1961 }
1962 
1963 #if INCLUDE_CDS
1964 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
1965   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1966 }
1967 #endif
1968 
1969 oop java_lang_Throwable::unassigned_stacktrace() {
1970   InstanceKlass* ik = SystemDictionary::Throwable_klass();
1971   oop base = ik-&gt;static_field_base_raw();
1972   return base-&gt;obj_field(_static_unassigned_stacktrace_offset);
1973 }
1974 
1975 oop java_lang_Throwable::backtrace(oop throwable) {
1976   return throwable-&gt;obj_field_acquire(_backtrace_offset);
1977 }
1978 
1979 
1980 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
1981   throwable-&gt;release_obj_field_put(_backtrace_offset, value);
1982 }
1983 
1984 int java_lang_Throwable::depth(oop throwable) {
1985   return throwable-&gt;int_field(_depth_offset);
1986 }
1987 
1988 void java_lang_Throwable::set_depth(oop throwable, int value) {
1989   throwable-&gt;int_field_put(_depth_offset, value);
1990 }
1991 
1992 oop java_lang_Throwable::message(oop throwable) {
1993   return throwable-&gt;obj_field(_detailMessage_offset);
1994 }
1995 
1996 
1997 // Return Symbol for detailed_message or NULL
1998 Symbol* java_lang_Throwable::detail_message(oop throwable) {
1999   PRESERVE_EXCEPTION_MARK;  // Keep original exception
2000   oop detailed_message = java_lang_Throwable::message(throwable);
2001   if (detailed_message != NULL) {
2002     return java_lang_String::as_symbol(detailed_message);
2003   }
2004   return NULL;
2005 }
2006 
2007 void java_lang_Throwable::set_message(oop throwable, oop value) {
2008   throwable-&gt;obj_field_put(_detailMessage_offset, value);
2009 }
2010 
2011 
2012 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
2013   throwable-&gt;obj_field_put(_stackTrace_offset, st_element_array);
2014 }
2015 
2016 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2017   set_stacktrace(throwable, NULL);
2018 }
2019 
2020 
2021 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2022   ResourceMark rm;
2023   Klass* k = throwable-&gt;klass();
2024   assert(k != NULL, &quot;just checking&quot;);
2025   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2026   oop msg = message(throwable);
2027   if (msg != NULL) {
2028     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2029   }
2030 }
2031 
2032 // After this many redefines, the stack trace is unreliable.
2033 const int MAX_VERSION = USHRT_MAX;
2034 
2035 static inline bool version_matches(Method* method, int version) {
2036   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2037   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2038 }
2039 
2040 // This class provides a simple wrapper over the internal structure of
2041 // exception backtrace to insulate users of the backtrace from needing
2042 // to know what it looks like.
2043 // The code of this class is not GC safe. Allocations can only happen
2044 // in expand().
2045 class BacktraceBuilder: public StackObj {
2046  friend class BacktraceIterator;
2047  private:
2048   Handle          _backtrace;
2049   objArrayOop     _head;
2050   typeArrayOop    _methods;
2051   typeArrayOop    _bcis;
2052   objArrayOop     _mirrors;
2053   typeArrayOop    _names; // Needed to insulate method name against redefinition.
2054   // True if the top frame of the backtrace is omitted because it shall be hidden.
2055   bool            _has_hidden_top_frame;
2056   int             _index;
2057   NoSafepointVerifier _nsv;
2058 
2059   enum {
2060     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2061     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2062     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2063     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2064     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2065     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2066     trace_size           = java_lang_Throwable::trace_size,
2067     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2068   };
2069 
2070   // get info out of chunks
2071   static typeArrayOop get_methods(objArrayHandle chunk) {
2072     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2073     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2074     return methods;
2075   }
2076   static typeArrayOop get_bcis(objArrayHandle chunk) {
2077     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2078     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2079     return bcis;
2080   }
2081   static objArrayOop get_mirrors(objArrayHandle chunk) {
2082     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2083     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2084     return mirrors;
2085   }
2086   static typeArrayOop get_names(objArrayHandle chunk) {
2087     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2088     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2089     return names;
2090   }
2091   static bool has_hidden_top_frame(objArrayHandle chunk) {
2092     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
2093     return hidden != NULL;
2094   }
2095 
2096  public:
2097 
2098   // constructor for new backtrace
2099   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {
2100     expand(CHECK);
2101     _backtrace = Handle(THREAD, _head);
2102     _index = 0;
2103   }
2104 
2105   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2106     _methods = get_methods(backtrace);
2107     _bcis = get_bcis(backtrace);
2108     _mirrors = get_mirrors(backtrace);
2109     _names = get_names(backtrace);
2110     _has_hidden_top_frame = has_hidden_top_frame(backtrace);
2111     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2112            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2113            _mirrors-&gt;length() == _names-&gt;length(),
2114            &quot;method and source information arrays should match&quot;);
2115 
2116     // head is the preallocated backtrace
2117     _head = backtrace();
2118     _backtrace = Handle(thread, _head);
2119     _index = 0;
2120   }
2121 
2122   void expand(TRAPS) {
2123     objArrayHandle old_head(THREAD, _head);
2124     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2125 
2126     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2127     objArrayHandle new_head(THREAD, head);
2128 
2129     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2130     typeArrayHandle new_methods(THREAD, methods);
2131 
2132     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2133     typeArrayHandle new_bcis(THREAD, bcis);
2134 
2135     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2136     objArrayHandle new_mirrors(THREAD, mirrors);
2137 
2138     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2139     typeArrayHandle new_names(THREAD, names);
2140 
2141     if (!old_head.is_null()) {
2142       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2143     }
2144     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2145     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2146     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2147     new_head-&gt;obj_at_put(trace_names_offset, new_names());
2148     new_head-&gt;obj_at_put(trace_hidden_offset, NULL);
2149 
2150     _head    = new_head();
2151     _methods = new_methods();
2152     _bcis = new_bcis();
2153     _mirrors = new_mirrors();
2154     _names  = new_names();
2155     _index = 0;
2156   }
2157 
2158   oop backtrace() {
2159     return _backtrace();
2160   }
2161 
2162   inline void push(Method* method, int bci, TRAPS) {
2163     // Smear the -1 bci to 0 since the array only holds unsigned
2164     // shorts.  The later line number lookup would just smear the -1
2165     // to a 0 even if it could be recorded.
2166     if (bci == SynchronizationEntryBCI) bci = 0;
2167 
2168     if (_index &gt;= trace_chunk_size) {
2169       methodHandle mhandle(THREAD, method);
2170       expand(CHECK);
2171       method = mhandle();
2172     }
2173 
2174     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2175     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2176 
2177     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2178     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2179     Symbol* name = method-&gt;name();
2180     _names-&gt;symbol_at_put(_index, name);
2181 
2182     // We need to save the mirrors in the backtrace to keep the class
2183     // from being unloaded while we still have this stack trace.
2184     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2185     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2186     _index++;
2187   }
2188 
2189   void set_has_hidden_top_frame(TRAPS) {
2190     if (!_has_hidden_top_frame) {
2191       // It would be nice to add java/lang/Boolean::TRUE here
2192       // to indicate that this backtrace has a hidden top frame.
2193       // But this code is used before TRUE is allocated.
2194       // Therefore let&#39;s just use an arbitrary legal oop
2195       // available right here. _methods is a short[].
2196       assert(_methods != NULL, &quot;we need a legal oop&quot;);
2197       _has_hidden_top_frame = true;
2198       _head-&gt;obj_at_put(trace_hidden_offset, _methods);
2199     }
2200   }
2201 };
2202 
2203 struct BacktraceElement : public StackObj {
2204   int _method_id;
2205   int _bci;
2206   int _version;
2207   Symbol* _name;
2208   Handle _mirror;
2209   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2210                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2211 };
2212 
2213 class BacktraceIterator : public StackObj {
2214   int _index;
2215   objArrayHandle  _result;
2216   objArrayHandle  _mirrors;
2217   typeArrayHandle _methods;
2218   typeArrayHandle _bcis;
2219   typeArrayHandle _names;
2220 
2221   void init(objArrayHandle result, Thread* thread) {
2222     // Get method id, bci, version and mirror from chunk
2223     _result = result;
2224     if (_result.not_null()) {
2225       _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));
2226       _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));
2227       _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));
2228       _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));
2229       _index = 0;
2230     }
2231   }
2232  public:
2233   BacktraceIterator(objArrayHandle result, Thread* thread) {
2234     init(result, thread);
2235     assert(_methods.is_null() || _methods-&gt;length() == java_lang_Throwable::trace_chunk_size, &quot;lengths don&#39;t match&quot;);
2236   }
2237 
2238   BacktraceElement next(Thread* thread) {
2239     BacktraceElement e (Handle(thread, _mirrors-&gt;obj_at(_index)),
2240                         _methods-&gt;ushort_at(_index),
2241                         Backtrace::version_at(_bcis-&gt;int_at(_index)),
2242                         Backtrace::bci_at(_bcis-&gt;int_at(_index)),
2243                         _names-&gt;symbol_at(_index));
2244     _index++;
2245 
2246     if (_index &gt;= java_lang_Throwable::trace_chunk_size) {
2247       int next_offset = java_lang_Throwable::trace_next_offset;
2248       // Get next chunk
2249       objArrayHandle result (thread, objArrayOop(_result-&gt;obj_at(next_offset)));
2250       init(result, thread);
2251     }
2252     return e;
2253   }
2254 
2255   bool repeat() {
2256     return _result.not_null() &amp;&amp; _mirrors-&gt;obj_at(_index) != NULL;
2257   }
2258 };
2259 
2260 
2261 // Print stack trace element to resource allocated buffer
2262 static void print_stack_element_to_stream(outputStream* st, Handle mirror, int method_id,
2263                                           int version, int bci, Symbol* name) {
2264   ResourceMark rm;
2265 
2266   // Get strings and string lengths
2267   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
2268   const char* klass_name  = holder-&gt;external_name();
2269   int buf_len = (int)strlen(klass_name);
2270 
2271   char* method_name = name-&gt;as_C_string();
2272   buf_len += (int)strlen(method_name);
2273 
2274   char* source_file_name = NULL;
2275   Symbol* source = Backtrace::get_source_file_name(holder, version);
2276   if (source != NULL) {
2277     source_file_name = source-&gt;as_C_string();
2278     buf_len += (int)strlen(source_file_name);
2279   }
2280 
2281   char *module_name = NULL, *module_version = NULL;
2282   ModuleEntry* module = holder-&gt;module();
2283   if (module-&gt;is_named()) {
2284     module_name = module-&gt;name()-&gt;as_C_string();
2285     buf_len += (int)strlen(module_name);
2286     if (module-&gt;version() != NULL) {
2287       module_version = module-&gt;version()-&gt;as_C_string();
2288       buf_len += (int)strlen(module_version);
2289     }
2290   }
2291 
2292   // Allocate temporary buffer with extra space for formatting and line number
2293   char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);
2294 
2295   // Print stack trace line in buffer
2296   sprintf(buf, &quot;\tat %s.%s(&quot;, klass_name, method_name);
2297 
2298   // Print module information
2299   if (module_name != NULL) {
2300     if (module_version != NULL) {
2301       sprintf(buf + (int)strlen(buf), &quot;%s@%s/&quot;, module_name, module_version);
2302     } else {
2303       sprintf(buf + (int)strlen(buf), &quot;%s/&quot;, module_name);
2304     }
2305   }
2306 
2307   // The method can be NULL if the requested class version is gone
2308   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
2309   if (!version_matches(method, version)) {
2310     strcat(buf, &quot;Redefined)&quot;);
2311   } else {
2312     int line_number = Backtrace::get_line_number(method, bci);
2313     if (line_number == -2) {
2314       strcat(buf, &quot;Native Method)&quot;);
2315     } else {
2316       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2317         // Sourcename and linenumber
2318         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2319       } else if (source_file_name != NULL) {
2320         // Just sourcename
2321         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2322       } else {
2323         // Neither sourcename nor linenumber
2324         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2325       }
2326       CompiledMethod* nm = method-&gt;code();
2327       if (WizardMode &amp;&amp; nm != NULL) {
2328         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2329       }
2330     }
2331   }
2332 
2333   st-&gt;print_cr(&quot;%s&quot;, buf);
2334 }
2335 
2336 void java_lang_Throwable::print_stack_element(outputStream *st, Method* method, int bci) {
2337   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2338   int method_id = method-&gt;orig_method_idnum();
2339   int version = method-&gt;constants()-&gt;version();
2340   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2341 }
2342 
2343 /**
2344  * Print the throwable message and its stack trace plus all causes by walking the
2345  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2346  */
2347 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2348   // First, print the message.
2349   print(throwable(), st);
2350   st-&gt;cr();
2351 
2352   // Now print the stack trace.
2353   Thread* THREAD = Thread::current();
2354   while (throwable.not_null()) {
2355     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2356     if (result.is_null()) {
2357       st-&gt;print_raw_cr(&quot;\t&lt;&lt;no stack trace available&gt;&gt;&quot;);
2358       return;
2359     }
2360     BacktraceIterator iter(result, THREAD);
2361 
2362     while (iter.repeat()) {
2363       BacktraceElement bte = iter.next(THREAD);
2364       print_stack_element_to_stream(st, bte._mirror, bte._method_id, bte._version, bte._bci, bte._name);
2365     }
2366     {
2367       // Call getCause() which doesn&#39;t necessarily return the _cause field.
2368       EXCEPTION_MARK;
2369       JavaValue cause(T_OBJECT);
2370       JavaCalls::call_virtual(&amp;cause,
2371                               throwable,
2372                               throwable-&gt;klass(),
2373                               vmSymbols::getCause_name(),
2374                               vmSymbols::void_throwable_signature(),
2375                               THREAD);
2376       // Ignore any exceptions. we are in the middle of exception handling. Same as classic VM.
2377       if (HAS_PENDING_EXCEPTION) {
2378         CLEAR_PENDING_EXCEPTION;
2379         throwable = Handle();
2380       } else {
2381         throwable = Handle(THREAD, (oop) cause.get_jobject());
2382         if (throwable.not_null()) {
2383           st-&gt;print(&quot;Caused by: &quot;);
2384           print(throwable(), st);
2385           st-&gt;cr();
2386         }
2387       }
2388     }
2389   }
2390 }
2391 
2392 /**
2393  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2394  */
2395 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2396   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2397   JavaValue result(T_VOID);
2398   JavaCalls::call_virtual(&amp;result,
2399                           throwable,
2400                           SystemDictionary::Throwable_klass(),
2401                           vmSymbols::printStackTrace_name(),
2402                           vmSymbols::void_method_signature(),
2403                           THREAD);
2404 }
2405 
2406 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS) {
2407   if (!StackTraceInThrowable) return;
2408   ResourceMark rm(THREAD);
2409 
2410   // Start out by clearing the backtrace for this object, in case the VM
2411   // runs out of memory while allocating the stack trace
2412   set_backtrace(throwable(), NULL);
2413   // Clear lazily constructed Java level stacktrace if refilling occurs
2414   // This is unnecessary in 1.7+ but harmless
2415   clear_stacktrace(throwable());
2416 
2417   int max_depth = MaxJavaStackTraceDepth;
2418   JavaThread* thread = (JavaThread*)THREAD;
2419 
2420   BacktraceBuilder bt(CHECK);
2421 
2422   // If there is no Java frame just return the method that was being called
2423   // with bci 0
2424   if (!thread-&gt;has_last_Java_frame()) {
2425     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2426       bt.push(method(), 0, CHECK);
2427       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2428       set_depth(throwable(), 1);
2429       set_backtrace(throwable(), bt.backtrace());
2430     }
2431     return;
2432   }
2433 
2434   // Instead of using vframe directly, this version of fill_in_stack_trace
2435   // basically handles everything by hand. This significantly improved the
2436   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2437   // See bug 6333838 for  more details.
2438   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2439   // trace as utilizing vframe.
2440 #ifdef ASSERT
2441   vframeStream st(thread);
2442 #endif
2443   int total_count = 0;
2444   RegisterMap map(thread, false);
2445   int decode_offset = 0;
2446   CompiledMethod* nm = NULL;
2447   bool skip_fillInStackTrace_check = false;
2448   bool skip_throwableInit_check = false;
2449   bool skip_hidden = !ShowHiddenFrames;
2450 
2451   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2452     Method* method = NULL;
2453     int bci = 0;
2454 
2455     // Compiled java method case.
2456     if (decode_offset != 0) {
2457       DebugInfoReadStream stream(nm, decode_offset);
2458       decode_offset = stream.read_int();
2459       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2460       bci = stream.read_bci();
2461     } else {
2462       if (fr.is_first_frame()) break;
2463       address pc = fr.pc();
2464       if (fr.is_interpreted_frame()) {
2465         address bcp = fr.interpreter_frame_bcp();
2466         method = fr.interpreter_frame_method();
2467         bci =  method-&gt;bci_from(bcp);
2468         fr = fr.sender(&amp;map);
2469       } else {
2470         CodeBlob* cb = fr.cb();
2471         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2472         // but non nmethod
2473         fr = fr.sender(&amp;map);
2474         if (cb == NULL || !cb-&gt;is_compiled()) {
2475           continue;
2476         }
2477         nm = cb-&gt;as_compiled_method();
2478         if (nm-&gt;method()-&gt;is_native()) {
2479           method = nm-&gt;method();
2480           bci = 0;
2481         } else {
2482           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2483           decode_offset = pd-&gt;scope_decode_offset();
2484           // if decode_offset is not equal to 0, it will execute the
2485           // &quot;compiled java method case&quot; at the beginning of the loop.
2486           continue;
2487         }
2488       }
2489     }
2490 #ifdef ASSERT
2491     assert(st.method() == method &amp;&amp; st.bci() == bci,
2492            &quot;Wrong stack trace&quot;);
2493     st.next();
2494 #endif
2495 
2496     // the format of the stacktrace will be:
2497     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2498     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2499     // - rest of the stack
2500 
2501     if (!skip_fillInStackTrace_check) {
2502       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2503           throwable-&gt;is_a(method-&gt;method_holder())) {
2504         continue;
2505       }
2506       else {
2507         skip_fillInStackTrace_check = true; // gone past them all
2508       }
2509     }
2510     if (!skip_throwableInit_check) {
2511       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2512 
2513       // skip &lt;init&gt; methods of the exception class and superclasses
2514       // This is simlar to classic VM.
2515       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
2516           throwable-&gt;is_a(method-&gt;method_holder())) {
2517         continue;
2518       } else {
2519         // there are none or we&#39;ve seen them all - either way stop checking
2520         skip_throwableInit_check = true;
2521       }
2522     }
2523     if (method-&gt;is_hidden()) {
2524       if (skip_hidden) {
2525         if (total_count == 0) {
2526           // The top frame will be hidden from the stack trace.
2527           bt.set_has_hidden_top_frame(CHECK);
2528         }
2529         continue;
2530       }
2531     }
2532     bt.push(method, bci, CHECK);
2533     total_count++;
2534   }
2535 
2536   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2537 
2538   // Put completed stack trace into throwable object
2539   set_backtrace(throwable(), bt.backtrace());
2540   set_depth(throwable(), total_count);
2541 }
2542 
2543 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method) {
2544   // No-op if stack trace is disabled
2545   if (!StackTraceInThrowable) {
2546     return;
2547   }
2548 
2549   // Disable stack traces for some preallocated out of memory errors
2550   if (!Universe::should_fill_in_stack_trace(throwable)) {
2551     return;
2552   }
2553 
2554   PRESERVE_EXCEPTION_MARK;
2555 
2556   JavaThread* thread = JavaThread::active();
2557   fill_in_stack_trace(throwable, method, thread);
2558   // ignore exceptions thrown during stack trace filling
2559   CLEAR_PENDING_EXCEPTION;
2560 }
2561 
2562 void java_lang_Throwable::allocate_backtrace(Handle throwable, TRAPS) {
2563   // Allocate stack trace - backtrace is created but not filled in
2564 
2565   // No-op if stack trace is disabled
2566   if (!StackTraceInThrowable) return;
2567   BacktraceBuilder bt(CHECK);   // creates a backtrace
2568   set_backtrace(throwable(), bt.backtrace());
2569 }
2570 
2571 
2572 void java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(Handle throwable) {
2573   // Fill in stack trace into preallocated backtrace (no GC)
2574 
2575   // No-op if stack trace is disabled
2576   if (!StackTraceInThrowable) return;
2577 
2578   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;sanity check&quot;);
2579 
2580   JavaThread* THREAD = JavaThread::current();
2581 
2582   objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));
2583   assert(backtrace.not_null(), &quot;backtrace should have been preallocated&quot;);
2584 
2585   ResourceMark rm(THREAD);
2586   vframeStream st(THREAD);
2587 
2588   BacktraceBuilder bt(THREAD, backtrace);
2589 
2590   // Unlike fill_in_stack_trace we do not skip fillInStackTrace or throwable init
2591   // methods as preallocated errors aren&#39;t created by &quot;java&quot; code.
2592 
2593   // fill in as much stack trace as possible
2594   int chunk_count = 0;
2595   for (;!st.at_end(); st.next()) {
2596     bt.push(st.method(), st.bci(), CHECK);
2597     chunk_count++;
2598 
2599     // Bail-out for deep stacks
2600     if (chunk_count &gt;= trace_chunk_size) break;
2601   }
2602   set_depth(throwable(), chunk_count);
2603   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), chunk_count);
2604 
2605   // We support the Throwable immutability protocol defined for Java 7.
2606   java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());
2607   assert(java_lang_Throwable::unassigned_stacktrace() != NULL, &quot;not initialized&quot;);
2608 }
2609 
2610 void java_lang_Throwable::get_stack_trace_elements(Handle throwable,
2611                                                    objArrayHandle stack_trace_array_h, TRAPS) {
2612 
2613   if (throwable.is_null() || stack_trace_array_h.is_null()) {
2614     THROW(vmSymbols::java_lang_NullPointerException());
2615   }
2616 
2617   assert(stack_trace_array_h-&gt;is_objArray(), &quot;Stack trace array should be an array of StackTraceElenent&quot;);
2618 
2619   if (stack_trace_array_h-&gt;length() != depth(throwable())) {
2620     THROW(vmSymbols::java_lang_IndexOutOfBoundsException());
2621   }
2622 
2623   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable())));
2624   BacktraceIterator iter(result, THREAD);
2625 
2626   int index = 0;
2627   while (iter.repeat()) {
2628     BacktraceElement bte = iter.next(THREAD);
2629 
2630     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2631 
2632     if (stack_trace_element.is_null()) {
2633       THROW(vmSymbols::java_lang_NullPointerException());
2634     }
2635 
2636     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2637     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2638 
2639     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2640                                          method,
2641                                          bte._version,
2642                                          bte._bci,
2643                                          bte._name, CHECK);
2644   }
2645 }
2646 
2647 bool java_lang_Throwable::get_top_method_and_bci(oop throwable, Method** method, int* bci) {
2648   Thread* THREAD = Thread::current();
2649   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));
2650   BacktraceIterator iter(result, THREAD);
2651   // No backtrace available.
2652   if (!iter.repeat()) return false;
2653 
2654   // If the exception happened in a frame that has been hidden, i.e.,
2655   // omitted from the back trace, we can not compute the message.
2656   oop hidden = ((objArrayOop)backtrace(throwable))-&gt;obj_at(trace_hidden_offset);
2657   if (hidden != NULL) {
2658     return false;
2659   }
2660 
2661   // Get first backtrace element.
2662   BacktraceElement bte = iter.next(THREAD);
2663 
2664   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2665   assert(holder != NULL, &quot;first element should be non-null&quot;);
2666   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2667 
2668   // Original version is no longer available.
2669   if (m == NULL || !version_matches(m, bte._version)) {
2670     return false;
2671   }
2672 
2673   *method = m;
2674   *bci = bte._bci;
2675   return true;
2676 }
2677 
2678 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2679   // Allocate java.lang.StackTraceElement instance
2680   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2681   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2682   if (k-&gt;should_be_initialized()) {
2683     k-&gt;initialize(CHECK_NULL);
2684   }
2685 
2686   Handle element = k-&gt;allocate_instance_handle(CHECK_NULL);
2687 
2688   int version = method-&gt;constants()-&gt;version();
2689   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_NULL);
2690   return element();
2691 }
2692 
2693 void java_lang_StackTraceElement::fill_in(Handle element,
2694                                           InstanceKlass* holder, const methodHandle&amp; method,
2695                                           int version, int bci, Symbol* name, TRAPS) {
2696   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2697 
2698   ResourceMark rm(THREAD);
2699   HandleMark hm(THREAD);
2700 
2701   // Fill in class name
2702   Handle java_class(THREAD, holder-&gt;java_mirror());
2703   oop classname = java_lang_Class::name(java_class, CHECK);
2704   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2705   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2706 
2707   oop loader = holder-&gt;class_loader();
2708   if (loader != NULL) {
2709     oop loader_name = java_lang_ClassLoader::name(loader);
2710     if (loader_name != NULL)
2711       java_lang_StackTraceElement::set_classLoaderName(element(), loader_name);
2712   }
2713 
2714   // Fill in method name
2715   oop methodname = StringTable::intern(name, CHECK);
2716   java_lang_StackTraceElement::set_methodName(element(), methodname);
2717 
2718   // Fill in module name and version
2719   ModuleEntry* module = holder-&gt;module();
2720   if (module-&gt;is_named()) {
2721     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2722     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2723     oop module_version;
2724     if (module-&gt;version() != NULL) {
2725       module_version = StringTable::intern(module-&gt;version(), CHECK);
2726     } else {
2727       module_version = NULL;
2728     }
2729     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2730   }
2731 
2732   if (method() == NULL || !version_matches(method(), version)) {
2733     // The method was redefined, accurate line number information isn&#39;t available
2734     java_lang_StackTraceElement::set_fileName(element(), NULL);
2735     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2736   } else {
2737     Symbol* source;
2738     oop source_file;
2739     int line_number;
2740     decode_file_and_line(java_class, holder, version, method, bci, source, source_file, line_number, CHECK);
2741 
2742     java_lang_StackTraceElement::set_fileName(element(), source_file);
2743     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2744   }
2745 }
2746 
2747 void java_lang_StackTraceElement::decode_file_and_line(Handle java_class,
2748                                                        InstanceKlass* holder,
2749                                                        int version,
2750                                                        const methodHandle&amp; method,
2751                                                        int bci,
2752                                                        Symbol*&amp; source,
2753                                                        oop&amp; source_file,
2754                                                        int&amp; line_number, TRAPS) {
2755   // Fill in source file name and line number.
2756   source = Backtrace::get_source_file_name(holder, version);
2757   source_file = java_lang_Class::source_file(java_class());
2758   if (source != NULL) {
2759     // Class was not redefined. We can trust its cache if set,
2760     // else we have to initialize it.
2761     if (source_file == NULL) {
2762       source_file = StringTable::intern(source, CHECK);
2763       java_lang_Class::set_source_file(java_class(), source_file);
2764     }
2765   } else {
2766     // Class was redefined. Dump the cache if it was set.
2767     if (source_file != NULL) {
2768       source_file = NULL;
2769       java_lang_Class::set_source_file(java_class(), source_file);
2770     }
2771   }
2772   line_number = Backtrace::get_line_number(method(), bci);
2773 }
2774 
2775 #if INCLUDE_JVMCI
2776 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2777                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2778   ResourceMark rm(THREAD);
2779   HandleMark hm(THREAD);
2780 
2781   filename = NULL;
2782   line_number = -1;
2783 
2784   oop source_file;
2785   int version = method-&gt;constants()-&gt;version();
2786   InstanceKlass* holder = method-&gt;method_holder();
2787   Handle java_class(THREAD, holder-&gt;java_mirror());
2788   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2789 }
2790 #endif // INCLUDE_JVMCI
2791 
2792 // java_lang_StackFrameInfo
2793 
2794 int java_lang_StackFrameInfo::_memberName_offset;
2795 int java_lang_StackFrameInfo::_bci_offset;
2796 int java_lang_StackFrameInfo::_version_offset;
2797 
2798 #define STACKFRAMEINFO_FIELDS_DO(macro) \
2799   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
2800   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)
2801 
2802 void java_lang_StackFrameInfo::compute_offsets() {
2803   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
2804   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2805   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2806 }
2807 
2808 #if INCLUDE_CDS
2809 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
2810   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2811   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
2812 }
2813 #endif
2814 
2815 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2816   HandleMark hm(THREAD);
2817   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2818   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2819   // we should expand MemberName::name when Throwable uses StackTrace
2820   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2821   return method;
2822 }
2823 
2824 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2825   // set Method* or mid/cpref
2826   HandleMark hm(THREAD);
2827   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2828   InstanceKlass* ik = method-&gt;method_holder();
2829   CallInfo info(method(), ik, CHECK);
2830   MethodHandles::init_method_MemberName(mname, info, THREAD);
2831   // set bci
2832   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2833   // method may be redefined; store the version
2834   int version = method-&gt;constants()-&gt;version();
2835   assert((jushort)version == version, &quot;version should be short&quot;);
2836   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2837 }
2838 
2839 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2840   ResourceMark rm(THREAD);
2841   HandleMark hm(THREAD);
2842   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2843   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2844   InstanceKlass* holder = InstanceKlass::cast(clazz);
2845   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2846 
2847   short version = stackFrame-&gt;short_field(_version_offset);
2848   int bci = stackFrame-&gt;int_field(_bci_offset);
2849   Symbol* name = method-&gt;name();
2850   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2851                                        version, bci, name, CHECK);
2852 }
2853 
2854 void java_lang_StackFrameInfo::set_version(oop element, short value) {
2855   element-&gt;short_field_put(_version_offset, value);
2856 }
2857 
2858 void java_lang_StackFrameInfo::set_bci(oop element, int value) {
2859   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);
2860   element-&gt;int_field_put(_bci_offset, value);
2861 }
2862 
2863 int java_lang_LiveStackFrameInfo::_monitors_offset;
2864 int java_lang_LiveStackFrameInfo::_locals_offset;
2865 int java_lang_LiveStackFrameInfo::_operands_offset;
2866 int java_lang_LiveStackFrameInfo::_mode_offset;
2867 
2868 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2869   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2870   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2871   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2872   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2873 
2874 void java_lang_LiveStackFrameInfo::compute_offsets() {
2875   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2876   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2877 }
2878 
2879 #if INCLUDE_CDS
2880 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2881   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2882 }
2883 #endif
2884 
2885 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
2886   element-&gt;obj_field_put(_monitors_offset, value);
2887 }
2888 
2889 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
2890   element-&gt;obj_field_put(_locals_offset, value);
2891 }
2892 
2893 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
2894   element-&gt;obj_field_put(_operands_offset, value);
2895 }
2896 
2897 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
2898   element-&gt;int_field_put(_mode_offset, value);
2899 }
2900 
2901 
2902 // java_lang_AccessibleObject
2903 
2904 int java_lang_reflect_AccessibleObject::_override_offset;
2905 
2906 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
2907   macro(_override_offset, k, &quot;override&quot;, bool_signature, false)
2908 
2909 void java_lang_reflect_AccessibleObject::compute_offsets() {
2910   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2911   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2912 }
2913 
2914 #if INCLUDE_CDS
2915 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2916   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2917 }
2918 #endif
2919 
2920 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
2921   return (jboolean) reflect-&gt;bool_field(_override_offset);
2922 }
2923 
2924 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
2925   reflect-&gt;bool_field_put(_override_offset, (int) value);
2926 }
2927 
2928 // java_lang_reflect_Method
2929 
2930 int java_lang_reflect_Method::_clazz_offset;
2931 int java_lang_reflect_Method::_name_offset;
2932 int java_lang_reflect_Method::_returnType_offset;
2933 int java_lang_reflect_Method::_parameterTypes_offset;
2934 int java_lang_reflect_Method::_exceptionTypes_offset;
2935 int java_lang_reflect_Method::_slot_offset;
2936 int java_lang_reflect_Method::_modifiers_offset;
2937 int java_lang_reflect_Method::_signature_offset;
2938 int java_lang_reflect_Method::_annotations_offset;
2939 int java_lang_reflect_Method::_parameter_annotations_offset;
2940 int java_lang_reflect_Method::_annotation_default_offset;
2941 
2942 #define METHOD_FIELDS_DO(macro) \
2943   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
2944   macro(_name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
2945   macro(_returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
2946   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
2947   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
2948   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
2949   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
2950   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
2951   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
2952   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
2953   macro(_annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
2954 
2955 void java_lang_reflect_Method::compute_offsets() {
2956   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
2957   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2958 }
2959 
2960 #if INCLUDE_CDS
2961 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
2962   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2963 }
2964 #endif
2965 
2966 Handle java_lang_reflect_Method::create(TRAPS) {
2967   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2968   Klass* klass = SystemDictionary::reflect_Method_klass();
2969   // This class is eagerly initialized during VM initialization, since we keep a refence
2970   // to one of the methods
2971   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
2972   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
2973 }
2974 
2975 oop java_lang_reflect_Method::clazz(oop reflect) {
2976   return reflect-&gt;obj_field(_clazz_offset);
2977 }
2978 
2979 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
2980    reflect-&gt;obj_field_put(_clazz_offset, value);
2981 }
2982 
2983 int java_lang_reflect_Method::slot(oop reflect) {
2984   return reflect-&gt;int_field(_slot_offset);
2985 }
2986 
2987 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
2988   reflect-&gt;int_field_put(_slot_offset, value);
2989 }
2990 
2991 void java_lang_reflect_Method::set_name(oop method, oop value) {
2992   method-&gt;obj_field_put(_name_offset, value);
2993 }
2994 
2995 oop java_lang_reflect_Method::return_type(oop method) {
2996   return method-&gt;obj_field(_returnType_offset);
2997 }
2998 
2999 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
3000   method-&gt;obj_field_put(_returnType_offset, value);
3001 }
3002 
3003 oop java_lang_reflect_Method::parameter_types(oop method) {
3004   return method-&gt;obj_field(_parameterTypes_offset);
3005 }
3006 
3007 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
3008   method-&gt;obj_field_put(_parameterTypes_offset, value);
3009 }
3010 
3011 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
3012   method-&gt;obj_field_put(_exceptionTypes_offset, value);
3013 }
3014 
3015 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
3016   method-&gt;int_field_put(_modifiers_offset, value);
3017 }
3018 
3019 void java_lang_reflect_Method::set_signature(oop method, oop value) {
3020   method-&gt;obj_field_put(_signature_offset, value);
3021 }
3022 
3023 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
3024   method-&gt;obj_field_put(_annotations_offset, value);
3025 }
3026 
3027 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
3028   method-&gt;obj_field_put(_parameter_annotations_offset, value);
3029 }
3030 
3031 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
3032   method-&gt;obj_field_put(_annotation_default_offset, value);
3033 }
3034 
3035 int java_lang_reflect_Constructor::_clazz_offset;
3036 int java_lang_reflect_Constructor::_parameterTypes_offset;
3037 int java_lang_reflect_Constructor::_exceptionTypes_offset;
3038 int java_lang_reflect_Constructor::_slot_offset;
3039 int java_lang_reflect_Constructor::_modifiers_offset;
3040 int java_lang_reflect_Constructor::_signature_offset;
3041 int java_lang_reflect_Constructor::_annotations_offset;
3042 int java_lang_reflect_Constructor::_parameter_annotations_offset;
3043 
3044 #define CONSTRUCTOR_FIELDS_DO(macro) \
3045   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
3046   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
3047   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
3048   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
3049   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
3050   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
3051   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
3052   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
3053 
3054 void java_lang_reflect_Constructor::compute_offsets() {
3055   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3056   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3057 }
3058 
3059 #if INCLUDE_CDS
3060 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3061   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3062 }
3063 #endif
3064 
3065 Handle java_lang_reflect_Constructor::create(TRAPS) {
3066   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3067   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3068   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3069   InstanceKlass* ik = InstanceKlass::cast(k);
3070   // Ensure it is initialized
3071   ik-&gt;initialize(CHECK_NH);
3072   return ik-&gt;allocate_instance_handle(THREAD);
3073 }
3074 
3075 oop java_lang_reflect_Constructor::clazz(oop reflect) {
3076   return reflect-&gt;obj_field(_clazz_offset);
3077 }
3078 
3079 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
3080    reflect-&gt;obj_field_put(_clazz_offset, value);
3081 }
3082 
3083 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
3084   return constructor-&gt;obj_field(_parameterTypes_offset);
3085 }
3086 
3087 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
3088   constructor-&gt;obj_field_put(_parameterTypes_offset, value);
3089 }
3090 
3091 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
3092   constructor-&gt;obj_field_put(_exceptionTypes_offset, value);
3093 }
3094 
3095 int java_lang_reflect_Constructor::slot(oop reflect) {
3096   return reflect-&gt;int_field(_slot_offset);
3097 }
3098 
3099 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
3100   reflect-&gt;int_field_put(_slot_offset, value);
3101 }
3102 
3103 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
3104   constructor-&gt;int_field_put(_modifiers_offset, value);
3105 }
3106 
3107 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
3108   constructor-&gt;obj_field_put(_signature_offset, value);
3109 }
3110 
3111 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
3112   constructor-&gt;obj_field_put(_annotations_offset, value);
3113 }
3114 
3115 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
3116   method-&gt;obj_field_put(_parameter_annotations_offset, value);
3117 }
3118 
3119 int java_lang_reflect_Field::_clazz_offset;
3120 int java_lang_reflect_Field::_name_offset;
3121 int java_lang_reflect_Field::_type_offset;
3122 int java_lang_reflect_Field::_slot_offset;
3123 int java_lang_reflect_Field::_modifiers_offset;
3124 int java_lang_reflect_Field::_trusted_final_offset;
3125 int java_lang_reflect_Field::_signature_offset;
3126 int java_lang_reflect_Field::_annotations_offset;
3127 
3128 #define FIELD_FIELDS_DO(macro) \
3129   macro(_clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
3130   macro(_name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
3131   macro(_type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
3132   macro(_slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
3133   macro(_modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
3134   macro(_trusted_final_offset,    k, vmSymbols::trusted_final_name(),    bool_signature,       false); \
3135   macro(_signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
3136   macro(_annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
3137 
3138 void java_lang_reflect_Field::compute_offsets() {
3139   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3140   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3141 }
3142 
3143 #if INCLUDE_CDS
3144 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3145   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3146 }
3147 #endif
3148 
3149 Handle java_lang_reflect_Field::create(TRAPS) {
3150   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3151   Symbol* name = vmSymbols::java_lang_reflect_Field();
3152   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3153   InstanceKlass* ik = InstanceKlass::cast(k);
3154   // Ensure it is initialized
3155   ik-&gt;initialize(CHECK_NH);
3156   return ik-&gt;allocate_instance_handle(THREAD);
3157 }
3158 
3159 oop java_lang_reflect_Field::clazz(oop reflect) {
3160   return reflect-&gt;obj_field(_clazz_offset);
3161 }
3162 
3163 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
3164   reflect-&gt;obj_field_put(_clazz_offset, value);
3165 }
3166 
3167 oop java_lang_reflect_Field::name(oop field) {
3168   return field-&gt;obj_field(_name_offset);
3169 }
3170 
3171 void java_lang_reflect_Field::set_name(oop field, oop value) {
3172   field-&gt;obj_field_put(_name_offset, value);
3173 }
3174 
3175 oop java_lang_reflect_Field::type(oop field) {
3176   return field-&gt;obj_field(_type_offset);
3177 }
3178 
3179 void java_lang_reflect_Field::set_type(oop field, oop value) {
3180   field-&gt;obj_field_put(_type_offset, value);
3181 }
3182 
3183 int java_lang_reflect_Field::slot(oop reflect) {
3184   return reflect-&gt;int_field(_slot_offset);
3185 }
3186 
3187 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
3188   reflect-&gt;int_field_put(_slot_offset, value);
3189 }
3190 
3191 int java_lang_reflect_Field::modifiers(oop field) {
3192   return field-&gt;int_field(_modifiers_offset);
3193 }
3194 
3195 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3196   field-&gt;int_field_put(_modifiers_offset, value);
3197 }
3198 
3199 void java_lang_reflect_Field::set_trusted_final(oop field) {
3200   field-&gt;bool_field_put(_trusted_final_offset, true);
3201 }
3202 
3203 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3204   field-&gt;obj_field_put(_signature_offset, value);
3205 }
3206 
3207 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3208   field-&gt;obj_field_put(_annotations_offset, value);
3209 }
3210 
3211 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3212   // Allocate java.lang.reflect.RecordComponent instance
3213   HandleMark hm(THREAD);
3214   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3215   assert(ik != NULL, &quot;must be loaded&quot;);
3216   ik-&gt;initialize(CHECK_NULL);
3217 
3218   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3219 
3220   Handle decl_class(THREAD, holder-&gt;java_mirror());
3221   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3222 
3223   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3224   oop component_name = StringTable::intern(name, CHECK_NULL);
3225   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3226 
3227   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3228   Handle component_type_h =
3229     SystemDictionary::find_java_mirror_for_type(type, holder, SignatureStream::NCDFError, CHECK_NULL);
3230   java_lang_reflect_RecordComponent::set_type(element(), component_type_h());
3231 
3232   Method* accessor_method = NULL;
3233   {
3234     // Prepend &quot;()&quot; to type to create the full method signature.
3235     ResourceMark rm(THREAD);
3236     int sig_len = type-&gt;utf8_length() + 3; // &quot;()&quot; and null char
3237     char* sig = NEW_RESOURCE_ARRAY(char, sig_len);
3238     jio_snprintf(sig, sig_len, &quot;%c%c%s&quot;, JVM_SIGNATURE_FUNC, JVM_SIGNATURE_ENDFUNC, type-&gt;as_C_string());
3239     TempNewSymbol full_sig = SymbolTable::new_symbol(sig);
3240     accessor_method = holder-&gt;find_instance_method(name, full_sig, Klass::find_private);
3241   }
3242 
3243   if (accessor_method != NULL) {
3244     methodHandle method(THREAD, accessor_method);
3245     oop m = Reflection::new_method(method, false, CHECK_NULL);
3246     java_lang_reflect_RecordComponent::set_accessor(element(), m);
3247   } else {
3248     java_lang_reflect_RecordComponent::set_accessor(element(), NULL);
3249   }
3250 
3251   int sig_index = component-&gt;generic_signature_index();
3252   if (sig_index &gt; 0) {
3253     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3254     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3255     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3256   } else {
3257     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3258   }
3259 
3260   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3261   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3262 
3263   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3264   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3265 
3266   return element();
3267 }
3268 
3269 int reflect_ConstantPool::_oop_offset;
3270 
3271 #define CONSTANTPOOL_FIELDS_DO(macro) \
3272   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3273 
3274 void reflect_ConstantPool::compute_offsets() {
3275   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3276   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3277   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3278 }
3279 
3280 #if INCLUDE_CDS
3281 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3282   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3283 }
3284 #endif
3285 
3286 int java_lang_reflect_Parameter::_name_offset;
3287 int java_lang_reflect_Parameter::_modifiers_offset;
3288 int java_lang_reflect_Parameter::_index_offset;
3289 int java_lang_reflect_Parameter::_executable_offset;
3290 
3291 #define PARAMETER_FIELDS_DO(macro) \
3292   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3293   macro(_modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3294   macro(_index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3295   macro(_executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
3296 
3297 void java_lang_reflect_Parameter::compute_offsets() {
3298   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3299   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3300 }
3301 
3302 #if INCLUDE_CDS
3303 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3304   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3305 }
3306 #endif
3307 
3308 Handle java_lang_reflect_Parameter::create(TRAPS) {
3309   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3310   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3311   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3312   InstanceKlass* ik = InstanceKlass::cast(k);
3313   // Ensure it is initialized
3314   ik-&gt;initialize(CHECK_NH);
3315   return ik-&gt;allocate_instance_handle(THREAD);
3316 }
3317 
3318 oop java_lang_reflect_Parameter::name(oop param) {
3319   return param-&gt;obj_field(_name_offset);
3320 }
3321 
3322 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
3323   param-&gt;obj_field_put(_name_offset, value);
3324 }
3325 
3326 int java_lang_reflect_Parameter::modifiers(oop param) {
3327   return param-&gt;int_field(_modifiers_offset);
3328 }
3329 
3330 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
3331   param-&gt;int_field_put(_modifiers_offset, value);
3332 }
3333 
3334 int java_lang_reflect_Parameter::index(oop param) {
3335   return param-&gt;int_field(_index_offset);
3336 }
3337 
3338 void java_lang_reflect_Parameter::set_index(oop param, int value) {
3339   param-&gt;int_field_put(_index_offset, value);
3340 }
3341 
3342 oop java_lang_reflect_Parameter::executable(oop param) {
3343   return param-&gt;obj_field(_executable_offset);
3344 }
3345 
3346 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
3347   param-&gt;obj_field_put(_executable_offset, value);
3348 }
3349 
3350 // java_lang_Module
3351 
3352 int java_lang_Module::_loader_offset;
3353 int java_lang_Module::_name_offset;
3354 int java_lang_Module::_module_entry_offset;
3355 
3356 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3357   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3358   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3359                           vmSymbols::java_lang_module_init_signature(),
3360                           loader, module_name, CHECK_NH);
3361 }
3362 
3363 #define MODULE_FIELDS_DO(macro) \
3364   macro(_loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
3365   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
3366 
3367 void java_lang_Module::compute_offsets() {
3368   InstanceKlass* k = SystemDictionary::Module_klass();
3369   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3370   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3371 }
3372 
3373 #if INCLUDE_CDS
3374 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3375   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3376   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3377 }
3378 #endif
3379 
3380 oop java_lang_Module::loader(oop module) {
3381   return module-&gt;obj_field(_loader_offset);
3382 }
3383 
3384 void java_lang_Module::set_loader(oop module, oop value) {
3385   module-&gt;obj_field_put(_loader_offset, value);
3386 }
3387 
3388 oop java_lang_Module::name(oop module) {
3389   return module-&gt;obj_field(_name_offset);
3390 }
3391 
3392 void java_lang_Module::set_name(oop module, oop value) {
3393   module-&gt;obj_field_put(_name_offset, value);
3394 }
3395 
3396 ModuleEntry* java_lang_Module::module_entry(oop module) {
3397   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);
3398   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3399   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3400 
3401   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3402   if (module_entry == NULL) {
3403     // If the inject field containing the ModuleEntry* is null then return the
3404     // class loader&#39;s unnamed module.
3405     oop loader = java_lang_Module::loader(module);
3406     Handle h_loader = Handle(Thread::current(), loader);
3407     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3408     return loader_cld-&gt;unnamed_module();
3409   }
3410   return module_entry;
3411 }
3412 
3413 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
3414   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);
3415   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3416   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3417   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3418 }
3419 
3420 Handle reflect_ConstantPool::create(TRAPS) {
3421   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3422   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3423   // Ensure it is initialized
3424   k-&gt;initialize(CHECK_NH);
3425   return k-&gt;allocate_instance_handle(THREAD);
3426 }
3427 
3428 
3429 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
3430   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3431   // Save the mirror to get back the constant pool.
3432   reflect-&gt;obj_field_put(_oop_offset, mirror);
3433 }
3434 
3435 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
3436 
3437   oop mirror = reflect-&gt;obj_field(_oop_offset);
3438   Klass* k = java_lang_Class::as_Klass(mirror);
3439   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3440 
3441   // Get the constant pool back from the klass.  Since class redefinition
3442   // merges the new constant pool into the old, this is essentially the
3443   // same constant pool as the original.  If constant pool merging is
3444   // no longer done in the future, this will have to change to save
3445   // the original.
3446   return InstanceKlass::cast(k)-&gt;constants();
3447 }
3448 
3449 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
3450 
3451 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3452   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3453 
3454 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3455   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3456   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3457 }
3458 
3459 #if INCLUDE_CDS
3460 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3461   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3462 }
3463 #endif
3464 
3465 // Support for java_lang_ref_Reference
3466 
3467 bool java_lang_ref_Reference::_offsets_initialized;
3468 
3469 int java_lang_ref_Reference::_referent_offset;
3470 int java_lang_ref_Reference::_queue_offset;
3471 int java_lang_ref_Reference::_next_offset;
3472 int java_lang_ref_Reference::_discovered_offset;
3473 
3474 #define REFERENCE_FIELDS_DO(macro) \
3475   macro(_referent_offset,   k, &quot;referent&quot;, object_signature, false); \
3476   macro(_queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \
3477   macro(_next_offset,       k, &quot;next&quot;, reference_signature, false); \
3478   macro(_discovered_offset, k, &quot;discovered&quot;, reference_signature, false);
3479 
3480 void java_lang_ref_Reference::compute_offsets() {
3481   if (_offsets_initialized) {
3482     return;
3483   }
3484   _offsets_initialized = true;
3485   InstanceKlass* k = SystemDictionary::Reference_klass();
3486   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3487 }
3488 
3489 #if INCLUDE_CDS
3490 void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {
3491   f-&gt;do_bool(&amp;_offsets_initialized);
3492   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3493 }
3494 #endif
3495 
3496 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3497   assert(obj != NULL, &quot;sanity&quot;);
3498   if (offset != _referent_offset) {
3499     return false;
3500   }
3501 
3502   Klass* k = obj-&gt;klass();
3503   if (!k-&gt;is_instance_klass()) {
3504     return false;
3505   }
3506 
3507   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3508   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3509   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3510   return is_reference;
3511 }
3512 
3513 int java_lang_boxing_object::_value_offset;
3514 int java_lang_boxing_object::_long_value_offset;
3515 
3516 #define BOXING_FIELDS_DO(macro) \
3517   macro(_value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \
3518   macro(_long_value_offset, longKlass, &quot;value&quot;, long_signature, false);
3519 
3520 void java_lang_boxing_object::compute_offsets() {
3521   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();
3522   InstanceKlass* longKlass = SystemDictionary::Long_klass();
3523   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3524 }
3525 
3526 #if INCLUDE_CDS
3527 void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {
3528   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3529 }
3530 #endif
3531 
3532 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3533   Klass* k = SystemDictionary::box_klass(type);
3534   if (k == NULL)  return NULL;
3535   InstanceKlass* ik = InstanceKlass::cast(k);
3536   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3537   return ik-&gt;allocate_instance(THREAD);
3538 }
3539 
3540 
3541 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3542   oop box = initialize_and_allocate(type, CHECK_NULL);
3543   if (box == NULL)  return NULL;
3544   switch (type) {
3545     case T_BOOLEAN:
3546       box-&gt;bool_field_put(_value_offset, value-&gt;z);
3547       break;
3548     case T_CHAR:
3549       box-&gt;char_field_put(_value_offset, value-&gt;c);
3550       break;
3551     case T_FLOAT:
3552       box-&gt;float_field_put(_value_offset, value-&gt;f);
3553       break;
3554     case T_DOUBLE:
3555       box-&gt;double_field_put(_long_value_offset, value-&gt;d);
3556       break;
3557     case T_BYTE:
3558       box-&gt;byte_field_put(_value_offset, value-&gt;b);
3559       break;
3560     case T_SHORT:
3561       box-&gt;short_field_put(_value_offset, value-&gt;s);
3562       break;
3563     case T_INT:
3564       box-&gt;int_field_put(_value_offset, value-&gt;i);
3565       break;
3566     case T_LONG:
3567       box-&gt;long_field_put(_long_value_offset, value-&gt;j);
3568       break;
3569     default:
3570       return NULL;
3571   }
3572   return box;
3573 }
3574 
3575 
3576 BasicType java_lang_boxing_object::basic_type(oop box) {
3577   if (box == NULL)  return T_ILLEGAL;
3578   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3579   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3580     return T_ILLEGAL;
3581   return type;
3582 }
3583 
3584 
3585 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3586   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3587   switch (type) {
3588   case T_BOOLEAN:
3589     value-&gt;z = box-&gt;bool_field(_value_offset);
3590     break;
3591   case T_CHAR:
3592     value-&gt;c = box-&gt;char_field(_value_offset);
3593     break;
3594   case T_FLOAT:
3595     value-&gt;f = box-&gt;float_field(_value_offset);
3596     break;
3597   case T_DOUBLE:
3598     value-&gt;d = box-&gt;double_field(_long_value_offset);
3599     break;
3600   case T_BYTE:
3601     value-&gt;b = box-&gt;byte_field(_value_offset);
3602     break;
3603   case T_SHORT:
3604     value-&gt;s = box-&gt;short_field(_value_offset);
3605     break;
3606   case T_INT:
3607     value-&gt;i = box-&gt;int_field(_value_offset);
3608     break;
3609   case T_LONG:
3610     value-&gt;j = box-&gt;long_field(_long_value_offset);
3611     break;
3612   default:
3613     return T_ILLEGAL;
3614   } // end switch
3615   return type;
3616 }
3617 
3618 
3619 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3620   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3621   switch (type) {
3622   case T_BOOLEAN:
3623     box-&gt;bool_field_put(_value_offset, value-&gt;z);
3624     break;
3625   case T_CHAR:
3626     box-&gt;char_field_put(_value_offset, value-&gt;c);
3627     break;
3628   case T_FLOAT:
3629     box-&gt;float_field_put(_value_offset, value-&gt;f);
3630     break;
3631   case T_DOUBLE:
3632     box-&gt;double_field_put(_long_value_offset, value-&gt;d);
3633     break;
3634   case T_BYTE:
3635     box-&gt;byte_field_put(_value_offset, value-&gt;b);
3636     break;
3637   case T_SHORT:
3638     box-&gt;short_field_put(_value_offset, value-&gt;s);
3639     break;
3640   case T_INT:
3641     box-&gt;int_field_put(_value_offset, value-&gt;i);
3642     break;
3643   case T_LONG:
3644     box-&gt;long_field_put(_long_value_offset, value-&gt;j);
3645     break;
3646   default:
3647     return T_ILLEGAL;
3648   } // end switch
3649   return type;
3650 }
3651 
3652 
3653 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3654   switch (type) {
3655   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3656   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3657   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3658   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3659   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3660   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3661   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3662   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3663   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3664   }
3665 }
3666 
3667 
3668 // Support for java_lang_ref_SoftReference
3669 //
3670 
3671 int java_lang_ref_SoftReference::_timestamp_offset;
3672 int java_lang_ref_SoftReference::_static_clock_offset;
3673 
3674 #define SOFTREFERENCE_FIELDS_DO(macro) \
3675   macro(_timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3676   macro(_static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3677 
3678 void java_lang_ref_SoftReference::compute_offsets() {
3679   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3680   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3681 }
3682 
3683 #if INCLUDE_CDS
3684 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3685   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3686 }
3687 #endif
3688 
3689 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3690   return ref-&gt;long_field(_timestamp_offset);
3691 }
3692 
3693 jlong java_lang_ref_SoftReference::clock() {
3694   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3695   oop base = ik-&gt;static_field_base_raw();
3696   return base-&gt;long_field(_static_clock_offset);
3697 }
3698 
3699 void java_lang_ref_SoftReference::set_clock(jlong value) {
3700   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3701   oop base = ik-&gt;static_field_base_raw();
3702   base-&gt;long_field_put(_static_clock_offset, value);
3703 }
3704 
3705 // Support for java_lang_invoke_DirectMethodHandle
3706 
3707 int java_lang_invoke_DirectMethodHandle::_member_offset;
3708 
3709 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3710   oop member_name = NULL;
3711   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3712          &quot;a DirectMethodHandle oop is expected&quot;);
3713   return dmh-&gt;obj_field(_member_offset);
3714 }
3715 
3716 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3717   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3718 
3719 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3720   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3721   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3722 }
3723 
3724 #if INCLUDE_CDS
3725 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3726   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3727 }
3728 #endif
3729 
3730 // Support for java_lang_invoke_MethodHandle
3731 
3732 int java_lang_invoke_MethodHandle::_type_offset;
3733 int java_lang_invoke_MethodHandle::_form_offset;
3734 
3735 int java_lang_invoke_MemberName::_clazz_offset;
3736 int java_lang_invoke_MemberName::_name_offset;
3737 int java_lang_invoke_MemberName::_type_offset;
3738 int java_lang_invoke_MemberName::_flags_offset;
3739 int java_lang_invoke_MemberName::_method_offset;
3740 int java_lang_invoke_MemberName::_vmindex_offset;
3741 
3742 int java_lang_invoke_ResolvedMethodName::_vmtarget_offset;
3743 int java_lang_invoke_ResolvedMethodName::_vmholder_offset;
3744 
3745 int java_lang_invoke_LambdaForm::_vmentry_offset;
3746 
3747 #define METHODHANDLE_FIELDS_DO(macro) \
3748   macro(_type_offset, k, vmSymbols::type_name(), java_lang_invoke_MethodType_signature, false); \
3749   macro(_form_offset, k, &quot;form&quot;,                 java_lang_invoke_LambdaForm_signature, false)
3750 
3751 void java_lang_invoke_MethodHandle::compute_offsets() {
3752   InstanceKlass* k = SystemDictionary::MethodHandle_klass();
3753   METHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3754 }
3755 
3756 #if INCLUDE_CDS
3757 void java_lang_invoke_MethodHandle::serialize_offsets(SerializeClosure* f) {
3758   METHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3759 }
3760 #endif
3761 
3762 #define MEMBERNAME_FIELDS_DO(macro) \
3763   macro(_clazz_offset,   k, vmSymbols::clazz_name(),   class_signature,  false); \
3764   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature, false); \
3765   macro(_type_offset,    k, vmSymbols::type_name(),    object_signature, false); \
3766   macro(_flags_offset,   k, vmSymbols::flags_name(),   int_signature,    false); \
3767   macro(_method_offset,  k, vmSymbols::method_name(),  java_lang_invoke_ResolvedMethodName_signature, false)
3768 
3769 void java_lang_invoke_MemberName::compute_offsets() {
3770   InstanceKlass* k = SystemDictionary::MemberName_klass();
3771   MEMBERNAME_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3772   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3773 }
3774 
3775 #if INCLUDE_CDS
3776 void java_lang_invoke_MemberName::serialize_offsets(SerializeClosure* f) {
3777   MEMBERNAME_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3778   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3779 }
3780 #endif
3781 
3782 void java_lang_invoke_ResolvedMethodName::compute_offsets() {
3783   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3784   assert(k != NULL, &quot;jdk mismatch&quot;);
3785   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3786 }
3787 
3788 #if INCLUDE_CDS
3789 void java_lang_invoke_ResolvedMethodName::serialize_offsets(SerializeClosure* f) {
3790   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3791 }
3792 #endif
3793 
3794 #define LAMBDAFORM_FIELDS_DO(macro) \
3795   macro(_vmentry_offset, k, &quot;vmentry&quot;, java_lang_invoke_MemberName_signature, false)
3796 
3797 void java_lang_invoke_LambdaForm::compute_offsets() {
3798   InstanceKlass* k = SystemDictionary::LambdaForm_klass();
3799   assert (k != NULL, &quot;jdk mismatch&quot;);
3800   LAMBDAFORM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3801 }
3802 
3803 #if INCLUDE_CDS
3804 void java_lang_invoke_LambdaForm::serialize_offsets(SerializeClosure* f) {
3805   LAMBDAFORM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3806 }
3807 #endif
3808 
3809 bool java_lang_invoke_LambdaForm::is_instance(oop obj) {
3810   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3811 }
3812 
3813 int jdk_internal_invoke_NativeEntryPoint::_addr_offset;
3814 int jdk_internal_invoke_NativeEntryPoint::_shadow_space_offset;
3815 int jdk_internal_invoke_NativeEntryPoint::_argMoves_offset;
3816 int jdk_internal_invoke_NativeEntryPoint::_returnMoves_offset;
3817 int jdk_internal_invoke_NativeEntryPoint::_need_transition_offset;
3818 int jdk_internal_invoke_NativeEntryPoint::_method_type_offset;
3819 int jdk_internal_invoke_NativeEntryPoint::_name_offset;
3820 
3821 #define NEP_FIELDS_DO(macro) \
3822   macro(_addr_offset,            k, &quot;addr&quot;,           long_signature, false); \
3823   macro(_shadow_space_offset,    k, &quot;shadowSpace&quot;,    int_signature, false); \
3824   macro(_argMoves_offset,        k, &quot;argMoves&quot;,       long_array_signature, false); \
3825   macro(_returnMoves_offset,     k, &quot;returnMoves&quot;,    long_array_signature, false); \
3826   macro(_need_transition_offset, k, &quot;needTransition&quot;, bool_signature, false); \
3827   macro(_method_type_offset,     k, &quot;methodType&quot;,     java_lang_invoke_MethodType_signature, false); \
3828   macro(_name_offset,            k, &quot;name&quot;,           string_signature, false);
3829 
3830 bool jdk_internal_invoke_NativeEntryPoint::is_instance(oop obj) {
3831   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3832 }
3833 
3834 void jdk_internal_invoke_NativeEntryPoint::compute_offsets() {
3835   InstanceKlass* k = SystemDictionary::NativeEntryPoint_klass();
3836   NEP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3837 }
3838 
3839 #if INCLUDE_CDS
3840 void jdk_internal_invoke_NativeEntryPoint::serialize_offsets(SerializeClosure* f) {
3841   NEP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3842 }
3843 #endif
3844 
3845 address jdk_internal_invoke_NativeEntryPoint::addr(oop entry) {
3846   return (address)entry-&gt;long_field(_addr_offset);
3847 }
3848 
3849 jint jdk_internal_invoke_NativeEntryPoint::shadow_space(oop entry) {
3850   return entry-&gt;int_field(_shadow_space_offset);
3851 }
3852 
3853 oop jdk_internal_invoke_NativeEntryPoint::argMoves(oop entry) {
3854   return entry-&gt;obj_field(_argMoves_offset);
3855 }
3856 
3857 oop jdk_internal_invoke_NativeEntryPoint::returnMoves(oop entry) {
3858   return entry-&gt;obj_field(_returnMoves_offset);
3859 }
3860 
3861 jboolean jdk_internal_invoke_NativeEntryPoint::need_transition(oop entry) {
3862   return entry-&gt;bool_field(_need_transition_offset);
3863 }
3864 
3865 oop jdk_internal_invoke_NativeEntryPoint::method_type(oop entry) {
3866   return entry-&gt;obj_field(_method_type_offset);
3867 }
3868 
3869 oop jdk_internal_invoke_NativeEntryPoint::name(oop entry) {
3870   return entry-&gt;obj_field(_name_offset);
3871 }
3872 
3873 oop java_lang_invoke_MethodHandle::type(oop mh) {
3874   return mh-&gt;obj_field(_type_offset);
3875 }
3876 
3877 void java_lang_invoke_MethodHandle::set_type(oop mh, oop mtype) {
3878   mh-&gt;obj_field_put(_type_offset, mtype);
3879 }
3880 
3881 oop java_lang_invoke_MethodHandle::form(oop mh) {
3882   assert(_form_offset != 0, &quot;&quot;);
3883   return mh-&gt;obj_field(_form_offset);
3884 }
3885 
3886 void java_lang_invoke_MethodHandle::set_form(oop mh, oop lform) {
3887   assert(_form_offset != 0, &quot;&quot;);
3888   mh-&gt;obj_field_put(_form_offset, lform);
3889 }
3890 
3891 /// MemberName accessors
3892 
3893 oop java_lang_invoke_MemberName::clazz(oop mname) {
3894   assert(is_instance(mname), &quot;wrong type&quot;);
3895   return mname-&gt;obj_field(_clazz_offset);
3896 }
3897 
3898 void java_lang_invoke_MemberName::set_clazz(oop mname, oop clazz) {
3899   assert(is_instance(mname), &quot;wrong type&quot;);
3900   mname-&gt;obj_field_put(_clazz_offset, clazz);
3901 }
3902 
3903 oop java_lang_invoke_MemberName::name(oop mname) {
3904   assert(is_instance(mname), &quot;wrong type&quot;);
3905   return mname-&gt;obj_field(_name_offset);
3906 }
3907 
3908 void java_lang_invoke_MemberName::set_name(oop mname, oop name) {
3909   assert(is_instance(mname), &quot;wrong type&quot;);
3910   mname-&gt;obj_field_put(_name_offset, name);
3911 }
3912 
3913 oop java_lang_invoke_MemberName::type(oop mname) {
3914   assert(is_instance(mname), &quot;wrong type&quot;);
3915   return mname-&gt;obj_field(_type_offset);
3916 }
3917 
3918 void java_lang_invoke_MemberName::set_type(oop mname, oop type) {
3919   assert(is_instance(mname), &quot;wrong type&quot;);
3920   mname-&gt;obj_field_put(_type_offset, type);
3921 }
3922 
3923 int java_lang_invoke_MemberName::flags(oop mname) {
3924   assert(is_instance(mname), &quot;wrong type&quot;);
3925   return mname-&gt;int_field(_flags_offset);
3926 }
3927 
3928 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3929   assert(is_instance(mname), &quot;wrong type&quot;);
3930   mname-&gt;int_field_put(_flags_offset, flags);
3931 }
3932 
3933 
3934 // Return vmtarget from ResolvedMethodName method field through indirection
3935 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3936   assert(is_instance(mname), &quot;wrong type&quot;);
3937   oop method = mname-&gt;obj_field(_method_offset);
3938   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3939 }
3940 
3941 bool java_lang_invoke_MemberName::is_method(oop mname) {
3942   assert(is_instance(mname), &quot;must be MemberName&quot;);
3943   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;
3944 }
3945 
3946 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3947   assert(is_instance(mname), &quot;wrong type&quot;);
3948   mname-&gt;obj_field_put(_method_offset, resolved_method);
3949 }
3950 
3951 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3952   assert(is_instance(mname), &quot;wrong type&quot;);
3953   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3954 }
3955 
3956 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3957   assert(is_instance(mname), &quot;wrong type&quot;);
3958   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3959 }
3960 
3961 
3962 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3963   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3964   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
3965   assert(m-&gt;is_method(), &quot;must be&quot;);
3966   return m;
3967 }
3968 
3969 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
3970 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
3971   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3972   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
3973 }
3974 
3975 void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop holder) {
3976   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3977   resolved_method-&gt;obj_field_put(_vmholder_offset, holder);
3978 }
3979 
3980 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
3981   const Method* method = m();
3982 
3983   // lookup ResolvedMethod oop in the table, or create a new one and intern it
3984   oop resolved_method = ResolvedMethodTable::find_method(method);
3985   if (resolved_method != NULL) {
3986     return resolved_method;
3987   }
3988 
3989   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3990   if (!k-&gt;is_initialized()) {
3991     k-&gt;initialize(CHECK_NULL);
3992   }
3993 
3994   oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);
3995 
3996   NoSafepointVerifier nsv;
3997 
3998   if (method-&gt;is_old()) {
3999     method = (method-&gt;is_deleted()) ? Universe::throw_no_such_method_error() :
4000                                       method-&gt;get_new_method();
4001   }
4002 
4003   InstanceKlass* holder = method-&gt;method_holder();
4004 
4005   set_vmtarget(new_resolved_method, const_cast&lt;Method*&gt;(method));
4006   // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have
4007   // distinct loaders) to ensure the metadata is kept alive.
4008   // This mirror may be different than the one in clazz field.
4009   set_vmholder(new_resolved_method, holder-&gt;java_mirror());
4010 
4011   // Set flag in class to indicate this InstanceKlass has entries in the table
4012   // to avoid walking table during redefinition if none of the redefined classes
4013   // have any membernames in the table.
4014   holder-&gt;set_has_resolved_methods();
4015 
4016   return ResolvedMethodTable::add_method(method, Handle(THREAD, new_resolved_method));
4017 }
4018 
4019 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
4020   assert(is_instance(lform), &quot;wrong type&quot;);
4021   return lform-&gt;obj_field(_vmentry_offset);
4022 }
4023 
4024 
4025 // Support for java_lang_invoke_MethodType
4026 
4027 int java_lang_invoke_MethodType::_rtype_offset;
4028 int java_lang_invoke_MethodType::_ptypes_offset;
4029 
4030 #define METHODTYPE_FIELDS_DO(macro) \
4031   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
4032   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
4033 
4034 void java_lang_invoke_MethodType::compute_offsets() {
4035   InstanceKlass* k = SystemDictionary::MethodType_klass();
4036   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4037 }
4038 
4039 #if INCLUDE_CDS
4040 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
4041   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4042 }
4043 #endif
4044 
4045 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
4046   st-&gt;print(&quot;(&quot;);
4047   objArrayOop pts = ptypes(mt);
4048   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
4049     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
4050   }
4051   st-&gt;print(&quot;)&quot;);
4052   java_lang_Class::print_signature(rtype(mt), st);
4053 }
4054 
4055 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found) {
4056   ResourceMark rm;
4057   stringStream buffer(128);
4058   print_signature(mt, &amp;buffer);
4059   const char* sigstr =       buffer.base();
4060   int         siglen = (int) buffer.size();
4061   Symbol *name;
4062   if (!intern_if_not_found) {
4063     name = SymbolTable::probe(sigstr, siglen);
4064   } else {
4065     name = SymbolTable::new_symbol(sigstr, siglen);
4066   }
4067   return name;
4068 }
4069 
4070 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
4071   if (mt1 == mt2)
4072     return true;
4073   if (rtype(mt1) != rtype(mt2))
4074     return false;
4075   if (ptype_count(mt1) != ptype_count(mt2))
4076     return false;
4077   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
4078     if (ptype(mt1, i) != ptype(mt2, i))
4079       return false;
4080   }
4081   return true;
4082 }
4083 
4084 oop java_lang_invoke_MethodType::rtype(oop mt) {
4085   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4086   return mt-&gt;obj_field(_rtype_offset);
4087 }
4088 
4089 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
4090   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4091   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
4092 }
4093 
4094 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
4095   return ptypes(mt)-&gt;obj_at(idx);
4096 }
4097 
4098 int java_lang_invoke_MethodType::ptype_count(oop mt) {
4099   return ptypes(mt)-&gt;length();
4100 }
4101 
4102 int java_lang_invoke_MethodType::ptype_slot_count(oop mt) {
4103   objArrayOop pts = ptypes(mt);
4104   int count = pts-&gt;length();
4105   int slots = 0;
4106   for (int i = 0; i &lt; count; i++) {
4107     BasicType bt = java_lang_Class::as_BasicType(pts-&gt;obj_at(i));
4108     slots += type2size[bt];
4109   }
4110   return slots;
4111 }
4112 
4113 int java_lang_invoke_MethodType::rtype_slot_count(oop mt) {
4114   BasicType bt = java_lang_Class::as_BasicType(rtype(mt));
4115   return type2size[bt];
4116 }
4117 
4118 
4119 // Support for java_lang_invoke_CallSite
4120 
4121 int java_lang_invoke_CallSite::_target_offset;
4122 int java_lang_invoke_CallSite::_context_offset;
4123 
4124 #define CALLSITE_FIELDS_DO(macro) \
4125   macro(_target_offset,  k, &quot;target&quot;, java_lang_invoke_MethodHandle_signature, false); \
4126   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
4127 
4128 void java_lang_invoke_CallSite::compute_offsets() {
4129   InstanceKlass* k = SystemDictionary::CallSite_klass();
4130   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4131 }
4132 
4133 #if INCLUDE_CDS
4134 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
4135   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4136 }
4137 #endif
4138 
4139 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
4140   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
4141 
4142   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
4143   return dep_oop;
4144 }
4145 
4146 // Support for java_lang_invoke_ConstantCallSite
4147 
4148 int java_lang_invoke_ConstantCallSite::_is_frozen_offset;
4149 
4150 #define CONSTANTCALLSITE_FIELDS_DO(macro) \
4151   macro(_is_frozen_offset, k, &quot;isFrozen&quot;, bool_signature, false)
4152 
4153 void java_lang_invoke_ConstantCallSite::compute_offsets() {
4154   InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();
4155   CONSTANTCALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4156 }
4157 
4158 #if INCLUDE_CDS
4159 void java_lang_invoke_ConstantCallSite::serialize_offsets(SerializeClosure* f) {
4160   CONSTANTCALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4161 }
4162 #endif
4163 
4164 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
4165 
4166 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
4167 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
4168 
4169 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
4170   InstanceKlass* k = SystemDictionary::Context_klass();
4171   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4172 }
4173 
4174 #if INCLUDE_CDS
4175 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4176   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4177 }
4178 #endif
4179 
4180 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4181   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4182   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4183   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4184   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4185   return dep_ctx;
4186 }
4187 
4188 // Support for java_security_AccessControlContext
4189 
4190 int java_security_AccessControlContext::_context_offset;
4191 int java_security_AccessControlContext::_privilegedContext_offset;
4192 int java_security_AccessControlContext::_isPrivileged_offset;
4193 int java_security_AccessControlContext::_isAuthorized_offset;
4194 
4195 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4196   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4197   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4198   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4199   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4200 
4201 void java_security_AccessControlContext::compute_offsets() {
4202   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4203   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4204   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4205 }
4206 
4207 #if INCLUDE_CDS
4208 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4209   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4210 }
4211 #endif
4212 
4213 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4214   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4215   assert(_isAuthorized_offset != 0, &quot;offsets should have been initialized&quot;);
4216   // Ensure klass is initialized
4217   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4218   // Allocate result
4219   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4220   // Fill in values
4221   result-&gt;obj_field_put(_context_offset, context());
4222   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4223   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4224   // whitelist AccessControlContexts created by the JVM
4225   result-&gt;bool_field_put(_isAuthorized_offset, true);
4226   return result;
4227 }
4228 
4229 
4230 // Support for java_lang_ClassLoader
4231 
4232 int  java_lang_ClassLoader::_loader_data_offset;
4233 int  java_lang_ClassLoader::_parallelCapable_offset;
4234 int  java_lang_ClassLoader::_name_offset;
4235 int  java_lang_ClassLoader::_nameAndId_offset;
4236 int  java_lang_ClassLoader::_unnamedModule_offset;
4237 int  java_lang_ClassLoader::_parent_offset;
4238 
4239 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4240   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4241   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4242   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4243 }
4244 
4245 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4246   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4247   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4248   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4249 }
4250 
4251 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4252   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4253   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4254   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4255 }
4256 
4257 #define CLASSLOADER_FIELDS_DO(macro) \
4258   macro(_parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
4259   macro(_name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
4260   macro(_nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
4261   macro(_unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
4262   macro(_parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
4263 
4264 void java_lang_ClassLoader::compute_offsets() {
4265   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4266   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4267 
4268   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4269 }
4270 
4271 #if INCLUDE_CDS
4272 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4273   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4274   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4275 }
4276 #endif
4277 
4278 oop java_lang_ClassLoader::parent(oop loader) {
4279   assert(is_instance(loader), &quot;loader must be oop&quot;);
4280   return loader-&gt;obj_field(_parent_offset);
4281 }
4282 
4283 // Returns the name field of this class loader.  If the name field has not
4284 // been set, null will be returned.
4285 oop java_lang_ClassLoader::name(oop loader) {
4286   assert(is_instance(loader), &quot;loader must be oop&quot;);
4287   return loader-&gt;obj_field(_name_offset);
4288 }
4289 
4290 // Returns the nameAndId field of this class loader. The format is
4291 // as follows:
4292 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4293 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4294 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4295 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4296 oop java_lang_ClassLoader::nameAndId(oop loader) {
4297   assert(is_instance(loader), &quot;loader must be oop&quot;);
4298   return loader-&gt;obj_field(_nameAndId_offset);
4299 }
4300 
4301 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4302   assert(is_instance(loader), &quot;loader must be oop&quot;);
4303   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4304   oop acl = loader;
4305   debug_only(jint loop_count = 0);
4306   // This loop taken verbatim from ClassLoader.java:
4307   do {
4308     acl = parent(acl);
4309     if (cl == acl) {
4310       return true;
4311     }
4312     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4313   } while (acl != NULL);
4314   return false;
4315 }
4316 
4317 bool java_lang_ClassLoader::is_instance(oop obj) {
4318   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4319 }
4320 
4321 
4322 // For class loader classes, parallelCapable defined
4323 // based on non-null field
4324 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4325 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
4326   assert(_parallelCapable_offset != 0, &quot;offsets should have been initialized&quot;);
4327   return (class_loader-&gt;obj_field(_parallelCapable_offset) != NULL);
4328 }
4329 
4330 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4331   // Fix for 4474172; see evaluation for more details
4332   loader = non_reflection_class_loader(loader);
4333 
4334   oop cl = SystemDictionary::java_system_loader();
4335   while(cl != NULL) {
4336     if (cl == loader) return true;
4337     cl = parent(cl);
4338   }
4339   return false;
4340 }
4341 
4342 // Return true if this is one of the class loaders associated with
4343 // the generated bytecodes for reflection.
4344 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4345   if (loader != NULL) {
4346     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4347     // This might be null in non-1.4 JDKs
4348     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4349   }
4350   return false;
4351 }
4352 
4353 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4354   // See whether this is one of the class loaders associated with
4355   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4356   // delegate to its parent to prevent class loading from occurring
4357   // in places where applications using reflection didn&#39;t expect it.
4358   if (is_reflection_class_loader(loader)) {
4359     return parent(loader);
4360   }
4361   return loader;
4362 }
4363 
4364 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4365   assert(is_instance(loader), &quot;loader must be oop&quot;);
4366   return loader-&gt;obj_field(_unnamedModule_offset);
4367 }
4368 
4369 // Support for java_lang_System
4370 //
4371 
4372 int java_lang_System::_static_in_offset;
4373 int java_lang_System::_static_out_offset;
4374 int java_lang_System::_static_err_offset;
4375 int java_lang_System::_static_security_offset;
4376 
4377 #define SYSTEM_FIELDS_DO(macro) \
4378   macro(_static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
4379   macro(_static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
4380   macro(_static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
4381   macro(_static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
4382 
4383 void java_lang_System::compute_offsets() {
4384   InstanceKlass* k = SystemDictionary::System_klass();
4385   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4386 }
4387 
4388 #if INCLUDE_CDS
4389 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4390    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4391 }
4392 #endif
4393 
4394 // Support for jdk_internal_misc_UnsafeConstants
4395 //
4396 class UnsafeConstantsFixup : public FieldClosure {
4397 private:
4398   int _address_size;
4399   int _page_size;
4400   bool _big_endian;
4401   bool _use_unaligned_access;
4402   int _data_cache_line_flush_size;
4403 public:
4404   UnsafeConstantsFixup() {
4405     // round up values for all static final fields
4406     _address_size = sizeof(void*);
4407     _page_size = os::vm_page_size();
4408     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4409     _use_unaligned_access = UseUnalignedAccesses;
4410     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4411   }
4412 
4413   void do_field(fieldDescriptor* fd) {
4414     oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
4415     assert(mirror != NULL, &quot;UnsafeConstants must have mirror already&quot;);
4416     assert(fd-&gt;field_holder() == SystemDictionary::UnsafeConstants_klass(), &quot;Should be UnsafeConstants&quot;);
4417     assert(fd-&gt;is_final(), &quot;fields of UnsafeConstants must be final&quot;);
4418     assert(fd-&gt;is_static(), &quot;fields of UnsafeConstants must be static&quot;);
4419     if (fd-&gt;name() == vmSymbols::address_size_name()) {
4420       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4421     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4422       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4423     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4424       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4425     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4426       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4427     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4428       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4429     } else {
4430       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4431     }
4432   }
4433 };
4434 
4435 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4436   UnsafeConstantsFixup fixup;
4437   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4438 }
4439 
4440 
4441 // java_lang_StackTraceElement
4442 
4443 int java_lang_StackTraceElement::_methodName_offset;
4444 int java_lang_StackTraceElement::_fileName_offset;
4445 int java_lang_StackTraceElement::_lineNumber_offset;
4446 int java_lang_StackTraceElement::_moduleName_offset;
4447 int java_lang_StackTraceElement::_moduleVersion_offset;
4448 int java_lang_StackTraceElement::_classLoaderName_offset;
4449 int java_lang_StackTraceElement::_declaringClass_offset;
4450 int java_lang_StackTraceElement::_declaringClassObject_offset;
4451 
4452 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4453   macro(_declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4454   macro(_classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4455   macro(_moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4456   macro(_moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4457   macro(_declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4458   macro(_methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4459   macro(_fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4460   macro(_lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4461 
4462 // Support for java_lang_StackTraceElement
4463 void java_lang_StackTraceElement::compute_offsets() {
4464   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4465   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4466 }
4467 
4468 #if INCLUDE_CDS
4469 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4470   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4471 }
4472 #endif
4473 
4474 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
4475   element-&gt;obj_field_put(_fileName_offset, value);
4476 }
4477 
4478 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
4479   element-&gt;obj_field_put(_declaringClass_offset, value);
4480 }
4481 
4482 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
4483   element-&gt;obj_field_put(_methodName_offset, value);
4484 }
4485 
4486 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
4487   element-&gt;int_field_put(_lineNumber_offset, value);
4488 }
4489 
4490 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
4491   element-&gt;obj_field_put(_moduleName_offset, value);
4492 }
4493 
4494 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4495   element-&gt;obj_field_put(_moduleVersion_offset, value);
4496 }
4497 
4498 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4499   element-&gt;obj_field_put(_classLoaderName_offset, value);
4500 }
4501 
4502 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4503   element-&gt;obj_field_put(_declaringClassObject_offset, value);
4504 }
4505 
4506 
4507 // java_lang_AssertionStatusDirectives
4508 
4509 int java_lang_AssertionStatusDirectives::_classes_offset;
4510 int java_lang_AssertionStatusDirectives::_classEnabled_offset;
4511 int java_lang_AssertionStatusDirectives::_packages_offset;
4512 int java_lang_AssertionStatusDirectives::_packageEnabled_offset;
4513 int java_lang_AssertionStatusDirectives::_deflt_offset;
4514 
4515 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4516 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
4517   macro(_classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \
4518   macro(_classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \
4519   macro(_packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \
4520   macro(_packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \
4521   macro(_deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)
4522 
4523 void java_lang_AssertionStatusDirectives::compute_offsets() {
4524   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4525   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4526 }
4527 
4528 #if INCLUDE_CDS
4529 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4530   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4531 }
4532 #endif
4533 
4534 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
4535   o-&gt;obj_field_put(_classes_offset, val);
4536 }
4537 
4538 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
4539   o-&gt;obj_field_put(_classEnabled_offset, val);
4540 }
4541 
4542 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
4543   o-&gt;obj_field_put(_packages_offset, val);
4544 }
4545 
4546 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
4547   o-&gt;obj_field_put(_packageEnabled_offset, val);
4548 }
4549 
4550 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
4551   o-&gt;bool_field_put(_deflt_offset, val);
4552 }
4553 
4554 
4555 // Support for intrinsification of java.nio.Buffer.checkIndex
4556 
4557 int java_nio_Buffer::_limit_offset;
4558 
4559 #define BUFFER_FIELDS_DO(macro) \
4560   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4561 
4562 void java_nio_Buffer::compute_offsets() {
4563   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4564   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4565   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4566 }
4567 
4568 #if INCLUDE_CDS
4569 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4570   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4571 }
4572 #endif
4573 
4574 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4575 
4576 #define AOS_FIELDS_DO(macro) \
4577   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4578 
4579 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4580   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4581   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4582 }
4583 
4584 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4585   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4586   return obj-&gt;obj_field(_owner_offset);
4587 }
4588 
4589 #if INCLUDE_CDS
4590 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4591   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4592 }
4593 #endif
4594 
4595 int java_lang_Integer_IntegerCache::_static_cache_offset;
4596 int java_lang_Long_LongCache::_static_cache_offset;
4597 int java_lang_Character_CharacterCache::_static_cache_offset;
4598 int java_lang_Short_ShortCache::_static_cache_offset;
4599 int java_lang_Byte_ByteCache::_static_cache_offset;
4600 
4601 #define INTEGER_CACHE_FIELDS_DO(macro) \
4602   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4603 
4604 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4605   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4606   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4607 }
4608 
4609 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4610   oop base = ik-&gt;static_field_base_raw();
4611   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4612 }
4613 
4614 Symbol* java_lang_Integer_IntegerCache::symbol() {
4615   return vmSymbols::java_lang_Integer_IntegerCache();
4616 }
4617 
4618 #if INCLUDE_CDS
4619 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4620   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4621 }
4622 #endif
4623 #undef INTEGER_CACHE_FIELDS_DO
4624 
4625 jint java_lang_Integer::value(oop obj) {
4626    jvalue v;
4627    java_lang_boxing_object::get_value(obj, &amp;v);
4628    return v.i;
4629 }
4630 
4631 #define LONG_CACHE_FIELDS_DO(macro) \
4632   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Long_array_signature, true)
4633 
4634 void java_lang_Long_LongCache::compute_offsets(InstanceKlass *k) {
4635   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4636   LONG_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4637 }
4638 
4639 objArrayOop java_lang_Long_LongCache::cache(InstanceKlass *ik) {
4640   oop base = ik-&gt;static_field_base_raw();
4641   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4642 }
4643 
4644 Symbol* java_lang_Long_LongCache::symbol() {
4645   return vmSymbols::java_lang_Long_LongCache();
4646 }
4647 
4648 #if INCLUDE_CDS
4649 void java_lang_Long_LongCache::serialize_offsets(SerializeClosure* f) {
4650   LONG_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4651 }
4652 #endif
4653 #undef LONG_CACHE_FIELDS_DO
4654 
4655 jlong java_lang_Long::value(oop obj) {
4656    jvalue v;
4657    java_lang_boxing_object::get_value(obj, &amp;v);
4658    return v.j;
4659 }
4660 
4661 #define CHARACTER_CACHE_FIELDS_DO(macro) \
4662   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Character_array_signature, true)
4663 
4664 void java_lang_Character_CharacterCache::compute_offsets(InstanceKlass *k) {
4665   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4666   CHARACTER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4667 }
4668 
4669 objArrayOop java_lang_Character_CharacterCache::cache(InstanceKlass *ik) {
4670   oop base = ik-&gt;static_field_base_raw();
4671   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4672 }
4673 
4674 Symbol* java_lang_Character_CharacterCache::symbol() {
4675   return vmSymbols::java_lang_Character_CharacterCache();
4676 }
4677 
4678 #if INCLUDE_CDS
4679 void java_lang_Character_CharacterCache::serialize_offsets(SerializeClosure* f) {
4680   CHARACTER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4681 }
4682 #endif
4683 #undef CHARACTER_CACHE_FIELDS_DO
4684 
4685 jchar java_lang_Character::value(oop obj) {
4686    jvalue v;
4687    java_lang_boxing_object::get_value(obj, &amp;v);
4688    return v.c;
4689 }
4690 
4691 #define SHORT_CACHE_FIELDS_DO(macro) \
4692   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Short_array_signature, true)
4693 
4694 void java_lang_Short_ShortCache::compute_offsets(InstanceKlass *k) {
4695   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4696   SHORT_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4697 }
4698 
4699 objArrayOop java_lang_Short_ShortCache::cache(InstanceKlass *ik) {
4700   oop base = ik-&gt;static_field_base_raw();
4701   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4702 }
4703 
4704 Symbol* java_lang_Short_ShortCache::symbol() {
4705   return vmSymbols::java_lang_Short_ShortCache();
4706 }
4707 
4708 #if INCLUDE_CDS
4709 void java_lang_Short_ShortCache::serialize_offsets(SerializeClosure* f) {
4710   SHORT_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4711 }
4712 #endif
4713 #undef SHORT_CACHE_FIELDS_DO
4714 
4715 jshort java_lang_Short::value(oop obj) {
4716    jvalue v;
4717    java_lang_boxing_object::get_value(obj, &amp;v);
4718    return v.s;
4719 }
4720 
4721 #define BYTE_CACHE_FIELDS_DO(macro) \
4722   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Byte_array_signature, true)
4723 
4724 void java_lang_Byte_ByteCache::compute_offsets(InstanceKlass *k) {
4725   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4726   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4727 }
4728 
4729 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4730   oop base = ik-&gt;static_field_base_raw();
4731   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4732 }
4733 
4734 Symbol* java_lang_Byte_ByteCache::symbol() {
4735   return vmSymbols::java_lang_Byte_ByteCache();
4736 }
4737 
4738 #if INCLUDE_CDS
4739 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4740   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4741 }
4742 #endif
4743 #undef BYTE_CACHE_FIELDS_DO
4744 
4745 jbyte java_lang_Byte::value(oop obj) {
4746    jvalue v;
4747    java_lang_boxing_object::get_value(obj, &amp;v);
4748    return v.b;
4749 }
4750 
4751 int java_lang_Boolean::_static_TRUE_offset;
4752 int java_lang_Boolean::_static_FALSE_offset;
4753 
4754 #define BOOLEAN_FIELDS_DO(macro) \
4755   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4756   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4757 
4758 
4759 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4760   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4761   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4762 }
4763 
4764 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4765   oop base = ik-&gt;static_field_base_raw();
4766   return base-&gt;obj_field(_static_TRUE_offset);
4767 }
4768 
4769 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4770   oop base = ik-&gt;static_field_base_raw();
4771   return base-&gt;obj_field(_static_FALSE_offset);
4772 }
4773 
4774 Symbol* java_lang_Boolean::symbol() {
4775   return vmSymbols::java_lang_Boolean();
4776 }
4777 
4778 #if INCLUDE_CDS
4779 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4780   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4781 }
4782 #endif
4783 #undef BOOLEAN_CACHE_FIELDS_DO
4784 
4785 jboolean java_lang_Boolean::value(oop obj) {
4786    jvalue v;
4787    java_lang_boxing_object::get_value(obj, &amp;v);
4788    return v.z;
4789 }
4790 
4791 // java_lang_reflect_RecordComponent
4792 
4793 int java_lang_reflect_RecordComponent::_clazz_offset;
4794 int java_lang_reflect_RecordComponent::_name_offset;
4795 int java_lang_reflect_RecordComponent::_type_offset;
4796 int java_lang_reflect_RecordComponent::_accessor_offset;
4797 int java_lang_reflect_RecordComponent::_signature_offset;
4798 int java_lang_reflect_RecordComponent::_annotations_offset;
4799 int java_lang_reflect_RecordComponent::_typeAnnotations_offset;
4800 
4801 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4802   macro(_clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4803   macro(_name_offset,        k, &quot;name&quot;,        string_signature, false); \
4804   macro(_type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4805   macro(_accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4806   macro(_signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4807   macro(_annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4808   macro(_typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4809 
4810 // Support for java_lang_reflect_RecordComponent
4811 void java_lang_reflect_RecordComponent::compute_offsets() {
4812   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4813   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4814 }
4815 
4816 #if INCLUDE_CDS
4817 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4818   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4819 }
4820 #endif
4821 
4822 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
4823   element-&gt;obj_field_put(_clazz_offset, value);
4824 }
4825 
4826 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
4827   element-&gt;obj_field_put(_name_offset, value);
4828 }
4829 
4830 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
4831   element-&gt;obj_field_put(_type_offset, value);
4832 }
4833 
4834 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
4835   element-&gt;obj_field_put(_accessor_offset, value);
4836 }
4837 
4838 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4839   element-&gt;obj_field_put(_signature_offset, value);
4840 }
4841 
4842 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4843   element-&gt;obj_field_put(_annotations_offset, value);
4844 }
4845 
4846 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4847   element-&gt;obj_field_put(_typeAnnotations_offset, value);
4848 }
4849 
4850 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4851 
4852 // Compute field offsets of all the classes in this file
4853 void JavaClasses::compute_offsets() {
4854   if (UseSharedSpaces) {
4855     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4856                                                          JvmtiExport::has_early_class_hook_env()),
4857                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4858     // None of the classes used by the rest of this function can be replaced by
4859     // JVMTI ClassFileLoadHook.
4860     // We are safe to use the archived offsets, which have already been restored
4861     // by JavaClasses::serialize_offsets, without computing the offsets again.
4862     return;
4863   }
4864 
4865   // We have already called the compute_offsets() of the
4866   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and
4867   // java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()
4868   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4869 }
4870 
4871 #if INCLUDE_CDS
4872 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4873 
4874 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4875   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4876 }
4877 #endif
4878 
4879 #if INCLUDE_CDS_JAVA_HEAP
4880 bool JavaClasses::is_supported_for_archiving(oop obj) {
4881   Klass* klass = obj-&gt;klass();
4882 
4883   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.
4884       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4885       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4886       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4887       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4888       // So for now we cannot not support these classes for archiving.
4889       //
4890       // These objects typically are not referenced by static fields, but rather by resolved
4891       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4892       klass == SystemDictionary::ResolvedMethodName_klass() ||
4893       klass == SystemDictionary::MemberName_klass() ||
4894       klass == SystemDictionary::Context_klass()) {
4895     return false;
4896   }
4897 
4898   return true;
4899 }
4900 #endif
4901 
4902 #ifndef PRODUCT
4903 
4904 // These functions exist to assert the validity of de-serialized offsets in boxing object as a sanity check.
4905 
4906 bool JavaClasses::check_offset(const char *klass_name, int deserialized_offset, const char *field_name,
4907                                const char* field_sig) {
4908   EXCEPTION_MARK;
4909   fieldDescriptor fd;
4910   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
4911   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
4912   InstanceKlass* ik = InstanceKlass::cast(k);
4913   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
4914   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
4915   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
4916     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
4917     return false;
4918   }
4919   if (fd.is_static()) {
4920     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
4921     return false;
4922   }
4923   if (fd.offset() == deserialized_offset ) {
4924     return true;
4925   } else {
4926     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is deserialized as %d but should really be %d.&quot;,
4927                   klass_name, field_name, deserialized_offset, fd.offset());
4928     return false;
4929   }
4930 }
4931 
4932 void JavaClasses::check_offsets() {
4933   bool valid = true;
4934 
4935 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
4936   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##field_name ## _offset, #field_name, field_sig)
4937 
4938 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
4939   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##long_ ## field_name ## _offset, #field_name, field_sig)
4940 
4941   // Boxed primitive objects (java_lang_boxing_object)
4942 
4943   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
4944   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
4945   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
4946   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
4947   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
4948   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
4949   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
4950   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
4951 
4952   if (!valid) vm_exit_during_initialization(&quot;Field offset verification failed&quot;);
4953 }
4954 
4955 #endif // PRODUCT
4956 
4957 int InjectedField::compute_offset() {
4958   InstanceKlass* ik = InstanceKlass::cast(klass());
4959   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4960     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
4961       // Only look at injected fields
4962       continue;
4963     }
4964     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
4965       return fs.offset();
4966     }
4967   }
4968   ResourceMark rm;
4969   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
4970 #ifndef PRODUCT
4971   ik-&gt;print();
4972   tty-&gt;print_cr(&quot;all fields:&quot;);
4973   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4974     tty-&gt;print_cr(&quot;  name: %s, sig: %s, flags: %08x&quot;, fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
4975   }
4976 #endif //PRODUCT
4977   vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
4978   return -1;
4979 }
4980 
4981 void javaClasses_init() {
4982   JavaClasses::compute_offsets();
4983   JavaClasses::check_offsets();
4984   FilteredFieldsMap::initialize();  // must be done after computing offsets.
4985 }
    </pre>
  </body>
</html>