<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef _JAVASOFT_JVM_H_
  27 #define _JAVASOFT_JVM_H_
  28 
  29 #include &lt;sys/stat.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jvm_md.h&quot;
  33 
  34 #ifdef __cplusplus
  35 extern &quot;C&quot; {
  36 #endif
  37 
  38 /*
  39  * This file contains additional functions exported from the VM.
  40  * These functions are complementary to the standard JNI support.
  41  * There are three parts to this file:
  42  *
  43  * First, this file contains the VM-related functions needed by native
  44  * libraries in the standard Java API. For example, the java.lang.Object
  45  * class needs VM-level functions that wait for and notify monitors.
  46  *
  47  * Second, this file contains the functions and constant definitions
  48  * needed by the byte code verifier and class file format checker.
  49  * These functions allow the verifier and format checker to be written
  50  * in a VM-independent way.
  51  *
  52  * Third, this file contains various I/O and network operations needed
  53  * by the standard Java I/O and network APIs.
  54  */
  55 
  56 /*
  57  * Bump the version number when either of the following happens:
  58  *
  59  * 1. There is a change in JVM_* functions.
  60  *
  61  * 2. There is a change in the contract between VM and Java classes.
  62  *    For example, if the VM relies on a new private field in Thread
  63  *    class.
  64  */
  65 
  66 #define JVM_INTERFACE_VERSION 6
  67 
  68 JNIEXPORT jint JNICALL
  69 JVM_GetInterfaceVersion(void);
  70 
  71 /*************************************************************************
  72  PART 1: Functions for Native Libraries
  73  ************************************************************************/
  74 /*
  75  * java.lang.Object
  76  */
  77 JNIEXPORT jint JNICALL
  78 JVM_IHashCode(JNIEnv *env, jobject obj);
  79 
  80 JNIEXPORT void JNICALL
  81 JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);
  82 
  83 JNIEXPORT void JNICALL
  84 JVM_MonitorNotify(JNIEnv *env, jobject obj);
  85 
  86 JNIEXPORT void JNICALL
  87 JVM_MonitorNotifyAll(JNIEnv *env, jobject obj);
  88 
  89 JNIEXPORT jobject JNICALL
  90 JVM_Clone(JNIEnv *env, jobject obj);
  91 
  92 /*
  93  * java.lang.String
  94  */
  95 JNIEXPORT jstring JNICALL
  96 JVM_InternString(JNIEnv *env, jstring str);
  97 
  98 /*
  99  * java.lang.System
 100  */
 101 JNIEXPORT jlong JNICALL
 102 JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored);
 103 
 104 JNIEXPORT jlong JNICALL
 105 JVM_NanoTime(JNIEnv *env, jclass ignored);
 106 
 107 JNIEXPORT jlong JNICALL
 108 JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs);
 109 
 110 JNIEXPORT void JNICALL
 111 JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 112               jobject dst, jint dst_pos, jint length);
 113 
 114 /*
 115  * Return an array of all properties as alternating name and value pairs.
 116  */
 117 JNIEXPORT jobjectArray JNICALL
 118 JVM_GetProperties(JNIEnv *env);
 119 
 120 /*
 121  * java.lang.Runtime
 122  */
 123 JNIEXPORT void JNICALL
 124 JVM_BeforeHalt();
 125 
 126 JNIEXPORT void JNICALL
 127 JVM_Halt(jint code);
 128 
 129 JNIEXPORT void JNICALL
 130 JVM_GC(void);
 131 
 132 /* Returns the number of real-time milliseconds that have elapsed since the
 133  * least-recently-inspected heap object was last inspected by the garbage
 134  * collector.
 135  *
 136  * For simple stop-the-world collectors this value is just the time
 137  * since the most recent collection.  For generational collectors it is the
 138  * time since the oldest generation was most recently collected.  Other
 139  * collectors are free to return a pessimistic estimate of the elapsed time, or
 140  * simply the time since the last full collection was performed.
 141  *
 142  * Note that in the presence of reference objects, a given object that is no
 143  * longer strongly reachable may have to be inspected multiple times before it
 144  * can be reclaimed.
 145  */
 146 JNIEXPORT jlong JNICALL
 147 JVM_MaxObjectInspectionAge(void);
 148 
 149 JNIEXPORT jlong JNICALL
 150 JVM_TotalMemory(void);
 151 
 152 JNIEXPORT jlong JNICALL
 153 JVM_FreeMemory(void);
 154 
 155 JNIEXPORT jlong JNICALL
 156 JVM_MaxMemory(void);
 157 
 158 JNIEXPORT jint JNICALL
 159 JVM_ActiveProcessorCount(void);
 160 
 161 JNIEXPORT jboolean JNICALL
 162 JVM_IsUseContainerSupport(void);
 163 
 164 JNIEXPORT void * JNICALL
 165 JVM_LoadLibrary(const char *name);
 166 
 167 JNIEXPORT void JNICALL
 168 JVM_UnloadLibrary(void * handle);
 169 
 170 JNIEXPORT void * JNICALL
 171 JVM_FindLibraryEntry(void *handle, const char *name);
 172 
 173 JNIEXPORT jboolean JNICALL
 174 JVM_IsSupportedJNIVersion(jint version);
 175 
 176 JNIEXPORT jobjectArray JNICALL
 177 JVM_GetVmArguments(JNIEnv *env);
 178 
 179 JNIEXPORT void JNICALL
 180 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 181 
 182 JNIEXPORT void JNICALL
 183 JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env, jclass caller,
 184                                          jstring invokedName,
 185                                          jobject invokedType,
 186                                          jobject methodType,
 187                                          jobject implMethodMember,
 188                                          jobject instantiatedMethodType,
 189                                          jclass lambdaProxyClass);
 190 
 191 JNIEXPORT jclass JNICALL
 192 JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env, jclass caller,
 193                                       jstring invokedName,
 194                                       jobject invokedType,
 195                                       jobject methodType,
 196                                       jobject implMethodMember,
 197                                       jobject instantiatedMethodType,
 198                                       jboolean initialize);
 199 
 200 JNIEXPORT jboolean JNICALL
 201 JVM_IsCDSDumpingEnabled(JNIEnv* env);
 202 
 203 JNIEXPORT jboolean JNICALL
 204 JVM_IsCDSSharingEnabled(JNIEnv* env);
 205 
 206 JNIEXPORT jlong JNICALL
 207 JVM_GetRandomSeedForCDSDump();
 208 
 209 /*
 210  * java.lang.Throwable
 211  */
 212 JNIEXPORT void JNICALL
 213 JVM_FillInStackTrace(JNIEnv *env, jobject throwable);
 214 
 215 /*
 216  * java.lang.StackTraceElement
 217  */
 218 JNIEXPORT void JNICALL
 219 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 220 
 221 JNIEXPORT void JNICALL
 222 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 223 
 224 /*
 225  * java.lang.NullPointerException
 226  */
 227 
 228 JNIEXPORT jstring JNICALL
 229 JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable);
 230 
 231 /*
 232  * java.lang.StackWalker
 233  */
 234 enum {
 235   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 236   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 237   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 238   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 239 };
 240 
 241 JNIEXPORT jobject JNICALL
 242 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 243                   jint skip_frames, jint frame_count, jint start_index,
 244                   jobjectArray frames);
 245 
 246 JNIEXPORT jint JNICALL
 247 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 248                   jint frame_count, jint start_index,
 249                   jobjectArray frames);
 250 
 251 /*
 252  * java.lang.Thread
 253  */
 254 JNIEXPORT void JNICALL
 255 JVM_StartThread(JNIEnv *env, jobject thread);
 256 
 257 JNIEXPORT void JNICALL
 258 JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);
 259 
 260 JNIEXPORT jboolean JNICALL
 261 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 262 
 263 JNIEXPORT void JNICALL
 264 JVM_SuspendThread(JNIEnv *env, jobject thread);
 265 
 266 JNIEXPORT void JNICALL
 267 JVM_ResumeThread(JNIEnv *env, jobject thread);
 268 
 269 JNIEXPORT void JNICALL
 270 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 271 
 272 JNIEXPORT void JNICALL
 273 JVM_Yield(JNIEnv *env, jclass threadClass);
 274 
 275 JNIEXPORT void JNICALL
 276 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 277 
 278 JNIEXPORT jobject JNICALL
 279 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 280 
 281 JNIEXPORT void JNICALL
 282 JVM_Interrupt(JNIEnv *env, jobject thread);
 283 
 284 JNIEXPORT jboolean JNICALL
 285 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 286 
 287 JNIEXPORT void JNICALL
 288 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 289 
 290 JNIEXPORT jobjectArray JNICALL
 291 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 292 
 293 JNIEXPORT void JNICALL
 294 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 295 
 296 /* getStackTrace() and getAllStackTraces() method */
 297 JNIEXPORT jobjectArray JNICALL
 298 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 299 
 300 /*
 301  * java.lang.SecurityManager
 302  */
 303 JNIEXPORT jobjectArray JNICALL
 304 JVM_GetClassContext(JNIEnv *env);
 305 
 306 /*
 307  * java.lang.Package
 308  */
 309 JNIEXPORT jstring JNICALL
 310 JVM_GetSystemPackage(JNIEnv *env, jstring name);
 311 
 312 JNIEXPORT jobjectArray JNICALL
 313 JVM_GetSystemPackages(JNIEnv *env);
 314 
 315 /*
 316  * java.lang.ref.Reference
 317  */
 318 JNIEXPORT jobject JNICALL
 319 JVM_GetAndClearReferencePendingList(JNIEnv *env);
 320 
 321 JNIEXPORT jboolean JNICALL
 322 JVM_HasReferencePendingList(JNIEnv *env);
 323 
 324 JNIEXPORT void JNICALL
 325 JVM_WaitForReferencePendingList(JNIEnv *env);
 326 
 327 /*
 328  * java.io.ObjectInputStream
 329  */
 330 JNIEXPORT jobject JNICALL
 331 JVM_LatestUserDefinedLoader(JNIEnv *env);
 332 
 333 /*
 334  * java.lang.reflect.Array
 335  */
 336 JNIEXPORT jint JNICALL
 337 JVM_GetArrayLength(JNIEnv *env, jobject arr);
 338 
 339 JNIEXPORT jobject JNICALL
 340 JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index);
 341 
 342 JNIEXPORT jvalue JNICALL
 343 JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode);
 344 
 345 JNIEXPORT void JNICALL
 346 JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val);
 347 
 348 JNIEXPORT void JNICALL
 349 JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v,
 350                              unsigned char vCode);
 351 
 352 JNIEXPORT jobject JNICALL
 353 JVM_NewArray(JNIEnv *env, jclass eltClass, jint length);
 354 
 355 JNIEXPORT jobject JNICALL
 356 JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim);
 357 
 358 
 359 /*
 360  * Returns the immediate caller class of the native method invoking
 361  * JVM_GetCallerClass.  The Method.invoke and other frames due to
 362  * reflection machinery are skipped.
 363  *
 364  * The caller is expected to be marked with
 365  * jdk.internal.reflect.CallerSensitive. The JVM will throw an
 366  * error if it is not marked properly.
 367  */
 368 JNIEXPORT jclass JNICALL
 369 JVM_GetCallerClass(JNIEnv *env);
 370 
 371 
 372 /*
 373  * Find primitive classes
 374  * utf: class name
 375  */
 376 JNIEXPORT jclass JNICALL
 377 JVM_FindPrimitiveClass(JNIEnv *env, const char *utf);
 378 
 379 
 380 /*
 381  * Find a class from a boot class loader. Returns NULL if class not found.
 382  */
 383 JNIEXPORT jclass JNICALL
 384 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 385 
 386 /*
 387  * Find a class from a given class loader.  Throws ClassNotFoundException.
 388  *  name:   name of class
 389  *  init:   whether initialization is done
 390  *  loader: class loader to look up the class. This may not be the same as the caller&#39;s
 391  *          class loader.
 392  *  caller: initiating class. The initiating class may be null when a security
 393  *          manager is not installed.
 394  */
 395 JNIEXPORT jclass JNICALL
 396 JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
 397                         jobject loader, jclass caller);
 398 
 399 /*
 400  * Find a class from a given class.
 401  */
 402 JNIEXPORT jclass JNICALL
 403 JVM_FindClassFromClass(JNIEnv *env, const char *name, jboolean init,
 404                              jclass from);
 405 
 406 /* Find a loaded class cached by the VM */
 407 JNIEXPORT jclass JNICALL
 408 JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name);
 409 
 410 /* Define a class */
 411 JNIEXPORT jclass JNICALL
 412 JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
 413                 jsize len, jobject pd);
 414 
 415 /* Define a class with a source (added in JDK1.5) */
 416 JNIEXPORT jclass JNICALL
 417 JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader,
 418                           const jbyte *buf, jsize len, jobject pd,
 419                           const char *source);
 420 
 421 /*
 422  * Define a class with the specified lookup class.
 423  *  lookup:  Lookup class
 424  *  name:    the name of the class
 425  *  buf:     class bytes
 426  *  len:     length of class bytes
 427  *  pd:      protection domain
 428  *  init:    initialize the class
 429  *  flags:   properties of the class
 430  *  classData: private static pre-initialized field; may be null
 431  */
 432 JNIEXPORT jclass JNICALL
 433 JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
 434                       jsize len, jobject pd, jboolean init, int flags, jobject classData);
 435 
 436 /*
 437  * Module support funcions
 438  */
 439 
 440 /*
 441  * Define a module with the specified packages and bind the module to the
 442  * given class loader.
 443  *  module:       module to define
 444  *  is_open:      specifies if module is open (currently ignored)
 445  *  version:      the module version
 446  *  location:     the module location
 447  *  packages:     array of packages in the module
 448  */
 449 JNIEXPORT void JNICALL
 450 JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
 451                  jstring location, jobjectArray packages);
 452 
 453 /*
 454  * Set the boot loader&#39;s unnamed module.
 455  *  module: boot loader&#39;s unnamed module
 456  */
 457 JNIEXPORT void JNICALL
 458 JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module);
 459 
 460 /*
 461  * Do a qualified export of a package.
 462  *  from_module: module containing the package to export
 463  *  package:     name of the package to export
 464  *  to_module:   module to export the package to
 465  */
 466 JNIEXPORT void JNICALL
 467 JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module);
 468 
 469 /*
 470  * Do an export of a package to all unnamed modules.
 471  *  from_module: module containing the package to export
 472  *  package:     name of the package to export to all unnamed modules
 473  */
 474 JNIEXPORT void JNICALL
 475 JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package);
 476 
 477 /*
 478  * Do an unqualified export of a package.
 479  *  from_module: module containing the package to export
 480  *  package:     name of the package to export
 481  */
 482 JNIEXPORT void JNICALL
 483 JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package);
 484 
 485 /*
 486  * Add a module to the list of modules that a given module can read.
 487  *  from_module:   module requesting read access
 488  *  source_module: module that from_module wants to read
 489  */
 490 JNIEXPORT void JNICALL
 491 JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module);
 492 
 493 /*
 494  * Reflection support functions
 495  */
 496 
 497 JNIEXPORT jstring JNICALL
 498 JVM_InitClassName(JNIEnv *env, jclass cls);
 499 
 500 JNIEXPORT jobjectArray JNICALL
 501 JVM_GetClassInterfaces(JNIEnv *env, jclass cls);
 502 
 503 JNIEXPORT jboolean JNICALL
 504 JVM_IsInterface(JNIEnv *env, jclass cls);
 505 
 506 JNIEXPORT jobjectArray JNICALL
 507 JVM_GetClassSigners(JNIEnv *env, jclass cls);
 508 
 509 JNIEXPORT void JNICALL
 510 JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);
 511 
 512 JNIEXPORT jobject JNICALL
 513 JVM_GetProtectionDomain(JNIEnv *env, jclass cls);
 514 
 515 JNIEXPORT jboolean JNICALL
 516 JVM_IsArrayClass(JNIEnv *env, jclass cls);
 517 
 518 JNIEXPORT jboolean JNICALL
 519 JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);
 520 
 521 JNIEXPORT jboolean JNICALL
 522 JVM_IsHiddenClass(JNIEnv *env, jclass cls);
 523 
 524 JNIEXPORT jint JNICALL
 525 JVM_GetClassModifiers(JNIEnv *env, jclass cls);
 526 
 527 JNIEXPORT jobjectArray JNICALL
 528 JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass);
 529 
 530 JNIEXPORT jclass JNICALL
 531 JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass);
 532 
 533 JNIEXPORT jstring JNICALL
 534 JVM_GetSimpleBinaryName(JNIEnv *env, jclass ofClass);
 535 
 536 /* Generics support (JDK 1.5) */
 537 JNIEXPORT jstring JNICALL
 538 JVM_GetClassSignature(JNIEnv *env, jclass cls);
 539 
 540 /* Annotations support (JDK 1.5) */
 541 JNIEXPORT jbyteArray JNICALL
 542 JVM_GetClassAnnotations(JNIEnv *env, jclass cls);
 543 
 544 /* Type use annotations support (JDK 1.8) */
 545 
 546 JNIEXPORT jbyteArray JNICALL
 547 JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls);
 548 
 549 JNIEXPORT jbyteArray JNICALL
 550 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 551 
 552 JNIEXPORT jbyteArray JNICALL
 553 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 554 
 555 /*
 556  * New (JDK 1.4) reflection implementation
 557  */
 558 
 559 JNIEXPORT jobjectArray JNICALL
 560 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 561 
 562 JNIEXPORT jobjectArray JNICALL
 563 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 564 
 565 JNIEXPORT jobjectArray JNICALL
 566 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 567 
 568 
 569 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 570    This returns the access flags for the class as specified in the
 571    class file rather than searching the InnerClasses attribute (if
 572    present) to find the source-level access flags. Only the values of
 573    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 574    valid. */
 575 JNIEXPORT jint JNICALL
 576 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 577 
 578 /* Nestmates - since JDK 11 */
 579 
 580 JNIEXPORT jboolean JNICALL
 581 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 582 
 583 JNIEXPORT jclass JNICALL
 584 JVM_GetNestHost(JNIEnv *env, jclass current);
 585 
 586 JNIEXPORT jobjectArray JNICALL
 587 JVM_GetNestMembers(JNIEnv *env, jclass current);
 588 
 589 /* Records - since JDK 14 */
 590 
 591 JNIEXPORT jboolean JNICALL
 592 JVM_IsRecord(JNIEnv *env, jclass cls);
 593 
 594 JNIEXPORT jobjectArray JNICALL
 595 JVM_GetRecordComponents(JNIEnv *env, jclass ofClass);
 596 
 597 /* Sealed types - since JDK 15 */
 598 
 599 JNIEXPORT jobjectArray JNICALL
 600 JVM_GetPermittedSubclasses(JNIEnv *env, jclass current);
 601 
 602 /* The following two reflection routines are still needed due to startup time issues */
 603 /*
 604  * java.lang.reflect.Method
 605  */
 606 JNIEXPORT jobject JNICALL
 607 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 608 
 609 /*
 610  * java.lang.reflect.Constructor
 611  */
 612 JNIEXPORT jobject JNICALL
 613 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 614 
 615 /*
 616  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 617  */
 618 
 619 JNIEXPORT jobject JNICALL
 620 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 621 
 622 JNIEXPORT jint JNICALL JVM_ConstantPoolGetSize
 623 (JNIEnv *env, jobject unused, jobject jcpool);
 624 
 625 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAt
 626 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 627 
 628 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAtIfLoaded
 629 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 630 
 631 JNIEXPORT jint JNICALL JVM_ConstantPoolGetClassRefIndexAt
 632 (JNIEnv *env, jobject obj, jobject unused, jint index);
 633 
 634 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAt
 635 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 636 
 637 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAtIfLoaded
 638 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 639 
 640 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAt
 641 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 642 
 643 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAtIfLoaded
 644 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 645 
 646 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetMemberRefInfoAt
 647 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 648 
 649 JNIEXPORT jint JNICALL JVM_ConstantPoolGetNameAndTypeRefIndexAt
 650 (JNIEnv *env, jobject obj, jobject unused, jint index);
 651 
 652 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetNameAndTypeRefInfoAt
 653 (JNIEnv *env, jobject obj, jobject unused, jint index);
 654 
 655 JNIEXPORT jint JNICALL JVM_ConstantPoolGetIntAt
 656 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 657 
 658 JNIEXPORT jlong JNICALL JVM_ConstantPoolGetLongAt
 659 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 660 
 661 JNIEXPORT jfloat JNICALL JVM_ConstantPoolGetFloatAt
 662 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 663 
 664 JNIEXPORT jdouble JNICALL JVM_ConstantPoolGetDoubleAt
 665 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 666 
 667 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetStringAt
 668 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 669 
 670 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetUTF8At
 671 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 672 
 673 JNIEXPORT jbyte JNICALL JVM_ConstantPoolGetTagAt
 674 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 675 
 676 /*
 677  * Parameter reflection
 678  */
 679 
 680 JNIEXPORT jobjectArray JNICALL
 681 JVM_GetMethodParameters(JNIEnv *env, jobject method);
 682 
 683 /*
 684  * java.security.*
 685  */
 686 
 687 JNIEXPORT jobject JNICALL
 688 JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);
 689 
 690 /*
 691  * Ensure that code doing a stackwalk and using javaVFrame::locals() to
 692  * get the value will see a materialized value and not a scalar-replaced
 693  * null value.
 694  */
 695 #define JVM_EnsureMaterializedForStackWalk(env, value) \
 696     do {} while(0) // Nothing to do.  The fact that the value escaped
 697                    // through a native method is enough.
 698 
 699 JNIEXPORT jobject JNICALL
 700 JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);
 701 
 702 /*
 703  * Signal support, used to implement the shutdown sequence.  Every VM must
 704  * support JVM_SIGINT and JVM_SIGTERM, raising the former for user interrupts
 705  * (^C) and the latter for external termination (kill, system shutdown, etc.).
 706  * Other platform-dependent signal values may also be supported.
 707  */
 708 
 709 JNIEXPORT void * JNICALL
 710 JVM_RegisterSignal(jint sig, void *handler);
 711 
 712 JNIEXPORT jboolean JNICALL
 713 JVM_RaiseSignal(jint sig);
 714 
 715 JNIEXPORT jint JNICALL
 716 JVM_FindSignal(const char *name);
 717 
 718 /*
 719  * Retrieve the assertion directives for the specified class.
 720  */
 721 JNIEXPORT jboolean JNICALL
 722 JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls);
 723 
 724 /*
 725  * Retrieve the assertion directives from the VM.
 726  */
 727 JNIEXPORT jobject JNICALL
 728 JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused);
 729 
 730 /*
 731  * java.util.concurrent.atomic.AtomicLong
 732  */
 733 JNIEXPORT jboolean JNICALL
 734 JVM_SupportsCX8(void);
 735 
 736 /*
 737  * com.sun.dtrace.jsdt support
 738  */
 739 
 740 #define JVM_TRACING_DTRACE_VERSION 1
 741 
 742 /*
 743  * Structure to pass one probe description to JVM
 744  */
 745 typedef struct {
 746     jmethodID method;
 747     jstring   function;
 748     jstring   name;
 749     void*            reserved[4];     // for future use
 750 } JVM_DTraceProbe;
 751 
 752 /**
 753  * Encapsulates the stability ratings for a DTrace provider field
 754  */
 755 typedef struct {
 756     jint nameStability;
 757     jint dataStability;
 758     jint dependencyClass;
 759 } JVM_DTraceInterfaceAttributes;
 760 
 761 /*
 762  * Structure to pass one provider description to JVM
 763  */
 764 typedef struct {
 765     jstring                       name;
 766     JVM_DTraceProbe*              probes;
 767     jint                          probe_count;
 768     JVM_DTraceInterfaceAttributes providerAttributes;
 769     JVM_DTraceInterfaceAttributes moduleAttributes;
 770     JVM_DTraceInterfaceAttributes functionAttributes;
 771     JVM_DTraceInterfaceAttributes nameAttributes;
 772     JVM_DTraceInterfaceAttributes argsAttributes;
 773     void*                         reserved[4]; // for future use
 774 } JVM_DTraceProvider;
 775 
 776 /*
 777  * Get the version number the JVM was built with
 778  */
 779 JNIEXPORT jint JNICALL
 780 JVM_DTraceGetVersion(JNIEnv* env);
 781 
 782 /*
 783  * Register new probe with given signature, return global handle
 784  *
 785  * The version passed in is the version that the library code was
 786  * built with.
 787  */
 788 JNIEXPORT jlong JNICALL
 789 JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,
 790   jint providers_count, JVM_DTraceProvider* providers);
 791 
 792 /*
 793  * Check JSDT probe
 794  */
 795 JNIEXPORT jboolean JNICALL
 796 JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);
 797 
 798 /*
 799  * Destroy custom DOF
 800  */
 801 JNIEXPORT void JNICALL
 802 JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);
 803 
 804 /*
 805  * Check to see if DTrace is supported by OS
 806  */
 807 JNIEXPORT jboolean JNICALL
 808 JVM_DTraceIsSupported(JNIEnv* env);
 809 
 810 /*************************************************************************
 811  PART 2: Support for the Verifier and Class File Format Checker
 812  ************************************************************************/
 813 /*
 814  * Return the class name in UTF format. The result is valid
 815  * until JVM_ReleaseUTf is called.
 816  *
 817  * The caller must treat the string as a constant and not modify it
 818  * in any way.
 819  */
 820 JNIEXPORT const char * JNICALL
 821 JVM_GetClassNameUTF(JNIEnv *env, jclass cb);
 822 
 823 /*
 824  * Returns the constant pool types in the buffer provided by &quot;types.&quot;
 825  */
 826 JNIEXPORT void JNICALL
 827 JVM_GetClassCPTypes(JNIEnv *env, jclass cb, unsigned char *types);
 828 
 829 /*
 830  * Returns the number of Constant Pool entries.
 831  */
 832 JNIEXPORT jint JNICALL
 833 JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cb);
 834 
 835 /*
 836  * Returns the number of *declared* fields or methods.
 837  */
 838 JNIEXPORT jint JNICALL
 839 JVM_GetClassFieldsCount(JNIEnv *env, jclass cb);
 840 
 841 JNIEXPORT jint JNICALL
 842 JVM_GetClassMethodsCount(JNIEnv *env, jclass cb);
 843 
 844 /*
 845  * Returns the CP indexes of exceptions raised by a given method.
 846  * Places the result in the given buffer.
 847  *
 848  * The method is identified by method_index.
 849  */
 850 JNIEXPORT void JNICALL
 851 JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cb, jint method_index,
 852                                 unsigned short *exceptions);
 853 /*
 854  * Returns the number of exceptions raised by a given method.
 855  * The method is identified by method_index.
 856  */
 857 JNIEXPORT jint JNICALL
 858 JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cb, jint method_index);
 859 
 860 /*
 861  * Returns the byte code sequence of a given method.
 862  * Places the result in the given buffer.
 863  *
 864  * The method is identified by method_index.
 865  */
 866 JNIEXPORT void JNICALL
 867 JVM_GetMethodIxByteCode(JNIEnv *env, jclass cb, jint method_index,
 868                         unsigned char *code);
 869 
 870 /*
 871  * Returns the length of the byte code sequence of a given method.
 872  * The method is identified by method_index.
 873  */
 874 JNIEXPORT jint JNICALL
 875 JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cb, jint method_index);
 876 
 877 /*
 878  * A structure used to a capture exception table entry in a Java method.
 879  */
 880 typedef struct {
 881     jint start_pc;
 882     jint end_pc;
 883     jint handler_pc;
 884     jint catchType;
 885 } JVM_ExceptionTableEntryType;
 886 
 887 /*
 888  * Returns the exception table entry at entry_index of a given method.
 889  * Places the result in the given buffer.
 890  *
 891  * The method is identified by method_index.
 892  */
 893 JNIEXPORT void JNICALL
 894 JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cb, jint method_index,
 895                                    jint entry_index,
 896                                    JVM_ExceptionTableEntryType *entry);
 897 
 898 /*
 899  * Returns the length of the exception table of a given method.
 900  * The method is identified by method_index.
 901  */
 902 JNIEXPORT jint JNICALL
 903 JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cb, int index);
 904 
 905 /*
 906  * Returns the modifiers of a given field.
 907  * The field is identified by field_index.
 908  */
 909 JNIEXPORT jint JNICALL
 910 JVM_GetFieldIxModifiers(JNIEnv *env, jclass cb, int index);
 911 
 912 /*
 913  * Returns the modifiers of a given method.
 914  * The method is identified by method_index.
 915  */
 916 JNIEXPORT jint JNICALL
 917 JVM_GetMethodIxModifiers(JNIEnv *env, jclass cb, int index);
 918 
 919 /*
 920  * Returns the number of local variables of a given method.
 921  * The method is identified by method_index.
 922  */
 923 JNIEXPORT jint JNICALL
 924 JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cb, int index);
 925 
 926 /*
 927  * Returns the number of arguments (including this pointer) of a given method.
 928  * The method is identified by method_index.
 929  */
 930 JNIEXPORT jint JNICALL
 931 JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cb, int index);
 932 
 933 /*
 934  * Returns the maximum amount of stack (in words) used by a given method.
 935  * The method is identified by method_index.
 936  */
 937 JNIEXPORT jint JNICALL
 938 JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cb, int index);
 939 
 940 /*
 941  * Is a given method a constructor.
 942  * The method is identified by method_index.
 943  */
 944 JNIEXPORT jboolean JNICALL
 945 JVM_IsConstructorIx(JNIEnv *env, jclass cb, int index);
 946 
 947 /*
 948  * Is the given method generated by the VM.
 949  * The method is identified by method_index.
 950  */
 951 JNIEXPORT jboolean JNICALL
 952 JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cb, int index);
 953 
 954 /*
 955  * Returns the name of a given method in UTF format.
 956  * The result remains valid until JVM_ReleaseUTF is called.
 957  *
 958  * The caller must treat the string as a constant and not modify it
 959  * in any way.
 960  */
 961 JNIEXPORT const char * JNICALL
 962 JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cb, jint index);
 963 
 964 /*
 965  * Returns the signature of a given method in UTF format.
 966  * The result remains valid until JVM_ReleaseUTF is called.
 967  *
 968  * The caller must treat the string as a constant and not modify it
 969  * in any way.
 970  */
 971 JNIEXPORT const char * JNICALL
 972 JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cb, jint index);
 973 
 974 /*
 975  * Returns the name of the field referred to at a given constant pool
 976  * index.
 977  *
 978  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 979  * is called.
 980  *
 981  * The caller must treat the string as a constant and not modify it
 982  * in any way.
 983  */
 984 JNIEXPORT const char * JNICALL
 985 JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cb, jint index);
 986 
 987 /*
 988  * Returns the name of the method referred to at a given constant pool
 989  * index.
 990  *
 991  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 992  * is called.
 993  *
 994  * The caller must treat the string as a constant and not modify it
 995  * in any way.
 996  */
 997 JNIEXPORT const char * JNICALL
 998 JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cb, jint index);
 999 
1000 /*
1001  * Returns the signature of the method referred to at a given constant pool
1002  * index.
1003  *
1004  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1005  * is called.
1006  *
1007  * The caller must treat the string as a constant and not modify it
1008  * in any way.
1009  */
1010 JNIEXPORT const char * JNICALL
1011 JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cb, jint index);
1012 
1013 /*
1014  * Returns the signature of the field referred to at a given constant pool
1015  * index.
1016  *
1017  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1018  * is called.
1019  *
1020  * The caller must treat the string as a constant and not modify it
1021  * in any way.
1022  */
1023 JNIEXPORT const char * JNICALL
1024 JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cb, jint index);
1025 
1026 /*
1027  * Returns the class name referred to at a given constant pool index.
1028  *
1029  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1030  * is called.
1031  *
1032  * The caller must treat the string as a constant and not modify it
1033  * in any way.
1034  */
1035 JNIEXPORT const char * JNICALL
1036 JVM_GetCPClassNameUTF(JNIEnv *env, jclass cb, jint index);
1037 
1038 /*
1039  * Returns the class name referred to at a given constant pool index.
1040  *
1041  * The constant pool entry must refer to a CONSTANT_Fieldref.
1042  *
1043  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1044  * is called.
1045  *
1046  * The caller must treat the string as a constant and not modify it
1047  * in any way.
1048  */
1049 JNIEXPORT const char * JNICALL
1050 JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cb, jint index);
1051 
1052 /*
1053  * Returns the class name referred to at a given constant pool index.
1054  *
1055  * The constant pool entry must refer to CONSTANT_Methodref or
1056  * CONSTANT_InterfaceMethodref.
1057  *
1058  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1059  * is called.
1060  *
1061  * The caller must treat the string as a constant and not modify it
1062  * in any way.
1063  */
1064 JNIEXPORT const char * JNICALL
1065 JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cb, jint index);
1066 
1067 /*
1068  * Returns the modifiers of a field in calledClass. The field is
1069  * referred to in class cb at constant pool entry index.
1070  *
1071  * The caller must treat the string as a constant and not modify it
1072  * in any way.
1073  *
1074  * Returns -1 if the field does not exist in calledClass.
1075  */
1076 JNIEXPORT jint JNICALL
1077 JVM_GetCPFieldModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1078 
1079 /*
1080  * Returns the modifiers of a method in calledClass. The method is
1081  * referred to in class cb at constant pool entry index.
1082  *
1083  * Returns -1 if the method does not exist in calledClass.
1084  */
1085 JNIEXPORT jint JNICALL
1086 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1087 
1088 /*
1089  * Releases the UTF string obtained from the VM.
1090  */
1091 JNIEXPORT void JNICALL
1092 JVM_ReleaseUTF(const char *utf);
1093 
1094 /*
1095  * Compare if two classes are in the same package.
1096  */
1097 JNIEXPORT jboolean JNICALL
1098 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1099 
1100 /* Get classfile constants */
1101 #include &quot;classfile_constants.h&quot;
1102 
1103 /*
1104  * Support for a VM-independent class format checker.
1105  */
1106 typedef struct {
1107     unsigned long code;    /* byte code */
1108     unsigned long excs;    /* exceptions */
1109     unsigned long etab;    /* catch table */
1110     unsigned long lnum;    /* line number */
1111     unsigned long lvar;    /* local vars */
1112 } method_size_info;
1113 
1114 typedef struct {
1115     unsigned int constants;    /* constant pool */
1116     unsigned int fields;
1117     unsigned int methods;
1118     unsigned int interfaces;
1119     unsigned int fields2;      /* number of static 2-word fields */
1120     unsigned int innerclasses; /* # of records in InnerClasses attr */
1121 
1122     method_size_info clinit;   /* memory used in clinit */
1123     method_size_info main;     /* used everywhere else */
1124 } class_size_info;
1125 
1126 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1127                                         JVM_ACC_FINAL | \
1128                                         JVM_ACC_SUPER | \
1129                                         JVM_ACC_INTERFACE | \
1130                                         JVM_ACC_ABSTRACT | \
1131                                         JVM_ACC_ANNOTATION | \
1132                                         JVM_ACC_ENUM | \
1133                                         JVM_ACC_SYNTHETIC)
1134 
1135 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1136                                         JVM_ACC_PRIVATE | \
1137                                         JVM_ACC_PROTECTED | \
1138                                         JVM_ACC_STATIC | \
1139                                         JVM_ACC_FINAL | \
1140                                         JVM_ACC_VOLATILE | \
1141                                         JVM_ACC_TRANSIENT | \
1142                                         JVM_ACC_ENUM | \
1143                                         JVM_ACC_SYNTHETIC)
1144 
1145 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1146                                          JVM_ACC_PRIVATE | \
1147                                          JVM_ACC_PROTECTED | \
1148                                          JVM_ACC_STATIC | \
1149                                          JVM_ACC_FINAL | \
1150                                          JVM_ACC_SYNCHRONIZED | \
1151                                          JVM_ACC_BRIDGE | \
1152                                          JVM_ACC_VARARGS | \
1153                                          JVM_ACC_NATIVE | \
1154                                          JVM_ACC_ABSTRACT | \
1155                                          JVM_ACC_STRICT | \
1156                                          JVM_ACC_SYNTHETIC)
1157 
1158 
1159 /*************************************************************************
1160  PART 3: I/O and Network Support
1161  ************************************************************************/
1162 
1163 /*
1164  * Convert a pathname into native format.  This function does syntactic
1165  * cleanup, such as removing redundant separator characters.  It modifies
1166  * the given pathname string in place.
1167  */
1168 JNIEXPORT char * JNICALL
1169 JVM_NativePath(char *);
1170 
1171 /*
1172  * The standard printing functions supported by the Java VM. (Should they
1173  * be renamed to JVM_* in the future?
1174  */
1175 
1176 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1177  *  respectively, with the following differences:
1178  * - The string written to str is always zero-terminated, also in case of
1179  *   truncation (count is too small to hold the result string), unless count
1180  *   is 0. In case of truncation count-1 characters are written and &#39;\0&#39;
1181  *   appendend.
1182  * - If count is too small to hold the whole string, -1 is returned across
1183  *   all platforms. */
1184 
1185 JNIEXPORT int
1186 jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
1187 
1188 JNIEXPORT int
1189 jio_snprintf(char *str, size_t count, const char *fmt, ...);
1190 
1191 JNIEXPORT int
1192 jio_fprintf(FILE *, const char *fmt, ...);
1193 
1194 JNIEXPORT int
1195 jio_vfprintf(FILE *, const char *fmt, va_list args);
1196 
1197 
1198 JNIEXPORT void * JNICALL
1199 JVM_RawMonitorCreate(void);
1200 
1201 JNIEXPORT void JNICALL
1202 JVM_RawMonitorDestroy(void *mon);
1203 
1204 JNIEXPORT jint JNICALL
1205 JVM_RawMonitorEnter(void *mon);
1206 
1207 JNIEXPORT void JNICALL
1208 JVM_RawMonitorExit(void *mon);
1209 
1210 /*
1211  * java.lang.management support
1212  */
1213 JNIEXPORT void* JNICALL
1214 JVM_GetManagement(jint version);
1215 
1216 /*
1217  * com.sun.tools.attach.VirtualMachine support
1218  *
1219  * Initialize the agent properties with the properties maintained in the VM.
1220  */
1221 JNIEXPORT jobject JNICALL
1222 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1223 
1224 JNIEXPORT jstring JNICALL
1225 JVM_GetTemporaryDirectory(JNIEnv *env);
1226 
1227 /* Generics reflection support.
1228  *
1229  * Returns information about the given class&#39;s EnclosingMethod
1230  * attribute, if present, or null if the class had no enclosing
1231  * method.
1232  *
1233  * If non-null, the returned array contains three elements. Element 0
1234  * is the java.lang.Class of which the enclosing method is a member,
1235  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1236  * method&#39;s name and descriptor, respectively.
1237  */
1238 JNIEXPORT jobjectArray JNICALL
1239 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1240 
1241 /*
1242  * This structure is used by the launcher to get the default thread
1243  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1244  * version of 1.1.  As it is not supported otherwise, it has been removed
1245  * from jni.h
1246  */
1247 typedef struct JDK1_1InitArgs {
1248     jint version;
1249 
1250     char **properties;
1251     jint checkSource;
1252     jint nativeStackSize;
1253     jint javaStackSize;
1254     jint minHeapSize;
1255     jint maxHeapSize;
1256     jint verifyMode;
1257     char *classpath;
1258 
1259     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1260     void (JNICALL *exit)(jint code);
1261     void (JNICALL *abort)(void);
1262 
1263     jint enableClassGC;
1264     jint enableVerboseGC;
1265     jint disableAsyncGC;
1266     jint verbose;
1267     jboolean debugging;
1268     jint debugPort;
1269 } JDK1_1InitArgs;
1270 
1271 
1272 #ifdef __cplusplus
1273 } /* extern &quot;C&quot; */
1274 
1275 #endif /* __cplusplus */
1276 
1277 #endif /* !_JAVASOFT_JVM_H_ */
    </pre>
  </body>
</html>