<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef _JAVASOFT_JVM_H_
  27 #define _JAVASOFT_JVM_H_
  28 
  29 #include &lt;sys/stat.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jvm_md.h&quot;
  33 
  34 #ifdef __cplusplus
  35 extern &quot;C&quot; {
  36 #endif
  37 
  38 /*
  39  * This file contains additional functions exported from the VM.
  40  * These functions are complementary to the standard JNI support.
  41  * There are three parts to this file:
  42  *
  43  * First, this file contains the VM-related functions needed by native
  44  * libraries in the standard Java API. For example, the java.lang.Object
  45  * class needs VM-level functions that wait for and notify monitors.
  46  *
  47  * Second, this file contains the functions and constant definitions
  48  * needed by the byte code verifier and class file format checker.
  49  * These functions allow the verifier and format checker to be written
  50  * in a VM-independent way.
  51  *
  52  * Third, this file contains various I/O and network operations needed
  53  * by the standard Java I/O and network APIs.
  54  */
  55 
  56 /*
  57  * Bump the version number when either of the following happens:
  58  *
  59  * 1. There is a change in JVM_* functions.
  60  *
  61  * 2. There is a change in the contract between VM and Java classes.
  62  *    For example, if the VM relies on a new private field in Thread
  63  *    class.
  64  */
  65 
  66 #define JVM_INTERFACE_VERSION 6
  67 
  68 JNIEXPORT jint JNICALL
  69 JVM_GetInterfaceVersion(void);
  70 
  71 /*************************************************************************
  72  PART 1: Functions for Native Libraries
  73  ************************************************************************/
  74 /*
  75  * java.lang.Object
  76  */
  77 JNIEXPORT jint JNICALL
  78 JVM_IHashCode(JNIEnv *env, jobject obj);
  79 
  80 JNIEXPORT void JNICALL
  81 JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);
  82 
  83 JNIEXPORT void JNICALL
  84 JVM_MonitorNotify(JNIEnv *env, jobject obj);
  85 
  86 JNIEXPORT void JNICALL
  87 JVM_MonitorNotifyAll(JNIEnv *env, jobject obj);
  88 
  89 JNIEXPORT jobject JNICALL
  90 JVM_Clone(JNIEnv *env, jobject obj);
  91 
  92 /*
  93  * java.lang.String
  94  */
  95 JNIEXPORT jstring JNICALL
  96 JVM_InternString(JNIEnv *env, jstring str);
  97 
  98 /*
  99  * java.lang.System
 100  */
 101 JNIEXPORT jlong JNICALL
 102 JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored);
 103 
 104 JNIEXPORT jlong JNICALL
 105 JVM_NanoTime(JNIEnv *env, jclass ignored);
 106 
 107 JNIEXPORT jlong JNICALL
 108 JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs);
 109 
 110 JNIEXPORT void JNICALL
 111 JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 112               jobject dst, jint dst_pos, jint length);
 113 
 114 /*
 115  * Return an array of all properties as alternating name and value pairs.
 116  */
 117 JNIEXPORT jobjectArray JNICALL
 118 JVM_GetProperties(JNIEnv *env);
 119 
 120 /*
 121  * java.lang.Runtime
 122  */
 123 JNIEXPORT void JNICALL
 124 JVM_BeforeHalt();
 125 
 126 JNIEXPORT void JNICALL
 127 JVM_Halt(jint code);
 128 
 129 JNIEXPORT void JNICALL
 130 JVM_GC(void);
 131 
 132 /* Returns the number of real-time milliseconds that have elapsed since the
 133  * least-recently-inspected heap object was last inspected by the garbage
 134  * collector.
 135  *
 136  * For simple stop-the-world collectors this value is just the time
 137  * since the most recent collection.  For generational collectors it is the
 138  * time since the oldest generation was most recently collected.  Other
 139  * collectors are free to return a pessimistic estimate of the elapsed time, or
 140  * simply the time since the last full collection was performed.
 141  *
 142  * Note that in the presence of reference objects, a given object that is no
 143  * longer strongly reachable may have to be inspected multiple times before it
 144  * can be reclaimed.
 145  */
 146 JNIEXPORT jlong JNICALL
 147 JVM_MaxObjectInspectionAge(void);
 148 
 149 JNIEXPORT jlong JNICALL
 150 JVM_TotalMemory(void);
 151 
 152 JNIEXPORT jlong JNICALL
 153 JVM_FreeMemory(void);
 154 
 155 JNIEXPORT jlong JNICALL
 156 JVM_MaxMemory(void);
 157 
 158 JNIEXPORT jint JNICALL
 159 JVM_ActiveProcessorCount(void);
 160 
 161 JNIEXPORT void * JNICALL
 162 JVM_LoadLibrary(const char *name);
 163 
 164 JNIEXPORT void JNICALL
 165 JVM_UnloadLibrary(void * handle);
 166 
 167 JNIEXPORT void * JNICALL
 168 JVM_FindLibraryEntry(void *handle, const char *name);
 169 
 170 JNIEXPORT jboolean JNICALL
 171 JVM_IsSupportedJNIVersion(jint version);
 172 
 173 JNIEXPORT jobjectArray JNICALL
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 JNIEXPORT void JNICALL
 180 JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env, jclass caller,
 181                                          jstring invokedName,
 182                                          jobject invokedType,
 183                                          jobject methodType,
 184                                          jobject implMethodMember,
 185                                          jobject instantiatedMethodType,
 186                                          jclass lambdaProxyClass);
 187 
 188 JNIEXPORT jclass JNICALL
 189 JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env, jclass caller,
 190                                       jstring invokedName,
 191                                       jobject invokedType,
 192                                       jobject methodType,
 193                                       jobject implMethodMember,
 194                                       jobject instantiatedMethodType,
 195                                       jboolean initialize);
 196 
 197 JNIEXPORT jboolean JNICALL
 198 JVM_IsCDSDumpingEnabled(JNIEnv* env);
 199 
 200 JNIEXPORT jboolean JNICALL
 201 JVM_IsCDSSharingEnabled(JNIEnv* env);
 202 
 203 JNIEXPORT jlong JNICALL
 204 JVM_GetRandomSeedForCDSDump();
 205 
 206 /*
 207  * java.lang.Throwable
 208  */
 209 JNIEXPORT void JNICALL
 210 JVM_FillInStackTrace(JNIEnv *env, jobject throwable);
 211 
 212 /*
 213  * java.lang.StackTraceElement
 214  */
 215 JNIEXPORT void JNICALL
 216 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 217 
 218 JNIEXPORT void JNICALL
 219 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 220 
 221 /*
 222  * java.lang.NullPointerException
 223  */
 224 
 225 JNIEXPORT jstring JNICALL
 226 JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable);
 227 
 228 /*
 229  * java.lang.StackWalker
 230  */
 231 enum {
 232   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 233   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 234   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 235   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 236 };
 237 
 238 JNIEXPORT jobject JNICALL
 239 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 240                   jint skip_frames, jint frame_count, jint start_index,
 241                   jobjectArray frames);
 242 
 243 JNIEXPORT jint JNICALL
 244 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 245                   jint frame_count, jint start_index,
 246                   jobjectArray frames);
 247 
 248 /*
 249  * java.lang.Thread
 250  */
 251 JNIEXPORT void JNICALL
 252 JVM_StartThread(JNIEnv *env, jobject thread);
 253 
 254 JNIEXPORT void JNICALL
 255 JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);
 256 
 257 JNIEXPORT jboolean JNICALL
 258 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 259 
 260 JNIEXPORT void JNICALL
 261 JVM_SuspendThread(JNIEnv *env, jobject thread);
 262 
 263 JNIEXPORT void JNICALL
 264 JVM_ResumeThread(JNIEnv *env, jobject thread);
 265 
 266 JNIEXPORT void JNICALL
 267 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 268 
 269 JNIEXPORT void JNICALL
 270 JVM_Yield(JNIEnv *env, jclass threadClass);
 271 
 272 JNIEXPORT void JNICALL
 273 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 274 
 275 JNIEXPORT jobject JNICALL
 276 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 277 
 278 JNIEXPORT void JNICALL
 279 JVM_Interrupt(JNIEnv *env, jobject thread);
 280 
 281 JNIEXPORT jboolean JNICALL
 282 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 283 
 284 JNIEXPORT void JNICALL
 285 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 286 
 287 JNIEXPORT jobjectArray JNICALL
 288 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 289 
 290 JNIEXPORT void JNICALL
 291 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 292 
 293 /* getStackTrace() and getAllStackTraces() method */
 294 JNIEXPORT jobjectArray JNICALL
 295 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 296 
 297 /*
 298  * java.lang.SecurityManager
 299  */
 300 JNIEXPORT jobjectArray JNICALL
 301 JVM_GetClassContext(JNIEnv *env);
 302 
 303 /*
 304  * java.lang.Package
 305  */
 306 JNIEXPORT jstring JNICALL
 307 JVM_GetSystemPackage(JNIEnv *env, jstring name);
 308 
 309 JNIEXPORT jobjectArray JNICALL
 310 JVM_GetSystemPackages(JNIEnv *env);
 311 
 312 /*
 313  * java.lang.ref.Reference
 314  */
 315 JNIEXPORT jobject JNICALL
 316 JVM_GetAndClearReferencePendingList(JNIEnv *env);
 317 
 318 JNIEXPORT jboolean JNICALL
 319 JVM_HasReferencePendingList(JNIEnv *env);
 320 
 321 JNIEXPORT void JNICALL
 322 JVM_WaitForReferencePendingList(JNIEnv *env);
 323 
 324 /*
 325  * java.io.ObjectInputStream
 326  */
 327 JNIEXPORT jobject JNICALL
 328 JVM_LatestUserDefinedLoader(JNIEnv *env);
 329 
 330 /*
 331  * java.lang.reflect.Array
 332  */
 333 JNIEXPORT jint JNICALL
 334 JVM_GetArrayLength(JNIEnv *env, jobject arr);
 335 
 336 JNIEXPORT jobject JNICALL
 337 JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index);
 338 
 339 JNIEXPORT jvalue JNICALL
 340 JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode);
 341 
 342 JNIEXPORT void JNICALL
 343 JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val);
 344 
 345 JNIEXPORT void JNICALL
 346 JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v,
 347                              unsigned char vCode);
 348 
 349 JNIEXPORT jobject JNICALL
 350 JVM_NewArray(JNIEnv *env, jclass eltClass, jint length);
 351 
 352 JNIEXPORT jobject JNICALL
 353 JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim);
 354 
 355 
 356 /*
 357  * Returns the immediate caller class of the native method invoking
 358  * JVM_GetCallerClass.  The Method.invoke and other frames due to
 359  * reflection machinery are skipped.
 360  *
 361  * The caller is expected to be marked with
 362  * jdk.internal.reflect.CallerSensitive. The JVM will throw an
 363  * error if it is not marked properly.
 364  */
 365 JNIEXPORT jclass JNICALL
 366 JVM_GetCallerClass(JNIEnv *env);
 367 
 368 
 369 /*
 370  * Find primitive classes
 371  * utf: class name
 372  */
 373 JNIEXPORT jclass JNICALL
 374 JVM_FindPrimitiveClass(JNIEnv *env, const char *utf);
 375 
 376 
 377 /*
 378  * Find a class from a boot class loader. Returns NULL if class not found.
 379  */
 380 JNIEXPORT jclass JNICALL
 381 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 382 
 383 /*
 384  * Find a class from a given class loader.  Throws ClassNotFoundException.
 385  *  name:   name of class
 386  *  init:   whether initialization is done
 387  *  loader: class loader to look up the class. This may not be the same as the caller&#39;s
 388  *          class loader.
 389  *  caller: initiating class. The initiating class may be null when a security
 390  *          manager is not installed.
 391  */
 392 JNIEXPORT jclass JNICALL
 393 JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
 394                         jobject loader, jclass caller);
 395 
 396 /*
 397  * Find a class from a given class.
 398  */
 399 JNIEXPORT jclass JNICALL
 400 JVM_FindClassFromClass(JNIEnv *env, const char *name, jboolean init,
 401                              jclass from);
 402 
 403 /* Find a loaded class cached by the VM */
 404 JNIEXPORT jclass JNICALL
 405 JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name);
 406 
 407 /* Define a class */
 408 JNIEXPORT jclass JNICALL
 409 JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
 410                 jsize len, jobject pd);
 411 
 412 /* Define a class with a source (added in JDK1.5) */
 413 JNIEXPORT jclass JNICALL
 414 JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader,
 415                           const jbyte *buf, jsize len, jobject pd,
 416                           const char *source);
 417 
 418 /*
 419  * Define a class with the specified lookup class.
 420  *  lookup:  Lookup class
 421  *  name:    the name of the class
 422  *  buf:     class bytes
 423  *  len:     length of class bytes
 424  *  pd:      protection domain
 425  *  init:    initialize the class
 426  *  flags:   properties of the class
 427  *  classData: private static pre-initialized field; may be null
 428  */
 429 JNIEXPORT jclass JNICALL
 430 JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
 431                       jsize len, jobject pd, jboolean init, int flags, jobject classData);
 432 
 433 /*
 434  * Module support funcions
 435  */
 436 
 437 /*
 438  * Define a module with the specified packages and bind the module to the
 439  * given class loader.
 440  *  module:       module to define
 441  *  is_open:      specifies if module is open (currently ignored)
 442  *  version:      the module version
 443  *  location:     the module location
 444  *  packages:     array of packages in the module
 445  */
 446 JNIEXPORT void JNICALL
 447 JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
 448                  jstring location, jobjectArray packages);
 449 
 450 /*
 451  * Set the boot loader&#39;s unnamed module.
 452  *  module: boot loader&#39;s unnamed module
 453  */
 454 JNIEXPORT void JNICALL
 455 JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module);
 456 
 457 /*
 458  * Do a qualified export of a package.
 459  *  from_module: module containing the package to export
 460  *  package:     name of the package to export
 461  *  to_module:   module to export the package to
 462  */
 463 JNIEXPORT void JNICALL
 464 JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module);
 465 
 466 /*
 467  * Do an export of a package to all unnamed modules.
 468  *  from_module: module containing the package to export
 469  *  package:     name of the package to export to all unnamed modules
 470  */
 471 JNIEXPORT void JNICALL
 472 JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package);
 473 
 474 /*
 475  * Do an unqualified export of a package.
 476  *  from_module: module containing the package to export
 477  *  package:     name of the package to export
 478  */
 479 JNIEXPORT void JNICALL
 480 JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package);
 481 
 482 /*
 483  * Add a module to the list of modules that a given module can read.
 484  *  from_module:   module requesting read access
 485  *  source_module: module that from_module wants to read
 486  */
 487 JNIEXPORT void JNICALL
 488 JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module);
 489 
 490 /*
 491  * Reflection support functions
 492  */
 493 
 494 JNIEXPORT jstring JNICALL
 495 JVM_InitClassName(JNIEnv *env, jclass cls);
 496 
 497 JNIEXPORT jobjectArray JNICALL
 498 JVM_GetClassInterfaces(JNIEnv *env, jclass cls);
 499 
 500 JNIEXPORT jboolean JNICALL
 501 JVM_IsInterface(JNIEnv *env, jclass cls);
 502 
 503 JNIEXPORT jobjectArray JNICALL
 504 JVM_GetClassSigners(JNIEnv *env, jclass cls);
 505 
 506 JNIEXPORT void JNICALL
 507 JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);
 508 
 509 JNIEXPORT jobject JNICALL
 510 JVM_GetProtectionDomain(JNIEnv *env, jclass cls);
 511 
 512 JNIEXPORT jboolean JNICALL
 513 JVM_IsArrayClass(JNIEnv *env, jclass cls);
 514 
 515 JNIEXPORT jboolean JNICALL
 516 JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);
 517 
 518 JNIEXPORT jboolean JNICALL
 519 JVM_IsHiddenClass(JNIEnv *env, jclass cls);
 520 
 521 JNIEXPORT jint JNICALL
 522 JVM_GetClassModifiers(JNIEnv *env, jclass cls);
 523 
 524 JNIEXPORT jobjectArray JNICALL
 525 JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass);
 526 
 527 JNIEXPORT jclass JNICALL
 528 JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass);
 529 
 530 JNIEXPORT jstring JNICALL
 531 JVM_GetSimpleBinaryName(JNIEnv *env, jclass ofClass);
 532 
 533 /* Generics support (JDK 1.5) */
 534 JNIEXPORT jstring JNICALL
 535 JVM_GetClassSignature(JNIEnv *env, jclass cls);
 536 
 537 /* Annotations support (JDK 1.5) */
 538 JNIEXPORT jbyteArray JNICALL
 539 JVM_GetClassAnnotations(JNIEnv *env, jclass cls);
 540 
 541 /* Type use annotations support (JDK 1.8) */
 542 
 543 JNIEXPORT jbyteArray JNICALL
 544 JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls);
 545 
 546 JNIEXPORT jbyteArray JNICALL
 547 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 548 
 549 JNIEXPORT jbyteArray JNICALL
 550 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 551 
 552 /*
 553  * New (JDK 1.4) reflection implementation
 554  */
 555 
 556 JNIEXPORT jobjectArray JNICALL
 557 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 558 
 559 JNIEXPORT jobjectArray JNICALL
 560 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 561 
 562 JNIEXPORT jobjectArray JNICALL
 563 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 564 
 565 
 566 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 567    This returns the access flags for the class as specified in the
 568    class file rather than searching the InnerClasses attribute (if
 569    present) to find the source-level access flags. Only the values of
 570    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 571    valid. */
 572 JNIEXPORT jint JNICALL
 573 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 574 
 575 /* Nestmates - since JDK 11 */
 576 
 577 JNIEXPORT jboolean JNICALL
 578 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 579 
 580 JNIEXPORT jclass JNICALL
 581 JVM_GetNestHost(JNIEnv *env, jclass current);
 582 
 583 JNIEXPORT jobjectArray JNICALL
 584 JVM_GetNestMembers(JNIEnv *env, jclass current);
 585 
 586 /* Records - since JDK 14 */
 587 
 588 JNIEXPORT jboolean JNICALL
 589 JVM_IsRecord(JNIEnv *env, jclass cls);
 590 
 591 JNIEXPORT jobjectArray JNICALL
 592 JVM_GetRecordComponents(JNIEnv *env, jclass ofClass);
 593 
 594 /* Sealed types - since JDK 15 */
 595 
 596 JNIEXPORT jobjectArray JNICALL
 597 JVM_GetPermittedSubclasses(JNIEnv *env, jclass current);
 598 
 599 /* The following two reflection routines are still needed due to startup time issues */
 600 /*
 601  * java.lang.reflect.Method
 602  */
 603 JNIEXPORT jobject JNICALL
 604 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 605 
 606 /*
 607  * java.lang.reflect.Constructor
 608  */
 609 JNIEXPORT jobject JNICALL
 610 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 611 
 612 /*
 613  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 614  */
 615 
 616 JNIEXPORT jobject JNICALL
 617 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 618 
 619 JNIEXPORT jint JNICALL JVM_ConstantPoolGetSize
 620 (JNIEnv *env, jobject unused, jobject jcpool);
 621 
 622 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAt
 623 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 624 
 625 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAtIfLoaded
 626 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 627 
 628 JNIEXPORT jint JNICALL JVM_ConstantPoolGetClassRefIndexAt
 629 (JNIEnv *env, jobject obj, jobject unused, jint index);
 630 
 631 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAt
 632 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 633 
 634 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAtIfLoaded
 635 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 636 
 637 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAt
 638 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 639 
 640 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAtIfLoaded
 641 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 642 
 643 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetMemberRefInfoAt
 644 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 645 
 646 JNIEXPORT jint JNICALL JVM_ConstantPoolGetNameAndTypeRefIndexAt
 647 (JNIEnv *env, jobject obj, jobject unused, jint index);
 648 
 649 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetNameAndTypeRefInfoAt
 650 (JNIEnv *env, jobject obj, jobject unused, jint index);
 651 
 652 JNIEXPORT jint JNICALL JVM_ConstantPoolGetIntAt
 653 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 654 
 655 JNIEXPORT jlong JNICALL JVM_ConstantPoolGetLongAt
 656 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 657 
 658 JNIEXPORT jfloat JNICALL JVM_ConstantPoolGetFloatAt
 659 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 660 
 661 JNIEXPORT jdouble JNICALL JVM_ConstantPoolGetDoubleAt
 662 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 663 
 664 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetStringAt
 665 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 666 
 667 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetUTF8At
 668 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 669 
 670 JNIEXPORT jbyte JNICALL JVM_ConstantPoolGetTagAt
 671 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 672 
 673 /*
 674  * Parameter reflection
 675  */
 676 
 677 JNIEXPORT jobjectArray JNICALL
 678 JVM_GetMethodParameters(JNIEnv *env, jobject method);
 679 
 680 /*
 681  * java.security.*
 682  */
 683 
 684 JNIEXPORT jobject JNICALL
 685 JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);
 686 
 687 /*
 688  * Ensure that code doing a stackwalk and using javaVFrame::locals() to
 689  * get the value will see a materialized value and not a scalar-replaced
 690  * null value.
 691  */
 692 #define JVM_EnsureMaterializedForStackWalk(env, value) \
 693     do {} while(0) // Nothing to do.  The fact that the value escaped
 694                    // through a native method is enough.
 695 
 696 JNIEXPORT jobject JNICALL
 697 JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);
 698 
 699 /*
 700  * Signal support, used to implement the shutdown sequence.  Every VM must
 701  * support JVM_SIGINT and JVM_SIGTERM, raising the former for user interrupts
 702  * (^C) and the latter for external termination (kill, system shutdown, etc.).
 703  * Other platform-dependent signal values may also be supported.
 704  */
 705 
 706 JNIEXPORT void * JNICALL
 707 JVM_RegisterSignal(jint sig, void *handler);
 708 
 709 JNIEXPORT jboolean JNICALL
 710 JVM_RaiseSignal(jint sig);
 711 
 712 JNIEXPORT jint JNICALL
 713 JVM_FindSignal(const char *name);
 714 
 715 /*
 716  * Retrieve the assertion directives for the specified class.
 717  */
 718 JNIEXPORT jboolean JNICALL
 719 JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls);
 720 
 721 /*
 722  * Retrieve the assertion directives from the VM.
 723  */
 724 JNIEXPORT jobject JNICALL
 725 JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused);
 726 
 727 /*
 728  * java.util.concurrent.atomic.AtomicLong
 729  */
 730 JNIEXPORT jboolean JNICALL
 731 JVM_SupportsCX8(void);
 732 
 733 /*
 734  * com.sun.dtrace.jsdt support
 735  */
 736 
 737 #define JVM_TRACING_DTRACE_VERSION 1
 738 
 739 /*
 740  * Structure to pass one probe description to JVM
 741  */
 742 typedef struct {
 743     jmethodID method;
 744     jstring   function;
 745     jstring   name;
 746     void*            reserved[4];     // for future use
 747 } JVM_DTraceProbe;
 748 
 749 /**
 750  * Encapsulates the stability ratings for a DTrace provider field
 751  */
 752 typedef struct {
 753     jint nameStability;
 754     jint dataStability;
 755     jint dependencyClass;
 756 } JVM_DTraceInterfaceAttributes;
 757 
 758 /*
 759  * Structure to pass one provider description to JVM
 760  */
 761 typedef struct {
 762     jstring                       name;
 763     JVM_DTraceProbe*              probes;
 764     jint                          probe_count;
 765     JVM_DTraceInterfaceAttributes providerAttributes;
 766     JVM_DTraceInterfaceAttributes moduleAttributes;
 767     JVM_DTraceInterfaceAttributes functionAttributes;
 768     JVM_DTraceInterfaceAttributes nameAttributes;
 769     JVM_DTraceInterfaceAttributes argsAttributes;
 770     void*                         reserved[4]; // for future use
 771 } JVM_DTraceProvider;
 772 
 773 /*
 774  * Get the version number the JVM was built with
 775  */
 776 JNIEXPORT jint JNICALL
 777 JVM_DTraceGetVersion(JNIEnv* env);
 778 
 779 /*
 780  * Register new probe with given signature, return global handle
 781  *
 782  * The version passed in is the version that the library code was
 783  * built with.
 784  */
 785 JNIEXPORT jlong JNICALL
 786 JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,
 787   jint providers_count, JVM_DTraceProvider* providers);
 788 
 789 /*
 790  * Check JSDT probe
 791  */
 792 JNIEXPORT jboolean JNICALL
 793 JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);
 794 
 795 /*
 796  * Destroy custom DOF
 797  */
 798 JNIEXPORT void JNICALL
 799 JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);
 800 
 801 /*
 802  * Check to see if DTrace is supported by OS
 803  */
 804 JNIEXPORT jboolean JNICALL
 805 JVM_DTraceIsSupported(JNIEnv* env);
 806 
 807 /*************************************************************************
 808  PART 2: Support for the Verifier and Class File Format Checker
 809  ************************************************************************/
 810 /*
 811  * Return the class name in UTF format. The result is valid
 812  * until JVM_ReleaseUTf is called.
 813  *
 814  * The caller must treat the string as a constant and not modify it
 815  * in any way.
 816  */
 817 JNIEXPORT const char * JNICALL
 818 JVM_GetClassNameUTF(JNIEnv *env, jclass cb);
 819 
 820 /*
 821  * Returns the constant pool types in the buffer provided by &quot;types.&quot;
 822  */
 823 JNIEXPORT void JNICALL
 824 JVM_GetClassCPTypes(JNIEnv *env, jclass cb, unsigned char *types);
 825 
 826 /*
 827  * Returns the number of Constant Pool entries.
 828  */
 829 JNIEXPORT jint JNICALL
 830 JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cb);
 831 
 832 /*
 833  * Returns the number of *declared* fields or methods.
 834  */
 835 JNIEXPORT jint JNICALL
 836 JVM_GetClassFieldsCount(JNIEnv *env, jclass cb);
 837 
 838 JNIEXPORT jint JNICALL
 839 JVM_GetClassMethodsCount(JNIEnv *env, jclass cb);
 840 
 841 /*
 842  * Returns the CP indexes of exceptions raised by a given method.
 843  * Places the result in the given buffer.
 844  *
 845  * The method is identified by method_index.
 846  */
 847 JNIEXPORT void JNICALL
 848 JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cb, jint method_index,
 849                                 unsigned short *exceptions);
 850 /*
 851  * Returns the number of exceptions raised by a given method.
 852  * The method is identified by method_index.
 853  */
 854 JNIEXPORT jint JNICALL
 855 JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cb, jint method_index);
 856 
 857 /*
 858  * Returns the byte code sequence of a given method.
 859  * Places the result in the given buffer.
 860  *
 861  * The method is identified by method_index.
 862  */
 863 JNIEXPORT void JNICALL
 864 JVM_GetMethodIxByteCode(JNIEnv *env, jclass cb, jint method_index,
 865                         unsigned char *code);
 866 
 867 /*
 868  * Returns the length of the byte code sequence of a given method.
 869  * The method is identified by method_index.
 870  */
 871 JNIEXPORT jint JNICALL
 872 JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cb, jint method_index);
 873 
 874 /*
 875  * A structure used to a capture exception table entry in a Java method.
 876  */
 877 typedef struct {
 878     jint start_pc;
 879     jint end_pc;
 880     jint handler_pc;
 881     jint catchType;
 882 } JVM_ExceptionTableEntryType;
 883 
 884 /*
 885  * Returns the exception table entry at entry_index of a given method.
 886  * Places the result in the given buffer.
 887  *
 888  * The method is identified by method_index.
 889  */
 890 JNIEXPORT void JNICALL
 891 JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cb, jint method_index,
 892                                    jint entry_index,
 893                                    JVM_ExceptionTableEntryType *entry);
 894 
 895 /*
 896  * Returns the length of the exception table of a given method.
 897  * The method is identified by method_index.
 898  */
 899 JNIEXPORT jint JNICALL
 900 JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cb, int index);
 901 
 902 /*
 903  * Returns the modifiers of a given field.
 904  * The field is identified by field_index.
 905  */
 906 JNIEXPORT jint JNICALL
 907 JVM_GetFieldIxModifiers(JNIEnv *env, jclass cb, int index);
 908 
 909 /*
 910  * Returns the modifiers of a given method.
 911  * The method is identified by method_index.
 912  */
 913 JNIEXPORT jint JNICALL
 914 JVM_GetMethodIxModifiers(JNIEnv *env, jclass cb, int index);
 915 
 916 /*
 917  * Returns the number of local variables of a given method.
 918  * The method is identified by method_index.
 919  */
 920 JNIEXPORT jint JNICALL
 921 JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cb, int index);
 922 
 923 /*
 924  * Returns the number of arguments (including this pointer) of a given method.
 925  * The method is identified by method_index.
 926  */
 927 JNIEXPORT jint JNICALL
 928 JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cb, int index);
 929 
 930 /*
 931  * Returns the maximum amount of stack (in words) used by a given method.
 932  * The method is identified by method_index.
 933  */
 934 JNIEXPORT jint JNICALL
 935 JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cb, int index);
 936 
 937 /*
 938  * Is a given method a constructor.
 939  * The method is identified by method_index.
 940  */
 941 JNIEXPORT jboolean JNICALL
 942 JVM_IsConstructorIx(JNIEnv *env, jclass cb, int index);
 943 
 944 /*
 945  * Is the given method generated by the VM.
 946  * The method is identified by method_index.
 947  */
 948 JNIEXPORT jboolean JNICALL
 949 JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cb, int index);
 950 
 951 /*
 952  * Returns the name of a given method in UTF format.
 953  * The result remains valid until JVM_ReleaseUTF is called.
 954  *
 955  * The caller must treat the string as a constant and not modify it
 956  * in any way.
 957  */
 958 JNIEXPORT const char * JNICALL
 959 JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cb, jint index);
 960 
 961 /*
 962  * Returns the signature of a given method in UTF format.
 963  * The result remains valid until JVM_ReleaseUTF is called.
 964  *
 965  * The caller must treat the string as a constant and not modify it
 966  * in any way.
 967  */
 968 JNIEXPORT const char * JNICALL
 969 JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cb, jint index);
 970 
 971 /*
 972  * Returns the name of the field referred to at a given constant pool
 973  * index.
 974  *
 975  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 976  * is called.
 977  *
 978  * The caller must treat the string as a constant and not modify it
 979  * in any way.
 980  */
 981 JNIEXPORT const char * JNICALL
 982 JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cb, jint index);
 983 
 984 /*
 985  * Returns the name of the method referred to at a given constant pool
 986  * index.
 987  *
 988  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 989  * is called.
 990  *
 991  * The caller must treat the string as a constant and not modify it
 992  * in any way.
 993  */
 994 JNIEXPORT const char * JNICALL
 995 JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cb, jint index);
 996 
 997 /*
 998  * Returns the signature of the method referred to at a given constant pool
 999  * index.
1000  *
1001  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1002  * is called.
1003  *
1004  * The caller must treat the string as a constant and not modify it
1005  * in any way.
1006  */
1007 JNIEXPORT const char * JNICALL
1008 JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cb, jint index);
1009 
1010 /*
1011  * Returns the signature of the field referred to at a given constant pool
1012  * index.
1013  *
1014  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1015  * is called.
1016  *
1017  * The caller must treat the string as a constant and not modify it
1018  * in any way.
1019  */
1020 JNIEXPORT const char * JNICALL
1021 JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cb, jint index);
1022 
1023 /*
1024  * Returns the class name referred to at a given constant pool index.
1025  *
1026  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1027  * is called.
1028  *
1029  * The caller must treat the string as a constant and not modify it
1030  * in any way.
1031  */
1032 JNIEXPORT const char * JNICALL
1033 JVM_GetCPClassNameUTF(JNIEnv *env, jclass cb, jint index);
1034 
1035 /*
1036  * Returns the class name referred to at a given constant pool index.
1037  *
1038  * The constant pool entry must refer to a CONSTANT_Fieldref.
1039  *
1040  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1041  * is called.
1042  *
1043  * The caller must treat the string as a constant and not modify it
1044  * in any way.
1045  */
1046 JNIEXPORT const char * JNICALL
1047 JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cb, jint index);
1048 
1049 /*
1050  * Returns the class name referred to at a given constant pool index.
1051  *
1052  * The constant pool entry must refer to CONSTANT_Methodref or
1053  * CONSTANT_InterfaceMethodref.
1054  *
1055  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1056  * is called.
1057  *
1058  * The caller must treat the string as a constant and not modify it
1059  * in any way.
1060  */
1061 JNIEXPORT const char * JNICALL
1062 JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cb, jint index);
1063 
1064 /*
1065  * Returns the modifiers of a field in calledClass. The field is
1066  * referred to in class cb at constant pool entry index.
1067  *
1068  * The caller must treat the string as a constant and not modify it
1069  * in any way.
1070  *
1071  * Returns -1 if the field does not exist in calledClass.
1072  */
1073 JNIEXPORT jint JNICALL
1074 JVM_GetCPFieldModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1075 
1076 /*
1077  * Returns the modifiers of a method in calledClass. The method is
1078  * referred to in class cb at constant pool entry index.
1079  *
1080  * Returns -1 if the method does not exist in calledClass.
1081  */
1082 JNIEXPORT jint JNICALL
1083 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1084 
1085 /*
1086  * Releases the UTF string obtained from the VM.
1087  */
1088 JNIEXPORT void JNICALL
1089 JVM_ReleaseUTF(const char *utf);
1090 
1091 /*
1092  * Compare if two classes are in the same package.
1093  */
1094 JNIEXPORT jboolean JNICALL
1095 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1096 
1097 /* Get classfile constants */
1098 #include &quot;classfile_constants.h&quot;
1099 
1100 /*
1101  * Support for a VM-independent class format checker.
1102  */
1103 typedef struct {
1104     unsigned long code;    /* byte code */
1105     unsigned long excs;    /* exceptions */
1106     unsigned long etab;    /* catch table */
1107     unsigned long lnum;    /* line number */
1108     unsigned long lvar;    /* local vars */
1109 } method_size_info;
1110 
1111 typedef struct {
1112     unsigned int constants;    /* constant pool */
1113     unsigned int fields;
1114     unsigned int methods;
1115     unsigned int interfaces;
1116     unsigned int fields2;      /* number of static 2-word fields */
1117     unsigned int innerclasses; /* # of records in InnerClasses attr */
1118 
1119     method_size_info clinit;   /* memory used in clinit */
1120     method_size_info main;     /* used everywhere else */
1121 } class_size_info;
1122 
1123 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1124                                         JVM_ACC_FINAL | \
1125                                         JVM_ACC_SUPER | \
1126                                         JVM_ACC_INTERFACE | \
1127                                         JVM_ACC_ABSTRACT | \
1128                                         JVM_ACC_ANNOTATION | \
1129                                         JVM_ACC_ENUM | \
1130                                         JVM_ACC_SYNTHETIC)
1131 
1132 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1133                                         JVM_ACC_PRIVATE | \
1134                                         JVM_ACC_PROTECTED | \
1135                                         JVM_ACC_STATIC | \
1136                                         JVM_ACC_FINAL | \
1137                                         JVM_ACC_VOLATILE | \
1138                                         JVM_ACC_TRANSIENT | \
1139                                         JVM_ACC_ENUM | \
1140                                         JVM_ACC_SYNTHETIC)
1141 
1142 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1143                                          JVM_ACC_PRIVATE | \
1144                                          JVM_ACC_PROTECTED | \
1145                                          JVM_ACC_STATIC | \
1146                                          JVM_ACC_FINAL | \
1147                                          JVM_ACC_SYNCHRONIZED | \
1148                                          JVM_ACC_BRIDGE | \
1149                                          JVM_ACC_VARARGS | \
1150                                          JVM_ACC_NATIVE | \
1151                                          JVM_ACC_ABSTRACT | \
1152                                          JVM_ACC_STRICT | \
1153                                          JVM_ACC_SYNTHETIC)
1154 
1155 
1156 /*************************************************************************
1157  PART 3: I/O and Network Support
1158  ************************************************************************/
1159 
1160 /*
1161  * Convert a pathname into native format.  This function does syntactic
1162  * cleanup, such as removing redundant separator characters.  It modifies
1163  * the given pathname string in place.
1164  */
1165 JNIEXPORT char * JNICALL
1166 JVM_NativePath(char *);
1167 
1168 /*
1169  * The standard printing functions supported by the Java VM. (Should they
1170  * be renamed to JVM_* in the future?
1171  */
1172 
1173 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1174  *  respectively, with the following differences:
1175  * - The string written to str is always zero-terminated, also in case of
1176  *   truncation (count is too small to hold the result string), unless count
1177  *   is 0. In case of truncation count-1 characters are written and &#39;\0&#39;
1178  *   appendend.
1179  * - If count is too small to hold the whole string, -1 is returned across
1180  *   all platforms. */
1181 
1182 JNIEXPORT int
1183 jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
1184 
1185 JNIEXPORT int
1186 jio_snprintf(char *str, size_t count, const char *fmt, ...);
1187 
1188 JNIEXPORT int
1189 jio_fprintf(FILE *, const char *fmt, ...);
1190 
1191 JNIEXPORT int
1192 jio_vfprintf(FILE *, const char *fmt, va_list args);
1193 
1194 
1195 JNIEXPORT void * JNICALL
1196 JVM_RawMonitorCreate(void);
1197 
1198 JNIEXPORT void JNICALL
1199 JVM_RawMonitorDestroy(void *mon);
1200 
1201 JNIEXPORT jint JNICALL
1202 JVM_RawMonitorEnter(void *mon);
1203 
1204 JNIEXPORT void JNICALL
1205 JVM_RawMonitorExit(void *mon);
1206 
1207 /*
1208  * java.lang.management support
1209  */
1210 JNIEXPORT void* JNICALL
1211 JVM_GetManagement(jint version);
1212 
1213 /*
1214  * com.sun.tools.attach.VirtualMachine support
1215  *
1216  * Initialize the agent properties with the properties maintained in the VM.
1217  */
1218 JNIEXPORT jobject JNICALL
1219 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1220 
1221 JNIEXPORT jstring JNICALL
1222 JVM_GetTemporaryDirectory(JNIEnv *env);
1223 
1224 /* Generics reflection support.
1225  *
1226  * Returns information about the given class&#39;s EnclosingMethod
1227  * attribute, if present, or null if the class had no enclosing
1228  * method.
1229  *
1230  * If non-null, the returned array contains three elements. Element 0
1231  * is the java.lang.Class of which the enclosing method is a member,
1232  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1233  * method&#39;s name and descriptor, respectively.
1234  */
1235 JNIEXPORT jobjectArray JNICALL
1236 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1237 
1238 /*
1239  * This structure is used by the launcher to get the default thread
1240  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1241  * version of 1.1.  As it is not supported otherwise, it has been removed
1242  * from jni.h
1243  */
1244 typedef struct JDK1_1InitArgs {
1245     jint version;
1246 
1247     char **properties;
1248     jint checkSource;
1249     jint nativeStackSize;
1250     jint javaStackSize;
1251     jint minHeapSize;
1252     jint maxHeapSize;
1253     jint verifyMode;
1254     char *classpath;
1255 
1256     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1257     void (JNICALL *exit)(jint code);
1258     void (JNICALL *abort)(void);
1259 
1260     jint enableClassGC;
1261     jint enableVerboseGC;
1262     jint disableAsyncGC;
1263     jint verbose;
1264     jboolean debugging;
1265     jint debugPort;
1266 } JDK1_1InitArgs;
1267 
1268 
1269 #ifdef __cplusplus
1270 } /* extern &quot;C&quot; */
1271 
1272 #endif /* __cplusplus */
1273 
1274 #endif /* !_JAVASOFT_JVM_H_ */
    </pre>
  </body>
</html>