<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/klass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
 28 #include &quot;classfile/dictionary.hpp&quot;
 29 #include &quot;classfile/javaClasses.hpp&quot;
 30 #include &quot;classfile/moduleEntry.hpp&quot;
 31 #include &quot;classfile/systemDictionary.hpp&quot;
 32 #include &quot;classfile/systemDictionaryShared.hpp&quot;
 33 #include &quot;classfile/vmSymbols.hpp&quot;
 34 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/heapShared.hpp&quot;
 37 #include &quot;memory/metadataFactory.hpp&quot;
 38 #include &quot;memory/metaspaceClosure.hpp&quot;
 39 #include &quot;memory/metaspaceShared.hpp&quot;
 40 #include &quot;memory/oopFactory.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
 42 #include &quot;memory/universe.hpp&quot;
 43 #include &quot;oops/compressedOops.inline.hpp&quot;
 44 #include &quot;oops/instanceKlass.hpp&quot;
 45 #include &quot;oops/klass.inline.hpp&quot;
 46 #include &quot;oops/oop.inline.hpp&quot;
 47 #include &quot;oops/oopHandle.inline.hpp&quot;
 48 #include &quot;runtime/atomic.hpp&quot;
 49 #include &quot;runtime/handles.inline.hpp&quot;
 50 #include &quot;utilities/macros.hpp&quot;
 51 #include &quot;utilities/powerOfTwo.hpp&quot;
 52 #include &quot;utilities/stack.inline.hpp&quot;
 53 
 54 void Klass::set_java_mirror(Handle m) {
 55   assert(!m.is_null(), &quot;New mirror should never be null.&quot;);
<a name="1" id="anc1"></a><span class="line-modified"> 56   assert(_java_mirror.resolve() == NULL, &quot;should only be used to initialize mirror&quot;);</span>
 57   _java_mirror = class_loader_data()-&gt;add_handle(m);
 58 }
 59 
 60 oop Klass::java_mirror_no_keepalive() const {
 61   return _java_mirror.peek();
 62 }
 63 
<a name="2" id="anc2"></a>



 64 bool Klass::is_cloneable() const {
 65   return _access_flags.is_cloneable_fast() ||
 66          is_subtype_of(SystemDictionary::Cloneable_klass());
 67 }
 68 
 69 void Klass::set_is_cloneable() {
 70   if (name() == vmSymbols::java_lang_invoke_MemberName()) {
 71     assert(is_final(), &quot;no subclasses allowed&quot;);
 72     // MemberName cloning should not be intrinsified and always happen in JVM_Clone.
 73   } else if (is_instance_klass() &amp;&amp; InstanceKlass::cast(this)-&gt;reference_type() != REF_NONE) {
 74     // Reference cloning should not be intrinsified and always happen in JVM_Clone.
 75   } else {
 76     _access_flags.set_is_cloneable_fast();
 77   }
 78 }
 79 
 80 void Klass::set_name(Symbol* n) {
 81   _name = n;
 82   if (_name != NULL) _name-&gt;increment_refcount();
 83 
 84   if (Arguments::is_dumping_archive() &amp;&amp; is_instance_klass()) {
 85     SystemDictionaryShared::init_dumptime_info(InstanceKlass::cast(this));
 86   }
 87 }
 88 
 89 bool Klass::is_subclass_of(const Klass* k) const {
 90   // Run up the super chain and check
 91   if (this == k) return true;
 92 
 93   Klass* t = const_cast&lt;Klass*&gt;(this)-&gt;super();
 94 
 95   while (t != NULL) {
 96     if (t == k) return true;
 97     t = t-&gt;super();
 98   }
 99   return false;
100 }
101 
102 void Klass::release_C_heap_structures() {
103   if (_name != NULL) _name-&gt;decrement_refcount();
104 }
105 
106 bool Klass::search_secondary_supers(Klass* k) const {
107   // Put some extra logic here out-of-line, before the search proper.
108   // This cuts down the size of the inline method.
109 
110   // This is necessary, since I am never in my own secondary_super list.
111   if (this == k)
112     return true;
113   // Scan the array-of-objects for a match
114   int cnt = secondary_supers()-&gt;length();
115   for (int i = 0; i &lt; cnt; i++) {
116     if (secondary_supers()-&gt;at(i) == k) {
117       ((Klass*)this)-&gt;set_secondary_super_cache(k);
118       return true;
119     }
120   }
121   return false;
122 }
123 
124 // Return self, except for abstract classes with exactly 1
125 // implementor.  Then return the 1 concrete implementation.
126 Klass *Klass::up_cast_abstract() {
127   Klass *r = this;
128   while( r-&gt;is_abstract() ) {   // Receiver is abstract?
129     Klass *s = r-&gt;subklass();   // Check for exactly 1 subklass
130     if (s == NULL || s-&gt;next_sibling() != NULL) // Oops; wrong count; give up
131       return this;              // Return &#39;this&#39; as a no-progress flag
132     r = s;                    // Loop till find concrete class
133   }
134   return r;                   // Return the 1 concrete class
135 }
136 
137 // Find LCA in class hierarchy
138 Klass *Klass::LCA( Klass *k2 ) {
139   Klass *k1 = this;
140   while( 1 ) {
141     if( k1-&gt;is_subtype_of(k2) ) return k2;
142     if( k2-&gt;is_subtype_of(k1) ) return k1;
143     k1 = k1-&gt;super();
144     k2 = k2-&gt;super();
145   }
146 }
147 
148 
149 void Klass::check_valid_for_instantiation(bool throwError, TRAPS) {
150   ResourceMark rm(THREAD);
151   THROW_MSG(throwError ? vmSymbols::java_lang_InstantiationError()
152             : vmSymbols::java_lang_InstantiationException(), external_name());
153 }
154 
155 
156 void Klass::copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS) {
157   ResourceMark rm(THREAD);
158   assert(s != NULL, &quot;Throw NPE!&quot;);
159   THROW_MSG(vmSymbols::java_lang_ArrayStoreException(),
160             err_msg(&quot;arraycopy: source type %s is not an array&quot;, s-&gt;klass()-&gt;external_name()));
161 }
162 
163 
164 void Klass::initialize(TRAPS) {
165   ShouldNotReachHere();
166 }
167 
168 Klass* Klass::find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
169 #ifdef ASSERT
170   tty-&gt;print_cr(&quot;Error: find_field called on a klass oop.&quot;
171                 &quot; Likely error: reflection method does not correctly&quot;
172                 &quot; wrap return value in a mirror object.&quot;);
173 #endif
174   ShouldNotReachHere();
175   return NULL;
176 }
177 
178 Method* Klass::uncached_lookup_method(const Symbol* name, const Symbol* signature,
179                                       OverpassLookupMode overpass_mode,
180                                       PrivateLookupMode private_mode) const {
181 #ifdef ASSERT
182   tty-&gt;print_cr(&quot;Error: uncached_lookup_method called on a klass oop.&quot;
183                 &quot; Likely error: reflection method does not correctly&quot;
184                 &quot; wrap return value in a mirror object.&quot;);
185 #endif
186   ShouldNotReachHere();
187   return NULL;
188 }
189 
190 void* Klass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw() {
191   return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);
192 }
193 
194 // &quot;Normal&quot; instantiation is preceeded by a MetaspaceObj allocation
195 // which zeros out memory - calloc equivalent.
196 // The constructor is also used from CppVtableCloner,
197 // which doesn&#39;t zero out the memory before calling the constructor.
<a name="3" id="anc3"></a><span class="line-removed">198 // Need to set the _java_mirror field explicitly to not hit an assert that the field</span>
<span class="line-removed">199 // should be NULL before setting it.</span>
200 Klass::Klass(KlassID id) : _id(id),
<a name="4" id="anc4"></a><span class="line-removed">201                            _java_mirror(NULL),</span>
202                            _prototype_header(markWord::prototype()),
203                            _shared_class_path_index(-1) {
204   CDS_ONLY(_shared_class_flags = 0;)
205   CDS_JAVA_HEAP_ONLY(_archived_mirror = 0;)
206   _primary_supers[0] = this;
207   set_super_check_offset(in_bytes(primary_supers_offset()));
208 }
209 
210 jint Klass::array_layout_helper(BasicType etype) {
211   assert(etype &gt;= T_BOOLEAN &amp;&amp; etype &lt;= T_OBJECT, &quot;valid etype&quot;);
212   // Note that T_ARRAY is not allowed here.
213   int  hsize = arrayOopDesc::base_offset_in_bytes(etype);
214   int  esize = type2aelembytes(etype);
215   bool isobj = (etype == T_OBJECT);
216   int  tag   =  isobj ? _lh_array_tag_obj_value : _lh_array_tag_type_value;
217   int lh = array_layout_helper(tag, hsize, etype, exact_log2(esize));
218 
219   assert(lh &lt; (int)_lh_neutral_value, &quot;must look like an array layout&quot;);
220   assert(layout_helper_is_array(lh), &quot;correct kind&quot;);
221   assert(layout_helper_is_objArray(lh) == isobj, &quot;correct kind&quot;);
222   assert(layout_helper_is_typeArray(lh) == !isobj, &quot;correct kind&quot;);
223   assert(layout_helper_header_size(lh) == hsize, &quot;correct decode&quot;);
224   assert(layout_helper_element_type(lh) == etype, &quot;correct decode&quot;);
225   assert(1 &lt;&lt; layout_helper_log2_element_size(lh) == esize, &quot;correct decode&quot;);
226 
227   return lh;
228 }
229 
230 bool Klass::can_be_primary_super_slow() const {
231   if (super() == NULL)
232     return true;
233   else if (super()-&gt;super_depth() &gt;= primary_super_limit()-1)
234     return false;
235   else
236     return true;
237 }
238 
239 void Klass::initialize_supers(Klass* k, Array&lt;InstanceKlass*&gt;* transitive_interfaces, TRAPS) {
240   if (k == NULL) {
241     set_super(NULL);
242     _primary_supers[0] = this;
243     assert(super_depth() == 0, &quot;Object must already be initialized properly&quot;);
244   } else if (k != super() || k == SystemDictionary::Object_klass()) {
245     assert(super() == NULL || super() == SystemDictionary::Object_klass(),
246            &quot;initialize this only once to a non-trivial value&quot;);
247     set_super(k);
248     Klass* sup = k;
249     int sup_depth = sup-&gt;super_depth();
250     juint my_depth  = MIN2(sup_depth + 1, (int)primary_super_limit());
251     if (!can_be_primary_super_slow())
252       my_depth = primary_super_limit();
253     for (juint i = 0; i &lt; my_depth; i++) {
254       _primary_supers[i] = sup-&gt;_primary_supers[i];
255     }
256     Klass* *super_check_cell;
257     if (my_depth &lt; primary_super_limit()) {
258       _primary_supers[my_depth] = this;
259       super_check_cell = &amp;_primary_supers[my_depth];
260     } else {
261       // Overflow of the primary_supers array forces me to be secondary.
262       super_check_cell = &amp;_secondary_super_cache;
263     }
264     set_super_check_offset((address)super_check_cell - (address) this);
265 
266 #ifdef ASSERT
267     {
268       juint j = super_depth();
269       assert(j == my_depth, &quot;computed accessor gets right answer&quot;);
270       Klass* t = this;
271       while (!t-&gt;can_be_primary_super()) {
272         t = t-&gt;super();
273         j = t-&gt;super_depth();
274       }
275       for (juint j1 = j+1; j1 &lt; primary_super_limit(); j1++) {
276         assert(primary_super_of_depth(j1) == NULL, &quot;super list padding&quot;);
277       }
278       while (t != NULL) {
279         assert(primary_super_of_depth(j) == t, &quot;super list initialization&quot;);
280         t = t-&gt;super();
281         --j;
282       }
283       assert(j == (juint)-1, &quot;correct depth count&quot;);
284     }
285 #endif
286   }
287 
288   if (secondary_supers() == NULL) {
289 
290     // Now compute the list of secondary supertypes.
291     // Secondaries can occasionally be on the super chain,
292     // if the inline &quot;_primary_supers&quot; array overflows.
293     int extras = 0;
294     Klass* p;
295     for (p = super(); !(p == NULL || p-&gt;can_be_primary_super()); p = p-&gt;super()) {
296       ++extras;
297     }
298 
299     ResourceMark rm(THREAD);  // need to reclaim GrowableArrays allocated below
300 
301     // Compute the &quot;real&quot; non-extra secondaries.
302     GrowableArray&lt;Klass*&gt;* secondaries = compute_secondary_supers(extras, transitive_interfaces);
303     if (secondaries == NULL) {
304       // secondary_supers set by compute_secondary_supers
305       return;
306     }
307 
308     GrowableArray&lt;Klass*&gt;* primaries = new GrowableArray&lt;Klass*&gt;(extras);
309 
310     for (p = super(); !(p == NULL || p-&gt;can_be_primary_super()); p = p-&gt;super()) {
311       int i;                    // Scan for overflow primaries being duplicates of 2nd&#39;arys
312 
313       // This happens frequently for very deeply nested arrays: the
314       // primary superclass chain overflows into the secondary.  The
315       // secondary list contains the element_klass&#39;s secondaries with
316       // an extra array dimension added.  If the element_klass&#39;s
317       // secondary list already contains some primary overflows, they
318       // (with the extra level of array-ness) will collide with the
319       // normal primary superclass overflows.
320       for( i = 0; i &lt; secondaries-&gt;length(); i++ ) {
321         if( secondaries-&gt;at(i) == p )
322           break;
323       }
324       if( i &lt; secondaries-&gt;length() )
325         continue;               // It&#39;s a dup, don&#39;t put it in
326       primaries-&gt;push(p);
327     }
328     // Combine the two arrays into a metadata object to pack the array.
329     // The primaries are added in the reverse order, then the secondaries.
330     int new_length = primaries-&gt;length() + secondaries-&gt;length();
331     Array&lt;Klass*&gt;* s2 = MetadataFactory::new_array&lt;Klass*&gt;(
332                                        class_loader_data(), new_length, CHECK);
333     int fill_p = primaries-&gt;length();
334     for (int j = 0; j &lt; fill_p; j++) {
335       s2-&gt;at_put(j, primaries-&gt;pop());  // add primaries in reverse order.
336     }
337     for( int j = 0; j &lt; secondaries-&gt;length(); j++ ) {
338       s2-&gt;at_put(j+fill_p, secondaries-&gt;at(j));  // add secondaries on the end.
339     }
340 
341   #ifdef ASSERT
342       // We must not copy any NULL placeholders left over from bootstrap.
343     for (int j = 0; j &lt; s2-&gt;length(); j++) {
344       assert(s2-&gt;at(j) != NULL, &quot;correct bootstrapping order&quot;);
345     }
346   #endif
347 
348     set_secondary_supers(s2);
349   }
350 }
351 
352 GrowableArray&lt;Klass*&gt;* Klass::compute_secondary_supers(int num_extra_slots,
353                                                        Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
354   assert(num_extra_slots == 0, &quot;override for complex klasses&quot;);
355   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
356   set_secondary_supers(Universe::the_empty_klass_array());
357   return NULL;
358 }
359 
360 
361 // superklass links
362 InstanceKlass* Klass::superklass() const {
363   assert(super() == NULL || super()-&gt;is_instance_klass(), &quot;must be instance klass&quot;);
364   return _super == NULL ? NULL : InstanceKlass::cast(_super);
365 }
366 
367 // subklass links.  Used by the compiler (and vtable initialization)
368 // May be cleaned concurrently, so must use the Compile_lock.
369 // The log parameter is for clean_weak_klass_links to report unlinked classes.
370 Klass* Klass::subklass(bool log) const {
371   // Need load_acquire on the _subklass, because it races with inserts that
372   // publishes freshly initialized data.
373   for (Klass* chain = Atomic::load_acquire(&amp;_subklass);
374        chain != NULL;
375        // Do not need load_acquire on _next_sibling, because inserts never
376        // create _next_sibling edges to dead data.
377        chain = Atomic::load(&amp;chain-&gt;_next_sibling))
378   {
379     if (chain-&gt;is_loader_alive()) {
380       return chain;
381     } else if (log) {
382       if (log_is_enabled(Trace, class, unload)) {
383         ResourceMark rm;
384         log_trace(class, unload)(&quot;unlinking class (subclass): %s&quot;, chain-&gt;external_name());
385       }
386     }
387   }
388   return NULL;
389 }
390 
391 Klass* Klass::next_sibling(bool log) const {
392   // Do not need load_acquire on _next_sibling, because inserts never
393   // create _next_sibling edges to dead data.
394   for (Klass* chain = Atomic::load(&amp;_next_sibling);
395        chain != NULL;
396        chain = Atomic::load(&amp;chain-&gt;_next_sibling)) {
397     // Only return alive klass, there may be stale klass
398     // in this chain if cleaned concurrently.
399     if (chain-&gt;is_loader_alive()) {
400       return chain;
401     } else if (log) {
402       if (log_is_enabled(Trace, class, unload)) {
403         ResourceMark rm;
404         log_trace(class, unload)(&quot;unlinking class (sibling): %s&quot;, chain-&gt;external_name());
405       }
406     }
407   }
408   return NULL;
409 }
410 
411 void Klass::set_subklass(Klass* s) {
412   assert(s != this, &quot;sanity check&quot;);
413   Atomic::release_store(&amp;_subklass, s);
414 }
415 
416 void Klass::set_next_sibling(Klass* s) {
417   assert(s != this, &quot;sanity check&quot;);
418   // Does not need release semantics. If used by cleanup, it will link to
419   // already safely published data, and if used by inserts, will be published
420   // safely using cmpxchg.
421   Atomic::store(&amp;_next_sibling, s);
422 }
423 
424 void Klass::append_to_sibling_list() {
425   if (Universe::is_fully_initialized()) {
426     assert_locked_or_safepoint(Compile_lock);
427   }
428   debug_only(verify();)
429   // add ourselves to superklass&#39; subklass list
430   InstanceKlass* super = superklass();
431   if (super == NULL) return;        // special case: class Object
432   assert((!super-&gt;is_interface()    // interfaces cannot be supers
433           &amp;&amp; (super-&gt;superklass() == NULL || !is_interface())),
434          &quot;an interface can only be a subklass of Object&quot;);
435 
436   // Make sure there is no stale subklass head
437   super-&gt;clean_subklass();
438 
439   for (;;) {
440     Klass* prev_first_subklass = Atomic::load_acquire(&amp;_super-&gt;_subklass);
441     if (prev_first_subklass != NULL) {
442       // set our sibling to be the superklass&#39; previous first subklass
443       assert(prev_first_subklass-&gt;is_loader_alive(), &quot;May not attach not alive klasses&quot;);
444       set_next_sibling(prev_first_subklass);
445     }
446     // Note that the prev_first_subklass is always alive, meaning no sibling_next links
447     // are ever created to not alive klasses. This is an important invariant of the lock-free
448     // cleaning protocol, that allows us to safely unlink dead klasses from the sibling list.
449     if (Atomic::cmpxchg(&amp;super-&gt;_subklass, prev_first_subklass, this) == prev_first_subklass) {
450       return;
451     }
452   }
453   debug_only(verify();)
454 }
455 
456 void Klass::clean_subklass() {
457   for (;;) {
458     // Need load_acquire, due to contending with concurrent inserts
459     Klass* subklass = Atomic::load_acquire(&amp;_subklass);
460     if (subklass == NULL || subklass-&gt;is_loader_alive()) {
461       return;
462     }
463     // Try to fix _subklass until it points at something not dead.
464     Atomic::cmpxchg(&amp;_subklass, subklass, subklass-&gt;next_sibling());
465   }
466 }
467 
468 void Klass::clean_weak_klass_links(bool unloading_occurred, bool clean_alive_klasses) {
469   if (!ClassUnloading || !unloading_occurred) {
470     return;
471   }
472 
473   Klass* root = SystemDictionary::Object_klass();
474   Stack&lt;Klass*, mtGC&gt; stack;
475 
476   stack.push(root);
477   while (!stack.is_empty()) {
478     Klass* current = stack.pop();
479 
480     assert(current-&gt;is_loader_alive(), &quot;just checking, this should be live&quot;);
481 
482     // Find and set the first alive subklass
483     Klass* sub = current-&gt;subklass(true);
484     current-&gt;clean_subklass();
485     if (sub != NULL) {
486       stack.push(sub);
487     }
488 
489     // Find and set the first alive sibling
490     Klass* sibling = current-&gt;next_sibling(true);
491     current-&gt;set_next_sibling(sibling);
492     if (sibling != NULL) {
493       stack.push(sibling);
494     }
495 
496     // Clean the implementors list and method data.
497     if (clean_alive_klasses &amp;&amp; current-&gt;is_instance_klass()) {
498       InstanceKlass* ik = InstanceKlass::cast(current);
499       ik-&gt;clean_weak_instanceklass_links();
500 
501       // JVMTI RedefineClasses creates previous versions that are not in
502       // the class hierarchy, so process them here.
503       while ((ik = ik-&gt;previous_versions()) != NULL) {
504         ik-&gt;clean_weak_instanceklass_links();
505       }
506     }
507   }
508 }
509 
510 void Klass::metaspace_pointers_do(MetaspaceClosure* it) {
511   if (log_is_enabled(Trace, cds)) {
512     ResourceMark rm;
513     log_trace(cds)(&quot;Iter(Klass): %p (%s)&quot;, this, external_name());
514   }
515 
516   it-&gt;push(&amp;_name);
517   it-&gt;push(&amp;_secondary_super_cache);
518   it-&gt;push(&amp;_secondary_supers);
519   for (int i = 0; i &lt; _primary_super_limit; i++) {
520     it-&gt;push(&amp;_primary_supers[i]);
521   }
522   it-&gt;push(&amp;_super);
523   it-&gt;push((Klass**)&amp;_subklass);
524   it-&gt;push((Klass**)&amp;_next_sibling);
525   it-&gt;push(&amp;_next_link);
526 
527   vtableEntry* vt = start_of_vtable();
528   for (int i=0; i&lt;vtable_length(); i++) {
529     it-&gt;push(vt[i].method_addr());
530   }
531 }
532 
533 void Klass::remove_unshareable_info() {
534   assert (Arguments::is_dumping_archive(),
535           &quot;only called during CDS dump time&quot;);
536   JFR_ONLY(REMOVE_ID(this);)
537   if (log_is_enabled(Trace, cds, unshareable)) {
538     ResourceMark rm;
539     log_trace(cds, unshareable)(&quot;remove: %s&quot;, external_name());
540   }
541 
542   set_subklass(NULL);
543   set_next_sibling(NULL);
544   set_next_link(NULL);
545 
546   // Null out class_loader_data because we don&#39;t share that yet.
547   set_class_loader_data(NULL);
548   set_is_shared();
549 }
550 
551 void Klass::remove_java_mirror() {
552   Arguments::assert_is_dumping_archive();
553   if (log_is_enabled(Trace, cds, unshareable)) {
554     ResourceMark rm;
555     log_trace(cds, unshareable)(&quot;remove java_mirror: %s&quot;, external_name());
556   }
557   // Just null out the mirror.  The class_loader_data() no longer exists.
<a name="5" id="anc5"></a><span class="line-modified">558   _java_mirror = OopHandle();</span>
559 }
560 
561 void Klass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {
562   assert(is_klass(), &quot;ensure C++ vtable is restored&quot;);
563   assert(is_shared(), &quot;must be set&quot;);
564   JFR_ONLY(RESTORE_ID(this);)
565   if (log_is_enabled(Trace, cds, unshareable)) {
566     ResourceMark rm(THREAD);
567     log_trace(cds, unshareable)(&quot;restore: %s&quot;, external_name());
568   }
569 
570   // If an exception happened during CDS restore, some of these fields may already be
571   // set.  We leave the class on the CLD list, even if incomplete so that we don&#39;t
572   // modify the CLD list outside a safepoint.
573   if (class_loader_data() == NULL) {
574     // Restore class_loader_data to the null class loader data
575     set_class_loader_data(loader_data);
576 
577     // Add to null class loader list first before creating the mirror
578     // (same order as class file parsing)
579     loader_data-&gt;add_class(this);
580   }
581 
582   Handle loader(THREAD, loader_data-&gt;class_loader());
583   ModuleEntry* module_entry = NULL;
584   Klass* k = this;
585   if (k-&gt;is_objArray_klass()) {
586     k = ObjArrayKlass::cast(k)-&gt;bottom_klass();
587   }
588   // Obtain klass&#39; module.
589   if (k-&gt;is_instance_klass()) {
590     InstanceKlass* ik = (InstanceKlass*) k;
591     module_entry = ik-&gt;module();
592   } else {
593     module_entry = ModuleEntryTable::javabase_moduleEntry();
594   }
595   // Obtain java.lang.Module, if available
596   Handle module_handle(THREAD, ((module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL));
597 
598   if (this-&gt;has_raw_archived_mirror()) {
599     ResourceMark rm(THREAD);
600     log_debug(cds, mirror)(&quot;%s has raw archived mirror&quot;, external_name());
601     if (HeapShared::open_archive_heap_region_mapped()) {
602       bool present = java_lang_Class::restore_archived_mirror(this, loader, module_handle,
603                                                               protection_domain,
604                                                               CHECK);
605       if (present) {
606         return;
607       }
608     }
609 
610     // No archived mirror data
611     log_debug(cds, mirror)(&quot;No archived mirror data for %s&quot;, external_name());
<a name="6" id="anc6"></a><span class="line-modified">612     _java_mirror = OopHandle();</span>
613     this-&gt;clear_has_raw_archived_mirror();
614   }
615 
616   // Only recreate it if not present.  A previous attempt to restore may have
617   // gotten an OOM later but keep the mirror if it was created.
618   if (java_mirror() == NULL) {
619     log_trace(cds, mirror)(&quot;Recreate mirror for %s&quot;, external_name());
620     java_lang_Class::create_mirror(this, loader, module_handle, protection_domain, Handle(), CHECK);
621   }
622 }
623 
624 #if INCLUDE_CDS_JAVA_HEAP
625 // Used at CDS dump time to access the archived mirror. No GC barrier.
626 oop Klass::archived_java_mirror_raw() {
627   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
628   return CompressedOops::decode(_archived_mirror);
629 }
630 
631 narrowOop Klass::archived_java_mirror_raw_narrow() {
632   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
633   return _archived_mirror;
634 }
635 
636 // No GC barrier
637 void Klass::set_archived_java_mirror_raw(oop m) {
638   assert(DumpSharedSpaces, &quot;called only during runtime&quot;);
639   _archived_mirror = CompressedOops::encode(m);
640 }
641 #endif // INCLUDE_CDS_JAVA_HEAP
642 
643 Klass* Klass::array_klass_or_null(int rank) {
644   EXCEPTION_MARK;
645   // No exception can be thrown by array_klass_impl when called with or_null == true.
646   // (In anycase, the execption mark will fail if it do so)
647   return array_klass_impl(true, rank, THREAD);
648 }
649 
650 
651 Klass* Klass::array_klass_or_null() {
652   EXCEPTION_MARK;
653   // No exception can be thrown by array_klass_impl when called with or_null == true.
654   // (In anycase, the execption mark will fail if it do so)
655   return array_klass_impl(true, THREAD);
656 }
657 
658 
659 Klass* Klass::array_klass_impl(bool or_null, int rank, TRAPS) {
660   fatal(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
661   return NULL;
662 }
663 
664 
665 Klass* Klass::array_klass_impl(bool or_null, TRAPS) {
666   fatal(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
667   return NULL;
668 }
669 
670 void Klass::check_array_allocation_length(int length, int max_length, TRAPS) {
671   if (length &gt; max_length) {
672     if (!THREAD-&gt;in_retryable_allocation()) {
673       report_java_out_of_memory(&quot;Requested array size exceeds VM limit&quot;);
674       JvmtiExport::post_array_size_exhausted();
675       THROW_OOP(Universe::out_of_memory_error_array_size());
676     } else {
677       THROW_OOP(Universe::out_of_memory_error_retry());
678     }
679   } else if (length &lt; 0) {
680     THROW_MSG(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
681   }
682 }
683 
684 // Replace the last &#39;+&#39; char with &#39;/&#39;.
685 static char* convert_hidden_name_to_java(Symbol* name) {
686   size_t name_len = name-&gt;utf8_length();
687   char* result = NEW_RESOURCE_ARRAY(char, name_len + 1);
688   name-&gt;as_klass_external_name(result, (int)name_len + 1);
689   for (int index = (int)name_len; index &gt; 0; index--) {
690     if (result[index] == &#39;+&#39;) {
691       result[index] = JVM_SIGNATURE_SLASH;
692       break;
693     }
694   }
695   return result;
696 }
697 
698 // In product mode, this function doesn&#39;t have virtual function calls so
699 // there might be some performance advantage to handling InstanceKlass here.
700 const char* Klass::external_name() const {
701   if (is_instance_klass()) {
702     const InstanceKlass* ik = static_cast&lt;const InstanceKlass*&gt;(this);
703     if (ik-&gt;is_unsafe_anonymous()) {
704       char addr_buf[20];
705       jio_snprintf(addr_buf, 20, &quot;/&quot; INTPTR_FORMAT, p2i(ik));
706       size_t addr_len = strlen(addr_buf);
707       size_t name_len = name()-&gt;utf8_length();
708       char*  result   = NEW_RESOURCE_ARRAY(char, name_len + addr_len + 1);
709       name()-&gt;as_klass_external_name(result, (int) name_len + 1);
710       assert(strlen(result) == name_len, &quot;&quot;);
711       strcpy(result + name_len, addr_buf);
712       assert(strlen(result) == name_len + addr_len, &quot;&quot;);
713       return result;
714 
715     } else if (ik-&gt;is_hidden()) {
716       char* result = convert_hidden_name_to_java(name());
717       return result;
718     }
719   } else if (is_objArray_klass() &amp;&amp; ObjArrayKlass::cast(this)-&gt;bottom_klass()-&gt;is_hidden()) {
720     char* result = convert_hidden_name_to_java(name());
721     return result;
722   }
723   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;
724   return name()-&gt;as_klass_external_name();
725 }
726 
727 const char* Klass::signature_name() const {
728   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;
729   if (is_objArray_klass() &amp;&amp; ObjArrayKlass::cast(this)-&gt;bottom_klass()-&gt;is_hidden()) {
730     size_t name_len = name()-&gt;utf8_length();
731     char* result = NEW_RESOURCE_ARRAY(char, name_len + 1);
732     name()-&gt;as_C_string(result, (int)name_len + 1);
733     for (int index = (int)name_len; index &gt; 0; index--) {
734       if (result[index] == &#39;+&#39;) {
735         result[index] = JVM_SIGNATURE_DOT;
736         break;
737       }
738     }
739     return result;
740   }
741   return name()-&gt;as_C_string();
742 }
743 
744 const char* Klass::external_kind() const {
745   if (is_interface()) return &quot;interface&quot;;
746   if (is_abstract()) return &quot;abstract class&quot;;
747   return &quot;class&quot;;
748 }
749 
750 // Unless overridden, modifier_flags is 0.
751 jint Klass::compute_modifier_flags(TRAPS) const {
752   return 0;
753 }
754 
755 int Klass::atomic_incr_biased_lock_revocation_count() {
756   return (int) Atomic::add(&amp;_biased_lock_revocation_count, 1);
757 }
758 
759 // Unless overridden, jvmti_class_status has no flags set.
760 jint Klass::jvmti_class_status() const {
761   return 0;
762 }
763 
764 
765 // Printing
766 
767 void Klass::print_on(outputStream* st) const {
768   ResourceMark rm;
769   // print title
770   st-&gt;print(&quot;%s&quot;, internal_name());
771   print_address_on(st);
772   st-&gt;cr();
773 }
774 
775 #define BULLET  &quot; - &quot;
776 
777 // Caller needs ResourceMark
778 void Klass::oop_print_on(oop obj, outputStream* st) {
779   // print title
780   st-&gt;print_cr(&quot;%s &quot;, internal_name());
781   obj-&gt;print_address_on(st);
782 
783   if (WizardMode) {
784      // print header
785      obj-&gt;mark().print_on(st);
786      st-&gt;cr();
787      st-&gt;print(BULLET&quot;prototype_header: &quot; INTPTR_FORMAT, _prototype_header.value());
788      st-&gt;cr();
789   }
790 
791   // print class
792   st-&gt;print(BULLET&quot;klass: &quot;);
793   obj-&gt;klass()-&gt;print_value_on(st);
794   st-&gt;cr();
795 }
796 
797 void Klass::oop_print_value_on(oop obj, outputStream* st) {
798   // print title
799   ResourceMark rm;              // Cannot print in debug mode without this
800   st-&gt;print(&quot;%s&quot;, internal_name());
801   obj-&gt;print_address_on(st);
802 }
803 
804 // Verification
805 
806 void Klass::verify_on(outputStream* st) {
807 
808   // This can be expensive, but it is worth checking that this klass is actually
809   // in the CLD graph but not in production.
810   assert(Metaspace::contains((address)this), &quot;Should be&quot;);
811 
812   guarantee(this-&gt;is_klass(),&quot;should be klass&quot;);
813 
814   if (super() != NULL) {
815     guarantee(super()-&gt;is_klass(), &quot;should be klass&quot;);
816   }
817   if (secondary_super_cache() != NULL) {
818     Klass* ko = secondary_super_cache();
819     guarantee(ko-&gt;is_klass(), &quot;should be klass&quot;);
820   }
821   for ( uint i = 0; i &lt; primary_super_limit(); i++ ) {
822     Klass* ko = _primary_supers[i];
823     if (ko != NULL) {
824       guarantee(ko-&gt;is_klass(), &quot;should be klass&quot;);
825     }
826   }
827 
828   if (java_mirror_no_keepalive() != NULL) {
829     guarantee(oopDesc::is_oop(java_mirror_no_keepalive()), &quot;should be instance&quot;);
830   }
831 }
832 
833 void Klass::oop_verify_on(oop obj, outputStream* st) {
834   guarantee(oopDesc::is_oop(obj),  &quot;should be oop&quot;);
835   guarantee(obj-&gt;klass()-&gt;is_klass(), &quot;klass field is not a klass&quot;);
836 }
837 
838 bool Klass::is_valid(Klass* k) {
839   if (!is_aligned(k, sizeof(MetaWord))) return false;
840   if ((size_t)k &lt; os::min_page_size()) return false;
841 
842   if (!os::is_readable_range(k, k + 1)) return false;
843   if (!Metaspace::contains(k)) return false;
844 
845   if (!Symbol::is_valid(k-&gt;name())) return false;
846   return ClassLoaderDataGraph::is_valid(k-&gt;class_loader_data());
847 }
848 
849 Method* Klass::method_at_vtable(int index)  {
850 #ifndef PRODUCT
851   assert(index &gt;= 0, &quot;valid vtable index&quot;);
852   if (DebugVtables) {
853     verify_vtable_index(index);
854   }
855 #endif
856   return start_of_vtable()[index].method();
857 }
858 
859 
860 #ifndef PRODUCT
861 
862 bool Klass::verify_vtable_index(int i) {
863   int limit = vtable_length()/vtableEntry::size();
864   assert(i &gt;= 0 &amp;&amp; i &lt; limit, &quot;index %d out of bounds %d&quot;, i, limit);
865   return true;
866 }
867 
868 #endif // PRODUCT
869 
870 // Caller needs ResourceMark
871 // joint_in_module_of_loader provides an optimization if 2 classes are in
872 // the same module to succinctly print out relevant information about their
873 // module name and class loader&#39;s name_and_id for error messages.
874 // Format:
875 //   &lt;fully-qualified-external-class-name1&gt; and &lt;fully-qualified-external-class-name2&gt;
876 //                      are in module &lt;module-name&gt;[@&lt;version&gt;]
877 //                      of loader &lt;loader-name_and_id&gt;[, parent loader &lt;parent-loader-name_and_id&gt;]
878 const char* Klass::joint_in_module_of_loader(const Klass* class2, bool include_parent_loader) const {
879   assert(module() == class2-&gt;module(), &quot;classes do not have the same module&quot;);
880   const char* class1_name = external_name();
881   size_t len = strlen(class1_name) + 1;
882 
883   const char* class2_description = class2-&gt;class_in_module_of_loader(true, include_parent_loader);
884   len += strlen(class2_description);
885 
886   len += strlen(&quot; and &quot;);
887 
888   char* joint_description = NEW_RESOURCE_ARRAY_RETURN_NULL(char, len);
889 
890   // Just return the FQN if error when allocating string
891   if (joint_description == NULL) {
892     return class1_name;
893   }
894 
895   jio_snprintf(joint_description, len, &quot;%s and %s&quot;,
896                class1_name,
897                class2_description);
898 
899   return joint_description;
900 }
901 
902 // Caller needs ResourceMark
903 // class_in_module_of_loader provides a standard way to include
904 // relevant information about a class, such as its module name as
905 // well as its class loader&#39;s name_and_id, in error messages and logging.
906 // Format:
907 //   &lt;fully-qualified-external-class-name&gt; is in module &lt;module-name&gt;[@&lt;version&gt;]
908 //                                         of loader &lt;loader-name_and_id&gt;[, parent loader &lt;parent-loader-name_and_id&gt;]
909 const char* Klass::class_in_module_of_loader(bool use_are, bool include_parent_loader) const {
910   // 1. fully qualified external name of class
911   const char* klass_name = external_name();
912   size_t len = strlen(klass_name) + 1;
913 
914   // 2. module name + @version
915   const char* module_name = &quot;&quot;;
916   const char* version = &quot;&quot;;
917   bool has_version = false;
918   bool module_is_named = false;
919   const char* module_name_phrase = &quot;&quot;;
920   const Klass* bottom_klass = is_objArray_klass() ?
921                                 ObjArrayKlass::cast(this)-&gt;bottom_klass() : this;
922   if (bottom_klass-&gt;is_instance_klass()) {
923     ModuleEntry* module = InstanceKlass::cast(bottom_klass)-&gt;module();
924     if (module-&gt;is_named()) {
925       module_is_named = true;
926       module_name_phrase = &quot;module &quot;;
927       module_name = module-&gt;name()-&gt;as_C_string();
928       len += strlen(module_name);
929       // Use version if exists and is not a jdk module
930       if (module-&gt;should_show_version()) {
931         has_version = true;
932         version = module-&gt;version()-&gt;as_C_string();
933         // Include stlen(version) + 1 for the &quot;@&quot;
934         len += strlen(version) + 1;
935       }
936     } else {
937       module_name = UNNAMED_MODULE;
938       len += UNNAMED_MODULE_LEN;
939     }
940   } else {
941     // klass is an array of primitives, module is java.base
942     module_is_named = true;
943     module_name_phrase = &quot;module &quot;;
944     module_name = JAVA_BASE_NAME;
945     len += JAVA_BASE_NAME_LEN;
946   }
947 
948   // 3. class loader&#39;s name_and_id
949   ClassLoaderData* cld = class_loader_data();
950   assert(cld != NULL, &quot;class_loader_data should not be null&quot;);
951   const char* loader_name_and_id = cld-&gt;loader_name_and_id();
952   len += strlen(loader_name_and_id);
953 
954   // 4. include parent loader information
955   const char* parent_loader_phrase = &quot;&quot;;
956   const char* parent_loader_name_and_id = &quot;&quot;;
957   if (include_parent_loader &amp;&amp;
958       !cld-&gt;is_builtin_class_loader_data()) {
959     oop parent_loader = java_lang_ClassLoader::parent(class_loader());
960     ClassLoaderData *parent_cld = ClassLoaderData::class_loader_data_or_null(parent_loader);
961     // The parent loader&#39;s ClassLoaderData could be null if it is
962     // a delegating class loader that has never defined a class.
963     // In this case the loader&#39;s name must be obtained via the parent loader&#39;s oop.
964     if (parent_cld == NULL) {
965       oop cl_name_and_id = java_lang_ClassLoader::nameAndId(parent_loader);
966       if (cl_name_and_id != NULL) {
967         parent_loader_name_and_id = java_lang_String::as_utf8_string(cl_name_and_id);
968       }
969     } else {
970       parent_loader_name_and_id = parent_cld-&gt;loader_name_and_id();
971     }
972     parent_loader_phrase = &quot;, parent loader &quot;;
973     len += strlen(parent_loader_phrase) + strlen(parent_loader_name_and_id);
974   }
975 
976   // Start to construct final full class description string
977   len += ((use_are) ? strlen(&quot; are in &quot;) : strlen(&quot; is in &quot;));
978   len += strlen(module_name_phrase) + strlen(&quot; of loader &quot;);
979 
980   char* class_description = NEW_RESOURCE_ARRAY_RETURN_NULL(char, len);
981 
982   // Just return the FQN if error when allocating string
983   if (class_description == NULL) {
984     return klass_name;
985   }
986 
987   jio_snprintf(class_description, len, &quot;%s %s in %s%s%s%s of loader %s%s%s&quot;,
988                klass_name,
989                (use_are) ? &quot;are&quot; : &quot;is&quot;,
990                module_name_phrase,
991                module_name,
992                (has_version) ? &quot;@&quot; : &quot;&quot;,
993                (has_version) ? version : &quot;&quot;,
994                loader_name_and_id,
995                parent_loader_phrase,
996                parent_loader_name_and_id);
997 
998   return class_description;
999 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>