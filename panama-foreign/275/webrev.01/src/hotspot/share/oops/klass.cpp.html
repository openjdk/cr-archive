<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/klass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  28 #include &quot;classfile/dictionary.hpp&quot;
  29 #include &quot;classfile/javaClasses.hpp&quot;
  30 #include &quot;classfile/moduleEntry.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/heapShared.hpp&quot;
  37 #include &quot;memory/metadataFactory.hpp&quot;
  38 #include &quot;memory/metaspaceClosure.hpp&quot;
  39 #include &quot;memory/metaspaceShared.hpp&quot;
  40 #include &quot;memory/oopFactory.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/compressedOops.inline.hpp&quot;
  44 #include &quot;oops/instanceKlass.hpp&quot;
  45 #include &quot;oops/klass.inline.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/oopHandle.inline.hpp&quot;
  48 #include &quot;runtime/atomic.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
  52 #include &quot;utilities/stack.inline.hpp&quot;
  53 
  54 void Klass::set_java_mirror(Handle m) {
  55   assert(!m.is_null(), &quot;New mirror should never be null.&quot;);
  56   assert(_java_mirror.is_empty(), &quot;should only be used to initialize mirror&quot;);
  57   _java_mirror = class_loader_data()-&gt;add_handle(m);
  58 }
  59 
  60 oop Klass::java_mirror_no_keepalive() const {
  61   return _java_mirror.peek();
  62 }
  63 
  64 void Klass::replace_java_mirror(oop mirror) {
  65   _java_mirror.replace(mirror);
  66 }
  67 
  68 bool Klass::is_cloneable() const {
  69   return _access_flags.is_cloneable_fast() ||
  70          is_subtype_of(SystemDictionary::Cloneable_klass());
  71 }
  72 
  73 void Klass::set_is_cloneable() {
  74   if (name() == vmSymbols::java_lang_invoke_MemberName()) {
  75     assert(is_final(), &quot;no subclasses allowed&quot;);
  76     // MemberName cloning should not be intrinsified and always happen in JVM_Clone.
  77   } else if (is_instance_klass() &amp;&amp; InstanceKlass::cast(this)-&gt;reference_type() != REF_NONE) {
  78     // Reference cloning should not be intrinsified and always happen in JVM_Clone.
  79   } else {
  80     _access_flags.set_is_cloneable_fast();
  81   }
  82 }
  83 
  84 void Klass::set_name(Symbol* n) {
  85   _name = n;
  86   if (_name != NULL) _name-&gt;increment_refcount();
  87 
  88   if (Arguments::is_dumping_archive() &amp;&amp; is_instance_klass()) {
  89     SystemDictionaryShared::init_dumptime_info(InstanceKlass::cast(this));
  90   }
  91 }
  92 
  93 bool Klass::is_subclass_of(const Klass* k) const {
  94   // Run up the super chain and check
  95   if (this == k) return true;
  96 
  97   Klass* t = const_cast&lt;Klass*&gt;(this)-&gt;super();
  98 
  99   while (t != NULL) {
 100     if (t == k) return true;
 101     t = t-&gt;super();
 102   }
 103   return false;
 104 }
 105 
 106 void Klass::release_C_heap_structures() {
 107   if (_name != NULL) _name-&gt;decrement_refcount();
 108 }
 109 
 110 bool Klass::search_secondary_supers(Klass* k) const {
 111   // Put some extra logic here out-of-line, before the search proper.
 112   // This cuts down the size of the inline method.
 113 
 114   // This is necessary, since I am never in my own secondary_super list.
 115   if (this == k)
 116     return true;
 117   // Scan the array-of-objects for a match
 118   int cnt = secondary_supers()-&gt;length();
 119   for (int i = 0; i &lt; cnt; i++) {
 120     if (secondary_supers()-&gt;at(i) == k) {
 121       ((Klass*)this)-&gt;set_secondary_super_cache(k);
 122       return true;
 123     }
 124   }
 125   return false;
 126 }
 127 
 128 // Return self, except for abstract classes with exactly 1
 129 // implementor.  Then return the 1 concrete implementation.
 130 Klass *Klass::up_cast_abstract() {
 131   Klass *r = this;
 132   while( r-&gt;is_abstract() ) {   // Receiver is abstract?
 133     Klass *s = r-&gt;subklass();   // Check for exactly 1 subklass
 134     if (s == NULL || s-&gt;next_sibling() != NULL) // Oops; wrong count; give up
 135       return this;              // Return &#39;this&#39; as a no-progress flag
 136     r = s;                    // Loop till find concrete class
 137   }
 138   return r;                   // Return the 1 concrete class
 139 }
 140 
 141 // Find LCA in class hierarchy
 142 Klass *Klass::LCA( Klass *k2 ) {
 143   Klass *k1 = this;
 144   while( 1 ) {
 145     if( k1-&gt;is_subtype_of(k2) ) return k2;
 146     if( k2-&gt;is_subtype_of(k1) ) return k1;
 147     k1 = k1-&gt;super();
 148     k2 = k2-&gt;super();
 149   }
 150 }
 151 
 152 
 153 void Klass::check_valid_for_instantiation(bool throwError, TRAPS) {
 154   ResourceMark rm(THREAD);
 155   THROW_MSG(throwError ? vmSymbols::java_lang_InstantiationError()
 156             : vmSymbols::java_lang_InstantiationException(), external_name());
 157 }
 158 
 159 
 160 void Klass::copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS) {
 161   ResourceMark rm(THREAD);
 162   assert(s != NULL, &quot;Throw NPE!&quot;);
 163   THROW_MSG(vmSymbols::java_lang_ArrayStoreException(),
 164             err_msg(&quot;arraycopy: source type %s is not an array&quot;, s-&gt;klass()-&gt;external_name()));
 165 }
 166 
 167 
 168 void Klass::initialize(TRAPS) {
 169   ShouldNotReachHere();
 170 }
 171 
 172 Klass* Klass::find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
 173 #ifdef ASSERT
 174   tty-&gt;print_cr(&quot;Error: find_field called on a klass oop.&quot;
 175                 &quot; Likely error: reflection method does not correctly&quot;
 176                 &quot; wrap return value in a mirror object.&quot;);
 177 #endif
 178   ShouldNotReachHere();
 179   return NULL;
 180 }
 181 
 182 Method* Klass::uncached_lookup_method(const Symbol* name, const Symbol* signature,
 183                                       OverpassLookupMode overpass_mode,
 184                                       PrivateLookupMode private_mode) const {
 185 #ifdef ASSERT
 186   tty-&gt;print_cr(&quot;Error: uncached_lookup_method called on a klass oop.&quot;
 187                 &quot; Likely error: reflection method does not correctly&quot;
 188                 &quot; wrap return value in a mirror object.&quot;);
 189 #endif
 190   ShouldNotReachHere();
 191   return NULL;
 192 }
 193 
 194 void* Klass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw() {
 195   return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);
 196 }
 197 
 198 // &quot;Normal&quot; instantiation is preceeded by a MetaspaceObj allocation
 199 // which zeros out memory - calloc equivalent.
 200 // The constructor is also used from CppVtableCloner,
 201 // which doesn&#39;t zero out the memory before calling the constructor.
 202 Klass::Klass(KlassID id) : _id(id),
 203                            _prototype_header(markWord::prototype()),
 204                            _shared_class_path_index(-1) {
 205   CDS_ONLY(_shared_class_flags = 0;)
 206   CDS_JAVA_HEAP_ONLY(_archived_mirror = 0;)
 207   _primary_supers[0] = this;
 208   set_super_check_offset(in_bytes(primary_supers_offset()));
 209 }
 210 
 211 jint Klass::array_layout_helper(BasicType etype) {
 212   assert(etype &gt;= T_BOOLEAN &amp;&amp; etype &lt;= T_OBJECT, &quot;valid etype&quot;);
 213   // Note that T_ARRAY is not allowed here.
 214   int  hsize = arrayOopDesc::base_offset_in_bytes(etype);
 215   int  esize = type2aelembytes(etype);
 216   bool isobj = (etype == T_OBJECT);
 217   int  tag   =  isobj ? _lh_array_tag_obj_value : _lh_array_tag_type_value;
 218   int lh = array_layout_helper(tag, hsize, etype, exact_log2(esize));
 219 
 220   assert(lh &lt; (int)_lh_neutral_value, &quot;must look like an array layout&quot;);
 221   assert(layout_helper_is_array(lh), &quot;correct kind&quot;);
 222   assert(layout_helper_is_objArray(lh) == isobj, &quot;correct kind&quot;);
 223   assert(layout_helper_is_typeArray(lh) == !isobj, &quot;correct kind&quot;);
 224   assert(layout_helper_header_size(lh) == hsize, &quot;correct decode&quot;);
 225   assert(layout_helper_element_type(lh) == etype, &quot;correct decode&quot;);
 226   assert(1 &lt;&lt; layout_helper_log2_element_size(lh) == esize, &quot;correct decode&quot;);
 227 
 228   return lh;
 229 }
 230 
 231 bool Klass::can_be_primary_super_slow() const {
 232   if (super() == NULL)
 233     return true;
 234   else if (super()-&gt;super_depth() &gt;= primary_super_limit()-1)
 235     return false;
 236   else
 237     return true;
 238 }
 239 
 240 void Klass::initialize_supers(Klass* k, Array&lt;InstanceKlass*&gt;* transitive_interfaces, TRAPS) {
 241   if (k == NULL) {
 242     set_super(NULL);
 243     _primary_supers[0] = this;
 244     assert(super_depth() == 0, &quot;Object must already be initialized properly&quot;);
 245   } else if (k != super() || k == SystemDictionary::Object_klass()) {
 246     assert(super() == NULL || super() == SystemDictionary::Object_klass(),
 247            &quot;initialize this only once to a non-trivial value&quot;);
 248     set_super(k);
 249     Klass* sup = k;
 250     int sup_depth = sup-&gt;super_depth();
 251     juint my_depth  = MIN2(sup_depth + 1, (int)primary_super_limit());
 252     if (!can_be_primary_super_slow())
 253       my_depth = primary_super_limit();
 254     for (juint i = 0; i &lt; my_depth; i++) {
 255       _primary_supers[i] = sup-&gt;_primary_supers[i];
 256     }
 257     Klass* *super_check_cell;
 258     if (my_depth &lt; primary_super_limit()) {
 259       _primary_supers[my_depth] = this;
 260       super_check_cell = &amp;_primary_supers[my_depth];
 261     } else {
 262       // Overflow of the primary_supers array forces me to be secondary.
 263       super_check_cell = &amp;_secondary_super_cache;
 264     }
 265     set_super_check_offset((address)super_check_cell - (address) this);
 266 
 267 #ifdef ASSERT
 268     {
 269       juint j = super_depth();
 270       assert(j == my_depth, &quot;computed accessor gets right answer&quot;);
 271       Klass* t = this;
 272       while (!t-&gt;can_be_primary_super()) {
 273         t = t-&gt;super();
 274         j = t-&gt;super_depth();
 275       }
 276       for (juint j1 = j+1; j1 &lt; primary_super_limit(); j1++) {
 277         assert(primary_super_of_depth(j1) == NULL, &quot;super list padding&quot;);
 278       }
 279       while (t != NULL) {
 280         assert(primary_super_of_depth(j) == t, &quot;super list initialization&quot;);
 281         t = t-&gt;super();
 282         --j;
 283       }
 284       assert(j == (juint)-1, &quot;correct depth count&quot;);
 285     }
 286 #endif
 287   }
 288 
 289   if (secondary_supers() == NULL) {
 290 
 291     // Now compute the list of secondary supertypes.
 292     // Secondaries can occasionally be on the super chain,
 293     // if the inline &quot;_primary_supers&quot; array overflows.
 294     int extras = 0;
 295     Klass* p;
 296     for (p = super(); !(p == NULL || p-&gt;can_be_primary_super()); p = p-&gt;super()) {
 297       ++extras;
 298     }
 299 
 300     ResourceMark rm(THREAD);  // need to reclaim GrowableArrays allocated below
 301 
 302     // Compute the &quot;real&quot; non-extra secondaries.
 303     GrowableArray&lt;Klass*&gt;* secondaries = compute_secondary_supers(extras, transitive_interfaces);
 304     if (secondaries == NULL) {
 305       // secondary_supers set by compute_secondary_supers
 306       return;
 307     }
 308 
 309     GrowableArray&lt;Klass*&gt;* primaries = new GrowableArray&lt;Klass*&gt;(extras);
 310 
 311     for (p = super(); !(p == NULL || p-&gt;can_be_primary_super()); p = p-&gt;super()) {
 312       int i;                    // Scan for overflow primaries being duplicates of 2nd&#39;arys
 313 
 314       // This happens frequently for very deeply nested arrays: the
 315       // primary superclass chain overflows into the secondary.  The
 316       // secondary list contains the element_klass&#39;s secondaries with
 317       // an extra array dimension added.  If the element_klass&#39;s
 318       // secondary list already contains some primary overflows, they
 319       // (with the extra level of array-ness) will collide with the
 320       // normal primary superclass overflows.
 321       for( i = 0; i &lt; secondaries-&gt;length(); i++ ) {
 322         if( secondaries-&gt;at(i) == p )
 323           break;
 324       }
 325       if( i &lt; secondaries-&gt;length() )
 326         continue;               // It&#39;s a dup, don&#39;t put it in
 327       primaries-&gt;push(p);
 328     }
 329     // Combine the two arrays into a metadata object to pack the array.
 330     // The primaries are added in the reverse order, then the secondaries.
 331     int new_length = primaries-&gt;length() + secondaries-&gt;length();
 332     Array&lt;Klass*&gt;* s2 = MetadataFactory::new_array&lt;Klass*&gt;(
 333                                        class_loader_data(), new_length, CHECK);
 334     int fill_p = primaries-&gt;length();
 335     for (int j = 0; j &lt; fill_p; j++) {
 336       s2-&gt;at_put(j, primaries-&gt;pop());  // add primaries in reverse order.
 337     }
 338     for( int j = 0; j &lt; secondaries-&gt;length(); j++ ) {
 339       s2-&gt;at_put(j+fill_p, secondaries-&gt;at(j));  // add secondaries on the end.
 340     }
 341 
 342   #ifdef ASSERT
 343       // We must not copy any NULL placeholders left over from bootstrap.
 344     for (int j = 0; j &lt; s2-&gt;length(); j++) {
 345       assert(s2-&gt;at(j) != NULL, &quot;correct bootstrapping order&quot;);
 346     }
 347   #endif
 348 
 349     set_secondary_supers(s2);
 350   }
 351 }
 352 
 353 GrowableArray&lt;Klass*&gt;* Klass::compute_secondary_supers(int num_extra_slots,
 354                                                        Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 355   assert(num_extra_slots == 0, &quot;override for complex klasses&quot;);
 356   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
 357   set_secondary_supers(Universe::the_empty_klass_array());
 358   return NULL;
 359 }
 360 
 361 
 362 // superklass links
 363 InstanceKlass* Klass::superklass() const {
 364   assert(super() == NULL || super()-&gt;is_instance_klass(), &quot;must be instance klass&quot;);
 365   return _super == NULL ? NULL : InstanceKlass::cast(_super);
 366 }
 367 
 368 // subklass links.  Used by the compiler (and vtable initialization)
 369 // May be cleaned concurrently, so must use the Compile_lock.
 370 // The log parameter is for clean_weak_klass_links to report unlinked classes.
 371 Klass* Klass::subklass(bool log) const {
 372   // Need load_acquire on the _subklass, because it races with inserts that
 373   // publishes freshly initialized data.
 374   for (Klass* chain = Atomic::load_acquire(&amp;_subklass);
 375        chain != NULL;
 376        // Do not need load_acquire on _next_sibling, because inserts never
 377        // create _next_sibling edges to dead data.
 378        chain = Atomic::load(&amp;chain-&gt;_next_sibling))
 379   {
 380     if (chain-&gt;is_loader_alive()) {
 381       return chain;
 382     } else if (log) {
 383       if (log_is_enabled(Trace, class, unload)) {
 384         ResourceMark rm;
 385         log_trace(class, unload)(&quot;unlinking class (subclass): %s&quot;, chain-&gt;external_name());
 386       }
 387     }
 388   }
 389   return NULL;
 390 }
 391 
 392 Klass* Klass::next_sibling(bool log) const {
 393   // Do not need load_acquire on _next_sibling, because inserts never
 394   // create _next_sibling edges to dead data.
 395   for (Klass* chain = Atomic::load(&amp;_next_sibling);
 396        chain != NULL;
 397        chain = Atomic::load(&amp;chain-&gt;_next_sibling)) {
 398     // Only return alive klass, there may be stale klass
 399     // in this chain if cleaned concurrently.
 400     if (chain-&gt;is_loader_alive()) {
 401       return chain;
 402     } else if (log) {
 403       if (log_is_enabled(Trace, class, unload)) {
 404         ResourceMark rm;
 405         log_trace(class, unload)(&quot;unlinking class (sibling): %s&quot;, chain-&gt;external_name());
 406       }
 407     }
 408   }
 409   return NULL;
 410 }
 411 
 412 void Klass::set_subklass(Klass* s) {
 413   assert(s != this, &quot;sanity check&quot;);
 414   Atomic::release_store(&amp;_subklass, s);
 415 }
 416 
 417 void Klass::set_next_sibling(Klass* s) {
 418   assert(s != this, &quot;sanity check&quot;);
 419   // Does not need release semantics. If used by cleanup, it will link to
 420   // already safely published data, and if used by inserts, will be published
 421   // safely using cmpxchg.
 422   Atomic::store(&amp;_next_sibling, s);
 423 }
 424 
 425 void Klass::append_to_sibling_list() {
 426   if (Universe::is_fully_initialized()) {
 427     assert_locked_or_safepoint(Compile_lock);
 428   }
 429   debug_only(verify();)
 430   // add ourselves to superklass&#39; subklass list
 431   InstanceKlass* super = superklass();
 432   if (super == NULL) return;        // special case: class Object
 433   assert((!super-&gt;is_interface()    // interfaces cannot be supers
 434           &amp;&amp; (super-&gt;superklass() == NULL || !is_interface())),
 435          &quot;an interface can only be a subklass of Object&quot;);
 436 
 437   // Make sure there is no stale subklass head
 438   super-&gt;clean_subklass();
 439 
 440   for (;;) {
 441     Klass* prev_first_subklass = Atomic::load_acquire(&amp;_super-&gt;_subklass);
 442     if (prev_first_subklass != NULL) {
 443       // set our sibling to be the superklass&#39; previous first subklass
 444       assert(prev_first_subklass-&gt;is_loader_alive(), &quot;May not attach not alive klasses&quot;);
 445       set_next_sibling(prev_first_subklass);
 446     }
 447     // Note that the prev_first_subklass is always alive, meaning no sibling_next links
 448     // are ever created to not alive klasses. This is an important invariant of the lock-free
 449     // cleaning protocol, that allows us to safely unlink dead klasses from the sibling list.
 450     if (Atomic::cmpxchg(&amp;super-&gt;_subklass, prev_first_subklass, this) == prev_first_subklass) {
 451       return;
 452     }
 453   }
 454   debug_only(verify();)
 455 }
 456 
 457 void Klass::clean_subklass() {
 458   for (;;) {
 459     // Need load_acquire, due to contending with concurrent inserts
 460     Klass* subklass = Atomic::load_acquire(&amp;_subklass);
 461     if (subklass == NULL || subklass-&gt;is_loader_alive()) {
 462       return;
 463     }
 464     // Try to fix _subklass until it points at something not dead.
 465     Atomic::cmpxchg(&amp;_subklass, subklass, subklass-&gt;next_sibling());
 466   }
 467 }
 468 
 469 void Klass::clean_weak_klass_links(bool unloading_occurred, bool clean_alive_klasses) {
 470   if (!ClassUnloading || !unloading_occurred) {
 471     return;
 472   }
 473 
 474   Klass* root = SystemDictionary::Object_klass();
 475   Stack&lt;Klass*, mtGC&gt; stack;
 476 
 477   stack.push(root);
 478   while (!stack.is_empty()) {
 479     Klass* current = stack.pop();
 480 
 481     assert(current-&gt;is_loader_alive(), &quot;just checking, this should be live&quot;);
 482 
 483     // Find and set the first alive subklass
 484     Klass* sub = current-&gt;subklass(true);
 485     current-&gt;clean_subklass();
 486     if (sub != NULL) {
 487       stack.push(sub);
 488     }
 489 
 490     // Find and set the first alive sibling
 491     Klass* sibling = current-&gt;next_sibling(true);
 492     current-&gt;set_next_sibling(sibling);
 493     if (sibling != NULL) {
 494       stack.push(sibling);
 495     }
 496 
 497     // Clean the implementors list and method data.
 498     if (clean_alive_klasses &amp;&amp; current-&gt;is_instance_klass()) {
 499       InstanceKlass* ik = InstanceKlass::cast(current);
 500       ik-&gt;clean_weak_instanceklass_links();
 501 
 502       // JVMTI RedefineClasses creates previous versions that are not in
 503       // the class hierarchy, so process them here.
 504       while ((ik = ik-&gt;previous_versions()) != NULL) {
 505         ik-&gt;clean_weak_instanceklass_links();
 506       }
 507     }
 508   }
 509 }
 510 
 511 void Klass::metaspace_pointers_do(MetaspaceClosure* it) {
 512   if (log_is_enabled(Trace, cds)) {
 513     ResourceMark rm;
 514     log_trace(cds)(&quot;Iter(Klass): %p (%s)&quot;, this, external_name());
 515   }
 516 
 517   it-&gt;push(&amp;_name);
 518   it-&gt;push(&amp;_secondary_super_cache);
 519   it-&gt;push(&amp;_secondary_supers);
 520   for (int i = 0; i &lt; _primary_super_limit; i++) {
 521     it-&gt;push(&amp;_primary_supers[i]);
 522   }
 523   it-&gt;push(&amp;_super);
 524   it-&gt;push((Klass**)&amp;_subklass);
 525   it-&gt;push((Klass**)&amp;_next_sibling);
 526   it-&gt;push(&amp;_next_link);
 527 
 528   vtableEntry* vt = start_of_vtable();
 529   for (int i=0; i&lt;vtable_length(); i++) {
 530     it-&gt;push(vt[i].method_addr());
 531   }
 532 }
 533 
 534 void Klass::remove_unshareable_info() {
 535   assert (Arguments::is_dumping_archive(),
 536           &quot;only called during CDS dump time&quot;);
 537   JFR_ONLY(REMOVE_ID(this);)
 538   if (log_is_enabled(Trace, cds, unshareable)) {
 539     ResourceMark rm;
 540     log_trace(cds, unshareable)(&quot;remove: %s&quot;, external_name());
 541   }
 542 
 543   set_subklass(NULL);
 544   set_next_sibling(NULL);
 545   set_next_link(NULL);
 546 
 547   // Null out class_loader_data because we don&#39;t share that yet.
 548   set_class_loader_data(NULL);
 549   set_is_shared();
 550 }
 551 
 552 void Klass::remove_java_mirror() {
 553   Arguments::assert_is_dumping_archive();
 554   if (log_is_enabled(Trace, cds, unshareable)) {
 555     ResourceMark rm;
 556     log_trace(cds, unshareable)(&quot;remove java_mirror: %s&quot;, external_name());
 557   }
 558   // Just null out the mirror.  The class_loader_data() no longer exists.
 559   clear_java_mirror_handle();
 560 }
 561 
 562 void Klass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {
 563   assert(is_klass(), &quot;ensure C++ vtable is restored&quot;);
 564   assert(is_shared(), &quot;must be set&quot;);
 565   JFR_ONLY(RESTORE_ID(this);)
 566   if (log_is_enabled(Trace, cds, unshareable)) {
 567     ResourceMark rm(THREAD);
 568     log_trace(cds, unshareable)(&quot;restore: %s&quot;, external_name());
 569   }
 570 
 571   // If an exception happened during CDS restore, some of these fields may already be
 572   // set.  We leave the class on the CLD list, even if incomplete so that we don&#39;t
 573   // modify the CLD list outside a safepoint.
 574   if (class_loader_data() == NULL) {
 575     // Restore class_loader_data to the null class loader data
 576     set_class_loader_data(loader_data);
 577 
 578     // Add to null class loader list first before creating the mirror
 579     // (same order as class file parsing)
 580     loader_data-&gt;add_class(this);
 581   }
 582 
 583   Handle loader(THREAD, loader_data-&gt;class_loader());
 584   ModuleEntry* module_entry = NULL;
 585   Klass* k = this;
 586   if (k-&gt;is_objArray_klass()) {
 587     k = ObjArrayKlass::cast(k)-&gt;bottom_klass();
 588   }
 589   // Obtain klass&#39; module.
 590   if (k-&gt;is_instance_klass()) {
 591     InstanceKlass* ik = (InstanceKlass*) k;
 592     module_entry = ik-&gt;module();
 593   } else {
 594     module_entry = ModuleEntryTable::javabase_moduleEntry();
 595   }
 596   // Obtain java.lang.Module, if available
 597   Handle module_handle(THREAD, ((module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL));
 598 
 599   if (this-&gt;has_raw_archived_mirror()) {
 600     ResourceMark rm(THREAD);
 601     log_debug(cds, mirror)(&quot;%s has raw archived mirror&quot;, external_name());
 602     if (HeapShared::open_archive_heap_region_mapped()) {
 603       bool present = java_lang_Class::restore_archived_mirror(this, loader, module_handle,
 604                                                               protection_domain,
 605                                                               CHECK);
 606       if (present) {
 607         return;
 608       }
 609     }
 610 
 611     // No archived mirror data
 612     log_debug(cds, mirror)(&quot;No archived mirror data for %s&quot;, external_name());
 613     clear_java_mirror_handle();
 614     this-&gt;clear_has_raw_archived_mirror();
 615   }
 616 
 617   // Only recreate it if not present.  A previous attempt to restore may have
 618   // gotten an OOM later but keep the mirror if it was created.
 619   if (java_mirror() == NULL) {
 620     log_trace(cds, mirror)(&quot;Recreate mirror for %s&quot;, external_name());
 621     java_lang_Class::create_mirror(this, loader, module_handle, protection_domain, Handle(), CHECK);
 622   }
 623 }
 624 
 625 #if INCLUDE_CDS_JAVA_HEAP
 626 // Used at CDS dump time to access the archived mirror. No GC barrier.
 627 oop Klass::archived_java_mirror_raw() {
 628   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
 629   return CompressedOops::decode(_archived_mirror);
 630 }
 631 
 632 narrowOop Klass::archived_java_mirror_raw_narrow() {
 633   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
 634   return _archived_mirror;
 635 }
 636 
 637 // No GC barrier
 638 void Klass::set_archived_java_mirror_raw(oop m) {
 639   assert(DumpSharedSpaces, &quot;called only during runtime&quot;);
 640   _archived_mirror = CompressedOops::encode(m);
 641 }
 642 #endif // INCLUDE_CDS_JAVA_HEAP
 643 
 644 Klass* Klass::array_klass_or_null(int rank) {
 645   EXCEPTION_MARK;
 646   // No exception can be thrown by array_klass_impl when called with or_null == true.
 647   // (In anycase, the execption mark will fail if it do so)
 648   return array_klass_impl(true, rank, THREAD);
 649 }
 650 
 651 
 652 Klass* Klass::array_klass_or_null() {
 653   EXCEPTION_MARK;
 654   // No exception can be thrown by array_klass_impl when called with or_null == true.
 655   // (In anycase, the execption mark will fail if it do so)
 656   return array_klass_impl(true, THREAD);
 657 }
 658 
 659 
 660 Klass* Klass::array_klass_impl(bool or_null, int rank, TRAPS) {
 661   fatal(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
 662   return NULL;
 663 }
 664 
 665 
 666 Klass* Klass::array_klass_impl(bool or_null, TRAPS) {
 667   fatal(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
 668   return NULL;
 669 }
 670 
 671 void Klass::check_array_allocation_length(int length, int max_length, TRAPS) {
 672   if (length &gt; max_length) {
 673     if (!THREAD-&gt;in_retryable_allocation()) {
 674       report_java_out_of_memory(&quot;Requested array size exceeds VM limit&quot;);
 675       JvmtiExport::post_array_size_exhausted();
 676       THROW_OOP(Universe::out_of_memory_error_array_size());
 677     } else {
 678       THROW_OOP(Universe::out_of_memory_error_retry());
 679     }
 680   } else if (length &lt; 0) {
 681     THROW_MSG(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
 682   }
 683 }
 684 
 685 // Replace the last &#39;+&#39; char with &#39;/&#39;.
 686 static char* convert_hidden_name_to_java(Symbol* name) {
 687   size_t name_len = name-&gt;utf8_length();
 688   char* result = NEW_RESOURCE_ARRAY(char, name_len + 1);
 689   name-&gt;as_klass_external_name(result, (int)name_len + 1);
 690   for (int index = (int)name_len; index &gt; 0; index--) {
 691     if (result[index] == &#39;+&#39;) {
 692       result[index] = JVM_SIGNATURE_SLASH;
 693       break;
 694     }
 695   }
 696   return result;
 697 }
 698 
 699 // In product mode, this function doesn&#39;t have virtual function calls so
 700 // there might be some performance advantage to handling InstanceKlass here.
 701 const char* Klass::external_name() const {
 702   if (is_instance_klass()) {
 703     const InstanceKlass* ik = static_cast&lt;const InstanceKlass*&gt;(this);
 704     if (ik-&gt;is_unsafe_anonymous()) {
 705       char addr_buf[20];
 706       jio_snprintf(addr_buf, 20, &quot;/&quot; INTPTR_FORMAT, p2i(ik));
 707       size_t addr_len = strlen(addr_buf);
 708       size_t name_len = name()-&gt;utf8_length();
 709       char*  result   = NEW_RESOURCE_ARRAY(char, name_len + addr_len + 1);
 710       name()-&gt;as_klass_external_name(result, (int) name_len + 1);
 711       assert(strlen(result) == name_len, &quot;&quot;);
 712       strcpy(result + name_len, addr_buf);
 713       assert(strlen(result) == name_len + addr_len, &quot;&quot;);
 714       return result;
 715 
 716     } else if (ik-&gt;is_hidden()) {
 717       char* result = convert_hidden_name_to_java(name());
 718       return result;
 719     }
 720   } else if (is_objArray_klass() &amp;&amp; ObjArrayKlass::cast(this)-&gt;bottom_klass()-&gt;is_hidden()) {
 721     char* result = convert_hidden_name_to_java(name());
 722     return result;
 723   }
 724   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;
 725   return name()-&gt;as_klass_external_name();
 726 }
 727 
 728 const char* Klass::signature_name() const {
 729   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;
 730   if (is_objArray_klass() &amp;&amp; ObjArrayKlass::cast(this)-&gt;bottom_klass()-&gt;is_hidden()) {
 731     size_t name_len = name()-&gt;utf8_length();
 732     char* result = NEW_RESOURCE_ARRAY(char, name_len + 1);
 733     name()-&gt;as_C_string(result, (int)name_len + 1);
 734     for (int index = (int)name_len; index &gt; 0; index--) {
 735       if (result[index] == &#39;+&#39;) {
 736         result[index] = JVM_SIGNATURE_DOT;
 737         break;
 738       }
 739     }
 740     return result;
 741   }
 742   return name()-&gt;as_C_string();
 743 }
 744 
 745 const char* Klass::external_kind() const {
 746   if (is_interface()) return &quot;interface&quot;;
 747   if (is_abstract()) return &quot;abstract class&quot;;
 748   return &quot;class&quot;;
 749 }
 750 
 751 // Unless overridden, modifier_flags is 0.
 752 jint Klass::compute_modifier_flags(TRAPS) const {
 753   return 0;
 754 }
 755 
 756 int Klass::atomic_incr_biased_lock_revocation_count() {
 757   return (int) Atomic::add(&amp;_biased_lock_revocation_count, 1);
 758 }
 759 
 760 // Unless overridden, jvmti_class_status has no flags set.
 761 jint Klass::jvmti_class_status() const {
 762   return 0;
 763 }
 764 
 765 
 766 // Printing
 767 
 768 void Klass::print_on(outputStream* st) const {
 769   ResourceMark rm;
 770   // print title
 771   st-&gt;print(&quot;%s&quot;, internal_name());
 772   print_address_on(st);
 773   st-&gt;cr();
 774 }
 775 
 776 #define BULLET  &quot; - &quot;
 777 
 778 // Caller needs ResourceMark
 779 void Klass::oop_print_on(oop obj, outputStream* st) {
 780   // print title
 781   st-&gt;print_cr(&quot;%s &quot;, internal_name());
 782   obj-&gt;print_address_on(st);
 783 
 784   if (WizardMode) {
 785      // print header
 786      obj-&gt;mark().print_on(st);
 787      st-&gt;cr();
 788      st-&gt;print(BULLET&quot;prototype_header: &quot; INTPTR_FORMAT, _prototype_header.value());
 789      st-&gt;cr();
 790   }
 791 
 792   // print class
 793   st-&gt;print(BULLET&quot;klass: &quot;);
 794   obj-&gt;klass()-&gt;print_value_on(st);
 795   st-&gt;cr();
 796 }
 797 
 798 void Klass::oop_print_value_on(oop obj, outputStream* st) {
 799   // print title
 800   ResourceMark rm;              // Cannot print in debug mode without this
 801   st-&gt;print(&quot;%s&quot;, internal_name());
 802   obj-&gt;print_address_on(st);
 803 }
 804 
 805 // Verification
 806 
 807 void Klass::verify_on(outputStream* st) {
 808 
 809   // This can be expensive, but it is worth checking that this klass is actually
 810   // in the CLD graph but not in production.
 811   assert(Metaspace::contains((address)this), &quot;Should be&quot;);
 812 
 813   guarantee(this-&gt;is_klass(),&quot;should be klass&quot;);
 814 
 815   if (super() != NULL) {
 816     guarantee(super()-&gt;is_klass(), &quot;should be klass&quot;);
 817   }
 818   if (secondary_super_cache() != NULL) {
 819     Klass* ko = secondary_super_cache();
 820     guarantee(ko-&gt;is_klass(), &quot;should be klass&quot;);
 821   }
 822   for ( uint i = 0; i &lt; primary_super_limit(); i++ ) {
 823     Klass* ko = _primary_supers[i];
 824     if (ko != NULL) {
 825       guarantee(ko-&gt;is_klass(), &quot;should be klass&quot;);
 826     }
 827   }
 828 
 829   if (java_mirror_no_keepalive() != NULL) {
 830     guarantee(oopDesc::is_oop(java_mirror_no_keepalive()), &quot;should be instance&quot;);
 831   }
 832 }
 833 
 834 void Klass::oop_verify_on(oop obj, outputStream* st) {
 835   guarantee(oopDesc::is_oop(obj),  &quot;should be oop&quot;);
 836   guarantee(obj-&gt;klass()-&gt;is_klass(), &quot;klass field is not a klass&quot;);
 837 }
 838 
 839 bool Klass::is_valid(Klass* k) {
 840   if (!is_aligned(k, sizeof(MetaWord))) return false;
 841   if ((size_t)k &lt; os::min_page_size()) return false;
 842 
 843   if (!os::is_readable_range(k, k + 1)) return false;
 844   if (!Metaspace::contains(k)) return false;
 845 
 846   if (!Symbol::is_valid(k-&gt;name())) return false;
 847   return ClassLoaderDataGraph::is_valid(k-&gt;class_loader_data());
 848 }
 849 
 850 Method* Klass::method_at_vtable(int index)  {
 851 #ifndef PRODUCT
 852   assert(index &gt;= 0, &quot;valid vtable index&quot;);
 853   if (DebugVtables) {
 854     verify_vtable_index(index);
 855   }
 856 #endif
 857   return start_of_vtable()[index].method();
 858 }
 859 
 860 
 861 #ifndef PRODUCT
 862 
 863 bool Klass::verify_vtable_index(int i) {
 864   int limit = vtable_length()/vtableEntry::size();
 865   assert(i &gt;= 0 &amp;&amp; i &lt; limit, &quot;index %d out of bounds %d&quot;, i, limit);
 866   return true;
 867 }
 868 
 869 #endif // PRODUCT
 870 
 871 // Caller needs ResourceMark
 872 // joint_in_module_of_loader provides an optimization if 2 classes are in
 873 // the same module to succinctly print out relevant information about their
 874 // module name and class loader&#39;s name_and_id for error messages.
 875 // Format:
 876 //   &lt;fully-qualified-external-class-name1&gt; and &lt;fully-qualified-external-class-name2&gt;
 877 //                      are in module &lt;module-name&gt;[@&lt;version&gt;]
 878 //                      of loader &lt;loader-name_and_id&gt;[, parent loader &lt;parent-loader-name_and_id&gt;]
 879 const char* Klass::joint_in_module_of_loader(const Klass* class2, bool include_parent_loader) const {
 880   assert(module() == class2-&gt;module(), &quot;classes do not have the same module&quot;);
 881   const char* class1_name = external_name();
 882   size_t len = strlen(class1_name) + 1;
 883 
 884   const char* class2_description = class2-&gt;class_in_module_of_loader(true, include_parent_loader);
 885   len += strlen(class2_description);
 886 
 887   len += strlen(&quot; and &quot;);
 888 
 889   char* joint_description = NEW_RESOURCE_ARRAY_RETURN_NULL(char, len);
 890 
 891   // Just return the FQN if error when allocating string
 892   if (joint_description == NULL) {
 893     return class1_name;
 894   }
 895 
 896   jio_snprintf(joint_description, len, &quot;%s and %s&quot;,
 897                class1_name,
 898                class2_description);
 899 
 900   return joint_description;
 901 }
 902 
 903 // Caller needs ResourceMark
 904 // class_in_module_of_loader provides a standard way to include
 905 // relevant information about a class, such as its module name as
 906 // well as its class loader&#39;s name_and_id, in error messages and logging.
 907 // Format:
 908 //   &lt;fully-qualified-external-class-name&gt; is in module &lt;module-name&gt;[@&lt;version&gt;]
 909 //                                         of loader &lt;loader-name_and_id&gt;[, parent loader &lt;parent-loader-name_and_id&gt;]
 910 const char* Klass::class_in_module_of_loader(bool use_are, bool include_parent_loader) const {
 911   // 1. fully qualified external name of class
 912   const char* klass_name = external_name();
 913   size_t len = strlen(klass_name) + 1;
 914 
 915   // 2. module name + @version
 916   const char* module_name = &quot;&quot;;
 917   const char* version = &quot;&quot;;
 918   bool has_version = false;
 919   bool module_is_named = false;
 920   const char* module_name_phrase = &quot;&quot;;
 921   const Klass* bottom_klass = is_objArray_klass() ?
 922                                 ObjArrayKlass::cast(this)-&gt;bottom_klass() : this;
 923   if (bottom_klass-&gt;is_instance_klass()) {
 924     ModuleEntry* module = InstanceKlass::cast(bottom_klass)-&gt;module();
 925     if (module-&gt;is_named()) {
 926       module_is_named = true;
 927       module_name_phrase = &quot;module &quot;;
 928       module_name = module-&gt;name()-&gt;as_C_string();
 929       len += strlen(module_name);
 930       // Use version if exists and is not a jdk module
 931       if (module-&gt;should_show_version()) {
 932         has_version = true;
 933         version = module-&gt;version()-&gt;as_C_string();
 934         // Include stlen(version) + 1 for the &quot;@&quot;
 935         len += strlen(version) + 1;
 936       }
 937     } else {
 938       module_name = UNNAMED_MODULE;
 939       len += UNNAMED_MODULE_LEN;
 940     }
 941   } else {
 942     // klass is an array of primitives, module is java.base
 943     module_is_named = true;
 944     module_name_phrase = &quot;module &quot;;
 945     module_name = JAVA_BASE_NAME;
 946     len += JAVA_BASE_NAME_LEN;
 947   }
 948 
 949   // 3. class loader&#39;s name_and_id
 950   ClassLoaderData* cld = class_loader_data();
 951   assert(cld != NULL, &quot;class_loader_data should not be null&quot;);
 952   const char* loader_name_and_id = cld-&gt;loader_name_and_id();
 953   len += strlen(loader_name_and_id);
 954 
 955   // 4. include parent loader information
 956   const char* parent_loader_phrase = &quot;&quot;;
 957   const char* parent_loader_name_and_id = &quot;&quot;;
 958   if (include_parent_loader &amp;&amp;
 959       !cld-&gt;is_builtin_class_loader_data()) {
 960     oop parent_loader = java_lang_ClassLoader::parent(class_loader());
 961     ClassLoaderData *parent_cld = ClassLoaderData::class_loader_data_or_null(parent_loader);
 962     // The parent loader&#39;s ClassLoaderData could be null if it is
 963     // a delegating class loader that has never defined a class.
 964     // In this case the loader&#39;s name must be obtained via the parent loader&#39;s oop.
 965     if (parent_cld == NULL) {
 966       oop cl_name_and_id = java_lang_ClassLoader::nameAndId(parent_loader);
 967       if (cl_name_and_id != NULL) {
 968         parent_loader_name_and_id = java_lang_String::as_utf8_string(cl_name_and_id);
 969       }
 970     } else {
 971       parent_loader_name_and_id = parent_cld-&gt;loader_name_and_id();
 972     }
 973     parent_loader_phrase = &quot;, parent loader &quot;;
 974     len += strlen(parent_loader_phrase) + strlen(parent_loader_name_and_id);
 975   }
 976 
 977   // Start to construct final full class description string
 978   len += ((use_are) ? strlen(&quot; are in &quot;) : strlen(&quot; is in &quot;));
 979   len += strlen(module_name_phrase) + strlen(&quot; of loader &quot;);
 980 
 981   char* class_description = NEW_RESOURCE_ARRAY_RETURN_NULL(char, len);
 982 
 983   // Just return the FQN if error when allocating string
 984   if (class_description == NULL) {
 985     return klass_name;
 986   }
 987 
 988   jio_snprintf(class_description, len, &quot;%s %s in %s%s%s%s of loader %s%s%s&quot;,
 989                klass_name,
 990                (use_are) ? &quot;are&quot; : &quot;is&quot;,
 991                module_name_phrase,
 992                module_name,
 993                (has_version) ? &quot;@&quot; : &quot;&quot;,
 994                (has_version) ? version : &quot;&quot;,
 995                loader_name_and_id,
 996                parent_loader_phrase,
 997                parent_loader_name_and_id);
 998 
 999   return class_description;
1000 }
    </pre>
  </body>
</html>