<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/heapDumper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;gc/shared/gcLocker.hpp&quot;
  34 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  35 #include &quot;gc/shared/workgroup.hpp&quot;
  36 #include &quot;jfr/jfrEvents.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;runtime/frame.inline.hpp&quot;
  45 #include &quot;runtime/handles.inline.hpp&quot;
  46 #include &quot;runtime/javaCalls.hpp&quot;
  47 #include &quot;runtime/jniHandles.hpp&quot;
  48 #include &quot;runtime/os.inline.hpp&quot;
  49 #include &quot;runtime/reflectionUtils.hpp&quot;
  50 #include &quot;runtime/thread.inline.hpp&quot;
  51 #include &quot;runtime/threadSMR.hpp&quot;
  52 #include &quot;runtime/vframe.hpp&quot;
  53 #include &quot;runtime/vmThread.hpp&quot;
  54 #include &quot;runtime/vmOperations.hpp&quot;
  55 #include &quot;services/heapDumper.hpp&quot;
  56 #include &quot;services/heapDumperCompression.hpp&quot;
  57 #include &quot;services/threadService.hpp&quot;
  58 #include &quot;utilities/macros.hpp&quot;
  59 #include &quot;utilities/ostream.hpp&quot;
  60 
  61 /*
  62  * HPROF binary format - description copied from:
  63  *   src/share/demo/jvmti/hprof/hprof_io.c
  64  *
  65  *
  66  *  header    &quot;JAVA PROFILE 1.0.2&quot; (0-terminated)
  67  *
  68  *  u4        size of identifiers. Identifiers are used to represent
  69  *            UTF8 strings, objects, stack traces, etc. They usually
  70  *            have the same size as host pointers. For example, on
  71  *            Solaris and Win32, the size is 4.
  72  * u4         high word
  73  * u4         low word    number of milliseconds since 0:00 GMT, 1/1/70
  74  * [record]*  a sequence of records.
  75  *
  76  *
  77  * Record format:
  78  *
  79  * u1         a TAG denoting the type of the record
  80  * u4         number of *microseconds* since the time stamp in the
  81  *            header. (wraps around in a little more than an hour)
  82  * u4         number of bytes *remaining* in the record. Note that
  83  *            this number excludes the tag and the length field itself.
  84  * [u1]*      BODY of the record (a sequence of bytes)
  85  *
  86  *
  87  * The following TAGs are supported:
  88  *
  89  * TAG           BODY       notes
  90  *----------------------------------------------------------
  91  * HPROF_UTF8               a UTF8-encoded name
  92  *
  93  *               id         name ID
  94  *               [u1]*      UTF8 characters (no trailing zero)
  95  *
  96  * HPROF_LOAD_CLASS         a newly loaded class
  97  *
  98  *                u4        class serial number (&gt; 0)
  99  *                id        class object ID
 100  *                u4        stack trace serial number
 101  *                id        class name ID
 102  *
 103  * HPROF_UNLOAD_CLASS       an unloading class
 104  *
 105  *                u4        class serial_number
 106  *
 107  * HPROF_FRAME              a Java stack frame
 108  *
 109  *                id        stack frame ID
 110  *                id        method name ID
 111  *                id        method signature ID
 112  *                id        source file name ID
 113  *                u4        class serial number
 114  *                i4        line number. &gt;0: normal
 115  *                                       -1: unknown
 116  *                                       -2: compiled method
 117  *                                       -3: native method
 118  *
 119  * HPROF_TRACE              a Java stack trace
 120  *
 121  *               u4         stack trace serial number
 122  *               u4         thread serial number
 123  *               u4         number of frames
 124  *               [id]*      stack frame IDs
 125  *
 126  *
 127  * HPROF_ALLOC_SITES        a set of heap allocation sites, obtained after GC
 128  *
 129  *               u2         flags 0x0001: incremental vs. complete
 130  *                                0x0002: sorted by allocation vs. live
 131  *                                0x0004: whether to force a GC
 132  *               u4         cutoff ratio
 133  *               u4         total live bytes
 134  *               u4         total live instances
 135  *               u8         total bytes allocated
 136  *               u8         total instances allocated
 137  *               u4         number of sites that follow
 138  *               [u1        is_array: 0:  normal object
 139  *                                    2:  object array
 140  *                                    4:  boolean array
 141  *                                    5:  char array
 142  *                                    6:  float array
 143  *                                    7:  double array
 144  *                                    8:  byte array
 145  *                                    9:  short array
 146  *                                    10: int array
 147  *                                    11: long array
 148  *                u4        class serial number (may be zero during startup)
 149  *                u4        stack trace serial number
 150  *                u4        number of bytes alive
 151  *                u4        number of instances alive
 152  *                u4        number of bytes allocated
 153  *                u4]*      number of instance allocated
 154  *
 155  * HPROF_START_THREAD       a newly started thread.
 156  *
 157  *               u4         thread serial number (&gt; 0)
 158  *               id         thread object ID
 159  *               u4         stack trace serial number
 160  *               id         thread name ID
 161  *               id         thread group name ID
 162  *               id         thread group parent name ID
 163  *
 164  * HPROF_END_THREAD         a terminating thread.
 165  *
 166  *               u4         thread serial number
 167  *
 168  * HPROF_HEAP_SUMMARY       heap summary
 169  *
 170  *               u4         total live bytes
 171  *               u4         total live instances
 172  *               u8         total bytes allocated
 173  *               u8         total instances allocated
 174  *
 175  * HPROF_HEAP_DUMP          denote a heap dump
 176  *
 177  *               [heap dump sub-records]*
 178  *
 179  *                          There are four kinds of heap dump sub-records:
 180  *
 181  *               u1         sub-record type
 182  *
 183  *               HPROF_GC_ROOT_UNKNOWN         unknown root
 184  *
 185  *                          id         object ID
 186  *
 187  *               HPROF_GC_ROOT_THREAD_OBJ      thread object
 188  *
 189  *                          id         thread object ID  (may be 0 for a
 190  *                                     thread newly attached through JNI)
 191  *                          u4         thread sequence number
 192  *                          u4         stack trace sequence number
 193  *
 194  *               HPROF_GC_ROOT_JNI_GLOBAL      JNI global ref root
 195  *
 196  *                          id         object ID
 197  *                          id         JNI global ref ID
 198  *
 199  *               HPROF_GC_ROOT_JNI_LOCAL       JNI local ref
 200  *
 201  *                          id         object ID
 202  *                          u4         thread serial number
 203  *                          u4         frame # in stack trace (-1 for empty)
 204  *
 205  *               HPROF_GC_ROOT_JAVA_FRAME      Java stack frame
 206  *
 207  *                          id         object ID
 208  *                          u4         thread serial number
 209  *                          u4         frame # in stack trace (-1 for empty)
 210  *
 211  *               HPROF_GC_ROOT_NATIVE_STACK    Native stack
 212  *
 213  *                          id         object ID
 214  *                          u4         thread serial number
 215  *
 216  *               HPROF_GC_ROOT_STICKY_CLASS    System class
 217  *
 218  *                          id         object ID
 219  *
 220  *               HPROF_GC_ROOT_THREAD_BLOCK    Reference from thread block
 221  *
 222  *                          id         object ID
 223  *                          u4         thread serial number
 224  *
 225  *               HPROF_GC_ROOT_MONITOR_USED    Busy monitor
 226  *
 227  *                          id         object ID
 228  *
 229  *               HPROF_GC_CLASS_DUMP           dump of a class object
 230  *
 231  *                          id         class object ID
 232  *                          u4         stack trace serial number
 233  *                          id         super class object ID
 234  *                          id         class loader object ID
 235  *                          id         signers object ID
 236  *                          id         protection domain object ID
 237  *                          id         reserved
 238  *                          id         reserved
 239  *
 240  *                          u4         instance size (in bytes)
 241  *
 242  *                          u2         size of constant pool
 243  *                          [u2,       constant pool index,
 244  *                           ty,       type
 245  *                                     2:  object
 246  *                                     4:  boolean
 247  *                                     5:  char
 248  *                                     6:  float
 249  *                                     7:  double
 250  *                                     8:  byte
 251  *                                     9:  short
 252  *                                     10: int
 253  *                                     11: long
 254  *                           vl]*      and value
 255  *
 256  *                          u2         number of static fields
 257  *                          [id,       static field name,
 258  *                           ty,       type,
 259  *                           vl]*      and value
 260  *
 261  *                          u2         number of inst. fields (not inc. super)
 262  *                          [id,       instance field name,
 263  *                           ty]*      type
 264  *
 265  *               HPROF_GC_INSTANCE_DUMP        dump of a normal object
 266  *
 267  *                          id         object ID
 268  *                          u4         stack trace serial number
 269  *                          id         class object ID
 270  *                          u4         number of bytes that follow
 271  *                          [vl]*      instance field values (class, followed
 272  *                                     by super, super&#39;s super ...)
 273  *
 274  *               HPROF_GC_OBJ_ARRAY_DUMP       dump of an object array
 275  *
 276  *                          id         array object ID
 277  *                          u4         stack trace serial number
 278  *                          u4         number of elements
 279  *                          id         array class ID
 280  *                          [id]*      elements
 281  *
 282  *               HPROF_GC_PRIM_ARRAY_DUMP      dump of a primitive array
 283  *
 284  *                          id         array object ID
 285  *                          u4         stack trace serial number
 286  *                          u4         number of elements
 287  *                          u1         element type
 288  *                                     4:  boolean array
 289  *                                     5:  char array
 290  *                                     6:  float array
 291  *                                     7:  double array
 292  *                                     8:  byte array
 293  *                                     9:  short array
 294  *                                     10: int array
 295  *                                     11: long array
 296  *                          [u1]*      elements
 297  *
 298  * HPROF_CPU_SAMPLES        a set of sample traces of running threads
 299  *
 300  *                u4        total number of samples
 301  *                u4        # of traces
 302  *               [u4        # of samples
 303  *                u4]*      stack trace serial number
 304  *
 305  * HPROF_CONTROL_SETTINGS   the settings of on/off switches
 306  *
 307  *                u4        0x00000001: alloc traces on/off
 308  *                          0x00000002: cpu sampling on/off
 309  *                u2        stack trace depth
 310  *
 311  *
 312  * When the header is &quot;JAVA PROFILE 1.0.2&quot; a heap dump can optionally
 313  * be generated as a sequence of heap dump segments. This sequence is
 314  * terminated by an end record. The additional tags allowed by format
 315  * &quot;JAVA PROFILE 1.0.2&quot; are:
 316  *
 317  * HPROF_HEAP_DUMP_SEGMENT  denote a heap dump segment
 318  *
 319  *               [heap dump sub-records]*
 320  *               The same sub-record types allowed by HPROF_HEAP_DUMP
 321  *
 322  * HPROF_HEAP_DUMP_END      denotes the end of a heap dump
 323  *
 324  */
 325 
 326 
 327 // HPROF tags
 328 
 329 typedef enum {
 330   // top-level records
 331   HPROF_UTF8                    = 0x01,
 332   HPROF_LOAD_CLASS              = 0x02,
 333   HPROF_UNLOAD_CLASS            = 0x03,
 334   HPROF_FRAME                   = 0x04,
 335   HPROF_TRACE                   = 0x05,
 336   HPROF_ALLOC_SITES             = 0x06,
 337   HPROF_HEAP_SUMMARY            = 0x07,
 338   HPROF_START_THREAD            = 0x0A,
 339   HPROF_END_THREAD              = 0x0B,
 340   HPROF_HEAP_DUMP               = 0x0C,
 341   HPROF_CPU_SAMPLES             = 0x0D,
 342   HPROF_CONTROL_SETTINGS        = 0x0E,
 343 
 344   // 1.0.2 record types
 345   HPROF_HEAP_DUMP_SEGMENT       = 0x1C,
 346   HPROF_HEAP_DUMP_END           = 0x2C,
 347 
 348   // field types
 349   HPROF_ARRAY_OBJECT            = 0x01,
 350   HPROF_NORMAL_OBJECT           = 0x02,
 351   HPROF_BOOLEAN                 = 0x04,
 352   HPROF_CHAR                    = 0x05,
 353   HPROF_FLOAT                   = 0x06,
 354   HPROF_DOUBLE                  = 0x07,
 355   HPROF_BYTE                    = 0x08,
 356   HPROF_SHORT                   = 0x09,
 357   HPROF_INT                     = 0x0A,
 358   HPROF_LONG                    = 0x0B,
 359 
 360   // data-dump sub-records
 361   HPROF_GC_ROOT_UNKNOWN         = 0xFF,
 362   HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,
 363   HPROF_GC_ROOT_JNI_LOCAL       = 0x02,
 364   HPROF_GC_ROOT_JAVA_FRAME      = 0x03,
 365   HPROF_GC_ROOT_NATIVE_STACK    = 0x04,
 366   HPROF_GC_ROOT_STICKY_CLASS    = 0x05,
 367   HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,
 368   HPROF_GC_ROOT_MONITOR_USED    = 0x07,
 369   HPROF_GC_ROOT_THREAD_OBJ      = 0x08,
 370   HPROF_GC_CLASS_DUMP           = 0x20,
 371   HPROF_GC_INSTANCE_DUMP        = 0x21,
 372   HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,
 373   HPROF_GC_PRIM_ARRAY_DUMP      = 0x23
 374 } hprofTag;
 375 
 376 // Default stack trace ID (used for dummy HPROF_TRACE record)
 377 enum {
 378   STACK_TRACE_ID = 1,
 379   INITIAL_CLASS_COUNT = 200
 380 };
 381 
 382 // Supports I/O operations for a dump
 383 
 384 class DumpWriter : public StackObj {
 385  private:
 386   enum {
 387     io_buffer_max_size = 1*M,
 388     io_buffer_max_waste = 10*K,
 389     dump_segment_header_size = 9
 390   };
 391 
 392   char* _buffer;    // internal buffer
 393   size_t _size;
 394   size_t _pos;
 395 
 396   bool _in_dump_segment; // Are we currently in a dump segment?
 397   bool _is_huge_sub_record; // Are we writing a sub-record larger than the buffer size?
 398   DEBUG_ONLY(size_t _sub_record_left;) // The bytes not written for the current sub-record.
 399   DEBUG_ONLY(bool _sub_record_ended;) // True if we have called the end_sub_record().
 400 
 401   CompressionBackend _backend; // Does the actual writing.
 402 
 403   void flush();
 404 
 405   char* buffer() const                          { return _buffer; }
 406   size_t buffer_size() const                    { return _size; }
 407   size_t position() const                       { return _pos; }
 408   void set_position(size_t pos)                 { _pos = pos; }
 409 
 410   // Can be called if we have enough room in the buffer.
 411   void write_fast(void* s, size_t len);
 412 
 413   // Returns true if we have enough room in the buffer for &#39;len&#39; bytes.
 414   bool can_write_fast(size_t len);
 415 
 416  public:
 417   // Takes ownership of the writer and compressor.
 418   DumpWriter(AbstractWriter* writer, AbstractCompressor* compressor);
 419 
 420   ~DumpWriter();
 421 
 422   // total number of bytes written to the disk
 423   julong bytes_written() const          { return (julong) _backend.get_written(); }
 424 
 425   char const* error() const             { return _backend.error(); }
 426 
 427   // writer functions
 428   void write_raw(void* s, size_t len);
 429   void write_u1(u1 x);
 430   void write_u2(u2 x);
 431   void write_u4(u4 x);
 432   void write_u8(u8 x);
 433   void write_objectID(oop o);
 434   void write_symbolID(Symbol* o);
 435   void write_classID(Klass* k);
 436   void write_id(u4 x);
 437 
 438   // Start a new sub-record. Starts a new heap dump segment if needed.
 439   void start_sub_record(u1 tag, u4 len);
 440   // Ends the current sub-record.
 441   void end_sub_record();
 442   // Finishes the current dump segment if not already finished.
 443   void finish_dump_segment();
 444 
 445   // Called by threads used for parallel writing.
 446   void writer_loop()                    { _backend.thread_loop(false); }
 447   // Called when finished to release the threads.
 448   void deactivate()                     { flush(); _backend.deactivate(); }
 449 };
 450 
 451 // Check for error after constructing the object and destroy it in case of an error.
 452 DumpWriter::DumpWriter(AbstractWriter* writer, AbstractCompressor* compressor) :
 453   _buffer(NULL),
 454   _size(0),
 455   _pos(0),
 456   _in_dump_segment(false),
 457   _backend(writer, compressor, io_buffer_max_size, io_buffer_max_waste) {
 458   flush();
 459 }
 460 
 461 DumpWriter::~DumpWriter() {
 462   flush();
 463 }
 464 
 465 void DumpWriter::write_fast(void* s, size_t len) {
 466   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);
 467   assert(buffer_size() - position() &gt;= len, &quot;Must fit&quot;);
 468   debug_only(_sub_record_left -= len);
 469 
 470   memcpy(buffer() + position(), s, len);
 471   set_position(position() + len);
 472 }
 473 
 474 bool DumpWriter::can_write_fast(size_t len) {
 475   return buffer_size() - position() &gt;= len;
 476 }
 477 
 478 // write raw bytes
 479 void DumpWriter::write_raw(void* s, size_t len) {
 480   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);
 481   debug_only(_sub_record_left -= len);
 482 
 483   // flush buffer to make room.
 484   while (len &gt; buffer_size() - position()) {
 485     assert(!_in_dump_segment || _is_huge_sub_record,
 486            &quot;Cannot overflow in non-huge sub-record.&quot;);
 487 
 488     size_t to_write = buffer_size() - position();
 489     memcpy(buffer() + position(), s, to_write);
 490     s = (void*) ((char*) s + to_write);
 491     len -= to_write;
 492     set_position(position() + to_write);
 493     flush();
 494   }
 495 
 496   memcpy(buffer() + position(), s, len);
 497   set_position(position() + len);
 498 }
 499 
 500 // flush any buffered bytes to the file
 501 void DumpWriter::flush() {
 502   _backend.get_new_buffer(&amp;_buffer, &amp;_pos, &amp;_size);
 503 }
 504 
 505 // Makes sure we inline the fast write into the write_u* functions. This is a big speedup.
 506 #define WRITE_KNOWN_TYPE(p, len) do { if (can_write_fast((len))) write_fast((p), (len)); \
 507                                       else write_raw((p), (len)); } while (0)
 508 
 509 void DumpWriter::write_u1(u1 x) {
 510   WRITE_KNOWN_TYPE((void*) &amp;x, 1);
 511 }
 512 
 513 void DumpWriter::write_u2(u2 x) {
 514   u2 v;
 515   Bytes::put_Java_u2((address)&amp;v, x);
 516   WRITE_KNOWN_TYPE((void*)&amp;v, 2);
 517 }
 518 
 519 void DumpWriter::write_u4(u4 x) {
 520   u4 v;
 521   Bytes::put_Java_u4((address)&amp;v, x);
 522   WRITE_KNOWN_TYPE((void*)&amp;v, 4);
 523 }
 524 
 525 void DumpWriter::write_u8(u8 x) {
 526   u8 v;
 527   Bytes::put_Java_u8((address)&amp;v, x);
 528   WRITE_KNOWN_TYPE((void*)&amp;v, 8);
 529 }
 530 
 531 void DumpWriter::write_objectID(oop o) {
 532   address a = cast_from_oop&lt;address&gt;(o);
 533 #ifdef _LP64
 534   write_u8((u8)a);
 535 #else
 536   write_u4((u4)a);
 537 #endif
 538 }
 539 
 540 void DumpWriter::write_symbolID(Symbol* s) {
 541   address a = (address)((uintptr_t)s);
 542 #ifdef _LP64
 543   write_u8((u8)a);
 544 #else
 545   write_u4((u4)a);
 546 #endif
 547 }
 548 
 549 void DumpWriter::write_id(u4 x) {
 550 #ifdef _LP64
 551   write_u8((u8) x);
 552 #else
 553   write_u4(x);
 554 #endif
 555 }
 556 
 557 // We use java mirror as the class ID
 558 void DumpWriter::write_classID(Klass* k) {
 559   write_objectID(k-&gt;java_mirror());
 560 }
 561 
 562 void DumpWriter::finish_dump_segment() {
 563   if (_in_dump_segment) {
 564     assert(_sub_record_left == 0, &quot;Last sub-record not written completely&quot;);
 565     assert(_sub_record_ended, &quot;sub-record must have ended&quot;);
 566 
 567     // Fix up the dump segment length if we haven&#39;t written a huge sub-record last
 568     // (in which case the segment length was already set to the correct value initially).
 569     if (!_is_huge_sub_record) {
 570       assert(position() &gt; dump_segment_header_size, &quot;Dump segment should have some content&quot;);
 571       Bytes::put_Java_u4((address) (buffer() + 5),
 572                          (u4) (position() - dump_segment_header_size));
 573     }
 574 
 575     flush();
 576     _in_dump_segment = false;
 577   }
 578 }
 579 
 580 void DumpWriter::start_sub_record(u1 tag, u4 len) {
 581   if (!_in_dump_segment) {
 582     if (position() &gt; 0) {
 583       flush();
 584     }
 585 
 586     assert(position() == 0, &quot;Must be at the start&quot;);
 587 
 588     write_u1(HPROF_HEAP_DUMP_SEGMENT);
 589     write_u4(0); // timestamp
 590     // Will be fixed up later if we add more sub-records.  If this is a huge sub-record,
 591     // this is already the correct length, since we don&#39;t add more sub-records.
 592     write_u4(len);
 593     _in_dump_segment = true;
 594     _is_huge_sub_record = len &gt; buffer_size() - dump_segment_header_size;
 595   } else if (_is_huge_sub_record || (len &gt; buffer_size() - position())) {
 596     // This object will not fit in completely or the last sub-record was huge.
 597     // Finish the current segement and try again.
 598     finish_dump_segment();
 599     start_sub_record(tag, len);
 600 
 601     return;
 602   }
 603 
 604   debug_only(_sub_record_left = len);
 605   debug_only(_sub_record_ended = false);
 606 
 607   write_u1(tag);
 608 }
 609 
 610 void DumpWriter::end_sub_record() {
 611   assert(_in_dump_segment, &quot;must be in dump segment&quot;);
 612   assert(_sub_record_left == 0, &quot;sub-record not written completely&quot;);
 613   assert(!_sub_record_ended, &quot;Must not have ended yet&quot;);
 614   debug_only(_sub_record_ended = true);
 615 }
 616 
 617 // Support class with a collection of functions used when dumping the heap
 618 
 619 class DumperSupport : AllStatic {
 620  public:
 621 
 622   // write a header of the given type
 623   static void write_header(DumpWriter* writer, hprofTag tag, u4 len);
 624 
 625   // returns hprof tag for the given type signature
 626   static hprofTag sig2tag(Symbol* sig);
 627   // returns hprof tag for the given basic type
 628   static hprofTag type2tag(BasicType type);
 629   // Returns the size of the data to write.
 630   static u4 sig2size(Symbol* sig);
 631 
 632   // returns the size of the instance of the given class
 633   static u4 instance_size(Klass* k);
 634 
 635   // dump a jfloat
 636   static void dump_float(DumpWriter* writer, jfloat f);
 637   // dump a jdouble
 638   static void dump_double(DumpWriter* writer, jdouble d);
 639   // dumps the raw value of the given field
 640   static void dump_field_value(DumpWriter* writer, char type, oop obj, int offset);
 641   // returns the size of the static fields; also counts the static fields
 642   static u4 get_static_fields_size(InstanceKlass* ik, u2&amp; field_count);
 643   // dumps static fields of the given class
 644   static void dump_static_fields(DumpWriter* writer, Klass* k);
 645   // dump the raw values of the instance fields of the given object
 646   static void dump_instance_fields(DumpWriter* writer, oop o);
 647   // get the count of the instance fields for a given class
 648   static u2 get_instance_fields_count(InstanceKlass* ik);
 649   // dumps the definition of the instance fields for a given class
 650   static void dump_instance_field_descriptors(DumpWriter* writer, Klass* k);
 651   // creates HPROF_GC_INSTANCE_DUMP record for the given object
 652   static void dump_instance(DumpWriter* writer, oop o);
 653   // creates HPROF_GC_CLASS_DUMP record for the given class and each of its
 654   // array classes
 655   static void dump_class_and_array_classes(DumpWriter* writer, Klass* k);
 656   // creates HPROF_GC_CLASS_DUMP record for a given primitive array
 657   // class (and each multi-dimensional array class too)
 658   static void dump_basic_type_array_class(DumpWriter* writer, Klass* k);
 659 
 660   // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
 661   static void dump_object_array(DumpWriter* writer, objArrayOop array);
 662   // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
 663   static void dump_prim_array(DumpWriter* writer, typeArrayOop array);
 664   // create HPROF_FRAME record for the given method and bci
 665   static void dump_stack_frame(DumpWriter* writer, int frame_serial_num, int class_serial_num, Method* m, int bci);
 666 
 667   // check if we need to truncate an array
 668   static int calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size);
 669 
 670   // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
 671   static void end_of_dump(DumpWriter* writer);
 672 
 673   static oop mask_dormant_archived_object(oop o) {
 674     if (o != NULL &amp;&amp; o-&gt;klass()-&gt;java_mirror() == NULL) {
 675       // Ignore this object since the corresponding java mirror is not loaded.
 676       // Might be a dormant archive object.
 677       return NULL;
 678     } else {
 679       return o;
 680     }
 681   }
 682 };
 683 
 684 // write a header of the given type
 685 void DumperSupport:: write_header(DumpWriter* writer, hprofTag tag, u4 len) {
 686   writer-&gt;write_u1((u1)tag);
 687   writer-&gt;write_u4(0);                  // current ticks
 688   writer-&gt;write_u4(len);
 689 }
 690 
 691 // returns hprof tag for the given type signature
 692 hprofTag DumperSupport::sig2tag(Symbol* sig) {
 693   switch (sig-&gt;char_at(0)) {
 694     case JVM_SIGNATURE_CLASS    : return HPROF_NORMAL_OBJECT;
 695     case JVM_SIGNATURE_ARRAY    : return HPROF_NORMAL_OBJECT;
 696     case JVM_SIGNATURE_BYTE     : return HPROF_BYTE;
 697     case JVM_SIGNATURE_CHAR     : return HPROF_CHAR;
 698     case JVM_SIGNATURE_FLOAT    : return HPROF_FLOAT;
 699     case JVM_SIGNATURE_DOUBLE   : return HPROF_DOUBLE;
 700     case JVM_SIGNATURE_INT      : return HPROF_INT;
 701     case JVM_SIGNATURE_LONG     : return HPROF_LONG;
 702     case JVM_SIGNATURE_SHORT    : return HPROF_SHORT;
 703     case JVM_SIGNATURE_BOOLEAN  : return HPROF_BOOLEAN;
 704     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 705   }
 706 }
 707 
 708 hprofTag DumperSupport::type2tag(BasicType type) {
 709   switch (type) {
 710     case T_BYTE     : return HPROF_BYTE;
 711     case T_CHAR     : return HPROF_CHAR;
 712     case T_FLOAT    : return HPROF_FLOAT;
 713     case T_DOUBLE   : return HPROF_DOUBLE;
 714     case T_INT      : return HPROF_INT;
 715     case T_LONG     : return HPROF_LONG;
 716     case T_SHORT    : return HPROF_SHORT;
 717     case T_BOOLEAN  : return HPROF_BOOLEAN;
 718     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 719   }
 720 }
 721 
 722 u4 DumperSupport::sig2size(Symbol* sig) {
 723   switch (sig-&gt;char_at(0)) {
 724     case JVM_SIGNATURE_CLASS:
 725     case JVM_SIGNATURE_ARRAY: return sizeof(address);
 726     case JVM_SIGNATURE_BOOLEAN:
 727     case JVM_SIGNATURE_BYTE: return 1;
 728     case JVM_SIGNATURE_SHORT:
 729     case JVM_SIGNATURE_CHAR: return 2;
 730     case JVM_SIGNATURE_INT:
 731     case JVM_SIGNATURE_FLOAT: return 4;
 732     case JVM_SIGNATURE_LONG:
 733     case JVM_SIGNATURE_DOUBLE: return 8;
 734     default: ShouldNotReachHere(); /* to shut up compiler */ return 0;
 735   }
 736 }
 737 
 738 // dump a jfloat
 739 void DumperSupport::dump_float(DumpWriter* writer, jfloat f) {
 740   if (g_isnan(f)) {
 741     writer-&gt;write_u4(0x7fc00000);    // collapsing NaNs
 742   } else {
 743     union {
 744       int i;
 745       float f;
 746     } u;
 747     u.f = (float)f;
 748     writer-&gt;write_u4((u4)u.i);
 749   }
 750 }
 751 
 752 // dump a jdouble
 753 void DumperSupport::dump_double(DumpWriter* writer, jdouble d) {
 754   union {
 755     jlong l;
 756     double d;
 757   } u;
 758   if (g_isnan(d)) {                 // collapsing NaNs
 759     u.l = (jlong)(0x7ff80000);
 760     u.l = (u.l &lt;&lt; 32);
 761   } else {
 762     u.d = (double)d;
 763   }
 764   writer-&gt;write_u8((u8)u.l);
 765 }
 766 
 767 // dumps the raw value of the given field
 768 void DumperSupport::dump_field_value(DumpWriter* writer, char type, oop obj, int offset) {
 769   switch (type) {
 770     case JVM_SIGNATURE_CLASS :
 771     case JVM_SIGNATURE_ARRAY : {
 772       oop o = obj-&gt;obj_field_access&lt;ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE&gt;(offset);
 773       if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {
 774         ResourceMark rm;
 775         log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,
 776                              p2i(o), o-&gt;klass()-&gt;external_name(),
 777                              p2i(obj), obj-&gt;klass()-&gt;external_name());
 778       }
 779       o = mask_dormant_archived_object(o);
 780       assert(oopDesc::is_oop_or_null(o), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(o));
 781       writer-&gt;write_objectID(o);
 782       break;
 783     }
 784     case JVM_SIGNATURE_BYTE : {
 785       jbyte b = obj-&gt;byte_field(offset);
 786       writer-&gt;write_u1((u1)b);
 787       break;
 788     }
 789     case JVM_SIGNATURE_CHAR : {
 790       jchar c = obj-&gt;char_field(offset);
 791       writer-&gt;write_u2((u2)c);
 792       break;
 793     }
 794     case JVM_SIGNATURE_SHORT : {
 795       jshort s = obj-&gt;short_field(offset);
 796       writer-&gt;write_u2((u2)s);
 797       break;
 798     }
 799     case JVM_SIGNATURE_FLOAT : {
 800       jfloat f = obj-&gt;float_field(offset);
 801       dump_float(writer, f);
 802       break;
 803     }
 804     case JVM_SIGNATURE_DOUBLE : {
 805       jdouble d = obj-&gt;double_field(offset);
 806       dump_double(writer, d);
 807       break;
 808     }
 809     case JVM_SIGNATURE_INT : {
 810       jint i = obj-&gt;int_field(offset);
 811       writer-&gt;write_u4((u4)i);
 812       break;
 813     }
 814     case JVM_SIGNATURE_LONG : {
 815       jlong l = obj-&gt;long_field(offset);
 816       writer-&gt;write_u8((u8)l);
 817       break;
 818     }
 819     case JVM_SIGNATURE_BOOLEAN : {
 820       jboolean b = obj-&gt;bool_field(offset);
 821       writer-&gt;write_u1((u1)b);
 822       break;
 823     }
 824     default : {
 825       ShouldNotReachHere();
 826       break;
 827     }
 828   }
 829 }
 830 
 831 // returns the size of the instance of the given class
 832 u4 DumperSupport::instance_size(Klass* k) {
<a name="1" id="anc1"></a><span class="line-removed"> 833   HandleMark hm;</span>
 834   InstanceKlass* ik = InstanceKlass::cast(k);
 835   u4 size = 0;
 836 
 837   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 838     if (!fld.access_flags().is_static()) {
 839       size += sig2size(fld.signature());
 840     }
 841   }
 842   return size;
 843 }
 844 
 845 u4 DumperSupport::get_static_fields_size(InstanceKlass* ik, u2&amp; field_count) {
<a name="2" id="anc2"></a><span class="line-removed"> 846   HandleMark hm;</span>
 847   field_count = 0;
 848   u4 size = 0;
 849 
 850   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
 851     if (fldc.access_flags().is_static()) {
 852       field_count++;
 853       size += sig2size(fldc.signature());
 854     }
 855   }
 856 
 857   // Add in resolved_references which is referenced by the cpCache
 858   // The resolved_references is an array per InstanceKlass holding the
 859   // strings and other oops resolved from the constant pool.
 860   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
 861   if (resolved_references != NULL) {
 862     field_count++;
 863     size += sizeof(address);
 864 
 865     // Add in the resolved_references of the used previous versions of the class
 866     // in the case of RedefineClasses
 867     InstanceKlass* prev = ik-&gt;previous_versions();
 868     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 869       field_count++;
 870       size += sizeof(address);
 871       prev = prev-&gt;previous_versions();
 872     }
 873   }
 874 
 875   // Also provide a pointer to the init_lock if present, so there aren&#39;t unreferenced int[0]
 876   // arrays.
 877   oop init_lock = ik-&gt;init_lock();
 878   if (init_lock != NULL) {
 879     field_count++;
 880     size += sizeof(address);
 881   }
 882 
 883   // We write the value itself plus a name and a one byte type tag per field.
 884   return size + field_count * (sizeof(address) + 1);
 885 }
 886 
 887 // dumps static fields of the given class
 888 void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {
<a name="3" id="anc3"></a><span class="line-removed"> 889   HandleMark hm;</span>
 890   InstanceKlass* ik = InstanceKlass::cast(k);
 891 
 892   // dump the field descriptors and raw values
 893   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 894     if (fld.access_flags().is_static()) {
 895       Symbol* sig = fld.signature();
 896 
 897       writer-&gt;write_symbolID(fld.name());   // name
 898       writer-&gt;write_u1(sig2tag(sig));       // type
 899 
 900       // value
 901       dump_field_value(writer, sig-&gt;char_at(0), ik-&gt;java_mirror(), fld.offset());
 902     }
 903   }
 904 
 905   // Add resolved_references for each class that has them
 906   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
 907   if (resolved_references != NULL) {
 908     writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 909     writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 910     writer-&gt;write_objectID(resolved_references);
 911 
 912     // Also write any previous versions
 913     InstanceKlass* prev = ik-&gt;previous_versions();
 914     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 915       writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 916       writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 917       writer-&gt;write_objectID(prev-&gt;constants()-&gt;resolved_references());
 918       prev = prev-&gt;previous_versions();
 919     }
 920   }
 921 
 922   // Add init lock to the end if the class is not yet initialized
 923   oop init_lock = ik-&gt;init_lock();
 924   if (init_lock != NULL) {
 925     writer-&gt;write_symbolID(vmSymbols::init_lock_name());         // name
 926     writer-&gt;write_u1(sig2tag(vmSymbols::int_array_signature())); // type
 927     writer-&gt;write_objectID(init_lock);
 928   }
 929 }
 930 
 931 // dump the raw values of the instance fields of the given object
 932 void DumperSupport::dump_instance_fields(DumpWriter* writer, oop o) {
<a name="4" id="anc4"></a><span class="line-removed"> 933   HandleMark hm;</span>
 934   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());
 935 
 936   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 937     if (!fld.access_flags().is_static()) {
 938       Symbol* sig = fld.signature();
 939       dump_field_value(writer, sig-&gt;char_at(0), o, fld.offset());
 940     }
 941   }
 942 }
 943 
 944 // dumps the definition of the instance fields for a given class
 945 u2 DumperSupport::get_instance_fields_count(InstanceKlass* ik) {
<a name="5" id="anc5"></a><span class="line-removed"> 946   HandleMark hm;</span>
 947   u2 field_count = 0;
 948 
 949   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
 950     if (!fldc.access_flags().is_static()) field_count++;
 951   }
 952 
 953   return field_count;
 954 }
 955 
 956 // dumps the definition of the instance fields for a given class
 957 void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {
<a name="6" id="anc6"></a><span class="line-removed"> 958   HandleMark hm;</span>
 959   InstanceKlass* ik = InstanceKlass::cast(k);
 960 
 961   // dump the field descriptors
 962   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 963     if (!fld.access_flags().is_static()) {
 964       Symbol* sig = fld.signature();
 965 
 966       writer-&gt;write_symbolID(fld.name());   // name
 967       writer-&gt;write_u1(sig2tag(sig));       // type
 968     }
 969   }
 970 }
 971 
 972 // creates HPROF_GC_INSTANCE_DUMP record for the given object
 973 void DumperSupport::dump_instance(DumpWriter* writer, oop o) {
 974   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());
 975   u4 is = instance_size(ik);
 976   u4 size = 1 + sizeof(address) + 4 + sizeof(address) + 4 + is;
 977 
 978   writer-&gt;start_sub_record(HPROF_GC_INSTANCE_DUMP, size);
 979   writer-&gt;write_objectID(o);
 980   writer-&gt;write_u4(STACK_TRACE_ID);
 981 
 982   // class ID
 983   writer-&gt;write_classID(ik);
 984 
 985   // number of bytes that follow
 986   writer-&gt;write_u4(is);
 987 
 988   // field values
 989   dump_instance_fields(writer, o);
 990 
 991   writer-&gt;end_sub_record();
 992 }
 993 
 994 // creates HPROF_GC_CLASS_DUMP record for the given class and each of
 995 // its array classes
 996 void DumperSupport::dump_class_and_array_classes(DumpWriter* writer, Klass* k) {
 997   InstanceKlass* ik = InstanceKlass::cast(k);
 998 
 999   // We can safepoint and do a heap dump at a point where we have a Klass,
1000   // but no java mirror class has been setup for it. So we need to check
1001   // that the class is at least loaded, to avoid crash from a null mirror.
1002   if (!ik-&gt;is_loaded()) {
1003     return;
1004   }
1005 
1006   u2 static_fields_count = 0;
1007   u4 static_size = get_static_fields_size(ik, static_fields_count);
1008   u2 instance_fields_count = get_instance_fields_count(ik);
1009   u4 instance_fields_size = instance_fields_count * (sizeof(address) + 1);
1010   u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + static_size + 2 + instance_fields_size;
1011 
1012   writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);
1013 
1014   // class ID
1015   writer-&gt;write_classID(ik);
1016   writer-&gt;write_u4(STACK_TRACE_ID);
1017 
1018   // super class ID
1019   InstanceKlass* java_super = ik-&gt;java_super();
1020   if (java_super == NULL) {
1021     writer-&gt;write_objectID(oop(NULL));
1022   } else {
1023     writer-&gt;write_classID(java_super);
1024   }
1025 
1026   writer-&gt;write_objectID(ik-&gt;class_loader());
1027   writer-&gt;write_objectID(ik-&gt;signers());
1028   writer-&gt;write_objectID(ik-&gt;protection_domain());
1029 
1030   // reserved
1031   writer-&gt;write_objectID(oop(NULL));
1032   writer-&gt;write_objectID(oop(NULL));
1033 
1034   // instance size
1035   writer-&gt;write_u4(DumperSupport::instance_size(ik));
1036 
1037   // size of constant pool - ignored by HAT 1.1
1038   writer-&gt;write_u2(0);
1039 
1040   // static fields
1041   writer-&gt;write_u2(static_fields_count);
1042   dump_static_fields(writer, ik);
1043 
1044   // description of instance fields
1045   writer-&gt;write_u2(instance_fields_count);
1046   dump_instance_field_descriptors(writer, ik);
1047 
1048   writer-&gt;end_sub_record();
1049 
1050   // array classes
1051   k = ik-&gt;array_klass_or_null();
1052   while (k != NULL) {
1053     assert(k-&gt;is_objArray_klass(), &quot;not an ObjArrayKlass&quot;);
1054 
1055     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;
1056     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);
1057     writer-&gt;write_classID(k);
1058     writer-&gt;write_u4(STACK_TRACE_ID);
1059 
1060     // super class of array classes is java.lang.Object
1061     java_super = k-&gt;java_super();
1062     assert(java_super != NULL, &quot;checking&quot;);
1063     writer-&gt;write_classID(java_super);
1064 
1065     writer-&gt;write_objectID(ik-&gt;class_loader());
1066     writer-&gt;write_objectID(ik-&gt;signers());
1067     writer-&gt;write_objectID(ik-&gt;protection_domain());
1068 
1069     writer-&gt;write_objectID(oop(NULL));    // reserved
1070     writer-&gt;write_objectID(oop(NULL));
1071     writer-&gt;write_u4(0);             // instance size
1072     writer-&gt;write_u2(0);             // constant pool
1073     writer-&gt;write_u2(0);             // static fields
1074     writer-&gt;write_u2(0);             // instance fields
1075 
1076     writer-&gt;end_sub_record();
1077 
1078     // get the array class for the next rank
1079     k = k-&gt;array_klass_or_null();
1080   }
1081 }
1082 
1083 // creates HPROF_GC_CLASS_DUMP record for a given primitive array
1084 // class (and each multi-dimensional array class too)
1085 void DumperSupport::dump_basic_type_array_class(DumpWriter* writer, Klass* k) {
1086  // array classes
1087  while (k != NULL) {
1088     Klass* klass = k;
1089 
1090     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;
1091     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);
1092     writer-&gt;write_classID(klass);
1093     writer-&gt;write_u4(STACK_TRACE_ID);
1094 
1095     // super class of array classes is java.lang.Object
1096     InstanceKlass* java_super = klass-&gt;java_super();
1097     assert(java_super != NULL, &quot;checking&quot;);
1098     writer-&gt;write_classID(java_super);
1099 
1100     writer-&gt;write_objectID(oop(NULL));    // loader
1101     writer-&gt;write_objectID(oop(NULL));    // signers
1102     writer-&gt;write_objectID(oop(NULL));    // protection domain
1103 
1104     writer-&gt;write_objectID(oop(NULL));    // reserved
1105     writer-&gt;write_objectID(oop(NULL));
1106     writer-&gt;write_u4(0);             // instance size
1107     writer-&gt;write_u2(0);             // constant pool
1108     writer-&gt;write_u2(0);             // static fields
1109     writer-&gt;write_u2(0);             // instance fields
1110 
1111     writer-&gt;end_sub_record();
1112 
1113     // get the array class for the next rank
1114     k = klass-&gt;array_klass_or_null();
1115   }
1116 }
1117 
1118 // Hprof uses an u4 as record length field,
1119 // which means we need to truncate arrays that are too long.
1120 int DumperSupport::calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size) {
1121   BasicType type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1122   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt;= T_OBJECT, &quot;invalid array element type&quot;);
1123 
1124   int length = array-&gt;length();
1125 
1126   int type_size;
1127   if (type == T_OBJECT) {
1128     type_size = sizeof(address);
1129   } else {
1130     type_size = type2aelembytes(type);
1131   }
1132 
1133   size_t length_in_bytes = (size_t)length * type_size;
1134   uint max_bytes = max_juint - header_size;
1135 
1136   if (length_in_bytes &gt; max_bytes) {
1137     length = max_bytes / type_size;
1138     length_in_bytes = (size_t)length * type_size;
1139 
1140     warning(&quot;cannot dump array of type %s[] with length %d; truncating to length %d&quot;,
1141             type2name_tab[type], array-&gt;length(), length);
1142   }
1143   return length;
1144 }
1145 
1146 // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
1147 void DumperSupport::dump_object_array(DumpWriter* writer, objArrayOop array) {
1148   // sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID) + sizeof(classID)
1149   short header_size = 1 + 2 * 4 + 2 * sizeof(address);
1150   int length = calculate_array_max_length(writer, array, header_size);
1151   u4 size = header_size + length * sizeof(address);
1152 
1153   writer-&gt;start_sub_record(HPROF_GC_OBJ_ARRAY_DUMP, size);
1154   writer-&gt;write_objectID(array);
1155   writer-&gt;write_u4(STACK_TRACE_ID);
1156   writer-&gt;write_u4(length);
1157 
1158   // array class ID
1159   writer-&gt;write_classID(array-&gt;klass());
1160 
1161   // [id]* elements
1162   for (int index = 0; index &lt; length; index++) {
1163     oop o = array-&gt;obj_at(index);
1164     if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {
1165       ResourceMark rm;
1166       log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,
1167                            p2i(o), o-&gt;klass()-&gt;external_name(),
1168                            p2i(array), array-&gt;klass()-&gt;external_name());
1169     }
1170     o = mask_dormant_archived_object(o);
1171     writer-&gt;write_objectID(o);
1172   }
1173 
1174   writer-&gt;end_sub_record();
1175 }
1176 
1177 #define WRITE_ARRAY(Array, Type, Size, Length) \
1178   for (int i = 0; i &lt; Length; i++) { writer-&gt;write_##Size((Size)Array-&gt;Type##_at(i)); }
1179 
1180 // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
1181 void DumperSupport::dump_prim_array(DumpWriter* writer, typeArrayOop array) {
1182   BasicType type = TypeArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1183 
1184   // 2 * sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID)
1185   short header_size = 2 * 1 + 2 * 4 + sizeof(address);
1186 
1187   int length = calculate_array_max_length(writer, array, header_size);
1188   int type_size = type2aelembytes(type);
1189   u4 length_in_bytes = (u4)length * type_size;
1190   u4 size = header_size + length_in_bytes;
1191 
1192   writer-&gt;start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);
1193   writer-&gt;write_objectID(array);
1194   writer-&gt;write_u4(STACK_TRACE_ID);
1195   writer-&gt;write_u4(length);
1196   writer-&gt;write_u1(type2tag(type));
1197 
1198   // nothing to copy
1199   if (length == 0) {
1200     writer-&gt;end_sub_record();
1201     return;
1202   }
1203 
1204   // If the byte ordering is big endian then we can copy most types directly
1205 
1206   switch (type) {
1207     case T_INT : {
1208       if (Endian::is_Java_byte_ordering_different()) {
1209         WRITE_ARRAY(array, int, u4, length);
1210       } else {
1211         writer-&gt;write_raw((void*)(array-&gt;int_at_addr(0)), length_in_bytes);
1212       }
1213       break;
1214     }
1215     case T_BYTE : {
1216       writer-&gt;write_raw((void*)(array-&gt;byte_at_addr(0)), length_in_bytes);
1217       break;
1218     }
1219     case T_CHAR : {
1220       if (Endian::is_Java_byte_ordering_different()) {
1221         WRITE_ARRAY(array, char, u2, length);
1222       } else {
1223         writer-&gt;write_raw((void*)(array-&gt;char_at_addr(0)), length_in_bytes);
1224       }
1225       break;
1226     }
1227     case T_SHORT : {
1228       if (Endian::is_Java_byte_ordering_different()) {
1229         WRITE_ARRAY(array, short, u2, length);
1230       } else {
1231         writer-&gt;write_raw((void*)(array-&gt;short_at_addr(0)), length_in_bytes);
1232       }
1233       break;
1234     }
1235     case T_BOOLEAN : {
1236       if (Endian::is_Java_byte_ordering_different()) {
1237         WRITE_ARRAY(array, bool, u1, length);
1238       } else {
1239         writer-&gt;write_raw((void*)(array-&gt;bool_at_addr(0)), length_in_bytes);
1240       }
1241       break;
1242     }
1243     case T_LONG : {
1244       if (Endian::is_Java_byte_ordering_different()) {
1245         WRITE_ARRAY(array, long, u8, length);
1246       } else {
1247         writer-&gt;write_raw((void*)(array-&gt;long_at_addr(0)), length_in_bytes);
1248       }
1249       break;
1250     }
1251 
1252     // handle float/doubles in a special value to ensure than NaNs are
1253     // written correctly. TO DO: Check if we can avoid this on processors that
1254     // use IEEE 754.
1255 
1256     case T_FLOAT : {
1257       for (int i = 0; i &lt; length; i++) {
1258         dump_float(writer, array-&gt;float_at(i));
1259       }
1260       break;
1261     }
1262     case T_DOUBLE : {
1263       for (int i = 0; i &lt; length; i++) {
1264         dump_double(writer, array-&gt;double_at(i));
1265       }
1266       break;
1267     }
1268     default : ShouldNotReachHere();
1269   }
1270 
1271   writer-&gt;end_sub_record();
1272 }
1273 
1274 // create a HPROF_FRAME record of the given Method* and bci
1275 void DumperSupport::dump_stack_frame(DumpWriter* writer,
1276                                      int frame_serial_num,
1277                                      int class_serial_num,
1278                                      Method* m,
1279                                      int bci) {
1280   int line_number;
1281   if (m-&gt;is_native()) {
1282     line_number = -3;  // native frame
1283   } else {
1284     line_number = m-&gt;line_number_from_bci(bci);
1285   }
1286 
1287   write_header(writer, HPROF_FRAME, 4*oopSize + 2*sizeof(u4));
1288   writer-&gt;write_id(frame_serial_num);               // frame serial number
1289   writer-&gt;write_symbolID(m-&gt;name());                // method&#39;s name
1290   writer-&gt;write_symbolID(m-&gt;signature());           // method&#39;s signature
1291 
1292   assert(m-&gt;method_holder()-&gt;is_instance_klass(), &quot;not InstanceKlass&quot;);
1293   writer-&gt;write_symbolID(m-&gt;method_holder()-&gt;source_file_name());  // source file name
1294   writer-&gt;write_u4(class_serial_num);               // class serial number
1295   writer-&gt;write_u4((u4) line_number);               // line number
1296 }
1297 
1298 
1299 // Support class used to generate HPROF_UTF8 records from the entries in the
1300 // SymbolTable.
1301 
1302 class SymbolTableDumper : public SymbolClosure {
1303  private:
1304   DumpWriter* _writer;
1305   DumpWriter* writer() const                { return _writer; }
1306  public:
1307   SymbolTableDumper(DumpWriter* writer)     { _writer = writer; }
1308   void do_symbol(Symbol** p);
1309 };
1310 
1311 void SymbolTableDumper::do_symbol(Symbol** p) {
1312   ResourceMark rm;
1313   Symbol* sym = load_symbol(p);
1314   int len = sym-&gt;utf8_length();
1315   if (len &gt; 0) {
1316     char* s = sym-&gt;as_utf8();
1317     DumperSupport::write_header(writer(), HPROF_UTF8, oopSize + len);
1318     writer()-&gt;write_symbolID(sym);
1319     writer()-&gt;write_raw(s, len);
1320   }
1321 }
1322 
1323 // Support class used to generate HPROF_GC_ROOT_JNI_LOCAL records
1324 
1325 class JNILocalsDumper : public OopClosure {
1326  private:
1327   DumpWriter* _writer;
1328   u4 _thread_serial_num;
1329   int _frame_num;
1330   DumpWriter* writer() const                { return _writer; }
1331  public:
1332   JNILocalsDumper(DumpWriter* writer, u4 thread_serial_num) {
1333     _writer = writer;
1334     _thread_serial_num = thread_serial_num;
1335     _frame_num = -1;  // default - empty stack
1336   }
1337   void set_frame_number(int n) { _frame_num = n; }
1338   void do_oop(oop* obj_p);
1339   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1340 };
1341 
1342 
1343 void JNILocalsDumper::do_oop(oop* obj_p) {
1344   // ignore null handles
1345   oop o = *obj_p;
1346   if (o != NULL) {
1347     u4 size = 1 + sizeof(address) + 4 + 4;
1348     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_LOCAL, size);
1349     writer()-&gt;write_objectID(o);
1350     writer()-&gt;write_u4(_thread_serial_num);
1351     writer()-&gt;write_u4((u4)_frame_num);
1352     writer()-&gt;end_sub_record();
1353   }
1354 }
1355 
1356 
1357 // Support class used to generate HPROF_GC_ROOT_JNI_GLOBAL records
1358 
1359 class JNIGlobalsDumper : public OopClosure {
1360  private:
1361   DumpWriter* _writer;
1362   DumpWriter* writer() const                { return _writer; }
1363 
1364  public:
1365   JNIGlobalsDumper(DumpWriter* writer) {
1366     _writer = writer;
1367   }
1368   void do_oop(oop* obj_p);
1369   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1370 };
1371 
1372 void JNIGlobalsDumper::do_oop(oop* obj_p) {
1373   oop o = *obj_p;
1374 
1375   // ignore these
1376   if (o == NULL) return;
1377 
1378   // we ignore global ref to symbols and other internal objects
1379   if (o-&gt;is_instance() || o-&gt;is_objArray() || o-&gt;is_typeArray()) {
1380     u4 size = 1 + 2 * sizeof(address);
1381     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_GLOBAL, size);
1382     writer()-&gt;write_objectID(o);
1383     writer()-&gt;write_objectID((oopDesc*)obj_p);      // global ref ID
1384     writer()-&gt;end_sub_record();
1385   }
1386 };
1387 
1388 
1389 // Support class used to generate HPROF_GC_ROOT_MONITOR_USED records
1390 
1391 class MonitorUsedDumper : public OopClosure {
1392  private:
1393   DumpWriter* _writer;
1394   DumpWriter* writer() const                { return _writer; }
1395  public:
1396   MonitorUsedDumper(DumpWriter* writer) {
1397     _writer = writer;
1398   }
1399   void do_oop(oop* obj_p) {
1400     u4 size = 1 + sizeof(address);
1401     writer()-&gt;start_sub_record(HPROF_GC_ROOT_MONITOR_USED, size);
1402     writer()-&gt;write_objectID(*obj_p);
1403     writer()-&gt;end_sub_record();
1404   }
1405   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1406 };
1407 
1408 
1409 // Support class used to generate HPROF_GC_ROOT_STICKY_CLASS records
1410 
1411 class StickyClassDumper : public KlassClosure {
1412  private:
1413   DumpWriter* _writer;
1414   DumpWriter* writer() const                { return _writer; }
1415  public:
1416   StickyClassDumper(DumpWriter* writer) {
1417     _writer = writer;
1418   }
1419   void do_klass(Klass* k) {
1420     if (k-&gt;is_instance_klass()) {
1421       InstanceKlass* ik = InstanceKlass::cast(k);
1422       u4 size = 1 + sizeof(address);
1423       writer()-&gt;start_sub_record(HPROF_GC_ROOT_STICKY_CLASS, size);
1424       writer()-&gt;write_classID(ik);
1425       writer()-&gt;end_sub_record();
1426     }
1427   }
1428 };
1429 
1430 
1431 class VM_HeapDumper;
1432 
1433 // Support class using when iterating over the heap.
1434 
1435 class HeapObjectDumper : public ObjectClosure {
1436  private:
1437   VM_HeapDumper* _dumper;
1438   DumpWriter* _writer;
1439 
1440   VM_HeapDumper* dumper()               { return _dumper; }
1441   DumpWriter* writer()                  { return _writer; }
1442 
1443  public:
1444   HeapObjectDumper(VM_HeapDumper* dumper, DumpWriter* writer) {
1445     _dumper = dumper;
1446     _writer = writer;
1447   }
1448 
1449   // called for each object in the heap
1450   void do_object(oop o);
1451 };
1452 
1453 void HeapObjectDumper::do_object(oop o) {
1454   // skip classes as these emitted as HPROF_GC_CLASS_DUMP records
1455   if (o-&gt;klass() == SystemDictionary::Class_klass()) {
1456     if (!java_lang_Class::is_primitive(o)) {
1457       return;
1458     }
1459   }
1460 
1461   if (DumperSupport::mask_dormant_archived_object(o) == NULL) {
1462     log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());
1463     return;
1464   }
1465 
1466   if (o-&gt;is_instance()) {
1467     // create a HPROF_GC_INSTANCE record for each object
1468     DumperSupport::dump_instance(writer(), o);
1469   } else if (o-&gt;is_objArray()) {
1470     // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
1471     DumperSupport::dump_object_array(writer(), objArrayOop(o));
1472   } else if (o-&gt;is_typeArray()) {
1473     // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
1474     DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
1475   }
1476 }
1477 
1478 // The VM operation that performs the heap dump
1479 class VM_HeapDumper : public VM_GC_Operation, public AbstractGangTask {
1480  private:
1481   static VM_HeapDumper* _global_dumper;
1482   static DumpWriter*    _global_writer;
1483   DumpWriter*           _local_writer;
1484   JavaThread*           _oome_thread;
1485   Method*               _oome_constructor;
1486   bool _gc_before_heap_dump;
1487   GrowableArray&lt;Klass*&gt;* _klass_map;
1488   ThreadStackTrace** _stack_traces;
1489   int _num_threads;
1490 
1491   // accessors and setters
1492   static VM_HeapDumper* dumper()         {  assert(_global_dumper != NULL, &quot;Error&quot;); return _global_dumper; }
1493   static DumpWriter* writer()            {  assert(_global_writer != NULL, &quot;Error&quot;); return _global_writer; }
1494   void set_global_dumper() {
1495     assert(_global_dumper == NULL, &quot;Error&quot;);
1496     _global_dumper = this;
1497   }
1498   void set_global_writer() {
1499     assert(_global_writer == NULL, &quot;Error&quot;);
1500     _global_writer = _local_writer;
1501   }
1502   void clear_global_dumper() { _global_dumper = NULL; }
1503   void clear_global_writer() { _global_writer = NULL; }
1504 
1505   bool skip_operation() const;
1506 
1507   // writes a HPROF_LOAD_CLASS record
1508   class ClassesDo;
1509   static void do_load_class(Klass* k);
1510 
1511   // writes a HPROF_GC_CLASS_DUMP record for the given class
1512   // (and each array class too)
1513   static void do_class_dump(Klass* k);
1514 
1515   // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1516   // array (and each multi-dimensional array too)
1517   static void do_basic_type_array_class_dump(Klass* k);
1518 
1519   // HPROF_GC_ROOT_THREAD_OBJ records
1520   int do_thread(JavaThread* thread, u4 thread_serial_num);
1521   void do_threads();
1522 
1523   void add_class_serial_number(Klass* k, int serial_num) {
1524     _klass_map-&gt;at_put_grow(serial_num, k);
1525   }
1526 
1527   // HPROF_TRACE and HPROF_FRAME records
1528   void dump_stack_traces();
1529 
1530  public:
1531   VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome) :
1532     VM_GC_Operation(0 /* total collections,      dummy, ignored */,
1533                     GCCause::_heap_dump /* GC Cause */,
1534                     0 /* total full collections, dummy, ignored */,
1535                     gc_before_heap_dump),
1536     AbstractGangTask(&quot;dump heap&quot;) {
1537     _local_writer = writer;
1538     _gc_before_heap_dump = gc_before_heap_dump;
1539     _klass_map = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;Klass*&gt;(INITIAL_CLASS_COUNT, mtServiceability);
1540     _stack_traces = NULL;
1541     _num_threads = 0;
1542     if (oome) {
1543       assert(!Thread::current()-&gt;is_VM_thread(), &quot;Dump from OutOfMemoryError cannot be called by the VMThread&quot;);
1544       // get OutOfMemoryError zero-parameter constructor
1545       InstanceKlass* oome_ik = SystemDictionary::OutOfMemoryError_klass();
1546       _oome_constructor = oome_ik-&gt;find_method(vmSymbols::object_initializer_name(),
1547                                                           vmSymbols::void_method_signature());
1548       // get thread throwing OOME when generating the heap dump at OOME
1549       _oome_thread = JavaThread::current();
1550     } else {
1551       _oome_thread = NULL;
1552       _oome_constructor = NULL;
1553     }
1554   }
1555   ~VM_HeapDumper() {
1556     if (_stack_traces != NULL) {
1557       for (int i=0; i &lt; _num_threads; i++) {
1558         delete _stack_traces[i];
1559       }
1560       FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);
1561     }
1562     delete _klass_map;
1563   }
1564 
1565   VMOp_Type type() const { return VMOp_HeapDumper; }
1566   void doit();
1567   void work(uint worker_id);
1568 };
1569 
1570 
1571 VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
1572 DumpWriter*    VM_HeapDumper::_global_writer = NULL;
1573 
1574 bool VM_HeapDumper::skip_operation() const {
1575   return false;
1576 }
1577 
1578 // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
1579 void DumperSupport::end_of_dump(DumpWriter* writer) {
1580   writer-&gt;finish_dump_segment();
1581 
1582   writer-&gt;write_u1(HPROF_HEAP_DUMP_END);
1583   writer-&gt;write_u4(0);
1584   writer-&gt;write_u4(0);
1585 }
1586 
1587 // writes a HPROF_LOAD_CLASS record for the class (and each of its
1588 // array classes)
1589 void VM_HeapDumper::do_load_class(Klass* k) {
1590   static u4 class_serial_num = 0;
1591 
1592   // len of HPROF_LOAD_CLASS record
1593   u4 remaining = 2*oopSize + 2*sizeof(u4);
1594 
1595   // write a HPROF_LOAD_CLASS for the class and each array class
1596   do {
1597     DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);
1598 
1599     // class serial number is just a number
1600     writer()-&gt;write_u4(++class_serial_num);
1601 
1602     // class ID
1603     Klass* klass = k;
1604     writer()-&gt;write_classID(klass);
1605 
1606     // add the Klass* and class serial number pair
1607     dumper()-&gt;add_class_serial_number(klass, class_serial_num);
1608 
1609     writer()-&gt;write_u4(STACK_TRACE_ID);
1610 
1611     // class name ID
1612     Symbol* name = klass-&gt;name();
1613     writer()-&gt;write_symbolID(name);
1614 
1615     // write a LOAD_CLASS record for the array type (if it exists)
1616     k = klass-&gt;array_klass_or_null();
1617   } while (k != NULL);
1618 }
1619 
1620 // writes a HPROF_GC_CLASS_DUMP record for the given class
1621 void VM_HeapDumper::do_class_dump(Klass* k) {
1622   if (k-&gt;is_instance_klass()) {
1623     DumperSupport::dump_class_and_array_classes(writer(), k);
1624   }
1625 }
1626 
1627 // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1628 // array (and each multi-dimensional array too)
1629 void VM_HeapDumper::do_basic_type_array_class_dump(Klass* k) {
1630   DumperSupport::dump_basic_type_array_class(writer(), k);
1631 }
1632 
1633 // Walk the stack of the given thread.
1634 // Dumps a HPROF_GC_ROOT_JAVA_FRAME record for each local
1635 // Dumps a HPROF_GC_ROOT_JNI_LOCAL record for each JNI local
1636 //
1637 // It returns the number of Java frames in this thread stack
1638 int VM_HeapDumper::do_thread(JavaThread* java_thread, u4 thread_serial_num) {
1639   JNILocalsDumper blk(writer(), thread_serial_num);
1640 
1641   oop threadObj = java_thread-&gt;threadObj();
1642   assert(threadObj != NULL, &quot;sanity check&quot;);
1643 
1644   int stack_depth = 0;
1645   if (java_thread-&gt;has_last_Java_frame()) {
1646 
1647     // vframes are resource allocated
1648     Thread* current_thread = Thread::current();
1649     ResourceMark rm(current_thread);
1650     HandleMark hm(current_thread);
1651 
1652     RegisterMap reg_map(java_thread);
1653     frame f = java_thread-&gt;last_frame();
1654     vframe* vf = vframe::new_vframe(&amp;f, &amp;reg_map, java_thread);
1655     frame* last_entry_frame = NULL;
1656     int extra_frames = 0;
1657 
1658     if (java_thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1659       extra_frames++;
1660     }
1661     while (vf != NULL) {
1662       blk.set_frame_number(stack_depth);
1663       if (vf-&gt;is_java_frame()) {
1664 
1665         // java frame (interpreted, compiled, ...)
1666         javaVFrame *jvf = javaVFrame::cast(vf);
1667         if (!(jvf-&gt;method()-&gt;is_native())) {
1668           StackValueCollection* locals = jvf-&gt;locals();
1669           for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
1670             if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
1671               oop o = locals-&gt;obj_at(slot)();
1672 
1673               if (o != NULL) {
1674                 u4 size = 1 + sizeof(address) + 4 + 4;
1675                 writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);
1676                 writer()-&gt;write_objectID(o);
1677                 writer()-&gt;write_u4(thread_serial_num);
1678                 writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
1679                 writer()-&gt;end_sub_record();
1680               }
1681             }
1682           }
1683           StackValueCollection *exprs = jvf-&gt;expressions();
1684           for(int index = 0; index &lt; exprs-&gt;size(); index++) {
1685             if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
1686                oop o = exprs-&gt;obj_at(index)();
1687                if (o != NULL) {
1688                  u4 size = 1 + sizeof(address) + 4 + 4;
1689                  writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);
1690                  writer()-&gt;write_objectID(o);
1691                  writer()-&gt;write_u4(thread_serial_num);
1692                  writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
1693                  writer()-&gt;end_sub_record();
1694                }
1695              }
1696           }
1697         } else {
1698           // native frame
1699           if (stack_depth == 0) {
1700             // JNI locals for the top frame.
1701             java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1702           } else {
1703             if (last_entry_frame != NULL) {
1704               // JNI locals for the entry frame
1705               assert(last_entry_frame-&gt;is_entry_frame(), &quot;checking&quot;);
1706               last_entry_frame-&gt;entry_frame_call_wrapper()-&gt;handles()-&gt;oops_do(&amp;blk);
1707             }
1708           }
1709         }
1710         // increment only for Java frames
1711         stack_depth++;
1712         last_entry_frame = NULL;
1713 
1714       } else {
1715         // externalVFrame - if it&#39;s an entry frame then report any JNI locals
1716         // as roots when we find the corresponding native javaVFrame
1717         frame* fr = vf-&gt;frame_pointer();
1718         assert(fr != NULL, &quot;sanity check&quot;);
1719         if (fr-&gt;is_entry_frame()) {
1720           last_entry_frame = fr;
1721         }
1722       }
1723       vf = vf-&gt;sender();
1724     }
1725   } else {
1726     // no last java frame but there may be JNI locals
1727     java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1728   }
1729   return stack_depth;
1730 }
1731 
1732 
1733 // write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk
1734 // the stack so that locals and JNI locals are dumped.
1735 void VM_HeapDumper::do_threads() {
1736   for (int i=0; i &lt; _num_threads; i++) {
1737     JavaThread* thread = _stack_traces[i]-&gt;thread();
1738     oop threadObj = thread-&gt;threadObj();
1739     u4 thread_serial_num = i+1;
1740     u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;
1741     u4 size = 1 + sizeof(address) + 4 + 4;
1742     writer()-&gt;start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);
1743     writer()-&gt;write_objectID(threadObj);
1744     writer()-&gt;write_u4(thread_serial_num);  // thread number
1745     writer()-&gt;write_u4(stack_serial_num);   // stack trace serial number
1746     writer()-&gt;end_sub_record();
1747     int num_frames = do_thread(thread, thread_serial_num);
1748     assert(num_frames == _stack_traces[i]-&gt;get_stack_depth(),
1749            &quot;total number of Java frames not matched&quot;);
1750   }
1751 }
1752 
1753 
1754 // The VM operation that dumps the heap. The dump consists of the following
1755 // records:
1756 //
1757 //  HPROF_HEADER
1758 //  [HPROF_UTF8]*
1759 //  [HPROF_LOAD_CLASS]*
1760 //  [[HPROF_FRAME]*|HPROF_TRACE]*
1761 //  [HPROF_GC_CLASS_DUMP]*
1762 //  [HPROF_HEAP_DUMP_SEGMENT]*
1763 //  HPROF_HEAP_DUMP_END
1764 //
1765 // The HPROF_TRACE records represent the stack traces where the heap dump
1766 // is generated and a &quot;dummy trace&quot; record which does not include
1767 // any frames. The dummy trace record is used to be referenced as the
1768 // unknown object alloc site.
1769 //
1770 // Each HPROF_HEAP_DUMP_SEGMENT record has a length followed by sub-records.
1771 // To allow the heap dump be generated in a single pass we remember the position
1772 // of the dump length and fix it up after all sub-records have been written.
1773 // To generate the sub-records we iterate over the heap, writing
1774 // HPROF_GC_INSTANCE_DUMP, HPROF_GC_OBJ_ARRAY_DUMP, and HPROF_GC_PRIM_ARRAY_DUMP
1775 // records as we go. Once that is done we write records for some of the GC
1776 // roots.
1777 
1778 void VM_HeapDumper::doit() {
1779 
<a name="7" id="anc7"></a><span class="line-removed">1780   HandleMark hm;</span>
1781   CollectedHeap* ch = Universe::heap();
1782 
1783   ch-&gt;ensure_parsability(false); // must happen, even if collection does
1784                                  // not happen (e.g. due to GCLocker)
1785 
1786   if (_gc_before_heap_dump) {
1787     if (GCLocker::is_active()) {
1788       warning(&quot;GC locker is held; pre-heapdump GC was skipped&quot;);
1789     } else {
1790       ch-&gt;collect_as_vm_thread(GCCause::_heap_dump);
1791     }
1792   }
1793 
1794   // At this point we should be the only dumper active, so
1795   // the following should be safe.
1796   set_global_dumper();
1797   set_global_writer();
1798 
1799   WorkGang* gang = ch-&gt;get_safepoint_workers();
1800 
1801   if (gang == NULL) {
1802     work(0);
1803   } else {
1804     gang-&gt;run_task(this, gang-&gt;active_workers(), true);
1805   }
1806 
1807   // Now we clear the global variables, so that a future dumper can run.
1808   clear_global_dumper();
1809   clear_global_writer();
1810 }
1811 
1812 void VM_HeapDumper::work(uint worker_id) {
1813   if (!Thread::current()-&gt;is_VM_thread()) {
1814     writer()-&gt;writer_loop();
1815     return;
1816   }
1817 
1818   // Write the file header - we always use 1.0.2
1819   const char* header = &quot;JAVA PROFILE 1.0.2&quot;;
1820 
1821   // header is few bytes long - no chance to overflow int
1822   writer()-&gt;write_raw((void*)header, (int)strlen(header));
1823   writer()-&gt;write_u1(0); // terminator
1824   writer()-&gt;write_u4(oopSize);
1825   // timestamp is current time in ms
1826   writer()-&gt;write_u8(os::javaTimeMillis());
1827 
1828   // HPROF_UTF8 records
1829   SymbolTableDumper sym_dumper(writer());
1830   SymbolTable::symbols_do(&amp;sym_dumper);
1831 
1832   // write HPROF_LOAD_CLASS records
1833   {
1834     LockedClassesDo locked_load_classes(&amp;do_load_class);
1835     ClassLoaderDataGraph::classes_do(&amp;locked_load_classes);
1836   }
1837   Universe::basic_type_classes_do(&amp;do_load_class);
1838 
1839   // write HPROF_FRAME and HPROF_TRACE records
1840   // this must be called after _klass_map is built when iterating the classes above.
1841   dump_stack_traces();
1842 
1843   // Writes HPROF_GC_CLASS_DUMP records
1844   {
1845     LockedClassesDo locked_dump_class(&amp;do_class_dump);
1846     ClassLoaderDataGraph::classes_do(&amp;locked_dump_class);
1847   }
1848   Universe::basic_type_classes_do(&amp;do_basic_type_array_class_dump);
1849 
1850   // writes HPROF_GC_INSTANCE_DUMP records.
1851   // After each sub-record is written check_segment_length will be invoked
1852   // to check if the current segment exceeds a threshold. If so, a new
1853   // segment is started.
1854   // The HPROF_GC_CLASS_DUMP and HPROF_GC_INSTANCE_DUMP are the vast bulk
1855   // of the heap dump.
1856   HeapObjectDumper obj_dumper(this, writer());
1857   Universe::heap()-&gt;object_iterate(&amp;obj_dumper);
1858 
1859   // HPROF_GC_ROOT_THREAD_OBJ + frames + jni locals
1860   do_threads();
1861 
1862   // HPROF_GC_ROOT_MONITOR_USED
1863   MonitorUsedDumper mon_dumper(writer());
1864   ObjectSynchronizer::oops_do(&amp;mon_dumper);
1865 
1866   // HPROF_GC_ROOT_JNI_GLOBAL
1867   JNIGlobalsDumper jni_dumper(writer());
1868   JNIHandles::oops_do(&amp;jni_dumper);
1869   Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
1870                                    // for things like preallocated throwable backtraces
1871 
1872   // HPROF_GC_ROOT_STICKY_CLASS
1873   // These should be classes in the NULL class loader data, and not all classes
1874   // if !ClassUnloading
1875   StickyClassDumper class_dumper(writer());
1876   ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
1877 
1878   // Writes the HPROF_HEAP_DUMP_END record.
1879   DumperSupport::end_of_dump(writer());
1880 
1881   // We are done with writing. Release the worker threads.
1882   writer()-&gt;deactivate();
1883 }
1884 
1885 void VM_HeapDumper::dump_stack_traces() {
1886   // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
1887   DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));
1888   writer()-&gt;write_u4((u4) STACK_TRACE_ID);
1889   writer()-&gt;write_u4(0);                    // thread number
1890   writer()-&gt;write_u4(0);                    // frame count
1891 
1892   _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);
1893   int frame_serial_num = 0;
1894   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
1895     oop threadObj = thread-&gt;threadObj();
1896     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1897       // dump thread stack trace
1898       ResourceMark rm;
1899       ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);
1900       stack_trace-&gt;dump_stack_at_safepoint(-1);
1901       _stack_traces[_num_threads++] = stack_trace;
1902 
1903       // write HPROF_FRAME records for this thread&#39;s stack trace
1904       int depth = stack_trace-&gt;get_stack_depth();
1905       int thread_frame_start = frame_serial_num;
1906       int extra_frames = 0;
1907       // write fake frame that makes it look like the thread, which caused OOME,
1908       // is in the OutOfMemoryError zero-parameter constructor
1909       if (thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1910         int oome_serial_num = _klass_map-&gt;find(_oome_constructor-&gt;method_holder());
1911         // the class serial number starts from 1
1912         assert(oome_serial_num &gt; 0, &quot;OutOfMemoryError class not found&quot;);
1913         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,
1914                                         _oome_constructor, 0);
1915         extra_frames++;
1916       }
1917       for (int j=0; j &lt; depth; j++) {
1918         StackFrameInfo* frame = stack_trace-&gt;stack_frame_at(j);
1919         Method* m = frame-&gt;method();
1920         int class_serial_num = _klass_map-&gt;find(m-&gt;method_holder());
1921         // the class serial number starts from 1
1922         assert(class_serial_num &gt; 0, &quot;class not found&quot;);
1923         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame-&gt;bci());
1924       }
1925       depth += extra_frames;
1926 
1927       // write HPROF_TRACE record for one thread
1928       DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4) + depth*oopSize);
1929       int stack_serial_num = _num_threads + STACK_TRACE_ID;
1930       writer()-&gt;write_u4(stack_serial_num);      // stack trace serial number
1931       writer()-&gt;write_u4((u4) _num_threads);     // thread serial number
1932       writer()-&gt;write_u4(depth);                 // frame count
1933       for (int j=1; j &lt;= depth; j++) {
1934         writer()-&gt;write_id(thread_frame_start + j);
1935       }
1936     }
1937   }
1938 }
1939 
1940 // dump the heap to given path.
1941 int HeapDumper::dump(const char* path, outputStream* out, int compression) {
1942   assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
1943 
1944   // print message in interactive case
1945   if (out != NULL) {
1946     out-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);
1947     timer()-&gt;start();
1948   }
1949 
1950   // create JFR event
1951   EventHeapDump event;
1952 
1953   AbstractCompressor* compressor = NULL;
1954 
1955   if (compression &gt; 0) {
1956     compressor = new (std::nothrow) GZipCompressor(compression);
1957 
1958     if (compressor == NULL) {
1959       set_error(&quot;Could not allocate gzip compressor&quot;);
1960       return -1;
1961     }
1962   }
1963 
1964   DumpWriter writer(new (std::nothrow) FileWriter(path), compressor);
1965 
1966   if (writer.error() != NULL) {
1967     set_error(writer.error());
1968     if (out != NULL) {
1969       out-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,
1970         (error() != NULL) ? error() : &quot;reason unknown&quot;);
1971     }
1972     return -1;
1973   }
1974 
1975   // generate the dump
1976   VM_HeapDumper dumper(&amp;writer, _gc_before_heap_dump, _oome);
1977   if (Thread::current()-&gt;is_VM_thread()) {
1978     assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected to be called at a safepoint&quot;);
1979     dumper.doit();
1980   } else {
1981     VMThread::execute(&amp;dumper);
1982   }
1983 
1984   // record any error that the writer may have encountered
1985   set_error(writer.error());
1986 
1987   // emit JFR event
1988   if (error() == NULL) {
1989     event.set_destination(path);
1990     event.set_gcBeforeDump(_gc_before_heap_dump);
1991     event.set_size(writer.bytes_written());
1992     event.set_onOutOfMemoryError(_oome);
1993     event.commit();
1994   }
1995 
1996   // print message in interactive case
1997   if (out != NULL) {
1998     timer()-&gt;stop();
1999     if (error() == NULL) {
2000       out-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,
2001                     writer.bytes_written(), timer()-&gt;seconds());
2002     } else {
2003       out-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());
2004     }
2005   }
2006 
2007   return (writer.error() == NULL) ? 0 : -1;
2008 }
2009 
2010 // stop timer (if still active), and free any error string we might be holding
2011 HeapDumper::~HeapDumper() {
2012   if (timer()-&gt;is_active()) {
2013     timer()-&gt;stop();
2014   }
2015   set_error(NULL);
2016 }
2017 
2018 
2019 // returns the error string (resource allocated), or NULL
2020 char* HeapDumper::error_as_C_string() const {
2021   if (error() != NULL) {
2022     char* str = NEW_RESOURCE_ARRAY(char, strlen(error())+1);
2023     strcpy(str, error());
2024     return str;
2025   } else {
2026     return NULL;
2027   }
2028 }
2029 
2030 // set the error string
2031 void HeapDumper::set_error(char const* error) {
2032   if (_error != NULL) {
2033     os::free(_error);
2034   }
2035   if (error == NULL) {
2036     _error = NULL;
2037   } else {
2038     _error = os::strdup(error);
2039     assert(_error != NULL, &quot;allocation failure&quot;);
2040   }
2041 }
2042 
2043 // Called by out-of-memory error reporting by a single Java thread
2044 // outside of a JVM safepoint
2045 void HeapDumper::dump_heap_from_oome() {
2046   HeapDumper::dump_heap(true);
2047 }
2048 
2049 // Called by error reporting by a single Java thread outside of a JVM safepoint,
2050 // or by heap dumping by the VM thread during a (GC) safepoint. Thus, these various
2051 // callers are strictly serialized and guaranteed not to interfere below. For more
2052 // general use, however, this method will need modification to prevent
2053 // inteference when updating the static variables base_path and dump_file_seq below.
2054 void HeapDumper::dump_heap() {
2055   HeapDumper::dump_heap(false);
2056 }
2057 
2058 void HeapDumper::dump_heap(bool oome) {
2059   static char base_path[JVM_MAXPATHLEN] = {&#39;\0&#39;};
2060   static uint dump_file_seq = 0;
2061   char* my_path;
2062   const int max_digit_chars = 20;
2063 
2064   const char* dump_file_name = &quot;java_pid&quot;;
2065   const char* dump_file_ext  = &quot;.hprof&quot;;
2066 
2067   // The dump file defaults to java_pid&lt;pid&gt;.hprof in the current working
2068   // directory. HeapDumpPath=&lt;file&gt; can be used to specify an alternative
2069   // dump file name or a directory where dump file is created.
2070   if (dump_file_seq == 0) { // first time in, we initialize base_path
2071     // Calculate potentially longest base path and check if we have enough
2072     // allocated statically.
2073     const size_t total_length =
2074                       (HeapDumpPath == NULL ? 0 : strlen(HeapDumpPath)) +
2075                       strlen(os::file_separator()) + max_digit_chars +
2076                       strlen(dump_file_name) + strlen(dump_file_ext) + 1;
2077     if (total_length &gt; sizeof(base_path)) {
2078       warning(&quot;Cannot create heap dump file.  HeapDumpPath is too long.&quot;);
2079       return;
2080     }
2081 
2082     bool use_default_filename = true;
2083     if (HeapDumpPath == NULL || HeapDumpPath[0] == &#39;\0&#39;) {
2084       // HeapDumpPath=&lt;file&gt; not specified
2085     } else {
2086       strcpy(base_path, HeapDumpPath);
2087       // check if the path is a directory (must exist)
2088       DIR* dir = os::opendir(base_path);
2089       if (dir == NULL) {
2090         use_default_filename = false;
2091       } else {
2092         // HeapDumpPath specified a directory. We append a file separator
2093         // (if needed).
2094         os::closedir(dir);
2095         size_t fs_len = strlen(os::file_separator());
2096         if (strlen(base_path) &gt;= fs_len) {
2097           char* end = base_path;
2098           end += (strlen(base_path) - fs_len);
2099           if (strcmp(end, os::file_separator()) != 0) {
2100             strcat(base_path, os::file_separator());
2101           }
2102         }
2103       }
2104     }
2105     // If HeapDumpPath wasn&#39;t a file name then we append the default name
2106     if (use_default_filename) {
2107       const size_t dlen = strlen(base_path);  // if heap dump dir specified
2108       jio_snprintf(&amp;base_path[dlen], sizeof(base_path)-dlen, &quot;%s%d%s&quot;,
2109                    dump_file_name, os::current_process_id(), dump_file_ext);
2110     }
2111     const size_t len = strlen(base_path) + 1;
2112     my_path = (char*)os::malloc(len, mtInternal);
2113     if (my_path == NULL) {
2114       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2115       return;
2116     }
2117     strncpy(my_path, base_path, len);
2118   } else {
2119     // Append a sequence number id for dumps following the first
2120     const size_t len = strlen(base_path) + max_digit_chars + 2; // for &#39;.&#39; and \0
2121     my_path = (char*)os::malloc(len, mtInternal);
2122     if (my_path == NULL) {
2123       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2124       return;
2125     }
2126     jio_snprintf(my_path, len, &quot;%s.%d&quot;, base_path, dump_file_seq);
2127   }
2128   dump_file_seq++;   // increment seq number for next time we dump
2129 
2130   HeapDumper dumper(false /* no GC before heap dump */,
2131                     oome  /* pass along out-of-memory-error flag */);
2132   dumper.dump(my_path, tty);
2133   os::free(my_path);
2134 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>