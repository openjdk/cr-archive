<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/threadService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;memory/allocation.hpp&quot;
  28 #include &quot;memory/heapInspection.hpp&quot;
  29 #include &quot;memory/oopFactory.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;memory/universe.hpp&quot;
  32 #include &quot;oops/instanceKlass.hpp&quot;
  33 #include &quot;oops/objArrayKlass.hpp&quot;
  34 #include &quot;oops/objArrayOop.inline.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
  37 #include &quot;runtime/atomic.hpp&quot;
  38 #include &quot;runtime/handles.inline.hpp&quot;
  39 #include &quot;runtime/init.hpp&quot;
  40 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  41 #include &quot;runtime/thread.inline.hpp&quot;
  42 #include &quot;runtime/threadSMR.inline.hpp&quot;
  43 #include &quot;runtime/vframe.hpp&quot;
  44 #include &quot;runtime/vmThread.hpp&quot;
  45 #include &quot;runtime/vmOperations.hpp&quot;
  46 #include &quot;services/threadService.hpp&quot;
  47 
  48 // TODO: we need to define a naming convention for perf counters
  49 // to distinguish counters for:
  50 //   - standard JSR174 use
  51 //   - Hotspot extension (public and committed)
  52 //   - Hotspot extension (private/internal and uncommitted)
  53 
  54 // Default is disabled.
  55 bool ThreadService::_thread_monitoring_contention_enabled = false;
  56 bool ThreadService::_thread_cpu_time_enabled = false;
  57 bool ThreadService::_thread_allocated_memory_enabled = false;
  58 
  59 PerfCounter*  ThreadService::_total_threads_count = NULL;
  60 PerfVariable* ThreadService::_live_threads_count = NULL;
  61 PerfVariable* ThreadService::_peak_threads_count = NULL;
  62 PerfVariable* ThreadService::_daemon_threads_count = NULL;
  63 volatile int ThreadService::_atomic_threads_count = 0;
  64 volatile int ThreadService::_atomic_daemon_threads_count = 0;
  65 
  66 ThreadDumpResult* ThreadService::_threaddump_list = NULL;
  67 
  68 static const int INITIAL_ARRAY_SIZE = 10;
  69 
  70 void ThreadService::init() {
  71   EXCEPTION_MARK;
  72 
  73   // These counters are for java.lang.management API support.
  74   // They are created even if -XX:-UsePerfData is set and in
  75   // that case, they will be allocated on C heap.
  76 
  77   _total_threads_count =
  78                 PerfDataManager::create_counter(JAVA_THREADS, &quot;started&quot;,
  79                                                 PerfData::U_Events, CHECK);
  80 
  81   _live_threads_count =
  82                 PerfDataManager::create_variable(JAVA_THREADS, &quot;live&quot;,
  83                                                  PerfData::U_None, CHECK);
  84 
  85   _peak_threads_count =
  86                 PerfDataManager::create_variable(JAVA_THREADS, &quot;livePeak&quot;,
  87                                                  PerfData::U_None, CHECK);
  88 
  89   _daemon_threads_count =
  90                 PerfDataManager::create_variable(JAVA_THREADS, &quot;daemon&quot;,
  91                                                  PerfData::U_None, CHECK);
  92 
  93   if (os::is_thread_cpu_time_supported()) {
  94     _thread_cpu_time_enabled = true;
  95   }
  96 
  97   _thread_allocated_memory_enabled = true; // Always on, so enable it
  98 }
  99 
 100 void ThreadService::reset_peak_thread_count() {
 101   // Acquire the lock to update the peak thread count
 102   // to synchronize with thread addition and removal.
 103   MutexLocker mu(Threads_lock);
 104   _peak_threads_count-&gt;set_value(get_live_thread_count());
 105 }
 106 
 107 static bool is_hidden_thread(JavaThread *thread) {
 108   // hide VM internal or JVMTI agent threads
 109   return thread-&gt;is_hidden_from_external_view() || thread-&gt;is_jvmti_agent_thread();
 110 }
 111 
 112 void ThreadService::add_thread(JavaThread* thread, bool daemon) {
 113   assert(Threads_lock-&gt;owned_by_self(), &quot;must have threads lock&quot;);
 114 
 115   // Do not count hidden threads
 116   if (is_hidden_thread(thread)) {
 117     return;
 118   }
 119 
 120   _total_threads_count-&gt;inc();
 121   _live_threads_count-&gt;inc();
 122   Atomic::inc(&amp;_atomic_threads_count);
 123   int count = _atomic_threads_count;
 124 
 125   if (count &gt; _peak_threads_count-&gt;get_value()) {
 126     _peak_threads_count-&gt;set_value(count);
 127   }
 128 
 129   if (daemon) {
 130     _daemon_threads_count-&gt;inc();
 131     Atomic::inc(&amp;_atomic_daemon_threads_count);
 132   }
 133 }
 134 
 135 void ThreadService::decrement_thread_counts(JavaThread* jt, bool daemon) {
 136   Atomic::dec(&amp;_atomic_threads_count);
 137 
 138   if (daemon) {
 139     Atomic::dec(&amp;_atomic_daemon_threads_count);
 140   }
 141 }
 142 
 143 void ThreadService::remove_thread(JavaThread* thread, bool daemon) {
 144   assert(Threads_lock-&gt;owned_by_self(), &quot;must have threads lock&quot;);
 145 
 146   // Do not count hidden threads
 147   if (is_hidden_thread(thread)) {
 148     return;
 149   }
 150 
 151   assert(!thread-&gt;is_terminated(), &quot;must not be terminated&quot;);
 152   if (!thread-&gt;is_exiting()) {
 153     // JavaThread::exit() skipped calling current_thread_exiting()
 154     decrement_thread_counts(thread, daemon);
 155   }
 156 
 157   int daemon_count = _atomic_daemon_threads_count;
 158   int count = _atomic_threads_count;
 159 
 160   // Counts are incremented at the same time, but atomic counts are
 161   // decremented earlier than perf counts.
 162   assert(_live_threads_count-&gt;get_value() &gt; count,
 163     &quot;thread count mismatch %d : %d&quot;,
 164     (int)_live_threads_count-&gt;get_value(), count);
 165 
 166   _live_threads_count-&gt;dec(1);
 167   if (daemon) {
 168     assert(_daemon_threads_count-&gt;get_value() &gt; daemon_count,
 169       &quot;thread count mismatch %d : %d&quot;,
 170       (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 171 
 172     _daemon_threads_count-&gt;dec(1);
 173   }
 174 
 175   // Counts are incremented at the same time, but atomic counts are
 176   // decremented earlier than perf counts.
 177   assert(_daemon_threads_count-&gt;get_value() &gt;= daemon_count,
 178     &quot;thread count mismatch %d : %d&quot;,
 179     (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 180   assert(_live_threads_count-&gt;get_value() &gt;= count,
 181     &quot;thread count mismatch %d : %d&quot;,
 182     (int)_live_threads_count-&gt;get_value(), count);
 183   assert(_live_threads_count-&gt;get_value() &gt; 0 ||
 184     (_live_threads_count-&gt;get_value() == 0 &amp;&amp; count == 0 &amp;&amp;
 185     _daemon_threads_count-&gt;get_value() == 0 &amp;&amp; daemon_count == 0),
 186     &quot;thread counts should reach 0 at the same time, live %d,%d daemon %d,%d&quot;,
 187     (int)_live_threads_count-&gt;get_value(), count,
 188     (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 189   assert(_daemon_threads_count-&gt;get_value() &gt; 0 ||
 190     (_daemon_threads_count-&gt;get_value() == 0 &amp;&amp; daemon_count == 0),
 191     &quot;thread counts should reach 0 at the same time, daemon %d,%d&quot;,
 192     (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 193 }
 194 
 195 void ThreadService::current_thread_exiting(JavaThread* jt, bool daemon) {
 196   // Do not count hidden threads
 197   if (is_hidden_thread(jt)) {
 198     return;
 199   }
 200 
 201   assert(jt == JavaThread::current(), &quot;Called by current thread&quot;);
 202   assert(!jt-&gt;is_terminated() &amp;&amp; jt-&gt;is_exiting(), &quot;must be exiting&quot;);
 203 
 204   decrement_thread_counts(jt, daemon);
 205 }
 206 
 207 // FIXME: JVMTI should call this function
 208 Handle ThreadService::get_current_contended_monitor(JavaThread* thread) {
 209   assert(thread != NULL, &quot;should be non-NULL&quot;);
 210   debug_only(Thread::check_for_dangling_thread_pointer(thread);)
 211 
 212   // This function can be called on a target JavaThread that is not
 213   // the caller and we are not at a safepoint. So it is possible for
 214   // the waiting or pending condition to be over/stale and for the
 215   // first stage of async deflation to clear the object field in
 216   // the ObjectMonitor. It is also possible for the object to be
 217   // inflated again and to be associated with a completely different
 218   // ObjectMonitor by the time this object reference is processed
 219   // by the caller.
 220   ObjectMonitor *wait_obj = thread-&gt;current_waiting_monitor();
 221 
 222   oop obj = NULL;
 223   if (wait_obj != NULL) {
 224     // thread is doing an Object.wait() call
 225     obj = (oop) wait_obj-&gt;object();
 226   } else {
 227     ObjectMonitor *enter_obj = thread-&gt;current_pending_monitor();
 228     if (enter_obj != NULL) {
 229       // thread is trying to enter() an ObjectMonitor.
 230       obj = (oop) enter_obj-&gt;object();
 231     }
 232   }
 233 
 234   Handle h(Thread::current(), obj);
 235   return h;
 236 }
 237 
 238 bool ThreadService::set_thread_monitoring_contention(bool flag) {
 239   MutexLocker m(Management_lock);
 240 
 241   bool prev = _thread_monitoring_contention_enabled;
 242   _thread_monitoring_contention_enabled = flag;
 243 
 244   return prev;
 245 }
 246 
 247 bool ThreadService::set_thread_cpu_time_enabled(bool flag) {
 248   MutexLocker m(Management_lock);
 249 
 250   bool prev = _thread_cpu_time_enabled;
 251   _thread_cpu_time_enabled = flag;
 252 
 253   return prev;
 254 }
 255 
 256 bool ThreadService::set_thread_allocated_memory_enabled(bool flag) {
 257   MutexLocker m(Management_lock);
 258 
 259   bool prev = _thread_allocated_memory_enabled;
 260   _thread_allocated_memory_enabled = flag;
 261 
 262   return prev;
 263 }
 264 
 265 void ThreadService::metadata_do(void f(Metadata*)) {
 266   for (ThreadDumpResult* dump = _threaddump_list; dump != NULL; dump = dump-&gt;next()) {
 267     dump-&gt;metadata_do(f);
 268   }
 269 }
 270 
 271 void ThreadService::add_thread_dump(ThreadDumpResult* dump) {
 272   MutexLocker ml(Management_lock);
 273   if (_threaddump_list == NULL) {
 274     _threaddump_list = dump;
 275   } else {
 276     dump-&gt;set_next(_threaddump_list);
 277     _threaddump_list = dump;
 278   }
 279 }
 280 
 281 void ThreadService::remove_thread_dump(ThreadDumpResult* dump) {
 282   MutexLocker ml(Management_lock);
 283 
 284   ThreadDumpResult* prev = NULL;
 285   bool found = false;
 286   for (ThreadDumpResult* d = _threaddump_list; d != NULL; prev = d, d = d-&gt;next()) {
 287     if (d == dump) {
 288       if (prev == NULL) {
 289         _threaddump_list = dump-&gt;next();
 290       } else {
 291         prev-&gt;set_next(dump-&gt;next());
 292       }
 293       found = true;
 294       break;
 295     }
 296   }
 297   assert(found, &quot;The threaddump result to be removed must exist.&quot;);
 298 }
 299 
 300 // Dump stack trace of threads specified in the given threads array.
 301 // Returns StackTraceElement[][] each element is the stack trace of a thread in
 302 // the corresponding entry in the given threads array
 303 Handle ThreadService::dump_stack_traces(GrowableArray&lt;instanceHandle&gt;* threads,
 304                                         int num_threads,
 305                                         TRAPS) {
 306   assert(num_threads &gt; 0, &quot;just checking&quot;);
 307 
 308   ThreadDumpResult dump_result;
 309   VM_ThreadDump op(&amp;dump_result,
 310                    threads,
 311                    num_threads,
 312                    -1,    /* entire stack */
 313                    false, /* with locked monitors */
 314                    false  /* with locked synchronizers */);
 315   VMThread::execute(&amp;op);
 316 
 317   // Allocate the resulting StackTraceElement[][] object
 318 
 319   ResourceMark rm(THREAD);
 320   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_StackTraceElement_array(), true, CHECK_NH);
 321   ObjArrayKlass* ik = ObjArrayKlass::cast(k);
 322   objArrayOop r = oopFactory::new_objArray(ik, num_threads, CHECK_NH);
 323   objArrayHandle result_obj(THREAD, r);
 324 
 325   int num_snapshots = dump_result.num_snapshots();
 326   assert(num_snapshots == num_threads, &quot;Must have num_threads thread snapshots&quot;);
 327   assert(num_snapshots == 0 || dump_result.t_list_has_been_set(), &quot;ThreadsList must have been set if we have a snapshot&quot;);
 328   int i = 0;
 329   for (ThreadSnapshot* ts = dump_result.snapshots(); ts != NULL; i++, ts = ts-&gt;next()) {
 330     ThreadStackTrace* stacktrace = ts-&gt;get_stack_trace();
 331     if (stacktrace == NULL) {
 332       // No stack trace
 333       result_obj-&gt;obj_at_put(i, NULL);
 334     } else {
 335       // Construct an array of java/lang/StackTraceElement object
 336       Handle backtrace_h = stacktrace-&gt;allocate_fill_stack_trace_element_array(CHECK_NH);
 337       result_obj-&gt;obj_at_put(i, backtrace_h());
 338     }
 339   }
 340 
 341   return result_obj;
 342 }
 343 
 344 void ThreadService::reset_contention_count_stat(JavaThread* thread) {
 345   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 346   if (stat != NULL) {
 347     stat-&gt;reset_count_stat();
 348   }
 349 }
 350 
 351 void ThreadService::reset_contention_time_stat(JavaThread* thread) {
 352   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 353   if (stat != NULL) {
 354     stat-&gt;reset_time_stat();
 355   }
 356 }
 357 
 358 // Find deadlocks involving raw monitors, object monitors and concurrent locks
 359 // if concurrent_locks is true.
 360 DeadlockCycle* ThreadService::find_deadlocks_at_safepoint(ThreadsList * t_list, bool concurrent_locks) {
 361   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
 362 
 363   // This code was modified from the original Threads::find_deadlocks code.
 364   int globalDfn = 0, thisDfn;
 365   ObjectMonitor* waitingToLockMonitor = NULL;
 366   JvmtiRawMonitor* waitingToLockRawMonitor = NULL;
 367   oop waitingToLockBlocker = NULL;
 368   bool blocked_on_monitor = false;
 369   JavaThread *currentThread, *previousThread;
 370   int num_deadlocks = 0;
 371 
 372   // Initialize the depth-first-number for each JavaThread.
 373   JavaThreadIterator jti(t_list);
 374   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 375     jt-&gt;set_depth_first_number(-1);
 376   }
 377 
 378   DeadlockCycle* deadlocks = NULL;
 379   DeadlockCycle* last = NULL;
 380   DeadlockCycle* cycle = new DeadlockCycle();
 381   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 382     if (jt-&gt;depth_first_number() &gt;= 0) {
 383       // this thread was already visited
 384       continue;
 385     }
 386 
 387     thisDfn = globalDfn;
 388     jt-&gt;set_depth_first_number(globalDfn++);
 389     previousThread = jt;
 390     currentThread = jt;
 391 
 392     cycle-&gt;reset();
 393 
 394     // The ObjectMonitor* can&#39;t be async deflated since we are at a safepoint.
 395     // When there is a deadlock, all the monitors involved in the dependency
 396     // cycle must be contended and heavyweight. So we only care about the
 397     // heavyweight monitor a thread is waiting to lock.
 398     waitingToLockMonitor = jt-&gt;current_pending_monitor();
 399     // JVM TI raw monitors can also be involved in deadlocks, and we can be
 400     // waiting to lock both a raw monitor and ObjectMonitor at the same time.
 401     // It isn&#39;t clear how to make deadlock detection work correctly if that
 402     // happens.
 403     waitingToLockRawMonitor = jt-&gt;current_pending_raw_monitor();
 404 
 405     if (concurrent_locks) {
 406       waitingToLockBlocker = jt-&gt;current_park_blocker();
 407     }
 408 
 409     while (waitingToLockMonitor != NULL ||
 410            waitingToLockRawMonitor != NULL ||
 411            waitingToLockBlocker != NULL) {
 412       cycle-&gt;add_thread(currentThread);
 413       // Give preference to the raw monitor
 414       if (waitingToLockRawMonitor != NULL) {
 415         Thread* owner = waitingToLockRawMonitor-&gt;owner();
 416         if (owner != NULL &amp;&amp; // the raw monitor could be released at any time
 417             owner-&gt;is_Java_thread()) {
 418           // only JavaThreads can be reported here
 419           currentThread = (JavaThread*) owner;
 420         }
 421       } else if (waitingToLockMonitor != NULL) {
 422         address currentOwner = (address)waitingToLockMonitor-&gt;owner();
 423         if (currentOwner != NULL) {
 424           currentThread = Threads::owning_thread_from_monitor_owner(t_list,
 425                                                                     currentOwner);
 426           if (currentThread == NULL) {
 427             // This function is called at a safepoint so the JavaThread
 428             // that owns waitingToLockMonitor should be findable, but
 429             // if it is not findable, then the previous currentThread is
 430             // blocked permanently. We record this as a deadlock.
 431             num_deadlocks++;
 432 
 433             cycle-&gt;set_deadlock(true);
 434 
 435             // add this cycle to the deadlocks list
 436             if (deadlocks == NULL) {
 437               deadlocks = cycle;
 438             } else {
 439               last-&gt;set_next(cycle);
 440             }
 441             last = cycle;
 442             cycle = new DeadlockCycle();
 443             break;
 444           }
 445         }
 446       } else {
 447         if (concurrent_locks) {
 448           if (waitingToLockBlocker-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {
 449             oop threadObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(waitingToLockBlocker);
 450             // This JavaThread (if there is one) is protected by the
 451             // ThreadsListSetter in VM_FindDeadlocks::doit().
 452             currentThread = threadObj != NULL ? java_lang_Thread::thread(threadObj) : NULL;
 453           } else {
 454             currentThread = NULL;
 455           }
 456         }
 457       }
 458 
 459       if (currentThread == NULL) {
 460         // No dependency on another thread
 461         break;
 462       }
 463       if (currentThread-&gt;depth_first_number() &lt; 0) {
 464         // First visit to this thread
 465         currentThread-&gt;set_depth_first_number(globalDfn++);
 466       } else if (currentThread-&gt;depth_first_number() &lt; thisDfn) {
 467         // Thread already visited, and not on a (new) cycle
 468         break;
 469       } else if (currentThread == previousThread) {
 470         // Self-loop, ignore
 471         break;
 472       } else {
 473         // We have a (new) cycle
 474         num_deadlocks++;
 475 
 476         cycle-&gt;set_deadlock(true);
 477 
 478         // add this cycle to the deadlocks list
 479         if (deadlocks == NULL) {
 480           deadlocks = cycle;
 481         } else {
 482           last-&gt;set_next(cycle);
 483         }
 484         last = cycle;
 485         cycle = new DeadlockCycle();
 486         break;
 487       }
 488       previousThread = currentThread;
 489       waitingToLockMonitor = (ObjectMonitor*)currentThread-&gt;current_pending_monitor();
 490       if (concurrent_locks) {
 491         waitingToLockBlocker = currentThread-&gt;current_park_blocker();
 492       }
 493     }
 494 
 495   }
 496   delete cycle;
 497   return deadlocks;
 498 }
 499 
 500 ThreadDumpResult::ThreadDumpResult() : _num_threads(0), _num_snapshots(0), _snapshots(NULL), _last(NULL), _next(NULL), _setter() {
 501 
 502   // Create a new ThreadDumpResult object and append to the list.
 503   // If GC happens before this function returns, Method*
 504   // in the stack trace will be visited.
 505   ThreadService::add_thread_dump(this);
 506 }
 507 
 508 ThreadDumpResult::ThreadDumpResult(int num_threads) : _num_threads(num_threads), _num_snapshots(0), _snapshots(NULL), _last(NULL), _next(NULL), _setter() {
 509   // Create a new ThreadDumpResult object and append to the list.
 510   // If GC happens before this function returns, oops
 511   // will be visited.
 512   ThreadService::add_thread_dump(this);
 513 }
 514 
 515 ThreadDumpResult::~ThreadDumpResult() {
 516   ThreadService::remove_thread_dump(this);
 517 
 518   // free all the ThreadSnapshot objects created during
 519   // the VM_ThreadDump operation
 520   ThreadSnapshot* ts = _snapshots;
 521   while (ts != NULL) {
 522     ThreadSnapshot* p = ts;
 523     ts = ts-&gt;next();
 524     delete p;
 525   }
 526 }
 527 
 528 ThreadSnapshot* ThreadDumpResult::add_thread_snapshot() {
 529   ThreadSnapshot* ts = new ThreadSnapshot();
 530   link_thread_snapshot(ts);
 531   return ts;
 532 }
 533 
 534 ThreadSnapshot* ThreadDumpResult::add_thread_snapshot(JavaThread* thread) {
 535   ThreadSnapshot* ts = new ThreadSnapshot();
 536   link_thread_snapshot(ts);
 537   ts-&gt;initialize(t_list(), thread);
 538   return ts;
 539 }
 540 
 541 void ThreadDumpResult::link_thread_snapshot(ThreadSnapshot* ts) {
 542   assert(_num_threads == 0 || _num_snapshots &lt; _num_threads,
 543          &quot;_num_snapshots must be less than _num_threads&quot;);
 544   _num_snapshots++;
 545   if (_snapshots == NULL) {
 546     _snapshots = ts;
 547   } else {
 548     _last-&gt;set_next(ts);
 549   }
 550   _last = ts;
 551 }
 552 
 553 void ThreadDumpResult::metadata_do(void f(Metadata*)) {
 554   for (ThreadSnapshot* ts = _snapshots; ts != NULL; ts = ts-&gt;next()) {
 555     ts-&gt;metadata_do(f);
 556   }
 557 }
 558 
 559 ThreadsList* ThreadDumpResult::t_list() {
 560   return _setter.list();
 561 }
 562 
 563 StackFrameInfo::StackFrameInfo(javaVFrame* jvf, bool with_lock_info) {
 564   _method = jvf-&gt;method();
 565   _bci = jvf-&gt;bci();
 566   _class_holder = OopHandle(Universe::vm_global(), _method-&gt;method_holder()-&gt;klass_holder());
 567   _locked_monitors = NULL;
 568   if (with_lock_info) {
<a name="1" id="anc1"></a><span class="line-modified"> 569     ResourceMark rm;</span>
<span class="line-modified"> 570     HandleMark hm;</span>

 571     GrowableArray&lt;MonitorInfo*&gt;* list = jvf-&gt;locked_monitors();
 572     int length = list-&gt;length();
 573     if (length &gt; 0) {
 574       _locked_monitors = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;OopHandle&gt;(length, mtServiceability);
 575       for (int i = 0; i &lt; length; i++) {
 576         MonitorInfo* monitor = list-&gt;at(i);
 577         assert(monitor-&gt;owner() != NULL, &quot;This monitor must have an owning object&quot;);
 578         _locked_monitors-&gt;append(OopHandle(Universe::vm_global(), monitor-&gt;owner()));
 579       }
 580     }
 581   }
 582 }
 583 
 584 StackFrameInfo::~StackFrameInfo() {
 585   if (_locked_monitors != NULL) {
 586     for (int i = 0; i &lt; _locked_monitors-&gt;length(); i++) {
 587       _locked_monitors-&gt;at(i).release(Universe::vm_global());
 588     }
 589     delete _locked_monitors;
 590   }
 591   _class_holder.release(Universe::vm_global());
 592 }
 593 
 594 void StackFrameInfo::metadata_do(void f(Metadata*)) {
 595   f(_method);
 596 }
 597 
 598 void StackFrameInfo::print_on(outputStream* st) const {
 599   ResourceMark rm;
 600   java_lang_Throwable::print_stack_element(st, method(), bci());
 601   int len = (_locked_monitors != NULL ? _locked_monitors-&gt;length() : 0);
 602   for (int i = 0; i &lt; len; i++) {
 603     oop o = _locked_monitors-&gt;at(i).resolve();
 604     st-&gt;print_cr(&quot;\t- locked &lt;&quot; INTPTR_FORMAT &quot;&gt; (a %s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());
 605   }
 606 
 607 }
 608 
 609 // Iterate through monitor cache to find JNI locked monitors
 610 class InflatedMonitorsClosure: public MonitorClosure {
 611 private:
 612   ThreadStackTrace* _stack_trace;
 613   Thread* _thread;
 614 public:
 615   InflatedMonitorsClosure(Thread* t, ThreadStackTrace* st) {
 616     _thread = t;
 617     _stack_trace = st;
 618   }
 619   void do_monitor(ObjectMonitor* mid) {
 620     if (mid-&gt;owner() == _thread) {
 621       oop object = (oop) mid-&gt;object();
 622       if (!_stack_trace-&gt;is_owned_monitor_on_stack(object)) {
 623         _stack_trace-&gt;add_jni_locked_monitor(object);
 624       }
 625     }
 626   }
 627 };
 628 
 629 ThreadStackTrace::ThreadStackTrace(JavaThread* t, bool with_locked_monitors) {
 630   _thread = t;
 631   _frames = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;StackFrameInfo*&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 632   _depth = 0;
 633   _with_locked_monitors = with_locked_monitors;
 634   if (_with_locked_monitors) {
 635     _jni_locked_monitors = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;OopHandle&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 636   } else {
 637     _jni_locked_monitors = NULL;
 638   }
 639 }
 640 
 641 void ThreadStackTrace::add_jni_locked_monitor(oop object) {
 642   _jni_locked_monitors-&gt;append(OopHandle(Universe::vm_global(), object));
 643 }
 644 
 645 ThreadStackTrace::~ThreadStackTrace() {
 646   for (int i = 0; i &lt; _frames-&gt;length(); i++) {
 647     delete _frames-&gt;at(i);
 648   }
 649   delete _frames;
 650   if (_jni_locked_monitors != NULL) {
 651     for (int i = 0; i &lt; _jni_locked_monitors-&gt;length(); i++) {
 652       _jni_locked_monitors-&gt;at(i).release(Universe::vm_global());
 653     }
 654     delete _jni_locked_monitors;
 655   }
 656 }
 657 
 658 void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth) {
 659   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 660 
 661   if (_thread-&gt;has_last_Java_frame()) {
 662     RegisterMap reg_map(_thread);
 663     vframe* start_vf = _thread-&gt;last_java_vframe(&amp;reg_map);
 664     int count = 0;
 665     for (vframe* f = start_vf; f; f = f-&gt;sender() ) {
 666       if (maxDepth &gt;= 0 &amp;&amp; count == maxDepth) {
 667         // Skip frames if more than maxDepth
 668         break;
 669       }
 670       if (f-&gt;is_java_frame()) {
 671         javaVFrame* jvf = javaVFrame::cast(f);
 672         add_stack_frame(jvf);
 673         count++;
 674       } else {
 675         // Ignore non-Java frames
 676       }
 677     }
 678   }
 679 
 680   if (_with_locked_monitors) {
 681     // Iterate inflated monitors and find monitors locked by this thread
 682     // not found in the stack
 683     InflatedMonitorsClosure imc(_thread, this);
 684     ObjectSynchronizer::monitors_iterate(&amp;imc);
 685   }
 686 }
 687 
 688 
 689 bool ThreadStackTrace::is_owned_monitor_on_stack(oop object) {
 690   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 691 
 692   bool found = false;
 693   int num_frames = get_stack_depth();
 694   for (int depth = 0; depth &lt; num_frames; depth++) {
 695     StackFrameInfo* frame = stack_frame_at(depth);
 696     int len = frame-&gt;num_locked_monitors();
 697     GrowableArray&lt;OopHandle&gt;* locked_monitors = frame-&gt;locked_monitors();
 698     for (int j = 0; j &lt; len; j++) {
 699       oop monitor = locked_monitors-&gt;at(j).resolve();
 700       assert(monitor != NULL, &quot;must be a Java object&quot;);
 701       if (monitor == object) {
 702         found = true;
 703         break;
 704       }
 705     }
 706   }
 707   return found;
 708 }
 709 
 710 Handle ThreadStackTrace::allocate_fill_stack_trace_element_array(TRAPS) {
 711   InstanceKlass* ik = SystemDictionary::StackTraceElement_klass();
 712   assert(ik != NULL, &quot;must be loaded in 1.4+&quot;);
 713 
 714   // Allocate an array of java/lang/StackTraceElement object
 715   objArrayOop ste = oopFactory::new_objArray(ik, _depth, CHECK_NH);
 716   objArrayHandle backtrace(THREAD, ste);
 717   for (int j = 0; j &lt; _depth; j++) {
 718     StackFrameInfo* frame = _frames-&gt;at(j);
 719     methodHandle mh(THREAD, frame-&gt;method());
 720     oop element = java_lang_StackTraceElement::create(mh, frame-&gt;bci(), CHECK_NH);
 721     backtrace-&gt;obj_at_put(j, element);
 722   }
 723   return backtrace;
 724 }
 725 
 726 void ThreadStackTrace::add_stack_frame(javaVFrame* jvf) {
 727   StackFrameInfo* frame = new StackFrameInfo(jvf, _with_locked_monitors);
 728   _frames-&gt;append(frame);
 729   _depth++;
 730 }
 731 
 732 void ThreadStackTrace::metadata_do(void f(Metadata*)) {
 733   int length = _frames-&gt;length();
 734   for (int i = 0; i &lt; length; i++) {
 735     _frames-&gt;at(i)-&gt;metadata_do(f);
 736   }
 737 }
 738 
 739 
 740 ConcurrentLocksDump::~ConcurrentLocksDump() {
 741   if (_retain_map_on_free) {
 742     return;
 743   }
 744 
 745   for (ThreadConcurrentLocks* t = _map; t != NULL;)  {
 746     ThreadConcurrentLocks* tcl = t;
 747     t = t-&gt;next();
 748     delete tcl;
 749   }
 750 }
 751 
 752 void ConcurrentLocksDump::dump_at_safepoint() {
 753   // dump all locked concurrent locks
 754   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 755 
 756   GrowableArray&lt;oop&gt;* aos_objects = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;oop&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 757 
 758   // Find all instances of AbstractOwnableSynchronizer
 759   HeapInspection::find_instances_at_safepoint(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass(),
 760                                               aos_objects);
 761   // Build a map of thread to its owned AQS locks
 762   build_map(aos_objects);
 763 
 764   delete aos_objects;
 765 }
 766 
 767 
 768 // build a map of JavaThread to all its owned AbstractOwnableSynchronizer
 769 void ConcurrentLocksDump::build_map(GrowableArray&lt;oop&gt;* aos_objects) {
 770   int length = aos_objects-&gt;length();
 771   for (int i = 0; i &lt; length; i++) {
 772     oop o = aos_objects-&gt;at(i);
 773     oop owner_thread_obj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(o);
 774     if (owner_thread_obj != NULL) {
 775       // See comments in ThreadConcurrentLocks to see how this
 776       // JavaThread* is protected.
 777       JavaThread* thread = java_lang_Thread::thread(owner_thread_obj);
 778       assert(o-&gt;is_instance(), &quot;Must be an instanceOop&quot;);
 779       add_lock(thread, (instanceOop) o);
 780     }
 781   }
 782 }
 783 
 784 void ConcurrentLocksDump::add_lock(JavaThread* thread, instanceOop o) {
 785   ThreadConcurrentLocks* tcl = thread_concurrent_locks(thread);
 786   if (tcl != NULL) {
 787     tcl-&gt;add_lock(o);
 788     return;
 789   }
 790 
 791   // First owned lock found for this thread
 792   tcl = new ThreadConcurrentLocks(thread);
 793   tcl-&gt;add_lock(o);
 794   if (_map == NULL) {
 795     _map = tcl;
 796   } else {
 797     _last-&gt;set_next(tcl);
 798   }
 799   _last = tcl;
 800 }
 801 
 802 ThreadConcurrentLocks* ConcurrentLocksDump::thread_concurrent_locks(JavaThread* thread) {
 803   for (ThreadConcurrentLocks* tcl = _map; tcl != NULL; tcl = tcl-&gt;next()) {
 804     if (tcl-&gt;java_thread() == thread) {
 805       return tcl;
 806     }
 807   }
 808   return NULL;
 809 }
 810 
 811 void ConcurrentLocksDump::print_locks_on(JavaThread* t, outputStream* st) {
 812   st-&gt;print_cr(&quot;   Locked ownable synchronizers:&quot;);
 813   ThreadConcurrentLocks* tcl = thread_concurrent_locks(t);
 814   GrowableArray&lt;OopHandle&gt;* locks = (tcl != NULL ? tcl-&gt;owned_locks() : NULL);
 815   if (locks == NULL || locks-&gt;is_empty()) {
 816     st-&gt;print_cr(&quot;\t- None&quot;);
 817     st-&gt;cr();
 818     return;
 819   }
 820 
 821   for (int i = 0; i &lt; locks-&gt;length(); i++) {
 822     oop obj = locks-&gt;at(i).resolve();
 823     st-&gt;print_cr(&quot;\t- &lt;&quot; INTPTR_FORMAT &quot;&gt; (a %s)&quot;, p2i(obj), obj-&gt;klass()-&gt;external_name());
 824   }
 825   st-&gt;cr();
 826 }
 827 
 828 ThreadConcurrentLocks::ThreadConcurrentLocks(JavaThread* thread) {
 829   _thread = thread;
 830   _owned_locks = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;OopHandle&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 831   _next = NULL;
 832 }
 833 
 834 ThreadConcurrentLocks::~ThreadConcurrentLocks() {
 835   for (int i = 0; i &lt; _owned_locks-&gt;length(); i++) {
 836     _owned_locks-&gt;at(i).release(Universe::vm_global());
 837   }
 838   delete _owned_locks;
 839 }
 840 
 841 void ThreadConcurrentLocks::add_lock(instanceOop o) {
 842   _owned_locks-&gt;append(OopHandle(Universe::vm_global(), o));
 843 }
 844 
 845 ThreadStatistics::ThreadStatistics() {
 846   _contended_enter_count = 0;
 847   _monitor_wait_count = 0;
 848   _sleep_count = 0;
 849   _count_pending_reset = false;
 850   _timer_pending_reset = false;
 851   memset((void*) _perf_recursion_counts, 0, sizeof(_perf_recursion_counts));
 852 }
 853 
 854 oop ThreadSnapshot::threadObj() const { return _threadObj.resolve(); }
 855 
 856 void ThreadSnapshot::initialize(ThreadsList * t_list, JavaThread* thread) {
 857   _thread = thread;
 858   oop threadObj = thread-&gt;threadObj();
 859   _threadObj = OopHandle(Universe::vm_global(), threadObj);
 860 
 861   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 862   _contended_enter_ticks = stat-&gt;contended_enter_ticks();
 863   _contended_enter_count = stat-&gt;contended_enter_count();
 864   _monitor_wait_ticks = stat-&gt;monitor_wait_ticks();
 865   _monitor_wait_count = stat-&gt;monitor_wait_count();
 866   _sleep_ticks = stat-&gt;sleep_ticks();
 867   _sleep_count = stat-&gt;sleep_count();
 868 
 869   _thread_status = java_lang_Thread::get_thread_status(threadObj);
 870   _is_ext_suspended = thread-&gt;is_being_ext_suspended();
 871   _is_in_native = (thread-&gt;thread_state() == _thread_in_native);
 872 
 873   oop blocker_object = NULL;
 874   oop blocker_object_owner = NULL;
 875 
 876   if (_thread_status == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER ||
 877       _thread_status == java_lang_Thread::IN_OBJECT_WAIT ||
 878       _thread_status == java_lang_Thread::IN_OBJECT_WAIT_TIMED) {
 879 
 880     Handle obj = ThreadService::get_current_contended_monitor(thread);
 881     if (obj() == NULL) {
 882       // monitor no longer exists; thread is not blocked
 883       _thread_status = java_lang_Thread::RUNNABLE;
 884     } else {
 885       blocker_object = obj();
 886       JavaThread* owner = ObjectSynchronizer::get_lock_owner(t_list, obj);
 887       if ((owner == NULL &amp;&amp; _thread_status == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER)
 888           || (owner != NULL &amp;&amp; owner-&gt;is_attaching_via_jni())) {
 889         // ownership information of the monitor is not available
 890         // (may no longer be owned or releasing to some other thread)
 891         // make this thread in RUNNABLE state.
 892         // And when the owner thread is in attaching state, the java thread
 893         // is not completely initialized. For example thread name and id
 894         // and may not be set, so hide the attaching thread.
 895         _thread_status = java_lang_Thread::RUNNABLE;
 896         blocker_object = NULL;
 897       } else if (owner != NULL) {
 898         blocker_object_owner = owner-&gt;threadObj();
 899       }
 900     }
 901   }
 902 
 903   // Support for JSR-166 locks
 904   if (_thread_status == java_lang_Thread::PARKED || _thread_status == java_lang_Thread::PARKED_TIMED) {
 905     blocker_object = thread-&gt;current_park_blocker();
 906     if (blocker_object != NULL &amp;&amp; blocker_object-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {
 907       blocker_object_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(blocker_object);
 908     }
 909   }
 910 
 911   if (blocker_object != NULL) {
 912     _blocker_object = OopHandle(Universe::vm_global(), blocker_object);
 913   }
 914   if (blocker_object_owner != NULL) {
 915     _blocker_object_owner = OopHandle(Universe::vm_global(), blocker_object_owner);
 916   }
 917 }
 918 
 919 oop ThreadSnapshot::blocker_object() const           { return _blocker_object.resolve(); }
 920 oop ThreadSnapshot::blocker_object_owner() const     { return _blocker_object_owner.resolve(); }
 921 
 922 ThreadSnapshot::~ThreadSnapshot() {
 923   _blocker_object.release(Universe::vm_global());
 924   _blocker_object_owner.release(Universe::vm_global());
 925   _threadObj.release(Universe::vm_global());
 926 
 927   delete _stack_trace;
 928   delete _concurrent_locks;
 929 }
 930 
 931 void ThreadSnapshot::dump_stack_at_safepoint(int max_depth, bool with_locked_monitors) {
 932   _stack_trace = new ThreadStackTrace(_thread, with_locked_monitors);
 933   _stack_trace-&gt;dump_stack_at_safepoint(max_depth);
 934 }
 935 
 936 
 937 void ThreadSnapshot::metadata_do(void f(Metadata*)) {
 938   if (_stack_trace != NULL) {
 939     _stack_trace-&gt;metadata_do(f);
 940   }
 941 }
 942 
 943 
 944 DeadlockCycle::DeadlockCycle() {
 945   _is_deadlock = false;
 946   _threads = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;JavaThread*&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 947   _next = NULL;
 948 }
 949 
 950 DeadlockCycle::~DeadlockCycle() {
 951   delete _threads;
 952 }
 953 
 954 void DeadlockCycle::print_on_with(ThreadsList * t_list, outputStream* st) const {
 955   st-&gt;cr();
 956   st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
 957   st-&gt;print(&quot;=============================&quot;);
 958 
 959   JavaThread* currentThread;
 960   JvmtiRawMonitor* waitingToLockRawMonitor;
 961   oop waitingToLockBlocker;
 962   int len = _threads-&gt;length();
 963   for (int i = 0; i &lt; len; i++) {
 964     currentThread = _threads-&gt;at(i);
 965     // The ObjectMonitor* can&#39;t be async deflated since we are at a safepoint.
 966     ObjectMonitor* waitingToLockMonitor = currentThread-&gt;current_pending_monitor();
 967     waitingToLockRawMonitor = currentThread-&gt;current_pending_raw_monitor();
 968     waitingToLockBlocker = currentThread-&gt;current_park_blocker();
 969     st-&gt;cr();
 970     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
 971     const char* owner_desc = &quot;,\n  which is held by&quot;;
 972 
 973     // Note: As the JVM TI &quot;monitor contended enter&quot; event callback is executed after ObjectMonitor
 974     // sets the current pending monitor, it is possible to then see a pending raw monitor as well.
 975     if (waitingToLockRawMonitor != NULL) {
 976       st-&gt;print(&quot;  waiting to lock JVM TI raw monitor &quot; INTPTR_FORMAT, p2i(waitingToLockRawMonitor));
 977       Thread* owner = waitingToLockRawMonitor-&gt;owner();
 978       // Could be NULL as the raw monitor could be released at any time if held by non-JavaThread
 979       if (owner != NULL) {
 980         if (owner-&gt;is_Java_thread()) {
 981           currentThread = (JavaThread*) owner;
 982           st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());
 983         } else {
 984           st-&gt;print_cr(&quot;,\n  which has now been released&quot;);
 985         }
 986       } else {
 987         st-&gt;print_cr(&quot;%s non-Java thread=&quot; PTR_FORMAT, owner_desc, p2i(owner));
 988       }
 989     }
 990 
 991     if (waitingToLockMonitor != NULL) {
 992       st-&gt;print(&quot;  waiting to lock monitor &quot; INTPTR_FORMAT, p2i(waitingToLockMonitor));
 993       oop obj = (oop)waitingToLockMonitor-&gt;object();
 994       st-&gt;print(&quot; (object &quot; INTPTR_FORMAT &quot;, a %s)&quot;, p2i(obj),
 995                  obj-&gt;klass()-&gt;external_name());
 996 
 997       if (!currentThread-&gt;current_pending_monitor_is_from_java()) {
 998         owner_desc = &quot;\n  in JNI, which is held by&quot;;
 999       }
1000       currentThread = Threads::owning_thread_from_monitor_owner(t_list,
1001                                                                 (address)waitingToLockMonitor-&gt;owner());
1002       if (currentThread == NULL) {
1003         // The deadlock was detected at a safepoint so the JavaThread
1004         // that owns waitingToLockMonitor should be findable, but
1005         // if it is not findable, then the previous currentThread is
1006         // blocked permanently.
1007         st-&gt;print_cr(&quot;%s UNKNOWN_owner_addr=&quot; PTR_FORMAT, owner_desc,
1008                   p2i(waitingToLockMonitor-&gt;owner()));
1009         continue;
1010       }
1011     } else {
1012       st-&gt;print(&quot;  waiting for ownable synchronizer &quot; INTPTR_FORMAT &quot;, (a %s)&quot;,
1013                 p2i(waitingToLockBlocker),
1014                 waitingToLockBlocker-&gt;klass()-&gt;external_name());
1015       assert(waitingToLockBlocker-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass()),
1016              &quot;Must be an AbstractOwnableSynchronizer&quot;);
1017       oop ownerObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(waitingToLockBlocker);
1018       currentThread = java_lang_Thread::thread(ownerObj);
1019       assert(currentThread != NULL, &quot;AbstractOwnableSynchronizer owning thread is unexpectedly NULL&quot;);
1020     }
1021     st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());
1022   }
1023 
1024   st-&gt;cr();
1025 
1026   // Print stack traces
1027   bool oldJavaMonitorsInStackTrace = JavaMonitorsInStackTrace;
1028   JavaMonitorsInStackTrace = true;
1029   st-&gt;print_cr(&quot;Java stack information for the threads listed above:&quot;);
1030   st-&gt;print_cr(&quot;===================================================&quot;);
1031   for (int j = 0; j &lt; len; j++) {
1032     currentThread = _threads-&gt;at(j);
1033     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
1034     currentThread-&gt;print_stack_on(st);
1035   }
1036   JavaMonitorsInStackTrace = oldJavaMonitorsInStackTrace;
1037 }
1038 
1039 ThreadsListEnumerator::ThreadsListEnumerator(Thread* cur_thread,
1040                                              bool include_jvmti_agent_threads,
1041                                              bool include_jni_attaching_threads) {
1042   assert(cur_thread == Thread::current(), &quot;Check current thread&quot;);
1043 
1044   int init_size = ThreadService::get_live_thread_count();
1045   _threads_array = new GrowableArray&lt;instanceHandle&gt;(init_size);
1046 
1047   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
1048     // skips JavaThreads in the process of exiting
1049     // and also skips VM internal JavaThreads
1050     // Threads in _thread_new or _thread_new_trans state are included.
1051     // i.e. threads have been started but not yet running.
1052     if (jt-&gt;threadObj() == NULL   ||
1053         jt-&gt;is_exiting() ||
1054         !java_lang_Thread::is_alive(jt-&gt;threadObj())   ||
1055         jt-&gt;is_hidden_from_external_view()) {
1056       continue;
1057     }
1058 
1059     // skip agent threads
1060     if (!include_jvmti_agent_threads &amp;&amp; jt-&gt;is_jvmti_agent_thread()) {
1061       continue;
1062     }
1063 
1064     // skip jni threads in the process of attaching
1065     if (!include_jni_attaching_threads &amp;&amp; jt-&gt;is_attaching_via_jni()) {
1066       continue;
1067     }
1068 
1069     instanceHandle h(cur_thread, (instanceOop) jt-&gt;threadObj());
1070     _threads_array-&gt;append(h);
1071   }
1072 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>