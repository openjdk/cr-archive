<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/heapDumper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;gc/shared/gcLocker.hpp&quot;
  34 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  35 #include &quot;gc/shared/workgroup.hpp&quot;
  36 #include &quot;jfr/jfrEvents.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;runtime/frame.inline.hpp&quot;
  45 #include &quot;runtime/handles.inline.hpp&quot;
  46 #include &quot;runtime/javaCalls.hpp&quot;
  47 #include &quot;runtime/jniHandles.hpp&quot;
  48 #include &quot;runtime/os.inline.hpp&quot;
  49 #include &quot;runtime/reflectionUtils.hpp&quot;
  50 #include &quot;runtime/thread.inline.hpp&quot;
  51 #include &quot;runtime/threadSMR.hpp&quot;
  52 #include &quot;runtime/vframe.hpp&quot;
  53 #include &quot;runtime/vmThread.hpp&quot;
  54 #include &quot;runtime/vmOperations.hpp&quot;
  55 #include &quot;services/heapDumper.hpp&quot;
  56 #include &quot;services/heapDumperCompression.hpp&quot;
  57 #include &quot;services/threadService.hpp&quot;
  58 #include &quot;utilities/macros.hpp&quot;
  59 #include &quot;utilities/ostream.hpp&quot;
  60 
  61 /*
  62  * HPROF binary format - description copied from:
  63  *   src/share/demo/jvmti/hprof/hprof_io.c
  64  *
  65  *
  66  *  header    &quot;JAVA PROFILE 1.0.2&quot; (0-terminated)
  67  *
  68  *  u4        size of identifiers. Identifiers are used to represent
  69  *            UTF8 strings, objects, stack traces, etc. They usually
  70  *            have the same size as host pointers. For example, on
  71  *            Solaris and Win32, the size is 4.
  72  * u4         high word
  73  * u4         low word    number of milliseconds since 0:00 GMT, 1/1/70
  74  * [record]*  a sequence of records.
  75  *
  76  *
  77  * Record format:
  78  *
  79  * u1         a TAG denoting the type of the record
  80  * u4         number of *microseconds* since the time stamp in the
  81  *            header. (wraps around in a little more than an hour)
  82  * u4         number of bytes *remaining* in the record. Note that
  83  *            this number excludes the tag and the length field itself.
  84  * [u1]*      BODY of the record (a sequence of bytes)
  85  *
  86  *
  87  * The following TAGs are supported:
  88  *
  89  * TAG           BODY       notes
  90  *----------------------------------------------------------
  91  * HPROF_UTF8               a UTF8-encoded name
  92  *
  93  *               id         name ID
  94  *               [u1]*      UTF8 characters (no trailing zero)
  95  *
  96  * HPROF_LOAD_CLASS         a newly loaded class
  97  *
  98  *                u4        class serial number (&gt; 0)
  99  *                id        class object ID
 100  *                u4        stack trace serial number
 101  *                id        class name ID
 102  *
 103  * HPROF_UNLOAD_CLASS       an unloading class
 104  *
 105  *                u4        class serial_number
 106  *
 107  * HPROF_FRAME              a Java stack frame
 108  *
 109  *                id        stack frame ID
 110  *                id        method name ID
 111  *                id        method signature ID
 112  *                id        source file name ID
 113  *                u4        class serial number
 114  *                i4        line number. &gt;0: normal
 115  *                                       -1: unknown
 116  *                                       -2: compiled method
 117  *                                       -3: native method
 118  *
 119  * HPROF_TRACE              a Java stack trace
 120  *
 121  *               u4         stack trace serial number
 122  *               u4         thread serial number
 123  *               u4         number of frames
 124  *               [id]*      stack frame IDs
 125  *
 126  *
 127  * HPROF_ALLOC_SITES        a set of heap allocation sites, obtained after GC
 128  *
 129  *               u2         flags 0x0001: incremental vs. complete
 130  *                                0x0002: sorted by allocation vs. live
 131  *                                0x0004: whether to force a GC
 132  *               u4         cutoff ratio
 133  *               u4         total live bytes
 134  *               u4         total live instances
 135  *               u8         total bytes allocated
 136  *               u8         total instances allocated
 137  *               u4         number of sites that follow
 138  *               [u1        is_array: 0:  normal object
 139  *                                    2:  object array
 140  *                                    4:  boolean array
 141  *                                    5:  char array
 142  *                                    6:  float array
 143  *                                    7:  double array
 144  *                                    8:  byte array
 145  *                                    9:  short array
 146  *                                    10: int array
 147  *                                    11: long array
 148  *                u4        class serial number (may be zero during startup)
 149  *                u4        stack trace serial number
 150  *                u4        number of bytes alive
 151  *                u4        number of instances alive
 152  *                u4        number of bytes allocated
 153  *                u4]*      number of instance allocated
 154  *
 155  * HPROF_START_THREAD       a newly started thread.
 156  *
 157  *               u4         thread serial number (&gt; 0)
 158  *               id         thread object ID
 159  *               u4         stack trace serial number
 160  *               id         thread name ID
 161  *               id         thread group name ID
 162  *               id         thread group parent name ID
 163  *
 164  * HPROF_END_THREAD         a terminating thread.
 165  *
 166  *               u4         thread serial number
 167  *
 168  * HPROF_HEAP_SUMMARY       heap summary
 169  *
 170  *               u4         total live bytes
 171  *               u4         total live instances
 172  *               u8         total bytes allocated
 173  *               u8         total instances allocated
 174  *
 175  * HPROF_HEAP_DUMP          denote a heap dump
 176  *
 177  *               [heap dump sub-records]*
 178  *
 179  *                          There are four kinds of heap dump sub-records:
 180  *
 181  *               u1         sub-record type
 182  *
 183  *               HPROF_GC_ROOT_UNKNOWN         unknown root
 184  *
 185  *                          id         object ID
 186  *
 187  *               HPROF_GC_ROOT_THREAD_OBJ      thread object
 188  *
 189  *                          id         thread object ID  (may be 0 for a
 190  *                                     thread newly attached through JNI)
 191  *                          u4         thread sequence number
 192  *                          u4         stack trace sequence number
 193  *
 194  *               HPROF_GC_ROOT_JNI_GLOBAL      JNI global ref root
 195  *
 196  *                          id         object ID
 197  *                          id         JNI global ref ID
 198  *
 199  *               HPROF_GC_ROOT_JNI_LOCAL       JNI local ref
 200  *
 201  *                          id         object ID
 202  *                          u4         thread serial number
 203  *                          u4         frame # in stack trace (-1 for empty)
 204  *
 205  *               HPROF_GC_ROOT_JAVA_FRAME      Java stack frame
 206  *
 207  *                          id         object ID
 208  *                          u4         thread serial number
 209  *                          u4         frame # in stack trace (-1 for empty)
 210  *
 211  *               HPROF_GC_ROOT_NATIVE_STACK    Native stack
 212  *
 213  *                          id         object ID
 214  *                          u4         thread serial number
 215  *
 216  *               HPROF_GC_ROOT_STICKY_CLASS    System class
 217  *
 218  *                          id         object ID
 219  *
 220  *               HPROF_GC_ROOT_THREAD_BLOCK    Reference from thread block
 221  *
 222  *                          id         object ID
 223  *                          u4         thread serial number
 224  *
 225  *               HPROF_GC_ROOT_MONITOR_USED    Busy monitor
 226  *
 227  *                          id         object ID
 228  *
 229  *               HPROF_GC_CLASS_DUMP           dump of a class object
 230  *
 231  *                          id         class object ID
 232  *                          u4         stack trace serial number
 233  *                          id         super class object ID
 234  *                          id         class loader object ID
 235  *                          id         signers object ID
 236  *                          id         protection domain object ID
 237  *                          id         reserved
 238  *                          id         reserved
 239  *
 240  *                          u4         instance size (in bytes)
 241  *
 242  *                          u2         size of constant pool
 243  *                          [u2,       constant pool index,
 244  *                           ty,       type
 245  *                                     2:  object
 246  *                                     4:  boolean
 247  *                                     5:  char
 248  *                                     6:  float
 249  *                                     7:  double
 250  *                                     8:  byte
 251  *                                     9:  short
 252  *                                     10: int
 253  *                                     11: long
 254  *                           vl]*      and value
 255  *
 256  *                          u2         number of static fields
 257  *                          [id,       static field name,
 258  *                           ty,       type,
 259  *                           vl]*      and value
 260  *
 261  *                          u2         number of inst. fields (not inc. super)
 262  *                          [id,       instance field name,
 263  *                           ty]*      type
 264  *
 265  *               HPROF_GC_INSTANCE_DUMP        dump of a normal object
 266  *
 267  *                          id         object ID
 268  *                          u4         stack trace serial number
 269  *                          id         class object ID
 270  *                          u4         number of bytes that follow
 271  *                          [vl]*      instance field values (class, followed
 272  *                                     by super, super&#39;s super ...)
 273  *
 274  *               HPROF_GC_OBJ_ARRAY_DUMP       dump of an object array
 275  *
 276  *                          id         array object ID
 277  *                          u4         stack trace serial number
 278  *                          u4         number of elements
 279  *                          id         array class ID
 280  *                          [id]*      elements
 281  *
 282  *               HPROF_GC_PRIM_ARRAY_DUMP      dump of a primitive array
 283  *
 284  *                          id         array object ID
 285  *                          u4         stack trace serial number
 286  *                          u4         number of elements
 287  *                          u1         element type
 288  *                                     4:  boolean array
 289  *                                     5:  char array
 290  *                                     6:  float array
 291  *                                     7:  double array
 292  *                                     8:  byte array
 293  *                                     9:  short array
 294  *                                     10: int array
 295  *                                     11: long array
 296  *                          [u1]*      elements
 297  *
 298  * HPROF_CPU_SAMPLES        a set of sample traces of running threads
 299  *
 300  *                u4        total number of samples
 301  *                u4        # of traces
 302  *               [u4        # of samples
 303  *                u4]*      stack trace serial number
 304  *
 305  * HPROF_CONTROL_SETTINGS   the settings of on/off switches
 306  *
 307  *                u4        0x00000001: alloc traces on/off
 308  *                          0x00000002: cpu sampling on/off
 309  *                u2        stack trace depth
 310  *
 311  *
 312  * When the header is &quot;JAVA PROFILE 1.0.2&quot; a heap dump can optionally
 313  * be generated as a sequence of heap dump segments. This sequence is
 314  * terminated by an end record. The additional tags allowed by format
 315  * &quot;JAVA PROFILE 1.0.2&quot; are:
 316  *
 317  * HPROF_HEAP_DUMP_SEGMENT  denote a heap dump segment
 318  *
 319  *               [heap dump sub-records]*
 320  *               The same sub-record types allowed by HPROF_HEAP_DUMP
 321  *
 322  * HPROF_HEAP_DUMP_END      denotes the end of a heap dump
 323  *
 324  */
 325 
 326 
 327 // HPROF tags
 328 
 329 typedef enum {
 330   // top-level records
 331   HPROF_UTF8                    = 0x01,
 332   HPROF_LOAD_CLASS              = 0x02,
 333   HPROF_UNLOAD_CLASS            = 0x03,
 334   HPROF_FRAME                   = 0x04,
 335   HPROF_TRACE                   = 0x05,
 336   HPROF_ALLOC_SITES             = 0x06,
 337   HPROF_HEAP_SUMMARY            = 0x07,
 338   HPROF_START_THREAD            = 0x0A,
 339   HPROF_END_THREAD              = 0x0B,
 340   HPROF_HEAP_DUMP               = 0x0C,
 341   HPROF_CPU_SAMPLES             = 0x0D,
 342   HPROF_CONTROL_SETTINGS        = 0x0E,
 343 
 344   // 1.0.2 record types
 345   HPROF_HEAP_DUMP_SEGMENT       = 0x1C,
 346   HPROF_HEAP_DUMP_END           = 0x2C,
 347 
 348   // field types
 349   HPROF_ARRAY_OBJECT            = 0x01,
 350   HPROF_NORMAL_OBJECT           = 0x02,
 351   HPROF_BOOLEAN                 = 0x04,
 352   HPROF_CHAR                    = 0x05,
 353   HPROF_FLOAT                   = 0x06,
 354   HPROF_DOUBLE                  = 0x07,
 355   HPROF_BYTE                    = 0x08,
 356   HPROF_SHORT                   = 0x09,
 357   HPROF_INT                     = 0x0A,
 358   HPROF_LONG                    = 0x0B,
 359 
 360   // data-dump sub-records
 361   HPROF_GC_ROOT_UNKNOWN         = 0xFF,
 362   HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,
 363   HPROF_GC_ROOT_JNI_LOCAL       = 0x02,
 364   HPROF_GC_ROOT_JAVA_FRAME      = 0x03,
 365   HPROF_GC_ROOT_NATIVE_STACK    = 0x04,
 366   HPROF_GC_ROOT_STICKY_CLASS    = 0x05,
 367   HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,
 368   HPROF_GC_ROOT_MONITOR_USED    = 0x07,
 369   HPROF_GC_ROOT_THREAD_OBJ      = 0x08,
 370   HPROF_GC_CLASS_DUMP           = 0x20,
 371   HPROF_GC_INSTANCE_DUMP        = 0x21,
 372   HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,
 373   HPROF_GC_PRIM_ARRAY_DUMP      = 0x23
 374 } hprofTag;
 375 
 376 // Default stack trace ID (used for dummy HPROF_TRACE record)
 377 enum {
 378   STACK_TRACE_ID = 1,
 379   INITIAL_CLASS_COUNT = 200
 380 };
 381 
 382 // Supports I/O operations for a dump
 383 
 384 class DumpWriter : public StackObj {
 385  private:
 386   enum {
 387     io_buffer_max_size = 1*M,
 388     io_buffer_max_waste = 10*K,
 389     dump_segment_header_size = 9
 390   };
 391 
 392   char* _buffer;    // internal buffer
 393   size_t _size;
 394   size_t _pos;
 395 
 396   bool _in_dump_segment; // Are we currently in a dump segment?
 397   bool _is_huge_sub_record; // Are we writing a sub-record larger than the buffer size?
 398   DEBUG_ONLY(size_t _sub_record_left;) // The bytes not written for the current sub-record.
 399   DEBUG_ONLY(bool _sub_record_ended;) // True if we have called the end_sub_record().
 400 
 401   CompressionBackend _backend; // Does the actual writing.
 402 
 403   void flush();
 404 
 405   char* buffer() const                          { return _buffer; }
 406   size_t buffer_size() const                    { return _size; }
 407   size_t position() const                       { return _pos; }
 408   void set_position(size_t pos)                 { _pos = pos; }
 409 
 410   // Can be called if we have enough room in the buffer.
 411   void write_fast(void* s, size_t len);
 412 
 413   // Returns true if we have enough room in the buffer for &#39;len&#39; bytes.
 414   bool can_write_fast(size_t len);
 415 
 416  public:
 417   // Takes ownership of the writer and compressor.
 418   DumpWriter(AbstractWriter* writer, AbstractCompressor* compressor);
 419 
 420   ~DumpWriter();
 421 
 422   // total number of bytes written to the disk
 423   julong bytes_written() const          { return (julong) _backend.get_written(); }
 424 
 425   char const* error() const             { return _backend.error(); }
 426 
 427   // writer functions
 428   void write_raw(void* s, size_t len);
 429   void write_u1(u1 x);
 430   void write_u2(u2 x);
 431   void write_u4(u4 x);
 432   void write_u8(u8 x);
 433   void write_objectID(oop o);
 434   void write_symbolID(Symbol* o);
 435   void write_classID(Klass* k);
 436   void write_id(u4 x);
 437 
 438   // Start a new sub-record. Starts a new heap dump segment if needed.
 439   void start_sub_record(u1 tag, u4 len);
 440   // Ends the current sub-record.
 441   void end_sub_record();
 442   // Finishes the current dump segment if not already finished.
 443   void finish_dump_segment();
 444 
 445   // Called by threads used for parallel writing.
 446   void writer_loop()                    { _backend.thread_loop(false); }
 447   // Called when finished to release the threads.
 448   void deactivate()                     { flush(); _backend.deactivate(); }
 449 };
 450 
 451 // Check for error after constructing the object and destroy it in case of an error.
 452 DumpWriter::DumpWriter(AbstractWriter* writer, AbstractCompressor* compressor) :
 453   _buffer(NULL),
 454   _size(0),
 455   _pos(0),
 456   _in_dump_segment(false),
 457   _backend(writer, compressor, io_buffer_max_size, io_buffer_max_waste) {
 458   flush();
 459 }
 460 
 461 DumpWriter::~DumpWriter() {
 462   flush();
 463 }
 464 
 465 void DumpWriter::write_fast(void* s, size_t len) {
 466   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);
 467   assert(buffer_size() - position() &gt;= len, &quot;Must fit&quot;);
 468   debug_only(_sub_record_left -= len);
 469 
 470   memcpy(buffer() + position(), s, len);
 471   set_position(position() + len);
 472 }
 473 
 474 bool DumpWriter::can_write_fast(size_t len) {
 475   return buffer_size() - position() &gt;= len;
 476 }
 477 
 478 // write raw bytes
 479 void DumpWriter::write_raw(void* s, size_t len) {
 480   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);
 481   debug_only(_sub_record_left -= len);
 482 
 483   // flush buffer to make room.
 484   while (len &gt; buffer_size() - position()) {
 485     assert(!_in_dump_segment || _is_huge_sub_record,
 486            &quot;Cannot overflow in non-huge sub-record.&quot;);
 487 
 488     size_t to_write = buffer_size() - position();
 489     memcpy(buffer() + position(), s, to_write);
 490     s = (void*) ((char*) s + to_write);
 491     len -= to_write;
 492     set_position(position() + to_write);
 493     flush();
 494   }
 495 
 496   memcpy(buffer() + position(), s, len);
 497   set_position(position() + len);
 498 }
 499 
 500 // flush any buffered bytes to the file
 501 void DumpWriter::flush() {
 502   _backend.get_new_buffer(&amp;_buffer, &amp;_pos, &amp;_size);
 503 }
 504 
 505 // Makes sure we inline the fast write into the write_u* functions. This is a big speedup.
 506 #define WRITE_KNOWN_TYPE(p, len) do { if (can_write_fast((len))) write_fast((p), (len)); \
 507                                       else write_raw((p), (len)); } while (0)
 508 
 509 void DumpWriter::write_u1(u1 x) {
 510   WRITE_KNOWN_TYPE((void*) &amp;x, 1);
 511 }
 512 
 513 void DumpWriter::write_u2(u2 x) {
 514   u2 v;
 515   Bytes::put_Java_u2((address)&amp;v, x);
 516   WRITE_KNOWN_TYPE((void*)&amp;v, 2);
 517 }
 518 
 519 void DumpWriter::write_u4(u4 x) {
 520   u4 v;
 521   Bytes::put_Java_u4((address)&amp;v, x);
 522   WRITE_KNOWN_TYPE((void*)&amp;v, 4);
 523 }
 524 
 525 void DumpWriter::write_u8(u8 x) {
 526   u8 v;
 527   Bytes::put_Java_u8((address)&amp;v, x);
 528   WRITE_KNOWN_TYPE((void*)&amp;v, 8);
 529 }
 530 
 531 void DumpWriter::write_objectID(oop o) {
 532   address a = cast_from_oop&lt;address&gt;(o);
 533 #ifdef _LP64
 534   write_u8((u8)a);
 535 #else
 536   write_u4((u4)a);
 537 #endif
 538 }
 539 
 540 void DumpWriter::write_symbolID(Symbol* s) {
 541   address a = (address)((uintptr_t)s);
 542 #ifdef _LP64
 543   write_u8((u8)a);
 544 #else
 545   write_u4((u4)a);
 546 #endif
 547 }
 548 
 549 void DumpWriter::write_id(u4 x) {
 550 #ifdef _LP64
 551   write_u8((u8) x);
 552 #else
 553   write_u4(x);
 554 #endif
 555 }
 556 
 557 // We use java mirror as the class ID
 558 void DumpWriter::write_classID(Klass* k) {
 559   write_objectID(k-&gt;java_mirror());
 560 }
 561 
 562 void DumpWriter::finish_dump_segment() {
 563   if (_in_dump_segment) {
 564     assert(_sub_record_left == 0, &quot;Last sub-record not written completely&quot;);
 565     assert(_sub_record_ended, &quot;sub-record must have ended&quot;);
 566 
 567     // Fix up the dump segment length if we haven&#39;t written a huge sub-record last
 568     // (in which case the segment length was already set to the correct value initially).
 569     if (!_is_huge_sub_record) {
 570       assert(position() &gt; dump_segment_header_size, &quot;Dump segment should have some content&quot;);
 571       Bytes::put_Java_u4((address) (buffer() + 5),
 572                          (u4) (position() - dump_segment_header_size));
 573     }
 574 
 575     flush();
 576     _in_dump_segment = false;
 577   }
 578 }
 579 
 580 void DumpWriter::start_sub_record(u1 tag, u4 len) {
 581   if (!_in_dump_segment) {
 582     if (position() &gt; 0) {
 583       flush();
 584     }
 585 
 586     assert(position() == 0, &quot;Must be at the start&quot;);
 587 
 588     write_u1(HPROF_HEAP_DUMP_SEGMENT);
 589     write_u4(0); // timestamp
 590     // Will be fixed up later if we add more sub-records.  If this is a huge sub-record,
 591     // this is already the correct length, since we don&#39;t add more sub-records.
 592     write_u4(len);
 593     _in_dump_segment = true;
 594     _is_huge_sub_record = len &gt; buffer_size() - dump_segment_header_size;
 595   } else if (_is_huge_sub_record || (len &gt; buffer_size() - position())) {
 596     // This object will not fit in completely or the last sub-record was huge.
 597     // Finish the current segement and try again.
 598     finish_dump_segment();
 599     start_sub_record(tag, len);
 600 
 601     return;
 602   }
 603 
 604   debug_only(_sub_record_left = len);
 605   debug_only(_sub_record_ended = false);
 606 
 607   write_u1(tag);
 608 }
 609 
 610 void DumpWriter::end_sub_record() {
 611   assert(_in_dump_segment, &quot;must be in dump segment&quot;);
 612   assert(_sub_record_left == 0, &quot;sub-record not written completely&quot;);
 613   assert(!_sub_record_ended, &quot;Must not have ended yet&quot;);
 614   debug_only(_sub_record_ended = true);
 615 }
 616 
 617 // Support class with a collection of functions used when dumping the heap
 618 
 619 class DumperSupport : AllStatic {
 620  public:
 621 
 622   // write a header of the given type
 623   static void write_header(DumpWriter* writer, hprofTag tag, u4 len);
 624 
 625   // returns hprof tag for the given type signature
 626   static hprofTag sig2tag(Symbol* sig);
 627   // returns hprof tag for the given basic type
 628   static hprofTag type2tag(BasicType type);
 629   // Returns the size of the data to write.
 630   static u4 sig2size(Symbol* sig);
 631 
 632   // returns the size of the instance of the given class
 633   static u4 instance_size(Klass* k);
 634 
 635   // dump a jfloat
 636   static void dump_float(DumpWriter* writer, jfloat f);
 637   // dump a jdouble
 638   static void dump_double(DumpWriter* writer, jdouble d);
 639   // dumps the raw value of the given field
 640   static void dump_field_value(DumpWriter* writer, char type, oop obj, int offset);
 641   // returns the size of the static fields; also counts the static fields
 642   static u4 get_static_fields_size(InstanceKlass* ik, u2&amp; field_count);
 643   // dumps static fields of the given class
 644   static void dump_static_fields(DumpWriter* writer, Klass* k);
 645   // dump the raw values of the instance fields of the given object
 646   static void dump_instance_fields(DumpWriter* writer, oop o);
 647   // get the count of the instance fields for a given class
 648   static u2 get_instance_fields_count(InstanceKlass* ik);
 649   // dumps the definition of the instance fields for a given class
 650   static void dump_instance_field_descriptors(DumpWriter* writer, Klass* k);
 651   // creates HPROF_GC_INSTANCE_DUMP record for the given object
 652   static void dump_instance(DumpWriter* writer, oop o);
 653   // creates HPROF_GC_CLASS_DUMP record for the given class and each of its
 654   // array classes
 655   static void dump_class_and_array_classes(DumpWriter* writer, Klass* k);
 656   // creates HPROF_GC_CLASS_DUMP record for a given primitive array
 657   // class (and each multi-dimensional array class too)
 658   static void dump_basic_type_array_class(DumpWriter* writer, Klass* k);
 659 
 660   // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
 661   static void dump_object_array(DumpWriter* writer, objArrayOop array);
 662   // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
 663   static void dump_prim_array(DumpWriter* writer, typeArrayOop array);
 664   // create HPROF_FRAME record for the given method and bci
 665   static void dump_stack_frame(DumpWriter* writer, int frame_serial_num, int class_serial_num, Method* m, int bci);
 666 
 667   // check if we need to truncate an array
 668   static int calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size);
 669 
 670   // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
 671   static void end_of_dump(DumpWriter* writer);
 672 
 673   static oop mask_dormant_archived_object(oop o) {
 674     if (o != NULL &amp;&amp; o-&gt;klass()-&gt;java_mirror() == NULL) {
 675       // Ignore this object since the corresponding java mirror is not loaded.
 676       // Might be a dormant archive object.
 677       return NULL;
 678     } else {
 679       return o;
 680     }
 681   }
 682 };
 683 
 684 // write a header of the given type
 685 void DumperSupport:: write_header(DumpWriter* writer, hprofTag tag, u4 len) {
 686   writer-&gt;write_u1((u1)tag);
 687   writer-&gt;write_u4(0);                  // current ticks
 688   writer-&gt;write_u4(len);
 689 }
 690 
 691 // returns hprof tag for the given type signature
 692 hprofTag DumperSupport::sig2tag(Symbol* sig) {
 693   switch (sig-&gt;char_at(0)) {
 694     case JVM_SIGNATURE_CLASS    : return HPROF_NORMAL_OBJECT;
 695     case JVM_SIGNATURE_ARRAY    : return HPROF_NORMAL_OBJECT;
 696     case JVM_SIGNATURE_BYTE     : return HPROF_BYTE;
 697     case JVM_SIGNATURE_CHAR     : return HPROF_CHAR;
 698     case JVM_SIGNATURE_FLOAT    : return HPROF_FLOAT;
 699     case JVM_SIGNATURE_DOUBLE   : return HPROF_DOUBLE;
 700     case JVM_SIGNATURE_INT      : return HPROF_INT;
 701     case JVM_SIGNATURE_LONG     : return HPROF_LONG;
 702     case JVM_SIGNATURE_SHORT    : return HPROF_SHORT;
 703     case JVM_SIGNATURE_BOOLEAN  : return HPROF_BOOLEAN;
 704     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 705   }
 706 }
 707 
 708 hprofTag DumperSupport::type2tag(BasicType type) {
 709   switch (type) {
 710     case T_BYTE     : return HPROF_BYTE;
 711     case T_CHAR     : return HPROF_CHAR;
 712     case T_FLOAT    : return HPROF_FLOAT;
 713     case T_DOUBLE   : return HPROF_DOUBLE;
 714     case T_INT      : return HPROF_INT;
 715     case T_LONG     : return HPROF_LONG;
 716     case T_SHORT    : return HPROF_SHORT;
 717     case T_BOOLEAN  : return HPROF_BOOLEAN;
 718     default : ShouldNotReachHere(); /* to shut up compiler */ return HPROF_BYTE;
 719   }
 720 }
 721 
 722 u4 DumperSupport::sig2size(Symbol* sig) {
 723   switch (sig-&gt;char_at(0)) {
 724     case JVM_SIGNATURE_CLASS:
 725     case JVM_SIGNATURE_ARRAY: return sizeof(address);
 726     case JVM_SIGNATURE_BOOLEAN:
 727     case JVM_SIGNATURE_BYTE: return 1;
 728     case JVM_SIGNATURE_SHORT:
 729     case JVM_SIGNATURE_CHAR: return 2;
 730     case JVM_SIGNATURE_INT:
 731     case JVM_SIGNATURE_FLOAT: return 4;
 732     case JVM_SIGNATURE_LONG:
 733     case JVM_SIGNATURE_DOUBLE: return 8;
 734     default: ShouldNotReachHere(); /* to shut up compiler */ return 0;
 735   }
 736 }
 737 
 738 // dump a jfloat
 739 void DumperSupport::dump_float(DumpWriter* writer, jfloat f) {
 740   if (g_isnan(f)) {
 741     writer-&gt;write_u4(0x7fc00000);    // collapsing NaNs
 742   } else {
 743     union {
 744       int i;
 745       float f;
 746     } u;
 747     u.f = (float)f;
 748     writer-&gt;write_u4((u4)u.i);
 749   }
 750 }
 751 
 752 // dump a jdouble
 753 void DumperSupport::dump_double(DumpWriter* writer, jdouble d) {
 754   union {
 755     jlong l;
 756     double d;
 757   } u;
 758   if (g_isnan(d)) {                 // collapsing NaNs
 759     u.l = (jlong)(0x7ff80000);
 760     u.l = (u.l &lt;&lt; 32);
 761   } else {
 762     u.d = (double)d;
 763   }
 764   writer-&gt;write_u8((u8)u.l);
 765 }
 766 
 767 // dumps the raw value of the given field
 768 void DumperSupport::dump_field_value(DumpWriter* writer, char type, oop obj, int offset) {
 769   switch (type) {
 770     case JVM_SIGNATURE_CLASS :
 771     case JVM_SIGNATURE_ARRAY : {
 772       oop o = obj-&gt;obj_field_access&lt;ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE&gt;(offset);
 773       if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {
 774         ResourceMark rm;
 775         log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,
 776                              p2i(o), o-&gt;klass()-&gt;external_name(),
 777                              p2i(obj), obj-&gt;klass()-&gt;external_name());
 778       }
 779       o = mask_dormant_archived_object(o);
 780       assert(oopDesc::is_oop_or_null(o), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(o));
 781       writer-&gt;write_objectID(o);
 782       break;
 783     }
 784     case JVM_SIGNATURE_BYTE : {
 785       jbyte b = obj-&gt;byte_field(offset);
 786       writer-&gt;write_u1((u1)b);
 787       break;
 788     }
 789     case JVM_SIGNATURE_CHAR : {
 790       jchar c = obj-&gt;char_field(offset);
 791       writer-&gt;write_u2((u2)c);
 792       break;
 793     }
 794     case JVM_SIGNATURE_SHORT : {
 795       jshort s = obj-&gt;short_field(offset);
 796       writer-&gt;write_u2((u2)s);
 797       break;
 798     }
 799     case JVM_SIGNATURE_FLOAT : {
 800       jfloat f = obj-&gt;float_field(offset);
 801       dump_float(writer, f);
 802       break;
 803     }
 804     case JVM_SIGNATURE_DOUBLE : {
 805       jdouble d = obj-&gt;double_field(offset);
 806       dump_double(writer, d);
 807       break;
 808     }
 809     case JVM_SIGNATURE_INT : {
 810       jint i = obj-&gt;int_field(offset);
 811       writer-&gt;write_u4((u4)i);
 812       break;
 813     }
 814     case JVM_SIGNATURE_LONG : {
 815       jlong l = obj-&gt;long_field(offset);
 816       writer-&gt;write_u8((u8)l);
 817       break;
 818     }
 819     case JVM_SIGNATURE_BOOLEAN : {
 820       jboolean b = obj-&gt;bool_field(offset);
 821       writer-&gt;write_u1((u1)b);
 822       break;
 823     }
 824     default : {
 825       ShouldNotReachHere();
 826       break;
 827     }
 828   }
 829 }
 830 
 831 // returns the size of the instance of the given class
 832 u4 DumperSupport::instance_size(Klass* k) {
<a name="1" id="anc1"></a>
 833   InstanceKlass* ik = InstanceKlass::cast(k);
 834   u4 size = 0;
 835 
 836   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 837     if (!fld.access_flags().is_static()) {
 838       size += sig2size(fld.signature());
 839     }
 840   }
 841   return size;
 842 }
 843 
 844 u4 DumperSupport::get_static_fields_size(InstanceKlass* ik, u2&amp; field_count) {
<a name="2" id="anc2"></a>
 845   field_count = 0;
 846   u4 size = 0;
 847 
 848   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
 849     if (fldc.access_flags().is_static()) {
 850       field_count++;
 851       size += sig2size(fldc.signature());
 852     }
 853   }
 854 
 855   // Add in resolved_references which is referenced by the cpCache
 856   // The resolved_references is an array per InstanceKlass holding the
 857   // strings and other oops resolved from the constant pool.
 858   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
 859   if (resolved_references != NULL) {
 860     field_count++;
 861     size += sizeof(address);
 862 
 863     // Add in the resolved_references of the used previous versions of the class
 864     // in the case of RedefineClasses
 865     InstanceKlass* prev = ik-&gt;previous_versions();
 866     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 867       field_count++;
 868       size += sizeof(address);
 869       prev = prev-&gt;previous_versions();
 870     }
 871   }
 872 
 873   // Also provide a pointer to the init_lock if present, so there aren&#39;t unreferenced int[0]
 874   // arrays.
 875   oop init_lock = ik-&gt;init_lock();
 876   if (init_lock != NULL) {
 877     field_count++;
 878     size += sizeof(address);
 879   }
 880 
 881   // We write the value itself plus a name and a one byte type tag per field.
 882   return size + field_count * (sizeof(address) + 1);
 883 }
 884 
 885 // dumps static fields of the given class
 886 void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {
<a name="3" id="anc3"></a>
 887   InstanceKlass* ik = InstanceKlass::cast(k);
 888 
 889   // dump the field descriptors and raw values
 890   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 891     if (fld.access_flags().is_static()) {
 892       Symbol* sig = fld.signature();
 893 
 894       writer-&gt;write_symbolID(fld.name());   // name
 895       writer-&gt;write_u1(sig2tag(sig));       // type
 896 
 897       // value
 898       dump_field_value(writer, sig-&gt;char_at(0), ik-&gt;java_mirror(), fld.offset());
 899     }
 900   }
 901 
 902   // Add resolved_references for each class that has them
 903   oop resolved_references = ik-&gt;constants()-&gt;resolved_references_or_null();
 904   if (resolved_references != NULL) {
 905     writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 906     writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 907     writer-&gt;write_objectID(resolved_references);
 908 
 909     // Also write any previous versions
 910     InstanceKlass* prev = ik-&gt;previous_versions();
 911     while (prev != NULL &amp;&amp; prev-&gt;constants()-&gt;resolved_references_or_null() != NULL) {
 912       writer-&gt;write_symbolID(vmSymbols::resolved_references_name());  // name
 913       writer-&gt;write_u1(sig2tag(vmSymbols::object_array_signature())); // type
 914       writer-&gt;write_objectID(prev-&gt;constants()-&gt;resolved_references());
 915       prev = prev-&gt;previous_versions();
 916     }
 917   }
 918 
 919   // Add init lock to the end if the class is not yet initialized
 920   oop init_lock = ik-&gt;init_lock();
 921   if (init_lock != NULL) {
 922     writer-&gt;write_symbolID(vmSymbols::init_lock_name());         // name
 923     writer-&gt;write_u1(sig2tag(vmSymbols::int_array_signature())); // type
 924     writer-&gt;write_objectID(init_lock);
 925   }
 926 }
 927 
 928 // dump the raw values of the instance fields of the given object
 929 void DumperSupport::dump_instance_fields(DumpWriter* writer, oop o) {
<a name="4" id="anc4"></a>
 930   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());
 931 
 932   for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {
 933     if (!fld.access_flags().is_static()) {
 934       Symbol* sig = fld.signature();
 935       dump_field_value(writer, sig-&gt;char_at(0), o, fld.offset());
 936     }
 937   }
 938 }
 939 
 940 // dumps the definition of the instance fields for a given class
 941 u2 DumperSupport::get_instance_fields_count(InstanceKlass* ik) {
<a name="5" id="anc5"></a>
 942   u2 field_count = 0;
 943 
 944   for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {
 945     if (!fldc.access_flags().is_static()) field_count++;
 946   }
 947 
 948   return field_count;
 949 }
 950 
 951 // dumps the definition of the instance fields for a given class
 952 void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {
<a name="6" id="anc6"></a>
 953   InstanceKlass* ik = InstanceKlass::cast(k);
 954 
 955   // dump the field descriptors
 956   for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {
 957     if (!fld.access_flags().is_static()) {
 958       Symbol* sig = fld.signature();
 959 
 960       writer-&gt;write_symbolID(fld.name());   // name
 961       writer-&gt;write_u1(sig2tag(sig));       // type
 962     }
 963   }
 964 }
 965 
 966 // creates HPROF_GC_INSTANCE_DUMP record for the given object
 967 void DumperSupport::dump_instance(DumpWriter* writer, oop o) {
 968   InstanceKlass* ik = InstanceKlass::cast(o-&gt;klass());
 969   u4 is = instance_size(ik);
 970   u4 size = 1 + sizeof(address) + 4 + sizeof(address) + 4 + is;
 971 
 972   writer-&gt;start_sub_record(HPROF_GC_INSTANCE_DUMP, size);
 973   writer-&gt;write_objectID(o);
 974   writer-&gt;write_u4(STACK_TRACE_ID);
 975 
 976   // class ID
 977   writer-&gt;write_classID(ik);
 978 
 979   // number of bytes that follow
 980   writer-&gt;write_u4(is);
 981 
 982   // field values
 983   dump_instance_fields(writer, o);
 984 
 985   writer-&gt;end_sub_record();
 986 }
 987 
 988 // creates HPROF_GC_CLASS_DUMP record for the given class and each of
 989 // its array classes
 990 void DumperSupport::dump_class_and_array_classes(DumpWriter* writer, Klass* k) {
 991   InstanceKlass* ik = InstanceKlass::cast(k);
 992 
 993   // We can safepoint and do a heap dump at a point where we have a Klass,
 994   // but no java mirror class has been setup for it. So we need to check
 995   // that the class is at least loaded, to avoid crash from a null mirror.
 996   if (!ik-&gt;is_loaded()) {
 997     return;
 998   }
 999 
1000   u2 static_fields_count = 0;
1001   u4 static_size = get_static_fields_size(ik, static_fields_count);
1002   u2 instance_fields_count = get_instance_fields_count(ik);
1003   u4 instance_fields_size = instance_fields_count * (sizeof(address) + 1);
1004   u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + static_size + 2 + instance_fields_size;
1005 
1006   writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);
1007 
1008   // class ID
1009   writer-&gt;write_classID(ik);
1010   writer-&gt;write_u4(STACK_TRACE_ID);
1011 
1012   // super class ID
1013   InstanceKlass* java_super = ik-&gt;java_super();
1014   if (java_super == NULL) {
1015     writer-&gt;write_objectID(oop(NULL));
1016   } else {
1017     writer-&gt;write_classID(java_super);
1018   }
1019 
1020   writer-&gt;write_objectID(ik-&gt;class_loader());
1021   writer-&gt;write_objectID(ik-&gt;signers());
1022   writer-&gt;write_objectID(ik-&gt;protection_domain());
1023 
1024   // reserved
1025   writer-&gt;write_objectID(oop(NULL));
1026   writer-&gt;write_objectID(oop(NULL));
1027 
1028   // instance size
1029   writer-&gt;write_u4(DumperSupport::instance_size(ik));
1030 
1031   // size of constant pool - ignored by HAT 1.1
1032   writer-&gt;write_u2(0);
1033 
1034   // static fields
1035   writer-&gt;write_u2(static_fields_count);
1036   dump_static_fields(writer, ik);
1037 
1038   // description of instance fields
1039   writer-&gt;write_u2(instance_fields_count);
1040   dump_instance_field_descriptors(writer, ik);
1041 
1042   writer-&gt;end_sub_record();
1043 
1044   // array classes
1045   k = ik-&gt;array_klass_or_null();
1046   while (k != NULL) {
1047     assert(k-&gt;is_objArray_klass(), &quot;not an ObjArrayKlass&quot;);
1048 
1049     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;
1050     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);
1051     writer-&gt;write_classID(k);
1052     writer-&gt;write_u4(STACK_TRACE_ID);
1053 
1054     // super class of array classes is java.lang.Object
1055     java_super = k-&gt;java_super();
1056     assert(java_super != NULL, &quot;checking&quot;);
1057     writer-&gt;write_classID(java_super);
1058 
1059     writer-&gt;write_objectID(ik-&gt;class_loader());
1060     writer-&gt;write_objectID(ik-&gt;signers());
1061     writer-&gt;write_objectID(ik-&gt;protection_domain());
1062 
1063     writer-&gt;write_objectID(oop(NULL));    // reserved
1064     writer-&gt;write_objectID(oop(NULL));
1065     writer-&gt;write_u4(0);             // instance size
1066     writer-&gt;write_u2(0);             // constant pool
1067     writer-&gt;write_u2(0);             // static fields
1068     writer-&gt;write_u2(0);             // instance fields
1069 
1070     writer-&gt;end_sub_record();
1071 
1072     // get the array class for the next rank
1073     k = k-&gt;array_klass_or_null();
1074   }
1075 }
1076 
1077 // creates HPROF_GC_CLASS_DUMP record for a given primitive array
1078 // class (and each multi-dimensional array class too)
1079 void DumperSupport::dump_basic_type_array_class(DumpWriter* writer, Klass* k) {
1080  // array classes
1081  while (k != NULL) {
1082     Klass* klass = k;
1083 
1084     u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;
1085     writer-&gt;start_sub_record(HPROF_GC_CLASS_DUMP, size);
1086     writer-&gt;write_classID(klass);
1087     writer-&gt;write_u4(STACK_TRACE_ID);
1088 
1089     // super class of array classes is java.lang.Object
1090     InstanceKlass* java_super = klass-&gt;java_super();
1091     assert(java_super != NULL, &quot;checking&quot;);
1092     writer-&gt;write_classID(java_super);
1093 
1094     writer-&gt;write_objectID(oop(NULL));    // loader
1095     writer-&gt;write_objectID(oop(NULL));    // signers
1096     writer-&gt;write_objectID(oop(NULL));    // protection domain
1097 
1098     writer-&gt;write_objectID(oop(NULL));    // reserved
1099     writer-&gt;write_objectID(oop(NULL));
1100     writer-&gt;write_u4(0);             // instance size
1101     writer-&gt;write_u2(0);             // constant pool
1102     writer-&gt;write_u2(0);             // static fields
1103     writer-&gt;write_u2(0);             // instance fields
1104 
1105     writer-&gt;end_sub_record();
1106 
1107     // get the array class for the next rank
1108     k = klass-&gt;array_klass_or_null();
1109   }
1110 }
1111 
1112 // Hprof uses an u4 as record length field,
1113 // which means we need to truncate arrays that are too long.
1114 int DumperSupport::calculate_array_max_length(DumpWriter* writer, arrayOop array, short header_size) {
1115   BasicType type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1116   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt;= T_OBJECT, &quot;invalid array element type&quot;);
1117 
1118   int length = array-&gt;length();
1119 
1120   int type_size;
1121   if (type == T_OBJECT) {
1122     type_size = sizeof(address);
1123   } else {
1124     type_size = type2aelembytes(type);
1125   }
1126 
1127   size_t length_in_bytes = (size_t)length * type_size;
1128   uint max_bytes = max_juint - header_size;
1129 
1130   if (length_in_bytes &gt; max_bytes) {
1131     length = max_bytes / type_size;
1132     length_in_bytes = (size_t)length * type_size;
1133 
1134     warning(&quot;cannot dump array of type %s[] with length %d; truncating to length %d&quot;,
1135             type2name_tab[type], array-&gt;length(), length);
1136   }
1137   return length;
1138 }
1139 
1140 // creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array
1141 void DumperSupport::dump_object_array(DumpWriter* writer, objArrayOop array) {
1142   // sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID) + sizeof(classID)
1143   short header_size = 1 + 2 * 4 + 2 * sizeof(address);
1144   int length = calculate_array_max_length(writer, array, header_size);
1145   u4 size = header_size + length * sizeof(address);
1146 
1147   writer-&gt;start_sub_record(HPROF_GC_OBJ_ARRAY_DUMP, size);
1148   writer-&gt;write_objectID(array);
1149   writer-&gt;write_u4(STACK_TRACE_ID);
1150   writer-&gt;write_u4(length);
1151 
1152   // array class ID
1153   writer-&gt;write_classID(array-&gt;klass());
1154 
1155   // [id]* elements
1156   for (int index = 0; index &lt; length; index++) {
1157     oop o = array-&gt;obj_at(index);
1158     if (o != NULL &amp;&amp; log_is_enabled(Debug, cds, heap) &amp;&amp; mask_dormant_archived_object(o) == NULL) {
1159       ResourceMark rm;
1160       log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s) referenced by &quot; INTPTR_FORMAT &quot; (%s)&quot;,
1161                            p2i(o), o-&gt;klass()-&gt;external_name(),
1162                            p2i(array), array-&gt;klass()-&gt;external_name());
1163     }
1164     o = mask_dormant_archived_object(o);
1165     writer-&gt;write_objectID(o);
1166   }
1167 
1168   writer-&gt;end_sub_record();
1169 }
1170 
1171 #define WRITE_ARRAY(Array, Type, Size, Length) \
1172   for (int i = 0; i &lt; Length; i++) { writer-&gt;write_##Size((Size)Array-&gt;Type##_at(i)); }
1173 
1174 // creates HPROF_GC_PRIM_ARRAY_DUMP record for the given type array
1175 void DumperSupport::dump_prim_array(DumpWriter* writer, typeArrayOop array) {
1176   BasicType type = TypeArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1177 
1178   // 2 * sizeof(u1) + 2 * sizeof(u4) + sizeof(objectID)
1179   short header_size = 2 * 1 + 2 * 4 + sizeof(address);
1180 
1181   int length = calculate_array_max_length(writer, array, header_size);
1182   int type_size = type2aelembytes(type);
1183   u4 length_in_bytes = (u4)length * type_size;
1184   u4 size = header_size + length_in_bytes;
1185 
1186   writer-&gt;start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);
1187   writer-&gt;write_objectID(array);
1188   writer-&gt;write_u4(STACK_TRACE_ID);
1189   writer-&gt;write_u4(length);
1190   writer-&gt;write_u1(type2tag(type));
1191 
1192   // nothing to copy
1193   if (length == 0) {
1194     writer-&gt;end_sub_record();
1195     return;
1196   }
1197 
1198   // If the byte ordering is big endian then we can copy most types directly
1199 
1200   switch (type) {
1201     case T_INT : {
1202       if (Endian::is_Java_byte_ordering_different()) {
1203         WRITE_ARRAY(array, int, u4, length);
1204       } else {
1205         writer-&gt;write_raw((void*)(array-&gt;int_at_addr(0)), length_in_bytes);
1206       }
1207       break;
1208     }
1209     case T_BYTE : {
1210       writer-&gt;write_raw((void*)(array-&gt;byte_at_addr(0)), length_in_bytes);
1211       break;
1212     }
1213     case T_CHAR : {
1214       if (Endian::is_Java_byte_ordering_different()) {
1215         WRITE_ARRAY(array, char, u2, length);
1216       } else {
1217         writer-&gt;write_raw((void*)(array-&gt;char_at_addr(0)), length_in_bytes);
1218       }
1219       break;
1220     }
1221     case T_SHORT : {
1222       if (Endian::is_Java_byte_ordering_different()) {
1223         WRITE_ARRAY(array, short, u2, length);
1224       } else {
1225         writer-&gt;write_raw((void*)(array-&gt;short_at_addr(0)), length_in_bytes);
1226       }
1227       break;
1228     }
1229     case T_BOOLEAN : {
1230       if (Endian::is_Java_byte_ordering_different()) {
1231         WRITE_ARRAY(array, bool, u1, length);
1232       } else {
1233         writer-&gt;write_raw((void*)(array-&gt;bool_at_addr(0)), length_in_bytes);
1234       }
1235       break;
1236     }
1237     case T_LONG : {
1238       if (Endian::is_Java_byte_ordering_different()) {
1239         WRITE_ARRAY(array, long, u8, length);
1240       } else {
1241         writer-&gt;write_raw((void*)(array-&gt;long_at_addr(0)), length_in_bytes);
1242       }
1243       break;
1244     }
1245 
1246     // handle float/doubles in a special value to ensure than NaNs are
1247     // written correctly. TO DO: Check if we can avoid this on processors that
1248     // use IEEE 754.
1249 
1250     case T_FLOAT : {
1251       for (int i = 0; i &lt; length; i++) {
1252         dump_float(writer, array-&gt;float_at(i));
1253       }
1254       break;
1255     }
1256     case T_DOUBLE : {
1257       for (int i = 0; i &lt; length; i++) {
1258         dump_double(writer, array-&gt;double_at(i));
1259       }
1260       break;
1261     }
1262     default : ShouldNotReachHere();
1263   }
1264 
1265   writer-&gt;end_sub_record();
1266 }
1267 
1268 // create a HPROF_FRAME record of the given Method* and bci
1269 void DumperSupport::dump_stack_frame(DumpWriter* writer,
1270                                      int frame_serial_num,
1271                                      int class_serial_num,
1272                                      Method* m,
1273                                      int bci) {
1274   int line_number;
1275   if (m-&gt;is_native()) {
1276     line_number = -3;  // native frame
1277   } else {
1278     line_number = m-&gt;line_number_from_bci(bci);
1279   }
1280 
1281   write_header(writer, HPROF_FRAME, 4*oopSize + 2*sizeof(u4));
1282   writer-&gt;write_id(frame_serial_num);               // frame serial number
1283   writer-&gt;write_symbolID(m-&gt;name());                // method&#39;s name
1284   writer-&gt;write_symbolID(m-&gt;signature());           // method&#39;s signature
1285 
1286   assert(m-&gt;method_holder()-&gt;is_instance_klass(), &quot;not InstanceKlass&quot;);
1287   writer-&gt;write_symbolID(m-&gt;method_holder()-&gt;source_file_name());  // source file name
1288   writer-&gt;write_u4(class_serial_num);               // class serial number
1289   writer-&gt;write_u4((u4) line_number);               // line number
1290 }
1291 
1292 
1293 // Support class used to generate HPROF_UTF8 records from the entries in the
1294 // SymbolTable.
1295 
1296 class SymbolTableDumper : public SymbolClosure {
1297  private:
1298   DumpWriter* _writer;
1299   DumpWriter* writer() const                { return _writer; }
1300  public:
1301   SymbolTableDumper(DumpWriter* writer)     { _writer = writer; }
1302   void do_symbol(Symbol** p);
1303 };
1304 
1305 void SymbolTableDumper::do_symbol(Symbol** p) {
1306   ResourceMark rm;
1307   Symbol* sym = load_symbol(p);
1308   int len = sym-&gt;utf8_length();
1309   if (len &gt; 0) {
1310     char* s = sym-&gt;as_utf8();
1311     DumperSupport::write_header(writer(), HPROF_UTF8, oopSize + len);
1312     writer()-&gt;write_symbolID(sym);
1313     writer()-&gt;write_raw(s, len);
1314   }
1315 }
1316 
1317 // Support class used to generate HPROF_GC_ROOT_JNI_LOCAL records
1318 
1319 class JNILocalsDumper : public OopClosure {
1320  private:
1321   DumpWriter* _writer;
1322   u4 _thread_serial_num;
1323   int _frame_num;
1324   DumpWriter* writer() const                { return _writer; }
1325  public:
1326   JNILocalsDumper(DumpWriter* writer, u4 thread_serial_num) {
1327     _writer = writer;
1328     _thread_serial_num = thread_serial_num;
1329     _frame_num = -1;  // default - empty stack
1330   }
1331   void set_frame_number(int n) { _frame_num = n; }
1332   void do_oop(oop* obj_p);
1333   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1334 };
1335 
1336 
1337 void JNILocalsDumper::do_oop(oop* obj_p) {
1338   // ignore null handles
1339   oop o = *obj_p;
1340   if (o != NULL) {
1341     u4 size = 1 + sizeof(address) + 4 + 4;
1342     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_LOCAL, size);
1343     writer()-&gt;write_objectID(o);
1344     writer()-&gt;write_u4(_thread_serial_num);
1345     writer()-&gt;write_u4((u4)_frame_num);
1346     writer()-&gt;end_sub_record();
1347   }
1348 }
1349 
1350 
1351 // Support class used to generate HPROF_GC_ROOT_JNI_GLOBAL records
1352 
1353 class JNIGlobalsDumper : public OopClosure {
1354  private:
1355   DumpWriter* _writer;
1356   DumpWriter* writer() const                { return _writer; }
1357 
1358  public:
1359   JNIGlobalsDumper(DumpWriter* writer) {
1360     _writer = writer;
1361   }
1362   void do_oop(oop* obj_p);
1363   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1364 };
1365 
1366 void JNIGlobalsDumper::do_oop(oop* obj_p) {
1367   oop o = *obj_p;
1368 
1369   // ignore these
1370   if (o == NULL) return;
1371 
1372   // we ignore global ref to symbols and other internal objects
1373   if (o-&gt;is_instance() || o-&gt;is_objArray() || o-&gt;is_typeArray()) {
1374     u4 size = 1 + 2 * sizeof(address);
1375     writer()-&gt;start_sub_record(HPROF_GC_ROOT_JNI_GLOBAL, size);
1376     writer()-&gt;write_objectID(o);
1377     writer()-&gt;write_objectID((oopDesc*)obj_p);      // global ref ID
1378     writer()-&gt;end_sub_record();
1379   }
1380 };
1381 
1382 
1383 // Support class used to generate HPROF_GC_ROOT_MONITOR_USED records
1384 
1385 class MonitorUsedDumper : public OopClosure {
1386  private:
1387   DumpWriter* _writer;
1388   DumpWriter* writer() const                { return _writer; }
1389  public:
1390   MonitorUsedDumper(DumpWriter* writer) {
1391     _writer = writer;
1392   }
1393   void do_oop(oop* obj_p) {
1394     u4 size = 1 + sizeof(address);
1395     writer()-&gt;start_sub_record(HPROF_GC_ROOT_MONITOR_USED, size);
1396     writer()-&gt;write_objectID(*obj_p);
1397     writer()-&gt;end_sub_record();
1398   }
1399   void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
1400 };
1401 
1402 
1403 // Support class used to generate HPROF_GC_ROOT_STICKY_CLASS records
1404 
1405 class StickyClassDumper : public KlassClosure {
1406  private:
1407   DumpWriter* _writer;
1408   DumpWriter* writer() const                { return _writer; }
1409  public:
1410   StickyClassDumper(DumpWriter* writer) {
1411     _writer = writer;
1412   }
1413   void do_klass(Klass* k) {
1414     if (k-&gt;is_instance_klass()) {
1415       InstanceKlass* ik = InstanceKlass::cast(k);
1416       u4 size = 1 + sizeof(address);
1417       writer()-&gt;start_sub_record(HPROF_GC_ROOT_STICKY_CLASS, size);
1418       writer()-&gt;write_classID(ik);
1419       writer()-&gt;end_sub_record();
1420     }
1421   }
1422 };
1423 
1424 
1425 class VM_HeapDumper;
1426 
1427 // Support class using when iterating over the heap.
1428 
1429 class HeapObjectDumper : public ObjectClosure {
1430  private:
1431   VM_HeapDumper* _dumper;
1432   DumpWriter* _writer;
1433 
1434   VM_HeapDumper* dumper()               { return _dumper; }
1435   DumpWriter* writer()                  { return _writer; }
1436 
1437  public:
1438   HeapObjectDumper(VM_HeapDumper* dumper, DumpWriter* writer) {
1439     _dumper = dumper;
1440     _writer = writer;
1441   }
1442 
1443   // called for each object in the heap
1444   void do_object(oop o);
1445 };
1446 
1447 void HeapObjectDumper::do_object(oop o) {
1448   // skip classes as these emitted as HPROF_GC_CLASS_DUMP records
1449   if (o-&gt;klass() == SystemDictionary::Class_klass()) {
1450     if (!java_lang_Class::is_primitive(o)) {
1451       return;
1452     }
1453   }
1454 
1455   if (DumperSupport::mask_dormant_archived_object(o) == NULL) {
1456     log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());
1457     return;
1458   }
1459 
1460   if (o-&gt;is_instance()) {
1461     // create a HPROF_GC_INSTANCE record for each object
1462     DumperSupport::dump_instance(writer(), o);
1463   } else if (o-&gt;is_objArray()) {
1464     // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
1465     DumperSupport::dump_object_array(writer(), objArrayOop(o));
1466   } else if (o-&gt;is_typeArray()) {
1467     // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
1468     DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
1469   }
1470 }
1471 
1472 // The VM operation that performs the heap dump
1473 class VM_HeapDumper : public VM_GC_Operation, public AbstractGangTask {
1474  private:
1475   static VM_HeapDumper* _global_dumper;
1476   static DumpWriter*    _global_writer;
1477   DumpWriter*           _local_writer;
1478   JavaThread*           _oome_thread;
1479   Method*               _oome_constructor;
1480   bool _gc_before_heap_dump;
1481   GrowableArray&lt;Klass*&gt;* _klass_map;
1482   ThreadStackTrace** _stack_traces;
1483   int _num_threads;
1484 
1485   // accessors and setters
1486   static VM_HeapDumper* dumper()         {  assert(_global_dumper != NULL, &quot;Error&quot;); return _global_dumper; }
1487   static DumpWriter* writer()            {  assert(_global_writer != NULL, &quot;Error&quot;); return _global_writer; }
1488   void set_global_dumper() {
1489     assert(_global_dumper == NULL, &quot;Error&quot;);
1490     _global_dumper = this;
1491   }
1492   void set_global_writer() {
1493     assert(_global_writer == NULL, &quot;Error&quot;);
1494     _global_writer = _local_writer;
1495   }
1496   void clear_global_dumper() { _global_dumper = NULL; }
1497   void clear_global_writer() { _global_writer = NULL; }
1498 
1499   bool skip_operation() const;
1500 
1501   // writes a HPROF_LOAD_CLASS record
1502   class ClassesDo;
1503   static void do_load_class(Klass* k);
1504 
1505   // writes a HPROF_GC_CLASS_DUMP record for the given class
1506   // (and each array class too)
1507   static void do_class_dump(Klass* k);
1508 
1509   // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1510   // array (and each multi-dimensional array too)
1511   static void do_basic_type_array_class_dump(Klass* k);
1512 
1513   // HPROF_GC_ROOT_THREAD_OBJ records
1514   int do_thread(JavaThread* thread, u4 thread_serial_num);
1515   void do_threads();
1516 
1517   void add_class_serial_number(Klass* k, int serial_num) {
1518     _klass_map-&gt;at_put_grow(serial_num, k);
1519   }
1520 
1521   // HPROF_TRACE and HPROF_FRAME records
1522   void dump_stack_traces();
1523 
1524  public:
1525   VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome) :
1526     VM_GC_Operation(0 /* total collections,      dummy, ignored */,
1527                     GCCause::_heap_dump /* GC Cause */,
1528                     0 /* total full collections, dummy, ignored */,
1529                     gc_before_heap_dump),
1530     AbstractGangTask(&quot;dump heap&quot;) {
1531     _local_writer = writer;
1532     _gc_before_heap_dump = gc_before_heap_dump;
1533     _klass_map = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;Klass*&gt;(INITIAL_CLASS_COUNT, mtServiceability);
1534     _stack_traces = NULL;
1535     _num_threads = 0;
1536     if (oome) {
1537       assert(!Thread::current()-&gt;is_VM_thread(), &quot;Dump from OutOfMemoryError cannot be called by the VMThread&quot;);
1538       // get OutOfMemoryError zero-parameter constructor
1539       InstanceKlass* oome_ik = SystemDictionary::OutOfMemoryError_klass();
1540       _oome_constructor = oome_ik-&gt;find_method(vmSymbols::object_initializer_name(),
1541                                                           vmSymbols::void_method_signature());
1542       // get thread throwing OOME when generating the heap dump at OOME
1543       _oome_thread = JavaThread::current();
1544     } else {
1545       _oome_thread = NULL;
1546       _oome_constructor = NULL;
1547     }
1548   }
1549   ~VM_HeapDumper() {
1550     if (_stack_traces != NULL) {
1551       for (int i=0; i &lt; _num_threads; i++) {
1552         delete _stack_traces[i];
1553       }
1554       FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);
1555     }
1556     delete _klass_map;
1557   }
1558 
1559   VMOp_Type type() const { return VMOp_HeapDumper; }
1560   void doit();
1561   void work(uint worker_id);
1562 };
1563 
1564 
1565 VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
1566 DumpWriter*    VM_HeapDumper::_global_writer = NULL;
1567 
1568 bool VM_HeapDumper::skip_operation() const {
1569   return false;
1570 }
1571 
1572 // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
1573 void DumperSupport::end_of_dump(DumpWriter* writer) {
1574   writer-&gt;finish_dump_segment();
1575 
1576   writer-&gt;write_u1(HPROF_HEAP_DUMP_END);
1577   writer-&gt;write_u4(0);
1578   writer-&gt;write_u4(0);
1579 }
1580 
1581 // writes a HPROF_LOAD_CLASS record for the class (and each of its
1582 // array classes)
1583 void VM_HeapDumper::do_load_class(Klass* k) {
1584   static u4 class_serial_num = 0;
1585 
1586   // len of HPROF_LOAD_CLASS record
1587   u4 remaining = 2*oopSize + 2*sizeof(u4);
1588 
1589   // write a HPROF_LOAD_CLASS for the class and each array class
1590   do {
1591     DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);
1592 
1593     // class serial number is just a number
1594     writer()-&gt;write_u4(++class_serial_num);
1595 
1596     // class ID
1597     Klass* klass = k;
1598     writer()-&gt;write_classID(klass);
1599 
1600     // add the Klass* and class serial number pair
1601     dumper()-&gt;add_class_serial_number(klass, class_serial_num);
1602 
1603     writer()-&gt;write_u4(STACK_TRACE_ID);
1604 
1605     // class name ID
1606     Symbol* name = klass-&gt;name();
1607     writer()-&gt;write_symbolID(name);
1608 
1609     // write a LOAD_CLASS record for the array type (if it exists)
1610     k = klass-&gt;array_klass_or_null();
1611   } while (k != NULL);
1612 }
1613 
1614 // writes a HPROF_GC_CLASS_DUMP record for the given class
1615 void VM_HeapDumper::do_class_dump(Klass* k) {
1616   if (k-&gt;is_instance_klass()) {
1617     DumperSupport::dump_class_and_array_classes(writer(), k);
1618   }
1619 }
1620 
1621 // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1622 // array (and each multi-dimensional array too)
1623 void VM_HeapDumper::do_basic_type_array_class_dump(Klass* k) {
1624   DumperSupport::dump_basic_type_array_class(writer(), k);
1625 }
1626 
1627 // Walk the stack of the given thread.
1628 // Dumps a HPROF_GC_ROOT_JAVA_FRAME record for each local
1629 // Dumps a HPROF_GC_ROOT_JNI_LOCAL record for each JNI local
1630 //
1631 // It returns the number of Java frames in this thread stack
1632 int VM_HeapDumper::do_thread(JavaThread* java_thread, u4 thread_serial_num) {
1633   JNILocalsDumper blk(writer(), thread_serial_num);
1634 
1635   oop threadObj = java_thread-&gt;threadObj();
1636   assert(threadObj != NULL, &quot;sanity check&quot;);
1637 
1638   int stack_depth = 0;
1639   if (java_thread-&gt;has_last_Java_frame()) {
1640 
1641     // vframes are resource allocated
1642     Thread* current_thread = Thread::current();
1643     ResourceMark rm(current_thread);
1644     HandleMark hm(current_thread);
1645 
1646     RegisterMap reg_map(java_thread);
1647     frame f = java_thread-&gt;last_frame();
1648     vframe* vf = vframe::new_vframe(&amp;f, &amp;reg_map, java_thread);
1649     frame* last_entry_frame = NULL;
1650     int extra_frames = 0;
1651 
1652     if (java_thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1653       extra_frames++;
1654     }
1655     while (vf != NULL) {
1656       blk.set_frame_number(stack_depth);
1657       if (vf-&gt;is_java_frame()) {
1658 
1659         // java frame (interpreted, compiled, ...)
1660         javaVFrame *jvf = javaVFrame::cast(vf);
1661         if (!(jvf-&gt;method()-&gt;is_native())) {
1662           StackValueCollection* locals = jvf-&gt;locals();
1663           for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
1664             if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
1665               oop o = locals-&gt;obj_at(slot)();
1666 
1667               if (o != NULL) {
1668                 u4 size = 1 + sizeof(address) + 4 + 4;
1669                 writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);
1670                 writer()-&gt;write_objectID(o);
1671                 writer()-&gt;write_u4(thread_serial_num);
1672                 writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
1673                 writer()-&gt;end_sub_record();
1674               }
1675             }
1676           }
1677           StackValueCollection *exprs = jvf-&gt;expressions();
1678           for(int index = 0; index &lt; exprs-&gt;size(); index++) {
1679             if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
1680                oop o = exprs-&gt;obj_at(index)();
1681                if (o != NULL) {
1682                  u4 size = 1 + sizeof(address) + 4 + 4;
1683                  writer()-&gt;start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);
1684                  writer()-&gt;write_objectID(o);
1685                  writer()-&gt;write_u4(thread_serial_num);
1686                  writer()-&gt;write_u4((u4) (stack_depth + extra_frames));
1687                  writer()-&gt;end_sub_record();
1688                }
1689              }
1690           }
1691         } else {
1692           // native frame
1693           if (stack_depth == 0) {
1694             // JNI locals for the top frame.
1695             java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1696           } else {
1697             if (last_entry_frame != NULL) {
1698               // JNI locals for the entry frame
1699               assert(last_entry_frame-&gt;is_entry_frame(), &quot;checking&quot;);
1700               last_entry_frame-&gt;entry_frame_call_wrapper()-&gt;handles()-&gt;oops_do(&amp;blk);
1701             }
1702           }
1703         }
1704         // increment only for Java frames
1705         stack_depth++;
1706         last_entry_frame = NULL;
1707 
1708       } else {
1709         // externalVFrame - if it&#39;s an entry frame then report any JNI locals
1710         // as roots when we find the corresponding native javaVFrame
1711         frame* fr = vf-&gt;frame_pointer();
1712         assert(fr != NULL, &quot;sanity check&quot;);
1713         if (fr-&gt;is_entry_frame()) {
1714           last_entry_frame = fr;
1715         }
1716       }
1717       vf = vf-&gt;sender();
1718     }
1719   } else {
1720     // no last java frame but there may be JNI locals
1721     java_thread-&gt;active_handles()-&gt;oops_do(&amp;blk);
1722   }
1723   return stack_depth;
1724 }
1725 
1726 
1727 // write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk
1728 // the stack so that locals and JNI locals are dumped.
1729 void VM_HeapDumper::do_threads() {
1730   for (int i=0; i &lt; _num_threads; i++) {
1731     JavaThread* thread = _stack_traces[i]-&gt;thread();
1732     oop threadObj = thread-&gt;threadObj();
1733     u4 thread_serial_num = i+1;
1734     u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;
1735     u4 size = 1 + sizeof(address) + 4 + 4;
1736     writer()-&gt;start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);
1737     writer()-&gt;write_objectID(threadObj);
1738     writer()-&gt;write_u4(thread_serial_num);  // thread number
1739     writer()-&gt;write_u4(stack_serial_num);   // stack trace serial number
1740     writer()-&gt;end_sub_record();
1741     int num_frames = do_thread(thread, thread_serial_num);
1742     assert(num_frames == _stack_traces[i]-&gt;get_stack_depth(),
1743            &quot;total number of Java frames not matched&quot;);
1744   }
1745 }
1746 
1747 
1748 // The VM operation that dumps the heap. The dump consists of the following
1749 // records:
1750 //
1751 //  HPROF_HEADER
1752 //  [HPROF_UTF8]*
1753 //  [HPROF_LOAD_CLASS]*
1754 //  [[HPROF_FRAME]*|HPROF_TRACE]*
1755 //  [HPROF_GC_CLASS_DUMP]*
1756 //  [HPROF_HEAP_DUMP_SEGMENT]*
1757 //  HPROF_HEAP_DUMP_END
1758 //
1759 // The HPROF_TRACE records represent the stack traces where the heap dump
1760 // is generated and a &quot;dummy trace&quot; record which does not include
1761 // any frames. The dummy trace record is used to be referenced as the
1762 // unknown object alloc site.
1763 //
1764 // Each HPROF_HEAP_DUMP_SEGMENT record has a length followed by sub-records.
1765 // To allow the heap dump be generated in a single pass we remember the position
1766 // of the dump length and fix it up after all sub-records have been written.
1767 // To generate the sub-records we iterate over the heap, writing
1768 // HPROF_GC_INSTANCE_DUMP, HPROF_GC_OBJ_ARRAY_DUMP, and HPROF_GC_PRIM_ARRAY_DUMP
1769 // records as we go. Once that is done we write records for some of the GC
1770 // roots.
1771 
1772 void VM_HeapDumper::doit() {
1773 
<a name="7" id="anc7"></a>
1774   CollectedHeap* ch = Universe::heap();
1775 
1776   ch-&gt;ensure_parsability(false); // must happen, even if collection does
1777                                  // not happen (e.g. due to GCLocker)
1778 
1779   if (_gc_before_heap_dump) {
1780     if (GCLocker::is_active()) {
1781       warning(&quot;GC locker is held; pre-heapdump GC was skipped&quot;);
1782     } else {
1783       ch-&gt;collect_as_vm_thread(GCCause::_heap_dump);
1784     }
1785   }
1786 
1787   // At this point we should be the only dumper active, so
1788   // the following should be safe.
1789   set_global_dumper();
1790   set_global_writer();
1791 
1792   WorkGang* gang = ch-&gt;get_safepoint_workers();
1793 
1794   if (gang == NULL) {
1795     work(0);
1796   } else {
1797     gang-&gt;run_task(this, gang-&gt;active_workers(), true);
1798   }
1799 
1800   // Now we clear the global variables, so that a future dumper can run.
1801   clear_global_dumper();
1802   clear_global_writer();
1803 }
1804 
1805 void VM_HeapDumper::work(uint worker_id) {
1806   if (!Thread::current()-&gt;is_VM_thread()) {
1807     writer()-&gt;writer_loop();
1808     return;
1809   }
1810 
1811   // Write the file header - we always use 1.0.2
1812   const char* header = &quot;JAVA PROFILE 1.0.2&quot;;
1813 
1814   // header is few bytes long - no chance to overflow int
1815   writer()-&gt;write_raw((void*)header, (int)strlen(header));
1816   writer()-&gt;write_u1(0); // terminator
1817   writer()-&gt;write_u4(oopSize);
1818   // timestamp is current time in ms
1819   writer()-&gt;write_u8(os::javaTimeMillis());
1820 
1821   // HPROF_UTF8 records
1822   SymbolTableDumper sym_dumper(writer());
1823   SymbolTable::symbols_do(&amp;sym_dumper);
1824 
1825   // write HPROF_LOAD_CLASS records
1826   {
1827     LockedClassesDo locked_load_classes(&amp;do_load_class);
1828     ClassLoaderDataGraph::classes_do(&amp;locked_load_classes);
1829   }
1830   Universe::basic_type_classes_do(&amp;do_load_class);
1831 
1832   // write HPROF_FRAME and HPROF_TRACE records
1833   // this must be called after _klass_map is built when iterating the classes above.
1834   dump_stack_traces();
1835 
1836   // Writes HPROF_GC_CLASS_DUMP records
1837   {
1838     LockedClassesDo locked_dump_class(&amp;do_class_dump);
1839     ClassLoaderDataGraph::classes_do(&amp;locked_dump_class);
1840   }
1841   Universe::basic_type_classes_do(&amp;do_basic_type_array_class_dump);
1842 
1843   // writes HPROF_GC_INSTANCE_DUMP records.
1844   // After each sub-record is written check_segment_length will be invoked
1845   // to check if the current segment exceeds a threshold. If so, a new
1846   // segment is started.
1847   // The HPROF_GC_CLASS_DUMP and HPROF_GC_INSTANCE_DUMP are the vast bulk
1848   // of the heap dump.
1849   HeapObjectDumper obj_dumper(this, writer());
1850   Universe::heap()-&gt;object_iterate(&amp;obj_dumper);
1851 
1852   // HPROF_GC_ROOT_THREAD_OBJ + frames + jni locals
1853   do_threads();
1854 
1855   // HPROF_GC_ROOT_MONITOR_USED
1856   MonitorUsedDumper mon_dumper(writer());
1857   ObjectSynchronizer::oops_do(&amp;mon_dumper);
1858 
1859   // HPROF_GC_ROOT_JNI_GLOBAL
1860   JNIGlobalsDumper jni_dumper(writer());
1861   JNIHandles::oops_do(&amp;jni_dumper);
1862   Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
1863                                    // for things like preallocated throwable backtraces
1864 
1865   // HPROF_GC_ROOT_STICKY_CLASS
1866   // These should be classes in the NULL class loader data, and not all classes
1867   // if !ClassUnloading
1868   StickyClassDumper class_dumper(writer());
1869   ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
1870 
1871   // Writes the HPROF_HEAP_DUMP_END record.
1872   DumperSupport::end_of_dump(writer());
1873 
1874   // We are done with writing. Release the worker threads.
1875   writer()-&gt;deactivate();
1876 }
1877 
1878 void VM_HeapDumper::dump_stack_traces() {
1879   // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
1880   DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));
1881   writer()-&gt;write_u4((u4) STACK_TRACE_ID);
1882   writer()-&gt;write_u4(0);                    // thread number
1883   writer()-&gt;write_u4(0);                    // frame count
1884 
1885   _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);
1886   int frame_serial_num = 0;
1887   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
1888     oop threadObj = thread-&gt;threadObj();
1889     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1890       // dump thread stack trace
1891       ResourceMark rm;
1892       ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);
1893       stack_trace-&gt;dump_stack_at_safepoint(-1);
1894       _stack_traces[_num_threads++] = stack_trace;
1895 
1896       // write HPROF_FRAME records for this thread&#39;s stack trace
1897       int depth = stack_trace-&gt;get_stack_depth();
1898       int thread_frame_start = frame_serial_num;
1899       int extra_frames = 0;
1900       // write fake frame that makes it look like the thread, which caused OOME,
1901       // is in the OutOfMemoryError zero-parameter constructor
1902       if (thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1903         int oome_serial_num = _klass_map-&gt;find(_oome_constructor-&gt;method_holder());
1904         // the class serial number starts from 1
1905         assert(oome_serial_num &gt; 0, &quot;OutOfMemoryError class not found&quot;);
1906         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,
1907                                         _oome_constructor, 0);
1908         extra_frames++;
1909       }
1910       for (int j=0; j &lt; depth; j++) {
1911         StackFrameInfo* frame = stack_trace-&gt;stack_frame_at(j);
1912         Method* m = frame-&gt;method();
1913         int class_serial_num = _klass_map-&gt;find(m-&gt;method_holder());
1914         // the class serial number starts from 1
1915         assert(class_serial_num &gt; 0, &quot;class not found&quot;);
1916         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame-&gt;bci());
1917       }
1918       depth += extra_frames;
1919 
1920       // write HPROF_TRACE record for one thread
1921       DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4) + depth*oopSize);
1922       int stack_serial_num = _num_threads + STACK_TRACE_ID;
1923       writer()-&gt;write_u4(stack_serial_num);      // stack trace serial number
1924       writer()-&gt;write_u4((u4) _num_threads);     // thread serial number
1925       writer()-&gt;write_u4(depth);                 // frame count
1926       for (int j=1; j &lt;= depth; j++) {
1927         writer()-&gt;write_id(thread_frame_start + j);
1928       }
1929     }
1930   }
1931 }
1932 
1933 // dump the heap to given path.
1934 int HeapDumper::dump(const char* path, outputStream* out, int compression) {
1935   assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
1936 
1937   // print message in interactive case
1938   if (out != NULL) {
1939     out-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);
1940     timer()-&gt;start();
1941   }
1942 
1943   // create JFR event
1944   EventHeapDump event;
1945 
1946   AbstractCompressor* compressor = NULL;
1947 
1948   if (compression &gt; 0) {
1949     compressor = new (std::nothrow) GZipCompressor(compression);
1950 
1951     if (compressor == NULL) {
1952       set_error(&quot;Could not allocate gzip compressor&quot;);
1953       return -1;
1954     }
1955   }
1956 
1957   DumpWriter writer(new (std::nothrow) FileWriter(path), compressor);
1958 
1959   if (writer.error() != NULL) {
1960     set_error(writer.error());
1961     if (out != NULL) {
1962       out-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,
1963         (error() != NULL) ? error() : &quot;reason unknown&quot;);
1964     }
1965     return -1;
1966   }
1967 
1968   // generate the dump
1969   VM_HeapDumper dumper(&amp;writer, _gc_before_heap_dump, _oome);
1970   if (Thread::current()-&gt;is_VM_thread()) {
1971     assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected to be called at a safepoint&quot;);
1972     dumper.doit();
1973   } else {
1974     VMThread::execute(&amp;dumper);
1975   }
1976 
1977   // record any error that the writer may have encountered
1978   set_error(writer.error());
1979 
1980   // emit JFR event
1981   if (error() == NULL) {
1982     event.set_destination(path);
1983     event.set_gcBeforeDump(_gc_before_heap_dump);
1984     event.set_size(writer.bytes_written());
1985     event.set_onOutOfMemoryError(_oome);
1986     event.commit();
1987   }
1988 
1989   // print message in interactive case
1990   if (out != NULL) {
1991     timer()-&gt;stop();
1992     if (error() == NULL) {
1993       out-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,
1994                     writer.bytes_written(), timer()-&gt;seconds());
1995     } else {
1996       out-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());
1997     }
1998   }
1999 
2000   return (writer.error() == NULL) ? 0 : -1;
2001 }
2002 
2003 // stop timer (if still active), and free any error string we might be holding
2004 HeapDumper::~HeapDumper() {
2005   if (timer()-&gt;is_active()) {
2006     timer()-&gt;stop();
2007   }
2008   set_error(NULL);
2009 }
2010 
2011 
2012 // returns the error string (resource allocated), or NULL
2013 char* HeapDumper::error_as_C_string() const {
2014   if (error() != NULL) {
2015     char* str = NEW_RESOURCE_ARRAY(char, strlen(error())+1);
2016     strcpy(str, error());
2017     return str;
2018   } else {
2019     return NULL;
2020   }
2021 }
2022 
2023 // set the error string
2024 void HeapDumper::set_error(char const* error) {
2025   if (_error != NULL) {
2026     os::free(_error);
2027   }
2028   if (error == NULL) {
2029     _error = NULL;
2030   } else {
2031     _error = os::strdup(error);
2032     assert(_error != NULL, &quot;allocation failure&quot;);
2033   }
2034 }
2035 
2036 // Called by out-of-memory error reporting by a single Java thread
2037 // outside of a JVM safepoint
2038 void HeapDumper::dump_heap_from_oome() {
2039   HeapDumper::dump_heap(true);
2040 }
2041 
2042 // Called by error reporting by a single Java thread outside of a JVM safepoint,
2043 // or by heap dumping by the VM thread during a (GC) safepoint. Thus, these various
2044 // callers are strictly serialized and guaranteed not to interfere below. For more
2045 // general use, however, this method will need modification to prevent
2046 // inteference when updating the static variables base_path and dump_file_seq below.
2047 void HeapDumper::dump_heap() {
2048   HeapDumper::dump_heap(false);
2049 }
2050 
2051 void HeapDumper::dump_heap(bool oome) {
2052   static char base_path[JVM_MAXPATHLEN] = {&#39;\0&#39;};
2053   static uint dump_file_seq = 0;
2054   char* my_path;
2055   const int max_digit_chars = 20;
2056 
2057   const char* dump_file_name = &quot;java_pid&quot;;
2058   const char* dump_file_ext  = &quot;.hprof&quot;;
2059 
2060   // The dump file defaults to java_pid&lt;pid&gt;.hprof in the current working
2061   // directory. HeapDumpPath=&lt;file&gt; can be used to specify an alternative
2062   // dump file name or a directory where dump file is created.
2063   if (dump_file_seq == 0) { // first time in, we initialize base_path
2064     // Calculate potentially longest base path and check if we have enough
2065     // allocated statically.
2066     const size_t total_length =
2067                       (HeapDumpPath == NULL ? 0 : strlen(HeapDumpPath)) +
2068                       strlen(os::file_separator()) + max_digit_chars +
2069                       strlen(dump_file_name) + strlen(dump_file_ext) + 1;
2070     if (total_length &gt; sizeof(base_path)) {
2071       warning(&quot;Cannot create heap dump file.  HeapDumpPath is too long.&quot;);
2072       return;
2073     }
2074 
2075     bool use_default_filename = true;
2076     if (HeapDumpPath == NULL || HeapDumpPath[0] == &#39;\0&#39;) {
2077       // HeapDumpPath=&lt;file&gt; not specified
2078     } else {
2079       strcpy(base_path, HeapDumpPath);
2080       // check if the path is a directory (must exist)
2081       DIR* dir = os::opendir(base_path);
2082       if (dir == NULL) {
2083         use_default_filename = false;
2084       } else {
2085         // HeapDumpPath specified a directory. We append a file separator
2086         // (if needed).
2087         os::closedir(dir);
2088         size_t fs_len = strlen(os::file_separator());
2089         if (strlen(base_path) &gt;= fs_len) {
2090           char* end = base_path;
2091           end += (strlen(base_path) - fs_len);
2092           if (strcmp(end, os::file_separator()) != 0) {
2093             strcat(base_path, os::file_separator());
2094           }
2095         }
2096       }
2097     }
2098     // If HeapDumpPath wasn&#39;t a file name then we append the default name
2099     if (use_default_filename) {
2100       const size_t dlen = strlen(base_path);  // if heap dump dir specified
2101       jio_snprintf(&amp;base_path[dlen], sizeof(base_path)-dlen, &quot;%s%d%s&quot;,
2102                    dump_file_name, os::current_process_id(), dump_file_ext);
2103     }
2104     const size_t len = strlen(base_path) + 1;
2105     my_path = (char*)os::malloc(len, mtInternal);
2106     if (my_path == NULL) {
2107       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2108       return;
2109     }
2110     strncpy(my_path, base_path, len);
2111   } else {
2112     // Append a sequence number id for dumps following the first
2113     const size_t len = strlen(base_path) + max_digit_chars + 2; // for &#39;.&#39; and \0
2114     my_path = (char*)os::malloc(len, mtInternal);
2115     if (my_path == NULL) {
2116       warning(&quot;Cannot create heap dump file.  Out of system memory.&quot;);
2117       return;
2118     }
2119     jio_snprintf(my_path, len, &quot;%s.%d&quot;, base_path, dump_file_seq);
2120   }
2121   dump_file_seq++;   // increment seq number for next time we dump
2122 
2123   HeapDumper dumper(false /* no GC before heap dump */,
2124                     oome  /* pass along out-of-memory-error flag */);
2125   dumper.dump(my_path, tty);
2126   os::free(my_path);
2127 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>