<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/threadService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;memory/allocation.hpp&quot;
  28 #include &quot;memory/heapInspection.hpp&quot;
  29 #include &quot;memory/oopFactory.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;memory/universe.hpp&quot;
  32 #include &quot;oops/instanceKlass.hpp&quot;
  33 #include &quot;oops/objArrayKlass.hpp&quot;
  34 #include &quot;oops/objArrayOop.inline.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/jvmtiRawMonitor.hpp&quot;
  37 #include &quot;runtime/atomic.hpp&quot;
  38 #include &quot;runtime/handles.inline.hpp&quot;
  39 #include &quot;runtime/init.hpp&quot;
  40 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  41 #include &quot;runtime/thread.inline.hpp&quot;
  42 #include &quot;runtime/threadSMR.inline.hpp&quot;
  43 #include &quot;runtime/vframe.hpp&quot;
  44 #include &quot;runtime/vmThread.hpp&quot;
  45 #include &quot;runtime/vmOperations.hpp&quot;
  46 #include &quot;services/threadService.hpp&quot;
  47 
  48 // TODO: we need to define a naming convention for perf counters
  49 // to distinguish counters for:
  50 //   - standard JSR174 use
  51 //   - Hotspot extension (public and committed)
  52 //   - Hotspot extension (private/internal and uncommitted)
  53 
  54 // Default is disabled.
  55 bool ThreadService::_thread_monitoring_contention_enabled = false;
  56 bool ThreadService::_thread_cpu_time_enabled = false;
  57 bool ThreadService::_thread_allocated_memory_enabled = false;
  58 
  59 PerfCounter*  ThreadService::_total_threads_count = NULL;
  60 PerfVariable* ThreadService::_live_threads_count = NULL;
  61 PerfVariable* ThreadService::_peak_threads_count = NULL;
  62 PerfVariable* ThreadService::_daemon_threads_count = NULL;
  63 volatile int ThreadService::_atomic_threads_count = 0;
  64 volatile int ThreadService::_atomic_daemon_threads_count = 0;
  65 
  66 ThreadDumpResult* ThreadService::_threaddump_list = NULL;
  67 
  68 static const int INITIAL_ARRAY_SIZE = 10;
  69 
  70 void ThreadService::init() {
  71   EXCEPTION_MARK;
  72 
  73   // These counters are for java.lang.management API support.
  74   // They are created even if -XX:-UsePerfData is set and in
  75   // that case, they will be allocated on C heap.
  76 
  77   _total_threads_count =
  78                 PerfDataManager::create_counter(JAVA_THREADS, &quot;started&quot;,
  79                                                 PerfData::U_Events, CHECK);
  80 
  81   _live_threads_count =
  82                 PerfDataManager::create_variable(JAVA_THREADS, &quot;live&quot;,
  83                                                  PerfData::U_None, CHECK);
  84 
  85   _peak_threads_count =
  86                 PerfDataManager::create_variable(JAVA_THREADS, &quot;livePeak&quot;,
  87                                                  PerfData::U_None, CHECK);
  88 
  89   _daemon_threads_count =
  90                 PerfDataManager::create_variable(JAVA_THREADS, &quot;daemon&quot;,
  91                                                  PerfData::U_None, CHECK);
  92 
  93   if (os::is_thread_cpu_time_supported()) {
  94     _thread_cpu_time_enabled = true;
  95   }
  96 
  97   _thread_allocated_memory_enabled = true; // Always on, so enable it
  98 }
  99 
 100 void ThreadService::reset_peak_thread_count() {
 101   // Acquire the lock to update the peak thread count
 102   // to synchronize with thread addition and removal.
 103   MutexLocker mu(Threads_lock);
 104   _peak_threads_count-&gt;set_value(get_live_thread_count());
 105 }
 106 
 107 static bool is_hidden_thread(JavaThread *thread) {
 108   // hide VM internal or JVMTI agent threads
 109   return thread-&gt;is_hidden_from_external_view() || thread-&gt;is_jvmti_agent_thread();
 110 }
 111 
 112 void ThreadService::add_thread(JavaThread* thread, bool daemon) {
 113   assert(Threads_lock-&gt;owned_by_self(), &quot;must have threads lock&quot;);
 114 
 115   // Do not count hidden threads
 116   if (is_hidden_thread(thread)) {
 117     return;
 118   }
 119 
 120   _total_threads_count-&gt;inc();
 121   _live_threads_count-&gt;inc();
 122   Atomic::inc(&amp;_atomic_threads_count);
 123   int count = _atomic_threads_count;
 124 
 125   if (count &gt; _peak_threads_count-&gt;get_value()) {
 126     _peak_threads_count-&gt;set_value(count);
 127   }
 128 
 129   if (daemon) {
 130     _daemon_threads_count-&gt;inc();
 131     Atomic::inc(&amp;_atomic_daemon_threads_count);
 132   }
 133 }
 134 
 135 void ThreadService::decrement_thread_counts(JavaThread* jt, bool daemon) {
 136   Atomic::dec(&amp;_atomic_threads_count);
 137 
 138   if (daemon) {
 139     Atomic::dec(&amp;_atomic_daemon_threads_count);
 140   }
 141 }
 142 
 143 void ThreadService::remove_thread(JavaThread* thread, bool daemon) {
 144   assert(Threads_lock-&gt;owned_by_self(), &quot;must have threads lock&quot;);
 145 
 146   // Do not count hidden threads
 147   if (is_hidden_thread(thread)) {
 148     return;
 149   }
 150 
 151   assert(!thread-&gt;is_terminated(), &quot;must not be terminated&quot;);
 152   if (!thread-&gt;is_exiting()) {
 153     // JavaThread::exit() skipped calling current_thread_exiting()
 154     decrement_thread_counts(thread, daemon);
 155   }
 156 
 157   int daemon_count = _atomic_daemon_threads_count;
 158   int count = _atomic_threads_count;
 159 
 160   // Counts are incremented at the same time, but atomic counts are
 161   // decremented earlier than perf counts.
 162   assert(_live_threads_count-&gt;get_value() &gt; count,
 163     &quot;thread count mismatch %d : %d&quot;,
 164     (int)_live_threads_count-&gt;get_value(), count);
 165 
 166   _live_threads_count-&gt;dec(1);
 167   if (daemon) {
 168     assert(_daemon_threads_count-&gt;get_value() &gt; daemon_count,
 169       &quot;thread count mismatch %d : %d&quot;,
 170       (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 171 
 172     _daemon_threads_count-&gt;dec(1);
 173   }
 174 
 175   // Counts are incremented at the same time, but atomic counts are
 176   // decremented earlier than perf counts.
 177   assert(_daemon_threads_count-&gt;get_value() &gt;= daemon_count,
 178     &quot;thread count mismatch %d : %d&quot;,
 179     (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 180   assert(_live_threads_count-&gt;get_value() &gt;= count,
 181     &quot;thread count mismatch %d : %d&quot;,
 182     (int)_live_threads_count-&gt;get_value(), count);
 183   assert(_live_threads_count-&gt;get_value() &gt; 0 ||
 184     (_live_threads_count-&gt;get_value() == 0 &amp;&amp; count == 0 &amp;&amp;
 185     _daemon_threads_count-&gt;get_value() == 0 &amp;&amp; daemon_count == 0),
 186     &quot;thread counts should reach 0 at the same time, live %d,%d daemon %d,%d&quot;,
 187     (int)_live_threads_count-&gt;get_value(), count,
 188     (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 189   assert(_daemon_threads_count-&gt;get_value() &gt; 0 ||
 190     (_daemon_threads_count-&gt;get_value() == 0 &amp;&amp; daemon_count == 0),
 191     &quot;thread counts should reach 0 at the same time, daemon %d,%d&quot;,
 192     (int)_daemon_threads_count-&gt;get_value(), daemon_count);
 193 }
 194 
 195 void ThreadService::current_thread_exiting(JavaThread* jt, bool daemon) {
 196   // Do not count hidden threads
 197   if (is_hidden_thread(jt)) {
 198     return;
 199   }
 200 
 201   assert(jt == JavaThread::current(), &quot;Called by current thread&quot;);
 202   assert(!jt-&gt;is_terminated() &amp;&amp; jt-&gt;is_exiting(), &quot;must be exiting&quot;);
 203 
 204   decrement_thread_counts(jt, daemon);
 205 }
 206 
 207 // FIXME: JVMTI should call this function
 208 Handle ThreadService::get_current_contended_monitor(JavaThread* thread) {
 209   assert(thread != NULL, &quot;should be non-NULL&quot;);
 210   debug_only(Thread::check_for_dangling_thread_pointer(thread);)
 211 
 212   // This function can be called on a target JavaThread that is not
 213   // the caller and we are not at a safepoint. So it is possible for
 214   // the waiting or pending condition to be over/stale and for the
 215   // first stage of async deflation to clear the object field in
 216   // the ObjectMonitor. It is also possible for the object to be
 217   // inflated again and to be associated with a completely different
 218   // ObjectMonitor by the time this object reference is processed
 219   // by the caller.
 220   ObjectMonitor *wait_obj = thread-&gt;current_waiting_monitor();
 221 
 222   oop obj = NULL;
 223   if (wait_obj != NULL) {
 224     // thread is doing an Object.wait() call
 225     obj = (oop) wait_obj-&gt;object();
 226   } else {
 227     ObjectMonitor *enter_obj = thread-&gt;current_pending_monitor();
 228     if (enter_obj != NULL) {
 229       // thread is trying to enter() an ObjectMonitor.
 230       obj = (oop) enter_obj-&gt;object();
 231     }
 232   }
 233 
 234   Handle h(Thread::current(), obj);
 235   return h;
 236 }
 237 
 238 bool ThreadService::set_thread_monitoring_contention(bool flag) {
 239   MutexLocker m(Management_lock);
 240 
 241   bool prev = _thread_monitoring_contention_enabled;
 242   _thread_monitoring_contention_enabled = flag;
 243 
 244   return prev;
 245 }
 246 
 247 bool ThreadService::set_thread_cpu_time_enabled(bool flag) {
 248   MutexLocker m(Management_lock);
 249 
 250   bool prev = _thread_cpu_time_enabled;
 251   _thread_cpu_time_enabled = flag;
 252 
 253   return prev;
 254 }
 255 
 256 bool ThreadService::set_thread_allocated_memory_enabled(bool flag) {
 257   MutexLocker m(Management_lock);
 258 
 259   bool prev = _thread_allocated_memory_enabled;
 260   _thread_allocated_memory_enabled = flag;
 261 
 262   return prev;
 263 }
 264 
 265 void ThreadService::metadata_do(void f(Metadata*)) {
 266   for (ThreadDumpResult* dump = _threaddump_list; dump != NULL; dump = dump-&gt;next()) {
 267     dump-&gt;metadata_do(f);
 268   }
 269 }
 270 
 271 void ThreadService::add_thread_dump(ThreadDumpResult* dump) {
 272   MutexLocker ml(Management_lock);
 273   if (_threaddump_list == NULL) {
 274     _threaddump_list = dump;
 275   } else {
 276     dump-&gt;set_next(_threaddump_list);
 277     _threaddump_list = dump;
 278   }
 279 }
 280 
 281 void ThreadService::remove_thread_dump(ThreadDumpResult* dump) {
 282   MutexLocker ml(Management_lock);
 283 
 284   ThreadDumpResult* prev = NULL;
 285   bool found = false;
 286   for (ThreadDumpResult* d = _threaddump_list; d != NULL; prev = d, d = d-&gt;next()) {
 287     if (d == dump) {
 288       if (prev == NULL) {
 289         _threaddump_list = dump-&gt;next();
 290       } else {
 291         prev-&gt;set_next(dump-&gt;next());
 292       }
 293       found = true;
 294       break;
 295     }
 296   }
 297   assert(found, &quot;The threaddump result to be removed must exist.&quot;);
 298 }
 299 
 300 // Dump stack trace of threads specified in the given threads array.
 301 // Returns StackTraceElement[][] each element is the stack trace of a thread in
 302 // the corresponding entry in the given threads array
 303 Handle ThreadService::dump_stack_traces(GrowableArray&lt;instanceHandle&gt;* threads,
 304                                         int num_threads,
 305                                         TRAPS) {
 306   assert(num_threads &gt; 0, &quot;just checking&quot;);
 307 
 308   ThreadDumpResult dump_result;
 309   VM_ThreadDump op(&amp;dump_result,
 310                    threads,
 311                    num_threads,
 312                    -1,    /* entire stack */
 313                    false, /* with locked monitors */
 314                    false  /* with locked synchronizers */);
 315   VMThread::execute(&amp;op);
 316 
 317   // Allocate the resulting StackTraceElement[][] object
 318 
 319   ResourceMark rm(THREAD);
 320   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_StackTraceElement_array(), true, CHECK_NH);
 321   ObjArrayKlass* ik = ObjArrayKlass::cast(k);
 322   objArrayOop r = oopFactory::new_objArray(ik, num_threads, CHECK_NH);
 323   objArrayHandle result_obj(THREAD, r);
 324 
 325   int num_snapshots = dump_result.num_snapshots();
 326   assert(num_snapshots == num_threads, &quot;Must have num_threads thread snapshots&quot;);
 327   assert(num_snapshots == 0 || dump_result.t_list_has_been_set(), &quot;ThreadsList must have been set if we have a snapshot&quot;);
 328   int i = 0;
 329   for (ThreadSnapshot* ts = dump_result.snapshots(); ts != NULL; i++, ts = ts-&gt;next()) {
 330     ThreadStackTrace* stacktrace = ts-&gt;get_stack_trace();
 331     if (stacktrace == NULL) {
 332       // No stack trace
 333       result_obj-&gt;obj_at_put(i, NULL);
 334     } else {
 335       // Construct an array of java/lang/StackTraceElement object
 336       Handle backtrace_h = stacktrace-&gt;allocate_fill_stack_trace_element_array(CHECK_NH);
 337       result_obj-&gt;obj_at_put(i, backtrace_h());
 338     }
 339   }
 340 
 341   return result_obj;
 342 }
 343 
 344 void ThreadService::reset_contention_count_stat(JavaThread* thread) {
 345   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 346   if (stat != NULL) {
 347     stat-&gt;reset_count_stat();
 348   }
 349 }
 350 
 351 void ThreadService::reset_contention_time_stat(JavaThread* thread) {
 352   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 353   if (stat != NULL) {
 354     stat-&gt;reset_time_stat();
 355   }
 356 }
 357 
 358 // Find deadlocks involving raw monitors, object monitors and concurrent locks
 359 // if concurrent_locks is true.
 360 DeadlockCycle* ThreadService::find_deadlocks_at_safepoint(ThreadsList * t_list, bool concurrent_locks) {
 361   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
 362 
 363   // This code was modified from the original Threads::find_deadlocks code.
 364   int globalDfn = 0, thisDfn;
 365   ObjectMonitor* waitingToLockMonitor = NULL;
 366   JvmtiRawMonitor* waitingToLockRawMonitor = NULL;
 367   oop waitingToLockBlocker = NULL;
 368   bool blocked_on_monitor = false;
 369   JavaThread *currentThread, *previousThread;
 370   int num_deadlocks = 0;
 371 
 372   // Initialize the depth-first-number for each JavaThread.
 373   JavaThreadIterator jti(t_list);
 374   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 375     jt-&gt;set_depth_first_number(-1);
 376   }
 377 
 378   DeadlockCycle* deadlocks = NULL;
 379   DeadlockCycle* last = NULL;
 380   DeadlockCycle* cycle = new DeadlockCycle();
 381   for (JavaThread* jt = jti.first(); jt != NULL; jt = jti.next()) {
 382     if (jt-&gt;depth_first_number() &gt;= 0) {
 383       // this thread was already visited
 384       continue;
 385     }
 386 
 387     thisDfn = globalDfn;
 388     jt-&gt;set_depth_first_number(globalDfn++);
 389     previousThread = jt;
 390     currentThread = jt;
 391 
 392     cycle-&gt;reset();
 393 
 394     // The ObjectMonitor* can&#39;t be async deflated since we are at a safepoint.
 395     // When there is a deadlock, all the monitors involved in the dependency
 396     // cycle must be contended and heavyweight. So we only care about the
 397     // heavyweight monitor a thread is waiting to lock.
 398     waitingToLockMonitor = jt-&gt;current_pending_monitor();
 399     // JVM TI raw monitors can also be involved in deadlocks, and we can be
 400     // waiting to lock both a raw monitor and ObjectMonitor at the same time.
 401     // It isn&#39;t clear how to make deadlock detection work correctly if that
 402     // happens.
 403     waitingToLockRawMonitor = jt-&gt;current_pending_raw_monitor();
 404 
 405     if (concurrent_locks) {
 406       waitingToLockBlocker = jt-&gt;current_park_blocker();
 407     }
 408 
 409     while (waitingToLockMonitor != NULL ||
 410            waitingToLockRawMonitor != NULL ||
 411            waitingToLockBlocker != NULL) {
 412       cycle-&gt;add_thread(currentThread);
 413       // Give preference to the raw monitor
 414       if (waitingToLockRawMonitor != NULL) {
 415         Thread* owner = waitingToLockRawMonitor-&gt;owner();
 416         if (owner != NULL &amp;&amp; // the raw monitor could be released at any time
 417             owner-&gt;is_Java_thread()) {
 418           // only JavaThreads can be reported here
 419           currentThread = (JavaThread*) owner;
 420         }
 421       } else if (waitingToLockMonitor != NULL) {
 422         address currentOwner = (address)waitingToLockMonitor-&gt;owner();
 423         if (currentOwner != NULL) {
 424           currentThread = Threads::owning_thread_from_monitor_owner(t_list,
 425                                                                     currentOwner);
 426           if (currentThread == NULL) {
 427             // This function is called at a safepoint so the JavaThread
 428             // that owns waitingToLockMonitor should be findable, but
 429             // if it is not findable, then the previous currentThread is
 430             // blocked permanently. We record this as a deadlock.
 431             num_deadlocks++;
 432 
 433             cycle-&gt;set_deadlock(true);
 434 
 435             // add this cycle to the deadlocks list
 436             if (deadlocks == NULL) {
 437               deadlocks = cycle;
 438             } else {
 439               last-&gt;set_next(cycle);
 440             }
 441             last = cycle;
 442             cycle = new DeadlockCycle();
 443             break;
 444           }
 445         }
 446       } else {
 447         if (concurrent_locks) {
 448           if (waitingToLockBlocker-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {
 449             oop threadObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(waitingToLockBlocker);
 450             // This JavaThread (if there is one) is protected by the
 451             // ThreadsListSetter in VM_FindDeadlocks::doit().
 452             currentThread = threadObj != NULL ? java_lang_Thread::thread(threadObj) : NULL;
 453           } else {
 454             currentThread = NULL;
 455           }
 456         }
 457       }
 458 
 459       if (currentThread == NULL) {
 460         // No dependency on another thread
 461         break;
 462       }
 463       if (currentThread-&gt;depth_first_number() &lt; 0) {
 464         // First visit to this thread
 465         currentThread-&gt;set_depth_first_number(globalDfn++);
 466       } else if (currentThread-&gt;depth_first_number() &lt; thisDfn) {
 467         // Thread already visited, and not on a (new) cycle
 468         break;
 469       } else if (currentThread == previousThread) {
 470         // Self-loop, ignore
 471         break;
 472       } else {
 473         // We have a (new) cycle
 474         num_deadlocks++;
 475 
 476         cycle-&gt;set_deadlock(true);
 477 
 478         // add this cycle to the deadlocks list
 479         if (deadlocks == NULL) {
 480           deadlocks = cycle;
 481         } else {
 482           last-&gt;set_next(cycle);
 483         }
 484         last = cycle;
 485         cycle = new DeadlockCycle();
 486         break;
 487       }
 488       previousThread = currentThread;
 489       waitingToLockMonitor = (ObjectMonitor*)currentThread-&gt;current_pending_monitor();
 490       if (concurrent_locks) {
 491         waitingToLockBlocker = currentThread-&gt;current_park_blocker();
 492       }
 493     }
 494 
 495   }
 496   delete cycle;
 497   return deadlocks;
 498 }
 499 
 500 ThreadDumpResult::ThreadDumpResult() : _num_threads(0), _num_snapshots(0), _snapshots(NULL), _last(NULL), _next(NULL), _setter() {
 501 
 502   // Create a new ThreadDumpResult object and append to the list.
 503   // If GC happens before this function returns, Method*
 504   // in the stack trace will be visited.
 505   ThreadService::add_thread_dump(this);
 506 }
 507 
 508 ThreadDumpResult::ThreadDumpResult(int num_threads) : _num_threads(num_threads), _num_snapshots(0), _snapshots(NULL), _last(NULL), _next(NULL), _setter() {
 509   // Create a new ThreadDumpResult object and append to the list.
 510   // If GC happens before this function returns, oops
 511   // will be visited.
 512   ThreadService::add_thread_dump(this);
 513 }
 514 
 515 ThreadDumpResult::~ThreadDumpResult() {
 516   ThreadService::remove_thread_dump(this);
 517 
 518   // free all the ThreadSnapshot objects created during
 519   // the VM_ThreadDump operation
 520   ThreadSnapshot* ts = _snapshots;
 521   while (ts != NULL) {
 522     ThreadSnapshot* p = ts;
 523     ts = ts-&gt;next();
 524     delete p;
 525   }
 526 }
 527 
 528 ThreadSnapshot* ThreadDumpResult::add_thread_snapshot() {
 529   ThreadSnapshot* ts = new ThreadSnapshot();
 530   link_thread_snapshot(ts);
 531   return ts;
 532 }
 533 
 534 ThreadSnapshot* ThreadDumpResult::add_thread_snapshot(JavaThread* thread) {
 535   ThreadSnapshot* ts = new ThreadSnapshot();
 536   link_thread_snapshot(ts);
 537   ts-&gt;initialize(t_list(), thread);
 538   return ts;
 539 }
 540 
 541 void ThreadDumpResult::link_thread_snapshot(ThreadSnapshot* ts) {
 542   assert(_num_threads == 0 || _num_snapshots &lt; _num_threads,
 543          &quot;_num_snapshots must be less than _num_threads&quot;);
 544   _num_snapshots++;
 545   if (_snapshots == NULL) {
 546     _snapshots = ts;
 547   } else {
 548     _last-&gt;set_next(ts);
 549   }
 550   _last = ts;
 551 }
 552 
 553 void ThreadDumpResult::metadata_do(void f(Metadata*)) {
 554   for (ThreadSnapshot* ts = _snapshots; ts != NULL; ts = ts-&gt;next()) {
 555     ts-&gt;metadata_do(f);
 556   }
 557 }
 558 
 559 ThreadsList* ThreadDumpResult::t_list() {
 560   return _setter.list();
 561 }
 562 
 563 StackFrameInfo::StackFrameInfo(javaVFrame* jvf, bool with_lock_info) {
 564   _method = jvf-&gt;method();
 565   _bci = jvf-&gt;bci();
 566   _class_holder = OopHandle(Universe::vm_global(), _method-&gt;method_holder()-&gt;klass_holder());
 567   _locked_monitors = NULL;
 568   if (with_lock_info) {
<a name="1" id="anc1"></a><span class="line-modified"> 569     Thread* current_thread = Thread::current();</span>
<span class="line-modified"> 570     ResourceMark rm(current_thread);</span>
<span class="line-added"> 571     HandleMark hm(current_thread);</span>
 572     GrowableArray&lt;MonitorInfo*&gt;* list = jvf-&gt;locked_monitors();
 573     int length = list-&gt;length();
 574     if (length &gt; 0) {
 575       _locked_monitors = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;OopHandle&gt;(length, mtServiceability);
 576       for (int i = 0; i &lt; length; i++) {
 577         MonitorInfo* monitor = list-&gt;at(i);
 578         assert(monitor-&gt;owner() != NULL, &quot;This monitor must have an owning object&quot;);
 579         _locked_monitors-&gt;append(OopHandle(Universe::vm_global(), monitor-&gt;owner()));
 580       }
 581     }
 582   }
 583 }
 584 
 585 StackFrameInfo::~StackFrameInfo() {
 586   if (_locked_monitors != NULL) {
 587     for (int i = 0; i &lt; _locked_monitors-&gt;length(); i++) {
 588       _locked_monitors-&gt;at(i).release(Universe::vm_global());
 589     }
 590     delete _locked_monitors;
 591   }
 592   _class_holder.release(Universe::vm_global());
 593 }
 594 
 595 void StackFrameInfo::metadata_do(void f(Metadata*)) {
 596   f(_method);
 597 }
 598 
 599 void StackFrameInfo::print_on(outputStream* st) const {
 600   ResourceMark rm;
 601   java_lang_Throwable::print_stack_element(st, method(), bci());
 602   int len = (_locked_monitors != NULL ? _locked_monitors-&gt;length() : 0);
 603   for (int i = 0; i &lt; len; i++) {
 604     oop o = _locked_monitors-&gt;at(i).resolve();
 605     st-&gt;print_cr(&quot;\t- locked &lt;&quot; INTPTR_FORMAT &quot;&gt; (a %s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());
 606   }
 607 
 608 }
 609 
 610 // Iterate through monitor cache to find JNI locked monitors
 611 class InflatedMonitorsClosure: public MonitorClosure {
 612 private:
 613   ThreadStackTrace* _stack_trace;
 614   Thread* _thread;
 615 public:
 616   InflatedMonitorsClosure(Thread* t, ThreadStackTrace* st) {
 617     _thread = t;
 618     _stack_trace = st;
 619   }
 620   void do_monitor(ObjectMonitor* mid) {
 621     if (mid-&gt;owner() == _thread) {
 622       oop object = (oop) mid-&gt;object();
 623       if (!_stack_trace-&gt;is_owned_monitor_on_stack(object)) {
 624         _stack_trace-&gt;add_jni_locked_monitor(object);
 625       }
 626     }
 627   }
 628 };
 629 
 630 ThreadStackTrace::ThreadStackTrace(JavaThread* t, bool with_locked_monitors) {
 631   _thread = t;
 632   _frames = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;StackFrameInfo*&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 633   _depth = 0;
 634   _with_locked_monitors = with_locked_monitors;
 635   if (_with_locked_monitors) {
 636     _jni_locked_monitors = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;OopHandle&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 637   } else {
 638     _jni_locked_monitors = NULL;
 639   }
 640 }
 641 
 642 void ThreadStackTrace::add_jni_locked_monitor(oop object) {
 643   _jni_locked_monitors-&gt;append(OopHandle(Universe::vm_global(), object));
 644 }
 645 
 646 ThreadStackTrace::~ThreadStackTrace() {
 647   for (int i = 0; i &lt; _frames-&gt;length(); i++) {
 648     delete _frames-&gt;at(i);
 649   }
 650   delete _frames;
 651   if (_jni_locked_monitors != NULL) {
 652     for (int i = 0; i &lt; _jni_locked_monitors-&gt;length(); i++) {
 653       _jni_locked_monitors-&gt;at(i).release(Universe::vm_global());
 654     }
 655     delete _jni_locked_monitors;
 656   }
 657 }
 658 
 659 void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth) {
 660   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 661 
 662   if (_thread-&gt;has_last_Java_frame()) {
 663     RegisterMap reg_map(_thread);
 664     vframe* start_vf = _thread-&gt;last_java_vframe(&amp;reg_map);
 665     int count = 0;
 666     for (vframe* f = start_vf; f; f = f-&gt;sender() ) {
 667       if (maxDepth &gt;= 0 &amp;&amp; count == maxDepth) {
 668         // Skip frames if more than maxDepth
 669         break;
 670       }
 671       if (f-&gt;is_java_frame()) {
 672         javaVFrame* jvf = javaVFrame::cast(f);
 673         add_stack_frame(jvf);
 674         count++;
 675       } else {
 676         // Ignore non-Java frames
 677       }
 678     }
 679   }
 680 
 681   if (_with_locked_monitors) {
 682     // Iterate inflated monitors and find monitors locked by this thread
 683     // not found in the stack
 684     InflatedMonitorsClosure imc(_thread, this);
 685     ObjectSynchronizer::monitors_iterate(&amp;imc);
 686   }
 687 }
 688 
 689 
 690 bool ThreadStackTrace::is_owned_monitor_on_stack(oop object) {
 691   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 692 
 693   bool found = false;
 694   int num_frames = get_stack_depth();
 695   for (int depth = 0; depth &lt; num_frames; depth++) {
 696     StackFrameInfo* frame = stack_frame_at(depth);
 697     int len = frame-&gt;num_locked_monitors();
 698     GrowableArray&lt;OopHandle&gt;* locked_monitors = frame-&gt;locked_monitors();
 699     for (int j = 0; j &lt; len; j++) {
 700       oop monitor = locked_monitors-&gt;at(j).resolve();
 701       assert(monitor != NULL, &quot;must be a Java object&quot;);
 702       if (monitor == object) {
 703         found = true;
 704         break;
 705       }
 706     }
 707   }
 708   return found;
 709 }
 710 
 711 Handle ThreadStackTrace::allocate_fill_stack_trace_element_array(TRAPS) {
 712   InstanceKlass* ik = SystemDictionary::StackTraceElement_klass();
 713   assert(ik != NULL, &quot;must be loaded in 1.4+&quot;);
 714 
 715   // Allocate an array of java/lang/StackTraceElement object
 716   objArrayOop ste = oopFactory::new_objArray(ik, _depth, CHECK_NH);
 717   objArrayHandle backtrace(THREAD, ste);
 718   for (int j = 0; j &lt; _depth; j++) {
 719     StackFrameInfo* frame = _frames-&gt;at(j);
 720     methodHandle mh(THREAD, frame-&gt;method());
 721     oop element = java_lang_StackTraceElement::create(mh, frame-&gt;bci(), CHECK_NH);
 722     backtrace-&gt;obj_at_put(j, element);
 723   }
 724   return backtrace;
 725 }
 726 
 727 void ThreadStackTrace::add_stack_frame(javaVFrame* jvf) {
 728   StackFrameInfo* frame = new StackFrameInfo(jvf, _with_locked_monitors);
 729   _frames-&gt;append(frame);
 730   _depth++;
 731 }
 732 
 733 void ThreadStackTrace::metadata_do(void f(Metadata*)) {
 734   int length = _frames-&gt;length();
 735   for (int i = 0; i &lt; length; i++) {
 736     _frames-&gt;at(i)-&gt;metadata_do(f);
 737   }
 738 }
 739 
 740 
 741 ConcurrentLocksDump::~ConcurrentLocksDump() {
 742   if (_retain_map_on_free) {
 743     return;
 744   }
 745 
 746   for (ThreadConcurrentLocks* t = _map; t != NULL;)  {
 747     ThreadConcurrentLocks* tcl = t;
 748     t = t-&gt;next();
 749     delete tcl;
 750   }
 751 }
 752 
 753 void ConcurrentLocksDump::dump_at_safepoint() {
 754   // dump all locked concurrent locks
 755   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 756 
 757   GrowableArray&lt;oop&gt;* aos_objects = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;oop&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 758 
 759   // Find all instances of AbstractOwnableSynchronizer
 760   HeapInspection::find_instances_at_safepoint(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass(),
 761                                               aos_objects);
 762   // Build a map of thread to its owned AQS locks
 763   build_map(aos_objects);
 764 
 765   delete aos_objects;
 766 }
 767 
 768 
 769 // build a map of JavaThread to all its owned AbstractOwnableSynchronizer
 770 void ConcurrentLocksDump::build_map(GrowableArray&lt;oop&gt;* aos_objects) {
 771   int length = aos_objects-&gt;length();
 772   for (int i = 0; i &lt; length; i++) {
 773     oop o = aos_objects-&gt;at(i);
 774     oop owner_thread_obj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(o);
 775     if (owner_thread_obj != NULL) {
 776       // See comments in ThreadConcurrentLocks to see how this
 777       // JavaThread* is protected.
 778       JavaThread* thread = java_lang_Thread::thread(owner_thread_obj);
 779       assert(o-&gt;is_instance(), &quot;Must be an instanceOop&quot;);
 780       add_lock(thread, (instanceOop) o);
 781     }
 782   }
 783 }
 784 
 785 void ConcurrentLocksDump::add_lock(JavaThread* thread, instanceOop o) {
 786   ThreadConcurrentLocks* tcl = thread_concurrent_locks(thread);
 787   if (tcl != NULL) {
 788     tcl-&gt;add_lock(o);
 789     return;
 790   }
 791 
 792   // First owned lock found for this thread
 793   tcl = new ThreadConcurrentLocks(thread);
 794   tcl-&gt;add_lock(o);
 795   if (_map == NULL) {
 796     _map = tcl;
 797   } else {
 798     _last-&gt;set_next(tcl);
 799   }
 800   _last = tcl;
 801 }
 802 
 803 ThreadConcurrentLocks* ConcurrentLocksDump::thread_concurrent_locks(JavaThread* thread) {
 804   for (ThreadConcurrentLocks* tcl = _map; tcl != NULL; tcl = tcl-&gt;next()) {
 805     if (tcl-&gt;java_thread() == thread) {
 806       return tcl;
 807     }
 808   }
 809   return NULL;
 810 }
 811 
 812 void ConcurrentLocksDump::print_locks_on(JavaThread* t, outputStream* st) {
 813   st-&gt;print_cr(&quot;   Locked ownable synchronizers:&quot;);
 814   ThreadConcurrentLocks* tcl = thread_concurrent_locks(t);
 815   GrowableArray&lt;OopHandle&gt;* locks = (tcl != NULL ? tcl-&gt;owned_locks() : NULL);
 816   if (locks == NULL || locks-&gt;is_empty()) {
 817     st-&gt;print_cr(&quot;\t- None&quot;);
 818     st-&gt;cr();
 819     return;
 820   }
 821 
 822   for (int i = 0; i &lt; locks-&gt;length(); i++) {
 823     oop obj = locks-&gt;at(i).resolve();
 824     st-&gt;print_cr(&quot;\t- &lt;&quot; INTPTR_FORMAT &quot;&gt; (a %s)&quot;, p2i(obj), obj-&gt;klass()-&gt;external_name());
 825   }
 826   st-&gt;cr();
 827 }
 828 
 829 ThreadConcurrentLocks::ThreadConcurrentLocks(JavaThread* thread) {
 830   _thread = thread;
 831   _owned_locks = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;OopHandle&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 832   _next = NULL;
 833 }
 834 
 835 ThreadConcurrentLocks::~ThreadConcurrentLocks() {
 836   for (int i = 0; i &lt; _owned_locks-&gt;length(); i++) {
 837     _owned_locks-&gt;at(i).release(Universe::vm_global());
 838   }
 839   delete _owned_locks;
 840 }
 841 
 842 void ThreadConcurrentLocks::add_lock(instanceOop o) {
 843   _owned_locks-&gt;append(OopHandle(Universe::vm_global(), o));
 844 }
 845 
 846 ThreadStatistics::ThreadStatistics() {
 847   _contended_enter_count = 0;
 848   _monitor_wait_count = 0;
 849   _sleep_count = 0;
 850   _count_pending_reset = false;
 851   _timer_pending_reset = false;
 852   memset((void*) _perf_recursion_counts, 0, sizeof(_perf_recursion_counts));
 853 }
 854 
 855 oop ThreadSnapshot::threadObj() const { return _threadObj.resolve(); }
 856 
 857 void ThreadSnapshot::initialize(ThreadsList * t_list, JavaThread* thread) {
 858   _thread = thread;
 859   oop threadObj = thread-&gt;threadObj();
 860   _threadObj = OopHandle(Universe::vm_global(), threadObj);
 861 
 862   ThreadStatistics* stat = thread-&gt;get_thread_stat();
 863   _contended_enter_ticks = stat-&gt;contended_enter_ticks();
 864   _contended_enter_count = stat-&gt;contended_enter_count();
 865   _monitor_wait_ticks = stat-&gt;monitor_wait_ticks();
 866   _monitor_wait_count = stat-&gt;monitor_wait_count();
 867   _sleep_ticks = stat-&gt;sleep_ticks();
 868   _sleep_count = stat-&gt;sleep_count();
 869 
 870   _thread_status = java_lang_Thread::get_thread_status(threadObj);
 871   _is_ext_suspended = thread-&gt;is_being_ext_suspended();
 872   _is_in_native = (thread-&gt;thread_state() == _thread_in_native);
 873 
 874   oop blocker_object = NULL;
 875   oop blocker_object_owner = NULL;
 876 
 877   if (_thread_status == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER ||
 878       _thread_status == java_lang_Thread::IN_OBJECT_WAIT ||
 879       _thread_status == java_lang_Thread::IN_OBJECT_WAIT_TIMED) {
 880 
 881     Handle obj = ThreadService::get_current_contended_monitor(thread);
 882     if (obj() == NULL) {
 883       // monitor no longer exists; thread is not blocked
 884       _thread_status = java_lang_Thread::RUNNABLE;
 885     } else {
 886       blocker_object = obj();
 887       JavaThread* owner = ObjectSynchronizer::get_lock_owner(t_list, obj);
 888       if ((owner == NULL &amp;&amp; _thread_status == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER)
 889           || (owner != NULL &amp;&amp; owner-&gt;is_attaching_via_jni())) {
 890         // ownership information of the monitor is not available
 891         // (may no longer be owned or releasing to some other thread)
 892         // make this thread in RUNNABLE state.
 893         // And when the owner thread is in attaching state, the java thread
 894         // is not completely initialized. For example thread name and id
 895         // and may not be set, so hide the attaching thread.
 896         _thread_status = java_lang_Thread::RUNNABLE;
 897         blocker_object = NULL;
 898       } else if (owner != NULL) {
 899         blocker_object_owner = owner-&gt;threadObj();
 900       }
 901     }
 902   }
 903 
 904   // Support for JSR-166 locks
 905   if (_thread_status == java_lang_Thread::PARKED || _thread_status == java_lang_Thread::PARKED_TIMED) {
 906     blocker_object = thread-&gt;current_park_blocker();
 907     if (blocker_object != NULL &amp;&amp; blocker_object-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {
 908       blocker_object_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(blocker_object);
 909     }
 910   }
 911 
 912   if (blocker_object != NULL) {
 913     _blocker_object = OopHandle(Universe::vm_global(), blocker_object);
 914   }
 915   if (blocker_object_owner != NULL) {
 916     _blocker_object_owner = OopHandle(Universe::vm_global(), blocker_object_owner);
 917   }
 918 }
 919 
 920 oop ThreadSnapshot::blocker_object() const           { return _blocker_object.resolve(); }
 921 oop ThreadSnapshot::blocker_object_owner() const     { return _blocker_object_owner.resolve(); }
 922 
 923 ThreadSnapshot::~ThreadSnapshot() {
 924   _blocker_object.release(Universe::vm_global());
 925   _blocker_object_owner.release(Universe::vm_global());
 926   _threadObj.release(Universe::vm_global());
 927 
 928   delete _stack_trace;
 929   delete _concurrent_locks;
 930 }
 931 
 932 void ThreadSnapshot::dump_stack_at_safepoint(int max_depth, bool with_locked_monitors) {
 933   _stack_trace = new ThreadStackTrace(_thread, with_locked_monitors);
 934   _stack_trace-&gt;dump_stack_at_safepoint(max_depth);
 935 }
 936 
 937 
 938 void ThreadSnapshot::metadata_do(void f(Metadata*)) {
 939   if (_stack_trace != NULL) {
 940     _stack_trace-&gt;metadata_do(f);
 941   }
 942 }
 943 
 944 
 945 DeadlockCycle::DeadlockCycle() {
 946   _is_deadlock = false;
 947   _threads = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;JavaThread*&gt;(INITIAL_ARRAY_SIZE, mtServiceability);
 948   _next = NULL;
 949 }
 950 
 951 DeadlockCycle::~DeadlockCycle() {
 952   delete _threads;
 953 }
 954 
 955 void DeadlockCycle::print_on_with(ThreadsList * t_list, outputStream* st) const {
 956   st-&gt;cr();
 957   st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
 958   st-&gt;print(&quot;=============================&quot;);
 959 
 960   JavaThread* currentThread;
 961   JvmtiRawMonitor* waitingToLockRawMonitor;
 962   oop waitingToLockBlocker;
 963   int len = _threads-&gt;length();
 964   for (int i = 0; i &lt; len; i++) {
 965     currentThread = _threads-&gt;at(i);
 966     // The ObjectMonitor* can&#39;t be async deflated since we are at a safepoint.
 967     ObjectMonitor* waitingToLockMonitor = currentThread-&gt;current_pending_monitor();
 968     waitingToLockRawMonitor = currentThread-&gt;current_pending_raw_monitor();
 969     waitingToLockBlocker = currentThread-&gt;current_park_blocker();
 970     st-&gt;cr();
 971     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
 972     const char* owner_desc = &quot;,\n  which is held by&quot;;
 973 
 974     // Note: As the JVM TI &quot;monitor contended enter&quot; event callback is executed after ObjectMonitor
 975     // sets the current pending monitor, it is possible to then see a pending raw monitor as well.
 976     if (waitingToLockRawMonitor != NULL) {
 977       st-&gt;print(&quot;  waiting to lock JVM TI raw monitor &quot; INTPTR_FORMAT, p2i(waitingToLockRawMonitor));
 978       Thread* owner = waitingToLockRawMonitor-&gt;owner();
 979       // Could be NULL as the raw monitor could be released at any time if held by non-JavaThread
 980       if (owner != NULL) {
 981         if (owner-&gt;is_Java_thread()) {
 982           currentThread = (JavaThread*) owner;
 983           st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());
 984         } else {
 985           st-&gt;print_cr(&quot;,\n  which has now been released&quot;);
 986         }
 987       } else {
 988         st-&gt;print_cr(&quot;%s non-Java thread=&quot; PTR_FORMAT, owner_desc, p2i(owner));
 989       }
 990     }
 991 
 992     if (waitingToLockMonitor != NULL) {
 993       st-&gt;print(&quot;  waiting to lock monitor &quot; INTPTR_FORMAT, p2i(waitingToLockMonitor));
 994       oop obj = (oop)waitingToLockMonitor-&gt;object();
 995       st-&gt;print(&quot; (object &quot; INTPTR_FORMAT &quot;, a %s)&quot;, p2i(obj),
 996                  obj-&gt;klass()-&gt;external_name());
 997 
 998       if (!currentThread-&gt;current_pending_monitor_is_from_java()) {
 999         owner_desc = &quot;\n  in JNI, which is held by&quot;;
1000       }
1001       currentThread = Threads::owning_thread_from_monitor_owner(t_list,
1002                                                                 (address)waitingToLockMonitor-&gt;owner());
1003       if (currentThread == NULL) {
1004         // The deadlock was detected at a safepoint so the JavaThread
1005         // that owns waitingToLockMonitor should be findable, but
1006         // if it is not findable, then the previous currentThread is
1007         // blocked permanently.
1008         st-&gt;print_cr(&quot;%s UNKNOWN_owner_addr=&quot; PTR_FORMAT, owner_desc,
1009                   p2i(waitingToLockMonitor-&gt;owner()));
1010         continue;
1011       }
1012     } else {
1013       st-&gt;print(&quot;  waiting for ownable synchronizer &quot; INTPTR_FORMAT &quot;, (a %s)&quot;,
1014                 p2i(waitingToLockBlocker),
1015                 waitingToLockBlocker-&gt;klass()-&gt;external_name());
1016       assert(waitingToLockBlocker-&gt;is_a(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass()),
1017              &quot;Must be an AbstractOwnableSynchronizer&quot;);
1018       oop ownerObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(waitingToLockBlocker);
1019       currentThread = java_lang_Thread::thread(ownerObj);
1020       assert(currentThread != NULL, &quot;AbstractOwnableSynchronizer owning thread is unexpectedly NULL&quot;);
1021     }
1022     st-&gt;print_cr(&quot;%s \&quot;%s\&quot;&quot;, owner_desc, currentThread-&gt;get_thread_name());
1023   }
1024 
1025   st-&gt;cr();
1026 
1027   // Print stack traces
1028   bool oldJavaMonitorsInStackTrace = JavaMonitorsInStackTrace;
1029   JavaMonitorsInStackTrace = true;
1030   st-&gt;print_cr(&quot;Java stack information for the threads listed above:&quot;);
1031   st-&gt;print_cr(&quot;===================================================&quot;);
1032   for (int j = 0; j &lt; len; j++) {
1033     currentThread = _threads-&gt;at(j);
1034     st-&gt;print_cr(&quot;\&quot;%s\&quot;:&quot;, currentThread-&gt;get_thread_name());
1035     currentThread-&gt;print_stack_on(st);
1036   }
1037   JavaMonitorsInStackTrace = oldJavaMonitorsInStackTrace;
1038 }
1039 
1040 ThreadsListEnumerator::ThreadsListEnumerator(Thread* cur_thread,
1041                                              bool include_jvmti_agent_threads,
1042                                              bool include_jni_attaching_threads) {
1043   assert(cur_thread == Thread::current(), &quot;Check current thread&quot;);
1044 
1045   int init_size = ThreadService::get_live_thread_count();
1046   _threads_array = new GrowableArray&lt;instanceHandle&gt;(init_size);
1047 
1048   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
1049     // skips JavaThreads in the process of exiting
1050     // and also skips VM internal JavaThreads
1051     // Threads in _thread_new or _thread_new_trans state are included.
1052     // i.e. threads have been started but not yet running.
1053     if (jt-&gt;threadObj() == NULL   ||
1054         jt-&gt;is_exiting() ||
1055         !java_lang_Thread::is_alive(jt-&gt;threadObj())   ||
1056         jt-&gt;is_hidden_from_external_view()) {
1057       continue;
1058     }
1059 
1060     // skip agent threads
1061     if (!include_jvmti_agent_threads &amp;&amp; jt-&gt;is_jvmti_agent_thread()) {
1062       continue;
1063     }
1064 
1065     // skip jni threads in the process of attaching
1066     if (!include_jni_attaching_threads &amp;&amp; jt-&gt;is_attaching_via_jni()) {
1067       continue;
1068     }
1069 
1070     instanceHandle h(cur_thread, (instanceOop) jt-&gt;threadObj());
1071     _threads_array-&gt;append(h);
1072   }
1073 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>