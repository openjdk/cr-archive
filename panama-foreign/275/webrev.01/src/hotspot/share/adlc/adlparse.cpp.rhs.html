<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/adlc/adlparse.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // ADLPARSE.CPP - Architecture Description Language Parser
  26 // Authors: Chris Vick and Mike Paleczny
  27 #include &quot;adlc.hpp&quot;
  28 
  29 //----------------------------ADLParser----------------------------------------
  30 // Create a new ADL parser
  31 ADLParser::ADLParser(FileBuff&amp; buffer, ArchDesc&amp; archDesc)
  32   : _buf(buffer), _AD(archDesc),
  33     _globalNames(archDesc.globalNames()) {
  34   _AD._syntax_errs = _AD._semantic_errs = 0; // No errors so far this file
  35   _AD._warnings    = 0;                      // No warnings either
  36   _curline         = _ptr = NULL;            // No pointers into buffer yet
  37 
  38   _preproc_depth = 0;
  39   _preproc_not_taken = 0;
  40 
  41   // Delimit command-line definitions from in-file definitions:
  42   _AD._preproc_list.add_signal();
  43 }
  44 
  45 //------------------------------~ADLParser-------------------------------------
  46 // Delete an ADL parser.
  47 ADLParser::~ADLParser() {
  48   if (!_AD._quiet_mode)
  49     fprintf(stderr,&quot;---------------------------- Errors and Warnings ----------------------------\n&quot;);
  50 #ifndef ASSERT
  51   if (!_AD._quiet_mode) {
  52     fprintf(stderr, &quot;**************************************************************\n&quot;);
  53     fprintf(stderr, &quot;***** WARNING: ASSERT is undefined, assertions disabled. *****\n&quot;);
  54     fprintf(stderr, &quot;**************************************************************\n&quot;);
  55   }
  56 #endif
  57   if( _AD._syntax_errs + _AD._semantic_errs + _AD._warnings == 0 ) {
  58     if (!_AD._quiet_mode)
  59       fprintf(stderr,&quot;No errors or warnings to report from phase-1 parse.\n&quot; );
  60   }
  61   else {
  62     if( _AD._syntax_errs ) {      // Any syntax errors?
  63       fprintf(stderr,&quot;%s:  Found %d syntax error&quot;, _buf._fp-&gt;_name, _AD._syntax_errs);
  64       if( _AD._syntax_errs &gt; 1 ) fprintf(stderr,&quot;s.\n\n&quot;);
  65       else fprintf(stderr,&quot;.\n\n&quot;);
  66     }
  67     if( _AD._semantic_errs ) {    // Any semantic errors?
  68       fprintf(stderr,&quot;%s:  Found %d semantic error&quot;, _buf._fp-&gt;_name, _AD._semantic_errs);
  69       if( _AD._semantic_errs &gt; 1 ) fprintf(stderr,&quot;s.\n\n&quot;);
  70       else fprintf(stderr,&quot;.\n\n&quot;);
  71     }
  72     if( _AD._warnings ) {         // Any warnings?
  73       fprintf(stderr,&quot;%s:  Found %d warning&quot;, _buf._fp-&gt;_name, _AD._warnings);
  74       if( _AD._warnings &gt; 1 ) fprintf(stderr,&quot;s.\n\n&quot;);
  75       else fprintf(stderr,&quot;.\n\n&quot;);
  76     }
  77   }
  78   if (!_AD._quiet_mode)
  79     fprintf(stderr,&quot;-----------------------------------------------------------------------------\n&quot;);
  80   _AD._TotalLines += linenum()-1;     // -1 for overshoot in &quot;nextline&quot; routine
  81 
  82   // Write out information we have stored
  83   // // UNIXism == fsync(stderr);
  84 }
  85 
  86 //------------------------------parse------------------------------------------
  87 // Each top-level keyword should appear as the first non-whitespace on a line.
  88 //
  89 void ADLParser::parse() {
  90   char *ident;
  91 
  92   // Iterate over the lines in the file buffer parsing Level 1 objects
  93   for( next_line(); _curline != NULL; next_line()) {
  94     _ptr = _curline;             // Reset ptr to start of new line
  95     skipws();                    // Skip any leading whitespace
  96     ident = get_ident();         // Get first token
  97     if (ident == NULL) {         // Empty line
  98       continue;                  // Get the next line
  99     }
 100          if (!strcmp(ident, &quot;instruct&quot;))   instr_parse();
 101     else if (!strcmp(ident, &quot;operand&quot;))    oper_parse();
 102     else if (!strcmp(ident, &quot;opclass&quot;))    opclass_parse();
 103     else if (!strcmp(ident, &quot;ins_attrib&quot;)) ins_attr_parse();
 104     else if (!strcmp(ident, &quot;op_attrib&quot;))  op_attr_parse();
 105     else if (!strcmp(ident, &quot;source&quot;))     source_parse();
 106     else if (!strcmp(ident, &quot;source_hpp&quot;)) source_hpp_parse();
 107     else if (!strcmp(ident, &quot;register&quot;))   reg_parse();
 108     else if (!strcmp(ident, &quot;frame&quot;))      frame_parse();
 109     else if (!strcmp(ident, &quot;encode&quot;))     encode_parse();
 110     else if (!strcmp(ident, &quot;pipeline&quot;))   pipe_parse();
 111     else if (!strcmp(ident, &quot;definitions&quot;)) definitions_parse();
 112     else if (!strcmp(ident, &quot;peephole&quot;))   peep_parse();
 113     else if (!strcmp(ident, &quot;#line&quot;))      preproc_line();
 114     else if (!strcmp(ident, &quot;#define&quot;))    preproc_define();
 115     else if (!strcmp(ident, &quot;#undef&quot;))     preproc_undef();
 116     else {
 117       parse_err(SYNERR, &quot;expected one of - instruct, operand, ins_attrib, op_attrib, source, register, pipeline, encode\n     Found %s&quot;,ident);
 118     }
 119   }
 120   // Add reg_class spill_regs after parsing.
 121   RegisterForm *regBlock = _AD.get_registers();
 122   if (regBlock == NULL) {
 123     parse_err(SEMERR, &quot;Did not declare &#39;register&#39; definitions&quot;);
 124   }
 125   regBlock-&gt;addSpillRegClass();
 126   regBlock-&gt;addDynamicRegClass();
 127 
 128   // Done with parsing, check consistency.
 129 
 130   if (_preproc_depth != 0) {
 131     parse_err(SYNERR, &quot;End of file inside #ifdef&quot;);
 132   }
 133 
 134   // AttributeForms ins_cost and op_cost must be defined for default behaviour
 135   if (_globalNames[AttributeForm::_ins_cost] == NULL) {
 136     parse_err(SEMERR, &quot;Did not declare &#39;ins_cost&#39; attribute&quot;);
 137   }
 138   if (_globalNames[AttributeForm::_op_cost] == NULL) {
 139     parse_err(SEMERR, &quot;Did not declare &#39;op_cost&#39; attribute&quot;);
 140   }
 141 }
 142 
 143 // ******************** Private Level 1 Parse Functions ********************
 144 //------------------------------instr_parse------------------------------------
 145 // Parse the contents of an instruction definition, build the InstructForm to
 146 // represent that instruction, and add it to the InstructForm list.
 147 void ADLParser::instr_parse(void) {
 148   char          *ident;
 149   InstructForm  *instr;
 150   MatchRule     *rule;
 151   int            match_rules_cnt = 0;
 152 
 153   // First get the name of the instruction
 154   if( (ident = get_unique_ident(_globalNames,&quot;instruction&quot;)) == NULL )
 155     return;
 156   instr = new InstructForm(ident); // Create new instruction form
 157   instr-&gt;_linenum = linenum();
 158   _globalNames.Insert(ident, instr); // Add name to the name table
 159   // Debugging Stuff
 160   if (_AD._adl_debug &gt; 1)
 161     fprintf(stderr,&quot;Parsing Instruction Form %s\n&quot;, ident);
 162 
 163   // Then get the operands
 164   skipws();
 165   if (_curchar != &#39;(&#39;) {
 166     parse_err(SYNERR, &quot;missing &#39;(&#39; in instruct definition\n&quot;);
 167   }
 168   // Parse the operand list
 169   else get_oplist(instr-&gt;_parameters, instr-&gt;_localNames);
 170   skipws();                        // Skip leading whitespace
 171   // Check for block delimiter
 172   if ( (_curchar != &#39;%&#39;)
 173        || ( next_char(),  (_curchar != &#39;{&#39;)) ) {
 174     parse_err(SYNERR, &quot;missing &#39;%%{&#39; in instruction definition\n&quot;);
 175     return;
 176   }
 177   next_char();                     // Maintain the invariant
 178   do {
 179     ident = get_ident();           // Grab next identifier
 180     if (ident == NULL) {
 181       parse_err(SYNERR, &quot;keyword identifier expected at %c\n&quot;, _curchar);
 182       continue;
 183     }
 184     if      (!strcmp(ident, &quot;predicate&quot;)) instr-&gt;_predicate = pred_parse();
 185     else if      (!strcmp(ident, &quot;match&quot;)) {
 186       // Allow one instruction have several match rules.
 187       rule = instr-&gt;_matrule;
 188       if (rule == NULL) {
 189         // This is first match rule encountered
 190         rule = match_parse(instr-&gt;_localNames);
 191         if (rule) {
 192           instr-&gt;_matrule = rule;
 193           // Special case the treatment of Control instructions.
 194           if( instr-&gt;is_ideal_control() ) {
 195             // Control instructions return a special result, &#39;Universe&#39;
 196             rule-&gt;_result = &quot;Universe&quot;;
 197           }
 198           // Check for commutative operations with tree operands.
 199           matchrule_clone_and_swap(rule, instr-&gt;_ident, match_rules_cnt);
 200         }
 201       } else {
 202         // Find the end of the match rule list
 203         while (rule-&gt;_next != NULL)
 204           rule = rule-&gt;_next;
 205         // Add the new match rule to the list
 206         rule-&gt;_next = match_parse(instr-&gt;_localNames);
 207         if (rule-&gt;_next) {
 208           rule = rule-&gt;_next;
 209           if( instr-&gt;is_ideal_control() ) {
 210             parse_err(SYNERR, &quot;unique match rule expected for %s\n&quot;, rule-&gt;_name);
 211             return;
 212           }
 213           assert(match_rules_cnt &lt; 100,&quot; too many match rule clones&quot;);
 214           char* buf = (char*) AllocateHeap(strlen(instr-&gt;_ident) + 4);
 215           sprintf(buf, &quot;%s_%d&quot;, instr-&gt;_ident, match_rules_cnt++);
 216           rule-&gt;_result = buf;
 217           // Check for commutative operations with tree operands.
 218           matchrule_clone_and_swap(rule, instr-&gt;_ident, match_rules_cnt);
 219         }
 220       }
 221     }
 222     else if (!strcmp(ident, &quot;encode&quot;))  {
 223       parse_err(SYNERR, &quot;Instructions specify ins_encode, not encode\n&quot;);
 224     }
 225     else if (!strcmp(ident, &quot;ins_encode&quot;))       ins_encode_parse(*instr);
 226     // Parse late expand keyword.
 227     else if (!strcmp(ident, &quot;postalloc_expand&quot;)) postalloc_expand_parse(*instr);
 228     else if (!strcmp(ident, &quot;opcode&quot;))           instr-&gt;_opcode    = opcode_parse(instr);
 229     else if (!strcmp(ident, &quot;size&quot;))             instr-&gt;_size      = size_parse(instr);
 230     else if (!strcmp(ident, &quot;effect&quot;))           effect_parse(instr);
 231     else if (!strcmp(ident, &quot;expand&quot;))           instr-&gt;_exprule   = expand_parse(instr);
 232     else if (!strcmp(ident, &quot;rewrite&quot;))          instr-&gt;_rewrule   = rewrite_parse();
 233     else if (!strcmp(ident, &quot;constraint&quot;)) {
 234       parse_err(SYNERR, &quot;Instructions do not specify a constraint\n&quot;);
 235     }
 236     else if (!strcmp(ident, &quot;construct&quot;)) {
 237       parse_err(SYNERR, &quot;Instructions do not specify a construct\n&quot;);
 238     }
 239     else if (!strcmp(ident, &quot;format&quot;))           instr-&gt;_format    = format_parse();
 240     else if (!strcmp(ident, &quot;interface&quot;)) {
 241       parse_err(SYNERR, &quot;Instructions do not specify an interface\n&quot;);
 242     }
 243     else if (!strcmp(ident, &quot;ins_pipe&quot;))        ins_pipe_parse(*instr);
 244     else {  // Done with staticly defined parts of instruction definition
 245       // Check identifier to see if it is the name of an attribute
 246       const Form    *form = _globalNames[ident];
 247       AttributeForm *attr = form ? form-&gt;is_attribute() : NULL;
 248       if (attr &amp;&amp; (attr-&gt;_atype == INS_ATTR)) {
 249         // Insert the new attribute into the linked list.
 250         Attribute *temp = attr_parse(ident);
 251         temp-&gt;_next = instr-&gt;_attribs;
 252         instr-&gt;_attribs = temp;
 253       } else {
 254         parse_err(SYNERR, &quot;expected one of:\n predicate, match, encode, or the name of&quot;
 255                   &quot; an instruction attribute at %s\n&quot;, ident);
 256       }
 257     }
 258     skipws();
 259   } while(_curchar != &#39;%&#39;);
 260   next_char();
 261   if (_curchar != &#39;}&#39;) {
 262     parse_err(SYNERR, &quot;missing &#39;%%}&#39; in instruction definition\n&quot;);
 263     return;
 264   }
 265   // Check for &quot;Set&quot; form of chain rule
 266   adjust_set_rule(instr);
 267   if (_AD._pipeline) {
 268     // No pipe required for late expand.
 269     if (instr-&gt;expands() || instr-&gt;postalloc_expands()) {
 270       if (instr-&gt;_ins_pipe) {
 271         parse_err(WARN, &quot;ins_pipe and expand rule both specified for instruction \&quot;%s\&quot;;&quot;
 272                   &quot; ins_pipe will be unused\n&quot;, instr-&gt;_ident);
 273       }
 274     } else {
 275       if (!instr-&gt;_ins_pipe) {
 276         parse_err(WARN, &quot;No ins_pipe specified for instruction \&quot;%s\&quot;\n&quot;, instr-&gt;_ident);
 277       }
 278     }
 279   }
 280   // Add instruction to tail of instruction list
 281   _AD.addForm(instr);
 282 
 283   // Create instruction form for each additional match rule
 284   rule = instr-&gt;_matrule;
 285   if (rule != NULL) {
 286     rule = rule-&gt;_next;
 287     while (rule != NULL) {
 288       ident = (char*)rule-&gt;_result;
 289       InstructForm *clone = new InstructForm(ident, instr, rule); // Create new instruction form
 290       _globalNames.Insert(ident, clone); // Add name to the name table
 291       // Debugging Stuff
 292       if (_AD._adl_debug &gt; 1)
 293         fprintf(stderr,&quot;Parsing Instruction Form %s\n&quot;, ident);
 294       // Check for &quot;Set&quot; form of chain rule
 295       adjust_set_rule(clone);
 296       // Add instruction to tail of instruction list
 297       _AD.addForm(clone);
 298       rule = rule-&gt;_next;
 299       clone-&gt;_matrule-&gt;_next = NULL; // One match rule per clone
 300     }
 301   }
 302 }
 303 
 304 //------------------------------matchrule_clone_and_swap-----------------------
 305 // Check for commutative operations with subtree operands,
 306 // create clones and swap operands.
 307 void ADLParser::matchrule_clone_and_swap(MatchRule* rule, const char* instr_ident, int&amp; match_rules_cnt) {
 308   // Check for commutative operations with tree operands.
 309   int count = 0;
 310   rule-&gt;count_commutative_op(count);
 311   if (count &gt; 0) {
 312     // Clone match rule and swap commutative operation&#39;s operands.
 313     rule-&gt;matchrule_swap_commutative_op(instr_ident, count, match_rules_cnt);
 314   }
 315 }
 316 
 317 //------------------------------adjust_set_rule--------------------------------
 318 // Check for &quot;Set&quot; form of chain rule
 319 void ADLParser::adjust_set_rule(InstructForm *instr) {
 320   if (instr-&gt;_matrule == NULL || instr-&gt;_matrule-&gt;_rChild == NULL) return;
 321   const char *rch = instr-&gt;_matrule-&gt;_rChild-&gt;_opType;
 322   const Form *frm = _globalNames[rch];
 323   if( (! strcmp(instr-&gt;_matrule-&gt;_opType,&quot;Set&quot;)) &amp;&amp;
 324       frm &amp;&amp; frm-&gt;is_operand() &amp;&amp; (! frm-&gt;ideal_only()) ) {
 325     // Previous implementation, which missed leaP*, but worked for loadCon*
 326     unsigned    position = 0;
 327     const char *result   = NULL;
 328     const char *name     = NULL;
 329     const char *optype   = NULL;
 330     MatchNode  *right    = instr-&gt;_matrule-&gt;_rChild;
 331     if (right-&gt;base_operand(position, _globalNames, result, name, optype)) {
 332       position = 1;
 333       const char *result2  = NULL;
 334       const char *name2    = NULL;
 335       const char *optype2  = NULL;
 336       // Can not have additional base operands in right side of match!
 337       if ( ! right-&gt;base_operand( position, _globalNames, result2, name2, optype2) ) {
 338         if (instr-&gt;_predicate != NULL)
 339           parse_err(SYNERR, &quot;ADLC does not support instruction chain rules with predicates&quot;);
 340         // Chain from input  _ideal_operand_type_,
 341         // Needed for shared roots of match-trees
 342         ChainList *lst = (ChainList *)_AD._chainRules[optype];
 343         if (lst == NULL) {
 344           lst = new ChainList();
 345           _AD._chainRules.Insert(optype, lst);
 346         }
 347         if (!lst-&gt;search(instr-&gt;_matrule-&gt;_lChild-&gt;_opType)) {
 348           const char *cost = instr-&gt;cost();
 349           if (cost == NULL) {
 350             cost = ((AttributeForm*)_globalNames[AttributeForm::_ins_cost])-&gt;_attrdef;
 351           }
 352           // The ADLC does not support chaining from the ideal operand type
 353           // of a predicated user-defined operand
 354           if( frm-&gt;is_operand() == NULL || frm-&gt;is_operand()-&gt;_predicate == NULL ) {
 355             lst-&gt;insert(instr-&gt;_matrule-&gt;_lChild-&gt;_opType,cost,instr-&gt;_ident);
 356           }
 357         }
 358         // Chain from input  _user_defined_operand_type_,
 359         lst = (ChainList *)_AD._chainRules[result];
 360         if (lst == NULL) {
 361           lst = new ChainList();
 362           _AD._chainRules.Insert(result, lst);
 363         }
 364         if (!lst-&gt;search(instr-&gt;_matrule-&gt;_lChild-&gt;_opType)) {
 365           const char *cost = instr-&gt;cost();
 366           if (cost == NULL) {
 367             cost = ((AttributeForm*)_globalNames[AttributeForm::_ins_cost])-&gt;_attrdef;
 368           }
 369           // It is safe to chain from the top-level user-defined operand even
 370           // if it has a predicate, since the predicate is checked before
 371           // the user-defined type is available.
 372           lst-&gt;insert(instr-&gt;_matrule-&gt;_lChild-&gt;_opType,cost,instr-&gt;_ident);
 373         }
 374       } else {
 375         // May have instruction chain rule if root of right-tree is an ideal
 376         OperandForm *rightOp = _globalNames[right-&gt;_opType]-&gt;is_operand();
 377         if( rightOp ) {
 378           const Form *rightRoot = _globalNames[rightOp-&gt;_matrule-&gt;_opType];
 379           if( rightRoot &amp;&amp; rightRoot-&gt;ideal_only() ) {
 380             const char *chain_op = NULL;
 381             if( rightRoot-&gt;is_instruction() )
 382               chain_op = rightOp-&gt;_ident;
 383             if( chain_op ) {
 384               // Look-up the operation in chain rule table
 385               ChainList *lst = (ChainList *)_AD._chainRules[chain_op];
 386               if (lst == NULL) {
 387                 lst = new ChainList();
 388                 _AD._chainRules.Insert(chain_op, lst);
 389               }
 390               // if (!lst-&gt;search(instr-&gt;_matrule-&gt;_lChild-&gt;_opType)) {
 391               const char *cost = instr-&gt;cost();
 392               if (cost == NULL) {
 393                 cost = ((AttributeForm*)_globalNames[AttributeForm::_ins_cost])-&gt;_attrdef;
 394               }
 395               // This chains from a top-level operand whose predicate, if any,
 396               // has been checked.
 397               lst-&gt;insert(instr-&gt;_matrule-&gt;_lChild-&gt;_opType,cost,instr-&gt;_ident);
 398               // }
 399             }
 400           }
 401         }
 402       } // end chain rule from right-tree&#39;s ideal root
 403     }
 404   }
 405 }
 406 
 407 
 408 //------------------------------oper_parse-------------------------------------
 409 void ADLParser::oper_parse(void) {
 410   char          *ident;
 411   OperandForm   *oper;
 412   AttributeForm *attr;
 413   MatchRule     *rule;
 414 
 415   // First get the name of the operand
 416   skipws();
 417   if( (ident = get_unique_ident(_globalNames,&quot;operand&quot;)) == NULL )
 418     return;
 419   oper = new OperandForm(ident);        // Create new operand form
 420   oper-&gt;_linenum = linenum();
 421   _globalNames.Insert(ident, oper); // Add name to the name table
 422 
 423   // Debugging Stuff
 424   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Parsing Operand Form %s\n&quot;, ident);
 425 
 426   // Get the component operands
 427   skipws();
 428   if (_curchar != &#39;(&#39;) {
 429     parse_err(SYNERR, &quot;missing &#39;(&#39; in operand definition\n&quot;);
 430     return;
 431   }
 432   else get_oplist(oper-&gt;_parameters, oper-&gt;_localNames); // Parse the component operand list
 433   skipws();
 434   // Check for block delimiter
 435   if ((_curchar != &#39;%&#39;) || (*(_ptr+1) != &#39;{&#39;)) { // If not open block
 436     parse_err(SYNERR, &quot;missing &#39;%%{&#39; in operand definition\n&quot;);
 437     return;
 438   }
 439   next_char(); next_char();        // Skip over &quot;%{&quot; symbol
 440   do {
 441     ident = get_ident();           // Grab next identifier
 442     if (ident == NULL) {
 443       parse_err(SYNERR, &quot;keyword identifier expected at %c\n&quot;, _curchar);
 444       continue;
 445     }
 446     if      (!strcmp(ident, &quot;predicate&quot;)) oper-&gt;_predicate = pred_parse();
 447     else if (!strcmp(ident, &quot;match&quot;))     {
 448       // Find the end of the match rule list
 449       rule = oper-&gt;_matrule;
 450       if (rule) {
 451         while (rule-&gt;_next) rule = rule-&gt;_next;
 452         // Add the new match rule to the list
 453         rule-&gt;_next = match_parse(oper-&gt;_localNames);
 454         if (rule-&gt;_next) {
 455           rule-&gt;_next-&gt;_result = oper-&gt;_ident;
 456         }
 457       }
 458       else {
 459         // This is first match rule encountered
 460         oper-&gt;_matrule = match_parse(oper-&gt;_localNames);
 461         if (oper-&gt;_matrule) {
 462           oper-&gt;_matrule-&gt;_result = oper-&gt;_ident;
 463         }
 464       }
 465     }
 466     else if (!strcmp(ident, &quot;encode&quot;))    oper-&gt;_interface = interface_parse();
 467     else if (!strcmp(ident, &quot;ins_encode&quot;)) {
 468       parse_err(SYNERR, &quot;Operands specify &#39;encode&#39;, not &#39;ins_encode&#39;\n&quot;);
 469     }
 470     else if (!strcmp(ident, &quot;opcode&quot;))    {
 471       parse_err(SYNERR, &quot;Operands do not specify an opcode\n&quot;);
 472     }
 473     else if (!strcmp(ident, &quot;effect&quot;))    {
 474       parse_err(SYNERR, &quot;Operands do not specify an effect\n&quot;);
 475     }
 476     else if (!strcmp(ident, &quot;expand&quot;))    {
 477       parse_err(SYNERR, &quot;Operands do not specify an expand\n&quot;);
 478     }
 479     else if (!strcmp(ident, &quot;rewrite&quot;))   {
 480       parse_err(SYNERR, &quot;Operands do not specify a rewrite\n&quot;);
 481     }
 482     else if (!strcmp(ident, &quot;constraint&quot;))oper-&gt;_constraint= constraint_parse();
 483     else if (!strcmp(ident, &quot;construct&quot;)) oper-&gt;_construct = construct_parse();
 484     else if (!strcmp(ident, &quot;format&quot;))    oper-&gt;_format    = format_parse();
 485     else if (!strcmp(ident, &quot;interface&quot;)) oper-&gt;_interface = interface_parse();
 486     // Check identifier to see if it is the name of an attribute
 487     else if (((attr = _globalNames[ident]-&gt;is_attribute()) != NULL) &amp;&amp;
 488              (attr-&gt;_atype == OP_ATTR))   oper-&gt;_attribs   = attr_parse(ident);
 489     else {
 490       parse_err(SYNERR, &quot;expected one of - constraint, predicate, match, encode, format, construct, or the name of a defined operand attribute at %s\n&quot;, ident);
 491     }
 492     skipws();
 493   } while(_curchar != &#39;%&#39;);
 494   next_char();
 495   if (_curchar != &#39;}&#39;) {
 496     parse_err(SYNERR, &quot;missing &#39;%%}&#39; in operand definition\n&quot;);
 497     return;
 498   }
 499   // Add operand to tail of operand list
 500   _AD.addForm(oper);
 501 }
 502 
 503 //------------------------------opclass_parse----------------------------------
 504 // Operand Classes are a block with a comma delimited list of operand names
 505 void ADLParser::opclass_parse(void) {
 506   char          *ident;
 507   OpClassForm   *opc;
 508   OperandForm   *opForm;
 509 
 510   // First get the name of the operand class
 511   skipws();
 512   if( (ident = get_unique_ident(_globalNames,&quot;opclass&quot;)) == NULL )
 513     return;
 514   opc = new OpClassForm(ident);             // Create new operand class form
 515   _globalNames.Insert(ident, opc);  // Add name to the name table
 516 
 517   // Debugging Stuff
 518   if (_AD._adl_debug &gt; 1)
 519     fprintf(stderr,&quot;Parsing Operand Class Form %s\n&quot;, ident);
 520 
 521   // Get the list of operands
 522   skipws();
 523   if (_curchar != &#39;(&#39;) {
 524     parse_err(SYNERR, &quot;missing &#39;(&#39; in operand definition\n&quot;);
 525     return;
 526   }
 527   do {
 528     next_char();                            // Skip past open paren or comma
 529     ident = get_ident();                    // Grab next identifier
 530     if (ident == NULL) {
 531       parse_err(SYNERR, &quot;keyword identifier expected at %c\n&quot;, _curchar);
 532       continue;
 533     }
 534     // Check identifier to see if it is the name of an operand
 535     const Form *form = _globalNames[ident];
 536     opForm     = form ? form-&gt;is_operand() : NULL;
 537     if ( opForm ) {
 538       opc-&gt;_oplst.addName(ident);           // Add operand to opclass list
 539       opForm-&gt;_classes.addName(opc-&gt;_ident);// Add opclass to operand list
 540     }
 541     else {
 542       parse_err(SYNERR, &quot;expected name of a defined operand at %s\n&quot;, ident);
 543     }
 544     skipws();                               // skip trailing whitespace
 545   } while (_curchar == &#39;,&#39;);                // Check for the comma
 546   // Check for closing &#39;)&#39;
 547   if (_curchar != &#39;)&#39;) {
 548     parse_err(SYNERR, &quot;missing &#39;)&#39; or &#39;,&#39; in opclass definition\n&quot;);
 549     return;
 550   }
 551   next_char();                              // Consume the &#39;)&#39;
 552   skipws();
 553   // Check for closing &#39;;&#39;
 554   if (_curchar != &#39;;&#39;) {
 555     parse_err(SYNERR, &quot;missing &#39;;&#39; in opclass definition\n&quot;);
 556     return;
 557   }
 558   next_char();                             // Consume the &#39;;&#39;
 559   // Add operand to tail of operand list
 560   _AD.addForm(opc);
 561 }
 562 
 563 //------------------------------ins_attr_parse---------------------------------
 564 void ADLParser::ins_attr_parse(void) {
 565   char          *ident;
 566   char          *aexpr;
 567   AttributeForm *attrib;
 568 
 569   // get name for the instruction attribute
 570   skipws();                      // Skip leading whitespace
 571   if( (ident = get_unique_ident(_globalNames,&quot;inst_attrib&quot;)) == NULL )
 572     return;
 573   // Debugging Stuff
 574   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Parsing Ins_Attribute Form %s\n&quot;, ident);
 575 
 576   // Get default value of the instruction attribute
 577   skipws();                      // Skip whitespace
 578   if ((aexpr = get_paren_expr(&quot;attribute default expression string&quot;)) == NULL) {
 579     parse_err(SYNERR, &quot;missing &#39;(&#39; in ins_attrib definition\n&quot;);
 580     return;
 581   }
 582   // Debug Stuff
 583   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Attribute Expression: %s\n&quot;, aexpr);
 584 
 585   // Check for terminator
 586   if (_curchar != &#39;;&#39;) {
 587     parse_err(SYNERR, &quot;missing &#39;;&#39; in ins_attrib definition\n&quot;);
 588     return;
 589   }
 590   next_char();                    // Advance past the &#39;;&#39;
 591 
 592   // Construct the attribute, record global name, and store in ArchDesc
 593   attrib = new AttributeForm(ident, INS_ATTR, aexpr);
 594   _globalNames.Insert(ident, attrib);  // Add name to the name table
 595   _AD.addForm(attrib);
 596 }
 597 
 598 //------------------------------op_attr_parse----------------------------------
 599 void ADLParser::op_attr_parse(void) {
 600   char          *ident;
 601   char          *aexpr;
 602   AttributeForm *attrib;
 603 
 604   // get name for the operand attribute
 605   skipws();                      // Skip leading whitespace
 606   if( (ident = get_unique_ident(_globalNames,&quot;op_attrib&quot;)) == NULL )
 607     return;
 608   // Debugging Stuff
 609   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Parsing Op_Attribute Form %s\n&quot;, ident);
 610 
 611   // Get default value of the instruction attribute
 612   skipws();                      // Skip whitespace
 613   if ((aexpr = get_paren_expr(&quot;attribute default expression string&quot;)) == NULL) {
 614     parse_err(SYNERR, &quot;missing &#39;(&#39; in op_attrib definition\n&quot;);
 615     return;
 616   }
 617   // Debug Stuff
 618   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Attribute Expression: %s\n&quot;, aexpr);
 619 
 620   // Check for terminator
 621   if (_curchar != &#39;;&#39;) {
 622     parse_err(SYNERR, &quot;missing &#39;;&#39; in op_attrib definition\n&quot;);
 623     return;
 624   }
 625   next_char();                    // Advance past the &#39;;&#39;
 626 
 627   // Construct the attribute, record global name, and store in ArchDesc
 628   attrib = new AttributeForm(ident, OP_ATTR, aexpr);
 629   _globalNames.Insert(ident, attrib);
 630   _AD.addForm(attrib);
 631 }
 632 
 633 //------------------------------definitions_parse-----------------------------------
 634 void ADLParser::definitions_parse(void) {
 635   skipws();                       // Skip leading whitespace
 636   if (_curchar == &#39;%&#39; &amp;&amp; *(_ptr+1) == &#39;{&#39;) {
 637     next_char(); next_char();     // Skip &quot;%{&quot;
 638     skipws();
 639     while (_curchar != &#39;%&#39; &amp;&amp; *(_ptr+1) != &#39;}&#39;) {
 640       // Process each definition until finding closing string &quot;%}&quot;
 641       char *token = get_ident();
 642       if (token == NULL) {
 643         parse_err(SYNERR, &quot;missing identifier inside definitions block.\n&quot;);
 644         return;
 645       }
 646       if (strcmp(token,&quot;int_def&quot;)==0)     { int_def_parse(); }
 647       // if (strcmp(token,&quot;str_def&quot;)==0)   { str_def_parse(); }
 648       skipws();
 649     }
 650   }
 651   else {
 652     parse_err(SYNERR, &quot;Missing %%{ ... %%} block after definitions keyword.\n&quot;);
 653     return;
 654   }
 655 }
 656 
 657 //------------------------------int_def_parse----------------------------------
 658 // Parse Example:
 659 // int_def    MEMORY_REF_COST      (         200,  DEFAULT_COST * 2);
 660 // &lt;keyword&gt;  &lt;name&gt;               ( &lt;int_value&gt;,   &lt;description&gt;  );
 661 //
 662 void ADLParser::int_def_parse(void) {
 663   char *name        = NULL;         // Name of definition
 664   char *value       = NULL;         // its value,
 665   int   int_value   = -1;           // positive values only
 666   char *description = NULL;         // textual description
 667 
 668   // Get definition name
 669   skipws();                      // Skip whitespace
 670   name = get_ident();
 671   if (name == NULL) {
 672     parse_err(SYNERR, &quot;missing definition name after int_def\n&quot;);
 673     return;
 674   }
 675 
 676   // Check for value of int_def dname( integer_value [, string_expression ] )
 677   skipws();
 678   if (_curchar == &#39;(&#39;) {
 679 
 680     // Parse the integer value.
 681     next_char();
 682     value = get_ident();
 683     if (value == NULL) {
 684       parse_err(SYNERR, &quot;missing value in int_def\n&quot;);
 685       return;
 686     }
 687     if( !is_int_token(value, int_value) ) {
 688       parse_err(SYNERR, &quot;value in int_def is not recognized as integer\n&quot;);
 689       return;
 690     }
 691     skipws();
 692 
 693     // Check for description
 694     if (_curchar == &#39;,&#39;) {
 695       next_char();   // skip &#39;,&#39;
 696 
 697       description = get_expr(&quot;int_def description&quot;, &quot;)&quot;);
 698       if (description == NULL) {
 699         parse_err(SYNERR, &quot;invalid or missing description in int_def\n&quot;);
 700         return;
 701       }
 702       trim(description);
 703     }
 704 
 705     if (_curchar != &#39;)&#39;) {
 706       parse_err(SYNERR, &quot;missing &#39;)&#39; in register definition statement\n&quot;);
 707       return;
 708     }
 709     next_char();
 710   }
 711 
 712   // Check for closing &#39;;&#39;
 713   skipws();
 714   if (_curchar != &#39;;&#39;) {
 715     parse_err(SYNERR, &quot;missing &#39;;&#39; after int_def\n&quot;);
 716     return;
 717   }
 718   next_char();                   // move past &#39;;&#39;
 719 
 720   // Debug Stuff
 721   if (_AD._adl_debug &gt; 1) {
 722     fprintf(stderr,&quot;int_def: %s ( %s, %s )\n&quot;, name,
 723             (value), (description ? description : &quot;&quot;));
 724   }
 725 
 726   // Record new definition.
 727   Expr *expr     = new Expr(name, description, int_value, int_value);
 728   const Expr *old_expr = _AD.globalDefs().define(name, expr);
 729   if (old_expr != NULL) {
 730     parse_err(SYNERR, &quot;Duplicate definition\n&quot;);
 731     return;
 732   }
 733 
 734   return;
 735 }
 736 
 737 
 738 //------------------------------source_parse-----------------------------------
 739 void ADLParser::source_parse(void) {
 740   SourceForm *source;             // Encode class for instruction/operand
 741   char   *rule = NULL;            // String representation of encode rule
 742 
 743   skipws();                       // Skip leading whitespace
 744   if ( (rule = find_cpp_block(&quot;source block&quot;)) == NULL ) {
 745     parse_err(SYNERR, &quot;incorrect or missing block for &#39;source&#39;.\n&quot;);
 746     return;
 747   }
 748   // Debug Stuff
 749   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Source Form: %s\n&quot;, rule);
 750 
 751   source = new SourceForm(rule);    // Build new Source object
 752   _AD.addForm(source);
 753   // skipws();
 754 }
 755 
 756 //------------------------------source_hpp_parse-------------------------------
 757 // Parse a source_hpp %{ ... %} block.
 758 // The code gets stuck into the ad_&lt;arch&gt;.hpp file.
 759 // If the source_hpp block appears before the register block in the AD
 760 // file, it goes up at the very top of the ad_&lt;arch&gt;.hpp file, so that
 761 // it can be used by register encodings, etc.  Otherwise, it goes towards
 762 // the bottom, where it&#39;s useful as a global definition to *.cpp files.
 763 void ADLParser::source_hpp_parse(void) {
 764   char   *rule = NULL;            // String representation of encode rule
 765 
 766   skipws();                       // Skip leading whitespace
 767   if ( (rule = find_cpp_block(&quot;source_hpp block&quot;)) == NULL ) {
 768     parse_err(SYNERR, &quot;incorrect or missing block for &#39;source_hpp&#39;.\n&quot;);
 769     return;
 770   }
 771   // Debug Stuff
 772   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Header Form: %s\n&quot;, rule);
 773 
 774   if (_AD.get_registers() == NULL) {
 775     // Very early in the file, before reg_defs, we collect pre-headers.
 776     PreHeaderForm* pre_header = new PreHeaderForm(rule);
 777     _AD.addForm(pre_header);
 778   } else {
 779     // Normally, we collect header info, placed at the bottom of the hpp file.
 780     HeaderForm* header = new HeaderForm(rule);
 781     _AD.addForm(header);
 782   }
 783 }
 784 
 785 //------------------------------reg_parse--------------------------------------
 786 void ADLParser::reg_parse(void) {
 787   RegisterForm *regBlock = _AD.get_registers(); // Information about registers encoding
 788   if (regBlock == NULL) {
 789     // Create the RegisterForm for the architecture description.
 790     regBlock = new RegisterForm();    // Build new Source object
 791     _AD.addForm(regBlock);
 792   }
 793 
 794   skipws();                       // Skip leading whitespace
 795   if (_curchar == &#39;%&#39; &amp;&amp; *(_ptr+1) == &#39;{&#39;) {
 796     next_char(); next_char();     // Skip &quot;%{&quot;
 797     skipws();
 798     while (_curchar != &#39;%&#39; &amp;&amp; *(_ptr+1) != &#39;}&#39;) {
 799       char *token = get_ident();
 800       if (token == NULL) {
 801         parse_err(SYNERR, &quot;missing identifier inside register block.\n&quot;);
 802         return;
 803       }
 804       if (strcmp(token,&quot;reg_def&quot;)==0)          { reg_def_parse(); }
 805       else if (strcmp(token,&quot;reg_class&quot;)==0)   { reg_class_parse(); }
 806       else if (strcmp(token, &quot;reg_class_dynamic&quot;) == 0) { reg_class_dynamic_parse(); }
 807       else if (strcmp(token,&quot;alloc_class&quot;)==0) { alloc_class_parse(); }
 808       else if (strcmp(token,&quot;#define&quot;)==0)     { preproc_define(); }
 809       else { parse_err(SYNERR, &quot;bad token %s inside register block.\n&quot;, token); break; }
 810       skipws();
 811     }
 812   }
 813   else {
 814     parse_err(SYNERR, &quot;Missing %c{ ... %c} block after register keyword.\n&quot;,&#39;%&#39;,&#39;%&#39;);
 815     return;
 816   }
 817 }
 818 
 819 //------------------------------encode_parse-----------------------------------
 820 void ADLParser::encode_parse(void) {
 821   EncodeForm *encBlock;         // Information about instruction/operand encoding
 822 
 823   _AD.getForm(&amp;encBlock);
 824   if ( encBlock == NULL) {
 825     // Create the EncodeForm for the architecture description.
 826     encBlock = new EncodeForm();    // Build new Source object
 827     _AD.addForm(encBlock);
 828   }
 829 
 830   skipws();                       // Skip leading whitespace
 831   if (_curchar == &#39;%&#39; &amp;&amp; *(_ptr+1) == &#39;{&#39;) {
 832     next_char(); next_char();     // Skip &quot;%{&quot;
 833     skipws();
 834     while (_curchar != &#39;%&#39; &amp;&amp; *(_ptr+1) != &#39;}&#39;) {
 835       char *token = get_ident();
 836       if (token == NULL) {
 837             parse_err(SYNERR, &quot;missing identifier inside encoding block.\n&quot;);
 838             return;
 839       }
 840       if (strcmp(token,&quot;enc_class&quot;)==0)   { enc_class_parse(); }
 841       skipws();
 842     }
 843   }
 844   else {
 845     parse_err(SYNERR, &quot;Missing %c{ ... %c} block after encode keyword.\n&quot;,&#39;%&#39;,&#39;%&#39;);
 846     return;
 847   }
 848 }
 849 
 850 //------------------------------enc_class_parse--------------------------------
 851 void ADLParser::enc_class_parse(void) {
 852   char       *ec_name;           // Name of encoding class being defined
 853 
 854   // Get encoding class name
 855   skipws();                      // Skip whitespace
 856   ec_name = get_ident();
 857   if (ec_name == NULL) {
 858     parse_err(SYNERR, &quot;missing encoding class name after encode.\n&quot;);
 859     return;
 860   }
 861 
 862   EncClass  *encoding = _AD._encode-&gt;add_EncClass(ec_name);
 863   encoding-&gt;_linenum = linenum();
 864 
 865   skipws();                      // Skip leading whitespace
 866   // Check for optional parameter list
 867   if (_curchar == &#39;(&#39;) {
 868     do {
 869       char *pType = NULL;        // parameter type
 870       char *pName = NULL;        // parameter name
 871 
 872       next_char();               // skip open paren &amp; comma characters
 873       skipws();
 874       if (_curchar == &#39;)&#39;) break;
 875 
 876       // Get parameter type
 877       pType = get_ident();
 878       if (pType == NULL) {
 879         parse_err(SYNERR, &quot;parameter type expected at %c\n&quot;, _curchar);
 880         return;
 881       }
 882 
 883       skipws();
 884       // Get parameter name
 885       pName = get_ident();
 886       if (pName == NULL) {
 887         parse_err(SYNERR, &quot;parameter name expected at %c\n&quot;, _curchar);
 888         return;
 889       }
 890 
 891       // Record parameter type and name
 892       encoding-&gt;add_parameter( pType, pName );
 893 
 894       skipws();
 895     } while(_curchar == &#39;,&#39;);
 896 
 897     if (_curchar != &#39;)&#39;) parse_err(SYNERR, &quot;missing &#39;)&#39;\n&quot;);
 898     else {
 899       next_char();                  // Skip &#39;)&#39;
 900     }
 901   } // Done with parameter list
 902 
 903   skipws();
 904   // Check for block starting delimiters
 905   if ((_curchar != &#39;%&#39;) || (*(_ptr+1) != &#39;{&#39;)) { // If not open block
 906     parse_err(SYNERR, &quot;missing &#39;%c{&#39; in enc_class definition\n&quot;, &#39;%&#39;);
 907     return;
 908   }
 909   next_char();                      // Skip &#39;%&#39;
 910   next_char();                      // Skip &#39;{&#39;
 911 
 912   enc_class_parse_block(encoding, ec_name);
 913 }
 914 
 915 
 916 void ADLParser::enc_class_parse_block(EncClass* encoding, char* ec_name) {
 917   skipws_no_preproc();              // Skip leading whitespace
 918   // Prepend location descriptor, for debugging; cf. ADLParser::find_cpp_block
 919   if (_AD._adlocation_debug) {
 920     encoding-&gt;add_code(get_line_string());
 921   }
 922 
 923   // Collect the parts of the encode description
 924   // (1) strings that are passed through to output
 925   // (2) replacement/substitution variable, preceeded by a &#39;$&#39;
 926   while ( (_curchar != &#39;%&#39;) &amp;&amp; (*(_ptr+1) != &#39;}&#39;) ) {
 927 
 928     // (1)
 929     // Check if there is a string to pass through to output
 930     char *start = _ptr;       // Record start of the next string
 931     while ((_curchar != &#39;$&#39;) &amp;&amp; ((_curchar != &#39;%&#39;) || (*(_ptr+1) != &#39;}&#39;)) ) {
 932       // If at the start of a comment, skip past it
 933       if( (_curchar == &#39;/&#39;) &amp;&amp; ((*(_ptr+1) == &#39;/&#39;) || (*(_ptr+1) == &#39;*&#39;)) ) {
 934         skipws_no_preproc();
 935       } else {
 936         // ELSE advance to the next character, or start of the next line
 937         next_char_or_line();
 938       }
 939     }
 940     // If a string was found, terminate it and record in EncClass
 941     if ( start != _ptr ) {
 942       *_ptr  = &#39;\0&#39;;          // Terminate the string
 943       encoding-&gt;add_code(start);
 944     }
 945 
 946     // (2)
 947     // If we are at a replacement variable,
 948     // copy it and record in EncClass
 949     if (_curchar == &#39;$&#39;) {
 950       // Found replacement Variable
 951       char* rep_var = get_rep_var_ident_dup();
 952       // Add flag to _strings list indicating we should check _rep_vars
 953       encoding-&gt;add_rep_var(rep_var);
 954     }
 955   } // end while part of format description
 956   next_char();                      // Skip &#39;%&#39;
 957   next_char();                      // Skip &#39;}&#39;
 958 
 959   skipws();
 960 
 961   if (_AD._adlocation_debug) {
 962     encoding-&gt;add_code(end_line_marker());
 963   }
 964 
 965   // Debug Stuff
 966   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;EncodingClass Form: %s\n&quot;, ec_name);
 967 }
 968 
 969 //------------------------------frame_parse-----------------------------------
 970 void ADLParser::frame_parse(void) {
 971   FrameForm  *frame;              // Information about stack-frame layout
 972   char       *desc = NULL;        // String representation of frame
 973 
 974   skipws();                       // Skip leading whitespace
 975 
 976   frame = new FrameForm();        // Build new Frame object
 977   // Check for open block sequence
 978   skipws();                       // Skip leading whitespace
 979   if (_curchar == &#39;%&#39; &amp;&amp; *(_ptr+1) == &#39;{&#39;) {
 980     next_char(); next_char();     // Skip &quot;%{&quot;
 981     skipws();
 982     while (_curchar != &#39;%&#39; &amp;&amp; *(_ptr+1) != &#39;}&#39;) {
 983       char *token = get_ident();
 984       if (token == NULL) {
 985             parse_err(SYNERR, &quot;missing identifier inside frame block.\n&quot;);
 986             return;
 987       }
 988       if (strcmp(token,&quot;stack_direction&quot;)==0) {
 989         stack_dir_parse(frame);
 990       }
 991       if (strcmp(token,&quot;sync_stack_slots&quot;)==0) {
 992         sync_stack_slots_parse(frame);
 993       }
 994       if (strcmp(token,&quot;frame_pointer&quot;)==0) {
 995         frame_pointer_parse(frame, false);
 996       }
 997       if (strcmp(token,&quot;interpreter_frame_pointer&quot;)==0) {
 998         interpreter_frame_pointer_parse(frame, false);
 999       }
1000       if (strcmp(token,&quot;inline_cache_reg&quot;)==0) {
1001         inline_cache_parse(frame, false);
1002       }
1003       if (strcmp(token,&quot;compiler_method_oop_reg&quot;)==0) {
1004         parse_err(WARN, &quot;Using obsolete Token, compiler_method_oop_reg&quot;);
1005         skipws();
1006       }
1007       if (strcmp(token,&quot;interpreter_method_oop_reg&quot;)==0) {
1008         interpreter_method_oop_parse(frame, false);
1009       }
1010       if (strcmp(token,&quot;cisc_spilling_operand_name&quot;)==0) {
1011         cisc_spilling_operand_name_parse(frame, false);
1012       }
1013       if (strcmp(token,&quot;stack_alignment&quot;)==0) {
1014         stack_alignment_parse(frame);
1015       }
1016       if (strcmp(token,&quot;return_addr&quot;)==0) {
1017         return_addr_parse(frame, false);
1018       }
1019       if (strcmp(token,&quot;in_preserve_stack_slots&quot;)==0) {
1020         preserve_stack_parse(frame);
1021       }
1022       if (strcmp(token,&quot;out_preserve_stack_slots&quot;)==0) {
1023         parse_err(WARN, &quot;Using obsolete token, out_preserve_stack_slots&quot;);
1024         skipws();
1025       }
1026       if (strcmp(token,&quot;varargs_C_out_slots_killed&quot;)==0) {
1027         frame-&gt;_varargs_C_out_slots_killed = parse_one_arg(&quot;varargs C out slots killed&quot;);
1028       }
1029       if (strcmp(token,&quot;calling_convention&quot;)==0) {
1030         frame-&gt;_calling_convention = calling_convention_parse();
1031       }
1032       if (strcmp(token,&quot;return_value&quot;)==0) {
1033         frame-&gt;_return_value = return_value_parse();
1034       }
1035       if (strcmp(token,&quot;c_frame_pointer&quot;)==0) {
1036         frame_pointer_parse(frame, true);
1037       }
1038       if (strcmp(token,&quot;c_return_addr&quot;)==0) {
1039         return_addr_parse(frame, true);
1040       }
1041       if (strcmp(token,&quot;c_calling_convention&quot;)==0) {
1042         frame-&gt;_c_calling_convention = calling_convention_parse();
1043       }
1044       if (strcmp(token,&quot;c_return_value&quot;)==0) {
1045         frame-&gt;_c_return_value = return_value_parse();
1046       }
1047 
1048       skipws();
1049     }
1050   }
1051   else {
1052     parse_err(SYNERR, &quot;Missing %c{ ... %c} block after encode keyword.\n&quot;,&#39;%&#39;,&#39;%&#39;);
1053     return;
1054   }
1055   // All Java versions are required, native versions are optional
1056   if(frame-&gt;_frame_pointer == NULL) {
1057     parse_err(SYNERR, &quot;missing frame pointer definition in frame section.\n&quot;);
1058     return;
1059   }
1060   // !!!!! !!!!!
1061   // if(frame-&gt;_interpreter_frame_ptr_reg == NULL) {
1062   //   parse_err(SYNERR, &quot;missing interpreter frame pointer definition in frame section.\n&quot;);
1063   //   return;
1064   // }
1065   if(frame-&gt;_alignment == NULL) {
1066     parse_err(SYNERR, &quot;missing alignment definition in frame section.\n&quot;);
1067     return;
1068   }
1069   if(frame-&gt;_return_addr == NULL) {
1070     parse_err(SYNERR, &quot;missing return address location in frame section.\n&quot;);
1071     return;
1072   }
1073   if(frame-&gt;_in_preserve_slots == NULL) {
1074     parse_err(SYNERR, &quot;missing stack slot preservation definition in frame section.\n&quot;);
1075     return;
1076   }
1077   if(frame-&gt;_varargs_C_out_slots_killed == NULL) {
1078     parse_err(SYNERR, &quot;missing varargs C out slots killed definition in frame section.\n&quot;);
1079     return;
1080   }
1081   if(frame-&gt;_calling_convention == NULL) {
1082     parse_err(SYNERR, &quot;missing calling convention definition in frame section.\n&quot;);
1083     return;
1084   }
1085   if(frame-&gt;_return_value == NULL) {
1086     parse_err(SYNERR, &quot;missing return value definition in frame section.\n&quot;);
1087     return;
1088   }
1089   // Fill natives in identically with the Java versions if not present.
1090   if(frame-&gt;_c_frame_pointer == NULL) {
1091     frame-&gt;_c_frame_pointer = frame-&gt;_frame_pointer;
1092   }
1093   if(frame-&gt;_c_return_addr == NULL) {
1094     frame-&gt;_c_return_addr = frame-&gt;_return_addr;
1095     frame-&gt;_c_return_addr_loc = frame-&gt;_return_addr_loc;
1096   }
1097   if(frame-&gt;_c_calling_convention == NULL) {
1098     frame-&gt;_c_calling_convention = frame-&gt;_calling_convention;
1099   }
1100   if(frame-&gt;_c_return_value == NULL) {
1101     frame-&gt;_c_return_value = frame-&gt;_return_value;
1102   }
1103 
1104   // Debug Stuff
1105   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Frame Form: %s\n&quot;, desc);
1106 
1107   // Create the EncodeForm for the architecture description.
1108   _AD.addForm(frame);
1109   // skipws();
1110 }
1111 
1112 //------------------------------stack_dir_parse--------------------------------
1113 void ADLParser::stack_dir_parse(FrameForm *frame) {
1114   char *direction = parse_one_arg(&quot;stack direction entry&quot;);
1115   if (strcmp(direction, &quot;TOWARDS_LOW&quot;) == 0) {
1116     frame-&gt;_direction = false;
1117   }
1118   else if (strcmp(direction, &quot;TOWARDS_HIGH&quot;) == 0) {
1119     frame-&gt;_direction = true;
1120   }
1121   else {
1122     parse_err(SYNERR, &quot;invalid value inside stack direction entry.\n&quot;);
1123     return;
1124   }
1125 }
1126 
1127 //------------------------------sync_stack_slots_parse-------------------------
1128 void ADLParser::sync_stack_slots_parse(FrameForm *frame) {
1129     // Assign value into frame form
1130     frame-&gt;_sync_stack_slots = parse_one_arg(&quot;sync stack slots entry&quot;);
1131 }
1132 
1133 //------------------------------frame_pointer_parse----------------------------
1134 void ADLParser::frame_pointer_parse(FrameForm *frame, bool native) {
1135   char *frame_pointer = parse_one_arg(&quot;frame pointer entry&quot;);
1136   // Assign value into frame form
1137   if (native) { frame-&gt;_c_frame_pointer = frame_pointer; }
1138   else        { frame-&gt;_frame_pointer   = frame_pointer; }
1139 }
1140 
1141 //------------------------------interpreter_frame_pointer_parse----------------------------
1142 void ADLParser::interpreter_frame_pointer_parse(FrameForm *frame, bool native) {
1143   frame-&gt;_interpreter_frame_pointer_reg = parse_one_arg(&quot;interpreter frame pointer entry&quot;);
1144 }
1145 
1146 //------------------------------inline_cache_parse-----------------------------
1147 void ADLParser::inline_cache_parse(FrameForm *frame, bool native) {
1148   frame-&gt;_inline_cache_reg = parse_one_arg(&quot;inline cache reg entry&quot;);
1149 }
1150 
1151 //------------------------------interpreter_method_oop_parse------------------
1152 void ADLParser::interpreter_method_oop_parse(FrameForm *frame, bool native) {
<a name="2" id="anc2"></a><span class="line-modified">1153   frame-&gt;_interpreter_method_oop_reg = parse_one_arg(&quot;method reg entry&quot;);</span>
1154 }
1155 
1156 //------------------------------cisc_spilling_operand_parse---------------------
1157 void ADLParser::cisc_spilling_operand_name_parse(FrameForm *frame, bool native) {
1158   frame-&gt;_cisc_spilling_operand_name = parse_one_arg(&quot;cisc spilling operand name&quot;);
1159 }
1160 
1161 //------------------------------stack_alignment_parse--------------------------
1162 void ADLParser::stack_alignment_parse(FrameForm *frame) {
1163   char *alignment = parse_one_arg(&quot;stack alignment entry&quot;);
1164   // Assign value into frame
1165   frame-&gt;_alignment   = alignment;
1166 }
1167 
1168 //------------------------------parse_one_arg-------------------------------
1169 char *ADLParser::parse_one_arg(const char *description) {
1170   char *token = NULL;
1171   if(_curchar == &#39;(&#39;) {
1172     next_char();
1173     skipws();
1174     token = get_expr(description, &quot;)&quot;);
1175     if (token == NULL) {
1176       parse_err(SYNERR, &quot;missing value inside %s.\n&quot;, description);
1177       return NULL;
1178     }
1179     next_char();           // skip the close paren
1180     if(_curchar != &#39;;&#39;) {  // check for semi-colon
1181       parse_err(SYNERR, &quot;missing %c in.\n&quot;, &#39;;&#39;, description);
1182       return NULL;
1183     }
1184     next_char();           // skip the semi-colon
1185   }
1186   else {
1187     parse_err(SYNERR, &quot;Missing %c in.\n&quot;, &#39;(&#39;, description);
1188     return NULL;
1189   }
1190 
1191   trim(token);
1192   return token;
1193 }
1194 
1195 //------------------------------return_addr_parse------------------------------
1196 void ADLParser::return_addr_parse(FrameForm *frame, bool native) {
1197   bool in_register  = true;
1198   if(_curchar == &#39;(&#39;) {
1199     next_char();
1200     skipws();
1201     char *token = get_ident();
1202     if (token == NULL) {
1203       parse_err(SYNERR, &quot;missing value inside return address entry.\n&quot;);
1204       return;
1205     }
1206     // check for valid values for stack/register
1207     if (strcmp(token, &quot;REG&quot;) == 0) {
1208       in_register = true;
1209     }
1210     else if (strcmp(token, &quot;STACK&quot;) == 0) {
1211       in_register = false;
1212     }
1213     else {
1214       parse_err(SYNERR, &quot;invalid value inside return_address entry.\n&quot;);
1215       return;
1216     }
1217     if (native) { frame-&gt;_c_return_addr_loc = in_register; }
1218     else        { frame-&gt;_return_addr_loc   = in_register; }
1219 
1220     // Parse expression that specifies register or stack position
1221     skipws();
1222     char *token2 = get_expr(&quot;return address entry&quot;, &quot;)&quot;);
1223     if (token2 == NULL) {
1224       parse_err(SYNERR, &quot;missing value inside return address entry.\n&quot;);
1225       return;
1226     }
1227     next_char();           // skip the close paren
1228     if (native) { frame-&gt;_c_return_addr = token2; }
1229     else        { frame-&gt;_return_addr   = token2; }
1230 
1231     if(_curchar != &#39;;&#39;) {  // check for semi-colon
1232       parse_err(SYNERR, &quot;missing %c in return address entry.\n&quot;, &#39;;&#39;);
1233       return;
1234     }
1235     next_char();           // skip the semi-colon
1236   }
1237   else {
1238     parse_err(SYNERR, &quot;Missing %c in return_address entry.\n&quot;, &#39;(&#39;);
1239   }
1240 }
1241 
1242 //------------------------------preserve_stack_parse---------------------------
1243 void ADLParser::preserve_stack_parse(FrameForm *frame) {
1244   if(_curchar == &#39;(&#39;) {
1245     char *token = get_paren_expr(&quot;preserve_stack_slots&quot;);
1246     frame-&gt;_in_preserve_slots   = token;
1247 
1248     if(_curchar != &#39;;&#39;) {  // check for semi-colon
1249       parse_err(SYNERR, &quot;missing %c in preserve stack slot entry.\n&quot;, &#39;;&#39;);
1250       return;
1251     }
1252     next_char();           // skip the semi-colon
1253   }
1254   else {
1255     parse_err(SYNERR, &quot;Missing %c in preserve stack slot entry.\n&quot;, &#39;(&#39;);
1256   }
1257 }
1258 
1259 //------------------------------calling_convention_parse-----------------------
1260 char *ADLParser::calling_convention_parse() {
1261   char   *desc = NULL;          // String representation of calling_convention
1262 
1263   skipws();                     // Skip leading whitespace
1264   if ( (desc = find_cpp_block(&quot;calling convention block&quot;)) == NULL ) {
1265     parse_err(SYNERR, &quot;incorrect or missing block for &#39;calling_convention&#39;.\n&quot;);
1266   }
1267   return desc;
1268 }
1269 
1270 //------------------------------return_value_parse-----------------------------
1271 char *ADLParser::return_value_parse() {
1272   char   *desc = NULL;          // String representation of calling_convention
1273 
1274   skipws();                     // Skip leading whitespace
1275   if ( (desc = find_cpp_block(&quot;return value block&quot;)) == NULL ) {
1276     parse_err(SYNERR, &quot;incorrect or missing block for &#39;return_value&#39;.\n&quot;);
1277   }
1278   return desc;
1279 }
1280 
1281 //------------------------------ins_pipe_parse---------------------------------
1282 void ADLParser::ins_pipe_parse(InstructForm &amp;instr) {
1283   char * ident;
1284 
1285   skipws();
1286   if ( _curchar != &#39;(&#39; ) {       // Check for delimiter
1287     parse_err(SYNERR, &quot;missing \&quot;(\&quot; in ins_pipe definition\n&quot;);
1288     return;
1289   }
1290 
1291   next_char();
1292   ident = get_ident();           // Grab next identifier
1293 
1294   if (ident == NULL) {
1295     parse_err(SYNERR, &quot;keyword identifier expected at %c\n&quot;, _curchar);
1296     return;
1297   }
1298 
1299   skipws();
1300   if ( _curchar != &#39;)&#39; ) {       // Check for delimiter
1301     parse_err(SYNERR, &quot;missing \&quot;)\&quot; in ins_pipe definition\n&quot;);
1302     return;
1303   }
1304 
1305   next_char();                   // skip the close paren
1306   if(_curchar != &#39;;&#39;) {          // check for semi-colon
1307     parse_err(SYNERR, &quot;missing %c in return value entry.\n&quot;, &#39;;&#39;);
1308     return;
1309   }
1310   next_char();                   // skip the semi-colon
1311 
1312   // Check ident for validity
1313   if (_AD._pipeline &amp;&amp; !_AD._pipeline-&gt;_classlist.search(ident)) {
1314     parse_err(SYNERR, &quot;\&quot;%s\&quot; is not a valid pipeline class\n&quot;, ident);
1315     return;
1316   }
1317 
1318   // Add this instruction to the list in the pipeline class
1319   _AD._pipeline-&gt;_classdict[ident]-&gt;is_pipeclass()-&gt;_instructs.addName(instr._ident);
1320 
1321   // Set the name of the pipeline class in the instruction
1322   instr._ins_pipe = ident;
1323   return;
1324 }
1325 
1326 //------------------------------pipe_parse-------------------------------------
1327 void ADLParser::pipe_parse(void) {
1328   PipelineForm *pipeline;         // Encode class for instruction/operand
1329   char * ident;
1330 
1331   pipeline = new PipelineForm();  // Build new Source object
1332   _AD.addForm(pipeline);
1333 
1334   skipws();                       // Skip leading whitespace
1335   // Check for block delimiter
1336   if ( (_curchar != &#39;%&#39;)
1337        || ( next_char(),  (_curchar != &#39;{&#39;)) ) {
1338     parse_err(SYNERR, &quot;missing &#39;%%{&#39; in pipeline definition\n&quot;);
1339     return;
1340   }
1341   next_char();                     // Maintain the invariant
1342   do {
1343     ident = get_ident();           // Grab next identifier
1344     if (ident == NULL) {
1345       parse_err(SYNERR, &quot;keyword identifier expected at %c\n&quot;, _curchar);
1346       continue;
1347     }
1348     if      (!strcmp(ident, &quot;resources&quot; )) resource_parse(*pipeline);
1349     else if (!strcmp(ident, &quot;pipe_desc&quot; )) pipe_desc_parse(*pipeline);
1350     else if (!strcmp(ident, &quot;pipe_class&quot;)) pipe_class_parse(*pipeline);
1351     else if (!strcmp(ident, &quot;define&quot;)) {
1352       skipws();
1353       if ( (_curchar != &#39;%&#39;)
1354            || ( next_char(),  (_curchar != &#39;{&#39;)) ) {
1355         parse_err(SYNERR, &quot;expected &#39;%%{&#39;\n&quot;);
1356         return;
1357       }
1358       next_char(); skipws();
1359 
1360       char *node_class = get_ident();
1361       if (node_class == NULL) {
1362         parse_err(SYNERR, &quot;expected identifier, found \&quot;%c\&quot;\n&quot;, _curchar);
1363         return;
1364       }
1365 
1366       skipws();
1367       if (_curchar != &#39;,&#39; &amp;&amp; _curchar != &#39;=&#39;) {
1368         parse_err(SYNERR, &quot;expected `=`, found &#39;%c&#39;\n&quot;, _curchar);
1369         break;
1370       }
1371       next_char(); skipws();
1372 
1373       char *pipe_class = get_ident();
1374       if (pipe_class == NULL) {
1375         parse_err(SYNERR, &quot;expected identifier, found \&quot;%c\&quot;\n&quot;, _curchar);
1376         return;
1377       }
1378       if (_curchar != &#39;;&#39; ) {
1379         parse_err(SYNERR, &quot;expected `;`, found &#39;%c&#39;\n&quot;, _curchar);
1380         break;
1381       }
1382       next_char();              // Skip over semi-colon
1383 
1384       skipws();
1385       if ( (_curchar != &#39;%&#39;)
1386            || ( next_char(),  (_curchar != &#39;}&#39;)) ) {
1387         parse_err(SYNERR, &quot;expected &#39;%%}&#39;, found \&quot;%c\&quot;\n&quot;, _curchar);
1388       }
1389       next_char();
1390 
1391       // Check ident for validity
1392       if (_AD._pipeline &amp;&amp; !_AD._pipeline-&gt;_classlist.search(pipe_class)) {
1393         parse_err(SYNERR, &quot;\&quot;%s\&quot; is not a valid pipeline class\n&quot;, pipe_class);
1394         return;
1395       }
1396 
1397       // Add this machine node to the list in the pipeline class
1398       _AD._pipeline-&gt;_classdict[pipe_class]-&gt;is_pipeclass()-&gt;_instructs.addName(node_class);
1399 
1400       MachNodeForm *machnode = new MachNodeForm(node_class); // Create new machnode form
1401       machnode-&gt;_machnode_pipe = pipe_class;
1402 
1403       _AD.addForm(machnode);
1404     }
1405     else if (!strcmp(ident, &quot;attributes&quot;)) {
1406       bool vsi_seen = false;
1407 
1408       skipws();
1409       if ( (_curchar != &#39;%&#39;)
1410            || ( next_char(),  (_curchar != &#39;{&#39;)) ) {
1411         parse_err(SYNERR, &quot;expected &#39;%%{&#39;\n&quot;);
1412         return;
1413       }
1414       next_char(); skipws();
1415 
1416       while (_curchar != &#39;%&#39;) {
1417         ident = get_ident();
1418         if (ident == NULL)
1419           break;
1420 
1421         if (!strcmp(ident, &quot;variable_size_instructions&quot;)) {
1422           skipws();
1423           if (_curchar == &#39;;&#39;) {
1424             next_char(); skipws();
1425           }
1426 
1427           pipeline-&gt;_variableSizeInstrs = true;
1428           vsi_seen = true;
1429           continue;
1430         }
1431 
1432         if (!strcmp(ident, &quot;fixed_size_instructions&quot;)) {
1433           skipws();
1434           if (_curchar == &#39;;&#39;) {
1435             next_char(); skipws();
1436           }
1437 
1438           pipeline-&gt;_variableSizeInstrs = false;
1439           vsi_seen = true;
1440           continue;
1441         }
1442 
1443         if (!strcmp(ident, &quot;branch_has_delay_slot&quot;)) {
1444           skipws();
1445           if (_curchar == &#39;;&#39;) {
1446             next_char(); skipws();
1447           }
1448 
1449           pipeline-&gt;_branchHasDelaySlot = true;
1450           continue;
1451         }
1452 
1453         if (!strcmp(ident, &quot;max_instructions_per_bundle&quot;)) {
1454           skipws();
1455           if (_curchar != &#39;=&#39;) {
1456             parse_err(SYNERR, &quot;expected `=`\n&quot;);
1457             break;
1458             }
1459 
1460           next_char(); skipws();
1461           pipeline-&gt;_maxInstrsPerBundle = get_int();
1462           skipws();
1463 
1464           if (_curchar == &#39;;&#39;) {
1465             next_char(); skipws();
1466           }
1467 
1468           continue;
1469         }
1470 
1471         if (!strcmp(ident, &quot;max_bundles_per_cycle&quot;)) {
1472           skipws();
1473           if (_curchar != &#39;=&#39;) {
1474             parse_err(SYNERR, &quot;expected `=`\n&quot;);
1475             break;
1476             }
1477 
1478           next_char(); skipws();
1479           pipeline-&gt;_maxBundlesPerCycle = get_int();
1480           skipws();
1481 
1482           if (_curchar == &#39;;&#39;) {
1483             next_char(); skipws();
1484           }
1485 
1486           continue;
1487         }
1488 
1489         if (!strcmp(ident, &quot;instruction_unit_size&quot;)) {
1490           skipws();
1491           if (_curchar != &#39;=&#39;) {
1492             parse_err(SYNERR, &quot;expected `=`, found &#39;%c&#39;\n&quot;, _curchar);
1493             break;
1494             }
1495 
1496           next_char(); skipws();
1497           pipeline-&gt;_instrUnitSize = get_int();
1498           skipws();
1499 
1500           if (_curchar == &#39;;&#39;) {
1501             next_char(); skipws();
1502           }
1503 
1504           continue;
1505         }
1506 
1507         if (!strcmp(ident, &quot;bundle_unit_size&quot;)) {
1508           skipws();
1509           if (_curchar != &#39;=&#39;) {
1510             parse_err(SYNERR, &quot;expected `=`, found &#39;%c&#39;\n&quot;, _curchar);
1511             break;
1512             }
1513 
1514           next_char(); skipws();
1515           pipeline-&gt;_bundleUnitSize = get_int();
1516           skipws();
1517 
1518           if (_curchar == &#39;;&#39;) {
1519             next_char(); skipws();
1520           }
1521 
1522           continue;
1523         }
1524 
1525         if (!strcmp(ident, &quot;instruction_fetch_unit_size&quot;)) {
1526           skipws();
1527           if (_curchar != &#39;=&#39;) {
1528             parse_err(SYNERR, &quot;expected `=`, found &#39;%c&#39;\n&quot;, _curchar);
1529             break;
1530             }
1531 
1532           next_char(); skipws();
1533           pipeline-&gt;_instrFetchUnitSize = get_int();
1534           skipws();
1535 
1536           if (_curchar == &#39;;&#39;) {
1537             next_char(); skipws();
1538           }
1539 
1540           continue;
1541         }
1542 
1543         if (!strcmp(ident, &quot;instruction_fetch_units&quot;)) {
1544           skipws();
1545           if (_curchar != &#39;=&#39;) {
1546             parse_err(SYNERR, &quot;expected `=`, found &#39;%c&#39;\n&quot;, _curchar);
1547             break;
1548             }
1549 
1550           next_char(); skipws();
1551           pipeline-&gt;_instrFetchUnits = get_int();
1552           skipws();
1553 
1554           if (_curchar == &#39;;&#39;) {
1555             next_char(); skipws();
1556           }
1557 
1558           continue;
1559         }
1560 
1561         if (!strcmp(ident, &quot;nops&quot;)) {
1562           skipws();
1563           if (_curchar != &#39;(&#39;) {
1564             parse_err(SYNERR, &quot;expected `(`, found &#39;%c&#39;\n&quot;, _curchar);
1565             break;
1566             }
1567 
1568           next_char(); skipws();
1569 
1570           while (_curchar != &#39;)&#39;) {
1571             ident = get_ident();
1572             if (ident == NULL) {
1573               parse_err(SYNERR, &quot;expected identifier for nop instruction, found &#39;%c&#39;\n&quot;, _curchar);
1574               break;
1575             }
1576 
1577             pipeline-&gt;_noplist.addName(ident);
1578             pipeline-&gt;_nopcnt++;
1579             skipws();
1580 
1581             if (_curchar == &#39;,&#39;) {
1582               next_char(); skipws();
1583             }
1584           }
1585 
1586           next_char(); skipws();
1587 
1588           if (_curchar == &#39;;&#39;) {
1589             next_char(); skipws();
1590           }
1591 
1592           continue;
1593         }
1594 
1595         parse_err(SYNERR, &quot;unknown specifier \&quot;%s\&quot;\n&quot;, ident);
1596       }
1597 
1598       if ( (_curchar != &#39;%&#39;)
1599            || ( next_char(),  (_curchar != &#39;}&#39;)) ) {
1600         parse_err(SYNERR, &quot;expected &#39;%%}&#39;, found \&quot;%c\&quot;\n&quot;, _curchar);
1601       }
1602       next_char(); skipws();
1603 
1604       if (pipeline-&gt;_maxInstrsPerBundle == 0)
1605         parse_err(SYNERR, &quot;\&quot;max_instructions_per_bundle\&quot; unspecified\n&quot;);
1606       if (pipeline-&gt;_instrUnitSize == 0 &amp;&amp; pipeline-&gt;_bundleUnitSize == 0)
1607         parse_err(SYNERR, &quot;\&quot;instruction_unit_size\&quot; and \&quot;bundle_unit_size\&quot; unspecified\n&quot;);
1608       if (pipeline-&gt;_instrFetchUnitSize == 0)
1609         parse_err(SYNERR, &quot;\&quot;instruction_fetch_unit_size\&quot; unspecified\n&quot;);
1610       if (pipeline-&gt;_instrFetchUnits == 0)
1611         parse_err(SYNERR, &quot;\&quot;instruction_fetch_units\&quot; unspecified\n&quot;);
1612       if (!vsi_seen)
1613         parse_err(SYNERR, &quot;\&quot;variable_size_instruction\&quot; or \&quot;fixed_size_instruction\&quot; unspecified\n&quot;);
1614     }
1615     else {  // Done with staticly defined parts of instruction definition
1616       parse_err(SYNERR, &quot;expected one of \&quot;resources\&quot;, \&quot;pipe_desc\&quot;, \&quot;pipe_class\&quot;, found \&quot;%s\&quot;\n&quot;, ident);
1617       return;
1618     }
1619     skipws();
1620     if (_curchar == &#39;;&#39;)
1621       skipws();
1622   } while(_curchar != &#39;%&#39;);
1623 
1624   next_char();
1625   if (_curchar != &#39;}&#39;) {
1626     parse_err(SYNERR, &quot;missing \&quot;%%}\&quot; in pipeline definition\n&quot;);
1627     return;
1628   }
1629 
1630   next_char();
1631 }
1632 
1633 //------------------------------resource_parse----------------------------
1634 void ADLParser::resource_parse(PipelineForm &amp;pipeline) {
1635   ResourceForm *resource;
1636   char * ident;
1637   char * expr;
1638   unsigned mask;
1639   pipeline._rescount = 0;
1640 
1641   skipws();                       // Skip leading whitespace
1642 
1643   if (_curchar != &#39;(&#39;) {
1644     parse_err(SYNERR, &quot;missing \&quot;(\&quot; in resource definition\n&quot;);
1645     return;
1646   }
1647 
1648   do {
1649     next_char();                   // Skip &quot;(&quot; or &quot;,&quot;
1650     ident = get_ident();           // Grab next identifier
1651 
1652     if (_AD._adl_debug &gt; 1) {
1653       if (ident != NULL) {
1654         fprintf(stderr, &quot;resource_parse: identifier: %s\n&quot;, ident);
1655       }
1656     }
1657 
1658     if (ident == NULL) {
1659       parse_err(SYNERR, &quot;keyword identifier expected at \&quot;%c\&quot;\n&quot;, _curchar);
1660       return;
1661     }
1662     skipws();
1663 
1664     if (_curchar != &#39;=&#39;) {
1665       mask = (1 &lt;&lt; pipeline._rescount++);
1666     }
1667     else {
1668       next_char(); skipws();
1669       expr = get_ident();          // Grab next identifier
1670       if (expr == NULL) {
1671         parse_err(SYNERR, &quot;keyword identifier expected at \&quot;%c\&quot;\n&quot;, _curchar);
1672         return;
1673       }
1674       resource = (ResourceForm *) pipeline._resdict[expr];
1675       if (resource == NULL) {
1676         parse_err(SYNERR, &quot;resource \&quot;%s\&quot; is not defined\n&quot;, expr);
1677         return;
1678       }
1679       mask = resource-&gt;mask();
1680 
1681       skipws();
1682       while (_curchar == &#39;|&#39;) {
1683         next_char(); skipws();
1684 
1685         expr = get_ident();          // Grab next identifier
1686         if (expr == NULL) {
1687           parse_err(SYNERR, &quot;keyword identifier expected at \&quot;%c\&quot;\n&quot;, _curchar);
1688           return;
1689         }
1690 
1691         resource = (ResourceForm *) pipeline._resdict[expr];   // Look up the value
1692         if (resource == NULL) {
1693           parse_err(SYNERR, &quot;resource \&quot;%s\&quot; is not defined\n&quot;, expr);
1694           return;
1695         }
1696 
1697         mask |= resource-&gt;mask();
1698         skipws();
1699       }
1700     }
1701 
1702     resource = new ResourceForm(mask);
1703 
1704     pipeline._resdict.Insert(ident, resource);
1705     pipeline._reslist.addName(ident);
1706   } while (_curchar == &#39;,&#39;);
1707 
1708   if (_curchar != &#39;)&#39;) {
1709       parse_err(SYNERR, &quot;\&quot;)\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
1710       return;
1711   }
1712 
1713   next_char();                 // Skip &quot;)&quot;
1714   if (_curchar == &#39;;&#39;)
1715     next_char();               // Skip &quot;;&quot;
1716 }
1717 
1718 //------------------------------resource_parse----------------------------
1719 void ADLParser::pipe_desc_parse(PipelineForm &amp;pipeline) {
1720   char * ident;
1721 
1722   skipws();                       // Skip leading whitespace
1723 
1724   if (_curchar != &#39;(&#39;) {
1725     parse_err(SYNERR, &quot;missing \&quot;(\&quot; in pipe_desc definition\n&quot;);
1726     return;
1727   }
1728 
1729   do {
1730     next_char();                   // Skip &quot;(&quot; or &quot;,&quot;
1731     ident = get_ident();           // Grab next identifier
1732     if (ident == NULL) {
1733       parse_err(SYNERR, &quot;keyword identifier expected at \&quot;%c\&quot;\n&quot;, _curchar);
1734       return;
1735     }
1736 
1737     // Add the name to the list
1738     pipeline._stages.addName(ident);
1739     pipeline._stagecnt++;
1740 
1741     skipws();
1742   } while (_curchar == &#39;,&#39;);
1743 
1744   if (_curchar != &#39;)&#39;) {
1745       parse_err(SYNERR, &quot;\&quot;)\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
1746       return;
1747   }
1748 
1749   next_char();                     // Skip &quot;)&quot;
1750   if (_curchar == &#39;;&#39;)
1751     next_char();                   // Skip &quot;;&quot;
1752 }
1753 
1754 //------------------------------pipe_class_parse--------------------------
1755 void ADLParser::pipe_class_parse(PipelineForm &amp;pipeline) {
1756   PipeClassForm *pipe_class;
1757   char * ident;
1758   char * stage;
1759   char * read_or_write;
1760   int is_write;
1761   int is_read;
1762   OperandForm  *oper;
1763 
1764   skipws();                       // Skip leading whitespace
1765 
1766   ident = get_ident();            // Grab next identifier
1767 
1768   if (ident == NULL) {
1769     parse_err(SYNERR, &quot;keyword identifier expected at \&quot;%c\&quot;\n&quot;, _curchar);
1770     return;
1771   }
1772 
1773   // Create a record for the pipe_class
1774   pipe_class = new PipeClassForm(ident, ++pipeline._classcnt);
1775   pipeline._classdict.Insert(ident, pipe_class);
1776   pipeline._classlist.addName(ident);
1777 
1778   // Then get the operands
1779   skipws();
1780   if (_curchar != &#39;(&#39;) {
1781     parse_err(SYNERR, &quot;missing \&quot;(\&quot; in pipe_class definition\n&quot;);
1782   }
1783   // Parse the operand list
1784   else get_oplist(pipe_class-&gt;_parameters, pipe_class-&gt;_localNames);
1785   skipws();                        // Skip leading whitespace
1786   // Check for block delimiter
1787   if ( (_curchar != &#39;%&#39;)
1788        || ( next_char(),  (_curchar != &#39;{&#39;)) ) {
1789     parse_err(SYNERR, &quot;missing \&quot;%%{\&quot; in pipe_class definition\n&quot;);
1790     return;
1791   }
1792   next_char();
1793 
1794   do {
1795     ident = get_ident();           // Grab next identifier
1796     if (ident == NULL) {
1797       parse_err(SYNERR, &quot;keyword identifier expected at \&quot;%c\&quot;\n&quot;, _curchar);
1798       continue;
1799     }
1800     skipws();
1801 
1802     if (!strcmp(ident, &quot;fixed_latency&quot;)) {
1803       skipws();
1804       if (_curchar != &#39;(&#39;) {
1805         parse_err(SYNERR, &quot;missing \&quot;(\&quot; in latency definition\n&quot;);
1806         return;
1807       }
1808       next_char(); skipws();
1809       if( !isdigit(_curchar) ) {
1810         parse_err(SYNERR, &quot;number expected for \&quot;%c\&quot; in latency definition\n&quot;, _curchar);
1811         return;
1812       }
1813       int fixed_latency = get_int();
1814       skipws();
1815       if (_curchar != &#39;)&#39;) {
1816         parse_err(SYNERR, &quot;missing \&quot;)\&quot; in latency definition\n&quot;);
1817         return;
1818       }
1819       next_char(); skipws();
1820       if (_curchar != &#39;;&#39;) {
1821         parse_err(SYNERR, &quot;missing \&quot;;\&quot; in latency definition\n&quot;);
1822         return;
1823       }
1824 
1825       pipe_class-&gt;setFixedLatency(fixed_latency);
1826       next_char(); skipws();
1827       continue;
1828     }
1829 
1830     if (!strcmp(ident, &quot;zero_instructions&quot;) ||
1831         !strcmp(ident, &quot;no_instructions&quot;)) {
1832       skipws();
1833       if (_curchar != &#39;;&#39;) {
1834         parse_err(SYNERR, &quot;missing \&quot;;\&quot; in latency definition\n&quot;);
1835         return;
1836       }
1837 
1838       pipe_class-&gt;setInstructionCount(0);
1839       next_char(); skipws();
1840       continue;
1841     }
1842 
1843     if (!strcmp(ident, &quot;one_instruction_with_delay_slot&quot;) ||
1844         !strcmp(ident, &quot;single_instruction_with_delay_slot&quot;)) {
1845       skipws();
1846       if (_curchar != &#39;;&#39;) {
1847         parse_err(SYNERR, &quot;missing \&quot;;\&quot; in latency definition\n&quot;);
1848         return;
1849       }
1850 
1851       pipe_class-&gt;setInstructionCount(1);
1852       pipe_class-&gt;setBranchDelay(true);
1853       next_char(); skipws();
1854       continue;
1855     }
1856 
1857     if (!strcmp(ident, &quot;one_instruction&quot;) ||
1858         !strcmp(ident, &quot;single_instruction&quot;)) {
1859       skipws();
1860       if (_curchar != &#39;;&#39;) {
1861         parse_err(SYNERR, &quot;missing \&quot;;\&quot; in latency definition\n&quot;);
1862         return;
1863       }
1864 
1865       pipe_class-&gt;setInstructionCount(1);
1866       next_char(); skipws();
1867       continue;
1868     }
1869 
1870     if (!strcmp(ident, &quot;instructions_in_first_bundle&quot;) ||
1871         !strcmp(ident, &quot;instruction_count&quot;)) {
1872       skipws();
1873 
1874       int number_of_instructions = 1;
1875 
1876       if (_curchar != &#39;(&#39;) {
1877         parse_err(SYNERR, &quot;\&quot;(\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
1878         continue;
1879       }
1880 
1881       next_char(); skipws();
1882       number_of_instructions = get_int();
1883 
1884       skipws();
1885       if (_curchar != &#39;)&#39;) {
1886         parse_err(SYNERR, &quot;\&quot;)\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
1887         continue;
1888       }
1889 
1890       next_char(); skipws();
1891       if (_curchar != &#39;;&#39;) {
1892         parse_err(SYNERR, &quot;missing \&quot;;\&quot; in latency definition\n&quot;);
1893         return;
1894       }
1895 
1896       pipe_class-&gt;setInstructionCount(number_of_instructions);
1897       next_char(); skipws();
1898       continue;
1899     }
1900 
1901     if (!strcmp(ident, &quot;multiple_bundles&quot;)) {
1902       skipws();
1903       if (_curchar != &#39;;&#39;) {
1904         parse_err(SYNERR, &quot;missing \&quot;;\&quot; after multiple bundles\n&quot;);
1905         return;
1906       }
1907 
1908       pipe_class-&gt;setMultipleBundles(true);
1909       next_char(); skipws();
1910       continue;
1911     }
1912 
1913     if (!strcmp(ident, &quot;has_delay_slot&quot;)) {
1914       skipws();
1915       if (_curchar != &#39;;&#39;) {
1916         parse_err(SYNERR, &quot;missing \&quot;;\&quot; after \&quot;has_delay_slot\&quot;\n&quot;);
1917         return;
1918       }
1919 
1920       pipe_class-&gt;setBranchDelay(true);
1921       next_char(); skipws();
1922       continue;
1923     }
1924 
1925     if (!strcmp(ident, &quot;force_serialization&quot;)) {
1926       skipws();
1927       if (_curchar != &#39;;&#39;) {
1928         parse_err(SYNERR, &quot;missing \&quot;;\&quot; after \&quot;force_serialization\&quot;\n&quot;);
1929         return;
1930       }
1931 
1932       pipe_class-&gt;setForceSerialization(true);
1933       next_char(); skipws();
1934       continue;
1935     }
1936 
1937     if (!strcmp(ident, &quot;may_have_no_code&quot;)) {
1938       skipws();
1939       if (_curchar != &#39;;&#39;) {
1940         parse_err(SYNERR, &quot;missing \&quot;;\&quot; after \&quot;may_have_no_code\&quot;\n&quot;);
1941         return;
1942       }
1943 
1944       pipe_class-&gt;setMayHaveNoCode(true);
1945       next_char(); skipws();
1946       continue;
1947     }
1948 
1949     const Form *parm = pipe_class-&gt;_localNames[ident];
1950     if (parm != NULL) {
1951       oper = parm-&gt;is_operand();
1952       if (oper == NULL &amp;&amp; !parm-&gt;is_opclass()) {
1953         parse_err(SYNERR, &quot;operand name expected at %s\n&quot;, ident);
1954         continue;
1955       }
1956 
1957       if (_curchar != &#39;:&#39;) {
1958         parse_err(SYNERR, &quot;\&quot;:\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
1959         continue;
1960       }
1961       next_char(); skipws();
1962       stage = get_ident();
1963       if (stage == NULL) {
1964         parse_err(SYNERR, &quot;pipeline stage identifier expected at \&quot;%c\&quot;\n&quot;, _curchar);
1965         continue;
1966       }
1967 
1968       skipws();
1969       if (_curchar != &#39;(&#39;) {
1970         parse_err(SYNERR, &quot;\&quot;(\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
1971         continue;
1972       }
1973 
1974       next_char();
1975       read_or_write = get_ident();
1976       if (read_or_write == NULL) {
1977         parse_err(SYNERR, &quot;\&quot;read\&quot; or \&quot;write\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
1978         continue;
1979       }
1980 
1981       is_read  = strcmp(read_or_write, &quot;read&quot;)   == 0;
1982       is_write = strcmp(read_or_write, &quot;write&quot;)  == 0;
1983       if (!is_read &amp;&amp; !is_write) {
1984         parse_err(SYNERR, &quot;\&quot;read\&quot; or \&quot;write\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
1985         continue;
1986       }
1987 
1988       skipws();
1989       if (_curchar != &#39;)&#39;) {
1990         parse_err(SYNERR, &quot;\&quot;)\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
1991         continue;
1992       }
1993 
1994       next_char(); skipws();
1995       int more_instrs = 0;
1996       if (_curchar == &#39;+&#39;) {
1997           next_char(); skipws();
1998           if (_curchar &lt; &#39;0&#39; || _curchar &gt; &#39;9&#39;) {
1999             parse_err(SYNERR, &quot;&lt;number&gt; expected at \&quot;%c\&quot;\n&quot;, _curchar);
2000             continue;
2001           }
2002           while (_curchar &gt;= &#39;0&#39; &amp;&amp; _curchar &lt;= &#39;9&#39;) {
2003             more_instrs *= 10;
2004             more_instrs += _curchar - &#39;0&#39;;
2005             next_char();
2006           }
2007           skipws();
2008       }
2009 
2010       PipeClassOperandForm *pipe_operand = new PipeClassOperandForm(stage, is_write, more_instrs);
2011       pipe_class-&gt;_localUsage.Insert(ident, pipe_operand);
2012 
2013       if (_curchar == &#39;%&#39;)
2014           continue;
2015 
2016       if (_curchar != &#39;;&#39;) {
2017         parse_err(SYNERR, &quot;\&quot;;\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
2018         continue;
2019       }
2020       next_char(); skipws();
2021       continue;
2022     }
2023 
2024     // Scan for Resource Specifier
2025     const Form *res = pipeline._resdict[ident];
2026     if (res != NULL) {
2027       int cyclecnt = 1;
2028       if (_curchar != &#39;:&#39;) {
2029         parse_err(SYNERR, &quot;\&quot;:\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
2030         continue;
2031       }
2032       next_char(); skipws();
2033       stage = get_ident();
2034       if (stage == NULL) {
2035         parse_err(SYNERR, &quot;pipeline stage identifier expected at \&quot;%c\&quot;\n&quot;, _curchar);
2036         continue;
2037       }
2038 
2039       skipws();
2040       if (_curchar == &#39;(&#39;) {
2041         next_char();
2042         cyclecnt = get_int();
2043 
2044         skipws();
2045         if (_curchar != &#39;)&#39;) {
2046           parse_err(SYNERR, &quot;\&quot;)\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
2047           continue;
2048         }
2049 
2050         next_char(); skipws();
2051       }
2052 
2053       PipeClassResourceForm *resource = new PipeClassResourceForm(ident, stage, cyclecnt);
2054       int stagenum = pipeline._stages.index(stage);
2055       if (pipeline._maxcycleused &lt; (stagenum+cyclecnt))
2056         pipeline._maxcycleused = (stagenum+cyclecnt);
2057       pipe_class-&gt;_resUsage.addForm(resource);
2058 
2059       if (_curchar == &#39;%&#39;)
2060           continue;
2061 
2062       if (_curchar != &#39;;&#39;) {
2063         parse_err(SYNERR, &quot;\&quot;;\&quot; expected at \&quot;%c\&quot;\n&quot;, _curchar);
2064         continue;
2065       }
2066       next_char(); skipws();
2067       continue;
2068     }
2069 
2070     parse_err(SYNERR, &quot;resource expected at \&quot;%s\&quot;\n&quot;, ident);
2071     return;
2072   } while(_curchar != &#39;%&#39;);
2073 
2074   next_char();
2075   if (_curchar != &#39;}&#39;) {
2076     parse_err(SYNERR, &quot;missing \&quot;%%}\&quot; in pipe_class definition\n&quot;);
2077     return;
2078   }
2079 
2080   next_char();
2081 }
2082 
2083 //------------------------------peep_parse-------------------------------------
2084 void ADLParser::peep_parse(void) {
2085   Peephole  *peep;                // Pointer to current peephole rule form
2086   char      *desc = NULL;         // String representation of rule
2087 
2088   skipws();                       // Skip leading whitespace
2089 
2090   peep = new Peephole();          // Build new Peephole object
2091   // Check for open block sequence
2092   skipws();                       // Skip leading whitespace
2093   if (_curchar == &#39;%&#39; &amp;&amp; *(_ptr+1) == &#39;{&#39;) {
2094     next_char(); next_char();     // Skip &quot;%{&quot;
2095     skipws();
2096     while (_curchar != &#39;%&#39; &amp;&amp; *(_ptr+1) != &#39;}&#39;) {
2097       char *token = get_ident();
2098       if (token == NULL) {
2099         parse_err(SYNERR, &quot;missing identifier inside peephole rule.\n&quot;);
2100         return;
2101       }
2102       // check for legal subsections of peephole rule
2103       if (strcmp(token,&quot;peepmatch&quot;)==0) {
2104         peep_match_parse(*peep); }
2105       else if (strcmp(token,&quot;peepconstraint&quot;)==0) {
2106         peep_constraint_parse(*peep); }
2107       else if (strcmp(token,&quot;peepreplace&quot;)==0) {
2108         peep_replace_parse(*peep); }
2109       else {
2110         parse_err(SYNERR, &quot;expected peepmatch, peepconstraint, or peepreplace for identifier %s.\n&quot;, token);
2111       }
2112       skipws();
2113     }
2114   }
2115   else {
2116     parse_err(SYNERR, &quot;Missing %%{ ... %%} block after peephole keyword.\n&quot;);
2117     return;
2118   }
2119   next_char();                    // Skip past &#39;%&#39;
2120   next_char();                    // Skip past &#39;}&#39;
2121 }
2122 
2123 // ******************** Private Level 2 Parse Functions ********************
2124 //------------------------------constraint_parse------------------------------
2125 Constraint *ADLParser::constraint_parse(void) {
2126   char *func;
2127   char *arg;
2128 
2129   // Check for constraint expression
2130   skipws();
2131   if (_curchar != &#39;(&#39;) {
2132     parse_err(SYNERR, &quot;missing constraint expression, (...)\n&quot;);
2133     return NULL;
2134   }
2135   next_char();                    // Skip past &#39;(&#39;
2136 
2137   // Get constraint function
2138   skipws();
2139   func = get_ident();
2140   if (func == NULL) {
2141     parse_err(SYNERR, &quot;missing function in constraint expression.\n&quot;);
2142     return NULL;
2143   }
2144   if (strcmp(func,&quot;ALLOC_IN_RC&quot;)==0
2145       || strcmp(func,&quot;IS_R_CLASS&quot;)==0) {
2146     // Check for &#39;(&#39; before argument
2147     skipws();
2148     if (_curchar != &#39;(&#39;) {
2149       parse_err(SYNERR, &quot;missing &#39;(&#39; for constraint function&#39;s argument.\n&quot;);
2150       return NULL;
2151     }
2152     next_char();
2153 
2154     // Get it&#39;s argument
2155     skipws();
2156     arg = get_ident();
2157     if (arg == NULL) {
2158       parse_err(SYNERR, &quot;missing argument for constraint function %s\n&quot;,func);
2159       return NULL;
2160     }
2161     // Check for &#39;)&#39; after argument
2162     skipws();
2163     if (_curchar != &#39;)&#39;) {
2164       parse_err(SYNERR, &quot;missing &#39;)&#39; after constraint function argument %s\n&quot;,arg);
2165       return NULL;
2166     }
2167     next_char();
2168   } else {
2169     parse_err(SYNERR, &quot;Invalid constraint function %s\n&quot;,func);
2170     return NULL;
2171   }
2172 
2173   // Check for closing paren and &#39;;&#39;
2174   skipws();
2175   if (_curchar != &#39;)&#39;) {
2176     parse_err(SYNERR, &quot;Missing &#39;)&#39; for constraint function %s\n&quot;,func);
2177     return NULL;
2178   }
2179   next_char();
2180   skipws();
2181   if (_curchar != &#39;;&#39;) {
2182     parse_err(SYNERR, &quot;Missing &#39;;&#39; after constraint.\n&quot;);
2183     return NULL;
2184   }
2185   next_char();
2186 
2187   // Create new &quot;Constraint&quot;
2188   Constraint *constraint = new Constraint(func,arg);
2189   return constraint;
2190 }
2191 
2192 //------------------------------constr_parse-----------------------------------
2193 ConstructRule *ADLParser::construct_parse(void) {
2194   return NULL;
2195 }
2196 
2197 
2198 //------------------------------reg_def_parse----------------------------------
2199 void ADLParser::reg_def_parse(void) {
2200   char *rname;                   // Name of register being defined
2201 
2202   // Get register name
2203   skipws();                      // Skip whitespace
2204   rname = get_ident();
2205   if (rname == NULL) {
2206     parse_err(SYNERR, &quot;missing register name after reg_def\n&quot;);
2207     return;
2208   }
2209 
2210   // Check for definition of register calling convention (save on call, ...),
2211   // register save type, and register encoding value.
2212   skipws();
2213   char *callconv  = NULL;
2214   char *c_conv    = NULL;
2215   char *idealtype = NULL;
2216   char *encoding  = NULL;
2217   char *concrete = NULL;
2218   if (_curchar == &#39;(&#39;) {
2219     next_char();
2220     callconv = get_ident();
2221     // Parse the internal calling convention, must be NS, SOC, SOE, or AS.
2222     if (callconv == NULL) {
2223       parse_err(SYNERR, &quot;missing register calling convention value\n&quot;);
2224       return;
2225     }
2226     if(strcmp(callconv, &quot;SOC&quot;) &amp;&amp; strcmp(callconv,&quot;SOE&quot;) &amp;&amp;
2227        strcmp(callconv, &quot;NS&quot;) &amp;&amp; strcmp(callconv, &quot;AS&quot;)) {
2228       parse_err(SYNERR, &quot;invalid value for register calling convention\n&quot;);
2229     }
2230     skipws();
2231     if (_curchar != &#39;,&#39;) {
2232       parse_err(SYNERR, &quot;missing comma in register definition statement\n&quot;);
2233       return;
2234     }
2235     next_char();
2236 
2237     // Parse the native calling convention, must be NS, SOC, SOE, AS
2238     c_conv = get_ident();
2239     if (c_conv == NULL) {
2240       parse_err(SYNERR, &quot;missing register native calling convention value\n&quot;);
2241       return;
2242     }
2243     if(strcmp(c_conv, &quot;SOC&quot;) &amp;&amp; strcmp(c_conv,&quot;SOE&quot;) &amp;&amp;
2244        strcmp(c_conv, &quot;NS&quot;) &amp;&amp; strcmp(c_conv, &quot;AS&quot;)) {
2245       parse_err(SYNERR, &quot;invalid value for register calling convention\n&quot;);
2246     }
2247     skipws();
2248     if (_curchar != &#39;,&#39;) {
2249       parse_err(SYNERR, &quot;missing comma in register definition statement\n&quot;);
2250       return;
2251     }
2252     next_char();
2253     skipws();
2254 
2255     // Parse the ideal save type
2256     idealtype = get_ident();
2257     if (idealtype == NULL) {
2258       parse_err(SYNERR, &quot;missing register save type value\n&quot;);
2259       return;
2260     }
2261     skipws();
2262     if (_curchar != &#39;,&#39;) {
2263       parse_err(SYNERR, &quot;missing comma in register definition statement\n&quot;);
2264       return;
2265     }
2266     next_char();
2267     skipws();
2268 
2269     // Parse the encoding value
2270     encoding = get_expr(&quot;encoding&quot;, &quot;,&quot;);
2271     if (encoding == NULL) {
2272       parse_err(SYNERR, &quot;missing register encoding value\n&quot;);
2273       return;
2274     }
2275     trim(encoding);
2276     if (_curchar != &#39;,&#39;) {
2277       parse_err(SYNERR, &quot;missing comma in register definition statement\n&quot;);
2278       return;
2279     }
2280     next_char();
2281     skipws();
2282     // Parse the concrete name type
2283     // concrete = get_ident();
2284     concrete = get_expr(&quot;concrete&quot;, &quot;)&quot;);
2285     if (concrete == NULL) {
2286       parse_err(SYNERR, &quot;missing vm register name value\n&quot;);
2287       return;
2288     }
2289 
2290     if (_curchar != &#39;)&#39;) {
2291       parse_err(SYNERR, &quot;missing &#39;)&#39; in register definition statement\n&quot;);
2292       return;
2293     }
2294     next_char();
2295   }
2296 
2297   // Check for closing &#39;;&#39;
2298   skipws();
2299   if (_curchar != &#39;;&#39;) {
2300     parse_err(SYNERR, &quot;missing &#39;;&#39; after reg_def\n&quot;);
2301     return;
2302   }
2303   next_char();                   // move past &#39;;&#39;
2304 
2305   // Debug Stuff
2306   if (_AD._adl_debug &gt; 1) {
2307     fprintf(stderr,&quot;Register Definition: %s ( %s, %s %s )\n&quot;, rname,
2308             (callconv ? callconv : &quot;&quot;), (c_conv ? c_conv : &quot;&quot;), concrete);
2309   }
2310 
2311   // Record new register definition.
2312   _AD._register-&gt;addRegDef(rname, callconv, c_conv, idealtype, encoding, concrete);
2313   return;
2314 }
2315 
2316 //------------------------------reg_class_parse--------------------------------
2317 void ADLParser::reg_class_parse(void) {
2318   char *cname;                    // Name of register class being defined
2319 
2320   // Get register class name
2321   skipws();                       // Skip leading whitespace
2322   cname = get_ident();
2323   if (cname == NULL) {
2324     parse_err(SYNERR, &quot;missing register class name after &#39;reg_class&#39;\n&quot;);
2325     return;
2326   }
2327   // Debug Stuff
2328   if (_AD._adl_debug &gt;1) fprintf(stderr,&quot;Register Class: %s\n&quot;, cname);
2329 
2330   skipws();
2331   if (_curchar == &#39;(&#39;) {
2332     // A register list is defined for the register class.
2333     // Collect registers into a generic RegClass register class.
2334     RegClass* reg_class = _AD._register-&gt;addRegClass&lt;RegClass&gt;(cname);
2335 
2336     next_char();                  // Skip &#39;(&#39;
2337     skipws();
2338     while (_curchar != &#39;)&#39;) {
2339       char *rname = get_ident();
2340       if (rname==NULL) {
2341         parse_err(SYNERR, &quot;missing identifier inside reg_class list.\n&quot;);
2342         return;
2343       }
2344       RegDef *regDef = _AD._register-&gt;getRegDef(rname);
2345       if (!regDef) {
2346         parse_err(SEMERR, &quot;unknown identifier %s inside reg_class list.\n&quot;, rname);
2347       } else {
2348         reg_class-&gt;addReg(regDef); // add regDef to regClass
2349       }
2350 
2351       // Check for &#39;,&#39; and position to next token.
2352       skipws();
2353       if (_curchar == &#39;,&#39;) {
2354         next_char();              // Skip trailing &#39;,&#39;
2355         skipws();
2356       }
2357     }
2358     next_char();                  // Skip closing &#39;)&#39;
2359   } else if (_curchar == &#39;%&#39;) {
2360     // A code snippet is defined for the register class.
2361     // Collect the code snippet into a CodeSnippetRegClass register class.
2362     CodeSnippetRegClass* reg_class = _AD._register-&gt;addRegClass&lt;CodeSnippetRegClass&gt;(cname);
2363     char *code = find_cpp_block(&quot;reg class&quot;);
2364     if (code == NULL) {
2365       parse_err(SYNERR, &quot;missing code declaration for reg class.\n&quot;);
2366       return;
2367     }
2368     reg_class-&gt;set_code_snippet(code);
2369     return;
2370   }
2371 
2372   // Check for terminating &#39;;&#39;
2373   skipws();
2374   if (_curchar != &#39;;&#39;) {
2375     parse_err(SYNERR, &quot;missing &#39;;&#39; at end of reg_class definition.\n&quot;);
2376     return;
2377   }
2378   next_char();                    // Skip trailing &#39;;&#39;
2379 
2380   // Check RegClass size, must be &lt;= 32 registers in class.
2381 
2382   return;
2383 }
2384 
2385 //------------------------------reg_class_dynamic_parse------------------------
2386 void ADLParser::reg_class_dynamic_parse(void) {
2387   char *cname; // Name of dynamic register class being defined
2388 
2389   // Get register class name
2390   skipws();
2391   cname = get_ident();
2392   if (cname == NULL) {
2393     parse_err(SYNERR, &quot;missing dynamic register class name after &#39;reg_class_dynamic&#39;\n&quot;);
2394     return;
2395   }
2396 
2397   if (_AD._adl_debug &gt; 1) {
2398     fprintf(stdout, &quot;Dynamic Register Class: %s\n&quot;, cname);
2399   }
2400 
2401   skipws();
2402   if (_curchar != &#39;(&#39;) {
2403     parse_err(SYNERR, &quot;missing &#39;(&#39; at the beginning of reg_class_dynamic definition\n&quot;);
2404     return;
2405   }
2406   next_char();
2407   skipws();
2408 
2409   // Collect two register classes and the C++ code representing the condition code used to
2410   // select between the two classes into a ConditionalRegClass register class.
2411   ConditionalRegClass* reg_class = _AD._register-&gt;addRegClass&lt;ConditionalRegClass&gt;(cname);
2412   int i;
2413   for (i = 0; i &lt; 2; i++) {
2414     char* name = get_ident();
2415     if (name == NULL) {
2416       parse_err(SYNERR, &quot;missing class identifier inside reg_class_dynamic list.\n&quot;);
2417       return;
2418     }
2419     RegClass* rc = _AD._register-&gt;getRegClass(name);
2420     if (rc == NULL) {
2421       parse_err(SEMERR, &quot;unknown identifier %s inside reg_class_dynamic list.\n&quot;, name);
2422     } else {
2423       reg_class-&gt;set_rclass_at_index(i, rc);
2424     }
2425 
2426     skipws();
2427     if (_curchar == &#39;,&#39;) {
2428       next_char();
2429       skipws();
2430     } else {
2431       parse_err(SYNERR, &quot;missing separator &#39;,&#39; inside reg_class_dynamic list.\n&quot;);
2432     }
2433   }
2434 
2435   // Collect the condition code.
2436   skipws();
2437   if (_curchar == &#39;%&#39;) {
2438     char* code = find_cpp_block(&quot;reg class dynamic&quot;);
2439     if (code == NULL) {
2440        parse_err(SYNERR, &quot;missing code declaration for reg_class_dynamic.\n&quot;);
2441        return;
2442     }
2443     reg_class-&gt;set_condition_code(code);
2444   } else {
2445     parse_err(SYNERR, &quot;missing %% at the beginning of code block in reg_class_dynamic definition\n&quot;);
2446     return;
2447   }
2448 
2449   skipws();
2450   if (_curchar != &#39;)&#39;) {
2451     parse_err(SYNERR, &quot;missing &#39;)&#39; at the end of reg_class_dynamic definition\n&quot;);
2452     return;
2453   }
2454   next_char();
2455 
2456   skipws();
2457   if (_curchar != &#39;;&#39;) {
2458     parse_err(SYNERR, &quot;missing &#39;;&#39; at the end of reg_class_dynamic definition.\n&quot;);
2459     return;
2460   }
2461   next_char();                    // Skip trailing &#39;;&#39;
2462 
2463   return;
2464 }
2465 
2466 //------------------------------alloc_class_parse------------------------------
2467 void ADLParser::alloc_class_parse(void) {
2468   char *name;                     // Name of allocation class being defined
2469 
2470   // Get allocation class name
2471   skipws();                       // Skip leading whitespace
2472   name = get_ident();
2473   if (name == NULL) {
2474     parse_err(SYNERR, &quot;missing allocation class name after &#39;reg_class&#39;\n&quot;);
2475     return;
2476   }
2477   // Debug Stuff
2478   if (_AD._adl_debug &gt;1) fprintf(stderr,&quot;Allocation Class: %s\n&quot;, name);
2479 
2480   AllocClass *alloc_class = _AD._register-&gt;addAllocClass(name);
2481 
2482   // Collect registers in class
2483   skipws();
2484   if (_curchar == &#39;(&#39;) {
2485     next_char();                  // Skip &#39;(&#39;
2486     skipws();
2487     while (_curchar != &#39;)&#39;) {
2488       char *rname = get_ident();
2489       if (rname==NULL) {
2490         parse_err(SYNERR, &quot;missing identifier inside reg_class list.\n&quot;);
2491         return;
2492       }
2493       // Check if name is a RegDef
2494       RegDef *regDef = _AD._register-&gt;getRegDef(rname);
2495       if (regDef) {
2496         alloc_class-&gt;addReg(regDef);   // add regDef to allocClass
2497       } else {
2498 
2499         // name must be a RegDef or a RegClass
2500         parse_err(SYNERR, &quot;name %s should be a previously defined reg_def.\n&quot;, rname);
2501         return;
2502       }
2503 
2504       // Check for &#39;,&#39; and position to next token.
2505       skipws();
2506       if (_curchar == &#39;,&#39;) {
2507         next_char();              // Skip trailing &#39;,&#39;
2508         skipws();
2509       }
2510     }
2511     next_char();                  // Skip closing &#39;)&#39;
2512   }
2513 
2514   // Check for terminating &#39;;&#39;
2515   skipws();
2516   if (_curchar != &#39;;&#39;) {
2517     parse_err(SYNERR, &quot;missing &#39;;&#39; at end of reg_class definition.\n&quot;);
2518     return;
2519   }
2520   next_char();                    // Skip trailing &#39;;&#39;
2521 
2522   return;
2523 }
2524 
2525 //------------------------------peep_match_child_parse-------------------------
2526 InstructForm *ADLParser::peep_match_child_parse(PeepMatch &amp;match, int parent, int &amp;position, int input){
2527   char      *token  = NULL;
2528   int        lparen = 0;          // keep track of parenthesis nesting depth
2529   int        rparen = 0;          // position of instruction at this depth
2530   InstructForm *inst_seen  = NULL;
2531 
2532   // Walk the match tree,
2533   // Record &lt;parent, position, instruction name, input position&gt;
2534   while ( lparen &gt;= rparen ) {
2535     skipws();
2536     // Left paren signals start of an input, collect with recursive call
2537     if (_curchar == &#39;(&#39;) {
2538       ++lparen;
2539       next_char();
2540       ( void ) peep_match_child_parse(match, parent, position, rparen);
2541     }
2542     // Right paren signals end of an input, may be more
2543     else if (_curchar == &#39;)&#39;) {
2544       ++rparen;
2545       if( rparen == lparen ) { // IF rparen matches an lparen I&#39;ve seen
2546         next_char();           //    move past &#39;)&#39;
2547       } else {                 // ELSE leave &#39;)&#39; for parent
2548         assert( rparen == lparen + 1, &quot;Should only see one extra &#39;)&#39;&quot;);
2549         // if an instruction was not specified for this paren-pair
2550         if( ! inst_seen ) {   // record signal entry
2551           match.add_instruction( parent, position, NameList::_signal, input );
2552           ++position;
2553         }
2554         // ++input;   // TEMPORARY
2555         return inst_seen;
2556       }
2557     }
2558     // if no parens, then check for instruction name
2559     // This instruction is the parent of a sub-tree
2560     else if ((token = get_ident_dup()) != NULL) {
2561       const Form *form = _AD._globalNames[token];
2562       if (form) {
2563         InstructForm *inst = form-&gt;is_instruction();
2564         // Record the first instruction at this level
2565         if( inst_seen == NULL ) {
2566           inst_seen = inst;
2567         }
2568         if (inst) {
2569           match.add_instruction( parent, position, token, input );
2570           parent = position;
2571           ++position;
2572         } else {
2573           parse_err(SYNERR, &quot;instruction name expected at identifier %s.\n&quot;,
2574                     token);
2575           return inst_seen;
2576         }
2577       }
2578       else {
2579         parse_err(SYNERR, &quot;missing identifier in peepmatch rule.\n&quot;);
2580         return NULL;
2581       }
2582     }
2583     else {
2584       parse_err(SYNERR, &quot;missing identifier in peepmatch rule.\n&quot;);
2585       return NULL;
2586     }
2587 
2588   } // end while
2589 
2590   assert( false, &quot;ShouldNotReachHere();&quot;);
2591   return NULL;
2592 }
2593 
2594 //------------------------------peep_match_parse-------------------------------
2595 // Syntax for a peepmatch rule
2596 //
2597 // peepmatch ( root_instr_name [(instruction subtree)] [,(instruction subtree)]* );
2598 //
2599 void ADLParser::peep_match_parse(Peephole &amp;peep) {
2600 
2601   skipws();
2602   // Check the structure of the rule
2603   // Check for open paren
2604   if (_curchar != &#39;(&#39;) {
2605     parse_err(SYNERR, &quot;missing &#39;(&#39; at start of peepmatch rule.\n&quot;);
2606     return;
2607   }
2608   next_char();   // skip &#39;(&#39;
2609 
2610   // Construct PeepMatch and parse the peepmatch rule.
2611   PeepMatch *match = new PeepMatch(_ptr);
2612   int  parent   = -1;                   // parent of root
2613   int  position = 0;                    // zero-based positions
2614   int  input    = 0;                    // input position in parent&#39;s operands
2615   InstructForm *root= peep_match_child_parse( *match, parent, position, input);
2616   if( root == NULL ) {
2617     parse_err(SYNERR, &quot;missing instruction-name at start of peepmatch.\n&quot;);
2618     return;
2619   }
2620 
2621   if( _curchar != &#39;)&#39; ) {
2622     parse_err(SYNERR, &quot;missing &#39;)&#39; at end of peepmatch.\n&quot;);
2623     return;
2624   }
2625   next_char();   // skip &#39;)&#39;
2626 
2627   // Check for closing semicolon
2628   skipws();
2629   if( _curchar != &#39;;&#39; ) {
2630     parse_err(SYNERR, &quot;missing &#39;;&#39; at end of peepmatch.\n&quot;);
2631     return;
2632   }
2633   next_char();   // skip &#39;;&#39;
2634 
2635   // Store match into peep, and store peep into instruction
2636   peep.add_match(match);
2637   root-&gt;append_peephole(&amp;peep);
2638 }
2639 
2640 //------------------------------peep_constraint_parse--------------------------
2641 // Syntax for a peepconstraint rule
2642 // A parenthesized list of relations between operands in peepmatch subtree
2643 //
2644 // peepconstraint %{
2645 // (instruction_number.operand_name
2646 //     relational_op
2647 //  instruction_number.operand_name OR register_name
2648 //  [, ...] );
2649 //
2650 // // instruction numbers are zero-based using topological order in peepmatch
2651 //
2652 void ADLParser::peep_constraint_parse(Peephole &amp;peep) {
2653 
2654   skipws();
2655   // Check the structure of the rule
2656   // Check for open paren
2657   if (_curchar != &#39;(&#39;) {
2658     parse_err(SYNERR, &quot;missing &#39;(&#39; at start of peepconstraint rule.\n&quot;);
2659     return;
2660   }
2661   else {
2662     next_char();                  // Skip &#39;(&#39;
2663   }
2664 
2665   // Check for a constraint
2666   skipws();
2667   while( _curchar != &#39;)&#39; ) {
2668     // Get information on the left instruction and its operand
2669     // left-instructions&#39;s number
2670     int left_inst = get_int();
2671     // Left-instruction&#39;s operand
2672     skipws();
2673     if( _curchar != &#39;.&#39; ) {
2674       parse_err(SYNERR, &quot;missing &#39;.&#39; in peepconstraint after instruction number.\n&quot;);
2675       return;
2676     }
2677     next_char();                  // Skip &#39;.&#39;
2678     char *left_op = get_ident_dup();
2679 
2680     skipws();
2681     // Collect relational operator
2682     char *relation = get_relation_dup();
2683 
2684     skipws();
2685     // Get information on the right instruction and its operand
2686     int right_inst;        // Right-instructions&#39;s number
2687     if( isdigit(_curchar) ) {
2688       right_inst = get_int();
2689       // Right-instruction&#39;s operand
2690       skipws();
2691       if( _curchar != &#39;.&#39; ) {
2692         parse_err(SYNERR, &quot;missing &#39;.&#39; in peepconstraint after instruction number.\n&quot;);
2693         return;
2694       }
2695       next_char();              // Skip &#39;.&#39;
2696     } else {
2697       right_inst = -1;          // Flag as being a register constraint
2698     }
2699 
2700     char *right_op = get_ident_dup();
2701 
2702     // Construct the next PeepConstraint
2703     PeepConstraint *constraint = new PeepConstraint( left_inst, left_op,
2704                                                      relation,
2705                                                      right_inst, right_op );
2706     // And append it to the list for this peephole rule
2707     peep.append_constraint( constraint );
2708 
2709     // Check for another constraint, or end of rule
2710     skipws();
2711     if( _curchar == &#39;,&#39; ) {
2712       next_char();                // Skip &#39;,&#39;
2713       skipws();
2714     }
2715     else if( _curchar != &#39;)&#39; ) {
2716       parse_err(SYNERR, &quot;expected &#39;,&#39; or &#39;)&#39; after peephole constraint.\n&quot;);
2717       return;
2718     }
2719   } // end while( processing constraints )
2720   next_char();                    // Skip &#39;)&#39;
2721 
2722   // Check for terminating &#39;;&#39;
2723   skipws();
2724   if (_curchar != &#39;;&#39;) {
2725     parse_err(SYNERR, &quot;missing &#39;;&#39; at end of peepconstraint.\n&quot;);
2726     return;
2727   }
2728   next_char();                    // Skip trailing &#39;;&#39;
2729 }
2730 
2731 
2732 //------------------------------peep_replace_parse-----------------------------
2733 // Syntax for a peepreplace rule
2734 // root instruction name followed by a
2735 // parenthesized list of whitespace separated instruction.operand specifiers
2736 //
2737 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
2738 //
2739 //
2740 void ADLParser::peep_replace_parse(Peephole &amp;peep) {
2741   int          lparen = 0;        // keep track of parenthesis nesting depth
2742   int          rparen = 0;        // keep track of parenthesis nesting depth
2743   int          icount = 0;        // count of instructions in rule for naming
2744   char        *str    = NULL;
2745   char        *token  = NULL;
2746 
2747   skipws();
2748   // Check for open paren
2749   if (_curchar != &#39;(&#39;) {
2750     parse_err(SYNERR, &quot;missing &#39;(&#39; at start of peepreplace rule.\n&quot;);
2751     return;
2752   }
2753   else {
2754     lparen++;
2755     next_char();
2756   }
2757 
2758   // Check for root instruction
2759   char       *inst = get_ident_dup();
2760   const Form *form = _AD._globalNames[inst];
2761   if( form == NULL || form-&gt;is_instruction() == NULL ) {
2762     parse_err(SYNERR, &quot;Instruction name expected at start of peepreplace.\n&quot;);
2763     return;
2764   }
2765 
2766   // Store string representation of rule into replace
2767   PeepReplace *replace = new PeepReplace(str);
2768   replace-&gt;add_instruction( inst );
2769 
2770   skipws();
2771   // Start of root&#39;s operand-list
2772   if (_curchar != &#39;(&#39;) {
2773     parse_err(SYNERR, &quot;missing &#39;(&#39; at peepreplace root&#39;s operand-list.\n&quot;);
2774     return;
2775   }
2776   else {
2777     lparen++;
2778     next_char();
2779   }
2780 
2781   skipws();
2782   // Get the list of operands
2783   while( _curchar != &#39;)&#39; ) {
2784     // Get information on an instruction and its operand
2785     // instructions&#39;s number
2786     int   inst_num = get_int();
2787     // Left-instruction&#39;s operand
2788     skipws();
2789     if( _curchar != &#39;.&#39; ) {
2790       parse_err(SYNERR, &quot;missing &#39;.&#39; in peepreplace after instruction number.\n&quot;);
2791       return;
2792     }
2793     next_char();                  // Skip &#39;.&#39;
2794     char *inst_op = get_ident_dup();
2795     if( inst_op == NULL ) {
2796       parse_err(SYNERR, &quot;missing operand identifier in peepreplace.\n&quot;);
2797       return;
2798     }
2799 
2800     // Record this operand&#39;s position in peepmatch
2801     replace-&gt;add_operand( inst_num, inst_op );
2802     skipws();
2803   }
2804 
2805   // Check for the end of operands list
2806   skipws();
2807   assert( _curchar == &#39;)&#39;, &quot;While loop should have advanced to &#39;)&#39;.&quot;);
2808   next_char();  // Skip &#39;)&#39;
2809 
2810   skipws();
2811   // Check for end of peepreplace
2812   if( _curchar != &#39;)&#39; ) {
2813     parse_err(SYNERR, &quot;missing &#39;)&#39; at end of peepmatch.\n&quot;);
2814     parse_err(SYNERR, &quot;Support one replacement instruction.\n&quot;);
2815     return;
2816   }
2817   next_char(); // Skip &#39;)&#39;
2818 
2819   // Check for closing semicolon
2820   skipws();
2821   if( _curchar != &#39;;&#39; ) {
2822     parse_err(SYNERR, &quot;missing &#39;;&#39; at end of peepreplace.\n&quot;);
2823     return;
2824   }
2825   next_char();   // skip &#39;;&#39;
2826 
2827   // Store replace into peep
2828   peep.add_replace( replace );
2829 }
2830 
2831 //------------------------------pred_parse-------------------------------------
2832 Predicate *ADLParser::pred_parse(void) {
2833   Predicate *predicate;           // Predicate class for operand
2834   char      *rule = NULL;         // String representation of predicate
2835 
2836   skipws();                       // Skip leading whitespace
2837   int line = linenum();
2838   if ( (rule = get_paren_expr(&quot;pred expression&quot;, true)) == NULL ) {
2839     parse_err(SYNERR, &quot;incorrect or missing expression for &#39;predicate&#39;\n&quot;);
2840     return NULL;
2841   }
2842   // Debug Stuff
2843   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Predicate: %s\n&quot;, rule);
2844   if (_curchar != &#39;;&#39;) {
2845     parse_err(SYNERR, &quot;missing &#39;;&#39; in predicate definition\n&quot;);
2846     return NULL;
2847   }
2848   next_char();                     // Point after the terminator
2849 
2850   predicate = new Predicate(rule); // Build new predicate object
2851   skipws();
2852   return predicate;
2853 }
2854 
2855 
2856 //------------------------------ins_encode_parse_block-------------------------
2857 // Parse the block form of ins_encode.  See ins_encode_parse for more details
2858 void ADLParser::ins_encode_parse_block(InstructForm&amp; inst) {
2859   // Create a new encoding name based on the name of the instruction
2860   // definition, which should be unique.
2861   const char* prefix = &quot;__ins_encode_&quot;;
2862   char* ec_name = (char*) AllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);
2863   sprintf(ec_name, &quot;%s%s&quot;, prefix, inst._ident);
2864 
2865   assert(_AD._encode-&gt;encClass(ec_name) == NULL, &quot;shouldn&#39;t already exist&quot;);
2866   EncClass* encoding = _AD._encode-&gt;add_EncClass(ec_name);
2867   encoding-&gt;_linenum = linenum();
2868 
2869   // synthesize the arguments list for the enc_class from the
2870   // arguments to the instruct definition.
2871   const char* param = NULL;
2872   inst._parameters.reset();
2873   while ((param = inst._parameters.iter()) != NULL) {
2874     OpClassForm* opForm = inst._localNames[param]-&gt;is_opclass();
2875     assert(opForm != NULL, &quot;sanity&quot;);
2876     encoding-&gt;add_parameter(opForm-&gt;_ident, param);
2877   }
2878 
2879   if (!inst._is_postalloc_expand) {
2880     // Define a MacroAssembler instance for use by the encoding.  The
2881     // name is chosen to match the __ idiom used for assembly in other
2882     // parts of hotspot and assumes the existence of the standard
2883     // #define __ _masm.
2884     encoding-&gt;add_code(&quot;    C2_MacroAssembler _masm(&amp;cbuf);\n&quot;);
2885   }
2886 
2887   // Parse the following %{ }% block
2888   ins_encode_parse_block_impl(inst, encoding, ec_name);
2889 
2890   // Build an encoding rule which invokes the encoding rule we just
2891   // created, passing all arguments that we received.
2892   InsEncode*   encrule = new InsEncode(); // Encode class for instruction
2893   NameAndList* params  = encrule-&gt;add_encode(ec_name);
2894   inst._parameters.reset();
2895   while ((param = inst._parameters.iter()) != NULL) {
2896     params-&gt;add_entry(param);
2897   }
2898 
2899   // Check for duplicate ins_encode sections after parsing the block
2900   // so that parsing can continue and find any other errors.
2901   if (inst._insencode != NULL) {
2902     parse_err(SYNERR, &quot;Multiple ins_encode sections defined\n&quot;);
2903     return;
2904   }
2905 
2906   // Set encode class of this instruction.
2907   inst._insencode = encrule;
2908 }
2909 
2910 
2911 void ADLParser::ins_encode_parse_block_impl(InstructForm&amp; inst, EncClass* encoding, char* ec_name) {
2912   skipws_no_preproc();              // Skip leading whitespace
2913   // Prepend location descriptor, for debugging; cf. ADLParser::find_cpp_block
2914   if (_AD._adlocation_debug) {
2915     encoding-&gt;add_code(get_line_string());
2916   }
2917 
2918   // Collect the parts of the encode description
2919   // (1) strings that are passed through to output
2920   // (2) replacement/substitution variable, preceeded by a &#39;$&#39;
2921   while ((_curchar != &#39;%&#39;) &amp;&amp; (*(_ptr+1) != &#39;}&#39;)) {
2922 
2923     // (1)
2924     // Check if there is a string to pass through to output
2925     char *start = _ptr;       // Record start of the next string
2926     while ((_curchar != &#39;$&#39;) &amp;&amp; ((_curchar != &#39;%&#39;) || (*(_ptr+1) != &#39;}&#39;)) ) {
2927       // If at the start of a comment, skip past it
2928       if( (_curchar == &#39;/&#39;) &amp;&amp; ((*(_ptr+1) == &#39;/&#39;) || (*(_ptr+1) == &#39;*&#39;)) ) {
2929         skipws_no_preproc();
2930       } else {
2931         // ELSE advance to the next character, or start of the next line
2932         next_char_or_line();
2933       }
2934     }
2935     // If a string was found, terminate it and record in EncClass
2936     if (start != _ptr) {
2937       *_ptr = &#39;\0&#39;;          // Terminate the string
2938       encoding-&gt;add_code(start);
2939     }
2940 
2941     // (2)
2942     // If we are at a replacement variable,
2943     // copy it and record in EncClass
2944     if (_curchar == &#39;$&#39;) {
2945       // Found replacement Variable
2946       char* rep_var = get_rep_var_ident_dup();
2947 
2948       // Add flag to _strings list indicating we should check _rep_vars
2949       encoding-&gt;add_rep_var(rep_var);
2950 
2951       skipws();
2952 
2953       // Check if this instruct is a MachConstantNode.
2954       if (strcmp(rep_var, &quot;constanttablebase&quot;) == 0) {
2955         // This instruct is a MachConstantNode.
2956         inst.set_needs_constant_base(true);
2957         if (strncmp(&quot;MachCall&quot;, inst.mach_base_class(_globalNames), strlen(&quot;MachCall&quot;)) != 0 ) {
2958           inst.set_is_mach_constant(true);
2959         }
2960 
2961         if (_curchar == &#39;(&#39;)  {
2962           parse_err(SYNERR, &quot;constanttablebase in instruct %s cannot have an argument &quot;
2963                             &quot;(only constantaddress and constantoffset)&quot;, ec_name);
2964           return;
2965         }
2966       }
2967       else if ((strcmp(rep_var, &quot;constantaddress&quot;)   == 0) ||
2968                (strcmp(rep_var, &quot;constantoffset&quot;)    == 0)) {
2969         // This instruct is a MachConstantNode.
2970         inst.set_is_mach_constant(true);
2971 
2972         // If the constant keyword has an argument, parse it.
2973         if (_curchar == &#39;(&#39;)  constant_parse(inst);
2974       }
2975     }
2976   } // end while part of format description
2977   next_char();                      // Skip &#39;%&#39;
2978   next_char();                      // Skip &#39;}&#39;
2979 
2980   skipws();
2981 
2982   if (_AD._adlocation_debug) {
2983     encoding-&gt;add_code(end_line_marker());
2984   }
2985 
2986   // Debug Stuff
2987   if (_AD._adl_debug &gt; 1)  fprintf(stderr, &quot;EncodingClass Form: %s\n&quot;, ec_name);
2988 }
2989 
2990 
2991 //------------------------------ins_encode_parse-------------------------------
2992 // Encode rules have the form
2993 //   ins_encode( encode_class_name(parameter_list), ... );
2994 //
2995 // The &quot;encode_class_name&quot; must be defined in the encode section
2996 // The parameter list contains $names that are locals.
2997 //
2998 // Alternatively it can be written like this:
2999 //
3000 //   ins_encode %{
3001 //      ... // body
3002 //   %}
3003 //
3004 // which synthesizes a new encoding class taking the same arguments as
3005 // the InstructForm, and automatically prefixes the definition with:
3006 //
3007 //    C2_MacroAssembler masm(&amp;cbuf);\n&quot;);
3008 //
3009 //  making it more compact to take advantage of the C2_MacroAssembler and
3010 //  placing the assembly closer to it&#39;s use by instructions.
3011 void ADLParser::ins_encode_parse(InstructForm&amp; inst) {
3012 
3013   // Parse encode class name
3014   skipws();                        // Skip whitespace
3015   if (_curchar != &#39;(&#39;) {
3016     // Check for ins_encode %{ form
3017     if ((_curchar == &#39;%&#39;) &amp;&amp; (*(_ptr+1) == &#39;{&#39;)) {
3018       next_char();                      // Skip &#39;%&#39;
3019       next_char();                      // Skip &#39;{&#39;
3020 
3021       // Parse the block form of ins_encode
3022       ins_encode_parse_block(inst);
3023       return;
3024     }
3025 
3026     parse_err(SYNERR, &quot;missing &#39;%%{&#39; or &#39;(&#39; in ins_encode definition\n&quot;);
3027     return;
3028   }
3029   next_char();                     // move past &#39;(&#39;
3030   skipws();
3031 
3032   InsEncode *encrule  = new InsEncode(); // Encode class for instruction
3033   encrule-&gt;_linenum = linenum();
3034   char      *ec_name  = NULL;      // String representation of encode rule
3035   // identifier is optional.
3036   while (_curchar != &#39;)&#39;) {
3037     ec_name = get_ident();
3038     if (ec_name == NULL) {
3039       parse_err(SYNERR, &quot;Invalid encode class name after &#39;ins_encode(&#39;.\n&quot;);
3040       return;
3041     }
3042     // Check that encoding is defined in the encode section
3043     EncClass *encode_class = _AD._encode-&gt;encClass(ec_name);
3044     if (encode_class == NULL) {
3045       // Like to defer checking these till later...
3046       // parse_err(WARN, &quot;Using an undefined encode class &#39;%s&#39; in &#39;ins_encode&#39;.\n&quot;, ec_name);
3047     }
3048 
3049     // Get list for encode method&#39;s parameters
3050     NameAndList *params = encrule-&gt;add_encode(ec_name);
3051 
3052     // Parse the parameters to this encode method.
3053     skipws();
3054     if ( _curchar == &#39;(&#39; ) {
3055       next_char();                 // move past &#39;(&#39; for parameters
3056 
3057       // Parse the encode method&#39;s parameters
3058       while (_curchar != &#39;)&#39;) {
3059         char *param = get_ident_or_literal_constant(&quot;encoding operand&quot;);
3060         if ( param != NULL ) {
3061 
3062           // Check if this instruct is a MachConstantNode.
3063           if (strcmp(param, &quot;constanttablebase&quot;) == 0) {
3064             // This instruct is a MachConstantNode.
3065             inst.set_needs_constant_base(true);
3066             if (strncmp(&quot;MachCall&quot;, inst.mach_base_class(_globalNames), strlen(&quot;MachCall&quot;)) != 0 ) {
3067               inst.set_is_mach_constant(true);
3068             }
3069 
3070             if (_curchar == &#39;(&#39;)  {
3071               parse_err(SYNERR, &quot;constanttablebase in instruct %s cannot have an argument &quot;
3072                         &quot;(only constantaddress and constantoffset)&quot;, ec_name);
3073               return;
3074             }
3075           } else {
3076             // Found a parameter:
3077             // Check it is a local name, add it to the list, then check for more
3078             // New: allow hex constants as parameters to an encode method.
3079             // New: allow parenthesized expressions as parameters.
3080             // New: allow &quot;primary&quot;, &quot;secondary&quot;, &quot;tertiary&quot; as parameters.
3081             // New: allow user-defined register name as parameter
3082             if ( (inst._localNames[param] == NULL) &amp;&amp;
3083                  !ADLParser::is_literal_constant(param) &amp;&amp;
3084                  (Opcode::as_opcode_type(param) == Opcode::NOT_AN_OPCODE) &amp;&amp;
3085                  ((_AD._register == NULL ) || (_AD._register-&gt;getRegDef(param) == NULL)) ) {
3086               parse_err(SYNERR, &quot;Using non-locally defined parameter %s for encoding %s.\n&quot;, param, ec_name);
3087               return;
3088             }
3089           }
3090           params-&gt;add_entry(param);
3091 
3092           skipws();
3093           if (_curchar == &#39;,&#39; ) {
3094             // More parameters to come
3095             next_char();           // move past &#39;,&#39; between parameters
3096             skipws();              // Skip to next parameter
3097           }
3098           else if (_curchar == &#39;)&#39;) {
3099             // Done with parameter list
3100           }
3101           else {
3102             // Only &#39;,&#39; or &#39;)&#39; are valid after a parameter name
3103             parse_err(SYNERR, &quot;expected &#39;,&#39; or &#39;)&#39; after parameter %s.\n&quot;,
3104                       ec_name);
3105             return;
3106           }
3107 
3108         } else {
3109           skipws();
3110           // Did not find a parameter
3111           if (_curchar == &#39;,&#39;) {
3112             parse_err(SYNERR, &quot;Expected encode parameter before &#39;,&#39; in encoding %s.\n&quot;, ec_name);
3113             return;
3114           }
3115           if (_curchar != &#39;)&#39;) {
3116             parse_err(SYNERR, &quot;Expected &#39;)&#39; after encode parameters.\n&quot;);
3117             return;
3118           }
3119         }
3120       } // WHILE loop collecting parameters
3121       next_char();                   // move past &#39;)&#39; at end of parameters
3122     } // done with parameter list for encoding
3123 
3124     // Check for &#39;,&#39; or &#39;)&#39; after encoding
3125     skipws();                      // move to character after parameters
3126     if ( _curchar == &#39;,&#39; ) {
3127       // Found a &#39;,&#39;
3128       next_char();                 // move past &#39;,&#39; between encode methods
3129       skipws();
3130     }
3131     else if ( _curchar != &#39;)&#39; ) {
3132       // If not a &#39;,&#39; then only a &#39;)&#39; is allowed
3133       parse_err(SYNERR, &quot;Expected &#39;)&#39; after encoding %s.\n&quot;, ec_name);
3134       return;
3135     }
3136 
3137     // Check for &#39;,&#39; separating parameters
3138     // if ( _curchar != &#39;,&#39; &amp;&amp; _curchar != &#39;)&#39; ) {
3139     //   parse_err(SYNERR, &quot;expected &#39;,&#39; or &#39;)&#39; after encode method inside ins_encode.\n&quot;);
3140     //   return NULL;
3141     // }
3142 
3143   } // done parsing ins_encode methods and their parameters
3144   if (_curchar != &#39;)&#39;) {
3145     parse_err(SYNERR, &quot;Missing &#39;)&#39; at end of ins_encode description.\n&quot;);
3146     return;
3147   }
3148   next_char();                     // move past &#39;)&#39;
3149   skipws();                        // Skip leading whitespace
3150 
3151   if ( _curchar != &#39;;&#39; ) {
3152     parse_err(SYNERR, &quot;Missing &#39;;&#39; at end of ins_encode.\n&quot;);
3153     return;
3154   }
3155   next_char();                     // move past &#39;;&#39;
3156   skipws();                        // be friendly to oper_parse()
3157 
3158   // Check for duplicate ins_encode sections after parsing the block
3159   // so that parsing can continue and find any other errors.
3160   if (inst._insencode != NULL) {
3161     parse_err(SYNERR, &quot;Multiple ins_encode sections defined\n&quot;);
3162     return;
3163   }
3164 
3165   // Debug Stuff
3166   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Instruction Encode: %s\n&quot;, ec_name);
3167 
3168   // Set encode class of this instruction.
3169   inst._insencode = encrule;
3170 }
3171 
3172 //------------------------------postalloc_expand_parse---------------------------
3173 // Encode rules have the form
3174 //   postalloc_expand( encode_class_name(parameter_list) );
3175 //
3176 // The &quot;encode_class_name&quot; must be defined in the encode section.
3177 // The parameter list contains $names that are locals.
3178 //
3179 // This is just a copy of ins_encode_parse without the loop.
3180 void ADLParser::postalloc_expand_parse(InstructForm&amp; inst) {
3181   inst._is_postalloc_expand = true;
3182 
3183   // Parse encode class name.
3184   skipws();                        // Skip whitespace.
3185   if (_curchar != &#39;(&#39;) {
3186     // Check for postalloc_expand %{ form
3187     if ((_curchar == &#39;%&#39;) &amp;&amp; (*(_ptr+1) == &#39;{&#39;)) {
3188       next_char();                      // Skip &#39;%&#39;
3189       next_char();                      // Skip &#39;{&#39;
3190 
3191       // Parse the block form of postalloc_expand
3192       ins_encode_parse_block(inst);
3193       return;
3194     }
3195 
3196     parse_err(SYNERR, &quot;missing &#39;(&#39; in postalloc_expand definition\n&quot;);
3197     return;
3198   }
3199   next_char();                     // Move past &#39;(&#39;.
3200   skipws();
3201 
3202   InsEncode *encrule = new InsEncode(); // Encode class for instruction.
3203   encrule-&gt;_linenum = linenum();
3204   char      *ec_name = NULL;       // String representation of encode rule.
3205   // identifier is optional.
3206   if (_curchar != &#39;)&#39;) {
3207     ec_name = get_ident();
3208     if (ec_name == NULL) {
3209       parse_err(SYNERR, &quot;Invalid postalloc_expand class name after &#39;postalloc_expand(&#39;.\n&quot;);
3210       return;
3211     }
3212     // Check that encoding is defined in the encode section.
3213     EncClass *encode_class = _AD._encode-&gt;encClass(ec_name);
3214 
3215     // Get list for encode method&#39;s parameters
3216     NameAndList *params = encrule-&gt;add_encode(ec_name);
3217 
3218     // Parse the parameters to this encode method.
3219     skipws();
3220     if (_curchar == &#39;(&#39;) {
3221       next_char();                 // Move past &#39;(&#39; for parameters.
3222 
3223       // Parse the encode method&#39;s parameters.
3224       while (_curchar != &#39;)&#39;) {
3225         char *param = get_ident_or_literal_constant(&quot;encoding operand&quot;);
3226         if (param != NULL) {
3227           // Found a parameter:
3228 
3229           // First check for constant table support.
3230 
3231           // Check if this instruct is a MachConstantNode.
3232           if (strcmp(param, &quot;constanttablebase&quot;) == 0) {
3233             // This instruct is a MachConstantNode.
3234             inst.set_needs_constant_base(true);
3235             if (strncmp(&quot;MachCall&quot;, inst.mach_base_class(_globalNames), strlen(&quot;MachCall&quot;)) != 0 ) {
3236               inst.set_is_mach_constant(true);
3237             }
3238 
3239             if (_curchar == &#39;(&#39;) {
3240               parse_err(SYNERR, &quot;constanttablebase in instruct %s cannot have an argument &quot;
3241                         &quot;(only constantaddress and constantoffset)&quot;, ec_name);
3242               return;
3243             }
3244           }
3245           else if ((strcmp(param, &quot;constantaddress&quot;) == 0) ||
3246                    (strcmp(param, &quot;constantoffset&quot;)  == 0))  {
3247             // This instruct is a MachConstantNode.
3248             inst.set_is_mach_constant(true);
3249 
3250             // If the constant keyword has an argument, parse it.
3251             if (_curchar == &#39;(&#39;) constant_parse(inst);
3252           }
3253 
3254           // Else check it is a local name, add it to the list, then check for more.
3255           // New: allow hex constants as parameters to an encode method.
3256           // New: allow parenthesized expressions as parameters.
3257           // New: allow &quot;primary&quot;, &quot;secondary&quot;, &quot;tertiary&quot; as parameters.
3258           // New: allow user-defined register name as parameter.
3259           else if ((inst._localNames[param] == NULL) &amp;&amp;
3260                    !ADLParser::is_literal_constant(param) &amp;&amp;
3261                    (Opcode::as_opcode_type(param) == Opcode::NOT_AN_OPCODE) &amp;&amp;
3262                    ((_AD._register == NULL) || (_AD._register-&gt;getRegDef(param) == NULL))) {
3263             parse_err(SYNERR, &quot;Using non-locally defined parameter %s for encoding %s.\n&quot;, param, ec_name);
3264             return;
3265           }
3266           params-&gt;add_entry(param);
3267 
3268           skipws();
3269           if (_curchar == &#39;,&#39;) {
3270             // More parameters to come.
3271             next_char();           // Move past &#39;,&#39; between parameters.
3272             skipws();              // Skip to next parameter.
3273           } else if (_curchar == &#39;)&#39;) {
3274             // Done with parameter list
3275           } else {
3276             // Only &#39;,&#39; or &#39;)&#39; are valid after a parameter name.
3277             parse_err(SYNERR, &quot;expected &#39;,&#39; or &#39;)&#39; after parameter %s.\n&quot;, ec_name);
3278             return;
3279           }
3280 
3281         } else {
3282           skipws();
3283           // Did not find a parameter.
3284           if (_curchar == &#39;,&#39;) {
3285             parse_err(SYNERR, &quot;Expected encode parameter before &#39;,&#39; in postalloc_expand %s.\n&quot;, ec_name);
3286             return;
3287           }
3288           if (_curchar != &#39;)&#39;) {
3289             parse_err(SYNERR, &quot;Expected &#39;)&#39; after postalloc_expand parameters.\n&quot;);
3290             return;
3291           }
3292         }
3293       } // WHILE loop collecting parameters.
3294       next_char();                 // Move past &#39;)&#39; at end of parameters.
3295     } // Done with parameter list for encoding.
3296 
3297     // Check for &#39;,&#39; or &#39;)&#39; after encoding.
3298     skipws();                      // Move to character after parameters.
3299     if (_curchar != &#39;)&#39;) {
3300       // Only a &#39;)&#39; is allowed.
3301       parse_err(SYNERR, &quot;Expected &#39;)&#39; after postalloc_expand %s.\n&quot;, ec_name);
3302       return;
3303     }
3304   } // Done parsing postalloc_expand method and their parameters.
3305   if (_curchar != &#39;)&#39;) {
3306     parse_err(SYNERR, &quot;Missing &#39;)&#39; at end of postalloc_expand description.\n&quot;);
3307     return;
3308   }
3309   next_char();                     // Move past &#39;)&#39;.
3310   skipws();                        // Skip leading whitespace.
3311 
3312   if (_curchar != &#39;;&#39;) {
3313     parse_err(SYNERR, &quot;Missing &#39;;&#39; at end of postalloc_expand.\n&quot;);
3314     return;
3315   }
3316   next_char();                     // Move past &#39;;&#39;.
3317   skipws();                        // Be friendly to oper_parse().
3318 
3319   // Debug Stuff.
3320   if (_AD._adl_debug &gt; 1) fprintf(stderr, &quot;Instruction postalloc_expand: %s\n&quot;, ec_name);
3321 
3322   // Set encode class of this instruction.
3323   inst._insencode = encrule;
3324 }
3325 
3326 
3327 //------------------------------constant_parse---------------------------------
3328 // Parse a constant expression.
3329 void ADLParser::constant_parse(InstructForm&amp; inst) {
3330   // Create a new encoding name based on the name of the instruction
3331   // definition, which should be unique.
3332   const char* prefix = &quot;__constant_&quot;;
3333   char* ec_name = (char*) AllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);
3334   sprintf(ec_name, &quot;%s%s&quot;, prefix, inst._ident);
3335 
3336   assert(_AD._encode-&gt;encClass(ec_name) == NULL, &quot;shouldn&#39;t already exist&quot;);
3337   EncClass* encoding = _AD._encode-&gt;add_EncClass(ec_name);
3338   encoding-&gt;_linenum = linenum();
3339 
3340   // synthesize the arguments list for the enc_class from the
3341   // arguments to the instruct definition.
3342   const char* param = NULL;
3343   inst._parameters.reset();
3344   while ((param = inst._parameters.iter()) != NULL) {
3345     OpClassForm* opForm = inst._localNames[param]-&gt;is_opclass();
3346     assert(opForm != NULL, &quot;sanity&quot;);
3347     encoding-&gt;add_parameter(opForm-&gt;_ident, param);
3348   }
3349 
3350   // Parse the following ( ) expression.
3351   constant_parse_expression(encoding, ec_name);
3352 
3353   // Build an encoding rule which invokes the encoding rule we just
3354   // created, passing all arguments that we received.
3355   InsEncode*   encrule = new InsEncode(); // Encode class for instruction
3356   NameAndList* params  = encrule-&gt;add_encode(ec_name);
3357   inst._parameters.reset();
3358   while ((param = inst._parameters.iter()) != NULL) {
3359     params-&gt;add_entry(param);
3360   }
3361 
3362   // Set encode class of this instruction.
3363   inst._constant = encrule;
3364 }
3365 
3366 
3367 //------------------------------constant_parse_expression----------------------
3368 void ADLParser::constant_parse_expression(EncClass* encoding, char* ec_name) {
3369   skipws();
3370 
3371   // Prepend location descriptor, for debugging; cf. ADLParser::find_cpp_block
3372   if (_AD._adlocation_debug) {
3373     encoding-&gt;add_code(get_line_string());
3374   }
3375 
3376   // Start code line.
3377   encoding-&gt;add_code(&quot;    _constant = C-&gt;output()-&gt;constant_table().add&quot;);
3378 
3379   // Parse everything in ( ) expression.
3380   encoding-&gt;add_code(&quot;(this, &quot;);
3381   next_char();  // Skip &#39;(&#39;
3382   int parens_depth = 1;
3383 
3384   // Collect the parts of the constant expression.
3385   // (1) strings that are passed through to output
3386   // (2) replacement/substitution variable, preceeded by a &#39;$&#39;
3387   while (parens_depth &gt; 0) {
3388     if (_curchar == &#39;(&#39;) {
3389       parens_depth++;
3390       encoding-&gt;add_code(&quot;(&quot;);
3391       next_char();
3392     }
3393     else if (_curchar == &#39;)&#39;) {
3394       parens_depth--;
3395       if (parens_depth &gt; 0)
3396         encoding-&gt;add_code(&quot;)&quot;);
3397       next_char();
3398     }
3399     else {
3400       // (1)
3401       // Check if there is a string to pass through to output
3402       char *start = _ptr;  // Record start of the next string
3403       while ((_curchar != &#39;$&#39;) &amp;&amp; (_curchar != &#39;(&#39;) &amp;&amp; (_curchar != &#39;)&#39;)) {
3404         next_char();
3405       }
3406       // If a string was found, terminate it and record in EncClass
3407       if (start != _ptr) {
3408         *_ptr = &#39;\0&#39;;  // Terminate the string
3409         encoding-&gt;add_code(start);
3410       }
3411 
3412       // (2)
3413       // If we are at a replacement variable, copy it and record in EncClass.
3414       if (_curchar == &#39;$&#39;) {
3415         // Found replacement Variable
3416         char* rep_var = get_rep_var_ident_dup();
3417         encoding-&gt;add_rep_var(rep_var);
3418       }
3419     }
3420   }
3421 
3422   // Finish code line.
3423   encoding-&gt;add_code(&quot;);&quot;);
3424 
3425   if (_AD._adlocation_debug) {
3426     encoding-&gt;add_code(end_line_marker());
3427   }
3428 
3429   // Debug Stuff
3430   if (_AD._adl_debug &gt; 1)  fprintf(stderr, &quot;EncodingClass Form: %s\n&quot;, ec_name);
3431 }
3432 
3433 
3434 //------------------------------size_parse-----------------------------------
3435 // Parse a &#39;size(&lt;expr&gt;)&#39; attribute which specifies the size of the
3436 // emitted instructions in bytes. &lt;expr&gt; can be a C++ expression,
3437 // e.g. a constant.
3438 char* ADLParser::size_parse(InstructForm *instr) {
3439   char* sizeOfInstr = NULL;
3440 
3441   // Get value of the instruction&#39;s size
3442   skipws();
3443 
3444   // Parse size
3445   sizeOfInstr = get_paren_expr(&quot;size expression&quot;);
3446   if (sizeOfInstr == NULL) {
3447      parse_err(SYNERR, &quot;size of opcode expected at %c\n&quot;, _curchar);
3448      return NULL;
3449   }
3450 
3451   skipws();
3452 
3453   // Check for terminator
3454   if (_curchar != &#39;;&#39;) {
3455     parse_err(SYNERR, &quot;missing &#39;;&#39; in ins_attrib definition\n&quot;);
3456     return NULL;
3457   }
3458   next_char();                     // Advance past the &#39;;&#39;
3459   skipws();                        // necessary for instr_parse()
3460 
3461   // Debug Stuff
3462   if (_AD._adl_debug &gt; 1) {
3463     if (sizeOfInstr != NULL) {
3464       fprintf(stderr,&quot;size of opcode: %s\n&quot;, sizeOfInstr);
3465     }
3466   }
3467 
3468   return sizeOfInstr;
3469 }
3470 
3471 
3472 //------------------------------opcode_parse-----------------------------------
3473 Opcode * ADLParser::opcode_parse(InstructForm *instr) {
3474   char *primary   = NULL;
3475   char *secondary = NULL;
3476   char *tertiary  = NULL;
3477 
3478   char   *val    = NULL;
3479   Opcode *opcode = NULL;
3480 
3481   // Get value of the instruction&#39;s opcode
3482   skipws();
3483   if (_curchar != &#39;(&#39;) {         // Check for parenthesized operand list
3484     parse_err(SYNERR, &quot;missing &#39;(&#39; in expand instruction declaration\n&quot;);
3485     return NULL;
3486   }
3487   next_char();                   // skip open paren
3488   skipws();
3489   if (_curchar != &#39;)&#39;) {
3490     // Parse primary, secondary, and tertiary opcodes, if provided.
3491     if ( (primary = get_ident_or_literal_constant(&quot;primary opcode&quot;)) == NULL ) {
3492           parse_err(SYNERR, &quot;primary hex opcode expected at %c\n&quot;, _curchar);
3493         return NULL;
3494     }
3495     skipws();
3496     if (_curchar == &#39;,&#39;) {
3497       next_char();
3498       skipws();
3499       // Parse secondary opcode
3500       if ( (secondary = get_ident_or_literal_constant(&quot;secondary opcode&quot;)) == NULL ) {
3501         parse_err(SYNERR, &quot;secondary hex opcode expected at %c\n&quot;, _curchar);
3502         return NULL;
3503       }
3504       skipws();
3505       if (_curchar == &#39;,&#39;) {
3506         next_char();
3507         skipws();
3508         // Parse tertiary opcode
3509         if ( (tertiary = get_ident_or_literal_constant(&quot;tertiary opcode&quot;)) == NULL ) {
3510           parse_err(SYNERR,&quot;tertiary hex opcode expected at %c\n&quot;, _curchar);
3511           return NULL;
3512         }
3513         skipws();
3514       }
3515     }
3516     skipws();
3517     if (_curchar != &#39;)&#39;) {
3518       parse_err(SYNERR, &quot;Missing &#39;)&#39; in opcode description\n&quot;);
3519       return NULL;
3520     }
3521   }
3522   next_char();                     // Skip &#39;)&#39;
3523   skipws();
3524   // Check for terminator
3525   if (_curchar != &#39;;&#39;) {
3526     parse_err(SYNERR, &quot;missing &#39;;&#39; in ins_attrib definition\n&quot;);
3527     return NULL;
3528   }
3529   next_char();                     // Advance past the &#39;;&#39;
3530   skipws();                        // necessary for instr_parse()
3531 
3532   // Debug Stuff
3533   if (_AD._adl_debug &gt; 1) {
3534     if (primary   != NULL) fprintf(stderr,&quot;primary   opcode: %s\n&quot;, primary);
3535     if (secondary != NULL) fprintf(stderr,&quot;secondary opcode: %s\n&quot;, secondary);
3536     if (tertiary  != NULL) fprintf(stderr,&quot;tertiary  opcode: %s\n&quot;, tertiary);
3537   }
3538 
3539   // Generate new object and return
3540   opcode = new Opcode(primary, secondary, tertiary);
3541   return opcode;
3542 }
3543 
3544 
3545 //------------------------------interface_parse--------------------------------
3546 Interface *ADLParser::interface_parse(void) {
3547   char *iface_name  = NULL;      // Name of interface class being used
3548   char *iface_code  = NULL;      // Describe components of this class
3549 
3550   // Get interface class name
3551   skipws();                       // Skip whitespace
3552   if (_curchar != &#39;(&#39;) {
3553     parse_err(SYNERR, &quot;Missing &#39;(&#39; at start of interface description.\n&quot;);
3554     return NULL;
3555   }
3556   next_char();                    // move past &#39;(&#39;
3557   skipws();
3558   iface_name = get_ident();
3559   if (iface_name == NULL) {
3560     parse_err(SYNERR, &quot;missing interface name after &#39;interface&#39;.\n&quot;);
3561     return NULL;
3562   }
3563   skipws();
3564   if (_curchar != &#39;)&#39;) {
3565     parse_err(SYNERR, &quot;Missing &#39;)&#39; after name of interface.\n&quot;);
3566     return NULL;
3567   }
3568   next_char();                    // move past &#39;)&#39;
3569 
3570   // Get details of the interface,
3571   // for the type of interface indicated by iface_name.
3572   Interface *inter = NULL;
3573   skipws();
3574   if ( _curchar != &#39;;&#39; ) {
3575     if ( strcmp(iface_name,&quot;MEMORY_INTER&quot;) == 0 ) {
3576       inter = mem_interface_parse();
3577     }
3578     else if ( strcmp(iface_name,&quot;COND_INTER&quot;) == 0 ) {
3579       inter = cond_interface_parse();
3580     }
3581     // The parse routines consume the &quot;%}&quot;
3582 
3583     // Check for probable extra &#39;;&#39; after defining block.
3584     if ( _curchar == &#39;;&#39; ) {
3585       parse_err(SYNERR, &quot;Extra &#39;;&#39; after defining interface block.\n&quot;);
3586       next_char();                // Skip &#39;;&#39;
3587       return NULL;
3588     }
3589   } else {
3590     next_char();                  // move past &#39;;&#39;
3591 
3592     // Create appropriate interface object
3593     if ( strcmp(iface_name,&quot;REG_INTER&quot;) == 0 ) {
3594       inter = new RegInterface();
3595     }
3596     else if ( strcmp(iface_name,&quot;CONST_INTER&quot;) == 0 ) {
3597       inter = new ConstInterface();
3598     }
3599   }
3600   skipws();                       // be friendly to oper_parse()
3601   // Debug Stuff
3602   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Interface Form: %s\n&quot;, iface_name);
3603 
3604   // Create appropriate interface object and return.
3605   return inter;
3606 }
3607 
3608 
3609 //------------------------------mem_interface_parse----------------------------
3610 Interface *ADLParser::mem_interface_parse(void) {
3611   // Fields for MemInterface
3612   char *base        = NULL;
3613   char *index       = NULL;
3614   char *scale       = NULL;
3615   char *disp        = NULL;
3616 
3617   if (_curchar != &#39;%&#39;) {
3618     parse_err(SYNERR, &quot;Missing &#39;%%{&#39; for &#39;interface&#39; block.\n&quot;);
3619     return NULL;
3620   }
3621   next_char();                  // Skip &#39;%&#39;
3622   if (_curchar != &#39;{&#39;) {
3623     parse_err(SYNERR, &quot;Missing &#39;%%{&#39; for &#39;interface&#39; block.\n&quot;);
3624     return NULL;
3625   }
3626   next_char();                  // Skip &#39;{&#39;
3627   skipws();
3628   do {
3629     char *field = get_ident();
3630     if (field == NULL) {
3631       parse_err(SYNERR, &quot;Expected keyword, base|index|scale|disp,  or &#39;%%}&#39; ending interface.\n&quot;);
3632       return NULL;
3633     }
3634     if ( strcmp(field,&quot;base&quot;) == 0 ) {
3635       base  = interface_field_parse();
3636     }
3637     else if ( strcmp(field,&quot;index&quot;) == 0 ) {
3638       index = interface_field_parse();
3639     }
3640     else if ( strcmp(field,&quot;scale&quot;) == 0 ) {
3641       scale = interface_field_parse();
3642     }
3643     else if ( strcmp(field,&quot;disp&quot;) == 0 ) {
3644       disp  = interface_field_parse();
3645     }
3646     else {
3647       parse_err(SYNERR, &quot;Expected keyword, base|index|scale|disp,  or &#39;%%}&#39; ending interface.\n&quot;);
3648       return NULL;
3649     }
3650   } while( _curchar != &#39;%&#39; );
3651   next_char();                  // Skip &#39;%&#39;
3652   if ( _curchar != &#39;}&#39; ) {
3653     parse_err(SYNERR, &quot;Missing &#39;%%}&#39; for &#39;interface&#39; block.\n&quot;);
3654     return NULL;
3655   }
3656   next_char();                  // Skip &#39;}&#39;
3657 
3658   // Construct desired object and return
3659   Interface *inter = new MemInterface(base, index, scale, disp);
3660   return inter;
3661 }
3662 
3663 
3664 //------------------------------cond_interface_parse---------------------------
3665 Interface *ADLParser::cond_interface_parse(void) {
3666   char *equal;
3667   char *not_equal;
3668   char *less;
3669   char *greater_equal;
3670   char *less_equal;
3671   char *greater;
3672   char *overflow;
3673   char *no_overflow;
3674   const char *equal_format = &quot;eq&quot;;
3675   const char *not_equal_format = &quot;ne&quot;;
3676   const char *less_format = &quot;lt&quot;;
3677   const char *greater_equal_format = &quot;ge&quot;;
3678   const char *less_equal_format = &quot;le&quot;;
3679   const char *greater_format = &quot;gt&quot;;
3680   const char *overflow_format = &quot;o&quot;;
3681   const char *no_overflow_format = &quot;no&quot;;
3682 
3683   if (_curchar != &#39;%&#39;) {
3684     parse_err(SYNERR, &quot;Missing &#39;%%{&#39; for &#39;cond_interface&#39; block.\n&quot;);
3685     return NULL;
3686   }
3687   next_char();                  // Skip &#39;%&#39;
3688   if (_curchar != &#39;{&#39;) {
3689     parse_err(SYNERR, &quot;Missing &#39;%%{&#39; for &#39;cond_interface&#39; block.\n&quot;);
3690     return NULL;
3691   }
3692   next_char();                  // Skip &#39;{&#39;
3693   skipws();
3694   do {
3695     char *field = get_ident();
3696     if (field == NULL) {
3697       parse_err(SYNERR, &quot;Expected keyword, base|index|scale|disp,  or &#39;%%}&#39; ending interface.\n&quot;);
3698       return NULL;
3699     }
3700     if ( strcmp(field,&quot;equal&quot;) == 0 ) {
3701       equal  = interface_field_parse(&amp;equal_format);
3702     }
3703     else if ( strcmp(field,&quot;not_equal&quot;) == 0 ) {
3704       not_equal = interface_field_parse(&amp;not_equal_format);
3705     }
3706     else if ( strcmp(field,&quot;less&quot;) == 0 ) {
3707       less = interface_field_parse(&amp;less_format);
3708     }
3709     else if ( strcmp(field,&quot;greater_equal&quot;) == 0 ) {
3710       greater_equal  = interface_field_parse(&amp;greater_equal_format);
3711     }
3712     else if ( strcmp(field,&quot;less_equal&quot;) == 0 ) {
3713       less_equal = interface_field_parse(&amp;less_equal_format);
3714     }
3715     else if ( strcmp(field,&quot;greater&quot;) == 0 ) {
3716       greater = interface_field_parse(&amp;greater_format);
3717     }
3718     else if ( strcmp(field,&quot;overflow&quot;) == 0 ) {
3719       overflow = interface_field_parse(&amp;overflow_format);
3720     }
3721     else if ( strcmp(field,&quot;no_overflow&quot;) == 0 ) {
3722       no_overflow = interface_field_parse(&amp;no_overflow_format);
3723     }
3724     else {
3725       parse_err(SYNERR, &quot;Expected keyword, base|index|scale|disp,  or &#39;%%}&#39; ending interface.\n&quot;);
3726       return NULL;
3727     }
3728   } while( _curchar != &#39;%&#39; );
3729   next_char();                  // Skip &#39;%&#39;
3730   if ( _curchar != &#39;}&#39; ) {
3731     parse_err(SYNERR, &quot;Missing &#39;%%}&#39; for &#39;interface&#39; block.\n&quot;);
3732     return NULL;
3733   }
3734   next_char();                  // Skip &#39;}&#39;
3735 
3736   // Construct desired object and return
3737   Interface *inter = new CondInterface(equal,         equal_format,
3738                                        not_equal,     not_equal_format,
3739                                        less,          less_format,
3740                                        greater_equal, greater_equal_format,
3741                                        less_equal,    less_equal_format,
3742                                        greater,       greater_format,
3743                                        overflow,      overflow_format,
3744                                        no_overflow,   no_overflow_format);
3745   return inter;
3746 }
3747 
3748 
3749 //------------------------------interface_field_parse--------------------------
3750 char *ADLParser::interface_field_parse(const char ** format) {
3751   char *iface_field = NULL;
3752 
3753   // Get interface field
3754   skipws();                      // Skip whitespace
3755   if (_curchar != &#39;(&#39;) {
3756     parse_err(SYNERR, &quot;Missing &#39;(&#39; at start of interface field.\n&quot;);
3757     return NULL;
3758   }
3759   next_char();                   // move past &#39;(&#39;
3760   skipws();
3761   if ( _curchar != &#39;0&#39; &amp;&amp; _curchar != &#39;$&#39; ) {
3762     parse_err(SYNERR, &quot;missing or invalid interface field contents.\n&quot;);
3763     return NULL;
3764   }
3765   iface_field = get_rep_var_ident();
3766   if (iface_field == NULL) {
3767     parse_err(SYNERR, &quot;missing or invalid interface field contents.\n&quot;);
3768     return NULL;
3769   }
3770   skipws();
3771   if (format != NULL &amp;&amp; _curchar == &#39;,&#39;) {
3772     next_char();
3773     skipws();
3774     if (_curchar != &#39;&quot;&#39;) {
3775       parse_err(SYNERR, &quot;Missing &#39;\&quot;&#39; in field format .\n&quot;);
3776       return NULL;
3777     }
3778     next_char();
3779     char *start = _ptr;       // Record start of the next string
3780     while ((_curchar != &#39;&quot;&#39;) &amp;&amp; (_curchar != &#39;%&#39;) &amp;&amp; (_curchar != &#39;\n&#39;)) {
3781       if (_curchar == &#39;\\&#39;)  next_char();  // superquote
3782       if (_curchar == &#39;\n&#39;)  parse_err(SYNERR, &quot;newline in string&quot;);  // unimplemented!
3783       next_char();
3784     }
3785     if (_curchar != &#39;&quot;&#39;) {
3786       parse_err(SYNERR, &quot;Missing &#39;\&quot;&#39; at end of field format .\n&quot;);
3787       return NULL;
3788     }
3789     // If a string was found, terminate it and record in FormatRule
3790     if ( start != _ptr ) {
3791       *_ptr  = &#39;\0&#39;;          // Terminate the string
3792       *format = start;
3793     }
3794     next_char();
3795     skipws();
3796   }
3797   if (_curchar != &#39;)&#39;) {
3798     parse_err(SYNERR, &quot;Missing &#39;)&#39; after interface field.\n&quot;);
3799     return NULL;
3800   }
3801   next_char();                   // move past &#39;)&#39;
3802   skipws();
3803   if ( _curchar != &#39;;&#39; ) {
3804     parse_err(SYNERR, &quot;Missing &#39;;&#39; at end of interface field.\n&quot;);
3805     return NULL;
3806   }
3807   next_char();                    // move past &#39;;&#39;
3808   skipws();                       // be friendly to interface_parse()
3809 
3810   return iface_field;
3811 }
3812 
3813 
3814 //------------------------------match_parse------------------------------------
3815 MatchRule *ADLParser::match_parse(FormDict &amp;operands) {
3816   MatchRule *match;               // Match Rule class for instruction/operand
3817   char      *cnstr = NULL;        // Code for constructor
3818   int        depth = 0;           // Counter for matching parentheses
3819   int        numleaves = 0;       // Counter for number of leaves in rule
3820 
3821   // Parse the match rule tree
3822   MatchNode *mnode = matchNode_parse(operands, depth, numleaves, true);
3823 
3824   // Either there is a block with a constructor, or a &#39;;&#39; here
3825   skipws();                       // Skip whitespace
3826   if ( _curchar == &#39;;&#39; ) {        // Semicolon is valid terminator
3827     cnstr = NULL;                 // no constructor for this form
3828     next_char();                  // Move past the &#39;;&#39;, replaced with &#39;\0&#39;
3829   }
3830   else if ((cnstr = find_cpp_block(&quot;match constructor&quot;)) == NULL ) {
3831     parse_err(SYNERR, &quot;invalid construction of match rule\n&quot;
3832               &quot;Missing &#39;;&#39; or invalid &#39;%%{&#39; and &#39;%%}&#39; constructor\n&quot;);
3833     return NULL;                  // No MatchRule to return
3834   }
3835   if (_AD._adl_debug &gt; 1)
3836     if (cnstr) fprintf(stderr,&quot;Match Constructor: %s\n&quot;, cnstr);
3837   // Build new MatchRule object
3838   match = new MatchRule(_AD, mnode, depth, cnstr, numleaves);
3839   skipws();                       // Skip any trailing whitespace
3840   return match;                   // Return MatchRule object
3841 }
3842 
3843 //------------------------------format_parse-----------------------------------
3844 FormatRule* ADLParser::format_parse(void) {
3845   char       *desc   = NULL;
3846   FormatRule *format = (new FormatRule(desc));
3847 
3848   // Without expression form, MUST have a code block;
3849   skipws();                       // Skip whitespace
3850   if ( _curchar == &#39;;&#39; ) {        // Semicolon is valid terminator
3851     desc  = NULL;                 // no constructor for this form
3852     next_char();                  // Move past the &#39;;&#39;, replaced with &#39;\0&#39;
3853   }
3854   else if ( _curchar == &#39;%&#39; &amp;&amp; *(_ptr+1) == &#39;{&#39;) {
3855     next_char();                  // Move past the &#39;%&#39;
3856     next_char();                  // Move past the &#39;{&#39;
3857 
3858     skipws();
3859     if (_curchar == &#39;$&#39;) {
3860       char* ident = get_rep_var_ident();
3861       if (strcmp(ident, &quot;$$template&quot;) == 0) return template_parse();
3862       parse_err(SYNERR, &quot;Unknown \&quot;%s\&quot; directive in format&quot;, ident);
3863       return NULL;
3864     }
3865     // Check for the opening &#39;&quot;&#39; inside the format description
3866     if ( _curchar == &#39;&quot;&#39; ) {
3867       next_char();              // Move past the initial &#39;&quot;&#39;
3868       if( _curchar == &#39;&quot;&#39; ) {   // Handle empty format string case
3869         *_ptr = &#39;\0&#39;;           // Terminate empty string
3870         format-&gt;_strings.addName(_ptr);
3871       }
3872 
3873       // Collect the parts of the format description
3874       // (1) strings that are passed through to tty-&gt;print
3875       // (2) replacement/substitution variable, preceeded by a &#39;$&#39;
3876       // (3) multi-token ANSIY C style strings
3877       while ( true ) {
3878         if ( _curchar == &#39;%&#39; || _curchar == &#39;\n&#39; ) {
3879           if ( _curchar != &#39;&quot;&#39; ) {
3880             parse_err(SYNERR, &quot;missing &#39;\&quot;&#39; at end of format block&quot;);
3881             return NULL;
3882           }
3883         }
3884 
3885         // (1)
3886         // Check if there is a string to pass through to output
3887         char *start = _ptr;       // Record start of the next string
3888         while ((_curchar != &#39;$&#39;) &amp;&amp; (_curchar != &#39;&quot;&#39;) &amp;&amp; (_curchar != &#39;%&#39;) &amp;&amp; (_curchar != &#39;\n&#39;)) {
3889           if (_curchar == &#39;\\&#39;) {
3890             next_char();  // superquote
3891             if ((_curchar == &#39;$&#39;) || (_curchar == &#39;%&#39;))
3892               // hack to avoid % escapes and warnings about undefined \ escapes
3893               *(_ptr-1) = _curchar;
3894           }
3895           if (_curchar == &#39;\n&#39;)  parse_err(SYNERR, &quot;newline in string&quot;);  // unimplemented!
3896           next_char();
3897         }
3898         // If a string was found, terminate it and record in FormatRule
3899         if ( start != _ptr ) {
3900           *_ptr  = &#39;\0&#39;;          // Terminate the string
3901           format-&gt;_strings.addName(start);
3902         }
3903 
3904         // (2)
3905         // If we are at a replacement variable,
3906         // copy it and record in FormatRule
3907         if ( _curchar == &#39;$&#39; ) {
3908           next_char();          // Move past the &#39;$&#39;
3909           char* rep_var = get_ident(); // Nil terminate the variable name
3910           rep_var = strdup(rep_var);// Copy the string
3911           *_ptr   = _curchar;     // and replace Nil with original character
3912           format-&gt;_rep_vars.addName(rep_var);
3913           // Add flag to _strings list indicating we should check _rep_vars
3914           format-&gt;_strings.addName(NameList::_signal);
3915         }
3916 
3917         // (3)
3918         // Allow very long strings to be broken up,
3919         // using the ANSI C syntax &quot;foo\n&quot; &lt;newline&gt; &quot;bar&quot;
3920         if ( _curchar == &#39;&quot;&#39;) {
3921           next_char();           // Move past the &#39;&quot;&#39;
3922           skipws();              // Skip white space before next string token
3923           if ( _curchar != &#39;&quot;&#39;) {
3924             break;
3925           } else {
3926             // Found one.  Skip both &quot; and the whitespace in between.
3927             next_char();
3928           }
3929         }
3930       } // end while part of format description
3931 
3932       // Check for closing &#39;&quot;&#39; and &#39;%}&#39; in format description
3933       skipws();                   // Move to closing &#39;%}&#39;
3934       if ( _curchar != &#39;%&#39; ) {
3935         parse_err(SYNERR, &quot;non-blank characters between closing &#39;\&quot;&#39; and &#39;%%&#39; in format&quot;);
3936         return NULL;
3937       }
3938     } // Done with format description inside
3939 
3940     skipws();
3941     // Past format description, at &#39;%&#39;
3942     if ( _curchar != &#39;%&#39; || *(_ptr+1) != &#39;}&#39; ) {
3943       parse_err(SYNERR, &quot;missing &#39;%%}&#39; at end of format block&quot;);
3944       return NULL;
3945     }
3946     next_char();                  // Move past the &#39;%&#39;
3947     next_char();                  // Move past the &#39;}&#39;
3948   }
3949   else {  // parameter list alone must terminate with a &#39;;&#39;
3950     parse_err(SYNERR, &quot;missing &#39;;&#39; after Format expression&quot;);
3951     return NULL;
3952   }
3953   // Debug Stuff
3954   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Format Rule: %s\n&quot;, desc);
3955 
3956   skipws();
3957   return format;
3958 }
3959 
3960 
3961 //------------------------------template_parse-----------------------------------
3962 FormatRule* ADLParser::template_parse(void) {
3963   char       *desc   = NULL;
3964   FormatRule *format = (new FormatRule(desc));
3965 
3966   skipws();
3967   while ( (_curchar != &#39;%&#39;) &amp;&amp; (*(_ptr+1) != &#39;}&#39;) ) {
3968 
3969     // (1)
3970     // Check if there is a string to pass through to output
3971     {
3972       char *start = _ptr;       // Record start of the next string
3973       while ((_curchar != &#39;$&#39;) &amp;&amp; ((_curchar != &#39;%&#39;) || (*(_ptr+1) != &#39;}&#39;)) ) {
3974         // If at the start of a comment, skip past it
3975         if( (_curchar == &#39;/&#39;) &amp;&amp; ((*(_ptr+1) == &#39;/&#39;) || (*(_ptr+1) == &#39;*&#39;)) ) {
3976           skipws_no_preproc();
3977         } else {
3978           // ELSE advance to the next character, or start of the next line
3979           next_char_or_line();
3980         }
3981       }
3982       // If a string was found, terminate it and record in EncClass
3983       if ( start != _ptr ) {
3984         *_ptr  = &#39;\0&#39;;          // Terminate the string
3985         // Add flag to _strings list indicating we should check _rep_vars
3986         format-&gt;_strings.addName(NameList::_signal2);
3987         format-&gt;_strings.addName(start);
3988       }
3989     }
3990 
3991     // (2)
3992     // If we are at a replacement variable,
3993     // copy it and record in EncClass
3994     if ( _curchar == &#39;$&#39; ) {
3995       // Found replacement Variable
3996       char *rep_var = get_rep_var_ident_dup();
3997       if (strcmp(rep_var, &quot;$emit&quot;) == 0) {
3998         // switch to normal format parsing
3999         next_char();
4000         next_char();
4001         skipws();
4002         // Check for the opening &#39;&quot;&#39; inside the format description
4003         if ( _curchar == &#39;&quot;&#39; ) {
4004           next_char();              // Move past the initial &#39;&quot;&#39;
4005           if( _curchar == &#39;&quot;&#39; ) {   // Handle empty format string case
4006             *_ptr = &#39;\0&#39;;           // Terminate empty string
4007             format-&gt;_strings.addName(_ptr);
4008           }
4009 
4010           // Collect the parts of the format description
4011           // (1) strings that are passed through to tty-&gt;print
4012           // (2) replacement/substitution variable, preceeded by a &#39;$&#39;
4013           // (3) multi-token ANSIY C style strings
4014           while ( true ) {
4015             if ( _curchar == &#39;%&#39; || _curchar == &#39;\n&#39; ) {
4016               parse_err(SYNERR, &quot;missing &#39;\&quot;&#39; at end of format block&quot;);
4017               return NULL;
4018             }
4019 
4020             // (1)
4021             // Check if there is a string to pass through to output
4022             char *start = _ptr;       // Record start of the next string
4023             while ((_curchar != &#39;$&#39;) &amp;&amp; (_curchar != &#39;&quot;&#39;) &amp;&amp; (_curchar != &#39;%&#39;) &amp;&amp; (_curchar != &#39;\n&#39;)) {
4024               if (_curchar == &#39;\\&#39;)  next_char();  // superquote
4025               if (_curchar == &#39;\n&#39;)  parse_err(SYNERR, &quot;newline in string&quot;);  // unimplemented!
4026               next_char();
4027             }
4028             // If a string was found, terminate it and record in FormatRule
4029             if ( start != _ptr ) {
4030               *_ptr  = &#39;\0&#39;;          // Terminate the string
4031               format-&gt;_strings.addName(start);
4032             }
4033 
4034             // (2)
4035             // If we are at a replacement variable,
4036             // copy it and record in FormatRule
4037             if ( _curchar == &#39;$&#39; ) {
4038               next_char();          // Move past the &#39;$&#39;
4039               char* next_rep_var = get_ident(); // Nil terminate the variable name
4040               next_rep_var = strdup(next_rep_var);// Copy the string
4041               *_ptr   = _curchar;     // and replace Nil with original character
4042               format-&gt;_rep_vars.addName(next_rep_var);
4043               // Add flag to _strings list indicating we should check _rep_vars
4044               format-&gt;_strings.addName(NameList::_signal);
4045             }
4046 
4047             // (3)
4048             // Allow very long strings to be broken up,
4049             // using the ANSI C syntax &quot;foo\n&quot; &lt;newline&gt; &quot;bar&quot;
4050             if ( _curchar == &#39;&quot;&#39;) {
4051               next_char();           // Move past the &#39;&quot;&#39;
4052               skipws();              // Skip white space before next string token
4053               if ( _curchar != &#39;&quot;&#39;) {
4054                 break;
4055               } else {
4056                 // Found one.  Skip both &quot; and the whitespace in between.
4057                 next_char();
4058               }
4059             }
4060           } // end while part of format description
4061         }
4062       } else {
4063         // Add flag to _strings list indicating we should check _rep_vars
4064         format-&gt;_rep_vars.addName(rep_var);
4065         // Add flag to _strings list indicating we should check _rep_vars
4066         format-&gt;_strings.addName(NameList::_signal3);
4067       }
4068     } // end while part of format description
4069   }
4070 
4071   skipws();
4072   // Past format description, at &#39;%&#39;
4073   if ( _curchar != &#39;%&#39; || *(_ptr+1) != &#39;}&#39; ) {
4074     parse_err(SYNERR, &quot;missing &#39;%%}&#39; at end of format block&quot;);
4075     return NULL;
4076   }
4077   next_char();                  // Move past the &#39;%&#39;
4078   next_char();                  // Move past the &#39;}&#39;
4079 
4080   // Debug Stuff
4081   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Format Rule: %s\n&quot;, desc);
4082 
4083   skipws();
4084   return format;
4085 }
4086 
4087 
4088 //------------------------------effect_parse-----------------------------------
4089 void ADLParser::effect_parse(InstructForm *instr) {
4090   char* desc   = NULL;
4091 
4092   skipws();                      // Skip whitespace
4093   if (_curchar != &#39;(&#39;) {
4094     parse_err(SYNERR, &quot;missing &#39;(&#39; in effect definition\n&quot;);
4095     return;
4096   }
4097   // Get list of effect-operand pairs and insert into dictionary
4098   else get_effectlist(instr-&gt;_effects, instr-&gt;_localNames, instr-&gt;_has_call);
4099 
4100   // Debug Stuff
4101   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Effect description: %s\n&quot;, desc);
4102   if (_curchar != &#39;;&#39;) {
4103     parse_err(SYNERR, &quot;missing &#39;;&#39; in Effect definition\n&quot;);
4104   }
4105   next_char();                  // Skip &#39;;&#39;
4106 
4107 }
4108 
4109 //------------------------------expand_parse-----------------------------------
4110 ExpandRule* ADLParser::expand_parse(InstructForm *instr) {
4111   char         *ident, *ident2;
4112   NameAndList  *instr_and_operands = NULL;
4113   ExpandRule   *exp = new ExpandRule();
4114 
4115   // Expand is a block containing an ordered list of operands with initializers,
4116   // or instructions, each of which has an ordered list of operands.
4117   // Check for block delimiter
4118   skipws();                        // Skip leading whitespace
4119   if ((_curchar != &#39;%&#39;)
4120       || (next_char(), (_curchar != &#39;{&#39;)) ) { // If not open block
4121     parse_err(SYNERR, &quot;missing &#39;%%{&#39; in expand definition\n&quot;);
4122     return(NULL);
4123   }
4124   next_char();                     // Maintain the invariant
4125   do {
4126     ident = get_ident();           // Grab next identifier
4127     if (ident == NULL) {
4128       parse_err(SYNERR, &quot;identifier expected at %c\n&quot;, _curchar);
4129       continue;
4130     }
4131 
4132     // Check whether we should parse an instruction or operand.
4133     const Form *form = _globalNames[ident];
4134     bool parse_oper = false;
4135     bool parse_ins  = false;
4136     if (form == NULL) {
4137       skipws();
4138       // Check whether this looks like an instruction specification.  If so,
4139       // just parse the instruction.  The declaration of the instruction is
4140       // not needed here.
4141       if (_curchar == &#39;(&#39;) parse_ins = true;
4142     } else if (form-&gt;is_instruction()) {
4143       parse_ins = true;
4144     } else if (form-&gt;is_operand()) {
4145       parse_oper = true;
4146     } else {
4147       parse_err(SYNERR, &quot;instruction/operand name expected at %s\n&quot;, ident);
4148       continue;
4149     }
4150 
4151     if (parse_oper) {
4152       // This is a new operand
4153       OperandForm *oper = form-&gt;is_operand();
4154       if (oper == NULL) {
4155         parse_err(SYNERR, &quot;instruction/operand name expected at %s\n&quot;, ident);
4156         continue;
4157       }
4158       // Throw the operand on the _newopers list
4159       skipws();
4160       ident = get_unique_ident(instr-&gt;_localNames,&quot;Operand&quot;);
4161       if (ident == NULL) {
4162         parse_err(SYNERR, &quot;identifier expected at %c\n&quot;, _curchar);
4163         continue;
4164       }
4165       exp-&gt;_newopers.addName(ident);
4166       // Add new operand to LocalNames
4167       instr-&gt;_localNames.Insert(ident, oper);
4168       // Grab any constructor code and save as a string
4169       char *c = NULL;
4170       skipws();
4171       if (_curchar == &#39;%&#39;) { // Need a constructor for the operand
4172         c = find_cpp_block(&quot;Operand Constructor&quot;);
4173         if (c == NULL) {
4174           parse_err(SYNERR, &quot;Invalid code block for operand constructor\n&quot;, _curchar);
4175           continue;
4176         }
4177         // Add constructor to _newopconst Dict
4178         exp-&gt;_newopconst.Insert(ident, c);
4179       }
4180       else if (_curchar != &#39;;&#39;) { // If no constructor, need a ;
4181         parse_err(SYNERR, &quot;Missing ; in expand rule operand declaration\n&quot;);
4182         continue;
4183       }
4184       else next_char(); // Skip the ;
4185       skipws();
4186     }
4187     else {
4188       assert(parse_ins, &quot;sanity&quot;);
4189       // Add instruction to list
4190       instr_and_operands = new NameAndList(ident);
4191       // Grab operands, build nameList of them, and then put into dictionary
4192       skipws();
4193       if (_curchar != &#39;(&#39;) {         // Check for parenthesized operand list
4194         parse_err(SYNERR, &quot;missing &#39;(&#39; in expand instruction declaration\n&quot;);
4195         continue;
4196       }
4197       do {
4198         next_char();                 // skip open paren &amp; comma characters
4199         skipws();
4200         if (_curchar == &#39;)&#39;) break;
4201         ident2 = get_ident();
4202         skipws();
4203         if (ident2 == NULL) {
4204           parse_err(SYNERR, &quot;identifier expected at %c\n&quot;, _curchar);
4205           continue;
4206         }                            // Check that you have a valid operand
4207         const Form *form2 = instr-&gt;_localNames[ident2];
4208         if (!form2) {
4209           parse_err(SYNERR, &quot;operand name expected at %s\n&quot;, ident2);
4210           continue;
4211         }
4212         OperandForm *oper = form2-&gt;is_operand();
4213         if (oper == NULL &amp;&amp; !form2-&gt;is_opclass()) {
4214           parse_err(SYNERR, &quot;operand name expected at %s\n&quot;, ident2);
4215           continue;
4216         }                            // Add operand to list
4217         instr_and_operands-&gt;add_entry(ident2);
4218       } while(_curchar == &#39;,&#39;);
4219       if (_curchar != &#39;)&#39;) {
4220         parse_err(SYNERR, &quot;missing &#39;)&#39;in expand instruction declaration\n&quot;);
4221         continue;
4222       }
4223       next_char();
4224       if (_curchar != &#39;;&#39;) {
4225         parse_err(SYNERR, &quot;missing &#39;;&#39;in expand instruction declaration\n&quot;);
4226         continue;
4227       }
4228       next_char();
4229 
4230       // Record both instruction name and its operand list
4231       exp-&gt;add_instruction(instr_and_operands);
4232 
4233       skipws();
4234     }
4235 
4236   } while(_curchar != &#39;%&#39;);
4237   next_char();
4238   if (_curchar != &#39;}&#39;) {
4239     parse_err(SYNERR, &quot;missing &#39;%%}&#39; in expand rule definition\n&quot;);
4240     return(NULL);
4241   }
4242   next_char();
4243 
4244   // Debug Stuff
4245   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Expand Rule:\n&quot;);
4246 
4247   skipws();
4248   return (exp);
4249 }
4250 
4251 //------------------------------rewrite_parse----------------------------------
4252 RewriteRule* ADLParser::rewrite_parse(void) {
4253   char* params = NULL;
4254   char* desc   = NULL;
4255 
4256 
4257   // This feature targeted for second generation description language.
4258 
4259   skipws();                      // Skip whitespace
4260   // Get parameters for rewrite
4261   if ((params = get_paren_expr(&quot;rewrite parameters&quot;)) == NULL) {
4262     parse_err(SYNERR, &quot;missing &#39;(&#39; in rewrite rule\n&quot;);
4263     return NULL;
4264   }
4265   // Debug Stuff
4266   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Rewrite parameters: %s\n&quot;, params);
4267 
4268   // For now, grab entire block;
4269   skipws();
4270   if ( (desc = find_cpp_block(&quot;rewrite block&quot;)) == NULL ) {
4271     parse_err(SYNERR, &quot;incorrect or missing block for &#39;rewrite&#39;.\n&quot;);
4272     return NULL;
4273   }
4274   // Debug Stuff
4275   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Rewrite Rule: %s\n&quot;, desc);
4276 
4277   skipws();
4278   return (new RewriteRule(params,desc));
4279 }
4280 
4281 //------------------------------attr_parse-------------------------------------
4282 Attribute *ADLParser::attr_parse(char* ident) {
4283   Attribute *attrib;              // Attribute class
4284   char      *cost = NULL;         // String representation of cost attribute
4285 
4286   skipws();                       // Skip leading whitespace
4287   if ( (cost = get_paren_expr(&quot;attribute&quot;)) == NULL ) {
4288     parse_err(SYNERR, &quot;incorrect or missing expression for &#39;attribute&#39;\n&quot;);
4289     return NULL;
4290   }
4291   // Debug Stuff
4292   if (_AD._adl_debug &gt; 1) fprintf(stderr,&quot;Attribute: %s\n&quot;, cost);
4293   if (_curchar != &#39;;&#39;) {
4294     parse_err(SYNERR, &quot;missing &#39;;&#39; in attribute definition\n&quot;);
4295     return NULL;
4296   }
4297   next_char();                   // Point after the terminator
4298 
4299   skipws();
4300   attrib = new Attribute(ident,cost,INS_ATTR); // Build new predicate object
4301   return attrib;
4302 }
4303 
4304 
4305 //------------------------------matchNode_parse--------------------------------
4306 MatchNode *ADLParser::matchNode_parse(FormDict &amp;operands, int &amp;depth, int &amp;numleaves, bool atroot) {
4307   // Count depth of parenthesis nesting for both left and right children
4308   int   lParens = depth;
4309   int   rParens = depth;
4310 
4311   // MatchNode objects for left, right, and root of subtree.
4312   MatchNode *lChild = NULL;
4313   MatchNode *rChild = NULL;
4314   char      *token;               // Identifier which may be opcode or operand
4315 
4316   // Match expression starts with a &#39;(&#39;
4317   if (cur_char() != &#39;(&#39;)
4318     return NULL;
4319 
4320   next_char();                    // advance past &#39;(&#39;
4321 
4322   // Parse the opcode
4323   token = get_ident();            // Get identifier, opcode
4324   if (token == NULL) {
4325     parse_err(SYNERR, &quot;missing opcode in match expression\n&quot;);
4326     return NULL;
4327   }
4328 
4329   // Take note if we see one of a few special operations - those that are
4330   // treated differently on different architectures in the sense that on
4331   // one architecture there is a match rule and on another there isn&#39;t (so
4332   // a call will eventually be generated).
4333 
4334   for (int i = _last_machine_leaf + 1; i &lt; _last_opcode; i++) {
4335     if (strcmp(token, NodeClassNames[i]) == 0) {
4336       _AD.has_match_rule(i, true);
4337     }
4338   }
4339 
4340   // Lookup the root value in the operands dict to perform substitution
4341   const char  *result    = NULL;  // Result type will be filled in later
4342   const char  *name      = token; // local name associated with this node
4343   const char  *operation = token; // remember valid operation for later
4344   const Form  *form      = operands[token];
4345   OpClassForm *opcForm = form ? form-&gt;is_opclass() : NULL;
4346   if (opcForm != NULL) {
4347     // If this token is an entry in the local names table, record its type
4348     if (!opcForm-&gt;ideal_only()) {
4349       operation = opcForm-&gt;_ident;
4350       result = operation;         // Operands result in their own type
4351     }
4352     // Otherwise it is an ideal type, and so, has no local name
4353     else                        name = NULL;
4354   }
4355 
4356   // Parse the operands
4357   skipws();
4358   if (cur_char() != &#39;)&#39;) {
4359 
4360     // Parse the left child
4361     if (strcmp(operation,&quot;Set&quot;))
4362       lChild = matchChild_parse(operands, lParens, numleaves, false);
4363     else
4364       lChild = matchChild_parse(operands, lParens, numleaves, true);
4365 
4366     skipws();
4367     if (cur_char() != &#39;)&#39; ) {
4368       if(strcmp(operation, &quot;Set&quot;))
4369         rChild = matchChild_parse(operands,rParens,numleaves,false);
4370       else
4371         rChild = matchChild_parse(operands,rParens,numleaves,true);
4372     }
4373   }
4374 
4375   // Check for required &#39;)&#39;
4376   skipws();
4377   if (cur_char() != &#39;)&#39;) {
4378     parse_err(SYNERR, &quot;missing &#39;)&#39; in match expression\n&quot;);
4379     return NULL;
4380   }
4381   next_char();                    // skip the &#39;)&#39;
4382 
4383   MatchNode* mroot = new MatchNode(_AD,result,name,operation,lChild,rChild);
4384 
4385   // If not the root, reduce this subtree to an internal operand
4386   if (!atroot) {
4387     mroot-&gt;build_internalop();
4388   }
4389   // depth is greater of left and right paths.
4390   depth = (lParens &gt; rParens) ? lParens : rParens;
4391 
4392   return mroot;
4393 }
4394 
4395 
4396 //------------------------------matchChild_parse-------------------------------
4397 MatchNode *ADLParser::matchChild_parse(FormDict &amp;operands, int &amp;parens, int &amp;numleaves, bool atroot) {
4398   MatchNode  *child  = NULL;
4399   const char *result = NULL;
4400   const char *token  = NULL;
4401   const char *opType = NULL;
4402 
4403   if (cur_char() == &#39;(&#39;) {         // child is an operation
4404     ++parens;
4405     child = matchNode_parse(operands, parens, numleaves, atroot);
4406   }
4407   else {                           // child is an operand
4408     token = get_ident();
4409     const Form  *form    = operands[token];
4410     OpClassForm *opcForm = form ? form-&gt;is_opclass() : NULL;
4411     if (opcForm != NULL) {
4412       opType = opcForm-&gt;_ident;
4413       result = opcForm-&gt;_ident;    // an operand&#39;s result matches its type
4414     } else {
4415       parse_err(SYNERR, &quot;undefined operand %s in match rule\n&quot;, token);
4416       return NULL;
4417     }
4418 
4419     if (opType == NULL) {
4420       parse_err(SYNERR, &quot;missing type for argument &#39;%s&#39;\n&quot;, token);
4421     }
4422 
4423     child = new MatchNode(_AD, result, token, opType);
4424     ++numleaves;
4425   }
4426 
4427   return child;
4428 }
4429 
4430 
4431 
4432 // ******************** Private Utility Functions *************************
4433 
4434 
4435 char* ADLParser::find_cpp_block(const char* description) {
4436   char *next;                     // Pointer for finding block delimiters
4437   char* cppBlock = NULL;          // Beginning of C++ code block
4438 
4439   if (_curchar == &#39;%&#39;) {          // Encoding is a C++ expression
4440     next_char();
4441     if (_curchar != &#39;{&#39;) {
4442       parse_err(SYNERR, &quot;missing &#39;{&#39; in %s \n&quot;, description);
4443       return NULL;
4444     }
4445     next_char();                  // Skip block delimiter
4446     skipws_no_preproc();          // Skip leading whitespace
4447     cppBlock = _ptr;              // Point to start of expression
4448     int line = linenum();
4449     next = _ptr + 1;
4450     while(((_curchar != &#39;%&#39;) || (*next != &#39;}&#39;)) &amp;&amp; (_curchar != &#39;\0&#39;)) {
4451       next_char_or_line();
4452       next = _ptr+1;              // Maintain the next pointer
4453     }                             // Grab string
4454     if (_curchar == &#39;\0&#39;) {
4455       parse_err(SYNERR, &quot;invalid termination of %s \n&quot;, description);
4456       return NULL;
4457     }
4458     *_ptr = &#39;\0&#39;;                 // Terminate string
4459     _ptr += 2;                    // Skip block delimiter
4460     _curchar = *_ptr;             // Maintain invariant
4461 
4462     // Prepend location descriptor, for debugging.
4463     if (_AD._adlocation_debug) {
4464       char* location = get_line_string(line);
4465       char* end_loc  = end_line_marker();
4466       char* result = (char *)AllocateHeap(strlen(location) + strlen(cppBlock) + strlen(end_loc) + 1);
4467       strcpy(result, location);
4468       strcat(result, cppBlock);
4469       strcat(result, end_loc);
4470       cppBlock = result;
4471       free(location);
4472     }
4473   }
4474 
4475   return cppBlock;
4476 }
4477 
4478 // Move to the closing token of the expression we are currently at,
4479 // as defined by stop_chars.  Match parens and quotes.
4480 char* ADLParser::get_expr(const char *desc, const char *stop_chars) {
4481   char* expr = NULL;
4482   int   paren = 0;
4483 
4484   expr = _ptr;
4485   while (paren &gt; 0 || !strchr(stop_chars, _curchar)) {
4486     if (_curchar == &#39;(&#39;) {        // Down level of nesting
4487       paren++;                    // Bump the parenthesis counter
4488       next_char();                // maintain the invariant
4489     }
4490     else if (_curchar == &#39;)&#39;) {   // Up one level of nesting
4491       if (paren == 0) {
4492         // Paren underflow:  We didn&#39;t encounter the required stop-char.
4493         parse_err(SYNERR, &quot;too many )&#39;s, did not find %s after %s\n&quot;,
4494                   stop_chars, desc);
4495         return NULL;
4496       }
4497       paren--;                    // Drop the parenthesis counter
4498       next_char();                // Maintain the invariant
4499     }
4500     else if (_curchar == &#39;&quot;&#39; || _curchar == &#39;\&#39;&#39;) {
4501       int qchar = _curchar;
4502       while (true) {
4503         next_char();
4504         if (_curchar == qchar) { next_char(); break; }
4505         if (_curchar == &#39;\\&#39;)  next_char();  // superquote
4506         if (_curchar == &#39;\n&#39; || _curchar == &#39;\0&#39;) {
4507           parse_err(SYNERR, &quot;newline in string in %s\n&quot;, desc);
4508           return NULL;
4509         }
4510       }
4511     }
4512     else if (_curchar == &#39;%&#39; &amp;&amp; (_ptr[1] == &#39;{&#39; || _ptr[1] == &#39;}&#39;)) {
4513       // Make sure we do not stray into the next ADLC-level form.
4514       parse_err(SYNERR, &quot;unexpected %%%c in %s\n&quot;, _ptr[1], desc);
4515       return NULL;
4516     }
4517     else if (_curchar == &#39;\0&#39;) {
4518       parse_err(SYNERR, &quot;unexpected EOF in %s\n&quot;, desc);
4519       return NULL;
4520     }
4521     else {
4522       // Always walk over whitespace, comments, preprocessor directives, etc.
4523       char* pre_skip_ptr = _ptr;
4524       skipws();
4525       // If the parser declined to make progress on whitespace,
4526       // skip the next character, which is therefore NOT whitespace.
4527       if (pre_skip_ptr == _ptr) {
4528         next_char();
4529       } else if (pre_skip_ptr+strlen(pre_skip_ptr) != _ptr+strlen(_ptr)) {
4530         parse_err(SYNERR, &quot;unimplemented: preprocessor must not elide subexpression in %s&quot;, desc);
4531       }
4532     }
4533   }
4534 
4535   assert(strchr(stop_chars, _curchar), &quot;non-null return must be at stop-char&quot;);
4536   *_ptr = &#39;\0&#39;;               // Replace &#39;)&#39; or other stop-char with &#39;\0&#39;
4537   return expr;
4538 }
4539 
4540 // Helper function around get_expr
4541 // Sets _curchar to &#39;(&#39; so that get_paren_expr will search for a matching &#39;)&#39;
4542 char *ADLParser::get_paren_expr(const char *description, bool include_location) {
4543   int line = linenum();
4544   if (_curchar != &#39;(&#39;)            // Escape if not valid starting position
4545     return NULL;
4546   next_char();                    // Skip the required initial paren.
4547   char *token2 = get_expr(description, &quot;)&quot;);
4548   if (_curchar == &#39;)&#39;)
4549     next_char();                  // Skip required final paren.
4550   int junk = 0;
4551   if (include_location &amp;&amp; _AD._adlocation_debug &amp;&amp; !is_int_token(token2, junk)) {
4552     // Prepend location descriptor, for debugging.
4553     char* location = get_line_string(line);
4554     char* end_loc  = end_line_marker();
4555     char* result = (char *)AllocateHeap(strlen(location) + strlen(token2) + strlen(end_loc) + 1);
4556     strcpy(result, location);
4557     strcat(result, token2);
4558     strcat(result, end_loc);
4559     token2 = result;
4560     free(location);
4561   }
4562   return token2;
4563 }
4564 
4565 //------------------------------get_ident_common-------------------------------
4566 // Looks for an identifier in the buffer, and turns it into a null terminated
4567 // string(still inside the file buffer).  Returns a pointer to the string or
4568 // NULL if some other token is found instead.
4569 char *ADLParser::get_ident_common(bool do_preproc) {
4570   char c;
4571   char *start;                    // Pointer to start of token
4572   char *end;                      // Pointer to end of token
4573 
4574   if( _curline == NULL )          // Return NULL at EOF.
4575     return NULL;
4576 
4577   skipws_common(do_preproc);      // Skip whitespace before identifier
4578   start = end = _ptr;             // Start points at first character
4579   end--;                          // unwind end by one to prepare for loop
4580   do {
4581     end++;                        // Increment end pointer
4582     c = *end;                     // Grab character to test
4583   } while ( ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) || ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;))
4584             || ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
4585             || ((c == &#39;_&#39;)) || ((c == &#39;:&#39;)) || ((c == &#39;#&#39;)) );
4586   if (start == end) {             // We popped out on the first try
4587     // It can occur that `start&#39; contains the rest of the input file.
4588     // In this case the output should be truncated.
4589     if (strlen(start) &gt; 24) {
4590       char buf[32];
4591       strncpy(buf, start, 20);
4592       buf[20] = &#39;\0&#39;;
4593       strcat(buf, &quot;[...]&quot;);
4594       parse_err(SYNERR, &quot;Identifier expected, but found &#39;%s&#39;.&quot;, buf);
4595     } else {
4596       parse_err(SYNERR, &quot;Identifier expected, but found &#39;%s&#39;.&quot;, start);
4597     }
4598     start = NULL;
4599   }
4600   else {
4601     _curchar = c;                 // Save the first character of next token
4602     *end = &#39;\0&#39;;                  // NULL terminate the string in place
4603   }
4604   _ptr = end;                     // Reset _ptr to point to next char after token
4605 
4606   // Make sure we do not try to use #defined identifiers.  If start is
4607   // NULL an error was already reported.
4608   if (do_preproc &amp;&amp; start != NULL) {
4609     const char* def = _AD.get_preproc_def(start);
4610     if (def != NULL &amp;&amp; strcmp(def, start)) {
4611       const char* def1 = def;
4612       const char* def2 = _AD.get_preproc_def(def1);
4613       // implement up to 2 levels of #define
4614       if (def2 != NULL &amp;&amp; strcmp(def2, def1)) {
4615         def = def2;
4616         const char* def3 = _AD.get_preproc_def(def2);
4617         if (def3 != NULL &amp;&amp; strcmp(def3, def2) &amp;&amp; strcmp(def3, def1)) {
4618           parse_err(SYNERR, &quot;unimplemented: using %s defined as %s =&gt; %s =&gt; %s&quot;,
4619                     start, def1, def2, def3);
4620         }
4621       }
4622       start = strdup(def);
4623     }
4624   }
4625 
4626   return start;                   // Pointer to token in filebuf
4627 }
4628 
4629 //------------------------------get_ident_dup----------------------------------
4630 // Looks for an identifier in the buffer, and returns a duplicate
4631 // or NULL if some other token is found instead.
4632 char *ADLParser::get_ident_dup(void) {
4633   char *ident = get_ident();
4634 
4635   // Duplicate an identifier before returning and restore string.
4636   if( ident != NULL ) {
4637     ident = strdup(ident);  // Copy the string
4638     *_ptr   = _curchar;         // and replace Nil with original character
4639   }
4640 
4641   return ident;
4642 }
4643 
4644 //----------------------get_ident_or_literal_constant--------------------------
4645 // Looks for an identifier in the buffer, or a parenthesized expression.
4646 char *ADLParser::get_ident_or_literal_constant(const char* description) {
4647   char* param = NULL;
4648   skipws();
4649   if (_curchar == &#39;(&#39;) {
4650     // Grab a constant expression.
4651     param = get_paren_expr(description);
4652     if (param[0] != &#39;(&#39;) {
4653       char* buf = (char*) AllocateHeap(strlen(param) + 3);
4654       sprintf(buf, &quot;(%s)&quot;, param);
4655       param = buf;
4656     }
4657     assert(is_literal_constant(param),
4658            &quot;expr must be recognizable as a constant&quot;);
4659   } else {
4660     param = get_ident();
4661   }
4662   return param;
4663 }
4664 
4665 //------------------------------get_rep_var_ident-----------------------------
4666 // Do NOT duplicate,
4667 // Leave nil terminator in buffer
4668 // Preserve initial &#39;$&#39;(s) in string
4669 char *ADLParser::get_rep_var_ident(void) {
4670   // Remember starting point
4671   char *rep_var = _ptr;
4672 
4673   // Check for replacement variable indicator &#39;$&#39; and pass if present
4674   if ( _curchar == &#39;$&#39; ) {
4675     next_char();
4676   }
4677   // Check for a subfield indicator, a second &#39;$&#39;, and pass if present
4678   if ( _curchar == &#39;$&#39; ) {
4679     next_char();
4680   }
4681 
4682   // Check for a control indicator, a third &#39;$&#39;:
4683   if ( _curchar == &#39;$&#39; ) {
4684     next_char();
4685   }
4686 
4687   // Check for more than three &#39;$&#39;s in sequence, SYNERR
4688   if( _curchar == &#39;$&#39; ) {
4689     parse_err(SYNERR, &quot;Replacement variables and field specifiers can not start with &#39;$$$$&#39;&quot;);
4690     next_char();
4691     return NULL;
4692   }
4693 
4694   // Nil terminate the variable name following the &#39;$&#39;
4695   char *rep_var_name = get_ident();
4696   assert( rep_var_name != NULL,
4697           &quot;Missing identifier after replacement variable indicator &#39;$&#39;&quot;);
4698 
4699   return rep_var;
4700 }
4701 
4702 
4703 
4704 //------------------------------get_rep_var_ident_dup-------------------------
4705 // Return the next replacement variable identifier, skipping first &#39;$&#39;
4706 // given a pointer into a line of the buffer.
4707 // Null terminates string, still inside the file buffer,
4708 // Returns a pointer to a copy of the string, or NULL on failure
4709 char *ADLParser::get_rep_var_ident_dup(void) {
4710   if( _curchar != &#39;$&#39; ) return NULL;
4711 
4712   next_char();                // Move past the &#39;$&#39;
4713   char *rep_var = _ptr;       // Remember starting point
4714 
4715   // Check for a subfield indicator, a second &#39;$&#39;:
4716   if ( _curchar == &#39;$&#39; ) {
4717     next_char();
4718   }
4719 
4720   // Check for a control indicator, a third &#39;$&#39;:
4721   if ( _curchar == &#39;$&#39; ) {
4722     next_char();
4723   }
4724 
4725   // Check for more than three &#39;$&#39;s in sequence, SYNERR
4726   if( _curchar == &#39;$&#39; ) {
4727     parse_err(SYNERR, &quot;Replacement variables and field specifiers can not start with &#39;$$$$&#39;&quot;);
4728     next_char();
4729     return NULL;
4730   }
4731 
4732   // Nil terminate the variable name following the &#39;$&#39;
4733   char *rep_var_name = get_ident();
4734   assert( rep_var_name != NULL,
4735           &quot;Missing identifier after replacement variable indicator &#39;$&#39;&quot;);
4736   rep_var = strdup(rep_var);  // Copy the string
4737   *_ptr   = _curchar;         // and replace Nil with original character
4738 
4739   return rep_var;
4740 }
4741 
4742 
4743 //------------------------------get_unique_ident------------------------------
4744 // Looks for an identifier in the buffer, terminates it with a NULL,
4745 // and checks that it is unique
4746 char *ADLParser::get_unique_ident(FormDict&amp; dict, const char* nameDescription){
4747   char* ident = get_ident();
4748 
4749   if (ident == NULL) {
4750     parse_err(SYNERR, &quot;missing %s identifier at %c\n&quot;, nameDescription, _curchar);
4751   }
4752   else {
4753     if (dict[ident] != NULL) {
4754       parse_err(SYNERR, &quot;duplicate name %s for %s\n&quot;, ident, nameDescription);
4755       ident = NULL;
4756     }
4757   }
4758 
4759   return ident;
4760 }
4761 
4762 
4763 //------------------------------get_int----------------------------------------
4764 // Looks for a character string integer in the buffer, and turns it into an int
4765 // invokes a parse_err if the next token is not an integer.
4766 // This routine does not leave the integer null-terminated.
4767 int ADLParser::get_int(void) {
4768   char          c;
4769   char         *start;            // Pointer to start of token
4770   char         *end;              // Pointer to end of token
4771   int           result;           // Storage for integer result
4772 
4773   if( _curline == NULL )          // Return NULL at EOF.
4774     return 0;
4775 
4776   skipws();                       // Skip whitespace before identifier
4777   start = end = _ptr;             // Start points at first character
4778   c = *end;                       // Grab character to test
4779   while ((c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) || (c == &#39;-&#39; &amp;&amp; end == start)) {
4780     end++;                        // Increment end pointer
4781     c = *end;                     // Grab character to test
4782   }
4783   if (start == end) {             // We popped out on the first try
4784     parse_err(SYNERR, &quot;integer expected at %c\n&quot;, c);
4785     result = 0;
4786   }
4787   else {
4788     _curchar = c;                 // Save the first character of next token
4789     *end = &#39;\0&#39;;                  // NULL terminate the string in place
4790     result = atoi(start);         // Convert the string to an integer
4791     *end = _curchar;              // Restore buffer to original condition
4792   }
4793 
4794   // Reset _ptr to next char after token
4795   _ptr = end;
4796 
4797   return result;                   // integer
4798 }
4799 
4800 
4801 //------------------------------get_relation_dup------------------------------
4802 // Looks for a relational operator in the buffer
4803 // invokes a parse_err if the next token is not a relation
4804 // This routine creates a duplicate of the string in the buffer.
4805 char *ADLParser::get_relation_dup(void) {
4806   char         *result = NULL;    // relational operator being returned
4807 
4808   if( _curline == NULL )          // Return NULL at EOF.
4809     return  NULL;
4810 
4811   skipws();                       // Skip whitespace before relation
4812   char *start = _ptr;             // Store start of relational operator
4813   char first  = *_ptr;            // the first character
4814   if( (first == &#39;=&#39;) || (first == &#39;!&#39;) || (first == &#39;&lt;&#39;) || (first == &#39;&gt;&#39;) ) {
4815     next_char();
4816     char second = *_ptr;          // the second character
4817     if( second == &#39;=&#39; ) {
4818       next_char();
4819       char tmp  = *_ptr;
4820       *_ptr = &#39;\0&#39;;               // NULL terminate
4821       result = strdup(start);     // Duplicate the string
4822       *_ptr = tmp;                // restore buffer
4823     } else {
4824       parse_err(SYNERR, &quot;relational operator expected at %s\n&quot;, _ptr);
4825     }
4826   } else {
4827     parse_err(SYNERR, &quot;relational operator expected at %s\n&quot;, _ptr);
4828   }
4829 
4830   return result;
4831 }
4832 
4833 
4834 
4835 //------------------------------get_oplist-------------------------------------
4836 // Looks for identifier pairs where first must be the name of an operand, and
4837 // second must be a name unique in the scope of this instruction.  Stores the
4838 // names with a pointer to the OpClassForm of their type in a local name table.
4839 void ADLParser::get_oplist(NameList &amp;parameters, FormDict &amp;operands) {
4840   OpClassForm *opclass = NULL;
4841   char        *ident   = NULL;
4842 
4843   do {
4844     next_char();             // skip open paren &amp; comma characters
4845     skipws();
4846     if (_curchar == &#39;)&#39;) break;
4847 
4848     // Get operand type, and check it against global name table
4849     ident = get_ident();
4850     if (ident == NULL) {
4851       parse_err(SYNERR, &quot;optype identifier expected at %c\n&quot;, _curchar);
4852       return;
4853     }
4854     else {
4855       const Form  *form = _globalNames[ident];
4856       if( form == NULL ) {
4857         parse_err(SYNERR, &quot;undefined operand type %s\n&quot;, ident);
4858         return;
4859       }
4860 
4861       // Check for valid operand type
4862       OpClassForm *opc  = form-&gt;is_opclass();
4863       OperandForm *oper = form-&gt;is_operand();
4864       if((oper == NULL) &amp;&amp; (opc == NULL)) {
4865         parse_err(SYNERR, &quot;identifier %s not operand type\n&quot;, ident);
4866         return;
4867       }
4868       opclass = opc;
4869     }
4870     // Debugging Stuff
4871     if (_AD._adl_debug &gt; 1) fprintf(stderr, &quot;\tOperand Type: %s\t&quot;, ident);
4872 
4873     // Get name of operand and add it to local name table
4874     if( (ident = get_unique_ident(operands, &quot;operand&quot;)) == NULL) {
4875       return;
4876     }
4877     // Parameter names must not be global names.
4878     if( _globalNames[ident] != NULL ) {
4879          parse_err(SYNERR, &quot;Reuse of global name %s as operand.\n&quot;,ident);
4880          return;
4881     }
4882     operands.Insert(ident, opclass);
4883     parameters.addName(ident);
4884 
4885     // Debugging Stuff
4886     if (_AD._adl_debug &gt; 1) fprintf(stderr, &quot;\tOperand Name: %s\n&quot;, ident);
4887     skipws();
4888   } while(_curchar == &#39;,&#39;);
4889 
4890   if (_curchar != &#39;)&#39;) parse_err(SYNERR, &quot;missing &#39;)&#39;\n&quot;);
4891   else {
4892     next_char();  // set current character position past the close paren
4893   }
4894 }
4895 
4896 
4897 //------------------------------get_effectlist---------------------------------
4898 // Looks for identifier pairs where first must be the name of a pre-defined,
4899 // effect, and the second must be the name of an operand defined in the
4900 // operand list of this instruction.  Stores the names with a pointer to the
4901 // effect form in a local effects table.
4902 void ADLParser::get_effectlist(FormDict &amp;effects, FormDict &amp;operands, bool&amp; has_call) {
4903   OperandForm *opForm;
4904   Effect      *eForm;
4905   char        *ident;
4906 
4907   do {
4908     next_char();             // skip open paren &amp; comma characters
4909     skipws();
4910     if (_curchar == &#39;)&#39;) break;
4911 
4912     // Get effect type, and check it against global name table
4913     ident = get_ident();
4914     if (ident == NULL) {
4915       parse_err(SYNERR, &quot;effect type identifier expected at %c\n&quot;, _curchar);
4916       return;
4917     }
4918     else {
4919       // Check for valid effect type
4920       const Form *form = _globalNames[ident];
4921       if( form == NULL ) {
4922         parse_err(SYNERR, &quot;undefined effect type %s\n&quot;, ident);
4923         return;
4924       }
4925       else {
4926         if( (eForm = form-&gt;is_effect()) == NULL) {
4927           parse_err(SYNERR, &quot;identifier %s not effect type\n&quot;, ident);
4928           return;
4929         }
4930       }
4931     }
4932       // Debugging Stuff
4933     if (_AD._adl_debug &gt; 1) fprintf(stderr, &quot;\tEffect Type: %s\t&quot;, ident);
4934     skipws();
4935     if (eForm-&gt;is(Component::CALL)) {
4936       if (_AD._adl_debug &gt; 1) fprintf(stderr, &quot;\n&quot;);
4937       has_call = true;
4938     } else {
4939       // Get name of operand and check that it is in the local name table
4940       if( (ident = get_unique_ident(effects, &quot;effect&quot;)) == NULL) {
4941         parse_err(SYNERR, &quot;missing operand identifier in effect list\n&quot;);
4942         return;
4943       }
4944       const Form *form = operands[ident];
4945       opForm = form ? form-&gt;is_operand() : NULL;
4946       if( opForm == NULL ) {
4947         if( form &amp;&amp; form-&gt;is_opclass() ) {
4948           const char* cname = form-&gt;is_opclass()-&gt;_ident;
4949           parse_err(SYNERR, &quot;operand classes are illegal in effect lists (found %s %s)\n&quot;, cname, ident);
4950         } else {
4951           parse_err(SYNERR, &quot;undefined operand %s in effect list\n&quot;, ident);
4952         }
4953         return;
4954       }
4955       // Add the pair to the effects table
4956       effects.Insert(ident, eForm);
4957       // Debugging Stuff
4958       if (_AD._adl_debug &gt; 1) fprintf(stderr, &quot;\tOperand Name: %s\n&quot;, ident);
4959     }
4960     skipws();
4961   } while(_curchar == &#39;,&#39;);
4962 
4963   if (_curchar != &#39;)&#39;) parse_err(SYNERR, &quot;missing &#39;)&#39;\n&quot;);
4964   else {
4965     next_char();  // set current character position past the close paren
4966   }
4967 }
4968 
4969 
4970 //-------------------------------preproc_line----------------------------------
4971 // A &quot;#line&quot; keyword has been seen, so parse the rest of the line.
4972 void ADLParser::preproc_line(void) {
4973   int line = get_int();
4974   skipws_no_preproc();
4975   const char* file = NULL;
4976   if (_curchar == &#39;&quot;&#39;) {
4977     next_char();              // Move past the initial &#39;&quot;&#39;
4978     file = _ptr;
4979     while (true) {
4980       if (_curchar == &#39;\n&#39;) {
4981         parse_err(SYNERR, &quot;missing &#39;\&quot;&#39; at end of #line directive&quot;);
4982         return;
4983       }
4984       if (_curchar == &#39;&quot;&#39;) {
4985         *_ptr  = &#39;\0&#39;;          // Terminate the string
4986         next_char();
4987         skipws_no_preproc();
4988         break;
4989       }
4990       next_char();
4991     }
4992   }
4993   ensure_end_of_line();
4994   if (file != NULL)
4995     _AD._ADL_file._name = file;
4996   _buf.set_linenum(line);
4997 }
4998 
4999 //------------------------------preproc_define---------------------------------
5000 // A &quot;#define&quot; keyword has been seen, so parse the rest of the line.
5001 void ADLParser::preproc_define(void) {
5002   char* flag = get_ident_no_preproc();
5003   skipws_no_preproc();
5004   // only #define x y is supported for now
5005   char* def = get_ident_no_preproc();
5006   _AD.set_preproc_def(flag, def);
5007   skipws_no_preproc();
5008   if (_curchar != &#39;\n&#39;) {
5009     parse_err(SYNERR, &quot;non-identifier in preprocessor definition\n&quot;);
5010   }
5011 }
5012 
5013 //------------------------------preproc_undef----------------------------------
5014 // An &quot;#undef&quot; keyword has been seen, so parse the rest of the line.
5015 void ADLParser::preproc_undef(void) {
5016   char* flag = get_ident_no_preproc();
5017   skipws_no_preproc();
5018   ensure_end_of_line();
5019   _AD.set_preproc_def(flag, NULL);
5020 }
5021 
5022 
5023 
5024 //------------------------------parse_err--------------------------------------
5025 // Issue a parser error message, and skip to the end of the current line
5026 void ADLParser::parse_err(int flag, const char *fmt, ...) {
5027   va_list args;
5028 
5029   va_start(args, fmt);
5030   if (flag == 1)
5031     _AD._syntax_errs += _AD.emit_msg(0, flag, linenum(), fmt, args);
5032   else if (flag == 2)
5033     _AD._semantic_errs += _AD.emit_msg(0, flag, linenum(), fmt, args);
5034   else
5035     _AD._warnings += _AD.emit_msg(0, flag, linenum(), fmt, args);
5036 
5037   int error_char = _curchar;
5038   char* error_ptr = _ptr+1;
5039   for(;*_ptr != &#39;\n&#39;; _ptr++) ; // Skip to the end of the current line
5040   _curchar = &#39;\n&#39;;
5041   va_end(args);
5042   _AD._no_output = 1;
5043 
5044   if (flag == 1) {
5045     char* error_tail = strchr(error_ptr, &#39;\n&#39;);
5046     char tem = *error_ptr;
5047     error_ptr[-1] = &#39;\0&#39;;
5048     char* error_head = error_ptr-1;
5049     while (error_head &gt; _curline &amp;&amp; *error_head)  --error_head;
5050     if (error_tail)  *error_tail = &#39;\0&#39;;
5051     fprintf(stderr, &quot;Error Context:  %s&gt;&gt;&gt;%c&lt;&lt;&lt;%s\n&quot;,
5052             error_head, error_char, error_ptr);
5053     if (error_tail)  *error_tail = &#39;\n&#39;;
5054     error_ptr[-1] = tem;
5055   }
5056 }
5057 
5058 //---------------------------ensure_start_of_line------------------------------
5059 // A preprocessor directive has been encountered.  Be sure it has fallen at
5060 // the beginning of a line, or else report an error.
5061 void ADLParser::ensure_start_of_line(void) {
5062   if (_curchar == &#39;\n&#39;) { next_line(); return; }
5063   assert( _ptr &gt;= _curline &amp;&amp; _ptr &lt; _curline+strlen(_curline),
5064           &quot;Must be able to find which line we are in&quot; );
5065 
5066   for (char *s = _curline; s &lt; _ptr; s++) {
5067     if (*s &gt; &#39; &#39;) {
5068       parse_err(SYNERR, &quot;&#39;%c&#39; must be at beginning of line\n&quot;, _curchar);
5069       break;
5070     }
5071   }
5072 }
5073 
5074 //---------------------------ensure_end_of_line--------------------------------
5075 // A preprocessor directive has been parsed.  Be sure there is no trailing
5076 // garbage at the end of this line.  Set the scan point to the beginning of
5077 // the next line.
5078 void ADLParser::ensure_end_of_line(void) {
5079   skipws_no_preproc();
5080   if (_curchar != &#39;\n&#39; &amp;&amp; _curchar != &#39;\0&#39;) {
5081     parse_err(SYNERR, &quot;garbage char &#39;%c&#39; at end of line\n&quot;, _curchar);
5082   } else {
5083     next_char_or_line();
5084   }
5085 }
5086 
5087 //---------------------------handle_preproc------------------------------------
5088 // The &#39;#&#39; character introducing a preprocessor directive has been found.
5089 // Parse the whole directive name (e.g., #define, #endif) and take appropriate
5090 // action.  If we are in an &quot;untaken&quot; span of text, simply keep track of
5091 // #ifdef nesting structure, so we can find out when to start taking text
5092 // again.  (In this state, we &quot;sort of support&quot; C&#39;s #if directives, enough
5093 // to disregard their associated #else and #endif lines.)  If we are in a
5094 // &quot;taken&quot; span of text, there are two cases:  &quot;#define&quot; and &quot;#undef&quot;
5095 // directives are preserved and passed up to the caller, which eventually
5096 // passes control to the top-level parser loop, which handles #define and
5097 // #undef directly.  (This prevents these directives from occurring in
5098 // arbitrary positions in the AD file--we require better structure than C.)
5099 // In the other case, and #ifdef, #ifndef, #else, or #endif is silently
5100 // processed as whitespace, with the &quot;taken&quot; state of the text correctly
5101 // updated.  This routine returns &quot;false&quot; exactly in the case of a &quot;taken&quot;
5102 // #define or #undef, which tells the caller that a preprocessor token
5103 // has appeared which must be handled explicitly by the parse loop.
5104 bool ADLParser::handle_preproc_token() {
5105   assert(*_ptr == &#39;#&#39;, &quot;must be at start of preproc&quot;);
5106   ensure_start_of_line();
5107   next_char();
5108   skipws_no_preproc();
5109   char* start_ident = _ptr;
5110   char* ident = (_curchar == &#39;\n&#39;) ? NULL : get_ident_no_preproc();
5111   if (ident == NULL) {
5112     parse_err(SYNERR, &quot;expected preprocessor command, got end of line\n&quot;);
5113   } else if (!strcmp(ident, &quot;ifdef&quot;) ||
5114              !strcmp(ident, &quot;ifndef&quot;)) {
5115     char* flag = get_ident_no_preproc();
5116     ensure_end_of_line();
5117     // Test the identifier only if we are already in taken code:
5118     bool flag_def  = preproc_taken() &amp;&amp; (_AD.get_preproc_def(flag) != NULL);
5119     bool now_taken = !strcmp(ident, &quot;ifdef&quot;) ? flag_def : !flag_def;
5120     begin_if_def(now_taken);
5121   } else if (!strcmp(ident, &quot;if&quot;)) {
5122     if (preproc_taken())
5123       parse_err(SYNERR, &quot;unimplemented: #%s %s&quot;, ident, _ptr+1);
5124     next_line();
5125     // Intelligently skip this nested C preprocessor directive:
5126     begin_if_def(true);
5127   } else if (!strcmp(ident, &quot;else&quot;)) {
5128     ensure_end_of_line();
5129     invert_if_def();
5130   } else if (!strcmp(ident, &quot;endif&quot;)) {
5131     ensure_end_of_line();
5132     end_if_def();
5133   } else if (preproc_taken()) {
5134     // pass this token up to the main parser as &quot;#define&quot; or &quot;#undef&quot;
5135     _ptr = start_ident;
5136     _curchar = *--_ptr;
5137     if( _curchar != &#39;#&#39; ) {
5138       parse_err(SYNERR, &quot;no space allowed after # in #define or #undef&quot;);
5139       assert(_curchar == &#39;#&#39;, &quot;no space allowed after # in #define or #undef&quot;);
5140     }
5141     return false;
5142   }
5143   return true;
5144 }
5145 
5146 //---------------------------skipws_common-------------------------------------
5147 // Skip whitespace, including comments and newlines, while keeping an accurate
5148 // line count.
5149 // Maybe handle certain preprocessor constructs: #ifdef, #ifndef, #else, #endif
5150 void ADLParser::skipws_common(bool do_preproc) {
5151   char *start = _ptr;
5152   char *next = _ptr + 1;
5153 
5154   if (*_ptr == &#39;\0&#39;) {
5155     // Check for string terminator
5156     if (_curchar &gt; &#39; &#39;)  return;
5157     if (_curchar == &#39;\n&#39;) {
5158       if (!do_preproc)  return;            // let caller handle the newline
5159       next_line();
5160       _ptr = _curline; next = _ptr + 1;
5161     }
5162     else if (_curchar == &#39;#&#39; ||
5163         (_curchar == &#39;/&#39; &amp;&amp; (*next == &#39;/&#39; || *next == &#39;*&#39;))) {
5164       parse_err(SYNERR, &quot;unimplemented: comment token in a funny place&quot;);
5165     }
5166   }
5167   while(_curline != NULL) {                // Check for end of file
5168     if (*_ptr == &#39;\n&#39;) {                   // keep proper track of new lines
5169       if (!do_preproc)  break;             // let caller handle the newline
5170       next_line();
5171       _ptr = _curline; next = _ptr + 1;
5172     }
5173     else if ((*_ptr == &#39;/&#39;) &amp;&amp; (*next == &#39;/&#39;))      // C++ comment
5174       do { _ptr++; next++; } while(*_ptr != &#39;\n&#39;);  // So go to end of line
5175     else if ((*_ptr == &#39;/&#39;) &amp;&amp; (*next == &#39;*&#39;)) {    // C comment
5176       _ptr++; next++;
5177       do {
5178         _ptr++; next++;
5179         if (*_ptr == &#39;\n&#39;) {               // keep proper track of new lines
5180           next_line();                     // skip newlines within comments
5181           if (_curline == NULL) {          // check for end of file
5182             parse_err(SYNERR, &quot;end-of-file detected inside comment\n&quot;);
5183             break;
5184           }
5185           _ptr = _curline; next = _ptr + 1;
5186         }
5187       } while(!((*_ptr == &#39;*&#39;) &amp;&amp; (*next == &#39;/&#39;))); // Go to end of comment
5188       _ptr = ++next; next++;               // increment _ptr past comment end
5189     }
5190     else if (do_preproc &amp;&amp; *_ptr == &#39;#&#39;) {
5191       // Note that this calls skipws_common(false) recursively!
5192       bool preproc_handled = handle_preproc_token();
5193       if (!preproc_handled) {
5194         if (preproc_taken()) {
5195           return;  // short circuit
5196         }
5197         ++_ptr;    // skip the preprocessor character
5198       }
5199       next = _ptr+1;
5200     } else if(*_ptr &gt; &#39; &#39; &amp;&amp; !(do_preproc &amp;&amp; !preproc_taken())) {
5201       break;
5202     }
5203     else if (*_ptr == &#39;&quot;&#39; || *_ptr == &#39;\&#39;&#39;) {
5204       assert(do_preproc, &quot;only skip strings if doing preproc&quot;);
5205       // skip untaken quoted string
5206       int qchar = *_ptr;
5207       while (true) {
5208         ++_ptr;
5209         if (*_ptr == qchar) { ++_ptr; break; }
5210         if (*_ptr == &#39;\\&#39;)  ++_ptr;
5211         if (*_ptr == &#39;\n&#39; || *_ptr == &#39;\0&#39;) {
5212           parse_err(SYNERR, &quot;newline in string&quot;);
5213           break;
5214         }
5215       }
5216       next = _ptr + 1;
5217     }
5218     else { ++_ptr; ++next; }
5219   }
5220   if( _curline != NULL )            // at end of file _curchar isn&#39;t valid
5221     _curchar = *_ptr;               // reset _curchar to maintain invariant
5222 }
5223 
5224 //---------------------------cur_char-----------------------------------------
5225 char ADLParser::cur_char() {
5226   return (_curchar);
5227 }
5228 
5229 //---------------------------next_char-----------------------------------------
5230 void ADLParser::next_char() {
5231   if (_curchar == &#39;\n&#39;)  parse_err(WARN, &quot;must call next_line!&quot;);
5232   _curchar = *++_ptr;
5233   // if ( _curchar == &#39;\n&#39; ) {
5234   //   next_line();
5235   // }
5236 }
5237 
5238 //---------------------------next_char_or_line---------------------------------
5239 void ADLParser::next_char_or_line() {
5240   if ( _curchar != &#39;\n&#39; ) {
5241     _curchar = *++_ptr;
5242   } else {
5243     next_line();
5244     _ptr = _curline;
5245     _curchar = *_ptr;  // maintain invariant
5246   }
5247 }
5248 
5249 //---------------------------next_line-----------------------------------------
5250 void ADLParser::next_line() {
5251   _curline = _buf.get_line();
5252   _curchar = &#39; &#39;;
5253 }
5254 
5255 //------------------------get_line_string--------------------------------------
5256 // Prepended location descriptor, for debugging.
5257 // Must return a malloced string (that can be freed if desired).
5258 char* ADLParser::get_line_string(int linenum) {
5259   const char* file = _AD._ADL_file._name;
5260   int         line = linenum ? linenum : this-&gt;linenum();
5261   char* location = (char *)AllocateHeap(strlen(file) + 100);
5262   sprintf(location, &quot;\n#line %d \&quot;%s\&quot;\n&quot;, line, file);
5263   return location;
5264 }
5265 
5266 //-------------------------is_literal_constant---------------------------------
5267 bool ADLParser::is_literal_constant(const char *param) {
5268   if (param[0] == 0)     return false;  // null string
5269   if (param[0] == &#39;(&#39;)   return true;   // parenthesized expression
5270   if (param[0] == &#39;0&#39; &amp;&amp; (param[1] == &#39;x&#39; || param[1] == &#39;X&#39;)) {
5271     // Make sure it&#39;s a hex constant.
5272     int i = 2;
5273     do {
5274       if( !ADLParser::is_hex_digit(*(param+i)) )  return false;
5275       ++i;
5276     } while( *(param+i) != 0 );
5277     return true;
5278   }
5279   return false;
5280 }
5281 
5282 //---------------------------is_hex_digit--------------------------------------
5283 bool ADLParser::is_hex_digit(char digit) {
5284   return ((digit &gt;= &#39;0&#39;) &amp;&amp; (digit &lt;= &#39;9&#39;))
5285        ||((digit &gt;= &#39;a&#39;) &amp;&amp; (digit &lt;= &#39;f&#39;))
5286        ||((digit &gt;= &#39;A&#39;) &amp;&amp; (digit &lt;= &#39;F&#39;));
5287 }
5288 
5289 //---------------------------is_int_token--------------------------------------
5290 bool ADLParser::is_int_token(const char* token, int&amp; intval) {
5291   const char* cp = token;
5292   while (*cp != &#39;\0&#39; &amp;&amp; *cp &lt;= &#39; &#39;)  cp++;
5293   if (*cp == &#39;-&#39;)  cp++;
5294   int ndigit = 0;
5295   while (*cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;)  { cp++; ndigit++; }
5296   while (*cp != &#39;\0&#39; &amp;&amp; *cp &lt;= &#39; &#39;)  cp++;
5297   if (ndigit == 0 || *cp != &#39;\0&#39;) {
5298     return false;
5299   }
5300   intval = atoi(token);
5301   return true;
5302 }
5303 
5304 static const char* skip_expr_ws(const char* str) {
5305   const char * cp = str;
5306   while (cp[0]) {
5307     if (cp[0] &lt;= &#39; &#39;) {
5308       ++cp;
5309     } else if (cp[0] == &#39;#&#39;) {
5310       ++cp;
5311       while (cp[0] == &#39; &#39;)  ++cp;
5312       assert(0 == strncmp(cp, &quot;line&quot;, 4), &quot;must be a #line directive&quot;);
5313       const char* eol = strchr(cp, &#39;\n&#39;);
5314       assert(eol != NULL, &quot;must find end of line&quot;);
5315       if (eol == NULL)  eol = cp + strlen(cp);
5316       cp = eol;
5317     } else {
5318       break;
5319     }
5320   }
5321   return cp;
5322 }
5323 
5324 //-----------------------equivalent_expressions--------------------------------
5325 bool ADLParser::equivalent_expressions(const char* str1, const char* str2) {
5326   if (str1 == str2)
5327     return true;
5328   else if (str1 == NULL || str2 == NULL)
5329     return false;
5330   const char* cp1 = str1;
5331   const char* cp2 = str2;
5332   char in_quote = &#39;\0&#39;;
5333   while (cp1[0] &amp;&amp; cp2[0]) {
5334     if (!in_quote) {
5335       // skip spaces and/or cpp directives
5336       const char* cp1a = skip_expr_ws(cp1);
5337       const char* cp2a = skip_expr_ws(cp2);
5338       if (cp1a &gt; cp1 &amp;&amp; cp2a &gt; cp2) {
5339         cp1 = cp1a; cp2 = cp2a;
5340         continue;
5341       }
5342       if (cp1a &gt; cp1 || cp2a &gt; cp2)  break; // fail
5343     }
5344     // match one non-space char
5345     if (cp1[0] != cp2[0])  break; // fail
5346     char ch = cp1[0];
5347     cp1++; cp2++;
5348     // watch for quotes
5349     if (in_quote &amp;&amp; ch == &#39;\\&#39;) {
5350       if (cp1[0] != cp2[0])  break; // fail
5351       if (!cp1[0])  break;
5352       cp1++; cp2++;
5353     }
5354     if (in_quote &amp;&amp; ch == in_quote) {
5355       in_quote = &#39;\0&#39;;
5356     } else if (!in_quote &amp;&amp; (ch == &#39;&quot;&#39; || ch == &#39;\&#39;&#39;)) {
5357       in_quote = ch;
5358     }
5359   }
5360   return (!cp1[0] &amp;&amp; !cp2[0]);
5361 }
5362 
5363 
5364 //-------------------------------trim------------------------------------------
5365 void ADLParser::trim(char* &amp;token) {
5366   while (*token &lt;= &#39; &#39;)  token++;
5367   char* end = token + strlen(token);
5368   while (end &gt; token &amp;&amp; *(end-1) &lt;= &#39; &#39;)  --end;
5369   *end = &#39;\0&#39;;
5370 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>