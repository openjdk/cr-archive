<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/methodData.hpp&quot;
  35 #include &quot;oops/method.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 // Platform-dependent initialization
  48 
  49 void TemplateTable::pd_initialize() {
  50   // No aarch64 specific initialization
  51 }
  52 
  53 // Address computation: local variables
  54 
  55 static inline Address iaddress(int n) {
  56   return Address(rlocals, Interpreter::local_offset_in_bytes(n));
  57 }
  58 
  59 static inline Address laddress(int n) {
  60   return iaddress(n + 1);
  61 }
  62 
  63 static inline Address faddress(int n) {
  64   return iaddress(n);
  65 }
  66 
  67 static inline Address daddress(int n) {
  68   return laddress(n);
  69 }
  70 
  71 static inline Address aaddress(int n) {
  72   return iaddress(n);
  73 }
  74 
  75 static inline Address iaddress(Register r) {
  76   return Address(rlocals, r, Address::lsl(3));
  77 }
  78 
  79 static inline Address laddress(Register r, Register scratch,
  80                                InterpreterMacroAssembler* _masm) {
  81   __ lea(scratch, Address(rlocals, r, Address::lsl(3)));
  82   return Address(scratch, Interpreter::local_offset_in_bytes(1));
  83 }
  84 
  85 static inline Address faddress(Register r) {
  86   return iaddress(r);
  87 }
  88 
  89 static inline Address daddress(Register r, Register scratch,
  90                                InterpreterMacroAssembler* _masm) {
  91   return laddress(r, scratch, _masm);
  92 }
  93 
  94 static inline Address aaddress(Register r) {
  95   return iaddress(r);
  96 }
  97 
  98 static inline Address at_rsp() {
  99   return Address(esp, 0);
 100 }
 101 
 102 // At top of Java expression stack which may be different than esp().  It
 103 // isn&#39;t for category 1 objects.
 104 static inline Address at_tos   () {
 105   return Address(esp,  Interpreter::expr_offset_in_bytes(0));
 106 }
 107 
 108 static inline Address at_tos_p1() {
 109   return Address(esp,  Interpreter::expr_offset_in_bytes(1));
 110 }
 111 
 112 static inline Address at_tos_p2() {
 113   return Address(esp,  Interpreter::expr_offset_in_bytes(2));
 114 }
 115 
 116 static inline Address at_tos_p3() {
 117   return Address(esp,  Interpreter::expr_offset_in_bytes(3));
 118 }
 119 
 120 static inline Address at_tos_p4() {
 121   return Address(esp,  Interpreter::expr_offset_in_bytes(4));
 122 }
 123 
 124 static inline Address at_tos_p5() {
 125   return Address(esp,  Interpreter::expr_offset_in_bytes(5));
 126 }
 127 
 128 // Condition conversion
 129 static Assembler::Condition j_not(TemplateTable::Condition cc) {
 130   switch (cc) {
 131   case TemplateTable::equal        : return Assembler::NE;
 132   case TemplateTable::not_equal    : return Assembler::EQ;
 133   case TemplateTable::less         : return Assembler::GE;
 134   case TemplateTable::less_equal   : return Assembler::GT;
 135   case TemplateTable::greater      : return Assembler::LE;
 136   case TemplateTable::greater_equal: return Assembler::LT;
 137   }
 138   ShouldNotReachHere();
 139   return Assembler::EQ;
 140 }
 141 
 142 
 143 // Miscelaneous helper routines
 144 // Store an oop (or NULL) at the Address described by obj.
 145 // If val == noreg this means store a NULL
 146 static void do_oop_store(InterpreterMacroAssembler* _masm,
 147                          Address dst,
 148                          Register val,
 149                          DecoratorSet decorators) {
 150   assert(val == noreg || val == r0, &quot;parameter is just for looks&quot;);
 151   __ store_heap_oop(dst, val, r10, r1, decorators);
 152 }
 153 
 154 static void do_oop_load(InterpreterMacroAssembler* _masm,
 155                         Address src,
 156                         Register dst,
 157                         DecoratorSet decorators) {
 158   __ load_heap_oop(dst, src, r10, r1, decorators);
 159 }
 160 
 161 Address TemplateTable::at_bcp(int offset) {
 162   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 163   return Address(rbcp, offset);
 164 }
 165 
 166 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 167                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 168                                    int byte_no)
 169 {
 170   if (!RewriteBytecodes)  return;
 171   Label L_patch_done;
 172 
 173   switch (bc) {
 174   case Bytecodes::_fast_aputfield:
 175   case Bytecodes::_fast_bputfield:
 176   case Bytecodes::_fast_zputfield:
 177   case Bytecodes::_fast_cputfield:
 178   case Bytecodes::_fast_dputfield:
 179   case Bytecodes::_fast_fputfield:
 180   case Bytecodes::_fast_iputfield:
 181   case Bytecodes::_fast_lputfield:
 182   case Bytecodes::_fast_sputfield:
 183     {
 184       // We skip bytecode quickening for putfield instructions when
 185       // the put_code written to the constant pool cache is zero.
 186       // This is required so that every execution of this instruction
 187       // calls out to InterpreterRuntime::resolve_get_put to do
 188       // additional, required work.
 189       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 190       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 191       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 192       __ movw(bc_reg, bc);
 193       __ cbzw(temp_reg, L_patch_done);  // don&#39;t patch
 194     }
 195     break;
 196   default:
 197     assert(byte_no == -1, &quot;sanity&quot;);
 198     // the pair bytecodes have already done the load.
 199     if (load_bc_into_bc_reg) {
 200       __ movw(bc_reg, bc);
 201     }
 202   }
 203 
 204   if (JvmtiExport::can_post_breakpoint()) {
 205     Label L_fast_patch;
 206     // if a breakpoint is present we can&#39;t rewrite the stream directly
 207     __ load_unsigned_byte(temp_reg, at_bcp(0));
 208     __ cmpw(temp_reg, Bytecodes::_breakpoint);
 209     __ br(Assembler::NE, L_fast_patch);
 210     // Let breakpoint table handling rewrite to quicker bytecode
 211     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at), rmethod, rbcp, bc_reg);
 212     __ b(L_patch_done);
 213     __ bind(L_fast_patch);
 214   }
 215 
 216 #ifdef ASSERT
 217   Label L_okay;
 218   __ load_unsigned_byte(temp_reg, at_bcp(0));
 219   __ cmpw(temp_reg, (int) Bytecodes::java_code(bc));
 220   __ br(Assembler::EQ, L_okay);
 221   __ cmpw(temp_reg, bc_reg);
 222   __ br(Assembler::EQ, L_okay);
 223   __ stop(&quot;patching the wrong bytecode&quot;);
 224   __ bind(L_okay);
 225 #endif
 226 
 227   // patch bytecode
 228   __ strb(bc_reg, at_bcp(0));
 229   __ bind(L_patch_done);
 230 }
 231 
 232 
 233 // Individual instructions
 234 
 235 void TemplateTable::nop() {
 236   transition(vtos, vtos);
 237   // nothing to do
 238 }
 239 
 240 void TemplateTable::shouldnotreachhere() {
 241   transition(vtos, vtos);
 242   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 243 }
 244 
 245 void TemplateTable::aconst_null()
 246 {
 247   transition(vtos, atos);
 248   __ mov(r0, 0);
 249 }
 250 
 251 void TemplateTable::iconst(int value)
 252 {
 253   transition(vtos, itos);
 254   __ mov(r0, value);
 255 }
 256 
 257 void TemplateTable::lconst(int value)
 258 {
 259   __ mov(r0, value);
 260 }
 261 
 262 void TemplateTable::fconst(int value)
 263 {
 264   transition(vtos, ftos);
 265   switch (value) {
 266   case 0:
 267     __ fmovs(v0, zr);
 268     break;
 269   case 1:
 270     __ fmovs(v0, 1.0);
 271     break;
 272   case 2:
 273     __ fmovs(v0, 2.0);
 274     break;
 275   default:
 276     ShouldNotReachHere();
 277     break;
 278   }
 279 }
 280 
 281 void TemplateTable::dconst(int value)
 282 {
 283   transition(vtos, dtos);
 284   switch (value) {
 285   case 0:
 286     __ fmovd(v0, zr);
 287     break;
 288   case 1:
 289     __ fmovd(v0, 1.0);
 290     break;
 291   case 2:
 292     __ fmovd(v0, 2.0);
 293     break;
 294   default:
 295     ShouldNotReachHere();
 296     break;
 297   }
 298 }
 299 
 300 void TemplateTable::bipush()
 301 {
 302   transition(vtos, itos);
 303   __ load_signed_byte32(r0, at_bcp(1));
 304 }
 305 
 306 void TemplateTable::sipush()
 307 {
 308   transition(vtos, itos);
 309   __ load_unsigned_short(r0, at_bcp(1));
 310   __ revw(r0, r0);
 311   __ asrw(r0, r0, 16);
 312 }
 313 
 314 void TemplateTable::ldc(bool wide)
 315 {
 316   transition(vtos, vtos);
 317   Label call_ldc, notFloat, notClass, notInt, Done;
 318 
 319   if (wide) {
 320     __ get_unsigned_2_byte_index_at_bcp(r1, 1);
 321   } else {
 322     __ load_unsigned_byte(r1, at_bcp(1));
 323   }
 324   __ get_cpool_and_tags(r2, r0);
 325 
 326   const int base_offset = ConstantPool::header_size() * wordSize;
 327   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 328 
 329   // get type
 330   __ add(r3, r1, tags_offset);
 331   __ lea(r3, Address(r0, r3));
 332   __ ldarb(r3, r3);
 333 
 334   // unresolved class - get the resolved class
 335   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClass);
 336   __ br(Assembler::EQ, call_ldc);
 337 
 338   // unresolved class in error state - call into runtime to throw the error
 339   // from the first resolution attempt
 340   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClassInError);
 341   __ br(Assembler::EQ, call_ldc);
 342 
 343   // resolved class - need to call vm to get java mirror of the class
 344   __ cmp(r3, (u1)JVM_CONSTANT_Class);
 345   __ br(Assembler::NE, notClass);
 346 
 347   __ bind(call_ldc);
 348   __ mov(c_rarg1, wide);
 349   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), c_rarg1);
 350   __ push_ptr(r0);
 351   __ verify_oop(r0);
 352   __ b(Done);
 353 
 354   __ bind(notClass);
 355   __ cmp(r3, (u1)JVM_CONSTANT_Float);
 356   __ br(Assembler::NE, notFloat);
 357   // ftos
 358   __ adds(r1, r2, r1, Assembler::LSL, 3);
 359   __ ldrs(v0, Address(r1, base_offset));
 360   __ push_f();
 361   __ b(Done);
 362 
 363   __ bind(notFloat);
 364 
 365   __ cmp(r3, (u1)JVM_CONSTANT_Integer);
 366   __ br(Assembler::NE, notInt);
 367 
 368   // itos
 369   __ adds(r1, r2, r1, Assembler::LSL, 3);
 370   __ ldrw(r0, Address(r1, base_offset));
 371   __ push_i(r0);
 372   __ b(Done);
 373 
 374   __ bind(notInt);
 375   condy_helper(Done);
 376 
 377   __ bind(Done);
 378 }
 379 
 380 // Fast path for caching oop constants.
 381 void TemplateTable::fast_aldc(bool wide)
 382 {
 383   transition(vtos, atos);
 384 
 385   Register result = r0;
 386   Register tmp = r1;
 387   Register rarg = r2;
 388 
 389   int index_size = wide ? sizeof(u2) : sizeof(u1);
 390 
 391   Label resolved;
 392 
 393   // We are resolved if the resolved reference cache entry contains a
 394   // non-null object (String, MethodType, etc.)
 395   assert_different_registers(result, tmp);
 396   __ get_cache_index_at_bcp(tmp, 1, index_size);
 397   __ load_resolved_reference_at_index(result, tmp);
 398   __ cbnz(result, resolved);
 399 
 400   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 401 
 402   // first time invocation - must resolve first
 403   __ mov(rarg, (int)bytecode());
 404   __ call_VM(result, entry, rarg);
 405 
 406   __ bind(resolved);
 407 
 408   { // Check for the null sentinel.
 409     // If we just called the VM, it already did the mapping for us,
 410     // but it&#39;s harmless to retry.
 411     Label notNull;
 412 
 413     // Stash null_sentinel address to get its value later
 414     __ movptr(rarg, (uintptr_t)Universe::the_null_sentinel_addr());
 415     __ ldr(tmp, Address(rarg));
 416     __ resolve_oop_handle(tmp);
 417     __ cmpoop(result, tmp);
 418     __ br(Assembler::NE, notNull);
 419     __ mov(result, 0);  // NULL object reference
 420     __ bind(notNull);
 421   }
 422 
 423   if (VerifyOops) {
 424     // Safe to call with 0 result
 425     __ verify_oop(result);
 426   }
 427 }
 428 
 429 void TemplateTable::ldc2_w()
 430 {
 431   transition(vtos, vtos);
 432   Label notDouble, notLong, Done;
 433   __ get_unsigned_2_byte_index_at_bcp(r0, 1);
 434 
 435   __ get_cpool_and_tags(r1, r2);
 436   const int base_offset = ConstantPool::header_size() * wordSize;
 437   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 438 
 439   // get type
 440   __ lea(r2, Address(r2, r0, Address::lsl(0)));
 441   __ load_unsigned_byte(r2, Address(r2, tags_offset));
 442   __ cmpw(r2, (int)JVM_CONSTANT_Double);
 443   __ br(Assembler::NE, notDouble);
 444 
 445   // dtos
 446   __ lea (r2, Address(r1, r0, Address::lsl(3)));
 447   __ ldrd(v0, Address(r2, base_offset));
 448   __ push_d();
 449   __ b(Done);
 450 
 451   __ bind(notDouble);
 452   __ cmpw(r2, (int)JVM_CONSTANT_Long);
 453   __ br(Assembler::NE, notLong);
 454 
 455   // ltos
 456   __ lea(r0, Address(r1, r0, Address::lsl(3)));
 457   __ ldr(r0, Address(r0, base_offset));
 458   __ push_l();
 459   __ b(Done);
 460 
 461   __ bind(notLong);
 462   condy_helper(Done);
 463 
 464   __ bind(Done);
 465 }
 466 
 467 void TemplateTable::condy_helper(Label&amp; Done)
 468 {
 469   Register obj = r0;
 470   Register rarg = r1;
 471   Register flags = r2;
 472   Register off = r3;
 473 
 474   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 475 
 476   __ mov(rarg, (int) bytecode());
 477   __ call_VM(obj, entry, rarg);
 478 
 479   __ get_vm_result_2(flags, rthread);
 480 
 481   // VMr = obj = base address to find primitive value to push
 482   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 483   __ mov(off, flags);
 484   __ andw(off, off, ConstantPoolCacheEntry::field_index_mask);
 485 
 486   const Address field(obj, off);
 487 
 488   // What sort of thing are we loading?
 489   // x86 uses a shift and mask or wings it with a shift plus assert
 490   // the mask is not needed. aarch64 just uses bitfield extract
 491   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,
 492            ConstantPoolCacheEntry::tos_state_bits);
 493 
 494   switch (bytecode()) {
 495     case Bytecodes::_ldc:
 496     case Bytecodes::_ldc_w:
 497       {
 498         // tos in (itos, ftos, stos, btos, ctos, ztos)
 499         Label notInt, notFloat, notShort, notByte, notChar, notBool;
 500         __ cmpw(flags, itos);
 501         __ br(Assembler::NE, notInt);
 502         // itos
 503         __ ldrw(r0, field);
 504         __ push(itos);
 505         __ b(Done);
 506 
 507         __ bind(notInt);
 508         __ cmpw(flags, ftos);
 509         __ br(Assembler::NE, notFloat);
 510         // ftos
 511         __ load_float(field);
 512         __ push(ftos);
 513         __ b(Done);
 514 
 515         __ bind(notFloat);
 516         __ cmpw(flags, stos);
 517         __ br(Assembler::NE, notShort);
 518         // stos
 519         __ load_signed_short(r0, field);
 520         __ push(stos);
 521         __ b(Done);
 522 
 523         __ bind(notShort);
 524         __ cmpw(flags, btos);
 525         __ br(Assembler::NE, notByte);
 526         // btos
 527         __ load_signed_byte(r0, field);
 528         __ push(btos);
 529         __ b(Done);
 530 
 531         __ bind(notByte);
 532         __ cmpw(flags, ctos);
 533         __ br(Assembler::NE, notChar);
 534         // ctos
 535         __ load_unsigned_short(r0, field);
 536         __ push(ctos);
 537         __ b(Done);
 538 
 539         __ bind(notChar);
 540         __ cmpw(flags, ztos);
 541         __ br(Assembler::NE, notBool);
 542         // ztos
 543         __ load_signed_byte(r0, field);
 544         __ push(ztos);
 545         __ b(Done);
 546 
 547         __ bind(notBool);
 548         break;
 549       }
 550 
 551     case Bytecodes::_ldc2_w:
 552       {
 553         Label notLong, notDouble;
 554         __ cmpw(flags, ltos);
 555         __ br(Assembler::NE, notLong);
 556         // ltos
 557         __ ldr(r0, field);
 558         __ push(ltos);
 559         __ b(Done);
 560 
 561         __ bind(notLong);
 562         __ cmpw(flags, dtos);
 563         __ br(Assembler::NE, notDouble);
 564         // dtos
 565         __ load_double(field);
 566         __ push(dtos);
 567         __ b(Done);
 568 
 569        __ bind(notDouble);
 570         break;
 571       }
 572 
 573     default:
 574       ShouldNotReachHere();
 575     }
 576 
 577     __ stop(&quot;bad ldc/condy&quot;);
 578 }
 579 
 580 void TemplateTable::locals_index(Register reg, int offset)
 581 {
 582   __ ldrb(reg, at_bcp(offset));
 583   __ neg(reg, reg);
 584 }
 585 
 586 void TemplateTable::iload() {
 587   iload_internal();
 588 }
 589 
 590 void TemplateTable::nofast_iload() {
 591   iload_internal(may_not_rewrite);
 592 }
 593 
 594 void TemplateTable::iload_internal(RewriteControl rc) {
 595   transition(vtos, itos);
 596   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 597     Label rewrite, done;
 598     Register bc = r4;
 599 
 600     // get next bytecode
 601     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_iload)));
 602 
 603     // if _iload, wait to rewrite to iload2.  We only want to rewrite the
 604     // last two iloads in a pair.  Comparing against fast_iload means that
 605     // the next bytecode is neither an iload or a caload, and therefore
 606     // an iload pair.
 607     __ cmpw(r1, Bytecodes::_iload);
 608     __ br(Assembler::EQ, done);
 609 
 610     // if _fast_iload rewrite to _fast_iload2
 611     __ cmpw(r1, Bytecodes::_fast_iload);
 612     __ movw(bc, Bytecodes::_fast_iload2);
 613     __ br(Assembler::EQ, rewrite);
 614 
 615     // if _caload rewrite to _fast_icaload
 616     __ cmpw(r1, Bytecodes::_caload);
 617     __ movw(bc, Bytecodes::_fast_icaload);
 618     __ br(Assembler::EQ, rewrite);
 619 
 620     // else rewrite to _fast_iload
 621     __ movw(bc, Bytecodes::_fast_iload);
 622 
 623     // rewrite
 624     // bc: new bytecode
 625     __ bind(rewrite);
 626     patch_bytecode(Bytecodes::_iload, bc, r1, false);
 627     __ bind(done);
 628 
 629   }
 630 
 631   // do iload, get the local value into tos
 632   locals_index(r1);
 633   __ ldr(r0, iaddress(r1));
 634 
 635 }
 636 
 637 void TemplateTable::fast_iload2()
 638 {
 639   transition(vtos, itos);
 640   locals_index(r1);
 641   __ ldr(r0, iaddress(r1));
 642   __ push(itos);
 643   locals_index(r1, 3);
 644   __ ldr(r0, iaddress(r1));
 645 }
 646 
 647 void TemplateTable::fast_iload()
 648 {
 649   transition(vtos, itos);
 650   locals_index(r1);
 651   __ ldr(r0, iaddress(r1));
 652 }
 653 
 654 void TemplateTable::lload()
 655 {
 656   transition(vtos, ltos);
 657   __ ldrb(r1, at_bcp(1));
 658   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 659   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 660 }
 661 
 662 void TemplateTable::fload()
 663 {
 664   transition(vtos, ftos);
 665   locals_index(r1);
 666   // n.b. we use ldrd here because this is a 64 bit slot
 667   // this is comparable to the iload case
 668   __ ldrd(v0, faddress(r1));
 669 }
 670 
 671 void TemplateTable::dload()
 672 {
 673   transition(vtos, dtos);
 674   __ ldrb(r1, at_bcp(1));
 675   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 676   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 677 }
 678 
 679 void TemplateTable::aload()
 680 {
 681   transition(vtos, atos);
 682   locals_index(r1);
 683   __ ldr(r0, iaddress(r1));
 684 }
 685 
 686 void TemplateTable::locals_index_wide(Register reg) {
 687   __ ldrh(reg, at_bcp(2));
 688   __ rev16w(reg, reg);
 689   __ neg(reg, reg);
 690 }
 691 
 692 void TemplateTable::wide_iload() {
 693   transition(vtos, itos);
 694   locals_index_wide(r1);
 695   __ ldr(r0, iaddress(r1));
 696 }
 697 
 698 void TemplateTable::wide_lload()
 699 {
 700   transition(vtos, ltos);
 701   __ ldrh(r1, at_bcp(2));
 702   __ rev16w(r1, r1);
 703   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 704   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 705 }
 706 
 707 void TemplateTable::wide_fload()
 708 {
 709   transition(vtos, ftos);
 710   locals_index_wide(r1);
 711   // n.b. we use ldrd here because this is a 64 bit slot
 712   // this is comparable to the iload case
 713   __ ldrd(v0, faddress(r1));
 714 }
 715 
 716 void TemplateTable::wide_dload()
 717 {
 718   transition(vtos, dtos);
 719   __ ldrh(r1, at_bcp(2));
 720   __ rev16w(r1, r1);
 721   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 722   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 723 }
 724 
 725 void TemplateTable::wide_aload()
 726 {
 727   transition(vtos, atos);
 728   locals_index_wide(r1);
 729   __ ldr(r0, aaddress(r1));
 730 }
 731 
 732 void TemplateTable::index_check(Register array, Register index)
 733 {
 734   // destroys r1, rscratch1
 735   // check array
 736   __ null_check(array, arrayOopDesc::length_offset_in_bytes());
 737   // sign extend index for use by indexed load
 738   // __ movl2ptr(index, index);
 739   // check index
 740   Register length = rscratch1;
 741   __ ldrw(length, Address(array, arrayOopDesc::length_offset_in_bytes()));
 742   __ cmpw(index, length);
 743   if (index != r1) {
 744     // ??? convention: move aberrant index into r1 for exception message
 745     assert(r1 != array, &quot;different registers&quot;);
 746     __ mov(r1, index);
 747   }
 748   Label ok;
 749   __ br(Assembler::LO, ok);
 750     // ??? convention: move array into r3 for exception message
 751   __ mov(r3, array);
 752   __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
 753   __ br(rscratch1);
 754   __ bind(ok);
 755 }
 756 
 757 void TemplateTable::iaload()
 758 {
 759   transition(itos, itos);
 760   __ mov(r1, r0);
 761   __ pop_ptr(r0);
 762   // r0: array
 763   // r1: index
 764   index_check(r0, r1); // leaves index in r1, kills rscratch1
 765   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
 766   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 767 }
 768 
 769 void TemplateTable::laload()
 770 {
 771   transition(itos, ltos);
 772   __ mov(r1, r0);
 773   __ pop_ptr(r0);
 774   // r0: array
 775   // r1: index
 776   index_check(r0, r1); // leaves index in r1, kills rscratch1
 777   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
 778   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 779 }
 780 
 781 void TemplateTable::faload()
 782 {
 783   transition(itos, ftos);
 784   __ mov(r1, r0);
 785   __ pop_ptr(r0);
 786   // r0: array
 787   // r1: index
 788   index_check(r0, r1); // leaves index in r1, kills rscratch1
 789   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
 790   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 791 }
 792 
 793 void TemplateTable::daload()
 794 {
 795   transition(itos, dtos);
 796   __ mov(r1, r0);
 797   __ pop_ptr(r0);
 798   // r0: array
 799   // r1: index
 800   index_check(r0, r1); // leaves index in r1, kills rscratch1
 801   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
 802   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 803 }
 804 
 805 void TemplateTable::aaload()
 806 {
 807   transition(itos, atos);
 808   __ mov(r1, r0);
 809   __ pop_ptr(r0);
 810   // r0: array
 811   // r1: index
 812   index_check(r0, r1); // leaves index in r1, kills rscratch1
 813   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
 814   do_oop_load(_masm,
 815               Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),
 816               r0,
 817               IS_ARRAY);
 818 }
 819 
 820 void TemplateTable::baload()
 821 {
 822   transition(itos, itos);
 823   __ mov(r1, r0);
 824   __ pop_ptr(r0);
 825   // r0: array
 826   // r1: index
 827   index_check(r0, r1); // leaves index in r1, kills rscratch1
 828   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
 829   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(0)), noreg, noreg);
 830 }
 831 
 832 void TemplateTable::caload()
 833 {
 834   transition(itos, itos);
 835   __ mov(r1, r0);
 836   __ pop_ptr(r0);
 837   // r0: array
 838   // r1: index
 839   index_check(r0, r1); // leaves index in r1, kills rscratch1
 840   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 841   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 842 }
 843 
 844 // iload followed by caload frequent pair
 845 void TemplateTable::fast_icaload()
 846 {
 847   transition(vtos, itos);
 848   // load index out of locals
 849   locals_index(r2);
 850   __ ldr(r1, iaddress(r2));
 851 
 852   __ pop_ptr(r0);
 853 
 854   // r0: array
 855   // r1: index
 856   index_check(r0, r1); // leaves index in r1, kills rscratch1
 857   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 858   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 859 }
 860 
 861 void TemplateTable::saload()
 862 {
 863   transition(itos, itos);
 864   __ mov(r1, r0);
 865   __ pop_ptr(r0);
 866   // r0: array
 867   // r1: index
 868   index_check(r0, r1); // leaves index in r1, kills rscratch1
 869   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_SHORT) &gt;&gt; 1);
 870   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 871 }
 872 
 873 void TemplateTable::iload(int n)
 874 {
 875   transition(vtos, itos);
 876   __ ldr(r0, iaddress(n));
 877 }
 878 
 879 void TemplateTable::lload(int n)
 880 {
 881   transition(vtos, ltos);
 882   __ ldr(r0, laddress(n));
 883 }
 884 
 885 void TemplateTable::fload(int n)
 886 {
 887   transition(vtos, ftos);
 888   __ ldrs(v0, faddress(n));
 889 }
 890 
 891 void TemplateTable::dload(int n)
 892 {
 893   transition(vtos, dtos);
 894   __ ldrd(v0, daddress(n));
 895 }
 896 
 897 void TemplateTable::aload(int n)
 898 {
 899   transition(vtos, atos);
 900   __ ldr(r0, iaddress(n));
 901 }
 902 
 903 void TemplateTable::aload_0() {
 904   aload_0_internal();
 905 }
 906 
 907 void TemplateTable::nofast_aload_0() {
 908   aload_0_internal(may_not_rewrite);
 909 }
 910 
 911 void TemplateTable::aload_0_internal(RewriteControl rc) {
 912   // According to bytecode histograms, the pairs:
 913   //
 914   // _aload_0, _fast_igetfield
 915   // _aload_0, _fast_agetfield
 916   // _aload_0, _fast_fgetfield
 917   //
 918   // occur frequently. If RewriteFrequentPairs is set, the (slow)
 919   // _aload_0 bytecode checks if the next bytecode is either
 920   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
 921   // rewrites the current bytecode into a pair bytecode; otherwise it
 922   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
 923   // the pair check anymore.
 924   //
 925   // Note: If the next bytecode is _getfield, the rewrite must be
 926   //       delayed, otherwise we may miss an opportunity for a pair.
 927   //
 928   // Also rewrite frequent pairs
 929   //   aload_0, aload_1
 930   //   aload_0, iload_1
 931   // These bytecodes with a small amount of code are most profitable
 932   // to rewrite
 933   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 934     Label rewrite, done;
 935     const Register bc = r4;
 936 
 937     // get next bytecode
 938     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_aload_0)));
 939 
 940     // if _getfield then wait with rewrite
 941     __ cmpw(r1, Bytecodes::Bytecodes::_getfield);
 942     __ br(Assembler::EQ, done);
 943 
 944     // if _igetfield then rewrite to _fast_iaccess_0
 945     assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 946     __ cmpw(r1, Bytecodes::_fast_igetfield);
 947     __ movw(bc, Bytecodes::_fast_iaccess_0);
 948     __ br(Assembler::EQ, rewrite);
 949 
 950     // if _agetfield then rewrite to _fast_aaccess_0
 951     assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 952     __ cmpw(r1, Bytecodes::_fast_agetfield);
 953     __ movw(bc, Bytecodes::_fast_aaccess_0);
 954     __ br(Assembler::EQ, rewrite);
 955 
 956     // if _fgetfield then rewrite to _fast_faccess_0
 957     assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 958     __ cmpw(r1, Bytecodes::_fast_fgetfield);
 959     __ movw(bc, Bytecodes::_fast_faccess_0);
 960     __ br(Assembler::EQ, rewrite);
 961 
 962     // else rewrite to _fast_aload0
 963     assert(Bytecodes::java_code(Bytecodes::_fast_aload_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 964     __ movw(bc, Bytecodes::Bytecodes::_fast_aload_0);
 965 
 966     // rewrite
 967     // bc: new bytecode
 968     __ bind(rewrite);
 969     patch_bytecode(Bytecodes::_aload_0, bc, r1, false);
 970 
 971     __ bind(done);
 972   }
 973 
 974   // Do actual aload_0 (must do this after patch_bytecode which might call VM and GC might change oop).
 975   aload(0);
 976 }
 977 
 978 void TemplateTable::istore()
 979 {
 980   transition(itos, vtos);
 981   locals_index(r1);
 982   // FIXME: We&#39;re being very pernickerty here storing a jint in a
 983   // local with strw, which costs an extra instruction over what we&#39;d
 984   // be able to do with a simple str.  We should just store the whole
 985   // word.
 986   __ lea(rscratch1, iaddress(r1));
 987   __ strw(r0, Address(rscratch1));
 988 }
 989 
 990 void TemplateTable::lstore()
 991 {
 992   transition(ltos, vtos);
 993   locals_index(r1);
 994   __ str(r0, laddress(r1, rscratch1, _masm));
 995 }
 996 
 997 void TemplateTable::fstore() {
 998   transition(ftos, vtos);
 999   locals_index(r1);
1000   __ lea(rscratch1, iaddress(r1));
1001   __ strs(v0, Address(rscratch1));
1002 }
1003 
1004 void TemplateTable::dstore() {
1005   transition(dtos, vtos);
1006   locals_index(r1);
1007   __ strd(v0, daddress(r1, rscratch1, _masm));
1008 }
1009 
1010 void TemplateTable::astore()
1011 {
1012   transition(vtos, vtos);
1013   __ pop_ptr(r0);
1014   locals_index(r1);
1015   __ str(r0, aaddress(r1));
1016 }
1017 
1018 void TemplateTable::wide_istore() {
1019   transition(vtos, vtos);
1020   __ pop_i();
1021   locals_index_wide(r1);
1022   __ lea(rscratch1, iaddress(r1));
1023   __ strw(r0, Address(rscratch1));
1024 }
1025 
1026 void TemplateTable::wide_lstore() {
1027   transition(vtos, vtos);
1028   __ pop_l();
1029   locals_index_wide(r1);
1030   __ str(r0, laddress(r1, rscratch1, _masm));
1031 }
1032 
1033 void TemplateTable::wide_fstore() {
1034   transition(vtos, vtos);
1035   __ pop_f();
1036   locals_index_wide(r1);
1037   __ lea(rscratch1, faddress(r1));
1038   __ strs(v0, rscratch1);
1039 }
1040 
1041 void TemplateTable::wide_dstore() {
1042   transition(vtos, vtos);
1043   __ pop_d();
1044   locals_index_wide(r1);
1045   __ strd(v0, daddress(r1, rscratch1, _masm));
1046 }
1047 
1048 void TemplateTable::wide_astore() {
1049   transition(vtos, vtos);
1050   __ pop_ptr(r0);
1051   locals_index_wide(r1);
1052   __ str(r0, aaddress(r1));
1053 }
1054 
1055 void TemplateTable::iastore() {
1056   transition(itos, vtos);
1057   __ pop_i(r1);
1058   __ pop_ptr(r3);
1059   // r0: value
1060   // r1: index
1061   // r3: array
1062   index_check(r3, r1); // prefer index in r1
1063   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
1064   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg);
1065 }
1066 
1067 void TemplateTable::lastore() {
1068   transition(ltos, vtos);
1069   __ pop_i(r1);
1070   __ pop_ptr(r3);
1071   // r0: value
1072   // r1: index
1073   // r3: array
1074   index_check(r3, r1); // prefer index in r1
1075   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
1076   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg);
1077 }
1078 
1079 void TemplateTable::fastore() {
1080   transition(ftos, vtos);
1081   __ pop_i(r1);
1082   __ pop_ptr(r3);
1083   // v0: value
1084   // r1:  index
1085   // r3:  array
1086   index_check(r3, r1); // prefer index in r1
1087   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
1088   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg /* ftos */, noreg, noreg);
1089 }
1090 
1091 void TemplateTable::dastore() {
1092   transition(dtos, vtos);
1093   __ pop_i(r1);
1094   __ pop_ptr(r3);
1095   // v0: value
1096   // r1:  index
1097   // r3:  array
1098   index_check(r3, r1); // prefer index in r1
1099   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
1100   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg /* dtos */, noreg, noreg);
1101 }
1102 
1103 void TemplateTable::aastore() {
1104   Label is_null, ok_is_subtype, done;
1105   transition(vtos, vtos);
1106   // stack: ..., array, index, value
1107   __ ldr(r0, at_tos());    // value
1108   __ ldr(r2, at_tos_p1()); // index
1109   __ ldr(r3, at_tos_p2()); // array
1110 
1111   Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));
1112 
1113   index_check(r3, r2);     // kills r1
1114   __ add(r4, r2, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
1115 
1116   // do array store check - check for NULL value first
1117   __ cbz(r0, is_null);
1118 
1119   // Move subklass into r1
1120   __ load_klass(r1, r0);
1121   // Move superklass into r0
1122   __ load_klass(r0, r3);
1123   __ ldr(r0, Address(r0,
1124                      ObjArrayKlass::element_klass_offset()));
1125   // Compress array + index*oopSize + 12 into a single register.  Frees r2.
1126 
1127   // Generate subtype check.  Blows r2, r5
1128   // Superklass in r0.  Subklass in r1.
1129   __ gen_subtype_check(r1, ok_is_subtype);
1130 
1131   // Come here on failure
1132   // object is at TOS
1133   __ b(Interpreter::_throw_ArrayStoreException_entry);
1134 
1135   // Come here on success
1136   __ bind(ok_is_subtype);
1137 
1138   // Get the value we will store
1139   __ ldr(r0, at_tos());
1140   // Now store using the appropriate barrier
1141   do_oop_store(_masm, element_address, r0, IS_ARRAY);
1142   __ b(done);
1143 
1144   // Have a NULL in r0, r3=array, r2=index.  Store NULL at ary[idx]
1145   __ bind(is_null);
1146   __ profile_null_seen(r2);
1147 
1148   // Store a NULL
1149   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
1150 
1151   // Pop stack arguments
1152   __ bind(done);
1153   __ add(esp, esp, 3 * Interpreter::stackElementSize);
1154 }
1155 
1156 void TemplateTable::bastore()
1157 {
1158   transition(itos, vtos);
1159   __ pop_i(r1);
1160   __ pop_ptr(r3);
1161   // r0: value
1162   // r1: index
1163   // r3: array
1164   index_check(r3, r1); // prefer index in r1
1165 
1166   // Need to check whether array is boolean or byte
1167   // since both types share the bastore bytecode.
1168   __ load_klass(r2, r3);
1169   __ ldrw(r2, Address(r2, Klass::layout_helper_offset()));
1170   int diffbit_index = exact_log2(Klass::layout_helper_boolean_diffbit());
1171   Label L_skip;
1172   __ tbz(r2, diffbit_index, L_skip);
1173   __ andw(r0, r0, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
1174   __ bind(L_skip);
1175 
1176   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
1177   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg);
1178 }
1179 
1180 void TemplateTable::castore()
1181 {
1182   transition(itos, vtos);
1183   __ pop_i(r1);
1184   __ pop_ptr(r3);
1185   // r0: value
1186   // r1: index
1187   // r3: array
1188   index_check(r3, r1); // prefer index in r1
1189   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
1190   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg);
1191 }
1192 
1193 void TemplateTable::sastore()
1194 {
1195   castore();
1196 }
1197 
1198 void TemplateTable::istore(int n)
1199 {
1200   transition(itos, vtos);
1201   __ str(r0, iaddress(n));
1202 }
1203 
1204 void TemplateTable::lstore(int n)
1205 {
1206   transition(ltos, vtos);
1207   __ str(r0, laddress(n));
1208 }
1209 
1210 void TemplateTable::fstore(int n)
1211 {
1212   transition(ftos, vtos);
1213   __ strs(v0, faddress(n));
1214 }
1215 
1216 void TemplateTable::dstore(int n)
1217 {
1218   transition(dtos, vtos);
1219   __ strd(v0, daddress(n));
1220 }
1221 
1222 void TemplateTable::astore(int n)
1223 {
1224   transition(vtos, vtos);
1225   __ pop_ptr(r0);
1226   __ str(r0, iaddress(n));
1227 }
1228 
1229 void TemplateTable::pop()
1230 {
1231   transition(vtos, vtos);
1232   __ add(esp, esp, Interpreter::stackElementSize);
1233 }
1234 
1235 void TemplateTable::pop2()
1236 {
1237   transition(vtos, vtos);
1238   __ add(esp, esp, 2 * Interpreter::stackElementSize);
1239 }
1240 
1241 void TemplateTable::dup()
1242 {
1243   transition(vtos, vtos);
1244   __ ldr(r0, Address(esp, 0));
1245   __ push(r0);
1246   // stack: ..., a, a
1247 }
1248 
1249 void TemplateTable::dup_x1()
1250 {
1251   transition(vtos, vtos);
1252   // stack: ..., a, b
1253   __ ldr(r0, at_tos());  // load b
1254   __ ldr(r2, at_tos_p1());  // load a
1255   __ str(r0, at_tos_p1());  // store b
1256   __ str(r2, at_tos());  // store a
1257   __ push(r0);                  // push b
1258   // stack: ..., b, a, b
1259 }
1260 
1261 void TemplateTable::dup_x2()
1262 {
1263   transition(vtos, vtos);
1264   // stack: ..., a, b, c
1265   __ ldr(r0, at_tos());  // load c
1266   __ ldr(r2, at_tos_p2());  // load a
1267   __ str(r0, at_tos_p2());  // store c in a
1268   __ push(r0);      // push c
1269   // stack: ..., c, b, c, c
1270   __ ldr(r0, at_tos_p2());  // load b
1271   __ str(r2, at_tos_p2());  // store a in b
1272   // stack: ..., c, a, c, c
1273   __ str(r0, at_tos_p1());  // store b in c
1274   // stack: ..., c, a, b, c
1275 }
1276 
1277 void TemplateTable::dup2()
1278 {
1279   transition(vtos, vtos);
1280   // stack: ..., a, b
1281   __ ldr(r0, at_tos_p1());  // load a
1282   __ push(r0);                  // push a
1283   __ ldr(r0, at_tos_p1());  // load b
1284   __ push(r0);                  // push b
1285   // stack: ..., a, b, a, b
1286 }
1287 
1288 void TemplateTable::dup2_x1()
1289 {
1290   transition(vtos, vtos);
1291   // stack: ..., a, b, c
1292   __ ldr(r2, at_tos());  // load c
1293   __ ldr(r0, at_tos_p1());  // load b
1294   __ push(r0);                  // push b
1295   __ push(r2);                  // push c
1296   // stack: ..., a, b, c, b, c
1297   __ str(r2, at_tos_p3());  // store c in b
1298   // stack: ..., a, c, c, b, c
1299   __ ldr(r2, at_tos_p4());  // load a
1300   __ str(r2, at_tos_p2());  // store a in 2nd c
1301   // stack: ..., a, c, a, b, c
1302   __ str(r0, at_tos_p4());  // store b in a
1303   // stack: ..., b, c, a, b, c
1304 }
1305 
1306 void TemplateTable::dup2_x2()
1307 {
1308   transition(vtos, vtos);
1309   // stack: ..., a, b, c, d
1310   __ ldr(r2, at_tos());  // load d
1311   __ ldr(r0, at_tos_p1());  // load c
1312   __ push(r0)            ;      // push c
1313   __ push(r2);                  // push d
1314   // stack: ..., a, b, c, d, c, d
1315   __ ldr(r0, at_tos_p4());  // load b
1316   __ str(r0, at_tos_p2());  // store b in d
1317   __ str(r2, at_tos_p4());  // store d in b
1318   // stack: ..., a, d, c, b, c, d
1319   __ ldr(r2, at_tos_p5());  // load a
1320   __ ldr(r0, at_tos_p3());  // load c
1321   __ str(r2, at_tos_p3());  // store a in c
1322   __ str(r0, at_tos_p5());  // store c in a
1323   // stack: ..., c, d, a, b, c, d
1324 }
1325 
1326 void TemplateTable::swap()
1327 {
1328   transition(vtos, vtos);
1329   // stack: ..., a, b
1330   __ ldr(r2, at_tos_p1());  // load a
1331   __ ldr(r0, at_tos());  // load b
1332   __ str(r2, at_tos());  // store a in b
1333   __ str(r0, at_tos_p1());  // store b in a
1334   // stack: ..., b, a
1335 }
1336 
1337 void TemplateTable::iop2(Operation op)
1338 {
1339   transition(itos, itos);
1340   // r0 &lt;== r1 op r0
1341   __ pop_i(r1);
1342   switch (op) {
1343   case add  : __ addw(r0, r1, r0); break;
1344   case sub  : __ subw(r0, r1, r0); break;
1345   case mul  : __ mulw(r0, r1, r0); break;
1346   case _and : __ andw(r0, r1, r0); break;
1347   case _or  : __ orrw(r0, r1, r0); break;
1348   case _xor : __ eorw(r0, r1, r0); break;
1349   case shl  : __ lslvw(r0, r1, r0); break;
1350   case shr  : __ asrvw(r0, r1, r0); break;
1351   case ushr : __ lsrvw(r0, r1, r0);break;
1352   default   : ShouldNotReachHere();
1353   }
1354 }
1355 
1356 void TemplateTable::lop2(Operation op)
1357 {
1358   transition(ltos, ltos);
1359   // r0 &lt;== r1 op r0
1360   __ pop_l(r1);
1361   switch (op) {
1362   case add  : __ add(r0, r1, r0); break;
1363   case sub  : __ sub(r0, r1, r0); break;
1364   case mul  : __ mul(r0, r1, r0); break;
1365   case _and : __ andr(r0, r1, r0); break;
1366   case _or  : __ orr(r0, r1, r0); break;
1367   case _xor : __ eor(r0, r1, r0); break;
1368   default   : ShouldNotReachHere();
1369   }
1370 }
1371 
1372 void TemplateTable::idiv()
1373 {
1374   transition(itos, itos);
1375   // explicitly check for div0
1376   Label no_div0;
1377   __ cbnzw(r0, no_div0);
1378   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1379   __ br(rscratch1);
1380   __ bind(no_div0);
1381   __ pop_i(r1);
1382   // r0 &lt;== r1 idiv r0
1383   __ corrected_idivl(r0, r1, r0, /* want_remainder */ false);
1384 }
1385 
1386 void TemplateTable::irem()
1387 {
1388   transition(itos, itos);
1389   // explicitly check for div0
1390   Label no_div0;
1391   __ cbnzw(r0, no_div0);
1392   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1393   __ br(rscratch1);
1394   __ bind(no_div0);
1395   __ pop_i(r1);
1396   // r0 &lt;== r1 irem r0
1397   __ corrected_idivl(r0, r1, r0, /* want_remainder */ true);
1398 }
1399 
1400 void TemplateTable::lmul()
1401 {
1402   transition(ltos, ltos);
1403   __ pop_l(r1);
1404   __ mul(r0, r0, r1);
1405 }
1406 
1407 void TemplateTable::ldiv()
1408 {
1409   transition(ltos, ltos);
1410   // explicitly check for div0
1411   Label no_div0;
1412   __ cbnz(r0, no_div0);
1413   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1414   __ br(rscratch1);
1415   __ bind(no_div0);
1416   __ pop_l(r1);
1417   // r0 &lt;== r1 ldiv r0
1418   __ corrected_idivq(r0, r1, r0, /* want_remainder */ false);
1419 }
1420 
1421 void TemplateTable::lrem()
1422 {
1423   transition(ltos, ltos);
1424   // explicitly check for div0
1425   Label no_div0;
1426   __ cbnz(r0, no_div0);
1427   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1428   __ br(rscratch1);
1429   __ bind(no_div0);
1430   __ pop_l(r1);
1431   // r0 &lt;== r1 lrem r0
1432   __ corrected_idivq(r0, r1, r0, /* want_remainder */ true);
1433 }
1434 
1435 void TemplateTable::lshl()
1436 {
1437   transition(itos, ltos);
1438   // shift count is in r0
1439   __ pop_l(r1);
1440   __ lslv(r0, r1, r0);
1441 }
1442 
1443 void TemplateTable::lshr()
1444 {
1445   transition(itos, ltos);
1446   // shift count is in r0
1447   __ pop_l(r1);
1448   __ asrv(r0, r1, r0);
1449 }
1450 
1451 void TemplateTable::lushr()
1452 {
1453   transition(itos, ltos);
1454   // shift count is in r0
1455   __ pop_l(r1);
1456   __ lsrv(r0, r1, r0);
1457 }
1458 
1459 void TemplateTable::fop2(Operation op)
1460 {
1461   transition(ftos, ftos);
1462   switch (op) {
1463   case add:
1464     // n.b. use ldrd because this is a 64 bit slot
1465     __ pop_f(v1);
1466     __ fadds(v0, v1, v0);
1467     break;
1468   case sub:
1469     __ pop_f(v1);
1470     __ fsubs(v0, v1, v0);
1471     break;
1472   case mul:
1473     __ pop_f(v1);
1474     __ fmuls(v0, v1, v0);
1475     break;
1476   case div:
1477     __ pop_f(v1);
1478     __ fdivs(v0, v1, v0);
1479     break;
1480   case rem:
1481     __ fmovs(v1, v0);
1482     __ pop_f(v0);
1483     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem));
1484     break;
1485   default:
1486     ShouldNotReachHere();
1487     break;
1488   }
1489 }
1490 
1491 void TemplateTable::dop2(Operation op)
1492 {
1493   transition(dtos, dtos);
1494   switch (op) {
1495   case add:
1496     // n.b. use ldrd because this is a 64 bit slot
1497     __ pop_d(v1);
1498     __ faddd(v0, v1, v0);
1499     break;
1500   case sub:
1501     __ pop_d(v1);
1502     __ fsubd(v0, v1, v0);
1503     break;
1504   case mul:
1505     __ pop_d(v1);
1506     __ fmuld(v0, v1, v0);
1507     break;
1508   case div:
1509     __ pop_d(v1);
1510     __ fdivd(v0, v1, v0);
1511     break;
1512   case rem:
1513     __ fmovd(v1, v0);
1514     __ pop_d(v0);
1515     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem));
1516     break;
1517   default:
1518     ShouldNotReachHere();
1519     break;
1520   }
1521 }
1522 
1523 void TemplateTable::ineg()
1524 {
1525   transition(itos, itos);
1526   __ negw(r0, r0);
1527 
1528 }
1529 
1530 void TemplateTable::lneg()
1531 {
1532   transition(ltos, ltos);
1533   __ neg(r0, r0);
1534 }
1535 
1536 void TemplateTable::fneg()
1537 {
1538   transition(ftos, ftos);
1539   __ fnegs(v0, v0);
1540 }
1541 
1542 void TemplateTable::dneg()
1543 {
1544   transition(dtos, dtos);
1545   __ fnegd(v0, v0);
1546 }
1547 
1548 void TemplateTable::iinc()
1549 {
1550   transition(vtos, vtos);
1551   __ load_signed_byte(r1, at_bcp(2)); // get constant
1552   locals_index(r2);
1553   __ ldr(r0, iaddress(r2));
1554   __ addw(r0, r0, r1);
1555   __ str(r0, iaddress(r2));
1556 }
1557 
1558 void TemplateTable::wide_iinc()
1559 {
1560   transition(vtos, vtos);
1561   // __ mov(r1, zr);
1562   __ ldrw(r1, at_bcp(2)); // get constant and index
1563   __ rev16(r1, r1);
1564   __ ubfx(r2, r1, 0, 16);
1565   __ neg(r2, r2);
1566   __ sbfx(r1, r1, 16, 16);
1567   __ ldr(r0, iaddress(r2));
1568   __ addw(r0, r0, r1);
1569   __ str(r0, iaddress(r2));
1570 }
1571 
1572 void TemplateTable::convert()
1573 {
1574   // Checking
1575 #ifdef ASSERT
1576   {
1577     TosState tos_in  = ilgl;
1578     TosState tos_out = ilgl;
1579     switch (bytecode()) {
1580     case Bytecodes::_i2l: // fall through
1581     case Bytecodes::_i2f: // fall through
1582     case Bytecodes::_i2d: // fall through
1583     case Bytecodes::_i2b: // fall through
1584     case Bytecodes::_i2c: // fall through
1585     case Bytecodes::_i2s: tos_in = itos; break;
1586     case Bytecodes::_l2i: // fall through
1587     case Bytecodes::_l2f: // fall through
1588     case Bytecodes::_l2d: tos_in = ltos; break;
1589     case Bytecodes::_f2i: // fall through
1590     case Bytecodes::_f2l: // fall through
1591     case Bytecodes::_f2d: tos_in = ftos; break;
1592     case Bytecodes::_d2i: // fall through
1593     case Bytecodes::_d2l: // fall through
1594     case Bytecodes::_d2f: tos_in = dtos; break;
1595     default             : ShouldNotReachHere();
1596     }
1597     switch (bytecode()) {
1598     case Bytecodes::_l2i: // fall through
1599     case Bytecodes::_f2i: // fall through
1600     case Bytecodes::_d2i: // fall through
1601     case Bytecodes::_i2b: // fall through
1602     case Bytecodes::_i2c: // fall through
1603     case Bytecodes::_i2s: tos_out = itos; break;
1604     case Bytecodes::_i2l: // fall through
1605     case Bytecodes::_f2l: // fall through
1606     case Bytecodes::_d2l: tos_out = ltos; break;
1607     case Bytecodes::_i2f: // fall through
1608     case Bytecodes::_l2f: // fall through
1609     case Bytecodes::_d2f: tos_out = ftos; break;
1610     case Bytecodes::_i2d: // fall through
1611     case Bytecodes::_l2d: // fall through
1612     case Bytecodes::_f2d: tos_out = dtos; break;
1613     default             : ShouldNotReachHere();
1614     }
1615     transition(tos_in, tos_out);
1616   }
1617 #endif // ASSERT
1618   // static const int64_t is_nan = 0x8000000000000000L;
1619 
1620   // Conversion
1621   switch (bytecode()) {
1622   case Bytecodes::_i2l:
1623     __ sxtw(r0, r0);
1624     break;
1625   case Bytecodes::_i2f:
1626     __ scvtfws(v0, r0);
1627     break;
1628   case Bytecodes::_i2d:
1629     __ scvtfwd(v0, r0);
1630     break;
1631   case Bytecodes::_i2b:
1632     __ sxtbw(r0, r0);
1633     break;
1634   case Bytecodes::_i2c:
1635     __ uxthw(r0, r0);
1636     break;
1637   case Bytecodes::_i2s:
1638     __ sxthw(r0, r0);
1639     break;
1640   case Bytecodes::_l2i:
1641     __ uxtw(r0, r0);
1642     break;
1643   case Bytecodes::_l2f:
1644     __ scvtfs(v0, r0);
1645     break;
1646   case Bytecodes::_l2d:
1647     __ scvtfd(v0, r0);
1648     break;
1649   case Bytecodes::_f2i:
1650   {
1651     Label L_Okay;
1652     __ clear_fpsr();
1653     __ fcvtzsw(r0, v0);
1654     __ get_fpsr(r1);
1655     __ cbzw(r1, L_Okay);
1656     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i));
1657     __ bind(L_Okay);
1658   }
1659     break;
1660   case Bytecodes::_f2l:
1661   {
1662     Label L_Okay;
1663     __ clear_fpsr();
1664     __ fcvtzs(r0, v0);
1665     __ get_fpsr(r1);
1666     __ cbzw(r1, L_Okay);
1667     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l));
1668     __ bind(L_Okay);
1669   }
1670     break;
1671   case Bytecodes::_f2d:
1672     __ fcvts(v0, v0);
1673     break;
1674   case Bytecodes::_d2i:
1675   {
1676     Label L_Okay;
1677     __ clear_fpsr();
1678     __ fcvtzdw(r0, v0);
1679     __ get_fpsr(r1);
1680     __ cbzw(r1, L_Okay);
1681     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i));
1682     __ bind(L_Okay);
1683   }
1684     break;
1685   case Bytecodes::_d2l:
1686   {
1687     Label L_Okay;
1688     __ clear_fpsr();
1689     __ fcvtzd(r0, v0);
1690     __ get_fpsr(r1);
1691     __ cbzw(r1, L_Okay);
1692     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l));
1693     __ bind(L_Okay);
1694   }
1695     break;
1696   case Bytecodes::_d2f:
1697     __ fcvtd(v0, v0);
1698     break;
1699   default:
1700     ShouldNotReachHere();
1701   }
1702 }
1703 
1704 void TemplateTable::lcmp()
1705 {
1706   transition(ltos, itos);
1707   Label done;
1708   __ pop_l(r1);
1709   __ cmp(r1, r0);
1710   __ mov(r0, (uint64_t)-1L);
1711   __ br(Assembler::LT, done);
1712   // __ mov(r0, 1UL);
1713   // __ csel(r0, r0, zr, Assembler::NE);
1714   // and here is a faster way
1715   __ csinc(r0, zr, zr, Assembler::EQ);
1716   __ bind(done);
1717 }
1718 
1719 void TemplateTable::float_cmp(bool is_float, int unordered_result)
1720 {
1721   Label done;
1722   if (is_float) {
1723     // XXX get rid of pop here, use ... reg, mem32
1724     __ pop_f(v1);
1725     __ fcmps(v1, v0);
1726   } else {
1727     // XXX get rid of pop here, use ... reg, mem64
1728     __ pop_d(v1);
1729     __ fcmpd(v1, v0);
1730   }
1731   if (unordered_result &lt; 0) {
1732     // we want -1 for unordered or less than, 0 for equal and 1 for
1733     // greater than.
1734     __ mov(r0, (uint64_t)-1L);
1735     // for FP LT tests less than or unordered
1736     __ br(Assembler::LT, done);
1737     // install 0 for EQ otherwise 1
1738     __ csinc(r0, zr, zr, Assembler::EQ);
1739   } else {
1740     // we want -1 for less than, 0 for equal and 1 for unordered or
1741     // greater than.
1742     __ mov(r0, 1L);
1743     // for FP HI tests greater than or unordered
1744     __ br(Assembler::HI, done);
1745     // install 0 for EQ otherwise ~0
1746     __ csinv(r0, zr, zr, Assembler::EQ);
1747 
1748   }
1749   __ bind(done);
1750 }
1751 
1752 void TemplateTable::branch(bool is_jsr, bool is_wide)
1753 {
1754   // We might be moving to a safepoint.  The thread which calls
1755   // Interpreter::notice_safepoints() will effectively flush its cache
1756   // when it makes a system call, but we need to do something to
1757   // ensure that we see the changed dispatch table.
1758   __ membar(MacroAssembler::LoadLoad);
1759 
1760   __ profile_taken_branch(r0, r1);
1761   const ByteSize be_offset = MethodCounters::backedge_counter_offset() +
1762                              InvocationCounter::counter_offset();
1763   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() +
1764                               InvocationCounter::counter_offset();
1765 
1766   // load branch displacement
1767   if (!is_wide) {
1768     __ ldrh(r2, at_bcp(1));
1769     __ rev16(r2, r2);
1770     // sign extend the 16 bit value in r2
1771     __ sbfm(r2, r2, 0, 15);
1772   } else {
1773     __ ldrw(r2, at_bcp(1));
1774     __ revw(r2, r2);
1775     // sign extend the 32 bit value in r2
1776     __ sbfm(r2, r2, 0, 31);
1777   }
1778 
1779   // Handle all the JSR stuff here, then exit.
1780   // It&#39;s much shorter and cleaner than intermingling with the non-JSR
1781   // normal-branch stuff occurring below.
1782 
1783   if (is_jsr) {
1784     // Pre-load the next target bytecode into rscratch1
1785     __ load_unsigned_byte(rscratch1, Address(rbcp, r2));
1786     // compute return address as bci
1787     __ ldr(rscratch2, Address(rmethod, Method::const_offset()));
1788     __ add(rscratch2, rscratch2,
1789            in_bytes(ConstMethod::codes_offset()) - (is_wide ? 5 : 3));
1790     __ sub(r1, rbcp, rscratch2);
1791     __ push_i(r1);
1792     // Adjust the bcp by the 16-bit displacement in r2
1793     __ add(rbcp, rbcp, r2);
1794     __ dispatch_only(vtos, /*generate_poll*/true);
1795     return;
1796   }
1797 
1798   // Normal (non-jsr) branch handling
1799 
1800   // Adjust the bcp by the displacement in r2
1801   __ add(rbcp, rbcp, r2);
1802 
1803   assert(UseLoopCounter || !UseOnStackReplacement,
1804          &quot;on-stack-replacement requires loop counters&quot;);
1805   Label backedge_counter_overflow;
1806   Label profile_method;
1807   Label dispatch;
1808   if (UseLoopCounter) {
1809     // increment backedge counter for backward branches
1810     // r0: MDO
1811     // w1: MDO bumped taken-count
1812     // r2: target offset
1813     __ cmp(r2, zr);
1814     __ br(Assembler::GT, dispatch); // count only if backward branch
1815 
1816     // ECN: FIXME: This code smells
1817     // check if MethodCounters exists
1818     Label has_counters;
1819     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1820     __ cbnz(rscratch1, has_counters);
1821     __ push(r0);
1822     __ push(r1);
1823     __ push(r2);
1824     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
1825             InterpreterRuntime::build_method_counters), rmethod);
1826     __ pop(r2);
1827     __ pop(r1);
1828     __ pop(r0);
1829     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1830     __ cbz(rscratch1, dispatch); // No MethodCounters allocated, OutOfMemory
1831     __ bind(has_counters);
1832 
1833     if (TieredCompilation) {
1834       Label no_mdo;
1835       int increment = InvocationCounter::count_increment;
1836       if (ProfileInterpreter) {
1837         // Are we profiling?
1838         __ ldr(r1, Address(rmethod, in_bytes(Method::method_data_offset())));
1839         __ cbz(r1, no_mdo);
1840         // Increment the MDO backedge counter
1841         const Address mdo_backedge_counter(r1, in_bytes(MethodData::backedge_counter_offset()) +
1842                                            in_bytes(InvocationCounter::counter_offset()));
1843         const Address mask(r1, in_bytes(MethodData::backedge_mask_offset()));
1844         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,
1845                                    r0, rscratch1, false, Assembler::EQ,
1846                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1847         __ b(dispatch);
1848       }
1849       __ bind(no_mdo);
1850       // Increment backedge counter in MethodCounters*
1851       __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1852       const Address mask(rscratch1, in_bytes(MethodCounters::backedge_mask_offset()));
1853       __ increment_mask_and_jump(Address(rscratch1, be_offset), increment, mask,
1854                                  r0, rscratch2, false, Assembler::EQ,
1855                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1856     } else { // not TieredCompilation
1857       // increment counter
1858       __ ldr(rscratch2, Address(rmethod, Method::method_counters_offset()));
1859       __ ldrw(r0, Address(rscratch2, be_offset));        // load backedge counter
1860       __ addw(rscratch1, r0, InvocationCounter::count_increment); // increment counter
1861       __ strw(rscratch1, Address(rscratch2, be_offset));        // store counter
1862 
1863       __ ldrw(r0, Address(rscratch2, inv_offset));    // load invocation counter
1864       __ andw(r0, r0, (unsigned)InvocationCounter::count_mask_value); // and the status bits
1865       __ addw(r0, r0, rscratch1);        // add both counters
1866 
1867       if (ProfileInterpreter) {
1868         // Test to see if we should create a method data oop
1869         __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_profile_limit_offset())));
1870         __ cmpw(r0, rscratch1);
1871         __ br(Assembler::LT, dispatch);
1872 
1873         // if no method data exists, go to profile method
1874         __ test_method_data_pointer(r0, profile_method);
1875 
1876         if (UseOnStackReplacement) {
1877           // check for overflow against w1 which is the MDO taken count
1878           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1879           __ cmpw(r1, rscratch1);
1880           __ br(Assembler::LO, dispatch); // Intel == Assembler::below
1881 
1882           // When ProfileInterpreter is on, the backedge_count comes
1883           // from the MethodData*, which value does not get reset on
1884           // the call to frequency_counter_overflow().  To avoid
1885           // excessive calls to the overflow routine while the method is
1886           // being compiled, add a second test to make sure the overflow
1887           // function is called only once every overflow_frequency.
1888           const int overflow_frequency = 1024;
1889           __ andsw(r1, r1, overflow_frequency - 1);
1890           __ br(Assembler::EQ, backedge_counter_overflow);
1891 
1892         }
1893       } else {
1894         if (UseOnStackReplacement) {
1895           // check for overflow against w0, which is the sum of the
1896           // counters
1897           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1898           __ cmpw(r0, rscratch1);
1899           __ br(Assembler::HS, backedge_counter_overflow); // Intel == Assembler::aboveEqual
1900         }
1901       }
1902     }
1903     __ bind(dispatch);
1904   }
1905 
1906   // Pre-load the next target bytecode into rscratch1
1907   __ load_unsigned_byte(rscratch1, Address(rbcp, 0));
1908 
1909   // continue with the bytecode @ target
1910   // rscratch1: target bytecode
1911   // rbcp: target bcp
1912   __ dispatch_only(vtos, /*generate_poll*/true);
1913 
1914   if (UseLoopCounter) {
1915     if (ProfileInterpreter) {
1916       // Out-of-line code to allocate method data oop.
1917       __ bind(profile_method);
1918       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
1919       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
1920       __ set_method_data_pointer_for_bcp();
1921       __ b(dispatch);
1922     }
1923 
1924     if (UseOnStackReplacement) {
1925       // invocation counter overflow
1926       __ bind(backedge_counter_overflow);
1927       __ neg(r2, r2);
1928       __ add(r2, r2, rbcp);     // branch bcp
1929       // IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)
1930       __ call_VM(noreg,
1931                  CAST_FROM_FN_PTR(address,
1932                                   InterpreterRuntime::frequency_counter_overflow),
1933                  r2);
1934       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
1935 
1936       // r0: osr nmethod (osr ok) or NULL (osr not possible)
1937       // w1: target bytecode
1938       // r2: scratch
1939       __ cbz(r0, dispatch);     // test result -- no osr if null
1940       // nmethod may have been invalidated (VM may block upon call_VM return)
1941       __ ldrb(r2, Address(r0, nmethod::state_offset()));
1942       if (nmethod::in_use != 0)
1943         __ sub(r2, r2, nmethod::in_use);
1944       __ cbnz(r2, dispatch);
1945 
1946       // We have the address of an on stack replacement routine in r0
1947       // We need to prepare to execute the OSR method. First we must
1948       // migrate the locals and monitors off of the stack.
1949 
1950       __ mov(r19, r0);                             // save the nmethod
1951 
1952       call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
1953 
1954       // r0 is OSR buffer, move it to expected parameter location
1955       __ mov(j_rarg0, r0);
1956 
1957       // remove activation
1958       // get sender esp
1959       __ ldr(esp,
1960           Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));
1961       // remove frame anchor
1962       __ leave();
1963       // Ensure compiled code always sees stack at proper alignment
1964       __ andr(sp, esp, -16);
1965 
1966       // and begin the OSR nmethod
1967       __ ldr(rscratch1, Address(r19, nmethod::osr_entry_point_offset()));
1968       __ br(rscratch1);
1969     }
1970   }
1971 }
1972 
1973 
1974 void TemplateTable::if_0cmp(Condition cc)
1975 {
1976   transition(itos, vtos);
1977   // assume branch is more often taken than not (loops use backward branches)
1978   Label not_taken;
1979   if (cc == equal)
1980     __ cbnzw(r0, not_taken);
1981   else if (cc == not_equal)
1982     __ cbzw(r0, not_taken);
1983   else {
1984     __ andsw(zr, r0, r0);
1985     __ br(j_not(cc), not_taken);
1986   }
1987 
1988   branch(false, false);
1989   __ bind(not_taken);
1990   __ profile_not_taken_branch(r0);
1991 }
1992 
1993 void TemplateTable::if_icmp(Condition cc)
1994 {
1995   transition(itos, vtos);
1996   // assume branch is more often taken than not (loops use backward branches)
1997   Label not_taken;
1998   __ pop_i(r1);
1999   __ cmpw(r1, r0, Assembler::LSL);
2000   __ br(j_not(cc), not_taken);
2001   branch(false, false);
2002   __ bind(not_taken);
2003   __ profile_not_taken_branch(r0);
2004 }
2005 
2006 void TemplateTable::if_nullcmp(Condition cc)
2007 {
2008   transition(atos, vtos);
2009   // assume branch is more often taken than not (loops use backward branches)
2010   Label not_taken;
2011   if (cc == equal)
2012     __ cbnz(r0, not_taken);
2013   else
2014     __ cbz(r0, not_taken);
2015   branch(false, false);
2016   __ bind(not_taken);
2017   __ profile_not_taken_branch(r0);
2018 }
2019 
2020 void TemplateTable::if_acmp(Condition cc)
2021 {
2022   transition(atos, vtos);
2023   // assume branch is more often taken than not (loops use backward branches)
2024   Label not_taken;
2025   __ pop_ptr(r1);
2026   __ cmpoop(r1, r0);
2027   __ br(j_not(cc), not_taken);
2028   branch(false, false);
2029   __ bind(not_taken);
2030   __ profile_not_taken_branch(r0);
2031 }
2032 
2033 void TemplateTable::ret() {
2034   transition(vtos, vtos);
2035   // We might be moving to a safepoint.  The thread which calls
2036   // Interpreter::notice_safepoints() will effectively flush its cache
2037   // when it makes a system call, but we need to do something to
2038   // ensure that we see the changed dispatch table.
2039   __ membar(MacroAssembler::LoadLoad);
2040 
2041   locals_index(r1);
2042   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2043   __ profile_ret(r1, r2);
2044   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2045   __ lea(rbcp, Address(rbcp, r1));
2046   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2047   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2048 }
2049 
2050 void TemplateTable::wide_ret() {
2051   transition(vtos, vtos);
2052   locals_index_wide(r1);
2053   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2054   __ profile_ret(r1, r2);
2055   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2056   __ lea(rbcp, Address(rbcp, r1));
2057   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2058   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2059 }
2060 
2061 
2062 void TemplateTable::tableswitch() {
2063   Label default_case, continue_execution;
2064   transition(itos, vtos);
2065   // align rbcp
2066   __ lea(r1, at_bcp(BytesPerInt));
2067   __ andr(r1, r1, -BytesPerInt);
2068   // load lo &amp; hi
2069   __ ldrw(r2, Address(r1, BytesPerInt));
2070   __ ldrw(r3, Address(r1, 2 * BytesPerInt));
2071   __ rev32(r2, r2);
2072   __ rev32(r3, r3);
2073   // check against lo &amp; hi
2074   __ cmpw(r0, r2);
2075   __ br(Assembler::LT, default_case);
2076   __ cmpw(r0, r3);
2077   __ br(Assembler::GT, default_case);
2078   // lookup dispatch offset
2079   __ subw(r0, r0, r2);
2080   __ lea(r3, Address(r1, r0, Address::uxtw(2)));
2081   __ ldrw(r3, Address(r3, 3 * BytesPerInt));
2082   __ profile_switch_case(r0, r1, r2);
2083   // continue execution
2084   __ bind(continue_execution);
2085   __ rev32(r3, r3);
2086   __ load_unsigned_byte(rscratch1, Address(rbcp, r3, Address::sxtw(0)));
2087   __ add(rbcp, rbcp, r3, ext::sxtw);
2088   __ dispatch_only(vtos, /*generate_poll*/true);
2089   // handle default
2090   __ bind(default_case);
2091   __ profile_switch_default(r0);
2092   __ ldrw(r3, Address(r1, 0));
2093   __ b(continue_execution);
2094 }
2095 
2096 void TemplateTable::lookupswitch() {
2097   transition(itos, itos);
2098   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2099 }
2100 
2101 void TemplateTable::fast_linearswitch() {
2102   transition(itos, vtos);
2103   Label loop_entry, loop, found, continue_execution;
2104   // bswap r0 so we can avoid bswapping the table entries
2105   __ rev32(r0, r0);
2106   // align rbcp
2107   __ lea(r19, at_bcp(BytesPerInt)); // btw: should be able to get rid of
2108                                     // this instruction (change offsets
2109                                     // below)
2110   __ andr(r19, r19, -BytesPerInt);
2111   // set counter
2112   __ ldrw(r1, Address(r19, BytesPerInt));
2113   __ rev32(r1, r1);
2114   __ b(loop_entry);
2115   // table search
2116   __ bind(loop);
2117   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2118   __ ldrw(rscratch1, Address(rscratch1, 2 * BytesPerInt));
2119   __ cmpw(r0, rscratch1);
2120   __ br(Assembler::EQ, found);
2121   __ bind(loop_entry);
2122   __ subs(r1, r1, 1);
2123   __ br(Assembler::PL, loop);
2124   // default case
2125   __ profile_switch_default(r0);
2126   __ ldrw(r3, Address(r19, 0));
2127   __ b(continue_execution);
2128   // entry found -&gt; get offset
2129   __ bind(found);
2130   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2131   __ ldrw(r3, Address(rscratch1, 3 * BytesPerInt));
2132   __ profile_switch_case(r1, r0, r19);
2133   // continue execution
2134   __ bind(continue_execution);
2135   __ rev32(r3, r3);
2136   __ add(rbcp, rbcp, r3, ext::sxtw);
2137   __ ldrb(rscratch1, Address(rbcp, 0));
2138   __ dispatch_only(vtos, /*generate_poll*/true);
2139 }
2140 
2141 void TemplateTable::fast_binaryswitch() {
2142   transition(itos, vtos);
2143   // Implementation using the following core algorithm:
2144   //
2145   // int binary_search(int key, LookupswitchPair* array, int n) {
2146   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2147   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2148   //   int i = 0;
2149   //   int j = n;
2150   //   while (i+1 &lt; j) {
2151   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2152   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2153   //     // where a stands for the array and assuming that the (inexisting)
2154   //     // element a[n] is infinitely big.
2155   //     int h = (i + j) &gt;&gt; 1;
2156   //     // i &lt; h &lt; j
2157   //     if (key &lt; array[h].fast_match()) {
2158   //       j = h;
2159   //     } else {
2160   //       i = h;
2161   //     }
2162   //   }
2163   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2164   //   // (i.e., if key is within array, i is the correct index)
2165   //   return i;
2166   // }
2167 
2168   // Register allocation
2169   const Register key   = r0; // already set (tosca)
2170   const Register array = r1;
2171   const Register i     = r2;
2172   const Register j     = r3;
2173   const Register h     = rscratch1;
2174   const Register temp  = rscratch2;
2175 
2176   // Find array start
2177   __ lea(array, at_bcp(3 * BytesPerInt)); // btw: should be able to
2178                                           // get rid of this
2179                                           // instruction (change
2180                                           // offsets below)
2181   __ andr(array, array, -BytesPerInt);
2182 
2183   // Initialize i &amp; j
2184   __ mov(i, 0);                            // i = 0;
2185   __ ldrw(j, Address(array, -BytesPerInt)); // j = length(array);
2186 
2187   // Convert j into native byteordering
2188   __ rev32(j, j);
2189 
2190   // And start
2191   Label entry;
2192   __ b(entry);
2193 
2194   // binary search loop
2195   {
2196     Label loop;
2197     __ bind(loop);
2198     // int h = (i + j) &gt;&gt; 1;
2199     __ addw(h, i, j);                           // h = i + j;
2200     __ lsrw(h, h, 1);                                   // h = (i + j) &gt;&gt; 1;
2201     // if (key &lt; array[h].fast_match()) {
2202     //   j = h;
2203     // } else {
2204     //   i = h;
2205     // }
2206     // Convert array[h].match to native byte-ordering before compare
2207     __ ldr(temp, Address(array, h, Address::lsl(3)));
2208     __ rev32(temp, temp);
2209     __ cmpw(key, temp);
2210     // j = h if (key &lt;  array[h].fast_match())
2211     __ csel(j, h, j, Assembler::LT);
2212     // i = h if (key &gt;= array[h].fast_match())
2213     __ csel(i, h, i, Assembler::GE);
2214     // while (i+1 &lt; j)
2215     __ bind(entry);
2216     __ addw(h, i, 1);          // i+1
2217     __ cmpw(h, j);             // i+1 &lt; j
2218     __ br(Assembler::LT, loop);
2219   }
2220 
2221   // end of binary search, result index is i (must check again!)
2222   Label default_case;
2223   // Convert array[i].match to native byte-ordering before compare
2224   __ ldr(temp, Address(array, i, Address::lsl(3)));
2225   __ rev32(temp, temp);
2226   __ cmpw(key, temp);
2227   __ br(Assembler::NE, default_case);
2228 
2229   // entry found -&gt; j = offset
2230   __ add(j, array, i, ext::uxtx, 3);
2231   __ ldrw(j, Address(j, BytesPerInt));
2232   __ profile_switch_case(i, key, array);
2233   __ rev32(j, j);
2234   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2235   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2236   __ dispatch_only(vtos, /*generate_poll*/true);
2237 
2238   // default case -&gt; j = default offset
2239   __ bind(default_case);
2240   __ profile_switch_default(i);
2241   __ ldrw(j, Address(array, -2 * BytesPerInt));
2242   __ rev32(j, j);
2243   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2244   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2245   __ dispatch_only(vtos, /*generate_poll*/true);
2246 }
2247 
2248 
2249 void TemplateTable::_return(TosState state)
2250 {
2251   transition(state, state);
2252   assert(_desc-&gt;calls_vm(),
2253          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2254 
2255   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2256     assert(state == vtos, &quot;only valid state&quot;);
2257 
2258     __ ldr(c_rarg1, aaddress(0));
2259     __ load_klass(r3, c_rarg1);
2260     __ ldrw(r3, Address(r3, Klass::access_flags_offset()));
2261     Label skip_register_finalizer;
2262     __ tbz(r3, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);
2263 
2264     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), c_rarg1);
2265 
2266     __ bind(skip_register_finalizer);
2267   }
2268 
2269   // Issue a StoreStore barrier after all stores but before return
2270   // from any constructor for any class with a final field.  We don&#39;t
2271   // know if this is a finalizer, so we always do so.
2272   if (_desc-&gt;bytecode() == Bytecodes::_return)
2273     __ membar(MacroAssembler::StoreStore);
2274 
2275   // Narrow result if state is itos but result type is smaller.
2276   // Need to narrow in the return bytecode rather than in generate_return_entry
2277   // since compiled code callers expect the result to already be narrowed.
2278   if (state == itos) {
2279     __ narrow(r0);
2280   }
2281 
2282   __ remove_activation(state);
2283   __ ret(lr);
2284 }
2285 
2286 // ----------------------------------------------------------------------------
2287 // Volatile variables demand their effects be made known to all CPU&#39;s
2288 // in order.  Store buffers on most chips allow reads &amp; writes to
2289 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2290 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2291 // the interpreter does not reorder volatile references, the hardware
2292 // also must not reorder them).
2293 //
2294 // According to the new Java Memory Model (JMM):
2295 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2296 //     writes act as aquire &amp; release, so:
2297 // (2) A read cannot let unrelated NON-volatile memory refs that
2298 //     happen after the read float up to before the read.  It&#39;s OK for
2299 //     non-volatile memory refs that happen before the volatile read to
2300 //     float down below it.
2301 // (3) Similar a volatile write cannot let unrelated NON-volatile
2302 //     memory refs that happen BEFORE the write float down to after the
2303 //     write.  It&#39;s OK for non-volatile memory refs that happen after the
2304 //     volatile write to float up before it.
2305 //
2306 // We only put in barriers around volatile refs (they are expensive),
2307 // not _between_ memory refs (that would require us to track the
2308 // flavor of the previous memory refs).  Requirements (2) and (3)
2309 // require some barriers before volatile stores and after volatile
2310 // loads.  These nearly cover requirement (1) but miss the
2311 // volatile-store-volatile-load case.  This final case is placed after
2312 // volatile-stores although it could just as well go before
2313 // volatile-loads.
2314 
2315 void TemplateTable::resolve_cache_and_index(int byte_no,
2316                                             Register Rcache,
2317                                             Register index,
2318                                             size_t index_size) {
2319   const Register temp = r19;
2320   assert_different_registers(Rcache, index, temp);
2321 
2322   Label resolved, clinit_barrier_slow;
2323 
2324   Bytecodes::Code code = bytecode();
2325   switch (code) {
2326   case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2327   case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2328   default: break;
2329   }
2330 
2331   assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2332   __ get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, 1, index_size);
2333   __ subs(zr, temp, (int) code);  // have we resolved this bytecode?
2334   __ br(Assembler::EQ, resolved);
2335 
2336   // resolve first time through
2337   // Class initialization barrier slow path lands here as well.
2338   __ bind(clinit_barrier_slow);
2339   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2340   __ mov(temp, (int) code);
2341   __ call_VM(noreg, entry, temp);
2342 
2343   // Update registers with resolved info
2344   __ get_cache_and_index_at_bcp(Rcache, index, 1, index_size);
2345   // n.b. unlike x86 Rcache is now rcpool plus the indexed offset
2346   // so all clients ofthis method must be modified accordingly
2347   __ bind(resolved);
2348 
2349   // Class initialization barrier for static methods
2350   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2351     __ load_resolved_method_at_index(byte_no, temp, Rcache);
2352     __ load_method_holder(temp, temp);
2353     __ clinit_barrier(temp, rscratch1, NULL, &amp;clinit_barrier_slow);
2354   }
2355 }
2356 
2357 // The Rcache and index registers must be set before call
2358 // n.b unlike x86 cache already includes the index offset
2359 void TemplateTable::load_field_cp_cache_entry(Register obj,
2360                                               Register cache,
2361                                               Register index,
2362                                               Register off,
2363                                               Register flags,
2364                                               bool is_static = false) {
2365   assert_different_registers(cache, index, flags, off);
2366 
2367   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2368   // Field offset
2369   __ ldr(off, Address(cache, in_bytes(cp_base_offset +
2370                                           ConstantPoolCacheEntry::f2_offset())));
2371   // Flags
2372   __ ldrw(flags, Address(cache, in_bytes(cp_base_offset +
2373                                            ConstantPoolCacheEntry::flags_offset())));
2374 
2375   // klass overwrite register
2376   if (is_static) {
2377     __ ldr(obj, Address(cache, in_bytes(cp_base_offset +
2378                                         ConstantPoolCacheEntry::f1_offset())));
2379     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
2380     __ ldr(obj, Address(obj, mirror_offset));
2381     __ resolve_oop_handle(obj);
2382   }
2383 }
2384 
2385 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2386                                                Register method,
2387                                                Register itable_index,
2388                                                Register flags,
2389                                                bool is_invokevirtual,
2390                                                bool is_invokevfinal, /*unused*/
2391                                                bool is_invokedynamic) {
2392   // setup registers
2393   const Register cache = rscratch2;
2394   const Register index = r4;
2395   assert_different_registers(method, flags);
2396   assert_different_registers(method, cache, index);
2397   assert_different_registers(itable_index, flags);
2398   assert_different_registers(itable_index, cache, index);
2399   // determine constant pool cache field offsets
2400   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2401   const int method_offset = in_bytes(
2402     ConstantPoolCache::base_offset() +
2403       (is_invokevirtual
2404        ? ConstantPoolCacheEntry::f2_offset()
2405        : ConstantPoolCacheEntry::f1_offset()));
2406   const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +
2407                                     ConstantPoolCacheEntry::flags_offset());
2408   // access constant pool cache fields
2409   const int index_offset = in_bytes(ConstantPoolCache::base_offset() +
2410                                     ConstantPoolCacheEntry::f2_offset());
2411 
2412   size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));
2413   resolve_cache_and_index(byte_no, cache, index, index_size);
2414   __ ldr(method, Address(cache, method_offset));
2415 
2416   if (itable_index != noreg) {
2417     __ ldr(itable_index, Address(cache, index_offset));
2418   }
2419   __ ldrw(flags, Address(cache, flags_offset));
2420 }
2421 
2422 
2423 // The registers cache and index expected to be set before call.
2424 // Correct values of the cache and index registers are preserved.
2425 void TemplateTable::jvmti_post_field_access(Register cache, Register index,
2426                                             bool is_static, bool has_tos) {
2427   // do the JVMTI work here to avoid disturbing the register state below
2428   // We use c_rarg registers here because we want to use the register used in
2429   // the call to the VM
2430   if (JvmtiExport::can_post_field_access()) {
2431     // Check to see if a field access watch has been set before we
2432     // take the time to call into the VM.
2433     Label L1;
2434     assert_different_registers(cache, index, r0);
2435     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
2436     __ ldrw(r0, Address(rscratch1));
2437     __ cbzw(r0, L1);
2438 
2439     __ get_cache_and_index_at_bcp(c_rarg2, c_rarg3, 1);
2440     __ lea(c_rarg2, Address(c_rarg2, in_bytes(ConstantPoolCache::base_offset())));
2441 
2442     if (is_static) {
2443       __ mov(c_rarg1, zr); // NULL object reference
2444     } else {
2445       __ ldr(c_rarg1, at_tos()); // get object pointer without popping it
2446       __ verify_oop(c_rarg1);
2447     }
2448     // c_rarg1: object pointer or NULL
2449     // c_rarg2: cache entry pointer
2450     // c_rarg3: jvalue object on the stack
2451     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2452                                        InterpreterRuntime::post_field_access),
2453                c_rarg1, c_rarg2, c_rarg3);
2454     __ get_cache_and_index_at_bcp(cache, index, 1);
2455     __ bind(L1);
2456   }
2457 }
2458 
2459 void TemplateTable::pop_and_check_object(Register r)
2460 {
2461   __ pop_ptr(r);
2462   __ null_check(r);  // for field access must check obj.
2463   __ verify_oop(r);
2464 }
2465 
2466 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc)
2467 {
2468   const Register cache = r2;
2469   const Register index = r3;
2470   const Register obj   = r4;
2471   const Register off   = r19;
2472   const Register flags = r0;
2473   const Register raw_flags = r6;
2474   const Register bc    = r4; // uses same reg as obj, so don&#39;t mix them
2475 
2476   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2477   jvmti_post_field_access(cache, index, is_static, false);
2478   load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);
2479 
2480   if (!is_static) {
2481     // obj is on the stack
2482     pop_and_check_object(obj);
2483   }
2484 
2485   // 8179954: We need to make sure that the code generated for
2486   // volatile accesses forms a sequentially-consistent set of
2487   // operations when combined with STLR and LDAR.  Without a leading
2488   // membar it&#39;s possible for a simple Dekker test to fail if loads
2489   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
2490   // the stores in one method and we interpret the loads in another.
2491   if (!is_c1_or_interpreter_only()){
2492     Label notVolatile;
2493     __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2494     __ membar(MacroAssembler::AnyAny);
2495     __ bind(notVolatile);
2496   }
2497 
2498   const Address field(obj, off);
2499 
2500   Label Done, notByte, notBool, notInt, notShort, notChar,
2501               notLong, notFloat, notObj, notDouble;
2502 
2503   // x86 uses a shift and mask or wings it with a shift plus assert
2504   // the mask is not needed. aarch64 just uses bitfield extract
2505   __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,
2506            ConstantPoolCacheEntry::tos_state_bits);
2507 
2508   assert(btos == 0, &quot;change code, btos != 0&quot;);
2509   __ cbnz(flags, notByte);
2510 
2511   // Don&#39;t rewrite getstatic, only getfield
2512   if (is_static) rc = may_not_rewrite;
2513 
2514   // btos
2515   __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
2516   __ push(btos);
2517   // Rewrite bytecode to be faster
2518   if (rc == may_rewrite) {
2519     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2520   }
2521   __ b(Done);
2522 
2523   __ bind(notByte);
2524   __ cmp(flags, (u1)ztos);
2525   __ br(Assembler::NE, notBool);
2526 
2527   // ztos (same code as btos)
2528   __ access_load_at(T_BOOLEAN, IN_HEAP, r0, field, noreg, noreg);
2529   __ push(ztos);
2530   // Rewrite bytecode to be faster
2531   if (rc == may_rewrite) {
2532     // use btos rewriting, no truncating to t/f bit is needed for getfield.
2533     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2534   }
2535   __ b(Done);
2536 
2537   __ bind(notBool);
2538   __ cmp(flags, (u1)atos);
2539   __ br(Assembler::NE, notObj);
2540   // atos
2541   do_oop_load(_masm, field, r0, IN_HEAP);
2542   __ push(atos);
2543   if (rc == may_rewrite) {
2544     patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2545   }
2546   __ b(Done);
2547 
2548   __ bind(notObj);
2549   __ cmp(flags, (u1)itos);
2550   __ br(Assembler::NE, notInt);
2551   // itos
2552   __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
2553   __ push(itos);
2554   // Rewrite bytecode to be faster
2555   if (rc == may_rewrite) {
2556     patch_bytecode(Bytecodes::_fast_igetfield, bc, r1);
2557   }
2558   __ b(Done);
2559 
2560   __ bind(notInt);
2561   __ cmp(flags, (u1)ctos);
2562   __ br(Assembler::NE, notChar);
2563   // ctos
2564   __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
2565   __ push(ctos);
2566   // Rewrite bytecode to be faster
2567   if (rc == may_rewrite) {
2568     patch_bytecode(Bytecodes::_fast_cgetfield, bc, r1);
2569   }
2570   __ b(Done);
2571 
2572   __ bind(notChar);
2573   __ cmp(flags, (u1)stos);
2574   __ br(Assembler::NE, notShort);
2575   // stos
2576   __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
2577   __ push(stos);
2578   // Rewrite bytecode to be faster
2579   if (rc == may_rewrite) {
2580     patch_bytecode(Bytecodes::_fast_sgetfield, bc, r1);
2581   }
2582   __ b(Done);
2583 
2584   __ bind(notShort);
2585   __ cmp(flags, (u1)ltos);
2586   __ br(Assembler::NE, notLong);
2587   // ltos
2588   __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
2589   __ push(ltos);
2590   // Rewrite bytecode to be faster
2591   if (rc == may_rewrite) {
2592     patch_bytecode(Bytecodes::_fast_lgetfield, bc, r1);
2593   }
2594   __ b(Done);
2595 
2596   __ bind(notLong);
2597   __ cmp(flags, (u1)ftos);
2598   __ br(Assembler::NE, notFloat);
2599   // ftos
2600   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2601   __ push(ftos);
2602   // Rewrite bytecode to be faster
2603   if (rc == may_rewrite) {
2604     patch_bytecode(Bytecodes::_fast_fgetfield, bc, r1);
2605   }
2606   __ b(Done);
2607 
2608   __ bind(notFloat);
2609 #ifdef ASSERT
2610   __ cmp(flags, (u1)dtos);
2611   __ br(Assembler::NE, notDouble);
2612 #endif
2613   // dtos
2614   __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2615   __ push(dtos);
2616   // Rewrite bytecode to be faster
2617   if (rc == may_rewrite) {
2618     patch_bytecode(Bytecodes::_fast_dgetfield, bc, r1);
2619   }
2620 #ifdef ASSERT
2621   __ b(Done);
2622 
2623   __ bind(notDouble);
2624   __ stop(&quot;Bad state&quot;);
2625 #endif
2626 
2627   __ bind(Done);
2628 
2629   Label notVolatile;
2630   __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2631   __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
2632   __ bind(notVolatile);
2633 }
2634 
2635 
2636 void TemplateTable::getfield(int byte_no)
2637 {
2638   getfield_or_static(byte_no, false);
2639 }
2640 
2641 void TemplateTable::nofast_getfield(int byte_no) {
2642   getfield_or_static(byte_no, false, may_not_rewrite);
2643 }
2644 
2645 void TemplateTable::getstatic(int byte_no)
2646 {
2647   getfield_or_static(byte_no, true);
2648 }
2649 
2650 // The registers cache and index expected to be set before call.
2651 // The function may destroy various registers, just not the cache and index registers.
2652 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
2653   transition(vtos, vtos);
2654 
2655   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2656 
2657   if (JvmtiExport::can_post_field_modification()) {
2658     // Check to see if a field modification watch has been set before
2659     // we take the time to call into the VM.
2660     Label L1;
2661     assert_different_registers(cache, index, r0);
2662     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
2663     __ ldrw(r0, Address(rscratch1));
2664     __ cbz(r0, L1);
2665 
2666     __ get_cache_and_index_at_bcp(c_rarg2, rscratch1, 1);
2667 
2668     if (is_static) {
2669       // Life is simple.  Null out the object pointer.
2670       __ mov(c_rarg1, zr);
2671     } else {
2672       // Life is harder. The stack holds the value on top, followed by
2673       // the object.  We don&#39;t know the size of the value, though; it
2674       // could be one or two words depending on its type. As a result,
2675       // we must find the type to determine where the object is.
2676       __ ldrw(c_rarg3, Address(c_rarg2,
2677                                in_bytes(cp_base_offset +
2678                                         ConstantPoolCacheEntry::flags_offset())));
2679       __ lsr(c_rarg3, c_rarg3,
2680              ConstantPoolCacheEntry::tos_state_shift);
2681       ConstantPoolCacheEntry::verify_tos_state_shift();
2682       Label nope2, done, ok;
2683       __ ldr(c_rarg1, at_tos_p1());  // initially assume a one word jvalue
2684       __ cmpw(c_rarg3, ltos);
2685       __ br(Assembler::EQ, ok);
2686       __ cmpw(c_rarg3, dtos);
2687       __ br(Assembler::NE, nope2);
2688       __ bind(ok);
2689       __ ldr(c_rarg1, at_tos_p2()); // ltos (two word jvalue)
2690       __ bind(nope2);
2691     }
2692     // cache entry pointer
2693     __ add(c_rarg2, c_rarg2, in_bytes(cp_base_offset));
2694     // object (tos)
2695     __ mov(c_rarg3, esp);
2696     // c_rarg1: object pointer set up above (NULL if static)
2697     // c_rarg2: cache entry pointer
2698     // c_rarg3: jvalue object on the stack
2699     __ call_VM(noreg,
2700                CAST_FROM_FN_PTR(address,
2701                                 InterpreterRuntime::post_field_modification),
2702                c_rarg1, c_rarg2, c_rarg3);
2703     __ get_cache_and_index_at_bcp(cache, index, 1);
2704     __ bind(L1);
2705   }
2706 }
2707 
2708 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2709   transition(vtos, vtos);
2710 
2711   const Register cache = r2;
2712   const Register index = r3;
2713   const Register obj   = r2;
2714   const Register off   = r19;
2715   const Register flags = r0;
2716   const Register bc    = r4;
2717 
2718   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2719   jvmti_post_field_mod(cache, index, is_static);
2720   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2721 
2722   Label Done;
2723   __ mov(r5, flags);
2724 
2725   {
2726     Label notVolatile;
2727     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2728     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
2729     __ bind(notVolatile);
2730   }
2731 
2732   // field address
2733   const Address field(obj, off);
2734 
2735   Label notByte, notBool, notInt, notShort, notChar,
2736         notLong, notFloat, notObj, notDouble;
2737 
2738   // x86 uses a shift and mask or wings it with a shift plus assert
2739   // the mask is not needed. aarch64 just uses bitfield extract
2740   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
2741 
2742   assert(btos == 0, &quot;change code, btos != 0&quot;);
2743   __ cbnz(flags, notByte);
2744 
2745   // Don&#39;t rewrite putstatic, only putfield
2746   if (is_static) rc = may_not_rewrite;
2747 
2748   // btos
2749   {
2750     __ pop(btos);
2751     if (!is_static) pop_and_check_object(obj);
2752     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
2753     if (rc == may_rewrite) {
2754       patch_bytecode(Bytecodes::_fast_bputfield, bc, r1, true, byte_no);
2755     }
2756     __ b(Done);
2757   }
2758 
2759   __ bind(notByte);
2760   __ cmp(flags, (u1)ztos);
2761   __ br(Assembler::NE, notBool);
2762 
2763   // ztos
2764   {
2765     __ pop(ztos);
2766     if (!is_static) pop_and_check_object(obj);
2767     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
2768     if (rc == may_rewrite) {
2769       patch_bytecode(Bytecodes::_fast_zputfield, bc, r1, true, byte_no);
2770     }
2771     __ b(Done);
2772   }
2773 
2774   __ bind(notBool);
2775   __ cmp(flags, (u1)atos);
2776   __ br(Assembler::NE, notObj);
2777 
2778   // atos
2779   {
2780     __ pop(atos);
2781     if (!is_static) pop_and_check_object(obj);
2782     // Store into the field
2783     do_oop_store(_masm, field, r0, IN_HEAP);
2784     if (rc == may_rewrite) {
2785       patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);
2786     }
2787     __ b(Done);
2788   }
2789 
2790   __ bind(notObj);
2791   __ cmp(flags, (u1)itos);
2792   __ br(Assembler::NE, notInt);
2793 
2794   // itos
2795   {
2796     __ pop(itos);
2797     if (!is_static) pop_and_check_object(obj);
2798     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
2799     if (rc == may_rewrite) {
2800       patch_bytecode(Bytecodes::_fast_iputfield, bc, r1, true, byte_no);
2801     }
2802     __ b(Done);
2803   }
2804 
2805   __ bind(notInt);
2806   __ cmp(flags, (u1)ctos);
2807   __ br(Assembler::NE, notChar);
2808 
2809   // ctos
2810   {
2811     __ pop(ctos);
2812     if (!is_static) pop_and_check_object(obj);
2813     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
2814     if (rc == may_rewrite) {
2815       patch_bytecode(Bytecodes::_fast_cputfield, bc, r1, true, byte_no);
2816     }
2817     __ b(Done);
2818   }
2819 
2820   __ bind(notChar);
2821   __ cmp(flags, (u1)stos);
2822   __ br(Assembler::NE, notShort);
2823 
2824   // stos
2825   {
2826     __ pop(stos);
2827     if (!is_static) pop_and_check_object(obj);
2828     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
2829     if (rc == may_rewrite) {
2830       patch_bytecode(Bytecodes::_fast_sputfield, bc, r1, true, byte_no);
2831     }
2832     __ b(Done);
2833   }
2834 
2835   __ bind(notShort);
2836   __ cmp(flags, (u1)ltos);
2837   __ br(Assembler::NE, notLong);
2838 
2839   // ltos
2840   {
2841     __ pop(ltos);
2842     if (!is_static) pop_and_check_object(obj);
2843     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
2844     if (rc == may_rewrite) {
2845       patch_bytecode(Bytecodes::_fast_lputfield, bc, r1, true, byte_no);
2846     }
2847     __ b(Done);
2848   }
2849 
2850   __ bind(notLong);
2851   __ cmp(flags, (u1)ftos);
2852   __ br(Assembler::NE, notFloat);
2853 
2854   // ftos
2855   {
2856     __ pop(ftos);
2857     if (!is_static) pop_and_check_object(obj);
2858     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
2859     if (rc == may_rewrite) {
2860       patch_bytecode(Bytecodes::_fast_fputfield, bc, r1, true, byte_no);
2861     }
2862     __ b(Done);
2863   }
2864 
2865   __ bind(notFloat);
2866 #ifdef ASSERT
2867   __ cmp(flags, (u1)dtos);
2868   __ br(Assembler::NE, notDouble);
2869 #endif
2870 
2871   // dtos
2872   {
2873     __ pop(dtos);
2874     if (!is_static) pop_and_check_object(obj);
2875     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
2876     if (rc == may_rewrite) {
2877       patch_bytecode(Bytecodes::_fast_dputfield, bc, r1, true, byte_no);
2878     }
2879   }
2880 
2881 #ifdef ASSERT
2882   __ b(Done);
2883 
2884   __ bind(notDouble);
2885   __ stop(&quot;Bad state&quot;);
2886 #endif
2887 
2888   __ bind(Done);
2889 
2890   {
2891     Label notVolatile;
2892     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2893     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
2894     __ bind(notVolatile);
2895   }
2896 }
2897 
2898 void TemplateTable::putfield(int byte_no)
2899 {
2900   putfield_or_static(byte_no, false);
2901 }
2902 
2903 void TemplateTable::nofast_putfield(int byte_no) {
2904   putfield_or_static(byte_no, false, may_not_rewrite);
2905 }
2906 
2907 void TemplateTable::putstatic(int byte_no) {
2908   putfield_or_static(byte_no, true);
2909 }
2910 
2911 void TemplateTable::jvmti_post_fast_field_mod()
2912 {
2913   if (JvmtiExport::can_post_field_modification()) {
2914     // Check to see if a field modification watch has been set before
2915     // we take the time to call into the VM.
2916     Label L2;
2917     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
2918     __ ldrw(c_rarg3, Address(rscratch1));
2919     __ cbzw(c_rarg3, L2);
2920     __ pop_ptr(r19);                  // copy the object pointer from tos
2921     __ verify_oop(r19);
2922     __ push_ptr(r19);                 // put the object pointer back on tos
2923     // Save tos values before call_VM() clobbers them. Since we have
2924     // to do it for every data type, we use the saved values as the
2925     // jvalue object.
2926     switch (bytecode()) {          // load values into the jvalue object
2927     case Bytecodes::_fast_aputfield: __ push_ptr(r0); break;
2928     case Bytecodes::_fast_bputfield: // fall through
2929     case Bytecodes::_fast_zputfield: // fall through
2930     case Bytecodes::_fast_sputfield: // fall through
2931     case Bytecodes::_fast_cputfield: // fall through
2932     case Bytecodes::_fast_iputfield: __ push_i(r0); break;
2933     case Bytecodes::_fast_dputfield: __ push_d(); break;
2934     case Bytecodes::_fast_fputfield: __ push_f(); break;
2935     case Bytecodes::_fast_lputfield: __ push_l(r0); break;
2936 
2937     default:
2938       ShouldNotReachHere();
2939     }
2940     __ mov(c_rarg3, esp);             // points to jvalue on the stack
2941     // access constant pool cache entry
2942     __ get_cache_entry_pointer_at_bcp(c_rarg2, r0, 1);
2943     __ verify_oop(r19);
2944     // r19: object pointer copied above
2945     // c_rarg2: cache entry pointer
2946     // c_rarg3: jvalue object on the stack
2947     __ call_VM(noreg,
2948                CAST_FROM_FN_PTR(address,
2949                                 InterpreterRuntime::post_field_modification),
2950                r19, c_rarg2, c_rarg3);
2951 
2952     switch (bytecode()) {             // restore tos values
2953     case Bytecodes::_fast_aputfield: __ pop_ptr(r0); break;
2954     case Bytecodes::_fast_bputfield: // fall through
2955     case Bytecodes::_fast_zputfield: // fall through
2956     case Bytecodes::_fast_sputfield: // fall through
2957     case Bytecodes::_fast_cputfield: // fall through
2958     case Bytecodes::_fast_iputfield: __ pop_i(r0); break;
2959     case Bytecodes::_fast_dputfield: __ pop_d(); break;
2960     case Bytecodes::_fast_fputfield: __ pop_f(); break;
2961     case Bytecodes::_fast_lputfield: __ pop_l(r0); break;
2962     default: break;
2963     }
2964     __ bind(L2);
2965   }
2966 }
2967 
2968 void TemplateTable::fast_storefield(TosState state)
2969 {
2970   transition(state, vtos);
2971 
2972   ByteSize base = ConstantPoolCache::base_offset();
2973 
2974   jvmti_post_fast_field_mod();
2975 
2976   // access constant pool cache
2977   __ get_cache_and_index_at_bcp(r2, r1, 1);
2978 
2979   // Must prevent reordering of the following cp cache loads with bytecode load
2980   __ membar(MacroAssembler::LoadLoad);
2981 
2982   // test for volatile with r3
2983   __ ldrw(r3, Address(r2, in_bytes(base +
2984                                    ConstantPoolCacheEntry::flags_offset())));
2985 
2986   // replace index with field offset from cache entry
2987   __ ldr(r1, Address(r2, in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
2988 
2989   {
2990     Label notVolatile;
2991     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2992     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
2993     __ bind(notVolatile);
2994   }
2995 
2996   Label notVolatile;
2997 
2998   // Get object from stack
2999   pop_and_check_object(r2);
3000 
3001   // field address
3002   const Address field(r2, r1);
3003 
3004   // access field
3005   switch (bytecode()) {
3006   case Bytecodes::_fast_aputfield:
3007     do_oop_store(_masm, field, r0, IN_HEAP);
3008     break;
3009   case Bytecodes::_fast_lputfield:
3010     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
3011     break;
3012   case Bytecodes::_fast_iputfield:
3013     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
3014     break;
3015   case Bytecodes::_fast_zputfield:
3016     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
3017     break;
3018   case Bytecodes::_fast_bputfield:
3019     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
3020     break;
3021   case Bytecodes::_fast_sputfield:
3022     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
3023     break;
3024   case Bytecodes::_fast_cputfield:
3025     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
3026     break;
3027   case Bytecodes::_fast_fputfield:
3028     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3029     break;
3030   case Bytecodes::_fast_dputfield:
3031     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
3032     break;
3033   default:
3034     ShouldNotReachHere();
3035   }
3036 
3037   {
3038     Label notVolatile;
3039     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3040     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
3041     __ bind(notVolatile);
3042   }
3043 }
3044 
3045 
3046 void TemplateTable::fast_accessfield(TosState state)
3047 {
3048   transition(atos, state);
3049   // Do the JVMTI work here to avoid disturbing the register state below
3050   if (JvmtiExport::can_post_field_access()) {
3051     // Check to see if a field access watch has been set before we
3052     // take the time to call into the VM.
3053     Label L1;
3054     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
3055     __ ldrw(r2, Address(rscratch1));
3056     __ cbzw(r2, L1);
3057     // access constant pool cache entry
3058     __ get_cache_entry_pointer_at_bcp(c_rarg2, rscratch2, 1);
3059     __ verify_oop(r0);
3060     __ push_ptr(r0);  // save object pointer before call_VM() clobbers it
3061     __ mov(c_rarg1, r0);
3062     // c_rarg1: object pointer copied above
3063     // c_rarg2: cache entry pointer
3064     __ call_VM(noreg,
3065                CAST_FROM_FN_PTR(address,
3066                                 InterpreterRuntime::post_field_access),
3067                c_rarg1, c_rarg2);
3068     __ pop_ptr(r0); // restore object pointer
3069     __ bind(L1);
3070   }
3071 
3072   // access constant pool cache
3073   __ get_cache_and_index_at_bcp(r2, r1, 1);
3074 
3075   // Must prevent reordering of the following cp cache loads with bytecode load
3076   __ membar(MacroAssembler::LoadLoad);
3077 
3078   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3079                                   ConstantPoolCacheEntry::f2_offset())));
3080   __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3081                                    ConstantPoolCacheEntry::flags_offset())));
3082 
3083   // r0: object
3084   __ verify_oop(r0);
3085   __ null_check(r0);
3086   const Address field(r0, r1);
3087 
3088   // 8179954: We need to make sure that the code generated for
3089   // volatile accesses forms a sequentially-consistent set of
3090   // operations when combined with STLR and LDAR.  Without a leading
3091   // membar it&#39;s possible for a simple Dekker test to fail if loads
3092   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3093   // the stores in one method and we interpret the loads in another.
3094   if (!is_c1_or_interpreter_only()) {
3095     Label notVolatile;
3096     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3097     __ membar(MacroAssembler::AnyAny);
3098     __ bind(notVolatile);
3099   }
3100 
3101   // access field
3102   switch (bytecode()) {
3103   case Bytecodes::_fast_agetfield:
3104     do_oop_load(_masm, field, r0, IN_HEAP);
3105     __ verify_oop(r0);
3106     break;
3107   case Bytecodes::_fast_lgetfield:
3108     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3109     break;
3110   case Bytecodes::_fast_igetfield:
3111     __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
3112     break;
3113   case Bytecodes::_fast_bgetfield:
3114     __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
3115     break;
3116   case Bytecodes::_fast_sgetfield:
3117     __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
3118     break;
3119   case Bytecodes::_fast_cgetfield:
3120     __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
3121     break;
3122   case Bytecodes::_fast_fgetfield:
3123     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3124     break;
3125   case Bytecodes::_fast_dgetfield:
3126     __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* dtos */, field, noreg, noreg);
3127     break;
3128   default:
3129     ShouldNotReachHere();
3130   }
3131   {
3132     Label notVolatile;
3133     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3134     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3135     __ bind(notVolatile);
3136   }
3137 }
3138 
3139 void TemplateTable::fast_xaccess(TosState state)
3140 {
3141   transition(vtos, state);
3142 
3143   // get receiver
3144   __ ldr(r0, aaddress(0));
3145   // access constant pool cache
3146   __ get_cache_and_index_at_bcp(r2, r3, 2);
3147   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3148                                   ConstantPoolCacheEntry::f2_offset())));
3149 
3150   // 8179954: We need to make sure that the code generated for
3151   // volatile accesses forms a sequentially-consistent set of
3152   // operations when combined with STLR and LDAR.  Without a leading
3153   // membar it&#39;s possible for a simple Dekker test to fail if loads
3154   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3155   // the stores in one method and we interpret the loads in another.
3156   if (!is_c1_or_interpreter_only()) {
3157     Label notVolatile;
3158     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3159                                      ConstantPoolCacheEntry::flags_offset())));
3160     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3161     __ membar(MacroAssembler::AnyAny);
3162     __ bind(notVolatile);
3163   }
3164 
3165   // make sure exception is reported in correct bcp range (getfield is
3166   // next instruction)
3167   __ increment(rbcp);
3168   __ null_check(r0);
3169   switch (state) {
3170   case itos:
3171     __ access_load_at(T_INT, IN_HEAP, r0, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3172     break;
3173   case atos:
3174     do_oop_load(_masm, Address(r0, r1, Address::lsl(0)), r0, IN_HEAP);
3175     __ verify_oop(r0);
3176     break;
3177   case ftos:
3178     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3179     break;
3180   default:
3181     ShouldNotReachHere();
3182   }
3183 
3184   {
3185     Label notVolatile;
3186     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3187                                      ConstantPoolCacheEntry::flags_offset())));
3188     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3189     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3190     __ bind(notVolatile);
3191   }
3192 
3193   __ decrement(rbcp);
3194 }
3195 
3196 
3197 
3198 //-----------------------------------------------------------------------------
3199 // Calls
3200 
3201 void TemplateTable::count_calls(Register method, Register temp)
3202 {
3203   __ call_Unimplemented();
3204 }
3205 
3206 void TemplateTable::prepare_invoke(int byte_no,
3207                                    Register method, // linked method (or i-klass)
3208                                    Register index,  // itable index, MethodType, etc.
3209                                    Register recv,   // if caller wants to see it
3210                                    Register flags   // if caller wants to test it
3211                                    ) {
3212   // determine flags
3213   Bytecodes::Code code = bytecode();
3214   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3215   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3216   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3217   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3218   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3219   const bool load_receiver       = (recv  != noreg);
3220   const bool save_flags          = (flags != noreg);
3221   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3222   assert(save_flags    == (is_invokeinterface || is_invokevirtual), &quot;need flags for vfinal&quot;);
3223   assert(flags == noreg || flags == r3, &quot;&quot;);
3224   assert(recv  == noreg || recv  == r2, &quot;&quot;);
3225 
3226   // setup registers &amp; access constant pool cache
3227   if (recv  == noreg)  recv  = r2;
3228   if (flags == noreg)  flags = r3;
3229   assert_different_registers(method, index, recv, flags);
3230 
3231   // save &#39;interpreter return address&#39;
3232   __ save_bcp();
3233 
3234   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3235 
3236   // maybe push appendix to arguments (just before return address)
3237   if (is_invokedynamic || is_invokehandle) {
3238     Label L_no_push;
3239     __ tbz(flags, ConstantPoolCacheEntry::has_appendix_shift, L_no_push);
3240     // Push the appendix as a trailing parameter.
3241     // This must be done before we get the receiver,
3242     // since the parameter_size includes it.
3243     __ push(r19);
3244     __ mov(r19, index);
3245     __ load_resolved_reference_at_index(index, r19);
3246     __ pop(r19);
3247     __ push(index);  // push appendix (MethodType, CallSite, etc.)
3248     __ bind(L_no_push);
3249   }
3250 
3251   // load receiver if needed (note: no return address pushed yet)
3252   if (load_receiver) {
3253     __ andw(recv, flags, ConstantPoolCacheEntry::parameter_size_mask);
3254     // FIXME -- is this actually correct? looks like it should be 2
3255     // const int no_return_pc_pushed_yet = -1;  // argument slot correction before we push return address
3256     // const int receiver_is_at_end      = -1;  // back off one slot to get receiver
3257     // Address recv_addr = __ argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);
3258     // __ movptr(recv, recv_addr);
3259     __ add(rscratch1, esp, recv, ext::uxtx, 3); // FIXME: uxtb here?
3260     __ ldr(recv, Address(rscratch1, -Interpreter::expr_offset_in_bytes(1)));
3261     __ verify_oop(recv);
3262   }
3263 
3264   // compute return type
3265   // x86 uses a shift and mask or wings it with a shift plus assert
3266   // the mask is not needed. aarch64 just uses bitfield extract
3267   __ ubfxw(rscratch2, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
3268   // load return address
3269   {
3270     const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);
3271     __ mov(rscratch1, table_addr);
3272     __ ldr(lr, Address(rscratch1, rscratch2, Address::lsl(3)));
3273   }
3274 }
3275 
3276 
3277 void TemplateTable::invokevirtual_helper(Register index,
3278                                          Register recv,
3279                                          Register flags)
3280 {
3281   // Uses temporary registers r0, r3
3282   assert_different_registers(index, recv, r0, r3);
3283   // Test for an invoke of a final method
3284   Label notFinal;
3285   __ tbz(flags, ConstantPoolCacheEntry::is_vfinal_shift, notFinal);
3286 
3287   const Register method = index;  // method must be rmethod
3288   assert(method == rmethod,
<a name="1" id="anc1"></a><span class="line-modified">3289          &quot;methodOop must be rmethod for interpreter calling convention&quot;);</span>
3290 
3291   // do the call - the index is actually the method to call
3292   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
3293 
3294   // It&#39;s final, need a null check here!
3295   __ null_check(recv);
3296 
3297   // profile this call
3298   __ profile_final_call(r0);
3299   __ profile_arguments_type(r0, method, r4, true);
3300 
3301   __ jump_from_interpreted(method, r0);
3302 
3303   __ bind(notFinal);
3304 
3305   // get receiver klass
3306   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3307   __ load_klass(r0, recv);
3308 
3309   // profile this call
3310   __ profile_virtual_call(r0, rlocals, r3);
3311 
<a name="2" id="anc2"></a><span class="line-modified">3312   // get target methodOop &amp; entry point</span>
3313   __ lookup_virtual_method(r0, index, method);
3314   __ profile_arguments_type(r3, method, r4, true);
3315   // FIXME -- this looks completely redundant. is it?
3316   // __ ldr(r3, Address(method, Method::interpreter_entry_offset()));
3317   __ jump_from_interpreted(method, r3);
3318 }
3319 
3320 void TemplateTable::invokevirtual(int byte_no)
3321 {
3322   transition(vtos, vtos);
3323   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3324 
3325   prepare_invoke(byte_no, rmethod, noreg, r2, r3);
3326 
3327   // rmethod: index (actually a Method*)
3328   // r2: receiver
3329   // r3: flags
3330 
3331   invokevirtual_helper(rmethod, r2, r3);
3332 }
3333 
3334 void TemplateTable::invokespecial(int byte_no)
3335 {
3336   transition(vtos, vtos);
3337   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3338 
3339   prepare_invoke(byte_no, rmethod, noreg,  // get f1 Method*
3340                  r2);  // get receiver also for null check
3341   __ verify_oop(r2);
3342   __ null_check(r2);
3343   // do the call
3344   __ profile_call(r0);
3345   __ profile_arguments_type(r0, rmethod, rbcp, false);
3346   __ jump_from_interpreted(rmethod, r0);
3347 }
3348 
3349 void TemplateTable::invokestatic(int byte_no)
3350 {
3351   transition(vtos, vtos);
3352   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3353 
3354   prepare_invoke(byte_no, rmethod);  // get f1 Method*
3355   // do the call
3356   __ profile_call(r0);
3357   __ profile_arguments_type(r0, rmethod, r4, false);
3358   __ jump_from_interpreted(rmethod, r0);
3359 }
3360 
3361 void TemplateTable::fast_invokevfinal(int byte_no)
3362 {
3363   __ call_Unimplemented();
3364 }
3365 
3366 void TemplateTable::invokeinterface(int byte_no) {
3367   transition(vtos, vtos);
3368   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3369 
3370   prepare_invoke(byte_no, r0, rmethod,  // get f1 Klass*, f2 Method*
3371                  r2, r3); // recv, flags
3372 
3373   // r0: interface klass (from f1)
3374   // rmethod: method (from f2)
3375   // r2: receiver
3376   // r3: flags
3377 
3378   // First check for Object case, then private interface method,
3379   // then regular interface method.
3380 
3381   // Special case of invokeinterface called for virtual method of
3382   // java.lang.Object.  See cpCache.cpp for details.
3383   Label notObjectMethod;
3384   __ tbz(r3, ConstantPoolCacheEntry::is_forced_virtual_shift, notObjectMethod);
3385 
3386   invokevirtual_helper(rmethod, r2, r3);
3387   __ bind(notObjectMethod);
3388 
3389   Label no_such_interface;
3390 
3391   // Check for private method invocation - indicated by vfinal
3392   Label notVFinal;
3393   __ tbz(r3, ConstantPoolCacheEntry::is_vfinal_shift, notVFinal);
3394 
3395   // Get receiver klass into r3 - also a null check
3396   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3397   __ load_klass(r3, r2);
3398 
3399   Label subtype;
3400   __ check_klass_subtype(r3, r0, r4, subtype);
3401   // If we get here the typecheck failed
3402   __ b(no_such_interface);
3403   __ bind(subtype);
3404 
3405   __ profile_final_call(r0);
3406   __ profile_arguments_type(r0, rmethod, r4, true);
3407   __ jump_from_interpreted(rmethod, r0);
3408 
3409   __ bind(notVFinal);
3410 
3411   // Get receiver klass into r3 - also a null check
3412   __ restore_locals();
3413   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3414   __ load_klass(r3, r2);
3415 
3416   Label no_such_method;
3417 
3418   // Preserve method for throw_AbstractMethodErrorVerbose.
3419   __ mov(r16, rmethod);
3420   // Receiver subtype check against REFC.
3421   // Superklass in r0. Subklass in r3. Blows rscratch2, r13
3422   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3423                              r3, r0, noreg,
3424                              // outputs: scan temp. reg, scan temp. reg
3425                              rscratch2, r13,
3426                              no_such_interface,
3427                              /*return_method=*/false);
3428 
3429   // profile this call
3430   __ profile_virtual_call(r3, r13, r19);
3431 
3432   // Get declaring interface class from method, and itable index
3433 
3434   __ load_method_holder(r0, rmethod);
3435   __ ldrw(rmethod, Address(rmethod, Method::itable_index_offset()));
3436   __ subw(rmethod, rmethod, Method::itable_index_max);
3437   __ negw(rmethod, rmethod);
3438 
3439   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
3440   __ mov(rlocals, r3);
3441   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3442                              rlocals, r0, rmethod,
3443                              // outputs: method, scan temp. reg
3444                              rmethod, r13,
3445                              no_such_interface);
3446 
<a name="3" id="anc3"></a><span class="line-modified">3447   // rmethod,: methodOop to call</span>
3448   // r2: receiver
3449   // Check for abstract method error
3450   // Note: This should be done more efficiently via a throw_abstract_method_error
3451   //       interpreter entry point and a conditional jump to it in case of a null
3452   //       method.
3453   __ cbz(rmethod, no_such_method);
3454 
3455   __ profile_arguments_type(r3, rmethod, r13, true);
3456 
3457   // do the call
3458   // r2: receiver
<a name="4" id="anc4"></a><span class="line-modified">3459   // rmethod,: methodOop</span>
3460   __ jump_from_interpreted(rmethod, r3);
3461   __ should_not_reach_here();
3462 
3463   // exception handling code follows...
3464   // note: must restore interpreter registers to canonical
3465   //       state for exception handling to work correctly!
3466 
3467   __ bind(no_such_method);
3468   // throw exception
3469   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3470   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3471   // Pass arguments for generating a verbose error message.
3472   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_AbstractMethodErrorVerbose), r3, r16);
3473   // the call_VM checks for exception, so we should never return here.
3474   __ should_not_reach_here();
3475 
3476   __ bind(no_such_interface);
3477   // throw exception
3478   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3479   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3480   // Pass arguments for generating a verbose error message.
3481   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
3482                    InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose), r3, r0);
3483   // the call_VM checks for exception, so we should never return here.
3484   __ should_not_reach_here();
3485   return;
3486 }
3487 
3488 void TemplateTable::invokehandle(int byte_no) {
3489   transition(vtos, vtos);
3490   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3491 
3492   prepare_invoke(byte_no, rmethod, r0, r2);
3493   __ verify_method_ptr(r2);
3494   __ verify_oop(r2);
3495   __ null_check(r2);
3496 
3497   // FIXME: profile the LambdaForm also
3498 
3499   // r13 is safe to use here as a scratch reg because it is about to
3500   // be clobbered by jump_from_interpreted().
3501   __ profile_final_call(r13);
3502   __ profile_arguments_type(r13, rmethod, r4, true);
3503 
3504   __ jump_from_interpreted(rmethod, r0);
3505 }
3506 
3507 void TemplateTable::invokedynamic(int byte_no) {
3508   transition(vtos, vtos);
3509   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3510 
3511   prepare_invoke(byte_no, rmethod, r0);
3512 
3513   // r0: CallSite object (from cpool-&gt;resolved_references[])
3514   // rmethod: MH.linkToCallSite method (from f2)
3515 
3516   // Note:  r0_callsite is already pushed by prepare_invoke
3517 
3518   // %%% should make a type profile for any invokedynamic that takes a ref argument
3519   // profile this call
3520   __ profile_call(rbcp);
3521   __ profile_arguments_type(r3, rmethod, r13, false);
3522 
3523   __ verify_oop(r0);
3524 
3525   __ jump_from_interpreted(rmethod, r0);
3526 }
3527 
3528 
3529 //-----------------------------------------------------------------------------
3530 // Allocation
3531 
3532 void TemplateTable::_new() {
3533   transition(vtos, atos);
3534 
3535   __ get_unsigned_2_byte_index_at_bcp(r3, 1);
3536   Label slow_case;
3537   Label done;
3538   Label initialize_header;
3539   Label initialize_object; // including clearing the fields
3540 
3541   __ get_cpool_and_tags(r4, r0);
3542   // Make sure the class we&#39;re about to instantiate has been resolved.
3543   // This is done before loading InstanceKlass to be consistent with the order
3544   // how Constant Pool is updated (see ConstantPool::klass_at_put)
3545   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
3546   __ lea(rscratch1, Address(r0, r3, Address::lsl(0)));
3547   __ lea(rscratch1, Address(rscratch1, tags_offset));
3548   __ ldarb(rscratch1, rscratch1);
3549   __ cmp(rscratch1, (u1)JVM_CONSTANT_Class);
3550   __ br(Assembler::NE, slow_case);
3551 
3552   // get InstanceKlass
3553   __ load_resolved_klass_at_offset(r4, r3, r4, rscratch1);
3554 
3555   // make sure klass is initialized &amp; doesn&#39;t have finalizer
3556   // make sure klass is fully initialized
3557   __ ldrb(rscratch1, Address(r4, InstanceKlass::init_state_offset()));
3558   __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);
3559   __ br(Assembler::NE, slow_case);
3560 
3561   // get instance_size in InstanceKlass (scaled to a count of bytes)
3562   __ ldrw(r3,
3563           Address(r4,
3564                   Klass::layout_helper_offset()));
3565   // test to see if it has a finalizer or is malformed in some way
3566   __ tbnz(r3, exact_log2(Klass::_lh_instance_slow_path_bit), slow_case);
3567 
3568   // Allocate the instance:
3569   //  If TLAB is enabled:
3570   //    Try to allocate in the TLAB.
3571   //    If fails, go to the slow path.
3572   //  Else If inline contiguous allocations are enabled:
3573   //    Try to allocate in eden.
3574   //    If fails due to heap end, go to slow path.
3575   //
3576   //  If TLAB is enabled OR inline contiguous is enabled:
3577   //    Initialize the allocation.
3578   //    Exit.
3579   //
3580   //  Go to slow path.
3581   const bool allow_shared_alloc =
3582     Universe::heap()-&gt;supports_inline_contig_alloc();
3583 
3584   if (UseTLAB) {
3585     __ tlab_allocate(r0, r3, 0, noreg, r1, slow_case);
3586 
3587     if (ZeroTLAB) {
3588       // the fields have been already cleared
3589       __ b(initialize_header);
3590     } else {
3591       // initialize both the header and fields
3592       __ b(initialize_object);
3593     }
3594   } else {
3595     // Allocation in the shared Eden, if allowed.
3596     //
3597     // r3: instance size in bytes
3598     if (allow_shared_alloc) {
3599       __ eden_allocate(r0, r3, 0, r10, slow_case);
3600     }
3601   }
3602 
3603   // If UseTLAB or allow_shared_alloc are true, the object is created above and
3604   // there is an initialize need. Otherwise, skip and go to the slow path.
3605   if (UseTLAB || allow_shared_alloc) {
3606     // The object is initialized before the header.  If the object size is
3607     // zero, go directly to the header initialization.
3608     __ bind(initialize_object);
3609     __ sub(r3, r3, sizeof(oopDesc));
3610     __ cbz(r3, initialize_header);
3611 
3612     // Initialize object fields
3613     {
3614       __ add(r2, r0, sizeof(oopDesc));
3615       Label loop;
3616       __ bind(loop);
3617       __ str(zr, Address(__ post(r2, BytesPerLong)));
3618       __ sub(r3, r3, BytesPerLong);
3619       __ cbnz(r3, loop);
3620     }
3621 
3622     // initialize object header only.
3623     __ bind(initialize_header);
3624     if (UseBiasedLocking) {
3625       __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));
3626     } else {
3627       __ mov(rscratch1, (intptr_t)markWord::prototype().value());
3628     }
3629     __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));
3630     __ store_klass_gap(r0, zr);  // zero klass gap for compressed oops
3631     __ store_klass(r0, r4);      // store klass last
3632 
3633     {
3634       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false);
3635       // Trigger dtrace event for fastpath
3636       __ push(atos); // save the return value
3637       __ call_VM_leaf(
3638            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), r0);
3639       __ pop(atos); // restore the return value
3640 
3641     }
3642     __ b(done);
3643   }
3644 
3645   // slow case
3646   __ bind(slow_case);
3647   __ get_constant_pool(c_rarg1);
3648   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3649   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);
3650   __ verify_oop(r0);
3651 
3652   // continue
3653   __ bind(done);
3654   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3655   __ membar(Assembler::StoreStore);
3656 }
3657 
3658 void TemplateTable::newarray() {
3659   transition(itos, atos);
3660   __ load_unsigned_byte(c_rarg1, at_bcp(1));
3661   __ mov(c_rarg2, r0);
3662   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
3663           c_rarg1, c_rarg2);
3664   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3665   __ membar(Assembler::StoreStore);
3666 }
3667 
3668 void TemplateTable::anewarray() {
3669   transition(itos, atos);
3670   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3671   __ get_constant_pool(c_rarg1);
3672   __ mov(c_rarg3, r0);
3673   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
3674           c_rarg1, c_rarg2, c_rarg3);
3675   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3676   __ membar(Assembler::StoreStore);
3677 }
3678 
3679 void TemplateTable::arraylength() {
3680   transition(atos, itos);
3681   __ null_check(r0, arrayOopDesc::length_offset_in_bytes());
3682   __ ldrw(r0, Address(r0, arrayOopDesc::length_offset_in_bytes()));
3683 }
3684 
3685 void TemplateTable::checkcast()
3686 {
3687   transition(atos, atos);
3688   Label done, is_null, ok_is_subtype, quicked, resolved;
3689   __ cbz(r0, is_null);
3690 
3691   // Get cpool &amp; tags index
3692   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3693   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3694   // See if bytecode has already been quicked
3695   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3696   __ lea(r1, Address(rscratch1, r19));
3697   __ ldarb(r1, r1);
3698   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3699   __ br(Assembler::EQ, quicked);
3700 
3701   __ push(atos); // save receiver for result, and for GC
3702   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3703   // vm_result_2 has metadata result
3704   __ get_vm_result_2(r0, rthread);
3705   __ pop(r3); // restore receiver
3706   __ b(resolved);
3707 
3708   // Get superklass in r0 and subklass in r3
3709   __ bind(quicked);
3710   __ mov(r3, r0); // Save object in r3; r0 needed for subtype check
3711   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1); // r0 = klass
3712 
3713   __ bind(resolved);
3714   __ load_klass(r19, r3);
3715 
3716   // Generate subtype check.  Blows r2, r5.  Object in r3.
3717   // Superklass in r0.  Subklass in r19.
3718   __ gen_subtype_check(r19, ok_is_subtype);
3719 
3720   // Come here on failure
3721   __ push(r3);
3722   // object is at TOS
3723   __ b(Interpreter::_throw_ClassCastException_entry);
3724 
3725   // Come here on success
3726   __ bind(ok_is_subtype);
3727   __ mov(r0, r3); // Restore object in r3
3728 
3729   // Collect counts on whether this test sees NULLs a lot or not.
3730   if (ProfileInterpreter) {
3731     __ b(done);
3732     __ bind(is_null);
3733     __ profile_null_seen(r2);
3734   } else {
3735     __ bind(is_null);   // same as &#39;done&#39;
3736   }
3737   __ bind(done);
3738 }
3739 
3740 void TemplateTable::instanceof() {
3741   transition(atos, itos);
3742   Label done, is_null, ok_is_subtype, quicked, resolved;
3743   __ cbz(r0, is_null);
3744 
3745   // Get cpool &amp; tags index
3746   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3747   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3748   // See if bytecode has already been quicked
3749   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3750   __ lea(r1, Address(rscratch1, r19));
3751   __ ldarb(r1, r1);
3752   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3753   __ br(Assembler::EQ, quicked);
3754 
3755   __ push(atos); // save receiver for result, and for GC
3756   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3757   // vm_result_2 has metadata result
3758   __ get_vm_result_2(r0, rthread);
3759   __ pop(r3); // restore receiver
3760   __ verify_oop(r3);
3761   __ load_klass(r3, r3);
3762   __ b(resolved);
3763 
3764   // Get superklass in r0 and subklass in r3
3765   __ bind(quicked);
3766   __ load_klass(r3, r0);
3767   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1);
3768 
3769   __ bind(resolved);
3770 
3771   // Generate subtype check.  Blows r2, r5
3772   // Superklass in r0.  Subklass in r3.
3773   __ gen_subtype_check(r3, ok_is_subtype);
3774 
3775   // Come here on failure
3776   __ mov(r0, 0);
3777   __ b(done);
3778   // Come here on success
3779   __ bind(ok_is_subtype);
3780   __ mov(r0, 1);
3781 
3782   // Collect counts on whether this test sees NULLs a lot or not.
3783   if (ProfileInterpreter) {
3784     __ b(done);
3785     __ bind(is_null);
3786     __ profile_null_seen(r2);
3787   } else {
3788     __ bind(is_null);   // same as &#39;done&#39;
3789   }
3790   __ bind(done);
3791   // r0 = 0: obj == NULL or  obj is not an instanceof the specified klass
3792   // r0 = 1: obj != NULL and obj is     an instanceof the specified klass
3793 }
3794 
3795 //-----------------------------------------------------------------------------
3796 // Breakpoints
3797 void TemplateTable::_breakpoint() {
3798   // Note: We get here even if we are single stepping..
3799   // jbug inists on setting breakpoints at every bytecode
3800   // even if we are in single step mode.
3801 
3802   transition(vtos, vtos);
3803 
3804   // get the unpatched byte code
3805   __ get_method(c_rarg1);
3806   __ call_VM(noreg,
3807              CAST_FROM_FN_PTR(address,
3808                               InterpreterRuntime::get_original_bytecode_at),
3809              c_rarg1, rbcp);
3810   __ mov(r19, r0);
3811 
3812   // post the breakpoint event
3813   __ call_VM(noreg,
3814              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
3815              rmethod, rbcp);
3816 
3817   // complete the execution of original bytecode
3818   __ mov(rscratch1, r19);
3819   __ dispatch_only_normal(vtos);
3820 }
3821 
3822 //-----------------------------------------------------------------------------
3823 // Exceptions
3824 
3825 void TemplateTable::athrow() {
3826   transition(atos, vtos);
3827   __ null_check(r0);
3828   __ b(Interpreter::throw_exception_entry());
3829 }
3830 
3831 //-----------------------------------------------------------------------------
3832 // Synchronization
3833 //
3834 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
3835 //       in the assembly code structure as well
3836 //
3837 // Stack layout:
3838 //
3839 // [expressions  ] &lt;--- esp               = expression stack top
3840 // ..
3841 // [expressions  ]
3842 // [monitor entry] &lt;--- monitor block top = expression stack bot
3843 // ..
3844 // [monitor entry]
3845 // [frame data   ] &lt;--- monitor block bot
3846 // ...
3847 // [saved rbp    ] &lt;--- rbp
3848 void TemplateTable::monitorenter()
3849 {
3850   transition(atos, vtos);
3851 
3852   // check for NULL object
3853   __ null_check(r0);
3854 
3855   __ resolve(IS_NOT_NULL, r0);
3856 
3857   const Address monitor_block_top(
3858         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
3859   const Address monitor_block_bot(
3860         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
3861   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
3862 
3863   Label allocated;
3864 
3865   // initialize entry pointer
3866   __ mov(c_rarg1, zr); // points to free slot or NULL
3867 
3868   // find a free slot in the monitor block (result in c_rarg1)
3869   {
3870     Label entry, loop, exit;
3871     __ ldr(c_rarg3, monitor_block_top); // points to current entry,
3872                                         // starting with top-most entry
3873     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
3874 
3875     __ b(entry);
3876 
3877     __ bind(loop);
3878     // check if current entry is used
3879     // if not used then remember entry in c_rarg1
3880     __ ldr(rscratch1, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));
3881     __ cmp(zr, rscratch1);
3882     __ csel(c_rarg1, c_rarg3, c_rarg1, Assembler::EQ);
3883     // check if current entry is for same object
3884     __ cmp(r0, rscratch1);
3885     // if same object then stop searching
3886     __ br(Assembler::EQ, exit);
3887     // otherwise advance to next entry
3888     __ add(c_rarg3, c_rarg3, entry_size);
3889     __ bind(entry);
3890     // check if bottom reached
3891     __ cmp(c_rarg3, c_rarg2);
3892     // if not at bottom then check this entry
3893     __ br(Assembler::NE, loop);
3894     __ bind(exit);
3895   }
3896 
3897   __ cbnz(c_rarg1, allocated); // check if a slot has been found and
3898                             // if found, continue with that on
3899 
3900   // allocate one if there&#39;s no free slot
3901   {
3902     Label entry, loop;
3903     // 1. compute new pointers            // rsp: old expression stack top
3904     __ ldr(c_rarg1, monitor_block_bot);   // c_rarg1: old expression stack bottom
3905     __ sub(esp, esp, entry_size);         // move expression stack top
3906     __ sub(c_rarg1, c_rarg1, entry_size); // move expression stack bottom
3907     __ mov(c_rarg3, esp);                 // set start value for copy loop
3908     __ str(c_rarg1, monitor_block_bot);   // set new monitor block bottom
3909 
3910     __ sub(sp, sp, entry_size);           // make room for the monitor
3911 
3912     __ b(entry);
3913     // 2. move expression stack contents
3914     __ bind(loop);
3915     __ ldr(c_rarg2, Address(c_rarg3, entry_size)); // load expression stack
3916                                                    // word from old location
3917     __ str(c_rarg2, Address(c_rarg3, 0));          // and store it at new location
3918     __ add(c_rarg3, c_rarg3, wordSize);            // advance to next word
3919     __ bind(entry);
3920     __ cmp(c_rarg3, c_rarg1);        // check if bottom reached
3921     __ br(Assembler::NE, loop);      // if not at bottom then
3922                                      // copy next word
3923   }
3924 
3925   // call run-time routine
3926   // c_rarg1: points to monitor entry
3927   __ bind(allocated);
3928 
3929   // Increment bcp to point to the next bytecode, so exception
3930   // handling for async. exceptions work correctly.
3931   // The object has already been poped from the stack, so the
3932   // expression stack looks correct.
3933   __ increment(rbcp);
3934 
3935   // store object
3936   __ str(r0, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
3937   __ lock_object(c_rarg1);
3938 
3939   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
3940   __ save_bcp();  // in case of exception
3941   __ generate_stack_overflow_check(0);
3942 
3943   // The bcp has already been incremented. Just need to dispatch to
3944   // next instruction.
3945   __ dispatch_next(vtos);
3946 }
3947 
3948 
3949 void TemplateTable::monitorexit()
3950 {
3951   transition(atos, vtos);
3952 
3953   // check for NULL object
3954   __ null_check(r0);
3955 
3956   __ resolve(IS_NOT_NULL, r0);
3957 
3958   const Address monitor_block_top(
3959         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
3960   const Address monitor_block_bot(
3961         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
3962   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
3963 
3964   Label found;
3965 
3966   // find matching slot
3967   {
3968     Label entry, loop;
3969     __ ldr(c_rarg1, monitor_block_top); // points to current entry,
3970                                         // starting with top-most entry
3971     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
3972                                         // of monitor block
3973     __ b(entry);
3974 
3975     __ bind(loop);
3976     // check if current entry is for same object
3977     __ ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
3978     __ cmp(r0, rscratch1);
3979     // if same object then stop searching
3980     __ br(Assembler::EQ, found);
3981     // otherwise advance to next entry
3982     __ add(c_rarg1, c_rarg1, entry_size);
3983     __ bind(entry);
3984     // check if bottom reached
3985     __ cmp(c_rarg1, c_rarg2);
3986     // if not at bottom then check this entry
3987     __ br(Assembler::NE, loop);
3988   }
3989 
3990   // error handling. Unlocking was not block-structured
3991   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
3992                    InterpreterRuntime::throw_illegal_monitor_state_exception));
3993   __ should_not_reach_here();
3994 
3995   // call run-time routine
3996   __ bind(found);
3997   __ push_ptr(r0); // make sure object is on stack (contract with oopMaps)
3998   __ unlock_object(c_rarg1);
3999   __ pop_ptr(r0); // discard object
4000 }
4001 
4002 
4003 // Wide instructions
4004 void TemplateTable::wide()
4005 {
4006   __ load_unsigned_byte(r19, at_bcp(1));
4007   __ mov(rscratch1, (address)Interpreter::_wentry_point);
4008   __ ldr(rscratch1, Address(rscratch1, r19, Address::uxtw(3)));
4009   __ br(rscratch1);
4010 }
4011 
4012 
4013 // Multi arrays
4014 void TemplateTable::multianewarray() {
4015   transition(vtos, atos);
4016   __ load_unsigned_byte(r0, at_bcp(3)); // get number of dimensions
4017   // last dim is on top of stack; we want address of first one:
4018   // first_addr = last_addr + (ndims - 1) * wordSize
4019   __ lea(c_rarg1, Address(esp, r0, Address::uxtw(3)));
4020   __ sub(c_rarg1, c_rarg1, wordSize);
4021   call_VM(r0,
4022           CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray),
4023           c_rarg1);
4024   __ load_unsigned_byte(r1, at_bcp(3));
4025   __ lea(esp, Address(esp, r1, Address::uxtw(3)));
4026 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>