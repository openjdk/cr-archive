<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  27 #define CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  28 
  29 #include &quot;asm/assembler.hpp&quot;
  30 #include &quot;oops/compressedOops.hpp&quot;
  31 #include &quot;utilities/powerOfTwo.hpp&quot;
  32 
  33 // MacroAssembler extends Assembler by frequently used macros.
  34 //
  35 // Instructions for which a &#39;better&#39; code sequence exists depending
  36 // on arguments should also go in here.
  37 
  38 class MacroAssembler: public Assembler {
  39   friend class LIR_Assembler;
  40 
  41  public:
  42   using Assembler::mov;
  43   using Assembler::movi;
  44 
  45  protected:
  46 
  47   // Support for VM calls
  48   //
  49   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  50   // may customize this version by overriding it for its purposes (e.g., to save/restore
  51   // additional registers when doing a VM call).
  52   virtual void call_VM_leaf_base(
  53     address entry_point,               // the entry point
  54     int     number_of_arguments,        // the number of arguments to pop after the call
  55     Label *retaddr = NULL
  56   );
  57 
  58   virtual void call_VM_leaf_base(
  59     address entry_point,               // the entry point
  60     int     number_of_arguments,        // the number of arguments to pop after the call
  61     Label &amp;retaddr) {
  62     call_VM_leaf_base(entry_point, number_of_arguments, &amp;retaddr);
  63   }
  64 
  65   // This is the base routine called by the different versions of call_VM. The interpreter
  66   // may customize this version by overriding it for its purposes (e.g., to save/restore
  67   // additional registers when doing a VM call).
  68   //
  69   // If no java_thread register is specified (noreg) than rthread will be used instead. call_VM_base
  70   // returns the register which contains the thread upon return. If a thread register has been
  71   // specified, the return value will correspond to that register. If no last_java_sp is specified
  72   // (noreg) than rsp will be used instead.
  73   virtual void call_VM_base(           // returns the register containing the thread upon return
  74     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  75     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  76     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  77     address  entry_point,              // the entry point
  78     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  79     bool     check_exceptions          // whether to check for pending exceptions after return
  80   );
  81 
  82   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  83 
  84   enum KlassDecodeMode {
  85     KlassDecodeNone,
  86     KlassDecodeZero,
  87     KlassDecodeXor,
  88     KlassDecodeMovk
  89   };
  90 
  91   KlassDecodeMode klass_decode_mode();
  92 
  93  private:
  94   static KlassDecodeMode _klass_decode_mode;
  95 
  96  public:
  97   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
  98 
  99  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
 100  // The implementation is only non-empty for the InterpreterMacroAssembler,
 101  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
 102  virtual void check_and_handle_popframe(Register java_thread);
 103  virtual void check_and_handle_earlyret(Register java_thread);
 104 
 105   void safepoint_poll(Label&amp; slow_path);
 106   void safepoint_poll_acquire(Label&amp; slow_path);
 107 
 108   // Biased locking support
 109   // lock_reg and obj_reg must be loaded up with the appropriate values.
 110   // swap_reg is killed.
 111   // tmp_reg must be supplied and must not be rscratch1 or rscratch2
 112   // Optional slow case is for implementations (interpreter and C1) which branch to
 113   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 114   // Returns offset of first potentially-faulting instruction for null
 115   // check info (currently consumed only by C1). If
 116   // swap_reg_contains_mark is true then returns -1 as it is assumed
 117   // the calling code has already passed any potential faults.
 118   int biased_locking_enter(Register lock_reg, Register obj_reg,
 119                            Register swap_reg, Register tmp_reg,
 120                            bool swap_reg_contains_mark,
 121                            Label&amp; done, Label* slow_case = NULL,
 122                            BiasedLockingCounters* counters = NULL);
 123   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 124 
 125 
 126   // Helper functions for statistics gathering.
 127   // Unconditional atomic increment.
 128   void atomic_incw(Register counter_addr, Register tmp, Register tmp2);
 129   void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {
 130     lea(tmp1, counter_addr);
 131     atomic_incw(tmp1, tmp2, tmp3);
 132   }
 133   // Load Effective Address
 134   void lea(Register r, const Address &amp;a) {
 135     InstructionMark im(this);
 136     code_section()-&gt;relocate(inst_mark(), a.rspec());
 137     a.lea(this, r);
 138   }
 139 
 140   /* Sometimes we get misaligned loads and stores, usually from Unsafe
 141      accesses, and these can exceed the offset range. */
 142   Address legitimize_address(const Address &amp;a, int size, Register scratch) {
 143     if (a.getMode() == Address::base_plus_offset) {
 144       if (! Address::offset_ok_for_immed(a.offset(), exact_log2(size))) {
 145         block_comment(&quot;legitimize_address {&quot;);
 146         lea(scratch, a);
 147         block_comment(&quot;} legitimize_address&quot;);
 148         return Address(scratch);
 149       }
 150     }
 151     return a;
 152   }
 153 
 154   void addmw(Address a, Register incr, Register scratch) {
 155     ldrw(scratch, a);
 156     addw(scratch, scratch, incr);
 157     strw(scratch, a);
 158   }
 159 
 160   // Add constant to memory word
 161   void addmw(Address a, int imm, Register scratch) {
 162     ldrw(scratch, a);
 163     if (imm &gt; 0)
 164       addw(scratch, scratch, (unsigned)imm);
 165     else
 166       subw(scratch, scratch, (unsigned)-imm);
 167     strw(scratch, a);
 168   }
 169 
 170   void bind(Label&amp; L) {
 171     Assembler::bind(L);
 172     code()-&gt;clear_last_insn();
 173   }
 174 
 175   void membar(Membar_mask_bits order_constraint);
 176 
 177   using Assembler::ldr;
 178   using Assembler::str;
 179   using Assembler::ldrw;
 180   using Assembler::strw;
 181 
 182   void ldr(Register Rx, const Address &amp;adr);
 183   void ldrw(Register Rw, const Address &amp;adr);
 184   void str(Register Rx, const Address &amp;adr);
 185   void strw(Register Rx, const Address &amp;adr);
 186 
 187   // Frame creation and destruction shared between JITs.
 188   void build_frame(int framesize);
 189   void remove_frame(int framesize);
 190 
 191   virtual void _call_Unimplemented(address call_site) {
 192     mov(rscratch2, call_site);
 193   }
 194 
 195 #define call_Unimplemented() _call_Unimplemented((address)__PRETTY_FUNCTION__)
 196 
 197   // aliases defined in AARCH64 spec
 198 
 199   template&lt;class T&gt;
 200   inline void cmpw(Register Rd, T imm)  { subsw(zr, Rd, imm); }
 201 
 202   inline void cmp(Register Rd, unsigned char imm8)  { subs(zr, Rd, imm8); }
 203   inline void cmp(Register Rd, unsigned imm) __attribute__ ((deprecated));
 204 
 205   inline void cmnw(Register Rd, unsigned imm) { addsw(zr, Rd, imm); }
 206   inline void cmn(Register Rd, unsigned imm) { adds(zr, Rd, imm); }
 207 
 208   void cset(Register Rd, Assembler::Condition cond) {
 209     csinc(Rd, zr, zr, ~cond);
 210   }
 211   void csetw(Register Rd, Assembler::Condition cond) {
 212     csincw(Rd, zr, zr, ~cond);
 213   }
 214 
 215   void cneg(Register Rd, Register Rn, Assembler::Condition cond) {
 216     csneg(Rd, Rn, Rn, ~cond);
 217   }
 218   void cnegw(Register Rd, Register Rn, Assembler::Condition cond) {
 219     csnegw(Rd, Rn, Rn, ~cond);
 220   }
 221 
 222   inline void movw(Register Rd, Register Rn) {
 223     if (Rd == sp || Rn == sp) {
 224       addw(Rd, Rn, 0U);
 225     } else {
 226       orrw(Rd, zr, Rn);
 227     }
 228   }
 229   inline void mov(Register Rd, Register Rn) {
 230     assert(Rd != r31_sp &amp;&amp; Rn != r31_sp, &quot;should be&quot;);
 231     if (Rd == Rn) {
 232     } else if (Rd == sp || Rn == sp) {
 233       add(Rd, Rn, 0U);
 234     } else {
 235       orr(Rd, zr, Rn);
 236     }
 237   }
 238 
 239   inline void moviw(Register Rd, unsigned imm) { orrw(Rd, zr, imm); }
 240   inline void movi(Register Rd, unsigned imm) { orr(Rd, zr, imm); }
 241 
 242   inline void tstw(Register Rd, Register Rn) { andsw(zr, Rd, Rn); }
 243   inline void tst(Register Rd, Register Rn) { ands(zr, Rd, Rn); }
 244 
 245   inline void tstw(Register Rd, uint64_t imm) { andsw(zr, Rd, imm); }
 246   inline void tst(Register Rd, uint64_t imm) { ands(zr, Rd, imm); }
 247 
 248   inline void bfiw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 249     bfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 250   }
 251   inline void bfi(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 252     bfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 253   }
 254 
 255   inline void bfxilw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 256     bfmw(Rd, Rn, lsb, (lsb + width - 1));
 257   }
 258   inline void bfxil(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 259     bfm(Rd, Rn, lsb , (lsb + width - 1));
 260   }
 261 
 262   inline void sbfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 263     sbfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 264   }
 265   inline void sbfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 266     sbfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 267   }
 268 
 269   inline void sbfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 270     sbfmw(Rd, Rn, lsb, (lsb + width - 1));
 271   }
 272   inline void sbfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 273     sbfm(Rd, Rn, lsb , (lsb + width - 1));
 274   }
 275 
 276   inline void ubfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 277     ubfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 278   }
 279   inline void ubfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 280     ubfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 281   }
 282 
 283   inline void ubfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 284     ubfmw(Rd, Rn, lsb, (lsb + width - 1));
 285   }
 286   inline void ubfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 287     ubfm(Rd, Rn, lsb , (lsb + width - 1));
 288   }
 289 
 290   inline void asrw(Register Rd, Register Rn, unsigned imm) {
 291     sbfmw(Rd, Rn, imm, 31);
 292   }
 293 
 294   inline void asr(Register Rd, Register Rn, unsigned imm) {
 295     sbfm(Rd, Rn, imm, 63);
 296   }
 297 
 298   inline void lslw(Register Rd, Register Rn, unsigned imm) {
 299     ubfmw(Rd, Rn, ((32 - imm) &amp; 31), (31 - imm));
 300   }
 301 
 302   inline void lsl(Register Rd, Register Rn, unsigned imm) {
 303     ubfm(Rd, Rn, ((64 - imm) &amp; 63), (63 - imm));
 304   }
 305 
 306   inline void lsrw(Register Rd, Register Rn, unsigned imm) {
 307     ubfmw(Rd, Rn, imm, 31);
 308   }
 309 
 310   inline void lsr(Register Rd, Register Rn, unsigned imm) {
 311     ubfm(Rd, Rn, imm, 63);
 312   }
 313 
 314   inline void rorw(Register Rd, Register Rn, unsigned imm) {
 315     extrw(Rd, Rn, Rn, imm);
 316   }
 317 
 318   inline void ror(Register Rd, Register Rn, unsigned imm) {
 319     extr(Rd, Rn, Rn, imm);
 320   }
 321 
 322   inline void sxtbw(Register Rd, Register Rn) {
 323     sbfmw(Rd, Rn, 0, 7);
 324   }
 325   inline void sxthw(Register Rd, Register Rn) {
 326     sbfmw(Rd, Rn, 0, 15);
 327   }
 328   inline void sxtb(Register Rd, Register Rn) {
 329     sbfm(Rd, Rn, 0, 7);
 330   }
 331   inline void sxth(Register Rd, Register Rn) {
 332     sbfm(Rd, Rn, 0, 15);
 333   }
 334   inline void sxtw(Register Rd, Register Rn) {
 335     sbfm(Rd, Rn, 0, 31);
 336   }
 337 
 338   inline void uxtbw(Register Rd, Register Rn) {
 339     ubfmw(Rd, Rn, 0, 7);
 340   }
 341   inline void uxthw(Register Rd, Register Rn) {
 342     ubfmw(Rd, Rn, 0, 15);
 343   }
 344   inline void uxtb(Register Rd, Register Rn) {
 345     ubfm(Rd, Rn, 0, 7);
 346   }
 347   inline void uxth(Register Rd, Register Rn) {
 348     ubfm(Rd, Rn, 0, 15);
 349   }
 350   inline void uxtw(Register Rd, Register Rn) {
 351     ubfm(Rd, Rn, 0, 31);
 352   }
 353 
 354   inline void cmnw(Register Rn, Register Rm) {
 355     addsw(zr, Rn, Rm);
 356   }
 357   inline void cmn(Register Rn, Register Rm) {
 358     adds(zr, Rn, Rm);
 359   }
 360 
 361   inline void cmpw(Register Rn, Register Rm) {
 362     subsw(zr, Rn, Rm);
 363   }
 364   inline void cmp(Register Rn, Register Rm) {
 365     subs(zr, Rn, Rm);
 366   }
 367 
 368   inline void negw(Register Rd, Register Rn) {
 369     subw(Rd, zr, Rn);
 370   }
 371 
 372   inline void neg(Register Rd, Register Rn) {
 373     sub(Rd, zr, Rn);
 374   }
 375 
 376   inline void negsw(Register Rd, Register Rn) {
 377     subsw(Rd, zr, Rn);
 378   }
 379 
 380   inline void negs(Register Rd, Register Rn) {
 381     subs(Rd, zr, Rn);
 382   }
 383 
 384   inline void cmnw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 385     addsw(zr, Rn, Rm, kind, shift);
 386   }
 387   inline void cmn(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 388     adds(zr, Rn, Rm, kind, shift);
 389   }
 390 
 391   inline void cmpw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 392     subsw(zr, Rn, Rm, kind, shift);
 393   }
 394   inline void cmp(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 395     subs(zr, Rn, Rm, kind, shift);
 396   }
 397 
 398   inline void negw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 399     subw(Rd, zr, Rn, kind, shift);
 400   }
 401 
 402   inline void neg(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 403     sub(Rd, zr, Rn, kind, shift);
 404   }
 405 
 406   inline void negsw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 407     subsw(Rd, zr, Rn, kind, shift);
 408   }
 409 
 410   inline void negs(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 411     subs(Rd, zr, Rn, kind, shift);
 412   }
 413 
 414   inline void mnegw(Register Rd, Register Rn, Register Rm) {
 415     msubw(Rd, Rn, Rm, zr);
 416   }
 417   inline void mneg(Register Rd, Register Rn, Register Rm) {
 418     msub(Rd, Rn, Rm, zr);
 419   }
 420 
 421   inline void mulw(Register Rd, Register Rn, Register Rm) {
 422     maddw(Rd, Rn, Rm, zr);
 423   }
 424   inline void mul(Register Rd, Register Rn, Register Rm) {
 425     madd(Rd, Rn, Rm, zr);
 426   }
 427 
 428   inline void smnegl(Register Rd, Register Rn, Register Rm) {
 429     smsubl(Rd, Rn, Rm, zr);
 430   }
 431   inline void smull(Register Rd, Register Rn, Register Rm) {
 432     smaddl(Rd, Rn, Rm, zr);
 433   }
 434 
 435   inline void umnegl(Register Rd, Register Rn, Register Rm) {
 436     umsubl(Rd, Rn, Rm, zr);
 437   }
 438   inline void umull(Register Rd, Register Rn, Register Rm) {
 439     umaddl(Rd, Rn, Rm, zr);
 440   }
 441 
 442 #define WRAP(INSN)                                                            \
 443   void INSN(Register Rd, Register Rn, Register Rm, Register Ra) {             \
 444     if ((VM_Version::features() &amp; VM_Version::CPU_A53MAC) &amp;&amp; Ra != zr)        \
 445       nop();                                                                  \
 446     Assembler::INSN(Rd, Rn, Rm, Ra);                                          \
 447   }
 448 
 449   WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)
 450   WRAP(smaddl) WRAP(smsubl) WRAP(umaddl) WRAP(umsubl)
 451 #undef WRAP
 452 
 453 
 454   // macro assembly operations needed for aarch64
 455 
 456   // first two private routines for loading 32 bit or 64 bit constants
 457 private:
 458 
 459   void mov_immediate64(Register dst, uint64_t imm64);
 460   void mov_immediate32(Register dst, uint32_t imm32);
 461 
 462   int push(unsigned int bitset, Register stack);
 463   int pop(unsigned int bitset, Register stack);
 464 
 465   int push_fp(unsigned int bitset, Register stack);
 466   int pop_fp(unsigned int bitset, Register stack);
 467 
 468   void mov(Register dst, Address a);
 469 
 470 public:
 471   void push(RegSet regs, Register stack) { if (regs.bits()) push(regs.bits(), stack); }
 472   void pop(RegSet regs, Register stack) { if (regs.bits()) pop(regs.bits(), stack); }
 473 
 474   void push_fp(RegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }
 475   void pop_fp(RegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }
 476 
 477   // Push and pop everything that might be clobbered by a native
 478   // runtime call except rscratch1 and rscratch2.  (They are always
 479   // scratch, so we don&#39;t have to protect them.)  Only save the lower
 480   // 64 bits of each vector register. Additonal registers can be excluded
 481   // in a passed RegSet.
 482   void push_call_clobbered_registers_except(RegSet exclude);
 483   void pop_call_clobbered_registers_except(RegSet exclude);
 484 
 485   void push_call_clobbered_registers() {
 486     push_call_clobbered_registers_except(RegSet());
 487   }
 488   void pop_call_clobbered_registers() {
 489     pop_call_clobbered_registers_except(RegSet());
 490   }
 491 
 492 
 493   // now mov instructions for loading absolute addresses and 32 or
 494   // 64 bit integers
 495 
 496   inline void mov(Register dst, address addr)
 497   {
 498     mov_immediate64(dst, (uint64_t)addr);
 499   }
 500 
 501   inline void mov(Register dst, uint64_t imm64)
 502   {
 503     mov_immediate64(dst, imm64);
 504   }
 505 
 506   inline void movw(Register dst, uint32_t imm32)
 507   {
 508     mov_immediate32(dst, imm32);
 509   }
 510 
 511   inline void mov(Register dst, int64_t l)
 512   {
 513     mov(dst, (uint64_t)l);
 514   }
 515 
 516   inline void mov(Register dst, int i)
 517   {
 518     mov(dst, (int64_t)i);
 519   }
 520 
 521   void mov(Register dst, RegisterOrConstant src) {
 522     if (src.is_register())
 523       mov(dst, src.as_register());
 524     else
 525       mov(dst, src.as_constant());
 526   }
 527 
 528   void movptr(Register r, uintptr_t imm64);
 529 
 530   void mov(FloatRegister Vd, SIMD_Arrangement T, uint32_t imm32);
 531 
 532   void mov(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {
 533     orr(Vd, T, Vn, Vn);
 534   }
 535 
 536 public:
 537 
 538   // Generalized Test Bit And Branch, including a &quot;far&quot; variety which
 539   // spans more than 32KiB.
 540   void tbr(Condition cond, Register Rt, int bitpos, Label &amp;dest, bool far = false) {
 541     assert(cond == EQ || cond == NE, &quot;must be&quot;);
 542 
 543     if (far)
 544       cond = ~cond;
 545 
 546     void (Assembler::* branch)(Register Rt, int bitpos, Label &amp;L);
 547     if (cond == Assembler::EQ)
 548       branch = &amp;Assembler::tbz;
 549     else
 550       branch = &amp;Assembler::tbnz;
 551 
 552     if (far) {
 553       Label L;
 554       (this-&gt;*branch)(Rt, bitpos, L);
 555       b(dest);
 556       bind(L);
 557     } else {
 558       (this-&gt;*branch)(Rt, bitpos, dest);
 559     }
 560   }
 561 
 562   // macro instructions for accessing and updating floating point
 563   // status register
 564   //
 565   // FPSR : op1 == 011
 566   //        CRn == 0100
 567   //        CRm == 0100
 568   //        op2 == 001
 569 
 570   inline void get_fpsr(Register reg)
 571   {
 572     mrs(0b11, 0b0100, 0b0100, 0b001, reg);
 573   }
 574 
 575   inline void set_fpsr(Register reg)
 576   {
 577     msr(0b011, 0b0100, 0b0100, 0b001, reg);
 578   }
 579 
 580   inline void clear_fpsr()
 581   {
 582     msr(0b011, 0b0100, 0b0100, 0b001, zr);
 583   }
 584 
 585   // DCZID_EL0: op1 == 011
 586   //            CRn == 0000
 587   //            CRm == 0000
 588   //            op2 == 111
 589   inline void get_dczid_el0(Register reg)
 590   {
 591     mrs(0b011, 0b0000, 0b0000, 0b111, reg);
 592   }
 593 
 594   // CTR_EL0:   op1 == 011
 595   //            CRn == 0000
 596   //            CRm == 0000
 597   //            op2 == 001
 598   inline void get_ctr_el0(Register reg)
 599   {
 600     mrs(0b011, 0b0000, 0b0000, 0b001, reg);
 601   }
 602 
 603   // idiv variant which deals with MINLONG as dividend and -1 as divisor
 604   int corrected_idivl(Register result, Register ra, Register rb,
 605                       bool want_remainder, Register tmp = rscratch1);
 606   int corrected_idivq(Register result, Register ra, Register rb,
 607                       bool want_remainder, Register tmp = rscratch1);
 608 
 609   // Support for NULL-checks
 610   //
 611   // Generates code that causes a NULL OS exception if the content of reg is NULL.
 612   // If the accessed location is M[reg + offset] and the offset is known, provide the
 613   // offset. No explicit code generation is needed if the offset is within a certain
 614   // range (0 &lt;= offset &lt;= page_size).
 615 
 616   virtual void null_check(Register reg, int offset = -1);
 617   static bool needs_explicit_null_check(intptr_t offset);
 618   static bool uses_implicit_null_check(void* address);
 619 
 620   static address target_addr_for_insn(address insn_addr, unsigned insn);
 621   static address target_addr_for_insn(address insn_addr) {
 622     unsigned insn = *(unsigned*)insn_addr;
 623     return target_addr_for_insn(insn_addr, insn);
 624   }
 625 
 626   // Required platform-specific helpers for Label::patch_instructions.
 627   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 628   static int pd_patch_instruction_size(address branch, address target);
 629   static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {
 630     pd_patch_instruction_size(branch, target);
 631   }
 632   static address pd_call_destination(address branch) {
 633     return target_addr_for_insn(branch);
 634   }
 635 #ifndef PRODUCT
 636   static void pd_print_patched_instruction(address branch);
 637 #endif
 638 
 639   static int patch_oop(address insn_addr, address o);
 640   static int patch_narrow_klass(address insn_addr, narrowKlass n);
 641 
 642   address emit_trampoline_stub(int insts_call_instruction_offset, address target);
 643   void emit_static_call_stub();
 644 
 645   // The following 4 methods return the offset of the appropriate move instruction
 646 
 647   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 648   int load_unsigned_byte(Register dst, Address src);
 649   int load_unsigned_short(Register dst, Address src);
 650 
 651   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 652   int load_signed_byte(Register dst, Address src);
 653   int load_signed_short(Register dst, Address src);
 654 
 655   int load_signed_byte32(Register dst, Address src);
 656   int load_signed_short32(Register dst, Address src);
 657 
 658   // Support for sign-extension (hi:lo = extend_sign(lo))
 659   void extend_sign(Register hi, Register lo);
 660 
 661   // Load and store values by size and signed-ness
 662   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 663   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 664 
 665   // Support for inc/dec with optimal instruction selection depending on value
 666 
 667   // x86_64 aliases an unqualified register/address increment and
 668   // decrement to call incrementq and decrementq but also supports
 669   // explicitly sized calls to incrementq/decrementq or
 670   // incrementl/decrementl
 671 
 672   // for aarch64 the proper convention would be to use
 673   // increment/decrement for 64 bit operatons and
 674   // incrementw/decrementw for 32 bit operations. so when porting
 675   // x86_64 code we can leave calls to increment/decrement as is,
 676   // replace incrementq/decrementq with increment/decrement and
 677   // replace incrementl/decrementl with incrementw/decrementw.
 678 
 679   // n.b. increment/decrement calls with an Address destination will
 680   // need to use a scratch register to load the value to be
 681   // incremented. increment/decrement calls which add or subtract a
 682   // constant value greater than 2^12 will need to use a 2nd scratch
 683   // register to hold the constant. so, a register increment/decrement
 684   // may trash rscratch2 and an address increment/decrement trash
 685   // rscratch and rscratch2
 686 
 687   void decrementw(Address dst, int value = 1);
 688   void decrementw(Register reg, int value = 1);
 689 
 690   void decrement(Register reg, int value = 1);
 691   void decrement(Address dst, int value = 1);
 692 
 693   void incrementw(Address dst, int value = 1);
 694   void incrementw(Register reg, int value = 1);
 695 
 696   void increment(Register reg, int value = 1);
 697   void increment(Address dst, int value = 1);
 698 
 699 
 700   // Alignment
 701   void align(int modulus);
 702 
 703   // Stack frame creation/removal
 704   void enter()
 705   {
 706     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
 707     mov(rfp, sp);
 708   }
 709   void leave()
 710   {
 711     mov(sp, rfp);
 712     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
 713   }
 714 
 715   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 716   // The pointer will be loaded into the thread register.
 717   void get_thread(Register thread);
 718 
 719 
 720   // Support for VM calls
 721   //
 722   // It is imperative that all calls into the VM are handled via the call_VM macros.
 723   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 724   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 725 
 726 
 727   void call_VM(Register oop_result,
 728                address entry_point,
 729                bool check_exceptions = true);
 730   void call_VM(Register oop_result,
 731                address entry_point,
 732                Register arg_1,
 733                bool check_exceptions = true);
 734   void call_VM(Register oop_result,
 735                address entry_point,
 736                Register arg_1, Register arg_2,
 737                bool check_exceptions = true);
 738   void call_VM(Register oop_result,
 739                address entry_point,
 740                Register arg_1, Register arg_2, Register arg_3,
 741                bool check_exceptions = true);
 742 
 743   // Overloadings with last_Java_sp
 744   void call_VM(Register oop_result,
 745                Register last_java_sp,
 746                address entry_point,
 747                int number_of_arguments = 0,
 748                bool check_exceptions = true);
 749   void call_VM(Register oop_result,
 750                Register last_java_sp,
 751                address entry_point,
 752                Register arg_1, bool
 753                check_exceptions = true);
 754   void call_VM(Register oop_result,
 755                Register last_java_sp,
 756                address entry_point,
 757                Register arg_1, Register arg_2,
 758                bool check_exceptions = true);
 759   void call_VM(Register oop_result,
 760                Register last_java_sp,
 761                address entry_point,
 762                Register arg_1, Register arg_2, Register arg_3,
 763                bool check_exceptions = true);
 764 
 765   void get_vm_result  (Register oop_result, Register thread);
 766   void get_vm_result_2(Register metadata_result, Register thread);
 767 
 768   // These always tightly bind to MacroAssembler::call_VM_base
 769   // bypassing the virtual implementation
 770   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 771   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 772   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 773   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 774   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 775 
 776   void call_VM_leaf(address entry_point,
 777                     int number_of_arguments = 0);
 778   void call_VM_leaf(address entry_point,
 779                     Register arg_1);
 780   void call_VM_leaf(address entry_point,
 781                     Register arg_1, Register arg_2);
 782   void call_VM_leaf(address entry_point,
 783                     Register arg_1, Register arg_2, Register arg_3);
 784 
 785   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 786   // bypassing the virtual implementation
 787   void super_call_VM_leaf(address entry_point);
 788   void super_call_VM_leaf(address entry_point, Register arg_1);
 789   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 790   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 791   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 792 
 793   // last Java Frame (fills frame anchor)
 794   void set_last_Java_frame(Register last_java_sp,
 795                            Register last_java_fp,
 796                            address last_java_pc,
 797                            Register scratch);
 798 
 799   void set_last_Java_frame(Register last_java_sp,
 800                            Register last_java_fp,
 801                            Label &amp;last_java_pc,
 802                            Register scratch);
 803 
 804   void set_last_Java_frame(Register last_java_sp,
 805                            Register last_java_fp,
 806                            Register last_java_pc,
 807                            Register scratch);
 808 
 809   void reset_last_Java_frame(Register thread);
 810 
 811   // thread in the default location (rthread)
 812   void reset_last_Java_frame(bool clear_fp);
 813 
 814   // Stores
 815   void store_check(Register obj);                // store check for obj - register is destroyed afterwards
 816   void store_check(Register obj, Address dst);   // same as above, dst is exact store location (reg. is destroyed)
 817 
 818   void resolve_jobject(Register value, Register thread, Register tmp);
 819 
 820   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 821   void c2bool(Register x);
 822 
 823   void load_method_holder_cld(Register rresult, Register rmethod);
 824   void load_method_holder(Register holder, Register method);
 825 
 826   // oop manipulations
 827   void load_klass(Register dst, Register src);
 828   void store_klass(Register dst, Register src);
 829   void cmp_klass(Register oop, Register trial_klass, Register tmp);
 830 
 831   void resolve_weak_handle(Register result, Register tmp);
 832   void resolve_oop_handle(Register result, Register tmp = r5);
 833   void load_mirror(Register dst, Register method, Register tmp = r5);
 834 
 835   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 836                       Register tmp1, Register tmp_thread);
 837 
 838   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 839                        Register tmp1, Register tmp_thread);
 840 
 841   // Resolves obj for access. Result is placed in the same register.
 842   // All other registers are preserved.
 843   void resolve(DecoratorSet decorators, Register obj);
 844 
 845   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 846                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 847 
 848   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 849                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 850   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 851                       Register tmp_thread = noreg, DecoratorSet decorators = 0);
 852 
 853   // currently unimplemented
 854   // Used for storing NULL. All other oop constants should be
 855   // stored using routines that take a jobject.
 856   void store_heap_oop_null(Address dst);
 857 
 858   void load_prototype_header(Register dst, Register src);
 859 
 860   void store_klass_gap(Register dst, Register src);
 861 
 862   // This dummy is to prevent a call to store_heap_oop from
 863   // converting a zero (like NULL) into a Register by giving
 864   // the compiler two choices it can&#39;t resolve
 865 
 866   void store_heap_oop(Address dst, void* dummy);
 867 
 868   void encode_heap_oop(Register d, Register s);
 869   void encode_heap_oop(Register r) { encode_heap_oop(r, r); }
 870   void decode_heap_oop(Register d, Register s);
 871   void decode_heap_oop(Register r) { decode_heap_oop(r, r); }
 872   void encode_heap_oop_not_null(Register r);
 873   void decode_heap_oop_not_null(Register r);
 874   void encode_heap_oop_not_null(Register dst, Register src);
 875   void decode_heap_oop_not_null(Register dst, Register src);
 876 
 877   void set_narrow_oop(Register dst, jobject obj);
 878 
 879   void encode_klass_not_null(Register r);
 880   void decode_klass_not_null(Register r);
 881   void encode_klass_not_null(Register dst, Register src);
 882   void decode_klass_not_null(Register dst, Register src);
 883 
 884   void set_narrow_klass(Register dst, Klass* k);
 885 
 886   // if heap base register is used - reinit it with the correct value
 887   void reinit_heapbase();
 888 
 889   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 890 
 891   void push_CPU_state(bool save_vectors = false);
 892   void pop_CPU_state(bool restore_vectors = false) ;
 893 
 894   // Round up to a power of two
 895   void round_to(Register reg, int modulus);
 896 
 897   // allocation
 898   void eden_allocate(
 899     Register obj,                      // result: pointer to object after successful allocation
 900     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 901     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 902     Register t1,                       // temp register
 903     Label&amp;   slow_case                 // continuation point if fast allocation fails
 904   );
 905   void tlab_allocate(
 906     Register obj,                      // result: pointer to object after successful allocation
 907     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 908     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 909     Register t1,                       // temp register
 910     Register t2,                       // temp register
 911     Label&amp;   slow_case                 // continuation point if fast allocation fails
 912   );
 913   void zero_memory(Register addr, Register len, Register t1);
 914   void verify_tlab();
 915 
 916   // interface method calling
 917   void lookup_interface_method(Register recv_klass,
 918                                Register intf_klass,
 919                                RegisterOrConstant itable_index,
 920                                Register method_result,
 921                                Register scan_temp,
 922                                Label&amp; no_such_interface,
 923                    bool return_method = true);
 924 
 925   // virtual method calling
 926   // n.b. x86 allows RegisterOrConstant for vtable_index
 927   void lookup_virtual_method(Register recv_klass,
 928                              RegisterOrConstant vtable_index,
 929                              Register method_result);
 930 
 931   // Test sub_klass against super_klass, with fast and slow paths.
 932 
 933   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 934   // One of the three labels can be NULL, meaning take the fall-through.
 935   // If super_check_offset is -1, the value is loaded up from super_klass.
 936   // No registers are killed, except temp_reg.
 937   void check_klass_subtype_fast_path(Register sub_klass,
 938                                      Register super_klass,
 939                                      Register temp_reg,
 940                                      Label* L_success,
 941                                      Label* L_failure,
 942                                      Label* L_slow_path,
 943                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 944 
 945   // The rest of the type check; must be wired to a corresponding fast path.
 946   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 947   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 948   // Updates the sub&#39;s secondary super cache as necessary.
 949   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 950   void check_klass_subtype_slow_path(Register sub_klass,
 951                                      Register super_klass,
 952                                      Register temp_reg,
 953                                      Register temp2_reg,
 954                                      Label* L_success,
 955                                      Label* L_failure,
 956                                      bool set_cond_codes = false);
 957 
 958   // Simplified, combined version, good for typical uses.
 959   // Falls through on failure.
 960   void check_klass_subtype(Register sub_klass,
 961                            Register super_klass,
 962                            Register temp_reg,
 963                            Label&amp; L_success);
 964 
 965   void clinit_barrier(Register klass,
 966                       Register thread,
 967                       Label* L_fast_path = NULL,
 968                       Label* L_slow_path = NULL);
 969 
 970   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 971 
 972 
 973   // Debugging
 974 
 975   // only if +VerifyOops
 976   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 977   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 978 
 979 // TODO: verify method and klass metadata (compare against vptr?)
 980   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 981   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 982 
 983 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 984 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 985 
 986   // only if +VerifyFPU
 987   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 988 
 989   // prints msg, dumps registers and stops execution
 990   void stop(const char* msg);
 991 
 992   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 993 
 994   void untested()                                { stop(&quot;untested&quot;); }
 995 
 996   void unimplemented(const char* what = &quot;&quot;);
 997 
 998   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 999 
1000   // Stack overflow checking
1001   void bang_stack_with_offset(int offset) {
1002     // stack grows down, caller passes positive offset
1003     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
1004     sub(rscratch2, sp, offset);
1005     str(zr, Address(rscratch2));
1006   }
1007 
1008   // Writes to stack successive pages until offset reached to check for
1009   // stack overflow + shadow pages.  Also, clobbers tmp
1010   void bang_stack_size(Register size, Register tmp);
1011 
1012   // Check for reserved stack access in method being exited (for JIT)
1013   void reserved_stack_check();
1014 
1015   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
1016                                                 Register tmp,
1017                                                 int offset);
1018 
1019   // Arithmetics
1020 
1021   void addptr(const Address &amp;dst, int32_t src);
1022   void cmpptr(Register src1, Address src2);
1023 
1024   void cmpoop(Register obj1, Register obj2);
1025 
1026   // Various forms of CAS
1027 
1028   void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
1029                           Label &amp;suceed, Label *fail);
1030   void cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
1031                   Label &amp;suceed, Label *fail);
1032 
1033   void cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
1034                   Label &amp;suceed, Label *fail);
1035 
1036   void atomic_add(Register prev, RegisterOrConstant incr, Register addr);
1037   void atomic_addw(Register prev, RegisterOrConstant incr, Register addr);
1038   void atomic_addal(Register prev, RegisterOrConstant incr, Register addr);
1039   void atomic_addalw(Register prev, RegisterOrConstant incr, Register addr);
1040 
1041   void atomic_xchg(Register prev, Register newv, Register addr);
1042   void atomic_xchgw(Register prev, Register newv, Register addr);
1043   void atomic_xchgal(Register prev, Register newv, Register addr);
1044   void atomic_xchgalw(Register prev, Register newv, Register addr);
1045 
1046   void orptr(Address adr, RegisterOrConstant src) {
1047     ldr(rscratch1, adr);
1048     if (src.is_register())
1049       orr(rscratch1, rscratch1, src.as_register());
1050     else
1051       orr(rscratch1, rscratch1, src.as_constant());
1052     str(rscratch1, adr);
1053   }
1054 
1055   // A generic CAS; success or failure is in the EQ flag.
1056   // Clobbers rscratch1
1057   void cmpxchg(Register addr, Register expected, Register new_val,
1058                enum operand_size size,
1059                bool acquire, bool release, bool weak,
1060                Register result);
1061 private:
1062   void compare_eq(Register rn, Register rm, enum operand_size size);
1063 
1064 public:
1065   // Calls
1066 
1067   address trampoline_call(Address entry, CodeBuffer *cbuf = NULL);
1068 
1069   static bool far_branches() {
1070     return ReservedCodeCacheSize &gt; branch_range || UseAOT;
1071   }
1072 
1073   // Jumps that can reach anywhere in the code cache.
1074   // Trashes tmp.
1075   void far_call(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1076   void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1077 
1078   static int far_branch_size() {
1079     if (far_branches()) {
1080       return 3 * 4;  // adrp, add, br
1081     } else {
1082       return 4;
1083     }
1084   }
1085 
1086   // Emit the CompiledIC call idiom
1087   address ic_call(address entry, jint method_index = 0);
1088 
1089 public:
1090 
1091   // Data
1092 
1093   void mov_metadata(Register dst, Metadata* obj);
1094   Address allocate_metadata_address(Metadata* obj);
1095   Address constant_oop_address(jobject obj);
1096 
1097   void movoop(Register dst, jobject obj, bool immediate = false);
1098 
1099   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1100   void kernel_crc32(Register crc, Register buf, Register len,
1101         Register table0, Register table1, Register table2, Register table3,
1102         Register tmp, Register tmp2, Register tmp3);
1103   // CRC32 code for java.util.zip.CRC32C::updateBytes() instrinsic.
1104   void kernel_crc32c(Register crc, Register buf, Register len,
1105         Register table0, Register table1, Register table2, Register table3,
1106         Register tmp, Register tmp2, Register tmp3);
1107 
1108   // Stack push and pop individual 64 bit registers
1109   void push(Register src);
1110   void pop(Register dst);
1111 
1112   // push all registers onto the stack
1113   void pusha();
1114   void popa();
1115 
1116   void repne_scan(Register addr, Register value, Register count,
1117                   Register scratch);
1118   void repne_scanw(Register addr, Register value, Register count,
1119                    Register scratch);
1120 
1121   typedef void (MacroAssembler::* add_sub_imm_insn)(Register Rd, Register Rn, unsigned imm);
1122   typedef void (MacroAssembler::* add_sub_reg_insn)(Register Rd, Register Rn, Register Rm, enum shift_kind kind, unsigned shift);
1123 
1124   // If a constant does not fit in an immediate field, generate some
1125   // number of MOV instructions and then perform the operation
1126   void wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
1127                              add_sub_imm_insn insn1,
1128                              add_sub_reg_insn insn2);
1129   // Seperate vsn which sets the flags
1130   void wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
1131                              add_sub_imm_insn insn1,
1132                              add_sub_reg_insn insn2);
1133 
1134 #define WRAP(INSN)                                                      \
1135   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1136     wrap_add_sub_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1137   }                                                                     \
1138                                                                         \
1139   void INSN(Register Rd, Register Rn, Register Rm,                      \
1140              enum shift_kind kind, unsigned shift = 0) {                \
1141     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1142   }                                                                     \
1143                                                                         \
1144   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1145     Assembler::INSN(Rd, Rn, Rm);                                        \
1146   }                                                                     \
1147                                                                         \
1148   void INSN(Register Rd, Register Rn, Register Rm,                      \
1149            ext::operation option, int amount = 0) {                     \
1150     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1151   }
1152 
1153   WRAP(add) WRAP(addw) WRAP(sub) WRAP(subw)
1154 
1155 #undef WRAP
1156 #define WRAP(INSN)                                                      \
1157   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1158     wrap_adds_subs_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1159   }                                                                     \
1160                                                                         \
1161   void INSN(Register Rd, Register Rn, Register Rm,                      \
1162              enum shift_kind kind, unsigned shift = 0) {                \
1163     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1164   }                                                                     \
1165                                                                         \
1166   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1167     Assembler::INSN(Rd, Rn, Rm);                                        \
1168   }                                                                     \
1169                                                                         \
1170   void INSN(Register Rd, Register Rn, Register Rm,                      \
1171            ext::operation option, int amount = 0) {                     \
1172     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1173   }
1174 
1175   WRAP(adds) WRAP(addsw) WRAP(subs) WRAP(subsw)
1176 
1177   void add(Register Rd, Register Rn, RegisterOrConstant increment);
1178   void addw(Register Rd, Register Rn, RegisterOrConstant increment);
1179   void sub(Register Rd, Register Rn, RegisterOrConstant decrement);
1180   void subw(Register Rd, Register Rn, RegisterOrConstant decrement);
1181 
1182   void adrp(Register reg1, const Address &amp;dest, uint64_t &amp;byte_offset);
1183 
1184   void tableswitch(Register index, jint lowbound, jint highbound,
1185                    Label &amp;jumptable, Label &amp;jumptable_end, int stride = 1) {
1186     adr(rscratch1, jumptable);
1187     subsw(rscratch2, index, lowbound);
1188     subsw(zr, rscratch2, highbound - lowbound);
1189     br(Assembler::HS, jumptable_end);
1190     add(rscratch1, rscratch1, rscratch2,
1191         ext::sxtw, exact_log2(stride * Assembler::instruction_size));
1192     br(rscratch1);
1193   }
1194 
1195   // Form an address from base + offset in Rd.  Rd may or may not
1196   // actually be used: you must use the Address that is returned.  It
1197   // is up to you to ensure that the shift provided matches the size
1198   // of your data.
1199   Address form_address(Register Rd, Register base, int64_t byte_offset, int shift);
1200 
1201   // Return true iff an address is within the 48-bit AArch64 address
1202   // space.
1203   bool is_valid_AArch64_address(address a) {
1204     return ((uint64_t)a &gt;&gt; 48) == 0;
1205   }
1206 
1207   // Load the base of the cardtable byte map into reg.
1208   void load_byte_map_base(Register reg);
1209 
1210   // Prolog generator routines to support switch between x86 code and
1211   // generated ARM code
1212 
1213   // routine to generate an x86 prolog for a stub function which
1214   // bootstraps into the generated ARM code which directly follows the
1215   // stub
1216   //
1217 
1218   public:
1219 
1220   void ldr_constant(Register dest, const Address &amp;const_addr) {
1221     if (NearCpool) {
1222       ldr(dest, const_addr);
1223     } else {
1224       uint64_t offset;
1225       adrp(dest, InternalAddress(const_addr.target()), offset);
1226       ldr(dest, Address(dest, offset));
1227     }
1228   }
1229 
1230   address read_polling_page(Register r, relocInfo::relocType rtype);
1231   void get_polling_page(Register dest, relocInfo::relocType rtype);
1232   address fetch_and_read_polling_page(Register r, relocInfo::relocType rtype);
1233 
1234   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1235   void update_byte_crc32(Register crc, Register val, Register table);
1236   void update_word_crc32(Register crc, Register v, Register tmp,
1237         Register table0, Register table1, Register table2, Register table3,
1238         bool upper = false);
1239 
1240   void has_negatives(Register ary1, Register len, Register result);
1241 
1242   void arrays_equals(Register a1, Register a2, Register result, Register cnt1,
1243                      Register tmp1, Register tmp2, Register tmp3, int elem_size);
1244 
1245   void string_equals(Register a1, Register a2, Register result, Register cnt1,
1246                      int elem_size);
1247 
1248   void fill_words(Register base, Register cnt, Register value);
1249   void zero_words(Register base, uint64_t cnt);
1250   void zero_words(Register ptr, Register cnt);
1251   void zero_dcache_blocks(Register base, Register cnt);
1252 
1253   static const int zero_words_block_size;
1254 
1255   void byte_array_inflate(Register src, Register dst, Register len,
1256                           FloatRegister vtmp1, FloatRegister vtmp2,
1257                           FloatRegister vtmp3, Register tmp4);
1258 
1259   void char_array_compress(Register src, Register dst, Register len,
1260                            FloatRegister tmp1Reg, FloatRegister tmp2Reg,
1261                            FloatRegister tmp3Reg, FloatRegister tmp4Reg,
1262                            Register result);
1263 
1264   void encode_iso_array(Register src, Register dst,
1265                         Register len, Register result,
1266                         FloatRegister Vtmp1, FloatRegister Vtmp2,
1267                         FloatRegister Vtmp3, FloatRegister Vtmp4);
1268   void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,
1269                 FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,
1270                 FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,
1271                 FloatRegister tmpC4, Register tmp1, Register tmp2,
1272                 Register tmp3, Register tmp4, Register tmp5);
1273   void generate_dsin_dcos(bool isCos, address npio2_hw, address two_over_pi,
1274       address pio2, address dsin_coef, address dcos_coef);
1275  private:
1276   // begin trigonometric functions support block
1277   void generate__ieee754_rem_pio2(address npio2_hw, address two_over_pi, address pio2);
1278   void generate__kernel_rem_pio2(address two_over_pi, address pio2);
1279   void generate_kernel_sin(FloatRegister x, bool iyIsOne, address dsin_coef);
1280   void generate_kernel_cos(FloatRegister x, address dcos_coef);
1281   // end trigonometric functions support block
1282   void add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
1283                        Register src1, Register src2);
1284   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
1285     add2_with_carry(dest_hi, dest_hi, dest_lo, src1, src2);
1286   }
1287   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1288                              Register y, Register y_idx, Register z,
1289                              Register carry, Register product,
1290                              Register idx, Register kdx);
1291   void multiply_128_x_128_loop(Register y, Register z,
1292                                Register carry, Register carry2,
1293                                Register idx, Register jdx,
1294                                Register yz_idx1, Register yz_idx2,
1295                                Register tmp, Register tmp3, Register tmp4,
1296                                Register tmp7, Register product_hi);
1297   void kernel_crc32_using_crc32(Register crc, Register buf,
1298         Register len, Register tmp0, Register tmp1, Register tmp2,
1299         Register tmp3);
1300   void kernel_crc32c_using_crc32c(Register crc, Register buf,
1301         Register len, Register tmp0, Register tmp1, Register tmp2,
1302         Register tmp3);
1303 public:
1304   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z,
1305                        Register zlen, Register tmp1, Register tmp2, Register tmp3,
1306                        Register tmp4, Register tmp5, Register tmp6, Register tmp7);
1307   void mul_add(Register out, Register in, Register offs, Register len, Register k);
1308   // ISB may be needed because of a safepoint
1309   void maybe_isb() { isb(); }
1310 
1311 private:
1312   // Return the effective address r + (r1 &lt;&lt; ext) + offset.
1313   // Uses rscratch2.
1314   Address offsetted_address(Register r, Register r1, Address::extend ext,
1315                             int offset, int size);
1316 
1317 private:
1318   // Returns an address on the stack which is reachable with a ldr/str of size
1319   // Uses rscratch2 if the address is not directly reachable
1320   Address spill_address(int size, int offset, Register tmp=rscratch2);
1321 
1322   bool merge_alignment_check(Register base, size_t size, int64_t cur_offset, int64_t prev_offset) const;
1323 
1324   // Check whether two loads/stores can be merged into ldp/stp.
1325   bool ldst_can_merge(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store) const;
1326 
1327   // Merge current load/store with previous load/store into ldp/stp.
1328   void merge_ldst(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1329 
1330   // Try to merge two loads/stores into ldp/stp. If success, returns true else false.
1331   bool try_merge_ldst(Register rt, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1332 
1333 public:
1334   void spill(Register Rx, bool is64, int offset) {
1335     if (is64) {
1336       str(Rx, spill_address(8, offset));
1337     } else {
1338       strw(Rx, spill_address(4, offset));
1339     }
1340   }
1341   void spill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1342     str(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1343   }
1344   void unspill(Register Rx, bool is64, int offset) {
1345     if (is64) {
1346       ldr(Rx, spill_address(8, offset));
1347     } else {
1348       ldrw(Rx, spill_address(4, offset));
1349     }
1350   }
1351   void unspill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1352     ldr(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1353   }
1354   void spill_copy128(int src_offset, int dst_offset,
1355                      Register tmp1=rscratch1, Register tmp2=rscratch2) {
1356     if (src_offset &lt; 512 &amp;&amp; (src_offset &amp; 7) == 0 &amp;&amp;
1357         dst_offset &lt; 512 &amp;&amp; (dst_offset &amp; 7) == 0) {
1358       ldp(tmp1, tmp2, Address(sp, src_offset));
1359       stp(tmp1, tmp2, Address(sp, dst_offset));
1360     } else {
1361       unspill(tmp1, true, src_offset);
1362       spill(tmp1, true, dst_offset);
1363       unspill(tmp1, true, src_offset+8);
1364       spill(tmp1, true, dst_offset+8);
1365     }
1366   }
1367 
1368   void cache_wb(Address line);
1369   void cache_wbsync(bool is_pre);
1370 };
1371 
1372 #ifdef ASSERT
1373 inline bool AbstractAssembler::pd_check_instruction_mark() { return false; }
1374 #endif
1375 
1376 /**
1377  * class SkipIfEqual:
1378  *
1379  * Instantiating this class will result in assembly code being output that will
1380  * jump around any code emitted between the creation of the instance and it&#39;s
1381  * automatic destruction at the end of a scope block, depending on the value of
1382  * the flag passed to the constructor, which will be checked at run-time.
1383  */
1384 class SkipIfEqual {
1385  private:
1386   MacroAssembler* _masm;
1387   Label _label;
1388 
1389  public:
1390    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1391    ~SkipIfEqual();
1392 };
1393 
1394 struct tableswitch {
1395   Register _reg;
1396   int _insn_index; jint _first_key; jint _last_key;
1397   Label _after;
1398   Label _branches;
1399 };
1400 
1401 #endif // CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
    </pre>
  </body>
</html>