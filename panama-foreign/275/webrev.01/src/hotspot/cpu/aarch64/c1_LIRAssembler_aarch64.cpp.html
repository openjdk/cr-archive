<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;c1/c1_CodeStubs.hpp&quot;
  30 #include &quot;c1/c1_Compilation.hpp&quot;
  31 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  32 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  33 #include &quot;c1/c1_Runtime1.hpp&quot;
  34 #include &quot;c1/c1_ValueStack.hpp&quot;
  35 #include &quot;ci/ciArrayKlass.hpp&quot;
  36 #include &quot;ci/ciInstance.hpp&quot;
  37 #include &quot;code/compiledIC.hpp&quot;
  38 #include &quot;gc/shared/collectedHeap.hpp&quot;
  39 #include &quot;nativeInst_aarch64.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;runtime/frame.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 #include &quot;vmreg_aarch64.inline.hpp&quot;
  45 
  46 
  47 #ifndef PRODUCT
  48 #define COMMENT(x)   do { __ block_comment(x); } while (0)
  49 #else
  50 #define COMMENT(x)
  51 #endif
  52 
  53 NEEDS_CLEANUP // remove this definitions ?
  54 const Register IC_Klass    = rscratch2;   // where the IC klass is cached
  55 const Register SYNC_header = r0;   // synchronization header
  56 const Register SHIFT_count = r0;   // where count for shift operations must be
  57 
  58 #define __ _masm-&gt;
  59 
  60 
  61 static void select_different_registers(Register preserve,
  62                                        Register extra,
  63                                        Register &amp;tmp1,
  64                                        Register &amp;tmp2) {
  65   if (tmp1 == preserve) {
  66     assert_different_registers(tmp1, tmp2, extra);
  67     tmp1 = extra;
  68   } else if (tmp2 == preserve) {
  69     assert_different_registers(tmp1, tmp2, extra);
  70     tmp2 = extra;
  71   }
  72   assert_different_registers(preserve, tmp1, tmp2);
  73 }
  74 
  75 
  76 
  77 static void select_different_registers(Register preserve,
  78                                        Register extra,
  79                                        Register &amp;tmp1,
  80                                        Register &amp;tmp2,
  81                                        Register &amp;tmp3) {
  82   if (tmp1 == preserve) {
  83     assert_different_registers(tmp1, tmp2, tmp3, extra);
  84     tmp1 = extra;
  85   } else if (tmp2 == preserve) {
  86     assert_different_registers(tmp1, tmp2, tmp3, extra);
  87     tmp2 = extra;
  88   } else if (tmp3 == preserve) {
  89     assert_different_registers(tmp1, tmp2, tmp3, extra);
  90     tmp3 = extra;
  91   }
  92   assert_different_registers(preserve, tmp1, tmp2, tmp3);
  93 }
  94 
  95 
  96 bool LIR_Assembler::is_small_constant(LIR_Opr opr) { Unimplemented(); return false; }
  97 
  98 
  99 LIR_Opr LIR_Assembler::receiverOpr() {
 100   return FrameMap::receiver_opr;
 101 }
 102 
 103 LIR_Opr LIR_Assembler::osrBufferPointer() {
 104   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 105 }
 106 
 107 //--------------fpu register translations-----------------------
 108 
 109 
 110 address LIR_Assembler::float_constant(float f) {
 111   address const_addr = __ float_constant(f);
 112   if (const_addr == NULL) {
 113     bailout(&quot;const section overflow&quot;);
 114     return __ code()-&gt;consts()-&gt;start();
 115   } else {
 116     return const_addr;
 117   }
 118 }
 119 
 120 
 121 address LIR_Assembler::double_constant(double d) {
 122   address const_addr = __ double_constant(d);
 123   if (const_addr == NULL) {
 124     bailout(&quot;const section overflow&quot;);
 125     return __ code()-&gt;consts()-&gt;start();
 126   } else {
 127     return const_addr;
 128   }
 129 }
 130 
 131 address LIR_Assembler::int_constant(jlong n) {
 132   address const_addr = __ long_constant(n);
 133   if (const_addr == NULL) {
 134     bailout(&quot;const section overflow&quot;);
 135     return __ code()-&gt;consts()-&gt;start();
 136   } else {
 137     return const_addr;
 138   }
 139 }
 140 
 141 void LIR_Assembler::breakpoint() { Unimplemented(); }
 142 
 143 void LIR_Assembler::push(LIR_Opr opr) { Unimplemented(); }
 144 
 145 void LIR_Assembler::pop(LIR_Opr opr) { Unimplemented(); }
 146 
 147 bool LIR_Assembler::is_literal_address(LIR_Address* addr) { Unimplemented(); return false; }
 148 //-------------------------------------------
 149 
 150 static Register as_reg(LIR_Opr op) {
 151   return op-&gt;is_double_cpu() ? op-&gt;as_register_lo() : op-&gt;as_register();
 152 }
 153 
 154 static jlong as_long(LIR_Opr data) {
 155   jlong result;
 156   switch (data-&gt;type()) {
 157   case T_INT:
 158     result = (data-&gt;as_jint());
 159     break;
 160   case T_LONG:
 161     result = (data-&gt;as_jlong());
 162     break;
 163   default:
 164     ShouldNotReachHere();
 165     result = 0;  // unreachable
 166   }
 167   return result;
 168 }
 169 
 170 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 171   Register base = addr-&gt;base()-&gt;as_pointer_register();
 172   LIR_Opr opr = addr-&gt;index();
 173   if (opr-&gt;is_cpu_register()) {
 174     Register index;
 175     if (opr-&gt;is_single_cpu())
 176       index = opr-&gt;as_register();
 177     else
 178       index = opr-&gt;as_register_lo();
 179     assert(addr-&gt;disp() == 0, &quot;must be&quot;);
 180     switch(opr-&gt;type()) {
 181       case T_INT:
 182         return Address(base, index, Address::sxtw(addr-&gt;scale()));
 183       case T_LONG:
 184         return Address(base, index, Address::lsl(addr-&gt;scale()));
 185       default:
 186         ShouldNotReachHere();
 187       }
 188   } else  {
 189     intptr_t addr_offset = intptr_t(addr-&gt;disp());
 190     if (Address::offset_ok_for_immed(addr_offset, addr-&gt;scale()))
 191       return Address(base, addr_offset, Address::lsl(addr-&gt;scale()));
 192     else {
 193       __ mov(tmp, addr_offset);
 194       return Address(base, tmp, Address::lsl(addr-&gt;scale()));
 195     }
 196   }
 197   return Address();
 198 }
 199 
 200 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 201   ShouldNotReachHere();
 202   return Address();
 203 }
 204 
 205 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 206   return as_Address(addr, rscratch1);
 207 }
 208 
 209 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 210   return as_Address(addr, rscratch1);  // Ouch
 211   // FIXME: This needs to be much more clever.  See x86.
 212 }
 213 
 214 // Ensure a valid Address (base + offset) to a stack-slot. If stack access is
 215 // not encodable as a base + (immediate) offset, generate an explicit address
 216 // calculation to hold the address in a temporary register.
 217 Address LIR_Assembler::stack_slot_address(int index, uint size, Register tmp, int adjust) {
 218   precond(size == 4 || size == 8);
 219   Address addr = frame_map()-&gt;address_for_slot(index, adjust);
 220   precond(addr.getMode() == Address::base_plus_offset);
 221   precond(addr.base() == sp);
 222   precond(addr.offset() &gt; 0);
 223   uint mask = size - 1;
 224   assert((addr.offset() &amp; mask) == 0, &quot;scaled offsets only&quot;);
 225   return __ legitimize_address(addr, size, tmp);
 226 }
 227 
 228 void LIR_Assembler::osr_entry() {
 229   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 230   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 231   ValueStack* entry_state = osr_entry-&gt;state();
 232   int number_of_locks = entry_state-&gt;locks_size();
 233 
 234   // we jump here if osr happens with the interpreter
 235   // state set up to continue at the beginning of the
 236   // loop that triggered osr - in particular, we have
 237   // the following registers setup:
 238   //
 239   // r2: osr buffer
 240   //
 241 
 242   // build frame
 243   ciMethod* m = compilation()-&gt;method();
 244   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 245 
 246   // OSR buffer is
 247   //
 248   // locals[nlocals-1..0]
 249   // monitors[0..number_of_locks]
 250   //
 251   // locals is a direct copy of the interpreter frame so in the osr buffer
 252   // so first slot in the local array is the last local from the interpreter
 253   // and last slot is local[0] (receiver) from the interpreter
 254   //
 255   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 256   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 257   // in the interpreter frame (the method lock if a sync method)
 258 
 259   // Initialize monitors in the compiled activation.
 260   //   r2: pointer to osr buffer
 261   //
 262   // All other registers are dead at this point and the locals will be
 263   // copied into place by code emitted in the IR.
 264 
 265   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 266   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 267     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 268       (2 * BytesPerWord) * (number_of_locks - 1);
 269     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 270     // the OSR buffer using 2 word entries: first the lock and then
 271     // the oop.
 272     for (int i = 0; i &lt; number_of_locks; i++) {
 273       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 274 #ifdef ASSERT
 275       // verify the interpreter&#39;s monitor has a non-null object
 276       {
 277         Label L;
 278         __ ldr(rscratch1, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 279         __ cbnz(rscratch1, L);
 280         __ stop(&quot;locked object is NULL&quot;);
 281         __ bind(L);
 282       }
 283 #endif
 284       __ ldr(r19, Address(OSR_buf, slot_offset + 0));
 285       __ str(r19, frame_map()-&gt;address_for_monitor_lock(i));
 286       __ ldr(r19, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 287       __ str(r19, frame_map()-&gt;address_for_monitor_object(i));
 288     }
 289   }
 290 }
 291 
 292 
 293 // inline cache check; done before the frame is built.
 294 int LIR_Assembler::check_icache() {
 295   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 296   Register ic_klass = IC_Klass;
 297   int start_offset = __ offset();
 298   __ inline_cache_check(receiver, ic_klass);
 299 
 300   // if icache check fails, then jump to runtime routine
 301   // Note: RECEIVER must still contain the receiver!
 302   Label dont;
 303   __ br(Assembler::EQ, dont);
 304   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 305 
 306   // We align the verified entry point unless the method body
 307   // (including its inline cache check) will fit in a single 64-byte
 308   // icache line.
 309   if (! method()-&gt;is_accessor() || __ offset() - start_offset &gt; 4 * 4) {
 310     // force alignment after the cache check.
 311     __ align(CodeEntryAlignment);
 312   }
 313 
 314   __ bind(dont);
 315   return start_offset;
 316 }
 317 
 318 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 319   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 320   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 321 
 322   Label L_skip_barrier;
 323 
 324   __ mov_metadata(rscratch2, method-&gt;holder()-&gt;constant_encoding());
 325   __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier /*L_fast_path*/);
 326   __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 327   __ bind(L_skip_barrier);
 328 }
 329 
 330 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 331   if (o == NULL) {
 332     __ mov(reg, zr);
 333   } else {
 334     __ movoop(reg, o, /*immediate*/true);
 335   }
 336 }
 337 
 338 void LIR_Assembler::deoptimize_trap(CodeEmitInfo *info) {
 339   address target = NULL;
 340   relocInfo::relocType reloc_type = relocInfo::none;
 341 
 342   switch (patching_id(info)) {
 343   case PatchingStub::access_field_id:
 344     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 345     reloc_type = relocInfo::section_word_type;
 346     break;
 347   case PatchingStub::load_klass_id:
 348     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 349     reloc_type = relocInfo::metadata_type;
 350     break;
 351   case PatchingStub::load_mirror_id:
 352     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 353     reloc_type = relocInfo::oop_type;
 354     break;
 355   case PatchingStub::load_appendix_id:
 356     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 357     reloc_type = relocInfo::oop_type;
 358     break;
 359   default: ShouldNotReachHere();
 360   }
 361 
 362   __ far_call(RuntimeAddress(target));
 363   add_call_info_here(info);
 364 }
 365 
 366 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 367   deoptimize_trap(info);
 368 }
 369 
 370 
 371 // This specifies the rsp decrement needed to build the frame
 372 int LIR_Assembler::initial_frame_size_in_bytes() const {
 373   // if rounding, must let FrameMap know!
 374 
 375   // The frame_map records size in slots (32bit word)
 376 
 377   // subtract two words to account for return address and link
 378   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 379 }
 380 
 381 
 382 int LIR_Assembler::emit_exception_handler() {
 383   // if the last instruction is a call (typically to do a throw which
 384   // is coming at the end after block reordering) the return address
 385   // must still point into the code area in order to avoid assertion
 386   // failures when searching for the corresponding bci =&gt; add a nop
 387   // (was bug 5/14/1999 - gri)
 388   __ nop();
 389 
 390   // generate code for exception handler
 391   address handler_base = __ start_a_stub(exception_handler_size());
 392   if (handler_base == NULL) {
 393     // not enough space left for the handler
 394     bailout(&quot;exception handler overflow&quot;);
 395     return -1;
 396   }
 397 
 398   int offset = code_offset();
 399 
 400   // the exception oop and pc are in r0, and r3
 401   // no other registers need to be preserved, so invalidate them
 402   __ invalidate_registers(false, true, true, false, true, true);
 403 
 404   // check that there is really an exception
 405   __ verify_not_null_oop(r0);
 406 
 407   // search an exception handler (r0: exception oop, r3: throwing pc)
 408   __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));  __ should_not_reach_here();
 409   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 410   __ end_a_stub();
 411 
 412   return offset;
 413 }
 414 
 415 
 416 // Emit the code to remove the frame from the stack in the exception
 417 // unwind path.
 418 int LIR_Assembler::emit_unwind_handler() {
 419 #ifndef PRODUCT
 420   if (CommentedAssembly) {
 421     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 422   }
 423 #endif
 424 
 425   int offset = code_offset();
 426 
 427   // Fetch the exception from TLS and clear out exception related thread state
 428   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
 429   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
 430   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
 431 
 432   __ bind(_unwind_handler_entry);
 433   __ verify_not_null_oop(r0);
 434   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 435     __ mov(r19, r0);  // Preserve the exception
 436   }
 437 
 438   // Preform needed unlocking
 439   MonitorExitStub* stub = NULL;
 440   if (method()-&gt;is_synchronized()) {
 441     monitor_address(0, FrameMap::r0_opr);
 442     stub = new MonitorExitStub(FrameMap::r0_opr, true, 0);
 443     __ unlock_object(r5, r4, r0, *stub-&gt;entry());
 444     __ bind(*stub-&gt;continuation());
 445   }
 446 
 447   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 448     __ mov(c_rarg0, rthread);
 449     __ mov_metadata(c_rarg1, method()-&gt;constant_encoding());
 450     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), c_rarg0, c_rarg1);
 451   }
 452 
 453   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 454     __ mov(r0, r19);  // Restore the exception
 455   }
 456 
 457   // remove the activation and dispatch to the unwind handler
 458   __ block_comment(&quot;remove_frame and dispatch to the unwind handler&quot;);
 459   __ remove_frame(initial_frame_size_in_bytes());
 460   __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 461 
 462   // Emit the slow path assembly
 463   if (stub != NULL) {
 464     stub-&gt;emit_code(this);
 465   }
 466 
 467   return offset;
 468 }
 469 
 470 
 471 int LIR_Assembler::emit_deopt_handler() {
 472   // if the last instruction is a call (typically to do a throw which
 473   // is coming at the end after block reordering) the return address
 474   // must still point into the code area in order to avoid assertion
 475   // failures when searching for the corresponding bci =&gt; add a nop
 476   // (was bug 5/14/1999 - gri)
 477   __ nop();
 478 
 479   // generate code for exception handler
 480   address handler_base = __ start_a_stub(deopt_handler_size());
 481   if (handler_base == NULL) {
 482     // not enough space left for the handler
 483     bailout(&quot;deopt handler overflow&quot;);
 484     return -1;
 485   }
 486 
 487   int offset = code_offset();
 488 
 489   __ adr(lr, pc());
 490   __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 491   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 492   __ end_a_stub();
 493 
 494   return offset;
 495 }
 496 
 497 void LIR_Assembler::add_debug_info_for_branch(address adr, CodeEmitInfo* info) {
 498   _masm-&gt;code_section()-&gt;relocate(adr, relocInfo::poll_type);
 499   int pc_offset = code_offset();
 500   flush_debug_info(pc_offset);
 501   info-&gt;record_debug_info(compilation()-&gt;debug_info_recorder(), pc_offset);
 502   if (info-&gt;exception_handlers() != NULL) {
 503     compilation()-&gt;add_exception_handlers_for_pco(pc_offset, info-&gt;exception_handlers());
 504   }
 505 }
 506 
 507 void LIR_Assembler::return_op(LIR_Opr result) {
 508   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == r0, &quot;word returns are in r0,&quot;);
 509 
 510   // Pop the stack before the safepoint code
 511   __ remove_frame(initial_frame_size_in_bytes());
 512 
 513   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 514     __ reserved_stack_check();
 515   }
 516 
 517   __ fetch_and_read_polling_page(rscratch1, relocInfo::poll_return_type);
 518   __ ret(lr);
 519 }
 520 
 521 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 522   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 523   __ get_polling_page(rscratch1, relocInfo::poll_type);
 524   add_debug_info_for_branch(info);  // This isn&#39;t just debug info:
 525                                     // it&#39;s the oop map
 526   __ read_polling_page(rscratch1, relocInfo::poll_type);
 527   return __ offset();
 528 }
 529 
 530 
 531 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 532   if (from_reg == r31_sp)
 533     from_reg = sp;
 534   if (to_reg == r31_sp)
 535     to_reg = sp;
 536   __ mov(to_reg, from_reg);
 537 }
 538 
 539 void LIR_Assembler::swap_reg(Register a, Register b) { Unimplemented(); }
 540 
 541 
 542 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 543   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 544   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 545   LIR_Const* c = src-&gt;as_constant_ptr();
 546 
 547   switch (c-&gt;type()) {
 548     case T_INT: {
 549       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 550       __ movw(dest-&gt;as_register(), c-&gt;as_jint());
 551       break;
 552     }
 553 
 554     case T_ADDRESS: {
 555       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 556       __ mov(dest-&gt;as_register(), c-&gt;as_jint());
 557       break;
 558     }
 559 
 560     case T_LONG: {
 561       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 562       __ mov(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 563       break;
 564     }
 565 
 566     case T_OBJECT: {
 567         if (patch_code == lir_patch_none) {
 568           jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 569         } else {
 570           jobject2reg_with_patching(dest-&gt;as_register(), info);
 571         }
 572       break;
 573     }
 574 
 575     case T_METADATA: {
 576       if (patch_code != lir_patch_none) {
 577         klass2reg_with_patching(dest-&gt;as_register(), info);
 578       } else {
 579         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 580       }
 581       break;
 582     }
 583 
 584     case T_FLOAT: {
 585       if (__ operand_valid_for_float_immediate(c-&gt;as_jfloat())) {
 586         __ fmovs(dest-&gt;as_float_reg(), (c-&gt;as_jfloat()));
 587       } else {
 588         __ adr(rscratch1, InternalAddress(float_constant(c-&gt;as_jfloat())));
 589         __ ldrs(dest-&gt;as_float_reg(), Address(rscratch1));
 590       }
 591       break;
 592     }
 593 
 594     case T_DOUBLE: {
 595       if (__ operand_valid_for_float_immediate(c-&gt;as_jdouble())) {
 596         __ fmovd(dest-&gt;as_double_reg(), (c-&gt;as_jdouble()));
 597       } else {
 598         __ adr(rscratch1, InternalAddress(double_constant(c-&gt;as_jdouble())));
 599         __ ldrd(dest-&gt;as_double_reg(), Address(rscratch1));
 600       }
 601       break;
 602     }
 603 
 604     default:
 605       ShouldNotReachHere();
 606   }
 607 }
 608 
 609 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 610   LIR_Const* c = src-&gt;as_constant_ptr();
 611   switch (c-&gt;type()) {
 612   case T_OBJECT:
 613     {
 614       if (! c-&gt;as_jobject())
 615         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 616       else {
 617         const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 618         reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 619       }
 620     }
 621     break;
 622   case T_ADDRESS:
 623     {
 624       const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 625       reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 626     }
 627   case T_INT:
 628   case T_FLOAT:
 629     {
 630       Register reg = zr;
 631       if (c-&gt;as_jint_bits() == 0)
 632         __ strw(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 633       else {
 634         __ movw(rscratch1, c-&gt;as_jint_bits());
 635         __ strw(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 636       }
 637     }
 638     break;
 639   case T_LONG:
 640   case T_DOUBLE:
 641     {
 642       Register reg = zr;
 643       if (c-&gt;as_jlong_bits() == 0)
 644         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 645                                                  lo_word_offset_in_bytes));
 646       else {
 647         __ mov(rscratch1, (intptr_t)c-&gt;as_jlong_bits());
 648         __ str(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 649                                                         lo_word_offset_in_bytes));
 650       }
 651     }
 652     break;
 653   default:
 654     ShouldNotReachHere();
 655   }
 656 }
 657 
 658 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 659   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 660   LIR_Const* c = src-&gt;as_constant_ptr();
 661   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 662 
 663   void (Assembler::* insn)(Register Rt, const Address &amp;adr);
 664 
 665   switch (type) {
 666   case T_ADDRESS:
 667     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 668     insn = &amp;Assembler::str;
 669     break;
 670   case T_LONG:
 671     assert(c-&gt;as_jlong() == 0, &quot;should be&quot;);
 672     insn = &amp;Assembler::str;
 673     break;
 674   case T_INT:
 675     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 676     insn = &amp;Assembler::strw;
 677     break;
 678   case T_OBJECT:
 679   case T_ARRAY:
 680     assert(c-&gt;as_jobject() == 0, &quot;should be&quot;);
 681     if (UseCompressedOops &amp;&amp; !wide) {
 682       insn = &amp;Assembler::strw;
 683     } else {
 684       insn = &amp;Assembler::str;
 685     }
 686     break;
 687   case T_CHAR:
 688   case T_SHORT:
 689     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 690     insn = &amp;Assembler::strh;
 691     break;
 692   case T_BOOLEAN:
 693   case T_BYTE:
 694     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 695     insn = &amp;Assembler::strb;
 696     break;
 697   default:
 698     ShouldNotReachHere();
 699     insn = &amp;Assembler::str;  // unreachable
 700   }
 701 
 702   if (info) add_debug_info_for_null_check_here(info);
 703   (_masm-&gt;*insn)(zr, as_Address(to_addr, rscratch1));
 704 }
 705 
 706 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 707   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 708   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 709 
 710   // move between cpu-registers
 711   if (dest-&gt;is_single_cpu()) {
 712     if (src-&gt;type() == T_LONG) {
 713       // Can do LONG -&gt; OBJECT
 714       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 715       return;
 716     }
 717     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 718     if (src-&gt;type() == T_OBJECT) {
 719       __ verify_oop(src-&gt;as_register());
 720     }
 721     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 722 
 723   } else if (dest-&gt;is_double_cpu()) {
 724     if (is_reference_type(src-&gt;type())) {
 725       // Surprising to me but we can see move of a long to t_object
 726       __ verify_oop(src-&gt;as_register());
 727       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 728       return;
 729     }
 730     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 731     Register f_lo = src-&gt;as_register_lo();
 732     Register f_hi = src-&gt;as_register_hi();
 733     Register t_lo = dest-&gt;as_register_lo();
 734     Register t_hi = dest-&gt;as_register_hi();
 735     assert(f_hi == f_lo, &quot;must be same&quot;);
 736     assert(t_hi == t_lo, &quot;must be same&quot;);
 737     move_regs(f_lo, t_lo);
 738 
 739   } else if (dest-&gt;is_single_fpu()) {
 740     __ fmovs(dest-&gt;as_float_reg(), src-&gt;as_float_reg());
 741 
 742   } else if (dest-&gt;is_double_fpu()) {
 743     __ fmovd(dest-&gt;as_double_reg(), src-&gt;as_double_reg());
 744 
 745   } else {
 746     ShouldNotReachHere();
 747   }
 748 }
 749 
 750 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 751   precond(src-&gt;is_register() &amp;&amp; dest-&gt;is_stack());
 752 
 753   uint const c_sz32 = sizeof(uint32_t);
 754   uint const c_sz64 = sizeof(uint64_t);
 755 
 756   if (src-&gt;is_single_cpu()) {
 757     int index = dest-&gt;single_stack_ix();
 758     if (is_reference_type(type)) {
 759       __ str(src-&gt;as_register(), stack_slot_address(index, c_sz64, rscratch1));
 760       __ verify_oop(src-&gt;as_register());
 761     } else if (type == T_METADATA || type == T_DOUBLE || type == T_ADDRESS) {
 762       __ str(src-&gt;as_register(), stack_slot_address(index, c_sz64, rscratch1));
 763     } else {
 764       __ strw(src-&gt;as_register(), stack_slot_address(index, c_sz32, rscratch1));
 765     }
 766 
 767   } else if (src-&gt;is_double_cpu()) {
 768     int index = dest-&gt;double_stack_ix();
 769     Address dest_addr_LO = stack_slot_address(index, c_sz64, rscratch1, lo_word_offset_in_bytes);
 770     __ str(src-&gt;as_register_lo(), dest_addr_LO);
 771 
 772   } else if (src-&gt;is_single_fpu()) {
 773     int index = dest-&gt;single_stack_ix();
 774     __ strs(src-&gt;as_float_reg(), stack_slot_address(index, c_sz32, rscratch1));
 775 
 776   } else if (src-&gt;is_double_fpu()) {
 777     int index = dest-&gt;double_stack_ix();
 778     __ strd(src-&gt;as_double_reg(), stack_slot_address(index, c_sz64, rscratch1));
 779 
 780   } else {
 781     ShouldNotReachHere();
 782   }
 783 }
 784 
 785 
 786 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 787   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 788   PatchingStub* patch = NULL;
 789   Register compressed_src = rscratch1;
 790 
 791   if (patch_code != lir_patch_none) {
 792     deoptimize_trap(info);
 793     return;
 794   }
 795 
 796   if (is_reference_type(type)) {
 797     __ verify_oop(src-&gt;as_register());
 798 
 799     if (UseCompressedOops &amp;&amp; !wide) {
 800       __ encode_heap_oop(compressed_src, src-&gt;as_register());
 801     } else {
 802       compressed_src = src-&gt;as_register();
 803     }
 804   }
 805 
 806   int null_check_here = code_offset();
 807   switch (type) {
 808     case T_FLOAT: {
 809       __ strs(src-&gt;as_float_reg(), as_Address(to_addr));
 810       break;
 811     }
 812 
 813     case T_DOUBLE: {
 814       __ strd(src-&gt;as_double_reg(), as_Address(to_addr));
 815       break;
 816     }
 817 
 818     case T_ARRAY:   // fall through
 819     case T_OBJECT:  // fall through
 820       if (UseCompressedOops &amp;&amp; !wide) {
 821         __ strw(compressed_src, as_Address(to_addr, rscratch2));
 822       } else {
 823          __ str(compressed_src, as_Address(to_addr));
 824       }
 825       break;
 826     case T_METADATA:
 827       // We get here to store a method pointer to the stack to pass to
 828       // a dtrace runtime call. This can&#39;t work on 64 bit with
 829       // compressed klass ptrs: T_METADATA can be a compressed klass
 830       // ptr or a 64 bit method pointer.
 831       ShouldNotReachHere();
 832       __ str(src-&gt;as_register(), as_Address(to_addr));
 833       break;
 834     case T_ADDRESS:
 835       __ str(src-&gt;as_register(), as_Address(to_addr));
 836       break;
 837     case T_INT:
 838       __ strw(src-&gt;as_register(), as_Address(to_addr));
 839       break;
 840 
 841     case T_LONG: {
 842       __ str(src-&gt;as_register_lo(), as_Address_lo(to_addr));
 843       break;
 844     }
 845 
 846     case T_BYTE:    // fall through
 847     case T_BOOLEAN: {
 848       __ strb(src-&gt;as_register(), as_Address(to_addr));
 849       break;
 850     }
 851 
 852     case T_CHAR:    // fall through
 853     case T_SHORT:
 854       __ strh(src-&gt;as_register(), as_Address(to_addr));
 855       break;
 856 
 857     default:
 858       ShouldNotReachHere();
 859   }
 860   if (info != NULL) {
 861     add_debug_info_for_null_check(null_check_here, info);
 862   }
 863 }
 864 
 865 
 866 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
 867   precond(src-&gt;is_stack() &amp;&amp; dest-&gt;is_register());
 868 
 869   uint const c_sz32 = sizeof(uint32_t);
 870   uint const c_sz64 = sizeof(uint64_t);
 871 
 872   if (dest-&gt;is_single_cpu()) {
 873     int index = src-&gt;single_stack_ix();
 874     if (is_reference_type(type)) {
 875       __ ldr(dest-&gt;as_register(), stack_slot_address(index, c_sz64, rscratch1));
 876       __ verify_oop(dest-&gt;as_register());
 877     } else if (type == T_METADATA || type == T_ADDRESS) {
 878       __ ldr(dest-&gt;as_register(), stack_slot_address(index, c_sz64, rscratch1));
 879     } else {
 880       __ ldrw(dest-&gt;as_register(), stack_slot_address(index, c_sz32, rscratch1));
 881     }
 882 
 883   } else if (dest-&gt;is_double_cpu()) {
 884     int index = src-&gt;double_stack_ix();
 885     Address src_addr_LO = stack_slot_address(index, c_sz64, rscratch1, lo_word_offset_in_bytes);
 886     __ ldr(dest-&gt;as_register_lo(), src_addr_LO);
 887 
 888   } else if (dest-&gt;is_single_fpu()) {
 889     int index = src-&gt;single_stack_ix();
 890     __ ldrs(dest-&gt;as_float_reg(), stack_slot_address(index, c_sz32, rscratch1));
 891 
 892   } else if (dest-&gt;is_double_fpu()) {
 893     int index = src-&gt;double_stack_ix();
 894     __ ldrd(dest-&gt;as_double_reg(), stack_slot_address(index, c_sz64, rscratch1));
 895 
 896   } else {
 897     ShouldNotReachHere();
 898   }
 899 }
 900 
 901 
 902 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 903   address target = NULL;
 904   relocInfo::relocType reloc_type = relocInfo::none;
 905 
 906   switch (patching_id(info)) {
 907   case PatchingStub::access_field_id:
 908     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 909     reloc_type = relocInfo::section_word_type;
 910     break;
 911   case PatchingStub::load_klass_id:
 912     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 913     reloc_type = relocInfo::metadata_type;
 914     break;
 915   case PatchingStub::load_mirror_id:
 916     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 917     reloc_type = relocInfo::oop_type;
 918     break;
 919   case PatchingStub::load_appendix_id:
 920     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 921     reloc_type = relocInfo::oop_type;
 922     break;
 923   default: ShouldNotReachHere();
 924   }
 925 
 926   __ far_call(RuntimeAddress(target));
 927   add_call_info_here(info);
 928 }
 929 
 930 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 931 
 932   LIR_Opr temp;
 933   if (type == T_LONG || type == T_DOUBLE)
 934     temp = FrameMap::rscratch1_long_opr;
 935   else
 936     temp = FrameMap::rscratch1_opr;
 937 
 938   stack2reg(src, temp, src-&gt;type());
 939   reg2stack(temp, dest, dest-&gt;type(), false);
 940 }
 941 
 942 
 943 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
 944   LIR_Address* addr = src-&gt;as_address_ptr();
 945   LIR_Address* from_addr = src-&gt;as_address_ptr();
 946 
 947   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
 948     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
 949   }
 950 
 951   if (patch_code != lir_patch_none) {
 952     deoptimize_trap(info);
 953     return;
 954   }
 955 
 956   if (info != NULL) {
 957     add_debug_info_for_null_check_here(info);
 958   }
 959   int null_check_here = code_offset();
 960   switch (type) {
 961     case T_FLOAT: {
 962       __ ldrs(dest-&gt;as_float_reg(), as_Address(from_addr));
 963       break;
 964     }
 965 
 966     case T_DOUBLE: {
 967       __ ldrd(dest-&gt;as_double_reg(), as_Address(from_addr));
 968       break;
 969     }
 970 
 971     case T_ARRAY:   // fall through
 972     case T_OBJECT:  // fall through
 973       if (UseCompressedOops &amp;&amp; !wide) {
 974         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 975       } else {
 976          __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 977       }
 978       break;
 979     case T_METADATA:
 980       // We get here to store a method pointer to the stack to pass to
 981       // a dtrace runtime call. This can&#39;t work on 64 bit with
 982       // compressed klass ptrs: T_METADATA can be a compressed klass
 983       // ptr or a 64 bit method pointer.
 984       ShouldNotReachHere();
 985       __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 986       break;
 987     case T_ADDRESS:
 988       // FIXME: OMG this is a horrible kludge.  Any offset from an
 989       // address that matches klass_offset_in_bytes() will be loaded
 990       // as a word, not a long.
 991       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 992         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 993       } else {
 994         __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 995       }
 996       break;
 997     case T_INT:
 998       __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 999       break;
1000 
1001     case T_LONG: {
1002       __ ldr(dest-&gt;as_register_lo(), as_Address_lo(from_addr));
1003       break;
1004     }
1005 
1006     case T_BYTE:
1007       __ ldrsb(dest-&gt;as_register(), as_Address(from_addr));
1008       break;
1009     case T_BOOLEAN: {
1010       __ ldrb(dest-&gt;as_register(), as_Address(from_addr));
1011       break;
1012     }
1013 
1014     case T_CHAR:
1015       __ ldrh(dest-&gt;as_register(), as_Address(from_addr));
1016       break;
1017     case T_SHORT:
1018       __ ldrsh(dest-&gt;as_register(), as_Address(from_addr));
1019       break;
1020 
1021     default:
1022       ShouldNotReachHere();
1023   }
1024 
1025   if (is_reference_type(type)) {
1026     if (UseCompressedOops &amp;&amp; !wide) {
1027       __ decode_heap_oop(dest-&gt;as_register());
1028     }
1029 
1030     if (!UseZGC) {
1031       // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1032       __ verify_oop(dest-&gt;as_register());
1033     }
1034   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1035     if (UseCompressedClassPointers) {
1036       __ decode_klass_not_null(dest-&gt;as_register());
1037     }
1038   }
1039 }
1040 
1041 
1042 int LIR_Assembler::array_element_size(BasicType type) const {
1043   int elem_size = type2aelembytes(type);
1044   return exact_log2(elem_size);
1045 }
1046 
1047 
1048 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1049   switch (op-&gt;code()) {
1050   case lir_idiv:
1051   case lir_irem:
1052     arithmetic_idiv(op-&gt;code(),
1053                     op-&gt;in_opr1(),
1054                     op-&gt;in_opr2(),
1055                     op-&gt;in_opr3(),
1056                     op-&gt;result_opr(),
1057                     op-&gt;info());
1058     break;
1059   case lir_fmad:
1060     __ fmaddd(op-&gt;result_opr()-&gt;as_double_reg(),
1061               op-&gt;in_opr1()-&gt;as_double_reg(),
1062               op-&gt;in_opr2()-&gt;as_double_reg(),
1063               op-&gt;in_opr3()-&gt;as_double_reg());
1064     break;
1065   case lir_fmaf:
1066     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(),
1067               op-&gt;in_opr1()-&gt;as_float_reg(),
1068               op-&gt;in_opr2()-&gt;as_float_reg(),
1069               op-&gt;in_opr3()-&gt;as_float_reg());
1070     break;
1071   default:      ShouldNotReachHere(); break;
1072   }
1073 }
1074 
1075 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1076 #ifdef ASSERT
1077   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1078   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1079   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1080 #endif
1081 
1082   if (op-&gt;cond() == lir_cond_always) {
1083     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1084     __ b(*(op-&gt;label()));
1085   } else {
1086     Assembler::Condition acond;
1087     if (op-&gt;code() == lir_cond_float_branch) {
1088       bool is_unordered = (op-&gt;ublock() == op-&gt;block());
1089       // Assembler::EQ does not permit unordered branches, so we add
1090       // another branch here.  Likewise, Assembler::NE does not permit
1091       // ordered branches.
1092       if ((is_unordered &amp;&amp; op-&gt;cond() == lir_cond_equal)
1093           || (!is_unordered &amp;&amp; op-&gt;cond() == lir_cond_notEqual))
1094         __ br(Assembler::VS, *(op-&gt;ublock()-&gt;label()));
1095       switch(op-&gt;cond()) {
1096       case lir_cond_equal:        acond = Assembler::EQ; break;
1097       case lir_cond_notEqual:     acond = Assembler::NE; break;
1098       case lir_cond_less:         acond = (is_unordered ? Assembler::LT : Assembler::LO); break;
1099       case lir_cond_lessEqual:    acond = (is_unordered ? Assembler::LE : Assembler::LS); break;
1100       case lir_cond_greaterEqual: acond = (is_unordered ? Assembler::HS : Assembler::GE); break;
1101       case lir_cond_greater:      acond = (is_unordered ? Assembler::HI : Assembler::GT); break;
1102       default:                    ShouldNotReachHere();
1103         acond = Assembler::EQ;  // unreachable
1104       }
1105     } else {
1106       switch (op-&gt;cond()) {
1107         case lir_cond_equal:        acond = Assembler::EQ; break;
1108         case lir_cond_notEqual:     acond = Assembler::NE; break;
1109         case lir_cond_less:         acond = Assembler::LT; break;
1110         case lir_cond_lessEqual:    acond = Assembler::LE; break;
1111         case lir_cond_greaterEqual: acond = Assembler::GE; break;
1112         case lir_cond_greater:      acond = Assembler::GT; break;
1113         case lir_cond_belowEqual:   acond = Assembler::LS; break;
1114         case lir_cond_aboveEqual:   acond = Assembler::HS; break;
1115         default:                    ShouldNotReachHere();
1116           acond = Assembler::EQ;  // unreachable
1117       }
1118     }
1119     __ br(acond,*(op-&gt;label()));
1120   }
1121 }
1122 
1123 
1124 
1125 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1126   LIR_Opr src  = op-&gt;in_opr();
1127   LIR_Opr dest = op-&gt;result_opr();
1128 
1129   switch (op-&gt;bytecode()) {
1130     case Bytecodes::_i2f:
1131       {
1132         __ scvtfws(dest-&gt;as_float_reg(), src-&gt;as_register());
1133         break;
1134       }
1135     case Bytecodes::_i2d:
1136       {
1137         __ scvtfwd(dest-&gt;as_double_reg(), src-&gt;as_register());
1138         break;
1139       }
1140     case Bytecodes::_l2d:
1141       {
1142         __ scvtfd(dest-&gt;as_double_reg(), src-&gt;as_register_lo());
1143         break;
1144       }
1145     case Bytecodes::_l2f:
1146       {
1147         __ scvtfs(dest-&gt;as_float_reg(), src-&gt;as_register_lo());
1148         break;
1149       }
1150     case Bytecodes::_f2d:
1151       {
1152         __ fcvts(dest-&gt;as_double_reg(), src-&gt;as_float_reg());
1153         break;
1154       }
1155     case Bytecodes::_d2f:
1156       {
1157         __ fcvtd(dest-&gt;as_float_reg(), src-&gt;as_double_reg());
1158         break;
1159       }
1160     case Bytecodes::_i2c:
1161       {
1162         __ ubfx(dest-&gt;as_register(), src-&gt;as_register(), 0, 16);
1163         break;
1164       }
1165     case Bytecodes::_i2l:
1166       {
1167         __ sxtw(dest-&gt;as_register_lo(), src-&gt;as_register());
1168         break;
1169       }
1170     case Bytecodes::_i2s:
1171       {
1172         __ sxth(dest-&gt;as_register(), src-&gt;as_register());
1173         break;
1174       }
1175     case Bytecodes::_i2b:
1176       {
1177         __ sxtb(dest-&gt;as_register(), src-&gt;as_register());
1178         break;
1179       }
1180     case Bytecodes::_l2i:
1181       {
1182         _masm-&gt;block_comment(&quot;FIXME: This could be a no-op&quot;);
1183         __ uxtw(dest-&gt;as_register(), src-&gt;as_register_lo());
1184         break;
1185       }
1186     case Bytecodes::_d2l:
1187       {
1188         __ fcvtzd(dest-&gt;as_register_lo(), src-&gt;as_double_reg());
1189         break;
1190       }
1191     case Bytecodes::_f2i:
1192       {
1193         __ fcvtzsw(dest-&gt;as_register(), src-&gt;as_float_reg());
1194         break;
1195       }
1196     case Bytecodes::_f2l:
1197       {
1198         __ fcvtzs(dest-&gt;as_register_lo(), src-&gt;as_float_reg());
1199         break;
1200       }
1201     case Bytecodes::_d2i:
1202       {
1203         __ fcvtzdw(dest-&gt;as_register(), src-&gt;as_double_reg());
1204         break;
1205       }
1206     default: ShouldNotReachHere();
1207   }
1208 }
1209 
1210 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1211   if (op-&gt;init_check()) {
1212     __ ldrb(rscratch1, Address(op-&gt;klass()-&gt;as_register(),
1213                                InstanceKlass::init_state_offset()));
1214     __ cmpw(rscratch1, InstanceKlass::fully_initialized);
1215     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1216     __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1217   }
1218   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1219                      op-&gt;tmp1()-&gt;as_register(),
1220                      op-&gt;tmp2()-&gt;as_register(),
1221                      op-&gt;header_size(),
1222                      op-&gt;object_size(),
1223                      op-&gt;klass()-&gt;as_register(),
1224                      *op-&gt;stub()-&gt;entry());
1225   __ bind(*op-&gt;stub()-&gt;continuation());
1226 }
1227 
1228 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1229   Register len =  op-&gt;len()-&gt;as_register();
1230   __ uxtw(len, len);
1231 
1232   if (UseSlowPath ||
1233       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1234       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1235     __ b(*op-&gt;stub()-&gt;entry());
1236   } else {
1237     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1238     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1239     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1240     if (len == tmp1) {
1241       tmp1 = tmp3;
1242     } else if (len == tmp2) {
1243       tmp2 = tmp3;
1244     } else if (len == tmp3) {
1245       // everything is ok
1246     } else {
1247       __ mov(tmp3, len);
1248     }
1249     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1250                       len,
1251                       tmp1,
1252                       tmp2,
1253                       arrayOopDesc::header_size(op-&gt;type()),
1254                       array_element_size(op-&gt;type()),
1255                       op-&gt;klass()-&gt;as_register(),
1256                       *op-&gt;stub()-&gt;entry());
1257   }
1258   __ bind(*op-&gt;stub()-&gt;continuation());
1259 }
1260 
1261 void LIR_Assembler::type_profile_helper(Register mdo,
1262                                         ciMethodData *md, ciProfileData *data,
1263                                         Register recv, Label* update_done) {
1264   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1265     Label next_test;
1266     // See if the receiver is receiver[n].
1267     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1268     __ ldr(rscratch1, Address(rscratch2));
1269     __ cmp(recv, rscratch1);
1270     __ br(Assembler::NE, next_test);
1271     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1272     __ addptr(data_addr, DataLayout::counter_increment);
1273     __ b(*update_done);
1274     __ bind(next_test);
1275   }
1276 
1277   // Didn&#39;t find receiver; find next empty slot and fill it in
1278   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1279     Label next_test;
1280     __ lea(rscratch2,
1281            Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1282     Address recv_addr(rscratch2);
1283     __ ldr(rscratch1, recv_addr);
1284     __ cbnz(rscratch1, next_test);
1285     __ str(recv, recv_addr);
1286     __ mov(rscratch1, DataLayout::counter_increment);
1287     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))));
1288     __ str(rscratch1, Address(rscratch2));
1289     __ b(*update_done);
1290     __ bind(next_test);
1291   }
1292 }
1293 
1294 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1295   // we always need a stub for the failure case.
1296   CodeStub* stub = op-&gt;stub();
1297   Register obj = op-&gt;object()-&gt;as_register();
1298   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1299   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1300   Register dst = op-&gt;result_opr()-&gt;as_register();
1301   ciKlass* k = op-&gt;klass();
1302   Register Rtmp1 = noreg;
1303 
1304   // check if it needs to be profiled
1305   ciMethodData* md;
1306   ciProfileData* data;
1307 
1308   const bool should_profile = op-&gt;should_profile();
1309 
1310   if (should_profile) {
1311     ciMethod* method = op-&gt;profiled_method();
1312     assert(method != NULL, &quot;Should have method&quot;);
1313     int bci = op-&gt;profiled_bci();
1314     md = method-&gt;method_data_or_null();
1315     assert(md != NULL, &quot;Sanity&quot;);
1316     data = md-&gt;bci_to_data(bci);
1317     assert(data != NULL,                &quot;need data for type check&quot;);
1318     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1319   }
1320   Label profile_cast_success, profile_cast_failure;
1321   Label *success_target = should_profile ? &amp;profile_cast_success : success;
1322   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
1323 
1324   if (obj == k_RInfo) {
1325     k_RInfo = dst;
1326   } else if (obj == klass_RInfo) {
1327     klass_RInfo = dst;
1328   }
1329   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1330     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1331   } else {
1332     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1333     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1334   }
1335 
1336   assert_different_registers(obj, k_RInfo, klass_RInfo);
1337 
1338     if (should_profile) {
1339       Label not_null;
1340       __ cbnz(obj, not_null);
1341       // Object is null; update MDO and exit
1342       Register mdo  = klass_RInfo;
1343       __ mov_metadata(mdo, md-&gt;constant_encoding());
1344       Address data_addr
1345         = __ form_address(rscratch2, mdo,
1346                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1347                           0);
1348       __ ldrb(rscratch1, data_addr);
1349       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1350       __ strb(rscratch1, data_addr);
1351       __ b(*obj_is_null);
1352       __ bind(not_null);
1353     } else {
1354       __ cbz(obj, *obj_is_null);
1355     }
1356 
1357   if (!k-&gt;is_loaded()) {
1358     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1359   } else {
1360     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1361   }
1362   __ verify_oop(obj);
1363 
1364   if (op-&gt;fast_check()) {
1365     // get object class
1366     // not a safepoint as obj null check happens earlier
1367     __ load_klass(rscratch1, obj);
1368     __ cmp( rscratch1, k_RInfo);
1369 
1370     __ br(Assembler::NE, *failure_target);
1371     // successful cast, fall through to profile or jump
1372   } else {
1373     // get object class
1374     // not a safepoint as obj null check happens earlier
1375     __ load_klass(klass_RInfo, obj);
1376     if (k-&gt;is_loaded()) {
1377       // See if we get an immediate positive hit
1378       __ ldr(rscratch1, Address(klass_RInfo, int64_t(k-&gt;super_check_offset())));
1379       __ cmp(k_RInfo, rscratch1);
1380       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1381         __ br(Assembler::NE, *failure_target);
1382         // successful cast, fall through to profile or jump
1383       } else {
1384         // See if we get an immediate positive hit
1385         __ br(Assembler::EQ, *success_target);
1386         // check for self
1387         __ cmp(klass_RInfo, k_RInfo);
1388         __ br(Assembler::EQ, *success_target);
1389 
1390         __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1391         __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1392         __ ldr(klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1393         // result is a boolean
1394         __ cbzw(klass_RInfo, *failure_target);
1395         // successful cast, fall through to profile or jump
1396       }
1397     } else {
1398       // perform the fast part of the checking logic
1399       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1400       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1401       __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1402       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1403       __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1404       // result is a boolean
1405       __ cbz(k_RInfo, *failure_target);
1406       // successful cast, fall through to profile or jump
1407     }
1408   }
1409   if (should_profile) {
1410     Register mdo  = klass_RInfo, recv = k_RInfo;
1411     __ bind(profile_cast_success);
1412     __ mov_metadata(mdo, md-&gt;constant_encoding());
1413     __ load_klass(recv, obj);
1414     Label update_done;
1415     type_profile_helper(mdo, md, data, recv, success);
1416     __ b(*success);
1417 
1418     __ bind(profile_cast_failure);
1419     __ mov_metadata(mdo, md-&gt;constant_encoding());
1420     Address counter_addr
1421       = __ form_address(rscratch2, mdo,
1422                         md-&gt;byte_offset_of_slot(data, CounterData::count_offset()),
1423                         0);
1424     __ ldr(rscratch1, counter_addr);
1425     __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1426     __ str(rscratch1, counter_addr);
1427     __ b(*failure);
1428   }
1429   __ b(*success);
1430 }
1431 
1432 
1433 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1434   const bool should_profile = op-&gt;should_profile();
1435 
1436   LIR_Code code = op-&gt;code();
1437   if (code == lir_store_check) {
1438     Register value = op-&gt;object()-&gt;as_register();
1439     Register array = op-&gt;array()-&gt;as_register();
1440     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1441     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1442     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1443 
1444     CodeStub* stub = op-&gt;stub();
1445 
1446     // check if it needs to be profiled
1447     ciMethodData* md;
1448     ciProfileData* data;
1449 
1450     if (should_profile) {
1451       ciMethod* method = op-&gt;profiled_method();
1452       assert(method != NULL, &quot;Should have method&quot;);
1453       int bci = op-&gt;profiled_bci();
1454       md = method-&gt;method_data_or_null();
1455       assert(md != NULL, &quot;Sanity&quot;);
1456       data = md-&gt;bci_to_data(bci);
1457       assert(data != NULL,                &quot;need data for type check&quot;);
1458       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1459     }
1460     Label profile_cast_success, profile_cast_failure, done;
1461     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
1462     Label *failure_target = should_profile ? &amp;profile_cast_failure : stub-&gt;entry();
1463 
1464     if (should_profile) {
1465       Label not_null;
1466       __ cbnz(value, not_null);
1467       // Object is null; update MDO and exit
1468       Register mdo  = klass_RInfo;
1469       __ mov_metadata(mdo, md-&gt;constant_encoding());
1470       Address data_addr
1471         = __ form_address(rscratch2, mdo,
1472                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1473                           0);
1474       __ ldrb(rscratch1, data_addr);
1475       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1476       __ strb(rscratch1, data_addr);
1477       __ b(done);
1478       __ bind(not_null);
1479     } else {
1480       __ cbz(value, done);
1481     }
1482 
1483     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1484     __ load_klass(k_RInfo, array);
1485     __ load_klass(klass_RInfo, value);
1486 
1487     // get instance klass (it&#39;s already uncompressed)
1488     __ ldr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1489     // perform the fast part of the checking logic
1490     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1491     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1492     __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1493     __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1494     __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1495     // result is a boolean
1496     __ cbzw(k_RInfo, *failure_target);
1497     // fall through to the success case
1498 
1499     if (should_profile) {
1500       Register mdo  = klass_RInfo, recv = k_RInfo;
1501       __ bind(profile_cast_success);
1502       __ mov_metadata(mdo, md-&gt;constant_encoding());
1503       __ load_klass(recv, value);
1504       Label update_done;
1505       type_profile_helper(mdo, md, data, recv, &amp;done);
1506       __ b(done);
1507 
1508       __ bind(profile_cast_failure);
1509       __ mov_metadata(mdo, md-&gt;constant_encoding());
1510       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1511       __ lea(rscratch2, counter_addr);
1512       __ ldr(rscratch1, Address(rscratch2));
1513       __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1514       __ str(rscratch1, Address(rscratch2));
1515       __ b(*stub-&gt;entry());
1516     }
1517 
1518     __ bind(done);
1519   } else if (code == lir_checkcast) {
1520     Register obj = op-&gt;object()-&gt;as_register();
1521     Register dst = op-&gt;result_opr()-&gt;as_register();
1522     Label success;
1523     emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1524     __ bind(success);
1525     if (dst != obj) {
1526       __ mov(dst, obj);
1527     }
1528   } else if (code == lir_instanceof) {
1529     Register obj = op-&gt;object()-&gt;as_register();
1530     Register dst = op-&gt;result_opr()-&gt;as_register();
1531     Label success, failure, done;
1532     emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1533     __ bind(failure);
1534     __ mov(dst, zr);
1535     __ b(done);
1536     __ bind(success);
1537     __ mov(dst, 1);
1538     __ bind(done);
1539   } else {
1540     ShouldNotReachHere();
1541   }
1542 }
1543 
1544 void LIR_Assembler::casw(Register addr, Register newval, Register cmpval) {
1545   __ cmpxchg(addr, cmpval, newval, Assembler::word, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1546   __ cset(rscratch1, Assembler::NE);
1547   __ membar(__ AnyAny);
1548 }
1549 
1550 void LIR_Assembler::casl(Register addr, Register newval, Register cmpval) {
1551   __ cmpxchg(addr, cmpval, newval, Assembler::xword, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1552   __ cset(rscratch1, Assembler::NE);
1553   __ membar(__ AnyAny);
1554 }
1555 
1556 
1557 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1558   assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
1559   Register addr;
1560   if (op-&gt;addr()-&gt;is_register()) {
1561     addr = as_reg(op-&gt;addr());
1562   } else {
1563     assert(op-&gt;addr()-&gt;is_address(), &quot;what else?&quot;);
1564     LIR_Address* addr_ptr = op-&gt;addr()-&gt;as_address_ptr();
1565     assert(addr_ptr-&gt;disp() == 0, &quot;need 0 disp&quot;);
1566     assert(addr_ptr-&gt;index() == LIR_OprDesc::illegalOpr(), &quot;need 0 index&quot;);
1567     addr = as_reg(addr_ptr-&gt;base());
1568   }
1569   Register newval = as_reg(op-&gt;new_value());
1570   Register cmpval = as_reg(op-&gt;cmp_value());
1571 
1572   if (op-&gt;code() == lir_cas_obj) {
1573     if (UseCompressedOops) {
1574       Register t1 = op-&gt;tmp1()-&gt;as_register();
1575       assert(op-&gt;tmp1()-&gt;is_valid(), &quot;must be&quot;);
1576       __ encode_heap_oop(t1, cmpval);
1577       cmpval = t1;
1578       __ encode_heap_oop(rscratch2, newval);
1579       newval = rscratch2;
1580       casw(addr, newval, cmpval);
1581     } else {
1582       casl(addr, newval, cmpval);
1583     }
1584   } else if (op-&gt;code() == lir_cas_int) {
1585     casw(addr, newval, cmpval);
1586   } else {
1587     casl(addr, newval, cmpval);
1588   }
1589 }
1590 
1591 
1592 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1593 
1594   Assembler::Condition acond, ncond;
1595   switch (condition) {
1596   case lir_cond_equal:        acond = Assembler::EQ; ncond = Assembler::NE; break;
1597   case lir_cond_notEqual:     acond = Assembler::NE; ncond = Assembler::EQ; break;
1598   case lir_cond_less:         acond = Assembler::LT; ncond = Assembler::GE; break;
1599   case lir_cond_lessEqual:    acond = Assembler::LE; ncond = Assembler::GT; break;
1600   case lir_cond_greaterEqual: acond = Assembler::GE; ncond = Assembler::LT; break;
1601   case lir_cond_greater:      acond = Assembler::GT; ncond = Assembler::LE; break;
1602   case lir_cond_belowEqual:
1603   case lir_cond_aboveEqual:
1604   default:                    ShouldNotReachHere();
1605     acond = Assembler::EQ; ncond = Assembler::NE;  // unreachable
1606   }
1607 
1608   assert(result-&gt;is_single_cpu() || result-&gt;is_double_cpu(),
1609          &quot;expect single register for result&quot;);
1610   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1611       &amp;&amp; opr1-&gt;type() == T_INT &amp;&amp; opr2-&gt;type() == T_INT) {
1612     jint val1 = opr1-&gt;as_jint();
1613     jint val2 = opr2-&gt;as_jint();
1614     if (val1 == 0 &amp;&amp; val2 == 1) {
1615       __ cset(result-&gt;as_register(), ncond);
1616       return;
1617     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1618       __ cset(result-&gt;as_register(), acond);
1619       return;
1620     }
1621   }
1622 
1623   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1624       &amp;&amp; opr1-&gt;type() == T_LONG &amp;&amp; opr2-&gt;type() == T_LONG) {
1625     jlong val1 = opr1-&gt;as_jlong();
1626     jlong val2 = opr2-&gt;as_jlong();
1627     if (val1 == 0 &amp;&amp; val2 == 1) {
1628       __ cset(result-&gt;as_register_lo(), ncond);
1629       return;
1630     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1631       __ cset(result-&gt;as_register_lo(), acond);
1632       return;
1633     }
1634   }
1635 
1636   if (opr1-&gt;is_stack()) {
1637     stack2reg(opr1, FrameMap::rscratch1_opr, result-&gt;type());
1638     opr1 = FrameMap::rscratch1_opr;
1639   } else if (opr1-&gt;is_constant()) {
1640     LIR_Opr tmp
1641       = opr1-&gt;type() == T_LONG ? FrameMap::rscratch1_long_opr : FrameMap::rscratch1_opr;
1642     const2reg(opr1, tmp, lir_patch_none, NULL);
1643     opr1 = tmp;
1644   }
1645 
1646   if (opr2-&gt;is_stack()) {
1647     stack2reg(opr2, FrameMap::rscratch2_opr, result-&gt;type());
1648     opr2 = FrameMap::rscratch2_opr;
1649   } else if (opr2-&gt;is_constant()) {
1650     LIR_Opr tmp
1651       = opr2-&gt;type() == T_LONG ? FrameMap::rscratch2_long_opr : FrameMap::rscratch2_opr;
1652     const2reg(opr2, tmp, lir_patch_none, NULL);
1653     opr2 = tmp;
1654   }
1655 
1656   if (result-&gt;type() == T_LONG)
1657     __ csel(result-&gt;as_register_lo(), opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo(), acond);
1658   else
1659     __ csel(result-&gt;as_register(), opr1-&gt;as_register(), opr2-&gt;as_register(), acond);
1660 }
1661 
1662 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
1663   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
1664 
1665   if (left-&gt;is_single_cpu()) {
1666     Register lreg = left-&gt;as_register();
1667     Register dreg = as_reg(dest);
1668 
1669     if (right-&gt;is_single_cpu()) {
1670       // cpu register - cpu register
1671 
1672       assert(left-&gt;type() == T_INT &amp;&amp; right-&gt;type() == T_INT &amp;&amp; dest-&gt;type() == T_INT,
1673              &quot;should be&quot;);
1674       Register rreg = right-&gt;as_register();
1675       switch (code) {
1676       case lir_add: __ addw (dest-&gt;as_register(), lreg, rreg); break;
1677       case lir_sub: __ subw (dest-&gt;as_register(), lreg, rreg); break;
1678       case lir_mul: __ mulw (dest-&gt;as_register(), lreg, rreg); break;
1679       default:      ShouldNotReachHere();
1680       }
1681 
1682     } else if (right-&gt;is_double_cpu()) {
1683       Register rreg = right-&gt;as_register_lo();
1684       // single_cpu + double_cpu: can happen with obj+long
1685       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1686       switch (code) {
1687       case lir_add: __ add(dreg, lreg, rreg); break;
1688       case lir_sub: __ sub(dreg, lreg, rreg); break;
1689       default: ShouldNotReachHere();
1690       }
1691     } else if (right-&gt;is_constant()) {
1692       // cpu register - constant
1693       jlong c;
1694 
1695       // FIXME.  This is fugly: we really need to factor all this logic.
1696       switch(right-&gt;type()) {
1697       case T_LONG:
1698         c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1699         break;
1700       case T_INT:
1701       case T_ADDRESS:
1702         c = right-&gt;as_constant_ptr()-&gt;as_jint();
1703         break;
1704       default:
1705         ShouldNotReachHere();
1706         c = 0;  // unreachable
1707         break;
1708       }
1709 
1710       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1711       if (c == 0 &amp;&amp; dreg == lreg) {
1712         COMMENT(&quot;effective nop elided&quot;);
1713         return;
1714       }
1715       switch(left-&gt;type()) {
1716       case T_INT:
1717         switch (code) {
1718         case lir_add: __ addw(dreg, lreg, c); break;
1719         case lir_sub: __ subw(dreg, lreg, c); break;
1720         default: ShouldNotReachHere();
1721         }
1722         break;
1723       case T_OBJECT:
1724       case T_ADDRESS:
1725         switch (code) {
1726         case lir_add: __ add(dreg, lreg, c); break;
1727         case lir_sub: __ sub(dreg, lreg, c); break;
1728         default: ShouldNotReachHere();
1729         }
1730         break;
1731       default:
1732         ShouldNotReachHere();
1733       }
1734     } else {
1735       ShouldNotReachHere();
1736     }
1737 
1738   } else if (left-&gt;is_double_cpu()) {
1739     Register lreg_lo = left-&gt;as_register_lo();
1740 
1741     if (right-&gt;is_double_cpu()) {
1742       // cpu register - cpu register
1743       Register rreg_lo = right-&gt;as_register_lo();
1744       switch (code) {
1745       case lir_add: __ add (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1746       case lir_sub: __ sub (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1747       case lir_mul: __ mul (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1748       case lir_div: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, false, rscratch1); break;
1749       case lir_rem: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, true, rscratch1); break;
1750       default:
1751         ShouldNotReachHere();
1752       }
1753 
1754     } else if (right-&gt;is_constant()) {
1755       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1756       Register dreg = as_reg(dest);
1757       switch (code) {
1758         case lir_add:
1759         case lir_sub:
1760           if (c == 0 &amp;&amp; dreg == lreg_lo) {
1761             COMMENT(&quot;effective nop elided&quot;);
1762             return;
1763           }
1764           code == lir_add ? __ add(dreg, lreg_lo, c) : __ sub(dreg, lreg_lo, c);
1765           break;
1766         case lir_div:
1767           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1768           if (c == 1) {
1769             // move lreg_lo to dreg if divisor is 1
1770             __ mov(dreg, lreg_lo);
1771           } else {
1772             unsigned int shift = exact_log2_long(c);
1773             // use rscratch1 as intermediate result register
1774             __ asr(rscratch1, lreg_lo, 63);
1775             __ add(rscratch1, lreg_lo, rscratch1, Assembler::LSR, 64 - shift);
1776             __ asr(dreg, rscratch1, shift);
1777           }
1778           break;
1779         case lir_rem:
1780           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1781           if (c == 1) {
1782             // move 0 to dreg if divisor is 1
1783             __ mov(dreg, zr);
1784           } else {
1785             // use rscratch1 as intermediate result register
1786             __ negs(rscratch1, lreg_lo);
1787             __ andr(dreg, lreg_lo, c - 1);
1788             __ andr(rscratch1, rscratch1, c - 1);
1789             __ csneg(dreg, dreg, rscratch1, Assembler::MI);
1790           }
1791           break;
1792         default:
1793           ShouldNotReachHere();
1794       }
1795     } else {
1796       ShouldNotReachHere();
1797     }
1798   } else if (left-&gt;is_single_fpu()) {
1799     assert(right-&gt;is_single_fpu(), &quot;right hand side of float arithmetics needs to be float register&quot;);
1800     switch (code) {
1801     case lir_add: __ fadds (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1802     case lir_sub: __ fsubs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1803     case lir_mul_strictfp: // fall through
1804     case lir_mul: __ fmuls (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1805     case lir_div_strictfp: // fall through
1806     case lir_div: __ fdivs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1807     default:
1808       ShouldNotReachHere();
1809     }
1810   } else if (left-&gt;is_double_fpu()) {
1811     if (right-&gt;is_double_fpu()) {
1812       // fpu register - fpu register
1813       switch (code) {
1814       case lir_add: __ faddd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1815       case lir_sub: __ fsubd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1816       case lir_mul_strictfp: // fall through
1817       case lir_mul: __ fmuld (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1818       case lir_div_strictfp: // fall through
1819       case lir_div: __ fdivd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1820       default:
1821         ShouldNotReachHere();
1822       }
1823     } else {
1824       if (right-&gt;is_constant()) {
1825         ShouldNotReachHere();
1826       }
1827       ShouldNotReachHere();
1828     }
1829   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
1830     assert(left == dest, &quot;left and dest must be equal&quot;);
1831     ShouldNotReachHere();
1832   } else {
1833     ShouldNotReachHere();
1834   }
1835 }
1836 
1837 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) { Unimplemented(); }
1838 
1839 
1840 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {
1841   switch(code) {
1842   case lir_abs : __ fabsd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1843   case lir_sqrt: __ fsqrtd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1844   default      : ShouldNotReachHere();
1845   }
1846 }
1847 
1848 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
1849 
1850   assert(left-&gt;is_single_cpu() || left-&gt;is_double_cpu(), &quot;expect single or double register&quot;);
1851   Register Rleft = left-&gt;is_single_cpu() ? left-&gt;as_register() :
1852                                            left-&gt;as_register_lo();
1853    if (dst-&gt;is_single_cpu()) {
1854      Register Rdst = dst-&gt;as_register();
1855      if (right-&gt;is_constant()) {
1856        switch (code) {
1857          case lir_logic_and: __ andw (Rdst, Rleft, right-&gt;as_jint()); break;
1858          case lir_logic_or:  __ orrw (Rdst, Rleft, right-&gt;as_jint()); break;
1859          case lir_logic_xor: __ eorw (Rdst, Rleft, right-&gt;as_jint()); break;
1860          default: ShouldNotReachHere(); break;
1861        }
1862      } else {
1863        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
1864                                                   right-&gt;as_register_lo();
1865        switch (code) {
1866          case lir_logic_and: __ andw (Rdst, Rleft, Rright); break;
1867          case lir_logic_or:  __ orrw (Rdst, Rleft, Rright); break;
1868          case lir_logic_xor: __ eorw (Rdst, Rleft, Rright); break;
1869          default: ShouldNotReachHere(); break;
1870        }
1871      }
1872    } else {
1873      Register Rdst = dst-&gt;as_register_lo();
1874      if (right-&gt;is_constant()) {
1875        switch (code) {
1876          case lir_logic_and: __ andr (Rdst, Rleft, right-&gt;as_jlong()); break;
1877          case lir_logic_or:  __ orr (Rdst, Rleft, right-&gt;as_jlong()); break;
1878          case lir_logic_xor: __ eor (Rdst, Rleft, right-&gt;as_jlong()); break;
1879          default: ShouldNotReachHere(); break;
1880        }
1881      } else {
1882        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
1883                                                   right-&gt;as_register_lo();
1884        switch (code) {
1885          case lir_logic_and: __ andr (Rdst, Rleft, Rright); break;
1886          case lir_logic_or:  __ orr (Rdst, Rleft, Rright); break;
1887          case lir_logic_xor: __ eor (Rdst, Rleft, Rright); break;
1888          default: ShouldNotReachHere(); break;
1889        }
1890      }
1891    }
1892 }
1893 
1894 
1895 
1896 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr illegal, LIR_Opr result, CodeEmitInfo* info) {
1897 
1898   // opcode check
1899   assert((code == lir_idiv) || (code == lir_irem), &quot;opcode must be idiv or irem&quot;);
1900   bool is_irem = (code == lir_irem);
1901 
1902   // operand check
1903   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
1904   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
1905   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
1906   Register lreg = left-&gt;as_register();
1907   Register dreg = result-&gt;as_register();
1908 
1909   // power-of-2 constant check and codegen
1910   if (right-&gt;is_constant()) {
1911     int c = right-&gt;as_constant_ptr()-&gt;as_jint();
1912     assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1913     if (is_irem) {
1914       if (c == 1) {
1915         // move 0 to dreg if divisor is 1
1916         __ movw(dreg, zr);
1917       } else {
1918         // use rscratch1 as intermediate result register
1919         __ negsw(rscratch1, lreg);
1920         __ andw(dreg, lreg, c - 1);
1921         __ andw(rscratch1, rscratch1, c - 1);
1922         __ csnegw(dreg, dreg, rscratch1, Assembler::MI);
1923       }
1924     } else {
1925       if (c == 1) {
1926         // move lreg to dreg if divisor is 1
1927         __ movw(dreg, lreg);
1928       } else {
1929         unsigned int shift = exact_log2(c);
1930         // use rscratch1 as intermediate result register
1931         __ asrw(rscratch1, lreg, 31);
1932         __ addw(rscratch1, lreg, rscratch1, Assembler::LSR, 32 - shift);
1933         __ asrw(dreg, rscratch1, shift);
1934       }
1935     }
1936   } else {
1937     Register rreg = right-&gt;as_register();
1938     __ corrected_idivl(dreg, lreg, rreg, is_irem, rscratch1);
1939   }
1940 }
1941 
1942 
1943 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1944   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_single_cpu()) {
1945     // tableswitch
1946     Register reg = as_reg(opr2);
1947     struct tableswitch &amp;table = switches[opr1-&gt;as_constant_ptr()-&gt;as_jint()];
1948     __ tableswitch(reg, table._first_key, table._last_key, table._branches, table._after);
1949   } else if (opr1-&gt;is_single_cpu() || opr1-&gt;is_double_cpu()) {
1950     Register reg1 = as_reg(opr1);
1951     if (opr2-&gt;is_single_cpu()) {
1952       // cpu register - cpu register
1953       Register reg2 = opr2-&gt;as_register();
1954       if (is_reference_type(opr1-&gt;type())) {
1955         __ cmpoop(reg1, reg2);
1956       } else {
1957         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
1958         __ cmpw(reg1, reg2);
1959       }
1960       return;
1961     }
1962     if (opr2-&gt;is_double_cpu()) {
1963       // cpu register - cpu register
1964       Register reg2 = opr2-&gt;as_register_lo();
1965       __ cmp(reg1, reg2);
1966       return;
1967     }
1968 
1969     if (opr2-&gt;is_constant()) {
1970       bool is_32bit = false; // width of register operand
1971       jlong imm;
1972 
1973       switch(opr2-&gt;type()) {
1974       case T_INT:
1975         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1976         is_32bit = true;
1977         break;
1978       case T_LONG:
1979         imm = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
1980         break;
1981       case T_ADDRESS:
1982         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1983         break;
1984       case T_METADATA:
1985         imm = (intptr_t)(opr2-&gt;as_constant_ptr()-&gt;as_metadata());
1986         break;
1987       case T_OBJECT:
1988       case T_ARRAY:
1989         jobject2reg(opr2-&gt;as_constant_ptr()-&gt;as_jobject(), rscratch1);
1990         __ cmpoop(reg1, rscratch1);
1991         return;
1992       default:
1993         ShouldNotReachHere();
1994         imm = 0;  // unreachable
1995         break;
1996       }
1997 
1998       if (Assembler::operand_valid_for_add_sub_immediate(imm)) {
1999         if (is_32bit)
2000           __ cmpw(reg1, imm);
2001         else
2002           __ subs(zr, reg1, imm);
2003         return;
2004       } else {
2005         __ mov(rscratch1, imm);
2006         if (is_32bit)
2007           __ cmpw(reg1, rscratch1);
2008         else
2009           __ cmp(reg1, rscratch1);
2010         return;
2011       }
2012     } else
2013       ShouldNotReachHere();
2014   } else if (opr1-&gt;is_single_fpu()) {
2015     FloatRegister reg1 = opr1-&gt;as_float_reg();
2016     assert(opr2-&gt;is_single_fpu(), &quot;expect single float register&quot;);
2017     FloatRegister reg2 = opr2-&gt;as_float_reg();
2018     __ fcmps(reg1, reg2);
2019   } else if (opr1-&gt;is_double_fpu()) {
2020     FloatRegister reg1 = opr1-&gt;as_double_reg();
2021     assert(opr2-&gt;is_double_fpu(), &quot;expect double float register&quot;);
2022     FloatRegister reg2 = opr2-&gt;as_double_reg();
2023     __ fcmpd(reg1, reg2);
2024   } else {
2025     ShouldNotReachHere();
2026   }
2027 }
2028 
2029 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
2030   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2031     bool is_unordered_less = (code == lir_ucmp_fd2i);
2032     if (left-&gt;is_single_fpu()) {
2033       __ float_cmp(true, is_unordered_less ? -1 : 1, left-&gt;as_float_reg(), right-&gt;as_float_reg(), dst-&gt;as_register());
2034     } else if (left-&gt;is_double_fpu()) {
2035       __ float_cmp(false, is_unordered_less ? -1 : 1, left-&gt;as_double_reg(), right-&gt;as_double_reg(), dst-&gt;as_register());
2036     } else {
2037       ShouldNotReachHere();
2038     }
2039   } else if (code == lir_cmp_l2i) {
2040     Label done;
2041     __ cmp(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2042     __ mov(dst-&gt;as_register(), (uint64_t)-1L);
2043     __ br(Assembler::LT, done);
2044     __ csinc(dst-&gt;as_register(), zr, zr, Assembler::EQ);
2045     __ bind(done);
2046   } else {
2047     ShouldNotReachHere();
2048   }
2049 }
2050 
2051 
2052 void LIR_Assembler::align_call(LIR_Code code) {  }
2053 
2054 
2055 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2056   address call = __ trampoline_call(Address(op-&gt;addr(), rtype));
2057   if (call == NULL) {
2058     bailout(&quot;trampoline stub overflow&quot;);
2059     return;
2060   }
2061   add_call_info(code_offset(), op-&gt;info());
2062 }
2063 
2064 
2065 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2066   address call = __ ic_call(op-&gt;addr());
2067   if (call == NULL) {
2068     bailout(&quot;trampoline stub overflow&quot;);
2069     return;
2070   }
2071   add_call_info(code_offset(), op-&gt;info());
2072 }
2073 
2074 
2075 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2076 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2077   ShouldNotReachHere();
2078 }
2079 
2080 
2081 void LIR_Assembler::emit_static_call_stub() {
2082   address call_pc = __ pc();
2083   address stub = __ start_a_stub(call_stub_size());
2084   if (stub == NULL) {
2085     bailout(&quot;static call stub overflow&quot;);
2086     return;
2087   }
2088 
2089   int start = __ offset();
2090 
2091   __ relocate(static_stub_Relocation::spec(call_pc));
2092   __ emit_static_call_stub();
2093 
2094   assert(__ offset() - start + CompiledStaticCall::to_trampoline_stub_size()
2095         &lt;= call_stub_size(), &quot;stub too big&quot;);
2096   __ end_a_stub();
2097 }
2098 
2099 
2100 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2101   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2102   assert(exceptionPC-&gt;as_register() == r3, &quot;must match&quot;);
2103 
2104   // exception object is not added to oop map by LinearScan
2105   // (LinearScan assumes that no oops are in fixed registers)
2106   info-&gt;add_register_oop(exceptionOop);
2107   Runtime1::StubID unwind_id;
2108 
2109   // get current pc information
2110   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2111   if (compilation()-&gt;debug_info_recorder()-&gt;last_pc_offset() == __ offset()) {
2112     // As no instructions have been generated yet for this LIR node it&#39;s
2113     // possible that an oop map already exists for the current offset.
2114     // In that case insert an dummy NOP here to ensure all oop map PCs
2115     // are unique. See JDK-8237483.
2116     __ nop();
2117   }
2118   int pc_for_athrow_offset = __ offset();
2119   InternalAddress pc_for_athrow(__ pc());
2120   __ adr(exceptionPC-&gt;as_register(), pc_for_athrow);
2121   add_call_info(pc_for_athrow_offset, info); // for exception handler
2122 
2123   __ verify_not_null_oop(r0);
2124   // search an exception handler (r0: exception oop, r3: throwing pc)
2125   if (compilation()-&gt;has_fpu_code()) {
2126     unwind_id = Runtime1::handle_exception_id;
2127   } else {
2128     unwind_id = Runtime1::handle_exception_nofpu_id;
2129   }
2130   __ far_call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2131 
2132   // FIXME: enough room for two byte trap   ????
2133   __ nop();
2134 }
2135 
2136 
2137 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
2138   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2139 
2140   __ b(_unwind_handler_entry);
2141 }
2142 
2143 
2144 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2145   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2146   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2147 
2148   switch (left-&gt;type()) {
2149     case T_INT: {
2150       switch (code) {
2151       case lir_shl:  __ lslvw (dreg, lreg, count-&gt;as_register()); break;
2152       case lir_shr:  __ asrvw (dreg, lreg, count-&gt;as_register()); break;
2153       case lir_ushr: __ lsrvw (dreg, lreg, count-&gt;as_register()); break;
2154       default:
2155         ShouldNotReachHere();
2156         break;
2157       }
2158       break;
2159     case T_LONG:
2160     case T_ADDRESS:
2161     case T_OBJECT:
2162       switch (code) {
2163       case lir_shl:  __ lslv (dreg, lreg, count-&gt;as_register()); break;
2164       case lir_shr:  __ asrv (dreg, lreg, count-&gt;as_register()); break;
2165       case lir_ushr: __ lsrv (dreg, lreg, count-&gt;as_register()); break;
2166       default:
2167         ShouldNotReachHere();
2168         break;
2169       }
2170       break;
2171     default:
2172       ShouldNotReachHere();
2173       break;
2174     }
2175   }
2176 }
2177 
2178 
2179 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2180   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2181   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2182 
2183   switch (left-&gt;type()) {
2184     case T_INT: {
2185       switch (code) {
2186       case lir_shl:  __ lslw (dreg, lreg, count); break;
2187       case lir_shr:  __ asrw (dreg, lreg, count); break;
2188       case lir_ushr: __ lsrw (dreg, lreg, count); break;
2189       default:
2190         ShouldNotReachHere();
2191         break;
2192       }
2193       break;
2194     case T_LONG:
2195     case T_ADDRESS:
2196     case T_OBJECT:
2197       switch (code) {
2198       case lir_shl:  __ lsl (dreg, lreg, count); break;
2199       case lir_shr:  __ asr (dreg, lreg, count); break;
2200       case lir_ushr: __ lsr (dreg, lreg, count); break;
2201       default:
2202         ShouldNotReachHere();
2203         break;
2204       }
2205       break;
2206     default:
2207       ShouldNotReachHere();
2208       break;
2209     }
2210   }
2211 }
2212 
2213 
2214 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
2215   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2216   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2217   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2218   __ str (r, Address(sp, offset_from_rsp_in_bytes));
2219 }
2220 
2221 
2222 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
2223   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2224   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2225   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2226   __ mov (rscratch1, c);
2227   __ str (rscratch1, Address(sp, offset_from_rsp_in_bytes));
2228 }
2229 
2230 
2231 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
2232   ShouldNotReachHere();
2233   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2234   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2235   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2236   __ lea(rscratch1, __ constant_oop_address(o));
2237   __ str(rscratch1, Address(sp, offset_from_rsp_in_bytes));
2238 }
2239 
2240 
2241 // This code replaces a call to arraycopy; no exception may
2242 // be thrown in this code, they must be thrown in the System.arraycopy
2243 // activation frame; we could save some checks if this would not be the case
2244 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
2245   ciArrayKlass* default_type = op-&gt;expected_type();
2246   Register src = op-&gt;src()-&gt;as_register();
2247   Register dst = op-&gt;dst()-&gt;as_register();
2248   Register src_pos = op-&gt;src_pos()-&gt;as_register();
2249   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
2250   Register length  = op-&gt;length()-&gt;as_register();
2251   Register tmp = op-&gt;tmp()-&gt;as_register();
2252 
2253   __ resolve(ACCESS_READ, src);
2254   __ resolve(ACCESS_WRITE, dst);
2255 
2256   CodeStub* stub = op-&gt;stub();
2257   int flags = op-&gt;flags();
2258   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
2259   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
2260 
2261   // if we don&#39;t know anything, just go through the generic arraycopy
2262   if (default_type == NULL // || basic_type == T_OBJECT
2263       ) {
2264     Label done;
2265     assert(src == r1 &amp;&amp; src_pos == r2, &quot;mismatch in calling convention&quot;);
2266 
2267     // Save the arguments in case the generic arraycopy fails and we
2268     // have to fall back to the JNI stub
2269     __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2270     __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2271     __ str(src,              Address(sp, 4*BytesPerWord));
2272 
2273     address copyfunc_addr = StubRoutines::generic_arraycopy();
2274     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
2275 
2276     // The arguments are in java calling convention so we shift them
2277     // to C convention
2278     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
2279     __ mov(c_rarg0, j_rarg0);
2280     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
2281     __ mov(c_rarg1, j_rarg1);
2282     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
2283     __ mov(c_rarg2, j_rarg2);
2284     assert_different_registers(c_rarg3, j_rarg4);
2285     __ mov(c_rarg3, j_rarg3);
2286     __ mov(c_rarg4, j_rarg4);
2287 #ifndef PRODUCT
2288     if (PrintC1Statistics) {
2289       __ incrementw(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
2290     }
2291 #endif
2292     __ far_call(RuntimeAddress(copyfunc_addr));
2293 
2294     __ cbz(r0, *stub-&gt;continuation());
2295 
2296     // Reload values from the stack so they are where the stub
2297     // expects them.
2298     __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2299     __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2300     __ ldr(src,              Address(sp, 4*BytesPerWord));
2301 
2302     // r0 is -1^K where K == partial copied count
2303     __ eonw(rscratch1, r0, zr);
2304     // adjust length down and src/end pos up by partial copied count
2305     __ subw(length, length, rscratch1);
2306     __ addw(src_pos, src_pos, rscratch1);
2307     __ addw(dst_pos, dst_pos, rscratch1);
2308     __ b(*stub-&gt;entry());
2309 
2310     __ bind(*stub-&gt;continuation());
2311     return;
2312   }
2313 
2314   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
2315 
2316   int elem_size = type2aelembytes(basic_type);
2317   int scale = exact_log2(elem_size);
2318 
2319   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
2320   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
2321   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
2322   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
2323 
2324   // test for NULL
2325   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
2326     __ cbz(src, *stub-&gt;entry());
2327   }
2328   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
2329     __ cbz(dst, *stub-&gt;entry());
2330   }
2331 
2332   // If the compiler was not able to prove that exact type of the source or the destination
2333   // of the arraycopy is an array type, check at runtime if the source or the destination is
2334   // an instance type.
2335   if (flags &amp; LIR_OpArrayCopy::type_check) {
2336     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::dst_objarray)) {
2337       __ load_klass(tmp, dst);
2338       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2339       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2340       __ br(Assembler::GE, *stub-&gt;entry());
2341     }
2342 
2343     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::src_objarray)) {
2344       __ load_klass(tmp, src);
2345       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2346       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2347       __ br(Assembler::GE, *stub-&gt;entry());
2348     }
2349   }
2350 
2351   // check if negative
2352   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
2353     __ cmpw(src_pos, 0);
2354     __ br(Assembler::LT, *stub-&gt;entry());
2355   }
2356   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
2357     __ cmpw(dst_pos, 0);
2358     __ br(Assembler::LT, *stub-&gt;entry());
2359   }
2360 
2361   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
2362     __ cmpw(length, 0);
2363     __ br(Assembler::LT, *stub-&gt;entry());
2364   }
2365 
2366   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
2367     __ addw(tmp, src_pos, length);
2368     __ ldrw(rscratch1, src_length_addr);
2369     __ cmpw(tmp, rscratch1);
2370     __ br(Assembler::HI, *stub-&gt;entry());
2371   }
2372   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
2373     __ addw(tmp, dst_pos, length);
2374     __ ldrw(rscratch1, dst_length_addr);
2375     __ cmpw(tmp, rscratch1);
2376     __ br(Assembler::HI, *stub-&gt;entry());
2377   }
2378 
2379   if (flags &amp; LIR_OpArrayCopy::type_check) {
2380     // We don&#39;t know the array types are compatible
2381     if (basic_type != T_OBJECT) {
2382       // Simple test for basic type arrays
2383       if (UseCompressedClassPointers) {
2384         __ ldrw(tmp, src_klass_addr);
2385         __ ldrw(rscratch1, dst_klass_addr);
2386         __ cmpw(tmp, rscratch1);
2387       } else {
2388         __ ldr(tmp, src_klass_addr);
2389         __ ldr(rscratch1, dst_klass_addr);
2390         __ cmp(tmp, rscratch1);
2391       }
2392       __ br(Assembler::NE, *stub-&gt;entry());
2393     } else {
2394       // For object arrays, if src is a sub class of dst then we can
2395       // safely do the copy.
2396       Label cont, slow;
2397 
2398 #define PUSH(r1, r2)                                    \
2399       stp(r1, r2, __ pre(sp, -2 * wordSize));
2400 
2401 #define POP(r1, r2)                                     \
2402       ldp(r1, r2, __ post(sp, 2 * wordSize));
2403 
2404       __ PUSH(src, dst);
2405 
2406       __ load_klass(src, src);
2407       __ load_klass(dst, dst);
2408 
2409       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
2410 
2411       __ PUSH(src, dst);
2412       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
2413       __ POP(src, dst);
2414 
2415       __ cbnz(src, cont);
2416 
2417       __ bind(slow);
2418       __ POP(src, dst);
2419 
2420       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2421       if (copyfunc_addr != NULL) { // use stub if available
2422         // src is not a sub class of dst so we have to do a
2423         // per-element check.
2424 
2425         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2426         if ((flags &amp; mask) != mask) {
2427           // Check that at least both of them object arrays.
2428           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2429 
2430           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2431             __ load_klass(tmp, src);
2432           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2433             __ load_klass(tmp, dst);
2434           }
2435           int lh_offset = in_bytes(Klass::layout_helper_offset());
2436           Address klass_lh_addr(tmp, lh_offset);
2437           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2438           __ ldrw(rscratch1, klass_lh_addr);
2439           __ mov(rscratch2, objArray_lh);
2440           __ eorw(rscratch1, rscratch1, rscratch2);
2441           __ cbnzw(rscratch1, *stub-&gt;entry());
2442         }
2443 
2444        // Spill because stubs can use any register they like and it&#39;s
2445        // easier to restore just those that we care about.
2446         __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2447         __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2448         __ str(src,              Address(sp, 4*BytesPerWord));
2449 
2450         __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2451         __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2452         assert_different_registers(c_rarg0, dst, dst_pos, length);
2453         __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2454         __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2455         assert_different_registers(c_rarg1, dst, length);
2456         __ uxtw(c_rarg2, length);
2457         assert_different_registers(c_rarg2, dst);
2458 
2459         __ load_klass(c_rarg4, dst);
2460         __ ldr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
2461         __ ldrw(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
2462         __ far_call(RuntimeAddress(copyfunc_addr));
2463 
2464 #ifndef PRODUCT
2465         if (PrintC1Statistics) {
2466           Label failed;
2467           __ cbnz(r0, failed);
2468           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
2469           __ bind(failed);
2470         }
2471 #endif
2472 
2473         __ cbz(r0, *stub-&gt;continuation());
2474 
2475 #ifndef PRODUCT
2476         if (PrintC1Statistics) {
2477           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
2478         }
2479 #endif
2480         assert_different_registers(dst, dst_pos, length, src_pos, src, r0, rscratch1);
2481 
2482         // Restore previously spilled arguments
2483         __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2484         __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2485         __ ldr(src,              Address(sp, 4*BytesPerWord));
2486 
2487         // return value is -1^K where K is partial copied count
2488         __ eonw(rscratch1, r0, zr);
2489         // adjust length down and src/end pos up by partial copied count
2490         __ subw(length, length, rscratch1);
2491         __ addw(src_pos, src_pos, rscratch1);
2492         __ addw(dst_pos, dst_pos, rscratch1);
2493       }
2494 
2495       __ b(*stub-&gt;entry());
2496 
2497       __ bind(cont);
2498       __ POP(src, dst);
2499     }
2500   }
2501 
2502 #ifdef ASSERT
2503   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2504     // Sanity check the known type with the incoming class.  For the
2505     // primitive case the types must match exactly with src.klass and
2506     // dst.klass each exactly matching the default type.  For the
2507     // object array case, if no type check is needed then either the
2508     // dst type is exactly the expected type and the src type is a
2509     // subtype which we can&#39;t check or src is the same array as dst
2510     // but not necessarily exactly of type default_type.
2511     Label known_ok, halt;
2512     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
2513     if (UseCompressedClassPointers) {
2514       __ encode_klass_not_null(tmp);
2515     }
2516 
2517     if (basic_type != T_OBJECT) {
2518 
2519       if (UseCompressedClassPointers) {
2520         __ ldrw(rscratch1, dst_klass_addr);
2521         __ cmpw(tmp, rscratch1);
2522       } else {
2523         __ ldr(rscratch1, dst_klass_addr);
2524         __ cmp(tmp, rscratch1);
2525       }
2526       __ br(Assembler::NE, halt);
2527       if (UseCompressedClassPointers) {
2528         __ ldrw(rscratch1, src_klass_addr);
2529         __ cmpw(tmp, rscratch1);
2530       } else {
2531         __ ldr(rscratch1, src_klass_addr);
2532         __ cmp(tmp, rscratch1);
2533       }
2534       __ br(Assembler::EQ, known_ok);
2535     } else {
2536       if (UseCompressedClassPointers) {
2537         __ ldrw(rscratch1, dst_klass_addr);
2538         __ cmpw(tmp, rscratch1);
2539       } else {
2540         __ ldr(rscratch1, dst_klass_addr);
2541         __ cmp(tmp, rscratch1);
2542       }
2543       __ br(Assembler::EQ, known_ok);
2544       __ cmp(src, dst);
2545       __ br(Assembler::EQ, known_ok);
2546     }
2547     __ bind(halt);
2548     __ stop(&quot;incorrect type information in arraycopy&quot;);
2549     __ bind(known_ok);
2550   }
2551 #endif
2552 
2553 #ifndef PRODUCT
2554   if (PrintC1Statistics) {
2555     __ incrementw(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
2556   }
2557 #endif
2558 
2559   __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2560   __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2561   assert_different_registers(c_rarg0, dst, dst_pos, length);
2562   __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2563   __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2564   assert_different_registers(c_rarg1, dst, length);
2565   __ uxtw(c_rarg2, length);
2566   assert_different_registers(c_rarg2, dst);
2567 
2568   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2569   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2570   const char *name;
2571   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2572 
2573  CodeBlob *cb = CodeCache::find_blob(entry);
2574  if (cb) {
2575    __ far_call(RuntimeAddress(entry));
2576  } else {
2577    __ call_VM_leaf(entry, 3);
2578  }
2579 
2580   __ bind(*stub-&gt;continuation());
2581 }
2582 
2583 
2584 
2585 
2586 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2587   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
2588   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2589   Register lock = op-&gt;lock_opr()-&gt;as_register();
2590   if (!UseFastLocking) {
2591     __ b(*op-&gt;stub()-&gt;entry());
2592   } else if (op-&gt;code() == lir_lock) {
2593     Register scratch = noreg;
2594     if (UseBiasedLocking) {
2595       scratch = op-&gt;scratch_opr()-&gt;as_register();
2596     }
2597     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2598     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
2599     // add debug info for NullPointerException only if one is possible
2600     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
2601     if (op-&gt;info() != NULL) {
2602       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
2603     }
2604     // done
2605   } else if (op-&gt;code() == lir_unlock) {
2606     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2607     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2608   } else {
2609     Unimplemented();
2610   }
2611   __ bind(*op-&gt;stub()-&gt;continuation());
2612 }
2613 
2614 
2615 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2616   ciMethod* method = op-&gt;profiled_method();
2617   int bci          = op-&gt;profiled_bci();
2618   ciMethod* callee = op-&gt;profiled_callee();
2619 
2620   // Update counter for all call types
2621   ciMethodData* md = method-&gt;method_data_or_null();
2622   assert(md != NULL, &quot;Sanity&quot;);
2623   ciProfileData* data = md-&gt;bci_to_data(bci);
2624   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2625   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2626   Register mdo  = op-&gt;mdo()-&gt;as_register();
2627   __ mov_metadata(mdo, md-&gt;constant_encoding());
2628   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
2629   // Perform additional virtual call profiling for invokevirtual and
2630   // invokeinterface bytecodes
2631   if (op-&gt;should_profile_receiver_type()) {
2632     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2633     Register recv = op-&gt;recv()-&gt;as_register();
2634     assert_different_registers(mdo, recv);
2635     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2636     ciKlass* known_klass = op-&gt;known_holder();
2637     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2638       // We know the type that will be seen at this call site; we can
2639       // statically update the MethodData* rather than needing to do
2640       // dynamic tests on the receiver type
2641 
2642       // NOTE: we should probably put a lock around this search to
2643       // avoid collisions by concurrent compilations
2644       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2645       uint i;
2646       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2647         ciKlass* receiver = vc_data-&gt;receiver(i);
2648         if (known_klass-&gt;equals(receiver)) {
2649           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2650           __ addptr(data_addr, DataLayout::counter_increment);
2651           return;
2652         }
2653       }
2654 
2655       // Receiver type not found in profile data; select an empty slot
2656 
2657       // Note that this is less efficient than it should be because it
2658       // always does a write to the receiver part of the
2659       // VirtualCallData rather than just the first time
2660       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2661         ciKlass* receiver = vc_data-&gt;receiver(i);
2662         if (receiver == NULL) {
2663           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
2664           __ mov_metadata(rscratch1, known_klass-&gt;constant_encoding());
2665           __ lea(rscratch2, recv_addr);
2666           __ str(rscratch1, Address(rscratch2));
2667           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2668           __ addptr(data_addr, DataLayout::counter_increment);
2669           return;
2670         }
2671       }
2672     } else {
2673       __ load_klass(recv, recv);
2674       Label update_done;
2675       type_profile_helper(mdo, md, data, recv, &amp;update_done);
2676       // Receiver did not match any saved receiver and there is no empty row for it.
2677       // Increment total counter to indicate polymorphic case.
2678       __ addptr(counter_addr, DataLayout::counter_increment);
2679 
2680       __ bind(update_done);
2681     }
2682   } else {
2683     // Static call
2684     __ addptr(counter_addr, DataLayout::counter_increment);
2685   }
2686 }
2687 
2688 
2689 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
2690   Unimplemented();
2691 }
2692 
2693 
2694 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
2695   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
2696 }
2697 
2698 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
2699   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
2700   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
2701   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
2702   Register crc = op-&gt;crc()-&gt;as_register();
2703   Register val = op-&gt;val()-&gt;as_register();
2704   Register res = op-&gt;result_opr()-&gt;as_register();
2705 
2706   assert_different_registers(val, crc, res);
2707   uint64_t offset;
2708   __ adrp(res, ExternalAddress(StubRoutines::crc_table_addr()), offset);
2709   if (offset) __ add(res, res, offset);
2710 
2711   __ mvnw(crc, crc); // ~crc
2712   __ update_byte_crc32(crc, val, res);
2713   __ mvnw(res, crc); // ~crc
2714 }
2715 
2716 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2717   COMMENT(&quot;emit_profile_type {&quot;);
2718   Register obj = op-&gt;obj()-&gt;as_register();
2719   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
2720   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2721   ciKlass* exact_klass = op-&gt;exact_klass();
2722   intptr_t current_klass = op-&gt;current_klass();
2723   bool not_null = op-&gt;not_null();
2724   bool no_conflict = op-&gt;no_conflict();
2725 
2726   Label update, next, none;
2727 
2728   bool do_null = !not_null;
2729   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2730   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2731 
2732   assert(do_null || do_update, &quot;why are we here?&quot;);
2733   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2734   assert(mdo_addr.base() != rscratch1, &quot;wrong register&quot;);
2735 
2736   __ verify_oop(obj);
2737 
2738   if (tmp != obj) {
2739     __ mov(tmp, obj);
2740   }
2741   if (do_null) {
2742     __ cbnz(tmp, update);
2743     if (!TypeEntries::was_null_seen(current_klass)) {
2744       __ ldr(rscratch2, mdo_addr);
2745       __ orr(rscratch2, rscratch2, TypeEntries::null_seen);
2746       __ str(rscratch2, mdo_addr);
2747     }
2748     if (do_update) {
2749 #ifndef ASSERT
2750       __ b(next);
2751     }
2752 #else
2753       __ b(next);
2754     }
2755   } else {
2756     __ cbnz(tmp, update);
2757     __ stop(&quot;unexpected null obj&quot;);
2758 #endif
2759   }
2760 
2761   __ bind(update);
2762 
2763   if (do_update) {
2764 #ifdef ASSERT
2765     if (exact_klass != NULL) {
2766       Label ok;
2767       __ load_klass(tmp, tmp);
2768       __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2769       __ eor(rscratch1, tmp, rscratch1);
2770       __ cbz(rscratch1, ok);
2771       __ stop(&quot;exact klass and actual klass differ&quot;);
2772       __ bind(ok);
2773     }
2774 #endif
2775     if (!no_conflict) {
2776       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
2777         if (exact_klass != NULL) {
2778           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2779         } else {
2780           __ load_klass(tmp, tmp);
2781         }
2782 
2783         __ ldr(rscratch2, mdo_addr);
2784         __ eor(tmp, tmp, rscratch2);
2785         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2786         // klass seen before, nothing to do. The unknown bit may have been
2787         // set already but no need to check.
2788         __ cbz(rscratch1, next);
2789 
2790         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2791 
2792         if (TypeEntries::is_type_none(current_klass)) {
2793           __ cbz(rscratch2, none);
2794           __ cmp(rscratch2, (u1)TypeEntries::null_seen);
2795           __ br(Assembler::EQ, none);
2796           // There is a chance that the checks above (re-reading profiling
2797           // data from memory) fail if another thread has just set the
2798           // profiling to this obj&#39;s klass
2799           __ dmb(Assembler::ISHLD);
2800           __ ldr(rscratch2, mdo_addr);
2801           __ eor(tmp, tmp, rscratch2);
2802           __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2803           __ cbz(rscratch1, next);
2804         }
2805       } else {
2806         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2807                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
2808 
2809         __ ldr(tmp, mdo_addr);
2810         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2811       }
2812 
2813       // different than before. Cannot keep accurate profile.
2814       __ ldr(rscratch2, mdo_addr);
2815       __ orr(rscratch2, rscratch2, TypeEntries::type_unknown);
2816       __ str(rscratch2, mdo_addr);
2817 
2818       if (TypeEntries::is_type_none(current_klass)) {
2819         __ b(next);
2820 
2821         __ bind(none);
2822         // first time here. Set profile type.
2823         __ str(tmp, mdo_addr);
2824       }
2825     } else {
2826       // There&#39;s a single possible klass at this profile point
2827       assert(exact_klass != NULL, &quot;should be&quot;);
2828       if (TypeEntries::is_type_none(current_klass)) {
2829         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2830         __ ldr(rscratch2, mdo_addr);
2831         __ eor(tmp, tmp, rscratch2);
2832         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2833         __ cbz(rscratch1, next);
2834 #ifdef ASSERT
2835         {
2836           Label ok;
2837           __ ldr(rscratch1, mdo_addr);
2838           __ cbz(rscratch1, ok);
2839           __ cmp(rscratch1, (u1)TypeEntries::null_seen);
2840           __ br(Assembler::EQ, ok);
2841           // may have been set by another thread
2842           __ dmb(Assembler::ISHLD);
2843           __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2844           __ ldr(rscratch2, mdo_addr);
2845           __ eor(rscratch2, rscratch1, rscratch2);
2846           __ andr(rscratch2, rscratch2, TypeEntries::type_mask);
2847           __ cbz(rscratch2, ok);
2848 
2849           __ stop(&quot;unexpected profiling mismatch&quot;);
2850           __ bind(ok);
2851         }
2852 #endif
2853         // first time here. Set profile type.
2854         __ ldr(tmp, mdo_addr);
2855       } else {
2856         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2857                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
2858 
2859         __ ldr(tmp, mdo_addr);
2860         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2861 
2862         __ orr(tmp, tmp, TypeEntries::type_unknown);
2863         __ str(tmp, mdo_addr);
2864         // FIXME: Write barrier needed here?
2865       }
2866     }
2867 
2868     __ bind(next);
2869   }
2870   COMMENT(&quot;} emit_profile_type&quot;);
2871 }
2872 
2873 
2874 void LIR_Assembler::align_backward_branch_target() {
2875 }
2876 
2877 
2878 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2879   // tmp must be unused
2880   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2881 
2882   if (left-&gt;is_single_cpu()) {
2883     assert(dest-&gt;is_single_cpu(), &quot;expect single result reg&quot;);
2884     __ negw(dest-&gt;as_register(), left-&gt;as_register());
2885   } else if (left-&gt;is_double_cpu()) {
2886     assert(dest-&gt;is_double_cpu(), &quot;expect double result reg&quot;);
2887     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2888   } else if (left-&gt;is_single_fpu()) {
2889     assert(dest-&gt;is_single_fpu(), &quot;expect single float result reg&quot;);
2890     __ fnegs(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2891   } else {
2892     assert(left-&gt;is_double_fpu(), &quot;expect double float operand reg&quot;);
2893     assert(dest-&gt;is_double_fpu(), &quot;expect double float result reg&quot;);
2894     __ fnegd(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2895   }
2896 }
2897 
2898 
2899 void LIR_Assembler::leal(LIR_Opr addr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2900   if (patch_code != lir_patch_none) {
2901     deoptimize_trap(info);
2902     return;
2903   }
2904 
2905   __ lea(dest-&gt;as_register_lo(), as_Address(addr-&gt;as_address_ptr()));
2906 }
2907 
2908 
2909 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2910   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
2911 
2912   CodeBlob *cb = CodeCache::find_blob(dest);
2913   if (cb) {
2914     __ far_call(RuntimeAddress(dest));
2915   } else {
2916     __ mov(rscratch1, RuntimeAddress(dest));
2917     __ blr(rscratch1);
2918   }
2919 
2920   if (info != NULL) {
2921     add_call_info_here(info);
2922   }
2923   __ maybe_isb();
2924 }
2925 
2926 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2927   if (dest-&gt;is_address() || src-&gt;is_address()) {
2928     move_op(src, dest, type, lir_patch_none, info,
2929             /*pop_fpu_stack*/false, /*unaligned*/false, /*wide*/false);
2930   } else {
2931     ShouldNotReachHere();
2932   }
2933 }
2934 
2935 #ifdef ASSERT
2936 // emit run-time assertion
2937 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2938   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
2939 
2940   if (op-&gt;in_opr1()-&gt;is_valid()) {
2941     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
2942     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
2943   } else {
2944     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
2945     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
2946   }
2947 
2948   Label ok;
2949   if (op-&gt;condition() != lir_cond_always) {
2950     Assembler::Condition acond = Assembler::AL;
2951     switch (op-&gt;condition()) {
2952       case lir_cond_equal:        acond = Assembler::EQ;  break;
2953       case lir_cond_notEqual:     acond = Assembler::NE;  break;
2954       case lir_cond_less:         acond = Assembler::LT;  break;
2955       case lir_cond_lessEqual:    acond = Assembler::LE;  break;
2956       case lir_cond_greaterEqual: acond = Assembler::GE;  break;
2957       case lir_cond_greater:      acond = Assembler::GT;  break;
2958       case lir_cond_belowEqual:   acond = Assembler::LS;  break;
2959       case lir_cond_aboveEqual:   acond = Assembler::HS;  break;
2960       default:                    ShouldNotReachHere();
2961     }
2962     __ br(acond, ok);
2963   }
2964   if (op-&gt;halt()) {
2965     const char* str = __ code_string(op-&gt;msg());
2966     __ stop(str);
2967   } else {
2968     breakpoint();
2969   }
2970   __ bind(ok);
2971 }
2972 #endif
2973 
2974 #ifndef PRODUCT
2975 #define COMMENT(x)   do { __ block_comment(x); } while (0)
2976 #else
2977 #define COMMENT(x)
2978 #endif
2979 
2980 void LIR_Assembler::membar() {
2981   COMMENT(&quot;membar&quot;);
2982   __ membar(MacroAssembler::AnyAny);
2983 }
2984 
2985 void LIR_Assembler::membar_acquire() {
2986   __ membar(Assembler::LoadLoad|Assembler::LoadStore);
2987 }
2988 
2989 void LIR_Assembler::membar_release() {
2990   __ membar(Assembler::LoadStore|Assembler::StoreStore);
2991 }
2992 
2993 void LIR_Assembler::membar_loadload() {
2994   __ membar(Assembler::LoadLoad);
2995 }
2996 
2997 void LIR_Assembler::membar_storestore() {
2998   __ membar(MacroAssembler::StoreStore);
2999 }
3000 
3001 void LIR_Assembler::membar_loadstore() { __ membar(MacroAssembler::LoadStore); }
3002 
3003 void LIR_Assembler::membar_storeload() { __ membar(MacroAssembler::StoreLoad); }
3004 
3005 void LIR_Assembler::on_spin_wait() {
3006   Unimplemented();
3007 }
3008 
3009 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
3010   __ mov(result_reg-&gt;as_register(), rthread);
3011 }
3012 
3013 
3014 void LIR_Assembler::peephole(LIR_List *lir) {
3015 #if 0
3016   if (tableswitch_count &gt;= max_tableswitches)
3017     return;
3018 
3019   /*
3020     This finite-state automaton recognizes sequences of compare-and-
3021     branch instructions.  We will turn them into a tableswitch.  You
3022     could argue that C1 really shouldn&#39;t be doing this sort of
3023     optimization, but without it the code is really horrible.
3024   */
3025 
3026   enum { start_s, cmp1_s, beq_s, cmp_s } state;
3027   int first_key, last_key = -2147483648;
3028   int next_key = 0;
3029   int start_insn = -1;
3030   int last_insn = -1;
3031   Register reg = noreg;
3032   LIR_Opr reg_opr;
3033   state = start_s;
3034 
3035   LIR_OpList* inst = lir-&gt;instructions_list();
3036   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3037     LIR_Op* op = inst-&gt;at(i);
3038     switch (state) {
3039     case start_s:
3040       first_key = -1;
3041       start_insn = i;
3042       switch (op-&gt;code()) {
3043       case lir_cmp:
3044         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3045         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3046         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3047             &amp;&amp; opr2-&gt;is_constant()
3048             &amp;&amp; opr2-&gt;type() == T_INT) {
3049           reg_opr = opr1;
3050           reg = opr1-&gt;as_register();
3051           first_key = opr2-&gt;as_constant_ptr()-&gt;as_jint();
3052           next_key = first_key + 1;
3053           state = cmp_s;
3054           goto next_state;
3055         }
3056         break;
3057       }
3058       break;
3059     case cmp_s:
3060       switch (op-&gt;code()) {
3061       case lir_branch:
3062         if (op-&gt;as_OpBranch()-&gt;cond() == lir_cond_equal) {
3063           state = beq_s;
3064           last_insn = i;
3065           goto next_state;
3066         }
3067       }
3068       state = start_s;
3069       break;
3070     case beq_s:
3071       switch (op-&gt;code()) {
3072       case lir_cmp: {
3073         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3074         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3075         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3076             &amp;&amp; opr1-&gt;as_register() == reg
3077             &amp;&amp; opr2-&gt;is_constant()
3078             &amp;&amp; opr2-&gt;type() == T_INT
3079             &amp;&amp; opr2-&gt;as_constant_ptr()-&gt;as_jint() == next_key) {
3080           last_key = next_key;
3081           next_key++;
3082           state = cmp_s;
3083           goto next_state;
3084         }
3085       }
3086       }
3087       last_key = next_key;
3088       state = start_s;
3089       break;
3090     default:
3091       assert(false, &quot;impossible state&quot;);
3092     }
3093     if (state == start_s) {
3094       if (first_key &lt; last_key - 5L &amp;&amp; reg != noreg) {
3095         {
3096           // printf(&quot;found run register %d starting at insn %d low value %d high value %d\n&quot;,
3097           //        reg-&gt;encoding(),
3098           //        start_insn, first_key, last_key);
3099           //   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3100           //     inst-&gt;at(i)-&gt;print();
3101           //     tty-&gt;print(&quot;\n&quot;);
3102           //   }
3103           //   tty-&gt;print(&quot;\n&quot;);
3104         }
3105 
3106         struct tableswitch *sw = &amp;switches[tableswitch_count];
3107         sw-&gt;_insn_index = start_insn, sw-&gt;_first_key = first_key,
3108           sw-&gt;_last_key = last_key, sw-&gt;_reg = reg;
3109         inst-&gt;insert_before(last_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_after));
3110         {
3111           // Insert the new table of branches
3112           int offset = last_insn;
3113           for (int n = first_key; n &lt; last_key; n++) {
3114             inst-&gt;insert_before
3115               (last_insn + 1,
3116                new LIR_OpBranch(lir_cond_always, T_ILLEGAL,
3117                                 inst-&gt;at(offset)-&gt;as_OpBranch()-&gt;label()));
3118             offset -= 2, i++;
3119           }
3120         }
3121         // Delete all the old compare-and-branch instructions
3122         for (int n = first_key; n &lt; last_key; n++) {
3123           inst-&gt;remove_at(start_insn);
3124           inst-&gt;remove_at(start_insn);
3125         }
3126         // Insert the tableswitch instruction
3127         inst-&gt;insert_before(start_insn,
3128                             new LIR_Op2(lir_cmp, lir_cond_always,
3129                                         LIR_OprFact::intConst(tableswitch_count),
3130                                         reg_opr));
3131         inst-&gt;insert_before(start_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_branches));
3132         tableswitch_count++;
3133       }
3134       reg = noreg;
3135       last_key = -2147483648;
3136     }
3137   next_state:
3138     ;
3139   }
3140 #endif
3141 }
3142 
3143 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
3144   Address addr = as_Address(src-&gt;as_address_ptr());
3145   BasicType type = src-&gt;type();
3146   bool is_oop = is_reference_type(type);
3147 
3148   void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
3149   void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
3150 
3151   switch(type) {
3152   case T_INT:
3153     xchg = &amp;MacroAssembler::atomic_xchgalw;
3154     add = &amp;MacroAssembler::atomic_addalw;
3155     break;
3156   case T_LONG:
3157     xchg = &amp;MacroAssembler::atomic_xchgal;
3158     add = &amp;MacroAssembler::atomic_addal;
3159     break;
3160   case T_OBJECT:
3161   case T_ARRAY:
3162     if (UseCompressedOops) {
3163       xchg = &amp;MacroAssembler::atomic_xchgalw;
3164       add = &amp;MacroAssembler::atomic_addalw;
3165     } else {
3166       xchg = &amp;MacroAssembler::atomic_xchgal;
3167       add = &amp;MacroAssembler::atomic_addal;
3168     }
3169     break;
3170   default:
3171     ShouldNotReachHere();
3172     xchg = &amp;MacroAssembler::atomic_xchgal;
3173     add = &amp;MacroAssembler::atomic_addal; // unreachable
3174   }
3175 
3176   switch (code) {
3177   case lir_xadd:
3178     {
3179       RegisterOrConstant inc;
3180       Register tmp = as_reg(tmp_op);
3181       Register dst = as_reg(dest);
3182       if (data-&gt;is_constant()) {
3183         inc = RegisterOrConstant(as_long(data));
3184         assert_different_registers(dst, addr.base(), tmp,
3185                                    rscratch1, rscratch2);
3186       } else {
3187         inc = RegisterOrConstant(as_reg(data));
3188         assert_different_registers(inc.as_register(), dst, addr.base(), tmp,
3189                                    rscratch1, rscratch2);
3190       }
3191       __ lea(tmp, addr);
3192       (_masm-&gt;*add)(dst, inc, tmp);
3193       break;
3194     }
3195   case lir_xchg:
3196     {
3197       Register tmp = tmp_op-&gt;as_register();
3198       Register obj = as_reg(data);
3199       Register dst = as_reg(dest);
3200       if (is_oop &amp;&amp; UseCompressedOops) {
3201         __ encode_heap_oop(rscratch2, obj);
3202         obj = rscratch2;
3203       }
3204       assert_different_registers(obj, addr.base(), tmp, rscratch1, dst);
3205       __ lea(tmp, addr);
3206       (_masm-&gt;*xchg)(dst, obj, tmp);
3207       if (is_oop &amp;&amp; UseCompressedOops) {
3208         __ decode_heap_oop(dst);
3209       }
3210     }
3211     break;
3212   default:
3213     ShouldNotReachHere();
3214   }
3215   __ membar(__ AnyAny);
3216 }
3217 
3218 #undef __
    </pre>
  </body>
</html>