<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/assembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_AARCH64_ASSEMBLER_AARCH64_HPP
  27 #define CPU_AARCH64_ASSEMBLER_AARCH64_HPP
  28 
  29 #include &quot;asm/register.hpp&quot;
  30 
  31 // definitions of various symbolic names for machine registers
  32 
  33 // First intercalls between C and Java which use 8 general registers
  34 // and 8 floating registers
  35 
  36 // we also have to copy between x86 and ARM registers but that&#39;s a
  37 // secondary complication -- not all code employing C call convention
  38 // executes as x86 code though -- we generate some of it
  39 
  40 class Argument {
  41  public:
  42   enum {
  43     n_int_register_parameters_c   = 8,  // r0, r1, ... r7 (c_rarg0, c_rarg1, ...)
  44     n_float_register_parameters_c = 8,  // v0, v1, ... v7 (c_farg0, c_farg1, ... )
  45 
  46     n_int_register_parameters_j   = 8, // r1, ... r7, r0 (rj_rarg0, j_rarg1, ...
  47     n_float_register_parameters_j = 8  // v0, v1, ... v7 (j_farg0, j_farg1, ...
  48   };
  49 };
  50 
  51 REGISTER_DECLARATION(Register, c_rarg0, r0);
  52 REGISTER_DECLARATION(Register, c_rarg1, r1);
  53 REGISTER_DECLARATION(Register, c_rarg2, r2);
  54 REGISTER_DECLARATION(Register, c_rarg3, r3);
  55 REGISTER_DECLARATION(Register, c_rarg4, r4);
  56 REGISTER_DECLARATION(Register, c_rarg5, r5);
  57 REGISTER_DECLARATION(Register, c_rarg6, r6);
  58 REGISTER_DECLARATION(Register, c_rarg7, r7);
  59 
  60 REGISTER_DECLARATION(FloatRegister, c_farg0, v0);
  61 REGISTER_DECLARATION(FloatRegister, c_farg1, v1);
  62 REGISTER_DECLARATION(FloatRegister, c_farg2, v2);
  63 REGISTER_DECLARATION(FloatRegister, c_farg3, v3);
  64 REGISTER_DECLARATION(FloatRegister, c_farg4, v4);
  65 REGISTER_DECLARATION(FloatRegister, c_farg5, v5);
  66 REGISTER_DECLARATION(FloatRegister, c_farg6, v6);
  67 REGISTER_DECLARATION(FloatRegister, c_farg7, v7);
  68 
  69 // Symbolically name the register arguments used by the Java calling convention.
  70 // We have control over the convention for java so we can do what we please.
  71 // What pleases us is to offset the java calling convention so that when
  72 // we call a suitable jni method the arguments are lined up and we don&#39;t
  73 // have to do much shuffling. A suitable jni method is non-static and a
  74 // small number of arguments
  75 //
  76 //  |--------------------------------------------------------------------|
  77 //  | c_rarg0  c_rarg1  c_rarg2 c_rarg3 c_rarg4 c_rarg5 c_rarg6 c_rarg7  |
  78 //  |--------------------------------------------------------------------|
  79 //  | r0       r1       r2      r3      r4      r5      r6      r7       |
  80 //  |--------------------------------------------------------------------|
  81 //  | j_rarg7  j_rarg0  j_rarg1 j_rarg2 j_rarg3 j_rarg4 j_rarg5 j_rarg6  |
  82 //  |--------------------------------------------------------------------|
  83 
  84 
  85 REGISTER_DECLARATION(Register, j_rarg0, c_rarg1);
  86 REGISTER_DECLARATION(Register, j_rarg1, c_rarg2);
  87 REGISTER_DECLARATION(Register, j_rarg2, c_rarg3);
  88 REGISTER_DECLARATION(Register, j_rarg3, c_rarg4);
  89 REGISTER_DECLARATION(Register, j_rarg4, c_rarg5);
  90 REGISTER_DECLARATION(Register, j_rarg5, c_rarg6);
  91 REGISTER_DECLARATION(Register, j_rarg6, c_rarg7);
  92 REGISTER_DECLARATION(Register, j_rarg7, c_rarg0);
  93 
  94 // Java floating args are passed as per C
  95 
  96 REGISTER_DECLARATION(FloatRegister, j_farg0, v0);
  97 REGISTER_DECLARATION(FloatRegister, j_farg1, v1);
  98 REGISTER_DECLARATION(FloatRegister, j_farg2, v2);
  99 REGISTER_DECLARATION(FloatRegister, j_farg3, v3);
 100 REGISTER_DECLARATION(FloatRegister, j_farg4, v4);
 101 REGISTER_DECLARATION(FloatRegister, j_farg5, v5);
 102 REGISTER_DECLARATION(FloatRegister, j_farg6, v6);
 103 REGISTER_DECLARATION(FloatRegister, j_farg7, v7);
 104 
 105 // registers used to hold VM data either temporarily within a method
 106 // or across method calls
 107 
 108 // volatile (caller-save) registers
 109 
 110 // r8 is used for indirect result location return
 111 // we use it and r9 as scratch registers
 112 REGISTER_DECLARATION(Register, rscratch1, r8);
 113 REGISTER_DECLARATION(Register, rscratch2, r9);
 114 
 115 // current method -- must be in a call-clobbered register
 116 REGISTER_DECLARATION(Register, rmethod,   r12);
 117 
 118 // non-volatile (callee-save) registers are r16-29
 119 // of which the following are dedicated global state
 120 
 121 // link register
 122 REGISTER_DECLARATION(Register, lr,        r30);
 123 // frame pointer
 124 REGISTER_DECLARATION(Register, rfp,       r29);
 125 // current thread
 126 REGISTER_DECLARATION(Register, rthread,   r28);
 127 // base of heap
 128 REGISTER_DECLARATION(Register, rheapbase, r27);
 129 // constant pool cache
 130 REGISTER_DECLARATION(Register, rcpool,    r26);
 131 // monitors allocated on stack
 132 REGISTER_DECLARATION(Register, rmonitors, r25);
 133 // locals on stack
 134 REGISTER_DECLARATION(Register, rlocals,   r24);
 135 // bytecode pointer
 136 REGISTER_DECLARATION(Register, rbcp,      r22);
 137 // Dispatch table base
 138 REGISTER_DECLARATION(Register, rdispatch, r21);
 139 // Java stack pointer
 140 REGISTER_DECLARATION(Register, esp,      r20);
 141 
 142 #define assert_cond(ARG1) assert(ARG1, #ARG1)
 143 
 144 namespace asm_util {
 145   uint32_t encode_logical_immediate(bool is32, uint64_t imm);
 146 };
 147 
 148 using namespace asm_util;
 149 
 150 
 151 class Assembler;
 152 
 153 class Instruction_aarch64 {
 154   unsigned insn;
 155 #ifdef ASSERT
 156   unsigned bits;
 157 #endif
 158   Assembler *assem;
 159 
 160 public:
 161 
 162   Instruction_aarch64(class Assembler *as) {
 163 #ifdef ASSERT
 164     bits = 0;
 165 #endif
 166     insn = 0;
 167     assem = as;
 168   }
 169 
 170   inline ~Instruction_aarch64();
 171 
 172   unsigned &amp;get_insn() { return insn; }
 173 #ifdef ASSERT
 174   unsigned &amp;get_bits() { return bits; }
 175 #endif
 176 
 177   static inline int32_t extend(unsigned val, int hi = 31, int lo = 0) {
 178     union {
 179       unsigned u;
 180       int n;
 181     };
 182 
 183     u = val &lt;&lt; (31 - hi);
 184     n = n &gt;&gt; (31 - hi + lo);
 185     return n;
 186   }
 187 
 188   static inline uint32_t extract(uint32_t val, int msb, int lsb) {
 189     int nbits = msb - lsb + 1;
 190     assert_cond(msb &gt;= lsb);
 191     uint32_t mask = (1U &lt;&lt; nbits) - 1;
 192     uint32_t result = val &gt;&gt; lsb;
 193     result &amp;= mask;
 194     return result;
 195   }
 196 
 197   static inline int32_t sextract(uint32_t val, int msb, int lsb) {
 198     uint32_t uval = extract(val, msb, lsb);
 199     return extend(uval, msb - lsb);
 200   }
 201 
 202   static void patch(address a, int msb, int lsb, uint64_t val) {
 203     int nbits = msb - lsb + 1;
 204     guarantee(val &lt; (1U &lt;&lt; nbits), &quot;Field too big for insn&quot;);
 205     assert_cond(msb &gt;= lsb);
 206     unsigned mask = (1U &lt;&lt; nbits) - 1;
 207     val &lt;&lt;= lsb;
 208     mask &lt;&lt;= lsb;
 209     unsigned target = *(unsigned *)a;
 210     target &amp;= ~mask;
 211     target |= val;
 212     *(unsigned *)a = target;
 213   }
 214 
 215   static void spatch(address a, int msb, int lsb, int64_t val) {
 216     int nbits = msb - lsb + 1;
 217     int64_t chk = val &gt;&gt; (nbits - 1);
 218     guarantee (chk == -1 || chk == 0, &quot;Field too big for insn&quot;);
 219     unsigned uval = val;
 220     unsigned mask = (1U &lt;&lt; nbits) - 1;
 221     uval &amp;= mask;
 222     uval &lt;&lt;= lsb;
 223     mask &lt;&lt;= lsb;
 224     unsigned target = *(unsigned *)a;
 225     target &amp;= ~mask;
 226     target |= uval;
 227     *(unsigned *)a = target;
 228   }
 229 
 230   void f(unsigned val, int msb, int lsb) {
 231     int nbits = msb - lsb + 1;
 232     guarantee(val &lt; (1U &lt;&lt; nbits), &quot;Field too big for insn&quot;);
 233     assert_cond(msb &gt;= lsb);
 234     unsigned mask = (1U &lt;&lt; nbits) - 1;
 235     val &lt;&lt;= lsb;
 236     mask &lt;&lt;= lsb;
 237     insn |= val;
 238     assert_cond((bits &amp; mask) == 0);
 239 #ifdef ASSERT
 240     bits |= mask;
 241 #endif
 242   }
 243 
 244   void f(unsigned val, int bit) {
 245     f(val, bit, bit);
 246   }
 247 
 248   void sf(int64_t val, int msb, int lsb) {
 249     int nbits = msb - lsb + 1;
 250     int64_t chk = val &gt;&gt; (nbits - 1);
 251     guarantee (chk == -1 || chk == 0, &quot;Field too big for insn&quot;);
 252     unsigned uval = val;
 253     unsigned mask = (1U &lt;&lt; nbits) - 1;
 254     uval &amp;= mask;
 255     f(uval, lsb + nbits - 1, lsb);
 256   }
 257 
 258   void rf(Register r, int lsb) {
 259     f(r-&gt;encoding_nocheck(), lsb + 4, lsb);
 260   }
 261 
 262   // reg|ZR
 263   void zrf(Register r, int lsb) {
 264     f(r-&gt;encoding_nocheck() - (r == zr), lsb + 4, lsb);
 265   }
 266 
 267   // reg|SP
 268   void srf(Register r, int lsb) {
 269     f(r == sp ? 31 : r-&gt;encoding_nocheck(), lsb + 4, lsb);
 270   }
 271 
 272   void rf(FloatRegister r, int lsb) {
 273     f(r-&gt;encoding_nocheck(), lsb + 4, lsb);
 274   }
 275 
 276   unsigned get(int msb = 31, int lsb = 0) {
 277     int nbits = msb - lsb + 1;
 278     unsigned mask = ((1U &lt;&lt; nbits) - 1) &lt;&lt; lsb;
 279     assert_cond((bits &amp; mask) == mask);
 280     return (insn &amp; mask) &gt;&gt; lsb;
 281   }
 282 
 283   void fixed(unsigned value, unsigned mask) {
 284     assert_cond ((mask &amp; bits) == 0);
 285 #ifdef ASSERT
 286     bits |= mask;
 287 #endif
 288     insn |= value;
 289   }
 290 };
 291 
 292 #define starti Instruction_aarch64 do_not_use(this); set_current(&amp;do_not_use)
 293 
 294 class PrePost {
 295   int _offset;
 296   Register _r;
 297 public:
 298   PrePost(Register reg, int o) : _offset(o), _r(reg) { }
 299   int offset() { return _offset; }
 300   Register reg() { return _r; }
 301 };
 302 
 303 class Pre : public PrePost {
 304 public:
 305   Pre(Register reg, int o) : PrePost(reg, o) { }
 306 };
 307 class Post : public PrePost {
 308   Register _idx;
 309   bool _is_postreg;
 310 public:
 311   Post(Register reg, int o) : PrePost(reg, o) { _idx = NULL; _is_postreg = false; }
 312   Post(Register reg, Register idx) : PrePost(reg, 0) { _idx = idx; _is_postreg = true; }
 313   Register idx_reg() { return _idx; }
 314   bool is_postreg() {return _is_postreg; }
 315 };
 316 
 317 namespace ext
 318 {
 319   enum operation { uxtb, uxth, uxtw, uxtx, sxtb, sxth, sxtw, sxtx };
 320 };
 321 
 322 // Addressing modes
 323 class Address {
 324  public:
 325 
 326   enum mode { no_mode, base_plus_offset, pre, post, post_reg, pcrel,
 327               base_plus_offset_reg, literal };
 328 
 329   // Shift and extend for base reg + reg offset addressing
 330   class extend {
 331     int _option, _shift;
 332     ext::operation _op;
 333   public:
 334     extend() { }
 335     extend(int s, int o, ext::operation op) : _option(o), _shift(s), _op(op) { }
 336     int option() const{ return _option; }
 337     int shift() const { return _shift; }
 338     ext::operation op() const { return _op; }
 339   };
 340   class uxtw : public extend {
 341   public:
 342     uxtw(int shift = -1): extend(shift, 0b010, ext::uxtw) { }
 343   };
 344   class lsl : public extend {
 345   public:
 346     lsl(int shift = -1): extend(shift, 0b011, ext::uxtx) { }
 347   };
 348   class sxtw : public extend {
 349   public:
 350     sxtw(int shift = -1): extend(shift, 0b110, ext::sxtw) { }
 351   };
 352   class sxtx : public extend {
 353   public:
 354     sxtx(int shift = -1): extend(shift, 0b111, ext::sxtx) { }
 355   };
 356 
 357  private:
 358   Register _base;
 359   Register _index;
 360   int64_t _offset;
 361   enum mode _mode;
 362   extend _ext;
 363 
 364   RelocationHolder _rspec;
 365 
 366   // Typically we use AddressLiterals we want to use their rval
 367   // However in some situations we want the lval (effect address) of
 368   // the item.  We provide a special factory for making those lvals.
 369   bool _is_lval;
 370 
 371   // If the target is far we&#39;ll need to load the ea of this to a
 372   // register to reach it. Otherwise if near we can do PC-relative
 373   // addressing.
 374   address          _target;
 375 
 376  public:
 377   Address()
 378     : _mode(no_mode) { }
 379   Address(Register r)
 380     : _base(r), _index(noreg), _offset(0), _mode(base_plus_offset), _target(0) { }
 381   Address(Register r, int o)
 382     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 383   Address(Register r, int64_t o)
 384     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 385   Address(Register r, uint64_t o)
 386     : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) { }
 387 #ifdef ASSERT
 388   Address(Register r, ByteSize disp)
 389     : _base(r), _index(noreg), _offset(in_bytes(disp)), _mode(base_plus_offset), _target(0) { }
 390 #endif
 391   Address(Register r, Register r1, extend ext = lsl())
 392     : _base(r), _index(r1), _offset(0), _mode(base_plus_offset_reg),
 393       _ext(ext), _target(0) { }
 394   Address(Pre p)
 395     : _base(p.reg()), _offset(p.offset()), _mode(pre) { }
 396   Address(Post p)
 397     : _base(p.reg()),  _index(p.idx_reg()), _offset(p.offset()),
 398       _mode(p.is_postreg() ? post_reg : post), _target(0) { }
 399   Address(address target, RelocationHolder const&amp; rspec)
 400     : _mode(literal),
 401       _rspec(rspec),
 402       _is_lval(false),
 403       _target(target)  { }
 404   Address(address target, relocInfo::relocType rtype = relocInfo::external_word_type);
 405   Address(Register base, RegisterOrConstant index, extend ext = lsl())
 406     : _base (base),
 407       _offset(0), _ext(ext), _target(0) {
 408     if (index.is_register()) {
 409       _mode = base_plus_offset_reg;
 410       _index = index.as_register();
 411     } else {
 412       guarantee(ext.option() == ext::uxtx, &quot;should be&quot;);
 413       assert(index.is_constant(), &quot;should be&quot;);
 414       _mode = base_plus_offset;
 415       _offset = index.as_constant() &lt;&lt; ext.shift();
 416     }
 417   }
 418 
 419   Register base() const {
 420     guarantee((_mode == base_plus_offset | _mode == base_plus_offset_reg
 421                | _mode == post | _mode == post_reg),
 422               &quot;wrong mode&quot;);
 423     return _base;
 424   }
 425   int64_t offset() const {
 426     return _offset;
 427   }
 428   Register index() const {
 429     return _index;
 430   }
 431   mode getMode() const {
 432     return _mode;
 433   }
 434   bool uses(Register reg) const { return _base == reg || _index == reg; }
 435   address target() const { return _target; }
 436   const RelocationHolder&amp; rspec() const { return _rspec; }
 437 
 438   void encode(Instruction_aarch64 *i) const {
 439     i-&gt;f(0b111, 29, 27);
 440     i-&gt;srf(_base, 5);
 441 
 442     switch(_mode) {
 443     case base_plus_offset:
 444       {
 445         unsigned size = i-&gt;get(31, 30);
 446         if (i-&gt;get(26, 26) &amp;&amp; i-&gt;get(23, 23)) {
 447           // SIMD Q Type - Size = 128 bits
 448           assert(size == 0, &quot;bad size&quot;);
 449           size = 0b100;
 450         }
 451         unsigned mask = (1 &lt;&lt; size) - 1;
 452         if (_offset &lt; 0 || _offset &amp; mask)
 453           {
 454             i-&gt;f(0b00, 25, 24);
 455             i-&gt;f(0, 21), i-&gt;f(0b00, 11, 10);
 456             i-&gt;sf(_offset, 20, 12);
 457           } else {
 458             i-&gt;f(0b01, 25, 24);
 459             i-&gt;f(_offset &gt;&gt; size, 21, 10);
 460           }
 461       }
 462       break;
 463 
 464     case base_plus_offset_reg:
 465       {
 466         i-&gt;f(0b00, 25, 24);
 467         i-&gt;f(1, 21);
 468         i-&gt;rf(_index, 16);
 469         i-&gt;f(_ext.option(), 15, 13);
 470         unsigned size = i-&gt;get(31, 30);
 471         if (i-&gt;get(26, 26) &amp;&amp; i-&gt;get(23, 23)) {
 472           // SIMD Q Type - Size = 128 bits
 473           assert(size == 0, &quot;bad size&quot;);
 474           size = 0b100;
 475         }
 476         if (size == 0) // It&#39;s a byte
 477           i-&gt;f(_ext.shift() &gt;= 0, 12);
 478         else {
 479           if (_ext.shift() &gt; 0)
 480             assert(_ext.shift() == (int)size, &quot;bad shift&quot;);
 481           i-&gt;f(_ext.shift() &gt; 0, 12);
 482         }
 483         i-&gt;f(0b10, 11, 10);
 484       }
 485       break;
 486 
 487     case pre:
 488       i-&gt;f(0b00, 25, 24);
 489       i-&gt;f(0, 21), i-&gt;f(0b11, 11, 10);
 490       i-&gt;sf(_offset, 20, 12);
 491       break;
 492 
 493     case post:
 494       i-&gt;f(0b00, 25, 24);
 495       i-&gt;f(0, 21), i-&gt;f(0b01, 11, 10);
 496       i-&gt;sf(_offset, 20, 12);
 497       break;
 498 
 499     default:
 500       ShouldNotReachHere();
 501     }
 502   }
 503 
 504   void encode_pair(Instruction_aarch64 *i) const {
 505     switch(_mode) {
 506     case base_plus_offset:
 507       i-&gt;f(0b010, 25, 23);
 508       break;
 509     case pre:
 510       i-&gt;f(0b011, 25, 23);
 511       break;
 512     case post:
 513       i-&gt;f(0b001, 25, 23);
 514       break;
 515     default:
 516       ShouldNotReachHere();
 517     }
 518 
 519     unsigned size; // Operand shift in 32-bit words
 520 
 521     if (i-&gt;get(26, 26)) { // float
 522       switch(i-&gt;get(31, 30)) {
 523       case 0b10:
 524         size = 2; break;
 525       case 0b01:
 526         size = 1; break;
 527       case 0b00:
 528         size = 0; break;
 529       default:
 530         ShouldNotReachHere();
 531         size = 0;  // unreachable
 532       }
 533     } else {
 534       size = i-&gt;get(31, 31);
 535     }
 536 
 537     size = 4 &lt;&lt; size;
 538     guarantee(_offset % size == 0, &quot;bad offset&quot;);
 539     i-&gt;sf(_offset / size, 21, 15);
 540     i-&gt;srf(_base, 5);
 541   }
 542 
 543   void encode_nontemporal_pair(Instruction_aarch64 *i) const {
 544     // Only base + offset is allowed
 545     i-&gt;f(0b000, 25, 23);
 546     unsigned size = i-&gt;get(31, 31);
 547     size = 4 &lt;&lt; size;
 548     guarantee(_offset % size == 0, &quot;bad offset&quot;);
 549     i-&gt;sf(_offset / size, 21, 15);
 550     i-&gt;srf(_base, 5);
 551     guarantee(_mode == Address::base_plus_offset,
 552               &quot;Bad addressing mode for non-temporal op&quot;);
 553   }
 554 
 555   void lea(MacroAssembler *, Register) const;
 556 
<a name="1" id="anc1"></a><span class="line-modified"> 557   static bool offset_ok_for_immed(int64_t offset, int shift) {</span>
<span class="line-removed"> 558     unsigned mask = (1 &lt;&lt; shift) - 1;</span>
<span class="line-removed"> 559     if (offset &lt; 0 || offset &amp; mask) {</span>
<span class="line-removed"> 560       return (uabs(offset) &lt; (1 &lt;&lt; (20 - 12))); // Unscaled offset</span>
<span class="line-removed"> 561     } else {</span>
<span class="line-removed"> 562       return ((offset &gt;&gt; shift) &lt; (1 &lt;&lt; (21 - 10 + 1))); // Scaled, unsigned offset</span>
<span class="line-removed"> 563     }</span>
<span class="line-removed"> 564   }</span>
 565 };
 566 
 567 // Convience classes
 568 class RuntimeAddress: public Address {
 569 
 570   public:
 571 
 572   RuntimeAddress(address target) : Address(target, relocInfo::runtime_call_type) {}
 573 
 574 };
 575 
 576 class OopAddress: public Address {
 577 
 578   public:
 579 
 580   OopAddress(address target) : Address(target, relocInfo::oop_type){}
 581 
 582 };
 583 
 584 class ExternalAddress: public Address {
 585  private:
 586   static relocInfo::relocType reloc_for_target(address target) {
 587     // Sometimes ExternalAddress is used for values which aren&#39;t
 588     // exactly addresses, like the card table base.
 589     // external_word_type can&#39;t be used for values in the first page
 590     // so just skip the reloc in that case.
 591     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 592   }
 593 
 594  public:
 595 
 596   ExternalAddress(address target) : Address(target, reloc_for_target(target)) {}
 597 
 598 };
 599 
 600 class InternalAddress: public Address {
 601 
 602   public:
 603 
 604   InternalAddress(address target) : Address(target, relocInfo::internal_word_type) {}
 605 };
 606 
 607 const int FPUStateSizeInWords = FloatRegisterImpl::number_of_registers *
 608                                 FloatRegisterImpl::save_slots_per_register;
 609 
 610 typedef enum {
 611   PLDL1KEEP = 0b00000, PLDL1STRM, PLDL2KEEP, PLDL2STRM, PLDL3KEEP, PLDL3STRM,
 612   PSTL1KEEP = 0b10000, PSTL1STRM, PSTL2KEEP, PSTL2STRM, PSTL3KEEP, PSTL3STRM,
 613   PLIL1KEEP = 0b01000, PLIL1STRM, PLIL2KEEP, PLIL2STRM, PLIL3KEEP, PLIL3STRM
 614 } prfop;
 615 
 616 class Assembler : public AbstractAssembler {
 617 
 618 #ifndef PRODUCT
 619   static const uintptr_t asm_bp;
 620 
 621   void emit_long(jint x) {
 622     if ((uintptr_t)pc() == asm_bp)
 623       asm volatile (&quot;nop&quot;);
 624     AbstractAssembler::emit_int32(x);
 625   }
 626 #else
 627   void emit_long(jint x) {
 628     AbstractAssembler::emit_int32(x);
 629   }
 630 #endif
 631 
 632 public:
 633 
 634   enum { instruction_size = 4 };
 635 
 636   //---&lt;  calculate length of instruction  &gt;---
 637   // We just use the values set above.
 638   // instruction must start at passed address
 639   static unsigned int instr_len(unsigned char *instr) { return instruction_size; }
 640 
 641   //---&lt;  longest instructions  &gt;---
 642   static unsigned int instr_maxlen() { return instruction_size; }
 643 
 644   Address adjust(Register base, int offset, bool preIncrement) {
 645     if (preIncrement)
 646       return Address(Pre(base, offset));
 647     else
 648       return Address(Post(base, offset));
 649   }
 650 
 651   Address pre(Register base, int offset) {
 652     return adjust(base, offset, true);
 653   }
 654 
 655   Address post(Register base, int offset) {
 656     return adjust(base, offset, false);
 657   }
 658 
 659   Address post(Register base, Register idx) {
 660     return Address(Post(base, idx));
 661   }
 662 
 663   Instruction_aarch64* current;
 664 
 665   void set_current(Instruction_aarch64* i) { current = i; }
 666 
 667   void f(unsigned val, int msb, int lsb) {
 668     current-&gt;f(val, msb, lsb);
 669   }
 670   void f(unsigned val, int msb) {
 671     current-&gt;f(val, msb, msb);
 672   }
 673   void sf(int64_t val, int msb, int lsb) {
 674     current-&gt;sf(val, msb, lsb);
 675   }
 676   void rf(Register reg, int lsb) {
 677     current-&gt;rf(reg, lsb);
 678   }
 679   void srf(Register reg, int lsb) {
 680     current-&gt;srf(reg, lsb);
 681   }
 682   void zrf(Register reg, int lsb) {
 683     current-&gt;zrf(reg, lsb);
 684   }
 685   void rf(FloatRegister reg, int lsb) {
 686     current-&gt;rf(reg, lsb);
 687   }
 688   void fixed(unsigned value, unsigned mask) {
 689     current-&gt;fixed(value, mask);
 690   }
 691 
 692   void emit() {
 693     emit_long(current-&gt;get_insn());
 694     assert_cond(current-&gt;get_bits() == 0xffffffff);
 695     current = NULL;
 696   }
 697 
 698   typedef void (Assembler::* uncond_branch_insn)(address dest);
 699   typedef void (Assembler::* compare_and_branch_insn)(Register Rt, address dest);
 700   typedef void (Assembler::* test_and_branch_insn)(Register Rt, int bitpos, address dest);
 701   typedef void (Assembler::* prefetch_insn)(address target, prfop);
 702 
 703   void wrap_label(Label &amp;L, uncond_branch_insn insn);
 704   void wrap_label(Register r, Label &amp;L, compare_and_branch_insn insn);
 705   void wrap_label(Register r, int bitpos, Label &amp;L, test_and_branch_insn insn);
 706   void wrap_label(Label &amp;L, prfop, prefetch_insn insn);
 707 
 708   // PC-rel. addressing
 709 
 710   void adr(Register Rd, address dest);
 711   void _adrp(Register Rd, address dest);
 712 
 713   void adr(Register Rd, const Address &amp;dest);
 714   void _adrp(Register Rd, const Address &amp;dest);
 715 
 716   void adr(Register Rd, Label &amp;L) {
 717     wrap_label(Rd, L, &amp;Assembler::Assembler::adr);
 718   }
 719   void _adrp(Register Rd, Label &amp;L) {
 720     wrap_label(Rd, L, &amp;Assembler::_adrp);
 721   }
 722 
 723   void adrp(Register Rd, const Address &amp;dest, uint64_t &amp;offset);
 724 
 725 #undef INSN
 726 
 727   void add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,
 728                          int negated_op);
 729 
 730   // Add/subtract (immediate)
 731 #define INSN(NAME, decode, negated)                                     \
 732   void NAME(Register Rd, Register Rn, unsigned imm, unsigned shift) {   \
 733     starti;                                                             \
 734     f(decode, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10); \
 735     zrf(Rd, 0), srf(Rn, 5);                                             \
 736   }                                                                     \
 737                                                                         \
 738   void NAME(Register Rd, Register Rn, unsigned imm) {                   \
 739     starti;                                                             \
 740     add_sub_immediate(Rd, Rn, imm, decode, negated);                    \
 741   }
 742 
 743   INSN(addsw, 0b001, 0b011);
 744   INSN(subsw, 0b011, 0b001);
 745   INSN(adds,  0b101, 0b111);
 746   INSN(subs,  0b111, 0b101);
 747 
 748 #undef INSN
 749 
 750 #define INSN(NAME, decode, negated)                     \
 751   void NAME(Register Rd, Register Rn, unsigned imm) {   \
 752     starti;                                             \
 753     add_sub_immediate(Rd, Rn, imm, decode, negated);    \
 754   }
 755 
 756   INSN(addw, 0b000, 0b010);
 757   INSN(subw, 0b010, 0b000);
 758   INSN(add,  0b100, 0b110);
 759   INSN(sub,  0b110, 0b100);
 760 
 761 #undef INSN
 762 
 763  // Logical (immediate)
 764 #define INSN(NAME, decode, is32)                                \
 765   void NAME(Register Rd, Register Rn, uint64_t imm) {           \
 766     starti;                                                     \
 767     uint32_t val = encode_logical_immediate(is32, imm);         \
 768     f(decode, 31, 29), f(0b100100, 28, 23), f(val, 22, 10);     \
 769     srf(Rd, 0), zrf(Rn, 5);                                     \
 770   }
 771 
 772   INSN(andw, 0b000, true);
 773   INSN(orrw, 0b001, true);
 774   INSN(eorw, 0b010, true);
 775   INSN(andr,  0b100, false);
 776   INSN(orr,  0b101, false);
 777   INSN(eor,  0b110, false);
 778 
 779 #undef INSN
 780 
 781 #define INSN(NAME, decode, is32)                                \
 782   void NAME(Register Rd, Register Rn, uint64_t imm) {           \
 783     starti;                                                     \
 784     uint32_t val = encode_logical_immediate(is32, imm);         \
 785     f(decode, 31, 29), f(0b100100, 28, 23), f(val, 22, 10);     \
 786     zrf(Rd, 0), zrf(Rn, 5);                                     \
 787   }
 788 
 789   INSN(ands, 0b111, false);
 790   INSN(andsw, 0b011, true);
 791 
 792 #undef INSN
 793 
 794   // Move wide (immediate)
 795 #define INSN(NAME, opcode)                                              \
 796   void NAME(Register Rd, unsigned imm, unsigned shift = 0) {            \
 797     assert_cond((shift/16)*16 == shift);                                \
 798     starti;                                                             \
 799     f(opcode, 31, 29), f(0b100101, 28, 23), f(shift/16, 22, 21),        \
 800       f(imm, 20, 5);                                                    \
 801     rf(Rd, 0);                                                          \
 802   }
 803 
 804   INSN(movnw, 0b000);
 805   INSN(movzw, 0b010);
 806   INSN(movkw, 0b011);
 807   INSN(movn, 0b100);
 808   INSN(movz, 0b110);
 809   INSN(movk, 0b111);
 810 
 811 #undef INSN
 812 
 813   // Bitfield
 814 #define INSN(NAME, opcode, size)                                        \
 815   void NAME(Register Rd, Register Rn, unsigned immr, unsigned imms) {   \
 816     starti;                                                             \
 817     guarantee(size == 1 || (immr &lt; 32 &amp;&amp; imms &lt; 32), &quot;incorrect immr/imms&quot;);\
 818     f(opcode, 31, 22), f(immr, 21, 16), f(imms, 15, 10);                \
 819     zrf(Rn, 5), rf(Rd, 0);                                              \
 820   }
 821 
 822   INSN(sbfmw, 0b0001001100, 0);
 823   INSN(bfmw,  0b0011001100, 0);
 824   INSN(ubfmw, 0b0101001100, 0);
 825   INSN(sbfm,  0b1001001101, 1);
 826   INSN(bfm,   0b1011001101, 1);
 827   INSN(ubfm,  0b1101001101, 1);
 828 
 829 #undef INSN
 830 
 831   // Extract
 832 #define INSN(NAME, opcode, size)                                        \
 833   void NAME(Register Rd, Register Rn, Register Rm, unsigned imms) {     \
 834     starti;                                                             \
 835     guarantee(size == 1 || imms &lt; 32, &quot;incorrect imms&quot;);                \
 836     f(opcode, 31, 21), f(imms, 15, 10);                                 \
 837     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \
 838   }
 839 
 840   INSN(extrw, 0b00010011100, 0);
 841   INSN(extr,  0b10010011110, 1);
 842 
 843 #undef INSN
 844 
 845   // The maximum range of a branch is fixed for the AArch64
 846   // architecture.  In debug mode we shrink it in order to test
 847   // trampolines, but not so small that branches in the interpreter
 848   // are out of range.
 849   static const uint64_t branch_range = NOT_DEBUG(128 * M) DEBUG_ONLY(2 * M);
 850 
 851   static bool reachable_from_branch_at(address branch, address target) {
 852     return uabs(target - branch) &lt; branch_range;
 853   }
 854 
 855   // Unconditional branch (immediate)
 856 #define INSN(NAME, opcode)                                              \
 857   void NAME(address dest) {                                             \
 858     starti;                                                             \
 859     int64_t offset = (dest - pc()) &gt;&gt; 2;                                \
 860     DEBUG_ONLY(assert(reachable_from_branch_at(pc(), dest), &quot;debug only&quot;)); \
 861     f(opcode, 31), f(0b00101, 30, 26), sf(offset, 25, 0);               \
 862   }                                                                     \
 863   void NAME(Label &amp;L) {                                                 \
 864     wrap_label(L, &amp;Assembler::NAME);                                    \
 865   }                                                                     \
 866   void NAME(const Address &amp;dest);
 867 
 868   INSN(b, 0);
 869   INSN(bl, 1);
 870 
 871 #undef INSN
 872 
 873   // Compare &amp; branch (immediate)
 874 #define INSN(NAME, opcode)                              \
 875   void NAME(Register Rt, address dest) {                \
 876     int64_t offset = (dest - pc()) &gt;&gt; 2;                \
 877     starti;                                             \
 878     f(opcode, 31, 24), sf(offset, 23, 5), rf(Rt, 0);    \
 879   }                                                     \
 880   void NAME(Register Rt, Label &amp;L) {                    \
 881     wrap_label(Rt, L, &amp;Assembler::NAME);                \
 882   }
 883 
 884   INSN(cbzw,  0b00110100);
 885   INSN(cbnzw, 0b00110101);
 886   INSN(cbz,   0b10110100);
 887   INSN(cbnz,  0b10110101);
 888 
 889 #undef INSN
 890 
 891   // Test &amp; branch (immediate)
 892 #define INSN(NAME, opcode)                                              \
 893   void NAME(Register Rt, int bitpos, address dest) {                    \
 894     int64_t offset = (dest - pc()) &gt;&gt; 2;                                \
 895     int b5 = bitpos &gt;&gt; 5;                                               \
 896     bitpos &amp;= 0x1f;                                                     \
 897     starti;                                                             \
 898     f(b5, 31), f(opcode, 30, 24), f(bitpos, 23, 19), sf(offset, 18, 5); \
 899     rf(Rt, 0);                                                          \
 900   }                                                                     \
 901   void NAME(Register Rt, int bitpos, Label &amp;L) {                        \
 902     wrap_label(Rt, bitpos, L, &amp;Assembler::NAME);                        \
 903   }
 904 
 905   INSN(tbz,  0b0110110);
 906   INSN(tbnz, 0b0110111);
 907 
 908 #undef INSN
 909 
 910   // Conditional branch (immediate)
 911   enum Condition
 912     {EQ, NE, HS, CS=HS, LO, CC=LO, MI, PL, VS, VC, HI, LS, GE, LT, GT, LE, AL, NV};
 913 
 914   void br(Condition  cond, address dest) {
 915     int64_t offset = (dest - pc()) &gt;&gt; 2;
 916     starti;
 917     f(0b0101010, 31, 25), f(0, 24), sf(offset, 23, 5), f(0, 4), f(cond, 3, 0);
 918   }
 919 
 920 #define INSN(NAME, cond)                        \
 921   void NAME(address dest) {                     \
 922     br(cond, dest);                             \
 923   }
 924 
 925   INSN(beq, EQ);
 926   INSN(bne, NE);
 927   INSN(bhs, HS);
 928   INSN(bcs, CS);
 929   INSN(blo, LO);
 930   INSN(bcc, CC);
 931   INSN(bmi, MI);
 932   INSN(bpl, PL);
 933   INSN(bvs, VS);
 934   INSN(bvc, VC);
 935   INSN(bhi, HI);
 936   INSN(bls, LS);
 937   INSN(bge, GE);
 938   INSN(blt, LT);
 939   INSN(bgt, GT);
 940   INSN(ble, LE);
 941   INSN(bal, AL);
 942   INSN(bnv, NV);
 943 
 944   void br(Condition cc, Label &amp;L);
 945 
 946 #undef INSN
 947 
 948   // Exception generation
 949   void generate_exception(int opc, int op2, int LL, unsigned imm) {
 950     starti;
 951     f(0b11010100, 31, 24);
 952     f(opc, 23, 21), f(imm, 20, 5), f(op2, 4, 2), f(LL, 1, 0);
 953   }
 954 
 955 #define INSN(NAME, opc, op2, LL)                \
 956   void NAME(unsigned imm) {                     \
 957     generate_exception(opc, op2, LL, imm);      \
 958   }
 959 
 960   INSN(svc, 0b000, 0, 0b01);
 961   INSN(hvc, 0b000, 0, 0b10);
 962   INSN(smc, 0b000, 0, 0b11);
 963   INSN(brk, 0b001, 0, 0b00);
 964   INSN(hlt, 0b010, 0, 0b00);
 965   INSN(dcps1, 0b101, 0, 0b01);
 966   INSN(dcps2, 0b101, 0, 0b10);
 967   INSN(dcps3, 0b101, 0, 0b11);
 968 
 969 #undef INSN
 970 
 971   // System
 972   void system(int op0, int op1, int CRn, int CRm, int op2,
 973               Register rt = dummy_reg)
 974   {
 975     starti;
 976     f(0b11010101000, 31, 21);
 977     f(op0, 20, 19);
 978     f(op1, 18, 16);
 979     f(CRn, 15, 12);
 980     f(CRm, 11, 8);
 981     f(op2, 7, 5);
 982     rf(rt, 0);
 983   }
 984 
 985   void hint(int imm) {
 986     system(0b00, 0b011, 0b0010, 0b0000, imm);
 987   }
 988 
 989   void nop() {
 990     hint(0);
 991   }
 992 
 993   void yield() {
 994     hint(1);
 995   }
 996 
 997   void wfe() {
 998     hint(2);
 999   }
1000 
1001   void wfi() {
1002     hint(3);
1003   }
1004 
1005   void sev() {
1006     hint(4);
1007   }
1008 
1009   void sevl() {
1010     hint(5);
1011   }
1012 
1013   // we only provide mrs and msr for the special purpose system
1014   // registers where op1 (instr[20:19]) == 11 and, (currently) only
1015   // use it for FPSR n.b msr has L (instr[21]) == 0 mrs has L == 1
1016 
1017   void msr(int op1, int CRn, int CRm, int op2, Register rt) {
1018     starti;
1019     f(0b1101010100011, 31, 19);
1020     f(op1, 18, 16);
1021     f(CRn, 15, 12);
1022     f(CRm, 11, 8);
1023     f(op2, 7, 5);
1024     // writing zr is ok
1025     zrf(rt, 0);
1026   }
1027 
1028   void mrs(int op1, int CRn, int CRm, int op2, Register rt) {
1029     starti;
1030     f(0b1101010100111, 31, 19);
1031     f(op1, 18, 16);
1032     f(CRn, 15, 12);
1033     f(CRm, 11, 8);
1034     f(op2, 7, 5);
1035     // reading to zr is a mistake
1036     rf(rt, 0);
1037   }
1038 
1039   enum barrier {OSHLD = 0b0001, OSHST, OSH, NSHLD=0b0101, NSHST, NSH,
1040                 ISHLD = 0b1001, ISHST, ISH, LD=0b1101, ST, SY};
1041 
1042   void dsb(barrier imm) {
1043     system(0b00, 0b011, 0b00011, imm, 0b100);
1044   }
1045 
1046   void dmb(barrier imm) {
1047     system(0b00, 0b011, 0b00011, imm, 0b101);
1048   }
1049 
1050   void isb() {
1051     system(0b00, 0b011, 0b00011, SY, 0b110);
1052   }
1053 
1054   void sys(int op1, int CRn, int CRm, int op2,
1055            Register rt = (Register)0b11111) {
1056     system(0b01, op1, CRn, CRm, op2, rt);
1057   }
1058 
1059   // Only implement operations accessible from EL0 or higher, i.e.,
1060   //            op1    CRn    CRm    op2
1061   // IC IVAU     3      7      5      1
1062   // DC CVAC     3      7      10     1
1063   // DC CVAP     3      7      12     1
1064   // DC CVAU     3      7      11     1
1065   // DC CIVAC    3      7      14     1
1066   // DC ZVA      3      7      4      1
1067   // So only deal with the CRm field.
1068   enum icache_maintenance {IVAU = 0b0101};
1069   enum dcache_maintenance {CVAC = 0b1010, CVAP = 0b1100, CVAU = 0b1011, CIVAC = 0b1110, ZVA = 0b100};
1070 
1071   void dc(dcache_maintenance cm, Register Rt) {
1072     sys(0b011, 0b0111, cm, 0b001, Rt);
1073   }
1074 
1075   void ic(icache_maintenance cm, Register Rt) {
1076     sys(0b011, 0b0111, cm, 0b001, Rt);
1077   }
1078 
1079   // A more convenient access to dmb for our purposes
1080   enum Membar_mask_bits {
1081     // We can use ISH for a barrier because the ARM ARM says &quot;This
1082     // architecture assumes that all Processing Elements that use the
1083     // same operating system or hypervisor are in the same Inner
1084     // Shareable shareability domain.&quot;
1085     StoreStore = ISHST,
1086     LoadStore  = ISHLD,
1087     LoadLoad   = ISHLD,
1088     StoreLoad  = ISH,
1089     AnyAny     = ISH
1090   };
1091 
1092   void membar(Membar_mask_bits order_constraint) {
1093     dmb(Assembler::barrier(order_constraint));
1094   }
1095 
1096   // Unconditional branch (register)
1097   void branch_reg(Register R, int opc) {
1098     starti;
1099     f(0b1101011, 31, 25);
1100     f(opc, 24, 21);
1101     f(0b11111000000, 20, 10);
1102     rf(R, 5);
1103     f(0b00000, 4, 0);
1104   }
1105 
1106 #define INSN(NAME, opc)                         \
1107   void NAME(Register R) {                       \
1108     branch_reg(R, opc);                         \
1109   }
1110 
1111   INSN(br, 0b0000);
1112   INSN(blr, 0b0001);
1113   INSN(ret, 0b0010);
1114 
1115   void ret(void *p); // This forces a compile-time error for ret(0)
1116 
1117 #undef INSN
1118 
1119 #define INSN(NAME, opc)                         \
1120   void NAME() {                 \
1121     branch_reg(dummy_reg, opc);         \
1122   }
1123 
1124   INSN(eret, 0b0100);
1125   INSN(drps, 0b0101);
1126 
1127 #undef INSN
1128 
1129   // Load/store exclusive
1130   enum operand_size { byte, halfword, word, xword };
1131 
1132   void load_store_exclusive(Register Rs, Register Rt1, Register Rt2,
1133     Register Rn, enum operand_size sz, int op, bool ordered) {
1134     starti;
1135     f(sz, 31, 30), f(0b001000, 29, 24), f(op, 23, 21);
1136     rf(Rs, 16), f(ordered, 15), zrf(Rt2, 10), srf(Rn, 5), zrf(Rt1, 0);
1137   }
1138 
1139   void load_exclusive(Register dst, Register addr,
1140                       enum operand_size sz, bool ordered) {
1141     load_store_exclusive(dummy_reg, dst, dummy_reg, addr,
1142                          sz, 0b010, ordered);
1143   }
1144 
1145   void store_exclusive(Register status, Register new_val, Register addr,
1146                        enum operand_size sz, bool ordered) {
1147     load_store_exclusive(status, new_val, dummy_reg, addr,
1148                          sz, 0b000, ordered);
1149   }
1150 
1151 #define INSN4(NAME, sz, op, o0) /* Four registers */                    \
1152   void NAME(Register Rs, Register Rt1, Register Rt2, Register Rn) {     \
1153     guarantee(Rs != Rn &amp;&amp; Rs != Rt1 &amp;&amp; Rs != Rt2, &quot;unpredictable instruction&quot;); \
1154     load_store_exclusive(Rs, Rt1, Rt2, Rn, sz, op, o0);                 \
1155   }
1156 
1157 #define INSN3(NAME, sz, op, o0) /* Three registers */                   \
1158   void NAME(Register Rs, Register Rt, Register Rn) {                    \
1159     guarantee(Rs != Rn &amp;&amp; Rs != Rt, &quot;unpredictable instruction&quot;);       \
1160     load_store_exclusive(Rs, Rt, dummy_reg, Rn, sz, op, o0); \
1161   }
1162 
1163 #define INSN2(NAME, sz, op, o0) /* Two registers */                     \
1164   void NAME(Register Rt, Register Rn) {                                 \
1165     load_store_exclusive(dummy_reg, Rt, dummy_reg, \
1166                          Rn, sz, op, o0);                               \
1167   }
1168 
1169 #define INSN_FOO(NAME, sz, op, o0) /* Three registers, encoded differently */ \
1170   void NAME(Register Rt1, Register Rt2, Register Rn) {                  \
1171     guarantee(Rt1 != Rt2, &quot;unpredictable instruction&quot;);                 \
1172     load_store_exclusive(dummy_reg, Rt1, Rt2, Rn, sz, op, o0);          \
1173   }
1174 
1175   // bytes
1176   INSN3(stxrb, byte, 0b000, 0);
1177   INSN3(stlxrb, byte, 0b000, 1);
1178   INSN2(ldxrb, byte, 0b010, 0);
1179   INSN2(ldaxrb, byte, 0b010, 1);
1180   INSN2(stlrb, byte, 0b100, 1);
1181   INSN2(ldarb, byte, 0b110, 1);
1182 
1183   // halfwords
1184   INSN3(stxrh, halfword, 0b000, 0);
1185   INSN3(stlxrh, halfword, 0b000, 1);
1186   INSN2(ldxrh, halfword, 0b010, 0);
1187   INSN2(ldaxrh, halfword, 0b010, 1);
1188   INSN2(stlrh, halfword, 0b100, 1);
1189   INSN2(ldarh, halfword, 0b110, 1);
1190 
1191   // words
1192   INSN3(stxrw, word, 0b000, 0);
1193   INSN3(stlxrw, word, 0b000, 1);
1194   INSN4(stxpw, word, 0b001, 0);
1195   INSN4(stlxpw, word, 0b001, 1);
1196   INSN2(ldxrw, word, 0b010, 0);
1197   INSN2(ldaxrw, word, 0b010, 1);
1198   INSN_FOO(ldxpw, word, 0b011, 0);
1199   INSN_FOO(ldaxpw, word, 0b011, 1);
1200   INSN2(stlrw, word, 0b100, 1);
1201   INSN2(ldarw, word, 0b110, 1);
1202 
1203   // xwords
1204   INSN3(stxr, xword, 0b000, 0);
1205   INSN3(stlxr, xword, 0b000, 1);
1206   INSN4(stxp, xword, 0b001, 0);
1207   INSN4(stlxp, xword, 0b001, 1);
1208   INSN2(ldxr, xword, 0b010, 0);
1209   INSN2(ldaxr, xword, 0b010, 1);
1210   INSN_FOO(ldxp, xword, 0b011, 0);
1211   INSN_FOO(ldaxp, xword, 0b011, 1);
1212   INSN2(stlr, xword, 0b100, 1);
1213   INSN2(ldar, xword, 0b110, 1);
1214 
1215 #undef INSN2
1216 #undef INSN3
1217 #undef INSN4
1218 #undef INSN_FOO
1219 
1220   // 8.1 Compare and swap extensions
1221   void lse_cas(Register Rs, Register Rt, Register Rn,
1222                         enum operand_size sz, bool a, bool r, bool not_pair) {
1223     starti;
1224     if (! not_pair) { // Pair
1225       assert(sz == word || sz == xword, &quot;invalid size&quot;);
1226       /* The size bit is in bit 30, not 31 */
1227       sz = (operand_size)(sz == word ? 0b00:0b01);
1228     }
1229     f(sz, 31, 30), f(0b001000, 29, 24), f(not_pair ? 1 : 0, 23), f(a, 22), f(1, 21);
1230     zrf(Rs, 16), f(r, 15), f(0b11111, 14, 10), srf(Rn, 5), zrf(Rt, 0);
1231   }
1232 
1233   // CAS
1234 #define INSN(NAME, a, r)                                                \
1235   void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
1236     assert(Rs != Rn &amp;&amp; Rs != Rt, &quot;unpredictable instruction&quot;);          \
1237     lse_cas(Rs, Rt, Rn, sz, a, r, true);                                \
1238   }
1239   INSN(cas,    false, false)
1240   INSN(casa,   true,  false)
1241   INSN(casl,   false, true)
1242   INSN(casal,  true,  true)
1243 #undef INSN
1244 
1245   // CASP
1246 #define INSN(NAME, a, r)                                                \
1247   void NAME(operand_size sz, Register Rs, Register Rs1,                 \
1248             Register Rt, Register Rt1, Register Rn) {                   \
1249     assert((Rs-&gt;encoding() &amp; 1) == 0 &amp;&amp; (Rt-&gt;encoding() &amp; 1) == 0 &amp;&amp;    \
1250            Rs-&gt;successor() == Rs1 &amp;&amp; Rt-&gt;successor() == Rt1 &amp;&amp;          \
1251            Rs != Rn &amp;&amp; Rs1 != Rn &amp;&amp; Rs != Rt, &quot;invalid registers&quot;);     \
1252     lse_cas(Rs, Rt, Rn, sz, a, r, false);                               \
1253   }
1254   INSN(casp,    false, false)
1255   INSN(caspa,   true,  false)
1256   INSN(caspl,   false, true)
1257   INSN(caspal,  true,  true)
1258 #undef INSN
1259 
1260   // 8.1 Atomic operations
1261   void lse_atomic(Register Rs, Register Rt, Register Rn,
1262                   enum operand_size sz, int op1, int op2, bool a, bool r) {
1263     starti;
1264     f(sz, 31, 30), f(0b111000, 29, 24), f(a, 23), f(r, 22), f(1, 21);
1265     zrf(Rs, 16), f(op1, 15), f(op2, 14, 12), f(0, 11, 10), srf(Rn, 5), zrf(Rt, 0);
1266   }
1267 
1268 #define INSN(NAME, NAME_A, NAME_L, NAME_AL, op1, op2)                   \
1269   void NAME(operand_size sz, Register Rs, Register Rt, Register Rn) {   \
1270     lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, false);                 \
1271   }                                                                     \
1272   void NAME_A(operand_size sz, Register Rs, Register Rt, Register Rn) { \
1273     lse_atomic(Rs, Rt, Rn, sz, op1, op2, true, false);                  \
1274   }                                                                     \
1275   void NAME_L(operand_size sz, Register Rs, Register Rt, Register Rn) { \
1276     lse_atomic(Rs, Rt, Rn, sz, op1, op2, false, true);                  \
1277   }                                                                     \
1278   void NAME_AL(operand_size sz, Register Rs, Register Rt, Register Rn) {\
1279     lse_atomic(Rs, Rt, Rn, sz, op1, op2, true, true);                   \
1280   }
1281   INSN(ldadd,  ldadda,  ldaddl,  ldaddal,  0, 0b000);
1282   INSN(ldbic,  ldbica,  ldbicl,  ldbical,  0, 0b001);
1283   INSN(ldeor,  ldeora,  ldeorl,  ldeoral,  0, 0b010);
1284   INSN(ldorr,  ldorra,  ldorrl,  ldorral,  0, 0b011);
1285   INSN(ldsmax, ldsmaxa, ldsmaxl, ldsmaxal, 0, 0b100);
1286   INSN(ldsmin, ldsmina, ldsminl, ldsminal, 0, 0b101);
1287   INSN(ldumax, ldumaxa, ldumaxl, ldumaxal, 0, 0b110);
1288   INSN(ldumin, ldumina, lduminl, lduminal, 0, 0b111);
1289   INSN(swp,    swpa,    swpl,    swpal,    1, 0b000);
1290 #undef INSN
1291 
1292   // Load register (literal)
1293 #define INSN(NAME, opc, V)                                              \
1294   void NAME(Register Rt, address dest) {                                \
1295     int64_t offset = (dest - pc()) &gt;&gt; 2;                                \
1296     starti;                                                             \
1297     f(opc, 31, 30), f(0b011, 29, 27), f(V, 26), f(0b00, 25, 24),        \
1298       sf(offset, 23, 5);                                                \
1299     rf(Rt, 0);                                                          \
1300   }                                                                     \
1301   void NAME(Register Rt, address dest, relocInfo::relocType rtype) {    \
1302     InstructionMark im(this);                                           \
1303     guarantee(rtype == relocInfo::internal_word_type,                   \
1304               &quot;only internal_word_type relocs make sense here&quot;);        \
1305     code_section()-&gt;relocate(inst_mark(), InternalAddress(dest).rspec()); \
1306     NAME(Rt, dest);                                                     \
1307   }                                                                     \
1308   void NAME(Register Rt, Label &amp;L) {                                    \
1309     wrap_label(Rt, L, &amp;Assembler::NAME);                                \
1310   }
1311 
1312   INSN(ldrw, 0b00, 0);
1313   INSN(ldr, 0b01, 0);
1314   INSN(ldrsw, 0b10, 0);
1315 
1316 #undef INSN
1317 
1318 #define INSN(NAME, opc, V)                                              \
1319   void NAME(FloatRegister Rt, address dest) {                           \
1320     int64_t offset = (dest - pc()) &gt;&gt; 2;                                \
1321     starti;                                                             \
1322     f(opc, 31, 30), f(0b011, 29, 27), f(V, 26), f(0b00, 25, 24),        \
1323       sf(offset, 23, 5);                                                \
1324     rf((Register)Rt, 0);                                                \
1325   }
1326 
1327   INSN(ldrs, 0b00, 1);
1328   INSN(ldrd, 0b01, 1);
1329   INSN(ldrq, 0b10, 1);
1330 
1331 #undef INSN
1332 
1333 #define INSN(NAME, opc, V)                                              \
1334   void NAME(address dest, prfop op = PLDL1KEEP) {                       \
1335     int64_t offset = (dest - pc()) &gt;&gt; 2;                                \
1336     starti;                                                             \
1337     f(opc, 31, 30), f(0b011, 29, 27), f(V, 26), f(0b00, 25, 24),        \
1338       sf(offset, 23, 5);                                                \
1339     f(op, 4, 0);                                                        \
1340   }                                                                     \
1341   void NAME(Label &amp;L, prfop op = PLDL1KEEP) {                           \
1342     wrap_label(L, op, &amp;Assembler::NAME);                                \
1343   }
1344 
1345   INSN(prfm, 0b11, 0);
1346 
1347 #undef INSN
1348 
1349   // Load/store
1350   void ld_st1(int opc, int p1, int V, int L,
1351               Register Rt1, Register Rt2, Address adr, bool no_allocate) {
1352     starti;
1353     f(opc, 31, 30), f(p1, 29, 27), f(V, 26), f(L, 22);
1354     zrf(Rt2, 10), zrf(Rt1, 0);
1355     if (no_allocate) {
1356       adr.encode_nontemporal_pair(current);
1357     } else {
1358       adr.encode_pair(current);
1359     }
1360   }
1361 
1362   // Load/store register pair (offset)
1363 #define INSN(NAME, size, p1, V, L, no_allocate)         \
1364   void NAME(Register Rt1, Register Rt2, Address adr) {  \
1365     ld_st1(size, p1, V, L, Rt1, Rt2, adr, no_allocate); \
1366    }
1367 
1368   INSN(stpw, 0b00, 0b101, 0, 0, false);
1369   INSN(ldpw, 0b00, 0b101, 0, 1, false);
1370   INSN(ldpsw, 0b01, 0b101, 0, 1, false);
1371   INSN(stp, 0b10, 0b101, 0, 0, false);
1372   INSN(ldp, 0b10, 0b101, 0, 1, false);
1373 
1374   // Load/store no-allocate pair (offset)
1375   INSN(stnpw, 0b00, 0b101, 0, 0, true);
1376   INSN(ldnpw, 0b00, 0b101, 0, 1, true);
1377   INSN(stnp, 0b10, 0b101, 0, 0, true);
1378   INSN(ldnp, 0b10, 0b101, 0, 1, true);
1379 
1380 #undef INSN
1381 
1382 #define INSN(NAME, size, p1, V, L, no_allocate)                         \
1383   void NAME(FloatRegister Rt1, FloatRegister Rt2, Address adr) {        \
1384     ld_st1(size, p1, V, L, (Register)Rt1, (Register)Rt2, adr, no_allocate); \
1385    }
1386 
1387   INSN(stps, 0b00, 0b101, 1, 0, false);
1388   INSN(ldps, 0b00, 0b101, 1, 1, false);
1389   INSN(stpd, 0b01, 0b101, 1, 0, false);
1390   INSN(ldpd, 0b01, 0b101, 1, 1, false);
1391   INSN(stpq, 0b10, 0b101, 1, 0, false);
1392   INSN(ldpq, 0b10, 0b101, 1, 1, false);
1393 
1394 #undef INSN
1395 
1396   // Load/store register (all modes)
1397   void ld_st2(Register Rt, const Address &amp;adr, int size, int op, int V = 0) {
1398     starti;
1399 
1400     f(V, 26); // general reg?
1401     zrf(Rt, 0);
1402 
1403     // Encoding for literal loads is done here (rather than pushed
1404     // down into Address::encode) because the encoding of this
1405     // instruction is too different from all of the other forms to
1406     // make it worth sharing.
1407     if (adr.getMode() == Address::literal) {
1408       assert(size == 0b10 || size == 0b11, &quot;bad operand size in ldr&quot;);
1409       assert(op == 0b01, &quot;literal form can only be used with loads&quot;);
1410       f(size &amp; 0b01, 31, 30), f(0b011, 29, 27), f(0b00, 25, 24);
1411       int64_t offset = (adr.target() - pc()) &gt;&gt; 2;
1412       sf(offset, 23, 5);
1413       code_section()-&gt;relocate(pc(), adr.rspec());
1414       return;
1415     }
1416 
1417     f(size, 31, 30);
1418     f(op, 23, 22); // str
1419     adr.encode(current);
1420   }
1421 
1422 #define INSN(NAME, size, op)                            \
1423   void NAME(Register Rt, const Address &amp;adr) {          \
1424     ld_st2(Rt, adr, size, op);                          \
1425   }                                                     \
1426 
1427   INSN(str, 0b11, 0b00);
1428   INSN(strw, 0b10, 0b00);
1429   INSN(strb, 0b00, 0b00);
1430   INSN(strh, 0b01, 0b00);
1431 
1432   INSN(ldr, 0b11, 0b01);
1433   INSN(ldrw, 0b10, 0b01);
1434   INSN(ldrb, 0b00, 0b01);
1435   INSN(ldrh, 0b01, 0b01);
1436 
1437   INSN(ldrsb, 0b00, 0b10);
1438   INSN(ldrsbw, 0b00, 0b11);
1439   INSN(ldrsh, 0b01, 0b10);
1440   INSN(ldrshw, 0b01, 0b11);
1441   INSN(ldrsw, 0b10, 0b10);
1442 
1443 #undef INSN
1444 
1445 #define INSN(NAME, size, op)                                    \
1446   void NAME(const Address &amp;adr, prfop pfop = PLDL1KEEP) {       \
1447     ld_st2((Register)pfop, adr, size, op);                      \
1448   }
1449 
1450   INSN(prfm, 0b11, 0b10); // FIXME: PRFM should not be used with
1451                           // writeback modes, but the assembler
1452                           // doesn&#39;t enfore that.
1453 
1454 #undef INSN
1455 
1456 #define INSN(NAME, size, op)                            \
1457   void NAME(FloatRegister Rt, const Address &amp;adr) {     \
1458     ld_st2((Register)Rt, adr, size, op, 1);             \
1459   }
1460 
1461   INSN(strd, 0b11, 0b00);
1462   INSN(strs, 0b10, 0b00);
1463   INSN(ldrd, 0b11, 0b01);
1464   INSN(ldrs, 0b10, 0b01);
1465   INSN(strq, 0b00, 0b10);
1466   INSN(ldrq, 0x00, 0b11);
1467 
1468 #undef INSN
1469 
1470   enum shift_kind { LSL, LSR, ASR, ROR };
1471 
1472   void op_shifted_reg(unsigned decode,
1473                       enum shift_kind kind, unsigned shift,
1474                       unsigned size, unsigned op) {
1475     f(size, 31);
1476     f(op, 30, 29);
1477     f(decode, 28, 24);
1478     f(shift, 15, 10);
1479     f(kind, 23, 22);
1480   }
1481 
1482   // Logical (shifted register)
1483 #define INSN(NAME, size, op, N)                                 \
1484   void NAME(Register Rd, Register Rn, Register Rm,              \
1485             enum shift_kind kind = LSL, unsigned shift = 0) {   \
1486     starti;                                                     \
1487     guarantee(size == 1 || shift &lt; 32, &quot;incorrect shift&quot;);      \
1488     f(N, 21);                                                   \
1489     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                        \
1490     op_shifted_reg(0b01010, kind, shift, size, op);             \
1491   }
1492 
1493   INSN(andr, 1, 0b00, 0);
1494   INSN(orr, 1, 0b01, 0);
1495   INSN(eor, 1, 0b10, 0);
1496   INSN(ands, 1, 0b11, 0);
1497   INSN(andw, 0, 0b00, 0);
1498   INSN(orrw, 0, 0b01, 0);
1499   INSN(eorw, 0, 0b10, 0);
1500   INSN(andsw, 0, 0b11, 0);
1501 
1502 #undef INSN
1503 
1504 #define INSN(NAME, size, op, N)                                         \
1505   void NAME(Register Rd, Register Rn, Register Rm,                      \
1506             enum shift_kind kind = LSL, unsigned shift = 0) {           \
1507     starti;                                                             \
1508     f(N, 21);                                                           \
1509     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \
1510     op_shifted_reg(0b01010, kind, shift, size, op);                     \
1511   }                                                                     \
1512                                                                         \
1513   /* These instructions have no immediate form. Provide an overload so  \
1514      that if anyone does try to use an immediate operand -- this has    \
1515      happened! -- we&#39;ll get a compile-time error. */                    \
1516   void NAME(Register Rd, Register Rn, unsigned imm,                     \
1517             enum shift_kind kind = LSL, unsigned shift = 0) {           \
1518     assert(false, &quot; can&#39;t be used with immediate operand&quot;);             \
1519   }
1520 
1521   INSN(bic, 1, 0b00, 1);
1522   INSN(orn, 1, 0b01, 1);
1523   INSN(eon, 1, 0b10, 1);
1524   INSN(bics, 1, 0b11, 1);
1525   INSN(bicw, 0, 0b00, 1);
1526   INSN(ornw, 0, 0b01, 1);
1527   INSN(eonw, 0, 0b10, 1);
1528   INSN(bicsw, 0, 0b11, 1);
1529 
1530 #undef INSN
1531 
1532   // Aliases for short forms of orn
1533 void mvn(Register Rd, Register Rm,
1534             enum shift_kind kind = LSL, unsigned shift = 0) {
1535   orn(Rd, zr, Rm, kind, shift);
1536 }
1537 
1538 void mvnw(Register Rd, Register Rm,
1539             enum shift_kind kind = LSL, unsigned shift = 0) {
1540   ornw(Rd, zr, Rm, kind, shift);
1541 }
1542 
1543   // Add/subtract (shifted register)
1544 #define INSN(NAME, size, op)                            \
1545   void NAME(Register Rd, Register Rn, Register Rm,      \
1546             enum shift_kind kind, unsigned shift = 0) { \
1547     starti;                                             \
1548     f(0, 21);                                           \
1549     assert_cond(kind != ROR);                           \
1550     guarantee(size == 1 || shift &lt; 32, &quot;incorrect shift&quot;);\
1551     zrf(Rd, 0), zrf(Rn, 5), zrf(Rm, 16);                \
1552     op_shifted_reg(0b01011, kind, shift, size, op);     \
1553   }
1554 
1555   INSN(add, 1, 0b000);
1556   INSN(sub, 1, 0b10);
1557   INSN(addw, 0, 0b000);
1558   INSN(subw, 0, 0b10);
1559 
1560   INSN(adds, 1, 0b001);
1561   INSN(subs, 1, 0b11);
1562   INSN(addsw, 0, 0b001);
1563   INSN(subsw, 0, 0b11);
1564 
1565 #undef INSN
1566 
1567   // Add/subtract (extended register)
1568 #define INSN(NAME, op)                                                  \
1569   void NAME(Register Rd, Register Rn, Register Rm,                      \
1570            ext::operation option, int amount = 0) {                     \
1571     starti;                                                             \
1572     zrf(Rm, 16), srf(Rn, 5), srf(Rd, 0);                                \
1573     add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \
1574   }
1575 
1576   void add_sub_extended_reg(unsigned op, unsigned decode,
1577     Register Rd, Register Rn, Register Rm,
1578     unsigned opt, ext::operation option, unsigned imm) {
1579     guarantee(imm &lt;= 4, &quot;shift amount must be &lt;= 4&quot;);
1580     f(op, 31, 29), f(decode, 28, 24), f(opt, 23, 22), f(1, 21);
1581     f(option, 15, 13), f(imm, 12, 10);
1582   }
1583 
1584   INSN(addw, 0b000);
1585   INSN(subw, 0b010);
1586   INSN(add, 0b100);
1587   INSN(sub, 0b110);
1588 
1589 #undef INSN
1590 
1591 #define INSN(NAME, op)                                                  \
1592   void NAME(Register Rd, Register Rn, Register Rm,                      \
1593            ext::operation option, int amount = 0) {                     \
1594     starti;                                                             \
1595     zrf(Rm, 16), srf(Rn, 5), zrf(Rd, 0);                                \
1596     add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \
1597   }
1598 
1599   INSN(addsw, 0b001);
1600   INSN(subsw, 0b011);
1601   INSN(adds, 0b101);
1602   INSN(subs, 0b111);
1603 
1604 #undef INSN
1605 
1606   // Aliases for short forms of add and sub
1607 #define INSN(NAME)                                      \
1608   void NAME(Register Rd, Register Rn, Register Rm) {    \
1609     if (Rd == sp || Rn == sp)                           \
1610       NAME(Rd, Rn, Rm, ext::uxtx);                      \
1611     else                                                \
1612       NAME(Rd, Rn, Rm, LSL);                            \
1613   }
1614 
1615   INSN(addw);
1616   INSN(subw);
1617   INSN(add);
1618   INSN(sub);
1619 
1620   INSN(addsw);
1621   INSN(subsw);
1622   INSN(adds);
1623   INSN(subs);
1624 
1625 #undef INSN
1626 
1627   // Add/subtract (with carry)
1628   void add_sub_carry(unsigned op, Register Rd, Register Rn, Register Rm) {
1629     starti;
1630     f(op, 31, 29);
1631     f(0b11010000, 28, 21);
1632     f(0b000000, 15, 10);
1633     zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);
1634   }
1635 
1636   #define INSN(NAME, op)                                \
1637     void NAME(Register Rd, Register Rn, Register Rm) {  \
1638       add_sub_carry(op, Rd, Rn, Rm);                    \
1639     }
1640 
1641   INSN(adcw, 0b000);
1642   INSN(adcsw, 0b001);
1643   INSN(sbcw, 0b010);
1644   INSN(sbcsw, 0b011);
1645   INSN(adc, 0b100);
1646   INSN(adcs, 0b101);
1647   INSN(sbc,0b110);
1648   INSN(sbcs, 0b111);
1649 
1650 #undef INSN
1651 
1652   // Conditional compare (both kinds)
1653   void conditional_compare(unsigned op, int o1, int o2, int o3,
1654                            Register Rn, unsigned imm5, unsigned nzcv,
1655                            unsigned cond) {
1656     starti;
1657     f(op, 31, 29);
1658     f(0b11010010, 28, 21);
1659     f(cond, 15, 12);
1660     f(o1, 11);
1661     f(o2, 10);
1662     f(o3, 4);
1663     f(nzcv, 3, 0);
1664     f(imm5, 20, 16), zrf(Rn, 5);
1665   }
1666 
1667 #define INSN(NAME, op)                                                  \
1668   void NAME(Register Rn, Register Rm, int imm, Condition cond) {        \
1669     int regNumber = (Rm == zr ? 31 : (uintptr_t)Rm);                    \
1670     conditional_compare(op, 0, 0, 0, Rn, regNumber, imm, cond);         \
1671   }                                                                     \
1672                                                                         \
1673   void NAME(Register Rn, int imm5, int imm, Condition cond) {           \
1674     conditional_compare(op, 1, 0, 0, Rn, imm5, imm, cond);              \
1675   }
1676 
1677   INSN(ccmnw, 0b001);
1678   INSN(ccmpw, 0b011);
1679   INSN(ccmn, 0b101);
1680   INSN(ccmp, 0b111);
1681 
1682 #undef INSN
1683 
1684   // Conditional select
1685   void conditional_select(unsigned op, unsigned op2,
1686                           Register Rd, Register Rn, Register Rm,
1687                           unsigned cond) {
1688     starti;
1689     f(op, 31, 29);
1690     f(0b11010100, 28, 21);
1691     f(cond, 15, 12);
1692     f(op2, 11, 10);
1693     zrf(Rm, 16), zrf(Rn, 5), rf(Rd, 0);
1694   }
1695 
1696 #define INSN(NAME, op, op2)                                             \
1697   void NAME(Register Rd, Register Rn, Register Rm, Condition cond) { \
1698     conditional_select(op, op2, Rd, Rn, Rm, cond);                      \
1699   }
1700 
1701   INSN(cselw, 0b000, 0b00);
1702   INSN(csincw, 0b000, 0b01);
1703   INSN(csinvw, 0b010, 0b00);
1704   INSN(csnegw, 0b010, 0b01);
1705   INSN(csel, 0b100, 0b00);
1706   INSN(csinc, 0b100, 0b01);
1707   INSN(csinv, 0b110, 0b00);
1708   INSN(csneg, 0b110, 0b01);
1709 
1710 #undef INSN
1711 
1712   // Data processing
1713   void data_processing(unsigned op29, unsigned opcode,
1714                        Register Rd, Register Rn) {
1715     f(op29, 31, 29), f(0b11010110, 28, 21);
1716     f(opcode, 15, 10);
1717     rf(Rn, 5), rf(Rd, 0);
1718   }
1719 
1720   // (1 source)
1721 #define INSN(NAME, op29, opcode2, opcode)       \
1722   void NAME(Register Rd, Register Rn) {         \
1723     starti;                                     \
1724     f(opcode2, 20, 16);                         \
1725     data_processing(op29, opcode, Rd, Rn);      \
1726   }
1727 
1728   INSN(rbitw,  0b010, 0b00000, 0b00000);
1729   INSN(rev16w, 0b010, 0b00000, 0b00001);
1730   INSN(revw,   0b010, 0b00000, 0b00010);
1731   INSN(clzw,   0b010, 0b00000, 0b00100);
1732   INSN(clsw,   0b010, 0b00000, 0b00101);
1733 
1734   INSN(rbit,   0b110, 0b00000, 0b00000);
1735   INSN(rev16,  0b110, 0b00000, 0b00001);
1736   INSN(rev32,  0b110, 0b00000, 0b00010);
1737   INSN(rev,    0b110, 0b00000, 0b00011);
1738   INSN(clz,    0b110, 0b00000, 0b00100);
1739   INSN(cls,    0b110, 0b00000, 0b00101);
1740 
1741 #undef INSN
1742 
1743   // (2 sources)
1744 #define INSN(NAME, op29, opcode)                        \
1745   void NAME(Register Rd, Register Rn, Register Rm) {    \
1746     starti;                                             \
1747     rf(Rm, 16);                                         \
1748     data_processing(op29, opcode, Rd, Rn);              \
1749   }
1750 
1751   INSN(udivw, 0b000, 0b000010);
1752   INSN(sdivw, 0b000, 0b000011);
1753   INSN(lslvw, 0b000, 0b001000);
1754   INSN(lsrvw, 0b000, 0b001001);
1755   INSN(asrvw, 0b000, 0b001010);
1756   INSN(rorvw, 0b000, 0b001011);
1757 
1758   INSN(udiv, 0b100, 0b000010);
1759   INSN(sdiv, 0b100, 0b000011);
1760   INSN(lslv, 0b100, 0b001000);
1761   INSN(lsrv, 0b100, 0b001001);
1762   INSN(asrv, 0b100, 0b001010);
1763   INSN(rorv, 0b100, 0b001011);
1764 
1765 #undef INSN
1766 
1767   // (3 sources)
1768   void data_processing(unsigned op54, unsigned op31, unsigned o0,
1769                        Register Rd, Register Rn, Register Rm,
1770                        Register Ra) {
1771     starti;
1772     f(op54, 31, 29), f(0b11011, 28, 24);
1773     f(op31, 23, 21), f(o0, 15);
1774     zrf(Rm, 16), zrf(Ra, 10), zrf(Rn, 5), zrf(Rd, 0);
1775   }
1776 
1777 #define INSN(NAME, op54, op31, o0)                                      \
1778   void NAME(Register Rd, Register Rn, Register Rm, Register Ra) {       \
1779     data_processing(op54, op31, o0, Rd, Rn, Rm, Ra);                    \
1780   }
1781 
1782   INSN(maddw, 0b000, 0b000, 0);
1783   INSN(msubw, 0b000, 0b000, 1);
1784   INSN(madd, 0b100, 0b000, 0);
1785   INSN(msub, 0b100, 0b000, 1);
1786   INSN(smaddl, 0b100, 0b001, 0);
1787   INSN(smsubl, 0b100, 0b001, 1);
1788   INSN(umaddl, 0b100, 0b101, 0);
1789   INSN(umsubl, 0b100, 0b101, 1);
1790 
1791 #undef INSN
1792 
1793 #define INSN(NAME, op54, op31, o0)                      \
1794   void NAME(Register Rd, Register Rn, Register Rm) {    \
1795     data_processing(op54, op31, o0, Rd, Rn, Rm, (Register)31);  \
1796   }
1797 
1798   INSN(smulh, 0b100, 0b010, 0);
1799   INSN(umulh, 0b100, 0b110, 0);
1800 
1801 #undef INSN
1802 
1803   // Floating-point data-processing (1 source)
1804   void data_processing(unsigned op31, unsigned type, unsigned opcode,
1805                        FloatRegister Vd, FloatRegister Vn) {
1806     starti;
1807     f(op31, 31, 29);
1808     f(0b11110, 28, 24);
1809     f(type, 23, 22), f(1, 21), f(opcode, 20, 15), f(0b10000, 14, 10);
1810     rf(Vn, 5), rf(Vd, 0);
1811   }
1812 
1813 #define INSN(NAME, op31, type, opcode)                  \
1814   void NAME(FloatRegister Vd, FloatRegister Vn) {       \
1815     data_processing(op31, type, opcode, Vd, Vn);        \
1816   }
1817 
1818 private:
1819   INSN(i_fmovs, 0b000, 0b00, 0b000000);
1820 public:
1821   INSN(fabss, 0b000, 0b00, 0b000001);
1822   INSN(fnegs, 0b000, 0b00, 0b000010);
1823   INSN(fsqrts, 0b000, 0b00, 0b000011);
1824   INSN(fcvts, 0b000, 0b00, 0b000101);   // Single-precision to double-precision
1825 
1826 private:
1827   INSN(i_fmovd, 0b000, 0b01, 0b000000);
1828 public:
1829   INSN(fabsd, 0b000, 0b01, 0b000001);
1830   INSN(fnegd, 0b000, 0b01, 0b000010);
1831   INSN(fsqrtd, 0b000, 0b01, 0b000011);
1832   INSN(fcvtd, 0b000, 0b01, 0b000100);   // Double-precision to single-precision
1833 
1834   void fmovd(FloatRegister Vd, FloatRegister Vn) {
1835     assert(Vd != Vn, &quot;should be&quot;);
1836     i_fmovd(Vd, Vn);
1837   }
1838 
1839   void fmovs(FloatRegister Vd, FloatRegister Vn) {
1840     assert(Vd != Vn, &quot;should be&quot;);
1841     i_fmovs(Vd, Vn);
1842   }
1843 
1844 #undef INSN
1845 
1846   // Floating-point data-processing (2 source)
1847   void data_processing(unsigned op31, unsigned type, unsigned opcode,
1848                        FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {
1849     starti;
1850     f(op31, 31, 29);
1851     f(0b11110, 28, 24);
1852     f(type, 23, 22), f(1, 21), f(opcode, 15, 12), f(0b10, 11, 10);
1853     rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);
1854   }
1855 
1856 #define INSN(NAME, op31, type, opcode)                  \
1857   void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {     \
1858     data_processing(op31, type, opcode, Vd, Vn, Vm);    \
1859   }
1860 
1861   INSN(fmuls, 0b000, 0b00, 0b0000);
1862   INSN(fdivs, 0b000, 0b00, 0b0001);
1863   INSN(fadds, 0b000, 0b00, 0b0010);
1864   INSN(fsubs, 0b000, 0b00, 0b0011);
1865   INSN(fmaxs, 0b000, 0b00, 0b0100);
1866   INSN(fmins, 0b000, 0b00, 0b0101);
1867   INSN(fnmuls, 0b000, 0b00, 0b1000);
1868 
1869   INSN(fmuld, 0b000, 0b01, 0b0000);
1870   INSN(fdivd, 0b000, 0b01, 0b0001);
1871   INSN(faddd, 0b000, 0b01, 0b0010);
1872   INSN(fsubd, 0b000, 0b01, 0b0011);
1873   INSN(fmaxd, 0b000, 0b01, 0b0100);
1874   INSN(fmind, 0b000, 0b01, 0b0101);
1875   INSN(fnmuld, 0b000, 0b01, 0b1000);
1876 
1877 #undef INSN
1878 
1879    // Floating-point data-processing (3 source)
1880   void data_processing(unsigned op31, unsigned type, unsigned o1, unsigned o0,
1881                        FloatRegister Vd, FloatRegister Vn, FloatRegister Vm,
1882                        FloatRegister Va) {
1883     starti;
1884     f(op31, 31, 29);
1885     f(0b11111, 28, 24);
1886     f(type, 23, 22), f(o1, 21), f(o0, 15);
1887     rf(Vm, 16), rf(Va, 10), rf(Vn, 5), rf(Vd, 0);
1888   }
1889 
1890 #define INSN(NAME, op31, type, o1, o0)                                  \
1891   void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm,       \
1892             FloatRegister Va) {                                         \
1893     data_processing(op31, type, o1, o0, Vd, Vn, Vm, Va);                \
1894   }
1895 
1896   INSN(fmadds, 0b000, 0b00, 0, 0);
1897   INSN(fmsubs, 0b000, 0b00, 0, 1);
1898   INSN(fnmadds, 0b000, 0b00, 1, 0);
1899   INSN(fnmsubs, 0b000, 0b00, 1, 1);
1900 
1901   INSN(fmaddd, 0b000, 0b01, 0, 0);
1902   INSN(fmsubd, 0b000, 0b01, 0, 1);
1903   INSN(fnmaddd, 0b000, 0b01, 1, 0);
1904   INSN(fnmsub, 0b000, 0b01, 1, 1);
1905 
1906 #undef INSN
1907 
1908    // Floating-point conditional select
1909   void fp_conditional_select(unsigned op31, unsigned type,
1910                              unsigned op1, unsigned op2,
1911                              Condition cond, FloatRegister Vd,
1912                              FloatRegister Vn, FloatRegister Vm) {
1913     starti;
1914     f(op31, 31, 29);
1915     f(0b11110, 28, 24);
1916     f(type, 23, 22);
1917     f(op1, 21, 21);
1918     f(op2, 11, 10);
1919     f(cond, 15, 12);
1920     rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);
1921   }
1922 
1923 #define INSN(NAME, op31, type, op1, op2)                                \
1924   void NAME(FloatRegister Vd, FloatRegister Vn,                         \
1925             FloatRegister Vm, Condition cond) {                         \
1926     fp_conditional_select(op31, type, op1, op2, cond, Vd, Vn, Vm);      \
1927   }
1928 
1929   INSN(fcsels, 0b000, 0b00, 0b1, 0b11);
1930   INSN(fcseld, 0b000, 0b01, 0b1, 0b11);
1931 
1932 #undef INSN
1933 
1934    // Floating-point&lt;-&gt;integer conversions
1935   void float_int_convert(unsigned op31, unsigned type,
1936                          unsigned rmode, unsigned opcode,
1937                          Register Rd, Register Rn) {
1938     starti;
1939     f(op31, 31, 29);
1940     f(0b11110, 28, 24);
1941     f(type, 23, 22), f(1, 21), f(rmode, 20, 19);
1942     f(opcode, 18, 16), f(0b000000, 15, 10);
1943     zrf(Rn, 5), zrf(Rd, 0);
1944   }
1945 
1946 #define INSN(NAME, op31, type, rmode, opcode)                           \
1947   void NAME(Register Rd, FloatRegister Vn) {                            \
1948     float_int_convert(op31, type, rmode, opcode, Rd, (Register)Vn);     \
1949   }
1950 
1951   INSN(fcvtzsw, 0b000, 0b00, 0b11, 0b000);
1952   INSN(fcvtzs,  0b100, 0b00, 0b11, 0b000);
1953   INSN(fcvtzdw, 0b000, 0b01, 0b11, 0b000);
1954   INSN(fcvtzd,  0b100, 0b01, 0b11, 0b000);
1955 
1956   INSN(fmovs, 0b000, 0b00, 0b00, 0b110);
1957   INSN(fmovd, 0b100, 0b01, 0b00, 0b110);
1958 
1959   // INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);
1960 
1961 #undef INSN
1962 
1963 #define INSN(NAME, op31, type, rmode, opcode)                           \
1964   void NAME(FloatRegister Vd, Register Rn) {                            \
1965     float_int_convert(op31, type, rmode, opcode, (Register)Vd, Rn);     \
1966   }
1967 
1968   INSN(fmovs, 0b000, 0b00, 0b00, 0b111);
1969   INSN(fmovd, 0b100, 0b01, 0b00, 0b111);
1970 
1971   INSN(scvtfws, 0b000, 0b00, 0b00, 0b010);
1972   INSN(scvtfs,  0b100, 0b00, 0b00, 0b010);
1973   INSN(scvtfwd, 0b000, 0b01, 0b00, 0b010);
1974   INSN(scvtfd,  0b100, 0b01, 0b00, 0b010);
1975 
1976   // INSN(fmovhid, 0b100, 0b10, 0b01, 0b111);
1977 
1978 #undef INSN
1979 
1980   // Floating-point compare
1981   void float_compare(unsigned op31, unsigned type,
1982                      unsigned op, unsigned op2,
1983                      FloatRegister Vn, FloatRegister Vm = (FloatRegister)0) {
1984     starti;
1985     f(op31, 31, 29);
1986     f(0b11110, 28, 24);
1987     f(type, 23, 22), f(1, 21);
1988     f(op, 15, 14), f(0b1000, 13, 10), f(op2, 4, 0);
1989     rf(Vn, 5), rf(Vm, 16);
1990   }
1991 
1992 
1993 #define INSN(NAME, op31, type, op, op2)                 \
1994   void NAME(FloatRegister Vn, FloatRegister Vm) {       \
1995     float_compare(op31, type, op, op2, Vn, Vm);         \
1996   }
1997 
1998 #define INSN1(NAME, op31, type, op, op2)        \
1999   void NAME(FloatRegister Vn, double d) {       \
2000     assert_cond(d == 0.0);                      \
2001     float_compare(op31, type, op, op2, Vn);     \
2002   }
2003 
2004   INSN(fcmps, 0b000, 0b00, 0b00, 0b00000);
2005   INSN1(fcmps, 0b000, 0b00, 0b00, 0b01000);
2006   // INSN(fcmpes, 0b000, 0b00, 0b00, 0b10000);
2007   // INSN1(fcmpes, 0b000, 0b00, 0b00, 0b11000);
2008 
2009   INSN(fcmpd, 0b000,   0b01, 0b00, 0b00000);
2010   INSN1(fcmpd, 0b000,  0b01, 0b00, 0b01000);
2011   // INSN(fcmped, 0b000,  0b01, 0b00, 0b10000);
2012   // INSN1(fcmped, 0b000, 0b01, 0b00, 0b11000);
2013 
2014 #undef INSN
2015 #undef INSN1
2016 
2017   // Floating-point Move (immediate)
2018 private:
2019   unsigned pack(double value);
2020 
2021   void fmov_imm(FloatRegister Vn, double value, unsigned size) {
2022     starti;
2023     f(0b00011110, 31, 24), f(size, 23, 22), f(1, 21);
2024     f(pack(value), 20, 13), f(0b10000000, 12, 5);
2025     rf(Vn, 0);
2026   }
2027 
2028 public:
2029 
2030   void fmovs(FloatRegister Vn, double value) {
2031     if (value)
2032       fmov_imm(Vn, value, 0b00);
2033     else
2034       fmovs(Vn, zr);
2035   }
2036   void fmovd(FloatRegister Vn, double value) {
2037     if (value)
2038       fmov_imm(Vn, value, 0b01);
2039     else
2040       fmovd(Vn, zr);
2041   }
2042 
2043    // Floating-point rounding
2044    // type: half-precision = 11
2045    //       single         = 00
2046    //       double         = 01
2047    // rmode: A = Away     = 100
2048    //        I = current  = 111
2049    //        M = MinusInf = 010
2050    //        N = eveN     = 000
2051    //        P = PlusInf  = 001
2052    //        X = eXact    = 110
2053    //        Z = Zero     = 011
2054   void float_round(unsigned type, unsigned rmode, FloatRegister Rd, FloatRegister Rn) {
2055     starti;
2056     f(0b00011110, 31, 24);
2057     f(type, 23, 22);
2058     f(0b1001, 21, 18);
2059     f(rmode, 17, 15);
2060     f(0b10000, 14, 10);
2061     rf(Rn, 5), rf(Rd, 0);
2062   }
2063 #define INSN(NAME, type, rmode)                   \
2064   void NAME(FloatRegister Vd, FloatRegister Vn) { \
2065     float_round(type, rmode, Vd, Vn);             \
2066   }
2067 
2068 public:
2069   INSN(frintah, 0b11, 0b100);
2070   INSN(frintih, 0b11, 0b111);
2071   INSN(frintmh, 0b11, 0b010);
2072   INSN(frintnh, 0b11, 0b000);
2073   INSN(frintph, 0b11, 0b001);
2074   INSN(frintxh, 0b11, 0b110);
2075   INSN(frintzh, 0b11, 0b011);
2076 
2077   INSN(frintas, 0b00, 0b100);
2078   INSN(frintis, 0b00, 0b111);
2079   INSN(frintms, 0b00, 0b010);
2080   INSN(frintns, 0b00, 0b000);
2081   INSN(frintps, 0b00, 0b001);
2082   INSN(frintxs, 0b00, 0b110);
2083   INSN(frintzs, 0b00, 0b011);
2084 
2085   INSN(frintad, 0b01, 0b100);
2086   INSN(frintid, 0b01, 0b111);
2087   INSN(frintmd, 0b01, 0b010);
2088   INSN(frintnd, 0b01, 0b000);
2089   INSN(frintpd, 0b01, 0b001);
2090   INSN(frintxd, 0b01, 0b110);
2091   INSN(frintzd, 0b01, 0b011);
2092 #undef INSN
2093 
2094 /* SIMD extensions
2095  *
2096  * We just use FloatRegister in the following. They are exactly the same
2097  * as SIMD registers.
2098  */
2099  public:
2100 
2101   enum SIMD_Arrangement {
2102        T8B, T16B, T4H, T8H, T2S, T4S, T1D, T2D, T1Q
2103   };
2104 
2105   enum SIMD_RegVariant {
2106        B, H, S, D, Q
2107   };
2108 
2109 private:
2110   static short SIMD_Size_in_bytes[];
2111 
2112 public:
2113 #define INSN(NAME, op)                                            \
2114   void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &amp;adr) {   \
2115     ld_st2((Register)Rt, adr, (int)T &amp; 3, op + ((T==Q) ? 0b10:0b00), 1); \
2116   }                                                                      \
2117 
2118   INSN(ldr, 1);
2119   INSN(str, 0);
2120 
2121 #undef INSN
2122 
2123  private:
2124 
2125   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn, int op1, int op2) {
2126     starti;
2127     f(0,31), f((int)T &amp; 1, 30);
2128     f(op1, 29, 21), f(0, 20, 16), f(op2, 15, 12);
2129     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2130   }
2131   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
2132              int imm, int op1, int op2, int regs) {
2133 
2134     bool replicate = op2 &gt;&gt; 2 == 3;
2135     // post-index value (imm) is formed differently for replicate/non-replicate ld* instructions
2136     int expectedImmediate = replicate ? regs * (1 &lt;&lt; (T &gt;&gt; 1)) : SIMD_Size_in_bytes[T] * regs;
2137     guarantee(T &lt; T1Q , &quot;incorrect arrangement&quot;);
2138     guarantee(imm == expectedImmediate, &quot;bad offset&quot;);
2139     starti;
2140     f(0,31), f((int)T &amp; 1, 30);
2141     f(op1 | 0b100, 29, 21), f(0b11111, 20, 16), f(op2, 15, 12);
2142     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2143   }
2144   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Register Xn,
2145              Register Xm, int op1, int op2) {
2146     starti;
2147     f(0,31), f((int)T &amp; 1, 30);
2148     f(op1 | 0b100, 29, 21), rf(Xm, 16), f(op2, 15, 12);
2149     f((int)T &gt;&gt; 1, 11, 10), srf(Xn, 5), rf(Vt, 0);
2150   }
2151 
2152   void ld_st(FloatRegister Vt, SIMD_Arrangement T, Address a, int op1, int op2, int regs) {
2153     switch (a.getMode()) {
2154     case Address::base_plus_offset:
2155       guarantee(a.offset() == 0, &quot;no offset allowed here&quot;);
2156       ld_st(Vt, T, a.base(), op1, op2);
2157       break;
2158     case Address::post:
2159       ld_st(Vt, T, a.base(), a.offset(), op1, op2, regs);
2160       break;
2161     case Address::post_reg:
2162       ld_st(Vt, T, a.base(), a.index(), op1, op2);
2163       break;
2164     default:
2165       ShouldNotReachHere();
2166     }
2167   }
2168 
2169  public:
2170 
2171 #define INSN1(NAME, op1, op2)                                           \
2172   void NAME(FloatRegister Vt, SIMD_Arrangement T, const Address &amp;a) {   \
2173     ld_st(Vt, T, a, op1, op2, 1);                                       \
2174  }
2175 
2176 #define INSN2(NAME, op1, op2)                                           \
2177   void NAME(FloatRegister Vt, FloatRegister Vt2, SIMD_Arrangement T, const Address &amp;a) { \
2178     assert(Vt-&gt;successor() == Vt2, &quot;Registers must be ordered&quot;);        \
2179     ld_st(Vt, T, a, op1, op2, 2);                                       \
2180   }
2181 
2182 #define INSN3(NAME, op1, op2)                                           \
2183   void NAME(FloatRegister Vt, FloatRegister Vt2, FloatRegister Vt3,     \
2184             SIMD_Arrangement T, const Address &amp;a) {                     \
2185     assert(Vt-&gt;successor() == Vt2 &amp;&amp; Vt2-&gt;successor() == Vt3,           \
2186            &quot;Registers must be ordered&quot;);                                \
2187     ld_st(Vt, T, a, op1, op2, 3);                                       \
2188   }
2189 
2190 #define INSN4(NAME, op1, op2)                                           \
2191   void NAME(FloatRegister Vt, FloatRegister Vt2, FloatRegister Vt3,     \
2192             FloatRegister Vt4, SIMD_Arrangement T, const Address &amp;a) {  \
2193     assert(Vt-&gt;successor() == Vt2 &amp;&amp; Vt2-&gt;successor() == Vt3 &amp;&amp;         \
2194            Vt3-&gt;successor() == Vt4, &quot;Registers must be ordered&quot;);       \
2195     ld_st(Vt, T, a, op1, op2, 4);                                       \
2196   }
2197 
2198   INSN1(ld1,  0b001100010, 0b0111);
2199   INSN2(ld1,  0b001100010, 0b1010);
2200   INSN3(ld1,  0b001100010, 0b0110);
2201   INSN4(ld1,  0b001100010, 0b0010);
2202 
2203   INSN2(ld2,  0b001100010, 0b1000);
2204   INSN3(ld3,  0b001100010, 0b0100);
2205   INSN4(ld4,  0b001100010, 0b0000);
2206 
2207   INSN1(st1,  0b001100000, 0b0111);
2208   INSN2(st1,  0b001100000, 0b1010);
2209   INSN3(st1,  0b001100000, 0b0110);
2210   INSN4(st1,  0b001100000, 0b0010);
2211 
2212   INSN2(st2,  0b001100000, 0b1000);
2213   INSN3(st3,  0b001100000, 0b0100);
2214   INSN4(st4,  0b001100000, 0b0000);
2215 
2216   INSN1(ld1r, 0b001101010, 0b1100);
2217   INSN2(ld2r, 0b001101011, 0b1100);
2218   INSN3(ld3r, 0b001101010, 0b1110);
2219   INSN4(ld4r, 0b001101011, 0b1110);
2220 
2221 #undef INSN1
2222 #undef INSN2
2223 #undef INSN3
2224 #undef INSN4
2225 
2226 #define INSN(NAME, opc)                                                                 \
2227   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2228     starti;                                                                             \
2229     assert(T == T8B || T == T16B, &quot;must be T8B or T16B&quot;);                               \
2230     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29, 21);                                        \
2231     rf(Vm, 16), f(0b000111, 15, 10), rf(Vn, 5), rf(Vd, 0);                              \
2232   }
2233 
2234   INSN(eor,  0b101110001);
2235   INSN(orr,  0b001110101);
2236   INSN(andr, 0b001110001);
2237   INSN(bic,  0b001110011);
2238   INSN(bif,  0b101110111);
2239   INSN(bit,  0b101110101);
2240   INSN(bsl,  0b101110011);
2241   INSN(orn,  0b001110111);
2242 
2243 #undef INSN
2244 
2245 #define INSN(NAME, opc, opc2, acceptT2D)                                                \
2246   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2247     guarantee(T != T1Q &amp;&amp; T != T1D, &quot;incorrect arrangement&quot;);                           \
2248     if (!acceptT2D) guarantee(T != T2D, &quot;incorrect arrangement&quot;);                       \
2249     starti;                                                                             \
2250     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
2251     f((int)T &gt;&gt; 1, 23, 22), f(1, 21), rf(Vm, 16), f(opc2, 15, 10);                      \
2252     rf(Vn, 5), rf(Vd, 0);                                                               \
2253   }
2254 
2255   INSN(addv,   0, 0b100001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D
2256   INSN(subv,   1, 0b100001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D
2257   INSN(mulv,   0, 0b100111, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S
2258   INSN(mlav,   0, 0b100101, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S
2259   INSN(mlsv,   1, 0b100101, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S
2260   INSN(sshl,   0, 0b010001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D
2261   INSN(ushl,   1, 0b010001, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D
2262   INSN(addpv,  0, 0b101111, true);  // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D
2263   INSN(smullv, 0, 0b110000, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S
2264   INSN(umullv, 1, 0b110000, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S
2265   INSN(umlalv, 1, 0b100000, false); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S
2266 
2267 #undef INSN
2268 
2269 #define INSN(NAME, opc, opc2, accepted) \
2270   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                   \
2271     guarantee(T != T1Q &amp;&amp; T != T1D, &quot;incorrect arrangement&quot;);                           \
2272     if (accepted &lt; 3) guarantee(T != T2D, &quot;incorrect arrangement&quot;);                     \
2273     if (accepted &lt; 2) guarantee(T != T2S, &quot;incorrect arrangement&quot;);                     \
2274     if (accepted &lt; 1) guarantee(T == T8B || T == T16B, &quot;incorrect arrangement&quot;);        \
2275     starti;                                                                             \
2276     f(0, 31), f((int)T &amp; 1, 30), f(opc, 29), f(0b01110, 28, 24);                        \
2277     f((int)T &gt;&gt; 1, 23, 22), f(opc2, 21, 10);                                            \
2278     rf(Vn, 5), rf(Vd, 0);                                                               \
2279   }
2280 
2281   INSN(absr,   0, 0b100000101110, 3); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D
2282   INSN(negr,   1, 0b100000101110, 3); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D
2283   INSN(notr,   1, 0b100000010110, 0); // accepted arrangements: T8B, T16B
2284   INSN(addv,   0, 0b110001101110, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S
2285   INSN(cls,    0, 0b100000010010, 2); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S
2286   INSN(clz,    1, 0b100000010010, 2); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S
2287   INSN(cnt,    0, 0b100000010110, 0); // accepted arrangements: T8B, T16B
2288   INSN(uaddlp, 1, 0b100000001010, 2); // accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S
2289   INSN(uaddlv, 1, 0b110000001110, 1); // accepted arrangements: T8B, T16B, T4H, T8H,      T4S
2290 
2291 #undef INSN
2292 
2293 #define INSN(NAME, opc) \
2294   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                  \
2295     starti;                                                                            \
2296     assert(T == T4S, &quot;arrangement must be T4S&quot;);                                       \
2297     f(0, 31), f((int)T &amp; 1, 30), f(0b101110, 29, 24), f(opc, 23),                      \
2298     f(T == T4S ? 0 : 1, 22), f(0b110000111110, 21, 10); rf(Vn, 5), rf(Vd, 0);          \
2299   }
2300 
2301   INSN(fmaxv, 0);
2302   INSN(fminv, 1);
2303 
2304 #undef INSN
2305 
2306 #define INSN(NAME, op0, cmode0) \
2307   void NAME(FloatRegister Vd, SIMD_Arrangement T, unsigned imm8, unsigned lsl = 0) {   \
2308     unsigned cmode = cmode0;                                                           \
2309     unsigned op = op0;                                                                 \
2310     starti;                                                                            \
2311     assert(lsl == 0 ||                                                                 \
2312            ((T == T4H || T == T8H) &amp;&amp; lsl == 8) ||                                     \
2313            ((T == T2S || T == T4S) &amp;&amp; ((lsl &gt;&gt; 3) &lt; 4) &amp;&amp; ((lsl &amp; 7) == 0)), &quot;invalid shift&quot;);\
2314     cmode |= lsl &gt;&gt; 2;                                                                 \
2315     if (T == T4H || T == T8H) cmode |= 0b1000;                                         \
2316     if (!(T == T4H || T == T8H || T == T2S || T == T4S)) {                             \
2317       assert(op == 0 &amp;&amp; cmode0 == 0, &quot;must be MOVI&quot;);                                  \
2318       cmode = 0b1110;                                                                  \
2319       if (T == T1D || T == T2D) op = 1;                                                \
2320     }                                                                                  \
2321     f(0, 31), f((int)T &amp; 1, 30), f(op, 29), f(0b0111100000, 28, 19);                   \
2322     f(imm8 &gt;&gt; 5, 18, 16), f(cmode, 15, 12), f(0x01, 11, 10), f(imm8 &amp; 0b11111, 9, 5);  \
2323     rf(Vd, 0);                                                                         \
2324   }
2325 
2326   INSN(movi, 0, 0);
2327   INSN(orri, 0, 1);
2328   INSN(mvni, 1, 0);
2329   INSN(bici, 1, 1);
2330 
2331 #undef INSN
2332 
2333 #define INSN(NAME, op1, op2, op3) \
2334   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2335     starti;                                                                             \
2336     assert(T == T2S || T == T4S || T == T2D, &quot;invalid arrangement&quot;);                    \
2337     f(0, 31), f((int)T &amp; 1, 30), f(op1, 29), f(0b01110, 28, 24), f(op2, 23);            \
2338     f(T==T2D ? 1:0, 22); f(1, 21), rf(Vm, 16), f(op3, 15, 10), rf(Vn, 5), rf(Vd, 0);    \
2339   }
2340 
2341   INSN(fadd, 0, 0, 0b110101);
2342   INSN(fdiv, 1, 0, 0b111111);
2343   INSN(fmul, 1, 0, 0b110111);
2344   INSN(fsub, 0, 1, 0b110101);
2345   INSN(fmla, 0, 0, 0b110011);
2346   INSN(fmls, 0, 1, 0b110011);
2347   INSN(fmax, 0, 0, 0b111101);
2348   INSN(fmin, 0, 1, 0b111101);
2349 
2350 #undef INSN
2351 
2352 #define INSN(NAME, opc)                                                                 \
2353   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2354     starti;                                                                             \
2355     assert(T == T4S, &quot;arrangement must be T4S&quot;);                                        \
2356     f(0b01011110000, 31, 21), rf(Vm, 16), f(opc, 15, 10), rf(Vn, 5), rf(Vd, 0);         \
2357   }
2358 
2359   INSN(sha1c,     0b000000);
2360   INSN(sha1m,     0b001000);
2361   INSN(sha1p,     0b000100);
2362   INSN(sha1su0,   0b001100);
2363   INSN(sha256h2,  0b010100);
2364   INSN(sha256h,   0b010000);
2365   INSN(sha256su1, 0b011000);
2366 
2367 #undef INSN
2368 
2369 #define INSN(NAME, opc)                                                                 \
2370   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {                   \
2371     starti;                                                                             \
2372     assert(T == T4S, &quot;arrangement must be T4S&quot;);                                        \
2373     f(0b0101111000101000, 31, 16), f(opc, 15, 10), rf(Vn, 5), rf(Vd, 0);                \
2374   }
2375 
2376   INSN(sha1h,     0b000010);
2377   INSN(sha1su1,   0b000110);
2378   INSN(sha256su0, 0b001010);
2379 
2380 #undef INSN
2381 
2382 #define INSN(NAME, opc)                           \
2383   void NAME(FloatRegister Vd, FloatRegister Vn) { \
2384     starti;                                       \
2385     f(opc, 31, 10), rf(Vn, 5), rf(Vd, 0);         \
2386   }
2387 
2388   INSN(aese, 0b0100111000101000010010);
2389   INSN(aesd, 0b0100111000101000010110);
2390   INSN(aesmc, 0b0100111000101000011010);
2391   INSN(aesimc, 0b0100111000101000011110);
2392 
2393 #undef INSN
2394 
2395 #define INSN(NAME, op1, op2) \
2396   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index = 0) { \
2397     starti;                                                                                            \
2398     assert(T == T2S || T == T4S || T == T2D, &quot;invalid arrangement&quot;);                                   \
2399     assert(index &gt;= 0 &amp;&amp; ((T == T2D &amp;&amp; index &lt;= 1) || (T != T2D &amp;&amp; index &lt;= 3)), &quot;invalid index&quot;);     \
2400     f(0, 31), f((int)T &amp; 1, 30), f(op1, 29); f(0b011111, 28, 23);                                      \
2401     f(T == T2D ? 1 : 0, 22), f(T == T2D ? 0 : index &amp; 1, 21), rf(Vm, 16);                              \
2402     f(op2, 15, 12), f(T == T2D ? index : (index &gt;&gt; 1), 11), f(0, 10);                                  \
2403     rf(Vn, 5), rf(Vd, 0);                                                                              \
2404   }
2405 
2406   // FMLA/FMLS - Vector - Scalar
2407   INSN(fmlavs, 0, 0b0001);
2408   INSN(fmlsvs, 0, 0b0101);
2409   // FMULX - Vector - Scalar
2410   INSN(fmulxvs, 1, 0b1001);
2411 
2412 #undef INSN
2413 
2414   // Floating-point Reciprocal Estimate
2415   void frecpe(FloatRegister Vd, FloatRegister Vn, SIMD_RegVariant type) {
2416     assert(type == D || type == S, &quot;Wrong type for frecpe&quot;);
2417     starti;
2418     f(0b010111101, 31, 23);
2419     f(type == D ? 1 : 0, 22);
2420     f(0b100001110110, 21, 10);
2421     rf(Vn, 5), rf(Vd, 0);
2422   }
2423 
2424   // (double) {a, b} -&gt; (a + b)
2425   void faddpd(FloatRegister Vd, FloatRegister Vn) {
2426     starti;
2427     f(0b0111111001110000110110, 31, 10);
2428     rf(Vn, 5), rf(Vd, 0);
2429   }
2430 
2431   void ins(FloatRegister Vd, SIMD_RegVariant T, FloatRegister Vn, int didx, int sidx) {
2432     starti;
2433     assert(T != Q, &quot;invalid register variant&quot;);
2434     f(0b01101110000, 31, 21), f(((didx&lt;&lt;1)|1)&lt;&lt;(int)T, 20, 16), f(0, 15);
2435     f(sidx&lt;&lt;(int)T, 14, 11), f(1, 10), rf(Vn, 5), rf(Vd, 0);
2436   }
2437 
2438   void umov(Register Rd, FloatRegister Vn, SIMD_RegVariant T, int idx) {
2439     starti;
2440     f(0, 31), f(T==D ? 1:0, 30), f(0b001110000, 29, 21);
2441     f(((idx&lt;&lt;1)|1)&lt;&lt;(int)T, 20, 16), f(0b001111, 15, 10);
2442     rf(Vn, 5), rf(Rd, 0);
2443   }
2444 
2445 #define INSN(NAME, opc, opc2, isSHR)                                    \
2446   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift){ \
2447     starti;                                                             \
2448     /* The encodings for the immh:immb fields (bits 22:16) in *SHR are  \
2449      *   0001 xxx       8B/16B, shift = 16  - UInt(immh:immb)           \
2450      *   001x xxx       4H/8H,  shift = 32  - UInt(immh:immb)           \
2451      *   01xx xxx       2S/4S,  shift = 64  - UInt(immh:immb)           \
2452      *   1xxx xxx       1D/2D,  shift = 128 - UInt(immh:immb)           \
2453      *   (1D is RESERVED)                                               \
2454      * for SHL shift is calculated as:                                  \
2455      *   0001 xxx       8B/16B, shift = UInt(immh:immb) - 8             \
2456      *   001x xxx       4H/8H,  shift = UInt(immh:immb) - 16            \
2457      *   01xx xxx       2S/4S,  shift = UInt(immh:immb) - 32            \
2458      *   1xxx xxx       1D/2D,  shift = UInt(immh:immb) - 64            \
2459      *   (1D is RESERVED)                                               \
2460      */                                                                 \
2461     assert((1 &lt;&lt; ((T&gt;&gt;1)+3)) &gt; shift, &quot;Invalid Shift value&quot;);           \
2462     int cVal = (1 &lt;&lt; (((T &gt;&gt; 1) + 3) + (isSHR ? 1 : 0)));               \
2463     int encodedShift = isSHR ? cVal - shift : cVal + shift;             \
2464     f(0, 31), f(T &amp; 1, 30), f(opc, 29), f(0b011110, 28, 23),            \
2465     f(encodedShift, 22, 16); f(opc2, 15, 10), rf(Vn, 5), rf(Vd, 0);     \
2466   }
2467 
2468   INSN(shl,  0, 0b010101, /* isSHR = */ false);
2469   INSN(sshr, 0, 0b000001, /* isSHR = */ true);
2470   INSN(ushr, 1, 0b000001, /* isSHR = */ true);
2471 
2472 #undef INSN
2473 
2474 private:
2475   void _ushll(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, SIMD_Arrangement Tb, int shift) {
2476     starti;
2477     /* The encodings for the immh:immb fields (bits 22:16) are
2478      *   0001 xxx       8H, 8B/16b shift = xxx
2479      *   001x xxx       4S, 4H/8H  shift = xxxx
2480      *   01xx xxx       2D, 2S/4S  shift = xxxxx
2481      *   1xxx xxx       RESERVED
2482      */
2483     assert((Tb &gt;&gt; 1) + 1 == (Ta &gt;&gt; 1), &quot;Incompatible arrangement&quot;);
2484     assert((1 &lt;&lt; ((Tb&gt;&gt;1)+3)) &gt; shift, &quot;Invalid shift value&quot;);
2485     f(0, 31), f(Tb &amp; 1, 30), f(0b1011110, 29, 23), f((1 &lt;&lt; ((Tb&gt;&gt;1)+3))|shift, 22, 16);
2486     f(0b101001, 15, 10), rf(Vn, 5), rf(Vd, 0);
2487   }
2488 
2489 public:
2490   void ushll(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {
2491     assert(Tb == T8B || Tb == T4H || Tb == T2S, &quot;invalid arrangement&quot;);
2492     _ushll(Vd, Ta, Vn, Tb, shift);
2493   }
2494 
2495   void ushll2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {
2496     assert(Tb == T16B || Tb == T8H || Tb == T4S, &quot;invalid arrangement&quot;);
2497     _ushll(Vd, Ta, Vn, Tb, shift);
2498   }
2499 
2500   // Move from general purpose register
2501   //   mov  Vd.T[index], Rn
2502   void mov(FloatRegister Vd, SIMD_Arrangement T, int index, Register Xn) {
2503     starti;
2504     f(0b01001110000, 31, 21), f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
2505     f(0b000111, 15, 10), zrf(Xn, 5), rf(Vd, 0);
2506   }
2507 
2508   // Move to general purpose register
2509   //   mov  Rd, Vn.T[index]
2510   void mov(Register Xd, FloatRegister Vn, SIMD_Arrangement T, int index) {
2511     guarantee(T &gt;= T2S &amp;&amp; T &lt; T1Q, &quot;only D and S arrangements are supported&quot;);
2512     starti;
2513     f(0, 31), f((T &gt;= T1D) ? 1:0, 30), f(0b001110000, 29, 21);
2514     f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
2515     f(0b001111, 15, 10), rf(Vn, 5), rf(Xd, 0);
2516   }
2517 
2518 private:
2519   void _pmull(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {
2520     starti;
2521     assert((Ta == T1Q &amp;&amp; (Tb == T1D || Tb == T2D)) ||
2522            (Ta == T8H &amp;&amp; (Tb == T8B || Tb == T16B)), &quot;Invalid Size specifier&quot;);
2523     int size = (Ta == T1Q) ? 0b11 : 0b00;
2524     f(0, 31), f(Tb &amp; 1, 30), f(0b001110, 29, 24), f(size, 23, 22);
2525     f(1, 21), rf(Vm, 16), f(0b111000, 15, 10), rf(Vn, 5), rf(Vd, 0);
2526   }
2527 
2528 public:
2529   void pmull(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {
2530     assert(Tb == T1D || Tb == T8B, &quot;pmull assumes T1D or T8B as the second size specifier&quot;);
2531     _pmull(Vd, Ta, Vn, Vm, Tb);
2532   }
2533 
2534   void pmull2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn, FloatRegister Vm, SIMD_Arrangement Tb) {
2535     assert(Tb == T2D || Tb == T16B, &quot;pmull2 assumes T2D or T16B as the second size specifier&quot;);
2536     _pmull(Vd, Ta, Vn, Vm, Tb);
2537   }
2538 
2539   void uqxtn(FloatRegister Vd, SIMD_Arrangement Tb, FloatRegister Vn, SIMD_Arrangement Ta) {
2540     starti;
2541     int size_b = (int)Tb &gt;&gt; 1;
2542     int size_a = (int)Ta &gt;&gt; 1;
2543     assert(size_b &lt; 3 &amp;&amp; size_b == size_a - 1, &quot;Invalid size specifier&quot;);
2544     f(0, 31), f(Tb &amp; 1, 30), f(0b101110, 29, 24), f(size_b, 23, 22);
2545     f(0b100001010010, 21, 10), rf(Vn, 5), rf(Vd, 0);
2546   }
2547 
2548   void dup(FloatRegister Vd, SIMD_Arrangement T, Register Xs)
2549   {
2550     starti;
2551     assert(T != T1D, &quot;reserved encoding&quot;);
2552     f(0,31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
2553     f((1 &lt;&lt; (T &gt;&gt; 1)), 20, 16), f(0b000011, 15, 10), zrf(Xs, 5), rf(Vd, 0);
2554   }
2555 
2556   void dup(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int index = 0)
2557   {
2558     starti;
2559     assert(T != T1D, &quot;reserved encoding&quot;);
2560     f(0, 31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21);
2561     f(((1 &lt;&lt; (T &gt;&gt; 1)) | (index &lt;&lt; ((T &gt;&gt; 1) + 1))), 20, 16);
2562     f(0b000001, 15, 10), rf(Vn, 5), rf(Vd, 0);
2563   }
2564 
2565   // AdvSIMD ZIP/UZP/TRN
2566 #define INSN(NAME, opcode)                                              \
2567   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \
2568     guarantee(T != T1D &amp;&amp; T != T1Q, &quot;invalid arrangement&quot;);             \
2569     starti;                                                             \
2570     f(0, 31), f(0b001110, 29, 24), f(0, 21), f(0, 15);                  \
2571     f(opcode, 14, 12), f(0b10, 11, 10);                                 \
2572     rf(Vm, 16), rf(Vn, 5), rf(Vd, 0);                                   \
2573     f(T &amp; 1, 30), f(T &gt;&gt; 1, 23, 22);                                    \
2574   }
2575 
2576   INSN(uzp1, 0b001);
2577   INSN(trn1, 0b010);
2578   INSN(zip1, 0b011);
2579   INSN(uzp2, 0b101);
2580   INSN(trn2, 0b110);
2581   INSN(zip2, 0b111);
2582 
2583 #undef INSN
2584 
2585   // CRC32 instructions
2586 #define INSN(NAME, c, sf, sz)                                             \
2587   void NAME(Register Rd, Register Rn, Register Rm) {                      \
2588     starti;                                                               \
2589     f(sf, 31), f(0b0011010110, 30, 21), f(0b010, 15, 13), f(c, 12);       \
2590     f(sz, 11, 10), rf(Rm, 16), rf(Rn, 5), rf(Rd, 0);                      \
2591   }
2592 
2593   INSN(crc32b,  0, 0, 0b00);
2594   INSN(crc32h,  0, 0, 0b01);
2595   INSN(crc32w,  0, 0, 0b10);
2596   INSN(crc32x,  0, 1, 0b11);
2597   INSN(crc32cb, 1, 0, 0b00);
2598   INSN(crc32ch, 1, 0, 0b01);
2599   INSN(crc32cw, 1, 0, 0b10);
2600   INSN(crc32cx, 1, 1, 0b11);
2601 
2602 #undef INSN
2603 
2604   // Table vector lookup
2605 #define INSN(NAME, op)                                                  \
2606   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, unsigned registers, FloatRegister Vm) { \
2607     starti;                                                             \
2608     assert(T == T8B || T == T16B, &quot;invalid arrangement&quot;);               \
2609     assert(0 &lt; registers &amp;&amp; registers &lt;= 4, &quot;invalid number of registers&quot;); \
2610     f(0, 31), f((int)T &amp; 1, 30), f(0b001110000, 29, 21), rf(Vm, 16), f(0, 15); \
2611     f(registers - 1, 14, 13), f(op, 12),f(0b00, 11, 10), rf(Vn, 5), rf(Vd, 0); \
2612   }
2613 
2614   INSN(tbl, 0);
2615   INSN(tbx, 1);
2616 
2617 #undef INSN
2618 
2619   // AdvSIMD two-reg misc
2620   // In this instruction group, the 2 bits in the size field ([23:22]) may be
2621   // fixed or determined by the &quot;SIMD_Arrangement T&quot;, or both. The additional
2622   // parameter &quot;tmask&quot; is a 2-bit mask used to indicate which bits in the size
2623   // field are determined by the SIMD_Arrangement. The bit of &quot;tmask&quot; should be
2624   // set to 1 if corresponding bit marked as &quot;x&quot; in the ArmARM.
2625 #define INSN(NAME, U, size, tmask, opcode)                                          \
2626   void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {               \
2627        starti;                                                                      \
2628        assert((ASSERTION), MSG);                                                    \
2629        f(0, 31), f((int)T &amp; 1, 30), f(U, 29), f(0b01110, 28, 24);                   \
2630        f(size | ((int)(T &gt;&gt; 1) &amp; tmask), 23, 22), f(0b10000, 21, 17);               \
2631        f(opcode, 16, 12), f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                    \
2632  }
2633 
2634 #define MSG &quot;invalid arrangement&quot;
2635 
2636 #define ASSERTION (T == T2S || T == T4S || T == T2D)
2637   INSN(fsqrt,  1, 0b10, 0b01, 0b11111);
2638   INSN(fabs,   0, 0b10, 0b01, 0b01111);
2639   INSN(fneg,   1, 0b10, 0b01, 0b01111);
2640   INSN(frintn, 0, 0b00, 0b01, 0b11000);
2641   INSN(frintm, 0, 0b00, 0b01, 0b11001);
2642   INSN(frintp, 0, 0b10, 0b01, 0b11000);
2643 #undef ASSERTION
2644 
2645 #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H || T == T2S || T == T4S)
2646   INSN(rev64, 0, 0b00, 0b11, 0b00000);
2647 #undef ASSERTION
2648 
2649 #define ASSERTION (T == T8B || T == T16B || T == T4H || T == T8H)
2650   INSN(rev32, 1, 0b00, 0b11, 0b00000);
2651 #undef ASSERTION
2652 
2653 #define ASSERTION (T == T8B || T == T16B)
2654   INSN(rev16, 0, 0b00, 0b11, 0b00001);
2655   INSN(rbit,  1, 0b01, 0b00, 0b00101);
2656 #undef ASSERTION
2657 
2658 #undef MSG
2659 
2660 #undef INSN
2661 
2662 void ext(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index)
2663   {
2664     starti;
2665     assert(T == T8B || T == T16B, &quot;invalid arrangement&quot;);
2666     assert((T == T8B &amp;&amp; index &lt;= 0b0111) || (T == T16B &amp;&amp; index &lt;= 0b1111), &quot;Invalid index value&quot;);
2667     f(0, 31), f((int)T &amp; 1, 30), f(0b101110000, 29, 21);
2668     rf(Vm, 16), f(0, 15), f(index, 14, 11);
2669     f(0, 10), rf(Vn, 5), rf(Vd, 0);
2670   }
2671 
2672   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2673   }
2674 
2675   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
2676                                                 Register tmp,
2677                                                 int offset) {
2678     ShouldNotCallThis();
2679     return RegisterOrConstant();
2680   }
2681 
2682   // Stack overflow checking
2683   virtual void bang_stack_with_offset(int offset);
2684 
2685   static bool operand_valid_for_logical_immediate(bool is32, uint64_t imm);
2686   static bool operand_valid_for_add_sub_immediate(int64_t imm);
2687   static bool operand_valid_for_float_immediate(double imm);
2688 
2689   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
2690   void emit_data64(jlong data, RelocationHolder const&amp; rspec, int format = 0);
2691 };
2692 
2693 inline Assembler::Membar_mask_bits operator|(Assembler::Membar_mask_bits a,
2694                                              Assembler::Membar_mask_bits b) {
2695   return Assembler::Membar_mask_bits(unsigned(a)|unsigned(b));
2696 }
2697 
2698 Instruction_aarch64::~Instruction_aarch64() {
2699   assem-&gt;emit();
2700 }
2701 
2702 #undef starti
2703 
2704 // Invert a condition
2705 inline const Assembler::Condition operator~(const Assembler::Condition cond) {
2706   return Assembler::Condition(int(cond) ^ 1);
2707 }
2708 
2709 class BiasedLockingCounters;
2710 
2711 extern &quot;C&quot; void das(uint64_t start, int len);
2712 
2713 #endif // CPU_AARCH64_ASSEMBLER_AARCH64_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>