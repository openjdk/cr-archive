<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;c1/c1_CodeStubs.hpp&quot;
  30 #include &quot;c1/c1_Compilation.hpp&quot;
  31 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  32 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  33 #include &quot;c1/c1_Runtime1.hpp&quot;
  34 #include &quot;c1/c1_ValueStack.hpp&quot;
  35 #include &quot;ci/ciArrayKlass.hpp&quot;
  36 #include &quot;ci/ciInstance.hpp&quot;
  37 #include &quot;code/compiledIC.hpp&quot;
  38 #include &quot;gc/shared/collectedHeap.hpp&quot;
  39 #include &quot;nativeInst_aarch64.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;runtime/frame.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 #include &quot;vmreg_aarch64.inline.hpp&quot;
  45 
  46 
  47 #ifndef PRODUCT
  48 #define COMMENT(x)   do { __ block_comment(x); } while (0)
  49 #else
  50 #define COMMENT(x)
  51 #endif
  52 
  53 NEEDS_CLEANUP // remove this definitions ?
  54 const Register IC_Klass    = rscratch2;   // where the IC klass is cached
  55 const Register SYNC_header = r0;   // synchronization header
  56 const Register SHIFT_count = r0;   // where count for shift operations must be
  57 
  58 #define __ _masm-&gt;
  59 
  60 
  61 static void select_different_registers(Register preserve,
  62                                        Register extra,
  63                                        Register &amp;tmp1,
  64                                        Register &amp;tmp2) {
  65   if (tmp1 == preserve) {
  66     assert_different_registers(tmp1, tmp2, extra);
  67     tmp1 = extra;
  68   } else if (tmp2 == preserve) {
  69     assert_different_registers(tmp1, tmp2, extra);
  70     tmp2 = extra;
  71   }
  72   assert_different_registers(preserve, tmp1, tmp2);
  73 }
  74 
  75 
  76 
  77 static void select_different_registers(Register preserve,
  78                                        Register extra,
  79                                        Register &amp;tmp1,
  80                                        Register &amp;tmp2,
  81                                        Register &amp;tmp3) {
  82   if (tmp1 == preserve) {
  83     assert_different_registers(tmp1, tmp2, tmp3, extra);
  84     tmp1 = extra;
  85   } else if (tmp2 == preserve) {
  86     assert_different_registers(tmp1, tmp2, tmp3, extra);
  87     tmp2 = extra;
  88   } else if (tmp3 == preserve) {
  89     assert_different_registers(tmp1, tmp2, tmp3, extra);
  90     tmp3 = extra;
  91   }
  92   assert_different_registers(preserve, tmp1, tmp2, tmp3);
  93 }
  94 
  95 
  96 bool LIR_Assembler::is_small_constant(LIR_Opr opr) { Unimplemented(); return false; }
  97 
  98 
  99 LIR_Opr LIR_Assembler::receiverOpr() {
 100   return FrameMap::receiver_opr;
 101 }
 102 
 103 LIR_Opr LIR_Assembler::osrBufferPointer() {
 104   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 105 }
 106 
 107 //--------------fpu register translations-----------------------
 108 
 109 
 110 address LIR_Assembler::float_constant(float f) {
 111   address const_addr = __ float_constant(f);
 112   if (const_addr == NULL) {
 113     bailout(&quot;const section overflow&quot;);
 114     return __ code()-&gt;consts()-&gt;start();
 115   } else {
 116     return const_addr;
 117   }
 118 }
 119 
 120 
 121 address LIR_Assembler::double_constant(double d) {
 122   address const_addr = __ double_constant(d);
 123   if (const_addr == NULL) {
 124     bailout(&quot;const section overflow&quot;);
 125     return __ code()-&gt;consts()-&gt;start();
 126   } else {
 127     return const_addr;
 128   }
 129 }
 130 
 131 address LIR_Assembler::int_constant(jlong n) {
 132   address const_addr = __ long_constant(n);
 133   if (const_addr == NULL) {
 134     bailout(&quot;const section overflow&quot;);
 135     return __ code()-&gt;consts()-&gt;start();
 136   } else {
 137     return const_addr;
 138   }
 139 }
 140 
 141 void LIR_Assembler::breakpoint() { Unimplemented(); }
 142 
 143 void LIR_Assembler::push(LIR_Opr opr) { Unimplemented(); }
 144 
 145 void LIR_Assembler::pop(LIR_Opr opr) { Unimplemented(); }
 146 
 147 bool LIR_Assembler::is_literal_address(LIR_Address* addr) { Unimplemented(); return false; }
 148 //-------------------------------------------
 149 
 150 static Register as_reg(LIR_Opr op) {
 151   return op-&gt;is_double_cpu() ? op-&gt;as_register_lo() : op-&gt;as_register();
 152 }
 153 
 154 static jlong as_long(LIR_Opr data) {
 155   jlong result;
 156   switch (data-&gt;type()) {
 157   case T_INT:
 158     result = (data-&gt;as_jint());
 159     break;
 160   case T_LONG:
 161     result = (data-&gt;as_jlong());
 162     break;
 163   default:
 164     ShouldNotReachHere();
 165     result = 0;  // unreachable
 166   }
 167   return result;
 168 }
 169 
 170 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 171   Register base = addr-&gt;base()-&gt;as_pointer_register();
 172   LIR_Opr opr = addr-&gt;index();
 173   if (opr-&gt;is_cpu_register()) {
 174     Register index;
 175     if (opr-&gt;is_single_cpu())
 176       index = opr-&gt;as_register();
 177     else
 178       index = opr-&gt;as_register_lo();
 179     assert(addr-&gt;disp() == 0, &quot;must be&quot;);
 180     switch(opr-&gt;type()) {
 181       case T_INT:
 182         return Address(base, index, Address::sxtw(addr-&gt;scale()));
 183       case T_LONG:
 184         return Address(base, index, Address::lsl(addr-&gt;scale()));
 185       default:
 186         ShouldNotReachHere();
 187       }
 188   } else  {
 189     intptr_t addr_offset = intptr_t(addr-&gt;disp());
 190     if (Address::offset_ok_for_immed(addr_offset, addr-&gt;scale()))
 191       return Address(base, addr_offset, Address::lsl(addr-&gt;scale()));
 192     else {
 193       __ mov(tmp, addr_offset);
 194       return Address(base, tmp, Address::lsl(addr-&gt;scale()));
 195     }
 196   }
 197   return Address();
 198 }
 199 
 200 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 201   ShouldNotReachHere();
 202   return Address();
 203 }
 204 
 205 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 206   return as_Address(addr, rscratch1);
 207 }
 208 
 209 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 210   return as_Address(addr, rscratch1);  // Ouch
 211   // FIXME: This needs to be much more clever.  See x86.
 212 }
 213 
<a name="1" id="anc1"></a>












 214 
 215 void LIR_Assembler::osr_entry() {
 216   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 217   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 218   ValueStack* entry_state = osr_entry-&gt;state();
 219   int number_of_locks = entry_state-&gt;locks_size();
 220 
 221   // we jump here if osr happens with the interpreter
 222   // state set up to continue at the beginning of the
 223   // loop that triggered osr - in particular, we have
 224   // the following registers setup:
 225   //
 226   // r2: osr buffer
 227   //
 228 
 229   // build frame
 230   ciMethod* m = compilation()-&gt;method();
 231   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 232 
 233   // OSR buffer is
 234   //
 235   // locals[nlocals-1..0]
 236   // monitors[0..number_of_locks]
 237   //
 238   // locals is a direct copy of the interpreter frame so in the osr buffer
 239   // so first slot in the local array is the last local from the interpreter
 240   // and last slot is local[0] (receiver) from the interpreter
 241   //
 242   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 243   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 244   // in the interpreter frame (the method lock if a sync method)
 245 
 246   // Initialize monitors in the compiled activation.
 247   //   r2: pointer to osr buffer
 248   //
 249   // All other registers are dead at this point and the locals will be
 250   // copied into place by code emitted in the IR.
 251 
 252   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 253   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 254     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 255       (2 * BytesPerWord) * (number_of_locks - 1);
 256     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 257     // the OSR buffer using 2 word entries: first the lock and then
 258     // the oop.
 259     for (int i = 0; i &lt; number_of_locks; i++) {
 260       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 261 #ifdef ASSERT
 262       // verify the interpreter&#39;s monitor has a non-null object
 263       {
 264         Label L;
 265         __ ldr(rscratch1, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 266         __ cbnz(rscratch1, L);
 267         __ stop(&quot;locked object is NULL&quot;);
 268         __ bind(L);
 269       }
 270 #endif
 271       __ ldr(r19, Address(OSR_buf, slot_offset + 0));
 272       __ str(r19, frame_map()-&gt;address_for_monitor_lock(i));
 273       __ ldr(r19, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 274       __ str(r19, frame_map()-&gt;address_for_monitor_object(i));
 275     }
 276   }
 277 }
 278 
 279 
 280 // inline cache check; done before the frame is built.
 281 int LIR_Assembler::check_icache() {
 282   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 283   Register ic_klass = IC_Klass;
 284   int start_offset = __ offset();
 285   __ inline_cache_check(receiver, ic_klass);
 286 
 287   // if icache check fails, then jump to runtime routine
 288   // Note: RECEIVER must still contain the receiver!
 289   Label dont;
 290   __ br(Assembler::EQ, dont);
 291   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 292 
 293   // We align the verified entry point unless the method body
 294   // (including its inline cache check) will fit in a single 64-byte
 295   // icache line.
 296   if (! method()-&gt;is_accessor() || __ offset() - start_offset &gt; 4 * 4) {
 297     // force alignment after the cache check.
 298     __ align(CodeEntryAlignment);
 299   }
 300 
 301   __ bind(dont);
 302   return start_offset;
 303 }
 304 
 305 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 306   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 307   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 308 
 309   Label L_skip_barrier;
 310 
 311   __ mov_metadata(rscratch2, method-&gt;holder()-&gt;constant_encoding());
 312   __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier /*L_fast_path*/);
 313   __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 314   __ bind(L_skip_barrier);
 315 }
 316 
 317 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 318   if (o == NULL) {
 319     __ mov(reg, zr);
 320   } else {
 321     __ movoop(reg, o, /*immediate*/true);
 322   }
 323 }
 324 
 325 void LIR_Assembler::deoptimize_trap(CodeEmitInfo *info) {
 326   address target = NULL;
 327   relocInfo::relocType reloc_type = relocInfo::none;
 328 
 329   switch (patching_id(info)) {
 330   case PatchingStub::access_field_id:
 331     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 332     reloc_type = relocInfo::section_word_type;
 333     break;
 334   case PatchingStub::load_klass_id:
 335     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 336     reloc_type = relocInfo::metadata_type;
 337     break;
 338   case PatchingStub::load_mirror_id:
 339     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 340     reloc_type = relocInfo::oop_type;
 341     break;
 342   case PatchingStub::load_appendix_id:
 343     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 344     reloc_type = relocInfo::oop_type;
 345     break;
 346   default: ShouldNotReachHere();
 347   }
 348 
 349   __ far_call(RuntimeAddress(target));
 350   add_call_info_here(info);
 351 }
 352 
 353 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 354   deoptimize_trap(info);
 355 }
 356 
 357 
 358 // This specifies the rsp decrement needed to build the frame
 359 int LIR_Assembler::initial_frame_size_in_bytes() const {
 360   // if rounding, must let FrameMap know!
 361 
 362   // The frame_map records size in slots (32bit word)
 363 
 364   // subtract two words to account for return address and link
 365   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 366 }
 367 
 368 
 369 int LIR_Assembler::emit_exception_handler() {
 370   // if the last instruction is a call (typically to do a throw which
 371   // is coming at the end after block reordering) the return address
 372   // must still point into the code area in order to avoid assertion
 373   // failures when searching for the corresponding bci =&gt; add a nop
 374   // (was bug 5/14/1999 - gri)
 375   __ nop();
 376 
 377   // generate code for exception handler
 378   address handler_base = __ start_a_stub(exception_handler_size());
 379   if (handler_base == NULL) {
 380     // not enough space left for the handler
 381     bailout(&quot;exception handler overflow&quot;);
 382     return -1;
 383   }
 384 
 385   int offset = code_offset();
 386 
 387   // the exception oop and pc are in r0, and r3
 388   // no other registers need to be preserved, so invalidate them
 389   __ invalidate_registers(false, true, true, false, true, true);
 390 
 391   // check that there is really an exception
 392   __ verify_not_null_oop(r0);
 393 
 394   // search an exception handler (r0: exception oop, r3: throwing pc)
 395   __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));  __ should_not_reach_here();
 396   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 397   __ end_a_stub();
 398 
 399   return offset;
 400 }
 401 
 402 
 403 // Emit the code to remove the frame from the stack in the exception
 404 // unwind path.
 405 int LIR_Assembler::emit_unwind_handler() {
 406 #ifndef PRODUCT
 407   if (CommentedAssembly) {
 408     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 409   }
 410 #endif
 411 
 412   int offset = code_offset();
 413 
 414   // Fetch the exception from TLS and clear out exception related thread state
 415   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
 416   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
 417   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
 418 
 419   __ bind(_unwind_handler_entry);
 420   __ verify_not_null_oop(r0);
 421   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 422     __ mov(r19, r0);  // Preserve the exception
 423   }
 424 
 425   // Preform needed unlocking
 426   MonitorExitStub* stub = NULL;
 427   if (method()-&gt;is_synchronized()) {
 428     monitor_address(0, FrameMap::r0_opr);
 429     stub = new MonitorExitStub(FrameMap::r0_opr, true, 0);
 430     __ unlock_object(r5, r4, r0, *stub-&gt;entry());
 431     __ bind(*stub-&gt;continuation());
 432   }
 433 
 434   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 435     __ mov(c_rarg0, rthread);
 436     __ mov_metadata(c_rarg1, method()-&gt;constant_encoding());
 437     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), c_rarg0, c_rarg1);
 438   }
 439 
 440   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 441     __ mov(r0, r19);  // Restore the exception
 442   }
 443 
 444   // remove the activation and dispatch to the unwind handler
 445   __ block_comment(&quot;remove_frame and dispatch to the unwind handler&quot;);
 446   __ remove_frame(initial_frame_size_in_bytes());
 447   __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 448 
 449   // Emit the slow path assembly
 450   if (stub != NULL) {
 451     stub-&gt;emit_code(this);
 452   }
 453 
 454   return offset;
 455 }
 456 
 457 
 458 int LIR_Assembler::emit_deopt_handler() {
 459   // if the last instruction is a call (typically to do a throw which
 460   // is coming at the end after block reordering) the return address
 461   // must still point into the code area in order to avoid assertion
 462   // failures when searching for the corresponding bci =&gt; add a nop
 463   // (was bug 5/14/1999 - gri)
 464   __ nop();
 465 
 466   // generate code for exception handler
 467   address handler_base = __ start_a_stub(deopt_handler_size());
 468   if (handler_base == NULL) {
 469     // not enough space left for the handler
 470     bailout(&quot;deopt handler overflow&quot;);
 471     return -1;
 472   }
 473 
 474   int offset = code_offset();
 475 
 476   __ adr(lr, pc());
 477   __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 478   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 479   __ end_a_stub();
 480 
 481   return offset;
 482 }
 483 
 484 void LIR_Assembler::add_debug_info_for_branch(address adr, CodeEmitInfo* info) {
 485   _masm-&gt;code_section()-&gt;relocate(adr, relocInfo::poll_type);
 486   int pc_offset = code_offset();
 487   flush_debug_info(pc_offset);
 488   info-&gt;record_debug_info(compilation()-&gt;debug_info_recorder(), pc_offset);
 489   if (info-&gt;exception_handlers() != NULL) {
 490     compilation()-&gt;add_exception_handlers_for_pco(pc_offset, info-&gt;exception_handlers());
 491   }
 492 }
 493 
 494 void LIR_Assembler::return_op(LIR_Opr result) {
 495   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == r0, &quot;word returns are in r0,&quot;);
 496 
 497   // Pop the stack before the safepoint code
 498   __ remove_frame(initial_frame_size_in_bytes());
 499 
 500   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 501     __ reserved_stack_check();
 502   }
 503 
 504   __ fetch_and_read_polling_page(rscratch1, relocInfo::poll_return_type);
 505   __ ret(lr);
 506 }
 507 
 508 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 509   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 510   __ get_polling_page(rscratch1, relocInfo::poll_type);
 511   add_debug_info_for_branch(info);  // This isn&#39;t just debug info:
 512                                     // it&#39;s the oop map
 513   __ read_polling_page(rscratch1, relocInfo::poll_type);
 514   return __ offset();
 515 }
 516 
 517 
 518 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 519   if (from_reg == r31_sp)
 520     from_reg = sp;
 521   if (to_reg == r31_sp)
 522     to_reg = sp;
 523   __ mov(to_reg, from_reg);
 524 }
 525 
 526 void LIR_Assembler::swap_reg(Register a, Register b) { Unimplemented(); }
 527 
 528 
 529 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 530   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 531   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 532   LIR_Const* c = src-&gt;as_constant_ptr();
 533 
 534   switch (c-&gt;type()) {
 535     case T_INT: {
 536       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 537       __ movw(dest-&gt;as_register(), c-&gt;as_jint());
 538       break;
 539     }
 540 
 541     case T_ADDRESS: {
 542       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 543       __ mov(dest-&gt;as_register(), c-&gt;as_jint());
 544       break;
 545     }
 546 
 547     case T_LONG: {
 548       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 549       __ mov(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 550       break;
 551     }
 552 
 553     case T_OBJECT: {
 554         if (patch_code == lir_patch_none) {
 555           jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 556         } else {
 557           jobject2reg_with_patching(dest-&gt;as_register(), info);
 558         }
 559       break;
 560     }
 561 
 562     case T_METADATA: {
 563       if (patch_code != lir_patch_none) {
 564         klass2reg_with_patching(dest-&gt;as_register(), info);
 565       } else {
 566         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 567       }
 568       break;
 569     }
 570 
 571     case T_FLOAT: {
 572       if (__ operand_valid_for_float_immediate(c-&gt;as_jfloat())) {
 573         __ fmovs(dest-&gt;as_float_reg(), (c-&gt;as_jfloat()));
 574       } else {
 575         __ adr(rscratch1, InternalAddress(float_constant(c-&gt;as_jfloat())));
 576         __ ldrs(dest-&gt;as_float_reg(), Address(rscratch1));
 577       }
 578       break;
 579     }
 580 
 581     case T_DOUBLE: {
 582       if (__ operand_valid_for_float_immediate(c-&gt;as_jdouble())) {
 583         __ fmovd(dest-&gt;as_double_reg(), (c-&gt;as_jdouble()));
 584       } else {
 585         __ adr(rscratch1, InternalAddress(double_constant(c-&gt;as_jdouble())));
 586         __ ldrd(dest-&gt;as_double_reg(), Address(rscratch1));
 587       }
 588       break;
 589     }
 590 
 591     default:
 592       ShouldNotReachHere();
 593   }
 594 }
 595 
 596 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 597   LIR_Const* c = src-&gt;as_constant_ptr();
 598   switch (c-&gt;type()) {
 599   case T_OBJECT:
 600     {
 601       if (! c-&gt;as_jobject())
 602         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 603       else {
 604         const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 605         reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 606       }
 607     }
 608     break;
 609   case T_ADDRESS:
 610     {
 611       const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 612       reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 613     }
 614   case T_INT:
 615   case T_FLOAT:
 616     {
 617       Register reg = zr;
 618       if (c-&gt;as_jint_bits() == 0)
 619         __ strw(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 620       else {
 621         __ movw(rscratch1, c-&gt;as_jint_bits());
 622         __ strw(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 623       }
 624     }
 625     break;
 626   case T_LONG:
 627   case T_DOUBLE:
 628     {
 629       Register reg = zr;
 630       if (c-&gt;as_jlong_bits() == 0)
 631         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 632                                                  lo_word_offset_in_bytes));
 633       else {
 634         __ mov(rscratch1, (intptr_t)c-&gt;as_jlong_bits());
 635         __ str(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 636                                                         lo_word_offset_in_bytes));
 637       }
 638     }
 639     break;
 640   default:
 641     ShouldNotReachHere();
 642   }
 643 }
 644 
 645 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 646   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 647   LIR_Const* c = src-&gt;as_constant_ptr();
 648   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 649 
 650   void (Assembler::* insn)(Register Rt, const Address &amp;adr);
 651 
 652   switch (type) {
 653   case T_ADDRESS:
 654     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 655     insn = &amp;Assembler::str;
 656     break;
 657   case T_LONG:
 658     assert(c-&gt;as_jlong() == 0, &quot;should be&quot;);
 659     insn = &amp;Assembler::str;
 660     break;
 661   case T_INT:
 662     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 663     insn = &amp;Assembler::strw;
 664     break;
 665   case T_OBJECT:
 666   case T_ARRAY:
 667     assert(c-&gt;as_jobject() == 0, &quot;should be&quot;);
 668     if (UseCompressedOops &amp;&amp; !wide) {
 669       insn = &amp;Assembler::strw;
 670     } else {
 671       insn = &amp;Assembler::str;
 672     }
 673     break;
 674   case T_CHAR:
 675   case T_SHORT:
 676     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 677     insn = &amp;Assembler::strh;
 678     break;
 679   case T_BOOLEAN:
 680   case T_BYTE:
 681     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 682     insn = &amp;Assembler::strb;
 683     break;
 684   default:
 685     ShouldNotReachHere();
 686     insn = &amp;Assembler::str;  // unreachable
 687   }
 688 
 689   if (info) add_debug_info_for_null_check_here(info);
 690   (_masm-&gt;*insn)(zr, as_Address(to_addr, rscratch1));
 691 }
 692 
 693 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 694   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 695   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 696 
 697   // move between cpu-registers
 698   if (dest-&gt;is_single_cpu()) {
 699     if (src-&gt;type() == T_LONG) {
 700       // Can do LONG -&gt; OBJECT
 701       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 702       return;
 703     }
 704     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 705     if (src-&gt;type() == T_OBJECT) {
 706       __ verify_oop(src-&gt;as_register());
 707     }
 708     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 709 
 710   } else if (dest-&gt;is_double_cpu()) {
 711     if (is_reference_type(src-&gt;type())) {
 712       // Surprising to me but we can see move of a long to t_object
 713       __ verify_oop(src-&gt;as_register());
 714       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 715       return;
 716     }
 717     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 718     Register f_lo = src-&gt;as_register_lo();
 719     Register f_hi = src-&gt;as_register_hi();
 720     Register t_lo = dest-&gt;as_register_lo();
 721     Register t_hi = dest-&gt;as_register_hi();
 722     assert(f_hi == f_lo, &quot;must be same&quot;);
 723     assert(t_hi == t_lo, &quot;must be same&quot;);
 724     move_regs(f_lo, t_lo);
 725 
 726   } else if (dest-&gt;is_single_fpu()) {
 727     __ fmovs(dest-&gt;as_float_reg(), src-&gt;as_float_reg());
 728 
 729   } else if (dest-&gt;is_double_fpu()) {
 730     __ fmovd(dest-&gt;as_double_reg(), src-&gt;as_double_reg());
 731 
 732   } else {
 733     ShouldNotReachHere();
 734   }
 735 }
 736 
 737 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
<a name="2" id="anc2"></a>




 738   if (src-&gt;is_single_cpu()) {
<a name="3" id="anc3"></a>
 739     if (is_reference_type(type)) {
<a name="4" id="anc4"></a><span class="line-modified"> 740       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));</span>
 741       __ verify_oop(src-&gt;as_register());
 742     } else if (type == T_METADATA || type == T_DOUBLE || type == T_ADDRESS) {
<a name="5" id="anc5"></a><span class="line-modified"> 743       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));</span>
 744     } else {
<a name="6" id="anc6"></a><span class="line-modified"> 745       __ strw(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));</span>
 746     }
 747 
 748   } else if (src-&gt;is_double_cpu()) {
<a name="7" id="anc7"></a><span class="line-modified"> 749     Address dest_addr_LO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);</span>

 750     __ str(src-&gt;as_register_lo(), dest_addr_LO);
 751 
 752   } else if (src-&gt;is_single_fpu()) {
<a name="8" id="anc8"></a><span class="line-modified"> 753     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());</span>
<span class="line-modified"> 754     __ strs(src-&gt;as_float_reg(), dest_addr);</span>
 755 
 756   } else if (src-&gt;is_double_fpu()) {
<a name="9" id="anc9"></a><span class="line-modified"> 757     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());</span>
<span class="line-modified"> 758     __ strd(src-&gt;as_double_reg(), dest_addr);</span>
 759 
 760   } else {
 761     ShouldNotReachHere();
 762   }
<a name="10" id="anc10"></a><span class="line-removed"> 763 </span>
 764 }
 765 
 766 
 767 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 768   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 769   PatchingStub* patch = NULL;
 770   Register compressed_src = rscratch1;
 771 
 772   if (patch_code != lir_patch_none) {
 773     deoptimize_trap(info);
 774     return;
 775   }
 776 
 777   if (is_reference_type(type)) {
 778     __ verify_oop(src-&gt;as_register());
 779 
 780     if (UseCompressedOops &amp;&amp; !wide) {
 781       __ encode_heap_oop(compressed_src, src-&gt;as_register());
 782     } else {
 783       compressed_src = src-&gt;as_register();
 784     }
 785   }
 786 
 787   int null_check_here = code_offset();
 788   switch (type) {
 789     case T_FLOAT: {
 790       __ strs(src-&gt;as_float_reg(), as_Address(to_addr));
 791       break;
 792     }
 793 
 794     case T_DOUBLE: {
 795       __ strd(src-&gt;as_double_reg(), as_Address(to_addr));
 796       break;
 797     }
 798 
 799     case T_ARRAY:   // fall through
 800     case T_OBJECT:  // fall through
 801       if (UseCompressedOops &amp;&amp; !wide) {
 802         __ strw(compressed_src, as_Address(to_addr, rscratch2));
 803       } else {
 804          __ str(compressed_src, as_Address(to_addr));
 805       }
 806       break;
 807     case T_METADATA:
 808       // We get here to store a method pointer to the stack to pass to
 809       // a dtrace runtime call. This can&#39;t work on 64 bit with
 810       // compressed klass ptrs: T_METADATA can be a compressed klass
 811       // ptr or a 64 bit method pointer.
 812       ShouldNotReachHere();
 813       __ str(src-&gt;as_register(), as_Address(to_addr));
 814       break;
 815     case T_ADDRESS:
 816       __ str(src-&gt;as_register(), as_Address(to_addr));
 817       break;
 818     case T_INT:
 819       __ strw(src-&gt;as_register(), as_Address(to_addr));
 820       break;
 821 
 822     case T_LONG: {
 823       __ str(src-&gt;as_register_lo(), as_Address_lo(to_addr));
 824       break;
 825     }
 826 
 827     case T_BYTE:    // fall through
 828     case T_BOOLEAN: {
 829       __ strb(src-&gt;as_register(), as_Address(to_addr));
 830       break;
 831     }
 832 
 833     case T_CHAR:    // fall through
 834     case T_SHORT:
 835       __ strh(src-&gt;as_register(), as_Address(to_addr));
 836       break;
 837 
 838     default:
 839       ShouldNotReachHere();
 840   }
 841   if (info != NULL) {
 842     add_debug_info_for_null_check(null_check_here, info);
 843   }
 844 }
 845 
 846 
 847 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
<a name="11" id="anc11"></a><span class="line-modified"> 848   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);</span>
<span class="line-modified"> 849   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);</span>


 850 
 851   if (dest-&gt;is_single_cpu()) {
<a name="12" id="anc12"></a>
 852     if (is_reference_type(type)) {
<a name="13" id="anc13"></a><span class="line-modified"> 853       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));</span>
 854       __ verify_oop(dest-&gt;as_register());
 855     } else if (type == T_METADATA || type == T_ADDRESS) {
<a name="14" id="anc14"></a><span class="line-modified"> 856       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));</span>
 857     } else {
<a name="15" id="anc15"></a><span class="line-modified"> 858       __ ldrw(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));</span>
 859     }
 860 
 861   } else if (dest-&gt;is_double_cpu()) {
<a name="16" id="anc16"></a><span class="line-modified"> 862     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);</span>

 863     __ ldr(dest-&gt;as_register_lo(), src_addr_LO);
 864 
 865   } else if (dest-&gt;is_single_fpu()) {
<a name="17" id="anc17"></a><span class="line-modified"> 866     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());</span>
<span class="line-modified"> 867     __ ldrs(dest-&gt;as_float_reg(), src_addr);</span>
 868 
 869   } else if (dest-&gt;is_double_fpu()) {
<a name="18" id="anc18"></a><span class="line-modified"> 870     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());</span>
<span class="line-modified"> 871     __ ldrd(dest-&gt;as_double_reg(), src_addr);</span>
 872 
 873   } else {
 874     ShouldNotReachHere();
 875   }
 876 }
 877 
 878 
 879 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 880   address target = NULL;
 881   relocInfo::relocType reloc_type = relocInfo::none;
 882 
 883   switch (patching_id(info)) {
 884   case PatchingStub::access_field_id:
 885     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 886     reloc_type = relocInfo::section_word_type;
 887     break;
 888   case PatchingStub::load_klass_id:
 889     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 890     reloc_type = relocInfo::metadata_type;
 891     break;
 892   case PatchingStub::load_mirror_id:
 893     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 894     reloc_type = relocInfo::oop_type;
 895     break;
 896   case PatchingStub::load_appendix_id:
 897     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 898     reloc_type = relocInfo::oop_type;
 899     break;
 900   default: ShouldNotReachHere();
 901   }
 902 
 903   __ far_call(RuntimeAddress(target));
 904   add_call_info_here(info);
 905 }
 906 
 907 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 908 
 909   LIR_Opr temp;
 910   if (type == T_LONG || type == T_DOUBLE)
 911     temp = FrameMap::rscratch1_long_opr;
 912   else
 913     temp = FrameMap::rscratch1_opr;
 914 
 915   stack2reg(src, temp, src-&gt;type());
 916   reg2stack(temp, dest, dest-&gt;type(), false);
 917 }
 918 
 919 
 920 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
 921   LIR_Address* addr = src-&gt;as_address_ptr();
 922   LIR_Address* from_addr = src-&gt;as_address_ptr();
 923 
 924   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
 925     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
 926   }
 927 
 928   if (patch_code != lir_patch_none) {
 929     deoptimize_trap(info);
 930     return;
 931   }
 932 
 933   if (info != NULL) {
 934     add_debug_info_for_null_check_here(info);
 935   }
 936   int null_check_here = code_offset();
 937   switch (type) {
 938     case T_FLOAT: {
 939       __ ldrs(dest-&gt;as_float_reg(), as_Address(from_addr));
 940       break;
 941     }
 942 
 943     case T_DOUBLE: {
 944       __ ldrd(dest-&gt;as_double_reg(), as_Address(from_addr));
 945       break;
 946     }
 947 
 948     case T_ARRAY:   // fall through
 949     case T_OBJECT:  // fall through
 950       if (UseCompressedOops &amp;&amp; !wide) {
 951         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 952       } else {
 953          __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 954       }
 955       break;
 956     case T_METADATA:
 957       // We get here to store a method pointer to the stack to pass to
 958       // a dtrace runtime call. This can&#39;t work on 64 bit with
 959       // compressed klass ptrs: T_METADATA can be a compressed klass
 960       // ptr or a 64 bit method pointer.
 961       ShouldNotReachHere();
 962       __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 963       break;
 964     case T_ADDRESS:
 965       // FIXME: OMG this is a horrible kludge.  Any offset from an
 966       // address that matches klass_offset_in_bytes() will be loaded
 967       // as a word, not a long.
 968       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 969         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 970       } else {
 971         __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 972       }
 973       break;
 974     case T_INT:
 975       __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 976       break;
 977 
 978     case T_LONG: {
 979       __ ldr(dest-&gt;as_register_lo(), as_Address_lo(from_addr));
 980       break;
 981     }
 982 
 983     case T_BYTE:
 984       __ ldrsb(dest-&gt;as_register(), as_Address(from_addr));
 985       break;
 986     case T_BOOLEAN: {
 987       __ ldrb(dest-&gt;as_register(), as_Address(from_addr));
 988       break;
 989     }
 990 
 991     case T_CHAR:
 992       __ ldrh(dest-&gt;as_register(), as_Address(from_addr));
 993       break;
 994     case T_SHORT:
 995       __ ldrsh(dest-&gt;as_register(), as_Address(from_addr));
 996       break;
 997 
 998     default:
 999       ShouldNotReachHere();
1000   }
1001 
1002   if (is_reference_type(type)) {
1003     if (UseCompressedOops &amp;&amp; !wide) {
1004       __ decode_heap_oop(dest-&gt;as_register());
1005     }
1006 
1007     if (!UseZGC) {
1008       // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1009       __ verify_oop(dest-&gt;as_register());
1010     }
1011   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1012     if (UseCompressedClassPointers) {
1013       __ decode_klass_not_null(dest-&gt;as_register());
1014     }
1015   }
1016 }
1017 
1018 
1019 int LIR_Assembler::array_element_size(BasicType type) const {
1020   int elem_size = type2aelembytes(type);
1021   return exact_log2(elem_size);
1022 }
1023 
1024 
1025 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1026   switch (op-&gt;code()) {
1027   case lir_idiv:
1028   case lir_irem:
1029     arithmetic_idiv(op-&gt;code(),
1030                     op-&gt;in_opr1(),
1031                     op-&gt;in_opr2(),
1032                     op-&gt;in_opr3(),
1033                     op-&gt;result_opr(),
1034                     op-&gt;info());
1035     break;
1036   case lir_fmad:
1037     __ fmaddd(op-&gt;result_opr()-&gt;as_double_reg(),
1038               op-&gt;in_opr1()-&gt;as_double_reg(),
1039               op-&gt;in_opr2()-&gt;as_double_reg(),
1040               op-&gt;in_opr3()-&gt;as_double_reg());
1041     break;
1042   case lir_fmaf:
1043     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(),
1044               op-&gt;in_opr1()-&gt;as_float_reg(),
1045               op-&gt;in_opr2()-&gt;as_float_reg(),
1046               op-&gt;in_opr3()-&gt;as_float_reg());
1047     break;
1048   default:      ShouldNotReachHere(); break;
1049   }
1050 }
1051 
1052 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1053 #ifdef ASSERT
1054   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1055   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1056   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1057 #endif
1058 
1059   if (op-&gt;cond() == lir_cond_always) {
1060     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1061     __ b(*(op-&gt;label()));
1062   } else {
1063     Assembler::Condition acond;
1064     if (op-&gt;code() == lir_cond_float_branch) {
1065       bool is_unordered = (op-&gt;ublock() == op-&gt;block());
1066       // Assembler::EQ does not permit unordered branches, so we add
1067       // another branch here.  Likewise, Assembler::NE does not permit
1068       // ordered branches.
1069       if ((is_unordered &amp;&amp; op-&gt;cond() == lir_cond_equal)
1070           || (!is_unordered &amp;&amp; op-&gt;cond() == lir_cond_notEqual))
1071         __ br(Assembler::VS, *(op-&gt;ublock()-&gt;label()));
1072       switch(op-&gt;cond()) {
1073       case lir_cond_equal:        acond = Assembler::EQ; break;
1074       case lir_cond_notEqual:     acond = Assembler::NE; break;
1075       case lir_cond_less:         acond = (is_unordered ? Assembler::LT : Assembler::LO); break;
1076       case lir_cond_lessEqual:    acond = (is_unordered ? Assembler::LE : Assembler::LS); break;
1077       case lir_cond_greaterEqual: acond = (is_unordered ? Assembler::HS : Assembler::GE); break;
1078       case lir_cond_greater:      acond = (is_unordered ? Assembler::HI : Assembler::GT); break;
1079       default:                    ShouldNotReachHere();
1080         acond = Assembler::EQ;  // unreachable
1081       }
1082     } else {
1083       switch (op-&gt;cond()) {
1084         case lir_cond_equal:        acond = Assembler::EQ; break;
1085         case lir_cond_notEqual:     acond = Assembler::NE; break;
1086         case lir_cond_less:         acond = Assembler::LT; break;
1087         case lir_cond_lessEqual:    acond = Assembler::LE; break;
1088         case lir_cond_greaterEqual: acond = Assembler::GE; break;
1089         case lir_cond_greater:      acond = Assembler::GT; break;
1090         case lir_cond_belowEqual:   acond = Assembler::LS; break;
1091         case lir_cond_aboveEqual:   acond = Assembler::HS; break;
1092         default:                    ShouldNotReachHere();
1093           acond = Assembler::EQ;  // unreachable
1094       }
1095     }
1096     __ br(acond,*(op-&gt;label()));
1097   }
1098 }
1099 
1100 
1101 
1102 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1103   LIR_Opr src  = op-&gt;in_opr();
1104   LIR_Opr dest = op-&gt;result_opr();
1105 
1106   switch (op-&gt;bytecode()) {
1107     case Bytecodes::_i2f:
1108       {
1109         __ scvtfws(dest-&gt;as_float_reg(), src-&gt;as_register());
1110         break;
1111       }
1112     case Bytecodes::_i2d:
1113       {
1114         __ scvtfwd(dest-&gt;as_double_reg(), src-&gt;as_register());
1115         break;
1116       }
1117     case Bytecodes::_l2d:
1118       {
1119         __ scvtfd(dest-&gt;as_double_reg(), src-&gt;as_register_lo());
1120         break;
1121       }
1122     case Bytecodes::_l2f:
1123       {
1124         __ scvtfs(dest-&gt;as_float_reg(), src-&gt;as_register_lo());
1125         break;
1126       }
1127     case Bytecodes::_f2d:
1128       {
1129         __ fcvts(dest-&gt;as_double_reg(), src-&gt;as_float_reg());
1130         break;
1131       }
1132     case Bytecodes::_d2f:
1133       {
1134         __ fcvtd(dest-&gt;as_float_reg(), src-&gt;as_double_reg());
1135         break;
1136       }
1137     case Bytecodes::_i2c:
1138       {
1139         __ ubfx(dest-&gt;as_register(), src-&gt;as_register(), 0, 16);
1140         break;
1141       }
1142     case Bytecodes::_i2l:
1143       {
1144         __ sxtw(dest-&gt;as_register_lo(), src-&gt;as_register());
1145         break;
1146       }
1147     case Bytecodes::_i2s:
1148       {
1149         __ sxth(dest-&gt;as_register(), src-&gt;as_register());
1150         break;
1151       }
1152     case Bytecodes::_i2b:
1153       {
1154         __ sxtb(dest-&gt;as_register(), src-&gt;as_register());
1155         break;
1156       }
1157     case Bytecodes::_l2i:
1158       {
1159         _masm-&gt;block_comment(&quot;FIXME: This could be a no-op&quot;);
1160         __ uxtw(dest-&gt;as_register(), src-&gt;as_register_lo());
1161         break;
1162       }
1163     case Bytecodes::_d2l:
1164       {
1165         __ fcvtzd(dest-&gt;as_register_lo(), src-&gt;as_double_reg());
1166         break;
1167       }
1168     case Bytecodes::_f2i:
1169       {
1170         __ fcvtzsw(dest-&gt;as_register(), src-&gt;as_float_reg());
1171         break;
1172       }
1173     case Bytecodes::_f2l:
1174       {
1175         __ fcvtzs(dest-&gt;as_register_lo(), src-&gt;as_float_reg());
1176         break;
1177       }
1178     case Bytecodes::_d2i:
1179       {
1180         __ fcvtzdw(dest-&gt;as_register(), src-&gt;as_double_reg());
1181         break;
1182       }
1183     default: ShouldNotReachHere();
1184   }
1185 }
1186 
1187 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1188   if (op-&gt;init_check()) {
1189     __ ldrb(rscratch1, Address(op-&gt;klass()-&gt;as_register(),
1190                                InstanceKlass::init_state_offset()));
1191     __ cmpw(rscratch1, InstanceKlass::fully_initialized);
1192     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1193     __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1194   }
1195   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1196                      op-&gt;tmp1()-&gt;as_register(),
1197                      op-&gt;tmp2()-&gt;as_register(),
1198                      op-&gt;header_size(),
1199                      op-&gt;object_size(),
1200                      op-&gt;klass()-&gt;as_register(),
1201                      *op-&gt;stub()-&gt;entry());
1202   __ bind(*op-&gt;stub()-&gt;continuation());
1203 }
1204 
1205 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1206   Register len =  op-&gt;len()-&gt;as_register();
1207   __ uxtw(len, len);
1208 
1209   if (UseSlowPath ||
1210       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1211       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1212     __ b(*op-&gt;stub()-&gt;entry());
1213   } else {
1214     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1215     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1216     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1217     if (len == tmp1) {
1218       tmp1 = tmp3;
1219     } else if (len == tmp2) {
1220       tmp2 = tmp3;
1221     } else if (len == tmp3) {
1222       // everything is ok
1223     } else {
1224       __ mov(tmp3, len);
1225     }
1226     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1227                       len,
1228                       tmp1,
1229                       tmp2,
1230                       arrayOopDesc::header_size(op-&gt;type()),
1231                       array_element_size(op-&gt;type()),
1232                       op-&gt;klass()-&gt;as_register(),
1233                       *op-&gt;stub()-&gt;entry());
1234   }
1235   __ bind(*op-&gt;stub()-&gt;continuation());
1236 }
1237 
1238 void LIR_Assembler::type_profile_helper(Register mdo,
1239                                         ciMethodData *md, ciProfileData *data,
1240                                         Register recv, Label* update_done) {
1241   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1242     Label next_test;
1243     // See if the receiver is receiver[n].
1244     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1245     __ ldr(rscratch1, Address(rscratch2));
1246     __ cmp(recv, rscratch1);
1247     __ br(Assembler::NE, next_test);
1248     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1249     __ addptr(data_addr, DataLayout::counter_increment);
1250     __ b(*update_done);
1251     __ bind(next_test);
1252   }
1253 
1254   // Didn&#39;t find receiver; find next empty slot and fill it in
1255   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1256     Label next_test;
1257     __ lea(rscratch2,
1258            Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1259     Address recv_addr(rscratch2);
1260     __ ldr(rscratch1, recv_addr);
1261     __ cbnz(rscratch1, next_test);
1262     __ str(recv, recv_addr);
1263     __ mov(rscratch1, DataLayout::counter_increment);
1264     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))));
1265     __ str(rscratch1, Address(rscratch2));
1266     __ b(*update_done);
1267     __ bind(next_test);
1268   }
1269 }
1270 
1271 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1272   // we always need a stub for the failure case.
1273   CodeStub* stub = op-&gt;stub();
1274   Register obj = op-&gt;object()-&gt;as_register();
1275   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1276   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1277   Register dst = op-&gt;result_opr()-&gt;as_register();
1278   ciKlass* k = op-&gt;klass();
1279   Register Rtmp1 = noreg;
1280 
1281   // check if it needs to be profiled
1282   ciMethodData* md;
1283   ciProfileData* data;
1284 
1285   const bool should_profile = op-&gt;should_profile();
1286 
1287   if (should_profile) {
1288     ciMethod* method = op-&gt;profiled_method();
1289     assert(method != NULL, &quot;Should have method&quot;);
1290     int bci = op-&gt;profiled_bci();
1291     md = method-&gt;method_data_or_null();
1292     assert(md != NULL, &quot;Sanity&quot;);
1293     data = md-&gt;bci_to_data(bci);
1294     assert(data != NULL,                &quot;need data for type check&quot;);
1295     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1296   }
1297   Label profile_cast_success, profile_cast_failure;
1298   Label *success_target = should_profile ? &amp;profile_cast_success : success;
1299   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
1300 
1301   if (obj == k_RInfo) {
1302     k_RInfo = dst;
1303   } else if (obj == klass_RInfo) {
1304     klass_RInfo = dst;
1305   }
1306   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1307     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1308   } else {
1309     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1310     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1311   }
1312 
1313   assert_different_registers(obj, k_RInfo, klass_RInfo);
1314 
1315     if (should_profile) {
1316       Label not_null;
1317       __ cbnz(obj, not_null);
1318       // Object is null; update MDO and exit
1319       Register mdo  = klass_RInfo;
1320       __ mov_metadata(mdo, md-&gt;constant_encoding());
1321       Address data_addr
1322         = __ form_address(rscratch2, mdo,
1323                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1324                           0);
1325       __ ldrb(rscratch1, data_addr);
1326       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1327       __ strb(rscratch1, data_addr);
1328       __ b(*obj_is_null);
1329       __ bind(not_null);
1330     } else {
1331       __ cbz(obj, *obj_is_null);
1332     }
1333 
1334   if (!k-&gt;is_loaded()) {
1335     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1336   } else {
1337     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1338   }
1339   __ verify_oop(obj);
1340 
1341   if (op-&gt;fast_check()) {
1342     // get object class
1343     // not a safepoint as obj null check happens earlier
1344     __ load_klass(rscratch1, obj);
1345     __ cmp( rscratch1, k_RInfo);
1346 
1347     __ br(Assembler::NE, *failure_target);
1348     // successful cast, fall through to profile or jump
1349   } else {
1350     // get object class
1351     // not a safepoint as obj null check happens earlier
1352     __ load_klass(klass_RInfo, obj);
1353     if (k-&gt;is_loaded()) {
1354       // See if we get an immediate positive hit
1355       __ ldr(rscratch1, Address(klass_RInfo, int64_t(k-&gt;super_check_offset())));
1356       __ cmp(k_RInfo, rscratch1);
1357       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1358         __ br(Assembler::NE, *failure_target);
1359         // successful cast, fall through to profile or jump
1360       } else {
1361         // See if we get an immediate positive hit
1362         __ br(Assembler::EQ, *success_target);
1363         // check for self
1364         __ cmp(klass_RInfo, k_RInfo);
1365         __ br(Assembler::EQ, *success_target);
1366 
1367         __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1368         __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1369         __ ldr(klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1370         // result is a boolean
1371         __ cbzw(klass_RInfo, *failure_target);
1372         // successful cast, fall through to profile or jump
1373       }
1374     } else {
1375       // perform the fast part of the checking logic
1376       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1377       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1378       __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1379       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1380       __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1381       // result is a boolean
1382       __ cbz(k_RInfo, *failure_target);
1383       // successful cast, fall through to profile or jump
1384     }
1385   }
1386   if (should_profile) {
1387     Register mdo  = klass_RInfo, recv = k_RInfo;
1388     __ bind(profile_cast_success);
1389     __ mov_metadata(mdo, md-&gt;constant_encoding());
1390     __ load_klass(recv, obj);
1391     Label update_done;
1392     type_profile_helper(mdo, md, data, recv, success);
1393     __ b(*success);
1394 
1395     __ bind(profile_cast_failure);
1396     __ mov_metadata(mdo, md-&gt;constant_encoding());
1397     Address counter_addr
1398       = __ form_address(rscratch2, mdo,
1399                         md-&gt;byte_offset_of_slot(data, CounterData::count_offset()),
1400                         0);
1401     __ ldr(rscratch1, counter_addr);
1402     __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1403     __ str(rscratch1, counter_addr);
1404     __ b(*failure);
1405   }
1406   __ b(*success);
1407 }
1408 
1409 
1410 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1411   const bool should_profile = op-&gt;should_profile();
1412 
1413   LIR_Code code = op-&gt;code();
1414   if (code == lir_store_check) {
1415     Register value = op-&gt;object()-&gt;as_register();
1416     Register array = op-&gt;array()-&gt;as_register();
1417     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1418     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1419     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1420 
1421     CodeStub* stub = op-&gt;stub();
1422 
1423     // check if it needs to be profiled
1424     ciMethodData* md;
1425     ciProfileData* data;
1426 
1427     if (should_profile) {
1428       ciMethod* method = op-&gt;profiled_method();
1429       assert(method != NULL, &quot;Should have method&quot;);
1430       int bci = op-&gt;profiled_bci();
1431       md = method-&gt;method_data_or_null();
1432       assert(md != NULL, &quot;Sanity&quot;);
1433       data = md-&gt;bci_to_data(bci);
1434       assert(data != NULL,                &quot;need data for type check&quot;);
1435       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1436     }
1437     Label profile_cast_success, profile_cast_failure, done;
1438     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
1439     Label *failure_target = should_profile ? &amp;profile_cast_failure : stub-&gt;entry();
1440 
1441     if (should_profile) {
1442       Label not_null;
1443       __ cbnz(value, not_null);
1444       // Object is null; update MDO and exit
1445       Register mdo  = klass_RInfo;
1446       __ mov_metadata(mdo, md-&gt;constant_encoding());
1447       Address data_addr
1448         = __ form_address(rscratch2, mdo,
1449                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1450                           0);
1451       __ ldrb(rscratch1, data_addr);
1452       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1453       __ strb(rscratch1, data_addr);
1454       __ b(done);
1455       __ bind(not_null);
1456     } else {
1457       __ cbz(value, done);
1458     }
1459 
1460     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1461     __ load_klass(k_RInfo, array);
1462     __ load_klass(klass_RInfo, value);
1463 
1464     // get instance klass (it&#39;s already uncompressed)
1465     __ ldr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1466     // perform the fast part of the checking logic
1467     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1468     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1469     __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1470     __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1471     __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1472     // result is a boolean
1473     __ cbzw(k_RInfo, *failure_target);
1474     // fall through to the success case
1475 
1476     if (should_profile) {
1477       Register mdo  = klass_RInfo, recv = k_RInfo;
1478       __ bind(profile_cast_success);
1479       __ mov_metadata(mdo, md-&gt;constant_encoding());
1480       __ load_klass(recv, value);
1481       Label update_done;
1482       type_profile_helper(mdo, md, data, recv, &amp;done);
1483       __ b(done);
1484 
1485       __ bind(profile_cast_failure);
1486       __ mov_metadata(mdo, md-&gt;constant_encoding());
1487       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1488       __ lea(rscratch2, counter_addr);
1489       __ ldr(rscratch1, Address(rscratch2));
1490       __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1491       __ str(rscratch1, Address(rscratch2));
1492       __ b(*stub-&gt;entry());
1493     }
1494 
1495     __ bind(done);
1496   } else if (code == lir_checkcast) {
1497     Register obj = op-&gt;object()-&gt;as_register();
1498     Register dst = op-&gt;result_opr()-&gt;as_register();
1499     Label success;
1500     emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1501     __ bind(success);
1502     if (dst != obj) {
1503       __ mov(dst, obj);
1504     }
1505   } else if (code == lir_instanceof) {
1506     Register obj = op-&gt;object()-&gt;as_register();
1507     Register dst = op-&gt;result_opr()-&gt;as_register();
1508     Label success, failure, done;
1509     emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1510     __ bind(failure);
1511     __ mov(dst, zr);
1512     __ b(done);
1513     __ bind(success);
1514     __ mov(dst, 1);
1515     __ bind(done);
1516   } else {
1517     ShouldNotReachHere();
1518   }
1519 }
1520 
1521 void LIR_Assembler::casw(Register addr, Register newval, Register cmpval) {
1522   __ cmpxchg(addr, cmpval, newval, Assembler::word, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1523   __ cset(rscratch1, Assembler::NE);
1524   __ membar(__ AnyAny);
1525 }
1526 
1527 void LIR_Assembler::casl(Register addr, Register newval, Register cmpval) {
1528   __ cmpxchg(addr, cmpval, newval, Assembler::xword, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1529   __ cset(rscratch1, Assembler::NE);
1530   __ membar(__ AnyAny);
1531 }
1532 
1533 
1534 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1535   assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
1536   Register addr;
1537   if (op-&gt;addr()-&gt;is_register()) {
1538     addr = as_reg(op-&gt;addr());
1539   } else {
1540     assert(op-&gt;addr()-&gt;is_address(), &quot;what else?&quot;);
1541     LIR_Address* addr_ptr = op-&gt;addr()-&gt;as_address_ptr();
1542     assert(addr_ptr-&gt;disp() == 0, &quot;need 0 disp&quot;);
1543     assert(addr_ptr-&gt;index() == LIR_OprDesc::illegalOpr(), &quot;need 0 index&quot;);
1544     addr = as_reg(addr_ptr-&gt;base());
1545   }
1546   Register newval = as_reg(op-&gt;new_value());
1547   Register cmpval = as_reg(op-&gt;cmp_value());
1548 
1549   if (op-&gt;code() == lir_cas_obj) {
1550     if (UseCompressedOops) {
1551       Register t1 = op-&gt;tmp1()-&gt;as_register();
1552       assert(op-&gt;tmp1()-&gt;is_valid(), &quot;must be&quot;);
1553       __ encode_heap_oop(t1, cmpval);
1554       cmpval = t1;
1555       __ encode_heap_oop(rscratch2, newval);
1556       newval = rscratch2;
1557       casw(addr, newval, cmpval);
1558     } else {
1559       casl(addr, newval, cmpval);
1560     }
1561   } else if (op-&gt;code() == lir_cas_int) {
1562     casw(addr, newval, cmpval);
1563   } else {
1564     casl(addr, newval, cmpval);
1565   }
1566 }
1567 
1568 
1569 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1570 
1571   Assembler::Condition acond, ncond;
1572   switch (condition) {
1573   case lir_cond_equal:        acond = Assembler::EQ; ncond = Assembler::NE; break;
1574   case lir_cond_notEqual:     acond = Assembler::NE; ncond = Assembler::EQ; break;
1575   case lir_cond_less:         acond = Assembler::LT; ncond = Assembler::GE; break;
1576   case lir_cond_lessEqual:    acond = Assembler::LE; ncond = Assembler::GT; break;
1577   case lir_cond_greaterEqual: acond = Assembler::GE; ncond = Assembler::LT; break;
1578   case lir_cond_greater:      acond = Assembler::GT; ncond = Assembler::LE; break;
1579   case lir_cond_belowEqual:
1580   case lir_cond_aboveEqual:
1581   default:                    ShouldNotReachHere();
1582     acond = Assembler::EQ; ncond = Assembler::NE;  // unreachable
1583   }
1584 
1585   assert(result-&gt;is_single_cpu() || result-&gt;is_double_cpu(),
1586          &quot;expect single register for result&quot;);
1587   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1588       &amp;&amp; opr1-&gt;type() == T_INT &amp;&amp; opr2-&gt;type() == T_INT) {
1589     jint val1 = opr1-&gt;as_jint();
1590     jint val2 = opr2-&gt;as_jint();
1591     if (val1 == 0 &amp;&amp; val2 == 1) {
1592       __ cset(result-&gt;as_register(), ncond);
1593       return;
1594     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1595       __ cset(result-&gt;as_register(), acond);
1596       return;
1597     }
1598   }
1599 
1600   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1601       &amp;&amp; opr1-&gt;type() == T_LONG &amp;&amp; opr2-&gt;type() == T_LONG) {
1602     jlong val1 = opr1-&gt;as_jlong();
1603     jlong val2 = opr2-&gt;as_jlong();
1604     if (val1 == 0 &amp;&amp; val2 == 1) {
1605       __ cset(result-&gt;as_register_lo(), ncond);
1606       return;
1607     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1608       __ cset(result-&gt;as_register_lo(), acond);
1609       return;
1610     }
1611   }
1612 
1613   if (opr1-&gt;is_stack()) {
1614     stack2reg(opr1, FrameMap::rscratch1_opr, result-&gt;type());
1615     opr1 = FrameMap::rscratch1_opr;
1616   } else if (opr1-&gt;is_constant()) {
1617     LIR_Opr tmp
1618       = opr1-&gt;type() == T_LONG ? FrameMap::rscratch1_long_opr : FrameMap::rscratch1_opr;
1619     const2reg(opr1, tmp, lir_patch_none, NULL);
1620     opr1 = tmp;
1621   }
1622 
1623   if (opr2-&gt;is_stack()) {
1624     stack2reg(opr2, FrameMap::rscratch2_opr, result-&gt;type());
1625     opr2 = FrameMap::rscratch2_opr;
1626   } else if (opr2-&gt;is_constant()) {
1627     LIR_Opr tmp
1628       = opr2-&gt;type() == T_LONG ? FrameMap::rscratch2_long_opr : FrameMap::rscratch2_opr;
1629     const2reg(opr2, tmp, lir_patch_none, NULL);
1630     opr2 = tmp;
1631   }
1632 
1633   if (result-&gt;type() == T_LONG)
1634     __ csel(result-&gt;as_register_lo(), opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo(), acond);
1635   else
1636     __ csel(result-&gt;as_register(), opr1-&gt;as_register(), opr2-&gt;as_register(), acond);
1637 }
1638 
1639 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
1640   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
1641 
1642   if (left-&gt;is_single_cpu()) {
1643     Register lreg = left-&gt;as_register();
1644     Register dreg = as_reg(dest);
1645 
1646     if (right-&gt;is_single_cpu()) {
1647       // cpu register - cpu register
1648 
1649       assert(left-&gt;type() == T_INT &amp;&amp; right-&gt;type() == T_INT &amp;&amp; dest-&gt;type() == T_INT,
1650              &quot;should be&quot;);
1651       Register rreg = right-&gt;as_register();
1652       switch (code) {
1653       case lir_add: __ addw (dest-&gt;as_register(), lreg, rreg); break;
1654       case lir_sub: __ subw (dest-&gt;as_register(), lreg, rreg); break;
1655       case lir_mul: __ mulw (dest-&gt;as_register(), lreg, rreg); break;
1656       default:      ShouldNotReachHere();
1657       }
1658 
1659     } else if (right-&gt;is_double_cpu()) {
1660       Register rreg = right-&gt;as_register_lo();
1661       // single_cpu + double_cpu: can happen with obj+long
1662       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1663       switch (code) {
1664       case lir_add: __ add(dreg, lreg, rreg); break;
1665       case lir_sub: __ sub(dreg, lreg, rreg); break;
1666       default: ShouldNotReachHere();
1667       }
1668     } else if (right-&gt;is_constant()) {
1669       // cpu register - constant
1670       jlong c;
1671 
1672       // FIXME.  This is fugly: we really need to factor all this logic.
1673       switch(right-&gt;type()) {
1674       case T_LONG:
1675         c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1676         break;
1677       case T_INT:
1678       case T_ADDRESS:
1679         c = right-&gt;as_constant_ptr()-&gt;as_jint();
1680         break;
1681       default:
1682         ShouldNotReachHere();
1683         c = 0;  // unreachable
1684         break;
1685       }
1686 
1687       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1688       if (c == 0 &amp;&amp; dreg == lreg) {
1689         COMMENT(&quot;effective nop elided&quot;);
1690         return;
1691       }
1692       switch(left-&gt;type()) {
1693       case T_INT:
1694         switch (code) {
1695         case lir_add: __ addw(dreg, lreg, c); break;
1696         case lir_sub: __ subw(dreg, lreg, c); break;
1697         default: ShouldNotReachHere();
1698         }
1699         break;
1700       case T_OBJECT:
1701       case T_ADDRESS:
1702         switch (code) {
1703         case lir_add: __ add(dreg, lreg, c); break;
1704         case lir_sub: __ sub(dreg, lreg, c); break;
1705         default: ShouldNotReachHere();
1706         }
1707         break;
1708       default:
1709         ShouldNotReachHere();
1710       }
1711     } else {
1712       ShouldNotReachHere();
1713     }
1714 
1715   } else if (left-&gt;is_double_cpu()) {
1716     Register lreg_lo = left-&gt;as_register_lo();
1717 
1718     if (right-&gt;is_double_cpu()) {
1719       // cpu register - cpu register
1720       Register rreg_lo = right-&gt;as_register_lo();
1721       switch (code) {
1722       case lir_add: __ add (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1723       case lir_sub: __ sub (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1724       case lir_mul: __ mul (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1725       case lir_div: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, false, rscratch1); break;
1726       case lir_rem: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, true, rscratch1); break;
1727       default:
1728         ShouldNotReachHere();
1729       }
1730 
1731     } else if (right-&gt;is_constant()) {
1732       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1733       Register dreg = as_reg(dest);
1734       switch (code) {
1735         case lir_add:
1736         case lir_sub:
1737           if (c == 0 &amp;&amp; dreg == lreg_lo) {
1738             COMMENT(&quot;effective nop elided&quot;);
1739             return;
1740           }
1741           code == lir_add ? __ add(dreg, lreg_lo, c) : __ sub(dreg, lreg_lo, c);
1742           break;
1743         case lir_div:
1744           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1745           if (c == 1) {
1746             // move lreg_lo to dreg if divisor is 1
1747             __ mov(dreg, lreg_lo);
1748           } else {
1749             unsigned int shift = exact_log2_long(c);
1750             // use rscratch1 as intermediate result register
1751             __ asr(rscratch1, lreg_lo, 63);
1752             __ add(rscratch1, lreg_lo, rscratch1, Assembler::LSR, 64 - shift);
1753             __ asr(dreg, rscratch1, shift);
1754           }
1755           break;
1756         case lir_rem:
1757           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1758           if (c == 1) {
1759             // move 0 to dreg if divisor is 1
1760             __ mov(dreg, zr);
1761           } else {
1762             // use rscratch1 as intermediate result register
1763             __ negs(rscratch1, lreg_lo);
1764             __ andr(dreg, lreg_lo, c - 1);
1765             __ andr(rscratch1, rscratch1, c - 1);
1766             __ csneg(dreg, dreg, rscratch1, Assembler::MI);
1767           }
1768           break;
1769         default:
1770           ShouldNotReachHere();
1771       }
1772     } else {
1773       ShouldNotReachHere();
1774     }
1775   } else if (left-&gt;is_single_fpu()) {
1776     assert(right-&gt;is_single_fpu(), &quot;right hand side of float arithmetics needs to be float register&quot;);
1777     switch (code) {
1778     case lir_add: __ fadds (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1779     case lir_sub: __ fsubs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1780     case lir_mul_strictfp: // fall through
1781     case lir_mul: __ fmuls (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1782     case lir_div_strictfp: // fall through
1783     case lir_div: __ fdivs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1784     default:
1785       ShouldNotReachHere();
1786     }
1787   } else if (left-&gt;is_double_fpu()) {
1788     if (right-&gt;is_double_fpu()) {
1789       // fpu register - fpu register
1790       switch (code) {
1791       case lir_add: __ faddd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1792       case lir_sub: __ fsubd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1793       case lir_mul_strictfp: // fall through
1794       case lir_mul: __ fmuld (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1795       case lir_div_strictfp: // fall through
1796       case lir_div: __ fdivd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1797       default:
1798         ShouldNotReachHere();
1799       }
1800     } else {
1801       if (right-&gt;is_constant()) {
1802         ShouldNotReachHere();
1803       }
1804       ShouldNotReachHere();
1805     }
1806   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
1807     assert(left == dest, &quot;left and dest must be equal&quot;);
1808     ShouldNotReachHere();
1809   } else {
1810     ShouldNotReachHere();
1811   }
1812 }
1813 
1814 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) { Unimplemented(); }
1815 
1816 
1817 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {
1818   switch(code) {
1819   case lir_abs : __ fabsd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1820   case lir_sqrt: __ fsqrtd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1821   default      : ShouldNotReachHere();
1822   }
1823 }
1824 
1825 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
1826 
1827   assert(left-&gt;is_single_cpu() || left-&gt;is_double_cpu(), &quot;expect single or double register&quot;);
1828   Register Rleft = left-&gt;is_single_cpu() ? left-&gt;as_register() :
1829                                            left-&gt;as_register_lo();
1830    if (dst-&gt;is_single_cpu()) {
1831      Register Rdst = dst-&gt;as_register();
1832      if (right-&gt;is_constant()) {
1833        switch (code) {
1834          case lir_logic_and: __ andw (Rdst, Rleft, right-&gt;as_jint()); break;
1835          case lir_logic_or:  __ orrw (Rdst, Rleft, right-&gt;as_jint()); break;
1836          case lir_logic_xor: __ eorw (Rdst, Rleft, right-&gt;as_jint()); break;
1837          default: ShouldNotReachHere(); break;
1838        }
1839      } else {
1840        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
1841                                                   right-&gt;as_register_lo();
1842        switch (code) {
1843          case lir_logic_and: __ andw (Rdst, Rleft, Rright); break;
1844          case lir_logic_or:  __ orrw (Rdst, Rleft, Rright); break;
1845          case lir_logic_xor: __ eorw (Rdst, Rleft, Rright); break;
1846          default: ShouldNotReachHere(); break;
1847        }
1848      }
1849    } else {
1850      Register Rdst = dst-&gt;as_register_lo();
1851      if (right-&gt;is_constant()) {
1852        switch (code) {
1853          case lir_logic_and: __ andr (Rdst, Rleft, right-&gt;as_jlong()); break;
1854          case lir_logic_or:  __ orr (Rdst, Rleft, right-&gt;as_jlong()); break;
1855          case lir_logic_xor: __ eor (Rdst, Rleft, right-&gt;as_jlong()); break;
1856          default: ShouldNotReachHere(); break;
1857        }
1858      } else {
1859        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
1860                                                   right-&gt;as_register_lo();
1861        switch (code) {
1862          case lir_logic_and: __ andr (Rdst, Rleft, Rright); break;
1863          case lir_logic_or:  __ orr (Rdst, Rleft, Rright); break;
1864          case lir_logic_xor: __ eor (Rdst, Rleft, Rright); break;
1865          default: ShouldNotReachHere(); break;
1866        }
1867      }
1868    }
1869 }
1870 
1871 
1872 
1873 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr illegal, LIR_Opr result, CodeEmitInfo* info) {
1874 
1875   // opcode check
1876   assert((code == lir_idiv) || (code == lir_irem), &quot;opcode must be idiv or irem&quot;);
1877   bool is_irem = (code == lir_irem);
1878 
1879   // operand check
1880   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
1881   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
1882   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
1883   Register lreg = left-&gt;as_register();
1884   Register dreg = result-&gt;as_register();
1885 
1886   // power-of-2 constant check and codegen
1887   if (right-&gt;is_constant()) {
1888     int c = right-&gt;as_constant_ptr()-&gt;as_jint();
1889     assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1890     if (is_irem) {
1891       if (c == 1) {
1892         // move 0 to dreg if divisor is 1
1893         __ movw(dreg, zr);
1894       } else {
1895         // use rscratch1 as intermediate result register
1896         __ negsw(rscratch1, lreg);
1897         __ andw(dreg, lreg, c - 1);
1898         __ andw(rscratch1, rscratch1, c - 1);
1899         __ csnegw(dreg, dreg, rscratch1, Assembler::MI);
1900       }
1901     } else {
1902       if (c == 1) {
1903         // move lreg to dreg if divisor is 1
1904         __ movw(dreg, lreg);
1905       } else {
1906         unsigned int shift = exact_log2(c);
1907         // use rscratch1 as intermediate result register
1908         __ asrw(rscratch1, lreg, 31);
1909         __ addw(rscratch1, lreg, rscratch1, Assembler::LSR, 32 - shift);
1910         __ asrw(dreg, rscratch1, shift);
1911       }
1912     }
1913   } else {
1914     Register rreg = right-&gt;as_register();
1915     __ corrected_idivl(dreg, lreg, rreg, is_irem, rscratch1);
1916   }
1917 }
1918 
1919 
1920 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1921   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_single_cpu()) {
1922     // tableswitch
1923     Register reg = as_reg(opr2);
1924     struct tableswitch &amp;table = switches[opr1-&gt;as_constant_ptr()-&gt;as_jint()];
1925     __ tableswitch(reg, table._first_key, table._last_key, table._branches, table._after);
1926   } else if (opr1-&gt;is_single_cpu() || opr1-&gt;is_double_cpu()) {
1927     Register reg1 = as_reg(opr1);
1928     if (opr2-&gt;is_single_cpu()) {
1929       // cpu register - cpu register
1930       Register reg2 = opr2-&gt;as_register();
1931       if (is_reference_type(opr1-&gt;type())) {
1932         __ cmpoop(reg1, reg2);
1933       } else {
1934         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
1935         __ cmpw(reg1, reg2);
1936       }
1937       return;
1938     }
1939     if (opr2-&gt;is_double_cpu()) {
1940       // cpu register - cpu register
1941       Register reg2 = opr2-&gt;as_register_lo();
1942       __ cmp(reg1, reg2);
1943       return;
1944     }
1945 
1946     if (opr2-&gt;is_constant()) {
1947       bool is_32bit = false; // width of register operand
1948       jlong imm;
1949 
1950       switch(opr2-&gt;type()) {
1951       case T_INT:
1952         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1953         is_32bit = true;
1954         break;
1955       case T_LONG:
1956         imm = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
1957         break;
1958       case T_ADDRESS:
1959         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1960         break;
1961       case T_METADATA:
1962         imm = (intptr_t)(opr2-&gt;as_constant_ptr()-&gt;as_metadata());
1963         break;
1964       case T_OBJECT:
1965       case T_ARRAY:
1966         jobject2reg(opr2-&gt;as_constant_ptr()-&gt;as_jobject(), rscratch1);
1967         __ cmpoop(reg1, rscratch1);
1968         return;
1969       default:
1970         ShouldNotReachHere();
1971         imm = 0;  // unreachable
1972         break;
1973       }
1974 
1975       if (Assembler::operand_valid_for_add_sub_immediate(imm)) {
1976         if (is_32bit)
1977           __ cmpw(reg1, imm);
1978         else
1979           __ subs(zr, reg1, imm);
1980         return;
1981       } else {
1982         __ mov(rscratch1, imm);
1983         if (is_32bit)
1984           __ cmpw(reg1, rscratch1);
1985         else
1986           __ cmp(reg1, rscratch1);
1987         return;
1988       }
1989     } else
1990       ShouldNotReachHere();
1991   } else if (opr1-&gt;is_single_fpu()) {
1992     FloatRegister reg1 = opr1-&gt;as_float_reg();
1993     assert(opr2-&gt;is_single_fpu(), &quot;expect single float register&quot;);
1994     FloatRegister reg2 = opr2-&gt;as_float_reg();
1995     __ fcmps(reg1, reg2);
1996   } else if (opr1-&gt;is_double_fpu()) {
1997     FloatRegister reg1 = opr1-&gt;as_double_reg();
1998     assert(opr2-&gt;is_double_fpu(), &quot;expect double float register&quot;);
1999     FloatRegister reg2 = opr2-&gt;as_double_reg();
2000     __ fcmpd(reg1, reg2);
2001   } else {
2002     ShouldNotReachHere();
2003   }
2004 }
2005 
2006 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
2007   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2008     bool is_unordered_less = (code == lir_ucmp_fd2i);
2009     if (left-&gt;is_single_fpu()) {
2010       __ float_cmp(true, is_unordered_less ? -1 : 1, left-&gt;as_float_reg(), right-&gt;as_float_reg(), dst-&gt;as_register());
2011     } else if (left-&gt;is_double_fpu()) {
2012       __ float_cmp(false, is_unordered_less ? -1 : 1, left-&gt;as_double_reg(), right-&gt;as_double_reg(), dst-&gt;as_register());
2013     } else {
2014       ShouldNotReachHere();
2015     }
2016   } else if (code == lir_cmp_l2i) {
2017     Label done;
2018     __ cmp(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2019     __ mov(dst-&gt;as_register(), (uint64_t)-1L);
2020     __ br(Assembler::LT, done);
2021     __ csinc(dst-&gt;as_register(), zr, zr, Assembler::EQ);
2022     __ bind(done);
2023   } else {
2024     ShouldNotReachHere();
2025   }
2026 }
2027 
2028 
2029 void LIR_Assembler::align_call(LIR_Code code) {  }
2030 
2031 
2032 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2033   address call = __ trampoline_call(Address(op-&gt;addr(), rtype));
2034   if (call == NULL) {
2035     bailout(&quot;trampoline stub overflow&quot;);
2036     return;
2037   }
2038   add_call_info(code_offset(), op-&gt;info());
2039 }
2040 
2041 
2042 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2043   address call = __ ic_call(op-&gt;addr());
2044   if (call == NULL) {
2045     bailout(&quot;trampoline stub overflow&quot;);
2046     return;
2047   }
2048   add_call_info(code_offset(), op-&gt;info());
2049 }
2050 
2051 
2052 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2053 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2054   ShouldNotReachHere();
2055 }
2056 
2057 
2058 void LIR_Assembler::emit_static_call_stub() {
2059   address call_pc = __ pc();
2060   address stub = __ start_a_stub(call_stub_size());
2061   if (stub == NULL) {
2062     bailout(&quot;static call stub overflow&quot;);
2063     return;
2064   }
2065 
2066   int start = __ offset();
2067 
2068   __ relocate(static_stub_Relocation::spec(call_pc));
2069   __ emit_static_call_stub();
2070 
2071   assert(__ offset() - start + CompiledStaticCall::to_trampoline_stub_size()
2072         &lt;= call_stub_size(), &quot;stub too big&quot;);
2073   __ end_a_stub();
2074 }
2075 
2076 
2077 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2078   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2079   assert(exceptionPC-&gt;as_register() == r3, &quot;must match&quot;);
2080 
2081   // exception object is not added to oop map by LinearScan
2082   // (LinearScan assumes that no oops are in fixed registers)
2083   info-&gt;add_register_oop(exceptionOop);
2084   Runtime1::StubID unwind_id;
2085 
2086   // get current pc information
2087   // pc is only needed if the method has an exception handler, the unwind code does not need it.
<a name="19" id="anc19"></a>






2088   int pc_for_athrow_offset = __ offset();
2089   InternalAddress pc_for_athrow(__ pc());
2090   __ adr(exceptionPC-&gt;as_register(), pc_for_athrow);
2091   add_call_info(pc_for_athrow_offset, info); // for exception handler
2092 
2093   __ verify_not_null_oop(r0);
2094   // search an exception handler (r0: exception oop, r3: throwing pc)
2095   if (compilation()-&gt;has_fpu_code()) {
2096     unwind_id = Runtime1::handle_exception_id;
2097   } else {
2098     unwind_id = Runtime1::handle_exception_nofpu_id;
2099   }
2100   __ far_call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2101 
2102   // FIXME: enough room for two byte trap   ????
2103   __ nop();
2104 }
2105 
2106 
2107 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
2108   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2109 
2110   __ b(_unwind_handler_entry);
2111 }
2112 
2113 
2114 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2115   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2116   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2117 
2118   switch (left-&gt;type()) {
2119     case T_INT: {
2120       switch (code) {
2121       case lir_shl:  __ lslvw (dreg, lreg, count-&gt;as_register()); break;
2122       case lir_shr:  __ asrvw (dreg, lreg, count-&gt;as_register()); break;
2123       case lir_ushr: __ lsrvw (dreg, lreg, count-&gt;as_register()); break;
2124       default:
2125         ShouldNotReachHere();
2126         break;
2127       }
2128       break;
2129     case T_LONG:
2130     case T_ADDRESS:
2131     case T_OBJECT:
2132       switch (code) {
2133       case lir_shl:  __ lslv (dreg, lreg, count-&gt;as_register()); break;
2134       case lir_shr:  __ asrv (dreg, lreg, count-&gt;as_register()); break;
2135       case lir_ushr: __ lsrv (dreg, lreg, count-&gt;as_register()); break;
2136       default:
2137         ShouldNotReachHere();
2138         break;
2139       }
2140       break;
2141     default:
2142       ShouldNotReachHere();
2143       break;
2144     }
2145   }
2146 }
2147 
2148 
2149 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2150   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2151   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2152 
2153   switch (left-&gt;type()) {
2154     case T_INT: {
2155       switch (code) {
2156       case lir_shl:  __ lslw (dreg, lreg, count); break;
2157       case lir_shr:  __ asrw (dreg, lreg, count); break;
2158       case lir_ushr: __ lsrw (dreg, lreg, count); break;
2159       default:
2160         ShouldNotReachHere();
2161         break;
2162       }
2163       break;
2164     case T_LONG:
2165     case T_ADDRESS:
2166     case T_OBJECT:
2167       switch (code) {
2168       case lir_shl:  __ lsl (dreg, lreg, count); break;
2169       case lir_shr:  __ asr (dreg, lreg, count); break;
2170       case lir_ushr: __ lsr (dreg, lreg, count); break;
2171       default:
2172         ShouldNotReachHere();
2173         break;
2174       }
2175       break;
2176     default:
2177       ShouldNotReachHere();
2178       break;
2179     }
2180   }
2181 }
2182 
2183 
2184 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
2185   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2186   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2187   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2188   __ str (r, Address(sp, offset_from_rsp_in_bytes));
2189 }
2190 
2191 
2192 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
2193   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2194   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2195   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2196   __ mov (rscratch1, c);
2197   __ str (rscratch1, Address(sp, offset_from_rsp_in_bytes));
2198 }
2199 
2200 
2201 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
2202   ShouldNotReachHere();
2203   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2204   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2205   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2206   __ lea(rscratch1, __ constant_oop_address(o));
2207   __ str(rscratch1, Address(sp, offset_from_rsp_in_bytes));
2208 }
2209 
2210 
2211 // This code replaces a call to arraycopy; no exception may
2212 // be thrown in this code, they must be thrown in the System.arraycopy
2213 // activation frame; we could save some checks if this would not be the case
2214 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
2215   ciArrayKlass* default_type = op-&gt;expected_type();
2216   Register src = op-&gt;src()-&gt;as_register();
2217   Register dst = op-&gt;dst()-&gt;as_register();
2218   Register src_pos = op-&gt;src_pos()-&gt;as_register();
2219   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
2220   Register length  = op-&gt;length()-&gt;as_register();
2221   Register tmp = op-&gt;tmp()-&gt;as_register();
2222 
2223   __ resolve(ACCESS_READ, src);
2224   __ resolve(ACCESS_WRITE, dst);
2225 
2226   CodeStub* stub = op-&gt;stub();
2227   int flags = op-&gt;flags();
2228   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
2229   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
2230 
2231   // if we don&#39;t know anything, just go through the generic arraycopy
2232   if (default_type == NULL // || basic_type == T_OBJECT
2233       ) {
2234     Label done;
2235     assert(src == r1 &amp;&amp; src_pos == r2, &quot;mismatch in calling convention&quot;);
2236 
2237     // Save the arguments in case the generic arraycopy fails and we
2238     // have to fall back to the JNI stub
2239     __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2240     __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2241     __ str(src,              Address(sp, 4*BytesPerWord));
2242 
2243     address copyfunc_addr = StubRoutines::generic_arraycopy();
2244     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
2245 
2246     // The arguments are in java calling convention so we shift them
2247     // to C convention
2248     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
2249     __ mov(c_rarg0, j_rarg0);
2250     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
2251     __ mov(c_rarg1, j_rarg1);
2252     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
2253     __ mov(c_rarg2, j_rarg2);
2254     assert_different_registers(c_rarg3, j_rarg4);
2255     __ mov(c_rarg3, j_rarg3);
2256     __ mov(c_rarg4, j_rarg4);
2257 #ifndef PRODUCT
2258     if (PrintC1Statistics) {
2259       __ incrementw(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
2260     }
2261 #endif
2262     __ far_call(RuntimeAddress(copyfunc_addr));
2263 
2264     __ cbz(r0, *stub-&gt;continuation());
2265 
2266     // Reload values from the stack so they are where the stub
2267     // expects them.
2268     __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2269     __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2270     __ ldr(src,              Address(sp, 4*BytesPerWord));
2271 
2272     // r0 is -1^K where K == partial copied count
2273     __ eonw(rscratch1, r0, zr);
2274     // adjust length down and src/end pos up by partial copied count
2275     __ subw(length, length, rscratch1);
2276     __ addw(src_pos, src_pos, rscratch1);
2277     __ addw(dst_pos, dst_pos, rscratch1);
2278     __ b(*stub-&gt;entry());
2279 
2280     __ bind(*stub-&gt;continuation());
2281     return;
2282   }
2283 
2284   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
2285 
2286   int elem_size = type2aelembytes(basic_type);
2287   int scale = exact_log2(elem_size);
2288 
2289   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
2290   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
2291   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
2292   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
2293 
2294   // test for NULL
2295   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
2296     __ cbz(src, *stub-&gt;entry());
2297   }
2298   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
2299     __ cbz(dst, *stub-&gt;entry());
2300   }
2301 
2302   // If the compiler was not able to prove that exact type of the source or the destination
2303   // of the arraycopy is an array type, check at runtime if the source or the destination is
2304   // an instance type.
2305   if (flags &amp; LIR_OpArrayCopy::type_check) {
2306     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::dst_objarray)) {
2307       __ load_klass(tmp, dst);
2308       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2309       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2310       __ br(Assembler::GE, *stub-&gt;entry());
2311     }
2312 
2313     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::src_objarray)) {
2314       __ load_klass(tmp, src);
2315       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2316       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2317       __ br(Assembler::GE, *stub-&gt;entry());
2318     }
2319   }
2320 
2321   // check if negative
2322   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
2323     __ cmpw(src_pos, 0);
2324     __ br(Assembler::LT, *stub-&gt;entry());
2325   }
2326   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
2327     __ cmpw(dst_pos, 0);
2328     __ br(Assembler::LT, *stub-&gt;entry());
2329   }
2330 
2331   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
2332     __ cmpw(length, 0);
2333     __ br(Assembler::LT, *stub-&gt;entry());
2334   }
2335 
2336   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
2337     __ addw(tmp, src_pos, length);
2338     __ ldrw(rscratch1, src_length_addr);
2339     __ cmpw(tmp, rscratch1);
2340     __ br(Assembler::HI, *stub-&gt;entry());
2341   }
2342   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
2343     __ addw(tmp, dst_pos, length);
2344     __ ldrw(rscratch1, dst_length_addr);
2345     __ cmpw(tmp, rscratch1);
2346     __ br(Assembler::HI, *stub-&gt;entry());
2347   }
2348 
2349   if (flags &amp; LIR_OpArrayCopy::type_check) {
2350     // We don&#39;t know the array types are compatible
2351     if (basic_type != T_OBJECT) {
2352       // Simple test for basic type arrays
2353       if (UseCompressedClassPointers) {
2354         __ ldrw(tmp, src_klass_addr);
2355         __ ldrw(rscratch1, dst_klass_addr);
2356         __ cmpw(tmp, rscratch1);
2357       } else {
2358         __ ldr(tmp, src_klass_addr);
2359         __ ldr(rscratch1, dst_klass_addr);
2360         __ cmp(tmp, rscratch1);
2361       }
2362       __ br(Assembler::NE, *stub-&gt;entry());
2363     } else {
2364       // For object arrays, if src is a sub class of dst then we can
2365       // safely do the copy.
2366       Label cont, slow;
2367 
2368 #define PUSH(r1, r2)                                    \
2369       stp(r1, r2, __ pre(sp, -2 * wordSize));
2370 
2371 #define POP(r1, r2)                                     \
2372       ldp(r1, r2, __ post(sp, 2 * wordSize));
2373 
2374       __ PUSH(src, dst);
2375 
2376       __ load_klass(src, src);
2377       __ load_klass(dst, dst);
2378 
2379       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
2380 
2381       __ PUSH(src, dst);
2382       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
2383       __ POP(src, dst);
2384 
2385       __ cbnz(src, cont);
2386 
2387       __ bind(slow);
2388       __ POP(src, dst);
2389 
2390       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2391       if (copyfunc_addr != NULL) { // use stub if available
2392         // src is not a sub class of dst so we have to do a
2393         // per-element check.
2394 
2395         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2396         if ((flags &amp; mask) != mask) {
2397           // Check that at least both of them object arrays.
2398           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2399 
2400           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2401             __ load_klass(tmp, src);
2402           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2403             __ load_klass(tmp, dst);
2404           }
2405           int lh_offset = in_bytes(Klass::layout_helper_offset());
2406           Address klass_lh_addr(tmp, lh_offset);
2407           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2408           __ ldrw(rscratch1, klass_lh_addr);
2409           __ mov(rscratch2, objArray_lh);
2410           __ eorw(rscratch1, rscratch1, rscratch2);
2411           __ cbnzw(rscratch1, *stub-&gt;entry());
2412         }
2413 
2414        // Spill because stubs can use any register they like and it&#39;s
2415        // easier to restore just those that we care about.
2416         __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2417         __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2418         __ str(src,              Address(sp, 4*BytesPerWord));
2419 
2420         __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2421         __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2422         assert_different_registers(c_rarg0, dst, dst_pos, length);
2423         __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2424         __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2425         assert_different_registers(c_rarg1, dst, length);
2426         __ uxtw(c_rarg2, length);
2427         assert_different_registers(c_rarg2, dst);
2428 
2429         __ load_klass(c_rarg4, dst);
2430         __ ldr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
2431         __ ldrw(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
2432         __ far_call(RuntimeAddress(copyfunc_addr));
2433 
2434 #ifndef PRODUCT
2435         if (PrintC1Statistics) {
2436           Label failed;
2437           __ cbnz(r0, failed);
2438           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
2439           __ bind(failed);
2440         }
2441 #endif
2442 
2443         __ cbz(r0, *stub-&gt;continuation());
2444 
2445 #ifndef PRODUCT
2446         if (PrintC1Statistics) {
2447           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
2448         }
2449 #endif
2450         assert_different_registers(dst, dst_pos, length, src_pos, src, r0, rscratch1);
2451 
2452         // Restore previously spilled arguments
2453         __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2454         __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2455         __ ldr(src,              Address(sp, 4*BytesPerWord));
2456 
2457         // return value is -1^K where K is partial copied count
2458         __ eonw(rscratch1, r0, zr);
2459         // adjust length down and src/end pos up by partial copied count
2460         __ subw(length, length, rscratch1);
2461         __ addw(src_pos, src_pos, rscratch1);
2462         __ addw(dst_pos, dst_pos, rscratch1);
2463       }
2464 
2465       __ b(*stub-&gt;entry());
2466 
2467       __ bind(cont);
2468       __ POP(src, dst);
2469     }
2470   }
2471 
2472 #ifdef ASSERT
2473   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2474     // Sanity check the known type with the incoming class.  For the
2475     // primitive case the types must match exactly with src.klass and
2476     // dst.klass each exactly matching the default type.  For the
2477     // object array case, if no type check is needed then either the
2478     // dst type is exactly the expected type and the src type is a
2479     // subtype which we can&#39;t check or src is the same array as dst
2480     // but not necessarily exactly of type default_type.
2481     Label known_ok, halt;
2482     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
2483     if (UseCompressedClassPointers) {
2484       __ encode_klass_not_null(tmp);
2485     }
2486 
2487     if (basic_type != T_OBJECT) {
2488 
2489       if (UseCompressedClassPointers) {
2490         __ ldrw(rscratch1, dst_klass_addr);
2491         __ cmpw(tmp, rscratch1);
2492       } else {
2493         __ ldr(rscratch1, dst_klass_addr);
2494         __ cmp(tmp, rscratch1);
2495       }
2496       __ br(Assembler::NE, halt);
2497       if (UseCompressedClassPointers) {
2498         __ ldrw(rscratch1, src_klass_addr);
2499         __ cmpw(tmp, rscratch1);
2500       } else {
2501         __ ldr(rscratch1, src_klass_addr);
2502         __ cmp(tmp, rscratch1);
2503       }
2504       __ br(Assembler::EQ, known_ok);
2505     } else {
2506       if (UseCompressedClassPointers) {
2507         __ ldrw(rscratch1, dst_klass_addr);
2508         __ cmpw(tmp, rscratch1);
2509       } else {
2510         __ ldr(rscratch1, dst_klass_addr);
2511         __ cmp(tmp, rscratch1);
2512       }
2513       __ br(Assembler::EQ, known_ok);
2514       __ cmp(src, dst);
2515       __ br(Assembler::EQ, known_ok);
2516     }
2517     __ bind(halt);
2518     __ stop(&quot;incorrect type information in arraycopy&quot;);
2519     __ bind(known_ok);
2520   }
2521 #endif
2522 
2523 #ifndef PRODUCT
2524   if (PrintC1Statistics) {
2525     __ incrementw(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
2526   }
2527 #endif
2528 
2529   __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2530   __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2531   assert_different_registers(c_rarg0, dst, dst_pos, length);
2532   __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2533   __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2534   assert_different_registers(c_rarg1, dst, length);
2535   __ uxtw(c_rarg2, length);
2536   assert_different_registers(c_rarg2, dst);
2537 
2538   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2539   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2540   const char *name;
2541   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2542 
2543  CodeBlob *cb = CodeCache::find_blob(entry);
2544  if (cb) {
2545    __ far_call(RuntimeAddress(entry));
2546  } else {
2547    __ call_VM_leaf(entry, 3);
2548  }
2549 
2550   __ bind(*stub-&gt;continuation());
2551 }
2552 
2553 
2554 
2555 
2556 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2557   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
2558   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2559   Register lock = op-&gt;lock_opr()-&gt;as_register();
2560   if (!UseFastLocking) {
2561     __ b(*op-&gt;stub()-&gt;entry());
2562   } else if (op-&gt;code() == lir_lock) {
2563     Register scratch = noreg;
2564     if (UseBiasedLocking) {
2565       scratch = op-&gt;scratch_opr()-&gt;as_register();
2566     }
2567     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2568     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
2569     // add debug info for NullPointerException only if one is possible
2570     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
2571     if (op-&gt;info() != NULL) {
2572       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
2573     }
2574     // done
2575   } else if (op-&gt;code() == lir_unlock) {
2576     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2577     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2578   } else {
2579     Unimplemented();
2580   }
2581   __ bind(*op-&gt;stub()-&gt;continuation());
2582 }
2583 
2584 
2585 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2586   ciMethod* method = op-&gt;profiled_method();
2587   int bci          = op-&gt;profiled_bci();
2588   ciMethod* callee = op-&gt;profiled_callee();
2589 
2590   // Update counter for all call types
2591   ciMethodData* md = method-&gt;method_data_or_null();
2592   assert(md != NULL, &quot;Sanity&quot;);
2593   ciProfileData* data = md-&gt;bci_to_data(bci);
2594   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2595   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2596   Register mdo  = op-&gt;mdo()-&gt;as_register();
2597   __ mov_metadata(mdo, md-&gt;constant_encoding());
2598   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
2599   // Perform additional virtual call profiling for invokevirtual and
2600   // invokeinterface bytecodes
2601   if (op-&gt;should_profile_receiver_type()) {
2602     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2603     Register recv = op-&gt;recv()-&gt;as_register();
2604     assert_different_registers(mdo, recv);
2605     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2606     ciKlass* known_klass = op-&gt;known_holder();
2607     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2608       // We know the type that will be seen at this call site; we can
2609       // statically update the MethodData* rather than needing to do
2610       // dynamic tests on the receiver type
2611 
2612       // NOTE: we should probably put a lock around this search to
2613       // avoid collisions by concurrent compilations
2614       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2615       uint i;
2616       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2617         ciKlass* receiver = vc_data-&gt;receiver(i);
2618         if (known_klass-&gt;equals(receiver)) {
2619           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2620           __ addptr(data_addr, DataLayout::counter_increment);
2621           return;
2622         }
2623       }
2624 
2625       // Receiver type not found in profile data; select an empty slot
2626 
2627       // Note that this is less efficient than it should be because it
2628       // always does a write to the receiver part of the
2629       // VirtualCallData rather than just the first time
2630       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2631         ciKlass* receiver = vc_data-&gt;receiver(i);
2632         if (receiver == NULL) {
2633           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
2634           __ mov_metadata(rscratch1, known_klass-&gt;constant_encoding());
2635           __ lea(rscratch2, recv_addr);
2636           __ str(rscratch1, Address(rscratch2));
2637           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2638           __ addptr(data_addr, DataLayout::counter_increment);
2639           return;
2640         }
2641       }
2642     } else {
2643       __ load_klass(recv, recv);
2644       Label update_done;
2645       type_profile_helper(mdo, md, data, recv, &amp;update_done);
2646       // Receiver did not match any saved receiver and there is no empty row for it.
2647       // Increment total counter to indicate polymorphic case.
2648       __ addptr(counter_addr, DataLayout::counter_increment);
2649 
2650       __ bind(update_done);
2651     }
2652   } else {
2653     // Static call
2654     __ addptr(counter_addr, DataLayout::counter_increment);
2655   }
2656 }
2657 
2658 
2659 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
2660   Unimplemented();
2661 }
2662 
2663 
2664 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
2665   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
2666 }
2667 
2668 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
2669   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
2670   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
2671   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
2672   Register crc = op-&gt;crc()-&gt;as_register();
2673   Register val = op-&gt;val()-&gt;as_register();
2674   Register res = op-&gt;result_opr()-&gt;as_register();
2675 
2676   assert_different_registers(val, crc, res);
2677   uint64_t offset;
2678   __ adrp(res, ExternalAddress(StubRoutines::crc_table_addr()), offset);
2679   if (offset) __ add(res, res, offset);
2680 
2681   __ mvnw(crc, crc); // ~crc
2682   __ update_byte_crc32(crc, val, res);
2683   __ mvnw(res, crc); // ~crc
2684 }
2685 
2686 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2687   COMMENT(&quot;emit_profile_type {&quot;);
2688   Register obj = op-&gt;obj()-&gt;as_register();
2689   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
2690   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2691   ciKlass* exact_klass = op-&gt;exact_klass();
2692   intptr_t current_klass = op-&gt;current_klass();
2693   bool not_null = op-&gt;not_null();
2694   bool no_conflict = op-&gt;no_conflict();
2695 
2696   Label update, next, none;
2697 
2698   bool do_null = !not_null;
2699   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2700   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2701 
2702   assert(do_null || do_update, &quot;why are we here?&quot;);
2703   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2704   assert(mdo_addr.base() != rscratch1, &quot;wrong register&quot;);
2705 
2706   __ verify_oop(obj);
2707 
2708   if (tmp != obj) {
2709     __ mov(tmp, obj);
2710   }
2711   if (do_null) {
2712     __ cbnz(tmp, update);
2713     if (!TypeEntries::was_null_seen(current_klass)) {
2714       __ ldr(rscratch2, mdo_addr);
2715       __ orr(rscratch2, rscratch2, TypeEntries::null_seen);
2716       __ str(rscratch2, mdo_addr);
2717     }
2718     if (do_update) {
2719 #ifndef ASSERT
2720       __ b(next);
2721     }
2722 #else
2723       __ b(next);
2724     }
2725   } else {
2726     __ cbnz(tmp, update);
2727     __ stop(&quot;unexpected null obj&quot;);
2728 #endif
2729   }
2730 
2731   __ bind(update);
2732 
2733   if (do_update) {
2734 #ifdef ASSERT
2735     if (exact_klass != NULL) {
2736       Label ok;
2737       __ load_klass(tmp, tmp);
2738       __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2739       __ eor(rscratch1, tmp, rscratch1);
2740       __ cbz(rscratch1, ok);
2741       __ stop(&quot;exact klass and actual klass differ&quot;);
2742       __ bind(ok);
2743     }
2744 #endif
2745     if (!no_conflict) {
2746       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
2747         if (exact_klass != NULL) {
2748           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2749         } else {
2750           __ load_klass(tmp, tmp);
2751         }
2752 
2753         __ ldr(rscratch2, mdo_addr);
2754         __ eor(tmp, tmp, rscratch2);
2755         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2756         // klass seen before, nothing to do. The unknown bit may have been
2757         // set already but no need to check.
2758         __ cbz(rscratch1, next);
2759 
2760         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2761 
2762         if (TypeEntries::is_type_none(current_klass)) {
2763           __ cbz(rscratch2, none);
2764           __ cmp(rscratch2, (u1)TypeEntries::null_seen);
2765           __ br(Assembler::EQ, none);
2766           // There is a chance that the checks above (re-reading profiling
2767           // data from memory) fail if another thread has just set the
2768           // profiling to this obj&#39;s klass
2769           __ dmb(Assembler::ISHLD);
2770           __ ldr(rscratch2, mdo_addr);
2771           __ eor(tmp, tmp, rscratch2);
2772           __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2773           __ cbz(rscratch1, next);
2774         }
2775       } else {
2776         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2777                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
2778 
2779         __ ldr(tmp, mdo_addr);
2780         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2781       }
2782 
2783       // different than before. Cannot keep accurate profile.
2784       __ ldr(rscratch2, mdo_addr);
2785       __ orr(rscratch2, rscratch2, TypeEntries::type_unknown);
2786       __ str(rscratch2, mdo_addr);
2787 
2788       if (TypeEntries::is_type_none(current_klass)) {
2789         __ b(next);
2790 
2791         __ bind(none);
2792         // first time here. Set profile type.
2793         __ str(tmp, mdo_addr);
2794       }
2795     } else {
2796       // There&#39;s a single possible klass at this profile point
2797       assert(exact_klass != NULL, &quot;should be&quot;);
2798       if (TypeEntries::is_type_none(current_klass)) {
2799         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2800         __ ldr(rscratch2, mdo_addr);
2801         __ eor(tmp, tmp, rscratch2);
2802         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2803         __ cbz(rscratch1, next);
2804 #ifdef ASSERT
2805         {
2806           Label ok;
2807           __ ldr(rscratch1, mdo_addr);
2808           __ cbz(rscratch1, ok);
2809           __ cmp(rscratch1, (u1)TypeEntries::null_seen);
2810           __ br(Assembler::EQ, ok);
2811           // may have been set by another thread
2812           __ dmb(Assembler::ISHLD);
2813           __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2814           __ ldr(rscratch2, mdo_addr);
2815           __ eor(rscratch2, rscratch1, rscratch2);
2816           __ andr(rscratch2, rscratch2, TypeEntries::type_mask);
2817           __ cbz(rscratch2, ok);
2818 
2819           __ stop(&quot;unexpected profiling mismatch&quot;);
2820           __ bind(ok);
2821         }
2822 #endif
2823         // first time here. Set profile type.
2824         __ ldr(tmp, mdo_addr);
2825       } else {
2826         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2827                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
2828 
2829         __ ldr(tmp, mdo_addr);
2830         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2831 
2832         __ orr(tmp, tmp, TypeEntries::type_unknown);
2833         __ str(tmp, mdo_addr);
2834         // FIXME: Write barrier needed here?
2835       }
2836     }
2837 
2838     __ bind(next);
2839   }
2840   COMMENT(&quot;} emit_profile_type&quot;);
2841 }
2842 
2843 
2844 void LIR_Assembler::align_backward_branch_target() {
2845 }
2846 
2847 
2848 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2849   // tmp must be unused
2850   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2851 
2852   if (left-&gt;is_single_cpu()) {
2853     assert(dest-&gt;is_single_cpu(), &quot;expect single result reg&quot;);
2854     __ negw(dest-&gt;as_register(), left-&gt;as_register());
2855   } else if (left-&gt;is_double_cpu()) {
2856     assert(dest-&gt;is_double_cpu(), &quot;expect double result reg&quot;);
2857     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2858   } else if (left-&gt;is_single_fpu()) {
2859     assert(dest-&gt;is_single_fpu(), &quot;expect single float result reg&quot;);
2860     __ fnegs(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2861   } else {
2862     assert(left-&gt;is_double_fpu(), &quot;expect double float operand reg&quot;);
2863     assert(dest-&gt;is_double_fpu(), &quot;expect double float result reg&quot;);
2864     __ fnegd(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2865   }
2866 }
2867 
2868 
2869 void LIR_Assembler::leal(LIR_Opr addr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2870   if (patch_code != lir_patch_none) {
2871     deoptimize_trap(info);
2872     return;
2873   }
2874 
2875   __ lea(dest-&gt;as_register_lo(), as_Address(addr-&gt;as_address_ptr()));
2876 }
2877 
2878 
2879 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2880   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
2881 
2882   CodeBlob *cb = CodeCache::find_blob(dest);
2883   if (cb) {
2884     __ far_call(RuntimeAddress(dest));
2885   } else {
2886     __ mov(rscratch1, RuntimeAddress(dest));
2887     __ blr(rscratch1);
2888   }
2889 
2890   if (info != NULL) {
2891     add_call_info_here(info);
2892   }
2893   __ maybe_isb();
2894 }
2895 
2896 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2897   if (dest-&gt;is_address() || src-&gt;is_address()) {
2898     move_op(src, dest, type, lir_patch_none, info,
2899             /*pop_fpu_stack*/false, /*unaligned*/false, /*wide*/false);
2900   } else {
2901     ShouldNotReachHere();
2902   }
2903 }
2904 
2905 #ifdef ASSERT
2906 // emit run-time assertion
2907 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2908   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
2909 
2910   if (op-&gt;in_opr1()-&gt;is_valid()) {
2911     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
2912     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
2913   } else {
2914     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
2915     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
2916   }
2917 
2918   Label ok;
2919   if (op-&gt;condition() != lir_cond_always) {
2920     Assembler::Condition acond = Assembler::AL;
2921     switch (op-&gt;condition()) {
2922       case lir_cond_equal:        acond = Assembler::EQ;  break;
2923       case lir_cond_notEqual:     acond = Assembler::NE;  break;
2924       case lir_cond_less:         acond = Assembler::LT;  break;
2925       case lir_cond_lessEqual:    acond = Assembler::LE;  break;
2926       case lir_cond_greaterEqual: acond = Assembler::GE;  break;
2927       case lir_cond_greater:      acond = Assembler::GT;  break;
2928       case lir_cond_belowEqual:   acond = Assembler::LS;  break;
2929       case lir_cond_aboveEqual:   acond = Assembler::HS;  break;
2930       default:                    ShouldNotReachHere();
2931     }
2932     __ br(acond, ok);
2933   }
2934   if (op-&gt;halt()) {
2935     const char* str = __ code_string(op-&gt;msg());
2936     __ stop(str);
2937   } else {
2938     breakpoint();
2939   }
2940   __ bind(ok);
2941 }
2942 #endif
2943 
2944 #ifndef PRODUCT
2945 #define COMMENT(x)   do { __ block_comment(x); } while (0)
2946 #else
2947 #define COMMENT(x)
2948 #endif
2949 
2950 void LIR_Assembler::membar() {
2951   COMMENT(&quot;membar&quot;);
2952   __ membar(MacroAssembler::AnyAny);
2953 }
2954 
2955 void LIR_Assembler::membar_acquire() {
2956   __ membar(Assembler::LoadLoad|Assembler::LoadStore);
2957 }
2958 
2959 void LIR_Assembler::membar_release() {
2960   __ membar(Assembler::LoadStore|Assembler::StoreStore);
2961 }
2962 
2963 void LIR_Assembler::membar_loadload() {
2964   __ membar(Assembler::LoadLoad);
2965 }
2966 
2967 void LIR_Assembler::membar_storestore() {
2968   __ membar(MacroAssembler::StoreStore);
2969 }
2970 
2971 void LIR_Assembler::membar_loadstore() { __ membar(MacroAssembler::LoadStore); }
2972 
2973 void LIR_Assembler::membar_storeload() { __ membar(MacroAssembler::StoreLoad); }
2974 
2975 void LIR_Assembler::on_spin_wait() {
2976   Unimplemented();
2977 }
2978 
2979 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
2980   __ mov(result_reg-&gt;as_register(), rthread);
2981 }
2982 
2983 
2984 void LIR_Assembler::peephole(LIR_List *lir) {
2985 #if 0
2986   if (tableswitch_count &gt;= max_tableswitches)
2987     return;
2988 
2989   /*
2990     This finite-state automaton recognizes sequences of compare-and-
2991     branch instructions.  We will turn them into a tableswitch.  You
2992     could argue that C1 really shouldn&#39;t be doing this sort of
2993     optimization, but without it the code is really horrible.
2994   */
2995 
2996   enum { start_s, cmp1_s, beq_s, cmp_s } state;
2997   int first_key, last_key = -2147483648;
2998   int next_key = 0;
2999   int start_insn = -1;
3000   int last_insn = -1;
3001   Register reg = noreg;
3002   LIR_Opr reg_opr;
3003   state = start_s;
3004 
3005   LIR_OpList* inst = lir-&gt;instructions_list();
3006   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3007     LIR_Op* op = inst-&gt;at(i);
3008     switch (state) {
3009     case start_s:
3010       first_key = -1;
3011       start_insn = i;
3012       switch (op-&gt;code()) {
3013       case lir_cmp:
3014         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3015         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3016         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3017             &amp;&amp; opr2-&gt;is_constant()
3018             &amp;&amp; opr2-&gt;type() == T_INT) {
3019           reg_opr = opr1;
3020           reg = opr1-&gt;as_register();
3021           first_key = opr2-&gt;as_constant_ptr()-&gt;as_jint();
3022           next_key = first_key + 1;
3023           state = cmp_s;
3024           goto next_state;
3025         }
3026         break;
3027       }
3028       break;
3029     case cmp_s:
3030       switch (op-&gt;code()) {
3031       case lir_branch:
3032         if (op-&gt;as_OpBranch()-&gt;cond() == lir_cond_equal) {
3033           state = beq_s;
3034           last_insn = i;
3035           goto next_state;
3036         }
3037       }
3038       state = start_s;
3039       break;
3040     case beq_s:
3041       switch (op-&gt;code()) {
3042       case lir_cmp: {
3043         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3044         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3045         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3046             &amp;&amp; opr1-&gt;as_register() == reg
3047             &amp;&amp; opr2-&gt;is_constant()
3048             &amp;&amp; opr2-&gt;type() == T_INT
3049             &amp;&amp; opr2-&gt;as_constant_ptr()-&gt;as_jint() == next_key) {
3050           last_key = next_key;
3051           next_key++;
3052           state = cmp_s;
3053           goto next_state;
3054         }
3055       }
3056       }
3057       last_key = next_key;
3058       state = start_s;
3059       break;
3060     default:
3061       assert(false, &quot;impossible state&quot;);
3062     }
3063     if (state == start_s) {
3064       if (first_key &lt; last_key - 5L &amp;&amp; reg != noreg) {
3065         {
3066           // printf(&quot;found run register %d starting at insn %d low value %d high value %d\n&quot;,
3067           //        reg-&gt;encoding(),
3068           //        start_insn, first_key, last_key);
3069           //   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3070           //     inst-&gt;at(i)-&gt;print();
3071           //     tty-&gt;print(&quot;\n&quot;);
3072           //   }
3073           //   tty-&gt;print(&quot;\n&quot;);
3074         }
3075 
3076         struct tableswitch *sw = &amp;switches[tableswitch_count];
3077         sw-&gt;_insn_index = start_insn, sw-&gt;_first_key = first_key,
3078           sw-&gt;_last_key = last_key, sw-&gt;_reg = reg;
3079         inst-&gt;insert_before(last_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_after));
3080         {
3081           // Insert the new table of branches
3082           int offset = last_insn;
3083           for (int n = first_key; n &lt; last_key; n++) {
3084             inst-&gt;insert_before
3085               (last_insn + 1,
3086                new LIR_OpBranch(lir_cond_always, T_ILLEGAL,
3087                                 inst-&gt;at(offset)-&gt;as_OpBranch()-&gt;label()));
3088             offset -= 2, i++;
3089           }
3090         }
3091         // Delete all the old compare-and-branch instructions
3092         for (int n = first_key; n &lt; last_key; n++) {
3093           inst-&gt;remove_at(start_insn);
3094           inst-&gt;remove_at(start_insn);
3095         }
3096         // Insert the tableswitch instruction
3097         inst-&gt;insert_before(start_insn,
3098                             new LIR_Op2(lir_cmp, lir_cond_always,
3099                                         LIR_OprFact::intConst(tableswitch_count),
3100                                         reg_opr));
3101         inst-&gt;insert_before(start_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_branches));
3102         tableswitch_count++;
3103       }
3104       reg = noreg;
3105       last_key = -2147483648;
3106     }
3107   next_state:
3108     ;
3109   }
3110 #endif
3111 }
3112 
3113 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
3114   Address addr = as_Address(src-&gt;as_address_ptr());
3115   BasicType type = src-&gt;type();
3116   bool is_oop = is_reference_type(type);
3117 
3118   void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
3119   void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
3120 
3121   switch(type) {
3122   case T_INT:
3123     xchg = &amp;MacroAssembler::atomic_xchgalw;
3124     add = &amp;MacroAssembler::atomic_addalw;
3125     break;
3126   case T_LONG:
3127     xchg = &amp;MacroAssembler::atomic_xchgal;
3128     add = &amp;MacroAssembler::atomic_addal;
3129     break;
3130   case T_OBJECT:
3131   case T_ARRAY:
3132     if (UseCompressedOops) {
3133       xchg = &amp;MacroAssembler::atomic_xchgalw;
3134       add = &amp;MacroAssembler::atomic_addalw;
3135     } else {
3136       xchg = &amp;MacroAssembler::atomic_xchgal;
3137       add = &amp;MacroAssembler::atomic_addal;
3138     }
3139     break;
3140   default:
3141     ShouldNotReachHere();
3142     xchg = &amp;MacroAssembler::atomic_xchgal;
3143     add = &amp;MacroAssembler::atomic_addal; // unreachable
3144   }
3145 
3146   switch (code) {
3147   case lir_xadd:
3148     {
3149       RegisterOrConstant inc;
3150       Register tmp = as_reg(tmp_op);
3151       Register dst = as_reg(dest);
3152       if (data-&gt;is_constant()) {
3153         inc = RegisterOrConstant(as_long(data));
3154         assert_different_registers(dst, addr.base(), tmp,
3155                                    rscratch1, rscratch2);
3156       } else {
3157         inc = RegisterOrConstant(as_reg(data));
3158         assert_different_registers(inc.as_register(), dst, addr.base(), tmp,
3159                                    rscratch1, rscratch2);
3160       }
3161       __ lea(tmp, addr);
3162       (_masm-&gt;*add)(dst, inc, tmp);
3163       break;
3164     }
3165   case lir_xchg:
3166     {
3167       Register tmp = tmp_op-&gt;as_register();
3168       Register obj = as_reg(data);
3169       Register dst = as_reg(dest);
3170       if (is_oop &amp;&amp; UseCompressedOops) {
3171         __ encode_heap_oop(rscratch2, obj);
3172         obj = rscratch2;
3173       }
3174       assert_different_registers(obj, addr.base(), tmp, rscratch1, dst);
3175       __ lea(tmp, addr);
3176       (_masm-&gt;*xchg)(dst, obj, tmp);
3177       if (is_oop &amp;&amp; UseCompressedOops) {
3178         __ decode_heap_oop(dst);
3179       }
3180     }
3181     break;
3182   default:
3183     ShouldNotReachHere();
3184   }
3185   __ membar(__ AnyAny);
3186 }
3187 
3188 #undef __
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>