<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // Copyright (c) 2017, 2020 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 
   25 // z/Architecture Architecture Description File
   26 
   27 // Major contributions by AS, JL, LS.
   28 
   29 //
   30 // Following information is derived from private mail communication
   31 // (Oct. 2011).
   32 //
   33 // General branch target alignment considerations
   34 //
   35 // z/Architecture does not imply a general branch target alignment requirement.
   36 // There are side effects and side considerations, though, which may
   37 // provide some performance benefit. These are:
   38 //  - Align branch target on octoword (32-byte) boundary
   39 //    On more recent models (from z9 on), I-fetch is done on a Octoword
   40 //    (32 bytes at a time) basis. To avoid I-fetching unnecessary
   41 //    instructions, branch targets should be 32-byte aligend. If this
   42 //    exact alingment cannot be achieved, having the branch target in
   43 //    the first doubleword still provides some benefit.
   44 //  - Avoid branch targets at the end of cache lines (&gt; 64 bytes distance).
   45 //    Sequential instruction prefetching after the branch target starts
   46 //    immediately after having fetched the octoword containing the
   47 //    branch target. When I-fetching crosses a cache line, there may be
   48 //    a small stall. The worst case: the branch target (at the end of
   49 //    a cache line) is a L1 I-cache miss and the next line as well.
   50 //    Then, the entire target line must be filled first (to contine at the
   51 //    branch target). Only then can the next sequential line be filled.
   52 //  - Avoid multiple poorly predicted branches in a row.
   53 //
   54 
   55 //----------REGISTER DEFINITION BLOCK------------------------------------------
   56 // This information is used by the matcher and the register allocator to
   57 // describe individual registers and classes of registers within the target
   58 // architecture.
   59 
   60 register %{
   61 
   62 //----------Architecture Description Register Definitions----------------------
   63 // General Registers
   64 // &quot;reg_def&quot; name (register save type, C convention save type,
   65 //                   ideal register type, encoding);
   66 //
   67 // Register Save Types:
   68 //
   69 //   NS  = No-Save:     The register allocator assumes that these registers
   70 //                      can be used without saving upon entry to the method, &amp;
   71 //                      that they do not need to be saved at call sites.
   72 //
   73 //   SOC = Save-On-Call: The register allocator assumes that these registers
   74 //                      can be used without saving upon entry to the method,
   75 //                      but that they must be saved at call sites.
   76 //
   77 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   78 //                      must be saved before using them upon entry to the
   79 //                      method, but they do not need to be saved at call sites.
   80 //
   81 //   AS  = Always-Save: The register allocator assumes that these registers
   82 //                      must be saved before using them upon entry to the
   83 //                      method, &amp; that they must be saved at call sites.
   84 //
   85 // Ideal Register Type is used to determine how to save &amp; restore a
   86 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   87 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   88 //
   89 // The encoding number is the actual bit-pattern placed into the opcodes.
   90 
   91 // z/Architecture register definitions, based on the z/Architecture Principles
   92 // of Operation, 5th Edition, September 2005, and z/Linux Elf ABI Supplement,
   93 // 5th Edition, March 2001.
   94 //
   95 // For each 64-bit register we must define two registers: the register
   96 // itself, e.g. Z_R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   97 // e.g. Z_R3_H, which is needed by the allocator, but is not used
   98 // for stores, loads, etc.
   99 
  100   // Integer/Long Registers
  101   // ----------------------------
  102 
  103   // z/Architecture has 16 64-bit integer registers.
  104 
  105   // types: v = volatile, nv = non-volatile, s = system
  106   reg_def Z_R0   (SOC, SOC, Op_RegI,  0, Z_R0-&gt;as_VMReg());   // v   scratch1
  107   reg_def Z_R0_H (SOC, SOC, Op_RegI, 99, Z_R0-&gt;as_VMReg()-&gt;next());
  108   reg_def Z_R1   (SOC, SOC, Op_RegI,  1, Z_R1-&gt;as_VMReg());   // v   scratch2
  109   reg_def Z_R1_H (SOC, SOC, Op_RegI, 99, Z_R1-&gt;as_VMReg()-&gt;next());
  110   reg_def Z_R2   (SOC, SOC, Op_RegI,  2, Z_R2-&gt;as_VMReg());   // v   iarg1 &amp; iret
  111   reg_def Z_R2_H (SOC, SOC, Op_RegI, 99, Z_R2-&gt;as_VMReg()-&gt;next());
  112   reg_def Z_R3   (SOC, SOC, Op_RegI,  3, Z_R3-&gt;as_VMReg());   // v   iarg2
  113   reg_def Z_R3_H (SOC, SOC, Op_RegI, 99, Z_R3-&gt;as_VMReg()-&gt;next());
  114   reg_def Z_R4   (SOC, SOC, Op_RegI,  4, Z_R4-&gt;as_VMReg());   // v   iarg3
  115   reg_def Z_R4_H (SOC, SOC, Op_RegI, 99, Z_R4-&gt;as_VMReg()-&gt;next());
  116   reg_def Z_R5   (SOC, SOC, Op_RegI,  5, Z_R5-&gt;as_VMReg());   // v   iarg4
  117   reg_def Z_R5_H (SOC, SOC, Op_RegI, 99, Z_R5-&gt;as_VMReg()-&gt;next());
  118   reg_def Z_R6   (SOC, SOE, Op_RegI,  6, Z_R6-&gt;as_VMReg());   // v   iarg5
  119   reg_def Z_R6_H (SOC, SOE, Op_RegI, 99, Z_R6-&gt;as_VMReg()-&gt;next());
  120   reg_def Z_R7   (SOC, SOE, Op_RegI,  7, Z_R7-&gt;as_VMReg());
  121   reg_def Z_R7_H (SOC, SOE, Op_RegI, 99, Z_R7-&gt;as_VMReg()-&gt;next());
  122   reg_def Z_R8   (SOC, SOE, Op_RegI,  8, Z_R8-&gt;as_VMReg());
  123   reg_def Z_R8_H (SOC, SOE, Op_RegI, 99, Z_R8-&gt;as_VMReg()-&gt;next());
  124   reg_def Z_R9   (SOC, SOE, Op_RegI,  9, Z_R9-&gt;as_VMReg());
  125   reg_def Z_R9_H (SOC, SOE, Op_RegI, 99, Z_R9-&gt;as_VMReg()-&gt;next());
  126   reg_def Z_R10  (SOC, SOE, Op_RegI, 10, Z_R10-&gt;as_VMReg());
  127   reg_def Z_R10_H(SOC, SOE, Op_RegI, 99, Z_R10-&gt;as_VMReg()-&gt;next());
  128   reg_def Z_R11  (SOC, SOE, Op_RegI, 11, Z_R11-&gt;as_VMReg());
  129   reg_def Z_R11_H(SOC, SOE, Op_RegI, 99, Z_R11-&gt;as_VMReg()-&gt;next());
  130   reg_def Z_R12  (SOC, SOE, Op_RegI, 12, Z_R12-&gt;as_VMReg());
  131   reg_def Z_R12_H(SOC, SOE, Op_RegI, 99, Z_R12-&gt;as_VMReg()-&gt;next());
  132   reg_def Z_R13  (SOC, SOE, Op_RegI, 13, Z_R13-&gt;as_VMReg());
  133   reg_def Z_R13_H(SOC, SOE, Op_RegI, 99, Z_R13-&gt;as_VMReg()-&gt;next());
  134   reg_def Z_R14  (NS,  NS,  Op_RegI, 14, Z_R14-&gt;as_VMReg());   // s  return_pc
  135   reg_def Z_R14_H(NS,  NS,  Op_RegI, 99, Z_R14-&gt;as_VMReg()-&gt;next());
  136   reg_def Z_R15  (NS,  NS,  Op_RegI, 15, Z_R15-&gt;as_VMReg());   // s  SP
  137   reg_def Z_R15_H(NS,  NS,  Op_RegI, 99, Z_R15-&gt;as_VMReg()-&gt;next());
  138 
  139   // Float/Double Registers
  140 
  141   // The rules of ADL require that double registers be defined in pairs.
  142   // Each pair must be two 32-bit values, but not necessarily a pair of
  143   // single float registers. In each pair, ADLC-assigned register numbers
  144   // must be adjacent, with the lower number even. Finally, when the
  145   // CPU stores such a register pair to memory, the word associated with
  146   // the lower ADLC-assigned number must be stored to the lower address.
  147 
  148   // z/Architecture has 16 64-bit floating-point registers. Each can store a single
  149   // or double precision floating-point value.
  150 
  151   // types: v = volatile, nv = non-volatile, s = system
  152   reg_def Z_F0   (SOC, SOC, Op_RegF,  0, Z_F0-&gt;as_VMReg());   // v   farg1 &amp; fret
  153   reg_def Z_F0_H (SOC, SOC, Op_RegF, 99, Z_F0-&gt;as_VMReg()-&gt;next());
  154   reg_def Z_F1   (SOC, SOC, Op_RegF,  1, Z_F1-&gt;as_VMReg());
  155   reg_def Z_F1_H (SOC, SOC, Op_RegF, 99, Z_F1-&gt;as_VMReg()-&gt;next());
  156   reg_def Z_F2   (SOC, SOC, Op_RegF,  2, Z_F2-&gt;as_VMReg());   // v   farg2
  157   reg_def Z_F2_H (SOC, SOC, Op_RegF, 99, Z_F2-&gt;as_VMReg()-&gt;next());
  158   reg_def Z_F3   (SOC, SOC, Op_RegF,  3, Z_F3-&gt;as_VMReg());
  159   reg_def Z_F3_H (SOC, SOC, Op_RegF, 99, Z_F3-&gt;as_VMReg()-&gt;next());
  160   reg_def Z_F4   (SOC, SOC, Op_RegF,  4, Z_F4-&gt;as_VMReg());   // v   farg3
  161   reg_def Z_F4_H (SOC, SOC, Op_RegF, 99, Z_F4-&gt;as_VMReg()-&gt;next());
  162   reg_def Z_F5   (SOC, SOC, Op_RegF,  5, Z_F5-&gt;as_VMReg());
  163   reg_def Z_F5_H (SOC, SOC, Op_RegF, 99, Z_F5-&gt;as_VMReg()-&gt;next());
  164   reg_def Z_F6   (SOC, SOC, Op_RegF,  6, Z_F6-&gt;as_VMReg());
  165   reg_def Z_F6_H (SOC, SOC, Op_RegF, 99, Z_F6-&gt;as_VMReg()-&gt;next());
  166   reg_def Z_F7   (SOC, SOC, Op_RegF,  7, Z_F7-&gt;as_VMReg());
  167   reg_def Z_F7_H (SOC, SOC, Op_RegF, 99, Z_F7-&gt;as_VMReg()-&gt;next());
  168   reg_def Z_F8   (SOC, SOE, Op_RegF,  8, Z_F8-&gt;as_VMReg());
  169   reg_def Z_F8_H (SOC, SOE, Op_RegF, 99, Z_F8-&gt;as_VMReg()-&gt;next());
  170   reg_def Z_F9   (SOC, SOE, Op_RegF,  9, Z_F9-&gt;as_VMReg());
  171   reg_def Z_F9_H (SOC, SOE, Op_RegF, 99, Z_F9-&gt;as_VMReg()-&gt;next());
  172   reg_def Z_F10  (SOC, SOE, Op_RegF, 10, Z_F10-&gt;as_VMReg());
  173   reg_def Z_F10_H(SOC, SOE, Op_RegF, 99, Z_F10-&gt;as_VMReg()-&gt;next());
  174   reg_def Z_F11  (SOC, SOE, Op_RegF, 11, Z_F11-&gt;as_VMReg());
  175   reg_def Z_F11_H(SOC, SOE, Op_RegF, 99, Z_F11-&gt;as_VMReg()-&gt;next());
  176   reg_def Z_F12  (SOC, SOE, Op_RegF, 12, Z_F12-&gt;as_VMReg());
  177   reg_def Z_F12_H(SOC, SOE, Op_RegF, 99, Z_F12-&gt;as_VMReg()-&gt;next());
  178   reg_def Z_F13  (SOC, SOE, Op_RegF, 13, Z_F13-&gt;as_VMReg());
  179   reg_def Z_F13_H(SOC, SOE, Op_RegF, 99, Z_F13-&gt;as_VMReg()-&gt;next());
  180   reg_def Z_F14  (SOC, SOE, Op_RegF, 14, Z_F14-&gt;as_VMReg());
  181   reg_def Z_F14_H(SOC, SOE, Op_RegF, 99, Z_F14-&gt;as_VMReg()-&gt;next());
  182   reg_def Z_F15  (SOC, SOE, Op_RegF, 15, Z_F15-&gt;as_VMReg());
  183   reg_def Z_F15_H(SOC, SOE, Op_RegF, 99, Z_F15-&gt;as_VMReg()-&gt;next());
  184 
  185 
  186   // Special Registers
  187 
  188   // Condition Codes Flag Registers
  189 
  190   // z/Architecture has the PSW (program status word) that contains
  191   // (among other information) the condition code. We treat this
  192   // part of the PSW as a condition register CR. It consists of 4
  193   // bits. Floating point instructions influence the same condition register CR.
  194 
  195   reg_def Z_CR(SOC, SOC, Op_RegFlags, 0, Z_CR-&gt;as_VMReg());   // volatile
  196 
  197 
  198 // Specify priority of register selection within phases of register
  199 // allocation. Highest priority is first. A useful heuristic is to
  200 // give registers a low priority when they are required by machine
  201 // instructions, and choose no-save registers before save-on-call, and
  202 // save-on-call before save-on-entry. Registers which participate in
  203 // fix calling sequences should come last. Registers which are used
  204 // as pairs must fall on an even boundary.
  205 
  206 // It&#39;s worth about 1% on SPEC geomean to get this right.
  207 
  208 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  209 // in adGlobals_s390.hpp which defines the &lt;register&gt;_num values, e.g.
  210 // Z_R3_num. Therefore, Z_R3_num may not be (and in reality is not)
  211 // the same as Z_R3-&gt;encoding()! Furthermore, we cannot make any
  212 // assumptions on ordering, e.g. Z_R3_num may be less than Z_R2_num.
  213 // Additionally, the function
  214 //   static enum RC rc_class(OptoReg::Name reg)
  215 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  216 // and its current implementation relies on chunk0 and chunk1 having a
  217 // size of 64 each.
  218 
  219 alloc_class chunk0(
  220   // chunk0 contains *all* 32 integer registers halves.
  221 
  222   // potential SOE regs
  223   Z_R13,Z_R13_H,
  224   Z_R12,Z_R12_H,
  225   Z_R11,Z_R11_H,
  226   Z_R10,Z_R10_H,
  227 
  228   Z_R9,Z_R9_H,
  229   Z_R8,Z_R8_H,
  230   Z_R7,Z_R7_H,
  231 
  232   Z_R1,Z_R1_H,
  233   Z_R0,Z_R0_H,
  234 
  235   // argument registers
  236   Z_R6,Z_R6_H,
  237   Z_R5,Z_R5_H,
  238   Z_R4,Z_R4_H,
  239   Z_R3,Z_R3_H,
  240   Z_R2,Z_R2_H,
  241 
  242   // special registers
  243   Z_R14,Z_R14_H,
  244   Z_R15,Z_R15_H
  245 );
  246 
  247 alloc_class chunk1(
  248   // Chunk1 contains *all* 64 floating-point registers halves.
  249 
  250   Z_F15,Z_F15_H,
  251   Z_F14,Z_F14_H,
  252   Z_F13,Z_F13_H,
  253   Z_F12,Z_F12_H,
  254   Z_F11,Z_F11_H,
  255   Z_F10,Z_F10_H,
  256   Z_F9,Z_F9_H,
  257   Z_F8,Z_F8_H,
  258   // scratch register
  259   Z_F7,Z_F7_H,
  260   Z_F5,Z_F5_H,
  261   Z_F3,Z_F3_H,
  262   Z_F1,Z_F1_H,
  263   // argument registers
  264   Z_F6,Z_F6_H,
  265   Z_F4,Z_F4_H,
  266   Z_F2,Z_F2_H,
  267   Z_F0,Z_F0_H
  268 );
  269 
  270 alloc_class chunk2(
  271   Z_CR
  272 );
  273 
  274 
  275 //-------Architecture Description Register Classes-----------------------
  276 
  277 // Several register classes are automatically defined based upon
  278 // information in this architecture description.
  279 
  280 // 1) reg_class inline_cache_reg           (as defined in frame section)
  281 // 2) reg_class compiler_method_oop_reg    (as defined in frame section)
  282 // 2) reg_class interpreter_method_oop_reg (as defined in frame section)
  283 // 3) reg_class stack_slots(/* one chunk of stack-based &quot;registers&quot; */)
  284 
  285 // Integer Register Classes
  286 reg_class z_int_reg(
  287 /*Z_R0*/              // R0
  288 /*Z_R1*/
  289   Z_R2,
  290   Z_R3,
  291   Z_R4,
  292   Z_R5,
  293   Z_R6,
  294   Z_R7,
  295 /*Z_R8,*/             // Z_thread
  296   Z_R9,
  297   Z_R10,
  298   Z_R11,
  299   Z_R12,
  300   Z_R13
  301 /*Z_R14*/             // return_pc
  302 /*Z_R15*/             // SP
  303 );
  304 
  305 reg_class z_no_odd_int_reg(
  306 /*Z_R0*/              // R0
  307 /*Z_R1*/
  308   Z_R2,
  309   Z_R3,
  310   Z_R4,
  311 /*Z_R5,*/             // odd part of fix register pair
  312   Z_R6,
  313   Z_R7,
  314 /*Z_R8,*/             // Z_thread
  315   Z_R9,
  316   Z_R10,
  317   Z_R11,
  318   Z_R12,
  319   Z_R13
  320 /*Z_R14*/             // return_pc
  321 /*Z_R15*/             // SP
  322 );
  323 
  324 reg_class z_no_arg_int_reg(
  325 /*Z_R0*/              // R0
  326 /*Z_R1*/              // scratch
  327 /*Z_R2*/
  328 /*Z_R3*/
  329 /*Z_R4*/
  330 /*Z_R5*/
  331 /*Z_R6*/
  332   Z_R7,
  333 /*Z_R8*/              // Z_thread
  334   Z_R9,
  335   Z_R10,
  336   Z_R11,
  337   Z_R12,
  338   Z_R13
  339 /*Z_R14*/             // return_pc
  340 /*Z_R15*/             // SP
  341 );
  342 
  343 reg_class z_rarg1_int_reg(Z_R2);
  344 reg_class z_rarg2_int_reg(Z_R3);
  345 reg_class z_rarg3_int_reg(Z_R4);
  346 reg_class z_rarg4_int_reg(Z_R5);
  347 reg_class z_rarg5_int_reg(Z_R6);
  348 
  349 // Pointer Register Classes
  350 
  351 // 64-bit build means 64-bit pointers means hi/lo pairs.
  352 
  353 reg_class z_rarg5_ptrN_reg(Z_R6);
  354 
  355 reg_class z_rarg1_ptr_reg(Z_R2_H,Z_R2);
  356 reg_class z_rarg2_ptr_reg(Z_R3_H,Z_R3);
  357 reg_class z_rarg3_ptr_reg(Z_R4_H,Z_R4);
  358 reg_class z_rarg4_ptr_reg(Z_R5_H,Z_R5);
  359 reg_class z_rarg5_ptr_reg(Z_R6_H,Z_R6);
  360 reg_class z_thread_ptr_reg(Z_R8_H,Z_R8);
  361 
  362 reg_class z_ptr_reg(
  363 /*Z_R0_H,Z_R0*/     // R0
  364 /*Z_R1_H,Z_R1*/
  365   Z_R2_H,Z_R2,
  366   Z_R3_H,Z_R3,
  367   Z_R4_H,Z_R4,
  368   Z_R5_H,Z_R5,
  369   Z_R6_H,Z_R6,
  370   Z_R7_H,Z_R7,
  371 /*Z_R8_H,Z_R8,*/    // Z_thread
  372   Z_R9_H,Z_R9,
  373   Z_R10_H,Z_R10,
  374   Z_R11_H,Z_R11,
  375   Z_R12_H,Z_R12,
  376   Z_R13_H,Z_R13
  377 /*Z_R14_H,Z_R14*/   // return_pc
  378 /*Z_R15_H,Z_R15*/   // SP
  379 );
  380 
  381 reg_class z_lock_ptr_reg(
  382 /*Z_R0_H,Z_R0*/     // R0
  383 /*Z_R1_H,Z_R1*/
  384   Z_R2_H,Z_R2,
  385   Z_R3_H,Z_R3,
  386   Z_R4_H,Z_R4,
  387 /*Z_R5_H,Z_R5,*/
  388 /*Z_R6_H,Z_R6,*/
  389   Z_R7_H,Z_R7,
  390 /*Z_R8_H,Z_R8,*/    // Z_thread
  391   Z_R9_H,Z_R9,
  392   Z_R10_H,Z_R10,
  393   Z_R11_H,Z_R11,
  394   Z_R12_H,Z_R12,
  395   Z_R13_H,Z_R13
  396 /*Z_R14_H,Z_R14*/   // return_pc
  397 /*Z_R15_H,Z_R15*/   // SP
  398 );
  399 
  400 reg_class z_no_arg_ptr_reg(
  401 /*Z_R0_H,Z_R0*/        // R0
  402 /*Z_R1_H,Z_R1*/        // scratch
  403 /*Z_R2_H,Z_R2*/
  404 /*Z_R3_H,Z_R3*/
  405 /*Z_R4_H,Z_R4*/
  406 /*Z_R5_H,Z_R5*/
  407 /*Z_R6_H,Z_R6*/
  408   Z_R7_H, Z_R7,
  409 /*Z_R8_H,Z_R8*/        // Z_thread
  410   Z_R9_H,Z_R9,
  411   Z_R10_H,Z_R10,
  412   Z_R11_H,Z_R11,
  413   Z_R12_H,Z_R12,
  414   Z_R13_H,Z_R13
  415 /*Z_R14_H,Z_R14*/      // return_pc
  416 /*Z_R15_H,Z_R15*/      // SP
  417 );
  418 
  419 // Special class for storeP instructions, which can store SP or RPC to
  420 // TLS. (Note: Do not generalize this to &quot;any_reg&quot;. If you add
  421 // another register, such as FP, to this mask, the allocator may try
  422 // to put a temp in it.)
  423 // Register class for memory access base registers,
  424 // This class is a superset of z_ptr_reg including Z_thread.
  425 reg_class z_memory_ptr_reg(
  426 /*Z_R0_H,Z_R0*/     // R0
  427 /*Z_R1_H,Z_R1*/
  428   Z_R2_H,Z_R2,
  429   Z_R3_H,Z_R3,
  430   Z_R4_H,Z_R4,
  431   Z_R5_H,Z_R5,
  432   Z_R6_H,Z_R6,
  433   Z_R7_H,Z_R7,
  434   Z_R8_H,Z_R8,      // Z_thread
  435   Z_R9_H,Z_R9,
  436   Z_R10_H,Z_R10,
  437   Z_R11_H,Z_R11,
  438   Z_R12_H,Z_R12,
  439   Z_R13_H,Z_R13
  440 /*Z_R14_H,Z_R14*/   // return_pc
  441 /*Z_R15_H,Z_R15*/   // SP
  442 );
  443 
  444 // Other special pointer regs.
  445 reg_class z_r1_regP(Z_R1_H,Z_R1);
  446 reg_class z_r9_regP(Z_R9_H,Z_R9);
  447 
  448 
  449 // Long Register Classes
  450 
  451 reg_class z_rarg1_long_reg(Z_R2_H,Z_R2);
  452 reg_class z_rarg2_long_reg(Z_R3_H,Z_R3);
  453 reg_class z_rarg3_long_reg(Z_R4_H,Z_R4);
  454 reg_class z_rarg4_long_reg(Z_R5_H,Z_R5);
  455 reg_class z_rarg5_long_reg(Z_R6_H,Z_R6);
  456 
  457 // Longs in 1 register. Aligned adjacent hi/lo pairs.
  458 reg_class z_long_reg(
  459 /*Z_R0_H,Z_R0*/     // R0
  460 /*Z_R1_H,Z_R1*/
  461   Z_R2_H,Z_R2,
  462   Z_R3_H,Z_R3,
  463   Z_R4_H,Z_R4,
  464   Z_R5_H,Z_R5,
  465   Z_R6_H,Z_R6,
  466   Z_R7_H,Z_R7,
  467 /*Z_R8_H,Z_R8,*/    // Z_thread
  468   Z_R9_H,Z_R9,
  469   Z_R10_H,Z_R10,
  470   Z_R11_H,Z_R11,
  471   Z_R12_H,Z_R12,
  472   Z_R13_H,Z_R13
  473 /*Z_R14_H,Z_R14,*/  // return_pc
  474 /*Z_R15_H,Z_R15*/   // SP
  475 );
  476 
  477 // z_long_reg without even registers
  478 reg_class z_long_odd_reg(
  479 /*Z_R0_H,Z_R0*/     // R0
  480 /*Z_R1_H,Z_R1*/
  481   Z_R3_H,Z_R3,
  482   Z_R5_H,Z_R5,
  483   Z_R7_H,Z_R7,
  484   Z_R9_H,Z_R9,
  485   Z_R11_H,Z_R11,
  486   Z_R13_H,Z_R13
  487 /*Z_R14_H,Z_R14,*/  // return_pc
  488 /*Z_R15_H,Z_R15*/   // SP
  489 );
  490 
  491 // Special Class for Condition Code Flags Register
  492 
  493 reg_class z_condition_reg(
  494   Z_CR
  495 );
  496 
  497 // Scratch register for late profiling. Callee saved.
  498 reg_class z_rscratch2_bits64_reg(Z_R2_H, Z_R2);
  499 
  500 
  501 // Float Register Classes
  502 
  503 reg_class z_flt_reg(
  504   Z_F0,
  505 /*Z_F1,*/ // scratch
  506   Z_F2,
  507   Z_F3,
  508   Z_F4,
  509   Z_F5,
  510   Z_F6,
  511   Z_F7,
  512   Z_F8,
  513   Z_F9,
  514   Z_F10,
  515   Z_F11,
  516   Z_F12,
  517   Z_F13,
  518   Z_F14,
  519   Z_F15
  520 );
  521 reg_class z_rscratch1_flt_reg(Z_F1);
  522 
  523 // Double precision float registers have virtual `high halves&#39; that
  524 // are needed by the allocator.
  525 reg_class z_dbl_reg(
  526   Z_F0,Z_F0_H,
  527 /*Z_F1,Z_F1_H,*/ // scratch
  528   Z_F2,Z_F2_H,
  529   Z_F3,Z_F3_H,
  530   Z_F4,Z_F4_H,
  531   Z_F5,Z_F5_H,
  532   Z_F6,Z_F6_H,
  533   Z_F7,Z_F7_H,
  534   Z_F8,Z_F8_H,
  535   Z_F9,Z_F9_H,
  536   Z_F10,Z_F10_H,
  537   Z_F11,Z_F11_H,
  538   Z_F12,Z_F12_H,
  539   Z_F13,Z_F13_H,
  540   Z_F14,Z_F14_H,
  541   Z_F15,Z_F15_H
  542 );
  543 reg_class z_rscratch1_dbl_reg(Z_F1,Z_F1_H);
  544 
  545 %}
  546 
  547 //----------DEFINITION BLOCK---------------------------------------------------
  548 // Define &#39;name --&gt; value&#39; mappings to inform the ADLC of an integer valued name.
  549 // Current support includes integer values in the range [0, 0x7FFFFFFF].
  550 // Format:
  551 //        int_def  &lt;name&gt;         (&lt;int_value&gt;, &lt;expression&gt;);
  552 // Generated Code in ad_&lt;arch&gt;.hpp
  553 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  554 //        // value == &lt;int_value&gt;
  555 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  556 //        assert(&lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  557 //
  558 definitions %{
  559   // The default cost (of an ALU instruction).
  560   int_def DEFAULT_COST      (   100,     100);
  561   int_def DEFAULT_COST_LOW  (    80,      80);
  562   int_def DEFAULT_COST_HIGH (   120,     120);
  563   int_def HUGE_COST         (1000000, 1000000);
  564 
  565   // Put an advantage on REG_MEM vs. MEM+REG_REG operations.
  566   int_def ALU_REG_COST      (   100, DEFAULT_COST);
  567   int_def ALU_MEMORY_COST   (   150,          150);
  568 
  569   // Memory refs are twice as expensive as run-of-the-mill.
  570   int_def MEMORY_REF_COST_HI (   220, 2 * DEFAULT_COST+20);
  571   int_def MEMORY_REF_COST    (   200, 2 * DEFAULT_COST);
  572   int_def MEMORY_REF_COST_LO (   180, 2 * DEFAULT_COST-20);
  573 
  574   // Branches are even more expensive.
  575   int_def BRANCH_COST       (   300, DEFAULT_COST * 3);
  576   int_def CALL_COST         (   300, DEFAULT_COST * 3);
  577 %}
  578 
  579 source %{
  580 
  581 #ifdef PRODUCT
  582 #define BLOCK_COMMENT(str)
  583 #define BIND(label)        __ bind(label)
  584 #else
  585 #define BLOCK_COMMENT(str) __ block_comment(str)
  586 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  587 #endif
  588 
  589 #define __ _masm.
  590 
  591 #define Z_DISP_SIZE Immediate::is_uimm12((long)opnd_array(1)-&gt;disp(ra_,this,2)) ?  4 : 6
  592 #define Z_DISP3_SIZE 6
  593 
  594 // Tertiary op of a LoadP or StoreP encoding.
  595 #define REGP_OP true
  596 
  597 // Given a register encoding, produce an Integer Register object.
  598 static Register reg_to_register_object(int register_encoding);
  599 
  600 // ****************************************************************************
  601 
  602 // REQUIRED FUNCTIONALITY
  603 
  604 // !!!!! Special hack to get all type of calls to specify the byte offset
  605 //       from the start of the call to the point where the return address
  606 //       will point.
  607 
  608 void PhaseOutput::pd_perform_mach_node_analysis() {
  609 }
  610 
  611 int MachNode::pd_alignment_required() const {
  612   return 1;
  613 }
  614 
  615 int MachNode::compute_padding(int current_offset) const {
  616   return 0;
  617 }
  618 
  619 int MachCallStaticJavaNode::ret_addr_offset() {
  620   if (_method) {
  621     return 8;
  622   } else {
  623     return MacroAssembler::call_far_patchable_ret_addr_offset();
  624   }
  625 }
  626 
  627 int MachCallDynamicJavaNode::ret_addr_offset() {
  628   // Consider size of receiver type profiling (C2 tiers).
  629   int profile_receiver_type_size = 0;
  630 
  631   int vtable_index = this-&gt;_vtable_index;
  632   if (vtable_index == -4) {
  633     return 14 + profile_receiver_type_size;
  634   } else {
  635     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  636     return 36 + profile_receiver_type_size;
  637   }
  638 }
  639 
  640 int MachCallRuntimeNode::ret_addr_offset() {
  641   return 12 + MacroAssembler::call_far_patchable_ret_addr_offset();
  642 }
  643 
  644 // Compute padding required for nodes which need alignment
  645 //
  646 // The addresses of the call instructions needs to be 4-byte aligned to
  647 // ensure that they don&#39;t span a cache line so that they are atomically patchable.
  648 // The actual calls get emitted at different offsets within the node emitters.
  649 // ins_alignment needs to be set to 2 which means that up to 1 nop may get inserted.
  650 
  651 int CallStaticJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  652   return (0 - current_offset) &amp; 2;
  653 }
  654 
  655 int CallDynamicJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  656   return (6 - current_offset) &amp; 2;
  657 }
  658 
  659 int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  660   return (12 - current_offset) &amp; 2;
  661 }
  662 
  663 int CallLeafDirectNode::compute_padding(int current_offset) const {
  664   return (12 - current_offset) &amp; 2;
  665 }
  666 
  667 int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  668   return (12 - current_offset) &amp; 2;
  669 }
  670 
  671 // Indicate if the safepoint node needs the polling page as an input.
  672 // Since z/Architecture does not have absolute addressing, it does.
  673 bool SafePointNode::needs_polling_address_input() {
  674   return true;
  675 }
  676 
  677 void emit_nop(CodeBuffer &amp;cbuf) {
  678   C2_MacroAssembler _masm(&amp;cbuf);
  679   __ z_nop();
  680 }
  681 
  682 // Emit an interrupt that is caught by the debugger (for debugging compiler).
  683 void emit_break(CodeBuffer &amp;cbuf) {
  684   C2_MacroAssembler _masm(&amp;cbuf);
  685   __ z_illtrap();
  686 }
  687 
  688 #if !defined(PRODUCT)
  689 void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
  690   os-&gt;print(&quot;TA&quot;);
  691 }
  692 #endif
  693 
  694 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  695   emit_break(cbuf);
  696 }
  697 
  698 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  699   return MachNode::size(ra_);
  700 }
  701 
  702 static inline void z_emit16(CodeBuffer &amp;cbuf, long value) {
  703   // 32bit instructions may become sign extended.
  704   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  705   assert(value &lt; (1L &lt;&lt; 16), &quot;instruction too large&quot;);
  706   *((unsigned short*)(cbuf.insts_end())) = (unsigned short)value;
  707   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned short));
  708 }
  709 
  710 static inline void z_emit32(CodeBuffer &amp;cbuf, long value) {
  711   // 32bit instructions may become sign extended.
  712   assert(value &lt; (1L &lt;&lt; 32), &quot;instruction too large&quot;);
  713   *((unsigned int*)(cbuf.insts_end())) = (unsigned int)value;
  714   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned int));
  715 }
  716 
  717 static inline void z_emit48(CodeBuffer &amp;cbuf, long value) {
  718   // 32bit instructions may become sign extended.
  719   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  720   assert(value &lt; (1L &lt;&lt; 48), &quot;instruction too large&quot;);
  721   value = value&lt;&lt;16;
  722   memcpy(cbuf.insts_end(), (unsigned char*)&amp;value, 6);
  723   cbuf.set_insts_end(cbuf.insts_end() + 6);
  724 }
  725 
  726 static inline unsigned int z_emit_inst(CodeBuffer &amp;cbuf, long value) {
  727   if (value &lt; 0) {
  728     // There obviously has been an unintended sign extension (int-&gt;long). Revert it.
  729     value = (long)((unsigned long)((unsigned int)value));
  730   }
  731 
  732   if (value &lt; (1L &lt;&lt; 16)) { // 2-byte instruction
  733     z_emit16(cbuf, value);
  734     return 2;
  735   }
  736 
  737   if (value &lt; (1L &lt;&lt; 32)) { // 4-byte instruction, might be unaligned store
  738     z_emit32(cbuf, value);
  739     return 4;
  740   }
  741 
  742   // 6-byte instruction, probably unaligned store.
  743   z_emit48(cbuf, value);
  744   return 6;
  745 }
  746 
  747 // Check effective address (at runtime) for required alignment.
  748 static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
  749   C2_MacroAssembler _masm(&amp;cbuf);
  750 
  751   __ z_lay(Z_R0, disp, index, base);
  752   __ z_nill(Z_R0, alignment-1);
  753   __ z_brc(Assembler::bcondEqual, +3);
  754   __ z_illtrap();
  755 }
  756 
  757 int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,
  758                     PhaseRegAlloc* ra_, bool is_native_call = false) {
  759   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  760   address old_mark = __ inst_mark();
  761   unsigned int start_off = __ offset();
  762 
  763   if (is_native_call) {
  764     ShouldNotReachHere();
  765   }
  766 
  767   if (rtype == relocInfo::runtime_call_w_cp_type) {
  768     assert((__ offset() &amp; 2) == 0, &quot;misaligned emit_call_reloc&quot;);
  769     address call_addr = __ call_c_opt((address)entry_point);
  770     if (call_addr == NULL) {
  771       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
  772       return -1;
  773     }
  774   } else {
  775     assert(rtype == relocInfo::none || rtype == relocInfo::opt_virtual_call_type ||
  776            rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
  777     __ relocate(rtype);
  778     // BRASL must be prepended with a nop to identify it in the instruction stream.
  779     __ z_nop();
  780     __ z_brasl(Z_R14, (address)entry_point);
  781   }
  782 
  783   unsigned int ret_off = __ offset();
  784 
  785   return (ret_off - start_off);
  786 }
  787 
  788 static int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {
  789   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  790   address old_mark = __ inst_mark();
  791   unsigned int start_off = __ offset();
  792 
  793   relocInfo::relocType rtype = rspec.type();
  794   assert(rtype == relocInfo::opt_virtual_call_type || rtype == relocInfo::static_call_type,
  795          &quot;unexpected rtype&quot;);
  796 
  797   __ relocate(rspec);
  798   __ z_nop();
  799   __ z_brasl(Z_R14, (address)entry_point);
  800 
  801   unsigned int ret_off = __ offset();
  802 
  803   return (ret_off - start_off);
  804 }
  805 
  806 //=============================================================================
  807 
  808 const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
  809 int ConstantTable::calculate_table_base_offset() const {
  810   return 0;  // absolute addressing, no offset
  811 }
  812 
  813 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  814 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  815   ShouldNotReachHere();
  816 }
  817 
  818 // Even with PC-relative TOC addressing, we still need this node.
  819 // Float loads/stores do not support PC-relative addresses.
  820 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  821   C2_MacroAssembler _masm(&amp;cbuf);
  822   Register Rtoc = as_Register(ra_-&gt;get_encode(this));
  823   __ load_toc(Rtoc);
  824 }
  825 
  826 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  827   // PCrelative TOC access.
  828   return 6;   // sizeof(LARL)
  829 }
  830 
  831 #if !defined(PRODUCT)
  832 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  833   Register r = as_Register(ra_-&gt;get_encode(this));
  834   st-&gt;print(&quot;LARL    %s,&amp;constant_pool # MachConstantBaseNode&quot;, r-&gt;name());
  835 }
  836 #endif
  837 
  838 //=============================================================================
  839 
  840 #if !defined(PRODUCT)
  841 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  842   Compile* C = ra_-&gt;C;
  843   st-&gt;print_cr(&quot;--- MachPrologNode ---&quot;);
  844   st-&gt;print(&quot;\t&quot;);
  845   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  846     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  847   }
  848 
  849   if (VerifyThread) {
  850     st-&gt;print_cr(&quot;Verify_Thread&quot;);
  851     st-&gt;print(&quot;\t&quot;);
  852   }
  853 
  854   long framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  855   int bangsize   = C-&gt;output()-&gt;bang_size_in_bytes();
  856 
  857   // Calls to C2R adapters often do not accept exceptional returns.
  858   // We require that their callers must bang for them. But be
  859   // careful, because some VM calls (such as call site linkage) can
  860   // use several kilobytes of stack. But the stack safety zone should
  861   // account for that. See bugs 4446381, 4468289, 4497237.
  862   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  863     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  864   }
  865   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  866   st-&gt;print(&quot;\t&quot;);
  867 }
  868 #endif
  869 
  870 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  871   Compile* C = ra_-&gt;C;
  872   C2_MacroAssembler _masm(&amp;cbuf);
  873 
  874   __ verify_thread();
  875 
  876   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  877   size_t bangsize  = C-&gt;output()-&gt;bang_size_in_bytes();
  878 
  879   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  880 
  881   if (C-&gt;clinit_barrier_on_entry()) {
  882     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  883 
  884     Label L_skip_barrier;
  885     Register klass = Z_R1_scratch;
  886 
  887     // Notify OOP recorder (don&#39;t need the relocation)
  888     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  889     __ load_const_optimized(klass, md.value());
  890     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);
  891 
  892     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
  893     __ z_br(klass);
  894 
  895     __ bind(L_skip_barrier);
  896   }
  897 
  898   // Calls to C2R adapters often do not accept exceptional returns.
  899   // We require that their callers must bang for them. But be
  900   // careful, because some VM calls (such as call site linkage) can
  901   // use several kilobytes of stack. But the stack safety zone should
  902   // account for that. See bugs 4446381, 4468289, 4497237.
  903   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  904     __ generate_stack_overflow_check(bangsize);
  905   }
  906 
  907   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  908   __ save_return_pc();
  909 
  910   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  911   // &#39;out_preserve_stack_slots&#39; declaration.
  912   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  913 
  914   if (C-&gt;has_mach_constant_base_node()) {
  915     // NOTE: We set the table base offset here because users might be
  916     // emitted before MachConstantBaseNode.
  917     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  918     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  919   }
  920 }
  921 
  922 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  923   // Variable size. Determine dynamically.
  924   return MachNode::size(ra_);
  925 }
  926 
  927 int MachPrologNode::reloc() const {
  928   // Return number of relocatable values contained in this instruction.
  929   return 1; // One reloc entry for load_const(toc).
  930 }
  931 
  932 //=============================================================================
  933 
  934 #if !defined(PRODUCT)
  935 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
  936   os-&gt;print_cr(&quot;epilog&quot;);
  937   os-&gt;print(&quot;\t&quot;);
  938   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  939     os-&gt;print_cr(&quot;load_from_polling_page Z_R1_scratch&quot;);
  940     os-&gt;print(&quot;\t&quot;);
  941   }
  942 }
  943 #endif
  944 
  945 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  946   C2_MacroAssembler _masm(&amp;cbuf);
  947   Compile* C = ra_-&gt;C;
  948   __ verify_thread();
  949 
  950   // If this does safepoint polling, then do it here.
  951   bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  952 
  953   // Pop frame, restore return_pc, and all stuff needed by interpreter.
  954   int frame_size_in_bytes = Assembler::align((C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);
  955   __ pop_frame_restore_retPC(frame_size_in_bytes);
  956 
  957   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  958     __ reserved_stack_check(Z_R14);
  959   }
  960 
  961   // Touch the polling page.
  962   if (need_polling) {
  963     __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));
  964     // We need to mark the code position where the load from the safepoint
  965     // polling page was emitted as relocInfo::poll_return_type here.
  966     __ relocate(relocInfo::poll_return_type);
  967     __ load_from_polling_page(Z_R1_scratch);
  968   }
  969 }
  970 
  971 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  972   // Variable size. determine dynamically.
  973   return MachNode::size(ra_);
  974 }
  975 
  976 int MachEpilogNode::reloc() const {
  977   // Return number of relocatable values contained in this instruction.
  978   return 1; // One for load_from_polling_page.
  979 }
  980 
  981 const Pipeline * MachEpilogNode::pipeline() const {
  982   return MachNode::pipeline_class();
  983 }
  984 
  985 //=============================================================================
  986 
  987 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack.
  988 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  989 
  990 static enum RC rc_class(OptoReg::Name reg) {
  991   // Return the register class for the given register. The given register
  992   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
  993   // enumeration in adGlobals_s390.hpp.
  994 
  995   if (reg == OptoReg::Bad) {
  996     return rc_bad;
  997   }
  998 
  999   // We have 32 integer register halves, starting at index 0.
 1000   if (reg &lt; 32) {
 1001     return rc_int;
 1002   }
 1003 
 1004   // We have 32 floating-point register halves, starting at index 32.
 1005   if (reg &lt; 32+32) {
 1006     return rc_float;
 1007   }
 1008 
 1009   // Between float regs &amp; stack are the flags regs.
 1010   assert(reg &gt;= OptoReg::stack0(), &quot;blow up if spilling flags&quot;);
 1011   return rc_stack;
 1012 }
 1013 
 1014 // Returns size as obtained from z_emit_instr.
 1015 static unsigned int z_ld_st_helper(CodeBuffer *cbuf, const char *op_str, unsigned long opcode,
 1016                                    int reg, int offset, bool do_print, outputStream *os) {
 1017 
 1018   if (cbuf) {
 1019     if (opcode &gt; (1L&lt;&lt;32)) {
 1020       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |
 1021                          Assembler::simm20(offset) | Assembler::reg(Z_R0, 12, 48) | Assembler::regz(Z_SP, 16, 48));
 1022     } else {
 1023       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |
 1024                          Assembler::uimm12(offset, 20, 32) | Assembler::reg(Z_R0, 12, 32) | Assembler::regz(Z_SP, 16, 32));
 1025     }
 1026   }
 1027 
 1028 #if !defined(PRODUCT)
 1029   if (do_print) {
 1030     os-&gt;print(&quot;%s    %s,#%d[,SP]\t # MachCopy spill code&quot;,op_str, Matcher::regName[reg], offset);
 1031   }
 1032 #endif
 1033   return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
 1034 }
 1035 
 1036 static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
 1037   if (cbuf) {
 1038     C2_MacroAssembler _masm(cbuf);
 1039     __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
 1040   }
 1041 
 1042 #if !defined(PRODUCT)
 1043   else if (do_print) {
 1044     os-&gt;print(&quot;MVC     %d(%d,SP),%d(SP)\t # MachCopy spill code&quot;,dst_off, len, src_off);
 1045   }
 1046 #endif
 1047 
 1048   return 6;
 1049 }
 1050 
 1051 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {
 1052   // Get registers to move.
 1053   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1054   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1055   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1056   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1057 
 1058   enum RC src_hi_rc = rc_class(src_hi);
 1059   enum RC src_lo_rc = rc_class(src_lo);
 1060   enum RC dst_hi_rc = rc_class(dst_hi);
 1061   enum RC dst_lo_rc = rc_class(dst_lo);
 1062 
 1063   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1064   bool is64 = (src_hi_rc != rc_bad);
 1065   assert(!is64 ||
 1066          ((src_lo&amp;1) == 0 &amp;&amp; src_lo+1 == src_hi &amp;&amp; (dst_lo&amp;1) == 0 &amp;&amp; dst_lo+1 == dst_hi),
 1067          &quot;expected aligned-adjacent pairs&quot;);
 1068 
 1069   // Generate spill code!
 1070 
 1071   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi) {
 1072     return 0;            // Self copy, no move.
 1073   }
 1074 
 1075   int  src_offset = ra_-&gt;reg2offset(src_lo);
 1076   int  dst_offset = ra_-&gt;reg2offset(dst_lo);
 1077   bool print = !do_size;
 1078   bool src12 = Immediate::is_uimm12(src_offset);
 1079   bool dst12 = Immediate::is_uimm12(dst_offset);
 1080 
 1081   const char   *mnemo = NULL;
 1082   unsigned long opc = 0;
 1083 
 1084   // Memory-&gt;Memory Spill. Use Z_R0 to hold the value.
 1085   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1086 
 1087     assert(!is64 || (src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack),
 1088            &quot;expected same type of move for high parts&quot;);
 1089 
 1090     if (src12 &amp;&amp; dst12) {
 1091       return z_mvc_helper(cbuf, is64 ? 8 : 4, dst_offset, src_offset, print, os);
 1092     }
 1093 
 1094     int r0 = Z_R0_num;
 1095     if (is64) {
 1096       return z_ld_st_helper(cbuf, &quot;LG  &quot;, LG_ZOPC, r0, src_offset, print, os) +
 1097              z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, r0, dst_offset, print, os);
 1098     }
 1099 
 1100     return z_ld_st_helper(cbuf, &quot;LY   &quot;, LY_ZOPC, r0, src_offset, print, os) +
 1101            z_ld_st_helper(cbuf, &quot;STY  &quot;, STY_ZOPC, r0, dst_offset, print, os);
 1102   }
 1103 
 1104   // Check for float-&gt;int copy. Requires a trip through memory.
 1105   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1106     Unimplemented();  // Unsafe, do not remove!
 1107   }
 1108 
 1109   // Check for integer reg-reg copy.
 1110   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1111     if (cbuf) {
 1112       C2_MacroAssembler _masm(cbuf);
 1113       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1114       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1115       __ z_lgr(Rdst, Rsrc);
 1116       return 4;
 1117     }
 1118 #if !defined(PRODUCT)
 1119     // else
 1120     if (print) {
 1121       os-&gt;print(&quot;LGR     %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1122     }
 1123 #endif
 1124     return 4;
 1125   }
 1126 
 1127   // Check for integer store.
 1128   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1129     assert(!is64 || (src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack),
 1130            &quot;expected same type of move for high parts&quot;);
 1131 
 1132     if (is64) {
 1133       return z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, src_lo, dst_offset, print, os);
 1134     }
 1135 
 1136     // else
 1137     mnemo = dst12 ? &quot;ST  &quot; : &quot;STY &quot;;
 1138     opc = dst12 ? ST_ZOPC : STY_ZOPC;
 1139 
 1140     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1141   }
 1142 
 1143   // Check for integer load
 1144   // Always load cOops zero-extended. That doesn&#39;t hurt int loads.
 1145   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1146 
 1147     assert(!is64 || (dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack),
 1148            &quot;expected same type of move for high parts&quot;);
 1149 
 1150     mnemo = is64 ? &quot;LG  &quot; : &quot;LLGF&quot;;
 1151     opc = is64 ? LG_ZOPC : LLGF_ZOPC;
 1152 
 1153     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1154   }
 1155 
 1156   // Check for float reg-reg copy.
 1157   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1158     if (cbuf) {
 1159       C2_MacroAssembler _masm(cbuf);
 1160       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1161       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1162       __ z_ldr(Rdst, Rsrc);
 1163       return 2;
 1164     }
 1165 #if !defined(PRODUCT)
 1166     // else
 1167     if (print) {
 1168       os-&gt;print(&quot;LDR      %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1169     }
 1170 #endif
 1171     return 2;
 1172   }
 1173 
 1174   // Check for float store.
 1175   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1176     assert(!is64 || (src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack),
 1177            &quot;expected same type of move for high parts&quot;);
 1178 
 1179     if (is64) {
 1180       mnemo = dst12 ? &quot;STD  &quot; : &quot;STDY &quot;;
 1181       opc = dst12 ? STD_ZOPC : STDY_ZOPC;
 1182       return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1183     }
 1184     // else
 1185 
 1186     mnemo = dst12 ? &quot;STE  &quot; : &quot;STEY &quot;;
 1187     opc = dst12 ? STE_ZOPC : STEY_ZOPC;
 1188     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1189   }
 1190 
 1191   // Check for float load.
 1192   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1193     assert(!is64 || (dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack),
 1194            &quot;expected same type of move for high parts&quot;);
 1195 
 1196     if (is64) {
 1197       mnemo = src12 ? &quot;LD   &quot; : &quot;LDY  &quot;;
 1198       opc = src12 ? LD_ZOPC : LDY_ZOPC;
 1199       return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1200     }
 1201     // else
 1202 
 1203     mnemo = src12 ? &quot;LE   &quot; : &quot;LEY  &quot;;
 1204     opc = src12 ? LE_ZOPC : LEY_ZOPC;
 1205     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1206   }
 1207 
 1208   // --------------------------------------------------------------------
 1209   // Check for hi bits still needing moving. Only happens for misaligned
 1210   // arguments to native calls.
 1211   if (src_hi == dst_hi) {
 1212     return 0;               // Self copy, no move.
 1213   }
 1214 
 1215   assert(is64 &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1216   Unimplemented();  // Unsafe, do not remove!
 1217 
 1218   return 0; // never reached, but make the compiler shut up!
 1219 }
 1220 
 1221 #if !defined(PRODUCT)
 1222 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1223   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1224     implementation(NULL, ra_, false, os);
 1225   } else {
 1226     if (req() == 2 &amp;&amp; in(1)) {
 1227       os-&gt;print(&quot;N%d = N%d\n&quot;, _idx, in(1)-&gt;_idx);
 1228     } else {
 1229       const char *c = &quot;(&quot;;
 1230       os-&gt;print(&quot;N%d = &quot;, _idx);
 1231       for (uint i = 1; i &lt; req(); ++i) {
 1232         os-&gt;print(&quot;%sN%d&quot;, c, in(i)-&gt;_idx);
 1233         c = &quot;, &quot;;
 1234       }
 1235       os-&gt;print(&quot;)&quot;);
 1236     }
 1237   }
 1238 }
 1239 #endif
 1240 
 1241 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1242   implementation(&amp;cbuf, ra_, false, NULL);
 1243 }
 1244 
 1245 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1246   return implementation(NULL, ra_, true, NULL);
 1247 }
 1248 
 1249 //=============================================================================
 1250 
 1251 #if !defined(PRODUCT)
 1252 void MachNopNode::format(PhaseRegAlloc *, outputStream *os) const {
 1253   os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
 1254 }
 1255 #endif
 1256 
 1257 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
 1258   C2_MacroAssembler _masm(&amp;cbuf);
 1259 
 1260   int rem_space = 0;
 1261   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {
 1262     rem_space = cbuf.insts()-&gt;remaining();
 1263     if (rem_space &lt;= _count*2 + 8) {
 1264       tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
 1265     }
 1266   }
 1267 
 1268   for (int i = 0; i &lt; _count; i++) {
 1269     __ z_nop();
 1270   }
 1271 
 1272   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {
 1273     if (rem_space &lt;= _count*2 + 8) {
 1274       int rem_space2 = cbuf.insts()-&gt;remaining();
 1275       tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
 1276     }
 1277   }
 1278 }
 1279 
 1280 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1281    return 2 * _count;
 1282 }
 1283 
 1284 #if !defined(PRODUCT)
 1285 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1286   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1287   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1288     int reg = ra_-&gt;get_reg_first(this);
 1289     os-&gt;print(&quot;ADDHI  %s, SP, %d\t//box node&quot;, Matcher::regName[reg], offset);
 1290   } else {
 1291     os-&gt;print(&quot;ADDHI  N%d = SP + %d\t// box node&quot;, _idx, offset);
 1292   }
 1293 }
 1294 #endif
 1295 
 1296 // Take care of the size function, if you make changes here!
 1297 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1298   C2_MacroAssembler _masm(&amp;cbuf);
 1299 
 1300   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1301   int reg = ra_-&gt;get_encode(this);
 1302   __ z_lay(as_Register(reg), offset, Z_SP);
 1303 }
 1304 
 1305 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1306   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1307   return 6;
 1308 }
 1309 
 1310  %} // end source section
 1311 
 1312 //----------SOURCE BLOCK-------------------------------------------------------
 1313 // This is a block of C++ code which provides values, functions, and
 1314 // definitions necessary in the rest of the architecture description
 1315 
 1316 source_hpp %{
 1317 
 1318 // Header information of the source block.
 1319 // Method declarations/definitions which are used outside
 1320 // the ad-scope can conveniently be defined here.
 1321 //
 1322 // To keep related declarations/definitions/uses close together,
 1323 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
 1324 
 1325 //--------------------------------------------------------------
 1326 // Used for optimization in Compile::Shorten_branches
 1327 //--------------------------------------------------------------
 1328 
 1329 class CallStubImpl {
 1330  public:
 1331 
 1332   // call trampolines
 1333   // Size of call trampoline stub. For add&#39;l comments, see size_java_to_interp().
 1334   static uint size_call_trampoline() {
 1335     return 0; // no call trampolines on this platform
 1336   }
 1337 
 1338   // call trampolines
 1339   // Number of relocations needed by a call trampoline stub.
 1340   static uint reloc_call_trampoline() {
 1341     return 0; // No call trampolines on this platform.
 1342   }
 1343 };
 1344 
 1345 %} // end source_hpp section
 1346 
 1347 source %{
 1348 
 1349 #if !defined(PRODUCT)
 1350 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1351   os-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 1352   os-&gt;print_cr(&quot;\tTA&quot;);
 1353   os-&gt;print_cr(&quot;\tload_const Z_R1, SharedRuntime::get_ic_miss_stub()&quot;);
 1354   os-&gt;print_cr(&quot;\tBR(Z_R1)&quot;);
 1355   os-&gt;print_cr(&quot;\tTA  # pad with illtraps&quot;);
 1356   os-&gt;print_cr(&quot;\t...&quot;);
 1357   os-&gt;print_cr(&quot;\tTA&quot;);
 1358   os-&gt;print_cr(&quot;\tLTGR    Z_R2, Z_R2&quot;);
 1359   os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
 1360 }
 1361 #endif
 1362 
 1363 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1364   C2_MacroAssembler _masm(&amp;cbuf);
 1365   const int ic_miss_offset = 2;
 1366 
 1367   // Inline_cache contains a klass.
 1368   Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
 1369   // ARG1 is the receiver oop.
 1370   Register R2_receiver = Z_ARG1;
 1371   int      klass_offset = oopDesc::klass_offset_in_bytes();
 1372   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
 1373   Register R1_ic_miss_stub_addr = Z_R1_scratch;
 1374 
 1375   // Null check of receiver.
 1376   // This is the null check of the receiver that actually should be
 1377   // done in the caller. It&#39;s here because in case of implicit null
 1378   // checks we get it for free.
 1379   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
 1380          &quot;second word in oop should not require explicit null check.&quot;);
 1381   if (!ImplicitNullChecks) {
 1382     Label valid;
 1383     if (VM_Version::has_CompareBranch()) {
 1384       __ z_cgij(R2_receiver, 0, Assembler::bcondNotEqual, valid);
 1385     } else {
 1386       __ z_ltgr(R2_receiver, R2_receiver);
 1387       __ z_bre(valid);
 1388     }
 1389     // The ic_miss_stub will handle the null pointer exception.
 1390     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1391     __ z_br(R1_ic_miss_stub_addr);
 1392     __ bind(valid);
 1393   }
 1394 
 1395   // Check whether this method is the proper implementation for the class of
 1396   // the receiver (ic miss check).
 1397   {
 1398     Label valid;
 1399     // Compare cached class against klass from receiver.
 1400     // This also does an implicit null check!
 1401     __ compare_klass_ptr(ic_klass, klass_offset, R2_receiver, false);
 1402     __ z_bre(valid);
 1403     // The inline cache points to the wrong method. Call the
 1404     // ic_miss_stub to find the proper method.
 1405     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1406     __ z_br(R1_ic_miss_stub_addr);
 1407     __ bind(valid);
 1408   }
 1409 }
 1410 
 1411 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1412   // Determine size dynamically.
 1413   return MachNode::size(ra_);
 1414 }
 1415 
 1416 //=============================================================================
 1417 
 1418 %} // interrupt source section
 1419 
 1420 source_hpp %{ // Header information of the source block.
 1421 
 1422 class HandlerImpl {
 1423  public:
 1424 
 1425   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1426   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1427 
 1428   static uint size_exception_handler() {
 1429     return NativeJump::max_instruction_size();
 1430   }
 1431 
 1432   static uint size_deopt_handler() {
 1433     return NativeCall::max_instruction_size();
 1434   }
 1435 };
 1436 
 1437 class Node::PD {
 1438 public:
 1439   enum NodeFlags {
 1440     _last_flag = Node::_last_flag
 1441   };
 1442 };
 1443 
 1444 %} // end source_hpp section
 1445 
 1446 source %{
 1447 
 1448 // This exception handler code snippet is placed after the method&#39;s
 1449 // code. It is the return point if an exception occurred. it jumps to
 1450 // the exception blob.
 1451 //
 1452 // If the method gets deoptimized, the method and this code snippet
 1453 // get patched.
 1454 //
 1455 // 1) Trampoline code gets patched into the end of this exception
 1456 //   handler. the trampoline code jumps to the deoptimization blob.
 1457 //
 1458 // 2) The return address in the method&#39;s code will get patched such
 1459 //   that it jumps to the trampoline.
 1460 //
 1461 // 3) The handler will get patched such that it does not jump to the
 1462 //   exception blob, but to an entry in the deoptimization blob being
 1463 //   aware of the exception.
 1464 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 1465   Register temp_reg = Z_R1;
 1466   C2_MacroAssembler _masm(&amp;cbuf);
 1467 
 1468   address base = __ start_a_stub(size_exception_handler());
 1469   if (base == NULL) {
 1470     return 0;          // CodeBuffer::expand failed
 1471   }
 1472 
 1473   int offset = __ offset();
 1474   // Use unconditional pc-relative jump with 32-bit range here.
 1475   __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()-&gt;content_begin());
 1476   __ z_br(temp_reg);
 1477 
 1478   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1479 
 1480   __ end_a_stub();
 1481 
 1482   return offset;
 1483 }
 1484 
 1485 // Emit deopt handler code.
 1486 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1487   C2_MacroAssembler _masm(&amp;cbuf);
 1488   address        base = __ start_a_stub(size_deopt_handler());
 1489 
 1490   if (base == NULL) {
 1491     return 0;  // CodeBuffer::expand failed
 1492   }
 1493 
 1494   int offset = __ offset();
 1495 
 1496   // Size_deopt_handler() must be exact on zarch, so for simplicity
 1497   // we do not use load_const_opt here.
 1498   __ load_const(Z_R1, SharedRuntime::deopt_blob()-&gt;unpack());
 1499   __ call(Z_R1);
 1500   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 1501 
 1502   __ end_a_stub();
 1503   return offset;
 1504 }
 1505 
 1506 //=============================================================================
 1507 
 1508 
 1509 // Given a register encoding, produce an Integer Register object.
 1510 static Register reg_to_register_object(int register_encoding) {
 1511   assert(Z_R12-&gt;encoding() == Z_R12_enc, &quot;wrong coding&quot;);
 1512   return as_Register(register_encoding);
 1513 }
 1514 
 1515 const bool Matcher::match_rule_supported(int opcode) {
 1516   if (!has_match_rule(opcode)) return false;
 1517 
 1518   switch (opcode) {
 1519     case Op_CountLeadingZerosI:
 1520     case Op_CountLeadingZerosL:
 1521     case Op_CountTrailingZerosI:
 1522     case Op_CountTrailingZerosL:
 1523       // Implementation requires FLOGR instruction, which is available since z9.
 1524       return true;
 1525 
 1526     case Op_ReverseBytesI:
 1527     case Op_ReverseBytesL:
 1528       return UseByteReverseInstruction;
 1529 
 1530     // PopCount supported by H/W from z/Architecture G5 (z196) on.
 1531     case Op_PopCountI:
 1532     case Op_PopCountL:
 1533       return UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount();
 1534 
 1535     case Op_StrComp:
 1536       return SpecialStringCompareTo;
 1537     case Op_StrEquals:
 1538       return SpecialStringEquals;
 1539     case Op_StrIndexOf:
 1540     case Op_StrIndexOfChar:
 1541       return SpecialStringIndexOf;
 1542 
 1543     case Op_GetAndAddI:
 1544     case Op_GetAndAddL:
 1545       return true;
 1546       // return VM_Version::has_AtomicMemWithImmALUOps();
 1547     case Op_GetAndSetI:
 1548     case Op_GetAndSetL:
 1549     case Op_GetAndSetP:
 1550     case Op_GetAndSetN:
 1551       return true;  // General CAS implementation, always available.
 1552 
 1553     default:
 1554       return true;  // Per default match rules are supported.
 1555                     // BUT: make sure match rule is not disabled by a false predicate!
 1556   }
 1557 
 1558   return true;  // Per default match rules are supported.
 1559                 // BUT: make sure match rule is not disabled by a false predicate!
 1560 }
 1561 
 1562 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 1563   // TODO
 1564   // Identify extra cases that we might want to provide match rules for
 1565   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen.
 1566   bool ret_value = match_rule_supported(opcode);
 1567   // Add rules here.
 1568 
 1569   return ret_value;  // Per default match rules are supported.
 1570 }
 1571 
 1572 int Matcher::regnum_to_fpu_offset(int regnum) {
 1573   ShouldNotReachHere();
 1574   return regnum - 32; // The FP registers are in the second chunk.
 1575 }
 1576 
 1577 const bool Matcher::has_predicated_vectors(void) {
 1578   return false;
 1579 }
 1580 
 1581 const int Matcher::float_pressure(int default_pressure_threshold) {
 1582   return default_pressure_threshold;
 1583 }
 1584 
 1585 const bool Matcher::convL2FSupported(void) {
 1586   return true; // False means that conversion is done by runtime call.
 1587 }
 1588 
 1589 //----------SUPERWORD HELPERS----------------------------------------
 1590 
 1591 // Vector width in bytes.
 1592 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1593   assert(MaxVectorSize == 8, &quot;&quot;);
 1594   return 8;
 1595 }
 1596 
 1597 // Vector ideal reg.
 1598 const uint Matcher::vector_ideal_reg(int size) {
 1599   assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 1600   return Op_RegL;
 1601 }
 1602 
 1603 // Limits on vector size (number of elements) loaded into vector.
 1604 const int Matcher::max_vector_size(const BasicType bt) {
 1605   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1606   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1607 }
 1608 
 1609 const int Matcher::min_vector_size(const BasicType bt) {
 1610   return max_vector_size(bt); // Same as max.
 1611 }
 1612 
 1613 // z/Architecture does support misaligned store/load at minimal extra cost.
 1614 const bool Matcher::misaligned_vectors_ok() {
 1615   return true;
 1616 }
 1617 
 1618 // Not yet ported to z/Architecture.
 1619 const bool Matcher::pass_original_key_for_aes() {
 1620   return false;
 1621 }
 1622 
 1623 // RETURNS: whether this branch offset is short enough that a short
 1624 // branch can be used.
 1625 //
 1626 // If the platform does not provide any short branch variants, then
 1627 // this method should return `false&#39; for offset 0.
 1628 //
 1629 // `Compile::Fill_buffer&#39; will decide on basis of this information
 1630 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 1631 //
 1632 // And `Compile::Shorten_branches&#39; will decide on basis of this
 1633 // information whether to replace particular branch sites by short
 1634 // ones.
 1635 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1636   // On zarch short branches use a 16 bit signed immediate that
 1637   // is the pc-relative offset in halfword (= 2 bytes) units.
 1638   return Assembler::is_within_range_of_RelAddr16((address)((long)offset), (address)0);
 1639 }
 1640 
 1641 const bool Matcher::isSimpleConstant64(jlong value) {
 1642   // Probably always true, even if a temp register is required.
 1643   return true;
 1644 }
 1645 
 1646 // Should correspond to setting above
 1647 const bool Matcher::init_array_count_is_in_bytes = false;
 1648 
 1649 // Suppress CMOVL. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1650 const int Matcher::long_cmove_cost() { return ConditionalMoveLimit; }
 1651 
 1652 // Suppress CMOVF. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1653 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1654 
 1655 // Does the CPU require postalloc expand (see block.cpp for description of postalloc expand)?
 1656 const bool Matcher::require_postalloc_expand = false;
 1657 
 1658 // Do we need to mask the count passed to shift instructions or does
 1659 // the cpu only look at the lower 5/6 bits anyway?
 1660 // 32bit shifts mask in emitter, 64bit shifts need no mask.
 1661 // Constant shift counts are handled in Ideal phase.
 1662 const bool Matcher::need_masked_shift_count = false;
 1663 
 1664 // No support for generic vector operands.
 1665 const bool Matcher::supports_generic_vector_operands  = false;
 1666 
 1667 MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1668   ShouldNotReachHere(); // generic vector operands not supported
 1669   return NULL;
 1670 }
 1671 
 1672 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1673   ShouldNotReachHere();  // generic vector operands not supported
 1674   return false;
 1675 }
 1676 
 1677 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1678   ShouldNotReachHere();  // generic vector operands not supported
 1679   return false;
 1680 }
 1681 
 1682 // Set this as clone_shift_expressions.
 1683 bool Matcher::narrow_oop_use_complex_address() {
 1684   if (CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0) return true;
 1685   return false;
 1686 }
 1687 
 1688 bool Matcher::narrow_klass_use_complex_address() {
 1689   NOT_LP64(ShouldNotCallThis());
 1690   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1691   // TODO HS25: z port if (MatchDecodeNodes) return true;
 1692   return false;
 1693 }
 1694 
 1695 bool Matcher::const_oop_prefer_decode() {
 1696   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 1697   return CompressedOops::base() == NULL;
 1698 }
 1699 
 1700 bool Matcher::const_klass_prefer_decode() {
 1701   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1702   return CompressedKlassPointers::base() == NULL;
 1703 }
 1704 
 1705 // Is it better to copy float constants, or load them directly from memory?
 1706 // Most RISCs will have to materialize an address into a
 1707 // register first, so they would do better to copy the constant from stack.
 1708 const bool Matcher::rematerialize_float_constants = false;
 1709 
 1710 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1711 // needed. Else we split the double into 2 integer pieces and move it
 1712 // piece-by-piece. Only happens when passing doubles into C code as the
 1713 // Java calling convention forces doubles to be aligned.
 1714 const bool Matcher::misaligned_doubles_ok = true;
 1715 
 1716 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1717 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1718 
 1719 // Do floats take an entire double register or just half?
 1720 //
 1721 // A float in resides in a zarch double register. When storing it by
 1722 // z_std, it cannot be restored in C-code by reloading it as a double
 1723 // and casting it into a float afterwards.
 1724 bool Matcher::float_in_double() { return false; }
 1725 
 1726 // Do ints take an entire long register or just half?
 1727 // The relevant question is how the int is callee-saved:
 1728 // the whole long is written but de-opt&#39;ing will have to extract
 1729 // the relevant 32 bits.
 1730 const bool Matcher::int_in_long = true;
 1731 
 1732 // Constants for c2c and c calling conventions.
 1733 
 1734 const MachRegisterNumbers z_iarg_reg[5] = {
 1735   Z_R2_num, Z_R3_num, Z_R4_num, Z_R5_num, Z_R6_num
 1736 };
 1737 
 1738 const MachRegisterNumbers z_farg_reg[4] = {
 1739   Z_F0_num, Z_F2_num, Z_F4_num, Z_F6_num
 1740 };
 1741 
 1742 const int z_num_iarg_registers = sizeof(z_iarg_reg) / sizeof(z_iarg_reg[0]);
 1743 
 1744 const int z_num_farg_registers = sizeof(z_farg_reg) / sizeof(z_farg_reg[0]);
 1745 
 1746 // Return whether or not this register is ever used as an argument. This
 1747 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1748 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1749 // arguments in those registers not be available to the callee.
 1750 bool Matcher::can_be_java_arg(int reg) {
 1751   // We return true for all registers contained in z_iarg_reg[] and
 1752   // z_farg_reg[] and their virtual halves.
 1753   // We must include the virtual halves in order to get STDs and LDs
 1754   // instead of STWs and LWs in the trampoline stubs.
 1755 
 1756   if (reg == Z_R2_num || reg == Z_R2_H_num ||
 1757       reg == Z_R3_num || reg == Z_R3_H_num ||
 1758       reg == Z_R4_num || reg == Z_R4_H_num ||
 1759       reg == Z_R5_num || reg == Z_R5_H_num ||
 1760       reg == Z_R6_num || reg == Z_R6_H_num) {
 1761     return true;
 1762   }
 1763 
 1764   if (reg == Z_F0_num || reg == Z_F0_H_num ||
 1765       reg == Z_F2_num || reg == Z_F2_H_num ||
 1766       reg == Z_F4_num || reg == Z_F4_H_num ||
 1767       reg == Z_F6_num || reg == Z_F6_H_num) {
 1768     return true;
 1769   }
 1770 
 1771   return false;
 1772 }
 1773 
 1774 bool Matcher::is_spillable_arg(int reg) {
 1775   return can_be_java_arg(reg);
 1776 }
 1777 
 1778 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 1779   return false;
 1780 }
 1781 
 1782 // Register for DIVI projection of divmodI
 1783 RegMask Matcher::divI_proj_mask() {
 1784   return _Z_RARG4_INT_REG_mask;
 1785 }
 1786 
 1787 // Register for MODI projection of divmodI
 1788 RegMask Matcher::modI_proj_mask() {
 1789   return _Z_RARG3_INT_REG_mask;
 1790 }
 1791 
 1792 // Register for DIVL projection of divmodL
 1793 RegMask Matcher::divL_proj_mask() {
 1794   return _Z_RARG4_LONG_REG_mask;
 1795 }
 1796 
 1797 // Register for MODL projection of divmodL
 1798 RegMask Matcher::modL_proj_mask() {
 1799   return _Z_RARG3_LONG_REG_mask;
 1800 }
 1801 
 1802 // Copied from sparc.
 1803 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1804   return RegMask();
 1805 }
 1806 
 1807 const bool Matcher::convi2l_type_required = true;
 1808 
 1809 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?
 1810 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {
 1811   return false;
 1812 }
 1813 
 1814 // Should the Matcher clone shifts on addressing modes, expecting them
 1815 // to be subsumed into complex addressing expressions or compute them
 1816 // into registers?
 1817 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 1818   return clone_base_plus_offset_address(m, mstack, address_visited);
 1819 }
 1820 
 1821 void Compile::reshape_address(AddPNode* addp) {
 1822 }
 1823 
 1824 %} // source
 1825 
 1826 //----------ENCODING BLOCK-----------------------------------------------------
 1827 // This block specifies the encoding classes used by the compiler to output
 1828 // byte streams. Encoding classes are parameterized macros used by
 1829 // Machine Instruction Nodes in order to generate the bit encoding of the
 1830 // instruction. Operands specify their base encoding interface with the
 1831 // interface keyword. There are currently supported four interfaces,
 1832 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 1833 // operand to generate a function which returns its register number when
 1834 // queried. CONST_INTER causes an operand to generate a function which
 1835 // returns the value of the constant when queried. MEMORY_INTER causes an
 1836 // operand to generate four functions which return the Base Register, the
 1837 // Index Register, the Scale Value, and the Offset Value of the operand when
 1838 // queried. COND_INTER causes an operand to generate six functions which
 1839 // return the encoding code (ie - encoding bits for the instruction)
 1840 // associated with each basic boolean condition for a conditional instruction.
 1841 //
 1842 // Instructions specify two basic values for encoding. Again, a function
 1843 // is available to check if the constant displacement is an oop. They use the
 1844 // ins_encode keyword to specify their encoding classes (which must be
 1845 // a sequence of enc_class names, and their parameters, specified in
 1846 // the encoding block), and they use the
 1847 // opcode keyword to specify, in order, their primary, secondary, and
 1848 // tertiary opcode. Only the opcode sections which a particular instruction
 1849 // needs for encoding need to be specified.
 1850 encode %{
 1851   enc_class enc_unimplemented %{
 1852     C2_MacroAssembler _masm(&amp;cbuf);
 1853     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 1854   %}
 1855 
 1856   enc_class enc_untested %{
 1857 #ifdef ASSERT
 1858     C2_MacroAssembler _masm(&amp;cbuf);
 1859     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 1860 #endif
 1861   %}
 1862 
 1863   enc_class z_rrform(iRegI dst, iRegI src) %{
 1864     assert((($primary &gt;&gt; 14) &amp; 0x03) == 0, &quot;Instruction format error&quot;);
 1865     assert( ($primary &gt;&gt; 16)         == 0, &quot;Instruction format error&quot;);
 1866     z_emit16(cbuf, $primary |
 1867              Assembler::reg($dst$$reg,8,16) |
 1868              Assembler::reg($src$$reg,12,16));
 1869   %}
 1870 
 1871   enc_class z_rreform(iRegI dst1, iRegI src2) %{
 1872     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1873     z_emit32(cbuf, $primary |
 1874              Assembler::reg($dst1$$reg,24,32) |
 1875              Assembler::reg($src2$$reg,28,32));
 1876   %}
 1877 
 1878   enc_class z_rrfform(iRegI dst1, iRegI src2, iRegI src3) %{
 1879     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1880     z_emit32(cbuf, $primary |
 1881              Assembler::reg($dst1$$reg,24,32) |
 1882              Assembler::reg($src2$$reg,28,32) |
 1883              Assembler::reg($src3$$reg,16,32));
 1884   %}
 1885 
 1886   enc_class z_riform_signed(iRegI dst, immI16 src) %{
 1887     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1888     z_emit32(cbuf, $primary |
 1889              Assembler::reg($dst$$reg,8,32) |
 1890              Assembler::simm16($src$$constant,16,32));
 1891   %}
 1892 
 1893   enc_class z_riform_unsigned(iRegI dst, uimmI16 src) %{
 1894     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1895     z_emit32(cbuf, $primary |
 1896              Assembler::reg($dst$$reg,8,32) |
 1897              Assembler::uimm16($src$$constant,16,32));
 1898   %}
 1899 
 1900   enc_class z_rieform_d(iRegI dst1, iRegI src3, immI src2) %{
 1901     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1902     z_emit48(cbuf, $primary |
 1903              Assembler::reg($dst1$$reg,8,48) |
 1904              Assembler::reg($src3$$reg,12,48) |
 1905              Assembler::simm16($src2$$constant,16,48));
 1906   %}
 1907 
 1908   enc_class z_rilform_signed(iRegI dst, immL32 src) %{
 1909     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1910     z_emit48(cbuf, $primary |
 1911              Assembler::reg($dst$$reg,8,48) |
 1912              Assembler::simm32($src$$constant,16,48));
 1913   %}
 1914 
 1915   enc_class z_rilform_unsigned(iRegI dst, uimmL32 src) %{
 1916     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1917     z_emit48(cbuf, $primary |
 1918              Assembler::reg($dst$$reg,8,48) |
 1919              Assembler::uimm32($src$$constant,16,48));
 1920   %}
 1921 
 1922   enc_class z_rsyform_const(iRegI dst, iRegI src1, immI src2) %{
 1923     z_emit48(cbuf, $primary |
 1924              Assembler::reg($dst$$reg,8,48) |
 1925              Assembler::reg($src1$$reg,12,48) |
 1926              Assembler::simm20($src2$$constant));
 1927   %}
 1928 
 1929   enc_class z_rsyform_reg_reg(iRegI dst, iRegI src, iRegI shft) %{
 1930     z_emit48(cbuf, $primary |
 1931              Assembler::reg($dst$$reg,8,48) |
 1932              Assembler::reg($src$$reg,12,48) |
 1933              Assembler::reg($shft$$reg,16,48) |
 1934              Assembler::simm20(0));
 1935   %}
 1936 
 1937   enc_class z_rxform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1938     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1939     z_emit32(cbuf, $primary |
 1940              Assembler::reg($dst$$reg,8,32) |
 1941              Assembler::reg($src1$$reg,12,32) |
 1942              Assembler::reg($src2$$reg,16,32) |
 1943              Assembler::uimm12($con$$constant,20,32));
 1944   %}
 1945 
 1946   enc_class z_rxform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1947     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1948     z_emit32(cbuf, $primary |
 1949              Assembler::reg($dst$$reg,8,32) |
 1950              Assembler::reg($src$$reg,16,32) |
 1951              Assembler::uimm12($con$$constant,20,32));
 1952   %}
 1953 
 1954   enc_class z_rxyform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1955     z_emit48(cbuf, $primary |
 1956              Assembler::reg($dst$$reg,8,48) |
 1957              Assembler::reg($src1$$reg,12,48) |
 1958              Assembler::reg($src2$$reg,16,48) |
 1959              Assembler::simm20($con$$constant));
 1960   %}
 1961 
 1962   enc_class z_rxyform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1963     z_emit48(cbuf, $primary |
 1964              Assembler::reg($dst$$reg,8,48) |
 1965              Assembler::reg($src$$reg,16,48) |
 1966              Assembler::simm20($con$$constant));
 1967   %}
 1968 
 1969   // Direct memory arithmetic.
 1970   enc_class z_siyform(memoryRSY mem, immI8 src) %{
 1971     int      disp = $mem$$disp;
 1972     Register base = reg_to_register_object($mem$$base);
 1973     int      con  = $src$$constant;
 1974 
 1975     assert(VM_Version::has_MemWithImmALUOps(), &quot;unsupported CPU&quot;);
 1976     z_emit_inst(cbuf, $primary |
 1977                 Assembler::regz(base,16,48) |
 1978                 Assembler::simm20(disp) |
 1979                 Assembler::simm8(con,8,48));
 1980   %}
 1981 
 1982   enc_class z_silform(memoryRS mem, immI16 src) %{
 1983     z_emit_inst(cbuf, $primary |
 1984                 Assembler::regz(reg_to_register_object($mem$$base),16,48) |
 1985                 Assembler::uimm12($mem$$disp,20,48) |
 1986                 Assembler::simm16($src$$constant,32,48));
 1987   %}
 1988 
 1989   // Encoder for FP ALU reg/mem instructions (support only short displacements).
 1990   enc_class z_form_rt_memFP(RegF dst, memoryRX mem) %{
 1991     Register Ridx = $mem$$index$$Register;
 1992     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 1993     if ($primary &gt; (1L &lt;&lt; 32)) {
 1994       z_emit_inst(cbuf, $primary |
 1995                   Assembler::reg($dst$$reg, 8, 48) |
 1996                   Assembler::uimm12($mem$$disp, 20, 48) |
 1997                   Assembler::reg(Ridx, 12, 48) |
 1998                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 1999     } else {
 2000       z_emit_inst(cbuf, $primary |
 2001                   Assembler::reg($dst$$reg, 8, 32) |
 2002                   Assembler::uimm12($mem$$disp, 20, 32) |
 2003                   Assembler::reg(Ridx, 12, 32) |
 2004                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 2005     }
 2006   %}
 2007 
 2008   enc_class z_form_rt_mem(iRegI dst, memory mem) %{
 2009     Register Ridx = $mem$$index$$Register;
 2010     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2011     if ($primary &gt; (1L&lt;&lt;32)) {
 2012       z_emit_inst(cbuf, $primary |
 2013                   Assembler::reg($dst$$reg, 8, 48) |
 2014                   Assembler::simm20($mem$$disp) |
 2015                   Assembler::reg(Ridx, 12, 48) |
 2016                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2017     } else {
 2018       z_emit_inst(cbuf, $primary |
 2019                   Assembler::reg($dst$$reg, 8, 32) |
 2020                   Assembler::uimm12($mem$$disp, 20, 32) |
 2021                   Assembler::reg(Ridx, 12, 32) |
 2022                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 2023     }
 2024   %}
 2025 
 2026   enc_class z_form_rt_mem_opt(iRegI dst, memory mem) %{
 2027     int isize = $secondary &gt; 1L &lt;&lt; 32 ? 48 : 32;
 2028     Register Ridx = $mem$$index$$Register;
 2029     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2030 
 2031     if (Displacement::is_shortDisp((long)$mem$$disp)) {
 2032       z_emit_inst(cbuf, $secondary |
 2033                   Assembler::reg($dst$$reg, 8, isize) |
 2034                   Assembler::uimm12($mem$$disp, 20, isize) |
 2035                   Assembler::reg(Ridx, 12, isize) |
 2036                   Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2037     } else if (Displacement::is_validDisp((long)$mem$$disp)) {
 2038       z_emit_inst(cbuf, $primary |
 2039                   Assembler::reg($dst$$reg, 8, 48) |
 2040                   Assembler::simm20($mem$$disp) |
 2041                   Assembler::reg(Ridx, 12, 48) |
 2042                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2043     } else {
 2044         C2_MacroAssembler _masm(&amp;cbuf);
 2045         __ load_const_optimized(Z_R1_scratch, $mem$$disp);
 2046         if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
 2047         z_emit_inst(cbuf, $secondary |
 2048                     Assembler::reg($dst$$reg, 8, isize) |
 2049                     Assembler::uimm12(0, 20, isize) |
 2050                     Assembler::reg(Z_R1_scratch, 12, isize) |
 2051                     Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2052     }
 2053   %}
 2054 
 2055   enc_class z_enc_brul(Label lbl) %{
 2056     C2_MacroAssembler _masm(&amp;cbuf);
 2057     Label* p = $lbl$$label;
 2058 
 2059     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2060     // determine the size of the encoded instruction.
 2061     // Use a bound dummy label in that case.
 2062     Label d;
 2063     __ bind(d);
 2064     Label&amp; l = (NULL == p) ? d : *(p);
 2065     __ z_brul(l);
 2066   %}
 2067 
 2068   enc_class z_enc_bru(Label lbl) %{
 2069     C2_MacroAssembler _masm(&amp;cbuf);
 2070     Label* p = $lbl$$label;
 2071 
 2072     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2073     // determine the size of the encoded instruction.
 2074     // Use a bound dummy label in that case.
 2075     Label d;
 2076     __ bind(d);
 2077     Label&amp; l = (NULL == p) ? d : *(p);
 2078     __ z_bru(l);
 2079   %}
 2080 
 2081   enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
 2082     C2_MacroAssembler _masm(&amp;cbuf);
 2083     Label* p = $lbl$$label;
 2084 
 2085     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2086     // determine the size of the encoded instruction.
 2087     // Use a bound dummy label in that case.
 2088     Label d;
 2089     __ bind(d);
 2090     Label&amp; l = (NULL == p) ? d : *(p);
 2091     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2092   %}
 2093 
 2094   enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
 2095     C2_MacroAssembler _masm(&amp;cbuf);
 2096     Label* p = $lbl$$label;
 2097 
 2098     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2099     // determine the size of the encoded instruction.
 2100     // Use a bound dummy label in that case.
 2101     Label d;
 2102     __ bind(d);
 2103     Label&amp; l = (NULL == p) ? d : *(p);
 2104     __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
 2105   %}
 2106 
 2107   enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2108     C2_MacroAssembler _masm(&amp;cbuf);
 2109     Label* p = $lbl$$label;
 2110 
 2111     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2112     // determine the size of the encoded instruction.
 2113     // Use a bound dummy label in that case.
 2114     Label d;
 2115     __ bind(d);
 2116     Label&amp; l = (NULL == p) ? d : *(p);
 2117     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2118     unsigned long instr = $primary;
 2119     if (instr == CRJ_ZOPC) {
 2120       __ z_crj($src1$$Register, $src2$$Register, cc, l);
 2121     } else if (instr == CLRJ_ZOPC) {
 2122       __ z_clrj($src1$$Register, $src2$$Register, cc, l);
 2123     } else if (instr == CGRJ_ZOPC) {
 2124       __ z_cgrj($src1$$Register, $src2$$Register, cc, l);
 2125     } else {
 2126       guarantee(instr == CLGRJ_ZOPC, &quot;opcode not implemented&quot;);
 2127       __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
 2128     }
 2129   %}
 2130 
 2131   enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2132     C2_MacroAssembler _masm(&amp;cbuf);
 2133     Label* p = $lbl$$label;
 2134 
 2135     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2136     // determine the size of the encoded instruction.
 2137     // Use a bound dummy label in that case.
 2138     Label d;
 2139     __ bind(d);
 2140     Label&amp; l = (NULL == p) ? d : *(p);
 2141 
 2142     unsigned long instr = $primary;
 2143     if (instr == CR_ZOPC) {
 2144       __ z_cr($src1$$Register, $src2$$Register);
 2145     } else if (instr == CLR_ZOPC) {
 2146       __ z_clr($src1$$Register, $src2$$Register);
 2147     } else if (instr == CGR_ZOPC) {
 2148       __ z_cgr($src1$$Register, $src2$$Register);
 2149     } else {
 2150       guarantee(instr == CLGR_ZOPC, &quot;opcode not implemented&quot;);
 2151       __ z_clgr($src1$$Register, $src2$$Register);
 2152     }
 2153 
 2154     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2155   %}
 2156 
 2157   enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2158     C2_MacroAssembler _masm(&amp;cbuf);
 2159     Label* p = $lbl$$label;
 2160 
 2161     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2162     // determine the size of the encoded instruction.
 2163     // Use a bound dummy label in that case.
 2164     Label d;
 2165     __ bind(d);
 2166     Label&amp; l = (NULL == p) ? d : *(p);
 2167 
 2168     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2169     unsigned long instr = $primary;
 2170     if (instr == CIJ_ZOPC) {
 2171       __ z_cij($src1$$Register, $src2$$constant, cc, l);
 2172     } else if (instr == CLIJ_ZOPC) {
 2173       __ z_clij($src1$$Register, $src2$$constant, cc, l);
 2174     } else if (instr == CGIJ_ZOPC) {
 2175       __ z_cgij($src1$$Register, $src2$$constant, cc, l);
 2176     } else {
 2177       guarantee(instr == CLGIJ_ZOPC, &quot;opcode not implemented&quot;);
 2178       __ z_clgij($src1$$Register, $src2$$constant, cc, l);
 2179     }
 2180   %}
 2181 
 2182   enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2183     C2_MacroAssembler _masm(&amp;cbuf);
 2184     Label* p = $lbl$$label;
 2185 
 2186     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2187     // determine the size of the encoded instruction.
 2188     // Use a bound dummy label in that case.
 2189     Label d;
 2190     __ bind(d);
 2191     Label&amp; l = (NULL == p) ? d : *(p);
 2192 
 2193     unsigned long instr = $primary;
 2194     if (instr == CHI_ZOPC) {
 2195       __ z_chi($src1$$Register, $src2$$constant);
 2196     } else if (instr == CLFI_ZOPC) {
 2197       __ z_clfi($src1$$Register, $src2$$constant);
 2198     } else if (instr == CGHI_ZOPC) {
 2199       __ z_cghi($src1$$Register, $src2$$constant);
 2200     } else {
 2201       guarantee(instr == CLGFI_ZOPC, &quot;opcode not implemented&quot;);
 2202       __ z_clgfi($src1$$Register, $src2$$constant);
 2203     }
 2204 
 2205     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2206   %}
 2207 
 2208   // Call from Java to runtime.
 2209   enc_class z_enc_java_to_runtime_call(method meth) %{
 2210     C2_MacroAssembler _masm(&amp;cbuf);
 2211 
 2212     // Save return pc before call to the place where we need it, since
 2213     // callee doesn&#39;t.
 2214     unsigned int start_off = __ offset();
 2215     // Compute size of &quot;larl + stg + call_c_opt&quot;.
 2216     const int size_of_code = 6 + 6 + MacroAssembler::call_far_patchable_size();
 2217     __ get_PC(Z_R14, size_of_code);
 2218     __ save_return_pc();
 2219     assert(__ offset() - start_off == 12, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2220 
 2221     assert((__ offset() &amp; 2) == 0, &quot;misaligned z_enc_java_to_runtime_call&quot;);
 2222     address call_addr = __ call_c_opt((address)$meth$$method);
 2223     if (call_addr == NULL) {
 2224       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2225       return;
 2226     }
 2227 
 2228 #ifdef ASSERT
 2229     // Plausibility check for size_of_code assumptions.
 2230     unsigned int actual_ret_off = __ offset();
 2231     assert(start_off + size_of_code == actual_ret_off, &quot;wrong return_pc&quot;);
 2232 #endif
 2233   %}
 2234 
 2235   enc_class z_enc_java_static_call(method meth) %{
 2236     // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
 2237     // whom we intended to call.
 2238     C2_MacroAssembler _masm(&amp;cbuf);
 2239     int ret_offset = 0;
 2240 
 2241     if (!_method) {
 2242       ret_offset = emit_call_reloc(_masm, $meth$$method,
 2243                                    relocInfo::runtime_call_w_cp_type, ra_);
 2244     } else {
 2245       int method_index = resolved_method_index(cbuf);
 2246       if (_optimized_virtual) {
 2247         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2248                                      opt_virtual_call_Relocation::spec(method_index));
 2249       } else {
 2250         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2251                                      static_call_Relocation::spec(method_index));
 2252       }
 2253     }
 2254     assert(__ inst_mark() != NULL, &quot;emit_call_reloc must set_inst_mark()&quot;);
 2255 
 2256     if (_method) { // Emit stub for static call.
 2257       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2258       if (stub == NULL) {
 2259         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2260         return;
 2261       }
 2262     }
 2263   %}
 2264 
 2265   // Java dynamic call
 2266   enc_class z_enc_java_dynamic_call(method meth) %{
 2267     C2_MacroAssembler _masm(&amp;cbuf);
 2268     unsigned int start_off = __ offset();
 2269 
 2270     int vtable_index = this-&gt;_vtable_index;
 2271     if (vtable_index == -4) {
 2272       Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2273       address virtual_call_oop_addr = NULL;
 2274 
 2275       AddressLiteral empty_ic((address) Universe::non_oop_word());
 2276       virtual_call_oop_addr = __ pc();
 2277       bool success = __ load_const_from_toc(ic_reg, empty_ic);
 2278       if (!success) {
 2279         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2280         return;
 2281       }
 2282 
 2283       // Call to fixup routine. Fixup routine uses ScopeDesc info
 2284       // to determine who we intended to call.
 2285       int method_index = resolved_method_index(cbuf);
 2286       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 2287       unsigned int ret_off = __ offset();
 2288       assert(__ offset() - start_off == 6, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2289       ret_off += emit_call_reloc(_masm, $meth$$method, relocInfo::none, ra_);
 2290       assert(_method, &quot;lazy_constant may be wrong when _method==null&quot;);
 2291     } else {
 2292       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2293       // Go through the vtable. Get receiver klass. Receiver already
 2294       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 2295       // interpreter expects method in Z_method.
 2296       // Use Z_method to temporarily hold the klass oop.
 2297       // Z_R1_scratch is destroyed.
 2298       __ load_klass(Z_method, Z_R2);
 2299 
 2300       int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index * vtableEntry::size_in_bytes();
 2301       int v_off        = entry_offset + vtableEntry::method_offset_in_bytes();
 2302 
 2303       if (Displacement::is_validDisp(v_off) ) {
 2304         // Can use load instruction with large offset.
 2305         __ z_lg(Z_method, Address(Z_method /*class oop*/, v_off /*method offset*/));
 2306       } else {
 2307         // Worse case, must load offset into register.
 2308         __ load_const(Z_R1_scratch, v_off);
 2309         __ z_lg(Z_method, Address(Z_method /*class oop*/, Z_R1_scratch /*method offset*/));
 2310       }
 2311       // NOTE: for vtable dispatches, the vtable entry will never be
 2312       // null. However it may very well end up in handle_wrong_method
 2313       // if the method is abstract for the particular class.
 2314       __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 2315       // Call target. Either compiled code or C2I adapter.
 2316       __ z_basr(Z_R14, Z_R1_scratch);
 2317       unsigned int ret_off = __ offset();
 2318     }
 2319   %}
 2320 
 2321   enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
 2322     C2_MacroAssembler _masm(&amp;cbuf);
 2323     Register Rdst = reg_to_register_object($dst$$reg);
 2324     Register Rsrc = reg_to_register_object($src$$reg);
 2325 
 2326     // Don&#39;t emit code if operands are identical (same register).
 2327     if (Rsrc != Rdst) {
 2328       Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2329 
 2330       if (VM_Version::has_LoadStoreConditional()) {
 2331         __ z_locgr(Rdst, Rsrc, cc);
 2332       } else {
 2333         // Branch if not (cmp cr).
 2334         Label done;
 2335         __ z_brc(Assembler::inverse_condition(cc), done);
 2336         __ z_lgr(Rdst, Rsrc); // Used for int and long+ptr.
 2337         __ bind(done);
 2338       }
 2339     }
 2340   %}
 2341 
 2342   enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
 2343     C2_MacroAssembler _masm(&amp;cbuf);
 2344     Register Rdst = reg_to_register_object($dst$$reg);
 2345     int      Csrc = $src$$constant;
 2346     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2347     Label done;
 2348     // Branch if not (cmp cr).
 2349     __ z_brc(Assembler::inverse_condition(cc), done);
 2350     if (Csrc == 0) {
 2351       // Don&#39;t set CC.
 2352       __ clear_reg(Rdst, true, false);  // Use for int, long &amp; ptr.
 2353     } else {
 2354       __ z_lghi(Rdst, Csrc); // Use for int, long &amp; ptr.
 2355     }
 2356     __ bind(done);
 2357   %}
 2358 
 2359   enc_class z_enc_cctobool(iRegI res) %{
 2360     C2_MacroAssembler _masm(&amp;cbuf);
 2361     Register Rres = reg_to_register_object($res$$reg);
 2362 
 2363     if (VM_Version::has_LoadStoreConditional()) {
 2364       __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
 2365       __ load_const_optimized(Rres, 1L);         // true  (succeed)
 2366       __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);
 2367     } else {
 2368       Label done;
 2369       __ load_const_optimized(Rres, 0L); // false (failed)
 2370       __ z_brne(done);                   // Assume true to be the common case.
 2371       __ load_const_optimized(Rres, 1L); // true  (succeed)
 2372       __ bind(done);
 2373     }
 2374   %}
 2375 
 2376   enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
 2377     C2_MacroAssembler _masm(&amp;cbuf);
 2378     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2379     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2380     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2381 
 2382     __ z_cs(Rcomp, Rnew, 0, Raddr);
 2383   %}
 2384 
 2385   enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
 2386     C2_MacroAssembler _masm(&amp;cbuf);
 2387     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2388     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2389     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2390 
 2391     __ z_csg(Rcomp, Rnew, 0, Raddr);
 2392   %}
 2393 
 2394   enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
 2395     C2_MacroAssembler _masm(&amp;cbuf);
 2396     Register Rdst = reg_to_register_object($dst$$reg);
 2397     Register Rtmp = reg_to_register_object($tmp$$reg);
 2398     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2399     Label    retry;
 2400 
 2401     // Iterate until swap succeeds.
 2402     __ z_llgf(Rtmp, $mem$$Address);  // current contents
 2403     __ bind(retry);
 2404       // Calculate incremented value.
 2405       __ z_csy(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2406       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2407     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2408   %}
 2409 
 2410   enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
 2411     C2_MacroAssembler _masm(&amp;cbuf);
 2412     Register Rdst = reg_to_register_object($dst$$reg);
 2413     Register Rtmp = reg_to_register_object($tmp$$reg);
 2414     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2415     Label    retry;
 2416 
 2417     // Iterate until swap succeeds.
 2418     __ z_lg(Rtmp, $mem$$Address);  // current contents
 2419     __ bind(retry);
 2420       // Calculate incremented value.
 2421       __ z_csg(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2422       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2423     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2424   %}
 2425 
 2426 %} // encode
 2427 
 2428 source %{
 2429 
 2430   // Check whether outs are all Stores. If so, we can omit clearing the upper
 2431   // 32 bits after encoding.
 2432   static bool all_outs_are_Stores(const Node *n) {
 2433     for (DUIterator_Fast imax, k = n-&gt;fast_outs(imax); k &lt; imax; k++) {
 2434       Node *out = n-&gt;fast_out(k);
 2435       if (!out-&gt;is_Mach() || out-&gt;as_Mach()-&gt;ideal_Opcode() != Op_StoreN) {
 2436         // Most other outs are SpillCopy, but there are various other.
 2437         // jvm98 has arond 9% Encodes where we return false.
 2438         return false;
 2439       }
 2440     }
 2441     return true;
 2442   }
 2443 
 2444 %} // source
 2445 
 2446 
 2447 //----------FRAME--------------------------------------------------------------
 2448 // Definition of frame structure and management information.
 2449 
 2450 frame %{
 2451   // What direction does stack grow in (assumed to be same for native &amp; Java).
 2452   stack_direction(TOWARDS_LOW);
 2453 
 2454   // These two registers define part of the calling convention between
 2455   // compiled code and the interpreter.
 2456 
 2457   // Inline Cache Register
 2458   inline_cache_reg(Z_R9); // Z_inline_cache
 2459 
 2460   // Argument pointer for I2C adapters
 2461   //
 2462   // Tos is loaded in run_compiled_code to Z_ARG5=Z_R6.
 2463   // interpreter_arg_ptr_reg(Z_R6);
 2464 
 2465   // Temporary in compiled entry-points
 2466   // compiler_method_oop_reg(Z_R1);//Z_R1_scratch
 2467 
 2468   // Method Oop Register when calling interpreter
 2469   interpreter_method_oop_reg(Z_R9);//Z_method
 2470 
 2471   // Optional: name the operand used by cisc-spilling to access
 2472   // [stack_pointer + offset].
 2473   cisc_spilling_operand_name(indOffset12);
 2474 
 2475   // Number of stack slots consumed by a Monitor enter.
 2476   sync_stack_slots(frame::jit_monitor_size_in_4_byte_units);
 2477 
 2478   // Compiled code&#39;s Frame Pointer
 2479   //
 2480   // z/Architecture stack pointer
 2481   frame_pointer(Z_R15); // Z_SP
 2482 
 2483   // Interpreter stores its frame pointer in a register which is
 2484   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 2485   // interpreted java to compiled java.
 2486   //
 2487   // Z_state holds pointer to caller&#39;s cInterpreter.
 2488   interpreter_frame_pointer(Z_R7); // Z_state
 2489 
 2490   // Use alignment_in_bytes instead of log_2_of_alignment_in_bits.
 2491   stack_alignment(frame::alignment_in_bytes);
 2492 
 2493   in_preserve_stack_slots(frame::jit_in_preserve_size_in_4_byte_units);
 2494 
 2495   // A `slot&#39; is assumed 4 bytes here!
 2496   // out_preserve_stack_slots(frame::jit_out_preserve_size_in_4_byte_units);
 2497 
 2498   // Number of outgoing stack slots killed above the
 2499   // out_preserve_stack_slots for calls to C. Supports the var-args
 2500   // backing area for register parms.
 2501   varargs_C_out_slots_killed(((frame::z_abi_160_size - frame::z_jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 2502 
 2503   // The after-PROLOG location of the return address. Location of
 2504   // return address specifies a type (REG or STACK) and a number
 2505   // representing the register number (i.e. - use a register name) or
 2506   // stack slot.
 2507   return_addr(REG Z_R14);
 2508 
 2509   // This is the body of the function
 2510   //
 2511   // void Matcher::calling_convention(OptoRegPair* sig /* array of ideal regs */,
 2512   //                                  uint length      /* length of array */,
 2513   //                                  bool is_outgoing)
 2514   //
 2515   // The `sig&#39; array is to be updated. Sig[j] represents the location
 2516   // of the j-th argument, either a register or a stack slot.
 2517 
 2518   // Body of function which returns an integer array locating
 2519   // arguments either in registers or in stack slots. Passed an array
 2520   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2521   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2522   // arguments for a CALLEE. Incoming stack arguments are
 2523   // automatically biased by the preserve_stack_slots field above.
 2524   calling_convention %{
 2525     // No difference between ingoing/outgoing just pass false.
 2526     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2527   %}
 2528 
 2529   // Body of function which returns an integer array locating
 2530   // arguments either in registers or in stack slots. Passed an array
 2531   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2532   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2533   // arguments for a CALLEE. Incoming stack arguments are
 2534   // automatically biased by the preserve_stack_slots field above.
 2535   c_calling_convention %{
 2536     // This is obviously always outgoing.
 2537     // C argument must be in register AND stack slot.
 2538     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2539   %}
 2540 
 2541   // Location of native (C/C++) and interpreter return values. This
 2542   // is specified to be the same as Java. In the 32-bit VM, long
 2543   // values are actually returned from native calls in O0:O1 and
 2544   // returned to the interpreter in I0:I1. The copying to and from
 2545   // the register pairs is done by the appropriate call and epilog
 2546   // opcodes. This simplifies the register allocator.
 2547   //
 2548   // Use register pair for c return value.
 2549   c_return_value %{
 2550     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2551     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2552     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2553     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2554   %}
 2555 
 2556   // Use register pair for return value.
 2557   // Location of compiled Java return values. Same as C
 2558   return_value %{
 2559     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2560     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2561     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2562     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2563   %}
 2564 %}
 2565 
 2566 
 2567 //----------ATTRIBUTES---------------------------------------------------------
 2568 
 2569 //----------Operand Attributes-------------------------------------------------
 2570 op_attrib op_cost(1);          // Required cost attribute
 2571 
 2572 //----------Instruction Attributes---------------------------------------------
 2573 
 2574 // Cost attribute. required.
 2575 ins_attrib ins_cost(DEFAULT_COST);
 2576 
 2577 // Is this instruction a non-matching short branch variant of some
 2578 // long branch? Not required.
 2579 ins_attrib ins_short_branch(0);
 2580 
 2581 // Indicates this is a trap based check node and final control-flow fixup
 2582 // must generate a proper fall through.
 2583 ins_attrib ins_is_TrapBasedCheckNode(true);
 2584 
 2585 // Attribute of instruction to tell how many constants the instruction will generate.
 2586 // (optional attribute). Default: 0.
 2587 ins_attrib ins_num_consts(0);
 2588 
 2589 // Required alignment attribute (must be a power of 2)
 2590 // specifies the alignment that some part of the instruction (not
 2591 // necessarily the start) requires. If &gt; 1, a compute_padding()
 2592 // function must be provided for the instruction.
 2593 //
 2594 // WARNING: Don&#39;t use size(FIXED_SIZE) or size(VARIABLE_SIZE) in
 2595 // instructions which depend on the proper alignment, because the
 2596 // desired alignment isn&#39;t guaranteed for the call to &quot;emit()&quot; during
 2597 // the size computation.
 2598 ins_attrib ins_alignment(1);
 2599 
 2600 // Enforce/prohibit rematerializations.
 2601 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 2602 //   then rematerialization of that instruction is prohibited and the
 2603 //   instruction&#39;s value will be spilled if necessary.
 2604 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 2605 //   then rematerialization is enforced and the instruction&#39;s value will
 2606 //   never get spilled. a copy of the instruction will be inserted if
 2607 //   necessary.
 2608 //   Note: this may result in rematerializations in front of every use.
 2609 // (optional attribute)
 2610 ins_attrib ins_cannot_rematerialize(false);
 2611 ins_attrib ins_should_rematerialize(false);
 2612 
 2613 //----------OPERANDS-----------------------------------------------------------
 2614 // Operand definitions must precede instruction definitions for correct
 2615 // parsing in the ADLC because operands constitute user defined types
 2616 // which are used in instruction definitions.
 2617 
 2618 //----------Simple Operands----------------------------------------------------
 2619 // Immediate Operands
 2620 // Please note:
 2621 // Formats are generated automatically for constants and base registers.
 2622 
 2623 //----------------------------------------------
 2624 // SIGNED (shorter than INT) immediate operands
 2625 //----------------------------------------------
 2626 
 2627 // Byte Immediate: constant &#39;int -1&#39;
 2628 operand immB_minus1() %{
 2629   //         sign-ext constant      zero-ext constant
 2630   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x000000ff) == 0x000000ff));
 2631   match(ConI);
 2632   op_cost(1);
 2633   format %{ %}
 2634   interface(CONST_INTER);
 2635 %}
 2636 
 2637 // Byte Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2638 operand immB_n0m1() %{
 2639   //                             sign-ext constant     zero-ext constant
 2640   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x000000ff) != 0x000000ff);
 2641   match(ConI);
 2642   op_cost(1);
 2643   format %{ %}
 2644   interface(CONST_INTER);
 2645 %}
 2646 
 2647 // Short Immediate: constant &#39;int -1&#39;
 2648 operand immS_minus1() %{
 2649   //         sign-ext constant      zero-ext constant
 2650   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x0000ffff) == 0x0000ffff));
 2651   match(ConI);
 2652   op_cost(1);
 2653   format %{ %}
 2654   interface(CONST_INTER);
 2655 %}
 2656 
 2657 // Short Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2658 operand immS_n0m1() %{
 2659   //                             sign-ext constant     zero-ext constant
 2660   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x0000ffff) != 0x0000ffff);
 2661   match(ConI);
 2662   op_cost(1);
 2663   format %{ %}
 2664   interface(CONST_INTER);
 2665 %}
 2666 
 2667 //-----------------------------------------
 2668 //  SIGNED INT immediate operands
 2669 //-----------------------------------------
 2670 
 2671 // Integer Immediate: 32-bit
 2672 operand immI() %{
 2673   match(ConI);
 2674   op_cost(1);
 2675   format %{ %}
 2676   interface(CONST_INTER);
 2677 %}
 2678 
 2679 // Int Immediate: 20-bit
 2680 operand immI20() %{
 2681   predicate(Immediate::is_simm20(n-&gt;get_int()));
 2682   match(ConI);
 2683   op_cost(1);
 2684   format %{ %}
 2685   interface(CONST_INTER);
 2686 %}
 2687 
 2688 // Integer Immediate: 16-bit
 2689 operand immI16() %{
 2690   predicate(Immediate::is_simm16(n-&gt;get_int()));
 2691   match(ConI);
 2692   op_cost(1);
 2693   format %{ %}
 2694   interface(CONST_INTER);
 2695 %}
 2696 
 2697 // Integer Immediate: 8-bit
 2698 operand immI8() %{
 2699   predicate(Immediate::is_simm8(n-&gt;get_int()));
 2700   match(ConI);
 2701   op_cost(1);
 2702   format %{ %}
 2703   interface(CONST_INTER);
 2704 %}
 2705 
 2706 // Integer Immediate: constant &#39;int 0&#39;
 2707 operand immI_0() %{
 2708   predicate(n-&gt;get_int() == 0);
 2709   match(ConI);
 2710   op_cost(1);
 2711   format %{ %}
 2712   interface(CONST_INTER);
 2713 %}
 2714 
 2715 // Integer Immediate: constant &#39;int -1&#39;
 2716 operand immI_minus1() %{
 2717   predicate(n-&gt;get_int() == -1);
 2718   match(ConI);
 2719   op_cost(1);
 2720   format %{ %}
 2721   interface(CONST_INTER);
 2722 %}
 2723 
 2724 // Integer Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2725 operand immI_n0m1() %{
 2726   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1);
 2727   match(ConI);
 2728   op_cost(1);
 2729   format %{ %}
 2730   interface(CONST_INTER);
 2731 %}
 2732 
 2733 //-------------------------------------------
 2734 // UNSIGNED INT immediate operands
 2735 //-------------------------------------------
 2736 
 2737 // Unsigned Integer Immediate: 32-bit
 2738 operand uimmI() %{
 2739   match(ConI);
 2740   op_cost(1);
 2741   format %{ %}
 2742   interface(CONST_INTER);
 2743 %}
 2744 
 2745 // Unsigned Integer Immediate: 16-bit
 2746 operand uimmI16() %{
 2747   predicate(Immediate::is_uimm16(n-&gt;get_int()));
 2748   match(ConI);
 2749   op_cost(1);
 2750   format %{ %}
 2751   interface(CONST_INTER);
 2752 %}
 2753 
 2754 // Unsigned Integer Immediate: 12-bit
 2755 operand uimmI12() %{
 2756   predicate(Immediate::is_uimm12(n-&gt;get_int()));
 2757   match(ConI);
 2758   op_cost(1);
 2759   format %{ %}
 2760   interface(CONST_INTER);
 2761 %}
 2762 
 2763 // Unsigned Integer Immediate: 12-bit
 2764 operand uimmI8() %{
 2765   predicate(Immediate::is_uimm8(n-&gt;get_int()));
 2766   match(ConI);
 2767   op_cost(1);
 2768   format %{ %}
 2769   interface(CONST_INTER);
 2770 %}
 2771 
 2772 // Integer Immediate: 6-bit
 2773 operand uimmI6() %{
 2774   predicate(Immediate::is_uimm(n-&gt;get_int(), 6));
 2775   match(ConI);
 2776   op_cost(1);
 2777   format %{ %}
 2778   interface(CONST_INTER);
 2779 %}
 2780 
 2781 // Integer Immediate: 5-bit
 2782 operand uimmI5() %{
 2783   predicate(Immediate::is_uimm(n-&gt;get_int(), 5));
 2784   match(ConI);
 2785   op_cost(1);
 2786   format %{ %}
 2787   interface(CONST_INTER);
 2788 %}
 2789 
 2790 // Length for SS instructions, given in DWs,
 2791 //   possible range [1..512], i.e. [8..4096] Bytes
 2792 //   used     range [1..256], i.e. [8..2048] Bytes
 2793 //   operand type int
 2794 // Unsigned Integer Immediate: 9-bit
 2795 operand SSlenDW() %{
 2796   predicate(Immediate::is_uimm8(n-&gt;get_long()-1));
 2797   match(ConL);
 2798   op_cost(1);
 2799   format %{ %}
 2800   interface(CONST_INTER);
 2801 %}
 2802 
 2803 //------------------------------------------
 2804 // (UN)SIGNED INT specific values
 2805 //------------------------------------------
 2806 
 2807 // Integer Immediate: the value 1
 2808 operand immI_1() %{
 2809   predicate(n-&gt;get_int() == 1);
 2810   match(ConI);
 2811   op_cost(1);
 2812   format %{ %}
 2813   interface(CONST_INTER);
 2814 %}
 2815 
 2816 // Integer Immediate: the value 16.
 2817 operand immI_16() %{
 2818   predicate(n-&gt;get_int() == 16);
 2819   match(ConI);
 2820   op_cost(1);
 2821   format %{ %}
 2822   interface(CONST_INTER);
 2823 %}
 2824 
 2825 // Integer Immediate: the value 24.
 2826 operand immI_24() %{
 2827   predicate(n-&gt;get_int() == 24);
 2828   match(ConI);
 2829   op_cost(1);
 2830   format %{ %}
 2831   interface(CONST_INTER);
 2832 %}
 2833 
 2834 // Integer Immediate: the value 255
 2835 operand immI_255() %{
 2836   predicate(n-&gt;get_int() == 255);
 2837   match(ConI);
 2838   op_cost(1);
 2839   format %{ %}
 2840   interface(CONST_INTER);
 2841 %}
 2842 
 2843 // Integer Immediate: the values 32-63
 2844 operand immI_32_63() %{
 2845   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 2846   match(ConI);
 2847   op_cost(1);
 2848   format %{ %}
 2849   interface(CONST_INTER);
 2850 %}
 2851 
 2852 // Unsigned Integer Immediate: LL-part, extended by 1s.
 2853 operand uimmI_LL1() %{
 2854   predicate((n-&gt;get_int() &amp; 0xFFFF0000) == 0xFFFF0000);
 2855   match(ConI);
 2856   op_cost(1);
 2857   format %{ %}
 2858   interface(CONST_INTER);
 2859 %}
 2860 
 2861 // Unsigned Integer Immediate: LH-part, extended by 1s.
 2862 operand uimmI_LH1() %{
 2863   predicate((n-&gt;get_int() &amp; 0xFFFF) == 0xFFFF);
 2864   match(ConI);
 2865   op_cost(1);
 2866   format %{ %}
 2867   interface(CONST_INTER);
 2868 %}
 2869 
 2870 //------------------------------------------
 2871 // SIGNED LONG immediate operands
 2872 //------------------------------------------
 2873 
 2874 operand immL() %{
 2875   match(ConL);
 2876   op_cost(1);
 2877   format %{ %}
 2878   interface(CONST_INTER);
 2879 %}
 2880 
 2881 // Long Immediate: 32-bit
 2882 operand immL32() %{
 2883   predicate(Immediate::is_simm32(n-&gt;get_long()));
 2884   match(ConL);
 2885   op_cost(1);
 2886   format %{ %}
 2887   interface(CONST_INTER);
 2888 %}
 2889 
 2890 // Long Immediate: 20-bit
 2891 operand immL20() %{
 2892   predicate(Immediate::is_simm20(n-&gt;get_long()));
 2893   match(ConL);
 2894   op_cost(1);
 2895   format %{ %}
 2896   interface(CONST_INTER);
 2897 %}
 2898 
 2899 // Long Immediate: 16-bit
 2900 operand immL16() %{
 2901   predicate(Immediate::is_simm16(n-&gt;get_long()));
 2902   match(ConL);
 2903   op_cost(1);
 2904   format %{ %}
 2905   interface(CONST_INTER);
 2906 %}
 2907 
 2908 // Long Immediate: 8-bit
 2909 operand immL8() %{
 2910   predicate(Immediate::is_simm8(n-&gt;get_long()));
 2911   match(ConL);
 2912   op_cost(1);
 2913   format %{ %}
 2914   interface(CONST_INTER);
 2915 %}
 2916 
 2917 //--------------------------------------------
 2918 // UNSIGNED LONG immediate operands
 2919 //--------------------------------------------
 2920 
 2921 operand uimmL32() %{
 2922   predicate(Immediate::is_uimm32(n-&gt;get_long()));
 2923   match(ConL);
 2924   op_cost(1);
 2925   format %{ %}
 2926   interface(CONST_INTER);
 2927 %}
 2928 
 2929 // Unsigned Long Immediate: 16-bit
 2930 operand uimmL16() %{
 2931   predicate(Immediate::is_uimm16(n-&gt;get_long()));
 2932   match(ConL);
 2933   op_cost(1);
 2934   format %{ %}
 2935   interface(CONST_INTER);
 2936 %}
 2937 
 2938 // Unsigned Long Immediate: 12-bit
 2939 operand uimmL12() %{
 2940   predicate(Immediate::is_uimm12(n-&gt;get_long()));
 2941   match(ConL);
 2942   op_cost(1);
 2943   format %{ %}
 2944   interface(CONST_INTER);
 2945 %}
 2946 
 2947 // Unsigned Long Immediate: 8-bit
 2948 operand uimmL8() %{
 2949   predicate(Immediate::is_uimm8(n-&gt;get_long()));
 2950   match(ConL);
 2951   op_cost(1);
 2952   format %{ %}
 2953   interface(CONST_INTER);
 2954 %}
 2955 
 2956 //-------------------------------------------
 2957 // (UN)SIGNED LONG specific values
 2958 //-------------------------------------------
 2959 
 2960 // Long Immediate: the value FF
 2961 operand immL_FF() %{
 2962   predicate(n-&gt;get_long() == 0xFFL);
 2963   match(ConL);
 2964   op_cost(1);
 2965   format %{ %}
 2966   interface(CONST_INTER);
 2967 %}
 2968 
 2969 // Long Immediate: the value FFFF
 2970 operand immL_FFFF() %{
 2971   predicate(n-&gt;get_long() == 0xFFFFL);
 2972   match(ConL);
 2973   op_cost(1);
 2974   format %{ %}
 2975   interface(CONST_INTER);
 2976 %}
 2977 
 2978 // Long Immediate: the value FFFFFFFF
 2979 operand immL_FFFFFFFF() %{
 2980   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 2981   match(ConL);
 2982   op_cost(1);
 2983   format %{ %}
 2984   interface(CONST_INTER);
 2985 %}
 2986 
 2987 operand immL_0() %{
 2988   predicate(n-&gt;get_long() == 0L);
 2989   match(ConL);
 2990   op_cost(1);
 2991   format %{ %}
 2992   interface(CONST_INTER);
 2993 %}
 2994 
 2995 // Unsigned Long Immediate: LL-part, extended by 1s.
 2996 operand uimmL_LL1() %{
 2997   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFF0000L) == 0xFFFFFFFFFFFF0000L);
 2998   match(ConL);
 2999   op_cost(1);
 3000   format %{ %}
 3001   interface(CONST_INTER);
 3002 %}
 3003 
 3004 // Unsigned Long Immediate: LH-part, extended by 1s.
 3005 operand uimmL_LH1() %{
 3006   predicate((n-&gt;get_long() &amp; 0xFFFFFFFF0000FFFFL) == 0xFFFFFFFF0000FFFFL);
 3007   match(ConL);
 3008   op_cost(1);
 3009   format %{ %}
 3010   interface(CONST_INTER);
 3011 %}
 3012 
 3013 // Unsigned Long Immediate: HL-part, extended by 1s.
 3014 operand uimmL_HL1() %{
 3015   predicate((n-&gt;get_long() &amp; 0xFFFF0000FFFFFFFFL) == 0xFFFF0000FFFFFFFFL);
 3016   match(ConL);
 3017   op_cost(1);
 3018   format %{ %}
 3019   interface(CONST_INTER);
 3020 %}
 3021 
 3022 // Unsigned Long Immediate: HH-part, extended by 1s.
 3023 operand uimmL_HH1() %{
 3024   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFFL) == 0xFFFFFFFFFFFFL);
 3025   match(ConL);
 3026   op_cost(1);
 3027   format %{ %}
 3028   interface(CONST_INTER);
 3029 %}
 3030 
 3031 // Long Immediate: low 32-bit mask
 3032 operand immL_32bits() %{
 3033   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3034   match(ConL);
 3035   op_cost(1);
 3036   format %{ %}
 3037   interface(CONST_INTER);
 3038 %}
 3039 
 3040 //--------------------------------------
 3041 //  POINTER immediate operands
 3042 //--------------------------------------
 3043 
 3044 // Pointer Immediate: 64-bit
 3045 operand immP() %{
 3046   match(ConP);
 3047   op_cost(1);
 3048   format %{ %}
 3049   interface(CONST_INTER);
 3050 %}
 3051 
 3052 // Pointer Immediate: 32-bit
 3053 operand immP32() %{
 3054   predicate(Immediate::is_uimm32(n-&gt;get_ptr()));
 3055   match(ConP);
 3056   op_cost(1);
 3057   format %{ %}
 3058   interface(CONST_INTER);
 3059 %}
 3060 
 3061 // Pointer Immediate: 16-bit
 3062 operand immP16() %{
 3063   predicate(Immediate::is_uimm16(n-&gt;get_ptr()));
 3064   match(ConP);
 3065   op_cost(1);
 3066   format %{ %}
 3067   interface(CONST_INTER);
 3068 %}
 3069 
 3070 // Pointer Immediate: 8-bit
 3071 operand immP8() %{
 3072   predicate(Immediate::is_uimm8(n-&gt;get_ptr()));
 3073   match(ConP);
 3074   op_cost(1);
 3075   format %{ %}
 3076   interface(CONST_INTER);
 3077 %}
 3078 
 3079 //-----------------------------------
 3080 // POINTER specific values
 3081 //-----------------------------------
 3082 
 3083 // Pointer Immediate: NULL
 3084 operand immP0() %{
 3085   predicate(n-&gt;get_ptr() == 0);
 3086   match(ConP);
 3087   op_cost(1);
 3088   format %{ %}
 3089   interface(CONST_INTER);
 3090 %}
 3091 
 3092 //---------------------------------------------
 3093 // NARROW POINTER immediate operands
 3094 //---------------------------------------------
 3095 
 3096 // Narrow Pointer Immediate
 3097 operand immN() %{
 3098   match(ConN);
 3099   op_cost(1);
 3100   format %{ %}
 3101   interface(CONST_INTER);
 3102 %}
 3103 
 3104 operand immNKlass() %{
 3105   match(ConNKlass);
 3106   op_cost(1);
 3107   format %{ %}
 3108   interface(CONST_INTER);
 3109 %}
 3110 
 3111 // Narrow Pointer Immediate
 3112 operand immN8() %{
 3113   predicate(Immediate::is_uimm8(n-&gt;get_narrowcon()));
 3114   match(ConN);
 3115   op_cost(1);
 3116   format %{ %}
 3117   interface(CONST_INTER);
 3118 %}
 3119 
 3120 // Narrow NULL Pointer Immediate
 3121 operand immN0() %{
 3122   predicate(n-&gt;get_narrowcon() == 0);
 3123   match(ConN);
 3124   op_cost(1);
 3125   format %{ %}
 3126   interface(CONST_INTER);
 3127 %}
 3128 
 3129 // FLOAT and DOUBLE immediate operands
 3130 
 3131 // Double Immediate
 3132 operand immD() %{
 3133   match(ConD);
 3134   op_cost(1);
 3135   format %{ %}
 3136   interface(CONST_INTER);
 3137 %}
 3138 
 3139 // Double Immediate: +-0
 3140 operand immDpm0() %{
 3141   predicate(n-&gt;getd() == 0);
 3142   match(ConD);
 3143   op_cost(1);
 3144   format %{ %}
 3145   interface(CONST_INTER);
 3146 %}
 3147 
 3148 // Double Immediate: +0
 3149 operand immDp0() %{
 3150   predicate(jlong_cast(n-&gt;getd()) == 0);
 3151   match(ConD);
 3152   op_cost(1);
 3153   format %{ %}
 3154   interface(CONST_INTER);
 3155 %}
 3156 
 3157 // Float Immediate
 3158 operand immF() %{
 3159   match(ConF);
 3160   op_cost(1);
 3161   format %{ %}
 3162   interface(CONST_INTER);
 3163 %}
 3164 
 3165 // Float Immediate: +-0
 3166 operand immFpm0() %{
 3167   predicate(n-&gt;getf() == 0);
 3168   match(ConF);
 3169   op_cost(1);
 3170   format %{ %}
 3171   interface(CONST_INTER);
 3172 %}
 3173 
 3174 // Float Immediate: +0
 3175 operand immFp0() %{
 3176   predicate(jint_cast(n-&gt;getf()) == 0);
 3177   match(ConF);
 3178   op_cost(1);
 3179   format %{ %}
 3180   interface(CONST_INTER);
 3181 %}
 3182 
 3183 // End of Immediate Operands
 3184 
 3185 // Integer Register Operands
 3186 // Integer Register
 3187 operand iRegI() %{
 3188   constraint(ALLOC_IN_RC(z_int_reg));
 3189   match(RegI);
 3190   match(noArg_iRegI);
 3191   match(rarg1RegI);
 3192   match(rarg2RegI);
 3193   match(rarg3RegI);
 3194   match(rarg4RegI);
 3195   match(rarg5RegI);
 3196   match(noOdd_iRegI);
 3197   match(revenRegI);
 3198   match(roddRegI);
 3199   format %{ %}
 3200   interface(REG_INTER);
 3201 %}
 3202 
 3203 operand noArg_iRegI() %{
 3204   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3205   match(RegI);
 3206   format %{ %}
 3207   interface(REG_INTER);
 3208 %}
 3209 
 3210 // revenRegI and roddRegI constitute and even-odd-pair.
 3211 operand revenRegI() %{
 3212   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3213   match(iRegI);
 3214   format %{ %}
 3215   interface(REG_INTER);
 3216 %}
 3217 
 3218 // revenRegI and roddRegI constitute and even-odd-pair.
 3219 operand roddRegI() %{
 3220   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3221   match(iRegI);
 3222   format %{ %}
 3223   interface(REG_INTER);
 3224 %}
 3225 
 3226 operand rarg1RegI() %{
 3227   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3228   match(iRegI);
 3229   format %{ %}
 3230   interface(REG_INTER);
 3231 %}
 3232 
 3233 operand rarg2RegI() %{
 3234   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3235   match(iRegI);
 3236   format %{ %}
 3237   interface(REG_INTER);
 3238 %}
 3239 
 3240 operand rarg3RegI() %{
 3241   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3242   match(iRegI);
 3243   format %{ %}
 3244   interface(REG_INTER);
 3245 %}
 3246 
 3247 operand rarg4RegI() %{
 3248   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3249   match(iRegI);
 3250   format %{ %}
 3251   interface(REG_INTER);
 3252 %}
 3253 
 3254 operand rarg5RegI() %{
 3255   constraint(ALLOC_IN_RC(z_rarg5_int_reg));
 3256   match(iRegI);
 3257   format %{ %}
 3258   interface(REG_INTER);
 3259 %}
 3260 
 3261 operand noOdd_iRegI() %{
 3262   constraint(ALLOC_IN_RC(z_no_odd_int_reg));
 3263   match(RegI);
 3264   match(revenRegI);
 3265   format %{ %}
 3266   interface(REG_INTER);
 3267 %}
 3268 
 3269 // Pointer Register
 3270 operand iRegP() %{
 3271   constraint(ALLOC_IN_RC(z_ptr_reg));
 3272   match(RegP);
 3273   match(noArg_iRegP);
 3274   match(rarg1RegP);
 3275   match(rarg2RegP);
 3276   match(rarg3RegP);
 3277   match(rarg4RegP);
 3278   match(rarg5RegP);
 3279   match(revenRegP);
 3280   match(roddRegP);
 3281   format %{ %}
 3282   interface(REG_INTER);
 3283 %}
 3284 
 3285 // thread operand
 3286 operand threadRegP() %{
 3287   constraint(ALLOC_IN_RC(z_thread_ptr_reg));
 3288   match(RegP);
 3289   format %{ &quot;Z_THREAD&quot; %}
 3290   interface(REG_INTER);
 3291 %}
 3292 
 3293 operand noArg_iRegP() %{
 3294   constraint(ALLOC_IN_RC(z_no_arg_ptr_reg));
 3295   match(iRegP);
 3296   format %{ %}
 3297   interface(REG_INTER);
 3298 %}
 3299 
 3300 operand rarg1RegP() %{
 3301   constraint(ALLOC_IN_RC(z_rarg1_ptr_reg));
 3302   match(iRegP);
 3303   format %{ %}
 3304   interface(REG_INTER);
 3305 %}
 3306 
 3307 operand rarg2RegP() %{
 3308   constraint(ALLOC_IN_RC(z_rarg2_ptr_reg));
 3309   match(iRegP);
 3310   format %{ %}
 3311   interface(REG_INTER);
 3312 %}
 3313 
 3314 operand rarg3RegP() %{
 3315   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3316   match(iRegP);
 3317   format %{ %}
 3318   interface(REG_INTER);
 3319 %}
 3320 
 3321 operand rarg4RegP() %{
 3322   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3323   match(iRegP);
 3324   format %{ %}
 3325   interface(REG_INTER);
 3326 %}
 3327 
 3328 operand rarg5RegP() %{
 3329   constraint(ALLOC_IN_RC(z_rarg5_ptr_reg));
 3330   match(iRegP);
 3331   format %{ %}
 3332   interface(REG_INTER);
 3333 %}
 3334 
 3335 operand memoryRegP() %{
 3336   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3337   match(RegP);
 3338   match(iRegP);
 3339   match(threadRegP);
 3340   format %{ %}
 3341   interface(REG_INTER);
 3342 %}
 3343 
 3344 // revenRegP and roddRegP constitute and even-odd-pair.
 3345 operand revenRegP() %{
 3346   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3347   match(iRegP);
 3348   format %{ %}
 3349   interface(REG_INTER);
 3350 %}
 3351 
 3352 // revenRegP and roddRegP constitute and even-odd-pair.
 3353 operand roddRegP() %{
 3354   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3355   match(iRegP);
 3356   format %{ %}
 3357   interface(REG_INTER);
 3358 %}
 3359 
 3360 operand lock_ptr_RegP() %{
 3361   constraint(ALLOC_IN_RC(z_lock_ptr_reg));
 3362   match(RegP);
 3363   format %{ %}
 3364   interface(REG_INTER);
 3365 %}
 3366 
 3367 operand rscratch2RegP() %{
 3368   constraint(ALLOC_IN_RC(z_rscratch2_bits64_reg));
 3369   match(RegP);
 3370   format %{ %}
 3371   interface(REG_INTER);
 3372 %}
 3373 
 3374 operand iRegN() %{
 3375   constraint(ALLOC_IN_RC(z_int_reg));
 3376   match(RegN);
 3377   match(noArg_iRegN);
 3378   match(rarg1RegN);
 3379   match(rarg2RegN);
 3380   match(rarg3RegN);
 3381   match(rarg4RegN);
 3382   match(rarg5RegN);
 3383   format %{ %}
 3384   interface(REG_INTER);
 3385 %}
 3386 
 3387 operand noArg_iRegN() %{
 3388   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3389   match(iRegN);
 3390   format %{ %}
 3391   interface(REG_INTER);
 3392 %}
 3393 
 3394 operand rarg1RegN() %{
 3395   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3396   match(iRegN);
 3397   format %{ %}
 3398   interface(REG_INTER);
 3399 %}
 3400 
 3401 operand rarg2RegN() %{
 3402   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3403   match(iRegN);
 3404   format %{ %}
 3405   interface(REG_INTER);
 3406 %}
 3407 
 3408 operand rarg3RegN() %{
 3409   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3410   match(iRegN);
 3411   format %{ %}
 3412   interface(REG_INTER);
 3413 %}
 3414 
 3415 operand rarg4RegN() %{
 3416   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3417   match(iRegN);
 3418   format %{ %}
 3419   interface(REG_INTER);
 3420 %}
 3421 
 3422 operand rarg5RegN() %{
 3423   constraint(ALLOC_IN_RC(z_rarg5_ptrN_reg));
 3424   match(iRegN);
 3425   format %{ %}
 3426   interface(REG_INTER);
 3427 %}
 3428 
 3429 // Long Register
 3430 operand iRegL() %{
 3431   constraint(ALLOC_IN_RC(z_long_reg));
 3432   match(RegL);
 3433   match(revenRegL);
 3434   match(roddRegL);
 3435   match(allRoddRegL);
 3436   match(rarg1RegL);
 3437   match(rarg5RegL);
 3438   format %{ %}
 3439   interface(REG_INTER);
 3440 %}
 3441 
 3442 // revenRegL and roddRegL constitute and even-odd-pair.
 3443 operand revenRegL() %{
 3444   constraint(ALLOC_IN_RC(z_rarg3_long_reg));
 3445   match(iRegL);
 3446   format %{ %}
 3447   interface(REG_INTER);
 3448 %}
 3449 
 3450 // revenRegL and roddRegL constitute and even-odd-pair.
 3451 operand roddRegL() %{
 3452   constraint(ALLOC_IN_RC(z_rarg4_long_reg));
 3453   match(iRegL);
 3454   format %{ %}
 3455   interface(REG_INTER);
 3456 %}
 3457 
 3458 // available odd registers for iRegL
 3459 operand allRoddRegL() %{
 3460   constraint(ALLOC_IN_RC(z_long_odd_reg));
 3461   match(iRegL);
 3462   format %{ %}
 3463   interface(REG_INTER);
 3464 %}
 3465 
 3466 operand rarg1RegL() %{
 3467   constraint(ALLOC_IN_RC(z_rarg1_long_reg));
 3468   match(iRegL);
 3469   format %{ %}
 3470   interface(REG_INTER);
 3471 %}
 3472 
 3473 operand rarg5RegL() %{
 3474   constraint(ALLOC_IN_RC(z_rarg5_long_reg));
 3475   match(iRegL);
 3476   format %{ %}
 3477   interface(REG_INTER);
 3478 %}
 3479 
 3480 // Condition Code Flag Registers
 3481 operand flagsReg() %{
 3482   constraint(ALLOC_IN_RC(z_condition_reg));
 3483   match(RegFlags);
 3484   format %{ &quot;CR&quot; %}
 3485   interface(REG_INTER);
 3486 %}
 3487 
 3488 // Condition Code Flag Registers for rules with result tuples
 3489 operand TD_flagsReg() %{
 3490   constraint(ALLOC_IN_RC(z_condition_reg));
 3491   match(RegFlags);
 3492   format %{ &quot;CR&quot; %}
 3493   interface(REG_TUPLE_DEST_INTER);
 3494 %}
 3495 
 3496 operand regD() %{
 3497   constraint(ALLOC_IN_RC(z_dbl_reg));
 3498   match(RegD);
 3499   format %{ %}
 3500   interface(REG_INTER);
 3501 %}
 3502 
 3503 operand rscratchRegD() %{
 3504   constraint(ALLOC_IN_RC(z_rscratch1_dbl_reg));
 3505   match(RegD);
 3506   format %{ %}
 3507   interface(REG_INTER);
 3508 %}
 3509 
 3510 operand regF() %{
 3511   constraint(ALLOC_IN_RC(z_flt_reg));
 3512   match(RegF);
 3513   format %{ %}
 3514   interface(REG_INTER);
 3515 %}
 3516 
 3517 operand rscratchRegF() %{
 3518   constraint(ALLOC_IN_RC(z_rscratch1_flt_reg));
 3519   match(RegF);
 3520   format %{ %}
 3521   interface(REG_INTER);
 3522 %}
 3523 
 3524 // Special Registers
 3525 
 3526 // Method Register
 3527 operand inline_cache_regP(iRegP reg) %{
 3528   constraint(ALLOC_IN_RC(z_r9_regP)); // inline_cache_reg
 3529   match(reg);
 3530   format %{ %}
 3531   interface(REG_INTER);
 3532 %}
 3533 
 3534 operand compiler_method_oop_regP(iRegP reg) %{
 3535   constraint(ALLOC_IN_RC(z_r1_RegP)); // compiler_method_oop_reg
 3536   match(reg);
 3537   format %{ %}
 3538   interface(REG_INTER);
 3539 %}
 3540 
 3541 operand interpreter_method_oop_regP(iRegP reg) %{
 3542   constraint(ALLOC_IN_RC(z_r9_regP)); // interpreter_method_oop_reg
 3543   match(reg);
 3544   format %{ %}
 3545   interface(REG_INTER);
 3546 %}
 3547 
 3548 // Operands to remove register moves in unscaled mode.
 3549 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 3550 operand iRegP2N(iRegP reg) %{
 3551   predicate(CompressedOops::shift() == 0 &amp;&amp; _leaf-&gt;as_EncodeP()-&gt;in(0) == NULL);
 3552   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3553   match(EncodeP reg);
 3554   format %{ &quot;$reg&quot; %}
 3555   interface(REG_INTER)
 3556 %}
 3557 
 3558 operand iRegN2P(iRegN reg) %{
 3559   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0 &amp;&amp;
 3560             _leaf-&gt;as_DecodeN()-&gt;in(0) == NULL);
 3561   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3562   match(DecodeN reg);
 3563   format %{ &quot;$reg&quot; %}
 3564   interface(REG_INTER)
 3565 %}
 3566 
 3567 
 3568 //----------Complex Operands---------------------------------------------------
 3569 
 3570 // Indirect Memory Reference
 3571 operand indirect(memoryRegP base) %{
 3572   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3573   match(base);
 3574   op_cost(1);
 3575   format %{ &quot;#0[,$base]&quot; %}
 3576   interface(MEMORY_INTER) %{
 3577     base($base);
 3578     index(0xffffFFFF); // noreg
 3579     scale(0x0);
 3580     disp(0x0);
 3581   %}
 3582 %}
 3583 
 3584 // Indirect with Offset (long)
 3585 operand indOffset20(memoryRegP base, immL20 offset) %{
 3586   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3587   match(AddP base offset);
 3588   op_cost(1);
 3589   format %{ &quot;$offset[,$base]&quot; %}
 3590   interface(MEMORY_INTER) %{
 3591     base($base);
 3592     index(0xffffFFFF); // noreg
 3593     scale(0x0);
 3594     disp($offset);
 3595   %}
 3596 %}
 3597 
 3598 operand indOffset20Narrow(iRegN base, immL20 offset) %{
 3599   predicate(Matcher::narrow_oop_use_complex_address());
 3600   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3601   match(AddP (DecodeN base) offset);
 3602   op_cost(1);
 3603   format %{ &quot;$offset[,$base]&quot; %}
 3604   interface(MEMORY_INTER) %{
 3605     base($base);
 3606     index(0xffffFFFF); // noreg
 3607     scale(0x0);
 3608     disp($offset);
 3609   %}
 3610 %}
 3611 
 3612 // Indirect with Offset (short)
 3613 operand indOffset12(memoryRegP base, uimmL12 offset) %{
 3614   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3615   match(AddP base offset);
 3616   op_cost(1);
 3617   format %{ &quot;$offset[[,$base]]&quot; %}
 3618   interface(MEMORY_INTER) %{
 3619     base($base);
 3620     index(0xffffFFFF); // noreg
 3621     scale(0x0);
 3622     disp($offset);
 3623   %}
 3624 %}
 3625 
 3626 operand indOffset12Narrow(iRegN base, uimmL12 offset) %{
 3627   predicate(Matcher::narrow_oop_use_complex_address());
 3628   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3629   match(AddP (DecodeN base) offset);
 3630   op_cost(1);
 3631   format %{ &quot;$offset[[,$base]]&quot; %}
 3632   interface(MEMORY_INTER) %{
 3633     base($base);
 3634     index(0xffffFFFF); // noreg
 3635     scale(0x0);
 3636     disp($offset);
 3637   %}
 3638 %}
 3639 
 3640 // Indirect with Register Index
 3641 operand indIndex(memoryRegP base, iRegL index) %{
 3642   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3643   match(AddP base index);
 3644   op_cost(1);
 3645   format %{ &quot;#0[($index,$base)]&quot; %}
 3646   interface(MEMORY_INTER) %{
 3647     base($base);
 3648     index($index);
 3649     scale(0x0);
 3650     disp(0x0);
 3651   %}
 3652 %}
 3653 
 3654 // Indirect with Offset (long) and index
 3655 operand indOffset20index(memoryRegP base, immL20 offset, iRegL index) %{
 3656   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3657   match(AddP (AddP base index) offset);
 3658   op_cost(1);
 3659   format %{ &quot;$offset[($index,$base)]&quot; %}
 3660   interface(MEMORY_INTER) %{
 3661     base($base);
 3662     index($index);
 3663     scale(0x0);
 3664     disp($offset);
 3665   %}
 3666 %}
 3667 
 3668 operand indOffset20indexNarrow(iRegN base, immL20 offset, iRegL index) %{
 3669   predicate(Matcher::narrow_oop_use_complex_address());
 3670   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3671   match(AddP (AddP (DecodeN base) index) offset);
 3672   op_cost(1);
 3673   format %{ &quot;$offset[($index,$base)]&quot; %}
 3674   interface(MEMORY_INTER) %{
 3675     base($base);
 3676     index($index);
 3677     scale(0x0);
 3678     disp($offset);
 3679   %}
 3680 %}
 3681 
 3682 // Indirect with Offset (short) and index
 3683 operand indOffset12index(memoryRegP base, uimmL12 offset, iRegL index) %{
 3684   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3685   match(AddP (AddP base index) offset);
 3686   op_cost(1);
 3687   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3688   interface(MEMORY_INTER) %{
 3689     base($base);
 3690     index($index);
 3691     scale(0x0);
 3692     disp($offset);
 3693   %}
 3694 %}
 3695 
 3696 operand indOffset12indexNarrow(iRegN base, uimmL12 offset, iRegL index) %{
 3697   predicate(Matcher::narrow_oop_use_complex_address());
 3698   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3699   match(AddP (AddP (DecodeN base) index) offset);
 3700   op_cost(1);
 3701   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3702   interface(MEMORY_INTER) %{
 3703     base($base);
 3704     index($index);
 3705     scale(0x0);
 3706     disp($offset);
 3707   %}
 3708 %}
 3709 
 3710 //----------Special Memory Operands--------------------------------------------
 3711 
 3712 // Stack Slot Operand
 3713 // This operand is used for loading and storing temporary values on
 3714 // the stack where a match requires a value to flow through memory.
 3715 operand stackSlotI(sRegI reg) %{
 3716   constraint(ALLOC_IN_RC(stack_slots));
 3717   op_cost(1);
 3718   format %{ &quot;[$reg(stackSlotI)]&quot; %}
 3719   interface(MEMORY_INTER) %{
 3720     base(0xf);   // Z_SP
 3721     index(0xffffFFFF); // noreg
 3722     scale(0x0);
 3723     disp($reg);  // stack offset
 3724   %}
 3725 %}
 3726 
 3727 operand stackSlotP(sRegP reg) %{
 3728   constraint(ALLOC_IN_RC(stack_slots));
 3729   op_cost(1);
 3730   format %{ &quot;[$reg(stackSlotP)]&quot; %}
 3731   interface(MEMORY_INTER) %{
 3732     base(0xf);   // Z_SP
 3733     index(0xffffFFFF); // noreg
 3734     scale(0x0);
 3735     disp($reg);  // Stack Offset
 3736   %}
 3737 %}
 3738 
 3739 operand stackSlotF(sRegF reg) %{
 3740   constraint(ALLOC_IN_RC(stack_slots));
 3741   op_cost(1);
 3742   format %{ &quot;[$reg(stackSlotF)]&quot; %}
 3743   interface(MEMORY_INTER) %{
 3744     base(0xf);   // Z_SP
 3745     index(0xffffFFFF); // noreg
 3746     scale(0x0);
 3747     disp($reg);  // Stack Offset
 3748   %}
 3749 %}
 3750 
 3751 operand stackSlotD(sRegD reg) %{
 3752   constraint(ALLOC_IN_RC(stack_slots));
 3753   op_cost(1);
 3754   //match(RegD);
 3755   format %{ &quot;[$reg(stackSlotD)]&quot; %}
 3756   interface(MEMORY_INTER) %{
 3757     base(0xf);   // Z_SP
 3758     index(0xffffFFFF); // noreg
 3759     scale(0x0);
 3760     disp($reg);  // Stack Offset
 3761   %}
 3762 %}
 3763 
 3764 operand stackSlotL(sRegL reg) %{
 3765   constraint(ALLOC_IN_RC(stack_slots));
 3766   op_cost(1);  //match(RegL);
 3767   format %{ &quot;[$reg(stackSlotL)]&quot; %}
 3768   interface(MEMORY_INTER) %{
 3769     base(0xf);   // Z_SP
 3770     index(0xffffFFFF); // noreg
 3771     scale(0x0);
 3772     disp($reg);  // Stack Offset
 3773   %}
 3774 %}
 3775 
 3776 // Operands for expressing Control Flow
 3777 // NOTE: Label is a predefined operand which should not be redefined in
 3778 // the AD file. It is generically handled within the ADLC.
 3779 
 3780 //----------Conditional Branch Operands----------------------------------------
 3781 // Comparison Op  - This is the operation of the comparison, and is limited to
 3782 //                  the following set of codes:
 3783 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 3784 //
 3785 // Other attributes of the comparison, such as unsignedness, are specified
 3786 // by the comparison instruction that sets a condition code flags register.
 3787 // That result is represented by a flags operand whose subtype is appropriate
 3788 // to the unsignedness (etc.) of the comparison.
 3789 //
 3790 // Later, the instruction which matches both the Comparison Op (a Bool) and
 3791 // the flags (produced by the Cmp) specifies the coding of the comparison op
 3792 // by matching a specific subtype of Bool operand below.
 3793 
 3794 // INT cmpOps for CompareAndBranch and CompareAndTrap instructions should not
 3795 // have mask bit #3 set.
 3796 operand cmpOpT() %{
 3797   match(Bool);
 3798   format %{ &quot;&quot; %}
 3799   interface(COND_INTER) %{
 3800     equal(0x8);         // Assembler::bcondEqual
 3801     not_equal(0x6);     // Assembler::bcondNotEqual
 3802     less(0x4);          // Assembler::bcondLow
 3803     greater_equal(0xa); // Assembler::bcondNotLow
 3804     less_equal(0xc);    // Assembler::bcondNotHigh
 3805     greater(0x2);       // Assembler::bcondHigh
 3806     overflow(0x1);      // Assembler::bcondOverflow
 3807     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3808   %}
 3809 %}
 3810 
 3811 // When used for floating point comparisons: unordered is treated as less.
 3812 operand cmpOpF() %{
 3813   match(Bool);
 3814   format %{ &quot;&quot; %}
 3815   interface(COND_INTER) %{
 3816     equal(0x8);
 3817     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3818     less(0x5);          // Includes &#39;unordered&#39;.
 3819     greater_equal(0xa);
 3820     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3821     greater(0x2);
 3822     overflow(0x0);      // Not meaningful on z/Architecture.
 3823     no_overflow(0x0);   // leave unchanged (zero) therefore
 3824   %}
 3825 %}
 3826 
 3827 // &quot;Regular&quot; cmpOp for int comparisons, includes bit #3 (overflow).
 3828 operand cmpOp() %{
 3829   match(Bool);
 3830   format %{ &quot;&quot; %}
 3831   interface(COND_INTER) %{
 3832     equal(0x8);
 3833     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3834     less(0x5);          // Includes &#39;unordered&#39;.
 3835     greater_equal(0xa);
 3836     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3837     greater(0x2);
 3838     overflow(0x1);      // Assembler::bcondOverflow
 3839     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3840   %}
 3841 %}
 3842 
 3843 //----------OPERAND CLASSES----------------------------------------------------
 3844 // Operand Classes are groups of operands that are used to simplify
 3845 // instruction definitions by not requiring the AD writer to specify
 3846 // seperate instructions for every form of operand when the
 3847 // instruction accepts multiple operand types with the same basic
 3848 // encoding and format.  The classic case of this is memory operands.
 3849 // Indirect is not included since its use is limited to Compare &amp; Swap
 3850 
 3851 // Most general memory operand, allows base, index, and long displacement.
 3852 opclass memory(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3853 opclass memoryRXY(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3854 
 3855 // General memory operand, allows base, index, and short displacement.
 3856 opclass memoryRX(indirect, indIndex, indOffset12, indOffset12Narrow, indOffset12index, indOffset12indexNarrow);
 3857 
 3858 // Memory operand, allows only base and long displacement.
 3859 opclass memoryRSY(indirect, indOffset20, indOffset20Narrow);
 3860 
 3861 // Memory operand, allows only base and short displacement.
 3862 opclass memoryRS(indirect, indOffset12, indOffset12Narrow);
 3863 
 3864 // Operand classes to match encode and decode.
 3865 opclass iRegN_P2N(iRegN);
 3866 opclass iRegP_N2P(iRegP);
 3867 
 3868 
 3869 //----------PIPELINE-----------------------------------------------------------
 3870 pipeline %{
 3871 
 3872 //----------ATTRIBUTES---------------------------------------------------------
 3873 attributes %{
 3874   // z/Architecture instructions are of length 2, 4, or 6 bytes.
 3875   variable_size_instructions;
 3876   instruction_unit_size = 2;
 3877 
 3878   // Meaningless on z/Architecture.
 3879   max_instructions_per_bundle = 1;
 3880 
 3881   // The z/Architecture processor fetches 64 bytes...
 3882   instruction_fetch_unit_size = 64;
 3883 
 3884   // ...in one line.
 3885   instruction_fetch_units = 1
 3886 %}
 3887 
 3888 //----------RESOURCES----------------------------------------------------------
 3889 // Resources are the functional units available to the machine.
 3890 resources(
 3891    Z_BR,     // branch unit
 3892    Z_CR,     // condition unit
 3893    Z_FX1,    // integer arithmetic unit 1
 3894    Z_FX2,    // integer arithmetic unit 2
 3895    Z_LDST1,  // load/store unit 1
 3896    Z_LDST2,  // load/store unit 2
 3897    Z_FP1,    // float arithmetic unit 1
 3898    Z_FP2,    // float arithmetic unit 2
 3899    Z_LDST = Z_LDST1 | Z_LDST2,
 3900    Z_FX   = Z_FX1 | Z_FX2,
 3901    Z_FP   = Z_FP1 | Z_FP2
 3902   );
 3903 
 3904 //----------PIPELINE DESCRIPTION-----------------------------------------------
 3905 // Pipeline Description specifies the stages in the machine&#39;s pipeline.
 3906 pipe_desc(
 3907    // TODO: adapt
 3908    Z_IF,  // instruction fetch
 3909    Z_IC,
 3910    Z_D0,  // decode
 3911    Z_D1,  // decode
 3912    Z_D2,  // decode
 3913    Z_D3,  // decode
 3914    Z_Xfer1,
 3915    Z_GD,  // group definition
 3916    Z_MP,  // map
 3917    Z_ISS, // issue
 3918    Z_RF,  // resource fetch
 3919    Z_EX1, // execute (all units)
 3920    Z_EX2, // execute (FP, LDST)
 3921    Z_EX3, // execute (FP, LDST)
 3922    Z_EX4, // execute (FP)
 3923    Z_EX5, // execute (FP)
 3924    Z_EX6, // execute (FP)
 3925    Z_WB,  // write back
 3926    Z_Xfer2,
 3927    Z_CP
 3928   );
 3929 
 3930 //----------PIPELINE CLASSES---------------------------------------------------
 3931 // Pipeline Classes describe the stages in which input and output are
 3932 // referenced by the hardware pipeline.
 3933 
 3934 // Providing the `ins_pipe&#39; declarations in the instruction
 3935 // specifications seems to be of little use. So we use
 3936 // `pipe_class_dummy&#39; for all our instructions at present.
 3937 pipe_class pipe_class_dummy() %{
 3938   single_instruction;
 3939   fixed_latency(4);
 3940 %}
 3941 
 3942 // SIGTRAP based implicit range checks in compiled code.
 3943 // Currently, no pipe classes are used on z/Architecture.
 3944 pipe_class pipe_class_trap() %{
 3945   single_instruction;
 3946 %}
 3947 
 3948 pipe_class pipe_class_fx_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 3949   single_instruction;
 3950   dst  : Z_EX1(write);
 3951   src1 : Z_RF(read);
 3952   src2 : Z_RF(read);
 3953   Z_FX : Z_RF;
 3954 %}
 3955 
 3956 pipe_class pipe_class_ldst(iRegP dst, memory mem) %{
 3957   single_instruction;
 3958   mem : Z_RF(read);
 3959   dst : Z_WB(write);
 3960   Z_LDST : Z_RF;
 3961 %}
 3962 
 3963 define %{
 3964   MachNop = pipe_class_dummy;
 3965 %}
 3966 
 3967 %}
 3968 
 3969 //----------INSTRUCTIONS-------------------------------------------------------
 3970 
 3971 //---------- Chain stack slots between similar types --------
 3972 
 3973 // Load integer from stack slot.
 3974 instruct stkI_to_regI(iRegI dst, stackSlotI src) %{
 3975   match(Set dst src);
 3976   ins_cost(MEMORY_REF_COST);
 3977   // TODO: s390 port size(FIXED_SIZE);
 3978   format %{ &quot;L       $dst,$src\t # stk reload int&quot; %}
 3979   opcode(L_ZOPC);
 3980   ins_encode(z_form_rt_mem(dst, src));
 3981   ins_pipe(pipe_class_dummy);
 3982 %}
 3983 
 3984 // Store integer to stack slot.
 3985 instruct regI_to_stkI(stackSlotI dst, iRegI src) %{
 3986   match(Set dst src);
 3987   ins_cost(MEMORY_REF_COST);
 3988   // TODO: s390 port size(FIXED_SIZE);
 3989   format %{ &quot;ST      $src,$dst\t # stk spill int&quot; %}
 3990   opcode(ST_ZOPC);
 3991   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 3992   ins_pipe(pipe_class_dummy);
 3993 %}
 3994 
 3995 // Load long from stack slot.
 3996 instruct stkL_to_regL(iRegL dst, stackSlotL src) %{
 3997   match(Set dst src);
 3998   ins_cost(MEMORY_REF_COST);
 3999   // TODO: s390 port size(FIXED_SIZE);
 4000   format %{ &quot;LG      $dst,$src\t # stk reload long&quot; %}
 4001   opcode(LG_ZOPC);
 4002   ins_encode(z_form_rt_mem(dst, src));
 4003   ins_pipe(pipe_class_dummy);
 4004 %}
 4005 
 4006 // Store long to stack slot.
 4007 instruct regL_to_stkL(stackSlotL dst, iRegL src) %{
 4008   match(Set dst src);
 4009   ins_cost(MEMORY_REF_COST);
 4010   size(6);
 4011   format %{ &quot;STG     $src,$dst\t # stk spill long&quot; %}
 4012   opcode(STG_ZOPC);
 4013   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 4014   ins_pipe(pipe_class_dummy);
 4015 %}
 4016 
 4017 // Load pointer from stack slot, 64-bit encoding.
 4018 instruct stkP_to_regP(iRegP dst, stackSlotP src) %{
 4019   match(Set dst src);
 4020   ins_cost(MEMORY_REF_COST);
 4021   // TODO: s390 port size(FIXED_SIZE);
 4022   format %{ &quot;LG      $dst,$src\t # stk reload ptr&quot; %}
 4023   opcode(LG_ZOPC);
 4024   ins_encode(z_form_rt_mem(dst, src));
 4025   ins_pipe(pipe_class_dummy);
 4026 %}
 4027 
 4028 // Store pointer to stack slot.
 4029 instruct regP_to_stkP(stackSlotP dst, iRegP src) %{
 4030   match(Set dst src);
 4031   ins_cost(MEMORY_REF_COST);
 4032   // TODO: s390 port size(FIXED_SIZE);
 4033   format %{ &quot;STG     $src,$dst\t # stk spill ptr&quot; %}
 4034   opcode(STG_ZOPC);
 4035   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 4036   ins_pipe(pipe_class_dummy);
 4037 %}
 4038 
 4039 //  Float types
 4040 
 4041 // Load float value from stack slot.
 4042 instruct stkF_to_regF(regF dst, stackSlotF src) %{
 4043   match(Set dst src);
 4044   ins_cost(MEMORY_REF_COST);
 4045   size(4);
 4046   format %{ &quot;LE(Y)   $dst,$src\t # stk reload float&quot; %}
 4047   opcode(LE_ZOPC);
 4048   ins_encode(z_form_rt_mem(dst, src));
 4049   ins_pipe(pipe_class_dummy);
 4050 %}
 4051 
 4052 // Store float value to stack slot.
 4053 instruct regF_to_stkF(stackSlotF dst, regF src) %{
 4054   match(Set dst src);
 4055   ins_cost(MEMORY_REF_COST);
 4056   size(4);
 4057   format %{ &quot;STE(Y)  $src,$dst\t # stk spill float&quot; %}
 4058   opcode(STE_ZOPC);
 4059   ins_encode(z_form_rt_mem(src, dst));
 4060   ins_pipe(pipe_class_dummy);
 4061 %}
 4062 
 4063 // Load double value from stack slot.
 4064 instruct stkD_to_regD(regD dst, stackSlotD src) %{
 4065   match(Set dst src);
 4066   ins_cost(MEMORY_REF_COST);
 4067   // TODO: s390 port size(FIXED_SIZE);
 4068   format %{ &quot;LD(Y)   $dst,$src\t # stk reload double&quot; %}
 4069   opcode(LD_ZOPC);
 4070   ins_encode(z_form_rt_mem(dst, src));
 4071   ins_pipe(pipe_class_dummy);
 4072 %}
 4073 
 4074 // Store double value to stack slot.
 4075 instruct regD_to_stkD(stackSlotD dst, regD src) %{
 4076   match(Set dst src);
 4077   ins_cost(MEMORY_REF_COST);
 4078   size(4);
 4079   format %{ &quot;STD(Y)  $src,$dst\t # stk spill double&quot; %}
 4080   opcode(STD_ZOPC);
 4081   ins_encode(z_form_rt_mem(src, dst));
 4082   ins_pipe(pipe_class_dummy);
 4083 %}
 4084 
 4085 //----------Load/Store/Move Instructions---------------------------------------
 4086 
 4087 //----------Load Instructions--------------------------------------------------
 4088 
 4089 //------------------
 4090 //  MEMORY
 4091 //------------------
 4092 
 4093 //  BYTE
 4094 // Load Byte (8bit signed)
 4095 instruct loadB(iRegI dst, memory mem) %{
 4096   match(Set dst (LoadB mem));
 4097   ins_cost(MEMORY_REF_COST);
 4098   size(Z_DISP3_SIZE);
 4099   format %{ &quot;LB      $dst, $mem\t # sign-extend byte to int&quot; %}
 4100   opcode(LB_ZOPC, LB_ZOPC);
 4101   ins_encode(z_form_rt_mem_opt(dst, mem));
 4102   ins_pipe(pipe_class_dummy);
 4103 %}
 4104 
 4105 // Load Byte (8bit signed)
 4106 instruct loadB2L(iRegL dst, memory mem) %{
 4107   match(Set dst (ConvI2L (LoadB mem)));
 4108   ins_cost(MEMORY_REF_COST);
 4109   size(Z_DISP3_SIZE);
 4110   format %{ &quot;LGB     $dst, $mem\t # sign-extend byte to long&quot; %}
 4111   opcode(LGB_ZOPC, LGB_ZOPC);
 4112   ins_encode(z_form_rt_mem_opt(dst, mem));
 4113   ins_pipe(pipe_class_dummy);
 4114 %}
 4115 
 4116 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 4117 instruct loadUB(iRegI dst, memory mem) %{
 4118   match(Set dst (LoadUB mem));
 4119   ins_cost(MEMORY_REF_COST);
 4120   size(Z_DISP3_SIZE);
 4121   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to int&quot; %}
 4122   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4123   ins_encode(z_form_rt_mem_opt(dst, mem));
 4124   ins_pipe(pipe_class_dummy);
 4125 %}
 4126 
 4127 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 4128 instruct loadUB2L(iRegL dst, memory mem) %{
 4129   match(Set dst (ConvI2L (LoadUB mem)));
 4130   ins_cost(MEMORY_REF_COST);
 4131   size(Z_DISP3_SIZE);
 4132   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to long&quot; %}
 4133   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4134   ins_encode(z_form_rt_mem_opt(dst, mem));
 4135   ins_pipe(pipe_class_dummy);
 4136 %}
 4137 
 4138 // CHAR/SHORT
 4139 
 4140 // Load Short (16bit signed)
 4141 instruct loadS(iRegI dst, memory mem) %{
 4142   match(Set dst (LoadS mem));
 4143   ins_cost(MEMORY_REF_COST);
 4144   size(Z_DISP_SIZE);
 4145   format %{ &quot;LH(Y)   $dst,$mem\t # sign-extend short to int&quot; %}
 4146   opcode(LHY_ZOPC, LH_ZOPC);
 4147   ins_encode(z_form_rt_mem_opt(dst, mem));
 4148   ins_pipe(pipe_class_dummy);
 4149 %}
 4150 
 4151 // Load Short (16bit signed)
 4152 instruct loadS2L(iRegL dst, memory mem) %{
 4153   match(Set dst (ConvI2L (LoadS mem)));
 4154   ins_cost(MEMORY_REF_COST);
 4155   size(Z_DISP3_SIZE);
 4156   format %{ &quot;LGH     $dst,$mem\t # sign-extend short to long&quot; %}
 4157   opcode(LGH_ZOPC, LGH_ZOPC);
 4158   ins_encode(z_form_rt_mem_opt(dst, mem));
 4159   ins_pipe(pipe_class_dummy);
 4160 %}
 4161 
 4162 // Load Char (16bit Unsigned)
 4163 instruct loadUS(iRegI dst, memory mem) %{
 4164   match(Set dst (LoadUS mem));
 4165   ins_cost(MEMORY_REF_COST);
 4166   size(Z_DISP3_SIZE);
 4167   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to int&quot; %}
 4168   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4169   ins_encode(z_form_rt_mem_opt(dst, mem));
 4170   ins_pipe(pipe_class_dummy);
 4171 %}
 4172 
 4173 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 4174 instruct loadUS2L(iRegL dst, memory mem) %{
 4175   match(Set dst (ConvI2L (LoadUS mem)));
 4176   ins_cost(MEMORY_REF_COST);
 4177   size(Z_DISP3_SIZE);
 4178   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to long&quot; %}
 4179   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4180   ins_encode(z_form_rt_mem_opt(dst, mem));
 4181   ins_pipe(pipe_class_dummy);
 4182 %}
 4183 
 4184 // INT
 4185 
 4186 // Load Integer
 4187 instruct loadI(iRegI dst, memory mem) %{
 4188   match(Set dst (LoadI mem));
 4189   ins_cost(MEMORY_REF_COST);
 4190   size(Z_DISP_SIZE);
 4191   format %{ &quot;L(Y)    $dst,$mem\t #&quot; %}
 4192   opcode(LY_ZOPC, L_ZOPC);
 4193   ins_encode(z_form_rt_mem_opt(dst, mem));
 4194   ins_pipe(pipe_class_dummy);
 4195 %}
 4196 
 4197 // Load and convert to long.
 4198 instruct loadI2L(iRegL dst, memory mem) %{
 4199   match(Set dst (ConvI2L (LoadI mem)));
 4200   ins_cost(MEMORY_REF_COST);
 4201   size(Z_DISP3_SIZE);
 4202   format %{ &quot;LGF     $dst,$mem\t #&quot; %}
 4203   opcode(LGF_ZOPC, LGF_ZOPC);
 4204   ins_encode(z_form_rt_mem_opt(dst, mem));
 4205   ins_pipe(pipe_class_dummy);
 4206 %}
 4207 
 4208 // Load Unsigned Integer into a Long Register
 4209 instruct loadUI2L(iRegL dst, memory mem, immL_FFFFFFFF mask) %{
 4210   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 4211   ins_cost(MEMORY_REF_COST);
 4212   size(Z_DISP3_SIZE);
 4213   format %{ &quot;LLGF    $dst,$mem\t # zero-extend int to long&quot; %}
 4214   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4215   ins_encode(z_form_rt_mem_opt(dst, mem));
 4216   ins_pipe(pipe_class_dummy);
 4217 %}
 4218 
 4219 // range = array length (=jint)
 4220 // Load Range
 4221 instruct loadRange(iRegI dst, memory mem) %{
 4222   match(Set dst (LoadRange mem));
 4223   ins_cost(MEMORY_REF_COST);
 4224   size(Z_DISP_SIZE);
 4225   format %{ &quot;L(Y)    $dst,$mem\t # range&quot; %}
 4226   opcode(LY_ZOPC, L_ZOPC);
 4227   ins_encode(z_form_rt_mem_opt(dst, mem));
 4228   ins_pipe(pipe_class_dummy);
 4229 %}
 4230 
 4231 // LONG
 4232 
 4233 // Load Long - aligned
 4234 instruct loadL(iRegL dst, memory mem) %{
 4235   match(Set dst (LoadL mem));
 4236   ins_cost(MEMORY_REF_COST);
 4237   size(Z_DISP3_SIZE);
 4238   format %{ &quot;LG      $dst,$mem\t # long&quot; %}
 4239   opcode(LG_ZOPC, LG_ZOPC);
 4240   ins_encode(z_form_rt_mem_opt(dst, mem));
 4241   ins_pipe(pipe_class_dummy);
 4242 %}
 4243 
 4244 // Load Long - UNaligned
 4245 instruct loadL_unaligned(iRegL dst, memory mem) %{
 4246   match(Set dst (LoadL_unaligned mem));
 4247   ins_cost(MEMORY_REF_COST);
 4248   size(Z_DISP3_SIZE);
 4249   format %{ &quot;LG      $dst,$mem\t # unaligned long&quot; %}
 4250   opcode(LG_ZOPC, LG_ZOPC);
 4251   ins_encode(z_form_rt_mem_opt(dst, mem));
 4252   ins_pipe(pipe_class_dummy);
 4253 %}
 4254 
 4255 
 4256 // PTR
 4257 
 4258 // Load Pointer
 4259 instruct loadP(iRegP dst, memory mem) %{
 4260   match(Set dst (LoadP mem));
 4261   ins_cost(MEMORY_REF_COST);
 4262   size(Z_DISP3_SIZE);
 4263   format %{ &quot;LG      $dst,$mem\t # ptr&quot; %}
 4264   opcode(LG_ZOPC, LG_ZOPC);
 4265   ins_encode(z_form_rt_mem_opt(dst, mem));
 4266   ins_pipe(pipe_class_dummy);
 4267 %}
 4268 
 4269 // LoadP + CastP2L
 4270 instruct castP2X_loadP(iRegL dst, memory mem) %{
 4271   match(Set dst (CastP2X (LoadP mem)));
 4272   ins_cost(MEMORY_REF_COST);
 4273   size(Z_DISP3_SIZE);
 4274   format %{ &quot;LG      $dst,$mem\t # ptr + p2x&quot; %}
 4275   opcode(LG_ZOPC, LG_ZOPC);
 4276   ins_encode(z_form_rt_mem_opt(dst, mem));
 4277   ins_pipe(pipe_class_dummy);
 4278 %}
 4279 
 4280 // Load Klass Pointer
 4281 instruct loadKlass(iRegP dst, memory mem) %{
 4282   match(Set dst (LoadKlass mem));
 4283   ins_cost(MEMORY_REF_COST);
 4284   size(Z_DISP3_SIZE);
 4285   format %{ &quot;LG      $dst,$mem\t # klass ptr&quot; %}
 4286   opcode(LG_ZOPC, LG_ZOPC);
 4287   ins_encode(z_form_rt_mem_opt(dst, mem));
 4288   ins_pipe(pipe_class_dummy);
 4289 %}
 4290 
 4291 instruct loadTOC(iRegL dst) %{
 4292   effect(DEF dst);
 4293   ins_cost(DEFAULT_COST);
 4294   // TODO: s390 port size(FIXED_SIZE);
 4295   // TODO: check why this attribute causes many unnecessary rematerializations.
 4296   //
 4297   // The graphs I saw just had high register pressure. Further the
 4298   // register TOC is loaded to is overwritten by the constant short
 4299   // after. Here something as round robin register allocation might
 4300   // help. But rematerializing seems not to hurt, jack even seems to
 4301   // improve slightly.
 4302   //
 4303   // Without this flag we get spill-split recycle sanity check
 4304   // failures in
 4305   // spec.benchmarks._228_jack.NfaState::GenerateCode. This happens in
 4306   // a block with three loadConP_dynTOC nodes and a tlsLoadP. The
 4307   // tlsLoadP has a huge amount of outs and forces the TOC down to the
 4308   // stack. Later tlsLoadP is rematerialized, leaving the register
 4309   // allocator with TOC on the stack and a badly placed reload.
 4310   ins_should_rematerialize(true);
 4311   format %{ &quot;LARL    $dst, &amp;constant_pool\t; load dynTOC&quot; %}
 4312   ins_encode %{ __ load_toc($dst$$Register); %}
 4313   ins_pipe(pipe_class_dummy);
 4314 %}
 4315 
 4316 // FLOAT
 4317 
 4318 // Load Float
 4319 instruct loadF(regF dst, memory mem) %{
 4320   match(Set dst (LoadF mem));
 4321   ins_cost(MEMORY_REF_COST);
 4322   size(Z_DISP_SIZE);
 4323   format %{ &quot;LE(Y)    $dst,$mem&quot; %}
 4324   opcode(LEY_ZOPC, LE_ZOPC);
 4325   ins_encode(z_form_rt_mem_opt(dst, mem));
 4326   ins_pipe(pipe_class_dummy);
 4327 %}
 4328 
 4329 // DOUBLE
 4330 
 4331 // Load Double
 4332 instruct loadD(regD dst, memory mem) %{
 4333   match(Set dst (LoadD mem));
 4334   ins_cost(MEMORY_REF_COST);
 4335   size(Z_DISP_SIZE);
 4336   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4337   opcode(LDY_ZOPC, LD_ZOPC);
 4338   ins_encode(z_form_rt_mem_opt(dst, mem));
 4339   ins_pipe(pipe_class_dummy);
 4340 %}
 4341 
 4342 // Load Double - UNaligned
 4343 instruct loadD_unaligned(regD dst, memory mem) %{
 4344   match(Set dst (LoadD_unaligned mem));
 4345   ins_cost(MEMORY_REF_COST);
 4346   size(Z_DISP_SIZE);
 4347   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4348   opcode(LDY_ZOPC, LD_ZOPC);
 4349   ins_encode(z_form_rt_mem_opt(dst, mem));
 4350   ins_pipe(pipe_class_dummy);
 4351 %}
 4352 
 4353 
 4354 //----------------------
 4355 //  IMMEDIATES
 4356 //----------------------
 4357 
 4358 instruct loadConI(iRegI dst, immI src) %{
 4359   match(Set dst src);
 4360   ins_cost(DEFAULT_COST);
 4361   size(6);
 4362   format %{ &quot;LGFI    $dst,$src\t # (int)&quot; %}
 4363   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4364   ins_pipe(pipe_class_dummy);
 4365 %}
 4366 
 4367 instruct loadConI16(iRegI dst, immI16 src) %{
 4368   match(Set dst src);
 4369   ins_cost(DEFAULT_COST_LOW);
 4370   size(4);
 4371   format %{ &quot;LGHI    $dst,$src\t # (int)&quot; %}
 4372   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4373   ins_pipe(pipe_class_dummy);
 4374 %}
 4375 
 4376 instruct loadConI_0(iRegI dst, immI_0 src, flagsReg cr) %{
 4377   match(Set dst src);
 4378   effect(KILL cr);
 4379   ins_cost(DEFAULT_COST_LOW);
 4380   size(4);
 4381   format %{ &quot;loadConI $dst,$src\t # (int) XGR because ZERO is loaded&quot; %}
 4382   opcode(XGR_ZOPC);
 4383   ins_encode(z_rreform(dst, dst));
 4384   ins_pipe(pipe_class_dummy);
 4385 %}
 4386 
 4387 instruct loadConUI16(iRegI dst, uimmI16 src) %{
 4388   match(Set dst src);
 4389   // TODO: s390 port size(FIXED_SIZE);
 4390   format %{ &quot;LLILL    $dst,$src&quot; %}
 4391   opcode(LLILL_ZOPC);
 4392   ins_encode(z_riform_unsigned(dst, src) );
 4393   ins_pipe(pipe_class_dummy);
 4394 %}
 4395 
 4396 // Load long constant from TOC with pcrelative address.
 4397 instruct loadConL_pcrelTOC(iRegL dst, immL src) %{
 4398   match(Set dst src);
 4399   ins_cost(MEMORY_REF_COST_LO);
 4400   size(6);
 4401   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load long $src from table&quot; %}
 4402   ins_encode %{
 4403     address long_address = __ long_constant($src$$constant);
 4404     if (long_address == NULL) {
 4405       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4406       return;
 4407     }
 4408     __ load_long_pcrelative($dst$$Register, long_address);
 4409   %}
 4410   ins_pipe(pipe_class_dummy);
 4411 %}
 4412 
 4413 instruct loadConL32(iRegL dst, immL32 src) %{
 4414   match(Set dst src);
 4415   ins_cost(DEFAULT_COST);
 4416   size(6);
 4417   format %{ &quot;LGFI     $dst,$src\t # (long)&quot; %}
 4418   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4419   ins_pipe(pipe_class_dummy);
 4420 %}
 4421 
 4422 instruct loadConL16(iRegL dst, immL16 src) %{
 4423   match(Set dst src);
 4424   ins_cost(DEFAULT_COST_LOW);
 4425   size(4);
 4426   format %{ &quot;LGHI     $dst,$src\t # (long)&quot; %}
 4427   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4428   ins_pipe(pipe_class_dummy);
 4429 %}
 4430 
 4431 instruct loadConL_0(iRegL dst, immL_0 src, flagsReg cr) %{
 4432   match(Set dst src);
 4433   effect(KILL cr);
 4434   ins_cost(DEFAULT_COST_LOW);
 4435   format %{ &quot;LoadConL    $dst,$src\t # (long) XGR because ZERO is loaded&quot; %}
 4436   opcode(XGR_ZOPC);
 4437   ins_encode(z_rreform(dst, dst));
 4438   ins_pipe(pipe_class_dummy);
 4439 %}
 4440 
 4441 // Load ptr constant from TOC with pc relative address.
 4442 // Special handling for oop constants required.
 4443 instruct loadConP_pcrelTOC(iRegP dst, immP src) %{
 4444   match(Set dst src);
 4445   ins_cost(MEMORY_REF_COST_LO);
 4446   size(6);
 4447   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load ptr $src from table&quot; %}
 4448   ins_encode %{
 4449     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();
 4450     if (constant_reloc == relocInfo::oop_type) {
 4451       AddressLiteral a = __ allocate_oop_address((jobject)$src$$constant);
 4452       bool success = __ load_oop_from_toc($dst$$Register, a);
 4453       if (!success) {
 4454         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4455         return;
 4456       }
 4457     } else if (constant_reloc == relocInfo::metadata_type) {
 4458       AddressLiteral a = __ constant_metadata_address((Metadata *)$src$$constant);
 4459       address const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 4460       if (const_toc_addr == NULL) {
 4461         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4462         return;
 4463       }
 4464       __ load_long_pcrelative($dst$$Register, const_toc_addr);
 4465     } else {          // Non-oop pointers, e.g. card mark base, heap top.
 4466       address long_address = __ long_constant((jlong)$src$$constant);
 4467       if (long_address == NULL) {
 4468         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4469         return;
 4470       }
 4471       __ load_long_pcrelative($dst$$Register, long_address);
 4472     }
 4473   %}
 4474   ins_pipe(pipe_class_dummy);
 4475 %}
 4476 
 4477 // We don&#39;t use immP16 to avoid problems with oops.
 4478 instruct loadConP0(iRegP dst, immP0 src, flagsReg cr) %{
 4479   match(Set dst src);
 4480   effect(KILL cr);
 4481   size(4);
 4482   format %{ &quot;XGR     $dst,$dst\t # NULL ptr&quot; %}
 4483   opcode(XGR_ZOPC);
 4484   ins_encode(z_rreform(dst, dst));
 4485   ins_pipe(pipe_class_dummy);
 4486 %}
 4487 
 4488 //----------Load Float Constant Instructions-------------------------------------------------
 4489 
 4490 // We may not specify this instruction via an `expand&#39; rule. If we do,
 4491 // code selection will forget that this instruction needs a floating
 4492 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4493 // will fail.
 4494 instruct loadConF_dynTOC(regF dst, immF src, flagsReg cr) %{
 4495   match(Set dst src);
 4496   effect(KILL cr);
 4497   ins_cost(MEMORY_REF_COST);
 4498   size(6);
 4499   // If this instruction rematerializes, it prolongs the live range
 4500   // of the toc node, causing illegal graphs.
 4501   ins_cannot_rematerialize(true);
 4502   format %{ &quot;LE(Y)    $dst,$constantoffset[,$constanttablebase]\t # load FLOAT $src from table&quot; %}
 4503   ins_encode %{
 4504     __ load_float_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4505   %}
 4506   ins_pipe(pipe_class_dummy);
 4507 %}
 4508 
 4509 // E may not specify this instruction via an `expand&#39; rule. If we do,
 4510 // code selection will forget that this instruction needs a floating
 4511 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4512 // will fail.
 4513 instruct loadConD_dynTOC(regD dst, immD src, flagsReg cr) %{
 4514   match(Set dst src);
 4515   effect(KILL cr);
 4516   ins_cost(MEMORY_REF_COST);
 4517   size(6);
 4518   // If this instruction rematerializes, it prolongs the live range
 4519   // of the toc node, causing illegal graphs.
 4520   ins_cannot_rematerialize(true);
 4521   format %{ &quot;LD(Y)    $dst,$constantoffset[,$constanttablebase]\t # load DOUBLE $src from table&quot; %}
 4522   ins_encode %{
 4523     __ load_double_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4524   %}
 4525   ins_pipe(pipe_class_dummy);
 4526 %}
 4527 
 4528 // Special case: Load Const 0.0F
 4529 
 4530 // There&#39;s a special instr to clear a FP register.
 4531 instruct loadConF0(regF dst, immFp0 src) %{
 4532   match(Set dst src);
 4533   ins_cost(DEFAULT_COST_LOW);
 4534   size(4);
 4535   format %{ &quot;LZER     $dst,$src\t # clear to zero&quot; %}
 4536   opcode(LZER_ZOPC);
 4537   ins_encode(z_rreform(dst, Z_F0));
 4538   ins_pipe(pipe_class_dummy);
 4539 %}
 4540 
 4541 // There&#39;s a special instr to clear a FP register.
 4542 instruct loadConD0(regD dst, immDp0 src) %{
 4543   match(Set dst src);
 4544   ins_cost(DEFAULT_COST_LOW);
 4545   size(4);
 4546   format %{ &quot;LZDR     $dst,$src\t # clear to zero&quot; %}
 4547   opcode(LZDR_ZOPC);
 4548   ins_encode(z_rreform(dst, Z_F0));
 4549   ins_pipe(pipe_class_dummy);
 4550 %}
 4551 
 4552 
 4553 //----------Store Instructions-------------------------------------------------
 4554 
 4555 // BYTE
 4556 
 4557 // Store Byte
 4558 instruct storeB(memory mem, iRegI src) %{
 4559   match(Set mem (StoreB mem src));
 4560   ins_cost(MEMORY_REF_COST);
 4561   size(Z_DISP_SIZE);
 4562   format %{ &quot;STC(Y)  $src,$mem\t # byte&quot; %}
 4563   opcode(STCY_ZOPC, STC_ZOPC);
 4564   ins_encode(z_form_rt_mem_opt(src, mem));
 4565   ins_pipe(pipe_class_dummy);
 4566 %}
 4567 
 4568 instruct storeCM(memory mem, immI_0 src) %{
 4569   match(Set mem (StoreCM mem src));
 4570   ins_cost(MEMORY_REF_COST);
 4571   // TODO: s390 port size(VARIABLE_SIZE);
 4572   format %{ &quot;STC(Y)  $src,$mem\t # CMS card-mark byte (must be 0!)&quot; %}
 4573   ins_encode %{
 4574     guarantee($mem$$index$$Register != Z_R0, &quot;content will not be used.&quot;);
 4575     if ($mem$$index$$Register != noreg) {
 4576       // Can&#39;t use clear_mem --&gt; load const zero and store character.
 4577       __ load_const_optimized(Z_R0_scratch, (long)0);
 4578       if (Immediate::is_uimm12($mem$$disp)) {
 4579         __ z_stc(Z_R0_scratch, $mem$$Address);
 4580       } else {
 4581         __ z_stcy(Z_R0_scratch, $mem$$Address);
 4582       }
 4583     } else {
 4584       __ clear_mem(Address($mem$$Address), 1);
 4585     }
 4586   %}
 4587   ins_pipe(pipe_class_dummy);
 4588 %}
 4589 
 4590 // CHAR/SHORT
 4591 
 4592 // Store Char/Short
 4593 instruct storeC(memory mem, iRegI src) %{
 4594   match(Set mem (StoreC mem src));
 4595   ins_cost(MEMORY_REF_COST);
 4596   size(Z_DISP_SIZE);
 4597   format %{ &quot;STH(Y)  $src,$mem\t # short&quot; %}
 4598   opcode(STHY_ZOPC, STH_ZOPC);
 4599   ins_encode(z_form_rt_mem_opt(src, mem));
 4600   ins_pipe(pipe_class_dummy);
 4601 %}
 4602 
 4603 // INT
 4604 
 4605 // Store Integer
 4606 instruct storeI(memory mem, iRegI src) %{
 4607   match(Set mem (StoreI mem src));
 4608   ins_cost(MEMORY_REF_COST);
 4609   size(Z_DISP_SIZE);
 4610   format %{ &quot;ST(Y)   $src,$mem\t # int&quot; %}
 4611   opcode(STY_ZOPC, ST_ZOPC);
 4612   ins_encode(z_form_rt_mem_opt(src, mem));
 4613   ins_pipe(pipe_class_dummy);
 4614 %}
 4615 
 4616 // LONG
 4617 
 4618 // Store Long
 4619 instruct storeL(memory mem, iRegL src) %{
 4620   match(Set mem (StoreL mem src));
 4621   ins_cost(MEMORY_REF_COST);
 4622   size(Z_DISP3_SIZE);
 4623   format %{ &quot;STG     $src,$mem\t # long&quot; %}
 4624   opcode(STG_ZOPC, STG_ZOPC);
 4625   ins_encode(z_form_rt_mem_opt(src, mem));
 4626   ins_pipe(pipe_class_dummy);
 4627 %}
 4628 
 4629 // PTR
 4630 
 4631 // Store Pointer
 4632 instruct storeP(memory dst, memoryRegP src) %{
 4633   match(Set dst (StoreP dst src));
 4634   ins_cost(MEMORY_REF_COST);
 4635   size(Z_DISP3_SIZE);
 4636   format %{ &quot;STG     $src,$dst\t # ptr&quot; %}
 4637   opcode(STG_ZOPC, STG_ZOPC);
 4638   ins_encode(z_form_rt_mem_opt(src, dst));
 4639   ins_pipe(pipe_class_dummy);
 4640 %}
 4641 
 4642 // FLOAT
 4643 
 4644 // Store Float
 4645 instruct storeF(memory mem, regF src) %{
 4646   match(Set mem (StoreF mem src));
 4647   ins_cost(MEMORY_REF_COST);
 4648   size(Z_DISP_SIZE);
 4649   format %{ &quot;STE(Y)   $src,$mem\t # float&quot; %}
 4650   opcode(STEY_ZOPC, STE_ZOPC);
 4651   ins_encode(z_form_rt_mem_opt(src, mem));
 4652   ins_pipe(pipe_class_dummy);
 4653 %}
 4654 
 4655 // DOUBLE
 4656 
 4657 // Store Double
 4658 instruct storeD(memory mem, regD src) %{
 4659   match(Set mem (StoreD mem src));
 4660   ins_cost(MEMORY_REF_COST);
 4661   size(Z_DISP_SIZE);
 4662   format %{ &quot;STD(Y)   $src,$mem\t # double&quot; %}
 4663   opcode(STDY_ZOPC, STD_ZOPC);
 4664   ins_encode(z_form_rt_mem_opt(src, mem));
 4665   ins_pipe(pipe_class_dummy);
 4666 %}
 4667 
 4668 // Prefetch instructions. Must be safe to execute with invalid address (cannot fault).
 4669 
 4670 // Should support match rule for PrefetchAllocation.
 4671 // Still needed after 8068977 for PrefetchAllocate.
 4672 instruct prefetchAlloc(memory mem) %{
 4673   match(PrefetchAllocation mem);
 4674   predicate(VM_Version::has_Prefetch());
 4675   ins_cost(DEFAULT_COST);
 4676   format %{ &quot;PREFETCH 2, $mem\t # Prefetch allocation, z10 only&quot; %}
 4677   ins_encode %{ __ z_pfd(0x02, $mem$$Address); %}
 4678   ins_pipe(pipe_class_dummy);
 4679 %}
 4680 
 4681 //----------Memory init instructions------------------------------------------
 4682 
 4683 // Move Immediate to 1-byte memory.
 4684 instruct memInitB(memoryRSY mem, immI8 src) %{
 4685   match(Set mem (StoreB mem src));
 4686   ins_cost(MEMORY_REF_COST);
 4687   // TODO: s390 port size(VARIABLE_SIZE);
 4688   format %{ &quot;MVI     $mem,$src\t # direct mem init 1&quot; %}
 4689   ins_encode %{
 4690     if (Immediate::is_uimm12((long)$mem$$disp)) {
 4691       __ z_mvi($mem$$Address, $src$$constant);
 4692     } else {
 4693       __ z_mviy($mem$$Address, $src$$constant);
 4694     }
 4695   %}
 4696   ins_pipe(pipe_class_dummy);
 4697 %}
 4698 
 4699 // Move Immediate to 2-byte memory.
 4700 instruct memInitC(memoryRS mem, immI16 src) %{
 4701   match(Set mem (StoreC mem src));
 4702   ins_cost(MEMORY_REF_COST);
 4703   size(6);
 4704   format %{ &quot;MVHHI   $mem,$src\t # direct mem init 2&quot; %}
 4705   opcode(MVHHI_ZOPC);
 4706   ins_encode(z_silform(mem, src));
 4707   ins_pipe(pipe_class_dummy);
 4708 %}
 4709 
 4710 // Move Immediate to 4-byte memory.
 4711 instruct memInitI(memoryRS mem, immI16 src) %{
 4712   match(Set mem (StoreI mem src));
 4713   ins_cost(MEMORY_REF_COST);
 4714   size(6);
 4715   format %{ &quot;MVHI    $mem,$src\t # direct mem init 4&quot; %}
 4716   opcode(MVHI_ZOPC);
 4717   ins_encode(z_silform(mem, src));
 4718   ins_pipe(pipe_class_dummy);
 4719 %}
 4720 
 4721 
 4722 // Move Immediate to 8-byte memory.
 4723 instruct memInitL(memoryRS mem, immL16 src) %{
 4724   match(Set mem (StoreL mem src));
 4725   ins_cost(MEMORY_REF_COST);
 4726   size(6);
 4727   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4728   opcode(MVGHI_ZOPC);
 4729   ins_encode(z_silform(mem, src));
 4730   ins_pipe(pipe_class_dummy);
 4731 %}
 4732 
 4733 // Move Immediate to 8-byte memory.
 4734 instruct memInitP(memoryRS mem, immP16 src) %{
 4735   match(Set mem (StoreP mem src));
 4736   ins_cost(MEMORY_REF_COST);
 4737   size(6);
 4738   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4739   opcode(MVGHI_ZOPC);
 4740   ins_encode(z_silform(mem, src));
 4741   ins_pipe(pipe_class_dummy);
 4742 %}
 4743 
 4744 
 4745 //----------Instructions for compressed pointers (cOop and NKlass)-------------
 4746 
 4747 // See cOop encoding classes for elaborate comment.
 4748 
 4749 // Moved here because it is needed in expand rules for encode.
 4750 // Long negation.
 4751 instruct negL_reg_reg(iRegL dst, immL_0 zero, iRegL src, flagsReg cr) %{
 4752   match(Set dst (SubL zero src));
 4753   effect(KILL cr);
 4754   size(4);
 4755   format %{ &quot;NEG     $dst, $src\t # long&quot; %}
 4756   ins_encode %{ __ z_lcgr($dst$$Register, $src$$Register); %}
 4757   ins_pipe(pipe_class_dummy);
 4758 %}
 4759 
 4760 // Load Compressed Pointer
 4761 
 4762 // Load narrow oop
 4763 instruct loadN(iRegN dst, memory mem) %{
 4764   match(Set dst (LoadN mem));
 4765   ins_cost(MEMORY_REF_COST);
 4766   size(Z_DISP3_SIZE);
 4767   format %{ &quot;LoadN   $dst,$mem\t # (cOop)&quot; %}
 4768   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4769   ins_encode(z_form_rt_mem_opt(dst, mem));
 4770   ins_pipe(pipe_class_dummy);
 4771 %}
 4772 
 4773 // Load narrow Klass Pointer
 4774 instruct loadNKlass(iRegN dst, memory mem) %{
 4775   match(Set dst (LoadNKlass mem));
 4776   ins_cost(MEMORY_REF_COST);
 4777   size(Z_DISP3_SIZE);
 4778   format %{ &quot;LoadNKlass $dst,$mem\t # (klass cOop)&quot; %}
 4779   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4780   ins_encode(z_form_rt_mem_opt(dst, mem));
 4781   ins_pipe(pipe_class_dummy);
 4782 %}
 4783 
 4784 // Load constant Compressed Pointer
 4785 
 4786 instruct loadConN(iRegN dst, immN src) %{
 4787   match(Set dst src);
 4788   ins_cost(DEFAULT_COST);
 4789   size(6);
 4790   format %{ &quot;loadConN    $dst,$src\t # (cOop)&quot; %}
 4791   ins_encode %{
 4792     AddressLiteral cOop = __ constant_oop_address((jobject)$src$$constant);
 4793     __ relocate(cOop.rspec(), 1);
 4794     __ load_narrow_oop($dst$$Register, (narrowOop)cOop.value());
 4795   %}
 4796   ins_pipe(pipe_class_dummy);
 4797 %}
 4798 
 4799 instruct loadConN0(iRegN dst, immN0 src, flagsReg cr) %{
 4800   match(Set dst src);
 4801   effect(KILL cr);
 4802   ins_cost(DEFAULT_COST_LOW);
 4803   size(4);
 4804   format %{ &quot;loadConN    $dst,$src\t # (cOop) XGR because ZERO is loaded&quot; %}
 4805   opcode(XGR_ZOPC);
 4806   ins_encode(z_rreform(dst, dst));
 4807   ins_pipe(pipe_class_dummy);
 4808 %}
 4809 
 4810 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 4811   match(Set dst src);
 4812   ins_cost(DEFAULT_COST);
 4813   size(6);
 4814   format %{ &quot;loadConNKlass $dst,$src\t # (cKlass)&quot; %}
 4815   ins_encode %{
 4816     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4817     __ relocate(NKlass.rspec(), 1);
 4818     __ load_narrow_klass($dst$$Register, (Klass*)NKlass.value());
 4819   %}
 4820   ins_pipe(pipe_class_dummy);
 4821 %}
 4822 
 4823 // Load and Decode Compressed Pointer
 4824 // optimized variants for Unscaled cOops
 4825 
 4826 instruct decodeLoadN(iRegP dst, memory mem) %{
 4827   match(Set dst (DecodeN (LoadN mem)));
 4828   predicate(false &amp;&amp; (CompressedOops::base()==NULL)&amp;&amp;(CompressedOops::shift()==0));
 4829   ins_cost(MEMORY_REF_COST);
 4830   size(Z_DISP3_SIZE);
 4831   format %{ &quot;DecodeLoadN  $dst,$mem\t # (cOop Load+Decode)&quot; %}
 4832   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4833   ins_encode(z_form_rt_mem_opt(dst, mem));
 4834   ins_pipe(pipe_class_dummy);
 4835 %}
 4836 
 4837 instruct decodeLoadNKlass(iRegP dst, memory mem) %{
 4838   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 4839   predicate(false &amp;&amp; (CompressedKlassPointers::base()==NULL)&amp;&amp;(CompressedKlassPointers::shift()==0));
 4840   ins_cost(MEMORY_REF_COST);
 4841   size(Z_DISP3_SIZE);
 4842   format %{ &quot;DecodeLoadNKlass  $dst,$mem\t # (load/decode NKlass)&quot; %}
 4843   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4844   ins_encode(z_form_rt_mem_opt(dst, mem));
 4845   ins_pipe(pipe_class_dummy);
 4846 %}
 4847 
 4848 instruct decodeLoadConNKlass(iRegP dst, immNKlass src) %{
 4849   match(Set dst (DecodeNKlass src));
 4850   ins_cost(3 * DEFAULT_COST);
 4851   size(12);
 4852   format %{ &quot;DecodeLoadConNKlass  $dst,$src\t # decode(cKlass)&quot; %}
 4853   ins_encode %{
 4854     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4855     __ relocate(NKlass.rspec(), 1);
 4856     __ load_const($dst$$Register, (Klass*)NKlass.value());
 4857   %}
 4858   ins_pipe(pipe_class_dummy);
 4859 %}
 4860 
 4861 // Decode Compressed Pointer
 4862 
 4863 // General decoder
 4864 instruct decodeN(iRegP dst, iRegN src, flagsReg cr) %{
 4865   match(Set dst (DecodeN src));
 4866   effect(KILL cr);
 4867   predicate(CompressedOops::base() == NULL || !ExpandLoadingBaseDecode);
 4868   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4869   // TODO: s390 port size(VARIABLE_SIZE);
 4870   format %{ &quot;decodeN  $dst,$src\t # (decode cOop)&quot; %}
 4871   ins_encode %{  __ oop_decoder($dst$$Register, $src$$Register, true); %}
 4872   ins_pipe(pipe_class_dummy);
 4873 %}
 4874 
 4875 // General Klass decoder
 4876 instruct decodeKlass(iRegP dst, iRegN src, flagsReg cr) %{
 4877   match(Set dst (DecodeNKlass src));
 4878   effect(KILL cr);
 4879   ins_cost(3 * DEFAULT_COST);
 4880   format %{ &quot;decode_klass $dst,$src&quot; %}
 4881   ins_encode %{ __ decode_klass_not_null($dst$$Register, $src$$Register); %}
 4882   ins_pipe(pipe_class_dummy);
 4883 %}
 4884 
 4885 // General decoder
 4886 instruct decodeN_NN(iRegP dst, iRegN src, flagsReg cr) %{
 4887   match(Set dst (DecodeN src));
 4888   effect(KILL cr);
 4889   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4890              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4891             (CompressedOops::base()== NULL || !ExpandLoadingBaseDecode_NN));
 4892   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4893   // TODO: s390 port size(VARIABLE_SIZE);
 4894   format %{ &quot;decodeN  $dst,$src\t # (decode cOop NN)&quot; %}
 4895   ins_encode %{ __ oop_decoder($dst$$Register, $src$$Register, false); %}
 4896   ins_pipe(pipe_class_dummy);
 4897 %}
 4898 
 4899   instruct loadBase(iRegL dst, immL baseImm) %{
 4900     effect(DEF dst, USE baseImm);
 4901     predicate(false);
 4902     format %{ &quot;llihl    $dst=$baseImm \t// load heap base&quot; %}
 4903     ins_encode %{ __ get_oop_base($dst$$Register, $baseImm$$constant); %}
 4904     ins_pipe(pipe_class_dummy);
 4905   %}
 4906 
 4907   // Decoder for heapbased mode peeling off loading the base.
 4908   instruct decodeN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4909     match(Set dst (DecodeN src base));
 4910     // Note: Effect TEMP dst was used with the intention to get
 4911     // different regs for dst and base, but this has caused ADLC to
 4912     // generate wrong code. Oop_decoder generates additional lgr when
 4913     // dst==base.
 4914     effect(KILL cr);
 4915     predicate(false);
 4916     // TODO: s390 port size(VARIABLE_SIZE);
 4917     format %{ &quot;decodeN  $dst = ($src == 0) ? NULL : ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}
 4918     ins_encode %{
 4919       __ oop_decoder($dst$$Register, $src$$Register, true, $base$$Register,
 4920                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));
 4921     %}
 4922     ins_pipe(pipe_class_dummy);
 4923   %}
 4924 
 4925   // Decoder for heapbased mode peeling off loading the base.
 4926   instruct decodeN_NN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4927     match(Set dst (DecodeN src base));
 4928     effect(KILL cr);
 4929     predicate(false);
 4930     // TODO: s390 port size(VARIABLE_SIZE);
 4931     format %{ &quot;decodeN  $dst = ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}
 4932     ins_encode %{
 4933       __ oop_decoder($dst$$Register, $src$$Register, false, $base$$Register,
 4934                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));
 4935     %}
 4936     ins_pipe(pipe_class_dummy);
 4937   %}
 4938 
 4939 // Decoder for heapbased mode peeling off loading the base.
 4940 instruct decodeN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4941   match(Set dst (DecodeN src));
 4942   predicate(CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode);
 4943   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4944   // TODO: s390 port size(VARIABLE_SIZE);
 4945   expand %{
 4946     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 4947     iRegL base;
 4948     loadBase(base, baseImm);
 4949     decodeN_base(dst, src, base, cr);
 4950   %}
 4951 %}
 4952 
 4953 // Decoder for heapbased mode peeling off loading the base.
 4954 instruct decodeN_NN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4955   match(Set dst (DecodeN src));
 4956   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4957              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4958             CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode_NN);
 4959   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4960   // TODO: s390 port size(VARIABLE_SIZE);
 4961   expand %{
 4962     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 4963     iRegL base;
 4964     loadBase(base, baseImm);
 4965     decodeN_NN_base(dst, src, base, cr);
 4966   %}
 4967 %}
 4968 
 4969 //  Encode Compressed Pointer
 4970 
 4971 // General encoder
 4972 instruct encodeP(iRegN dst, iRegP src, flagsReg cr) %{
 4973   match(Set dst (EncodeP src));
 4974   effect(KILL cr);
 4975   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 4976             (CompressedOops::base() == 0 ||
 4977              CompressedOops::base_disjoint() ||
 4978              !ExpandLoadingBaseEncode));
 4979   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4980   // TODO: s390 port size(VARIABLE_SIZE);
 4981   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}
 4982   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, true, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4983   ins_pipe(pipe_class_dummy);
 4984 %}
 4985 
 4986 // General class encoder
 4987 instruct encodeKlass(iRegN dst, iRegP src, flagsReg cr) %{
 4988   match(Set dst (EncodePKlass src));
 4989   effect(KILL cr);
 4990   format %{ &quot;encode_klass $dst,$src&quot; %}
 4991   ins_encode %{ __ encode_klass_not_null($dst$$Register, $src$$Register); %}
 4992   ins_pipe(pipe_class_dummy);
 4993 %}
 4994 
 4995 instruct encodeP_NN(iRegN dst, iRegP src, flagsReg cr) %{
 4996   match(Set dst (EncodeP src));
 4997   effect(KILL cr);
 4998   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 4999             (CompressedOops::base() == 0 ||
 5000              CompressedOops::base_disjoint() ||
 5001              !ExpandLoadingBaseEncode_NN));
 5002   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5003   // TODO: s390 port size(VARIABLE_SIZE);
 5004   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}
 5005   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 5006   ins_pipe(pipe_class_dummy);
 5007 %}
 5008 
 5009   // Encoder for heapbased mode peeling off loading the base.
 5010   instruct encodeP_base(iRegN dst, iRegP src, iRegL base) %{
 5011     match(Set dst (EncodeP src (Binary base dst)));
 5012     effect(TEMP_DEF dst);
 5013     predicate(false);
 5014     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5015     // TODO: s390 port size(VARIABLE_SIZE);
 5016     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + pow2_offset\t # (encode cOop)&quot; %}
 5017     ins_encode %{
 5018       jlong offset = -(jlong)MacroAssembler::get_oop_base_pow2_offset
 5019         (((uint64_t)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift());
 5020       __ oop_encoder($dst$$Register, $src$$Register, true, $base$$Register, offset);
 5021     %}
 5022     ins_pipe(pipe_class_dummy);
 5023   %}
 5024 
 5025   // Encoder for heapbased mode peeling off loading the base.
 5026   instruct encodeP_NN_base(iRegN dst, iRegP src, iRegL base, immL pow2_offset) %{
 5027     match(Set dst (EncodeP src base));
 5028     effect(USE pow2_offset);
 5029     predicate(false);
 5030     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5031     // TODO: s390 port size(VARIABLE_SIZE);
 5032     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + $pow2_offset\t # (encode cOop)&quot; %}
 5033     ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, $base$$Register, $pow2_offset$$constant); %}
 5034     ins_pipe(pipe_class_dummy);
 5035   %}
 5036 
 5037 // Encoder for heapbased mode peeling off loading the base.
 5038 instruct encodeP_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5039   match(Set dst (EncodeP src));
 5040   effect(KILL cr);
 5041   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 5042             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode));
 5043   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5044   // TODO: s390 port size(VARIABLE_SIZE);
 5045   expand %{
 5046     immL baseImm %{ ((jlong)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift() %}
 5047     immL_0 zero %{ (0) %}
 5048     flagsReg ccr;
 5049     iRegL base;
 5050     iRegL negBase;
 5051     loadBase(base, baseImm);
 5052     negL_reg_reg(negBase, zero, base, ccr);
 5053     encodeP_base(dst, src, negBase);
 5054   %}
 5055 %}
 5056 
 5057 // Encoder for heapbased mode peeling off loading the base.
 5058 instruct encodeP_NN_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5059   match(Set dst (EncodeP src));
 5060   effect(KILL cr);
 5061   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 5062             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode_NN));
 5063   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5064   // TODO: s390 port size(VARIABLE_SIZE);
 5065   expand %{
 5066     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 5067     immL pow2_offset %{ -(jlong)MacroAssembler::get_oop_base_pow2_offset(((uint64_t)(intptr_t)CompressedOops::base())) %}
 5068     immL_0 zero %{ 0 %}
 5069     flagsReg ccr;
 5070     iRegL base;
 5071     iRegL negBase;
 5072     loadBase(base, baseImm);
 5073     negL_reg_reg(negBase, zero, base, ccr);
 5074     encodeP_NN_base(dst, src, negBase, pow2_offset);
 5075   %}
 5076 %}
 5077 
 5078 //  Store Compressed Pointer
 5079 
 5080 // Store Compressed Pointer
 5081 instruct storeN(memory mem, iRegN_P2N src) %{
 5082   match(Set mem (StoreN mem src));
 5083   ins_cost(MEMORY_REF_COST);
 5084   size(Z_DISP_SIZE);
 5085   format %{ &quot;ST      $src,$mem\t # (cOop)&quot; %}
 5086   opcode(STY_ZOPC, ST_ZOPC);
 5087   ins_encode(z_form_rt_mem_opt(src, mem));
 5088   ins_pipe(pipe_class_dummy);
 5089 %}
 5090 
 5091 // Store Compressed Klass pointer
 5092 instruct storeNKlass(memory mem, iRegN src) %{
 5093   match(Set mem (StoreNKlass mem src));
 5094   ins_cost(MEMORY_REF_COST);
 5095   size(Z_DISP_SIZE);
 5096   format %{ &quot;ST      $src,$mem\t # (cKlass)&quot; %}
 5097   opcode(STY_ZOPC, ST_ZOPC);
 5098   ins_encode(z_form_rt_mem_opt(src, mem));
 5099   ins_pipe(pipe_class_dummy);
 5100 %}
 5101 
 5102 // Compare Compressed Pointers
 5103 
 5104 instruct compN_iRegN(iRegN_P2N src1, iRegN_P2N src2, flagsReg cr) %{
 5105   match(Set cr (CmpN src1 src2));
 5106   ins_cost(DEFAULT_COST);
 5107   size(2);
 5108   format %{ &quot;CLR     $src1,$src2\t # (cOop)&quot; %}
 5109   opcode(CLR_ZOPC);
 5110   ins_encode(z_rrform(src1, src2));
 5111   ins_pipe(pipe_class_dummy);
 5112 %}
 5113 
 5114 instruct compN_iRegN_immN(iRegN_P2N src1, immN src2, flagsReg cr) %{
 5115   match(Set cr (CmpN src1 src2));
 5116   ins_cost(DEFAULT_COST);
 5117   size(6);
 5118   format %{ &quot;CLFI    $src1,$src2\t # (cOop) compare immediate narrow&quot; %}
 5119   ins_encode %{
 5120     AddressLiteral cOop = __ constant_oop_address((jobject)$src2$$constant);
 5121     __ relocate(cOop.rspec(), 1);
 5122     __ compare_immediate_narrow_oop($src1$$Register, (narrowOop)cOop.value());
 5123   %}
 5124   ins_pipe(pipe_class_dummy);
 5125 %}
 5126 
 5127 instruct compNKlass_iRegN_immN(iRegN src1, immNKlass src2, flagsReg cr) %{
 5128   match(Set cr (CmpN src1 src2));
 5129   ins_cost(DEFAULT_COST);
 5130   size(6);
 5131   format %{ &quot;CLFI    $src1,$src2\t # (NKlass) compare immediate narrow&quot; %}
 5132   ins_encode %{
 5133     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src2$$constant);
 5134     __ relocate(NKlass.rspec(), 1);
 5135     __ compare_immediate_narrow_klass($src1$$Register, (Klass*)NKlass.value());
 5136   %}
 5137   ins_pipe(pipe_class_dummy);
 5138 %}
 5139 
 5140 instruct compN_iRegN_immN0(iRegN_P2N src1, immN0 src2, flagsReg cr) %{
 5141   match(Set cr (CmpN src1 src2));
 5142   ins_cost(DEFAULT_COST);
 5143   size(2);
 5144   format %{ &quot;LTR     $src1,$src2\t # (cOop) LTR because comparing against zero&quot; %}
 5145   opcode(LTR_ZOPC);
 5146   ins_encode(z_rrform(src1, src1));
 5147   ins_pipe(pipe_class_dummy);
 5148 %}
 5149 
 5150 
 5151 //----------MemBar Instructions-----------------------------------------------
 5152 
 5153 // Memory barrier flavors
 5154 
 5155 instruct membar_acquire() %{
 5156   match(MemBarAcquire);
 5157   match(LoadFence);
 5158   ins_cost(4*MEMORY_REF_COST);
 5159   size(0);
 5160   format %{ &quot;MEMBAR-acquire&quot; %}
 5161   ins_encode %{ __ z_acquire(); %}
 5162   ins_pipe(pipe_class_dummy);
 5163 %}
 5164 
 5165 instruct membar_acquire_lock() %{
 5166   match(MemBarAcquireLock);
 5167   ins_cost(0);
 5168   size(0);
 5169   format %{ &quot;MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 5170   ins_encode(/*empty*/);
 5171   ins_pipe(pipe_class_dummy);
 5172 %}
 5173 
 5174 instruct membar_release() %{
 5175   match(MemBarRelease);
 5176   match(StoreFence);
 5177   ins_cost(4 * MEMORY_REF_COST);
 5178   size(0);
 5179   format %{ &quot;MEMBAR-release&quot; %}
 5180   ins_encode %{ __ z_release(); %}
 5181   ins_pipe(pipe_class_dummy);
 5182 %}
 5183 
 5184 instruct membar_release_lock() %{
 5185   match(MemBarReleaseLock);
 5186   ins_cost(0);
 5187   size(0);
 5188   format %{ &quot;MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 5189   ins_encode(/*empty*/);
 5190   ins_pipe(pipe_class_dummy);
 5191 %}
 5192 
 5193 instruct membar_volatile() %{
 5194   match(MemBarVolatile);
 5195   ins_cost(4 * MEMORY_REF_COST);
 5196   size(2);
 5197   format %{ &quot;MEMBAR-volatile&quot; %}
 5198   ins_encode %{ __ z_fence(); %}
 5199   ins_pipe(pipe_class_dummy);
 5200 %}
 5201 
 5202 instruct unnecessary_membar_volatile() %{
 5203   match(MemBarVolatile);
 5204   predicate(Matcher::post_store_load_barrier(n));
 5205   ins_cost(0);
 5206   size(0);
 5207   format %{ &quot;# MEMBAR-volatile (empty)&quot; %}
 5208   ins_encode(/*empty*/);
 5209   ins_pipe(pipe_class_dummy);
 5210 %}
 5211 
 5212 instruct membar_CPUOrder() %{
 5213   match(MemBarCPUOrder);
 5214   ins_cost(0);
 5215   // TODO: s390 port size(FIXED_SIZE);
 5216   format %{ &quot;MEMBAR-CPUOrder (empty)&quot; %}
 5217   ins_encode(/*empty*/);
 5218   ins_pipe(pipe_class_dummy);
 5219 %}
 5220 
 5221 instruct membar_storestore() %{
 5222   match(MemBarStoreStore);
 5223   ins_cost(0);
 5224   size(0);
 5225   format %{ &quot;MEMBAR-storestore (empty)&quot; %}
 5226   ins_encode();
 5227   ins_pipe(pipe_class_dummy);
 5228 %}
 5229 
 5230 
 5231 //----------Register Move Instructions-----------------------------------------
 5232 instruct roundDouble_nop(regD dst) %{
 5233   match(Set dst (RoundDouble dst));
 5234   ins_cost(0);
 5235   // TODO: s390 port size(FIXED_SIZE);
 5236   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5237   ins_encode();
 5238   ins_pipe(pipe_class_dummy);
 5239 %}
 5240 
 5241 instruct roundFloat_nop(regF dst) %{
 5242   match(Set dst (RoundFloat dst));
 5243   ins_cost(0);
 5244   // TODO: s390 port size(FIXED_SIZE);
 5245   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5246   ins_encode();
 5247   ins_pipe(pipe_class_dummy);
 5248 %}
 5249 
 5250 // Cast Long to Pointer for unsafe natives.
 5251 instruct castX2P(iRegP dst, iRegL src) %{
 5252   match(Set dst (CastX2P src));
 5253   // TODO: s390 port size(VARIABLE_SIZE);
 5254   format %{ &quot;LGR     $dst,$src\t # CastX2P&quot; %}
 5255   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5256   ins_pipe(pipe_class_dummy);
 5257 %}
 5258 
 5259 // Cast Pointer to Long for unsafe natives.
 5260 instruct castP2X(iRegL dst, iRegP_N2P src) %{
 5261   match(Set dst (CastP2X src));
 5262   // TODO: s390 port size(VARIABLE_SIZE);
 5263   format %{ &quot;LGR     $dst,$src\t # CastP2X&quot; %}
 5264   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5265   ins_pipe(pipe_class_dummy);
 5266 %}
 5267 
 5268 instruct stfSSD(stackSlotD stkSlot, regD src) %{
 5269   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5270   match(Set stkSlot src);   // chain rule
 5271   ins_cost(MEMORY_REF_COST);
 5272   // TODO: s390 port size(FIXED_SIZE);
 5273   format %{ &quot; STD   $src,$stkSlot\t # stk&quot; %}
 5274   opcode(STD_ZOPC);
 5275   ins_encode(z_form_rt_mem(src, stkSlot));
 5276   ins_pipe(pipe_class_dummy);
 5277 %}
 5278 
 5279 instruct stfSSF(stackSlotF stkSlot, regF src) %{
 5280   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5281   match(Set stkSlot src);   // chain rule
 5282   ins_cost(MEMORY_REF_COST);
 5283   // TODO: s390 port size(FIXED_SIZE);
 5284   format %{ &quot;STE   $src,$stkSlot\t # stk&quot; %}
 5285   opcode(STE_ZOPC);
 5286   ins_encode(z_form_rt_mem(src, stkSlot));
 5287   ins_pipe(pipe_class_dummy);
 5288 %}
 5289 
 5290 //----------Conditional Move---------------------------------------------------
 5291 
 5292 instruct cmovN_reg(cmpOp cmp, flagsReg cr, iRegN dst, iRegN_P2N src) %{
 5293   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5294   ins_cost(DEFAULT_COST + BRANCH_COST);
 5295   // TODO: s390 port size(VARIABLE_SIZE);
 5296   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5297   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5298   ins_pipe(pipe_class_dummy);
 5299 %}
 5300 
 5301 instruct cmovN_imm(cmpOp cmp, flagsReg cr, iRegN dst, immN0 src) %{
 5302   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5303   ins_cost(DEFAULT_COST + BRANCH_COST);
 5304   // TODO: s390 port size(VARIABLE_SIZE);
 5305   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5306   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5307   ins_pipe(pipe_class_dummy);
 5308 %}
 5309 
 5310 instruct cmovI_reg(cmpOp cmp, flagsReg cr, iRegI dst, iRegI src) %{
 5311   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5312   ins_cost(DEFAULT_COST + BRANCH_COST);
 5313   // TODO: s390 port size(VARIABLE_SIZE);
 5314   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5315   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5316   ins_pipe(pipe_class_dummy);
 5317 %}
 5318 
 5319 instruct cmovI_imm(cmpOp cmp, flagsReg cr, iRegI dst, immI16 src) %{
 5320   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5321   ins_cost(DEFAULT_COST + BRANCH_COST);
 5322   // TODO: s390 port size(VARIABLE_SIZE);
 5323   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5324   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5325   ins_pipe(pipe_class_dummy);
 5326 %}
 5327 
 5328 instruct cmovP_reg(cmpOp cmp, flagsReg cr, iRegP dst, iRegP_N2P src) %{
 5329   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5330   ins_cost(DEFAULT_COST + BRANCH_COST);
 5331   // TODO: s390 port size(VARIABLE_SIZE);
 5332   format %{ &quot;CMoveP,$cmp    $dst,$src&quot; %}
 5333   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5334   ins_pipe(pipe_class_dummy);
 5335 %}
 5336 
 5337 instruct cmovP_imm(cmpOp cmp, flagsReg cr, iRegP dst, immP0 src) %{
 5338   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5339   ins_cost(DEFAULT_COST + BRANCH_COST);
 5340   // TODO: s390 port size(VARIABLE_SIZE);
 5341   format %{ &quot;CMoveP,$cmp  $dst,$src&quot; %}
 5342   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5343   ins_pipe(pipe_class_dummy);
 5344 %}
 5345 
 5346 instruct cmovF_reg(cmpOpF cmp, flagsReg cr, regF dst, regF src) %{
 5347   match(Set dst (CMoveF (Binary cmp cr) (Binary dst src)));
 5348   ins_cost(DEFAULT_COST + BRANCH_COST);
 5349   // TODO: s390 port size(VARIABLE_SIZE);
 5350   format %{ &quot;CMoveF,$cmp   $dst,$src&quot; %}
 5351   ins_encode %{
 5352     // Don&#39;t emit code if operands are identical (same register).
 5353     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5354       Label done;
 5355       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5356       __ z_ler($dst$$FloatRegister, $src$$FloatRegister);
 5357       __ bind(done);
 5358     }
 5359   %}
 5360   ins_pipe(pipe_class_dummy);
 5361 %}
 5362 
 5363 instruct cmovD_reg(cmpOpF cmp, flagsReg cr, regD dst, regD src) %{
 5364   match(Set dst (CMoveD (Binary cmp cr) (Binary dst src)));
 5365   ins_cost(DEFAULT_COST + BRANCH_COST);
 5366   // TODO: s390 port size(VARIABLE_SIZE);
 5367   format %{ &quot;CMoveD,$cmp   $dst,$src&quot; %}
 5368   ins_encode %{
 5369     // Don&#39;t emit code if operands are identical (same register).
 5370     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5371       Label done;
 5372       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5373       __ z_ldr($dst$$FloatRegister, $src$$FloatRegister);
 5374       __ bind(done);
 5375     }
 5376   %}
 5377   ins_pipe(pipe_class_dummy);
 5378 %}
 5379 
 5380 instruct cmovL_reg(cmpOp cmp, flagsReg cr, iRegL dst, iRegL src) %{
 5381   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5382   ins_cost(DEFAULT_COST + BRANCH_COST);
 5383   // TODO: s390 port size(VARIABLE_SIZE);
 5384   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5385   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5386   ins_pipe(pipe_class_dummy);
 5387 %}
 5388 
 5389 instruct cmovL_imm(cmpOp cmp, flagsReg cr, iRegL dst, immL16 src) %{
 5390   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5391   ins_cost(DEFAULT_COST + BRANCH_COST);
 5392   // TODO: s390 port size(VARIABLE_SIZE);
 5393   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5394   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5395   ins_pipe(pipe_class_dummy);
 5396 %}
 5397 
 5398 //----------OS and Locking Instructions----------------------------------------
 5399 
 5400 // This name is KNOWN by the ADLC and cannot be changed.
 5401 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 5402 // for this guy.
 5403 instruct tlsLoadP(threadRegP dst) %{
 5404   match(Set dst (ThreadLocal));
 5405   ins_cost(0);
 5406   size(0);
 5407   ins_should_rematerialize(true);
 5408   format %{ &quot;# $dst=ThreadLocal&quot; %}
 5409   ins_encode(/* empty */);
 5410   ins_pipe(pipe_class_dummy);
 5411 %}
 5412 
 5413 instruct checkCastPP(iRegP dst) %{
 5414   match(Set dst (CheckCastPP dst));
 5415   size(0);
 5416   format %{ &quot;# checkcastPP of $dst&quot; %}
 5417   ins_encode(/*empty*/);
 5418   ins_pipe(pipe_class_dummy);
 5419 %}
 5420 
 5421 instruct castPP(iRegP dst) %{
 5422   match(Set dst (CastPP dst));
 5423   size(0);
 5424   format %{ &quot;# castPP of $dst&quot; %}
 5425   ins_encode(/*empty*/);
 5426   ins_pipe(pipe_class_dummy);
 5427 %}
 5428 
 5429 instruct castII(iRegI dst) %{
 5430   match(Set dst (CastII dst));
 5431   size(0);
 5432   format %{ &quot;# castII of $dst&quot; %}
 5433   ins_encode(/*empty*/);
 5434   ins_pipe(pipe_class_dummy);
 5435 %}
 5436 
 5437 
 5438 //----------Conditional_store--------------------------------------------------
 5439 // Conditional-store of the updated heap-top.
 5440 // Used during allocation of the shared heap.
 5441 // Sets flags (EQ) on success.
 5442 
 5443 // Implement LoadPLocked. Must be ordered against changes of the memory location
 5444 // by storePConditional.
 5445 // Don&#39;t know whether this is ever used.
 5446 instruct loadPLocked(iRegP dst, memory mem) %{
 5447   match(Set dst (LoadPLocked mem));
 5448   ins_cost(MEMORY_REF_COST);
 5449   size(Z_DISP3_SIZE);
 5450   format %{ &quot;LG      $dst,$mem\t # LoadPLocked&quot; %}
 5451   opcode(LG_ZOPC, LG_ZOPC);
 5452   ins_encode(z_form_rt_mem_opt(dst, mem));
 5453   ins_pipe(pipe_class_dummy);
 5454 %}
 5455 
 5456 // As compareAndSwapP, but return flag register instead of boolean value in
 5457 // int register.
 5458 // This instruction is matched if UseTLAB is off. Needed to pass
 5459 // option tests.  Mem_ptr must be a memory operand, else this node
 5460 // does not get Flag_needs_anti_dependence_check set by adlc. If this
 5461 // is not set this node can be rematerialized which leads to errors.
 5462 instruct storePConditional(indirect mem_ptr, rarg5RegP oldval, iRegP_N2P newval, flagsReg cr) %{
 5463   match(Set cr (StorePConditional mem_ptr (Binary oldval newval)));
 5464   effect(KILL oldval);
 5465   // TODO: s390 port size(FIXED_SIZE);
 5466   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5467   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5468   ins_pipe(pipe_class_dummy);
 5469 %}
 5470 
 5471 // As compareAndSwapL, but return flag register instead of boolean value in
 5472 // int register.
 5473 // Used by sun/misc/AtomicLongCSImpl.java. Mem_ptr must be a memory
 5474 // operand, else this node does not get
 5475 // Flag_needs_anti_dependence_check set by adlc. If this is not set
 5476 // this node can be rematerialized which leads to errors.
 5477 instruct storeLConditional(indirect mem_ptr, rarg5RegL oldval, iRegL newval, flagsReg cr) %{
 5478   match(Set cr (StoreLConditional mem_ptr (Binary oldval newval)));
 5479   effect(KILL oldval);
 5480   // TODO: s390 port size(FIXED_SIZE);
 5481   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5482   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5483   ins_pipe(pipe_class_dummy);
 5484 %}
 5485 
 5486 // No flag versions for CompareAndSwap{P,I,L,N} because matcher can&#39;t match them.
 5487 
 5488 instruct compareAndSwapI_bool(iRegP mem_ptr, rarg5RegI oldval, iRegI newval, iRegI res, flagsReg cr) %{
 5489   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 5490   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5491   size(16);
 5492   format %{ &quot;$res = CompareAndSwapI $oldval,$newval,$mem_ptr&quot; %}
 5493   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5494              z_enc_cctobool(res));
 5495   ins_pipe(pipe_class_dummy);
 5496 %}
 5497 
 5498 instruct compareAndSwapL_bool(iRegP mem_ptr, rarg5RegL oldval, iRegL newval, iRegI res, flagsReg cr) %{
 5499   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 5500   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5501   size(18);
 5502   format %{ &quot;$res = CompareAndSwapL $oldval,$newval,$mem_ptr&quot; %}
 5503   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5504              z_enc_cctobool(res));
 5505   ins_pipe(pipe_class_dummy);
 5506 %}
 5507 
 5508 instruct compareAndSwapP_bool(iRegP mem_ptr, rarg5RegP oldval, iRegP_N2P newval, iRegI res, flagsReg cr) %{
 5509   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 5510   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5511   size(18);
 5512   format %{ &quot;$res = CompareAndSwapP $oldval,$newval,$mem_ptr&quot; %}
 5513   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5514              z_enc_cctobool(res));
 5515   ins_pipe(pipe_class_dummy);
 5516 %}
 5517 
 5518 instruct compareAndSwapN_bool(iRegP mem_ptr, rarg5RegN oldval, iRegN_P2N newval, iRegI res, flagsReg cr) %{
 5519   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 5520   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5521   size(16);
 5522   format %{ &quot;$res = CompareAndSwapN $oldval,$newval,$mem_ptr&quot; %}
 5523   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5524              z_enc_cctobool(res));
 5525   ins_pipe(pipe_class_dummy);
 5526 %}
 5527 
 5528 //----------Atomic operations on memory (GetAndSet*, GetAndAdd*)---------------
 5529 
 5530 // Exploit: direct memory arithmetic
 5531 // Prereqs: - instructions available
 5532 //          - instructions guarantee atomicity
 5533 //          - immediate operand to be added
 5534 //          - immediate operand is small enough (8-bit signed).
 5535 //          - result of instruction is not used
 5536 instruct addI_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immI8 src, flagsReg cr) %{
 5537   match(Set dummy (GetAndAddI mem src));
 5538   effect(KILL cr);
 5539   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5540   ins_cost(MEMORY_REF_COST);
 5541   size(6);
 5542   format %{ &quot;ASI     [$mem],$src\t # GetAndAddI (atomic)&quot; %}
 5543   opcode(ASI_ZOPC);
 5544   ins_encode(z_siyform(mem, src));
 5545   ins_pipe(pipe_class_dummy);
 5546 %}
 5547 
 5548 // Fallback: direct memory arithmetic not available
 5549 // Disadvantages: - CS-Loop required, very expensive.
 5550 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5551 instruct addI_mem_imm16_atomic(memoryRSY mem, iRegI dst, immI16 src, iRegI tmp, flagsReg cr) %{
 5552   match(Set dst (GetAndAddI mem src));
 5553   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5554   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5555   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5556             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5557             &quot;  AHIK    $tmp,$dst,$src\n\t&quot;
 5558             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5559             &quot;  retry if failed\n\t&quot;
 5560             &quot;} END ATOMIC&quot;
 5561          %}
 5562   ins_encode %{
 5563     Register Rdst = $dst$$Register;
 5564     Register Rtmp = $tmp$$Register;
 5565     int      Isrc = $src$$constant;
 5566     Label    retry;
 5567 
 5568     // Iterate until update with incremented value succeeds.
 5569     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5570     __ bind(retry);
 5571       // Calculate incremented value.
 5572       if (VM_Version::has_DistinctOpnds()) {
 5573         __ z_ahik(Rtmp, Rdst, Isrc);
 5574       } else {
 5575         __ z_lr(Rtmp, Rdst);
 5576         __ z_ahi(Rtmp, Isrc);
 5577       }
 5578       // Swap into memory location.
 5579       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5580     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5581   %}
 5582   ins_pipe(pipe_class_dummy);
 5583 %}
 5584 
 5585 instruct addI_mem_imm32_atomic(memoryRSY mem, iRegI dst, immI src, iRegI tmp, flagsReg cr) %{
 5586   match(Set dst (GetAndAddI mem src));
 5587   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5588   ins_cost(MEMORY_REF_COST+200*DEFAULT_COST);
 5589   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5590             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5591             &quot;  LGR     $tmp,$dst\n\t&quot;
 5592             &quot;  AFI     $tmp,$src\n\t&quot;
 5593             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5594             &quot;  retry if failed\n\t&quot;
 5595             &quot;} END ATOMIC&quot;
 5596          %}
 5597   ins_encode %{
 5598     Register Rdst = $dst$$Register;
 5599     Register Rtmp = $tmp$$Register;
 5600     int      Isrc = $src$$constant;
 5601     Label    retry;
 5602 
 5603     // Iterate until update with incremented value succeeds.
 5604     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5605     __ bind(retry);
 5606       // Calculate incremented value.
 5607       __ z_lr(Rtmp, Rdst);
 5608       __ z_afi(Rtmp, Isrc);
 5609       // Swap into memory location.
 5610       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5611     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5612   %}
 5613   ins_pipe(pipe_class_dummy);
 5614 %}
 5615 
 5616 instruct addI_mem_reg_atomic(memoryRSY mem, iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
 5617   match(Set dst (GetAndAddI mem src));
 5618   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5619   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5620   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5621             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5622             &quot;  ARK     $tmp,$dst,$src\n\t&quot;
 5623             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5624             &quot;  retry if failed\n\t&quot;
 5625             &quot;} END ATOMIC&quot;
 5626          %}
 5627   ins_encode %{
 5628     Register Rsrc = $src$$Register;
 5629     Register Rdst = $dst$$Register;
 5630     Register Rtmp = $tmp$$Register;
 5631     Label    retry;
 5632 
 5633     // Iterate until update with incremented value succeeds.
 5634     __ z_lgf(Rdst, $mem$$Address);  // current contents
 5635     __ bind(retry);
 5636       // Calculate incremented value.
 5637       if (VM_Version::has_DistinctOpnds()) {
 5638         __ z_ark(Rtmp, Rdst, Rsrc);
 5639       } else {
 5640         __ z_lr(Rtmp, Rdst);
 5641         __ z_ar(Rtmp, Rsrc);
 5642       }
 5643       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5644     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5645   %}
 5646   ins_pipe(pipe_class_dummy);
 5647 %}
 5648 
 5649 
 5650 // Exploit: direct memory arithmetic
 5651 // Prereqs: - instructions available
 5652 //          - instructions guarantee atomicity
 5653 //          - immediate operand to be added
 5654 //          - immediate operand is small enough (8-bit signed).
 5655 //          - result of instruction is not used
 5656 instruct addL_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immL8 src, flagsReg cr) %{
 5657   match(Set dummy (GetAndAddL mem src));
 5658   effect(KILL cr);
 5659   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5660   ins_cost(MEMORY_REF_COST);
 5661   size(6);
 5662   format %{ &quot;AGSI    [$mem],$src\t # GetAndAddL (atomic)&quot; %}
 5663   opcode(AGSI_ZOPC);
 5664   ins_encode(z_siyform(mem, src));
 5665   ins_pipe(pipe_class_dummy);
 5666 %}
 5667 
 5668 // Fallback: direct memory arithmetic not available
 5669 // Disadvantages: - CS-Loop required, very expensive.
 5670 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5671 instruct addL_mem_imm16_atomic(memoryRSY mem, iRegL dst, immL16 src, iRegL tmp, flagsReg cr) %{
 5672   match(Set dst (GetAndAddL mem src));
 5673   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5674   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5675   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5676             &quot;  LG      $dst,[$mem]\n\t&quot;
 5677             &quot;  AGHIK   $tmp,$dst,$src\n\t&quot;
 5678             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5679             &quot;  retry if failed\n\t&quot;
 5680             &quot;} END ATOMIC&quot;
 5681          %}
 5682   ins_encode %{
 5683     Register Rdst = $dst$$Register;
 5684     Register Rtmp = $tmp$$Register;
 5685     int      Isrc = $src$$constant;
 5686     Label    retry;
 5687 
 5688     // Iterate until update with incremented value succeeds.
 5689     __ z_lg(Rdst, $mem$$Address);  // current contents
 5690     __ bind(retry);
 5691       // Calculate incremented value.
 5692       if (VM_Version::has_DistinctOpnds()) {
 5693         __ z_aghik(Rtmp, Rdst, Isrc);
 5694       } else {
 5695         __ z_lgr(Rtmp, Rdst);
 5696         __ z_aghi(Rtmp, Isrc);
 5697       }
 5698       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5699     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5700   %}
 5701   ins_pipe(pipe_class_dummy);
 5702 %}
 5703 
 5704 instruct addL_mem_imm32_atomic(memoryRSY mem, iRegL dst, immL32 src, iRegL tmp, flagsReg cr) %{
 5705   match(Set dst (GetAndAddL mem src));
 5706   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5707   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5708   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5709             &quot;  LG      $dst,[$mem]\n\t&quot;
 5710             &quot;  LGR     $tmp,$dst\n\t&quot;
 5711             &quot;  AGFI    $tmp,$src\n\t&quot;
 5712             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5713             &quot;  retry if failed\n\t&quot;
 5714             &quot;} END ATOMIC&quot;
 5715          %}
 5716   ins_encode %{
 5717     Register Rdst = $dst$$Register;
 5718     Register Rtmp = $tmp$$Register;
 5719     int      Isrc = $src$$constant;
 5720     Label    retry;
 5721 
 5722     // Iterate until update with incremented value succeeds.
 5723     __ z_lg(Rdst, $mem$$Address);  // current contents
 5724     __ bind(retry);
 5725       // Calculate incremented value.
 5726       __ z_lgr(Rtmp, Rdst);
 5727       __ z_agfi(Rtmp, Isrc);
 5728       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5729     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5730   %}
 5731   ins_pipe(pipe_class_dummy);
 5732 %}
 5733 
 5734 instruct addL_mem_reg_atomic(memoryRSY mem, iRegL dst, iRegL src, iRegL tmp, flagsReg cr) %{
 5735   match(Set dst (GetAndAddL mem src));
 5736   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5737   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5738   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5739             &quot;  LG      $dst,[$mem]\n\t&quot;
 5740             &quot;  AGRK    $tmp,$dst,$src\n\t&quot;
 5741             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5742             &quot;  retry if failed\n\t&quot;
 5743             &quot;} END ATOMIC&quot;
 5744          %}
 5745   ins_encode %{
 5746     Register Rsrc = $src$$Register;
 5747     Register Rdst = $dst$$Register;
 5748     Register Rtmp = $tmp$$Register;
 5749     Label    retry;
 5750 
 5751     // Iterate until update with incremented value succeeds.
 5752     __ z_lg(Rdst, $mem$$Address);  // current contents
 5753     __ bind(retry);
 5754       // Calculate incremented value.
 5755       if (VM_Version::has_DistinctOpnds()) {
 5756         __ z_agrk(Rtmp, Rdst, Rsrc);
 5757       } else {
 5758         __ z_lgr(Rtmp, Rdst);
 5759         __ z_agr(Rtmp, Rsrc);
 5760       }
 5761       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5762     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5763   %}
 5764   ins_pipe(pipe_class_dummy);
 5765 %}
 5766 
 5767 // Increment value in memory, save old value in dst.
 5768 instruct addI_mem_reg_atomic_z196(memoryRSY mem, iRegI dst, iRegI src) %{
 5769   match(Set dst (GetAndAddI mem src));
 5770   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5771   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5772   size(6);
 5773   format %{ &quot;LAA     $dst,$src,[$mem]&quot; %}
 5774   ins_encode %{ __ z_laa($dst$$Register, $src$$Register, $mem$$Address); %}
 5775   ins_pipe(pipe_class_dummy);
 5776 %}
 5777 
 5778 // Increment value in memory, save old value in dst.
 5779 instruct addL_mem_reg_atomic_z196(memoryRSY mem, iRegL dst, iRegL src) %{
 5780   match(Set dst (GetAndAddL mem src));
 5781   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5782   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5783   size(6);
 5784   format %{ &quot;LAAG    $dst,$src,[$mem]&quot; %}
 5785   ins_encode %{ __ z_laag($dst$$Register, $src$$Register, $mem$$Address); %}
 5786   ins_pipe(pipe_class_dummy);
 5787 %}
 5788 
 5789 
 5790 instruct xchgI_reg_mem(memoryRSY mem, iRegI dst, iRegI tmp, flagsReg cr) %{
 5791   match(Set dst (GetAndSetI mem dst));
 5792   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5793   format %{ &quot;XCHGI   $dst,[$mem]\t # EXCHANGE (int, atomic), temp $tmp&quot; %}
 5794   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5795   ins_pipe(pipe_class_dummy);
 5796 %}
 5797 
 5798 instruct xchgL_reg_mem(memoryRSY mem, iRegL dst, iRegL tmp, flagsReg cr) %{
 5799   match(Set dst (GetAndSetL mem dst));
 5800   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5801   format %{ &quot;XCHGL   $dst,[$mem]\t # EXCHANGE (long, atomic), temp $tmp&quot; %}
 5802   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5803   ins_pipe(pipe_class_dummy);
 5804 %}
 5805 
 5806 instruct xchgN_reg_mem(memoryRSY mem, iRegN dst, iRegI tmp, flagsReg cr) %{
 5807   match(Set dst (GetAndSetN mem dst));
 5808   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5809   format %{ &quot;XCHGN   $dst,[$mem]\t # EXCHANGE (coop, atomic), temp $tmp&quot; %}
 5810   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5811   ins_pipe(pipe_class_dummy);
 5812 %}
 5813 
 5814 instruct xchgP_reg_mem(memoryRSY mem, iRegP dst, iRegL tmp, flagsReg cr) %{
 5815   match(Set dst (GetAndSetP mem dst));
 5816   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5817   format %{ &quot;XCHGP   $dst,[$mem]\t # EXCHANGE (oop, atomic), temp $tmp&quot; %}
 5818   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5819   ins_pipe(pipe_class_dummy);
 5820 %}
 5821 
 5822 
 5823 //----------Arithmetic Instructions--------------------------------------------
 5824 
 5825 // The rules are sorted by right operand type and operand length. Please keep
 5826 // it that way.
 5827 // Left operand type is always reg. Left operand len is I, L, P
 5828 // Right operand type is reg, imm, mem. Right operand len is S, I, L, P
 5829 // Special instruction formats, e.g. multi-operand, are inserted at the end.
 5830 
 5831 // ADD
 5832 
 5833 // REG = REG + REG
 5834 
 5835 // Register Addition
 5836 instruct addI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 5837   match(Set dst (AddI dst src));
 5838   effect(KILL cr);
 5839   // TODO: s390 port size(FIXED_SIZE);
 5840   format %{ &quot;AR      $dst,$src\t # int  CISC ALU&quot; %}
 5841   opcode(AR_ZOPC);
 5842   ins_encode(z_rrform(dst, src));
 5843   ins_pipe(pipe_class_dummy);
 5844 %}
 5845 
 5846 // Avoid use of LA(Y) for general ALU operation.
 5847 instruct addI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 5848   match(Set dst (AddI src1 src2));
 5849   effect(KILL cr);
 5850   predicate(VM_Version::has_DistinctOpnds());
 5851   ins_cost(DEFAULT_COST);
 5852   size(4);
 5853   format %{ &quot;ARK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 5854   opcode(ARK_ZOPC);
 5855   ins_encode(z_rrfform(dst, src1, src2));
 5856   ins_pipe(pipe_class_dummy);
 5857 %}
 5858 
 5859 // REG = REG + IMM
 5860 
 5861 // Avoid use of LA(Y) for general ALU operation.
 5862 // Immediate Addition
 5863 instruct addI_reg_imm16_CISC(iRegI dst, immI16 con, flagsReg cr) %{
 5864   match(Set dst (AddI dst con));
 5865   effect(KILL cr);
 5866   ins_cost(DEFAULT_COST);
 5867   // TODO: s390 port size(FIXED_SIZE);
 5868   format %{ &quot;AHI     $dst,$con\t # int  CISC ALU&quot; %}
 5869   opcode(AHI_ZOPC);
 5870   ins_encode(z_riform_signed(dst, con));
 5871   ins_pipe(pipe_class_dummy);
 5872 %}
 5873 
 5874 // Avoid use of LA(Y) for general ALU operation.
 5875 // Immediate Addition
 5876 instruct addI_reg_imm16_RISC(iRegI dst, iRegI src, immI16 con, flagsReg cr) %{
 5877   match(Set dst (AddI src con));
 5878   effect(KILL cr);
 5879   predicate( VM_Version::has_DistinctOpnds());
 5880   ins_cost(DEFAULT_COST);
 5881   // TODO: s390 port size(FIXED_SIZE);
 5882   format %{ &quot;AHIK    $dst,$src,$con\t # int  RISC ALU&quot; %}
 5883   opcode(AHIK_ZOPC);
 5884   ins_encode(z_rieform_d(dst, src, con));
 5885   ins_pipe(pipe_class_dummy);
 5886 %}
 5887 
 5888 // Immediate Addition
 5889 instruct addI_reg_imm32(iRegI dst, immI src, flagsReg cr) %{
 5890   match(Set dst (AddI dst src));
 5891   effect(KILL cr);
 5892   ins_cost(DEFAULT_COST_HIGH);
 5893   size(6);
 5894   format %{ &quot;AFI     $dst,$src&quot; %}
 5895   opcode(AFI_ZOPC);
 5896   ins_encode(z_rilform_signed(dst, src));
 5897   ins_pipe(pipe_class_dummy);
 5898 %}
 5899 
 5900 // Immediate Addition
 5901 instruct addI_reg_imm12(iRegI dst, iRegI src, uimmI12 con) %{
 5902   match(Set dst (AddI src con));
 5903   predicate(PreferLAoverADD);
 5904   ins_cost(DEFAULT_COST_LOW);
 5905   size(4);
 5906   format %{ &quot;LA      $dst,$con(,$src)\t # int d12(,b)&quot; %}
 5907   opcode(LA_ZOPC);
 5908   ins_encode(z_rxform_imm_reg(dst, con, src));
 5909   ins_pipe(pipe_class_dummy);
 5910 %}
 5911 
 5912 // Immediate Addition
 5913 instruct addI_reg_imm20(iRegI dst, iRegI src, immI20 con) %{
 5914   match(Set dst (AddI src con));
 5915   predicate(PreferLAoverADD);
 5916   ins_cost(DEFAULT_COST);
 5917   size(6);
 5918   format %{ &quot;LAY     $dst,$con(,$src)\t # int d20(,b)&quot; %}
 5919   opcode(LAY_ZOPC);
 5920   ins_encode(z_rxyform_imm_reg(dst, con, src));
 5921   ins_pipe(pipe_class_dummy);
 5922 %}
 5923 
 5924 instruct addI_reg_reg_imm12(iRegI dst, iRegI src1, iRegI src2, uimmI12 con) %{
 5925   match(Set dst (AddI (AddI src1 src2) con));
 5926   predicate( PreferLAoverADD);
 5927   ins_cost(DEFAULT_COST_LOW);
 5928   size(4);
 5929   format %{ &quot;LA      $dst,$con($src1,$src2)\t # int d12(x,b)&quot; %}
 5930   opcode(LA_ZOPC);
 5931   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 5932   ins_pipe(pipe_class_dummy);
 5933 %}
 5934 
 5935 instruct addI_reg_reg_imm20(iRegI dst, iRegI src1, iRegI src2, immI20 con) %{
 5936   match(Set dst (AddI (AddI src1 src2) con));
 5937   predicate(PreferLAoverADD);
 5938   ins_cost(DEFAULT_COST);
 5939   size(6);
 5940   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # int d20(x,b)&quot; %}
 5941   opcode(LAY_ZOPC);
 5942   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 5943   ins_pipe(pipe_class_dummy);
 5944 %}
 5945 
 5946 // REG = REG + MEM
 5947 
 5948 instruct addI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 5949   match(Set dst (AddI dst (LoadI src)));
 5950   effect(KILL cr);
 5951   ins_cost(MEMORY_REF_COST);
 5952   // TODO: s390 port size(VARIABLE_SIZE);
 5953   format %{ &quot;A(Y)    $dst, $src\t # int&quot; %}
 5954   opcode(AY_ZOPC, A_ZOPC);
 5955   ins_encode(z_form_rt_mem_opt(dst, src));
 5956   ins_pipe(pipe_class_dummy);
 5957 %}
 5958 
 5959 // MEM = MEM + IMM
 5960 
 5961 // Add Immediate to 4-byte memory operand and result
 5962 instruct addI_mem_imm(memoryRSY mem, immI8 src, flagsReg cr) %{
 5963   match(Set mem (StoreI mem (AddI (LoadI mem) src)));
 5964   effect(KILL cr);
 5965   predicate(VM_Version::has_MemWithImmALUOps());
 5966   ins_cost(MEMORY_REF_COST);
 5967   size(6);
 5968   format %{ &quot;ASI     $mem,$src\t # direct mem add 4&quot; %}
 5969   opcode(ASI_ZOPC);
 5970   ins_encode(z_siyform(mem, src));
 5971   ins_pipe(pipe_class_dummy);
 5972 %}
 5973 
 5974 
 5975 //
 5976 
 5977 // REG = REG + REG
 5978 
 5979 instruct addL_reg_regI(iRegL dst, iRegI src, flagsReg cr) %{
 5980   match(Set dst (AddL dst (ConvI2L src)));
 5981   effect(KILL cr);
 5982   size(4);
 5983   format %{ &quot;AGFR    $dst,$src\t # long&lt;-int CISC ALU&quot; %}
 5984   opcode(AGFR_ZOPC);
 5985   ins_encode(z_rreform(dst, src));
 5986   ins_pipe(pipe_class_dummy);
 5987 %}
 5988 
 5989 instruct addL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 5990   match(Set dst (AddL dst src));
 5991   effect(KILL cr);
 5992   // TODO: s390 port size(FIXED_SIZE);
 5993   format %{ &quot;AGR     $dst, $src\t # long CISC ALU&quot; %}
 5994   opcode(AGR_ZOPC);
 5995   ins_encode(z_rreform(dst, src));
 5996   ins_pipe(pipe_class_dummy);
 5997 %}
 5998 
 5999 // Avoid use of LA(Y) for general ALU operation.
 6000 instruct addL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 6001   match(Set dst (AddL src1 src2));
 6002   effect(KILL cr);
 6003   predicate(VM_Version::has_DistinctOpnds());
 6004   ins_cost(DEFAULT_COST);
 6005   size(4);
 6006   format %{ &quot;AGRK    $dst,$src1,$src2\t # long RISC ALU&quot; %}
 6007   opcode(AGRK_ZOPC);
 6008   ins_encode(z_rrfform(dst, src1, src2));
 6009   ins_pipe(pipe_class_dummy);
 6010 %}
 6011 
 6012 // REG = REG + IMM
 6013 
 6014 instruct addL_reg_imm12(iRegL dst, iRegL src, uimmL12 con) %{
 6015   match(Set dst (AddL src con));
 6016   predicate( PreferLAoverADD);
 6017   ins_cost(DEFAULT_COST_LOW);
 6018   size(4);
 6019   format %{ &quot;LA      $dst,$con(,$src)\t # long d12(,b)&quot; %}
 6020   opcode(LA_ZOPC);
 6021   ins_encode(z_rxform_imm_reg(dst, con, src));
 6022   ins_pipe(pipe_class_dummy);
 6023 %}
 6024 
 6025 instruct addL_reg_imm20(iRegL dst, iRegL src, immL20 con) %{
 6026   match(Set dst (AddL src con));
 6027   predicate(PreferLAoverADD);
 6028   ins_cost(DEFAULT_COST);
 6029   size(6);
 6030   format %{ &quot;LAY     $dst,$con(,$src)\t # long d20(,b)&quot; %}
 6031   opcode(LAY_ZOPC);
 6032   ins_encode(z_rxyform_imm_reg(dst, con, src));
 6033   ins_pipe(pipe_class_dummy);
 6034 %}
 6035 
 6036 instruct addL_reg_imm32(iRegL dst, immL32 con, flagsReg cr) %{
 6037   match(Set dst (AddL dst con));
 6038   effect(KILL cr);
 6039   ins_cost(DEFAULT_COST_HIGH);
 6040   size(6);
 6041   format %{ &quot;AGFI    $dst,$con\t # long CISC ALU&quot; %}
 6042   opcode(AGFI_ZOPC);
 6043   ins_encode(z_rilform_signed(dst, con));
 6044   ins_pipe(pipe_class_dummy);
 6045 %}
 6046 
 6047 // Avoid use of LA(Y) for general ALU operation.
 6048 instruct addL_reg_imm16_CISC(iRegL dst, immL16 con, flagsReg cr) %{
 6049   match(Set dst (AddL dst con));
 6050   effect(KILL cr);
 6051   ins_cost(DEFAULT_COST);
 6052   // TODO: s390 port size(FIXED_SIZE);
 6053   format %{ &quot;AGHI    $dst,$con\t # long CISC ALU&quot; %}
 6054   opcode(AGHI_ZOPC);
 6055   ins_encode(z_riform_signed(dst, con));
 6056   ins_pipe(pipe_class_dummy);
 6057 %}
 6058 
 6059 // Avoid use of LA(Y) for general ALU operation.
 6060 instruct addL_reg_imm16_RISC(iRegL dst, iRegL src, immL16 con, flagsReg cr) %{
 6061   match(Set dst (AddL src con));
 6062   effect(KILL cr);
 6063   predicate( VM_Version::has_DistinctOpnds());
 6064   ins_cost(DEFAULT_COST);
 6065   size(6);
 6066   format %{ &quot;AGHIK   $dst,$src,$con\t # long RISC ALU&quot; %}
 6067   opcode(AGHIK_ZOPC);
 6068   ins_encode(z_rieform_d(dst, src, con));
 6069   ins_pipe(pipe_class_dummy);
 6070 %}
 6071 
 6072 // REG = REG + MEM
 6073 
 6074 instruct addL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6075   match(Set dst (AddL dst (ConvI2L (LoadI src))));
 6076   effect(KILL cr);
 6077   ins_cost(MEMORY_REF_COST);
 6078   size(Z_DISP3_SIZE);
 6079   format %{ &quot;AGF     $dst, $src\t # long/int&quot; %}
 6080   opcode(AGF_ZOPC, AGF_ZOPC);
 6081   ins_encode(z_form_rt_mem_opt(dst, src));
 6082   ins_pipe(pipe_class_dummy);
 6083 %}
 6084 
 6085 instruct addL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6086   match(Set dst (AddL dst (LoadL src)));
 6087   effect(KILL cr);
 6088   ins_cost(MEMORY_REF_COST);
 6089   size(Z_DISP3_SIZE);
 6090   format %{ &quot;AG      $dst, $src\t # long&quot; %}
 6091   opcode(AG_ZOPC, AG_ZOPC);
 6092   ins_encode(z_form_rt_mem_opt(dst, src));
 6093   ins_pipe(pipe_class_dummy);
 6094 %}
 6095 
 6096 instruct addL_reg_reg_imm12(iRegL dst, iRegL src1, iRegL src2, uimmL12 con) %{
 6097   match(Set dst (AddL (AddL src1 src2) con));
 6098   predicate( PreferLAoverADD);
 6099   ins_cost(DEFAULT_COST_LOW);
 6100   size(4);
 6101   format %{ &quot;LA     $dst,$con($src1,$src2)\t # long d12(x,b)&quot; %}
 6102   opcode(LA_ZOPC);
 6103   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6104   ins_pipe(pipe_class_dummy);
 6105 %}
 6106 
 6107 instruct addL_reg_reg_imm20(iRegL dst, iRegL src1, iRegL src2, immL20 con) %{
 6108   match(Set dst (AddL (AddL src1 src2) con));
 6109   predicate(PreferLAoverADD);
 6110   ins_cost(DEFAULT_COST);
 6111   size(6);
 6112   format %{ &quot;LAY    $dst,$con($src1,$src2)\t # long d20(x,b)&quot; %}
 6113   opcode(LAY_ZOPC);
 6114   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6115   ins_pipe(pipe_class_dummy);
 6116 %}
 6117 
 6118 // MEM = MEM + IMM
 6119 
 6120 // Add Immediate to 8-byte memory operand and result.
 6121 instruct addL_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6122   match(Set mem (StoreL mem (AddL (LoadL mem) src)));
 6123   effect(KILL cr);
 6124   predicate(VM_Version::has_MemWithImmALUOps());
 6125   ins_cost(MEMORY_REF_COST);
 6126   size(6);
 6127   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8&quot; %}
 6128   opcode(AGSI_ZOPC);
 6129   ins_encode(z_siyform(mem, src));
 6130   ins_pipe(pipe_class_dummy);
 6131 %}
 6132 
 6133 
 6134 // REG = REG + REG
 6135 
 6136 // Ptr Addition
 6137 instruct addP_reg_reg_LA(iRegP dst, iRegP_N2P src1, iRegL src2) %{
 6138   match(Set dst (AddP src1 src2));
 6139   predicate( PreferLAoverADD);
 6140   ins_cost(DEFAULT_COST);
 6141   size(4);
 6142   format %{ &quot;LA      $dst,#0($src1,$src2)\t # ptr 0(x,b)&quot; %}
 6143   opcode(LA_ZOPC);
 6144   ins_encode(z_rxform_imm_reg_reg(dst, 0x0, src1, src2));
 6145   ins_pipe(pipe_class_dummy);
 6146 %}
 6147 
 6148 // Ptr Addition
 6149 // Avoid use of LA(Y) for general ALU operation.
 6150 instruct addP_reg_reg_CISC(iRegP dst, iRegL src, flagsReg cr) %{
 6151   match(Set dst (AddP dst src));
 6152   effect(KILL cr);
 6153   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6154   ins_cost(DEFAULT_COST);
 6155   // TODO: s390 port size(FIXED_SIZE);
 6156   format %{ &quot;ALGR    $dst,$src\t # ptr CICS ALU&quot; %}
 6157   opcode(ALGR_ZOPC);
 6158   ins_encode(z_rreform(dst, src));
 6159   ins_pipe(pipe_class_dummy);
 6160 %}
 6161 
 6162 // Ptr Addition
 6163 // Avoid use of LA(Y) for general ALU operation.
 6164 instruct addP_reg_reg_RISC(iRegP dst, iRegP_N2P src1, iRegL src2, flagsReg cr) %{
 6165   match(Set dst (AddP src1 src2));
 6166   effect(KILL cr);
 6167   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6168   ins_cost(DEFAULT_COST);
 6169   // TODO: s390 port size(FIXED_SIZE);
 6170   format %{ &quot;ALGRK   $dst,$src1,$src2\t # ptr RISC ALU&quot; %}
 6171   opcode(ALGRK_ZOPC);
 6172   ins_encode(z_rrfform(dst, src1, src2));
 6173   ins_pipe(pipe_class_dummy);
 6174 %}
 6175 
 6176 // REG = REG + IMM
 6177 
 6178 instruct addP_reg_imm12(iRegP dst, iRegP_N2P src, uimmL12 con) %{
 6179   match(Set dst (AddP src con));
 6180   predicate( PreferLAoverADD);
 6181   ins_cost(DEFAULT_COST_LOW);
 6182   size(4);
 6183   format %{ &quot;LA      $dst,$con(,$src)\t # ptr d12(,b)&quot; %}
 6184   opcode(LA_ZOPC);
 6185   ins_encode(z_rxform_imm_reg(dst, con, src));
 6186   ins_pipe(pipe_class_dummy);
 6187 %}
 6188 
 6189 // Avoid use of LA(Y) for general ALU operation.
 6190 instruct addP_reg_imm16_CISC(iRegP dst, immL16 src, flagsReg cr) %{
 6191   match(Set dst (AddP dst src));
 6192   effect(KILL cr);
 6193   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6194   ins_cost(DEFAULT_COST);
 6195   // TODO: s390 port size(FIXED_SIZE);
 6196   format %{ &quot;AGHI    $dst,$src\t # ptr CISC ALU&quot; %}
 6197   opcode(AGHI_ZOPC);
 6198   ins_encode(z_riform_signed(dst, src));
 6199   ins_pipe(pipe_class_dummy);
 6200 %}
 6201 
 6202 // Avoid use of LA(Y) for general ALU operation.
 6203 instruct addP_reg_imm16_RISC(iRegP dst, iRegP_N2P src, immL16 con, flagsReg cr) %{
 6204   match(Set dst (AddP src con));
 6205   effect(KILL cr);
 6206   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6207   ins_cost(DEFAULT_COST);
 6208   // TODO: s390 port size(FIXED_SIZE);
 6209   format %{ &quot;ALGHSIK $dst,$src,$con\t # ptr RISC ALU&quot; %}
 6210   opcode(ALGHSIK_ZOPC);
 6211   ins_encode(z_rieform_d(dst, src, con));
 6212   ins_pipe(pipe_class_dummy);
 6213 %}
 6214 
 6215 instruct addP_reg_imm20(iRegP dst, memoryRegP src, immL20 con) %{
 6216   match(Set dst (AddP src con));
 6217   predicate(PreferLAoverADD);
 6218   ins_cost(DEFAULT_COST);
 6219   size(6);
 6220   format %{ &quot;LAY     $dst,$con(,$src)\t # ptr d20(,b)&quot; %}
 6221   opcode(LAY_ZOPC);
 6222   ins_encode(z_rxyform_imm_reg(dst, con, src));
 6223   ins_pipe(pipe_class_dummy);
 6224 %}
 6225 
 6226 // Pointer Immediate Addition
 6227 instruct addP_reg_imm32(iRegP dst, immL32 src, flagsReg cr) %{
 6228   match(Set dst (AddP dst src));
 6229   effect(KILL cr);
 6230   ins_cost(DEFAULT_COST_HIGH);
 6231   // TODO: s390 port size(FIXED_SIZE);
 6232   format %{ &quot;AGFI    $dst,$src\t # ptr&quot; %}
 6233   opcode(AGFI_ZOPC);
 6234   ins_encode(z_rilform_signed(dst, src));
 6235   ins_pipe(pipe_class_dummy);
 6236 %}
 6237 
 6238 // REG = REG1 + REG2 + IMM
 6239 
 6240 instruct addP_reg_reg_imm12(iRegP dst, memoryRegP src1, iRegL src2, uimmL12 con) %{
 6241   match(Set dst (AddP (AddP src1 src2) con));
 6242   predicate( PreferLAoverADD);
 6243   ins_cost(DEFAULT_COST_LOW);
 6244   size(4);
 6245   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6246   opcode(LA_ZOPC);
 6247   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6248   ins_pipe(pipe_class_dummy);
 6249 %}
 6250 
 6251 instruct addP_regN_reg_imm12(iRegP dst, iRegP_N2P src1, iRegL src2, uimmL12 con) %{
 6252   match(Set dst (AddP (AddP src1 src2) con));
 6253   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 6254   ins_cost(DEFAULT_COST_LOW);
 6255   size(4);
 6256   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6257   opcode(LA_ZOPC);
 6258   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6259   ins_pipe(pipe_class_dummy);
 6260 %}
 6261 
 6262 instruct addP_reg_reg_imm20(iRegP dst, memoryRegP src1, iRegL src2, immL20 con) %{
 6263   match(Set dst (AddP (AddP src1 src2) con));
 6264   predicate(PreferLAoverADD);
 6265   ins_cost(DEFAULT_COST);
 6266   // TODO: s390 port size(FIXED_SIZE);
 6267   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6268   opcode(LAY_ZOPC);
 6269   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6270   ins_pipe(pipe_class_dummy);
 6271 %}
 6272 
 6273 instruct addP_regN_reg_imm20(iRegP dst, iRegP_N2P src1, iRegL src2, immL20 con) %{
 6274   match(Set dst (AddP (AddP src1 src2) con));
 6275   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 6276   ins_cost(DEFAULT_COST);
 6277   // TODO: s390 port size(FIXED_SIZE);
 6278   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6279   opcode(LAY_ZOPC);
 6280   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6281   ins_pipe(pipe_class_dummy);
 6282 %}
 6283 
 6284 // MEM = MEM + IMM
 6285 
 6286 // Add Immediate to 8-byte memory operand and result
 6287 instruct addP_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6288   match(Set mem (StoreP mem (AddP (LoadP mem) src)));
 6289   effect(KILL cr);
 6290   predicate(VM_Version::has_MemWithImmALUOps());
 6291   ins_cost(MEMORY_REF_COST);
 6292   size(6);
 6293   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8 (ptr)&quot; %}
 6294   opcode(AGSI_ZOPC);
 6295   ins_encode(z_siyform(mem, src));
 6296   ins_pipe(pipe_class_dummy);
 6297 %}
 6298 
 6299 // SUB
 6300 
 6301 // Register Subtraction
 6302 instruct subI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 6303   match(Set dst (SubI dst src));
 6304   effect(KILL cr);
 6305   // TODO: s390 port size(FIXED_SIZE);
 6306   format %{ &quot;SR      $dst,$src\t # int  CISC ALU&quot; %}
 6307   opcode(SR_ZOPC);
 6308   ins_encode(z_rrform(dst, src));
 6309   ins_pipe(pipe_class_dummy);
 6310 %}
 6311 
 6312 instruct subI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 6313   match(Set dst (SubI src1 src2));
 6314   effect(KILL cr);
 6315   predicate(VM_Version::has_DistinctOpnds());
 6316   ins_cost(DEFAULT_COST);
 6317   size(4);
 6318   format %{ &quot;SRK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6319   opcode(SRK_ZOPC);
 6320   ins_encode(z_rrfform(dst, src1, src2));
 6321   ins_pipe(pipe_class_dummy);
 6322 %}
 6323 
 6324 instruct subI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 6325   match(Set dst (SubI dst (LoadI src)));
 6326   effect(KILL cr);
 6327   ins_cost(MEMORY_REF_COST);
 6328   // TODO: s390 port size(VARIABLE_SIZE);
 6329   format %{ &quot;S(Y)    $dst, $src\t # int&quot; %}
 6330   opcode(SY_ZOPC, S_ZOPC);
 6331   ins_encode(z_form_rt_mem_opt(dst, src));
 6332   ins_pipe(pipe_class_dummy);
 6333 %}
 6334 
 6335 instruct subI_zero_reg(iRegI dst, immI_0 zero, iRegI src, flagsReg cr) %{
 6336   match(Set dst (SubI zero src));
 6337   effect(KILL cr);
 6338   size(2);
 6339   format %{ &quot;NEG     $dst, $src&quot; %}
 6340   ins_encode %{ __ z_lcr($dst$$Register, $src$$Register); %}
 6341   ins_pipe(pipe_class_dummy);
 6342 %}
 6343 
 6344 //
 6345 
 6346 // Long subtraction
 6347 instruct subL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 6348   match(Set dst (SubL dst src));
 6349   effect(KILL cr);
 6350   // TODO: s390 port size(FIXED_SIZE);
 6351   format %{ &quot;SGR     $dst,$src\t # int  CISC ALU&quot; %}
 6352   opcode(SGR_ZOPC);
 6353   ins_encode(z_rreform(dst, src));
 6354   ins_pipe(pipe_class_dummy);
 6355 %}
 6356 
 6357 // Avoid use of LA(Y) for general ALU operation.
 6358 instruct subL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 6359   match(Set dst (SubL src1 src2));
 6360   effect(KILL cr);
 6361   predicate(VM_Version::has_DistinctOpnds());
 6362   ins_cost(DEFAULT_COST);
 6363   size(4);
 6364   format %{ &quot;SGRK    $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6365   opcode(SGRK_ZOPC);
 6366   ins_encode(z_rrfform(dst, src1, src2));
 6367   ins_pipe(pipe_class_dummy);
 6368 %}
 6369 
 6370 instruct subL_reg_regI_CISC(iRegL dst, iRegI src, flagsReg cr) %{
 6371   match(Set dst (SubL dst (ConvI2L src)));
 6372   effect(KILL cr);
 6373   size(4);
 6374   format %{ &quot;SGFR    $dst, $src\t # int  CISC ALU&quot; %}
 6375   opcode(SGFR_ZOPC);
 6376   ins_encode(z_rreform(dst, src));
 6377   ins_pipe(pipe_class_dummy);
 6378 %}
 6379 
 6380 instruct subL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6381   match(Set dst (SubL dst (ConvI2L (LoadI src))));
 6382   effect(KILL cr);
 6383   ins_cost(MEMORY_REF_COST);
 6384   size(Z_DISP3_SIZE);
 6385   format %{ &quot;SGF     $dst, $src\t # long/int&quot; %}
 6386   opcode(SGF_ZOPC, SGF_ZOPC);
 6387   ins_encode(z_form_rt_mem_opt(dst, src));
 6388   ins_pipe(pipe_class_dummy);
 6389 %}
 6390 
 6391 instruct subL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6392   match(Set dst (SubL dst (LoadL src)));
 6393   effect(KILL cr);
 6394   ins_cost(MEMORY_REF_COST);
 6395   size(Z_DISP3_SIZE);
 6396   format %{ &quot;SG      $dst, $src\t # long&quot; %}
 6397   opcode(SG_ZOPC, SG_ZOPC);
 6398   ins_encode(z_form_rt_mem_opt(dst, src));
 6399   ins_pipe(pipe_class_dummy);
 6400 %}
 6401 
 6402 // Moved declaration of negL_reg_reg before encode nodes, where it is used.
 6403 
 6404 //  MUL
 6405 
 6406 // Register Multiplication
 6407 instruct mulI_reg_reg(iRegI dst, iRegI src) %{
 6408   match(Set dst (MulI dst src));
 6409   ins_cost(DEFAULT_COST);
 6410   size(4);
 6411   format %{ &quot;MSR     $dst, $src&quot; %}
 6412   opcode(MSR_ZOPC);
 6413   ins_encode(z_rreform(dst, src));
 6414   ins_pipe(pipe_class_dummy);
 6415 %}
 6416 
 6417 // Immediate Multiplication
 6418 instruct mulI_reg_imm16(iRegI dst, immI16 con) %{
 6419   match(Set dst (MulI dst con));
 6420   ins_cost(DEFAULT_COST);
 6421   // TODO: s390 port size(FIXED_SIZE);
 6422   format %{ &quot;MHI     $dst,$con&quot; %}
 6423   opcode(MHI_ZOPC);
 6424   ins_encode(z_riform_signed(dst,con));
 6425   ins_pipe(pipe_class_dummy);
 6426 %}
 6427 
 6428 // Immediate (32bit) Multiplication
 6429 instruct mulI_reg_imm32(iRegI dst, immI con) %{
 6430   match(Set dst (MulI dst con));
 6431   ins_cost(DEFAULT_COST);
 6432   size(6);
 6433   format %{ &quot;MSFI    $dst,$con&quot; %}
 6434   opcode(MSFI_ZOPC);
 6435   ins_encode(z_rilform_signed(dst,con));
 6436   ins_pipe(pipe_class_dummy);
 6437 %}
 6438 
 6439 instruct mulI_Reg_mem(iRegI dst, memory src)%{
 6440   match(Set dst (MulI dst (LoadI src)));
 6441   ins_cost(MEMORY_REF_COST);
 6442   // TODO: s390 port size(VARIABLE_SIZE);
 6443   format %{ &quot;MS(Y)   $dst, $src\t # int&quot; %}
 6444   opcode(MSY_ZOPC, MS_ZOPC);
 6445   ins_encode(z_form_rt_mem_opt(dst, src));
 6446   ins_pipe(pipe_class_dummy);
 6447 %}
 6448 
 6449 //
 6450 
 6451 instruct mulL_reg_regI(iRegL dst, iRegI src) %{
 6452   match(Set dst (MulL dst (ConvI2L src)));
 6453   ins_cost(DEFAULT_COST);
 6454   // TODO: s390 port size(FIXED_SIZE);
 6455   format %{ &quot;MSGFR   $dst $src\t # long/int&quot; %}
 6456   opcode(MSGFR_ZOPC);
 6457   ins_encode(z_rreform(dst, src));
 6458   ins_pipe(pipe_class_dummy);
 6459 %}
 6460 
 6461 instruct mulL_reg_reg(iRegL dst, iRegL src) %{
 6462   match(Set dst (MulL dst src));
 6463   ins_cost(DEFAULT_COST);
 6464   size(4);
 6465   format %{ &quot;MSGR    $dst $src\t # long&quot; %}
 6466   opcode(MSGR_ZOPC);
 6467   ins_encode(z_rreform(dst, src));
 6468   ins_pipe(pipe_class_dummy);
 6469 %}
 6470 
 6471 // Immediate Multiplication
 6472 instruct mulL_reg_imm16(iRegL dst, immL16 src) %{
 6473   match(Set dst (MulL dst src));
 6474   ins_cost(DEFAULT_COST);
 6475   // TODO: s390 port size(FIXED_SIZE);
 6476   format %{ &quot;MGHI    $dst,$src\t # long&quot; %}
 6477   opcode(MGHI_ZOPC);
 6478   ins_encode(z_riform_signed(dst, src));
 6479   ins_pipe(pipe_class_dummy);
 6480 %}
 6481 
 6482 // Immediate (32bit) Multiplication
 6483 instruct mulL_reg_imm32(iRegL dst, immL32 con) %{
 6484   match(Set dst (MulL dst con));
 6485   ins_cost(DEFAULT_COST);
 6486   size(6);
 6487   format %{ &quot;MSGFI   $dst,$con&quot; %}
 6488   opcode(MSGFI_ZOPC);
 6489   ins_encode(z_rilform_signed(dst,con));
 6490   ins_pipe(pipe_class_dummy);
 6491 %}
 6492 
 6493 instruct mulL_Reg_memI(iRegL dst, memory src)%{
 6494   match(Set dst (MulL dst (ConvI2L (LoadI src))));
 6495   ins_cost(MEMORY_REF_COST);
 6496   size(Z_DISP3_SIZE);
 6497   format %{ &quot;MSGF    $dst, $src\t # long&quot; %}
 6498   opcode(MSGF_ZOPC, MSGF_ZOPC);
 6499   ins_encode(z_form_rt_mem_opt(dst, src));
 6500   ins_pipe(pipe_class_dummy);
 6501 %}
 6502 
 6503 instruct mulL_Reg_mem(iRegL dst, memory src)%{
 6504   match(Set dst (MulL dst (LoadL src)));
 6505   ins_cost(MEMORY_REF_COST);
 6506   size(Z_DISP3_SIZE);
 6507   format %{ &quot;MSG     $dst, $src\t # long&quot; %}
 6508   opcode(MSG_ZOPC, MSG_ZOPC);
 6509   ins_encode(z_form_rt_mem_opt(dst, src));
 6510   ins_pipe(pipe_class_dummy);
 6511 %}
 6512 
 6513 instruct mulHiL_reg_reg(revenRegL Rdst, roddRegL Rsrc1, iRegL Rsrc2, iRegL Rtmp1, flagsReg cr)%{
 6514   match(Set Rdst (MulHiL Rsrc1 Rsrc2));
 6515   effect(TEMP_DEF Rdst, USE_KILL Rsrc1, TEMP Rtmp1, KILL cr);
 6516   ins_cost(7*DEFAULT_COST);
 6517   // TODO: s390 port size(VARIABLE_SIZE);
 6518   format %{ &quot;MulHiL  $Rdst, $Rsrc1, $Rsrc2\t # Multiply High Long&quot; %}
 6519   ins_encode%{
 6520     Register dst  = $Rdst$$Register;
 6521     Register src1 = $Rsrc1$$Register;
 6522     Register src2 = $Rsrc2$$Register;
 6523     Register tmp1 = $Rtmp1$$Register;
 6524     Register tmp2 = $Rdst$$Register;
 6525     // z/Architecture has only unsigned multiply (64 * 64 -&gt; 128).
 6526     // implementing mulhs(a,b) = mulhu(a,b) – (a &amp; (b&gt;&gt;63)) – (b &amp; (a&gt;&gt;63))
 6527     __ z_srag(tmp2, src1, 63);  // a&gt;&gt;63
 6528     __ z_srag(tmp1, src2, 63);  // b&gt;&gt;63
 6529     __ z_ngr(tmp2, src2);       // b &amp; (a&gt;&gt;63)
 6530     __ z_ngr(tmp1, src1);       // a &amp; (b&gt;&gt;63)
 6531     __ z_agr(tmp1, tmp2);       // ((a &amp; (b&gt;&gt;63)) + (b &amp; (a&gt;&gt;63)))
 6532     __ z_mlgr(dst, src2);       // tricky: 128-bit product is written to even/odd pair (dst,src1),
 6533                                 //         multiplicand is taken from oddReg (src1), multiplier in src2.
 6534     __ z_sgr(dst, tmp1);
 6535   %}
 6536   ins_pipe(pipe_class_dummy);
 6537 %}
 6538 
 6539 //  DIV
 6540 
 6541 // Integer DIVMOD with Register, both quotient and mod results
 6542 instruct divModI_reg_divmod(roddRegI dst1src1, revenRegI dst2, noOdd_iRegI src2, flagsReg cr) %{
 6543   match(DivModI dst1src1 src2);
 6544   effect(KILL cr);
 6545   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6546   size((VM_Version::has_CompareBranch() ? 24 : 26));
 6547   format %{ &quot;DIVMODI ($dst1src1, $dst2) $src2&quot; %}
 6548   ins_encode %{
 6549     Register d1s1 = $dst1src1$$Register;
 6550     Register d2   = $dst2$$Register;
 6551     Register s2   = $src2$$Register;
 6552 
 6553     assert_different_registers(d1s1, s2);
 6554 
 6555     Label do_div, done_div;
 6556     if (VM_Version::has_CompareBranch()) {
 6557       __ z_cij(s2, -1, Assembler::bcondNotEqual, do_div);
 6558     } else {
 6559       __ z_chi(s2, -1);
 6560       __ z_brne(do_div);
 6561     }
 6562     __ z_lcr(d1s1, d1s1);
 6563     __ clear_reg(d2, false, false);
 6564     __ z_bru(done_div);
 6565     __ bind(do_div);
 6566     __ z_lgfr(d1s1, d1s1);
 6567     __ z_dsgfr(d2, s2);
 6568     __ bind(done_div);
 6569   %}
 6570   ins_pipe(pipe_class_dummy);
 6571 %}
 6572 
 6573 
 6574 // Register Division
 6575 instruct divI_reg_reg(roddRegI dst, iRegI src1, noOdd_iRegI src2, revenRegI tmp, flagsReg cr) %{
 6576   match(Set dst (DivI src1 src2));
 6577   effect(KILL tmp, KILL cr);
 6578   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6579   size((VM_Version::has_CompareBranch() ? 20 : 22));
 6580   format %{ &quot;DIV_checked $dst, $src1,$src2\t # treats special case 0x80../-1&quot; %}
 6581   ins_encode %{
 6582     Register a = $src1$$Register;
 6583     Register b = $src2$$Register;
 6584     Register t = $dst$$Register;
 6585 
 6586     assert_different_registers(t, b);
 6587 
 6588     Label do_div, done_div;
 6589     if (VM_Version::has_CompareBranch()) {
 6590       __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6591     } else {
 6592       __ z_chi(b, -1);
 6593       __ z_brne(do_div);
 6594     }
 6595     __ z_lcr(t, a);
 6596     __ z_bru(done_div);
 6597     __ bind(do_div);
 6598     __ z_lgfr(t, a);
 6599     __ z_dsgfr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6600     __ bind(done_div);
 6601   %}
 6602   ins_pipe(pipe_class_dummy);
 6603 %}
 6604 
 6605 // Immediate Division
 6606 instruct divI_reg_imm16(roddRegI dst, iRegI src1, immI16 src2, revenRegI tmp, flagsReg cr) %{
 6607   match(Set dst (DivI src1 src2));
 6608   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6609   ins_cost(2 * DEFAULT_COST);
 6610   // TODO: s390 port size(VARIABLE_SIZE);
 6611   format %{ &quot;DIV_const  $dst,$src1,$src2&quot; %}
 6612   ins_encode %{
 6613     // No sign extension of Rdividend needed here.
 6614     if ($src2$$constant != -1) {
 6615       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6616       __ z_lgfr($dst$$Register, $src1$$Register);
 6617       __ z_dsgfr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6618     } else {
 6619       __ z_lcr($dst$$Register, $src1$$Register);
 6620     }
 6621   %}
 6622   ins_pipe(pipe_class_dummy);
 6623 %}
 6624 
 6625 // Long DIVMOD with Register, both quotient and mod results
 6626 instruct divModL_reg_divmod(roddRegL dst1src1, revenRegL dst2, iRegL src2, flagsReg cr) %{
 6627   match(DivModL dst1src1 src2);
 6628   effect(KILL cr);
 6629   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6630   size((VM_Version::has_CompareBranch() ? 22 : 24));
 6631   format %{ &quot;DIVMODL ($dst1src1, $dst2) $src2&quot; %}
 6632   ins_encode %{
 6633     Register d1s1 = $dst1src1$$Register;
 6634     Register d2   = $dst2$$Register;
 6635     Register s2   = $src2$$Register;
 6636 
 6637     Label do_div, done_div;
 6638     if (VM_Version::has_CompareBranch()) {
 6639       __ z_cgij(s2, -1, Assembler::bcondNotEqual, do_div);
 6640     } else {
 6641       __ z_cghi(s2, -1);
 6642       __ z_brne(do_div);
 6643     }
 6644     __ z_lcgr(d1s1, d1s1);
 6645     // indicate unused result
 6646     (void) __ clear_reg(d2, true, false);
 6647     __ z_bru(done_div);
 6648     __ bind(do_div);
 6649     __ z_dsgr(d2, s2);
 6650     __ bind(done_div);
 6651   %}
 6652   ins_pipe(pipe_class_dummy);
 6653 %}
 6654 
 6655 // Register Long Division
 6656 instruct divL_reg_reg(roddRegL dst, iRegL src, revenRegL tmp, flagsReg cr) %{
 6657   match(Set dst (DivL dst src));
 6658   effect(KILL tmp, KILL cr);
 6659   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6660   size((VM_Version::has_CompareBranch() ? 18 : 20));
 6661   format %{ &quot;DIVG_checked  $dst, $src\t # long, treats special case 0x80../-1&quot; %}
 6662   ins_encode %{
 6663     Register b = $src$$Register;
 6664     Register t = $dst$$Register;
 6665 
 6666     Label done_div;
 6667     __ z_lcgr(t, t);    // Does no harm. divisor is in other register.
 6668     if (VM_Version::has_CompareBranch()) {
 6669       __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6670     } else {
 6671       __ z_cghi(b, -1);
 6672       __ z_bre(done_div);
 6673     }
 6674     __ z_lcgr(t, t);    // Restore sign.
 6675     __ z_dsgr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6676     __ bind(done_div);
 6677   %}
 6678   ins_pipe(pipe_class_dummy);
 6679 %}
 6680 
 6681 // Immediate Long Division
 6682 instruct divL_reg_imm16(roddRegL dst, iRegL src1, immL16 src2, revenRegL tmp, flagsReg cr) %{
 6683   match(Set dst (DivL src1 src2));
 6684   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6685   ins_cost(2 * DEFAULT_COST);
 6686   // TODO: s390 port size(VARIABLE_SIZE);
 6687   format %{ &quot;DIVG_const  $dst,$src1,$src2\t # long&quot; %}
 6688   ins_encode %{
 6689     if ($src2$$constant != -1) {
 6690       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6691       __ lgr_if_needed($dst$$Register, $src1$$Register);
 6692       __ z_dsgr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6693     } else {
 6694       __ z_lcgr($dst$$Register, $src1$$Register);
 6695     }
 6696   %}
 6697   ins_pipe(pipe_class_dummy);
 6698 %}
 6699 
 6700 // REM
 6701 
 6702 // Integer Remainder
 6703 // Register Remainder
 6704 instruct modI_reg_reg(revenRegI dst, iRegI src1, noOdd_iRegI src2, roddRegI tmp, flagsReg cr) %{
 6705   match(Set dst (ModI src1 src2));
 6706   effect(KILL tmp, KILL cr);
 6707   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6708   // TODO: s390 port size(VARIABLE_SIZE);
 6709   format %{ &quot;MOD_checked   $dst,$src1,$src2&quot; %}
 6710   ins_encode %{
 6711     Register a = $src1$$Register;
 6712     Register b = $src2$$Register;
 6713     Register t = $dst$$Register;
 6714     assert_different_registers(t-&gt;successor(), b);
 6715 
 6716     Label do_div, done_div;
 6717 
 6718     if ((t-&gt;encoding() != b-&gt;encoding()) &amp;&amp; (t-&gt;encoding() != a-&gt;encoding())) {
 6719       (void) __ clear_reg(t, true, false);  // Does no harm. Operands are in other regs.
 6720       if (VM_Version::has_CompareBranch()) {
 6721         __ z_cij(b, -1, Assembler::bcondEqual, done_div);
 6722       } else {
 6723         __ z_chi(b, -1);
 6724         __ z_bre(done_div);
 6725       }
 6726       __ z_lgfr(t-&gt;successor(), a);
 6727       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6728     } else {
 6729       if (VM_Version::has_CompareBranch()) {
 6730         __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6731       } else {
 6732         __ z_chi(b, -1);
 6733         __ z_brne(do_div);
 6734       }
 6735       __ clear_reg(t, true, false);
 6736       __ z_bru(done_div);
 6737       __ bind(do_div);
 6738       __ z_lgfr(t-&gt;successor(), a);
 6739       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6740     }
 6741     __ bind(done_div);
 6742   %}
 6743   ins_pipe(pipe_class_dummy);
 6744 %}
 6745 
 6746 // Immediate Remainder
 6747 instruct modI_reg_imm16(revenRegI dst, iRegI src1, immI16 src2, roddRegI tmp, flagsReg cr) %{
 6748   match(Set dst (ModI src1 src2));
 6749   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6750   ins_cost(3 * DEFAULT_COST);
 6751   // TODO: s390 port size(VARIABLE_SIZE);
 6752   format %{ &quot;MOD_const  $dst,src1,$src2&quot; %}
 6753   ins_encode %{
 6754     assert_different_registers($dst$$Register, $src1$$Register);
 6755     assert_different_registers($dst$$Register-&gt;successor(), $src1$$Register);
 6756     int divisor = $src2$$constant;
 6757 
 6758     if (divisor != -1) {
 6759       __ z_lghi(Z_R0_scratch, divisor);
 6760       __ z_lgfr($dst$$Register-&gt;successor(), $src1$$Register);
 6761       __ z_dsgfr($dst$$Register/* Dst is even part of a register pair. */, Z_R0_scratch); // Instruction kills tmp.
 6762     } else {
 6763       __ clear_reg($dst$$Register, true, false);
 6764     }
 6765   %}
 6766   ins_pipe(pipe_class_dummy);
 6767 %}
 6768 
 6769 // Register Long Remainder
 6770 instruct modL_reg_reg(revenRegL dst, roddRegL src1, iRegL src2, flagsReg cr) %{
 6771   match(Set dst (ModL src1 src2));
 6772   effect(KILL src1, KILL cr); // R0 is killed, too.
 6773   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6774   // TODO: s390 port size(VARIABLE_SIZE);
 6775   format %{ &quot;MODG_checked   $dst,$src1,$src2&quot; %}
 6776   ins_encode %{
 6777     Register a = $src1$$Register;
 6778     Register b = $src2$$Register;
 6779     Register t = $dst$$Register;
 6780     assert(t-&gt;successor() == a, &quot;(t,a) is an even-odd pair&quot; );
 6781 
 6782     Label do_div, done_div;
 6783     if (t-&gt;encoding() != b-&gt;encoding()) {
 6784       (void) __ clear_reg(t, true, false); // Does no harm. Dividend is in successor.
 6785       if (VM_Version::has_CompareBranch()) {
 6786         __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6787       } else {
 6788         __ z_cghi(b, -1);
 6789         __ z_bre(done_div);
 6790       }
 6791       __ z_dsgr(t, b);
 6792     } else {
 6793       if (VM_Version::has_CompareBranch()) {
 6794         __ z_cgij(b, -1, Assembler::bcondNotEqual, do_div);
 6795       } else {
 6796         __ z_cghi(b, -1);
 6797         __ z_brne(do_div);
 6798       }
 6799       __ clear_reg(t, true, false);
 6800       __ z_bru(done_div);
 6801       __ bind(do_div);
 6802       __ z_dsgr(t, b);
 6803     }
 6804     __ bind(done_div);
 6805   %}
 6806   ins_pipe(pipe_class_dummy);
 6807 %}
 6808 
 6809 // Register Long Remainder
 6810 instruct modL_reg_imm16(revenRegL dst, iRegL src1, immL16 src2, roddRegL tmp, flagsReg cr) %{
 6811   match(Set dst (ModL src1 src2));
 6812   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6813   ins_cost(3 * DEFAULT_COST);
 6814   // TODO: s390 port size(VARIABLE_SIZE);
 6815   format %{ &quot;MODG_const  $dst,src1,$src2\t # long&quot; %}
 6816   ins_encode %{
 6817     int divisor = $src2$$constant;
 6818     if (divisor != -1) {
 6819       __ z_lghi(Z_R0_scratch, divisor);
 6820       __ z_lgr($dst$$Register-&gt;successor(), $src1$$Register);
 6821       __ z_dsgr($dst$$Register /* Dst is even part of a register pair. */, Z_R0_scratch);  // Instruction kills tmp.
 6822     } else {
 6823       __ clear_reg($dst$$Register, true, false);
 6824     }
 6825   %}
 6826   ins_pipe(pipe_class_dummy);
 6827 %}
 6828 
 6829 // SHIFT
 6830 
 6831 // Shift left logical
 6832 
 6833 // Register Shift Left variable
 6834 instruct sllI_reg_reg(iRegI dst, iRegI src, iRegI nbits, flagsReg cr) %{
 6835   match(Set dst (LShiftI src nbits));
 6836   effect(KILL cr); // R1 is killed, too.
 6837   ins_cost(3 * DEFAULT_COST);
 6838   size(14);
 6839   format %{ &quot;SLL     $dst,$src,[$nbits] &amp; 31\t # use RISC-like SLLG also for int&quot; %}
 6840   ins_encode %{
 6841     __ z_lgr(Z_R1_scratch, $nbits$$Register);
 6842     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6843     __ z_sllg($dst$$Register, $src$$Register, 0, Z_R1_scratch);
 6844   %}
 6845   ins_pipe(pipe_class_dummy);
 6846 %}
 6847 
 6848 // Register Shift Left Immediate
 6849 // Constant shift count is masked in ideal graph already.
 6850 instruct sllI_reg_imm(iRegI dst, iRegI src, immI nbits) %{
 6851   match(Set dst (LShiftI src nbits));
 6852   size(6);
 6853   format %{ &quot;SLL     $dst,$src,$nbits\t # use RISC-like SLLG also for int&quot; %}
 6854   ins_encode %{
 6855     int Nbit = $nbits$$constant;
 6856     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6857     __ z_sllg($dst$$Register, $src$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6858   %}
 6859   ins_pipe(pipe_class_dummy);
 6860 %}
 6861 
 6862 // Register Shift Left Immediate by 1bit
 6863 instruct sllI_reg_imm_1(iRegI dst, iRegI src, immI_1 nbits) %{
 6864   match(Set dst (LShiftI src nbits));
 6865   predicate(PreferLAoverADD);
 6866   ins_cost(DEFAULT_COST_LOW);
 6867   size(4);
 6868   format %{ &quot;LA      $dst,#0($src,$src)\t # SLL by 1 (int)&quot; %}
 6869   ins_encode %{ __ z_la($dst$$Register, 0, $src$$Register, $src$$Register); %}
 6870   ins_pipe(pipe_class_dummy);
 6871 %}
 6872 
 6873 // Register Shift Left Long
 6874 instruct sllL_reg_reg(iRegL dst, iRegL src1, iRegI nbits) %{
 6875   match(Set dst (LShiftL src1 nbits));
 6876   size(6);
 6877   format %{ &quot;SLLG    $dst,$src1,[$nbits]&quot; %}
 6878   opcode(SLLG_ZOPC);
 6879   ins_encode(z_rsyform_reg_reg(dst, src1, nbits));
 6880   ins_pipe(pipe_class_dummy);
 6881 %}
 6882 
 6883 // Register Shift Left Long Immediate
 6884 instruct sllL_reg_imm(iRegL dst, iRegL src1, immI nbits) %{
 6885   match(Set dst (LShiftL src1 nbits));
 6886   size(6);
 6887   format %{ &quot;SLLG    $dst,$src1,$nbits&quot; %}
 6888   opcode(SLLG_ZOPC);
 6889   ins_encode(z_rsyform_const(dst, src1, nbits));
 6890   ins_pipe(pipe_class_dummy);
 6891 %}
 6892 
 6893 // Register Shift Left Long Immediate by 1bit
 6894 instruct sllL_reg_imm_1(iRegL dst, iRegL src1, immI_1 nbits) %{
 6895   match(Set dst (LShiftL src1 nbits));
 6896   predicate(PreferLAoverADD);
 6897   ins_cost(DEFAULT_COST_LOW);
 6898   size(4);
 6899   format %{ &quot;LA      $dst,#0($src1,$src1)\t # SLLG by 1 (long)&quot; %}
 6900   ins_encode %{ __ z_la($dst$$Register, 0, $src1$$Register, $src1$$Register); %}
 6901   ins_pipe(pipe_class_dummy);
 6902 %}
 6903 
 6904 // Shift right arithmetic
 6905 
 6906 // Register Arithmetic Shift Right
 6907 instruct sraI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6908   match(Set dst (RShiftI dst src));
 6909   effect(KILL cr); // R1 is killed, too.
 6910   ins_cost(3 * DEFAULT_COST);
 6911   size(12);
 6912   format %{ &quot;SRA     $dst,[$src] &amp; 31&quot; %}
 6913   ins_encode %{
 6914     __ z_lgr(Z_R1_scratch, $src$$Register);
 6915     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6916     __ z_sra($dst$$Register, 0, Z_R1_scratch);
 6917   %}
 6918   ins_pipe(pipe_class_dummy);
 6919 %}
 6920 
 6921 // Register Arithmetic Shift Right Immediate
 6922 // Constant shift count is masked in ideal graph already.
 6923 instruct sraI_reg_imm(iRegI dst, immI src, flagsReg cr) %{
 6924   match(Set dst (RShiftI dst src));
 6925   effect(KILL cr);
 6926   size(4);
 6927   format %{ &quot;SRA     $dst,$src&quot; %}
 6928   ins_encode %{
 6929     int Nbit = $src$$constant;
 6930     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6931     __ z_sra($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6932   %}
 6933   ins_pipe(pipe_class_dummy);
 6934 %}
 6935 
 6936 // Register Arithmetic Shift Right Long
 6937 instruct sraL_reg_reg(iRegL dst, iRegL src1, iRegI src2, flagsReg cr) %{
 6938   match(Set dst (RShiftL src1 src2));
 6939   effect(KILL cr);
 6940   size(6);
 6941   format %{ &quot;SRAG    $dst,$src1,[$src2]&quot; %}
 6942   opcode(SRAG_ZOPC);
 6943   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 6944   ins_pipe(pipe_class_dummy);
 6945 %}
 6946 
 6947 // Register Arithmetic Shift Right Long Immediate
 6948 instruct sraL_reg_imm(iRegL dst, iRegL src1, immI src2, flagsReg cr) %{
 6949   match(Set dst (RShiftL src1 src2));
 6950   effect(KILL cr);
 6951   size(6);
 6952   format %{ &quot;SRAG    $dst,$src1,$src2&quot; %}
 6953   opcode(SRAG_ZOPC);
 6954   ins_encode(z_rsyform_const(dst, src1, src2));
 6955   ins_pipe(pipe_class_dummy);
 6956 %}
 6957 
 6958 //  Shift right logical
 6959 
 6960 // Register Shift Right
 6961 instruct srlI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6962   match(Set dst (URShiftI dst src));
 6963   effect(KILL cr); // R1 is killed, too.
 6964   ins_cost(3 * DEFAULT_COST);
 6965   size(12);
 6966   format %{ &quot;SRL     $dst,[$src] &amp; 31&quot; %}
 6967   ins_encode %{
 6968     __ z_lgr(Z_R1_scratch, $src$$Register);
 6969     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6970     __ z_srl($dst$$Register, 0, Z_R1_scratch);
 6971   %}
 6972   ins_pipe(pipe_class_dummy);
 6973 %}
 6974 
 6975 // Register Shift Right Immediate
 6976 // Constant shift count is masked in ideal graph already.
 6977 instruct srlI_reg_imm(iRegI dst, immI src) %{
 6978   match(Set dst (URShiftI dst src));
 6979   size(4);
 6980   format %{ &quot;SRL     $dst,$src&quot; %}
 6981   ins_encode %{
 6982     int Nbit = $src$$constant;
 6983     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6984     __ z_srl($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6985   %}
 6986   ins_pipe(pipe_class_dummy);
 6987 %}
 6988 
 6989 // Register Shift Right Long
 6990 instruct srlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 6991   match(Set dst (URShiftL src1 src2));
 6992   size(6);
 6993   format %{ &quot;SRLG    $dst,$src1,[$src2]&quot; %}
 6994   opcode(SRLG_ZOPC);
 6995   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 6996   ins_pipe(pipe_class_dummy);
 6997 %}
 6998 
 6999 // Register Shift Right Long Immediate
 7000 instruct srlL_reg_imm(iRegL dst, iRegL src1, immI src2) %{
 7001   match(Set dst (URShiftL src1 src2));
 7002   size(6);
 7003   format %{ &quot;SRLG    $dst,$src1,$src2&quot; %}
 7004   opcode(SRLG_ZOPC);
 7005   ins_encode(z_rsyform_const(dst, src1, src2));
 7006   ins_pipe(pipe_class_dummy);
 7007 %}
 7008 
 7009 // Register Shift Right Immediate with a CastP2X
 7010 instruct srlP_reg_imm(iRegL dst, iRegP_N2P src1, immI src2) %{
 7011   match(Set dst (URShiftL (CastP2X src1) src2));
 7012   size(6);
 7013   format %{ &quot;SRLG    $dst,$src1,$src2\t # Cast ptr $src1 to long and shift&quot; %}
 7014   opcode(SRLG_ZOPC);
 7015   ins_encode(z_rsyform_const(dst, src1, src2));
 7016   ins_pipe(pipe_class_dummy);
 7017 %}
 7018 
 7019 //----------Rotate Instructions------------------------------------------------
 7020 
 7021 // Rotate left 32bit.
 7022 instruct rotlI_reg_immI8(iRegI dst, iRegI src, immI8 lshift, immI8 rshift) %{
 7023   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 7024   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 7025   size(6);
 7026   format %{ &quot;RLL     $dst,$src,$lshift\t # ROTL32&quot; %}
 7027   opcode(RLL_ZOPC);
 7028   ins_encode(z_rsyform_const(dst, src, lshift));
 7029   ins_pipe(pipe_class_dummy);
 7030 %}
 7031 
 7032 // Rotate left 64bit.
 7033 instruct rotlL_reg_immI8(iRegL dst, iRegL src, immI8 lshift, immI8 rshift) %{
 7034   match(Set dst (OrL (LShiftL src lshift) (URShiftL src rshift)));
 7035   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 7036   size(6);
 7037   format %{ &quot;RLLG    $dst,$src,$lshift\t # ROTL64&quot; %}
 7038   opcode(RLLG_ZOPC);
 7039   ins_encode(z_rsyform_const(dst, src, lshift));
 7040   ins_pipe(pipe_class_dummy);
 7041 %}
 7042 
 7043 // Rotate right 32bit.
 7044 instruct rotrI_reg_immI8(iRegI dst, iRegI src, immI8 rshift, immI8 lshift) %{
 7045   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 7046   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 7047   // TODO: s390 port size(FIXED_SIZE);
 7048   format %{ &quot;RLL     $dst,$src,$rshift\t # ROTR32&quot; %}
 7049   opcode(RLL_ZOPC);
 7050   ins_encode(z_rsyform_const(dst, src, rshift));
 7051   ins_pipe(pipe_class_dummy);
 7052 %}
 7053 
 7054 // Rotate right 64bit.
 7055 instruct rotrL_reg_immI8(iRegL dst, iRegL src, immI8 rshift, immI8 lshift) %{
 7056   match(Set dst (OrL (URShiftL src rshift) (LShiftL src lshift)));
 7057   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 7058   // TODO: s390 port size(FIXED_SIZE);
 7059   format %{ &quot;RLLG    $dst,$src,$rshift\t # ROTR64&quot; %}
 7060   opcode(RLLG_ZOPC);
 7061   ins_encode(z_rsyform_const(dst, src, rshift));
 7062   ins_pipe(pipe_class_dummy);
 7063 %}
 7064 
 7065 
 7066 //----------Overflow Math Instructions-----------------------------------------
 7067 
 7068 instruct overflowAddI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7069   match(Set cr (OverflowAddI op1 op2));
 7070   effect(DEF cr, USE op1, USE op2);
 7071   // TODO: s390 port size(FIXED_SIZE);
 7072   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7073   ins_encode %{
 7074     __ z_lr(Z_R0_scratch, $op1$$Register);
 7075     __ z_ar(Z_R0_scratch, $op2$$Register);
 7076   %}
 7077   ins_pipe(pipe_class_dummy);
 7078 %}
 7079 
 7080 instruct overflowAddI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7081   match(Set cr (OverflowAddI op1 op2));
 7082   effect(DEF cr, USE op1, USE op2);
 7083   // TODO: s390 port size(VARIABLE_SIZE);
 7084   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7085   ins_encode %{
 7086     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7087     __ z_ar(Z_R0_scratch, $op1$$Register);
 7088   %}
 7089   ins_pipe(pipe_class_dummy);
 7090 %}
 7091 
 7092 instruct overflowAddL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7093   match(Set cr (OverflowAddL op1 op2));
 7094   effect(DEF cr, USE op1, USE op2);
 7095   // TODO: s390 port size(FIXED_SIZE);
 7096   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7097   ins_encode %{
 7098     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7099     __ z_agr(Z_R0_scratch, $op2$$Register);
 7100   %}
 7101   ins_pipe(pipe_class_dummy);
 7102 %}
 7103 
 7104 instruct overflowAddL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7105   match(Set cr (OverflowAddL op1 op2));
 7106   effect(DEF cr, USE op1, USE op2);
 7107   // TODO: s390 port size(VARIABLE_SIZE);
 7108   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7109   ins_encode %{
 7110     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7111     __ z_agr(Z_R0_scratch, $op1$$Register);
 7112   %}
 7113   ins_pipe(pipe_class_dummy);
 7114 %}
 7115 
 7116 instruct overflowSubI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7117   match(Set cr (OverflowSubI op1 op2));
 7118   effect(DEF cr, USE op1, USE op2);
 7119   // TODO: s390 port size(FIXED_SIZE);
 7120   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7121   ins_encode %{
 7122     __ z_lr(Z_R0_scratch, $op1$$Register);
 7123     __ z_sr(Z_R0_scratch, $op2$$Register);
 7124   %}
 7125   ins_pipe(pipe_class_dummy);
 7126 %}
 7127 
 7128 instruct overflowSubI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7129   match(Set cr (OverflowSubI op1 op2));
 7130   effect(DEF cr, USE op1, USE op2);
 7131   // TODO: s390 port size(VARIABLE_SIZE);
 7132   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7133   ins_encode %{
 7134     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7135     __ z_lr(Z_R0_scratch, $op1$$Register);
 7136     __ z_sr(Z_R0_scratch, Z_R1_scratch);
 7137   %}
 7138   ins_pipe(pipe_class_dummy);
 7139 %}
 7140 
 7141 instruct overflowSubL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7142   match(Set cr (OverflowSubL op1 op2));
 7143   effect(DEF cr, USE op1, USE op2);
 7144   // TODO: s390 port size(FIXED_SIZE);
 7145   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7146   ins_encode %{
 7147     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7148     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7149   %}
 7150   ins_pipe(pipe_class_dummy);
 7151 %}
 7152 
 7153 instruct overflowSubL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7154   match(Set cr (OverflowSubL op1 op2));
 7155   effect(DEF cr, USE op1, USE op2);
 7156   // TODO: s390 port size(VARIABLE_SIZE);
 7157   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7158   ins_encode %{
 7159     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7160     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7161     __ z_sgr(Z_R0_scratch, Z_R1_scratch);
 7162   %}
 7163   ins_pipe(pipe_class_dummy);
 7164 %}
 7165 
 7166 instruct overflowNegI_rReg(flagsReg cr, immI_0 zero, iRegI op2) %{
 7167   match(Set cr (OverflowSubI zero op2));
 7168   effect(DEF cr, USE op2);
 7169   format %{ &quot;NEG    $op2\t # overflow check int&quot; %}
 7170   ins_encode %{
 7171     __ clear_reg(Z_R0_scratch, false, false);
 7172     __ z_sr(Z_R0_scratch, $op2$$Register);
 7173   %}
 7174   ins_pipe(pipe_class_dummy);
 7175 %}
 7176 
 7177 instruct overflowNegL_rReg(flagsReg cr, immL_0 zero, iRegL op2) %{
 7178   match(Set cr (OverflowSubL zero op2));
 7179   effect(DEF cr, USE op2);
 7180   format %{ &quot;NEGG    $op2\t # overflow check long&quot; %}
 7181   ins_encode %{
 7182     __ clear_reg(Z_R0_scratch, true, false);
 7183     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7184   %}
 7185   ins_pipe(pipe_class_dummy);
 7186 %}
 7187 
 7188 // No intrinsics for multiplication, since there is no easy way
 7189 // to check for overflow.
 7190 
 7191 
 7192 //----------Floating Point Arithmetic Instructions-----------------------------
 7193 
 7194 //  ADD
 7195 
 7196 //  Add float single precision
 7197 instruct addF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7198   match(Set dst (AddF dst src));
 7199   effect(KILL cr);
 7200   ins_cost(ALU_REG_COST);
 7201   size(4);
 7202   format %{ &quot;AEBR     $dst,$src&quot; %}
 7203   opcode(AEBR_ZOPC);
 7204   ins_encode(z_rreform(dst, src));
 7205   ins_pipe(pipe_class_dummy);
 7206 %}
 7207 
 7208 instruct addF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7209   match(Set dst (AddF dst (LoadF src)));
 7210   effect(KILL cr);
 7211   ins_cost(ALU_MEMORY_COST);
 7212   size(6);
 7213   format %{ &quot;AEB      $dst,$src\t # floatMemory&quot; %}
 7214   opcode(AEB_ZOPC);
 7215   ins_encode(z_form_rt_memFP(dst, src));
 7216   ins_pipe(pipe_class_dummy);
 7217 %}
 7218 
 7219 // Add float double precision
 7220 instruct addD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7221   match(Set dst (AddD dst src));
 7222   effect(KILL cr);
 7223   ins_cost(ALU_REG_COST);
 7224   size(4);
 7225   format %{ &quot;ADBR     $dst,$src&quot; %}
 7226   opcode(ADBR_ZOPC);
 7227   ins_encode(z_rreform(dst, src));
 7228   ins_pipe(pipe_class_dummy);
 7229 %}
 7230 
 7231 instruct addD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7232   match(Set dst (AddD dst (LoadD src)));
 7233   effect(KILL cr);
 7234   ins_cost(ALU_MEMORY_COST);
 7235   size(6);
 7236   format %{ &quot;ADB      $dst,$src\t # doubleMemory&quot; %}
 7237   opcode(ADB_ZOPC);
 7238   ins_encode(z_form_rt_memFP(dst, src));
 7239   ins_pipe(pipe_class_dummy);
 7240 %}
 7241 
 7242 // SUB
 7243 
 7244 // Sub float single precision
 7245 instruct subF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7246   match(Set dst (SubF dst src));
 7247   effect(KILL cr);
 7248   ins_cost(ALU_REG_COST);
 7249   size(4);
 7250   format %{ &quot;SEBR     $dst,$src&quot; %}
 7251   opcode(SEBR_ZOPC);
 7252   ins_encode(z_rreform(dst, src));
 7253   ins_pipe(pipe_class_dummy);
 7254 %}
 7255 
 7256 instruct subF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7257   match(Set dst (SubF dst (LoadF src)));
 7258   effect(KILL cr);
 7259   ins_cost(ALU_MEMORY_COST);
 7260   size(6);
 7261   format %{ &quot;SEB      $dst,$src\t # floatMemory&quot; %}
 7262   opcode(SEB_ZOPC);
 7263   ins_encode(z_form_rt_memFP(dst, src));
 7264   ins_pipe(pipe_class_dummy);
 7265 %}
 7266 
 7267 //  Sub float double precision
 7268 instruct subD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7269   match(Set dst (SubD dst src));
 7270   effect(KILL cr);
 7271   ins_cost(ALU_REG_COST);
 7272   size(4);
 7273   format %{ &quot;SDBR     $dst,$src&quot; %}
 7274   opcode(SDBR_ZOPC);
 7275   ins_encode(z_rreform(dst, src));
 7276   ins_pipe(pipe_class_dummy);
 7277 %}
 7278 
 7279 instruct subD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7280   match(Set dst (SubD dst (LoadD src)));
 7281   effect(KILL cr);
 7282   ins_cost(ALU_MEMORY_COST);
 7283   size(6);
 7284   format %{ &quot;SDB      $dst,$src\t # doubleMemory&quot; %}
 7285   opcode(SDB_ZOPC);
 7286   ins_encode(z_form_rt_memFP(dst, src));
 7287   ins_pipe(pipe_class_dummy);
 7288 %}
 7289 
 7290 // MUL
 7291 
 7292 // Mul float single precision
 7293 instruct mulF_reg_reg(regF dst, regF src) %{
 7294   match(Set dst (MulF dst src));
 7295   // CC unchanged by MUL.
 7296   ins_cost(ALU_REG_COST);
 7297   size(4);
 7298   format %{ &quot;MEEBR    $dst,$src&quot; %}
 7299   opcode(MEEBR_ZOPC);
 7300   ins_encode(z_rreform(dst, src));
 7301   ins_pipe(pipe_class_dummy);
 7302 %}
 7303 
 7304 instruct mulF_reg_mem(regF dst, memoryRX src)%{
 7305   match(Set dst (MulF dst (LoadF src)));
 7306   // CC unchanged by MUL.
 7307   ins_cost(ALU_MEMORY_COST);
 7308   size(6);
 7309   format %{ &quot;MEEB     $dst,$src\t # floatMemory&quot; %}
 7310   opcode(MEEB_ZOPC);
 7311   ins_encode(z_form_rt_memFP(dst, src));
 7312   ins_pipe(pipe_class_dummy);
 7313 %}
 7314 
 7315 //  Mul float double precision
 7316 instruct mulD_reg_reg(regD dst, regD src) %{
 7317   match(Set dst (MulD dst src));
 7318   // CC unchanged by MUL.
 7319   ins_cost(ALU_REG_COST);
 7320   size(4);
 7321   format %{ &quot;MDBR     $dst,$src&quot; %}
 7322   opcode(MDBR_ZOPC);
 7323   ins_encode(z_rreform(dst, src));
 7324   ins_pipe(pipe_class_dummy);
 7325 %}
 7326 
 7327 instruct mulD_reg_mem(regD dst, memoryRX src)%{
 7328   match(Set dst (MulD dst (LoadD src)));
 7329   // CC unchanged by MUL.
 7330   ins_cost(ALU_MEMORY_COST);
 7331   size(6);
 7332   format %{ &quot;MDB      $dst,$src\t # doubleMemory&quot; %}
 7333   opcode(MDB_ZOPC);
 7334   ins_encode(z_form_rt_memFP(dst, src));
 7335   ins_pipe(pipe_class_dummy);
 7336 %}
 7337 
 7338 // Multiply-Accumulate
 7339 // src1 * src2 + dst
 7340 instruct maddF_reg_reg(regF dst, regF src1, regF src2) %{
 7341   match(Set dst (FmaF dst (Binary src1 src2)));
 7342   // CC unchanged by MUL-ADD.
 7343   ins_cost(ALU_REG_COST);
 7344   size(4);
 7345   format %{ &quot;MAEBR    $dst, $src1, $src2&quot; %}
 7346   ins_encode %{
 7347     __ z_maebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7348   %}
 7349   ins_pipe(pipe_class_dummy);
 7350 %}
 7351 
 7352 // src1 * src2 + dst
 7353 instruct maddD_reg_reg(regD dst, regD src1, regD src2) %{
 7354   match(Set dst (FmaD dst (Binary src1 src2)));
 7355   // CC unchanged by MUL-ADD.
 7356   ins_cost(ALU_REG_COST);
 7357   size(4);
 7358   format %{ &quot;MADBR    $dst, $src1, $src2&quot; %}
 7359   ins_encode %{
 7360     __ z_madbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7361   %}
 7362   ins_pipe(pipe_class_dummy);
 7363 %}
 7364 
 7365 // src1 * src2 - dst
 7366 instruct msubF_reg_reg(regF dst, regF src1, regF src2) %{
 7367   match(Set dst (FmaF (NegF dst) (Binary src1 src2)));
 7368   // CC unchanged by MUL-SUB.
 7369   ins_cost(ALU_REG_COST);
 7370   size(4);
 7371   format %{ &quot;MSEBR    $dst, $src1, $src2&quot; %}
 7372   ins_encode %{
 7373     __ z_msebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7374   %}
 7375   ins_pipe(pipe_class_dummy);
 7376 %}
 7377 
 7378 // src1 * src2 - dst
 7379 instruct msubD_reg_reg(regD dst, regD src1, regD src2) %{
 7380   match(Set dst (FmaD (NegD dst) (Binary src1 src2)));
 7381   // CC unchanged by MUL-SUB.
 7382   ins_cost(ALU_REG_COST);
 7383   size(4);
 7384   format %{ &quot;MSDBR    $dst, $src1, $src2&quot; %}
 7385   ins_encode %{
 7386     __ z_msdbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7387   %}
 7388   ins_pipe(pipe_class_dummy);
 7389 %}
 7390 
 7391 // src1 * src2 + dst
 7392 instruct maddF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7393   match(Set dst (FmaF dst (Binary src1 (LoadF src2))));
 7394   // CC unchanged by MUL-ADD.
 7395   ins_cost(ALU_MEMORY_COST);
 7396   size(6);
 7397   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7398   ins_encode %{
 7399     __ z_maeb($dst$$FloatRegister, $src1$$FloatRegister,
 7400               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7401   %}
 7402   ins_pipe(pipe_class_dummy);
 7403 %}
 7404 
 7405 // src1 * src2 + dst
 7406 instruct maddD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7407   match(Set dst (FmaD dst (Binary src1 (LoadD src2))));
 7408   // CC unchanged by MUL-ADD.
 7409   ins_cost(ALU_MEMORY_COST);
 7410   size(6);
 7411   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7412   ins_encode %{
 7413     __ z_madb($dst$$FloatRegister, $src1$$FloatRegister,
 7414               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7415   %}
 7416   ins_pipe(pipe_class_dummy);
 7417 %}
 7418 
 7419 // src1 * src2 - dst
 7420 instruct msubF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7421   match(Set dst (FmaF (NegF dst) (Binary src1 (LoadF src2))));
 7422   // CC unchanged by MUL-SUB.
 7423   ins_cost(ALU_MEMORY_COST);
 7424   size(6);
 7425   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7426   ins_encode %{
 7427     __ z_mseb($dst$$FloatRegister, $src1$$FloatRegister,
 7428               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7429   %}
 7430   ins_pipe(pipe_class_dummy);
 7431 %}
 7432 
 7433 // src1 * src2 - dst
 7434 instruct msubD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7435   match(Set dst (FmaD (NegD dst) (Binary src1 (LoadD src2))));
 7436   // CC unchanged by MUL-SUB.
 7437   ins_cost(ALU_MEMORY_COST);
 7438   size(6);
 7439   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7440   ins_encode %{
 7441     __ z_msdb($dst$$FloatRegister, $src1$$FloatRegister,
 7442               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7443   %}
 7444   ins_pipe(pipe_class_dummy);
 7445 %}
 7446 
 7447 // src1 * src2 + dst
 7448 instruct maddF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7449   match(Set dst (FmaF dst (Binary (LoadF src1) src2)));
 7450   // CC unchanged by MUL-ADD.
 7451   ins_cost(ALU_MEMORY_COST);
 7452   size(6);
 7453   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7454   ins_encode %{
 7455     __ z_maeb($dst$$FloatRegister, $src2$$FloatRegister,
 7456               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7457   %}
 7458   ins_pipe(pipe_class_dummy);
 7459 %}
 7460 
 7461 // src1 * src2 + dst
 7462 instruct maddD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7463   match(Set dst (FmaD dst (Binary (LoadD src1) src2)));
 7464   // CC unchanged by MUL-ADD.
 7465   ins_cost(ALU_MEMORY_COST);
 7466   size(6);
 7467   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7468   ins_encode %{
 7469     __ z_madb($dst$$FloatRegister, $src2$$FloatRegister,
 7470               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7471   %}
 7472   ins_pipe(pipe_class_dummy);
 7473 %}
 7474 
 7475 // src1 * src2 - dst
 7476 instruct msubF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7477   match(Set dst (FmaF (NegF dst) (Binary (LoadF src1) src2)));
 7478   // CC unchanged by MUL-SUB.
 7479   ins_cost(ALU_MEMORY_COST);
 7480   size(6);
 7481   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7482   ins_encode %{
 7483     __ z_mseb($dst$$FloatRegister, $src2$$FloatRegister,
 7484               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7485   %}
 7486   ins_pipe(pipe_class_dummy);
 7487 %}
 7488 
 7489 // src1 * src2 - dst
 7490 instruct msubD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7491   match(Set dst (FmaD (NegD dst) (Binary (LoadD src1) src2)));
 7492   // CC unchanged by MUL-SUB.
 7493   ins_cost(ALU_MEMORY_COST);
 7494   size(6);
 7495   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7496   ins_encode %{
 7497     __ z_msdb($dst$$FloatRegister, $src2$$FloatRegister,
 7498               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7499   %}
 7500   ins_pipe(pipe_class_dummy);
 7501 %}
 7502 
 7503 //  DIV
 7504 
 7505 //  Div float single precision
 7506 instruct divF_reg_reg(regF dst, regF src) %{
 7507   match(Set dst (DivF dst src));
 7508   // CC unchanged by DIV.
 7509   ins_cost(ALU_REG_COST);
 7510   size(4);
 7511   format %{ &quot;DEBR     $dst,$src&quot; %}
 7512   opcode(DEBR_ZOPC);
 7513   ins_encode(z_rreform(dst, src));
 7514   ins_pipe(pipe_class_dummy);
 7515 %}
 7516 
 7517 instruct divF_reg_mem(regF dst, memoryRX src)%{
 7518   match(Set dst (DivF dst (LoadF src)));
 7519   // CC unchanged by DIV.
 7520   ins_cost(ALU_MEMORY_COST);
 7521   size(6);
 7522   format %{ &quot;DEB      $dst,$src\t # floatMemory&quot; %}
 7523   opcode(DEB_ZOPC);
 7524   ins_encode(z_form_rt_memFP(dst, src));
 7525   ins_pipe(pipe_class_dummy);
 7526 %}
 7527 
 7528 //  Div float double precision
 7529 instruct divD_reg_reg(regD dst, regD src) %{
 7530   match(Set dst (DivD dst src));
 7531   // CC unchanged by DIV.
 7532   ins_cost(ALU_REG_COST);
 7533   size(4);
 7534   format %{ &quot;DDBR     $dst,$src&quot; %}
 7535   opcode(DDBR_ZOPC);
 7536   ins_encode(z_rreform(dst, src));
 7537   ins_pipe(pipe_class_dummy);
 7538 %}
 7539 
 7540 instruct divD_reg_mem(regD dst, memoryRX src)%{
 7541   match(Set dst (DivD dst (LoadD src)));
 7542   // CC unchanged by DIV.
 7543   ins_cost(ALU_MEMORY_COST);
 7544   size(6);
 7545   format %{ &quot;DDB      $dst,$src\t # doubleMemory&quot; %}
 7546   opcode(DDB_ZOPC);
 7547   ins_encode(z_form_rt_memFP(dst, src));
 7548   ins_pipe(pipe_class_dummy);
 7549 %}
 7550 
 7551 // ABS
 7552 
 7553 // Absolute float single precision
 7554 instruct absF_reg(regF dst, regF src, flagsReg cr) %{
 7555   match(Set dst (AbsF src));
 7556   effect(KILL cr);
 7557   size(4);
 7558   format %{ &quot;LPEBR    $dst,$src\t float&quot; %}
 7559   opcode(LPEBR_ZOPC);
 7560   ins_encode(z_rreform(dst, src));
 7561   ins_pipe(pipe_class_dummy);
 7562 %}
 7563 
 7564 // Absolute float double precision
 7565 instruct absD_reg(regD dst, regD src, flagsReg cr) %{
 7566   match(Set dst (AbsD src));
 7567   effect(KILL cr);
 7568   size(4);
 7569   format %{ &quot;LPDBR    $dst,$src\t double&quot; %}
 7570   opcode(LPDBR_ZOPC);
 7571   ins_encode(z_rreform(dst, src));
 7572   ins_pipe(pipe_class_dummy);
 7573 %}
 7574 
 7575 //  NEG(ABS)
 7576 
 7577 // Negative absolute float single precision
 7578 instruct nabsF_reg(regF dst, regF src, flagsReg cr) %{
 7579   match(Set dst (NegF (AbsF src)));
 7580   effect(KILL cr);
 7581   size(4);
 7582   format %{ &quot;LNEBR    $dst,$src\t float&quot; %}
 7583   opcode(LNEBR_ZOPC);
 7584   ins_encode(z_rreform(dst, src));
 7585   ins_pipe(pipe_class_dummy);
 7586 %}
 7587 
 7588 // Negative absolute float double precision
 7589 instruct nabsD_reg(regD dst, regD src, flagsReg cr) %{
 7590   match(Set dst (NegD (AbsD src)));
 7591   effect(KILL cr);
 7592   size(4);
 7593   format %{ &quot;LNDBR    $dst,$src\t double&quot; %}
 7594   opcode(LNDBR_ZOPC);
 7595   ins_encode(z_rreform(dst, src));
 7596   ins_pipe(pipe_class_dummy);
 7597 %}
 7598 
 7599 // NEG
 7600 
 7601 instruct negF_reg(regF dst, regF src, flagsReg cr) %{
 7602   match(Set dst (NegF src));
 7603   effect(KILL cr);
 7604   size(4);
 7605   format %{ &quot;NegF     $dst,$src\t float&quot; %}
 7606   ins_encode %{ __ z_lcebr($dst$$FloatRegister, $src$$FloatRegister); %}
 7607   ins_pipe(pipe_class_dummy);
 7608 %}
 7609 
 7610 instruct negD_reg(regD dst, regD src, flagsReg cr) %{
 7611   match(Set dst (NegD src));
 7612   effect(KILL cr);
 7613   size(4);
 7614   format %{ &quot;NegD     $dst,$src\t double&quot; %}
 7615   ins_encode %{ __ z_lcdbr($dst$$FloatRegister, $src$$FloatRegister); %}
 7616   ins_pipe(pipe_class_dummy);
 7617 %}
 7618 
 7619 // SQRT
 7620 
 7621 // Sqrt float precision
 7622 instruct sqrtF_reg(regF dst, regF src) %{
 7623   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7624   // CC remains unchanged.
 7625   ins_cost(ALU_REG_COST);
 7626   size(4);
 7627   format %{ &quot;SQEBR    $dst,$src&quot; %}
 7628   opcode(SQEBR_ZOPC);
 7629   ins_encode(z_rreform(dst, src));
 7630   ins_pipe(pipe_class_dummy);
 7631 %}
 7632 
 7633 // Sqrt double precision
 7634 instruct sqrtD_reg(regD dst, regD src) %{
 7635   match(Set dst (SqrtD src));
 7636   // CC remains unchanged.
 7637   ins_cost(ALU_REG_COST);
 7638   size(4);
 7639   format %{ &quot;SQDBR    $dst,$src&quot; %}
 7640   opcode(SQDBR_ZOPC);
 7641   ins_encode(z_rreform(dst, src));
 7642   ins_pipe(pipe_class_dummy);
 7643 %}
 7644 
 7645 instruct sqrtF_mem(regF dst, memoryRX src) %{
 7646   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7647   // CC remains unchanged.
 7648   ins_cost(ALU_MEMORY_COST);
 7649   size(6);
 7650   format %{ &quot;SQEB     $dst,$src\t # floatMemory&quot; %}
 7651   opcode(SQEB_ZOPC);
 7652   ins_encode(z_form_rt_memFP(dst, src));
 7653   ins_pipe(pipe_class_dummy);
 7654 %}
 7655 
 7656 instruct sqrtD_mem(regD dst, memoryRX src) %{
 7657   match(Set dst (SqrtD src));
 7658   // CC remains unchanged.
 7659   ins_cost(ALU_MEMORY_COST);
 7660   // TODO: s390 port size(FIXED_SIZE);
 7661   format %{ &quot;SQDB     $dst,$src\t # doubleMemory&quot; %}
 7662   opcode(SQDB_ZOPC);
 7663   ins_encode(z_form_rt_memFP(dst, src));
 7664   ins_pipe(pipe_class_dummy);
 7665 %}
 7666 
 7667 //----------Logical Instructions-----------------------------------------------
 7668 
 7669 // Register And
 7670 instruct andI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7671   match(Set dst (AndI dst src));
 7672   effect(KILL cr);
 7673   ins_cost(DEFAULT_COST_LOW);
 7674   size(2);
 7675   format %{ &quot;NR      $dst,$src\t # int&quot; %}
 7676   opcode(NR_ZOPC);
 7677   ins_encode(z_rrform(dst, src));
 7678   ins_pipe(pipe_class_dummy);
 7679 %}
 7680 
 7681 instruct andI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7682   match(Set dst (AndI dst (LoadI src)));
 7683   effect(KILL cr);
 7684   ins_cost(MEMORY_REF_COST);
 7685   // TODO: s390 port size(VARIABLE_SIZE);
 7686   format %{ &quot;N(Y)    $dst, $src\t # int&quot; %}
 7687   opcode(NY_ZOPC, N_ZOPC);
 7688   ins_encode(z_form_rt_mem_opt(dst, src));
 7689   ins_pipe(pipe_class_dummy);
 7690 %}
 7691 
 7692 // Immediate And
 7693 instruct andI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7694   match(Set dst (AndI dst src));
 7695   effect(KILL cr);
 7696   ins_cost(DEFAULT_COST_HIGH);
 7697   size(6);
 7698   format %{ &quot;NILF    $dst,$src&quot; %}
 7699   opcode(NILF_ZOPC);
 7700   ins_encode(z_rilform_unsigned(dst, src));
 7701   ins_pipe(pipe_class_dummy);
 7702 %}
 7703 
 7704 instruct andI_reg_uimmI_LH1(iRegI dst, uimmI_LH1 src, flagsReg cr) %{
 7705   match(Set dst (AndI dst src));
 7706   effect(KILL cr);
 7707   ins_cost(DEFAULT_COST);
 7708   size(4);
 7709   format %{ &quot;NILH    $dst,$src&quot; %}
 7710   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7711   ins_pipe(pipe_class_dummy);
 7712 %}
 7713 
 7714 instruct andI_reg_uimmI_LL1(iRegI dst, uimmI_LL1 src, flagsReg cr) %{
 7715   match(Set dst (AndI dst src));
 7716   effect(KILL cr);
 7717   ins_cost(DEFAULT_COST);
 7718   size(4);
 7719   format %{ &quot;NILL    $dst,$src&quot; %}
 7720   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7721   ins_pipe(pipe_class_dummy);
 7722 %}
 7723 
 7724 // Register And Long
 7725 instruct andL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7726   match(Set dst (AndL dst src));
 7727   effect(KILL cr);
 7728   ins_cost(DEFAULT_COST);
 7729   size(4);
 7730   format %{ &quot;NGR     $dst,$src\t # long&quot; %}
 7731   opcode(NGR_ZOPC);
 7732   ins_encode(z_rreform(dst, src));
 7733   ins_pipe(pipe_class_dummy);
 7734 %}
 7735 
 7736 instruct andL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7737   match(Set dst (AndL dst (LoadL src)));
 7738   effect(KILL cr);
 7739   ins_cost(MEMORY_REF_COST);
 7740   size(Z_DISP3_SIZE);
 7741   format %{ &quot;NG      $dst, $src\t # long&quot; %}
 7742   opcode(NG_ZOPC, NG_ZOPC);
 7743   ins_encode(z_form_rt_mem_opt(dst, src));
 7744   ins_pipe(pipe_class_dummy);
 7745 %}
 7746 
 7747 instruct andL_reg_uimmL_LL1(iRegL dst, uimmL_LL1 src, flagsReg cr) %{
 7748   match(Set dst (AndL dst src));
 7749   effect(KILL cr);
 7750   ins_cost(DEFAULT_COST);
 7751   size(4);
 7752   format %{ &quot;NILL    $dst,$src\t # long&quot; %}
 7753   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7754   ins_pipe(pipe_class_dummy);
 7755 %}
 7756 
 7757 instruct andL_reg_uimmL_LH1(iRegL dst, uimmL_LH1 src, flagsReg cr) %{
 7758   match(Set dst (AndL dst src));
 7759   effect(KILL cr);
 7760   ins_cost(DEFAULT_COST);
 7761   size(4);
 7762   format %{ &quot;NILH    $dst,$src\t # long&quot; %}
 7763   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7764   ins_pipe(pipe_class_dummy);
 7765 %}
 7766 
 7767 instruct andL_reg_uimmL_HL1(iRegL dst, uimmL_HL1 src, flagsReg cr) %{
 7768   match(Set dst (AndL dst src));
 7769   effect(KILL cr);
 7770   ins_cost(DEFAULT_COST);
 7771   size(4);
 7772   format %{ &quot;NIHL    $dst,$src\t # long&quot; %}
 7773   ins_encode %{ __ z_nihl($dst$$Register, ($src$$constant &gt;&gt; 32) &amp; 0xFFFF); %}
 7774   ins_pipe(pipe_class_dummy);
 7775 %}
 7776 
 7777 instruct andL_reg_uimmL_HH1(iRegL dst, uimmL_HH1 src, flagsReg cr) %{
 7778   match(Set dst (AndL dst src));
 7779   effect(KILL cr);
 7780   ins_cost(DEFAULT_COST);
 7781   size(4);
 7782   format %{ &quot;NIHH    $dst,$src\t # long&quot; %}
 7783   ins_encode %{ __ z_nihh($dst$$Register, ($src$$constant &gt;&gt; 48) &amp; 0xFFFF); %}
 7784   ins_pipe(pipe_class_dummy);
 7785 %}
 7786 
 7787 //  OR
 7788 
 7789 // Or Instructions
 7790 // Register Or
 7791 instruct orI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7792   match(Set dst (OrI dst src));
 7793   effect(KILL cr);
 7794   size(2);
 7795   format %{ &quot;OR      $dst,$src&quot; %}
 7796   opcode(OR_ZOPC);
 7797   ins_encode(z_rrform(dst, src));
 7798   ins_pipe(pipe_class_dummy);
 7799 %}
 7800 
 7801 instruct orI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7802   match(Set dst (OrI dst (LoadI src)));
 7803   effect(KILL cr);
 7804   ins_cost(MEMORY_REF_COST);
 7805   // TODO: s390 port size(VARIABLE_SIZE);
 7806   format %{ &quot;O(Y)    $dst, $src\t # int&quot; %}
 7807   opcode(OY_ZOPC, O_ZOPC);
 7808   ins_encode(z_form_rt_mem_opt(dst, src));
 7809   ins_pipe(pipe_class_dummy);
 7810 %}
 7811 
 7812 // Immediate Or
 7813 instruct orI_reg_uimm16(iRegI dst, uimmI16 con, flagsReg cr) %{
 7814   match(Set dst (OrI dst con));
 7815   effect(KILL cr);
 7816   size(4);
 7817   format %{ &quot;OILL    $dst,$con&quot; %}
 7818   opcode(OILL_ZOPC);
 7819   ins_encode(z_riform_unsigned(dst,con));
 7820   ins_pipe(pipe_class_dummy);
 7821 %}
 7822 
 7823 instruct orI_reg_uimm32(iRegI dst, uimmI con, flagsReg cr) %{
 7824   match(Set dst (OrI dst con));
 7825   effect(KILL cr);
 7826   ins_cost(DEFAULT_COST_HIGH);
 7827   size(6);
 7828   format %{ &quot;OILF    $dst,$con&quot; %}
 7829   opcode(OILF_ZOPC);
 7830   ins_encode(z_rilform_unsigned(dst,con));
 7831   ins_pipe(pipe_class_dummy);
 7832 %}
 7833 
 7834 // Register Or Long
 7835 instruct orL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7836   match(Set dst (OrL dst src));
 7837   effect(KILL cr);
 7838   ins_cost(DEFAULT_COST);
 7839   size(4);
 7840   format %{ &quot;OGR      $dst,$src\t # long&quot; %}
 7841   opcode(OGR_ZOPC);
 7842   ins_encode(z_rreform(dst, src));
 7843   ins_pipe(pipe_class_dummy);
 7844 %}
 7845 
 7846 instruct orL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7847   match(Set dst (OrL dst (LoadL src)));
 7848   effect(KILL cr);
 7849   ins_cost(MEMORY_REF_COST);
 7850   size(Z_DISP3_SIZE);
 7851   format %{ &quot;OG      $dst, $src\t # long&quot; %}
 7852   opcode(OG_ZOPC, OG_ZOPC);
 7853   ins_encode(z_form_rt_mem_opt(dst, src));
 7854   ins_pipe(pipe_class_dummy);
 7855 %}
 7856 
 7857 // Immediate Or long
 7858 instruct orL_reg_uimm16(iRegL dst, uimmL16 con, flagsReg cr) %{
 7859   match(Set dst (OrL dst con));
 7860   effect(KILL cr);
 7861   ins_cost(DEFAULT_COST);
 7862   size(4);
 7863   format %{ &quot;OILL    $dst,$con\t # long&quot; %}
 7864   opcode(OILL_ZOPC);
 7865   ins_encode(z_riform_unsigned(dst,con));
 7866   ins_pipe(pipe_class_dummy);
 7867 %}
 7868 
 7869 instruct orL_reg_uimm32(iRegI dst, uimmL32 con, flagsReg cr) %{
 7870   match(Set dst (OrI dst con));
 7871   effect(KILL cr);
 7872   ins_cost(DEFAULT_COST_HIGH);
 7873   // TODO: s390 port size(FIXED_SIZE);
 7874   format %{ &quot;OILF    $dst,$con\t # long&quot; %}
 7875   opcode(OILF_ZOPC);
 7876   ins_encode(z_rilform_unsigned(dst,con));
 7877   ins_pipe(pipe_class_dummy);
 7878 %}
 7879 
 7880 // XOR
 7881 
 7882 // Register Xor
 7883 instruct xorI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7884   match(Set dst (XorI dst src));
 7885   effect(KILL cr);
 7886   size(2);
 7887   format %{ &quot;XR      $dst,$src&quot; %}
 7888   opcode(XR_ZOPC);
 7889   ins_encode(z_rrform(dst, src));
 7890   ins_pipe(pipe_class_dummy);
 7891 %}
 7892 
 7893 instruct xorI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7894   match(Set dst (XorI dst (LoadI src)));
 7895   effect(KILL cr);
 7896   ins_cost(MEMORY_REF_COST);
 7897   // TODO: s390 port size(VARIABLE_SIZE);
 7898   format %{ &quot;X(Y)    $dst, $src\t # int&quot; %}
 7899   opcode(XY_ZOPC, X_ZOPC);
 7900   ins_encode(z_form_rt_mem_opt(dst, src));
 7901   ins_pipe(pipe_class_dummy);
 7902 %}
 7903 
 7904 // Immediate Xor
 7905 instruct xorI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7906   match(Set dst (XorI dst src));
 7907   effect(KILL cr);
 7908   ins_cost(DEFAULT_COST_HIGH);
 7909   size(6);
 7910   format %{ &quot;XILF    $dst,$src&quot; %}
 7911   opcode(XILF_ZOPC);
 7912   ins_encode(z_rilform_unsigned(dst, src));
 7913   ins_pipe(pipe_class_dummy);
 7914 %}
 7915 
 7916 // Register Xor Long
 7917 instruct xorL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7918   match(Set dst (XorL dst src));
 7919   effect(KILL cr);
 7920   ins_cost(DEFAULT_COST);
 7921   size(4);
 7922   format %{ &quot;XGR     $dst,$src\t # long&quot; %}
 7923   opcode(XGR_ZOPC);
 7924   ins_encode(z_rreform(dst, src));
 7925   ins_pipe(pipe_class_dummy);
 7926 %}
 7927 
 7928 instruct xorL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7929   match(Set dst (XorL dst (LoadL src)));
 7930   effect(KILL cr);
 7931   ins_cost(MEMORY_REF_COST);
 7932   size(Z_DISP3_SIZE);
 7933   format %{ &quot;XG      $dst, $src\t # long&quot; %}
 7934   opcode(XG_ZOPC, XG_ZOPC);
 7935   ins_encode(z_form_rt_mem_opt(dst, src));
 7936   ins_pipe(pipe_class_dummy);
 7937 %}
 7938 
 7939 // Immediate Xor Long
 7940 instruct xorL_reg_uimm32(iRegL dst, uimmL32 con, flagsReg cr) %{
 7941   match(Set dst (XorL dst con));
 7942   effect(KILL cr);
 7943   ins_cost(DEFAULT_COST_HIGH);
 7944   size(6);
 7945   format %{ &quot;XILF    $dst,$con\t # long&quot; %}
 7946   opcode(XILF_ZOPC);
 7947   ins_encode(z_rilform_unsigned(dst,con));
 7948   ins_pipe(pipe_class_dummy);
 7949 %}
 7950 
 7951 //----------Convert to Boolean-------------------------------------------------
 7952 
 7953 // Convert integer to boolean.
 7954 instruct convI2B(iRegI dst, iRegI src, flagsReg cr) %{
 7955   match(Set dst (Conv2B src));
 7956   effect(KILL cr);
 7957   ins_cost(3 * DEFAULT_COST);
 7958   size(6);
 7959   format %{ &quot;convI2B $dst,$src&quot; %}
 7960   ins_encode %{
 7961     __ z_lnr($dst$$Register, $src$$Register);  // Rdst := -|Rsrc|, i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7962     __ z_srl($dst$$Register, 31);              // Rdst := sign(Rdest)
 7963   %}
 7964   ins_pipe(pipe_class_dummy);
 7965 %}
 7966 
 7967 instruct convP2B(iRegI dst, iRegP_N2P src, flagsReg cr) %{
 7968   match(Set dst (Conv2B src));
 7969   effect(KILL cr);
 7970   ins_cost(3 * DEFAULT_COST);
 7971   size(10);
 7972   format %{ &quot;convP2B $dst,$src&quot; %}
 7973   ins_encode %{
 7974     __ z_lngr($dst$$Register, $src$$Register);     // Rdst := -|Rsrc| i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7975     __ z_srlg($dst$$Register, $dst$$Register, 63); // Rdst := sign(Rdest)
 7976   %}
 7977   ins_pipe(pipe_class_dummy);
 7978 %}
 7979 
 7980 instruct cmpLTMask_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7981   match(Set dst (CmpLTMask dst src));
 7982   effect(KILL cr);
 7983   ins_cost(2 * DEFAULT_COST);
 7984   size(18);
 7985   format %{ &quot;Set $dst CmpLTMask $dst,$src&quot; %}
 7986   ins_encode %{
 7987     // Avoid signed 32 bit overflow: Do sign extend and sub 64 bit.
 7988     __ z_lgfr(Z_R0_scratch, $src$$Register);
 7989     __ z_lgfr($dst$$Register, $dst$$Register);
 7990     __ z_sgr($dst$$Register, Z_R0_scratch);
 7991     __ z_srag($dst$$Register, $dst$$Register, 63);
 7992   %}
 7993   ins_pipe(pipe_class_dummy);
 7994 %}
 7995 
 7996 instruct cmpLTMask_reg_zero(iRegI dst, immI_0 zero, flagsReg cr) %{
 7997   match(Set dst (CmpLTMask dst zero));
 7998   effect(KILL cr);
 7999   ins_cost(DEFAULT_COST);
 8000   size(4);
 8001   format %{ &quot;Set $dst CmpLTMask $dst,$zero&quot; %}
 8002   ins_encode %{ __ z_sra($dst$$Register, 31); %}
 8003   ins_pipe(pipe_class_dummy);
 8004 %}
 8005 
 8006 
 8007 //----------Arithmetic Conversion Instructions---------------------------------
 8008 // The conversions operations are all Alpha sorted. Please keep it that way!
 8009 
 8010 instruct convD2F_reg(regF dst, regD src) %{
 8011   match(Set dst (ConvD2F src));
 8012   // CC remains unchanged.
 8013   size(4);
 8014   format %{ &quot;LEDBR   $dst,$src&quot; %}
 8015   opcode(LEDBR_ZOPC);
 8016   ins_encode(z_rreform(dst, src));
 8017   ins_pipe(pipe_class_dummy);
 8018 %}
 8019 
 8020 instruct convF2I_reg(iRegI dst, regF src, flagsReg cr) %{
 8021   match(Set dst (ConvF2I src));
 8022   effect(KILL cr);
 8023   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8024   size(16);
 8025   format %{ &quot;convF2I  $dst,$src&quot; %}
 8026   ins_encode %{
 8027     Label done;
 8028     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 8029     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8030     __ z_brno(done);                             // Result is zero if unordered argument.
 8031     __ z_cfebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8032     __ bind(done);
 8033   %}
 8034   ins_pipe(pipe_class_dummy);
 8035 %}
 8036 
 8037 instruct convD2I_reg(iRegI dst, regD src, flagsReg cr) %{
 8038   match(Set dst (ConvD2I src));
 8039   effect(KILL cr);
 8040   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8041   size(16);
 8042   format %{ &quot;convD2I  $dst,$src&quot; %}
 8043   ins_encode %{
 8044     Label done;
 8045     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 8046     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8047     __ z_brno(done);                             // Result is zero if unordered argument.
 8048     __ z_cfdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8049     __ bind(done);
 8050   %}
 8051   ins_pipe(pipe_class_dummy);
 8052 %}
 8053 
 8054 instruct convF2L_reg(iRegL dst, regF src, flagsReg cr) %{
 8055   match(Set dst (ConvF2L src));
 8056   effect(KILL cr);
 8057   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8058   size(16);
 8059   format %{ &quot;convF2L  $dst,$src&quot; %}
 8060   ins_encode %{
 8061     Label done;
 8062     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8063     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8064     __ z_brno(done);                             // Result is zero if unordered argument.
 8065     __ z_cgebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8066     __ bind(done);
 8067   %}
 8068   ins_pipe(pipe_class_dummy);
 8069 %}
 8070 
 8071 instruct convD2L_reg(iRegL dst, regD src, flagsReg cr) %{
 8072   match(Set dst (ConvD2L src));
 8073   effect(KILL cr);
 8074   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8075   size(16);
 8076   format %{ &quot;convD2L  $dst,$src&quot; %}
 8077   ins_encode %{
 8078     Label done;
 8079     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8080     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8081     __ z_brno(done);                             // Result is zero if unordered argument.
 8082     __ z_cgdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8083     __ bind(done);
 8084   %}
 8085   ins_pipe(pipe_class_dummy);
 8086 %}
 8087 
 8088 instruct convF2D_reg(regD dst, regF src) %{
 8089   match(Set dst (ConvF2D src));
 8090   // CC remains unchanged.
 8091   size(4);
 8092   format %{ &quot;LDEBR   $dst,$src&quot; %}
 8093   opcode(LDEBR_ZOPC);
 8094   ins_encode(z_rreform(dst, src));
 8095   ins_pipe(pipe_class_dummy);
 8096 %}
 8097 
 8098 instruct convF2D_mem(regD dst, memoryRX src) %{
 8099   match(Set dst (ConvF2D src));
 8100   // CC remains unchanged.
 8101   size(6);
 8102   format %{ &quot;LDEB    $dst,$src&quot; %}
 8103   opcode(LDEB_ZOPC);
 8104   ins_encode(z_form_rt_memFP(dst, src));
 8105   ins_pipe(pipe_class_dummy);
 8106 %}
 8107 
 8108 instruct convI2D_reg(regD dst, iRegI src) %{
 8109   match(Set dst (ConvI2D src));
 8110   // CC remains unchanged.
 8111   ins_cost(DEFAULT_COST);
 8112   size(4);
 8113   format %{ &quot;CDFBR   $dst,$src&quot; %}
 8114   opcode(CDFBR_ZOPC);
 8115   ins_encode(z_rreform(dst, src));
 8116   ins_pipe(pipe_class_dummy);
 8117 %}
 8118 
 8119 // Optimization that saves up to two memory operations for each conversion.
 8120 instruct convI2F_ireg(regF dst, iRegI src) %{
 8121   match(Set dst (ConvI2F src));
 8122   // CC remains unchanged.
 8123   ins_cost(DEFAULT_COST);
 8124   size(4);
 8125   format %{ &quot;CEFBR   $dst,$src\t # convert int to float&quot; %}
 8126   opcode(CEFBR_ZOPC);
 8127   ins_encode(z_rreform(dst, src));
 8128   ins_pipe(pipe_class_dummy);
 8129 %}
 8130 
 8131 instruct convI2L_reg(iRegL dst, iRegI src) %{
 8132   match(Set dst (ConvI2L src));
 8133   size(4);
 8134   format %{ &quot;LGFR    $dst,$src\t # int-&gt;long&quot; %}
 8135   opcode(LGFR_ZOPC);
 8136   ins_encode(z_rreform(dst, src));
 8137   ins_pipe(pipe_class_dummy);
 8138 %}
 8139 
 8140 // Zero-extend convert int to long.
 8141 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask) %{
 8142   match(Set dst (AndL (ConvI2L src) mask));
 8143   size(4);
 8144   format %{ &quot;LLGFR   $dst, $src \t # zero-extend int to long&quot; %}
 8145   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8146   ins_pipe(pipe_class_dummy);
 8147 %}
 8148 
 8149 // Zero-extend convert int to long.
 8150 instruct convI2L_mem_zex(iRegL dst, memory src, immL_32bits mask) %{
 8151   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
 8152   // Uses load_const_optmized, so size can vary.
 8153   // TODO: s390 port size(VARIABLE_SIZE);
 8154   format %{ &quot;LLGF    $dst, $src \t # zero-extend int to long&quot; %}
 8155   opcode(LLGF_ZOPC, LLGF_ZOPC);
 8156   ins_encode(z_form_rt_mem_opt(dst, src));
 8157   ins_pipe(pipe_class_dummy);
 8158 %}
 8159 
 8160 // Zero-extend long
 8161 instruct zeroExtend_long(iRegL dst, iRegL src, immL_32bits mask) %{
 8162   match(Set dst (AndL src mask));
 8163   size(4);
 8164   format %{ &quot;LLGFR   $dst, $src \t # zero-extend long to long&quot; %}
 8165   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8166   ins_pipe(pipe_class_dummy);
 8167 %}
 8168 
 8169 instruct rShiftI16_lShiftI16_reg(iRegI dst, iRegI src, immI_16 amount) %{
 8170   match(Set dst (RShiftI (LShiftI src amount) amount));
 8171   size(4);
 8172   format %{ &quot;LHR     $dst,$src\t short-&gt;int&quot; %}
 8173   opcode(LHR_ZOPC);
 8174   ins_encode(z_rreform(dst, src));
 8175   ins_pipe(pipe_class_dummy);
 8176 %}
 8177 
 8178 instruct rShiftI24_lShiftI24_reg(iRegI dst, iRegI src, immI_24 amount) %{
 8179   match(Set dst (RShiftI (LShiftI src amount) amount));
 8180   size(4);
 8181   format %{ &quot;LBR     $dst,$src\t byte-&gt;int&quot; %}
 8182   opcode(LBR_ZOPC);
 8183   ins_encode(z_rreform(dst, src));
 8184   ins_pipe(pipe_class_dummy);
 8185 %}
 8186 
 8187 instruct MoveF2I_stack_reg(iRegI dst, stackSlotF src) %{
 8188   match(Set dst (MoveF2I src));
 8189   ins_cost(MEMORY_REF_COST);
 8190   size(4);
 8191   format %{ &quot;L       $dst,$src\t # MoveF2I&quot; %}
 8192   opcode(L_ZOPC);
 8193   ins_encode(z_form_rt_mem(dst, src));
 8194   ins_pipe(pipe_class_dummy);
 8195 %}
 8196 
 8197 // javax.imageio.stream.ImageInputStreamImpl.toFloats([B[FII)
 8198 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
 8199   match(Set dst (MoveI2F src));
 8200   ins_cost(MEMORY_REF_COST);
 8201   // TODO: s390 port size(FIXED_SIZE);
 8202   format %{ &quot;LE      $dst,$src\t # MoveI2F&quot; %}
 8203   opcode(LE_ZOPC);
 8204   ins_encode(z_form_rt_mem(dst, src));
 8205   ins_pipe(pipe_class_dummy);
 8206 %}
 8207 
 8208 instruct MoveD2L_stack_reg(iRegL dst, stackSlotD src) %{
 8209   match(Set dst (MoveD2L src));
 8210   ins_cost(MEMORY_REF_COST);
 8211   size(6);
 8212   format %{ &quot;LG      $src,$dst\t # MoveD2L&quot; %}
 8213   opcode(LG_ZOPC);
 8214   ins_encode(z_form_rt_mem(dst, src));
 8215   ins_pipe(pipe_class_dummy);
 8216 %}
 8217 
 8218 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
 8219   match(Set dst (MoveL2D src));
 8220   ins_cost(MEMORY_REF_COST);
 8221   size(4);
 8222   format %{ &quot;LD      $dst,$src\t # MoveL2D&quot; %}
 8223   opcode(LD_ZOPC);
 8224   ins_encode(z_form_rt_mem(dst, src));
 8225   ins_pipe(pipe_class_dummy);
 8226 %}
 8227 
 8228 instruct MoveI2F_reg_stack(stackSlotF dst, iRegI src) %{
 8229   match(Set dst (MoveI2F src));
 8230   ins_cost(MEMORY_REF_COST);
 8231   size(4);
 8232   format %{ &quot;ST      $src,$dst\t # MoveI2F&quot; %}
 8233   opcode(ST_ZOPC);
 8234   ins_encode(z_form_rt_mem(src, dst));
 8235   ins_pipe(pipe_class_dummy);
 8236 %}
 8237 
 8238 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
 8239   match(Set dst (MoveD2L src));
 8240   effect(DEF dst, USE src);
 8241   ins_cost(MEMORY_REF_COST);
 8242   size(4);
 8243   format %{ &quot;STD     $src,$dst\t # MoveD2L&quot; %}
 8244   opcode(STD_ZOPC);
 8245   ins_encode(z_form_rt_mem(src,dst));
 8246   ins_pipe(pipe_class_dummy);
 8247 %}
 8248 
 8249 instruct MoveL2D_reg_stack(stackSlotD dst, iRegL src) %{
 8250   match(Set dst (MoveL2D src));
 8251   ins_cost(MEMORY_REF_COST);
 8252   size(6);
 8253   format %{ &quot;STG     $src,$dst\t # MoveL2D&quot; %}
 8254   opcode(STG_ZOPC);
 8255   ins_encode(z_form_rt_mem(src,dst));
 8256   ins_pipe(pipe_class_dummy);
 8257 %}
 8258 
 8259 instruct convL2F_reg(regF dst, iRegL src) %{
 8260   match(Set dst (ConvL2F src));
 8261   // CC remains unchanged.
 8262   ins_cost(DEFAULT_COST);
 8263   size(4);
 8264   format %{ &quot;CEGBR   $dst,$src&quot; %}
 8265   opcode(CEGBR_ZOPC);
 8266   ins_encode(z_rreform(dst, src));
 8267   ins_pipe(pipe_class_dummy);
 8268 %}
 8269 
 8270 instruct convL2D_reg(regD dst, iRegL src) %{
 8271   match(Set dst (ConvL2D src));
 8272   // CC remains unchanged.
 8273   ins_cost(DEFAULT_COST);
 8274   size(4);
 8275   format %{ &quot;CDGBR   $dst,$src&quot; %}
 8276   opcode(CDGBR_ZOPC);
 8277   ins_encode(z_rreform(dst, src));
 8278   ins_pipe(pipe_class_dummy);
 8279 %}
 8280 
 8281 instruct convL2I_reg(iRegI dst, iRegL src) %{
 8282   match(Set dst (ConvL2I src));
 8283   // TODO: s390 port size(VARIABLE_SIZE);
 8284   format %{ &quot;LR      $dst,$src\t # long-&gt;int (if needed)&quot; %}
 8285   ins_encode %{ __ lr_if_needed($dst$$Register, $src$$Register); %}
 8286   ins_pipe(pipe_class_dummy);
 8287 %}
 8288 
 8289 // Register Shift Right Immediate
 8290 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt, flagsReg cr) %{
 8291   match(Set dst (ConvL2I (RShiftL src cnt)));
 8292   effect(KILL cr);
 8293   size(6);
 8294   format %{ &quot;SRAG    $dst,$src,$cnt&quot; %}
 8295   opcode(SRAG_ZOPC);
 8296   ins_encode(z_rsyform_const(dst, src, cnt));
 8297   ins_pipe(pipe_class_dummy);
 8298 %}
 8299 
 8300 //----------TRAP based zero checks and range checks----------------------------
 8301 
 8302 // SIGTRAP based implicit range checks in compiled code.
 8303 // A range check in the ideal world has one of the following shapes:
 8304 //   - (If le (CmpU length index)), (IfTrue  throw exception)
 8305 //   - (If lt (CmpU index length)), (IfFalse throw exception)
 8306 //
 8307 // Match range check &#39;If le (CmpU length index)&#39;
 8308 instruct rangeCheck_iReg_uimmI16(cmpOpT cmp, iRegI length, uimmI16 index, label labl) %{
 8309   match(If cmp (CmpU length index));
 8310   effect(USE labl);
 8311   predicate(TrapBasedRangeChecks &amp;&amp;
 8312             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
 8313             PROB_UNLIKELY(_leaf-&gt;as_If ()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
 8314             Matcher::branches_to_uncommon_trap(_leaf));
 8315   ins_cost(1);
 8316   // TODO: s390 port size(FIXED_SIZE);
 8317 
 8318   ins_is_TrapBasedCheckNode(true);
 8319 
 8320   format %{ &quot;RangeCheck len=$length cmp=$cmp idx=$index =&gt; trap $labl&quot; %}
 8321   ins_encode %{ __ z_clfit($length$$Register, $index$$constant, $cmp$$cmpcode); %}
 8322   ins_pipe(pipe_class_trap);
 8323 %}
 8324 
 8325 // Match range check &#39;If lt (CmpU index length)&#39;
 8326 instruct rangeCheck_iReg_iReg(cmpOpT cmp, iRegI index, iRegI length, label labl, flagsReg cr) %{
 8327   match(If cmp (CmpU index length));
 8328   effect(USE labl, KILL cr);
 8329   predicate(TrapBasedRangeChecks &amp;&amp;
 8330             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8331             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8332             Matcher::branches_to_uncommon_trap(_leaf));
 8333   ins_cost(1);
 8334   // TODO: s390 port size(FIXED_SIZE);
 8335 
 8336   ins_is_TrapBasedCheckNode(true);
 8337 
 8338   format %{ &quot;RangeCheck idx=$index cmp=$cmp len=$length =&gt; trap $labl&quot; %}
 8339   ins_encode %{ __ z_clrt($index$$Register, $length$$Register, $cmp$$cmpcode); %}
 8340   ins_pipe(pipe_class_trap);
 8341 %}
 8342 
 8343 // Match range check &#39;If lt (CmpU index length)&#39;
 8344 instruct rangeCheck_uimmI16_iReg(cmpOpT cmp, iRegI index, uimmI16 length, label labl) %{
 8345   match(If cmp (CmpU index length));
 8346   effect(USE labl);
 8347   predicate(TrapBasedRangeChecks &amp;&amp;
 8348             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8349             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8350             Matcher::branches_to_uncommon_trap(_leaf));
 8351   ins_cost(1);
 8352   // TODO: s390 port size(FIXED_SIZE);
 8353 
 8354   ins_is_TrapBasedCheckNode(true);
 8355 
 8356   format %{ &quot;RangeCheck idx=$index cmp=$cmp len= $length =&gt; trap $labl&quot; %}
 8357   ins_encode %{ __ z_clfit($index$$Register, $length$$constant, $cmp$$cmpcode); %}
 8358   ins_pipe(pipe_class_trap);
 8359 %}
 8360 
 8361 // Implicit zero checks (more implicit null checks).
 8362 instruct zeroCheckP_iReg_imm0(cmpOpT cmp, iRegP_N2P value, immP0 zero, label labl) %{
 8363   match(If cmp (CmpP value zero));
 8364   effect(USE labl);
 8365   predicate(TrapBasedNullChecks &amp;&amp;
 8366             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8367             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8368             Matcher::branches_to_uncommon_trap(_leaf));
 8369   size(6);
 8370 
 8371   ins_is_TrapBasedCheckNode(true);
 8372 
 8373   format %{ &quot;ZeroCheckP value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8374   ins_encode %{ __ z_cgit($value$$Register, 0, $cmp$$cmpcode); %}
 8375   ins_pipe(pipe_class_trap);
 8376 %}
 8377 
 8378 // Implicit zero checks (more implicit null checks).
 8379 instruct zeroCheckN_iReg_imm0(cmpOpT cmp, iRegN_P2N value, immN0 zero, label labl) %{
 8380   match(If cmp (CmpN value zero));
 8381   effect(USE labl);
 8382   predicate(TrapBasedNullChecks &amp;&amp;
 8383             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8384             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8385             Matcher::branches_to_uncommon_trap(_leaf));
 8386   size(6);
 8387 
 8388   ins_is_TrapBasedCheckNode(true);
 8389 
 8390   format %{ &quot;ZeroCheckN value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8391   ins_encode %{ __ z_cit($value$$Register, 0, $cmp$$cmpcode); %}
 8392   ins_pipe(pipe_class_trap);
 8393 %}
 8394 
 8395 //----------Compare instructions-----------------------------------------------
 8396 
 8397 // INT signed
 8398 
 8399 // Compare Integers
 8400 instruct compI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8401   match(Set cr (CmpI op1 op2));
 8402   size(2);
 8403   format %{ &quot;CR      $op1,$op2&quot; %}
 8404   opcode(CR_ZOPC);
 8405   ins_encode(z_rrform(op1, op2));
 8406   ins_pipe(pipe_class_dummy);
 8407 %}
 8408 
 8409 instruct compI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 8410   match(Set cr (CmpI op1 op2));
 8411   size(6);
 8412   format %{ &quot;CFI     $op1,$op2&quot; %}
 8413   opcode(CFI_ZOPC);
 8414   ins_encode(z_rilform_signed(op1, op2));
 8415   ins_pipe(pipe_class_dummy);
 8416 %}
 8417 
 8418 instruct compI_reg_imm16(flagsReg cr, iRegI op1, immI16 op2) %{
 8419   match(Set cr (CmpI op1 op2));
 8420   size(4);
 8421   format %{ &quot;CHI     $op1,$op2&quot; %}
 8422   opcode(CHI_ZOPC);
 8423   ins_encode(z_riform_signed(op1, op2));
 8424   ins_pipe(pipe_class_dummy);
 8425 %}
 8426 
 8427 instruct compI_reg_imm0(flagsReg cr, iRegI op1, immI_0 zero) %{
 8428   match(Set cr (CmpI op1 zero));
 8429   ins_cost(DEFAULT_COST_LOW);
 8430   size(2);
 8431   format %{ &quot;LTR     $op1,$op1&quot; %}
 8432   opcode(LTR_ZOPC);
 8433   ins_encode(z_rrform(op1, op1));
 8434   ins_pipe(pipe_class_dummy);
 8435 %}
 8436 
 8437 instruct compI_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8438   match(Set cr (CmpI op1 (LoadI op2)));
 8439   ins_cost(MEMORY_REF_COST);
 8440   // TODO: s390 port size(VARIABLE_SIZE);
 8441   format %{ &quot;C(Y)    $op1, $op2\t # int&quot; %}
 8442   opcode(CY_ZOPC, C_ZOPC);
 8443   ins_encode(z_form_rt_mem_opt(op1, op2));
 8444   ins_pipe(pipe_class_dummy);
 8445 %}
 8446 
 8447 // INT unsigned
 8448 
 8449 instruct compU_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8450   match(Set cr (CmpU op1 op2));
 8451   size(2);
 8452   format %{ &quot;CLR     $op1,$op2\t # unsigned&quot; %}
 8453   opcode(CLR_ZOPC);
 8454   ins_encode(z_rrform(op1, op2));
 8455   ins_pipe(pipe_class_dummy);
 8456 %}
 8457 
 8458 instruct compU_reg_uimm(flagsReg cr, iRegI op1, uimmI op2) %{
 8459   match(Set cr (CmpU op1 op2));
 8460   size(6);
 8461   format %{ &quot;CLFI    $op1,$op2\t # unsigned&quot; %}
 8462   opcode(CLFI_ZOPC);
 8463   ins_encode(z_rilform_unsigned(op1, op2));
 8464   ins_pipe(pipe_class_dummy);
 8465 %}
 8466 
 8467 instruct compU_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8468   match(Set cr (CmpU op1 (LoadI op2)));
 8469   ins_cost(MEMORY_REF_COST);
 8470   // TODO: s390 port size(VARIABLE_SIZE);
 8471   format %{ &quot;CL(Y)   $op1, $op2\t # unsigned&quot; %}
 8472   opcode(CLY_ZOPC, CL_ZOPC);
 8473   ins_encode(z_form_rt_mem_opt(op1, op2));
 8474   ins_pipe(pipe_class_dummy);
 8475 %}
 8476 
 8477 // LONG signed
 8478 
 8479 instruct compL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8480   match(Set cr (CmpL op1 op2));
 8481   size(4);
 8482   format %{ &quot;CGR     $op1,$op2\t # long&quot; %}
 8483   opcode(CGR_ZOPC);
 8484   ins_encode(z_rreform(op1, op2));
 8485   ins_pipe(pipe_class_dummy);
 8486 %}
 8487 
 8488 instruct compL_reg_regI(flagsReg cr, iRegL op1, iRegI op2) %{
 8489   match(Set cr (CmpL op1 (ConvI2L op2)));
 8490   size(4);
 8491   format %{ &quot;CGFR    $op1,$op2\t # long/int&quot; %}
 8492   opcode(CGFR_ZOPC);
 8493   ins_encode(z_rreform(op1, op2));
 8494   ins_pipe(pipe_class_dummy);
 8495 %}
 8496 
 8497 instruct compL_reg_imm32(flagsReg cr, iRegL op1, immL32 con) %{
 8498   match(Set cr (CmpL op1 con));
 8499   size(6);
 8500   format %{ &quot;CGFI    $op1,$con&quot; %}
 8501   opcode(CGFI_ZOPC);
 8502   ins_encode(z_rilform_signed(op1, con));
 8503   ins_pipe(pipe_class_dummy);
 8504 %}
 8505 
 8506 instruct compL_reg_imm16(flagsReg cr, iRegL op1, immL16 con) %{
 8507   match(Set cr (CmpL op1 con));
 8508   size(4);
 8509   format %{ &quot;CGHI    $op1,$con&quot; %}
 8510   opcode(CGHI_ZOPC);
 8511   ins_encode(z_riform_signed(op1, con));
 8512   ins_pipe(pipe_class_dummy);
 8513 %}
 8514 
 8515 instruct compL_reg_imm0(flagsReg cr, iRegL op1, immL_0 con) %{
 8516   match(Set cr (CmpL op1 con));
 8517   ins_cost(DEFAULT_COST_LOW);
 8518   size(4);
 8519   format %{ &quot;LTGR    $op1,$op1&quot; %}
 8520   opcode(LTGR_ZOPC);
 8521   ins_encode(z_rreform(op1, op1));
 8522   ins_pipe(pipe_class_dummy);
 8523 %}
 8524 
 8525 instruct compL_conv_reg_imm0(flagsReg cr, iRegI op1, immL_0 con) %{
 8526   match(Set cr (CmpL (ConvI2L op1) con));
 8527   ins_cost(DEFAULT_COST_LOW);
 8528   size(4);
 8529   format %{ &quot;LTGFR    $op1,$op1&quot; %}
 8530   opcode(LTGFR_ZOPC);
 8531   ins_encode(z_rreform(op1, op1));
 8532   ins_pipe(pipe_class_dummy);
 8533 %}
 8534 
 8535 instruct compL_reg_mem(iRegL dst, memory src, flagsReg cr)%{
 8536   match(Set cr (CmpL dst (LoadL src)));
 8537   ins_cost(MEMORY_REF_COST);
 8538   size(Z_DISP3_SIZE);
 8539   format %{ &quot;CG      $dst, $src\t # long&quot; %}
 8540   opcode(CG_ZOPC, CG_ZOPC);
 8541   ins_encode(z_form_rt_mem_opt(dst, src));
 8542   ins_pipe(pipe_class_dummy);
 8543 %}
 8544 
 8545 instruct compL_reg_memI(iRegL dst, memory src, flagsReg cr)%{
 8546   match(Set cr (CmpL dst (ConvI2L (LoadI src))));
 8547   ins_cost(MEMORY_REF_COST);
 8548   size(Z_DISP3_SIZE);
 8549   format %{ &quot;CGF     $dst, $src\t # long/int&quot; %}
 8550   opcode(CGF_ZOPC, CGF_ZOPC);
 8551   ins_encode(z_form_rt_mem_opt(dst, src));
 8552   ins_pipe(pipe_class_dummy);
 8553 %}
 8554 
 8555 //  LONG unsigned
 8556 // Added CmpUL for LoopPredicate.
 8557 instruct compUL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8558   match(Set cr (CmpUL op1 op2));
 8559   size(4);
 8560   format %{ &quot;CLGR    $op1,$op2\t # long&quot; %}
 8561   opcode(CLGR_ZOPC);
 8562   ins_encode(z_rreform(op1, op2));
 8563   ins_pipe(pipe_class_dummy);
 8564 %}
 8565 
 8566 instruct compUL_reg_imm32(flagsReg cr, iRegL op1, uimmL32 con) %{
 8567   match(Set cr (CmpUL op1 con));
 8568   size(6);
 8569   format %{ &quot;CLGFI   $op1,$con&quot; %}
 8570   opcode(CLGFI_ZOPC);
 8571   ins_encode(z_rilform_unsigned(op1, con));
 8572   ins_pipe(pipe_class_dummy);
 8573 %}
 8574 
 8575 //  PTR unsigned
 8576 
 8577 instruct compP_reg_reg(flagsReg cr, iRegP_N2P op1, iRegP_N2P op2) %{
 8578   match(Set cr (CmpP op1 op2));
 8579   size(4);
 8580   format %{ &quot;CLGR    $op1,$op2\t # ptr&quot; %}
 8581   opcode(CLGR_ZOPC);
 8582   ins_encode(z_rreform(op1, op2));
 8583   ins_pipe(pipe_class_dummy);
 8584 %}
 8585 
 8586 instruct compP_reg_imm0(flagsReg cr, iRegP_N2P op1, immP0 op2) %{
 8587   match(Set cr (CmpP op1 op2));
 8588   ins_cost(DEFAULT_COST_LOW);
 8589   size(4);
 8590   format %{ &quot;LTGR    $op1, $op1\t # ptr&quot; %}
 8591   opcode(LTGR_ZOPC);
 8592   ins_encode(z_rreform(op1, op1));
 8593   ins_pipe(pipe_class_dummy);
 8594 %}
 8595 
 8596 // Don&#39;t use LTGFR which performs sign extend.
 8597 instruct compP_decode_reg_imm0(flagsReg cr, iRegN op1, immP0 op2) %{
 8598   match(Set cr (CmpP (DecodeN op1) op2));
 8599   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 8600   ins_cost(DEFAULT_COST_LOW);
 8601   size(2);
 8602   format %{ &quot;LTR    $op1, $op1\t # ptr&quot; %}
 8603   opcode(LTR_ZOPC);
 8604   ins_encode(z_rrform(op1, op1));
 8605   ins_pipe(pipe_class_dummy);
 8606 %}
 8607 
 8608 instruct compP_reg_mem(iRegP dst, memory src, flagsReg cr)%{
 8609   match(Set cr (CmpP dst (LoadP src)));
 8610   ins_cost(MEMORY_REF_COST);
 8611   size(Z_DISP3_SIZE);
 8612   format %{ &quot;CLG     $dst, $src\t # ptr&quot; %}
 8613   opcode(CLG_ZOPC, CLG_ZOPC);
 8614   ins_encode(z_form_rt_mem_opt(dst, src));
 8615   ins_pipe(pipe_class_dummy);
 8616 %}
 8617 
 8618 //----------Max and Min--------------------------------------------------------
 8619 
 8620 // Max Register with Register
 8621 instruct z196_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8622   match(Set dst (MinI src1 src2));
 8623   effect(KILL cr);
 8624   predicate(VM_Version::has_LoadStoreConditional());
 8625   ins_cost(3 * DEFAULT_COST);
 8626   // TODO: s390 port size(VARIABLE_SIZE);
 8627   format %{ &quot;MinI $dst $src1,$src2\t MinI (z196 only)&quot; %}
 8628   ins_encode %{
 8629     Register Rdst = $dst$$Register;
 8630     Register Rsrc1 = $src1$$Register;
 8631     Register Rsrc2 = $src2$$Register;
 8632 
 8633     if (Rsrc1 == Rsrc2) {
 8634       if (Rdst != Rsrc1) {
 8635         __ z_lgfr(Rdst, Rsrc1);
 8636       }
 8637     } else if (Rdst == Rsrc1) {   // Rdst preset with src1.
 8638       __ z_cr(Rsrc1, Rsrc2);      // Move src2 only if src1 is NotLow.
 8639       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8640     } else if (Rdst == Rsrc2) {   // Rdst preset with src2.
 8641       __ z_cr(Rsrc2, Rsrc1);      // Move src1 only if src2 is NotLow.
 8642       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotLow);
 8643     } else {
 8644       // Rdst is disjoint from operands, move in either case.
 8645       __ z_cr(Rsrc1, Rsrc2);
 8646       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8647       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8648     }
 8649   %}
 8650   ins_pipe(pipe_class_dummy);
 8651 %}
 8652 
 8653 // Min Register with Register.
 8654 instruct z10_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8655   match(Set dst (MinI src1 src2));
 8656   effect(KILL cr);
 8657   predicate(VM_Version::has_CompareBranch());
 8658   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8659   // TODO: s390 port size(VARIABLE_SIZE);
 8660   format %{ &quot;MinI $dst $src1,$src2\t MinI (z10 only)&quot; %}
 8661   ins_encode %{
 8662     Register Rdst = $dst$$Register;
 8663     Register Rsrc1 = $src1$$Register;
 8664     Register Rsrc2 = $src2$$Register;
 8665     Label done;
 8666 
 8667     if (Rsrc1 == Rsrc2) {
 8668       if (Rdst != Rsrc1) {
 8669         __ z_lgfr(Rdst, Rsrc1);
 8670       }
 8671     } else if (Rdst == Rsrc1) {
 8672       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8673       __ z_lgfr(Rdst, Rsrc2);
 8674     } else if (Rdst == Rsrc2) {
 8675       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondLow, done);
 8676       __ z_lgfr(Rdst, Rsrc1);
 8677     } else {
 8678       __ z_lgfr(Rdst, Rsrc1);
 8679       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8680       __ z_lgfr(Rdst, Rsrc2);
 8681     }
 8682     __ bind(done);
 8683   %}
 8684   ins_pipe(pipe_class_dummy);
 8685 %}
 8686 
 8687 instruct minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8688   match(Set dst (MinI src1 src2));
 8689   effect(KILL cr);
 8690   predicate(!VM_Version::has_CompareBranch());
 8691   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8692   // TODO: s390 port size(VARIABLE_SIZE);
 8693   format %{ &quot;MinI $dst $src1,$src2\t MinI&quot; %}
 8694   ins_encode %{
 8695     Register Rdst = $dst$$Register;
 8696     Register Rsrc1 = $src1$$Register;
 8697     Register Rsrc2 = $src2$$Register;
 8698     Label done;
 8699 
 8700     if (Rsrc1 == Rsrc2) {
 8701       if (Rdst != Rsrc1) {
 8702         __ z_lgfr(Rdst, Rsrc1);
 8703       }
 8704     } else if (Rdst == Rsrc1) {
 8705       __ z_cr(Rsrc1, Rsrc2);
 8706       __ z_brl(done);
 8707       __ z_lgfr(Rdst, Rsrc2);
 8708     } else if (Rdst == Rsrc2) {
 8709       __ z_cr(Rsrc2, Rsrc1);
 8710       __ z_brl(done);
 8711       __ z_lgfr(Rdst, Rsrc1);
 8712     } else {
 8713       __ z_lgfr(Rdst, Rsrc1);
 8714       __ z_cr(Rsrc1, Rsrc2);
 8715       __ z_brl(done);
 8716       __ z_lgfr(Rdst, Rsrc2);
 8717     }
 8718     __ bind(done);
 8719   %}
 8720   ins_pipe(pipe_class_dummy);
 8721 %}
 8722 
 8723 instruct z196_minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8724   match(Set dst (MinI src1 src2));
 8725   effect(KILL cr);
 8726   predicate(VM_Version::has_LoadStoreConditional());
 8727   ins_cost(3 * DEFAULT_COST);
 8728   // TODO: s390 port size(VARIABLE_SIZE);
 8729   format %{ &quot;MinI $dst $src1,$src2\t MinI const32 (z196 only)&quot; %}
 8730   ins_encode %{
 8731     Register Rdst = $dst$$Register;
 8732     Register Rsrc1 = $src1$$Register;
 8733     int      Isrc2 = $src2$$constant;
 8734 
 8735     if (Rdst == Rsrc1) {
 8736       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8737       __ z_cfi(Rsrc1, Isrc2);
 8738       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8739     } else {
 8740       __ load_const_optimized(Rdst, Isrc2);
 8741       __ z_cfi(Rsrc1, Isrc2);
 8742       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8743     }
 8744   %}
 8745   ins_pipe(pipe_class_dummy);
 8746 %}
 8747 
 8748 instruct minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8749   match(Set dst (MinI src1 src2));
 8750   effect(KILL cr);
 8751   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8752   // TODO: s390 port size(VARIABLE_SIZE);
 8753   format %{ &quot;MinI $dst $src1,$src2\t MinI const32&quot; %}
 8754   ins_encode %{
 8755     Label done;
 8756     if ($dst$$Register != $src1$$Register) {
 8757       __ z_lgfr($dst$$Register, $src1$$Register);
 8758     }
 8759     __ z_cfi($src1$$Register, $src2$$constant);
 8760     __ z_brl(done);
 8761     __ z_lgfi($dst$$Register, $src2$$constant);
 8762     __ bind(done);
 8763   %}
 8764   ins_pipe(pipe_class_dummy);
 8765 %}
 8766 
 8767 instruct z196_minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8768   match(Set dst (MinI src1 src2));
 8769   effect(KILL cr);
 8770   predicate(VM_Version::has_LoadStoreConditional());
 8771   ins_cost(3 * DEFAULT_COST);
 8772   // TODO: s390 port size(VARIABLE_SIZE);
 8773   format %{ &quot;MinI $dst $src1,$src2\t MinI const16 (z196 only)&quot; %}
 8774   ins_encode %{
 8775     Register Rdst = $dst$$Register;
 8776     Register Rsrc1 = $src1$$Register;
 8777     int      Isrc2 = $src2$$constant;
 8778 
 8779     if (Rdst == Rsrc1) {
 8780       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8781       __ z_chi(Rsrc1, Isrc2);
 8782       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8783     } else {
 8784       __ load_const_optimized(Rdst, Isrc2);
 8785       __ z_chi(Rsrc1, Isrc2);
 8786       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8787     }
 8788   %}
 8789   ins_pipe(pipe_class_dummy);
 8790 %}
 8791 
 8792 instruct minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8793   match(Set dst (MinI src1 src2));
 8794   effect(KILL cr);
 8795   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8796   // TODO: s390 port size(VARIABLE_SIZE);
 8797   format %{ &quot;MinI $dst $src1,$src2\t MinI const16&quot; %}
 8798   ins_encode %{
 8799     Label done;
 8800     if ($dst$$Register != $src1$$Register) {
 8801       __ z_lgfr($dst$$Register, $src1$$Register);
 8802     }
 8803     __ z_chi($src1$$Register, $src2$$constant);
 8804     __ z_brl(done);
 8805     __ z_lghi($dst$$Register, $src2$$constant);
 8806     __ bind(done);
 8807   %}
 8808   ins_pipe(pipe_class_dummy);
 8809 %}
 8810 
 8811 instruct z10_minI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 8812   match(Set dst (MinI src1 src2));
 8813   effect(KILL cr);
 8814   predicate(VM_Version::has_CompareBranch());
 8815   ins_cost(DEFAULT_COST + BRANCH_COST);
 8816   // TODO: s390 port size(VARIABLE_SIZE);
 8817   format %{ &quot;MinI $dst $src1,$src2\t MinI const8 (z10 only)&quot; %}
 8818   ins_encode %{
 8819     Label done;
 8820     if ($dst$$Register != $src1$$Register) {
 8821       __ z_lgfr($dst$$Register, $src1$$Register);
 8822     }
 8823     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondLow, done);
 8824     __ z_lghi($dst$$Register, $src2$$constant);
 8825     __ bind(done);
 8826   %}
 8827   ins_pipe(pipe_class_dummy);
 8828 %}
 8829 
 8830 // Max Register with Register
 8831 instruct z196_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8832   match(Set dst (MaxI src1 src2));
 8833   effect(KILL cr);
 8834   predicate(VM_Version::has_LoadStoreConditional());
 8835   ins_cost(3 * DEFAULT_COST);
 8836   // TODO: s390 port size(VARIABLE_SIZE);
 8837   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z196 only)&quot; %}
 8838   ins_encode %{
 8839     Register Rdst = $dst$$Register;
 8840     Register Rsrc1 = $src1$$Register;
 8841     Register Rsrc2 = $src2$$Register;
 8842 
 8843     if (Rsrc1 == Rsrc2) {
 8844       if (Rdst != Rsrc1) {
 8845         __ z_lgfr(Rdst, Rsrc1);
 8846       }
 8847     } else if (Rdst == Rsrc1) { // Rdst preset with src1.
 8848       __ z_cr(Rsrc1, Rsrc2);    // Move src2 only if src1 is NotHigh.
 8849       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8850     } else if (Rdst == Rsrc2) { // Rdst preset with src2.
 8851       __ z_cr(Rsrc2, Rsrc1);    // Move src1 only if src2 is NotHigh.
 8852       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotHigh);
 8853     } else {                    // Rdst is disjoint from operands, move in either case.
 8854       __ z_cr(Rsrc1, Rsrc2);
 8855       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8856       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8857     }
 8858   %}
 8859   ins_pipe(pipe_class_dummy);
 8860 %}
 8861 
 8862 // Max Register with Register
 8863 instruct z10_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8864   match(Set dst (MaxI src1 src2));
 8865   effect(KILL cr);
 8866   predicate(VM_Version::has_CompareBranch());
 8867   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8868   // TODO: s390 port size(VARIABLE_SIZE);
 8869   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z10 only)&quot; %}
 8870   ins_encode %{
 8871     Register Rdst = $dst$$Register;
 8872     Register Rsrc1 = $src1$$Register;
 8873     Register Rsrc2 = $src2$$Register;
 8874     Label done;
 8875 
 8876     if (Rsrc1 == Rsrc2) {
 8877       if (Rdst != Rsrc1) {
 8878         __ z_lgfr(Rdst, Rsrc1);
 8879       }
 8880     } else if (Rdst == Rsrc1) {
 8881       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8882       __ z_lgfr(Rdst, Rsrc2);
 8883     } else if (Rdst == Rsrc2) {
 8884       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondHigh, done);
 8885       __ z_lgfr(Rdst, Rsrc1);
 8886     } else {
 8887       __ z_lgfr(Rdst, Rsrc1);
 8888       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8889       __ z_lgfr(Rdst, Rsrc2);
 8890     }
 8891     __ bind(done);
 8892   %}
 8893   ins_pipe(pipe_class_dummy);
 8894 %}
 8895 
 8896 instruct maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8897   match(Set dst (MaxI src1 src2));
 8898   effect(KILL cr);
 8899   predicate(!VM_Version::has_CompareBranch());
 8900   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8901   // TODO: s390 port size(VARIABLE_SIZE);
 8902   format %{ &quot;MaxI $dst $src1,$src2\t MaxI&quot; %}
 8903   ins_encode %{
 8904     Register Rdst = $dst$$Register;
 8905     Register Rsrc1 = $src1$$Register;
 8906     Register Rsrc2 = $src2$$Register;
 8907     Label done;
 8908 
 8909     if (Rsrc1 == Rsrc2) {
 8910       if (Rdst != Rsrc1) {
 8911         __ z_lgfr(Rdst, Rsrc1);
 8912       }
 8913     } else if (Rdst == Rsrc1) {
 8914       __ z_cr(Rsrc1, Rsrc2);
 8915       __ z_brh(done);
 8916       __ z_lgfr(Rdst, Rsrc2);
 8917     } else if (Rdst == Rsrc2) {
 8918       __ z_cr(Rsrc2, Rsrc1);
 8919       __ z_brh(done);
 8920       __ z_lgfr(Rdst, Rsrc1);
 8921     } else {
 8922       __ z_lgfr(Rdst, Rsrc1);
 8923       __ z_cr(Rsrc1, Rsrc2);
 8924       __ z_brh(done);
 8925       __ z_lgfr(Rdst, Rsrc2);
 8926     }
 8927 
 8928     __ bind(done);
 8929   %}
 8930 
 8931   ins_pipe(pipe_class_dummy);
 8932 %}
 8933 
 8934 instruct z196_maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8935   match(Set dst (MaxI src1 src2));
 8936   effect(KILL cr);
 8937   predicate(VM_Version::has_LoadStoreConditional());
 8938   ins_cost(3 * DEFAULT_COST);
 8939   // TODO: s390 port size(VARIABLE_SIZE);
 8940   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32 (z196 only)&quot; %}
 8941   ins_encode %{
 8942     Register Rdst = $dst$$Register;
 8943     Register Rsrc1 = $src1$$Register;
 8944     int      Isrc2 = $src2$$constant;
 8945 
 8946     if (Rdst == Rsrc1) {
 8947       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8948       __ z_cfi(Rsrc1, Isrc2);
 8949       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 8950     } else {
 8951       __ load_const_optimized(Rdst, Isrc2);
 8952       __ z_cfi(Rsrc1, Isrc2);
 8953       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8954     }
 8955   %}
 8956   ins_pipe(pipe_class_dummy);
 8957 %}
 8958 
 8959 instruct maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8960   match(Set dst (MaxI src1 src2));
 8961   effect(KILL cr);
 8962   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8963   // TODO: s390 port size(VARIABLE_SIZE);
 8964   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32&quot; %}
 8965   ins_encode %{
 8966     Label done;
 8967     if ($dst$$Register != $src1$$Register) {
 8968       __ z_lgfr($dst$$Register, $src1$$Register);
 8969     }
 8970     __ z_cfi($src1$$Register, $src2$$constant);
 8971     __ z_brh(done);
 8972     __ z_lgfi($dst$$Register, $src2$$constant);
 8973     __ bind(done);
 8974   %}
 8975   ins_pipe(pipe_class_dummy);
 8976 %}
 8977 
 8978 instruct z196_maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8979   match(Set dst (MaxI src1 src2));
 8980   effect(KILL cr);
 8981   predicate(VM_Version::has_LoadStoreConditional());
 8982   ins_cost(3 * DEFAULT_COST);
 8983   // TODO: s390 port size(VARIABLE_SIZE);
 8984   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16 (z196 only)&quot; %}
 8985   ins_encode %{
 8986     Register Rdst = $dst$$Register;
 8987     Register Rsrc1 = $src1$$Register;
 8988     int      Isrc2 = $src2$$constant;
 8989     if (Rdst == Rsrc1) {
 8990       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8991       __ z_chi(Rsrc1, Isrc2);
 8992       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 8993     } else {
 8994       __ load_const_optimized(Rdst, Isrc2);
 8995       __ z_chi(Rsrc1, Isrc2);
 8996       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8997     }
 8998   %}
 8999   ins_pipe(pipe_class_dummy);
 9000 %}
 9001 
 9002 instruct maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 9003   match(Set dst (MaxI src1 src2));
 9004   effect(KILL cr);
 9005   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 9006   // TODO: s390 port size(VARIABLE_SIZE);
 9007   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16&quot; %}
 9008   ins_encode %{
 9009     Label done;
 9010     if ($dst$$Register != $src1$$Register) {
 9011       __ z_lgfr($dst$$Register, $src1$$Register);
 9012     }
 9013     __ z_chi($src1$$Register, $src2$$constant);
 9014     __ z_brh(done);
 9015     __ z_lghi($dst$$Register, $src2$$constant);
 9016     __ bind(done);
 9017   %}
 9018   ins_pipe(pipe_class_dummy);
 9019 %}
 9020 
 9021 instruct z10_maxI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 9022   match(Set dst (MaxI src1 src2));
 9023   effect(KILL cr);
 9024   predicate(VM_Version::has_CompareBranch());
 9025   ins_cost(DEFAULT_COST + BRANCH_COST);
 9026   // TODO: s390 port size(VARIABLE_SIZE);
 9027   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const8&quot; %}
 9028   ins_encode %{
 9029     Label done;
 9030     if ($dst$$Register != $src1$$Register) {
 9031       __ z_lgfr($dst$$Register, $src1$$Register);
 9032     }
 9033     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondHigh, done);
 9034     __ z_lghi($dst$$Register, $src2$$constant);
 9035     __ bind(done);
 9036   %}
 9037   ins_pipe(pipe_class_dummy);
 9038 %}
 9039 
 9040 //----------Abs---------------------------------------------------------------
 9041 
 9042 instruct absI_reg(iRegI dst, iRegI src, flagsReg cr) %{
 9043   match(Set dst (AbsI src));
 9044   effect(KILL cr);
 9045   ins_cost(DEFAULT_COST_LOW);
 9046   // TODO: s390 port size(FIXED_SIZE);
 9047   format %{ &quot;LPR     $dst, $src&quot; %}
 9048   opcode(LPR_ZOPC);
 9049   ins_encode(z_rrform(dst, src));
 9050   ins_pipe(pipe_class_dummy);
 9051 %}
 9052 
 9053 instruct absL_reg(iRegL dst, iRegL src, flagsReg cr) %{
 9054   match(Set dst (AbsL src));
 9055   effect(KILL cr);
 9056   ins_cost(DEFAULT_COST_LOW);
 9057   // TODO: s390 port size(FIXED_SIZE);
 9058   format %{ &quot;LPGR     $dst, $src&quot; %}
 9059   opcode(LPGR_ZOPC);
 9060   ins_encode(z_rreform(dst, src));
 9061   ins_pipe(pipe_class_dummy);
 9062 %}
 9063 
 9064 instruct negabsI_reg(iRegI dst, iRegI src, immI_0 zero, flagsReg cr) %{
 9065   match(Set dst (SubI zero (AbsI src)));
 9066   effect(KILL cr);
 9067   ins_cost(DEFAULT_COST_LOW);
 9068   // TODO: s390 port size(FIXED_SIZE);
 9069   format %{ &quot;LNR     $dst, $src&quot; %}
 9070   opcode(LNR_ZOPC);
 9071   ins_encode(z_rrform(dst, src));
 9072   ins_pipe(pipe_class_dummy);
 9073 %}
 9074 
 9075 //----------Float Compares----------------------------------------------------
 9076 
 9077 // Compare floating, generate condition code.
 9078 instruct cmpF_cc(flagsReg cr, regF src1, regF src2) %{
 9079   match(Set cr (CmpF src1 src2));
 9080   ins_cost(ALU_REG_COST);
 9081   size(4);
 9082   format %{ &quot;FCMPcc   $src1,$src2\t # float&quot; %}
 9083   ins_encode %{ __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9084   ins_pipe(pipe_class_dummy);
 9085 %}
 9086 
 9087 instruct cmpD_cc(flagsReg cr, regD src1, regD src2) %{
 9088   match(Set cr (CmpD src1 src2));
 9089   ins_cost(ALU_REG_COST);
 9090   size(4);
 9091   format %{ &quot;FCMPcc   $src1,$src2 \t # double&quot; %}
 9092   ins_encode %{ __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9093   ins_pipe(pipe_class_dummy);
 9094 %}
 9095 
 9096 instruct cmpF_cc_mem(flagsReg cr, regF src1, memoryRX src2) %{
 9097   match(Set cr (CmpF src1 (LoadF src2)));
 9098   ins_cost(ALU_MEMORY_COST);
 9099   size(6);
 9100   format %{ &quot;FCMPcc_mem $src1,$src2\t # floatMemory&quot; %}
 9101   opcode(CEB_ZOPC);
 9102   ins_encode(z_form_rt_memFP(src1, src2));
 9103   ins_pipe(pipe_class_dummy);
 9104 %}
 9105 
 9106 instruct cmpD_cc_mem(flagsReg cr, regD src1, memoryRX src2) %{
 9107   match(Set cr (CmpD src1 (LoadD src2)));
 9108   ins_cost(ALU_MEMORY_COST);
 9109   size(6);
 9110   format %{ &quot;DCMPcc_mem $src1,$src2\t # doubleMemory&quot; %}
 9111   opcode(CDB_ZOPC);
 9112   ins_encode(z_form_rt_memFP(src1, src2));
 9113   ins_pipe(pipe_class_dummy);
 9114 %}
 9115 
 9116 // Compare floating, generate condition code
 9117 instruct cmpF0_cc(flagsReg cr, regF src1, immFpm0 src2) %{
 9118   match(Set cr (CmpF src1 src2));
 9119   ins_cost(DEFAULT_COST);
 9120   size(4);
 9121   format %{ &quot;LTEBR    $src1,$src1\t # float&quot; %}
 9122   opcode(LTEBR_ZOPC);
 9123   ins_encode(z_rreform(src1, src1));
 9124   ins_pipe(pipe_class_dummy);
 9125 %}
 9126 
 9127 instruct cmpD0_cc(flagsReg cr, regD src1, immDpm0 src2) %{
 9128   match(Set cr (CmpD src1 src2));
 9129   ins_cost(DEFAULT_COST);
 9130   size(4);
 9131   format %{ &quot;LTDBR    $src1,$src1 \t # double&quot; %}
 9132   opcode(LTDBR_ZOPC);
 9133   ins_encode(z_rreform(src1, src1));
 9134   ins_pipe(pipe_class_dummy);
 9135 %}
 9136 
 9137 // Compare floating, generate -1,0,1
 9138 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsReg cr) %{
 9139   match(Set dst (CmpF3 src1 src2));
 9140   effect(KILL cr);
 9141   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9142   size(24);
 9143   format %{ &quot;CmpF3    $dst,$src1,$src2&quot; %}
 9144   ins_encode %{
 9145     // compare registers
 9146     __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister);
 9147     // Convert condition code into -1,0,1, where
 9148     // -1 means unordered or less
 9149     //  0 means equal
 9150     //  1 means greater.
 9151     if (VM_Version::has_LoadStoreConditional()) {
 9152       Register one       = Z_R0_scratch;
 9153       Register minus_one = Z_R1_scratch;
 9154       __ z_lghi(minus_one, -1);
 9155       __ z_lghi(one, 1);
 9156       __ z_lghi( $dst$$Register, 0);
 9157       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9158       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9159     } else {
 9160       Label done;
 9161       __ clear_reg($dst$$Register, true, false);
 9162       __ z_bre(done);
 9163       __ z_lhi($dst$$Register, 1);
 9164       __ z_brh(done);
 9165       __ z_lhi($dst$$Register, -1);
 9166       __ bind(done);
 9167     }
 9168   %}
 9169   ins_pipe(pipe_class_dummy);
 9170 %}
 9171 
 9172 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsReg cr) %{
 9173   match(Set dst (CmpD3 src1 src2));
 9174   effect(KILL cr);
 9175   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9176   size(24);
 9177   format %{ &quot;CmpD3    $dst,$src1,$src2&quot; %}
 9178   ins_encode %{
 9179     // compare registers
 9180     __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister);
 9181     // Convert condition code into -1,0,1, where
 9182     // -1 means unordered or less
 9183     //  0 means equal
 9184     //  1 means greater.
 9185     if (VM_Version::has_LoadStoreConditional()) {
 9186       Register one       = Z_R0_scratch;
 9187       Register minus_one = Z_R1_scratch;
 9188       __ z_lghi(minus_one, -1);
 9189       __ z_lghi(one, 1);
 9190       __ z_lghi( $dst$$Register, 0);
 9191       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9192       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9193     } else {
 9194       Label done;
 9195       // indicate unused result
 9196       (void) __ clear_reg($dst$$Register, true, false);
 9197       __ z_bre(done);
 9198       __ z_lhi($dst$$Register, 1);
 9199       __ z_brh(done);
 9200       __ z_lhi($dst$$Register, -1);
 9201       __ bind(done);
 9202     }
 9203   %}
 9204   ins_pipe(pipe_class_dummy);
 9205 %}
 9206 
 9207 //----------Branches---------------------------------------------------------
 9208 // Jump
 9209 
 9210 // Direct Branch.
 9211 instruct branch(label labl) %{
 9212   match(Goto);
 9213   effect(USE labl);
 9214   ins_cost(BRANCH_COST);
 9215   size(4);
 9216   format %{ &quot;BRU     $labl&quot; %}
 9217   ins_encode(z_enc_bru(labl));
 9218   ins_pipe(pipe_class_dummy);
 9219   // If set to 1 this indicates that the current instruction is a
 9220   // short variant of a long branch. This avoids using this
 9221   // instruction in first-pass matching. It will then only be used in
 9222   // the `Shorten_branches&#39; pass.
 9223   ins_short_branch(1);
 9224 %}
 9225 
 9226 // Direct Branch.
 9227 instruct branchFar(label labl) %{
 9228   match(Goto);
 9229   effect(USE labl);
 9230   ins_cost(BRANCH_COST);
 9231   size(6);
 9232   format %{ &quot;BRUL   $labl&quot; %}
 9233   ins_encode(z_enc_brul(labl));
 9234   ins_pipe(pipe_class_dummy);
 9235   // This is not a short variant of a branch, but the long variant.
 9236   ins_short_branch(0);
 9237 %}
 9238 
 9239 // Conditional Near Branch
 9240 instruct branchCon(cmpOp cmp, flagsReg cr, label lbl) %{
 9241   // Same match rule as `branchConFar&#39;.
 9242   match(If cmp cr);
 9243   effect(USE lbl);
 9244   ins_cost(BRANCH_COST);
 9245   size(4);
 9246   format %{ &quot;branch_con_short,$cmp   $lbl&quot; %}
 9247   ins_encode(z_enc_branch_con_short(cmp, lbl));
 9248   ins_pipe(pipe_class_dummy);
 9249   // If set to 1 this indicates that the current instruction is a
 9250   // short variant of a long branch. This avoids using this
 9251   // instruction in first-pass matching. It will then only be used in
 9252   // the `Shorten_branches&#39; pass.
 9253   ins_short_branch(1);
 9254 %}
 9255 
 9256 // This is for cases when the z/Architecture conditional branch instruction
 9257 // does not reach far enough. So we emit a far branch here, which is
 9258 // more expensive.
 9259 //
 9260 // Conditional Far Branch
 9261 instruct branchConFar(cmpOp cmp, flagsReg cr, label lbl) %{
 9262   // Same match rule as `branchCon&#39;.
 9263   match(If cmp cr);
 9264   effect(USE cr, USE lbl);
 9265   // Make more expensive to prefer compare_and_branch over separate instructions.
 9266   ins_cost(2 * BRANCH_COST);
 9267   size(6);
 9268   format %{ &quot;branch_con_far,$cmp   $lbl&quot; %}
 9269   ins_encode(z_enc_branch_con_far(cmp, lbl));
 9270   ins_pipe(pipe_class_dummy);
 9271   // This is not a short variant of a branch, but the long variant..
 9272   ins_short_branch(0);
 9273 %}
 9274 
 9275 instruct branchLoopEnd(cmpOp cmp, flagsReg cr, label labl) %{
 9276   match(CountedLoopEnd cmp cr);
 9277   effect(USE labl);
 9278   ins_cost(BRANCH_COST);
 9279   size(4);
 9280   format %{ &quot;branch_con_short,$cmp   $labl\t # counted loop end&quot; %}
 9281   ins_encode(z_enc_branch_con_short(cmp, labl));
 9282   ins_pipe(pipe_class_dummy);
 9283   // If set to 1 this indicates that the current instruction is a
 9284   // short variant of a long branch. This avoids using this
 9285   // instruction in first-pass matching. It will then only be used in
 9286   // the `Shorten_branches&#39; pass.
 9287   ins_short_branch(1);
 9288 %}
 9289 
 9290 instruct branchLoopEndFar(cmpOp cmp, flagsReg cr, label labl) %{
 9291   match(CountedLoopEnd cmp cr);
 9292   effect(USE labl);
 9293   ins_cost(BRANCH_COST);
 9294   size(6);
 9295   format %{ &quot;branch_con_far,$cmp   $labl\t # counted loop end&quot; %}
 9296   ins_encode(z_enc_branch_con_far(cmp, labl));
 9297   ins_pipe(pipe_class_dummy);
 9298   // This is not a short variant of a branch, but the long variant.
 9299   ins_short_branch(0);
 9300 %}
 9301 
 9302 //----------Compare and Branch (short distance)------------------------------
 9303 
 9304 // INT REG operands for loop counter processing.
 9305 instruct testAndBranchLoopEnd_Reg(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9306   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9307   effect(USE labl, KILL cr);
 9308   predicate(VM_Version::has_CompareBranch());
 9309   ins_cost(BRANCH_COST);
 9310   // TODO: s390 port size(FIXED_SIZE);
 9311   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9312   opcode(CRJ_ZOPC);
 9313   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9314   ins_pipe(pipe_class_dummy);
 9315   ins_short_branch(1);
 9316 %}
 9317 
 9318 // INT REG operands.
 9319 instruct cmpb_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9320   match(If boolnode (CmpI src1 src2));
 9321   effect(USE labl, KILL cr);
 9322   predicate(VM_Version::has_CompareBranch());
 9323   ins_cost(BRANCH_COST);
 9324   // TODO: s390 port size(FIXED_SIZE);
 9325   format %{ &quot;CRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9326   opcode(CRJ_ZOPC);
 9327   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9328   ins_pipe(pipe_class_dummy);
 9329   ins_short_branch(1);
 9330 %}
 9331 
 9332 // Unsigned INT REG operands
 9333 instruct cmpbU_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9334   match(If boolnode (CmpU src1 src2));
 9335   effect(USE labl, KILL cr);
 9336   predicate(VM_Version::has_CompareBranch());
 9337   ins_cost(BRANCH_COST);
 9338   // TODO: s390 port size(FIXED_SIZE);
 9339   format %{ &quot;CLRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9340   opcode(CLRJ_ZOPC);
 9341   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9342   ins_pipe(pipe_class_dummy);
 9343   ins_short_branch(1);
 9344 %}
 9345 
 9346 // LONG REG operands
 9347 instruct cmpb_RegL(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9348   match(If boolnode (CmpL src1 src2));
 9349   effect(USE labl, KILL cr);
 9350   predicate(VM_Version::has_CompareBranch());
 9351   ins_cost(BRANCH_COST);
 9352   // TODO: s390 port size(FIXED_SIZE);
 9353   format %{ &quot;CGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9354   opcode(CGRJ_ZOPC);
 9355   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9356   ins_pipe(pipe_class_dummy);
 9357   ins_short_branch(1);
 9358 %}
 9359 
 9360 //  PTR REG operands
 9361 
 9362 // Separate rules for regular and narrow oops.  ADLC can&#39;t recognize
 9363 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9364 // will not shorten.
 9365 
 9366 instruct cmpb_RegPP(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9367   match(If boolnode (CmpP src1 src2));
 9368   effect(USE labl, KILL cr);
 9369   predicate(VM_Version::has_CompareBranch());
 9370   ins_cost(BRANCH_COST);
 9371   // TODO: s390 port size(FIXED_SIZE);
 9372   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9373   opcode(CLGRJ_ZOPC);
 9374   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9375   ins_pipe(pipe_class_dummy);
 9376   ins_short_branch(1);
 9377 %}
 9378 
 9379 instruct cmpb_RegNN(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9380   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9381   effect(USE labl, KILL cr);
 9382   predicate(VM_Version::has_CompareBranch());
 9383   ins_cost(BRANCH_COST);
 9384   // TODO: s390 port size(FIXED_SIZE);
 9385   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9386   opcode(CLGRJ_ZOPC);
 9387   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9388   ins_pipe(pipe_class_dummy);
 9389   ins_short_branch(1);
 9390 %}
 9391 
 9392 // INT REG/IMM operands for loop counter processing
 9393 instruct testAndBranchLoopEnd_Imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9394   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9395   effect(USE labl, KILL cr);
 9396   predicate(VM_Version::has_CompareBranch());
 9397   ins_cost(BRANCH_COST);
 9398   // TODO: s390 port size(FIXED_SIZE);
 9399   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9400   opcode(CIJ_ZOPC);
 9401   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9402   ins_pipe(pipe_class_dummy);
 9403   ins_short_branch(1);
 9404 %}
 9405 
 9406 // INT REG/IMM operands
 9407 instruct cmpb_RegI_imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9408   match(If boolnode (CmpI src1 src2));
 9409   effect(USE labl, KILL cr);
 9410   predicate(VM_Version::has_CompareBranch());
 9411   ins_cost(BRANCH_COST);
 9412   // TODO: s390 port size(FIXED_SIZE);
 9413   format %{ &quot;CIJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9414   opcode(CIJ_ZOPC);
 9415   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9416   ins_pipe(pipe_class_dummy);
 9417   ins_short_branch(1);
 9418 %}
 9419 
 9420 // INT REG/IMM operands
 9421 instruct cmpbU_RegI_imm(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9422   match(If boolnode (CmpU src1 src2));
 9423   effect(USE labl, KILL cr);
 9424   predicate(VM_Version::has_CompareBranch());
 9425   ins_cost(BRANCH_COST);
 9426   // TODO: s390 port size(FIXED_SIZE);
 9427   format %{ &quot;CLIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9428   opcode(CLIJ_ZOPC);
 9429   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9430   ins_pipe(pipe_class_dummy);
 9431   ins_short_branch(1);
 9432 %}
 9433 
 9434 // LONG REG/IMM operands
 9435 instruct cmpb_RegL_imm(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9436   match(If boolnode (CmpL src1 src2));
 9437   effect(USE labl, KILL cr);
 9438   predicate(VM_Version::has_CompareBranch());
 9439   ins_cost(BRANCH_COST);
 9440   // TODO: s390 port size(FIXED_SIZE);
 9441   format %{ &quot;CGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9442   opcode(CGIJ_ZOPC);
 9443   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9444   ins_pipe(pipe_class_dummy);
 9445   ins_short_branch(1);
 9446 %}
 9447 
 9448 // PTR REG-imm operands
 9449 
 9450 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9451 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9452 // will not shorten.
 9453 
 9454 instruct cmpb_RegP_immP(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9455   match(If boolnode (CmpP src1 src2));
 9456   effect(USE labl, KILL cr);
 9457   predicate(VM_Version::has_CompareBranch());
 9458   ins_cost(BRANCH_COST);
 9459   // TODO: s390 port size(FIXED_SIZE);
 9460   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9461   opcode(CLGIJ_ZOPC);
 9462   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9463   ins_pipe(pipe_class_dummy);
 9464   ins_short_branch(1);
 9465 %}
 9466 
 9467 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9468 instruct cmpb_RegN_immP0(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9469   match(If boolnode (CmpP (DecodeN src1) src2));
 9470   effect(USE labl, KILL cr);
 9471   predicate(VM_Version::has_CompareBranch());
 9472   ins_cost(BRANCH_COST);
 9473   // TODO: s390 port size(FIXED_SIZE);
 9474   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9475   opcode(CLGIJ_ZOPC);
 9476   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9477   ins_pipe(pipe_class_dummy);
 9478   ins_short_branch(1);
 9479 %}
 9480 
 9481 instruct cmpb_RegN_imm(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9482   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9483   effect(USE labl, KILL cr);
 9484   predicate(VM_Version::has_CompareBranch());
 9485   ins_cost(BRANCH_COST);
 9486   // TODO: s390 port size(FIXED_SIZE);
 9487   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9488   opcode(CLGIJ_ZOPC);
 9489   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9490   ins_pipe(pipe_class_dummy);
 9491   ins_short_branch(1);
 9492 %}
 9493 
 9494 
 9495 //----------Compare and Branch (far distance)------------------------------
 9496 
 9497 // INT REG operands for loop counter processing
 9498 instruct testAndBranchLoopEnd_RegFar(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9499   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9500   effect(USE labl, KILL cr);
 9501   predicate(VM_Version::has_CompareBranch());
 9502   ins_cost(BRANCH_COST+DEFAULT_COST);
 9503   // TODO: s390 port size(FIXED_SIZE);
 9504   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9505   opcode(CR_ZOPC, BRCL_ZOPC);
 9506   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9507   ins_pipe(pipe_class_dummy);
 9508   ins_short_branch(0);
 9509 %}
 9510 
 9511 // INT REG operands
 9512 instruct cmpb_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9513   match(If boolnode (CmpI src1 src2));
 9514   effect(USE labl, KILL cr);
 9515   predicate(VM_Version::has_CompareBranch());
 9516   ins_cost(BRANCH_COST+DEFAULT_COST);
 9517   // TODO: s390 port size(FIXED_SIZE);
 9518   format %{ &quot;CRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9519   opcode(CR_ZOPC, BRCL_ZOPC);
 9520   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9521   ins_pipe(pipe_class_dummy);
 9522   ins_short_branch(0);
 9523 %}
 9524 
 9525 // INT REG operands
 9526 instruct cmpbU_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9527   match(If boolnode (CmpU src1 src2));
 9528   effect(USE labl, KILL cr);
 9529   predicate(VM_Version::has_CompareBranch());
 9530   ins_cost(BRANCH_COST+DEFAULT_COST);
 9531   // TODO: s390 port size(FIXED_SIZE);
 9532   format %{ &quot;CLRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9533   opcode(CLR_ZOPC, BRCL_ZOPC);
 9534   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9535   ins_pipe(pipe_class_dummy);
 9536   ins_short_branch(0);
 9537 %}
 9538 
 9539 // LONG REG operands
 9540 instruct cmpb_RegL_Far(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9541   match(If boolnode (CmpL src1 src2));
 9542   effect(USE labl, KILL cr);
 9543   predicate(VM_Version::has_CompareBranch());
 9544   ins_cost(BRANCH_COST+DEFAULT_COST);
 9545   // TODO: s390 port size(FIXED_SIZE);
 9546   format %{ &quot;CGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9547   opcode(CGR_ZOPC, BRCL_ZOPC);
 9548   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9549   ins_pipe(pipe_class_dummy);
 9550   ins_short_branch(0);
 9551 %}
 9552 
 9553 // PTR REG operands
 9554 
 9555 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9556 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9557 // will not shorten.
 9558 
 9559 instruct cmpb_RegPP_Far(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9560   match(If boolnode (CmpP src1 src2));
 9561   effect(USE labl, KILL cr);
 9562   predicate(VM_Version::has_CompareBranch());
 9563   ins_cost(BRANCH_COST+DEFAULT_COST);
 9564   // TODO: s390 port size(FIXED_SIZE);
 9565   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9566   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9567   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9568   ins_pipe(pipe_class_dummy);
 9569   ins_short_branch(0);
 9570 %}
 9571 
 9572 instruct cmpb_RegNN_Far(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9573   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9574   effect(USE labl, KILL cr);
 9575   predicate(VM_Version::has_CompareBranch());
 9576   ins_cost(BRANCH_COST+DEFAULT_COST);
 9577   // TODO: s390 port size(FIXED_SIZE);
 9578   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9579   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9580   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9581   ins_pipe(pipe_class_dummy);
 9582   ins_short_branch(0);
 9583 %}
 9584 
 9585 // INT REG/IMM operands for loop counter processing
 9586 instruct testAndBranchLoopEnd_ImmFar(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9587   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9588   effect(USE labl, KILL cr);
 9589   predicate(VM_Version::has_CompareBranch());
 9590   ins_cost(BRANCH_COST+DEFAULT_COST);
 9591   // TODO: s390 port size(FIXED_SIZE);
 9592   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9593   opcode(CHI_ZOPC, BRCL_ZOPC);
 9594   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9595   ins_pipe(pipe_class_dummy);
 9596   ins_short_branch(0);
 9597 %}
 9598 
 9599 // INT REG/IMM operands
 9600 instruct cmpb_RegI_imm_Far(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9601   match(If boolnode (CmpI src1 src2));
 9602   effect(USE labl, KILL cr);
 9603   predicate(VM_Version::has_CompareBranch());
 9604   ins_cost(BRANCH_COST+DEFAULT_COST);
 9605   // TODO: s390 port size(FIXED_SIZE);
 9606   format %{ &quot;CIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9607   opcode(CHI_ZOPC, BRCL_ZOPC);
 9608   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9609   ins_pipe(pipe_class_dummy);
 9610   ins_short_branch(0);
 9611 %}
 9612 
 9613 // INT REG/IMM operands
 9614 instruct cmpbU_RegI_imm_Far(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9615   match(If boolnode (CmpU src1 src2));
 9616   effect(USE labl, KILL cr);
 9617   predicate(VM_Version::has_CompareBranch());
 9618   ins_cost(BRANCH_COST+DEFAULT_COST);
 9619   // TODO: s390 port size(FIXED_SIZE);
 9620   format %{ &quot;CLIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9621   opcode(CLFI_ZOPC, BRCL_ZOPC);
 9622   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9623   ins_pipe(pipe_class_dummy);
 9624   ins_short_branch(0);
 9625 %}
 9626 
 9627 // LONG REG/IMM operands
 9628 instruct cmpb_RegL_imm_Far(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9629   match(If boolnode (CmpL src1 src2));
 9630   effect(USE labl, KILL cr);
 9631   predicate(VM_Version::has_CompareBranch());
 9632   ins_cost(BRANCH_COST+DEFAULT_COST);
 9633   // TODO: s390 port size(FIXED_SIZE);
 9634   format %{ &quot;CGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9635   opcode(CGHI_ZOPC, BRCL_ZOPC);
 9636   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9637   ins_pipe(pipe_class_dummy);
 9638   ins_short_branch(0);
 9639 %}
 9640 
 9641 // PTR REG-imm operands
 9642 
 9643 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9644 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9645 // will not shorten.
 9646 
 9647 instruct cmpb_RegP_immP_Far(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9648   match(If boolnode (CmpP src1 src2));
 9649   effect(USE labl, KILL cr);
 9650   predicate(VM_Version::has_CompareBranch());
 9651   ins_cost(BRANCH_COST+DEFAULT_COST);
 9652   // TODO: s390 port size(FIXED_SIZE);
 9653   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9654   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9655   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9656   ins_pipe(pipe_class_dummy);
 9657   ins_short_branch(0);
 9658 %}
 9659 
 9660 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9661 instruct cmpb_RegN_immP0_Far(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9662   match(If boolnode (CmpP (DecodeN src1) src2));
 9663   effect(USE labl, KILL cr);
 9664   predicate(VM_Version::has_CompareBranch());
 9665   ins_cost(BRANCH_COST+DEFAULT_COST);
 9666   // TODO: s390 port size(FIXED_SIZE);
 9667   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9668   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9669   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9670   ins_pipe(pipe_class_dummy);
 9671   ins_short_branch(0);
 9672 %}
 9673 
 9674 instruct cmpb_RegN_immN_Far(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9675   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9676   effect(USE labl, KILL cr);
 9677   predicate(VM_Version::has_CompareBranch());
 9678   ins_cost(BRANCH_COST+DEFAULT_COST);
 9679   // TODO: s390 port size(FIXED_SIZE);
 9680   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9681   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9682   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9683   ins_pipe(pipe_class_dummy);
 9684   ins_short_branch(0);
 9685 %}
 9686 
 9687 // ============================================================================
 9688 // Long Compare
 9689 
 9690 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 9691 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)). Note the
 9692 // difference between &#39;Y&#39; and &#39;0L&#39;. The tree-matches for the CmpI sections
 9693 // are collapsed internally in the ADLC&#39;s dfa-gen code. The match for
 9694 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 9695 // foo match ends up with the wrong leaf. One fix is to not match both
 9696 // reg-reg and reg-zero forms of long-compare. This is unfortunate because
 9697 // both forms beat the trinary form of long-compare and both are very useful
 9698 // on platforms which have few registers.
 9699 
 9700 // Manifest a CmpL3 result in an integer register. Very painful.
 9701 // This is the test to avoid.
 9702 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr) %{
 9703   match(Set dst (CmpL3 src1 src2));
 9704   effect(KILL cr);
 9705   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9706   size(24);
 9707   format %{ &quot;CmpL3 $dst,$src1,$src2&quot; %}
 9708   ins_encode %{
 9709     Label done;
 9710     // compare registers
 9711     __ z_cgr($src1$$Register, $src2$$Register);
 9712     // Convert condition code into -1,0,1, where
 9713     // -1 means less
 9714     //  0 means equal
 9715     //  1 means greater.
 9716     if (VM_Version::has_LoadStoreConditional()) {
 9717       Register one       = Z_R0_scratch;
 9718       Register minus_one = Z_R1_scratch;
 9719       __ z_lghi(minus_one, -1);
 9720       __ z_lghi(one, 1);
 9721       __ z_lghi( $dst$$Register, 0);
 9722       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9723       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLow);
 9724     } else {
 9725       __ clear_reg($dst$$Register, true, false);
 9726       __ z_bre(done);
 9727       __ z_lhi($dst$$Register, 1);
 9728       __ z_brh(done);
 9729       __ z_lhi($dst$$Register, -1);
 9730     }
 9731     __ bind(done);
 9732   %}
 9733   ins_pipe(pipe_class_dummy);
 9734 %}
 9735 
 9736 // ============================================================================
 9737 // Safepoint Instruction
 9738 
 9739 instruct safePoint() %{
 9740   match(SafePoint);
 9741   predicate(false);
 9742   // TODO: s390 port size(FIXED_SIZE);
 9743   format %{ &quot;UNIMPLEMENTED Safepoint_ &quot; %}
 9744   ins_encode(enc_unimplemented());
 9745   ins_pipe(pipe_class_dummy);
 9746 %}
 9747 
 9748 instruct safePoint_poll(iRegP poll, flagsReg cr) %{
 9749   match(SafePoint poll);
 9750   effect(USE poll, KILL cr); // R0 is killed, too.
 9751   // TODO: s390 port size(FIXED_SIZE);
 9752   format %{ &quot;TM      #0[,$poll],#111\t # Safepoint: poll for GC&quot; %}
 9753   ins_encode %{
 9754     // Mark the code position where the load from the safepoint
 9755     // polling page was emitted as relocInfo::poll_type.
 9756     __ relocate(relocInfo::poll_type);
 9757     __ load_from_polling_page($poll$$Register);
 9758   %}
 9759   ins_pipe(pipe_class_dummy);
 9760 %}
 9761 
 9762 // ============================================================================
 9763 
 9764 // Call Instructions
 9765 
 9766 // Call Java Static Instruction
 9767 instruct CallStaticJavaDirect_dynTOC(method meth) %{
 9768   match(CallStaticJava);
 9769   effect(USE meth);
 9770   ins_cost(CALL_COST);
 9771   // TODO: s390 port size(VARIABLE_SIZE);
 9772   format %{ &quot;CALL,static dynTOC $meth; ==&gt; &quot; %}
 9773   ins_encode( z_enc_java_static_call(meth) );
 9774   ins_pipe(pipe_class_dummy);
 9775   ins_alignment(2);
 9776 %}
 9777 
 9778 // Call Java Dynamic Instruction
 9779 instruct CallDynamicJavaDirect_dynTOC(method meth) %{
 9780   match(CallDynamicJava);
 9781   effect(USE meth);
 9782   ins_cost(CALL_COST);
 9783   // TODO: s390 port size(VARIABLE_SIZE);
 9784   format %{ &quot;CALL,dynamic dynTOC $meth; ==&gt; &quot; %}
 9785   ins_encode(z_enc_java_dynamic_call(meth));
 9786   ins_pipe(pipe_class_dummy);
 9787   ins_alignment(2);
 9788 %}
 9789 
 9790 // Call Runtime Instruction
 9791 instruct CallRuntimeDirect(method meth) %{
 9792   match(CallRuntime);
 9793   effect(USE meth);
 9794   ins_cost(CALL_COST);
 9795   // TODO: s390 port size(VARIABLE_SIZE);
 9796   ins_num_consts(1);
 9797   ins_alignment(2);
 9798   format %{ &quot;CALL,runtime&quot; %}
 9799   ins_encode( z_enc_java_to_runtime_call(meth) );
 9800   ins_pipe(pipe_class_dummy);
 9801 %}
 9802 
 9803 // Call runtime without safepoint - same as CallRuntime
 9804 instruct CallLeafDirect(method meth) %{
 9805   match(CallLeaf);
 9806   effect(USE meth);
 9807   ins_cost(CALL_COST);
 9808   // TODO: s390 port size(VARIABLE_SIZE);
 9809   ins_num_consts(1);
 9810   ins_alignment(2);
 9811   format %{ &quot;CALL,runtime leaf $meth&quot; %}
 9812   ins_encode( z_enc_java_to_runtime_call(meth) );
 9813   ins_pipe(pipe_class_dummy);
 9814 %}
 9815 
 9816 // Call runtime without safepoint - same as CallLeaf
 9817 instruct CallLeafNoFPDirect(method meth) %{
 9818   match(CallLeafNoFP);
 9819   effect(USE meth);
 9820   ins_cost(CALL_COST);
 9821   // TODO: s390 port size(VARIABLE_SIZE);
 9822   ins_num_consts(1);
 9823   format %{ &quot;CALL,runtime leaf nofp $meth&quot; %}
 9824   ins_encode( z_enc_java_to_runtime_call(meth) );
 9825   ins_pipe(pipe_class_dummy);
 9826   ins_alignment(2);
 9827 %}
 9828 
 9829 // Tail Call; Jump from runtime stub to Java code.
 9830 // Also known as an &#39;interprocedural jump&#39;.
 9831 // Target of jump will eventually return to caller.
 9832 // TailJump below removes the return address.
 9833 instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
 9834   match(TailCall jump_target method_oop);
 9835   ins_cost(CALL_COST);
 9836   size(2);
 9837   format %{ &quot;Jmp     $jump_target\t # $method_oop holds method oop&quot; %}
 9838   ins_encode %{ __ z_br($jump_target$$Register); %}
 9839   ins_pipe(pipe_class_dummy);
 9840 %}
 9841 
 9842 // Return Instruction
 9843 instruct Ret() %{
 9844   match(Return);
 9845   size(2);
 9846   format %{ &quot;BR(Z_R14) // branch to link register&quot; %}
 9847   ins_encode %{ __ z_br(Z_R14); %}
 9848   ins_pipe(pipe_class_dummy);
 9849 %}
 9850 
 9851 // Tail Jump; remove the return address; jump to target.
 9852 // TailCall above leaves the return address around.
 9853 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9854 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9855 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9856 // in %i0.
 9857 instruct tailjmpInd(iRegP jump_target, rarg1RegP ex_oop) %{
 9858   match(TailJump jump_target ex_oop);
 9859   ins_cost(CALL_COST);
 9860   size(8);
 9861   format %{ &quot;TailJump $jump_target&quot; %}
 9862   ins_encode %{
 9863     __ z_lg(Z_ARG2/* issuing pc */, _z_abi(return_pc), Z_SP);
 9864     __ z_br($jump_target$$Register);
 9865   %}
 9866   ins_pipe(pipe_class_dummy);
 9867 %}
 9868 
 9869 // Create exception oop: created by stack-crawling runtime code.
 9870 // Created exception is now available to this handler, and is setup
 9871 // just prior to jumping to this handler. No code emitted.
 9872 instruct CreateException(rarg1RegP ex_oop) %{
 9873   match(Set ex_oop (CreateEx));
 9874   ins_cost(0);
 9875   size(0);
 9876   format %{ &quot;# exception oop; no code emitted&quot; %}
 9877   ins_encode(/*empty*/);
 9878   ins_pipe(pipe_class_dummy);
 9879 %}
 9880 
 9881 // Rethrow exception: The exception oop will come in the first
 9882 // argument position. Then JUMP (not call) to the rethrow stub code.
 9883 instruct RethrowException() %{
 9884   match(Rethrow);
 9885   ins_cost(CALL_COST);
 9886   // TODO: s390 port size(VARIABLE_SIZE);
 9887   format %{ &quot;Jmp    rethrow_stub&quot; %}
 9888   ins_encode %{
 9889     cbuf.set_insts_mark();
 9890     __ load_const_optimized(Z_R1_scratch, (address)OptoRuntime::rethrow_stub());
 9891     __ z_br(Z_R1_scratch);
 9892   %}
 9893   ins_pipe(pipe_class_dummy);
 9894 %}
 9895 
 9896 // Die now.
 9897 instruct ShouldNotReachHere() %{
 9898   match(Halt);
 9899   ins_cost(CALL_COST);
 9900   format %{ &quot;ILLTRAP; ShouldNotReachHere&quot; %}
 9901   ins_encode %{
 9902     if (is_reachable()) {
 9903       __ stop(_halt_reason);
 9904     }
 9905   %}
 9906   ins_pipe(pipe_class_dummy);
 9907 %}
 9908 
 9909 // ============================================================================
 9910 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
 9911 // array for an instance of the superklass. Set a hidden internal cache on a
 9912 // hit (cache is checked with exposed code in gen_subtype_check()). Return
 9913 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
 9914 instruct partialSubtypeCheck(rarg1RegP index, rarg2RegP sub, rarg3RegP super, flagsReg pcc,
 9915                              rarg4RegP scratch1, rarg5RegP scratch2) %{
 9916   match(Set index (PartialSubtypeCheck sub super));
 9917   effect(KILL pcc, KILL scratch1, KILL scratch2);
 9918   ins_cost(10 * DEFAULT_COST);
 9919   // TODO: s390 port size(FIXED_SIZE);
 9920   format %{ &quot;  CALL   PartialSubtypeCheck\n&quot; %}
 9921   ins_encode %{
 9922     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9923     __ load_const_optimized(Z_ARG4, stub_address);
 9924     __ z_basr(Z_R14, Z_ARG4);
 9925   %}
 9926   ins_pipe(pipe_class_dummy);
 9927 %}
 9928 
 9929 instruct partialSubtypeCheck_vs_zero(flagsReg pcc, rarg2RegP sub, rarg3RegP super, immP0 zero,
 9930                                      rarg1RegP index, rarg4RegP scratch1, rarg5RegP scratch2) %{
 9931   match(Set pcc (CmpI (PartialSubtypeCheck sub super) zero));
 9932   effect(KILL scratch1, KILL scratch2, KILL index);
 9933   ins_cost(10 * DEFAULT_COST);
 9934   // TODO: s390 port size(FIXED_SIZE);
 9935   format %{ &quot;CALL   PartialSubtypeCheck_vs_zero\n&quot; %}
 9936   ins_encode %{
 9937     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9938     __ load_const_optimized(Z_ARG4, stub_address);
 9939     __ z_basr(Z_R14, Z_ARG4);
 9940   %}
 9941   ins_pipe(pipe_class_dummy);
 9942 %}
 9943 
 9944 // ============================================================================
 9945 // inlined locking and unlocking
 9946 
 9947 instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9948   match(Set pcc (FastLock oop box));
 9949   effect(TEMP tmp1, TEMP tmp2);
 9950   ins_cost(100);
 9951   // TODO: s390 port size(VARIABLE_SIZE); // Uses load_const_optimized.
 9952   format %{ &quot;FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9953   ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9954                                              UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9955   ins_pipe(pipe_class_dummy);
 9956 %}
 9957 
 9958 instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9959   match(Set pcc (FastUnlock oop box));
 9960   effect(TEMP tmp1, TEMP tmp2);
 9961   ins_cost(100);
 9962   // TODO: s390 port size(FIXED_SIZE);  // emitted code depends on UseBiasedLocking being on/off.
 9963   format %{ &quot;FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9964   ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9965                                                UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9966   ins_pipe(pipe_class_dummy);
 9967 %}
 9968 
 9969 instruct inlineCallClearArrayConst(SSlenDW cnt, iRegP_N2P base, Universe dummy, flagsReg cr) %{
 9970   match(Set dummy (ClearArray cnt base));
 9971   effect(KILL cr);
 9972   ins_cost(100);
 9973   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to varying #instructions.
 9974   format %{ &quot;ClearArrayConst $cnt,$base&quot; %}
 9975   ins_encode %{ __ Clear_Array_Const($cnt$$constant, $base$$Register); %}
 9976   ins_pipe(pipe_class_dummy);
 9977 %}
 9978 
 9979 instruct inlineCallClearArrayConstBig(immL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{
 9980   match(Set dummy (ClearArray cnt base));
 9981   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.
 9982   ins_cost(200);
 9983   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to optimized constant loader.
 9984   format %{ &quot;ClearArrayConstBig $cnt,$base&quot; %}
 9985   ins_encode %{ __ Clear_Array_Const_Big($cnt$$constant, $base$$Register, $tmpL$$Register); %}
 9986   ins_pipe(pipe_class_dummy);
 9987 %}
 9988 
 9989 instruct inlineCallClearArray(iRegL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{
 9990   match(Set dummy (ClearArray cnt base));
 9991   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.
 9992   ins_cost(300);
 9993   // TODO: s390 port size(FIXED_SIZE);  // z/Architecture: emitted code depends on PreferLAoverADD being on/off.
 9994   format %{ &quot;ClearArrayVar $cnt,$base&quot; %}
 9995   ins_encode %{ __ Clear_Array($cnt$$Register, $base$$Register, $tmpL$$Register); %}
 9996   ins_pipe(pipe_class_dummy);
 9997 %}
 9998 
 9999 // ============================================================================
10000 // CompactStrings
10001 
10002 // String equals
10003 instruct string_equalsL(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10004   match(Set result (StrEquals (Binary str1 str2) cnt));
10005   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10006   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10007   ins_cost(300);
10008   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
10009   ins_encode %{
10010     __ array_equals(false, $str1$$Register, $str2$$Register,
10011                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
10012                     $result$$Register, true /* byte */);
10013   %}
10014   ins_pipe(pipe_class_dummy);
10015 %}
10016 
10017 instruct string_equalsU(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10018   match(Set result (StrEquals (Binary str1 str2) cnt));
10019   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10020   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10021   ins_cost(300);
10022   format %{ &quot;String Equals char[] $str1,$str2,$cnt -&gt; $result&quot; %}
10023   ins_encode %{
10024     __ array_equals(false, $str1$$Register, $str2$$Register,
10025                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
10026                     $result$$Register, false /* byte */);
10027   %}
10028   ins_pipe(pipe_class_dummy);
10029 %}
10030 
10031 instruct string_equals_imm(iRegP str1, iRegP str2, uimmI8 cnt, iRegI result, flagsReg cr) %{
10032   match(Set result (StrEquals (Binary str1 str2) cnt));
10033   effect(KILL cr); // R0 is killed, too.
10034   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10035   ins_cost(100);
10036   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
10037   ins_encode %{
10038     const int cnt_imm = $cnt$$constant;
10039     if (cnt_imm) { __ z_clc(0, cnt_imm - 1, $str1$$Register, 0, $str2$$Register); }
10040     __ z_lhi($result$$Register, 1);
10041     if (cnt_imm) {
10042       if (VM_Version::has_LoadStoreConditional()) {
10043         __ z_lhi(Z_R0_scratch, 0);
10044         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
10045       } else {
10046         Label Lskip;
10047         __ z_bre(Lskip);
10048         __ clear_reg($result$$Register);
10049         __ bind(Lskip);
10050       }
10051     }
10052   %}
10053   ins_pipe(pipe_class_dummy);
10054 %}
10055 
10056 instruct string_equalsC_imm(iRegP str1, iRegP str2, immI8 cnt, iRegI result, flagsReg cr) %{
10057   match(Set result (StrEquals (Binary str1 str2) cnt));
10058   effect(KILL cr); // R0 is killed, too.
10059   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10060   ins_cost(100);
10061   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result&quot; %}
10062   ins_encode %{
10063     const int cnt_imm = $cnt$$constant; // positive immI8 (7 bits used)
10064     if (cnt_imm) { __ z_clc(0, (cnt_imm &lt;&lt; 1) - 1, $str1$$Register, 0, $str2$$Register); }
10065     __ z_lhi($result$$Register, 1);
10066     if (cnt_imm) {
10067       if (VM_Version::has_LoadStoreConditional()) {
10068         __ z_lhi(Z_R0_scratch, 0);
10069         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
10070       } else {
10071         Label Lskip;
10072         __ z_bre(Lskip);
10073         __ clear_reg($result$$Register);
10074         __ bind(Lskip);
10075       }
10076     }
10077   %}
10078   ins_pipe(pipe_class_dummy);
10079 %}
10080 
10081 // Array equals
10082 instruct array_equalsB(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10083   match(Set result (AryEq ary1 ary2));
10084   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10085   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10086   ins_cost(300);
10087   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10088   ins_encode %{
10089     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10090                     noreg, $oddReg$$Register, $evenReg$$Register,
10091                     $result$$Register, true /* byte */);
10092   %}
10093   ins_pipe(pipe_class_dummy);
10094 %}
10095 
10096 instruct array_equalsC(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10097   match(Set result (AryEq ary1 ary2));
10098   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10099   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10100   ins_cost(300);
10101   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10102   ins_encode %{
10103     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10104                     noreg, $oddReg$$Register, $evenReg$$Register,
10105                     $result$$Register, false /* byte */);
10106   %}
10107   ins_pipe(pipe_class_dummy);
10108 %}
10109 
10110 // String CompareTo
10111 instruct string_compareL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10112   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10113   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10114   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10115   ins_cost(300);
10116   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10117   ins_encode %{
10118     __ string_compare($str1$$Register, $str2$$Register,
10119                       $cnt1$$Register, $cnt2$$Register,
10120                       $oddReg$$Register, $evenReg$$Register,
10121                       $result$$Register, StrIntrinsicNode::LL);
10122   %}
10123   ins_pipe(pipe_class_dummy);
10124 %}
10125 
10126 instruct string_compareU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10127   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10128   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10129   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10130   ins_cost(300);
10131   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10132   ins_encode %{
10133     __ string_compare($str1$$Register, $str2$$Register,
10134                       $cnt1$$Register, $cnt2$$Register,
10135                       $oddReg$$Register, $evenReg$$Register,
10136                       $result$$Register, StrIntrinsicNode::UU);
10137   %}
10138   ins_pipe(pipe_class_dummy);
10139 %}
10140 
10141 instruct string_compareLU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10142   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10143   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10144   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10145   ins_cost(300);
10146   format %{ &quot;String Compare byte[],char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10147   ins_encode %{
10148     __ string_compare($str1$$Register, $str2$$Register,
10149                       $cnt1$$Register, $cnt2$$Register,
10150                       $oddReg$$Register, $evenReg$$Register,
10151                       $result$$Register, StrIntrinsicNode::LU);
10152   %}
10153   ins_pipe(pipe_class_dummy);
10154 %}
10155 
10156 instruct string_compareUL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10157   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10158   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10159   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10160   ins_cost(300);
10161   format %{ &quot;String Compare char[],byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10162   ins_encode %{
10163     __ string_compare($str2$$Register, $str1$$Register,
10164                       $cnt2$$Register, $cnt1$$Register,
10165                       $oddReg$$Register, $evenReg$$Register,
10166                       $result$$Register, StrIntrinsicNode::UL);
10167   %}
10168   ins_pipe(pipe_class_dummy);
10169 %}
10170 
10171 // String IndexOfChar
10172 instruct indexOfChar_U(iRegP haystack, iRegI haycnt, iRegI ch, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10173   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
10174   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10175   ins_cost(200);
10176   format %{ &quot;String IndexOfChar [0..$haycnt]($haystack), $ch -&gt; $result&quot; %}
10177   ins_encode %{
10178     __ string_indexof_char($result$$Register,
10179                            $haystack$$Register, $haycnt$$Register,
10180                            $ch$$Register, 0 /* unused, ch is in register */,
10181                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10182   %}
10183   ins_pipe(pipe_class_dummy);
10184 %}
10185 
10186 instruct indexOf_imm1_U(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10187   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10188   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10189   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10190   ins_cost(200);
10191   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10192   ins_encode %{
10193     immPOper *needleOper = (immPOper *)$needle;
10194     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10195     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10196     jchar chr;
10197 #ifdef VM_LITTLE_ENDIAN
10198     Unimplemented();
10199 #else
10200     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
10201            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
10202 #endif
10203     __ string_indexof_char($result$$Register,
10204                            $haystack$$Register, $haycnt$$Register,
10205                            noreg, chr,
10206                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10207   %}
10208   ins_pipe(pipe_class_dummy);
10209 %}
10210 
10211 instruct indexOf_imm1_L(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10212   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10213   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10214   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10215   ins_cost(200);
10216   format %{ &quot;String IndexOf L [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10217   ins_encode %{
10218     immPOper *needleOper = (immPOper *)$needle;
10219     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10220     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10221     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10222     __ string_indexof_char($result$$Register,
10223                            $haystack$$Register, $haycnt$$Register,
10224                            noreg, chr,
10225                            $oddReg$$Register, $evenReg$$Register, true /*is_byte*/);
10226   %}
10227   ins_pipe(pipe_class_dummy);
10228 %}
10229 
10230 instruct indexOf_imm1_UL(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10231   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10232   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10233   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10234   ins_cost(200);
10235   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10236   ins_encode %{
10237     immPOper *needleOper = (immPOper *)$needle;
10238     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10239     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10240     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10241     __ string_indexof_char($result$$Register,
10242                            $haystack$$Register, $haycnt$$Register,
10243                            noreg, chr,
10244                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10245   %}
10246   ins_pipe(pipe_class_dummy);
10247 %}
10248 
10249 // String IndexOf
10250 instruct indexOf_imm_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10251   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10252   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10253   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10254   ins_cost(250);
10255   format %{ &quot;String IndexOf U [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10256   ins_encode %{
10257     __ string_indexof($result$$Register,
10258                       $haystack$$Register, $haycnt$$Register,
10259                       $needle$$Register, noreg, $needlecntImm$$constant,
10260                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10261   %}
10262   ins_pipe(pipe_class_dummy);
10263 %}
10264 
10265 instruct indexOf_imm_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10266   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10267   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10268   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10269   ins_cost(250);
10270   format %{ &quot;String IndexOf L [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10271   ins_encode %{
10272     __ string_indexof($result$$Register,
10273                       $haystack$$Register, $haycnt$$Register,
10274                       $needle$$Register, noreg, $needlecntImm$$constant,
10275                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10276   %}
10277   ins_pipe(pipe_class_dummy);
10278 %}
10279 
10280 instruct indexOf_imm_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10281   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10282   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10283   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10284   ins_cost(250);
10285   format %{ &quot;String IndexOf UL [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10286   ins_encode %{
10287     __ string_indexof($result$$Register,
10288                       $haystack$$Register, $haycnt$$Register,
10289                       $needle$$Register, noreg, $needlecntImm$$constant,
10290                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10291   %}
10292   ins_pipe(pipe_class_dummy);
10293 %}
10294 
10295 instruct indexOf_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10296   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10297   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10298   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10299   ins_cost(300);
10300   format %{ &quot;String IndexOf U [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10301   ins_encode %{
10302     __ string_indexof($result$$Register,
10303                       $haystack$$Register, $haycnt$$Register,
10304                       $needle$$Register, $needlecnt$$Register, 0,
10305                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10306   %}
10307   ins_pipe(pipe_class_dummy);
10308 %}
10309 
10310 instruct indexOf_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10311   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10312   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10313   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10314   ins_cost(300);
10315   format %{ &quot;String IndexOf L [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10316   ins_encode %{
10317     __ string_indexof($result$$Register,
10318                       $haystack$$Register, $haycnt$$Register,
10319                       $needle$$Register, $needlecnt$$Register, 0,
10320                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10321   %}
10322   ins_pipe(pipe_class_dummy);
10323 %}
10324 
10325 instruct indexOf_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10326   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10327   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10328   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10329   ins_cost(300);
10330   format %{ &quot;String IndexOf UL [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10331   ins_encode %{
10332     __ string_indexof($result$$Register,
10333                       $haystack$$Register, $haycnt$$Register,
10334                       $needle$$Register, $needlecnt$$Register, 0,
10335                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10336   %}
10337   ins_pipe(pipe_class_dummy);
10338 %}
10339 
10340 // char[] to byte[] compression
10341 instruct string_compress(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10342   match(Set result (StrCompressedCopy src (Binary dst len)));
10343   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10344   ins_cost(300);
10345   format %{ &quot;String Compress $src-&gt;$dst($len) -&gt; $result&quot; %}
10346   ins_encode %{
10347     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10348                        $tmp$$Register, false);
10349   %}
10350   ins_pipe(pipe_class_dummy);
10351 %}
10352 
10353 // byte[] to char[] inflation. trot implementation is shorter, but slower than the unrolled icm(h) loop.
10354 //instruct string_inflate_trot(Universe dummy, iRegP src, revenRegP dst, roddRegI len, iRegI tmp, flagsReg cr) %{
10355 //  match(Set dummy (StrInflatedCopy src (Binary dst len)));
10356 //  effect(USE_KILL dst, USE_KILL len, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10357 //  predicate(VM_Version::has_ETF2Enhancements());
10358 //  ins_cost(300);
10359 //  format %{ &quot;String Inflate (trot) $dst,$src($len)&quot; %}
10360 //  ins_encode %{
10361 //    __ string_inflate_trot($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10362 //  %}
10363 //  ins_pipe(pipe_class_dummy);
10364 //%}
10365 
10366 // byte[] to char[] inflation
10367 instruct string_inflate(Universe dummy, iRegP src, iRegP dst, iRegI len, iRegI tmp, flagsReg cr) %{
10368   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10369   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10370   ins_cost(300);
10371   format %{ &quot;String Inflate $src-&gt;$dst($len)&quot; %}
10372   ins_encode %{
10373     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10374   %}
10375   ins_pipe(pipe_class_dummy);
10376 %}
10377 
10378 // byte[] to char[] inflation
10379 instruct string_inflate_const(Universe dummy, iRegP src, iRegP dst, iRegI tmp, immI len, flagsReg cr) %{
10380   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10381   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10382   ins_cost(300);
10383   format %{ &quot;String Inflate (constLen) $src-&gt;$dst($len)&quot; %}
10384   ins_encode %{
10385     __ string_inflate_const($src$$Register, $dst$$Register, $tmp$$Register, $len$$constant);
10386   %}
10387   ins_pipe(pipe_class_dummy);
10388 %}
10389 
10390 // StringCoding.java intrinsics
10391 instruct has_negatives(rarg5RegP ary1, iRegI len, iRegI result, roddRegI oddReg, revenRegI evenReg, iRegI tmp, flagsReg cr) %{
10392   match(Set result (HasNegatives ary1 len));
10393   effect(TEMP_DEF result, USE_KILL ary1, TEMP oddReg, TEMP evenReg, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10394   ins_cost(300);
10395   format %{ &quot;has negatives byte[] $ary1($len) -&gt; $result&quot; %}
10396   ins_encode %{
10397     __ has_negatives($result$$Register, $ary1$$Register, $len$$Register,
10398                      $oddReg$$Register, $evenReg$$Register, $tmp$$Register);
10399   %}
10400   ins_pipe(pipe_class_dummy);
10401 %}
10402 
10403 // encode char[] to byte[] in ISO_8859_1
10404 instruct encode_iso_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10405   match(Set result (EncodeISOArray src (Binary dst len)));
10406   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10407   ins_cost(300);
10408   format %{ &quot;Encode array $src-&gt;$dst($len) -&gt; $result&quot; %}
10409   ins_encode %{
10410     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10411                        $tmp$$Register, true);
10412   %}
10413   ins_pipe(pipe_class_dummy);
10414 %}
10415 
10416 
10417 //----------PEEPHOLE RULES-----------------------------------------------------
10418 // These must follow all instruction definitions as they use the names
10419 // defined in the instructions definitions.
10420 //
10421 // peepmatch (root_instr_name [preceeding_instruction]*);
10422 //
10423 // peepconstraint %{
10424 // (instruction_number.operand_name relational_op instruction_number.operand_name
10425 //  [, ...]);
10426 // // instruction numbers are zero-based using left to right order in peepmatch
10427 //
10428 // peepreplace (instr_name([instruction_number.operand_name]*));
10429 // // provide an instruction_number.operand_name for each operand that appears
10430 // // in the replacement instruction&#39;s match rule
10431 //
10432 // ---------VM FLAGS---------------------------------------------------------
10433 //
10434 // All peephole optimizations can be turned off using -XX:-OptoPeephole
10435 //
10436 // Each peephole rule is given an identifying number starting with zero and
10437 // increasing by one in the order seen by the parser. An individual peephole
10438 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
10439 // on the command-line.
10440 //
10441 // ---------CURRENT LIMITATIONS----------------------------------------------
10442 //
10443 // Only match adjacent instructions in same basic block
10444 // Only equality constraints
10445 // Only constraints between operands, not (0.dest_reg == EAX_enc)
10446 // Only one replacement instruction
10447 //
10448 // ---------EXAMPLE----------------------------------------------------------
10449 //
10450 // // pertinent parts of existing instructions in architecture description
10451 // instruct movI(eRegI dst, eRegI src) %{
10452 //   match(Set dst (CopyI src));
10453 // %}
10454 //
10455 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
10456 //   match(Set dst (AddI dst src));
10457 //   effect(KILL cr);
10458 // %}
10459 //
10460 // // Change (inc mov) to lea
10461 // peephole %{
10462 //   // increment preceeded by register-register move
10463 //   peepmatch (incI_eReg movI);
10464 //   // require that the destination register of the increment
10465 //   // match the destination register of the move
10466 //   peepconstraint (0.dst == 1.dst);
10467 //   // construct a replacement instruction that sets
10468 //   // the destination to (move&#39;s source register + one)
10469 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10470 // %}
10471 //
10472 // Implementation no longer uses movX instructions since
10473 // machine-independent system no longer uses CopyX nodes.
10474 //
10475 // peephole %{
10476 //   peepmatch (incI_eReg movI);
10477 //   peepconstraint (0.dst == 1.dst);
10478 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10479 // %}
10480 //
10481 // peephole %{
10482 //   peepmatch (decI_eReg movI);
10483 //   peepconstraint (0.dst == 1.dst);
10484 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10485 // %}
10486 //
10487 // peephole %{
10488 //   peepmatch (addI_eReg_imm movI);
10489 //   peepconstraint (0.dst == 1.dst);
10490 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10491 // %}
10492 //
10493 // peephole %{
10494 //   peepmatch (addP_eReg_imm movP);
10495 //   peepconstraint (0.dst == 1.dst);
10496 //   peepreplace (leaP_eReg_immI(0.dst 1.src 0.src));
10497 // %}
10498 
10499 
10500 //  This peephole rule does not work, probably because ADLC can&#39;t handle two effects:
10501 //  Effect 1 is defining 0.op1 and effect 2 is setting CC
10502 // condense a load from memory and subsequent test for zero
10503 // into a single, more efficient ICM instruction.
10504 // peephole %{
10505 //   peepmatch (compI_iReg_imm0 loadI);
10506 //   peepconstraint (1.dst == 0.op1);
10507 //   peepreplace (loadtest15_iReg_mem(0.op1 0.op1 1.mem));
10508 // %}
10509 
10510 // // Change load of spilled value to only a spill
10511 // instruct storeI(memory mem, eRegI src) %{
10512 //   match(Set mem (StoreI mem src));
10513 // %}
10514 //
10515 // instruct loadI(eRegI dst, memory mem) %{
10516 //   match(Set dst (LoadI mem));
10517 // %}
10518 //
10519 peephole %{
10520   peepmatch (loadI storeI);
10521   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10522   peepreplace (storeI(1.mem 1.mem 1.src));
10523 %}
10524 
10525 peephole %{
10526   peepmatch (loadL storeL);
10527   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10528   peepreplace (storeL(1.mem 1.mem 1.src));
10529 %}
10530 
10531 peephole %{
10532   peepmatch (loadP storeP);
10533   peepconstraint (1.src == 0.dst, 1.dst == 0.mem);
10534   peepreplace (storeP(1.dst 1.dst 1.src));
10535 %}
10536 
10537 //----------SUPERWORD RULES---------------------------------------------------
10538 
10539 //  Expand rules for special cases
10540 
10541 instruct expand_storeF(stackSlotF mem, regF src) %{
10542   // No match rule, false predicate, for expand only.
10543   effect(DEF mem, USE src);
10544   predicate(false);
10545   ins_cost(MEMORY_REF_COST);
10546   // TODO: s390 port size(FIXED_SIZE);
10547   format %{ &quot;STE      $src,$mem\t # replicate(float2stack)&quot; %}
10548   opcode(STE_ZOPC, STE_ZOPC);
10549   ins_encode(z_form_rt_mem(src, mem));
10550   ins_pipe(pipe_class_dummy);
10551 %}
10552 
10553 instruct expand_LoadLogical_I2L(iRegL dst, stackSlotF mem) %{
10554   // No match rule, false predicate, for expand only.
10555   effect(DEF dst, USE mem);
10556   predicate(false);
10557   ins_cost(MEMORY_REF_COST);
10558   // TODO: s390 port size(FIXED_SIZE);
10559   format %{ &quot;LLGF     $dst,$mem\t # replicate(stack2reg(unsigned))&quot; %}
10560   opcode(LLGF_ZOPC, LLGF_ZOPC);
10561   ins_encode(z_form_rt_mem(dst, mem));
10562   ins_pipe(pipe_class_dummy);
10563 %}
10564 
10565 // Replicate scalar int to packed int values (8 Bytes)
10566 instruct expand_Repl2I_reg(iRegL dst, iRegL src) %{
10567   // Dummy match rule, false predicate, for expand only.
10568   match(Set dst (ConvI2L src));
10569   predicate(false);
10570   ins_cost(DEFAULT_COST);
10571   // TODO: s390 port size(FIXED_SIZE);
10572   format %{ &quot;REPLIC2F $dst,$src\t # replicate(pack2F)&quot; %}
10573   ins_encode %{
10574     if ($dst$$Register == $src$$Register) {
10575       __ z_sllg(Z_R0_scratch, $src$$Register, 64-32);
10576       __ z_ogr($dst$$Register, Z_R0_scratch);
10577     }  else {
10578       __ z_sllg($dst$$Register, $src$$Register, 64-32);
10579       __ z_ogr( $dst$$Register, $src$$Register);
10580     }
10581   %}
10582   ins_pipe(pipe_class_dummy);
10583 %}
10584 
10585 // Replication
10586 
10587 // Exploit rotate_then_insert, if available
10588 // Replicate scalar byte to packed byte values (8 Bytes).
10589 instruct Repl8B_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10590   match(Set dst (ReplicateB src));
10591   effect(KILL cr);
10592   predicate((n-&gt;as_Vector()-&gt;length() == 8));
10593   format %{ &quot;REPLIC8B $dst,$src\t # pack8B&quot; %}
10594   ins_encode %{
10595     if ($dst$$Register != $src$$Register) {
10596       __ z_lgr($dst$$Register, $src$$Register);
10597     }
10598     __ rotate_then_insert($dst$$Register, $dst$$Register, 48, 55,  8, false);
10599     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10600     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10601   %}
10602   ins_pipe(pipe_class_dummy);
10603 %}
10604 
10605 // Replicate scalar byte to packed byte values (8 Bytes).
10606 instruct Repl8B_imm(iRegL dst, immB_n0m1 src) %{
10607   match(Set dst (ReplicateB src));
10608   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10609   ins_should_rematerialize(true);
10610   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm&quot; %}
10611   ins_encode %{
10612     int64_t  Isrc8 = $src$$constant &amp; 0x000000ff;
10613     int64_t Isrc16 =  Isrc8 &lt;&lt;  8 |  Isrc8;
10614     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10615     assert(Isrc8 != 0x000000ff &amp;&amp; Isrc8 != 0, &quot;should be handled by other match rules.&quot;);
10616 
10617     __ z_llilf($dst$$Register, Isrc32);
10618     __ z_iihf($dst$$Register, Isrc32);
10619   %}
10620   ins_pipe(pipe_class_dummy);
10621 %}
10622 
10623 // Replicate scalar byte to packed byte values (8 Bytes).
10624 instruct Repl8B_imm0(iRegL dst, immI_0 src) %{
10625   match(Set dst (ReplicateB src));
10626   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10627   ins_should_rematerialize(true);
10628   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm0&quot; %}
10629   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10630   ins_pipe(pipe_class_dummy);
10631 %}
10632 
10633 // Replicate scalar byte to packed byte values (8 Bytes).
10634 instruct Repl8B_immm1(iRegL dst, immB_minus1 src) %{
10635   match(Set dst (ReplicateB src));
10636   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10637   ins_should_rematerialize(true);
10638   format %{ &quot;REPLIC8B $dst,$src\t # pack8B immm1&quot; %}
10639   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10640   ins_pipe(pipe_class_dummy);
10641 %}
10642 
10643 // Exploit rotate_then_insert, if available
10644 // Replicate scalar short to packed short values (8 Bytes).
10645 instruct Repl4S_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10646   match(Set dst (ReplicateS src));
10647   effect(KILL cr);
10648   predicate((n-&gt;as_Vector()-&gt;length() == 4));
10649   format %{ &quot;REPLIC4S $dst,$src\t # pack4S&quot; %}
10650   ins_encode %{
10651     if ($dst$$Register != $src$$Register) {
10652       __ z_lgr($dst$$Register, $src$$Register);
10653     }
10654     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10655     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10656   %}
10657   ins_pipe(pipe_class_dummy);
10658 %}
10659 
10660 // Replicate scalar short to packed short values (8 Bytes).
10661 instruct Repl4S_imm(iRegL dst, immS_n0m1 src) %{
10662   match(Set dst (ReplicateS src));
10663   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10664   ins_should_rematerialize(true);
10665   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm&quot; %}
10666   ins_encode %{
10667     int64_t Isrc16 = $src$$constant &amp; 0x0000ffff;
10668     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10669     assert(Isrc16 != 0x0000ffff &amp;&amp; Isrc16 != 0, &quot;Repl4S_imm: (src == &quot; INT64_FORMAT
10670            &quot;) should be handled by other match rules.&quot;, $src$$constant);
10671 
10672     __ z_llilf($dst$$Register, Isrc32);
10673     __ z_iihf($dst$$Register, Isrc32);
10674   %}
10675   ins_pipe(pipe_class_dummy);
10676 %}
10677 
10678 // Replicate scalar short to packed short values (8 Bytes).
10679 instruct Repl4S_imm0(iRegL dst, immI_0 src) %{
10680   match(Set dst (ReplicateS src));
10681   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10682   ins_should_rematerialize(true);
10683   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm0&quot; %}
10684   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10685   ins_pipe(pipe_class_dummy);
10686 %}
10687 
10688 // Replicate scalar short to packed short values (8 Bytes).
10689 instruct Repl4S_immm1(iRegL dst, immS_minus1 src) %{
10690   match(Set dst (ReplicateS src));
10691   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10692   ins_should_rematerialize(true);
10693   format %{ &quot;REPLIC4S $dst,$src\t # pack4S immm1&quot; %}
10694   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10695   ins_pipe(pipe_class_dummy);
10696 %}
10697 
10698 // Exploit rotate_then_insert, if available.
10699 // Replicate scalar int to packed int values (8 Bytes).
10700 instruct Repl2I_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10701   match(Set dst (ReplicateI src));
10702   effect(KILL cr);
10703   predicate((n-&gt;as_Vector()-&gt;length() == 2));
10704   format %{ &quot;REPLIC2I $dst,$src\t # pack2I&quot; %}
10705   ins_encode %{
10706     if ($dst$$Register != $src$$Register) {
10707       __ z_lgr($dst$$Register, $src$$Register);
10708     }
10709     __ rotate_then_insert($dst$$Register, $dst$$Register, 0, 31, 32, false);
10710   %}
10711   ins_pipe(pipe_class_dummy);
10712 %}
10713 
10714 // Replicate scalar int to packed int values (8 Bytes).
10715 instruct Repl2I_imm(iRegL dst, immI_n0m1 src) %{
10716   match(Set dst (ReplicateI src));
10717   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10718   ins_should_rematerialize(true);
10719   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm&quot; %}
10720   ins_encode %{
10721     int64_t Isrc32 = $src$$constant;
10722     assert(Isrc32 != -1 &amp;&amp; Isrc32 != 0, &quot;should be handled by other match rules.&quot;);
10723 
10724     __ z_llilf($dst$$Register, Isrc32);
10725     __ z_iihf($dst$$Register, Isrc32);
10726   %}
10727   ins_pipe(pipe_class_dummy);
10728 %}
10729 
10730 // Replicate scalar int to packed int values (8 Bytes).
10731 instruct Repl2I_imm0(iRegL dst, immI_0 src) %{
10732   match(Set dst (ReplicateI src));
10733   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10734   ins_should_rematerialize(true);
10735   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm0&quot; %}
10736   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10737   ins_pipe(pipe_class_dummy);
10738 %}
10739 
10740 // Replicate scalar int to packed int values (8 Bytes).
10741 instruct Repl2I_immm1(iRegL dst, immI_minus1 src) %{
10742   match(Set dst (ReplicateI src));
10743   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10744   ins_should_rematerialize(true);
10745   format %{ &quot;REPLIC2I $dst,$src\t # pack2I immm1&quot; %}
10746   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10747   ins_pipe(pipe_class_dummy);
10748 %}
10749 
10750 //
10751 
10752 instruct Repl2F_reg_indirect(iRegL dst, regF src, flagsReg cr) %{
10753   match(Set dst (ReplicateF src));
10754   effect(KILL cr);
10755   predicate(!VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10756   format %{ &quot;REPLIC2F $dst,$src\t # pack2F indirect&quot; %}
10757   expand %{
10758     stackSlotF tmp;
10759     iRegL      tmp2;
10760     expand_storeF(tmp, src);
10761     expand_LoadLogical_I2L(tmp2, tmp);
10762     expand_Repl2I_reg(dst, tmp2);
10763   %}
10764 %}
10765 
10766 // Replicate scalar float to packed float values in GREG (8 Bytes).
10767 instruct Repl2F_reg_direct(iRegL dst, regF src, flagsReg cr) %{
10768   match(Set dst (ReplicateF src));
10769   effect(KILL cr);
10770   predicate(VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10771   format %{ &quot;REPLIC2F $dst,$src\t # pack2F direct&quot; %}
10772   ins_encode %{
10773     assert(VM_Version::has_FPSupportEnhancements(), &quot;encoder should never be called on old H/W&quot;);
10774     __ z_lgdr($dst$$Register, $src$$FloatRegister);
10775 
10776     __ z_srlg(Z_R0_scratch, $dst$$Register, 32);  // Floats are left-justified in 64bit reg.
10777     __ z_iilf($dst$$Register, 0);                 // Save a &quot;result not ready&quot; stall.
10778     __ z_ogr($dst$$Register, Z_R0_scratch);
10779   %}
10780   ins_pipe(pipe_class_dummy);
10781 %}
10782 
10783 // Replicate scalar float immediate to packed float values in GREG (8 Bytes).
10784 instruct Repl2F_imm(iRegL dst, immF src) %{
10785   match(Set dst (ReplicateF src));
10786   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10787   ins_should_rematerialize(true);
10788   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm&quot; %}
10789   ins_encode %{
10790     union {
10791       int   Isrc32;
10792       float Fsrc32;
10793     };
10794     Fsrc32 = $src$$constant;
10795     __ z_llilf($dst$$Register, Isrc32);
10796     __ z_iihf($dst$$Register, Isrc32);
10797   %}
10798   ins_pipe(pipe_class_dummy);
10799 %}
10800 
10801 // Replicate scalar float immediate zeroes to packed float values in GREG (8 Bytes).
10802 // Do this only for &#39;real&#39; zeroes, especially don&#39;t loose sign of negative zeroes.
10803 instruct Repl2F_imm0(iRegL dst, immFp0 src) %{
10804   match(Set dst (ReplicateF src));
10805   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10806   ins_should_rematerialize(true);
10807   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm0&quot; %}
10808   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10809   ins_pipe(pipe_class_dummy);
10810 %}
10811 
10812 // Store
10813 
10814 // Store Aligned Packed Byte register to memory (8 Bytes).
10815 instruct storeA8B(memory mem, iRegL src) %{
10816   match(Set mem (StoreVector mem src));
10817   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10818   ins_cost(MEMORY_REF_COST);
10819   // TODO: s390 port size(VARIABLE_SIZE);
10820   format %{ &quot;STG     $src,$mem\t # ST(packed8B)&quot; %}
10821   opcode(STG_ZOPC, STG_ZOPC);
10822   ins_encode(z_form_rt_mem_opt(src, mem));
10823   ins_pipe(pipe_class_dummy);
10824 %}
10825 
10826 // Load
10827 
10828 instruct loadV8(iRegL dst, memory mem) %{
10829   match(Set dst (LoadVector mem));
10830   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10831   ins_cost(MEMORY_REF_COST);
10832   // TODO: s390 port size(VARIABLE_SIZE);
10833   format %{ &quot;LG      $dst,$mem\t # L(packed8B)&quot; %}
10834   opcode(LG_ZOPC, LG_ZOPC);
10835   ins_encode(z_form_rt_mem_opt(dst, mem));
10836   ins_pipe(pipe_class_dummy);
10837 %}
10838 
10839 //----------POPULATION COUNT RULES--------------------------------------------
10840 
10841 // Byte reverse
10842 
10843 instruct bytes_reverse_int(iRegI dst, iRegI src) %{
10844   match(Set dst (ReverseBytesI src));
10845   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10846   ins_cost(DEFAULT_COST);
10847   size(4);
10848   format %{ &quot;LRVR    $dst,$src\t # byte reverse int&quot; %}
10849   opcode(LRVR_ZOPC);
10850   ins_encode(z_rreform(dst, src));
10851   ins_pipe(pipe_class_dummy);
10852 %}
10853 
10854 instruct bytes_reverse_long(iRegL dst, iRegL src) %{
10855   match(Set dst (ReverseBytesL src));
10856   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10857   ins_cost(DEFAULT_COST);
10858   // TODO: s390 port size(FIXED_SIZE);
10859   format %{ &quot;LRVGR   $dst,$src\t # byte reverse long&quot; %}
10860   opcode(LRVGR_ZOPC);
10861   ins_encode(z_rreform(dst, src));
10862   ins_pipe(pipe_class_dummy);
10863 %}
10864 
10865 // Leading zeroes
10866 
10867 // The instruction FLOGR (Find Leftmost One in Grande (64bit) Register)
10868 // returns the bit position of the leftmost 1 in the 64bit source register.
10869 // As the bits are numbered from left to right (0..63), the returned
10870 // position index is equivalent to the number of leading zeroes.
10871 // If no 1-bit is found (i.e. the regsiter contains zero), the instruction
10872 // returns position 64. That&#39;s exactly what we need.
10873 
10874 instruct countLeadingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10875   match(Set dst (CountLeadingZerosI src));
10876   effect(KILL tmp, KILL cr);
10877   ins_cost(3 * DEFAULT_COST);
10878   size(14);
10879   format %{ &quot;SLLG    $dst,$src,32\t # no need to always count 32 zeroes first\n\t&quot;
10880             &quot;IILH    $dst,0x8000 \t # insert \&quot;stop bit\&quot; to force result 32 for zero src.\n\t&quot;
10881             &quot;FLOGR   $dst,$dst&quot;
10882          %}
10883   ins_encode %{
10884     // Performance experiments indicate that &quot;FLOGR&quot; is using some kind of
10885     // iteration to find the leftmost &quot;1&quot; bit.
10886     //
10887     // The prior implementation zero-extended the 32-bit argument to 64 bit,
10888     // thus forcing &quot;FLOGR&quot; to count 32 bits of which we know they are zero.
10889     // We could gain measurable speedup in micro benchmark:
10890     //
10891     //               leading   trailing
10892     //   z10:   int     2.04       1.68
10893     //         long     1.00       1.02
10894     //   z196:  int     0.99       1.23
10895     //         long     1.00       1.11
10896     //
10897     // By shifting the argument into the high-word instead of zero-extending it.
10898     // The add&#39;l branch on condition (taken for a zero argument, very infrequent,
10899     // good prediction) is well compensated for by the savings.
10900     //
10901     // We leave the previous implementation in for some time in the future when
10902     // the &quot;FLOGR&quot; instruction may become less iterative.
10903 
10904     // Version 2: shows 62%(z9), 204%(z10), -1%(z196) improvement over original
10905     __ z_sllg($dst$$Register, $src$$Register, 32); // No need to always count 32 zeroes first.
10906     __ z_iilh($dst$$Register, 0x8000);   // Insert &quot;stop bit&quot; to force result 32 for zero src.
10907     __ z_flogr($dst$$Register, $dst$$Register);
10908   %}
10909   ins_pipe(pipe_class_dummy);
10910 %}
10911 
10912 instruct countLeadingZerosL(revenRegI dst, iRegL src, roddRegI tmp, flagsReg cr) %{
10913   match(Set dst (CountLeadingZerosL src));
10914   effect(KILL tmp, KILL cr);
10915   ins_cost(DEFAULT_COST);
10916   size(4);
10917   format %{ &quot;FLOGR   $dst,$src \t # count leading zeros (long)\n\t&quot; %}
10918   ins_encode %{ __ z_flogr($dst$$Register, $src$$Register); %}
10919   ins_pipe(pipe_class_dummy);
10920 %}
10921 
10922 // trailing zeroes
10923 
10924 // We transform the trailing zeroes problem to a leading zeroes problem
10925 // such that can use the FLOGR instruction to our advantage.
10926 
10927 // With
10928 //   tmp1 = src - 1
10929 // we flip all trailing zeroes to ones and the rightmost one to zero.
10930 // All other bits remain unchanged.
10931 // With the complement
10932 //   tmp2 = ~src
10933 // we get all ones in the trailing zeroes positions. Thus,
10934 //   tmp3 = tmp1 &amp; tmp2
10935 // yields ones in the trailing zeroes positions and zeroes elsewhere.
10936 // Now we can apply FLOGR and get 64-(trailing zeroes).
10937 instruct countTrailingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10938   match(Set dst (CountTrailingZerosI src));
10939   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10940   ins_cost(8 * DEFAULT_COST);
10941   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10942   format %{ &quot;LLGFR   $dst,$src  \t # clear upper 32 bits (we are dealing with int)\n\t&quot;
10943             &quot;LCGFR   $tmp,$src  \t # load 2&#39;s complement (32-&gt;64 bit)\n\t&quot;
10944             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;
10945             &quot;AGHI    $tmp,-1    \t # tmp2 = -src-1 = ~src\n\t&quot;
10946             &quot;NGR     $dst,$tmp  \t # tmp3 = tmp1&amp;tmp2\n\t&quot;
10947             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (int)\n\t&quot;
10948             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;
10949             &quot;LCR     $dst,$dst  \t # res = -tmp4&quot;
10950          %}
10951   ins_encode %{
10952     Register Rdst = $dst$$Register;
10953     Register Rsrc = $src$$Register;
10954     // Rtmp only needed for for zero-argument shortcut. With kill effect in
10955     // match rule Rsrc = roddReg would be possible, saving one register.
10956     Register Rtmp = $tmp$$Register;
10957 
10958     assert_different_registers(Rdst, Rsrc, Rtmp);
10959 
10960     // Algorithm:
10961     // - Isolate the least significant (rightmost) set bit using (src &amp; (-src)).
10962     //   All other bits in the result are zero.
10963     // - Find the &quot;leftmost one&quot; bit position in the single-bit result from previous step.
10964     // - 63-(&quot;leftmost one&quot; bit position) gives the # of trailing zeros.
10965 
10966     // Version 2: shows 79%(z9), 68%(z10), 23%(z196) improvement over original.
10967     Label done;
10968     __ load_const_optimized(Rdst, 32); // Prepare for shortcut (zero argument), result will be 32.
10969     __ z_lcgfr(Rtmp, Rsrc);
10970     __ z_bre(done);                    // Taken very infrequently, good prediction, no BHT entry.
10971 
10972     __ z_nr(Rtmp, Rsrc);               // (src) &amp; (-src) leaves nothing but least significant bit.
10973     __ z_ahi(Rtmp,  -1);               // Subtract one to fill all trailing zero positions with ones.
10974                                        // Use 32bit op to prevent borrow propagation (case Rdst = 0x80000000)
10975                                        // into upper half of reg. Not relevant with sllg below.
10976     __ z_sllg(Rdst, Rtmp, 32);         // Shift interesting contents to upper half of register.
10977     __ z_bre(done);                    // Shortcut for argument = 1, result will be 0.
10978                                        // Depends on CC set by ahi above.
10979                                        // Taken very infrequently, good prediction, no BHT entry.
10980                                        // Branch delayed to have Rdst set correctly (Rtmp == 0(32bit)
10981                                        // after SLLG Rdst == 0(64bit)).
10982     __ z_flogr(Rdst, Rdst);            // Kills tmp which is the oddReg for dst.
10983     __ add2reg(Rdst,  -32);            // 32-pos(leftmost1) is #trailing zeros
10984     __ z_lcgfr(Rdst, Rdst);            // Provide 64bit result at no cost.
10985     __ bind(done);
10986   %}
10987   ins_pipe(pipe_class_dummy);
10988 %}
10989 
10990 instruct countTrailingZerosL(revenRegI dst, iRegL src, roddRegL tmp, flagsReg cr) %{
10991   match(Set dst (CountTrailingZerosL src));
10992   effect(TEMP_DEF dst, KILL tmp, KILL cr);
10993   ins_cost(8 * DEFAULT_COST);
10994   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10995   format %{ &quot;LCGR    $dst,$src  \t # preserve src\n\t&quot;
10996             &quot;NGR     $dst,$src  \t #\n\t&quot;
10997             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;
10998             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (long), kill $tmp\n\t&quot;
10999             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;
11000             &quot;LCR     $dst,$dst  \t #&quot;
11001          %}
11002   ins_encode %{
11003     Register Rdst = $dst$$Register;
11004     Register Rsrc = $src$$Register;
11005     assert_different_registers(Rdst, Rsrc); // Rtmp == Rsrc allowed.
11006 
11007     // New version: shows 5%(z9), 2%(z10), 11%(z196) improvement over original.
11008     __ z_lcgr(Rdst, Rsrc);
11009     __ z_ngr(Rdst, Rsrc);
11010     __ add2reg(Rdst,   -1);
11011     __ z_flogr(Rdst, Rdst); // Kills tmp which is the oddReg for dst.
11012     __ add2reg(Rdst,  -64);
11013     __ z_lcgfr(Rdst, Rdst); // Provide 64bit result at no cost.
11014   %}
11015   ins_pipe(pipe_class_dummy);
11016 %}
11017 
11018 
11019 // bit count
11020 
11021 instruct popCountI(iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
11022   match(Set dst (PopCountI src));
11023   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11024   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11025   ins_cost(DEFAULT_COST);
11026   size(24);
11027   format %{ &quot;POPCNT  $dst,$src\t # pop count int&quot; %}
11028   ins_encode %{
11029     Register Rdst = $dst$$Register;
11030     Register Rsrc = $src$$Register;
11031     Register Rtmp = $tmp$$Register;
11032 
11033     // Prefer compile-time assertion over run-time SIGILL.
11034     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11035     assert_different_registers(Rdst, Rtmp);
11036 
11037     // Version 2: shows 10%(z196) improvement over original.
11038     __ z_popcnt(Rdst, Rsrc);
11039     __ z_srlg(Rtmp, Rdst, 16); // calc  byte4+byte6 and byte5+byte7
11040     __ z_alr(Rdst, Rtmp);      //   into byte6 and byte7
11041     __ z_srlg(Rtmp, Rdst,  8); // calc (byte4+byte6) + (byte5+byte7)
11042     __ z_alr(Rdst, Rtmp);      //   into byte7
11043     __ z_llgcr(Rdst, Rdst);    // zero-extend sum
11044   %}
11045   ins_pipe(pipe_class_dummy);
11046 %}
11047 
11048 instruct popCountL(iRegI dst, iRegL src, iRegL tmp, flagsReg cr) %{
11049   match(Set dst (PopCountL src));
11050   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11051   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11052   ins_cost(DEFAULT_COST);
11053   // TODO: s390 port size(FIXED_SIZE);
11054   format %{ &quot;POPCNT  $dst,$src\t # pop count long&quot; %}
11055   ins_encode %{
11056     Register Rdst = $dst$$Register;
11057     Register Rsrc = $src$$Register;
11058     Register Rtmp = $tmp$$Register;
11059 
11060     // Prefer compile-time assertion over run-time SIGILL.
11061     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11062     assert_different_registers(Rdst, Rtmp);
11063 
11064     // Original version. Using LA instead of algr seems to be a really bad idea (-35%).
11065     __ z_popcnt(Rdst, Rsrc);
11066     __ z_ahhlr(Rdst, Rdst, Rdst);
11067     __ z_sllg(Rtmp, Rdst, 16);
11068     __ z_algr(Rdst, Rtmp);
11069     __ z_sllg(Rtmp, Rdst,  8);
11070     __ z_algr(Rdst, Rtmp);
11071     __ z_srlg(Rdst, Rdst, 56);
11072   %}
11073   ins_pipe(pipe_class_dummy);
11074 %}
11075 
11076 //----------SMARTSPILL RULES---------------------------------------------------
11077 // These must follow all instruction definitions as they use the names
11078 // defined in the instructions definitions.
11079 
11080 // ============================================================================
11081 // TYPE PROFILING RULES
    </pre>
  </body>
</html>