<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  27 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  33 #include &quot;gc/shenandoah/heuristics/shenandoahHeuristics.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;interpreter/interp_masm.hpp&quot;
  36 #include &quot;runtime/sharedRuntime.hpp&quot;
  37 #include &quot;runtime/thread.hpp&quot;
  38 #include &quot;utilities/macros.hpp&quot;
  39 #ifdef COMPILER1
  40 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  41 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  42 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
  43 #endif
  44 
  45 #define __ masm-&gt;
  46 
  47 address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;
  48 
<a name="1" id="anc1"></a><span class="line-added">  49 static void save_xmm_registers(MacroAssembler* masm) {</span>
<span class="line-added">  50     __ subptr(rsp, 64);</span>
<span class="line-added">  51     __ movdbl(Address(rsp, 0), xmm0);</span>
<span class="line-added">  52     __ movdbl(Address(rsp, 8), xmm1);</span>
<span class="line-added">  53     __ movdbl(Address(rsp, 16), xmm2);</span>
<span class="line-added">  54     __ movdbl(Address(rsp, 24), xmm3);</span>
<span class="line-added">  55     __ movdbl(Address(rsp, 32), xmm4);</span>
<span class="line-added">  56     __ movdbl(Address(rsp, 40), xmm5);</span>
<span class="line-added">  57     __ movdbl(Address(rsp, 48), xmm6);</span>
<span class="line-added">  58     __ movdbl(Address(rsp, 56), xmm7);</span>
<span class="line-added">  59 }</span>
<span class="line-added">  60 </span>
<span class="line-added">  61 static void restore_xmm_registers(MacroAssembler* masm) {</span>
<span class="line-added">  62     __ movdbl(xmm0, Address(rsp, 0));</span>
<span class="line-added">  63     __ movdbl(xmm1, Address(rsp, 8));</span>
<span class="line-added">  64     __ movdbl(xmm2, Address(rsp, 16));</span>
<span class="line-added">  65     __ movdbl(xmm3, Address(rsp, 24));</span>
<span class="line-added">  66     __ movdbl(xmm4, Address(rsp, 32));</span>
<span class="line-added">  67     __ movdbl(xmm5, Address(rsp, 40));</span>
<span class="line-added">  68     __ movdbl(xmm6, Address(rsp, 48));</span>
<span class="line-added">  69     __ movdbl(xmm7, Address(rsp, 56));</span>
<span class="line-added">  70     __ addptr(rsp, 64);</span>
<span class="line-added">  71 }</span>
<span class="line-added">  72 </span>
  73 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
  74                                                        Register src, Register dst, Register count) {
  75 
  76   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
  77 
  78   if (is_reference_type(type)) {
  79 
  80     if ((ShenandoahSATBBarrier &amp;&amp; !dest_uninitialized) || ShenandoahStoreValEnqueueBarrier || ShenandoahLoadRefBarrier) {
  81 #ifdef _LP64
  82       Register thread = r15_thread;
  83 #else
  84       Register thread = rax;
  85       if (thread == src || thread == dst || thread == count) {
  86         thread = rbx;
  87       }
  88       if (thread == src || thread == dst || thread == count) {
  89         thread = rcx;
  90       }
  91       if (thread == src || thread == dst || thread == count) {
  92         thread = rdx;
  93       }
  94       __ push(thread);
  95       __ get_thread(thread);
  96 #endif
  97       assert_different_registers(src, dst, count, thread);
  98 
  99       Label done;
 100       // Short-circuit if count == 0.
 101       __ testptr(count, count);
 102       __ jcc(Assembler::zero, done);
 103 
 104       // Avoid runtime call when not active.
 105       Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 106       int flags;
 107       if (ShenandoahSATBBarrier &amp;&amp; dest_uninitialized) {
 108         flags = ShenandoahHeap::HAS_FORWARDED;
 109       } else {
 110         flags = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING;
 111       }
 112       __ testb(gc_state, flags);
 113       __ jcc(Assembler::zero, done);
 114 
 115       __ pusha();                      // push registers
 116 
 117 #ifdef _LP64
 118       assert(src == rdi, &quot;expected&quot;);
 119       assert(dst == rsi, &quot;expected&quot;);
 120       assert(count == rdx, &quot;expected&quot;);
 121       if (UseCompressedOops) {
 122         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop_entry),
 123                         src, dst, count);
 124       } else
 125 #endif
 126       {
 127         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop_entry),
 128                         src, dst, count);
 129       }
 130 
 131       __ popa();
 132       __ bind(done);
 133       NOT_LP64(__ pop(thread);)
 134     }
 135   }
 136 
 137 }
 138 
 139 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 140                                                                  Register obj,
 141                                                                  Register pre_val,
 142                                                                  Register thread,
 143                                                                  Register tmp,
 144                                                                  bool tosca_live,
 145                                                                  bool expand_call) {
 146 
 147   if (ShenandoahSATBBarrier) {
 148     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
 149   }
 150 }
 151 
 152 void ShenandoahBarrierSetAssembler::satb_write_barrier_pre(MacroAssembler* masm,
 153                                                            Register obj,
 154                                                            Register pre_val,
 155                                                            Register thread,
 156                                                            Register tmp,
 157                                                            bool tosca_live,
 158                                                            bool expand_call) {
 159   // If expand_call is true then we expand the call_VM_leaf macro
 160   // directly to skip generating the check by
 161   // InterpreterMacroAssembler::call_VM_leaf_base that checks _last_sp.
 162 
 163 #ifdef _LP64
 164   assert(thread == r15_thread, &quot;must be&quot;);
 165 #endif // _LP64
 166 
 167   Label done;
 168   Label runtime;
 169 
 170   assert(pre_val != noreg, &quot;check this code&quot;);
 171 
 172   if (obj != noreg) {
 173     assert_different_registers(obj, pre_val, tmp);
 174     assert(pre_val != rax, &quot;check this code&quot;);
 175   }
 176 
 177   Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));
 178   Address index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
 179   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
 180 
 181   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 182   __ testb(gc_state, ShenandoahHeap::MARKING);
 183   __ jcc(Assembler::zero, done);
 184 
 185   // Do we need to load the previous value?
 186   if (obj != noreg) {
 187     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
 188   }
 189 
 190   // Is the previous value null?
 191   __ cmpptr(pre_val, (int32_t) NULL_WORD);
 192   __ jcc(Assembler::equal, done);
 193 
 194   // Can we store original value in the thread&#39;s buffer?
 195   // Is index == 0?
 196   // (The index field is typed as size_t.)
 197 
 198   __ movptr(tmp, index);                   // tmp := *index_adr
 199   __ cmpptr(tmp, 0);                       // tmp == 0?
 200   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
 201 
 202   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
 203   __ movptr(index, tmp);                   // *index_adr := tmp
 204   __ addptr(tmp, buffer);                  // tmp := tmp + *buffer_adr
 205 
 206   // Record the previous value
 207   __ movptr(Address(tmp, 0), pre_val);
 208   __ jmp(done);
 209 
 210   __ bind(runtime);
 211   // save the live input values
 212   if(tosca_live) __ push(rax);
 213 
 214   if (obj != noreg &amp;&amp; obj != rax)
 215     __ push(obj);
 216 
 217   if (pre_val != rax)
 218     __ push(pre_val);
 219 
 220   // Calling the runtime using the regular call_VM_leaf mechanism generates
 221   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
 222   // that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.
 223   //
 224   // If we care generating the pre-barrier without a frame (e.g. in the
 225   // intrinsified Reference.get() routine) then ebp might be pointing to
 226   // the caller frame and so this check will most likely fail at runtime.
 227   //
 228   // Expanding the call directly bypasses the generation of the check.
 229   // So when we do not have have a full interpreter frame on the stack
 230   // expand_call should be passed true.
 231 
 232   NOT_LP64( __ push(thread); )
 233 
 234 #ifdef _LP64
 235   // We move pre_val into c_rarg0 early, in order to avoid smashing it, should
 236   // pre_val be c_rarg1 (where the call prologue would copy thread argument).
 237   // Note: this should not accidentally smash thread, because thread is always r15.
 238   assert(thread != c_rarg0, &quot;smashed arg&quot;);
 239   if (c_rarg0 != pre_val) {
 240     __ mov(c_rarg0, pre_val);
 241   }
 242 #endif
 243 
 244   if (expand_call) {
 245     LP64_ONLY( assert(pre_val != c_rarg1, &quot;smashed arg&quot;); )
 246 #ifdef _LP64
 247     if (c_rarg1 != thread) {
 248       __ mov(c_rarg1, thread);
 249     }
 250     // Already moved pre_val into c_rarg0 above
 251 #else
 252     __ push(thread);
 253     __ push(pre_val);
 254 #endif
 255     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), 2);
 256   } else {
 257     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), LP64_ONLY(c_rarg0) NOT_LP64(pre_val), thread);
 258   }
 259 
 260   NOT_LP64( __ pop(thread); )
 261 
 262   // save the live input values
 263   if (pre_val != rax)
 264     __ pop(pre_val);
 265 
 266   if (obj != noreg &amp;&amp; obj != rax)
 267     __ pop(obj);
 268 
 269   if(tosca_live) __ pop(rax);
 270 
 271   __ bind(done);
 272 }
 273 
 274 void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address src) {
 275   assert(ShenandoahLoadRefBarrier, &quot;Should be enabled&quot;);
 276 
 277   Label done;
 278 
 279 #ifdef _LP64
 280   Register thread = r15_thread;
 281 #else
 282   Register thread = rcx;
 283   if (thread == dst) {
 284     thread = rbx;
 285   }
 286   __ push(thread);
 287   __ get_thread(thread);
 288 #endif
 289 
 290   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 291   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);
 292   __ jccb(Assembler::zero, done);
 293 
 294   // Use rsi for src address
 295   const Register src_addr = rsi;
 296   // Setup address parameter first, if it does not clobber oop in dst
 297   bool need_addr_setup = (src_addr != dst);
 298 
 299   if (need_addr_setup) {
 300     __ push(src_addr);
 301     __ lea(src_addr, src);
 302 
 303     if (dst != rax) {
 304       // Move obj into rax and save rax
 305       __ push(rax);
 306       __ movptr(rax, dst);
 307     }
 308   } else {
 309     // dst == rsi
 310     __ push(rax);
 311     __ movptr(rax, dst);
 312 
 313     // we can clobber it, since it is outgoing register
 314     __ lea(src_addr, src);
 315   }
 316 
<a name="2" id="anc2"></a><span class="line-added"> 317   save_xmm_registers(masm);</span>
 318   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));
<a name="3" id="anc3"></a><span class="line-added"> 319   restore_xmm_registers(masm);</span>
 320 
 321   if (need_addr_setup) {
 322     if (dst != rax) {
 323       __ movptr(dst, rax);
 324       __ pop(rax);
 325     }
 326     __ pop(src_addr);
 327   } else {
 328     __ movptr(dst, rax);
 329     __ pop(rax);
 330   }
 331 
 332   __ bind(done);
 333 
 334 #ifndef _LP64
 335     __ pop(thread);
 336 #endif
 337 }
 338 
 339 void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src) {
 340   if (!ShenandoahLoadRefBarrier) {
 341     return;
 342   }
 343 
 344   Label done;
 345   Label not_null;
 346   Label slow_path;
 347   __ block_comment(&quot;load_reference_barrier_native { &quot;);
 348 
 349   // null check
 350   __ testptr(dst, dst);
 351   __ jcc(Assembler::notZero, not_null);
 352   __ jmp(done);
 353   __ bind(not_null);
 354 
 355 
 356 #ifdef _LP64
 357   Register thread = r15_thread;
 358 #else
 359   Register thread = rcx;
 360   if (thread == dst) {
 361     thread = rbx;
 362   }
 363   __ push(thread);
 364   __ get_thread(thread);
 365 #endif
 366   assert_different_registers(dst, thread);
 367 
 368   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 369   __ testb(gc_state, ShenandoahHeap::EVACUATION);
 370 #ifndef _LP64
 371   __ pop(thread);
 372 #endif
 373   __ jccb(Assembler::notZero, slow_path);
 374   __ jmp(done);
 375   __ bind(slow_path);
 376 
 377   if (dst != rax) {
 378     __ push(rax);
 379   }
 380   __ push(rcx);
 381   __ push(rdx);
 382   __ push(rdi);
 383   __ push(rsi);
 384 #ifdef _LP64
 385   __ push(r8);
 386   __ push(r9);
 387   __ push(r10);
 388   __ push(r11);
 389   __ push(r12);
 390   __ push(r13);
 391   __ push(r14);
 392   __ push(r15);
 393 #endif
 394 
 395   assert_different_registers(dst, rsi);
 396   __ lea(rsi, src);
<a name="4" id="anc4"></a><span class="line-added"> 397 </span>
<span class="line-added"> 398   save_xmm_registers(masm);</span>
 399   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), dst, rsi);
<a name="5" id="anc5"></a><span class="line-added"> 400   restore_xmm_registers(masm);</span>
 401 
 402 #ifdef _LP64
 403   __ pop(r15);
 404   __ pop(r14);
 405   __ pop(r13);
 406   __ pop(r12);
 407   __ pop(r11);
 408   __ pop(r10);
 409   __ pop(r9);
 410   __ pop(r8);
 411 #endif
 412   __ pop(rsi);
 413   __ pop(rdi);
 414   __ pop(rdx);
 415   __ pop(rcx);
 416 
 417   if (dst != rax) {
 418     __ movptr(dst, rax);
 419     __ pop(rax);
 420   }
 421 
 422   __ bind(done);
 423   __ block_comment(&quot;load_reference_barrier_native { &quot;);
 424 }
 425 
 426 void ShenandoahBarrierSetAssembler::storeval_barrier(MacroAssembler* masm, Register dst, Register tmp) {
 427   if (ShenandoahStoreValEnqueueBarrier) {
 428     storeval_barrier_impl(masm, dst, tmp);
 429   }
 430 }
 431 
 432 void ShenandoahBarrierSetAssembler::storeval_barrier_impl(MacroAssembler* masm, Register dst, Register tmp) {
 433   assert(ShenandoahStoreValEnqueueBarrier, &quot;should be enabled&quot;);
 434 
 435   if (dst == noreg) return;
 436 
 437   if (ShenandoahStoreValEnqueueBarrier) {
 438     // The set of registers to be saved+restored is the same as in the write-barrier above.
 439     // Those are the commonly used registers in the interpreter.
 440     __ pusha();
 441     // __ push_callee_saved_registers();
 442     __ subptr(rsp, 2 * Interpreter::stackElementSize);
 443     __ movdbl(Address(rsp, 0), xmm0);
 444 
 445 #ifdef _LP64
 446     Register thread = r15_thread;
 447 #else
 448     Register thread = rcx;
 449     if (thread == dst || thread == tmp) {
 450       thread = rdi;
 451     }
 452     if (thread == dst || thread == tmp) {
 453       thread = rbx;
 454     }
 455     __ get_thread(thread);
 456 #endif
 457     assert_different_registers(dst, tmp, thread);
 458 
 459     satb_write_barrier_pre(masm, noreg, dst, thread, tmp, true, false);
 460     __ movdbl(xmm0, Address(rsp, 0));
 461     __ addptr(rsp, 2 * Interpreter::stackElementSize);
 462     //__ pop_callee_saved_registers();
 463     __ popa();
 464   }
 465 }
 466 
 467 void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address src) {
 468   if (ShenandoahLoadRefBarrier) {
 469     Label done;
 470     __ testptr(dst, dst);
 471     __ jcc(Assembler::zero, done);
 472     load_reference_barrier_not_null(masm, dst, src);
 473     __ bind(done);
 474   }
 475 }
 476 
 477 //
 478 // Arguments:
 479 //
 480 // Inputs:
 481 //   src:        oop location, might be clobbered
 482 //   tmp1:       scratch register, might not be valid.
 483 //
 484 // Output:
 485 //   dst:        oop loaded from src location
 486 //
 487 // Kill:
 488 //   tmp1 (if it is valid)
 489 //
 490 void ShenandoahBarrierSetAssembler::load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 491              Register dst, Address src, Register tmp1, Register tmp_thread) {
 492   // 1: non-reference load, no additional barrier is needed
 493   if (!is_reference_type(type)) {
 494     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);
 495     return;
 496   }
 497 
 498   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Not expected&quot;);
 499 
 500   // 2: load a reference from src location and apply LRB if needed
 501   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {
 502     Register result_dst = dst;
 503     bool use_tmp1_for_dst = false;
 504 
 505     // Preserve src location for LRB
 506     if (dst == src.base() || dst == src.index()) {
 507       // Use tmp1 for dst if possible, as it is not used in BarrierAssembler::load_at()
 508       if (tmp1-&gt;is_valid() &amp;&amp; tmp1 != src.base() &amp;&amp; tmp1 != src.index()) {
 509         dst = tmp1;
 510         use_tmp1_for_dst = true;
 511       } else {
 512         dst = rdi;
 513         __ push(dst);
 514       }
 515       assert_different_registers(dst, src.base(), src.index());
 516     }
 517 
 518     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);
 519 
 520     if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {
 521       load_reference_barrier_native(masm, dst, src);
 522     } else {
 523       load_reference_barrier(masm, dst, src);
 524     }
 525 
 526     // Move loaded oop to final destination
 527     if (dst != result_dst) {
 528       __ movptr(result_dst, dst);
 529 
 530       if (!use_tmp1_for_dst) {
 531         __ pop(dst);
 532       }
 533 
 534       dst = result_dst;
 535     }
 536   } else {
 537     BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);
 538   }
 539 
 540   // 3: apply keep-alive barrier if needed
 541   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {
 542     __ push_IU_state();
 543     // That path can be reached from the c2i adapter with live fp
 544     // arguments in registers.
 545     LP64_ONLY(assert(Argument::n_float_register_parameters_j == 8, &quot;8 fp registers to save at java call&quot;));
<a name="6" id="anc6"></a><span class="line-modified"> 546     save_xmm_registers(masm);</span>








 547 
 548     Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);
 549     assert_different_registers(dst, tmp1, tmp_thread);
 550     if (!thread-&gt;is_valid()) {
 551       thread = rdx;
 552     }
 553     NOT_LP64(__ get_thread(thread));
 554     // Generate the SATB pre-barrier code to log the value of
 555     // the referent field in an SATB buffer.
 556     shenandoah_write_barrier_pre(masm /* masm */,
 557                                  noreg /* obj */,
 558                                  dst /* pre_val */,
 559                                  thread /* thread */,
 560                                  tmp1 /* tmp */,
 561                                  true /* tosca_live */,
 562                                  true /* expand_call */);
<a name="7" id="anc7"></a><span class="line-modified"> 563     restore_xmm_registers(masm);</span>








 564     __ pop_IU_state();
 565   }
 566 }
 567 
 568 void ShenandoahBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
 569               Address dst, Register val, Register tmp1, Register tmp2) {
 570 
 571   bool on_oop = is_reference_type(type);
 572   bool in_heap = (decorators &amp; IN_HEAP) != 0;
 573   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
 574   if (on_oop &amp;&amp; in_heap) {
 575     bool needs_pre_barrier = as_normal;
 576 
 577     Register tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
 578     Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
 579     // flatten object address if needed
 580     // We do it regardless of precise because we need the registers
 581     if (dst.index() == noreg &amp;&amp; dst.disp() == 0) {
 582       if (dst.base() != tmp1) {
 583         __ movptr(tmp1, dst.base());
 584       }
 585     } else {
 586       __ lea(tmp1, dst);
 587     }
 588 
 589     assert_different_registers(val, tmp1, tmp2, tmp3, rthread);
 590 
 591 #ifndef _LP64
 592     __ get_thread(rthread);
 593     InterpreterMacroAssembler *imasm = static_cast&lt;InterpreterMacroAssembler*&gt;(masm);
 594     imasm-&gt;save_bcp();
 595 #endif
 596 
 597     if (needs_pre_barrier) {
 598       shenandoah_write_barrier_pre(masm /*masm*/,
 599                                    tmp1 /* obj */,
 600                                    tmp2 /* pre_val */,
 601                                    rthread /* thread */,
 602                                    tmp3  /* tmp */,
 603                                    val != noreg /* tosca_live */,
 604                                    false /* expand_call */);
 605     }
 606     if (val == noreg) {
 607       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
 608     } else {
 609       storeval_barrier(masm, val, tmp3);
 610       BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg);
 611     }
 612     NOT_LP64(imasm-&gt;restore_bcp());
 613   } else {
 614     BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);
 615   }
 616 }
 617 
 618 void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler* masm, Register jni_env,
 619                                                                   Register obj, Register tmp, Label&amp; slowpath) {
 620   Label done;
 621   // Resolve jobject
 622   BarrierSetAssembler::try_resolve_jobject_in_native(masm, jni_env, obj, tmp, slowpath);
 623 
 624   // Check for null.
 625   __ testptr(obj, obj);
 626   __ jcc(Assembler::zero, done);
 627 
 628   Address gc_state(jni_env, ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset());
 629   __ testb(gc_state, ShenandoahHeap::EVACUATION);
 630   __ jccb(Assembler::notZero, slowpath);
 631   __ bind(done);
 632 }
 633 
 634 // Special Shenandoah CAS implementation that handles false negatives
 635 // due to concurrent evacuation.
 636 void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,
 637                                                 Register res, Address addr, Register oldval, Register newval,
 638                                                 bool exchange, Register tmp1, Register tmp2) {
 639   assert(ShenandoahCASBarrier, &quot;Should only be used when CAS barrier is enabled&quot;);
 640   assert(oldval == rax, &quot;must be in rax for implicit use in cmpxchg&quot;);
 641   assert_different_registers(oldval, newval, tmp1, tmp2);
 642 
 643   Label L_success, L_failure;
 644 
 645   // Remember oldval for retry logic below
 646 #ifdef _LP64
 647   if (UseCompressedOops) {
 648     __ movl(tmp1, oldval);
 649   } else
 650 #endif
 651   {
 652     __ movptr(tmp1, oldval);
 653   }
 654 
 655   // Step 1. Fast-path.
 656   //
 657   // Try to CAS with given arguments. If successful, then we are done.
 658 
 659   if (os::is_MP()) __ lock();
 660 #ifdef _LP64
 661   if (UseCompressedOops) {
 662     __ cmpxchgl(newval, addr);
 663   } else
 664 #endif
 665   {
 666     __ cmpxchgptr(newval, addr);
 667   }
 668   __ jcc(Assembler::equal, L_success);
 669 
 670   // Step 2. CAS had failed. This may be a false negative.
 671   //
 672   // The trouble comes when we compare the to-space pointer with the from-space
 673   // pointer to the same object. To resolve this, it will suffice to resolve
 674   // the value from memory -- this will give both to-space pointers.
 675   // If they mismatch, then it was a legitimate failure.
 676   //
 677   // Before reaching to resolve sequence, see if we can avoid the whole shebang
 678   // with filters.
 679 
 680   // Filter: when offending in-memory value is NULL, the failure is definitely legitimate
 681   __ testptr(oldval, oldval);
 682   __ jcc(Assembler::zero, L_failure);
 683 
 684   // Filter: when heap is stable, the failure is definitely legitimate
 685 #ifdef _LP64
 686   const Register thread = r15_thread;
 687 #else
 688   const Register thread = tmp2;
 689   __ get_thread(thread);
 690 #endif
 691   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 692   __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);
 693   __ jcc(Assembler::zero, L_failure);
 694 
 695 #ifdef _LP64
 696   if (UseCompressedOops) {
 697     __ movl(tmp2, oldval);
 698     __ decode_heap_oop(tmp2);
 699   } else
 700 #endif
 701   {
 702     __ movptr(tmp2, oldval);
 703   }
 704 
 705   // Decode offending in-memory value.
 706   // Test if-forwarded
 707   __ testb(Address(tmp2, oopDesc::mark_offset_in_bytes()), markWord::marked_value);
 708   __ jcc(Assembler::noParity, L_failure);  // When odd number of bits, then not forwarded
 709   __ jcc(Assembler::zero, L_failure);      // When it is 00, then also not forwarded
 710 
 711   // Load and mask forwarding pointer
 712   __ movptr(tmp2, Address(tmp2, oopDesc::mark_offset_in_bytes()));
 713   __ shrptr(tmp2, 2);
 714   __ shlptr(tmp2, 2);
 715 
 716 #ifdef _LP64
 717   if (UseCompressedOops) {
 718     __ decode_heap_oop(tmp1); // decode for comparison
 719   }
 720 #endif
 721 
 722   // Now we have the forwarded offender in tmp2.
 723   // Compare and if they don&#39;t match, we have legitimate failure
 724   __ cmpptr(tmp1, tmp2);
 725   __ jcc(Assembler::notEqual, L_failure);
 726 
 727   // Step 3. Need to fix the memory ptr before continuing.
 728   //
 729   // At this point, we have from-space oldval in the register, and its to-space
 730   // address is in tmp2. Let&#39;s try to update it into memory. We don&#39;t care if it
 731   // succeeds or not. If it does, then the retrying CAS would see it and succeed.
 732   // If this fixup fails, this means somebody else beat us to it, and necessarily
 733   // with to-space ptr store. We still have to do the retry, because the GC might
 734   // have updated the reference for us.
 735 
 736 #ifdef _LP64
 737   if (UseCompressedOops) {
 738     __ encode_heap_oop(tmp2); // previously decoded at step 2.
 739   }
 740 #endif
 741 
 742   if (os::is_MP()) __ lock();
 743 #ifdef _LP64
 744   if (UseCompressedOops) {
 745     __ cmpxchgl(tmp2, addr);
 746   } else
 747 #endif
 748   {
 749     __ cmpxchgptr(tmp2, addr);
 750   }
 751 
 752   // Step 4. Try to CAS again.
 753   //
 754   // This is guaranteed not to have false negatives, because oldval is definitely
 755   // to-space, and memory pointer is to-space as well. Nothing is able to store
 756   // from-space ptr into memory anymore. Make sure oldval is restored, after being
 757   // garbled during retries.
 758   //
 759 #ifdef _LP64
 760   if (UseCompressedOops) {
 761     __ movl(oldval, tmp2);
 762   } else
 763 #endif
 764   {
 765     __ movptr(oldval, tmp2);
 766   }
 767 
 768   if (os::is_MP()) __ lock();
 769 #ifdef _LP64
 770   if (UseCompressedOops) {
 771     __ cmpxchgl(newval, addr);
 772   } else
 773 #endif
 774   {
 775     __ cmpxchgptr(newval, addr);
 776   }
 777   if (!exchange) {
 778     __ jccb(Assembler::equal, L_success); // fastpath, peeking into Step 5, no need to jump
 779   }
 780 
 781   // Step 5. If we need a boolean result out of CAS, set the flag appropriately.
 782   // and promote the result. Note that we handle the flag from both the 1st and 2nd CAS.
 783   // Otherwise, failure witness for CAE is in oldval on all paths, and we can return.
 784 
 785   if (exchange) {
 786     __ bind(L_failure);
 787     __ bind(L_success);
 788   } else {
 789     assert(res != NULL, &quot;need result register&quot;);
 790 
 791     Label exit;
 792     __ bind(L_failure);
 793     __ xorptr(res, res);
 794     __ jmpb(exit);
 795 
 796     __ bind(L_success);
 797     __ movptr(res, 1);
 798     __ bind(exit);
 799   }
 800 }
 801 
 802 #undef __
 803 
 804 #ifdef COMPILER1
 805 
 806 #define __ ce-&gt;masm()-&gt;
 807 
 808 void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub) {
 809   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
 810   // At this point we know that marking is in progress.
 811   // If do_load() is true then we have to emit the
 812   // load of the previous value; otherwise it has already
 813   // been loaded into _pre_val.
 814 
 815   __ bind(*stub-&gt;entry());
 816   assert(stub-&gt;pre_val()-&gt;is_register(), &quot;Precondition.&quot;);
 817 
 818   Register pre_val_reg = stub-&gt;pre_val()-&gt;as_register();
 819 
 820   if (stub-&gt;do_load()) {
 821     ce-&gt;mem2reg(stub-&gt;addr(), stub-&gt;pre_val(), T_OBJECT, stub-&gt;patch_code(), stub-&gt;info(), false /*wide*/, false /*unaligned*/);
 822   }
 823 
 824   __ cmpptr(pre_val_reg, (int32_t)NULL_WORD);
 825   __ jcc(Assembler::equal, *stub-&gt;continuation());
 826   ce-&gt;store_parameter(stub-&gt;pre_val()-&gt;as_register(), 0);
 827   __ call(RuntimeAddress(bs-&gt;pre_barrier_c1_runtime_code_blob()-&gt;code_begin()));
 828   __ jmp(*stub-&gt;continuation());
 829 
 830 }
 831 
 832 void ShenandoahBarrierSetAssembler::gen_load_reference_barrier_stub(LIR_Assembler* ce, ShenandoahLoadReferenceBarrierStub* stub) {
 833   ShenandoahBarrierSetC1* bs = (ShenandoahBarrierSetC1*)BarrierSet::barrier_set()-&gt;barrier_set_c1();
 834   __ bind(*stub-&gt;entry());
 835 
 836   Register obj = stub-&gt;obj()-&gt;as_register();
 837   Register res = stub-&gt;result()-&gt;as_register();
 838   Register addr = stub-&gt;addr()-&gt;as_pointer_register();
 839   Register tmp1 = stub-&gt;tmp1()-&gt;as_register();
 840   Register tmp2 = stub-&gt;tmp2()-&gt;as_register();
 841   assert_different_registers(obj, res, addr, tmp1, tmp2);
 842 
 843   Label slow_path;
 844 
 845   assert(res == rax, &quot;result must arrive in rax&quot;);
 846 
 847   if (res != obj) {
 848     __ mov(res, obj);
 849   }
 850 
 851   // Check for null.
 852   __ testptr(res, res);
 853   __ jcc(Assembler::zero, *stub-&gt;continuation());
 854 
 855   // Check for object being in the collection set.
 856   __ mov(tmp1, res);
 857   __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());
 858   __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());
 859 #ifdef _LP64
 860   __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));
 861   __ testbool(tmp2);
 862 #else
 863   // On x86_32, C1 register allocator can give us the register without 8-bit support.
 864   // Do the full-register access and test to avoid compilation failures.
 865   __ movptr(tmp2, Address(tmp2, tmp1, Address::times_1));
 866   __ testptr(tmp2, 0xFF);
 867 #endif
 868   __ jcc(Assembler::zero, *stub-&gt;continuation());
 869 
 870   __ bind(slow_path);
 871   ce-&gt;store_parameter(res, 0);
 872   ce-&gt;store_parameter(addr, 1);
 873   if (stub-&gt;is_native()) {
 874     __ call(RuntimeAddress(bs-&gt;load_reference_barrier_native_rt_code_blob()-&gt;code_begin()));
 875   } else {
 876     __ call(RuntimeAddress(bs-&gt;load_reference_barrier_rt_code_blob()-&gt;code_begin()));
 877   }
 878   __ jmp(*stub-&gt;continuation());
 879 }
 880 
 881 #undef __
 882 
 883 #define __ sasm-&gt;
 884 
 885 void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm) {
 886   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
 887   // arg0 : previous value of memory
 888 
 889   __ push(rax);
 890   __ push(rdx);
 891 
 892   const Register pre_val = rax;
 893   const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);
 894   const Register tmp = rdx;
 895 
 896   NOT_LP64(__ get_thread(thread);)
 897 
 898   Address queue_index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
 899   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
 900 
 901   Label done;
 902   Label runtime;
 903 
 904   // Is SATB still active?
 905   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 906   __ testb(gc_state, ShenandoahHeap::MARKING);
 907   __ jcc(Assembler::zero, done);
 908 
 909   // Can we store original value in the thread&#39;s buffer?
 910 
 911   __ movptr(tmp, queue_index);
 912   __ testptr(tmp, tmp);
 913   __ jcc(Assembler::zero, runtime);
 914   __ subptr(tmp, wordSize);
 915   __ movptr(queue_index, tmp);
 916   __ addptr(tmp, buffer);
 917 
 918   // prev_val (rax)
 919   __ load_parameter(0, pre_val);
 920   __ movptr(Address(tmp, 0), pre_val);
 921   __ jmp(done);
 922 
 923   __ bind(runtime);
 924 
 925   __ save_live_registers_no_oop_map(true);
 926 
 927   // load the pre-value
 928   __ load_parameter(0, rcx);
 929   __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), rcx, thread);
 930 
 931   __ restore_live_registers(true);
 932 
 933   __ bind(done);
 934 
 935   __ pop(rdx);
 936   __ pop(rax);
 937 
 938   __ epilogue();
 939 }
 940 
 941 void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {
 942   __ prologue(&quot;shenandoah_load_reference_barrier&quot;, false);
 943   // arg0 : object to be resolved
 944 
 945   __ save_live_registers_no_oop_map(true);
 946 
 947 #ifdef _LP64
 948   __ load_parameter(0, c_rarg0);
 949   __ load_parameter(1, c_rarg1);
 950   if (is_native) {
 951     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), c_rarg0, c_rarg1);
 952   } else if (UseCompressedOops) {
 953     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), c_rarg0, c_rarg1);
 954   } else {
 955     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), c_rarg0, c_rarg1);
 956   }
 957 #else
 958   __ load_parameter(0, rax);
 959   __ load_parameter(1, rbx);
 960   if (is_native) {
 961     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), rax, rbx);
 962   } else {
 963     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rbx);
 964   }
 965 #endif
 966 
 967   __ restore_live_registers_except_rax(true);
 968 
 969   __ epilogue();
 970 }
 971 
 972 #undef __
 973 
 974 #endif // COMPILER1
 975 
 976 address ShenandoahBarrierSetAssembler::shenandoah_lrb() {
 977   assert(_shenandoah_lrb != NULL, &quot;need load reference barrier stub&quot;);
 978   return _shenandoah_lrb;
 979 }
 980 
 981 #define __ cgen-&gt;assembler()-&gt;
 982 
 983 /*
 984  *  Incoming parameters:
 985  *  rax: oop
 986  *  rsi: load address
 987  */
 988 address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {
 989   __ align(CodeEntryAlignment);
 990   StubCodeMark mark(cgen, &quot;StubRoutines&quot;, &quot;shenandoah_lrb&quot;);
 991   address start = __ pc();
 992 
 993   Label slow_path;
 994 
 995   // We use RDI, which also serves as argument register for slow call.
 996   // RAX always holds the src object ptr, except after the slow call,
 997   // then it holds the result. R8/RBX is used as temporary register.
 998 
 999   Register tmp1 = rdi;
1000   Register tmp2 = LP64_ONLY(r8) NOT_LP64(rbx);
1001 
1002   __ push(tmp1);
1003   __ push(tmp2);
1004 
1005   // Check for object being in the collection set.
1006   __ mov(tmp1, rax);
1007   __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());
1008   __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());
1009   __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));
1010   __ testbool(tmp2);
1011   __ jccb(Assembler::notZero, slow_path);
1012   __ pop(tmp2);
1013   __ pop(tmp1);
1014   __ ret(0);
1015 
1016   __ bind(slow_path);
1017 
1018   __ push(rcx);
1019   __ push(rdx);
1020   __ push(rdi);
1021 #ifdef _LP64
1022   __ push(r8);
1023   __ push(r9);
1024   __ push(r10);
1025   __ push(r11);
1026   __ push(r12);
1027   __ push(r13);
1028   __ push(r14);
1029   __ push(r15);
1030 #endif
1031   __ push(rbp);
1032   __ movptr(rbp, rsp);
1033   __ andptr(rsp, -StackAlignmentInBytes);
1034   __ push_FPU_state();
1035   if (UseCompressedOops) {
1036     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), rax, rsi);
1037   } else {
1038     __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rsi);
1039   }
1040   __ pop_FPU_state();
1041   __ movptr(rsp, rbp);
1042   __ pop(rbp);
1043 #ifdef _LP64
1044   __ pop(r15);
1045   __ pop(r14);
1046   __ pop(r13);
1047   __ pop(r12);
1048   __ pop(r11);
1049   __ pop(r10);
1050   __ pop(r9);
1051   __ pop(r8);
1052 #endif
1053   __ pop(rdi);
1054   __ pop(rdx);
1055   __ pop(rcx);
1056 
1057   __ pop(tmp2);
1058   __ pop(tmp1);
1059   __ ret(0);
1060 
1061   return start;
1062 }
1063 
1064 #undef __
1065 
1066 void ShenandoahBarrierSetAssembler::barrier_stubs_init() {
1067   if (ShenandoahLoadRefBarrier) {
1068     int stub_code_size = 4096;
1069     ResourceMark rm;
1070     BufferBlob* bb = BufferBlob::create(&quot;shenandoah_barrier_stubs&quot;, stub_code_size);
1071     CodeBuffer buf(bb);
1072     StubCodeGenerator cgen(&amp;buf);
1073     _shenandoah_lrb = generate_shenandoah_lrb(&amp;cgen);
1074   }
1075 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>