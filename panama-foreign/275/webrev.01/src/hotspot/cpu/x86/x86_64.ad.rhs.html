<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 int MachCallNativeNode::ret_addr_offset() {
  463   int offset = 13; // movq r10,#addr; callq (r10)
  464   offset += clear_avx_size();
  465   return offset;
  466 }
  467 //
  468 // Compute padding required for nodes which need alignment
  469 //
  470 
  471 // The address of the call instruction needs to be 4-byte aligned to
  472 // ensure that it does not span a cache line so that it can be patched.
  473 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  474 {
  475   current_offset += clear_avx_size(); // skip vzeroupper
  476   current_offset += 1; // skip call opcode byte
  477   return align_up(current_offset, alignment_required()) - current_offset;
  478 }
  479 
  480 // The address of the call instruction needs to be 4-byte aligned to
  481 // ensure that it does not span a cache line so that it can be patched.
  482 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  483 {
  484   current_offset += clear_avx_size(); // skip vzeroupper
  485   current_offset += 11; // skip movq instruction + call opcode byte
  486   return align_up(current_offset, alignment_required()) - current_offset;
  487 }
  488 
  489 // EMIT_RM()
  490 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  491   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  492   cbuf.insts()-&gt;emit_int8(c);
  493 }
  494 
  495 // EMIT_CC()
  496 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  497   unsigned char c = (unsigned char) (f1 | f2);
  498   cbuf.insts()-&gt;emit_int8(c);
  499 }
  500 
  501 // EMIT_OPCODE()
  502 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  503   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  504 }
  505 
  506 // EMIT_OPCODE() w/ relocation information
  507 void emit_opcode(CodeBuffer &amp;cbuf,
  508                  int code, relocInfo::relocType reloc, int offset, int format)
  509 {
  510   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  511   emit_opcode(cbuf, code);
  512 }
  513 
  514 // EMIT_D8()
  515 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  516   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  517 }
  518 
  519 // EMIT_D16()
  520 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  521   cbuf.insts()-&gt;emit_int16(d16);
  522 }
  523 
  524 // EMIT_D32()
  525 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  526   cbuf.insts()-&gt;emit_int32(d32);
  527 }
  528 
  529 // EMIT_D64()
  530 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  531   cbuf.insts()-&gt;emit_int64(d64);
  532 }
  533 
  534 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  535 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  536                     int d32,
  537                     relocInfo::relocType reloc,
  538                     int format)
  539 {
  540   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  541   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  542   cbuf.insts()-&gt;emit_int32(d32);
  543 }
  544 
  545 // emit 32 bit value and construct relocation entry from RelocationHolder
  546 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  547 #ifdef ASSERT
  548   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  549       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  550     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  551     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  552   }
  553 #endif
  554   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  555   cbuf.insts()-&gt;emit_int32(d32);
  556 }
  557 
  558 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  559   address next_ip = cbuf.insts_end() + 4;
  560   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  561                  external_word_Relocation::spec(addr),
  562                  RELOC_DISP32);
  563 }
  564 
  565 
  566 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  567 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  568   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  569   cbuf.insts()-&gt;emit_int64(d64);
  570 }
  571 
  572 // emit 64 bit value and construct relocation entry from RelocationHolder
  573 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  574 #ifdef ASSERT
  575   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  576       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  577     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  578     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  579   }
  580 #endif
  581   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  582   cbuf.insts()-&gt;emit_int64(d64);
  583 }
  584 
  585 // Access stack slot for load or store
  586 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  587 {
  588   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  589   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  590     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  591     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  592     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  593   } else {
  594     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  595     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  596     emit_d32(cbuf, disp);     // Displacement // R/M byte
  597   }
  598 }
  599 
  600    // rRegI ereg, memory mem) %{    // emit_reg_mem
  601 void encode_RegMem(CodeBuffer &amp;cbuf,
  602                    int reg,
  603                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  604 {
  605   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  606   int regenc = reg &amp; 7;
  607   int baseenc = base &amp; 7;
  608   int indexenc = index &amp; 7;
  609 
  610   // There is no index &amp; no scale, use form without SIB byte
  611   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  612     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  613     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  614       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  615     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  616       // If 8-bit displacement, mode 0x1
  617       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  618       emit_d8(cbuf, disp);
  619     } else {
  620       // If 32-bit displacement
  621       if (base == -1) { // Special flag for absolute address
  622         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  623         if (disp_reloc != relocInfo::none) {
  624           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  625         } else {
  626           emit_d32(cbuf, disp);
  627         }
  628       } else {
  629         // Normal base + offset
  630         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  631         if (disp_reloc != relocInfo::none) {
  632           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  633         } else {
  634           emit_d32(cbuf, disp);
  635         }
  636       }
  637     }
  638   } else {
  639     // Else, encode with the SIB byte
  640     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  641     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  642       // If no displacement
  643       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  644       emit_rm(cbuf, scale, indexenc, baseenc);
  645     } else {
  646       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  647         // If 8-bit displacement, mode 0x1
  648         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  649         emit_rm(cbuf, scale, indexenc, baseenc);
  650         emit_d8(cbuf, disp);
  651       } else {
  652         // If 32-bit displacement
  653         if (base == 0x04 ) {
  654           emit_rm(cbuf, 0x2, regenc, 0x4);
  655           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  656         } else {
  657           emit_rm(cbuf, 0x2, regenc, 0x4);
  658           emit_rm(cbuf, scale, indexenc, baseenc); // *
  659         }
  660         if (disp_reloc != relocInfo::none) {
  661           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  662         } else {
  663           emit_d32(cbuf, disp);
  664         }
  665       }
  666     }
  667   }
  668 }
  669 
  670 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  671 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  672   Label exit;
  673   __ jccb(Assembler::noParity, exit);
  674   __ pushf();
  675   //
  676   // comiss/ucomiss instructions set ZF,PF,CF flags and
  677   // zero OF,AF,SF for NaN values.
  678   // Fixup flags by zeroing ZF,PF so that compare of NaN
  679   // values returns &#39;less than&#39; result (CF is set).
  680   // Leave the rest of flags unchanged.
  681   //
  682   //    7 6 5 4 3 2 1 0
  683   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  684   //    0 0 1 0 1 0 1 1   (0x2B)
  685   //
  686   __ andq(Address(rsp, 0), 0xffffff2b);
  687   __ popf();
  688   __ bind(exit);
  689 }
  690 
  691 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  692   Label done;
  693   __ movl(dst, -1);
  694   __ jcc(Assembler::parity, done);
  695   __ jcc(Assembler::below, done);
  696   __ setb(Assembler::notEqual, dst);
  697   __ movzbl(dst, dst);
  698   __ bind(done);
  699 }
  700 
  701 // Math.min()    # Math.max()
  702 // --------------------------
  703 // ucomis[s/d]   #
  704 // ja   -&gt; b     # a
  705 // jp   -&gt; NaN   # NaN
  706 // jb   -&gt; a     # b
  707 // je            #
  708 // |-jz -&gt; a | b # a &amp; b
  709 // |    -&gt; a     #
  710 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  711                      XMMRegister a, XMMRegister b,
  712                      XMMRegister xmmt, Register rt,
  713                      bool min, bool single) {
  714 
  715   Label nan, zero, below, above, done;
  716 
  717   if (single)
  718     __ ucomiss(a, b);
  719   else
  720     __ ucomisd(a, b);
  721 
  722   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  723     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  724   else
  725     __ jccb(Assembler::above, done);
  726 
  727   __ jccb(Assembler::parity, nan);  // PF=1
  728   __ jccb(Assembler::below, below); // CF=1
  729 
  730   // equal
  731   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  732   if (single) {
  733     __ ucomiss(a, xmmt);
  734     __ jccb(Assembler::equal, zero);
  735 
  736     __ movflt(dst, a);
  737     __ jmp(done);
  738   }
  739   else {
  740     __ ucomisd(a, xmmt);
  741     __ jccb(Assembler::equal, zero);
  742 
  743     __ movdbl(dst, a);
  744     __ jmp(done);
  745   }
  746 
  747   __ bind(zero);
  748   if (min)
  749     __ vpor(dst, a, b, Assembler::AVX_128bit);
  750   else
  751     __ vpand(dst, a, b, Assembler::AVX_128bit);
  752 
  753   __ jmp(done);
  754 
  755   __ bind(above);
  756   if (single)
  757     __ movflt(dst, min ? b : a);
  758   else
  759     __ movdbl(dst, min ? b : a);
  760 
  761   __ jmp(done);
  762 
  763   __ bind(nan);
  764   if (single) {
  765     __ movl(rt, 0x7fc00000); // Float.NaN
  766     __ movdl(dst, rt);
  767   }
  768   else {
  769     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  770     __ movdq(dst, rt);
  771   }
  772   __ jmp(done);
  773 
  774   __ bind(below);
  775   if (single)
  776     __ movflt(dst, min ? a : b);
  777   else
  778     __ movdbl(dst, min ? a : b);
  779 
  780   __ bind(done);
  781 }
  782 
  783 //=============================================================================
  784 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  785 
  786 int ConstantTable::calculate_table_base_offset() const {
  787   return 0;  // absolute addressing, no offset
  788 }
  789 
  790 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  791 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  792   ShouldNotReachHere();
  793 }
  794 
  795 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  796   // Empty encoding
  797 }
  798 
  799 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  800   return 0;
  801 }
  802 
  803 #ifndef PRODUCT
  804 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  805   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  806 }
  807 #endif
  808 
  809 
  810 //=============================================================================
  811 #ifndef PRODUCT
  812 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  813   Compile* C = ra_-&gt;C;
  814 
  815   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  816   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  817   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  818   // Remove wordSize for return addr which is already pushed.
  819   framesize -= wordSize;
  820 
  821   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  822     framesize -= wordSize;
  823     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  824     st-&gt;print(&quot;\n\t&quot;);
  825     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  826     if (PreserveFramePointer) {
  827         st-&gt;print(&quot;\n\t&quot;);
  828         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  829     }
  830     if (framesize) {
  831       st-&gt;print(&quot;\n\t&quot;);
  832       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  833     }
  834   } else {
  835     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  836     st-&gt;print(&quot;\n\t&quot;);
  837     framesize -= wordSize;
  838     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  839     if (PreserveFramePointer) {
  840       st-&gt;print(&quot;\n\t&quot;);
  841       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  842       if (framesize &gt; 0) {
  843         st-&gt;print(&quot;\n\t&quot;);
  844         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  845       }
  846     }
  847   }
  848 
  849   if (VerifyStackAtCalls) {
  850     st-&gt;print(&quot;\n\t&quot;);
  851     framesize -= wordSize;
  852     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  853 #ifdef ASSERT
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;# stack alignment check&quot;);
  856 #endif
  857   }
  858   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  859     st-&gt;print(&quot;\n\t&quot;);
  860     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  861     st-&gt;print(&quot;\n\t&quot;);
  862     st-&gt;print(&quot;je      fast_entry\t&quot;);
  863     st-&gt;print(&quot;\n\t&quot;);
  864     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  865     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  866   }
  867   st-&gt;cr();
  868 }
  869 #endif
  870 
  871 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  872   Compile* C = ra_-&gt;C;
  873   MacroAssembler _masm(&amp;cbuf);
  874 
  875   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  876   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  877 
  878   if (C-&gt;clinit_barrier_on_entry()) {
  879     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  880     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  881 
  882     Label L_skip_barrier;
  883     Register klass = rscratch1;
  884 
  885     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  886     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  887 
  888     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  889 
  890     __ bind(L_skip_barrier);
  891   }
  892 
  893   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);
  894 
  895   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  896 
  897   if (C-&gt;has_mach_constant_base_node()) {
  898     // NOTE: We set the table base offset here because users might be
  899     // emitted before MachConstantBaseNode.
  900     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  901     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  902   }
  903 }
  904 
  905 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  906 {
  907   return MachNode::size(ra_); // too many variables; just compute it
  908                               // the hard way
  909 }
  910 
  911 int MachPrologNode::reloc() const
  912 {
  913   return 0; // a large enough number
  914 }
  915 
  916 //=============================================================================
  917 #ifndef PRODUCT
  918 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  919 {
  920   Compile* C = ra_-&gt;C;
  921   if (generate_vzeroupper(C)) {
  922     st-&gt;print(&quot;vzeroupper&quot;);
  923     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  924   }
  925 
  926   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  927   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  928   // Remove word for return adr already pushed
  929   // and RBP
  930   framesize -= 2*wordSize;
  931 
  932   if (framesize) {
  933     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  934     st-&gt;print(&quot;\t&quot;);
  935   }
  936 
  937   st-&gt;print_cr(&quot;popq    rbp&quot;);
  938   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  939     st-&gt;print(&quot;\t&quot;);
  940     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  941                  &quot;testl   rax, [rscratch1]\t&quot;
  942                  &quot;# Safepoint: poll for GC&quot;);
  943   }
  944 }
  945 #endif
  946 
  947 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  948 {
  949   Compile* C = ra_-&gt;C;
  950   MacroAssembler _masm(&amp;cbuf);
  951 
  952   if (generate_vzeroupper(C)) {
  953     // Clear upper bits of YMM registers when current compiled code uses
  954     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  955     __ vzeroupper();
  956   }
  957 
  958   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  959   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  960   // Remove word for return adr already pushed
  961   // and RBP
  962   framesize -= 2*wordSize;
  963 
  964   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  965 
  966   if (framesize) {
  967     emit_opcode(cbuf, Assembler::REX_W);
  968     if (framesize &lt; 0x80) {
  969       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
  970       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  971       emit_d8(cbuf, framesize);
  972     } else {
  973       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
  974       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  975       emit_d32(cbuf, framesize);
  976     }
  977   }
  978 
  979   // popq rbp
  980   emit_opcode(cbuf, 0x58 | RBP_enc);
  981 
  982   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  983     __ reserved_stack_check();
  984   }
  985 
  986   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  987     MacroAssembler _masm(&amp;cbuf);
  988     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  989     __ relocate(relocInfo::poll_return_type);
  990     __ testl(rax, Address(rscratch1, 0));
  991   }
  992 }
  993 
  994 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
  995 {
  996   return MachNode::size(ra_); // too many variables; just compute it
  997                               // the hard way
  998 }
  999 
 1000 int MachEpilogNode::reloc() const
 1001 {
 1002   return 2; // a large enough number
 1003 }
 1004 
 1005 const Pipeline* MachEpilogNode::pipeline() const
 1006 {
 1007   return MachNode::pipeline_class();
 1008 }
 1009 
 1010 //=============================================================================
 1011 
 1012 enum RC {
 1013   rc_bad,
 1014   rc_int,
 1015   rc_float,
 1016   rc_stack
 1017 };
 1018 
 1019 static enum RC rc_class(OptoReg::Name reg)
 1020 {
 1021   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1022 
 1023   if (OptoReg::is_stack(reg)) return rc_stack;
 1024 
 1025   VMReg r = OptoReg::as_VMReg(reg);
 1026 
 1027   if (r-&gt;is_Register()) return rc_int;
 1028 
 1029   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1030   return rc_float;
 1031 }
 1032 
 1033 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1034 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1035                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1036 
 1037 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1038                      int stack_offset, int reg, uint ireg, outputStream* st);
 1039 
 1040 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1041                                       int dst_offset, uint ireg, outputStream* st) {
 1042   if (cbuf) {
 1043     MacroAssembler _masm(cbuf);
 1044     switch (ireg) {
 1045     case Op_VecS:
 1046       __ movq(Address(rsp, -8), rax);
 1047       __ movl(rax, Address(rsp, src_offset));
 1048       __ movl(Address(rsp, dst_offset), rax);
 1049       __ movq(rax, Address(rsp, -8));
 1050       break;
 1051     case Op_VecD:
 1052       __ pushq(Address(rsp, src_offset));
 1053       __ popq (Address(rsp, dst_offset));
 1054       break;
 1055     case Op_VecX:
 1056       __ pushq(Address(rsp, src_offset));
 1057       __ popq (Address(rsp, dst_offset));
 1058       __ pushq(Address(rsp, src_offset+8));
 1059       __ popq (Address(rsp, dst_offset+8));
 1060       break;
 1061     case Op_VecY:
 1062       __ vmovdqu(Address(rsp, -32), xmm0);
 1063       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1064       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1065       __ vmovdqu(xmm0, Address(rsp, -32));
 1066       break;
 1067     case Op_VecZ:
 1068       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1069       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1070       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1071       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1072       break;
 1073     default:
 1074       ShouldNotReachHere();
 1075     }
 1076 #ifndef PRODUCT
 1077   } else {
 1078     switch (ireg) {
 1079     case Op_VecS:
 1080       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1081                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1082                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1083                 &quot;movq    rax, [rsp - #8]&quot;,
 1084                 src_offset, dst_offset);
 1085       break;
 1086     case Op_VecD:
 1087       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1088                 &quot;popq    [rsp + #%d]&quot;,
 1089                 src_offset, dst_offset);
 1090       break;
 1091      case Op_VecX:
 1092       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1093                 &quot;popq    [rsp + #%d]\n\t&quot;
 1094                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1095                 &quot;popq    [rsp + #%d]&quot;,
 1096                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1097       break;
 1098     case Op_VecY:
 1099       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1100                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1101                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1102                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1103                 src_offset, dst_offset);
 1104       break;
 1105     case Op_VecZ:
 1106       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1107                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1108                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1109                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1110                 src_offset, dst_offset);
 1111       break;
 1112     default:
 1113       ShouldNotReachHere();
 1114     }
 1115 #endif
 1116   }
 1117 }
 1118 
 1119 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1120                                        PhaseRegAlloc* ra_,
 1121                                        bool do_size,
 1122                                        outputStream* st) const {
 1123   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1124   // Get registers to move
 1125   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1126   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1127   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1128   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1129 
 1130   enum RC src_second_rc = rc_class(src_second);
 1131   enum RC src_first_rc = rc_class(src_first);
 1132   enum RC dst_second_rc = rc_class(dst_second);
 1133   enum RC dst_first_rc = rc_class(dst_first);
 1134 
 1135   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1136          &quot;must move at least 1 register&quot; );
 1137 
 1138   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1139     // Self copy, no move
 1140     return 0;
 1141   }
 1142   if (bottom_type()-&gt;isa_vect() != NULL) {
 1143     uint ireg = ideal_reg();
 1144     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1145     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1146     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1147       // mem -&gt; mem
 1148       int src_offset = ra_-&gt;reg2offset(src_first);
 1149       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1150       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1151     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1152       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1153     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1154       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1155       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1156     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1157       int stack_offset = ra_-&gt;reg2offset(src_first);
 1158       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1159     } else {
 1160       ShouldNotReachHere();
 1161     }
 1162     return 0;
 1163   }
 1164   if (src_first_rc == rc_stack) {
 1165     // mem -&gt;
 1166     if (dst_first_rc == rc_stack) {
 1167       // mem -&gt; mem
 1168       assert(src_second != dst_first, &quot;overlap&quot;);
 1169       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1170           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1171         // 64-bit
 1172         int src_offset = ra_-&gt;reg2offset(src_first);
 1173         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1174         if (cbuf) {
 1175           MacroAssembler _masm(cbuf);
 1176           __ pushq(Address(rsp, src_offset));
 1177           __ popq (Address(rsp, dst_offset));
 1178 #ifndef PRODUCT
 1179         } else {
 1180           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1181                     &quot;popq    [rsp + #%d]&quot;,
 1182                      src_offset, dst_offset);
 1183 #endif
 1184         }
 1185       } else {
 1186         // 32-bit
 1187         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1188         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1189         // No pushl/popl, so:
 1190         int src_offset = ra_-&gt;reg2offset(src_first);
 1191         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1192         if (cbuf) {
 1193           MacroAssembler _masm(cbuf);
 1194           __ movq(Address(rsp, -8), rax);
 1195           __ movl(rax, Address(rsp, src_offset));
 1196           __ movl(Address(rsp, dst_offset), rax);
 1197           __ movq(rax, Address(rsp, -8));
 1198 #ifndef PRODUCT
 1199         } else {
 1200           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1201                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1202                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1203                     &quot;movq    rax, [rsp - #8]&quot;,
 1204                      src_offset, dst_offset);
 1205 #endif
 1206         }
 1207       }
 1208       return 0;
 1209     } else if (dst_first_rc == rc_int) {
 1210       // mem -&gt; gpr
 1211       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1212           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1213         // 64-bit
 1214         int offset = ra_-&gt;reg2offset(src_first);
 1215         if (cbuf) {
 1216           MacroAssembler _masm(cbuf);
 1217           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1218 #ifndef PRODUCT
 1219         } else {
 1220           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1221                      Matcher::regName[dst_first],
 1222                      offset);
 1223 #endif
 1224         }
 1225       } else {
 1226         // 32-bit
 1227         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1228         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1229         int offset = ra_-&gt;reg2offset(src_first);
 1230         if (cbuf) {
 1231           MacroAssembler _masm(cbuf);
 1232           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1233 #ifndef PRODUCT
 1234         } else {
 1235           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1236                      Matcher::regName[dst_first],
 1237                      offset);
 1238 #endif
 1239         }
 1240       }
 1241       return 0;
 1242     } else if (dst_first_rc == rc_float) {
 1243       // mem-&gt; xmm
 1244       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1245           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1246         // 64-bit
 1247         int offset = ra_-&gt;reg2offset(src_first);
 1248         if (cbuf) {
 1249           MacroAssembler _masm(cbuf);
 1250           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1251 #ifndef PRODUCT
 1252         } else {
 1253           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1254                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1255                      Matcher::regName[dst_first],
 1256                      offset);
 1257 #endif
 1258         }
 1259       } else {
 1260         // 32-bit
 1261         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1262         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1263         int offset = ra_-&gt;reg2offset(src_first);
 1264         if (cbuf) {
 1265           MacroAssembler _masm(cbuf);
 1266           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1267 #ifndef PRODUCT
 1268         } else {
 1269           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1270                      Matcher::regName[dst_first],
 1271                      offset);
 1272 #endif
 1273         }
 1274       }
 1275       return 0;
 1276     }
 1277   } else if (src_first_rc == rc_int) {
 1278     // gpr -&gt;
 1279     if (dst_first_rc == rc_stack) {
 1280       // gpr -&gt; mem
 1281       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1282           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1283         // 64-bit
 1284         int offset = ra_-&gt;reg2offset(dst_first);
 1285         if (cbuf) {
 1286           MacroAssembler _masm(cbuf);
 1287           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1288 #ifndef PRODUCT
 1289         } else {
 1290           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1291                      offset,
 1292                      Matcher::regName[src_first]);
 1293 #endif
 1294         }
 1295       } else {
 1296         // 32-bit
 1297         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1298         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1299         int offset = ra_-&gt;reg2offset(dst_first);
 1300         if (cbuf) {
 1301           MacroAssembler _masm(cbuf);
 1302           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1303 #ifndef PRODUCT
 1304         } else {
 1305           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1306                      offset,
 1307                      Matcher::regName[src_first]);
 1308 #endif
 1309         }
 1310       }
 1311       return 0;
 1312     } else if (dst_first_rc == rc_int) {
 1313       // gpr -&gt; gpr
 1314       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1315           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1316         // 64-bit
 1317         if (cbuf) {
 1318           MacroAssembler _masm(cbuf);
 1319           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1320                   as_Register(Matcher::_regEncode[src_first]));
 1321 #ifndef PRODUCT
 1322         } else {
 1323           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1324                      Matcher::regName[dst_first],
 1325                      Matcher::regName[src_first]);
 1326 #endif
 1327         }
 1328         return 0;
 1329       } else {
 1330         // 32-bit
 1331         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1332         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1333         if (cbuf) {
 1334           MacroAssembler _masm(cbuf);
 1335           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1336                   as_Register(Matcher::_regEncode[src_first]));
 1337 #ifndef PRODUCT
 1338         } else {
 1339           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1340                      Matcher::regName[dst_first],
 1341                      Matcher::regName[src_first]);
 1342 #endif
 1343         }
 1344         return 0;
 1345       }
 1346     } else if (dst_first_rc == rc_float) {
 1347       // gpr -&gt; xmm
 1348       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1349           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1350         // 64-bit
 1351         if (cbuf) {
 1352           MacroAssembler _masm(cbuf);
 1353           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1354 #ifndef PRODUCT
 1355         } else {
 1356           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1357                      Matcher::regName[dst_first],
 1358                      Matcher::regName[src_first]);
 1359 #endif
 1360         }
 1361       } else {
 1362         // 32-bit
 1363         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1364         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1365         if (cbuf) {
 1366           MacroAssembler _masm(cbuf);
 1367           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1368 #ifndef PRODUCT
 1369         } else {
 1370           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1371                      Matcher::regName[dst_first],
 1372                      Matcher::regName[src_first]);
 1373 #endif
 1374         }
 1375       }
 1376       return 0;
 1377     }
 1378   } else if (src_first_rc == rc_float) {
 1379     // xmm -&gt;
 1380     if (dst_first_rc == rc_stack) {
 1381       // xmm -&gt; mem
 1382       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1383           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1384         // 64-bit
 1385         int offset = ra_-&gt;reg2offset(dst_first);
 1386         if (cbuf) {
 1387           MacroAssembler _masm(cbuf);
 1388           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1389 #ifndef PRODUCT
 1390         } else {
 1391           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1392                      offset,
 1393                      Matcher::regName[src_first]);
 1394 #endif
 1395         }
 1396       } else {
 1397         // 32-bit
 1398         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1399         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1400         int offset = ra_-&gt;reg2offset(dst_first);
 1401         if (cbuf) {
 1402           MacroAssembler _masm(cbuf);
 1403           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1404 #ifndef PRODUCT
 1405         } else {
 1406           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1407                      offset,
 1408                      Matcher::regName[src_first]);
 1409 #endif
 1410         }
 1411       }
 1412       return 0;
 1413     } else if (dst_first_rc == rc_int) {
 1414       // xmm -&gt; gpr
 1415       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1416           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1417         // 64-bit
 1418         if (cbuf) {
 1419           MacroAssembler _masm(cbuf);
 1420           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1421 #ifndef PRODUCT
 1422         } else {
 1423           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1424                      Matcher::regName[dst_first],
 1425                      Matcher::regName[src_first]);
 1426 #endif
 1427         }
 1428       } else {
 1429         // 32-bit
 1430         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1431         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1432         if (cbuf) {
 1433           MacroAssembler _masm(cbuf);
 1434           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1435 #ifndef PRODUCT
 1436         } else {
 1437           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1438                      Matcher::regName[dst_first],
 1439                      Matcher::regName[src_first]);
 1440 #endif
 1441         }
 1442       }
 1443       return 0;
 1444     } else if (dst_first_rc == rc_float) {
 1445       // xmm -&gt; xmm
 1446       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1447           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1448         // 64-bit
 1449         if (cbuf) {
 1450           MacroAssembler _masm(cbuf);
 1451           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1452 #ifndef PRODUCT
 1453         } else {
 1454           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1455                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1456                      Matcher::regName[dst_first],
 1457                      Matcher::regName[src_first]);
 1458 #endif
 1459         }
 1460       } else {
 1461         // 32-bit
 1462         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1463         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1464         if (cbuf) {
 1465           MacroAssembler _masm(cbuf);
 1466           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1467 #ifndef PRODUCT
 1468         } else {
 1469           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1470                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1471                      Matcher::regName[dst_first],
 1472                      Matcher::regName[src_first]);
 1473 #endif
 1474         }
 1475       }
 1476       return 0;
 1477     }
 1478   }
 1479 
 1480   assert(0,&quot; foo &quot;);
 1481   Unimplemented();
 1482   return 0;
 1483 }
 1484 
 1485 #ifndef PRODUCT
 1486 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1487   implementation(NULL, ra_, false, st);
 1488 }
 1489 #endif
 1490 
 1491 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1492   implementation(&amp;cbuf, ra_, false, NULL);
 1493 }
 1494 
 1495 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1496   return MachNode::size(ra_);
 1497 }
 1498 
 1499 //=============================================================================
 1500 #ifndef PRODUCT
 1501 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1502 {
 1503   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1504   int reg = ra_-&gt;get_reg_first(this);
 1505   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1506             Matcher::regName[reg], offset);
 1507 }
 1508 #endif
 1509 
 1510 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1511 {
 1512   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1513   int reg = ra_-&gt;get_encode(this);
 1514   if (offset &gt;= 0x80) {
 1515     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1516     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1517     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1518     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1519     emit_d32(cbuf, offset);
 1520   } else {
 1521     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1522     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1523     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1524     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1525     emit_d8(cbuf, offset);
 1526   }
 1527 }
 1528 
 1529 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1530 {
 1531   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1532   return (offset &lt; 0x80) ? 5 : 8; // REX
 1533 }
 1534 
 1535 //=============================================================================
 1536 #ifndef PRODUCT
 1537 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1538 {
 1539   if (UseCompressedClassPointers) {
 1540     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1541     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1542     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1543   } else {
 1544     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1545                  &quot;# Inline cache check&quot;);
 1546   }
 1547   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1548   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1549 }
 1550 #endif
 1551 
 1552 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1553 {
 1554   MacroAssembler masm(&amp;cbuf);
 1555   uint insts_size = cbuf.insts_size();
 1556   if (UseCompressedClassPointers) {
 1557     masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1558     masm.cmpptr(rax, rscratch1);
 1559   } else {
 1560     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1561   }
 1562 
 1563   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1564 
 1565   /* WARNING these NOPs are critical so that verified entry point is properly
 1566      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1567   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1568   if (OptoBreakpoint) {
 1569     // Leave space for int3
 1570     nops_cnt -= 1;
 1571   }
 1572   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1573   if (nops_cnt &gt; 0)
 1574     masm.nop(nops_cnt);
 1575 }
 1576 
 1577 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
 1578 {
 1579   return MachNode::size(ra_); // too many variables; just compute it
 1580                               // the hard way
 1581 }
 1582 
 1583 
 1584 //=============================================================================
 1585 
 1586 int Matcher::regnum_to_fpu_offset(int regnum)
 1587 {
 1588   return regnum - 32; // The FP registers are in the second chunk
 1589 }
 1590 
 1591 // This is UltraSparc specific, true just means we have fast l2f conversion
 1592 const bool Matcher::convL2FSupported(void) {
 1593   return true;
 1594 }
 1595 
 1596 // Is this branch offset short enough that a short branch can be used?
 1597 //
 1598 // NOTE: If the platform does not provide any short branch variants, then
 1599 //       this method should return false for offset 0.
 1600 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1601   // The passed offset is relative to address of the branch.
 1602   // On 86 a branch displacement is calculated relative to address
 1603   // of a next instruction.
 1604   offset -= br_size;
 1605 
 1606   // the short version of jmpConUCF2 contains multiple branches,
 1607   // making the reach slightly less
 1608   if (rule == jmpConUCF2_rule)
 1609     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1610   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1611 }
 1612 
 1613 const bool Matcher::isSimpleConstant64(jlong value) {
 1614   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1615   //return value == (int) value;  // Cf. storeImmL and immL32.
 1616 
 1617   // Probably always true, even if a temp register is required.
 1618   return true;
 1619 }
 1620 
 1621 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1622 const bool Matcher::init_array_count_is_in_bytes = false;
 1623 
 1624 // No additional cost for CMOVL.
 1625 const int Matcher::long_cmove_cost() { return 0; }
 1626 
 1627 // No CMOVF/CMOVD with SSE2
 1628 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1629 
 1630 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1631 const bool Matcher::require_postalloc_expand = false;
 1632 
 1633 // Do we need to mask the count passed to shift instructions or does
 1634 // the cpu only look at the lower 5/6 bits anyway?
 1635 const bool Matcher::need_masked_shift_count = false;
 1636 
 1637 bool Matcher::narrow_oop_use_complex_address() {
 1638   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1639   return (LogMinObjAlignmentInBytes &lt;= 3);
 1640 }
 1641 
 1642 bool Matcher::narrow_klass_use_complex_address() {
 1643   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1644   return (LogKlassAlignmentInBytes &lt;= 3);
 1645 }
 1646 
 1647 bool Matcher::const_oop_prefer_decode() {
 1648   // Prefer ConN+DecodeN over ConP.
 1649   return true;
 1650 }
 1651 
 1652 bool Matcher::const_klass_prefer_decode() {
 1653   // Prefer ConP over ConNKlass+DecodeNKlass.
 1654   return true;
 1655 }
 1656 
 1657 // Is it better to copy float constants, or load them directly from
 1658 // memory?  Intel can load a float constant from a direct address,
 1659 // requiring no extra registers.  Most RISCs will have to materialize
 1660 // an address into a register first, so they would do better to copy
 1661 // the constant from stack.
 1662 const bool Matcher::rematerialize_float_constants = true; // XXX
 1663 
 1664 // If CPU can load and store mis-aligned doubles directly then no
 1665 // fixup is needed.  Else we split the double into 2 integer pieces
 1666 // and move it piece-by-piece.  Only happens when passing doubles into
 1667 // C code as the Java calling convention forces doubles to be aligned.
 1668 const bool Matcher::misaligned_doubles_ok = true;
 1669 
 1670 // No-op on amd64
 1671 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1672 
 1673 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1674 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1675 
 1676 // Are floats conerted to double when stored to stack during deoptimization?
 1677 // On x64 it is stored without convertion so we can use normal access.
 1678 bool Matcher::float_in_double() { return false; }
 1679 
 1680 // Do ints take an entire long register or just half?
 1681 const bool Matcher::int_in_long = true;
 1682 
 1683 // Return whether or not this register is ever used as an argument.
 1684 // This function is used on startup to build the trampoline stubs in
 1685 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1686 // call in the trampoline, and arguments in those registers not be
 1687 // available to the callee.
 1688 bool Matcher::can_be_java_arg(int reg)
 1689 {
 1690   return
 1691     reg ==  RDI_num || reg == RDI_H_num ||
 1692     reg ==  RSI_num || reg == RSI_H_num ||
 1693     reg ==  RDX_num || reg == RDX_H_num ||
 1694     reg ==  RCX_num || reg == RCX_H_num ||
 1695     reg ==   R8_num || reg ==  R8_H_num ||
 1696     reg ==   R9_num || reg ==  R9_H_num ||
 1697     reg ==  R12_num || reg == R12_H_num ||
 1698     reg == XMM0_num || reg == XMM0b_num ||
 1699     reg == XMM1_num || reg == XMM1b_num ||
 1700     reg == XMM2_num || reg == XMM2b_num ||
 1701     reg == XMM3_num || reg == XMM3b_num ||
 1702     reg == XMM4_num || reg == XMM4b_num ||
 1703     reg == XMM5_num || reg == XMM5b_num ||
 1704     reg == XMM6_num || reg == XMM6b_num ||
 1705     reg == XMM7_num || reg == XMM7b_num;
 1706 }
 1707 
 1708 bool Matcher::is_spillable_arg(int reg)
 1709 {
 1710   return can_be_java_arg(reg);
 1711 }
 1712 
 1713 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1714   // In 64 bit mode a code which use multiply when
 1715   // devisor is constant is faster than hardware
 1716   // DIV instruction (it uses MulHiL).
 1717   return false;
 1718 }
 1719 
 1720 // Register for DIVI projection of divmodI
 1721 RegMask Matcher::divI_proj_mask() {
 1722   return INT_RAX_REG_mask();
 1723 }
 1724 
 1725 // Register for MODI projection of divmodI
 1726 RegMask Matcher::modI_proj_mask() {
 1727   return INT_RDX_REG_mask();
 1728 }
 1729 
 1730 // Register for DIVL projection of divmodL
 1731 RegMask Matcher::divL_proj_mask() {
 1732   return LONG_RAX_REG_mask();
 1733 }
 1734 
 1735 // Register for MODL projection of divmodL
 1736 RegMask Matcher::modL_proj_mask() {
 1737   return LONG_RDX_REG_mask();
 1738 }
 1739 
 1740 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1741 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1742     return NO_REG_mask();
 1743 }
 1744 
 1745 %}
 1746 
 1747 //----------ENCODING BLOCK-----------------------------------------------------
 1748 // This block specifies the encoding classes used by the compiler to
 1749 // output byte streams.  Encoding classes are parameterized macros
 1750 // used by Machine Instruction Nodes in order to generate the bit
 1751 // encoding of the instruction.  Operands specify their base encoding
 1752 // interface with the interface keyword.  There are currently
 1753 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1754 // COND_INTER.  REG_INTER causes an operand to generate a function
 1755 // which returns its register number when queried.  CONST_INTER causes
 1756 // an operand to generate a function which returns the value of the
 1757 // constant when queried.  MEMORY_INTER causes an operand to generate
 1758 // four functions which return the Base Register, the Index Register,
 1759 // the Scale Value, and the Offset Value of the operand when queried.
 1760 // COND_INTER causes an operand to generate six functions which return
 1761 // the encoding code (ie - encoding bits for the instruction)
 1762 // associated with each basic boolean condition for a conditional
 1763 // instruction.
 1764 //
 1765 // Instructions specify two basic values for encoding.  Again, a
 1766 // function is available to check if the constant displacement is an
 1767 // oop. They use the ins_encode keyword to specify their encoding
 1768 // classes (which must be a sequence of enc_class names, and their
 1769 // parameters, specified in the encoding block), and they use the
 1770 // opcode keyword to specify, in order, their primary, secondary, and
 1771 // tertiary opcode.  Only the opcode sections which a particular
 1772 // instruction needs for encoding need to be specified.
 1773 encode %{
 1774   // Build emit functions for each basic byte or larger field in the
 1775   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1776   // from C++ code in the enc_class source block.  Emit functions will
 1777   // live in the main source block for now.  In future, we can
 1778   // generalize this by adding a syntax that specifies the sizes of
 1779   // fields in an order, so that the adlc can build the emit functions
 1780   // automagically
 1781 
 1782   // Emit primary opcode
 1783   enc_class OpcP
 1784   %{
 1785     emit_opcode(cbuf, $primary);
 1786   %}
 1787 
 1788   // Emit secondary opcode
 1789   enc_class OpcS
 1790   %{
 1791     emit_opcode(cbuf, $secondary);
 1792   %}
 1793 
 1794   // Emit tertiary opcode
 1795   enc_class OpcT
 1796   %{
 1797     emit_opcode(cbuf, $tertiary);
 1798   %}
 1799 
 1800   // Emit opcode directly
 1801   enc_class Opcode(immI d8)
 1802   %{
 1803     emit_opcode(cbuf, $d8$$constant);
 1804   %}
 1805 
 1806   // Emit size prefix
 1807   enc_class SizePrefix
 1808   %{
 1809     emit_opcode(cbuf, 0x66);
 1810   %}
 1811 
 1812   enc_class reg(rRegI reg)
 1813   %{
 1814     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1815   %}
 1816 
 1817   enc_class reg_reg(rRegI dst, rRegI src)
 1818   %{
 1819     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1820   %}
 1821 
 1822   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1823   %{
 1824     emit_opcode(cbuf, $opcode$$constant);
 1825     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1826   %}
 1827 
 1828   enc_class cdql_enc(no_rax_rdx_RegI div)
 1829   %{
 1830     // Full implementation of Java idiv and irem; checks for
 1831     // special case as described in JVM spec., p.243 &amp; p.271.
 1832     //
 1833     //         normal case                           special case
 1834     //
 1835     // input : rax: dividend                         min_int
 1836     //         reg: divisor                          -1
 1837     //
 1838     // output: rax: quotient  (= rax idiv reg)       min_int
 1839     //         rdx: remainder (= rax irem reg)       0
 1840     //
 1841     //  Code sequnce:
 1842     //
 1843     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1844     //    5:   75 07/08                jne    e &lt;normal&gt;
 1845     //    7:   33 d2                   xor    %edx,%edx
 1846     //  [div &gt;= 8 -&gt; offset + 1]
 1847     //  [REX_B]
 1848     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1849     //    c:   74 03/04                je     11 &lt;done&gt;
 1850     // 000000000000000e &lt;normal&gt;:
 1851     //    e:   99                      cltd
 1852     //  [div &gt;= 8 -&gt; offset + 1]
 1853     //  [REX_B]
 1854     //    f:   f7 f9                   idiv   $div
 1855     // 0000000000000011 &lt;done&gt;:
 1856 
 1857     // cmp    $0x80000000,%eax
 1858     emit_opcode(cbuf, 0x3d);
 1859     emit_d8(cbuf, 0x00);
 1860     emit_d8(cbuf, 0x00);
 1861     emit_d8(cbuf, 0x00);
 1862     emit_d8(cbuf, 0x80);
 1863 
 1864     // jne    e &lt;normal&gt;
 1865     emit_opcode(cbuf, 0x75);
 1866     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1867 
 1868     // xor    %edx,%edx
 1869     emit_opcode(cbuf, 0x33);
 1870     emit_d8(cbuf, 0xD2);
 1871 
 1872     // cmp    $0xffffffffffffffff,%ecx
 1873     if ($div$$reg &gt;= 8) {
 1874       emit_opcode(cbuf, Assembler::REX_B);
 1875     }
 1876     emit_opcode(cbuf, 0x83);
 1877     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1878     emit_d8(cbuf, 0xFF);
 1879 
 1880     // je     11 &lt;done&gt;
 1881     emit_opcode(cbuf, 0x74);
 1882     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1883 
 1884     // &lt;normal&gt;
 1885     // cltd
 1886     emit_opcode(cbuf, 0x99);
 1887 
 1888     // idivl (note: must be emitted by the user of this rule)
 1889     // &lt;done&gt;
 1890   %}
 1891 
 1892   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1893   %{
 1894     // Full implementation of Java ldiv and lrem; checks for
 1895     // special case as described in JVM spec., p.243 &amp; p.271.
 1896     //
 1897     //         normal case                           special case
 1898     //
 1899     // input : rax: dividend                         min_long
 1900     //         reg: divisor                          -1
 1901     //
 1902     // output: rax: quotient  (= rax idiv reg)       min_long
 1903     //         rdx: remainder (= rax irem reg)       0
 1904     //
 1905     //  Code sequnce:
 1906     //
 1907     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1908     //    7:   00 00 80
 1909     //    a:   48 39 d0                cmp    %rdx,%rax
 1910     //    d:   75 08                   jne    17 &lt;normal&gt;
 1911     //    f:   33 d2                   xor    %edx,%edx
 1912     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1913     //   15:   74 05                   je     1c &lt;done&gt;
 1914     // 0000000000000017 &lt;normal&gt;:
 1915     //   17:   48 99                   cqto
 1916     //   19:   48 f7 f9                idiv   $div
 1917     // 000000000000001c &lt;done&gt;:
 1918 
 1919     // mov    $0x8000000000000000,%rdx
 1920     emit_opcode(cbuf, Assembler::REX_W);
 1921     emit_opcode(cbuf, 0xBA);
 1922     emit_d8(cbuf, 0x00);
 1923     emit_d8(cbuf, 0x00);
 1924     emit_d8(cbuf, 0x00);
 1925     emit_d8(cbuf, 0x00);
 1926     emit_d8(cbuf, 0x00);
 1927     emit_d8(cbuf, 0x00);
 1928     emit_d8(cbuf, 0x00);
 1929     emit_d8(cbuf, 0x80);
 1930 
 1931     // cmp    %rdx,%rax
 1932     emit_opcode(cbuf, Assembler::REX_W);
 1933     emit_opcode(cbuf, 0x39);
 1934     emit_d8(cbuf, 0xD0);
 1935 
 1936     // jne    17 &lt;normal&gt;
 1937     emit_opcode(cbuf, 0x75);
 1938     emit_d8(cbuf, 0x08);
 1939 
 1940     // xor    %edx,%edx
 1941     emit_opcode(cbuf, 0x33);
 1942     emit_d8(cbuf, 0xD2);
 1943 
 1944     // cmp    $0xffffffffffffffff,$div
 1945     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1946     emit_opcode(cbuf, 0x83);
 1947     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1948     emit_d8(cbuf, 0xFF);
 1949 
 1950     // je     1e &lt;done&gt;
 1951     emit_opcode(cbuf, 0x74);
 1952     emit_d8(cbuf, 0x05);
 1953 
 1954     // &lt;normal&gt;
 1955     // cqto
 1956     emit_opcode(cbuf, Assembler::REX_W);
 1957     emit_opcode(cbuf, 0x99);
 1958 
 1959     // idivq (note: must be emitted by the user of this rule)
 1960     // &lt;done&gt;
 1961   %}
 1962 
 1963   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1964   enc_class OpcSE(immI imm)
 1965   %{
 1966     // Emit primary opcode and set sign-extend bit
 1967     // Check for 8-bit immediate, and set sign extend bit in opcode
 1968     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1969       emit_opcode(cbuf, $primary | 0x02);
 1970     } else {
 1971       // 32-bit immediate
 1972       emit_opcode(cbuf, $primary);
 1973     }
 1974   %}
 1975 
 1976   enc_class OpcSErm(rRegI dst, immI imm)
 1977   %{
 1978     // OpcSEr/m
 1979     int dstenc = $dst$$reg;
 1980     if (dstenc &gt;= 8) {
 1981       emit_opcode(cbuf, Assembler::REX_B);
 1982       dstenc -= 8;
 1983     }
 1984     // Emit primary opcode and set sign-extend bit
 1985     // Check for 8-bit immediate, and set sign extend bit in opcode
 1986     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1987       emit_opcode(cbuf, $primary | 0x02);
 1988     } else {
 1989       // 32-bit immediate
 1990       emit_opcode(cbuf, $primary);
 1991     }
 1992     // Emit r/m byte with secondary opcode, after primary opcode.
 1993     emit_rm(cbuf, 0x3, $secondary, dstenc);
 1994   %}
 1995 
 1996   enc_class OpcSErm_wide(rRegL dst, immI imm)
 1997   %{
 1998     // OpcSEr/m
 1999     int dstenc = $dst$$reg;
 2000     if (dstenc &lt; 8) {
 2001       emit_opcode(cbuf, Assembler::REX_W);
 2002     } else {
 2003       emit_opcode(cbuf, Assembler::REX_WB);
 2004       dstenc -= 8;
 2005     }
 2006     // Emit primary opcode and set sign-extend bit
 2007     // Check for 8-bit immediate, and set sign extend bit in opcode
 2008     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2009       emit_opcode(cbuf, $primary | 0x02);
 2010     } else {
 2011       // 32-bit immediate
 2012       emit_opcode(cbuf, $primary);
 2013     }
 2014     // Emit r/m byte with secondary opcode, after primary opcode.
 2015     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2016   %}
 2017 
 2018   enc_class Con8or32(immI imm)
 2019   %{
 2020     // Check for 8-bit immediate, and set sign extend bit in opcode
 2021     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2022       $$$emit8$imm$$constant;
 2023     } else {
 2024       // 32-bit immediate
 2025       $$$emit32$imm$$constant;
 2026     }
 2027   %}
 2028 
 2029   enc_class opc2_reg(rRegI dst)
 2030   %{
 2031     // BSWAP
 2032     emit_cc(cbuf, $secondary, $dst$$reg);
 2033   %}
 2034 
 2035   enc_class opc3_reg(rRegI dst)
 2036   %{
 2037     // BSWAP
 2038     emit_cc(cbuf, $tertiary, $dst$$reg);
 2039   %}
 2040 
 2041   enc_class reg_opc(rRegI div)
 2042   %{
 2043     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2044     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2045   %}
 2046 
 2047   enc_class enc_cmov(cmpOp cop)
 2048   %{
 2049     // CMOV
 2050     $$$emit8$primary;
 2051     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2052   %}
 2053 
 2054   enc_class enc_PartialSubtypeCheck()
 2055   %{
 2056     Register Rrdi = as_Register(RDI_enc); // result register
 2057     Register Rrax = as_Register(RAX_enc); // super class
 2058     Register Rrcx = as_Register(RCX_enc); // killed
 2059     Register Rrsi = as_Register(RSI_enc); // sub class
 2060     Label miss;
 2061     const bool set_cond_codes = true;
 2062 
 2063     MacroAssembler _masm(&amp;cbuf);
 2064     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2065                                      NULL, &amp;miss,
 2066                                      /*set_cond_codes:*/ true);
 2067     if ($primary) {
 2068       __ xorptr(Rrdi, Rrdi);
 2069     }
 2070     __ bind(miss);
 2071   %}
 2072 
 2073   enc_class clear_avx %{
 2074     debug_only(int off0 = cbuf.insts_size());
 2075     if (generate_vzeroupper(Compile::current())) {
 2076       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2077       // Clear upper bits of YMM registers when current compiled code uses
 2078       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2079       MacroAssembler _masm(&amp;cbuf);
 2080       __ vzeroupper();
 2081     }
 2082     debug_only(int off1 = cbuf.insts_size());
 2083     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2084   %}
 2085 
 2086   enc_class Java_To_Runtime(method meth) %{
 2087     // No relocation needed
 2088     MacroAssembler _masm(&amp;cbuf);
 2089     __ mov64(r10, (int64_t) $meth$$method);
 2090     __ call(r10);
 2091   %}
 2092 
 2093   enc_class Java_To_Interpreter(method meth)
 2094   %{
 2095     // CALL Java_To_Interpreter
 2096     // This is the instruction starting address for relocation info.
 2097     cbuf.set_insts_mark();
 2098     $$$emit8$primary;
 2099     // CALL directly to the runtime
 2100     emit_d32_reloc(cbuf,
 2101                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2102                    runtime_call_Relocation::spec(),
 2103                    RELOC_DISP32);
 2104   %}
 2105 
 2106   enc_class Java_Static_Call(method meth)
 2107   %{
 2108     // JAVA STATIC CALL
 2109     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2110     // determine who we intended to call.
 2111     cbuf.set_insts_mark();
 2112     $$$emit8$primary;
 2113 
 2114     if (!_method) {
 2115       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2116                      runtime_call_Relocation::spec(),
 2117                      RELOC_DISP32);
 2118     } else {
 2119       int method_index = resolved_method_index(cbuf);
 2120       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2121                                                   : static_call_Relocation::spec(method_index);
 2122       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2123                      rspec, RELOC_DISP32);
 2124       // Emit stubs for static call.
 2125       address mark = cbuf.insts_mark();
 2126       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2127       if (stub == NULL) {
 2128         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2129         return;
 2130       }
 2131 #if INCLUDE_AOT
 2132       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2133 #endif
 2134     }
 2135   %}
 2136 
 2137   enc_class Java_Dynamic_Call(method meth) %{
 2138     MacroAssembler _masm(&amp;cbuf);
 2139     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2140   %}
 2141 
 2142   enc_class Java_Compiled_Call(method meth)
 2143   %{
 2144     // JAVA COMPILED CALL
 2145     int disp = in_bytes(Method:: from_compiled_offset());
 2146 
 2147     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2148     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2149 
 2150     // callq *disp(%rax)
 2151     cbuf.set_insts_mark();
 2152     $$$emit8$primary;
 2153     if (disp &lt; 0x80) {
 2154       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2155       emit_d8(cbuf, disp); // Displacement
 2156     } else {
 2157       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2158       emit_d32(cbuf, disp); // Displacement
 2159     }
 2160   %}
 2161 
 2162   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2163   %{
 2164     // SAL, SAR, SHR
 2165     int dstenc = $dst$$reg;
 2166     if (dstenc &gt;= 8) {
 2167       emit_opcode(cbuf, Assembler::REX_B);
 2168       dstenc -= 8;
 2169     }
 2170     $$$emit8$primary;
 2171     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2172     $$$emit8$shift$$constant;
 2173   %}
 2174 
 2175   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2176   %{
 2177     // SAL, SAR, SHR
 2178     int dstenc = $dst$$reg;
 2179     if (dstenc &lt; 8) {
 2180       emit_opcode(cbuf, Assembler::REX_W);
 2181     } else {
 2182       emit_opcode(cbuf, Assembler::REX_WB);
 2183       dstenc -= 8;
 2184     }
 2185     $$$emit8$primary;
 2186     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2187     $$$emit8$shift$$constant;
 2188   %}
 2189 
 2190   enc_class load_immI(rRegI dst, immI src)
 2191   %{
 2192     int dstenc = $dst$$reg;
 2193     if (dstenc &gt;= 8) {
 2194       emit_opcode(cbuf, Assembler::REX_B);
 2195       dstenc -= 8;
 2196     }
 2197     emit_opcode(cbuf, 0xB8 | dstenc);
 2198     $$$emit32$src$$constant;
 2199   %}
 2200 
 2201   enc_class load_immL(rRegL dst, immL src)
 2202   %{
 2203     int dstenc = $dst$$reg;
 2204     if (dstenc &lt; 8) {
 2205       emit_opcode(cbuf, Assembler::REX_W);
 2206     } else {
 2207       emit_opcode(cbuf, Assembler::REX_WB);
 2208       dstenc -= 8;
 2209     }
 2210     emit_opcode(cbuf, 0xB8 | dstenc);
 2211     emit_d64(cbuf, $src$$constant);
 2212   %}
 2213 
 2214   enc_class load_immUL32(rRegL dst, immUL32 src)
 2215   %{
 2216     // same as load_immI, but this time we care about zeroes in the high word
 2217     int dstenc = $dst$$reg;
 2218     if (dstenc &gt;= 8) {
 2219       emit_opcode(cbuf, Assembler::REX_B);
 2220       dstenc -= 8;
 2221     }
 2222     emit_opcode(cbuf, 0xB8 | dstenc);
 2223     $$$emit32$src$$constant;
 2224   %}
 2225 
 2226   enc_class load_immL32(rRegL dst, immL32 src)
 2227   %{
 2228     int dstenc = $dst$$reg;
 2229     if (dstenc &lt; 8) {
 2230       emit_opcode(cbuf, Assembler::REX_W);
 2231     } else {
 2232       emit_opcode(cbuf, Assembler::REX_WB);
 2233       dstenc -= 8;
 2234     }
 2235     emit_opcode(cbuf, 0xC7);
 2236     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2237     $$$emit32$src$$constant;
 2238   %}
 2239 
 2240   enc_class load_immP31(rRegP dst, immP32 src)
 2241   %{
 2242     // same as load_immI, but this time we care about zeroes in the high word
 2243     int dstenc = $dst$$reg;
 2244     if (dstenc &gt;= 8) {
 2245       emit_opcode(cbuf, Assembler::REX_B);
 2246       dstenc -= 8;
 2247     }
 2248     emit_opcode(cbuf, 0xB8 | dstenc);
 2249     $$$emit32$src$$constant;
 2250   %}
 2251 
 2252   enc_class load_immP(rRegP dst, immP src)
 2253   %{
 2254     int dstenc = $dst$$reg;
 2255     if (dstenc &lt; 8) {
 2256       emit_opcode(cbuf, Assembler::REX_W);
 2257     } else {
 2258       emit_opcode(cbuf, Assembler::REX_WB);
 2259       dstenc -= 8;
 2260     }
 2261     emit_opcode(cbuf, 0xB8 | dstenc);
 2262     // This next line should be generated from ADLC
 2263     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2264       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2265     } else {
 2266       emit_d64(cbuf, $src$$constant);
 2267     }
 2268   %}
 2269 
 2270   enc_class Con32(immI src)
 2271   %{
 2272     // Output immediate
 2273     $$$emit32$src$$constant;
 2274   %}
 2275 
 2276   enc_class Con32F_as_bits(immF src)
 2277   %{
 2278     // Output Float immediate bits
 2279     jfloat jf = $src$$constant;
 2280     jint jf_as_bits = jint_cast(jf);
 2281     emit_d32(cbuf, jf_as_bits);
 2282   %}
 2283 
 2284   enc_class Con16(immI src)
 2285   %{
 2286     // Output immediate
 2287     $$$emit16$src$$constant;
 2288   %}
 2289 
 2290   // How is this different from Con32??? XXX
 2291   enc_class Con_d32(immI src)
 2292   %{
 2293     emit_d32(cbuf,$src$$constant);
 2294   %}
 2295 
 2296   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2297     // Output immediate memory reference
 2298     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2299     emit_d32(cbuf, 0x00);
 2300   %}
 2301 
 2302   enc_class lock_prefix()
 2303   %{
 2304     emit_opcode(cbuf, 0xF0); // lock
 2305   %}
 2306 
 2307   enc_class REX_mem(memory mem)
 2308   %{
 2309     if ($mem$$base &gt;= 8) {
 2310       if ($mem$$index &lt; 8) {
 2311         emit_opcode(cbuf, Assembler::REX_B);
 2312       } else {
 2313         emit_opcode(cbuf, Assembler::REX_XB);
 2314       }
 2315     } else {
 2316       if ($mem$$index &gt;= 8) {
 2317         emit_opcode(cbuf, Assembler::REX_X);
 2318       }
 2319     }
 2320   %}
 2321 
 2322   enc_class REX_mem_wide(memory mem)
 2323   %{
 2324     if ($mem$$base &gt;= 8) {
 2325       if ($mem$$index &lt; 8) {
 2326         emit_opcode(cbuf, Assembler::REX_WB);
 2327       } else {
 2328         emit_opcode(cbuf, Assembler::REX_WXB);
 2329       }
 2330     } else {
 2331       if ($mem$$index &lt; 8) {
 2332         emit_opcode(cbuf, Assembler::REX_W);
 2333       } else {
 2334         emit_opcode(cbuf, Assembler::REX_WX);
 2335       }
 2336     }
 2337   %}
 2338 
 2339   // for byte regs
 2340   enc_class REX_breg(rRegI reg)
 2341   %{
 2342     if ($reg$$reg &gt;= 4) {
 2343       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2344     }
 2345   %}
 2346 
 2347   // for byte regs
 2348   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2349   %{
 2350     if ($dst$$reg &lt; 8) {
 2351       if ($src$$reg &gt;= 4) {
 2352         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2353       }
 2354     } else {
 2355       if ($src$$reg &lt; 8) {
 2356         emit_opcode(cbuf, Assembler::REX_R);
 2357       } else {
 2358         emit_opcode(cbuf, Assembler::REX_RB);
 2359       }
 2360     }
 2361   %}
 2362 
 2363   // for byte regs
 2364   enc_class REX_breg_mem(rRegI reg, memory mem)
 2365   %{
 2366     if ($reg$$reg &lt; 8) {
 2367       if ($mem$$base &lt; 8) {
 2368         if ($mem$$index &gt;= 8) {
 2369           emit_opcode(cbuf, Assembler::REX_X);
 2370         } else if ($reg$$reg &gt;= 4) {
 2371           emit_opcode(cbuf, Assembler::REX);
 2372         }
 2373       } else {
 2374         if ($mem$$index &lt; 8) {
 2375           emit_opcode(cbuf, Assembler::REX_B);
 2376         } else {
 2377           emit_opcode(cbuf, Assembler::REX_XB);
 2378         }
 2379       }
 2380     } else {
 2381       if ($mem$$base &lt; 8) {
 2382         if ($mem$$index &lt; 8) {
 2383           emit_opcode(cbuf, Assembler::REX_R);
 2384         } else {
 2385           emit_opcode(cbuf, Assembler::REX_RX);
 2386         }
 2387       } else {
 2388         if ($mem$$index &lt; 8) {
 2389           emit_opcode(cbuf, Assembler::REX_RB);
 2390         } else {
 2391           emit_opcode(cbuf, Assembler::REX_RXB);
 2392         }
 2393       }
 2394     }
 2395   %}
 2396 
 2397   enc_class REX_reg(rRegI reg)
 2398   %{
 2399     if ($reg$$reg &gt;= 8) {
 2400       emit_opcode(cbuf, Assembler::REX_B);
 2401     }
 2402   %}
 2403 
 2404   enc_class REX_reg_wide(rRegI reg)
 2405   %{
 2406     if ($reg$$reg &lt; 8) {
 2407       emit_opcode(cbuf, Assembler::REX_W);
 2408     } else {
 2409       emit_opcode(cbuf, Assembler::REX_WB);
 2410     }
 2411   %}
 2412 
 2413   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2414   %{
 2415     if ($dst$$reg &lt; 8) {
 2416       if ($src$$reg &gt;= 8) {
 2417         emit_opcode(cbuf, Assembler::REX_B);
 2418       }
 2419     } else {
 2420       if ($src$$reg &lt; 8) {
 2421         emit_opcode(cbuf, Assembler::REX_R);
 2422       } else {
 2423         emit_opcode(cbuf, Assembler::REX_RB);
 2424       }
 2425     }
 2426   %}
 2427 
 2428   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2429   %{
 2430     if ($dst$$reg &lt; 8) {
 2431       if ($src$$reg &lt; 8) {
 2432         emit_opcode(cbuf, Assembler::REX_W);
 2433       } else {
 2434         emit_opcode(cbuf, Assembler::REX_WB);
 2435       }
 2436     } else {
 2437       if ($src$$reg &lt; 8) {
 2438         emit_opcode(cbuf, Assembler::REX_WR);
 2439       } else {
 2440         emit_opcode(cbuf, Assembler::REX_WRB);
 2441       }
 2442     }
 2443   %}
 2444 
 2445   enc_class REX_reg_mem(rRegI reg, memory mem)
 2446   %{
 2447     if ($reg$$reg &lt; 8) {
 2448       if ($mem$$base &lt; 8) {
 2449         if ($mem$$index &gt;= 8) {
 2450           emit_opcode(cbuf, Assembler::REX_X);
 2451         }
 2452       } else {
 2453         if ($mem$$index &lt; 8) {
 2454           emit_opcode(cbuf, Assembler::REX_B);
 2455         } else {
 2456           emit_opcode(cbuf, Assembler::REX_XB);
 2457         }
 2458       }
 2459     } else {
 2460       if ($mem$$base &lt; 8) {
 2461         if ($mem$$index &lt; 8) {
 2462           emit_opcode(cbuf, Assembler::REX_R);
 2463         } else {
 2464           emit_opcode(cbuf, Assembler::REX_RX);
 2465         }
 2466       } else {
 2467         if ($mem$$index &lt; 8) {
 2468           emit_opcode(cbuf, Assembler::REX_RB);
 2469         } else {
 2470           emit_opcode(cbuf, Assembler::REX_RXB);
 2471         }
 2472       }
 2473     }
 2474   %}
 2475 
 2476   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2477   %{
 2478     if ($reg$$reg &lt; 8) {
 2479       if ($mem$$base &lt; 8) {
 2480         if ($mem$$index &lt; 8) {
 2481           emit_opcode(cbuf, Assembler::REX_W);
 2482         } else {
 2483           emit_opcode(cbuf, Assembler::REX_WX);
 2484         }
 2485       } else {
 2486         if ($mem$$index &lt; 8) {
 2487           emit_opcode(cbuf, Assembler::REX_WB);
 2488         } else {
 2489           emit_opcode(cbuf, Assembler::REX_WXB);
 2490         }
 2491       }
 2492     } else {
 2493       if ($mem$$base &lt; 8) {
 2494         if ($mem$$index &lt; 8) {
 2495           emit_opcode(cbuf, Assembler::REX_WR);
 2496         } else {
 2497           emit_opcode(cbuf, Assembler::REX_WRX);
 2498         }
 2499       } else {
 2500         if ($mem$$index &lt; 8) {
 2501           emit_opcode(cbuf, Assembler::REX_WRB);
 2502         } else {
 2503           emit_opcode(cbuf, Assembler::REX_WRXB);
 2504         }
 2505       }
 2506     }
 2507   %}
 2508 
 2509   enc_class reg_mem(rRegI ereg, memory mem)
 2510   %{
 2511     // High registers handle in encode_RegMem
 2512     int reg = $ereg$$reg;
 2513     int base = $mem$$base;
 2514     int index = $mem$$index;
 2515     int scale = $mem$$scale;
 2516     int disp = $mem$$disp;
 2517     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2518 
 2519     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2520   %}
 2521 
 2522   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2523   %{
 2524     int rm_byte_opcode = $rm_opcode$$constant;
 2525 
 2526     // High registers handle in encode_RegMem
 2527     int base = $mem$$base;
 2528     int index = $mem$$index;
 2529     int scale = $mem$$scale;
 2530     int displace = $mem$$disp;
 2531 
 2532     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2533                                             // working with static
 2534                                             // globals
 2535     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2536                   disp_reloc);
 2537   %}
 2538 
 2539   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2540   %{
 2541     int reg_encoding = $dst$$reg;
 2542     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2543     int index        = 0x04;            // 0x04 indicates no index
 2544     int scale        = 0x00;            // 0x00 indicates no scale
 2545     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2546     relocInfo::relocType disp_reloc = relocInfo::none;
 2547     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2548                   disp_reloc);
 2549   %}
 2550 
 2551   enc_class neg_reg(rRegI dst)
 2552   %{
 2553     int dstenc = $dst$$reg;
 2554     if (dstenc &gt;= 8) {
 2555       emit_opcode(cbuf, Assembler::REX_B);
 2556       dstenc -= 8;
 2557     }
 2558     // NEG $dst
 2559     emit_opcode(cbuf, 0xF7);
 2560     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2561   %}
 2562 
 2563   enc_class neg_reg_wide(rRegI dst)
 2564   %{
 2565     int dstenc = $dst$$reg;
 2566     if (dstenc &lt; 8) {
 2567       emit_opcode(cbuf, Assembler::REX_W);
 2568     } else {
 2569       emit_opcode(cbuf, Assembler::REX_WB);
 2570       dstenc -= 8;
 2571     }
 2572     // NEG $dst
 2573     emit_opcode(cbuf, 0xF7);
 2574     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2575   %}
 2576 
 2577   enc_class setLT_reg(rRegI dst)
 2578   %{
 2579     int dstenc = $dst$$reg;
 2580     if (dstenc &gt;= 8) {
 2581       emit_opcode(cbuf, Assembler::REX_B);
 2582       dstenc -= 8;
 2583     } else if (dstenc &gt;= 4) {
 2584       emit_opcode(cbuf, Assembler::REX);
 2585     }
 2586     // SETLT $dst
 2587     emit_opcode(cbuf, 0x0F);
 2588     emit_opcode(cbuf, 0x9C);
 2589     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2590   %}
 2591 
 2592   enc_class setNZ_reg(rRegI dst)
 2593   %{
 2594     int dstenc = $dst$$reg;
 2595     if (dstenc &gt;= 8) {
 2596       emit_opcode(cbuf, Assembler::REX_B);
 2597       dstenc -= 8;
 2598     } else if (dstenc &gt;= 4) {
 2599       emit_opcode(cbuf, Assembler::REX);
 2600     }
 2601     // SETNZ $dst
 2602     emit_opcode(cbuf, 0x0F);
 2603     emit_opcode(cbuf, 0x95);
 2604     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2605   %}
 2606 
 2607 
 2608   // Compare the lonogs and set -1, 0, or 1 into dst
 2609   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2610   %{
 2611     int src1enc = $src1$$reg;
 2612     int src2enc = $src2$$reg;
 2613     int dstenc = $dst$$reg;
 2614 
 2615     // cmpq $src1, $src2
 2616     if (src1enc &lt; 8) {
 2617       if (src2enc &lt; 8) {
 2618         emit_opcode(cbuf, Assembler::REX_W);
 2619       } else {
 2620         emit_opcode(cbuf, Assembler::REX_WB);
 2621       }
 2622     } else {
 2623       if (src2enc &lt; 8) {
 2624         emit_opcode(cbuf, Assembler::REX_WR);
 2625       } else {
 2626         emit_opcode(cbuf, Assembler::REX_WRB);
 2627       }
 2628     }
 2629     emit_opcode(cbuf, 0x3B);
 2630     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2631 
 2632     // movl $dst, -1
 2633     if (dstenc &gt;= 8) {
 2634       emit_opcode(cbuf, Assembler::REX_B);
 2635     }
 2636     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2637     emit_d32(cbuf, -1);
 2638 
 2639     // jl,s done
 2640     emit_opcode(cbuf, 0x7C);
 2641     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2642 
 2643     // setne $dst
 2644     if (dstenc &gt;= 4) {
 2645       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2646     }
 2647     emit_opcode(cbuf, 0x0F);
 2648     emit_opcode(cbuf, 0x95);
 2649     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2650 
 2651     // movzbl $dst, $dst
 2652     if (dstenc &gt;= 4) {
 2653       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2654     }
 2655     emit_opcode(cbuf, 0x0F);
 2656     emit_opcode(cbuf, 0xB6);
 2657     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2658   %}
 2659 
 2660   enc_class Push_ResultXD(regD dst) %{
 2661     MacroAssembler _masm(&amp;cbuf);
 2662     __ fstp_d(Address(rsp, 0));
 2663     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2664     __ addptr(rsp, 8);
 2665   %}
 2666 
 2667   enc_class Push_SrcXD(regD src) %{
 2668     MacroAssembler _masm(&amp;cbuf);
 2669     __ subptr(rsp, 8);
 2670     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2671     __ fld_d(Address(rsp, 0));
 2672   %}
 2673 
 2674 
 2675   enc_class enc_rethrow()
 2676   %{
 2677     cbuf.set_insts_mark();
 2678     emit_opcode(cbuf, 0xE9); // jmp entry
 2679     emit_d32_reloc(cbuf,
 2680                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2681                    runtime_call_Relocation::spec(),
 2682                    RELOC_DISP32);
 2683   %}
 2684 
 2685 %}
 2686 
 2687 
 2688 
 2689 //----------FRAME--------------------------------------------------------------
 2690 // Definition of frame structure and management information.
 2691 //
 2692 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2693 //                             |   (to get allocators register number
 2694 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2695 //  r   CALLER     |        |
 2696 //  o     |        +--------+      pad to even-align allocators stack-slot
 2697 //  w     V        |  pad0  |        numbers; owned by CALLER
 2698 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2699 //  h     ^        |   in   |  5
 2700 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2701 //  |     |        |        |  3
 2702 //  |     |        +--------+
 2703 //  V     |        | old out|      Empty on Intel, window on Sparc
 2704 //        |    old |preserve|      Must be even aligned.
 2705 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2706 //        |        |   in   |  3   area for Intel ret address
 2707 //     Owned by    |preserve|      Empty on Sparc.
 2708 //       SELF      +--------+
 2709 //        |        |  pad2  |  2   pad to align old SP
 2710 //        |        +--------+  1
 2711 //        |        | locks  |  0
 2712 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2713 //        |        |  pad1  | 11   pad to align new SP
 2714 //        |        +--------+
 2715 //        |        |        | 10
 2716 //        |        | spills |  9   spills
 2717 //        V        |        |  8   (pad0 slot for callee)
 2718 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2719 //        ^        |  out   |  7
 2720 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2721 //     Owned by    +--------+
 2722 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2723 //        |    new |preserve|      Must be even-aligned.
 2724 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2725 //        |        |        |
 2726 //
 2727 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2728 //         known from SELF&#39;s arguments and the Java calling convention.
 2729 //         Region 6-7 is determined per call site.
 2730 // Note 2: If the calling convention leaves holes in the incoming argument
 2731 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2732 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2733 //         incoming area, as the Java calling convention is completely under
 2734 //         the control of the AD file.  Doubles can be sorted and packed to
 2735 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2736 //         varargs C calling conventions.
 2737 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2738 //         even aligned with pad0 as needed.
 2739 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2740 //         region 6-11 is even aligned; it may be padded out more so that
 2741 //         the region from SP to FP meets the minimum stack alignment.
 2742 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2743 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2744 //         SP meets the minimum alignment.
 2745 
 2746 frame
 2747 %{
 2748   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2749   stack_direction(TOWARDS_LOW);
 2750 
 2751   // These three registers define part of the calling convention
 2752   // between compiled code and the interpreter.
 2753   inline_cache_reg(RAX);                // Inline Cache Register
 2754   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2755                                         // calling interpreter
 2756 
 2757   // Optional: name the operand used by cisc-spilling to access
 2758   // [stack_pointer + offset]
 2759   cisc_spilling_operand_name(indOffset32);
 2760 
 2761   // Number of stack slots consumed by locking an object
 2762   sync_stack_slots(2);
 2763 
 2764   // Compiled code&#39;s Frame Pointer
 2765   frame_pointer(RSP);
 2766 
 2767   // Interpreter stores its frame pointer in a register which is
 2768   // stored to the stack by I2CAdaptors.
 2769   // I2CAdaptors convert from interpreted java to compiled java.
 2770   interpreter_frame_pointer(RBP);
 2771 
 2772   // Stack alignment requirement
 2773   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2774 
 2775   // Number of stack slots between incoming argument block and the start of
 2776   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2777   // EPILOG must remove this many slots.  amd64 needs two slots for
 2778   // return address.
 2779   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2780 
 2781   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2782   // for calls to C.  Supports the var-args backing area for register parms.
 2783   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2784 
 2785   // The after-PROLOG location of the return address.  Location of
 2786   // return address specifies a type (REG or STACK) and a number
 2787   // representing the register number (i.e. - use a register name) or
 2788   // stack slot.
 2789   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2790   // Otherwise, it is above the locks and verification slot and alignment word
 2791   return_addr(STACK - 2 +
 2792               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2793                         Compile::current()-&gt;fixed_slots()),
 2794                        stack_alignment_in_slots()));
 2795 
 2796   // Body of function which returns an integer array locating
 2797   // arguments either in registers or in stack slots.  Passed an array
 2798   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2799   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2800   // arguments for a CALLEE.  Incoming stack arguments are
 2801   // automatically biased by the preserve_stack_slots field above.
 2802 
 2803   calling_convention
 2804   %{
 2805     // No difference between ingoing/outgoing just pass false
 2806     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2807   %}
 2808 
 2809   c_calling_convention
 2810   %{
 2811     // This is obviously always outgoing
 2812     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2813   %}
 2814 
 2815   // Location of compiled Java return values.  Same as C for now.
 2816   return_value
 2817   %{
 2818     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2819            &quot;only return normal values&quot;);
 2820 
 2821     static const int lo[Op_RegL + 1] = {
 2822       0,
 2823       0,
 2824       RAX_num,  // Op_RegN
 2825       RAX_num,  // Op_RegI
 2826       RAX_num,  // Op_RegP
 2827       XMM0_num, // Op_RegF
 2828       XMM0_num, // Op_RegD
 2829       RAX_num   // Op_RegL
 2830     };
 2831     static const int hi[Op_RegL + 1] = {
 2832       0,
 2833       0,
 2834       OptoReg::Bad, // Op_RegN
 2835       OptoReg::Bad, // Op_RegI
 2836       RAX_H_num,    // Op_RegP
 2837       OptoReg::Bad, // Op_RegF
 2838       XMM0b_num,    // Op_RegD
 2839       RAX_H_num     // Op_RegL
 2840     };
 2841     // Excluded flags and vector registers.
 2842     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2843     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2844   %}
 2845 %}
 2846 
 2847 //----------ATTRIBUTES---------------------------------------------------------
 2848 //----------Operand Attributes-------------------------------------------------
 2849 op_attrib op_cost(0);        // Required cost attribute
 2850 
 2851 //----------Instruction Attributes---------------------------------------------
 2852 ins_attrib ins_cost(100);       // Required cost attribute
 2853 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2854 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2855                                 // a non-matching short branch variant
 2856                                 // of some long branch?
 2857 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2858                                 // be a power of 2) specifies the
 2859                                 // alignment that some part of the
 2860                                 // instruction (not necessarily the
 2861                                 // start) requires.  If &gt; 1, a
 2862                                 // compute_padding() function must be
 2863                                 // provided for the instruction
 2864 
 2865 //----------OPERANDS-----------------------------------------------------------
 2866 // Operand definitions must precede instruction definitions for correct parsing
 2867 // in the ADLC because operands constitute user defined types which are used in
 2868 // instruction definitions.
 2869 
 2870 //----------Simple Operands----------------------------------------------------
 2871 // Immediate Operands
 2872 // Integer Immediate
 2873 operand immI()
 2874 %{
 2875   match(ConI);
 2876 
 2877   op_cost(10);
 2878   format %{ %}
 2879   interface(CONST_INTER);
 2880 %}
 2881 
 2882 // Constant for test vs zero
 2883 operand immI0()
 2884 %{
 2885   predicate(n-&gt;get_int() == 0);
 2886   match(ConI);
 2887 
 2888   op_cost(0);
 2889   format %{ %}
 2890   interface(CONST_INTER);
 2891 %}
 2892 
 2893 // Constant for increment
 2894 operand immI1()
 2895 %{
 2896   predicate(n-&gt;get_int() == 1);
 2897   match(ConI);
 2898 
 2899   op_cost(0);
 2900   format %{ %}
 2901   interface(CONST_INTER);
 2902 %}
 2903 
 2904 // Constant for decrement
 2905 operand immI_M1()
 2906 %{
 2907   predicate(n-&gt;get_int() == -1);
 2908   match(ConI);
 2909 
 2910   op_cost(0);
 2911   format %{ %}
 2912   interface(CONST_INTER);
 2913 %}
 2914 
 2915 // Valid scale values for addressing modes
 2916 operand immI2()
 2917 %{
 2918   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2919   match(ConI);
 2920 
 2921   format %{ %}
 2922   interface(CONST_INTER);
 2923 %}
 2924 
 2925 operand immI8()
 2926 %{
 2927   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2928   match(ConI);
 2929 
 2930   op_cost(5);
 2931   format %{ %}
 2932   interface(CONST_INTER);
 2933 %}
 2934 
 2935 operand immU8()
 2936 %{
 2937   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2938   match(ConI);
 2939 
 2940   op_cost(5);
 2941   format %{ %}
 2942   interface(CONST_INTER);
 2943 %}
 2944 
 2945 operand immI16()
 2946 %{
 2947   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2948   match(ConI);
 2949 
 2950   op_cost(10);
 2951   format %{ %}
 2952   interface(CONST_INTER);
 2953 %}
 2954 
 2955 // Int Immediate non-negative
 2956 operand immU31()
 2957 %{
 2958   predicate(n-&gt;get_int() &gt;= 0);
 2959   match(ConI);
 2960 
 2961   op_cost(0);
 2962   format %{ %}
 2963   interface(CONST_INTER);
 2964 %}
 2965 
 2966 // Constant for long shifts
 2967 operand immI_32()
 2968 %{
 2969   predicate( n-&gt;get_int() == 32 );
 2970   match(ConI);
 2971 
 2972   op_cost(0);
 2973   format %{ %}
 2974   interface(CONST_INTER);
 2975 %}
 2976 
 2977 // Constant for long shifts
 2978 operand immI_64()
 2979 %{
 2980   predicate( n-&gt;get_int() == 64 );
 2981   match(ConI);
 2982 
 2983   op_cost(0);
 2984   format %{ %}
 2985   interface(CONST_INTER);
 2986 %}
 2987 
 2988 // Pointer Immediate
 2989 operand immP()
 2990 %{
 2991   match(ConP);
 2992 
 2993   op_cost(10);
 2994   format %{ %}
 2995   interface(CONST_INTER);
 2996 %}
 2997 
 2998 // NULL Pointer Immediate
 2999 operand immP0()
 3000 %{
 3001   predicate(n-&gt;get_ptr() == 0);
 3002   match(ConP);
 3003 
 3004   op_cost(5);
 3005   format %{ %}
 3006   interface(CONST_INTER);
 3007 %}
 3008 
 3009 // Pointer Immediate
 3010 operand immN() %{
 3011   match(ConN);
 3012 
 3013   op_cost(10);
 3014   format %{ %}
 3015   interface(CONST_INTER);
 3016 %}
 3017 
 3018 operand immNKlass() %{
 3019   match(ConNKlass);
 3020 
 3021   op_cost(10);
 3022   format %{ %}
 3023   interface(CONST_INTER);
 3024 %}
 3025 
 3026 // NULL Pointer Immediate
 3027 operand immN0() %{
 3028   predicate(n-&gt;get_narrowcon() == 0);
 3029   match(ConN);
 3030 
 3031   op_cost(5);
 3032   format %{ %}
 3033   interface(CONST_INTER);
 3034 %}
 3035 
 3036 operand immP31()
 3037 %{
 3038   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3039             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3040   match(ConP);
 3041 
 3042   op_cost(5);
 3043   format %{ %}
 3044   interface(CONST_INTER);
 3045 %}
 3046 
 3047 
 3048 // Long Immediate
 3049 operand immL()
 3050 %{
 3051   match(ConL);
 3052 
 3053   op_cost(20);
 3054   format %{ %}
 3055   interface(CONST_INTER);
 3056 %}
 3057 
 3058 // Long Immediate 8-bit
 3059 operand immL8()
 3060 %{
 3061   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3062   match(ConL);
 3063 
 3064   op_cost(5);
 3065   format %{ %}
 3066   interface(CONST_INTER);
 3067 %}
 3068 
 3069 // Long Immediate 32-bit unsigned
 3070 operand immUL32()
 3071 %{
 3072   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3073   match(ConL);
 3074 
 3075   op_cost(10);
 3076   format %{ %}
 3077   interface(CONST_INTER);
 3078 %}
 3079 
 3080 // Long Immediate 32-bit signed
 3081 operand immL32()
 3082 %{
 3083   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3084   match(ConL);
 3085 
 3086   op_cost(15);
 3087   format %{ %}
 3088   interface(CONST_INTER);
 3089 %}
 3090 
 3091 operand immL_Pow2()
 3092 %{
 3093   predicate(is_power_of_2((julong)n-&gt;get_long()));
 3094   match(ConL);
 3095 
 3096   op_cost(15);
 3097   format %{ %}
 3098   interface(CONST_INTER);
 3099 %}
 3100 
 3101 operand immL_NotPow2()
 3102 %{
 3103   predicate(is_power_of_2((julong)~n-&gt;get_long()));
 3104   match(ConL);
 3105 
 3106   op_cost(15);
 3107   format %{ %}
 3108   interface(CONST_INTER);
 3109 %}
 3110 
 3111 // Long Immediate zero
 3112 operand immL0()
 3113 %{
 3114   predicate(n-&gt;get_long() == 0L);
 3115   match(ConL);
 3116 
 3117   op_cost(10);
 3118   format %{ %}
 3119   interface(CONST_INTER);
 3120 %}
 3121 
 3122 // Constant for increment
 3123 operand immL1()
 3124 %{
 3125   predicate(n-&gt;get_long() == 1);
 3126   match(ConL);
 3127 
 3128   format %{ %}
 3129   interface(CONST_INTER);
 3130 %}
 3131 
 3132 // Constant for decrement
 3133 operand immL_M1()
 3134 %{
 3135   predicate(n-&gt;get_long() == -1);
 3136   match(ConL);
 3137 
 3138   format %{ %}
 3139   interface(CONST_INTER);
 3140 %}
 3141 
 3142 // Long Immediate: the value 10
 3143 operand immL10()
 3144 %{
 3145   predicate(n-&gt;get_long() == 10);
 3146   match(ConL);
 3147 
 3148   format %{ %}
 3149   interface(CONST_INTER);
 3150 %}
 3151 
 3152 // Long immediate from 0 to 127.
 3153 // Used for a shorter form of long mul by 10.
 3154 operand immL_127()
 3155 %{
 3156   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3157   match(ConL);
 3158 
 3159   op_cost(10);
 3160   format %{ %}
 3161   interface(CONST_INTER);
 3162 %}
 3163 
 3164 // Long Immediate: low 32-bit mask
 3165 operand immL_32bits()
 3166 %{
 3167   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3168   match(ConL);
 3169   op_cost(20);
 3170 
 3171   format %{ %}
 3172   interface(CONST_INTER);
 3173 %}
 3174 
 3175 // Float Immediate zero
 3176 operand immF0()
 3177 %{
 3178   predicate(jint_cast(n-&gt;getf()) == 0);
 3179   match(ConF);
 3180 
 3181   op_cost(5);
 3182   format %{ %}
 3183   interface(CONST_INTER);
 3184 %}
 3185 
 3186 // Float Immediate
 3187 operand immF()
 3188 %{
 3189   match(ConF);
 3190 
 3191   op_cost(15);
 3192   format %{ %}
 3193   interface(CONST_INTER);
 3194 %}
 3195 
 3196 // Double Immediate zero
 3197 operand immD0()
 3198 %{
 3199   predicate(jlong_cast(n-&gt;getd()) == 0);
 3200   match(ConD);
 3201 
 3202   op_cost(5);
 3203   format %{ %}
 3204   interface(CONST_INTER);
 3205 %}
 3206 
 3207 // Double Immediate
 3208 operand immD()
 3209 %{
 3210   match(ConD);
 3211 
 3212   op_cost(15);
 3213   format %{ %}
 3214   interface(CONST_INTER);
 3215 %}
 3216 
 3217 // Immediates for special shifts (sign extend)
 3218 
 3219 // Constants for increment
 3220 operand immI_16()
 3221 %{
 3222   predicate(n-&gt;get_int() == 16);
 3223   match(ConI);
 3224 
 3225   format %{ %}
 3226   interface(CONST_INTER);
 3227 %}
 3228 
 3229 operand immI_24()
 3230 %{
 3231   predicate(n-&gt;get_int() == 24);
 3232   match(ConI);
 3233 
 3234   format %{ %}
 3235   interface(CONST_INTER);
 3236 %}
 3237 
 3238 // Constant for byte-wide masking
 3239 operand immI_255()
 3240 %{
 3241   predicate(n-&gt;get_int() == 255);
 3242   match(ConI);
 3243 
 3244   format %{ %}
 3245   interface(CONST_INTER);
 3246 %}
 3247 
 3248 // Constant for short-wide masking
 3249 operand immI_65535()
 3250 %{
 3251   predicate(n-&gt;get_int() == 65535);
 3252   match(ConI);
 3253 
 3254   format %{ %}
 3255   interface(CONST_INTER);
 3256 %}
 3257 
 3258 // Constant for byte-wide masking
 3259 operand immL_255()
 3260 %{
 3261   predicate(n-&gt;get_long() == 255);
 3262   match(ConL);
 3263 
 3264   format %{ %}
 3265   interface(CONST_INTER);
 3266 %}
 3267 
 3268 // Constant for short-wide masking
 3269 operand immL_65535()
 3270 %{
 3271   predicate(n-&gt;get_long() == 65535);
 3272   match(ConL);
 3273 
 3274   format %{ %}
 3275   interface(CONST_INTER);
 3276 %}
 3277 
 3278 // Register Operands
 3279 // Integer Register
 3280 operand rRegI()
 3281 %{
 3282   constraint(ALLOC_IN_RC(int_reg));
 3283   match(RegI);
 3284 
 3285   match(rax_RegI);
 3286   match(rbx_RegI);
 3287   match(rcx_RegI);
 3288   match(rdx_RegI);
 3289   match(rdi_RegI);
 3290 
 3291   format %{ %}
 3292   interface(REG_INTER);
 3293 %}
 3294 
 3295 // Special Registers
 3296 operand rax_RegI()
 3297 %{
 3298   constraint(ALLOC_IN_RC(int_rax_reg));
 3299   match(RegI);
 3300   match(rRegI);
 3301 
 3302   format %{ &quot;RAX&quot; %}
 3303   interface(REG_INTER);
 3304 %}
 3305 
 3306 // Special Registers
 3307 operand rbx_RegI()
 3308 %{
 3309   constraint(ALLOC_IN_RC(int_rbx_reg));
 3310   match(RegI);
 3311   match(rRegI);
 3312 
 3313   format %{ &quot;RBX&quot; %}
 3314   interface(REG_INTER);
 3315 %}
 3316 
 3317 operand rcx_RegI()
 3318 %{
 3319   constraint(ALLOC_IN_RC(int_rcx_reg));
 3320   match(RegI);
 3321   match(rRegI);
 3322 
 3323   format %{ &quot;RCX&quot; %}
 3324   interface(REG_INTER);
 3325 %}
 3326 
 3327 operand rdx_RegI()
 3328 %{
 3329   constraint(ALLOC_IN_RC(int_rdx_reg));
 3330   match(RegI);
 3331   match(rRegI);
 3332 
 3333   format %{ &quot;RDX&quot; %}
 3334   interface(REG_INTER);
 3335 %}
 3336 
 3337 operand rdi_RegI()
 3338 %{
 3339   constraint(ALLOC_IN_RC(int_rdi_reg));
 3340   match(RegI);
 3341   match(rRegI);
 3342 
 3343   format %{ &quot;RDI&quot; %}
 3344   interface(REG_INTER);
 3345 %}
 3346 
 3347 operand no_rcx_RegI()
 3348 %{
 3349   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3350   match(RegI);
 3351   match(rax_RegI);
 3352   match(rbx_RegI);
 3353   match(rdx_RegI);
 3354   match(rdi_RegI);
 3355 
 3356   format %{ %}
 3357   interface(REG_INTER);
 3358 %}
 3359 
 3360 operand no_rax_rdx_RegI()
 3361 %{
 3362   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3363   match(RegI);
 3364   match(rbx_RegI);
 3365   match(rcx_RegI);
 3366   match(rdi_RegI);
 3367 
 3368   format %{ %}
 3369   interface(REG_INTER);
 3370 %}
 3371 
 3372 // Pointer Register
 3373 operand any_RegP()
 3374 %{
 3375   constraint(ALLOC_IN_RC(any_reg));
 3376   match(RegP);
 3377   match(rax_RegP);
 3378   match(rbx_RegP);
 3379   match(rdi_RegP);
 3380   match(rsi_RegP);
 3381   match(rbp_RegP);
 3382   match(r15_RegP);
 3383   match(rRegP);
 3384 
 3385   format %{ %}
 3386   interface(REG_INTER);
 3387 %}
 3388 
 3389 operand rRegP()
 3390 %{
 3391   constraint(ALLOC_IN_RC(ptr_reg));
 3392   match(RegP);
 3393   match(rax_RegP);
 3394   match(rbx_RegP);
 3395   match(rdi_RegP);
 3396   match(rsi_RegP);
 3397   match(rbp_RegP);  // See Q&amp;A below about
 3398   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3399 
 3400   format %{ %}
 3401   interface(REG_INTER);
 3402 %}
 3403 
 3404 operand rRegN() %{
 3405   constraint(ALLOC_IN_RC(int_reg));
 3406   match(RegN);
 3407 
 3408   format %{ %}
 3409   interface(REG_INTER);
 3410 %}
 3411 
 3412 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3413 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3414 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3415 // The output of an instruction is controlled by the allocator, which respects
 3416 // register class masks, not match rules.  Unless an instruction mentions
 3417 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3418 // by the allocator as an input.
 3419 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3420 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3421 // result, RBP is not included in the output of the instruction either.
 3422 
 3423 operand no_rax_RegP()
 3424 %{
 3425   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3426   match(RegP);
 3427   match(rbx_RegP);
 3428   match(rsi_RegP);
 3429   match(rdi_RegP);
 3430 
 3431   format %{ %}
 3432   interface(REG_INTER);
 3433 %}
 3434 
 3435 // This operand is not allowed to use RBP even if
 3436 // RBP is not used to hold the frame pointer.
 3437 operand no_rbp_RegP()
 3438 %{
 3439   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3440   match(RegP);
 3441   match(rbx_RegP);
 3442   match(rsi_RegP);
 3443   match(rdi_RegP);
 3444 
 3445   format %{ %}
 3446   interface(REG_INTER);
 3447 %}
 3448 
 3449 operand no_rax_rbx_RegP()
 3450 %{
 3451   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3452   match(RegP);
 3453   match(rsi_RegP);
 3454   match(rdi_RegP);
 3455 
 3456   format %{ %}
 3457   interface(REG_INTER);
 3458 %}
 3459 
 3460 // Special Registers
 3461 // Return a pointer value
 3462 operand rax_RegP()
 3463 %{
 3464   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3465   match(RegP);
 3466   match(rRegP);
 3467 
 3468   format %{ %}
 3469   interface(REG_INTER);
 3470 %}
 3471 
 3472 // Special Registers
 3473 // Return a compressed pointer value
 3474 operand rax_RegN()
 3475 %{
 3476   constraint(ALLOC_IN_RC(int_rax_reg));
 3477   match(RegN);
 3478   match(rRegN);
 3479 
 3480   format %{ %}
 3481   interface(REG_INTER);
 3482 %}
 3483 
 3484 // Used in AtomicAdd
 3485 operand rbx_RegP()
 3486 %{
 3487   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3488   match(RegP);
 3489   match(rRegP);
 3490 
 3491   format %{ %}
 3492   interface(REG_INTER);
 3493 %}
 3494 
 3495 operand rsi_RegP()
 3496 %{
 3497   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3498   match(RegP);
 3499   match(rRegP);
 3500 
 3501   format %{ %}
 3502   interface(REG_INTER);
 3503 %}
 3504 
 3505 operand rbp_RegP()
 3506 %{
 3507   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3508   match(RegP);
 3509   match(rRegP);
 3510 
 3511   format %{ %}
 3512   interface(REG_INTER);
 3513 %}
 3514 
 3515 // Used in rep stosq
 3516 operand rdi_RegP()
 3517 %{
 3518   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3519   match(RegP);
 3520   match(rRegP);
 3521 
 3522   format %{ %}
 3523   interface(REG_INTER);
 3524 %}
 3525 
 3526 operand r15_RegP()
 3527 %{
 3528   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3529   match(RegP);
 3530   match(rRegP);
 3531 
 3532   format %{ %}
 3533   interface(REG_INTER);
 3534 %}
 3535 
 3536 operand rRegL()
 3537 %{
 3538   constraint(ALLOC_IN_RC(long_reg));
 3539   match(RegL);
 3540   match(rax_RegL);
 3541   match(rdx_RegL);
 3542 
 3543   format %{ %}
 3544   interface(REG_INTER);
 3545 %}
 3546 
 3547 // Special Registers
 3548 operand no_rax_rdx_RegL()
 3549 %{
 3550   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3551   match(RegL);
 3552   match(rRegL);
 3553 
 3554   format %{ %}
 3555   interface(REG_INTER);
 3556 %}
 3557 
 3558 operand no_rax_RegL()
 3559 %{
 3560   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3561   match(RegL);
 3562   match(rRegL);
 3563   match(rdx_RegL);
 3564 
 3565   format %{ %}
 3566   interface(REG_INTER);
 3567 %}
 3568 
 3569 operand no_rcx_RegL()
 3570 %{
 3571   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3572   match(RegL);
 3573   match(rRegL);
 3574 
 3575   format %{ %}
 3576   interface(REG_INTER);
 3577 %}
 3578 
 3579 operand rax_RegL()
 3580 %{
 3581   constraint(ALLOC_IN_RC(long_rax_reg));
 3582   match(RegL);
 3583   match(rRegL);
 3584 
 3585   format %{ &quot;RAX&quot; %}
 3586   interface(REG_INTER);
 3587 %}
 3588 
 3589 operand rcx_RegL()
 3590 %{
 3591   constraint(ALLOC_IN_RC(long_rcx_reg));
 3592   match(RegL);
 3593   match(rRegL);
 3594 
 3595   format %{ %}
 3596   interface(REG_INTER);
 3597 %}
 3598 
 3599 operand rdx_RegL()
 3600 %{
 3601   constraint(ALLOC_IN_RC(long_rdx_reg));
 3602   match(RegL);
 3603   match(rRegL);
 3604 
 3605   format %{ %}
 3606   interface(REG_INTER);
 3607 %}
 3608 
 3609 // Flags register, used as output of compare instructions
 3610 operand rFlagsReg()
 3611 %{
 3612   constraint(ALLOC_IN_RC(int_flags));
 3613   match(RegFlags);
 3614 
 3615   format %{ &quot;RFLAGS&quot; %}
 3616   interface(REG_INTER);
 3617 %}
 3618 
 3619 // Flags register, used as output of FLOATING POINT compare instructions
 3620 operand rFlagsRegU()
 3621 %{
 3622   constraint(ALLOC_IN_RC(int_flags));
 3623   match(RegFlags);
 3624 
 3625   format %{ &quot;RFLAGS_U&quot; %}
 3626   interface(REG_INTER);
 3627 %}
 3628 
 3629 operand rFlagsRegUCF() %{
 3630   constraint(ALLOC_IN_RC(int_flags));
 3631   match(RegFlags);
 3632   predicate(false);
 3633 
 3634   format %{ &quot;RFLAGS_U_CF&quot; %}
 3635   interface(REG_INTER);
 3636 %}
 3637 
 3638 // Float register operands
 3639 operand regF() %{
 3640    constraint(ALLOC_IN_RC(float_reg));
 3641    match(RegF);
 3642 
 3643    format %{ %}
 3644    interface(REG_INTER);
 3645 %}
 3646 
 3647 // Float register operands
 3648 operand legRegF() %{
 3649    constraint(ALLOC_IN_RC(float_reg_legacy));
 3650    match(RegF);
 3651 
 3652    format %{ %}
 3653    interface(REG_INTER);
 3654 %}
 3655 
 3656 // Float register operands
 3657 operand vlRegF() %{
 3658    constraint(ALLOC_IN_RC(float_reg_vl));
 3659    match(RegF);
 3660 
 3661    format %{ %}
 3662    interface(REG_INTER);
 3663 %}
 3664 
 3665 // Double register operands
 3666 operand regD() %{
 3667    constraint(ALLOC_IN_RC(double_reg));
 3668    match(RegD);
 3669 
 3670    format %{ %}
 3671    interface(REG_INTER);
 3672 %}
 3673 
 3674 // Double register operands
 3675 operand legRegD() %{
 3676    constraint(ALLOC_IN_RC(double_reg_legacy));
 3677    match(RegD);
 3678 
 3679    format %{ %}
 3680    interface(REG_INTER);
 3681 %}
 3682 
 3683 // Double register operands
 3684 operand vlRegD() %{
 3685    constraint(ALLOC_IN_RC(double_reg_vl));
 3686    match(RegD);
 3687 
 3688    format %{ %}
 3689    interface(REG_INTER);
 3690 %}
 3691 
 3692 //----------Memory Operands----------------------------------------------------
 3693 // Direct Memory Operand
 3694 // operand direct(immP addr)
 3695 // %{
 3696 //   match(addr);
 3697 
 3698 //   format %{ &quot;[$addr]&quot; %}
 3699 //   interface(MEMORY_INTER) %{
 3700 //     base(0xFFFFFFFF);
 3701 //     index(0x4);
 3702 //     scale(0x0);
 3703 //     disp($addr);
 3704 //   %}
 3705 // %}
 3706 
 3707 // Indirect Memory Operand
 3708 operand indirect(any_RegP reg)
 3709 %{
 3710   constraint(ALLOC_IN_RC(ptr_reg));
 3711   match(reg);
 3712 
 3713   format %{ &quot;[$reg]&quot; %}
 3714   interface(MEMORY_INTER) %{
 3715     base($reg);
 3716     index(0x4);
 3717     scale(0x0);
 3718     disp(0x0);
 3719   %}
 3720 %}
 3721 
 3722 // Indirect Memory Plus Short Offset Operand
 3723 operand indOffset8(any_RegP reg, immL8 off)
 3724 %{
 3725   constraint(ALLOC_IN_RC(ptr_reg));
 3726   match(AddP reg off);
 3727 
 3728   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3729   interface(MEMORY_INTER) %{
 3730     base($reg);
 3731     index(0x4);
 3732     scale(0x0);
 3733     disp($off);
 3734   %}
 3735 %}
 3736 
 3737 // Indirect Memory Plus Long Offset Operand
 3738 operand indOffset32(any_RegP reg, immL32 off)
 3739 %{
 3740   constraint(ALLOC_IN_RC(ptr_reg));
 3741   match(AddP reg off);
 3742 
 3743   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3744   interface(MEMORY_INTER) %{
 3745     base($reg);
 3746     index(0x4);
 3747     scale(0x0);
 3748     disp($off);
 3749   %}
 3750 %}
 3751 
 3752 // Indirect Memory Plus Index Register Plus Offset Operand
 3753 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3754 %{
 3755   constraint(ALLOC_IN_RC(ptr_reg));
 3756   match(AddP (AddP reg lreg) off);
 3757 
 3758   op_cost(10);
 3759   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3760   interface(MEMORY_INTER) %{
 3761     base($reg);
 3762     index($lreg);
 3763     scale(0x0);
 3764     disp($off);
 3765   %}
 3766 %}
 3767 
 3768 // Indirect Memory Plus Index Register Plus Offset Operand
 3769 operand indIndex(any_RegP reg, rRegL lreg)
 3770 %{
 3771   constraint(ALLOC_IN_RC(ptr_reg));
 3772   match(AddP reg lreg);
 3773 
 3774   op_cost(10);
 3775   format %{&quot;[$reg + $lreg]&quot; %}
 3776   interface(MEMORY_INTER) %{
 3777     base($reg);
 3778     index($lreg);
 3779     scale(0x0);
 3780     disp(0x0);
 3781   %}
 3782 %}
 3783 
 3784 // Indirect Memory Times Scale Plus Index Register
 3785 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3786 %{
 3787   constraint(ALLOC_IN_RC(ptr_reg));
 3788   match(AddP reg (LShiftL lreg scale));
 3789 
 3790   op_cost(10);
 3791   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3792   interface(MEMORY_INTER) %{
 3793     base($reg);
 3794     index($lreg);
 3795     scale($scale);
 3796     disp(0x0);
 3797   %}
 3798 %}
 3799 
 3800 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3801 %{
 3802   constraint(ALLOC_IN_RC(ptr_reg));
 3803   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3804   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3805 
 3806   op_cost(10);
 3807   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3808   interface(MEMORY_INTER) %{
 3809     base($reg);
 3810     index($idx);
 3811     scale($scale);
 3812     disp(0x0);
 3813   %}
 3814 %}
 3815 
 3816 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3817 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3818 %{
 3819   constraint(ALLOC_IN_RC(ptr_reg));
 3820   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3821 
 3822   op_cost(10);
 3823   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3824   interface(MEMORY_INTER) %{
 3825     base($reg);
 3826     index($lreg);
 3827     scale($scale);
 3828     disp($off);
 3829   %}
 3830 %}
 3831 
 3832 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3833 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3834 %{
 3835   constraint(ALLOC_IN_RC(ptr_reg));
 3836   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3837   match(AddP (AddP reg (ConvI2L idx)) off);
 3838 
 3839   op_cost(10);
 3840   format %{&quot;[$reg + $off + $idx]&quot; %}
 3841   interface(MEMORY_INTER) %{
 3842     base($reg);
 3843     index($idx);
 3844     scale(0x0);
 3845     disp($off);
 3846   %}
 3847 %}
 3848 
 3849 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3850 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3851 %{
 3852   constraint(ALLOC_IN_RC(ptr_reg));
 3853   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3854   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3855 
 3856   op_cost(10);
 3857   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3858   interface(MEMORY_INTER) %{
 3859     base($reg);
 3860     index($idx);
 3861     scale($scale);
 3862     disp($off);
 3863   %}
 3864 %}
 3865 
 3866 // Indirect Narrow Oop Plus Offset Operand
 3867 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3868 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3869 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3870   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3871   constraint(ALLOC_IN_RC(ptr_reg));
 3872   match(AddP (DecodeN reg) off);
 3873 
 3874   op_cost(10);
 3875   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3876   interface(MEMORY_INTER) %{
 3877     base(0xc); // R12
 3878     index($reg);
 3879     scale(0x3);
 3880     disp($off);
 3881   %}
 3882 %}
 3883 
 3884 // Indirect Memory Operand
 3885 operand indirectNarrow(rRegN reg)
 3886 %{
 3887   predicate(CompressedOops::shift() == 0);
 3888   constraint(ALLOC_IN_RC(ptr_reg));
 3889   match(DecodeN reg);
 3890 
 3891   format %{ &quot;[$reg]&quot; %}
 3892   interface(MEMORY_INTER) %{
 3893     base($reg);
 3894     index(0x4);
 3895     scale(0x0);
 3896     disp(0x0);
 3897   %}
 3898 %}
 3899 
 3900 // Indirect Memory Plus Short Offset Operand
 3901 operand indOffset8Narrow(rRegN reg, immL8 off)
 3902 %{
 3903   predicate(CompressedOops::shift() == 0);
 3904   constraint(ALLOC_IN_RC(ptr_reg));
 3905   match(AddP (DecodeN reg) off);
 3906 
 3907   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3908   interface(MEMORY_INTER) %{
 3909     base($reg);
 3910     index(0x4);
 3911     scale(0x0);
 3912     disp($off);
 3913   %}
 3914 %}
 3915 
 3916 // Indirect Memory Plus Long Offset Operand
 3917 operand indOffset32Narrow(rRegN reg, immL32 off)
 3918 %{
 3919   predicate(CompressedOops::shift() == 0);
 3920   constraint(ALLOC_IN_RC(ptr_reg));
 3921   match(AddP (DecodeN reg) off);
 3922 
 3923   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3924   interface(MEMORY_INTER) %{
 3925     base($reg);
 3926     index(0x4);
 3927     scale(0x0);
 3928     disp($off);
 3929   %}
 3930 %}
 3931 
 3932 // Indirect Memory Plus Index Register Plus Offset Operand
 3933 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3934 %{
 3935   predicate(CompressedOops::shift() == 0);
 3936   constraint(ALLOC_IN_RC(ptr_reg));
 3937   match(AddP (AddP (DecodeN reg) lreg) off);
 3938 
 3939   op_cost(10);
 3940   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3941   interface(MEMORY_INTER) %{
 3942     base($reg);
 3943     index($lreg);
 3944     scale(0x0);
 3945     disp($off);
 3946   %}
 3947 %}
 3948 
 3949 // Indirect Memory Plus Index Register Plus Offset Operand
 3950 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3951 %{
 3952   predicate(CompressedOops::shift() == 0);
 3953   constraint(ALLOC_IN_RC(ptr_reg));
 3954   match(AddP (DecodeN reg) lreg);
 3955 
 3956   op_cost(10);
 3957   format %{&quot;[$reg + $lreg]&quot; %}
 3958   interface(MEMORY_INTER) %{
 3959     base($reg);
 3960     index($lreg);
 3961     scale(0x0);
 3962     disp(0x0);
 3963   %}
 3964 %}
 3965 
 3966 // Indirect Memory Times Scale Plus Index Register
 3967 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3968 %{
 3969   predicate(CompressedOops::shift() == 0);
 3970   constraint(ALLOC_IN_RC(ptr_reg));
 3971   match(AddP (DecodeN reg) (LShiftL lreg scale));
 3972 
 3973   op_cost(10);
 3974   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3975   interface(MEMORY_INTER) %{
 3976     base($reg);
 3977     index($lreg);
 3978     scale($scale);
 3979     disp(0x0);
 3980   %}
 3981 %}
 3982 
 3983 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3984 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 3985 %{
 3986   predicate(CompressedOops::shift() == 0);
 3987   constraint(ALLOC_IN_RC(ptr_reg));
 3988   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 3989 
 3990   op_cost(10);
 3991   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3992   interface(MEMORY_INTER) %{
 3993     base($reg);
 3994     index($lreg);
 3995     scale($scale);
 3996     disp($off);
 3997   %}
 3998 %}
 3999 
 4000 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4001 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4002 %{
 4003   constraint(ALLOC_IN_RC(ptr_reg));
 4004   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4005   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4006 
 4007   op_cost(10);
 4008   format %{&quot;[$reg + $off + $idx]&quot; %}
 4009   interface(MEMORY_INTER) %{
 4010     base($reg);
 4011     index($idx);
 4012     scale(0x0);
 4013     disp($off);
 4014   %}
 4015 %}
 4016 
 4017 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4018 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4019 %{
 4020   constraint(ALLOC_IN_RC(ptr_reg));
 4021   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4022   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4023 
 4024   op_cost(10);
 4025   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4026   interface(MEMORY_INTER) %{
 4027     base($reg);
 4028     index($idx);
 4029     scale($scale);
 4030     disp($off);
 4031   %}
 4032 %}
 4033 
 4034 //----------Special Memory Operands--------------------------------------------
 4035 // Stack Slot Operand - This operand is used for loading and storing temporary
 4036 //                      values on the stack where a match requires a value to
 4037 //                      flow through memory.
 4038 operand stackSlotP(sRegP reg)
 4039 %{
 4040   constraint(ALLOC_IN_RC(stack_slots));
 4041   // No match rule because this operand is only generated in matching
 4042 
 4043   format %{ &quot;[$reg]&quot; %}
 4044   interface(MEMORY_INTER) %{
 4045     base(0x4);   // RSP
 4046     index(0x4);  // No Index
 4047     scale(0x0);  // No Scale
 4048     disp($reg);  // Stack Offset
 4049   %}
 4050 %}
 4051 
 4052 operand stackSlotI(sRegI reg)
 4053 %{
 4054   constraint(ALLOC_IN_RC(stack_slots));
 4055   // No match rule because this operand is only generated in matching
 4056 
 4057   format %{ &quot;[$reg]&quot; %}
 4058   interface(MEMORY_INTER) %{
 4059     base(0x4);   // RSP
 4060     index(0x4);  // No Index
 4061     scale(0x0);  // No Scale
 4062     disp($reg);  // Stack Offset
 4063   %}
 4064 %}
 4065 
 4066 operand stackSlotF(sRegF reg)
 4067 %{
 4068   constraint(ALLOC_IN_RC(stack_slots));
 4069   // No match rule because this operand is only generated in matching
 4070 
 4071   format %{ &quot;[$reg]&quot; %}
 4072   interface(MEMORY_INTER) %{
 4073     base(0x4);   // RSP
 4074     index(0x4);  // No Index
 4075     scale(0x0);  // No Scale
 4076     disp($reg);  // Stack Offset
 4077   %}
 4078 %}
 4079 
 4080 operand stackSlotD(sRegD reg)
 4081 %{
 4082   constraint(ALLOC_IN_RC(stack_slots));
 4083   // No match rule because this operand is only generated in matching
 4084 
 4085   format %{ &quot;[$reg]&quot; %}
 4086   interface(MEMORY_INTER) %{
 4087     base(0x4);   // RSP
 4088     index(0x4);  // No Index
 4089     scale(0x0);  // No Scale
 4090     disp($reg);  // Stack Offset
 4091   %}
 4092 %}
 4093 operand stackSlotL(sRegL reg)
 4094 %{
 4095   constraint(ALLOC_IN_RC(stack_slots));
 4096   // No match rule because this operand is only generated in matching
 4097 
 4098   format %{ &quot;[$reg]&quot; %}
 4099   interface(MEMORY_INTER) %{
 4100     base(0x4);   // RSP
 4101     index(0x4);  // No Index
 4102     scale(0x0);  // No Scale
 4103     disp($reg);  // Stack Offset
 4104   %}
 4105 %}
 4106 
 4107 //----------Conditional Branch Operands----------------------------------------
 4108 // Comparison Op  - This is the operation of the comparison, and is limited to
 4109 //                  the following set of codes:
 4110 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4111 //
 4112 // Other attributes of the comparison, such as unsignedness, are specified
 4113 // by the comparison instruction that sets a condition code flags register.
 4114 // That result is represented by a flags operand whose subtype is appropriate
 4115 // to the unsignedness (etc.) of the comparison.
 4116 //
 4117 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4118 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4119 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4120 
 4121 // Comparision Code
 4122 operand cmpOp()
 4123 %{
 4124   match(Bool);
 4125 
 4126   format %{ &quot;&quot; %}
 4127   interface(COND_INTER) %{
 4128     equal(0x4, &quot;e&quot;);
 4129     not_equal(0x5, &quot;ne&quot;);
 4130     less(0xC, &quot;l&quot;);
 4131     greater_equal(0xD, &quot;ge&quot;);
 4132     less_equal(0xE, &quot;le&quot;);
 4133     greater(0xF, &quot;g&quot;);
 4134     overflow(0x0, &quot;o&quot;);
 4135     no_overflow(0x1, &quot;no&quot;);
 4136   %}
 4137 %}
 4138 
 4139 // Comparison Code, unsigned compare.  Used by FP also, with
 4140 // C2 (unordered) turned into GT or LT already.  The other bits
 4141 // C0 and C3 are turned into Carry &amp; Zero flags.
 4142 operand cmpOpU()
 4143 %{
 4144   match(Bool);
 4145 
 4146   format %{ &quot;&quot; %}
 4147   interface(COND_INTER) %{
 4148     equal(0x4, &quot;e&quot;);
 4149     not_equal(0x5, &quot;ne&quot;);
 4150     less(0x2, &quot;b&quot;);
 4151     greater_equal(0x3, &quot;nb&quot;);
 4152     less_equal(0x6, &quot;be&quot;);
 4153     greater(0x7, &quot;nbe&quot;);
 4154     overflow(0x0, &quot;o&quot;);
 4155     no_overflow(0x1, &quot;no&quot;);
 4156   %}
 4157 %}
 4158 
 4159 
 4160 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4161 operand cmpOpUCF() %{
 4162   match(Bool);
 4163   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4164             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4165             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4166             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4167   format %{ &quot;&quot; %}
 4168   interface(COND_INTER) %{
 4169     equal(0x4, &quot;e&quot;);
 4170     not_equal(0x5, &quot;ne&quot;);
 4171     less(0x2, &quot;b&quot;);
 4172     greater_equal(0x3, &quot;nb&quot;);
 4173     less_equal(0x6, &quot;be&quot;);
 4174     greater(0x7, &quot;nbe&quot;);
 4175     overflow(0x0, &quot;o&quot;);
 4176     no_overflow(0x1, &quot;no&quot;);
 4177   %}
 4178 %}
 4179 
 4180 
 4181 // Floating comparisons that can be fixed up with extra conditional jumps
 4182 operand cmpOpUCF2() %{
 4183   match(Bool);
 4184   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4185             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4186   format %{ &quot;&quot; %}
 4187   interface(COND_INTER) %{
 4188     equal(0x4, &quot;e&quot;);
 4189     not_equal(0x5, &quot;ne&quot;);
 4190     less(0x2, &quot;b&quot;);
 4191     greater_equal(0x3, &quot;nb&quot;);
 4192     less_equal(0x6, &quot;be&quot;);
 4193     greater(0x7, &quot;nbe&quot;);
 4194     overflow(0x0, &quot;o&quot;);
 4195     no_overflow(0x1, &quot;no&quot;);
 4196   %}
 4197 %}
 4198 
 4199 //----------OPERAND CLASSES----------------------------------------------------
 4200 // Operand Classes are groups of operands that are used as to simplify
 4201 // instruction definitions by not requiring the AD writer to specify separate
 4202 // instructions for every form of operand when the instruction accepts
 4203 // multiple operand types with the same basic encoding and format.  The classic
 4204 // case of this is memory operands.
 4205 
 4206 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4207                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4208                indCompressedOopOffset,
 4209                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4210                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4211                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4212 
 4213 //----------PIPELINE-----------------------------------------------------------
 4214 // Rules which define the behavior of the target architectures pipeline.
 4215 pipeline %{
 4216 
 4217 //----------ATTRIBUTES---------------------------------------------------------
 4218 attributes %{
 4219   variable_size_instructions;        // Fixed size instructions
 4220   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4221   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4222   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4223   instruction_fetch_units = 1;       // of 16 bytes
 4224 
 4225   // List of nop instructions
 4226   nops( MachNop );
 4227 %}
 4228 
 4229 //----------RESOURCES----------------------------------------------------------
 4230 // Resources are the functional units available to the machine
 4231 
 4232 // Generic P2/P3 pipeline
 4233 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4234 // 3 instructions decoded per cycle.
 4235 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4236 // 3 ALU op, only ALU0 handles mul instructions.
 4237 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4238            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4239            BR, FPU,
 4240            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4241 
 4242 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4243 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4244 
 4245 // Generic P2/P3 pipeline
 4246 pipe_desc(S0, S1, S2, S3, S4, S5);
 4247 
 4248 //----------PIPELINE CLASSES---------------------------------------------------
 4249 // Pipeline Classes describe the stages in which input and output are
 4250 // referenced by the hardware pipeline.
 4251 
 4252 // Naming convention: ialu or fpu
 4253 // Then: _reg
 4254 // Then: _reg if there is a 2nd register
 4255 // Then: _long if it&#39;s a pair of instructions implementing a long
 4256 // Then: _fat if it requires the big decoder
 4257 //   Or: _mem if it requires the big decoder and a memory unit.
 4258 
 4259 // Integer ALU reg operation
 4260 pipe_class ialu_reg(rRegI dst)
 4261 %{
 4262     single_instruction;
 4263     dst    : S4(write);
 4264     dst    : S3(read);
 4265     DECODE : S0;        // any decoder
 4266     ALU    : S3;        // any alu
 4267 %}
 4268 
 4269 // Long ALU reg operation
 4270 pipe_class ialu_reg_long(rRegL dst)
 4271 %{
 4272     instruction_count(2);
 4273     dst    : S4(write);
 4274     dst    : S3(read);
 4275     DECODE : S0(2);     // any 2 decoders
 4276     ALU    : S3(2);     // both alus
 4277 %}
 4278 
 4279 // Integer ALU reg operation using big decoder
 4280 pipe_class ialu_reg_fat(rRegI dst)
 4281 %{
 4282     single_instruction;
 4283     dst    : S4(write);
 4284     dst    : S3(read);
 4285     D0     : S0;        // big decoder only
 4286     ALU    : S3;        // any alu
 4287 %}
 4288 
 4289 // Long ALU reg operation using big decoder
 4290 pipe_class ialu_reg_long_fat(rRegL dst)
 4291 %{
 4292     instruction_count(2);
 4293     dst    : S4(write);
 4294     dst    : S3(read);
 4295     D0     : S0(2);     // big decoder only; twice
 4296     ALU    : S3(2);     // any 2 alus
 4297 %}
 4298 
 4299 // Integer ALU reg-reg operation
 4300 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4301 %{
 4302     single_instruction;
 4303     dst    : S4(write);
 4304     src    : S3(read);
 4305     DECODE : S0;        // any decoder
 4306     ALU    : S3;        // any alu
 4307 %}
 4308 
 4309 // Long ALU reg-reg operation
 4310 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4311 %{
 4312     instruction_count(2);
 4313     dst    : S4(write);
 4314     src    : S3(read);
 4315     DECODE : S0(2);     // any 2 decoders
 4316     ALU    : S3(2);     // both alus
 4317 %}
 4318 
 4319 // Integer ALU reg-reg operation
 4320 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4321 %{
 4322     single_instruction;
 4323     dst    : S4(write);
 4324     src    : S3(read);
 4325     D0     : S0;        // big decoder only
 4326     ALU    : S3;        // any alu
 4327 %}
 4328 
 4329 // Long ALU reg-reg operation
 4330 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4331 %{
 4332     instruction_count(2);
 4333     dst    : S4(write);
 4334     src    : S3(read);
 4335     D0     : S0(2);     // big decoder only; twice
 4336     ALU    : S3(2);     // both alus
 4337 %}
 4338 
 4339 // Integer ALU reg-mem operation
 4340 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4341 %{
 4342     single_instruction;
 4343     dst    : S5(write);
 4344     mem    : S3(read);
 4345     D0     : S0;        // big decoder only
 4346     ALU    : S4;        // any alu
 4347     MEM    : S3;        // any mem
 4348 %}
 4349 
 4350 // Integer mem operation (prefetch)
 4351 pipe_class ialu_mem(memory mem)
 4352 %{
 4353     single_instruction;
 4354     mem    : S3(read);
 4355     D0     : S0;        // big decoder only
 4356     MEM    : S3;        // any mem
 4357 %}
 4358 
 4359 // Integer Store to Memory
 4360 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4361 %{
 4362     single_instruction;
 4363     mem    : S3(read);
 4364     src    : S5(read);
 4365     D0     : S0;        // big decoder only
 4366     ALU    : S4;        // any alu
 4367     MEM    : S3;
 4368 %}
 4369 
 4370 // // Long Store to Memory
 4371 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4372 // %{
 4373 //     instruction_count(2);
 4374 //     mem    : S3(read);
 4375 //     src    : S5(read);
 4376 //     D0     : S0(2);          // big decoder only; twice
 4377 //     ALU    : S4(2);     // any 2 alus
 4378 //     MEM    : S3(2);  // Both mems
 4379 // %}
 4380 
 4381 // Integer Store to Memory
 4382 pipe_class ialu_mem_imm(memory mem)
 4383 %{
 4384     single_instruction;
 4385     mem    : S3(read);
 4386     D0     : S0;        // big decoder only
 4387     ALU    : S4;        // any alu
 4388     MEM    : S3;
 4389 %}
 4390 
 4391 // Integer ALU0 reg-reg operation
 4392 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4393 %{
 4394     single_instruction;
 4395     dst    : S4(write);
 4396     src    : S3(read);
 4397     D0     : S0;        // Big decoder only
 4398     ALU0   : S3;        // only alu0
 4399 %}
 4400 
 4401 // Integer ALU0 reg-mem operation
 4402 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4403 %{
 4404     single_instruction;
 4405     dst    : S5(write);
 4406     mem    : S3(read);
 4407     D0     : S0;        // big decoder only
 4408     ALU0   : S4;        // ALU0 only
 4409     MEM    : S3;        // any mem
 4410 %}
 4411 
 4412 // Integer ALU reg-reg operation
 4413 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4414 %{
 4415     single_instruction;
 4416     cr     : S4(write);
 4417     src1   : S3(read);
 4418     src2   : S3(read);
 4419     DECODE : S0;        // any decoder
 4420     ALU    : S3;        // any alu
 4421 %}
 4422 
 4423 // Integer ALU reg-imm operation
 4424 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4425 %{
 4426     single_instruction;
 4427     cr     : S4(write);
 4428     src1   : S3(read);
 4429     DECODE : S0;        // any decoder
 4430     ALU    : S3;        // any alu
 4431 %}
 4432 
 4433 // Integer ALU reg-mem operation
 4434 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4435 %{
 4436     single_instruction;
 4437     cr     : S4(write);
 4438     src1   : S3(read);
 4439     src2   : S3(read);
 4440     D0     : S0;        // big decoder only
 4441     ALU    : S4;        // any alu
 4442     MEM    : S3;
 4443 %}
 4444 
 4445 // Conditional move reg-reg
 4446 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4447 %{
 4448     instruction_count(4);
 4449     y      : S4(read);
 4450     q      : S3(read);
 4451     p      : S3(read);
 4452     DECODE : S0(4);     // any decoder
 4453 %}
 4454 
 4455 // Conditional move reg-reg
 4456 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4457 %{
 4458     single_instruction;
 4459     dst    : S4(write);
 4460     src    : S3(read);
 4461     cr     : S3(read);
 4462     DECODE : S0;        // any decoder
 4463 %}
 4464 
 4465 // Conditional move reg-mem
 4466 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4467 %{
 4468     single_instruction;
 4469     dst    : S4(write);
 4470     src    : S3(read);
 4471     cr     : S3(read);
 4472     DECODE : S0;        // any decoder
 4473     MEM    : S3;
 4474 %}
 4475 
 4476 // Conditional move reg-reg long
 4477 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4478 %{
 4479     single_instruction;
 4480     dst    : S4(write);
 4481     src    : S3(read);
 4482     cr     : S3(read);
 4483     DECODE : S0(2);     // any 2 decoders
 4484 %}
 4485 
 4486 // XXX
 4487 // // Conditional move double reg-reg
 4488 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4489 // %{
 4490 //     single_instruction;
 4491 //     dst    : S4(write);
 4492 //     src    : S3(read);
 4493 //     cr     : S3(read);
 4494 //     DECODE : S0;     // any decoder
 4495 // %}
 4496 
 4497 // Float reg-reg operation
 4498 pipe_class fpu_reg(regD dst)
 4499 %{
 4500     instruction_count(2);
 4501     dst    : S3(read);
 4502     DECODE : S0(2);     // any 2 decoders
 4503     FPU    : S3;
 4504 %}
 4505 
 4506 // Float reg-reg operation
 4507 pipe_class fpu_reg_reg(regD dst, regD src)
 4508 %{
 4509     instruction_count(2);
 4510     dst    : S4(write);
 4511     src    : S3(read);
 4512     DECODE : S0(2);     // any 2 decoders
 4513     FPU    : S3;
 4514 %}
 4515 
 4516 // Float reg-reg operation
 4517 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4518 %{
 4519     instruction_count(3);
 4520     dst    : S4(write);
 4521     src1   : S3(read);
 4522     src2   : S3(read);
 4523     DECODE : S0(3);     // any 3 decoders
 4524     FPU    : S3(2);
 4525 %}
 4526 
 4527 // Float reg-reg operation
 4528 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4529 %{
 4530     instruction_count(4);
 4531     dst    : S4(write);
 4532     src1   : S3(read);
 4533     src2   : S3(read);
 4534     src3   : S3(read);
 4535     DECODE : S0(4);     // any 3 decoders
 4536     FPU    : S3(2);
 4537 %}
 4538 
 4539 // Float reg-reg operation
 4540 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4541 %{
 4542     instruction_count(4);
 4543     dst    : S4(write);
 4544     src1   : S3(read);
 4545     src2   : S3(read);
 4546     src3   : S3(read);
 4547     DECODE : S1(3);     // any 3 decoders
 4548     D0     : S0;        // Big decoder only
 4549     FPU    : S3(2);
 4550     MEM    : S3;
 4551 %}
 4552 
 4553 // Float reg-mem operation
 4554 pipe_class fpu_reg_mem(regD dst, memory mem)
 4555 %{
 4556     instruction_count(2);
 4557     dst    : S5(write);
 4558     mem    : S3(read);
 4559     D0     : S0;        // big decoder only
 4560     DECODE : S1;        // any decoder for FPU POP
 4561     FPU    : S4;
 4562     MEM    : S3;        // any mem
 4563 %}
 4564 
 4565 // Float reg-mem operation
 4566 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4567 %{
 4568     instruction_count(3);
 4569     dst    : S5(write);
 4570     src1   : S3(read);
 4571     mem    : S3(read);
 4572     D0     : S0;        // big decoder only
 4573     DECODE : S1(2);     // any decoder for FPU POP
 4574     FPU    : S4;
 4575     MEM    : S3;        // any mem
 4576 %}
 4577 
 4578 // Float mem-reg operation
 4579 pipe_class fpu_mem_reg(memory mem, regD src)
 4580 %{
 4581     instruction_count(2);
 4582     src    : S5(read);
 4583     mem    : S3(read);
 4584     DECODE : S0;        // any decoder for FPU PUSH
 4585     D0     : S1;        // big decoder only
 4586     FPU    : S4;
 4587     MEM    : S3;        // any mem
 4588 %}
 4589 
 4590 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4591 %{
 4592     instruction_count(3);
 4593     src1   : S3(read);
 4594     src2   : S3(read);
 4595     mem    : S3(read);
 4596     DECODE : S0(2);     // any decoder for FPU PUSH
 4597     D0     : S1;        // big decoder only
 4598     FPU    : S4;
 4599     MEM    : S3;        // any mem
 4600 %}
 4601 
 4602 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4603 %{
 4604     instruction_count(3);
 4605     src1   : S3(read);
 4606     src2   : S3(read);
 4607     mem    : S4(read);
 4608     DECODE : S0;        // any decoder for FPU PUSH
 4609     D0     : S0(2);     // big decoder only
 4610     FPU    : S4;
 4611     MEM    : S3(2);     // any mem
 4612 %}
 4613 
 4614 pipe_class fpu_mem_mem(memory dst, memory src1)
 4615 %{
 4616     instruction_count(2);
 4617     src1   : S3(read);
 4618     dst    : S4(read);
 4619     D0     : S0(2);     // big decoder only
 4620     MEM    : S3(2);     // any mem
 4621 %}
 4622 
 4623 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4624 %{
 4625     instruction_count(3);
 4626     src1   : S3(read);
 4627     src2   : S3(read);
 4628     dst    : S4(read);
 4629     D0     : S0(3);     // big decoder only
 4630     FPU    : S4;
 4631     MEM    : S3(3);     // any mem
 4632 %}
 4633 
 4634 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4635 %{
 4636     instruction_count(3);
 4637     src1   : S4(read);
 4638     mem    : S4(read);
 4639     DECODE : S0;        // any decoder for FPU PUSH
 4640     D0     : S0(2);     // big decoder only
 4641     FPU    : S4;
 4642     MEM    : S3(2);     // any mem
 4643 %}
 4644 
 4645 // Float load constant
 4646 pipe_class fpu_reg_con(regD dst)
 4647 %{
 4648     instruction_count(2);
 4649     dst    : S5(write);
 4650     D0     : S0;        // big decoder only for the load
 4651     DECODE : S1;        // any decoder for FPU POP
 4652     FPU    : S4;
 4653     MEM    : S3;        // any mem
 4654 %}
 4655 
 4656 // Float load constant
 4657 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4658 %{
 4659     instruction_count(3);
 4660     dst    : S5(write);
 4661     src    : S3(read);
 4662     D0     : S0;        // big decoder only for the load
 4663     DECODE : S1(2);     // any decoder for FPU POP
 4664     FPU    : S4;
 4665     MEM    : S3;        // any mem
 4666 %}
 4667 
 4668 // UnConditional branch
 4669 pipe_class pipe_jmp(label labl)
 4670 %{
 4671     single_instruction;
 4672     BR   : S3;
 4673 %}
 4674 
 4675 // Conditional branch
 4676 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4677 %{
 4678     single_instruction;
 4679     cr    : S1(read);
 4680     BR    : S3;
 4681 %}
 4682 
 4683 // Allocation idiom
 4684 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4685 %{
 4686     instruction_count(1); force_serialization;
 4687     fixed_latency(6);
 4688     heap_ptr : S3(read);
 4689     DECODE   : S0(3);
 4690     D0       : S2;
 4691     MEM      : S3;
 4692     ALU      : S3(2);
 4693     dst      : S5(write);
 4694     BR       : S5;
 4695 %}
 4696 
 4697 // Generic big/slow expanded idiom
 4698 pipe_class pipe_slow()
 4699 %{
 4700     instruction_count(10); multiple_bundles; force_serialization;
 4701     fixed_latency(100);
 4702     D0  : S0(2);
 4703     MEM : S3(2);
 4704 %}
 4705 
 4706 // The real do-nothing guy
 4707 pipe_class empty()
 4708 %{
 4709     instruction_count(0);
 4710 %}
 4711 
 4712 // Define the class for the Nop node
 4713 define
 4714 %{
 4715    MachNop = empty;
 4716 %}
 4717 
 4718 %}
 4719 
 4720 //----------INSTRUCTIONS-------------------------------------------------------
 4721 //
 4722 // match      -- States which machine-independent subtree may be replaced
 4723 //               by this instruction.
 4724 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4725 //               selection to identify a minimum cost tree of machine
 4726 //               instructions that matches a tree of machine-independent
 4727 //               instructions.
 4728 // format     -- A string providing the disassembly for this instruction.
 4729 //               The value of an instruction&#39;s operand may be inserted
 4730 //               by referring to it with a &#39;$&#39; prefix.
 4731 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4732 //               to within an encode class as $primary, $secondary, and $tertiary
 4733 //               rrspectively.  The primary opcode is commonly used to
 4734 //               indicate the type of machine instruction, while secondary
 4735 //               and tertiary are often used for prefix options or addressing
 4736 //               modes.
 4737 // ins_encode -- A list of encode classes with parameters. The encode class
 4738 //               name must have been defined in an &#39;enc_class&#39; specification
 4739 //               in the encode section of the architecture description.
 4740 
 4741 
 4742 //----------Load/Store/Move Instructions---------------------------------------
 4743 //----------Load Instructions--------------------------------------------------
 4744 
 4745 // Load Byte (8 bit signed)
 4746 instruct loadB(rRegI dst, memory mem)
 4747 %{
 4748   match(Set dst (LoadB mem));
 4749 
 4750   ins_cost(125);
 4751   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4752 
 4753   ins_encode %{
 4754     __ movsbl($dst$$Register, $mem$$Address);
 4755   %}
 4756 
 4757   ins_pipe(ialu_reg_mem);
 4758 %}
 4759 
 4760 // Load Byte (8 bit signed) into Long Register
 4761 instruct loadB2L(rRegL dst, memory mem)
 4762 %{
 4763   match(Set dst (ConvI2L (LoadB mem)));
 4764 
 4765   ins_cost(125);
 4766   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4767 
 4768   ins_encode %{
 4769     __ movsbq($dst$$Register, $mem$$Address);
 4770   %}
 4771 
 4772   ins_pipe(ialu_reg_mem);
 4773 %}
 4774 
 4775 // Load Unsigned Byte (8 bit UNsigned)
 4776 instruct loadUB(rRegI dst, memory mem)
 4777 %{
 4778   match(Set dst (LoadUB mem));
 4779 
 4780   ins_cost(125);
 4781   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4782 
 4783   ins_encode %{
 4784     __ movzbl($dst$$Register, $mem$$Address);
 4785   %}
 4786 
 4787   ins_pipe(ialu_reg_mem);
 4788 %}
 4789 
 4790 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4791 instruct loadUB2L(rRegL dst, memory mem)
 4792 %{
 4793   match(Set dst (ConvI2L (LoadUB mem)));
 4794 
 4795   ins_cost(125);
 4796   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4797 
 4798   ins_encode %{
 4799     __ movzbq($dst$$Register, $mem$$Address);
 4800   %}
 4801 
 4802   ins_pipe(ialu_reg_mem);
 4803 %}
 4804 
 4805 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4806 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4807   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4808   effect(KILL cr);
 4809 
 4810   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4811             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4812   ins_encode %{
 4813     Register Rdst = $dst$$Register;
 4814     __ movzbq(Rdst, $mem$$Address);
 4815     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4816   %}
 4817   ins_pipe(ialu_reg_mem);
 4818 %}
 4819 
 4820 // Load Short (16 bit signed)
 4821 instruct loadS(rRegI dst, memory mem)
 4822 %{
 4823   match(Set dst (LoadS mem));
 4824 
 4825   ins_cost(125);
 4826   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4827 
 4828   ins_encode %{
 4829     __ movswl($dst$$Register, $mem$$Address);
 4830   %}
 4831 
 4832   ins_pipe(ialu_reg_mem);
 4833 %}
 4834 
 4835 // Load Short (16 bit signed) to Byte (8 bit signed)
 4836 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4837   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4838 
 4839   ins_cost(125);
 4840   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4841   ins_encode %{
 4842     __ movsbl($dst$$Register, $mem$$Address);
 4843   %}
 4844   ins_pipe(ialu_reg_mem);
 4845 %}
 4846 
 4847 // Load Short (16 bit signed) into Long Register
 4848 instruct loadS2L(rRegL dst, memory mem)
 4849 %{
 4850   match(Set dst (ConvI2L (LoadS mem)));
 4851 
 4852   ins_cost(125);
 4853   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4854 
 4855   ins_encode %{
 4856     __ movswq($dst$$Register, $mem$$Address);
 4857   %}
 4858 
 4859   ins_pipe(ialu_reg_mem);
 4860 %}
 4861 
 4862 // Load Unsigned Short/Char (16 bit UNsigned)
 4863 instruct loadUS(rRegI dst, memory mem)
 4864 %{
 4865   match(Set dst (LoadUS mem));
 4866 
 4867   ins_cost(125);
 4868   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4869 
 4870   ins_encode %{
 4871     __ movzwl($dst$$Register, $mem$$Address);
 4872   %}
 4873 
 4874   ins_pipe(ialu_reg_mem);
 4875 %}
 4876 
 4877 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4878 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4879   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4880 
 4881   ins_cost(125);
 4882   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4883   ins_encode %{
 4884     __ movsbl($dst$$Register, $mem$$Address);
 4885   %}
 4886   ins_pipe(ialu_reg_mem);
 4887 %}
 4888 
 4889 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4890 instruct loadUS2L(rRegL dst, memory mem)
 4891 %{
 4892   match(Set dst (ConvI2L (LoadUS mem)));
 4893 
 4894   ins_cost(125);
 4895   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4896 
 4897   ins_encode %{
 4898     __ movzwq($dst$$Register, $mem$$Address);
 4899   %}
 4900 
 4901   ins_pipe(ialu_reg_mem);
 4902 %}
 4903 
 4904 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4905 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4906   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4907 
 4908   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4909   ins_encode %{
 4910     __ movzbq($dst$$Register, $mem$$Address);
 4911   %}
 4912   ins_pipe(ialu_reg_mem);
 4913 %}
 4914 
 4915 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4916 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4917   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4918   effect(KILL cr);
 4919 
 4920   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4921             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4922   ins_encode %{
 4923     Register Rdst = $dst$$Register;
 4924     __ movzwq(Rdst, $mem$$Address);
 4925     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4926   %}
 4927   ins_pipe(ialu_reg_mem);
 4928 %}
 4929 
 4930 // Load Integer
 4931 instruct loadI(rRegI dst, memory mem)
 4932 %{
 4933   match(Set dst (LoadI mem));
 4934 
 4935   ins_cost(125);
 4936   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4937 
 4938   ins_encode %{
 4939     __ movl($dst$$Register, $mem$$Address);
 4940   %}
 4941 
 4942   ins_pipe(ialu_reg_mem);
 4943 %}
 4944 
 4945 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4946 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4947   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4948 
 4949   ins_cost(125);
 4950   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4951   ins_encode %{
 4952     __ movsbl($dst$$Register, $mem$$Address);
 4953   %}
 4954   ins_pipe(ialu_reg_mem);
 4955 %}
 4956 
 4957 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4958 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4959   match(Set dst (AndI (LoadI mem) mask));
 4960 
 4961   ins_cost(125);
 4962   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 4963   ins_encode %{
 4964     __ movzbl($dst$$Register, $mem$$Address);
 4965   %}
 4966   ins_pipe(ialu_reg_mem);
 4967 %}
 4968 
 4969 // Load Integer (32 bit signed) to Short (16 bit signed)
 4970 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 4971   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 4972 
 4973   ins_cost(125);
 4974   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 4975   ins_encode %{
 4976     __ movswl($dst$$Register, $mem$$Address);
 4977   %}
 4978   ins_pipe(ialu_reg_mem);
 4979 %}
 4980 
 4981 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 4982 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 4983   match(Set dst (AndI (LoadI mem) mask));
 4984 
 4985   ins_cost(125);
 4986   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 4987   ins_encode %{
 4988     __ movzwl($dst$$Register, $mem$$Address);
 4989   %}
 4990   ins_pipe(ialu_reg_mem);
 4991 %}
 4992 
 4993 // Load Integer into Long Register
 4994 instruct loadI2L(rRegL dst, memory mem)
 4995 %{
 4996   match(Set dst (ConvI2L (LoadI mem)));
 4997 
 4998   ins_cost(125);
 4999   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 5000 
 5001   ins_encode %{
 5002     __ movslq($dst$$Register, $mem$$Address);
 5003   %}
 5004 
 5005   ins_pipe(ialu_reg_mem);
 5006 %}
 5007 
 5008 // Load Integer with mask 0xFF into Long Register
 5009 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5010   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5011 
 5012   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5013   ins_encode %{
 5014     __ movzbq($dst$$Register, $mem$$Address);
 5015   %}
 5016   ins_pipe(ialu_reg_mem);
 5017 %}
 5018 
 5019 // Load Integer with mask 0xFFFF into Long Register
 5020 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5021   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5022 
 5023   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5024   ins_encode %{
 5025     __ movzwq($dst$$Register, $mem$$Address);
 5026   %}
 5027   ins_pipe(ialu_reg_mem);
 5028 %}
 5029 
 5030 // Load Integer with a 31-bit mask into Long Register
 5031 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5032   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5033   effect(KILL cr);
 5034 
 5035   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5036             &quot;andl    $dst, $mask&quot; %}
 5037   ins_encode %{
 5038     Register Rdst = $dst$$Register;
 5039     __ movl(Rdst, $mem$$Address);
 5040     __ andl(Rdst, $mask$$constant);
 5041   %}
 5042   ins_pipe(ialu_reg_mem);
 5043 %}
 5044 
 5045 // Load Unsigned Integer into Long Register
 5046 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5047 %{
 5048   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5049 
 5050   ins_cost(125);
 5051   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5052 
 5053   ins_encode %{
 5054     __ movl($dst$$Register, $mem$$Address);
 5055   %}
 5056 
 5057   ins_pipe(ialu_reg_mem);
 5058 %}
 5059 
 5060 // Load Long
 5061 instruct loadL(rRegL dst, memory mem)
 5062 %{
 5063   match(Set dst (LoadL mem));
 5064 
 5065   ins_cost(125);
 5066   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5067 
 5068   ins_encode %{
 5069     __ movq($dst$$Register, $mem$$Address);
 5070   %}
 5071 
 5072   ins_pipe(ialu_reg_mem); // XXX
 5073 %}
 5074 
 5075 // Load Range
 5076 instruct loadRange(rRegI dst, memory mem)
 5077 %{
 5078   match(Set dst (LoadRange mem));
 5079 
 5080   ins_cost(125); // XXX
 5081   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5082   opcode(0x8B);
 5083   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5084   ins_pipe(ialu_reg_mem);
 5085 %}
 5086 
 5087 // Load Pointer
 5088 instruct loadP(rRegP dst, memory mem)
 5089 %{
 5090   match(Set dst (LoadP mem));
 5091   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5092 
 5093   ins_cost(125); // XXX
 5094   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5095   opcode(0x8B);
 5096   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5097   ins_pipe(ialu_reg_mem); // XXX
 5098 %}
 5099 
 5100 // Load Compressed Pointer
 5101 instruct loadN(rRegN dst, memory mem)
 5102 %{
 5103    match(Set dst (LoadN mem));
 5104 
 5105    ins_cost(125); // XXX
 5106    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5107    ins_encode %{
 5108      __ movl($dst$$Register, $mem$$Address);
 5109    %}
 5110    ins_pipe(ialu_reg_mem); // XXX
 5111 %}
 5112 
 5113 
 5114 // Load Klass Pointer
 5115 instruct loadKlass(rRegP dst, memory mem)
 5116 %{
 5117   match(Set dst (LoadKlass mem));
 5118 
 5119   ins_cost(125); // XXX
 5120   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5121   opcode(0x8B);
 5122   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5123   ins_pipe(ialu_reg_mem); // XXX
 5124 %}
 5125 
 5126 // Load narrow Klass Pointer
 5127 instruct loadNKlass(rRegN dst, memory mem)
 5128 %{
 5129   match(Set dst (LoadNKlass mem));
 5130 
 5131   ins_cost(125); // XXX
 5132   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5133   ins_encode %{
 5134     __ movl($dst$$Register, $mem$$Address);
 5135   %}
 5136   ins_pipe(ialu_reg_mem); // XXX
 5137 %}
 5138 
 5139 // Load Float
 5140 instruct loadF(regF dst, memory mem)
 5141 %{
 5142   match(Set dst (LoadF mem));
 5143 
 5144   ins_cost(145); // XXX
 5145   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5146   ins_encode %{
 5147     __ movflt($dst$$XMMRegister, $mem$$Address);
 5148   %}
 5149   ins_pipe(pipe_slow); // XXX
 5150 %}
 5151 
 5152 // Load Float
 5153 instruct MoveF2VL(vlRegF dst, regF src) %{
 5154   match(Set dst src);
 5155   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5156   ins_encode %{
 5157     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5158   %}
 5159   ins_pipe( fpu_reg_reg );
 5160 %}
 5161 
 5162 // Load Float
 5163 instruct MoveF2LEG(legRegF dst, regF src) %{
 5164   match(Set dst src);
 5165   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5166   ins_encode %{
 5167     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5168   %}
 5169   ins_pipe( fpu_reg_reg );
 5170 %}
 5171 
 5172 // Load Float
 5173 instruct MoveVL2F(regF dst, vlRegF src) %{
 5174   match(Set dst src);
 5175   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5176   ins_encode %{
 5177     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5178   %}
 5179   ins_pipe( fpu_reg_reg );
 5180 %}
 5181 
 5182 // Load Float
 5183 instruct MoveLEG2F(regF dst, legRegF src) %{
 5184   match(Set dst src);
 5185   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5186   ins_encode %{
 5187     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5188   %}
 5189   ins_pipe( fpu_reg_reg );
 5190 %}
 5191 
 5192 // Load Double
 5193 instruct loadD_partial(regD dst, memory mem)
 5194 %{
 5195   predicate(!UseXmmLoadAndClearUpper);
 5196   match(Set dst (LoadD mem));
 5197 
 5198   ins_cost(145); // XXX
 5199   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5200   ins_encode %{
 5201     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5202   %}
 5203   ins_pipe(pipe_slow); // XXX
 5204 %}
 5205 
 5206 instruct loadD(regD dst, memory mem)
 5207 %{
 5208   predicate(UseXmmLoadAndClearUpper);
 5209   match(Set dst (LoadD mem));
 5210 
 5211   ins_cost(145); // XXX
 5212   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5213   ins_encode %{
 5214     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5215   %}
 5216   ins_pipe(pipe_slow); // XXX
 5217 %}
 5218 
 5219 // Load Double
 5220 instruct MoveD2VL(vlRegD dst, regD src) %{
 5221   match(Set dst src);
 5222   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5223   ins_encode %{
 5224     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5225   %}
 5226   ins_pipe( fpu_reg_reg );
 5227 %}
 5228 
 5229 // Load Double
 5230 instruct MoveD2LEG(legRegD dst, regD src) %{
 5231   match(Set dst src);
 5232   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5233   ins_encode %{
 5234     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5235   %}
 5236   ins_pipe( fpu_reg_reg );
 5237 %}
 5238 
 5239 // Load Double
 5240 instruct MoveVL2D(regD dst, vlRegD src) %{
 5241   match(Set dst src);
 5242   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5243   ins_encode %{
 5244     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5245   %}
 5246   ins_pipe( fpu_reg_reg );
 5247 %}
 5248 
 5249 // Load Double
 5250 instruct MoveLEG2D(regD dst, legRegD src) %{
 5251   match(Set dst src);
 5252   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5253   ins_encode %{
 5254     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5255   %}
 5256   ins_pipe( fpu_reg_reg );
 5257 %}
 5258 
 5259 // Following pseudo code describes the algorithm for max[FD]:
 5260 // Min algorithm is on similar lines
 5261 //  btmp = (b &lt; +0.0) ? a : b
 5262 //  atmp = (b &lt; +0.0) ? b : a
 5263 //  Tmp  = Max_Float(atmp , btmp)
 5264 //  Res  = (atmp == NaN) ? atmp : Tmp
 5265 
 5266 // max = java.lang.Math.max(float a, float b)
 5267 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5268   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5269   match(Set dst (MaxF a b));
 5270   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5271   format %{
 5272      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5273      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5274      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5275      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5276      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5277   %}
 5278   ins_encode %{
 5279     int vector_len = Assembler::AVX_128bit;
 5280     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5281     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5282     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5283     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5284     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5285  %}
 5286   ins_pipe( pipe_slow );
 5287 %}
 5288 
 5289 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5290   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5291   match(Set dst (MaxF a b));
 5292   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5293 
 5294   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5295   ins_encode %{
 5296     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5297                     false /*min*/, true /*single*/);
 5298   %}
 5299   ins_pipe( pipe_slow );
 5300 %}
 5301 
 5302 // max = java.lang.Math.max(double a, double b)
 5303 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5304   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5305   match(Set dst (MaxD a b));
 5306   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5307   format %{
 5308      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5309      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5310      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5311      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5312      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5313   %}
 5314   ins_encode %{
 5315     int vector_len = Assembler::AVX_128bit;
 5316     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5317     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5318     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5319     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5320     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5321   %}
 5322   ins_pipe( pipe_slow );
 5323 %}
 5324 
 5325 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5326   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5327   match(Set dst (MaxD a b));
 5328   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5329 
 5330   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5331   ins_encode %{
 5332     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5333                     false /*min*/, false /*single*/);
 5334   %}
 5335   ins_pipe( pipe_slow );
 5336 %}
 5337 
 5338 // min = java.lang.Math.min(float a, float b)
 5339 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5340   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5341   match(Set dst (MinF a b));
 5342   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5343   format %{
 5344      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5345      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5346      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5347      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5348      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5349   %}
 5350   ins_encode %{
 5351     int vector_len = Assembler::AVX_128bit;
 5352     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5353     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5354     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5355     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5356     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5357   %}
 5358   ins_pipe( pipe_slow );
 5359 %}
 5360 
 5361 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5362   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5363   match(Set dst (MinF a b));
 5364   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5365 
 5366   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5367   ins_encode %{
 5368     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5369                     true /*min*/, true /*single*/);
 5370   %}
 5371   ins_pipe( pipe_slow );
 5372 %}
 5373 
 5374 // min = java.lang.Math.min(double a, double b)
 5375 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5376   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5377   match(Set dst (MinD a b));
 5378   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5379   format %{
 5380      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5381      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5382      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5383      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5384      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5385   %}
 5386   ins_encode %{
 5387     int vector_len = Assembler::AVX_128bit;
 5388     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5389     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5390     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5391     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5392     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5393   %}
 5394   ins_pipe( pipe_slow );
 5395 %}
 5396 
 5397 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5398   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5399   match(Set dst (MinD a b));
 5400   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5401 
 5402   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5403   ins_encode %{
 5404     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5405                     true /*min*/, false /*single*/);
 5406   %}
 5407   ins_pipe( pipe_slow );
 5408 %}
 5409 
 5410 // Load Effective Address
 5411 instruct leaP8(rRegP dst, indOffset8 mem)
 5412 %{
 5413   match(Set dst mem);
 5414 
 5415   ins_cost(110); // XXX
 5416   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5417   opcode(0x8D);
 5418   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5419   ins_pipe(ialu_reg_reg_fat);
 5420 %}
 5421 
 5422 instruct leaP32(rRegP dst, indOffset32 mem)
 5423 %{
 5424   match(Set dst mem);
 5425 
 5426   ins_cost(110);
 5427   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5428   opcode(0x8D);
 5429   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5430   ins_pipe(ialu_reg_reg_fat);
 5431 %}
 5432 
 5433 // instruct leaPIdx(rRegP dst, indIndex mem)
 5434 // %{
 5435 //   match(Set dst mem);
 5436 
 5437 //   ins_cost(110);
 5438 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5439 //   opcode(0x8D);
 5440 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5441 //   ins_pipe(ialu_reg_reg_fat);
 5442 // %}
 5443 
 5444 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5445 %{
 5446   match(Set dst mem);
 5447 
 5448   ins_cost(110);
 5449   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5450   opcode(0x8D);
 5451   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5452   ins_pipe(ialu_reg_reg_fat);
 5453 %}
 5454 
 5455 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5456 %{
 5457   match(Set dst mem);
 5458 
 5459   ins_cost(110);
 5460   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5461   opcode(0x8D);
 5462   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5463   ins_pipe(ialu_reg_reg_fat);
 5464 %}
 5465 
 5466 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5467 %{
 5468   match(Set dst mem);
 5469 
 5470   ins_cost(110);
 5471   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5472   opcode(0x8D);
 5473   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5474   ins_pipe(ialu_reg_reg_fat);
 5475 %}
 5476 
 5477 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5478 %{
 5479   match(Set dst mem);
 5480 
 5481   ins_cost(110);
 5482   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5483   opcode(0x8D);
 5484   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5485   ins_pipe(ialu_reg_reg_fat);
 5486 %}
 5487 
 5488 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5489 %{
 5490   match(Set dst mem);
 5491 
 5492   ins_cost(110);
 5493   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5494   opcode(0x8D);
 5495   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5496   ins_pipe(ialu_reg_reg_fat);
 5497 %}
 5498 
 5499 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5500 %{
 5501   match(Set dst mem);
 5502 
 5503   ins_cost(110);
 5504   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5505   opcode(0x8D);
 5506   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5507   ins_pipe(ialu_reg_reg_fat);
 5508 %}
 5509 
 5510 // Load Effective Address which uses Narrow (32-bits) oop
 5511 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5512 %{
 5513   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5514   match(Set dst mem);
 5515 
 5516   ins_cost(110);
 5517   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5518   opcode(0x8D);
 5519   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5520   ins_pipe(ialu_reg_reg_fat);
 5521 %}
 5522 
 5523 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5524 %{
 5525   predicate(CompressedOops::shift() == 0);
 5526   match(Set dst mem);
 5527 
 5528   ins_cost(110); // XXX
 5529   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5530   opcode(0x8D);
 5531   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5532   ins_pipe(ialu_reg_reg_fat);
 5533 %}
 5534 
 5535 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5536 %{
 5537   predicate(CompressedOops::shift() == 0);
 5538   match(Set dst mem);
 5539 
 5540   ins_cost(110);
 5541   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5542   opcode(0x8D);
 5543   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5544   ins_pipe(ialu_reg_reg_fat);
 5545 %}
 5546 
 5547 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5548 %{
 5549   predicate(CompressedOops::shift() == 0);
 5550   match(Set dst mem);
 5551 
 5552   ins_cost(110);
 5553   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5554   opcode(0x8D);
 5555   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5556   ins_pipe(ialu_reg_reg_fat);
 5557 %}
 5558 
 5559 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5560 %{
 5561   predicate(CompressedOops::shift() == 0);
 5562   match(Set dst mem);
 5563 
 5564   ins_cost(110);
 5565   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5566   opcode(0x8D);
 5567   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5568   ins_pipe(ialu_reg_reg_fat);
 5569 %}
 5570 
 5571 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5572 %{
 5573   predicate(CompressedOops::shift() == 0);
 5574   match(Set dst mem);
 5575 
 5576   ins_cost(110);
 5577   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5578   opcode(0x8D);
 5579   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5580   ins_pipe(ialu_reg_reg_fat);
 5581 %}
 5582 
 5583 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5584 %{
 5585   predicate(CompressedOops::shift() == 0);
 5586   match(Set dst mem);
 5587 
 5588   ins_cost(110);
 5589   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5590   opcode(0x8D);
 5591   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5592   ins_pipe(ialu_reg_reg_fat);
 5593 %}
 5594 
 5595 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5596 %{
 5597   predicate(CompressedOops::shift() == 0);
 5598   match(Set dst mem);
 5599 
 5600   ins_cost(110);
 5601   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5602   opcode(0x8D);
 5603   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5604   ins_pipe(ialu_reg_reg_fat);
 5605 %}
 5606 
 5607 instruct loadConI(rRegI dst, immI src)
 5608 %{
 5609   match(Set dst src);
 5610 
 5611   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5612   ins_encode(load_immI(dst, src));
 5613   ins_pipe(ialu_reg_fat); // XXX
 5614 %}
 5615 
 5616 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5617 %{
 5618   match(Set dst src);
 5619   effect(KILL cr);
 5620 
 5621   ins_cost(50);
 5622   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5623   opcode(0x33); /* + rd */
 5624   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5625   ins_pipe(ialu_reg);
 5626 %}
 5627 
 5628 instruct loadConL(rRegL dst, immL src)
 5629 %{
 5630   match(Set dst src);
 5631 
 5632   ins_cost(150);
 5633   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5634   ins_encode(load_immL(dst, src));
 5635   ins_pipe(ialu_reg);
 5636 %}
 5637 
 5638 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5639 %{
 5640   match(Set dst src);
 5641   effect(KILL cr);
 5642 
 5643   ins_cost(50);
 5644   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5645   opcode(0x33); /* + rd */
 5646   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5647   ins_pipe(ialu_reg); // XXX
 5648 %}
 5649 
 5650 instruct loadConUL32(rRegL dst, immUL32 src)
 5651 %{
 5652   match(Set dst src);
 5653 
 5654   ins_cost(60);
 5655   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5656   ins_encode(load_immUL32(dst, src));
 5657   ins_pipe(ialu_reg);
 5658 %}
 5659 
 5660 instruct loadConL32(rRegL dst, immL32 src)
 5661 %{
 5662   match(Set dst src);
 5663 
 5664   ins_cost(70);
 5665   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5666   ins_encode(load_immL32(dst, src));
 5667   ins_pipe(ialu_reg);
 5668 %}
 5669 
 5670 instruct loadConP(rRegP dst, immP con) %{
 5671   match(Set dst con);
 5672 
 5673   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5674   ins_encode(load_immP(dst, con));
 5675   ins_pipe(ialu_reg_fat); // XXX
 5676 %}
 5677 
 5678 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5679 %{
 5680   match(Set dst src);
 5681   effect(KILL cr);
 5682 
 5683   ins_cost(50);
 5684   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5685   opcode(0x33); /* + rd */
 5686   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5687   ins_pipe(ialu_reg);
 5688 %}
 5689 
 5690 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5691 %{
 5692   match(Set dst src);
 5693   effect(KILL cr);
 5694 
 5695   ins_cost(60);
 5696   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5697   ins_encode(load_immP31(dst, src));
 5698   ins_pipe(ialu_reg);
 5699 %}
 5700 
 5701 instruct loadConF(regF dst, immF con) %{
 5702   match(Set dst con);
 5703   ins_cost(125);
 5704   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5705   ins_encode %{
 5706     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5707   %}
 5708   ins_pipe(pipe_slow);
 5709 %}
 5710 
 5711 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5712   match(Set dst src);
 5713   effect(KILL cr);
 5714   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5715   ins_encode %{
 5716     __ xorq($dst$$Register, $dst$$Register);
 5717   %}
 5718   ins_pipe(ialu_reg);
 5719 %}
 5720 
 5721 instruct loadConN(rRegN dst, immN src) %{
 5722   match(Set dst src);
 5723 
 5724   ins_cost(125);
 5725   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5726   ins_encode %{
 5727     address con = (address)$src$$constant;
 5728     if (con == NULL) {
 5729       ShouldNotReachHere();
 5730     } else {
 5731       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5732     }
 5733   %}
 5734   ins_pipe(ialu_reg_fat); // XXX
 5735 %}
 5736 
 5737 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5738   match(Set dst src);
 5739 
 5740   ins_cost(125);
 5741   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5742   ins_encode %{
 5743     address con = (address)$src$$constant;
 5744     if (con == NULL) {
 5745       ShouldNotReachHere();
 5746     } else {
 5747       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5748     }
 5749   %}
 5750   ins_pipe(ialu_reg_fat); // XXX
 5751 %}
 5752 
 5753 instruct loadConF0(regF dst, immF0 src)
 5754 %{
 5755   match(Set dst src);
 5756   ins_cost(100);
 5757 
 5758   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5759   ins_encode %{
 5760     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5761   %}
 5762   ins_pipe(pipe_slow);
 5763 %}
 5764 
 5765 // Use the same format since predicate() can not be used here.
 5766 instruct loadConD(regD dst, immD con) %{
 5767   match(Set dst con);
 5768   ins_cost(125);
 5769   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5770   ins_encode %{
 5771     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5772   %}
 5773   ins_pipe(pipe_slow);
 5774 %}
 5775 
 5776 instruct loadConD0(regD dst, immD0 src)
 5777 %{
 5778   match(Set dst src);
 5779   ins_cost(100);
 5780 
 5781   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5782   ins_encode %{
 5783     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5784   %}
 5785   ins_pipe(pipe_slow);
 5786 %}
 5787 
 5788 instruct loadSSI(rRegI dst, stackSlotI src)
 5789 %{
 5790   match(Set dst src);
 5791 
 5792   ins_cost(125);
 5793   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5794   opcode(0x8B);
 5795   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5796   ins_pipe(ialu_reg_mem);
 5797 %}
 5798 
 5799 instruct loadSSL(rRegL dst, stackSlotL src)
 5800 %{
 5801   match(Set dst src);
 5802 
 5803   ins_cost(125);
 5804   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5805   opcode(0x8B);
 5806   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5807   ins_pipe(ialu_reg_mem);
 5808 %}
 5809 
 5810 instruct loadSSP(rRegP dst, stackSlotP src)
 5811 %{
 5812   match(Set dst src);
 5813 
 5814   ins_cost(125);
 5815   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5816   opcode(0x8B);
 5817   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5818   ins_pipe(ialu_reg_mem);
 5819 %}
 5820 
 5821 instruct loadSSF(regF dst, stackSlotF src)
 5822 %{
 5823   match(Set dst src);
 5824 
 5825   ins_cost(125);
 5826   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5827   ins_encode %{
 5828     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5829   %}
 5830   ins_pipe(pipe_slow); // XXX
 5831 %}
 5832 
 5833 // Use the same format since predicate() can not be used here.
 5834 instruct loadSSD(regD dst, stackSlotD src)
 5835 %{
 5836   match(Set dst src);
 5837 
 5838   ins_cost(125);
 5839   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5840   ins_encode  %{
 5841     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5842   %}
 5843   ins_pipe(pipe_slow); // XXX
 5844 %}
 5845 
 5846 // Prefetch instructions for allocation.
 5847 // Must be safe to execute with invalid address (cannot fault).
 5848 
 5849 instruct prefetchAlloc( memory mem ) %{
 5850   predicate(AllocatePrefetchInstr==3);
 5851   match(PrefetchAllocation mem);
 5852   ins_cost(125);
 5853 
 5854   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5855   ins_encode %{
 5856     __ prefetchw($mem$$Address);
 5857   %}
 5858   ins_pipe(ialu_mem);
 5859 %}
 5860 
 5861 instruct prefetchAllocNTA( memory mem ) %{
 5862   predicate(AllocatePrefetchInstr==0);
 5863   match(PrefetchAllocation mem);
 5864   ins_cost(125);
 5865 
 5866   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5867   ins_encode %{
 5868     __ prefetchnta($mem$$Address);
 5869   %}
 5870   ins_pipe(ialu_mem);
 5871 %}
 5872 
 5873 instruct prefetchAllocT0( memory mem ) %{
 5874   predicate(AllocatePrefetchInstr==1);
 5875   match(PrefetchAllocation mem);
 5876   ins_cost(125);
 5877 
 5878   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5879   ins_encode %{
 5880     __ prefetcht0($mem$$Address);
 5881   %}
 5882   ins_pipe(ialu_mem);
 5883 %}
 5884 
 5885 instruct prefetchAllocT2( memory mem ) %{
 5886   predicate(AllocatePrefetchInstr==2);
 5887   match(PrefetchAllocation mem);
 5888   ins_cost(125);
 5889 
 5890   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5891   ins_encode %{
 5892     __ prefetcht2($mem$$Address);
 5893   %}
 5894   ins_pipe(ialu_mem);
 5895 %}
 5896 
 5897 //----------Store Instructions-------------------------------------------------
 5898 
 5899 // Store Byte
 5900 instruct storeB(memory mem, rRegI src)
 5901 %{
 5902   match(Set mem (StoreB mem src));
 5903 
 5904   ins_cost(125); // XXX
 5905   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5906   opcode(0x88);
 5907   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5908   ins_pipe(ialu_mem_reg);
 5909 %}
 5910 
 5911 // Store Char/Short
 5912 instruct storeC(memory mem, rRegI src)
 5913 %{
 5914   match(Set mem (StoreC mem src));
 5915 
 5916   ins_cost(125); // XXX
 5917   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5918   opcode(0x89);
 5919   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5920   ins_pipe(ialu_mem_reg);
 5921 %}
 5922 
 5923 // Store Integer
 5924 instruct storeI(memory mem, rRegI src)
 5925 %{
 5926   match(Set mem (StoreI mem src));
 5927 
 5928   ins_cost(125); // XXX
 5929   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5930   opcode(0x89);
 5931   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5932   ins_pipe(ialu_mem_reg);
 5933 %}
 5934 
 5935 // Store Long
 5936 instruct storeL(memory mem, rRegL src)
 5937 %{
 5938   match(Set mem (StoreL mem src));
 5939 
 5940   ins_cost(125); // XXX
 5941   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5942   opcode(0x89);
 5943   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5944   ins_pipe(ialu_mem_reg); // XXX
 5945 %}
 5946 
 5947 // Store Pointer
 5948 instruct storeP(memory mem, any_RegP src)
 5949 %{
 5950   match(Set mem (StoreP mem src));
 5951 
 5952   ins_cost(125); // XXX
 5953   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5954   opcode(0x89);
 5955   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5956   ins_pipe(ialu_mem_reg);
 5957 %}
 5958 
 5959 instruct storeImmP0(memory mem, immP0 zero)
 5960 %{
 5961   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 5962   match(Set mem (StoreP mem zero));
 5963 
 5964   ins_cost(125); // XXX
 5965   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5966   ins_encode %{
 5967     __ movq($mem$$Address, r12);
 5968   %}
 5969   ins_pipe(ialu_mem_reg);
 5970 %}
 5971 
 5972 // Store NULL Pointer, mark word, or other simple pointer constant.
 5973 instruct storeImmP(memory mem, immP31 src)
 5974 %{
 5975   match(Set mem (StoreP mem src));
 5976 
 5977   ins_cost(150); // XXX
 5978   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5979   opcode(0xC7); /* C7 /0 */
 5980   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5981   ins_pipe(ialu_mem_imm);
 5982 %}
 5983 
 5984 // Store Compressed Pointer
 5985 instruct storeN(memory mem, rRegN src)
 5986 %{
 5987   match(Set mem (StoreN mem src));
 5988 
 5989   ins_cost(125); // XXX
 5990   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 5991   ins_encode %{
 5992     __ movl($mem$$Address, $src$$Register);
 5993   %}
 5994   ins_pipe(ialu_mem_reg);
 5995 %}
 5996 
 5997 instruct storeNKlass(memory mem, rRegN src)
 5998 %{
 5999   match(Set mem (StoreNKlass mem src));
 6000 
 6001   ins_cost(125); // XXX
 6002   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6003   ins_encode %{
 6004     __ movl($mem$$Address, $src$$Register);
 6005   %}
 6006   ins_pipe(ialu_mem_reg);
 6007 %}
 6008 
 6009 instruct storeImmN0(memory mem, immN0 zero)
 6010 %{
 6011   predicate(CompressedOops::base() == NULL);
 6012   match(Set mem (StoreN mem zero));
 6013 
 6014   ins_cost(125); // XXX
 6015   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6016   ins_encode %{
 6017     __ movl($mem$$Address, r12);
 6018   %}
 6019   ins_pipe(ialu_mem_reg);
 6020 %}
 6021 
 6022 instruct storeImmN(memory mem, immN src)
 6023 %{
 6024   match(Set mem (StoreN mem src));
 6025 
 6026   ins_cost(150); // XXX
 6027   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6028   ins_encode %{
 6029     address con = (address)$src$$constant;
 6030     if (con == NULL) {
 6031       __ movl($mem$$Address, (int32_t)0);
 6032     } else {
 6033       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6034     }
 6035   %}
 6036   ins_pipe(ialu_mem_imm);
 6037 %}
 6038 
 6039 instruct storeImmNKlass(memory mem, immNKlass src)
 6040 %{
 6041   match(Set mem (StoreNKlass mem src));
 6042 
 6043   ins_cost(150); // XXX
 6044   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6045   ins_encode %{
 6046     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6047   %}
 6048   ins_pipe(ialu_mem_imm);
 6049 %}
 6050 
 6051 // Store Integer Immediate
 6052 instruct storeImmI0(memory mem, immI0 zero)
 6053 %{
 6054   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6055   match(Set mem (StoreI mem zero));
 6056 
 6057   ins_cost(125); // XXX
 6058   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6059   ins_encode %{
 6060     __ movl($mem$$Address, r12);
 6061   %}
 6062   ins_pipe(ialu_mem_reg);
 6063 %}
 6064 
 6065 instruct storeImmI(memory mem, immI src)
 6066 %{
 6067   match(Set mem (StoreI mem src));
 6068 
 6069   ins_cost(150);
 6070   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6071   opcode(0xC7); /* C7 /0 */
 6072   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6073   ins_pipe(ialu_mem_imm);
 6074 %}
 6075 
 6076 // Store Long Immediate
 6077 instruct storeImmL0(memory mem, immL0 zero)
 6078 %{
 6079   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6080   match(Set mem (StoreL mem zero));
 6081 
 6082   ins_cost(125); // XXX
 6083   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6084   ins_encode %{
 6085     __ movq($mem$$Address, r12);
 6086   %}
 6087   ins_pipe(ialu_mem_reg);
 6088 %}
 6089 
 6090 instruct storeImmL(memory mem, immL32 src)
 6091 %{
 6092   match(Set mem (StoreL mem src));
 6093 
 6094   ins_cost(150);
 6095   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6096   opcode(0xC7); /* C7 /0 */
 6097   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6098   ins_pipe(ialu_mem_imm);
 6099 %}
 6100 
 6101 // Store Short/Char Immediate
 6102 instruct storeImmC0(memory mem, immI0 zero)
 6103 %{
 6104   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6105   match(Set mem (StoreC mem zero));
 6106 
 6107   ins_cost(125); // XXX
 6108   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6109   ins_encode %{
 6110     __ movw($mem$$Address, r12);
 6111   %}
 6112   ins_pipe(ialu_mem_reg);
 6113 %}
 6114 
 6115 instruct storeImmI16(memory mem, immI16 src)
 6116 %{
 6117   predicate(UseStoreImmI16);
 6118   match(Set mem (StoreC mem src));
 6119 
 6120   ins_cost(150);
 6121   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6122   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6123   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6124   ins_pipe(ialu_mem_imm);
 6125 %}
 6126 
 6127 // Store Byte Immediate
 6128 instruct storeImmB0(memory mem, immI0 zero)
 6129 %{
 6130   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6131   match(Set mem (StoreB mem zero));
 6132 
 6133   ins_cost(125); // XXX
 6134   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6135   ins_encode %{
 6136     __ movb($mem$$Address, r12);
 6137   %}
 6138   ins_pipe(ialu_mem_reg);
 6139 %}
 6140 
 6141 instruct storeImmB(memory mem, immI8 src)
 6142 %{
 6143   match(Set mem (StoreB mem src));
 6144 
 6145   ins_cost(150); // XXX
 6146   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6147   opcode(0xC6); /* C6 /0 */
 6148   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6149   ins_pipe(ialu_mem_imm);
 6150 %}
 6151 
 6152 // Store CMS card-mark Immediate
 6153 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6154 %{
 6155   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6156   match(Set mem (StoreCM mem zero));
 6157 
 6158   ins_cost(125); // XXX
 6159   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6160   ins_encode %{
 6161     __ movb($mem$$Address, r12);
 6162   %}
 6163   ins_pipe(ialu_mem_reg);
 6164 %}
 6165 
 6166 instruct storeImmCM0(memory mem, immI0 src)
 6167 %{
 6168   match(Set mem (StoreCM mem src));
 6169 
 6170   ins_cost(150); // XXX
 6171   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6172   opcode(0xC6); /* C6 /0 */
 6173   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6174   ins_pipe(ialu_mem_imm);
 6175 %}
 6176 
 6177 // Store Float
 6178 instruct storeF(memory mem, regF src)
 6179 %{
 6180   match(Set mem (StoreF mem src));
 6181 
 6182   ins_cost(95); // XXX
 6183   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6184   ins_encode %{
 6185     __ movflt($mem$$Address, $src$$XMMRegister);
 6186   %}
 6187   ins_pipe(pipe_slow); // XXX
 6188 %}
 6189 
 6190 // Store immediate Float value (it is faster than store from XMM register)
 6191 instruct storeF0(memory mem, immF0 zero)
 6192 %{
 6193   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6194   match(Set mem (StoreF mem zero));
 6195 
 6196   ins_cost(25); // XXX
 6197   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6198   ins_encode %{
 6199     __ movl($mem$$Address, r12);
 6200   %}
 6201   ins_pipe(ialu_mem_reg);
 6202 %}
 6203 
 6204 instruct storeF_imm(memory mem, immF src)
 6205 %{
 6206   match(Set mem (StoreF mem src));
 6207 
 6208   ins_cost(50);
 6209   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6210   opcode(0xC7); /* C7 /0 */
 6211   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6212   ins_pipe(ialu_mem_imm);
 6213 %}
 6214 
 6215 // Store Double
 6216 instruct storeD(memory mem, regD src)
 6217 %{
 6218   match(Set mem (StoreD mem src));
 6219 
 6220   ins_cost(95); // XXX
 6221   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6222   ins_encode %{
 6223     __ movdbl($mem$$Address, $src$$XMMRegister);
 6224   %}
 6225   ins_pipe(pipe_slow); // XXX
 6226 %}
 6227 
 6228 // Store immediate double 0.0 (it is faster than store from XMM register)
 6229 instruct storeD0_imm(memory mem, immD0 src)
 6230 %{
 6231   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6232   match(Set mem (StoreD mem src));
 6233 
 6234   ins_cost(50);
 6235   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6236   opcode(0xC7); /* C7 /0 */
 6237   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6238   ins_pipe(ialu_mem_imm);
 6239 %}
 6240 
 6241 instruct storeD0(memory mem, immD0 zero)
 6242 %{
 6243   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6244   match(Set mem (StoreD mem zero));
 6245 
 6246   ins_cost(25); // XXX
 6247   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6248   ins_encode %{
 6249     __ movq($mem$$Address, r12);
 6250   %}
 6251   ins_pipe(ialu_mem_reg);
 6252 %}
 6253 
 6254 instruct storeSSI(stackSlotI dst, rRegI src)
 6255 %{
 6256   match(Set dst src);
 6257 
 6258   ins_cost(100);
 6259   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6260   opcode(0x89);
 6261   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6262   ins_pipe( ialu_mem_reg );
 6263 %}
 6264 
 6265 instruct storeSSL(stackSlotL dst, rRegL src)
 6266 %{
 6267   match(Set dst src);
 6268 
 6269   ins_cost(100);
 6270   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6271   opcode(0x89);
 6272   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6273   ins_pipe(ialu_mem_reg);
 6274 %}
 6275 
 6276 instruct storeSSP(stackSlotP dst, rRegP src)
 6277 %{
 6278   match(Set dst src);
 6279 
 6280   ins_cost(100);
 6281   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6282   opcode(0x89);
 6283   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6284   ins_pipe(ialu_mem_reg);
 6285 %}
 6286 
 6287 instruct storeSSF(stackSlotF dst, regF src)
 6288 %{
 6289   match(Set dst src);
 6290 
 6291   ins_cost(95); // XXX
 6292   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6293   ins_encode %{
 6294     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6295   %}
 6296   ins_pipe(pipe_slow); // XXX
 6297 %}
 6298 
 6299 instruct storeSSD(stackSlotD dst, regD src)
 6300 %{
 6301   match(Set dst src);
 6302 
 6303   ins_cost(95); // XXX
 6304   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6305   ins_encode %{
 6306     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6307   %}
 6308   ins_pipe(pipe_slow); // XXX
 6309 %}
 6310 
 6311 instruct cacheWB(indirect addr)
 6312 %{
 6313   predicate(VM_Version::supports_data_cache_line_flush());
 6314   match(CacheWB addr);
 6315 
 6316   ins_cost(100);
 6317   format %{&quot;cache wb $addr&quot; %}
 6318   ins_encode %{
 6319     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6320     assert($addr$$disp == 0, &quot;should be&quot;);
 6321     __ cache_wb(Address($addr$$base$$Register, 0));
 6322   %}
 6323   ins_pipe(pipe_slow); // XXX
 6324 %}
 6325 
 6326 instruct cacheWBPreSync()
 6327 %{
 6328   predicate(VM_Version::supports_data_cache_line_flush());
 6329   match(CacheWBPreSync);
 6330 
 6331   ins_cost(100);
 6332   format %{&quot;cache wb presync&quot; %}
 6333   ins_encode %{
 6334     __ cache_wbsync(true);
 6335   %}
 6336   ins_pipe(pipe_slow); // XXX
 6337 %}
 6338 
 6339 instruct cacheWBPostSync()
 6340 %{
 6341   predicate(VM_Version::supports_data_cache_line_flush());
 6342   match(CacheWBPostSync);
 6343 
 6344   ins_cost(100);
 6345   format %{&quot;cache wb postsync&quot; %}
 6346   ins_encode %{
 6347     __ cache_wbsync(false);
 6348   %}
 6349   ins_pipe(pipe_slow); // XXX
 6350 %}
 6351 
 6352 //----------BSWAP Instructions-------------------------------------------------
 6353 instruct bytes_reverse_int(rRegI dst) %{
 6354   match(Set dst (ReverseBytesI dst));
 6355 
 6356   format %{ &quot;bswapl  $dst&quot; %}
 6357   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6358   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6359   ins_pipe( ialu_reg );
 6360 %}
 6361 
 6362 instruct bytes_reverse_long(rRegL dst) %{
 6363   match(Set dst (ReverseBytesL dst));
 6364 
 6365   format %{ &quot;bswapq  $dst&quot; %}
 6366   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6367   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6368   ins_pipe( ialu_reg);
 6369 %}
 6370 
 6371 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6372   match(Set dst (ReverseBytesUS dst));
 6373   effect(KILL cr);
 6374 
 6375   format %{ &quot;bswapl  $dst\n\t&quot;
 6376             &quot;shrl    $dst,16\n\t&quot; %}
 6377   ins_encode %{
 6378     __ bswapl($dst$$Register);
 6379     __ shrl($dst$$Register, 16);
 6380   %}
 6381   ins_pipe( ialu_reg );
 6382 %}
 6383 
 6384 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6385   match(Set dst (ReverseBytesS dst));
 6386   effect(KILL cr);
 6387 
 6388   format %{ &quot;bswapl  $dst\n\t&quot;
 6389             &quot;sar     $dst,16\n\t&quot; %}
 6390   ins_encode %{
 6391     __ bswapl($dst$$Register);
 6392     __ sarl($dst$$Register, 16);
 6393   %}
 6394   ins_pipe( ialu_reg );
 6395 %}
 6396 
 6397 //---------- Zeros Count Instructions ------------------------------------------
 6398 
 6399 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6400   predicate(UseCountLeadingZerosInstruction);
 6401   match(Set dst (CountLeadingZerosI src));
 6402   effect(KILL cr);
 6403 
 6404   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6405   ins_encode %{
 6406     __ lzcntl($dst$$Register, $src$$Register);
 6407   %}
 6408   ins_pipe(ialu_reg);
 6409 %}
 6410 
 6411 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6412   predicate(!UseCountLeadingZerosInstruction);
 6413   match(Set dst (CountLeadingZerosI src));
 6414   effect(KILL cr);
 6415 
 6416   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6417             &quot;jnz     skip\n\t&quot;
 6418             &quot;movl    $dst, -1\n&quot;
 6419       &quot;skip:\n\t&quot;
 6420             &quot;negl    $dst\n\t&quot;
 6421             &quot;addl    $dst, 31&quot; %}
 6422   ins_encode %{
 6423     Register Rdst = $dst$$Register;
 6424     Register Rsrc = $src$$Register;
 6425     Label skip;
 6426     __ bsrl(Rdst, Rsrc);
 6427     __ jccb(Assembler::notZero, skip);
 6428     __ movl(Rdst, -1);
 6429     __ bind(skip);
 6430     __ negl(Rdst);
 6431     __ addl(Rdst, BitsPerInt - 1);
 6432   %}
 6433   ins_pipe(ialu_reg);
 6434 %}
 6435 
 6436 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6437   predicate(UseCountLeadingZerosInstruction);
 6438   match(Set dst (CountLeadingZerosL src));
 6439   effect(KILL cr);
 6440 
 6441   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6442   ins_encode %{
 6443     __ lzcntq($dst$$Register, $src$$Register);
 6444   %}
 6445   ins_pipe(ialu_reg);
 6446 %}
 6447 
 6448 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6449   predicate(!UseCountLeadingZerosInstruction);
 6450   match(Set dst (CountLeadingZerosL src));
 6451   effect(KILL cr);
 6452 
 6453   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6454             &quot;jnz     skip\n\t&quot;
 6455             &quot;movl    $dst, -1\n&quot;
 6456       &quot;skip:\n\t&quot;
 6457             &quot;negl    $dst\n\t&quot;
 6458             &quot;addl    $dst, 63&quot; %}
 6459   ins_encode %{
 6460     Register Rdst = $dst$$Register;
 6461     Register Rsrc = $src$$Register;
 6462     Label skip;
 6463     __ bsrq(Rdst, Rsrc);
 6464     __ jccb(Assembler::notZero, skip);
 6465     __ movl(Rdst, -1);
 6466     __ bind(skip);
 6467     __ negl(Rdst);
 6468     __ addl(Rdst, BitsPerLong - 1);
 6469   %}
 6470   ins_pipe(ialu_reg);
 6471 %}
 6472 
 6473 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6474   predicate(UseCountTrailingZerosInstruction);
 6475   match(Set dst (CountTrailingZerosI src));
 6476   effect(KILL cr);
 6477 
 6478   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6479   ins_encode %{
 6480     __ tzcntl($dst$$Register, $src$$Register);
 6481   %}
 6482   ins_pipe(ialu_reg);
 6483 %}
 6484 
 6485 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6486   predicate(!UseCountTrailingZerosInstruction);
 6487   match(Set dst (CountTrailingZerosI src));
 6488   effect(KILL cr);
 6489 
 6490   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6491             &quot;jnz     done\n\t&quot;
 6492             &quot;movl    $dst, 32\n&quot;
 6493       &quot;done:&quot; %}
 6494   ins_encode %{
 6495     Register Rdst = $dst$$Register;
 6496     Label done;
 6497     __ bsfl(Rdst, $src$$Register);
 6498     __ jccb(Assembler::notZero, done);
 6499     __ movl(Rdst, BitsPerInt);
 6500     __ bind(done);
 6501   %}
 6502   ins_pipe(ialu_reg);
 6503 %}
 6504 
 6505 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6506   predicate(UseCountTrailingZerosInstruction);
 6507   match(Set dst (CountTrailingZerosL src));
 6508   effect(KILL cr);
 6509 
 6510   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6511   ins_encode %{
 6512     __ tzcntq($dst$$Register, $src$$Register);
 6513   %}
 6514   ins_pipe(ialu_reg);
 6515 %}
 6516 
 6517 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6518   predicate(!UseCountTrailingZerosInstruction);
 6519   match(Set dst (CountTrailingZerosL src));
 6520   effect(KILL cr);
 6521 
 6522   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6523             &quot;jnz     done\n\t&quot;
 6524             &quot;movl    $dst, 64\n&quot;
 6525       &quot;done:&quot; %}
 6526   ins_encode %{
 6527     Register Rdst = $dst$$Register;
 6528     Label done;
 6529     __ bsfq(Rdst, $src$$Register);
 6530     __ jccb(Assembler::notZero, done);
 6531     __ movl(Rdst, BitsPerLong);
 6532     __ bind(done);
 6533   %}
 6534   ins_pipe(ialu_reg);
 6535 %}
 6536 
 6537 
 6538 //---------- Population Count Instructions -------------------------------------
 6539 
 6540 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6541   predicate(UsePopCountInstruction);
 6542   match(Set dst (PopCountI src));
 6543   effect(KILL cr);
 6544 
 6545   format %{ &quot;popcnt  $dst, $src&quot; %}
 6546   ins_encode %{
 6547     __ popcntl($dst$$Register, $src$$Register);
 6548   %}
 6549   ins_pipe(ialu_reg);
 6550 %}
 6551 
 6552 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6553   predicate(UsePopCountInstruction);
 6554   match(Set dst (PopCountI (LoadI mem)));
 6555   effect(KILL cr);
 6556 
 6557   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6558   ins_encode %{
 6559     __ popcntl($dst$$Register, $mem$$Address);
 6560   %}
 6561   ins_pipe(ialu_reg);
 6562 %}
 6563 
 6564 // Note: Long.bitCount(long) returns an int.
 6565 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6566   predicate(UsePopCountInstruction);
 6567   match(Set dst (PopCountL src));
 6568   effect(KILL cr);
 6569 
 6570   format %{ &quot;popcnt  $dst, $src&quot; %}
 6571   ins_encode %{
 6572     __ popcntq($dst$$Register, $src$$Register);
 6573   %}
 6574   ins_pipe(ialu_reg);
 6575 %}
 6576 
 6577 // Note: Long.bitCount(long) returns an int.
 6578 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6579   predicate(UsePopCountInstruction);
 6580   match(Set dst (PopCountL (LoadL mem)));
 6581   effect(KILL cr);
 6582 
 6583   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6584   ins_encode %{
 6585     __ popcntq($dst$$Register, $mem$$Address);
 6586   %}
 6587   ins_pipe(ialu_reg);
 6588 %}
 6589 
 6590 
 6591 //----------MemBar Instructions-----------------------------------------------
 6592 // Memory barrier flavors
 6593 
 6594 instruct membar_acquire()
 6595 %{
 6596   match(MemBarAcquire);
 6597   match(LoadFence);
 6598   ins_cost(0);
 6599 
 6600   size(0);
 6601   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6602   ins_encode();
 6603   ins_pipe(empty);
 6604 %}
 6605 
 6606 instruct membar_acquire_lock()
 6607 %{
 6608   match(MemBarAcquireLock);
 6609   ins_cost(0);
 6610 
 6611   size(0);
 6612   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6613   ins_encode();
 6614   ins_pipe(empty);
 6615 %}
 6616 
 6617 instruct membar_release()
 6618 %{
 6619   match(MemBarRelease);
 6620   match(StoreFence);
 6621   ins_cost(0);
 6622 
 6623   size(0);
 6624   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6625   ins_encode();
 6626   ins_pipe(empty);
 6627 %}
 6628 
 6629 instruct membar_release_lock()
 6630 %{
 6631   match(MemBarReleaseLock);
 6632   ins_cost(0);
 6633 
 6634   size(0);
 6635   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6636   ins_encode();
 6637   ins_pipe(empty);
 6638 %}
 6639 
 6640 instruct membar_volatile(rFlagsReg cr) %{
 6641   match(MemBarVolatile);
 6642   effect(KILL cr);
 6643   ins_cost(400);
 6644 
 6645   format %{
 6646     $$template
 6647     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6648   %}
 6649   ins_encode %{
 6650     __ membar(Assembler::StoreLoad);
 6651   %}
 6652   ins_pipe(pipe_slow);
 6653 %}
 6654 
 6655 instruct unnecessary_membar_volatile()
 6656 %{
 6657   match(MemBarVolatile);
 6658   predicate(Matcher::post_store_load_barrier(n));
 6659   ins_cost(0);
 6660 
 6661   size(0);
 6662   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6663   ins_encode();
 6664   ins_pipe(empty);
 6665 %}
 6666 
 6667 instruct membar_storestore() %{
 6668   match(MemBarStoreStore);
 6669   ins_cost(0);
 6670 
 6671   size(0);
 6672   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6673   ins_encode( );
 6674   ins_pipe(empty);
 6675 %}
 6676 
 6677 //----------Move Instructions--------------------------------------------------
 6678 
 6679 instruct castX2P(rRegP dst, rRegL src)
 6680 %{
 6681   match(Set dst (CastX2P src));
 6682 
 6683   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6684   ins_encode %{
 6685     if ($dst$$reg != $src$$reg) {
 6686       __ movptr($dst$$Register, $src$$Register);
 6687     }
 6688   %}
 6689   ins_pipe(ialu_reg_reg); // XXX
 6690 %}
 6691 
 6692 instruct castP2X(rRegL dst, rRegP src)
 6693 %{
 6694   match(Set dst (CastP2X src));
 6695 
 6696   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6697   ins_encode %{
 6698     if ($dst$$reg != $src$$reg) {
 6699       __ movptr($dst$$Register, $src$$Register);
 6700     }
 6701   %}
 6702   ins_pipe(ialu_reg_reg); // XXX
 6703 %}
 6704 
 6705 // Convert oop into int for vectors alignment masking
 6706 instruct convP2I(rRegI dst, rRegP src)
 6707 %{
 6708   match(Set dst (ConvL2I (CastP2X src)));
 6709 
 6710   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6711   ins_encode %{
 6712     __ movl($dst$$Register, $src$$Register);
 6713   %}
 6714   ins_pipe(ialu_reg_reg); // XXX
 6715 %}
 6716 
 6717 // Convert compressed oop into int for vectors alignment masking
 6718 // in case of 32bit oops (heap &lt; 4Gb).
 6719 instruct convN2I(rRegI dst, rRegN src)
 6720 %{
 6721   predicate(CompressedOops::shift() == 0);
 6722   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6723 
 6724   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6725   ins_encode %{
 6726     __ movl($dst$$Register, $src$$Register);
 6727   %}
 6728   ins_pipe(ialu_reg_reg); // XXX
 6729 %}
 6730 
 6731 // Convert oop pointer into compressed form
 6732 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6733   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6734   match(Set dst (EncodeP src));
 6735   effect(KILL cr);
 6736   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6737   ins_encode %{
 6738     Register s = $src$$Register;
 6739     Register d = $dst$$Register;
 6740     if (s != d) {
 6741       __ movq(d, s);
 6742     }
 6743     __ encode_heap_oop(d);
 6744   %}
 6745   ins_pipe(ialu_reg_long);
 6746 %}
 6747 
 6748 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6749   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6750   match(Set dst (EncodeP src));
 6751   effect(KILL cr);
 6752   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6753   ins_encode %{
 6754     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6755   %}
 6756   ins_pipe(ialu_reg_long);
 6757 %}
 6758 
 6759 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6760   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6761             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6762   match(Set dst (DecodeN src));
 6763   effect(KILL cr);
 6764   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6765   ins_encode %{
 6766     Register s = $src$$Register;
 6767     Register d = $dst$$Register;
 6768     if (s != d) {
 6769       __ movq(d, s);
 6770     }
 6771     __ decode_heap_oop(d);
 6772   %}
 6773   ins_pipe(ialu_reg_long);
 6774 %}
 6775 
 6776 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6777   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6778             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6779   match(Set dst (DecodeN src));
 6780   effect(KILL cr);
 6781   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6782   ins_encode %{
 6783     Register s = $src$$Register;
 6784     Register d = $dst$$Register;
 6785     if (s != d) {
 6786       __ decode_heap_oop_not_null(d, s);
 6787     } else {
 6788       __ decode_heap_oop_not_null(d);
 6789     }
 6790   %}
 6791   ins_pipe(ialu_reg_long);
 6792 %}
 6793 
 6794 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6795   match(Set dst (EncodePKlass src));
 6796   effect(TEMP dst, KILL cr);
 6797   format %{ &quot;encode_and_move_klass_not_null $dst,$src&quot; %}
 6798   ins_encode %{
 6799     __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6800   %}
 6801   ins_pipe(ialu_reg_long);
 6802 %}
 6803 
 6804 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6805   match(Set dst (DecodeNKlass src));
 6806   effect(TEMP dst, KILL cr);
 6807   format %{ &quot;decode_and_move_klass_not_null $dst,$src&quot; %}
 6808   ins_encode %{
 6809     __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6810   %}
 6811   ins_pipe(ialu_reg_long);
 6812 %}
 6813 
 6814 //----------Conditional Move---------------------------------------------------
 6815 // Jump
 6816 // dummy instruction for generating temp registers
 6817 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6818   match(Jump (LShiftL switch_val shift));
 6819   ins_cost(350);
 6820   predicate(false);
 6821   effect(TEMP dest);
 6822 
 6823   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6824             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6825   ins_encode %{
 6826     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6827     // to do that and the compiler is using that register as one it can allocate.
 6828     // So we build it all by hand.
 6829     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6830     // ArrayAddress dispatch(table, index);
 6831     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6832     __ lea($dest$$Register, $constantaddress);
 6833     __ jmp(dispatch);
 6834   %}
 6835   ins_pipe(pipe_jmp);
 6836 %}
 6837 
 6838 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6839   match(Jump (AddL (LShiftL switch_val shift) offset));
 6840   ins_cost(350);
 6841   effect(TEMP dest);
 6842 
 6843   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6844             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6845   ins_encode %{
 6846     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6847     // to do that and the compiler is using that register as one it can allocate.
 6848     // So we build it all by hand.
 6849     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6850     // ArrayAddress dispatch(table, index);
 6851     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6852     __ lea($dest$$Register, $constantaddress);
 6853     __ jmp(dispatch);
 6854   %}
 6855   ins_pipe(pipe_jmp);
 6856 %}
 6857 
 6858 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6859   match(Jump switch_val);
 6860   ins_cost(350);
 6861   effect(TEMP dest);
 6862 
 6863   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6864             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6865   ins_encode %{
 6866     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6867     // to do that and the compiler is using that register as one it can allocate.
 6868     // So we build it all by hand.
 6869     // Address index(noreg, switch_reg, Address::times_1);
 6870     // ArrayAddress dispatch(table, index);
 6871     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6872     __ lea($dest$$Register, $constantaddress);
 6873     __ jmp(dispatch);
 6874   %}
 6875   ins_pipe(pipe_jmp);
 6876 %}
 6877 
 6878 // Conditional move
 6879 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6880 %{
 6881   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6882 
 6883   ins_cost(200); // XXX
 6884   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6885   opcode(0x0F, 0x40);
 6886   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6887   ins_pipe(pipe_cmov_reg);
 6888 %}
 6889 
 6890 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6891   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6892 
 6893   ins_cost(200); // XXX
 6894   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6895   opcode(0x0F, 0x40);
 6896   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6897   ins_pipe(pipe_cmov_reg);
 6898 %}
 6899 
 6900 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6901   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6902   ins_cost(200);
 6903   expand %{
 6904     cmovI_regU(cop, cr, dst, src);
 6905   %}
 6906 %}
 6907 
 6908 // Conditional move
 6909 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6910   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6911 
 6912   ins_cost(250); // XXX
 6913   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6914   opcode(0x0F, 0x40);
 6915   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6916   ins_pipe(pipe_cmov_mem);
 6917 %}
 6918 
 6919 // Conditional move
 6920 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 6921 %{
 6922   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6923 
 6924   ins_cost(250); // XXX
 6925   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6926   opcode(0x0F, 0x40);
 6927   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6928   ins_pipe(pipe_cmov_mem);
 6929 %}
 6930 
 6931 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 6932   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6933   ins_cost(250);
 6934   expand %{
 6935     cmovI_memU(cop, cr, dst, src);
 6936   %}
 6937 %}
 6938 
 6939 // Conditional move
 6940 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 6941 %{
 6942   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6943 
 6944   ins_cost(200); // XXX
 6945   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 6946   opcode(0x0F, 0x40);
 6947   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6948   ins_pipe(pipe_cmov_reg);
 6949 %}
 6950 
 6951 // Conditional move
 6952 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 6953 %{
 6954   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6955 
 6956   ins_cost(200); // XXX
 6957   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 6958   opcode(0x0F, 0x40);
 6959   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6960   ins_pipe(pipe_cmov_reg);
 6961 %}
 6962 
 6963 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 6964   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6965   ins_cost(200);
 6966   expand %{
 6967     cmovN_regU(cop, cr, dst, src);
 6968   %}
 6969 %}
 6970 
 6971 // Conditional move
 6972 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 6973 %{
 6974   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6975 
 6976   ins_cost(200); // XXX
 6977   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 6978   opcode(0x0F, 0x40);
 6979   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6980   ins_pipe(pipe_cmov_reg);  // XXX
 6981 %}
 6982 
 6983 // Conditional move
 6984 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 6985 %{
 6986   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6987 
 6988   ins_cost(200); // XXX
 6989   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 6990   opcode(0x0F, 0x40);
 6991   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6992   ins_pipe(pipe_cmov_reg); // XXX
 6993 %}
 6994 
 6995 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 6996   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6997   ins_cost(200);
 6998   expand %{
 6999     cmovP_regU(cop, cr, dst, src);
 7000   %}
 7001 %}
 7002 
 7003 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7004 // correctly meets the two pointer arguments; one is an incoming
 7005 // register but the other is a memory operand.  ALSO appears to
 7006 // be buggy with implicit null checks.
 7007 //
 7008 //// Conditional move
 7009 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7010 //%{
 7011 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7012 //  ins_cost(250);
 7013 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7014 //  opcode(0x0F,0x40);
 7015 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7016 //  ins_pipe( pipe_cmov_mem );
 7017 //%}
 7018 //
 7019 //// Conditional move
 7020 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7021 //%{
 7022 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7023 //  ins_cost(250);
 7024 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7025 //  opcode(0x0F,0x40);
 7026 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7027 //  ins_pipe( pipe_cmov_mem );
 7028 //%}
 7029 
 7030 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7031 %{
 7032   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7033 
 7034   ins_cost(200); // XXX
 7035   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7036   opcode(0x0F, 0x40);
 7037   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7038   ins_pipe(pipe_cmov_reg);  // XXX
 7039 %}
 7040 
 7041 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7042 %{
 7043   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7044 
 7045   ins_cost(200); // XXX
 7046   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7047   opcode(0x0F, 0x40);
 7048   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7049   ins_pipe(pipe_cmov_mem);  // XXX
 7050 %}
 7051 
 7052 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7053 %{
 7054   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7055 
 7056   ins_cost(200); // XXX
 7057   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7058   opcode(0x0F, 0x40);
 7059   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7060   ins_pipe(pipe_cmov_reg); // XXX
 7061 %}
 7062 
 7063 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7064   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7065   ins_cost(200);
 7066   expand %{
 7067     cmovL_regU(cop, cr, dst, src);
 7068   %}
 7069 %}
 7070 
 7071 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7072 %{
 7073   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7074 
 7075   ins_cost(200); // XXX
 7076   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7077   opcode(0x0F, 0x40);
 7078   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7079   ins_pipe(pipe_cmov_mem); // XXX
 7080 %}
 7081 
 7082 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7083   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7084   ins_cost(200);
 7085   expand %{
 7086     cmovL_memU(cop, cr, dst, src);
 7087   %}
 7088 %}
 7089 
 7090 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7091 %{
 7092   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7093 
 7094   ins_cost(200); // XXX
 7095   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7096             &quot;movss     $dst, $src\n&quot;
 7097     &quot;skip:&quot; %}
 7098   ins_encode %{
 7099     Label Lskip;
 7100     // Invert sense of branch from sense of CMOV
 7101     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7102     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7103     __ bind(Lskip);
 7104   %}
 7105   ins_pipe(pipe_slow);
 7106 %}
 7107 
 7108 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7109 // %{
 7110 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7111 
 7112 //   ins_cost(200); // XXX
 7113 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7114 //             &quot;movss     $dst, $src\n&quot;
 7115 //     &quot;skip:&quot; %}
 7116 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7117 //   ins_pipe(pipe_slow);
 7118 // %}
 7119 
 7120 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7121 %{
 7122   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7123 
 7124   ins_cost(200); // XXX
 7125   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7126             &quot;movss     $dst, $src\n&quot;
 7127     &quot;skip:&quot; %}
 7128   ins_encode %{
 7129     Label Lskip;
 7130     // Invert sense of branch from sense of CMOV
 7131     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7132     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7133     __ bind(Lskip);
 7134   %}
 7135   ins_pipe(pipe_slow);
 7136 %}
 7137 
 7138 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7139   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7140   ins_cost(200);
 7141   expand %{
 7142     cmovF_regU(cop, cr, dst, src);
 7143   %}
 7144 %}
 7145 
 7146 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7147 %{
 7148   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7149 
 7150   ins_cost(200); // XXX
 7151   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7152             &quot;movsd     $dst, $src\n&quot;
 7153     &quot;skip:&quot; %}
 7154   ins_encode %{
 7155     Label Lskip;
 7156     // Invert sense of branch from sense of CMOV
 7157     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7158     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7159     __ bind(Lskip);
 7160   %}
 7161   ins_pipe(pipe_slow);
 7162 %}
 7163 
 7164 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7165 %{
 7166   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7167 
 7168   ins_cost(200); // XXX
 7169   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7170             &quot;movsd     $dst, $src\n&quot;
 7171     &quot;skip:&quot; %}
 7172   ins_encode %{
 7173     Label Lskip;
 7174     // Invert sense of branch from sense of CMOV
 7175     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7176     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7177     __ bind(Lskip);
 7178   %}
 7179   ins_pipe(pipe_slow);
 7180 %}
 7181 
 7182 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7183   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7184   ins_cost(200);
 7185   expand %{
 7186     cmovD_regU(cop, cr, dst, src);
 7187   %}
 7188 %}
 7189 
 7190 //----------Arithmetic Instructions--------------------------------------------
 7191 //----------Addition Instructions----------------------------------------------
 7192 
 7193 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7194 %{
 7195   match(Set dst (AddI dst src));
 7196   effect(KILL cr);
 7197 
 7198   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7199   opcode(0x03);
 7200   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7201   ins_pipe(ialu_reg_reg);
 7202 %}
 7203 
 7204 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7205 %{
 7206   match(Set dst (AddI dst src));
 7207   effect(KILL cr);
 7208 
 7209   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7210   opcode(0x81, 0x00); /* /0 id */
 7211   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7212   ins_pipe( ialu_reg );
 7213 %}
 7214 
 7215 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7216 %{
 7217   match(Set dst (AddI dst (LoadI src)));
 7218   effect(KILL cr);
 7219 
 7220   ins_cost(125); // XXX
 7221   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7222   opcode(0x03);
 7223   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7224   ins_pipe(ialu_reg_mem);
 7225 %}
 7226 
 7227 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7228 %{
 7229   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7230   effect(KILL cr);
 7231 
 7232   ins_cost(150); // XXX
 7233   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7234   opcode(0x01); /* Opcode 01 /r */
 7235   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7236   ins_pipe(ialu_mem_reg);
 7237 %}
 7238 
 7239 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7240 %{
 7241   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7242   effect(KILL cr);
 7243 
 7244   ins_cost(125); // XXX
 7245   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7246   opcode(0x81); /* Opcode 81 /0 id */
 7247   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7248   ins_pipe(ialu_mem_imm);
 7249 %}
 7250 
 7251 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7252 %{
 7253   predicate(UseIncDec);
 7254   match(Set dst (AddI dst src));
 7255   effect(KILL cr);
 7256 
 7257   format %{ &quot;incl    $dst\t# int&quot; %}
 7258   opcode(0xFF, 0x00); // FF /0
 7259   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7260   ins_pipe(ialu_reg);
 7261 %}
 7262 
 7263 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7264 %{
 7265   predicate(UseIncDec);
 7266   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7267   effect(KILL cr);
 7268 
 7269   ins_cost(125); // XXX
 7270   format %{ &quot;incl    $dst\t# int&quot; %}
 7271   opcode(0xFF); /* Opcode FF /0 */
 7272   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7273   ins_pipe(ialu_mem_imm);
 7274 %}
 7275 
 7276 // XXX why does that use AddI
 7277 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7278 %{
 7279   predicate(UseIncDec);
 7280   match(Set dst (AddI dst src));
 7281   effect(KILL cr);
 7282 
 7283   format %{ &quot;decl    $dst\t# int&quot; %}
 7284   opcode(0xFF, 0x01); // FF /1
 7285   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7286   ins_pipe(ialu_reg);
 7287 %}
 7288 
 7289 // XXX why does that use AddI
 7290 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7291 %{
 7292   predicate(UseIncDec);
 7293   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7294   effect(KILL cr);
 7295 
 7296   ins_cost(125); // XXX
 7297   format %{ &quot;decl    $dst\t# int&quot; %}
 7298   opcode(0xFF); /* Opcode FF /1 */
 7299   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7300   ins_pipe(ialu_mem_imm);
 7301 %}
 7302 
 7303 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7304 %{
 7305   match(Set dst (AddI src0 src1));
 7306 
 7307   ins_cost(110);
 7308   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7309   opcode(0x8D); /* 0x8D /r */
 7310   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7311   ins_pipe(ialu_reg_reg);
 7312 %}
 7313 
 7314 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7315 %{
 7316   match(Set dst (AddL dst src));
 7317   effect(KILL cr);
 7318 
 7319   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7320   opcode(0x03);
 7321   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7322   ins_pipe(ialu_reg_reg);
 7323 %}
 7324 
 7325 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7326 %{
 7327   match(Set dst (AddL dst src));
 7328   effect(KILL cr);
 7329 
 7330   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7331   opcode(0x81, 0x00); /* /0 id */
 7332   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7333   ins_pipe( ialu_reg );
 7334 %}
 7335 
 7336 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7337 %{
 7338   match(Set dst (AddL dst (LoadL src)));
 7339   effect(KILL cr);
 7340 
 7341   ins_cost(125); // XXX
 7342   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7343   opcode(0x03);
 7344   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7345   ins_pipe(ialu_reg_mem);
 7346 %}
 7347 
 7348 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7349 %{
 7350   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7351   effect(KILL cr);
 7352 
 7353   ins_cost(150); // XXX
 7354   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7355   opcode(0x01); /* Opcode 01 /r */
 7356   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7357   ins_pipe(ialu_mem_reg);
 7358 %}
 7359 
 7360 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7361 %{
 7362   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7363   effect(KILL cr);
 7364 
 7365   ins_cost(125); // XXX
 7366   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7367   opcode(0x81); /* Opcode 81 /0 id */
 7368   ins_encode(REX_mem_wide(dst),
 7369              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7370   ins_pipe(ialu_mem_imm);
 7371 %}
 7372 
 7373 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7374 %{
 7375   predicate(UseIncDec);
 7376   match(Set dst (AddL dst src));
 7377   effect(KILL cr);
 7378 
 7379   format %{ &quot;incq    $dst\t# long&quot; %}
 7380   opcode(0xFF, 0x00); // FF /0
 7381   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7382   ins_pipe(ialu_reg);
 7383 %}
 7384 
 7385 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7386 %{
 7387   predicate(UseIncDec);
 7388   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7389   effect(KILL cr);
 7390 
 7391   ins_cost(125); // XXX
 7392   format %{ &quot;incq    $dst\t# long&quot; %}
 7393   opcode(0xFF); /* Opcode FF /0 */
 7394   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7395   ins_pipe(ialu_mem_imm);
 7396 %}
 7397 
 7398 // XXX why does that use AddL
 7399 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7400 %{
 7401   predicate(UseIncDec);
 7402   match(Set dst (AddL dst src));
 7403   effect(KILL cr);
 7404 
 7405   format %{ &quot;decq    $dst\t# long&quot; %}
 7406   opcode(0xFF, 0x01); // FF /1
 7407   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7408   ins_pipe(ialu_reg);
 7409 %}
 7410 
 7411 // XXX why does that use AddL
 7412 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7413 %{
 7414   predicate(UseIncDec);
 7415   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7416   effect(KILL cr);
 7417 
 7418   ins_cost(125); // XXX
 7419   format %{ &quot;decq    $dst\t# long&quot; %}
 7420   opcode(0xFF); /* Opcode FF /1 */
 7421   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7422   ins_pipe(ialu_mem_imm);
 7423 %}
 7424 
 7425 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7426 %{
 7427   match(Set dst (AddL src0 src1));
 7428 
 7429   ins_cost(110);
 7430   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7431   opcode(0x8D); /* 0x8D /r */
 7432   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7433   ins_pipe(ialu_reg_reg);
 7434 %}
 7435 
 7436 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7437 %{
 7438   match(Set dst (AddP dst src));
 7439   effect(KILL cr);
 7440 
 7441   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7442   opcode(0x03);
 7443   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7444   ins_pipe(ialu_reg_reg);
 7445 %}
 7446 
 7447 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7448 %{
 7449   match(Set dst (AddP dst src));
 7450   effect(KILL cr);
 7451 
 7452   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7453   opcode(0x81, 0x00); /* /0 id */
 7454   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7455   ins_pipe( ialu_reg );
 7456 %}
 7457 
 7458 // XXX addP mem ops ????
 7459 
 7460 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7461 %{
 7462   match(Set dst (AddP src0 src1));
 7463 
 7464   ins_cost(110);
 7465   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7466   opcode(0x8D); /* 0x8D /r */
 7467   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7468   ins_pipe(ialu_reg_reg);
 7469 %}
 7470 
 7471 instruct checkCastPP(rRegP dst)
 7472 %{
 7473   match(Set dst (CheckCastPP dst));
 7474 
 7475   size(0);
 7476   format %{ &quot;# checkcastPP of $dst&quot; %}
 7477   ins_encode(/* empty encoding */);
 7478   ins_pipe(empty);
 7479 %}
 7480 
 7481 instruct castPP(rRegP dst)
 7482 %{
 7483   match(Set dst (CastPP dst));
 7484 
 7485   size(0);
 7486   format %{ &quot;# castPP of $dst&quot; %}
 7487   ins_encode(/* empty encoding */);
 7488   ins_pipe(empty);
 7489 %}
 7490 
 7491 instruct castII(rRegI dst)
 7492 %{
 7493   match(Set dst (CastII dst));
 7494 
 7495   size(0);
 7496   format %{ &quot;# castII of $dst&quot; %}
 7497   ins_encode(/* empty encoding */);
 7498   ins_cost(0);
 7499   ins_pipe(empty);
 7500 %}
 7501 
 7502 // LoadP-locked same as a regular LoadP when used with compare-swap
 7503 instruct loadPLocked(rRegP dst, memory mem)
 7504 %{
 7505   match(Set dst (LoadPLocked mem));
 7506 
 7507   ins_cost(125); // XXX
 7508   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7509   opcode(0x8B);
 7510   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7511   ins_pipe(ialu_reg_mem); // XXX
 7512 %}
 7513 
 7514 // Conditional-store of the updated heap-top.
 7515 // Used during allocation of the shared heap.
 7516 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7517 
 7518 instruct storePConditional(memory heap_top_ptr,
 7519                            rax_RegP oldval, rRegP newval,
 7520                            rFlagsReg cr)
 7521 %{
 7522   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7523   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7524 
 7525   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7526             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7527   opcode(0x0F, 0xB1);
 7528   ins_encode(lock_prefix,
 7529              REX_reg_mem_wide(newval, heap_top_ptr),
 7530              OpcP, OpcS,
 7531              reg_mem(newval, heap_top_ptr));
 7532   ins_pipe(pipe_cmpxchg);
 7533 %}
 7534 
 7535 // Conditional-store of an int value.
 7536 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7537 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7538 %{
 7539   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7540   effect(KILL oldval);
 7541 
 7542   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7543   opcode(0x0F, 0xB1);
 7544   ins_encode(lock_prefix,
 7545              REX_reg_mem(newval, mem),
 7546              OpcP, OpcS,
 7547              reg_mem(newval, mem));
 7548   ins_pipe(pipe_cmpxchg);
 7549 %}
 7550 
 7551 // Conditional-store of a long value.
 7552 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7553 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7554 %{
 7555   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7556   effect(KILL oldval);
 7557 
 7558   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7559   opcode(0x0F, 0xB1);
 7560   ins_encode(lock_prefix,
 7561              REX_reg_mem_wide(newval, mem),
 7562              OpcP, OpcS,
 7563              reg_mem(newval, mem));
 7564   ins_pipe(pipe_cmpxchg);
 7565 %}
 7566 
 7567 
 7568 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7569 instruct compareAndSwapP(rRegI res,
 7570                          memory mem_ptr,
 7571                          rax_RegP oldval, rRegP newval,
 7572                          rFlagsReg cr)
 7573 %{
 7574   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7575   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7576   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7577   effect(KILL cr, KILL oldval);
 7578 
 7579   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7580             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7581             &quot;sete    $res\n\t&quot;
 7582             &quot;movzbl  $res, $res&quot; %}
 7583   opcode(0x0F, 0xB1);
 7584   ins_encode(lock_prefix,
 7585              REX_reg_mem_wide(newval, mem_ptr),
 7586              OpcP, OpcS,
 7587              reg_mem(newval, mem_ptr),
 7588              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7589              REX_reg_breg(res, res), // movzbl
 7590              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7591   ins_pipe( pipe_cmpxchg );
 7592 %}
 7593 
 7594 instruct compareAndSwapL(rRegI res,
 7595                          memory mem_ptr,
 7596                          rax_RegL oldval, rRegL newval,
 7597                          rFlagsReg cr)
 7598 %{
 7599   predicate(VM_Version::supports_cx8());
 7600   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7601   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7602   effect(KILL cr, KILL oldval);
 7603 
 7604   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7605             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7606             &quot;sete    $res\n\t&quot;
 7607             &quot;movzbl  $res, $res&quot; %}
 7608   opcode(0x0F, 0xB1);
 7609   ins_encode(lock_prefix,
 7610              REX_reg_mem_wide(newval, mem_ptr),
 7611              OpcP, OpcS,
 7612              reg_mem(newval, mem_ptr),
 7613              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7614              REX_reg_breg(res, res), // movzbl
 7615              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7616   ins_pipe( pipe_cmpxchg );
 7617 %}
 7618 
 7619 instruct compareAndSwapI(rRegI res,
 7620                          memory mem_ptr,
 7621                          rax_RegI oldval, rRegI newval,
 7622                          rFlagsReg cr)
 7623 %{
 7624   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7625   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7626   effect(KILL cr, KILL oldval);
 7627 
 7628   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7629             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7630             &quot;sete    $res\n\t&quot;
 7631             &quot;movzbl  $res, $res&quot; %}
 7632   opcode(0x0F, 0xB1);
 7633   ins_encode(lock_prefix,
 7634              REX_reg_mem(newval, mem_ptr),
 7635              OpcP, OpcS,
 7636              reg_mem(newval, mem_ptr),
 7637              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7638              REX_reg_breg(res, res), // movzbl
 7639              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7640   ins_pipe( pipe_cmpxchg );
 7641 %}
 7642 
 7643 instruct compareAndSwapB(rRegI res,
 7644                          memory mem_ptr,
 7645                          rax_RegI oldval, rRegI newval,
 7646                          rFlagsReg cr)
 7647 %{
 7648   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7649   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7650   effect(KILL cr, KILL oldval);
 7651 
 7652   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7653             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7654             &quot;sete    $res\n\t&quot;
 7655             &quot;movzbl  $res, $res&quot; %}
 7656   opcode(0x0F, 0xB0);
 7657   ins_encode(lock_prefix,
 7658              REX_breg_mem(newval, mem_ptr),
 7659              OpcP, OpcS,
 7660              reg_mem(newval, mem_ptr),
 7661              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7662              REX_reg_breg(res, res), // movzbl
 7663              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7664   ins_pipe( pipe_cmpxchg );
 7665 %}
 7666 
 7667 instruct compareAndSwapS(rRegI res,
 7668                          memory mem_ptr,
 7669                          rax_RegI oldval, rRegI newval,
 7670                          rFlagsReg cr)
 7671 %{
 7672   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7673   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7674   effect(KILL cr, KILL oldval);
 7675 
 7676   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7677             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7678             &quot;sete    $res\n\t&quot;
 7679             &quot;movzbl  $res, $res&quot; %}
 7680   opcode(0x0F, 0xB1);
 7681   ins_encode(lock_prefix,
 7682              SizePrefix,
 7683              REX_reg_mem(newval, mem_ptr),
 7684              OpcP, OpcS,
 7685              reg_mem(newval, mem_ptr),
 7686              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7687              REX_reg_breg(res, res), // movzbl
 7688              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7689   ins_pipe( pipe_cmpxchg );
 7690 %}
 7691 
 7692 instruct compareAndSwapN(rRegI res,
 7693                           memory mem_ptr,
 7694                           rax_RegN oldval, rRegN newval,
 7695                           rFlagsReg cr) %{
 7696   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7697   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7698   effect(KILL cr, KILL oldval);
 7699 
 7700   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7701             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7702             &quot;sete    $res\n\t&quot;
 7703             &quot;movzbl  $res, $res&quot; %}
 7704   opcode(0x0F, 0xB1);
 7705   ins_encode(lock_prefix,
 7706              REX_reg_mem(newval, mem_ptr),
 7707              OpcP, OpcS,
 7708              reg_mem(newval, mem_ptr),
 7709              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7710              REX_reg_breg(res, res), // movzbl
 7711              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7712   ins_pipe( pipe_cmpxchg );
 7713 %}
 7714 
 7715 instruct compareAndExchangeB(
 7716                          memory mem_ptr,
 7717                          rax_RegI oldval, rRegI newval,
 7718                          rFlagsReg cr)
 7719 %{
 7720   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7721   effect(KILL cr);
 7722 
 7723   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7724             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7725   opcode(0x0F, 0xB0);
 7726   ins_encode(lock_prefix,
 7727              REX_breg_mem(newval, mem_ptr),
 7728              OpcP, OpcS,
 7729              reg_mem(newval, mem_ptr) // lock cmpxchg
 7730              );
 7731   ins_pipe( pipe_cmpxchg );
 7732 %}
 7733 
 7734 instruct compareAndExchangeS(
 7735                          memory mem_ptr,
 7736                          rax_RegI oldval, rRegI newval,
 7737                          rFlagsReg cr)
 7738 %{
 7739   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7740   effect(KILL cr);
 7741 
 7742   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7743             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7744   opcode(0x0F, 0xB1);
 7745   ins_encode(lock_prefix,
 7746              SizePrefix,
 7747              REX_reg_mem(newval, mem_ptr),
 7748              OpcP, OpcS,
 7749              reg_mem(newval, mem_ptr) // lock cmpxchg
 7750              );
 7751   ins_pipe( pipe_cmpxchg );
 7752 %}
 7753 
 7754 instruct compareAndExchangeI(
 7755                          memory mem_ptr,
 7756                          rax_RegI oldval, rRegI newval,
 7757                          rFlagsReg cr)
 7758 %{
 7759   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7760   effect(KILL cr);
 7761 
 7762   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7763             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7764   opcode(0x0F, 0xB1);
 7765   ins_encode(lock_prefix,
 7766              REX_reg_mem(newval, mem_ptr),
 7767              OpcP, OpcS,
 7768              reg_mem(newval, mem_ptr) // lock cmpxchg
 7769              );
 7770   ins_pipe( pipe_cmpxchg );
 7771 %}
 7772 
 7773 instruct compareAndExchangeL(
 7774                          memory mem_ptr,
 7775                          rax_RegL oldval, rRegL newval,
 7776                          rFlagsReg cr)
 7777 %{
 7778   predicate(VM_Version::supports_cx8());
 7779   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7780   effect(KILL cr);
 7781 
 7782   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7783             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7784   opcode(0x0F, 0xB1);
 7785   ins_encode(lock_prefix,
 7786              REX_reg_mem_wide(newval, mem_ptr),
 7787              OpcP, OpcS,
 7788              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7789             );
 7790   ins_pipe( pipe_cmpxchg );
 7791 %}
 7792 
 7793 instruct compareAndExchangeN(
 7794                           memory mem_ptr,
 7795                           rax_RegN oldval, rRegN newval,
 7796                           rFlagsReg cr) %{
 7797   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7798   effect(KILL cr);
 7799 
 7800   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7801             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7802   opcode(0x0F, 0xB1);
 7803   ins_encode(lock_prefix,
 7804              REX_reg_mem(newval, mem_ptr),
 7805              OpcP, OpcS,
 7806              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7807           );
 7808   ins_pipe( pipe_cmpxchg );
 7809 %}
 7810 
 7811 instruct compareAndExchangeP(
 7812                          memory mem_ptr,
 7813                          rax_RegP oldval, rRegP newval,
 7814                          rFlagsReg cr)
 7815 %{
 7816   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7817   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7818   effect(KILL cr);
 7819 
 7820   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7821             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7822   opcode(0x0F, 0xB1);
 7823   ins_encode(lock_prefix,
 7824              REX_reg_mem_wide(newval, mem_ptr),
 7825              OpcP, OpcS,
 7826              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7827           );
 7828   ins_pipe( pipe_cmpxchg );
 7829 %}
 7830 
 7831 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7832   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7833   match(Set dummy (GetAndAddB mem add));
 7834   effect(KILL cr);
 7835   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7836   ins_encode %{
 7837     __ lock();
 7838     __ addb($mem$$Address, $add$$constant);
 7839   %}
 7840   ins_pipe( pipe_cmpxchg );
 7841 %}
 7842 
 7843 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7844   match(Set newval (GetAndAddB mem newval));
 7845   effect(KILL cr);
 7846   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7847   ins_encode %{
 7848     __ lock();
 7849     __ xaddb($mem$$Address, $newval$$Register);
 7850   %}
 7851   ins_pipe( pipe_cmpxchg );
 7852 %}
 7853 
 7854 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7855   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7856   match(Set dummy (GetAndAddS mem add));
 7857   effect(KILL cr);
 7858   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7859   ins_encode %{
 7860     __ lock();
 7861     __ addw($mem$$Address, $add$$constant);
 7862   %}
 7863   ins_pipe( pipe_cmpxchg );
 7864 %}
 7865 
 7866 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7867   match(Set newval (GetAndAddS mem newval));
 7868   effect(KILL cr);
 7869   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7870   ins_encode %{
 7871     __ lock();
 7872     __ xaddw($mem$$Address, $newval$$Register);
 7873   %}
 7874   ins_pipe( pipe_cmpxchg );
 7875 %}
 7876 
 7877 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7878   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7879   match(Set dummy (GetAndAddI mem add));
 7880   effect(KILL cr);
 7881   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7882   ins_encode %{
 7883     __ lock();
 7884     __ addl($mem$$Address, $add$$constant);
 7885   %}
 7886   ins_pipe( pipe_cmpxchg );
 7887 %}
 7888 
 7889 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7890   match(Set newval (GetAndAddI mem newval));
 7891   effect(KILL cr);
 7892   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7893   ins_encode %{
 7894     __ lock();
 7895     __ xaddl($mem$$Address, $newval$$Register);
 7896   %}
 7897   ins_pipe( pipe_cmpxchg );
 7898 %}
 7899 
 7900 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7901   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7902   match(Set dummy (GetAndAddL mem add));
 7903   effect(KILL cr);
 7904   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 7905   ins_encode %{
 7906     __ lock();
 7907     __ addq($mem$$Address, $add$$constant);
 7908   %}
 7909   ins_pipe( pipe_cmpxchg );
 7910 %}
 7911 
 7912 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 7913   match(Set newval (GetAndAddL mem newval));
 7914   effect(KILL cr);
 7915   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 7916   ins_encode %{
 7917     __ lock();
 7918     __ xaddq($mem$$Address, $newval$$Register);
 7919   %}
 7920   ins_pipe( pipe_cmpxchg );
 7921 %}
 7922 
 7923 instruct xchgB( memory mem, rRegI newval) %{
 7924   match(Set newval (GetAndSetB mem newval));
 7925   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7926   ins_encode %{
 7927     __ xchgb($newval$$Register, $mem$$Address);
 7928   %}
 7929   ins_pipe( pipe_cmpxchg );
 7930 %}
 7931 
 7932 instruct xchgS( memory mem, rRegI newval) %{
 7933   match(Set newval (GetAndSetS mem newval));
 7934   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7935   ins_encode %{
 7936     __ xchgw($newval$$Register, $mem$$Address);
 7937   %}
 7938   ins_pipe( pipe_cmpxchg );
 7939 %}
 7940 
 7941 instruct xchgI( memory mem, rRegI newval) %{
 7942   match(Set newval (GetAndSetI mem newval));
 7943   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7944   ins_encode %{
 7945     __ xchgl($newval$$Register, $mem$$Address);
 7946   %}
 7947   ins_pipe( pipe_cmpxchg );
 7948 %}
 7949 
 7950 instruct xchgL( memory mem, rRegL newval) %{
 7951   match(Set newval (GetAndSetL mem newval));
 7952   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7953   ins_encode %{
 7954     __ xchgq($newval$$Register, $mem$$Address);
 7955   %}
 7956   ins_pipe( pipe_cmpxchg );
 7957 %}
 7958 
 7959 instruct xchgP( memory mem, rRegP newval) %{
 7960   match(Set newval (GetAndSetP mem newval));
 7961   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7962   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 7963   ins_encode %{
 7964     __ xchgq($newval$$Register, $mem$$Address);
 7965   %}
 7966   ins_pipe( pipe_cmpxchg );
 7967 %}
 7968 
 7969 instruct xchgN( memory mem, rRegN newval) %{
 7970   match(Set newval (GetAndSetN mem newval));
 7971   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 7972   ins_encode %{
 7973     __ xchgl($newval$$Register, $mem$$Address);
 7974   %}
 7975   ins_pipe( pipe_cmpxchg );
 7976 %}
 7977 
 7978 //----------Abs Instructions-------------------------------------------
 7979 
 7980 // Integer Absolute Instructions
 7981 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 7982 %{
 7983   match(Set dst (AbsI src));
 7984   effect(TEMP dst, TEMP tmp, KILL cr);
 7985   format %{ &quot;movl $tmp, $src\n\t&quot;
 7986             &quot;sarl $tmp, 31\n\t&quot;
 7987             &quot;movl $dst, $src\n\t&quot;
 7988             &quot;xorl $dst, $tmp\n\t&quot;
 7989             &quot;subl $dst, $tmp\n&quot;
 7990           %}
 7991   ins_encode %{
 7992     __ movl($tmp$$Register, $src$$Register);
 7993     __ sarl($tmp$$Register, 31);
 7994     __ movl($dst$$Register, $src$$Register);
 7995     __ xorl($dst$$Register, $tmp$$Register);
 7996     __ subl($dst$$Register, $tmp$$Register);
 7997   %}
 7998 
 7999   ins_pipe(ialu_reg_reg);
 8000 %}
 8001 
 8002 // Long Absolute Instructions
 8003 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8004 %{
 8005   match(Set dst (AbsL src));
 8006   effect(TEMP dst, TEMP tmp, KILL cr);
 8007   format %{ &quot;movq $tmp, $src\n\t&quot;
 8008             &quot;sarq $tmp, 63\n\t&quot;
 8009             &quot;movq $dst, $src\n\t&quot;
 8010             &quot;xorq $dst, $tmp\n\t&quot;
 8011             &quot;subq $dst, $tmp\n&quot;
 8012           %}
 8013   ins_encode %{
 8014     __ movq($tmp$$Register, $src$$Register);
 8015     __ sarq($tmp$$Register, 63);
 8016     __ movq($dst$$Register, $src$$Register);
 8017     __ xorq($dst$$Register, $tmp$$Register);
 8018     __ subq($dst$$Register, $tmp$$Register);
 8019   %}
 8020 
 8021   ins_pipe(ialu_reg_reg);
 8022 %}
 8023 
 8024 //----------Subtraction Instructions-------------------------------------------
 8025 
 8026 // Integer Subtraction Instructions
 8027 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8028 %{
 8029   match(Set dst (SubI dst src));
 8030   effect(KILL cr);
 8031 
 8032   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8033   opcode(0x2B);
 8034   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8035   ins_pipe(ialu_reg_reg);
 8036 %}
 8037 
 8038 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8039 %{
 8040   match(Set dst (SubI dst src));
 8041   effect(KILL cr);
 8042 
 8043   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8044   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8045   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8046   ins_pipe(ialu_reg);
 8047 %}
 8048 
 8049 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8050 %{
 8051   match(Set dst (SubI dst (LoadI src)));
 8052   effect(KILL cr);
 8053 
 8054   ins_cost(125);
 8055   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8056   opcode(0x2B);
 8057   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8058   ins_pipe(ialu_reg_mem);
 8059 %}
 8060 
 8061 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8062 %{
 8063   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8064   effect(KILL cr);
 8065 
 8066   ins_cost(150);
 8067   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8068   opcode(0x29); /* Opcode 29 /r */
 8069   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8070   ins_pipe(ialu_mem_reg);
 8071 %}
 8072 
 8073 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8074 %{
 8075   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8076   effect(KILL cr);
 8077 
 8078   ins_cost(125); // XXX
 8079   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8080   opcode(0x81); /* Opcode 81 /5 id */
 8081   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8082   ins_pipe(ialu_mem_imm);
 8083 %}
 8084 
 8085 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8086 %{
 8087   match(Set dst (SubL dst src));
 8088   effect(KILL cr);
 8089 
 8090   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8091   opcode(0x2B);
 8092   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8093   ins_pipe(ialu_reg_reg);
 8094 %}
 8095 
 8096 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8097 %{
 8098   match(Set dst (SubL dst src));
 8099   effect(KILL cr);
 8100 
 8101   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8102   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8103   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8104   ins_pipe(ialu_reg);
 8105 %}
 8106 
 8107 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8108 %{
 8109   match(Set dst (SubL dst (LoadL src)));
 8110   effect(KILL cr);
 8111 
 8112   ins_cost(125);
 8113   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8114   opcode(0x2B);
 8115   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8116   ins_pipe(ialu_reg_mem);
 8117 %}
 8118 
 8119 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8120 %{
 8121   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8122   effect(KILL cr);
 8123 
 8124   ins_cost(150);
 8125   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8126   opcode(0x29); /* Opcode 29 /r */
 8127   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8128   ins_pipe(ialu_mem_reg);
 8129 %}
 8130 
 8131 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8132 %{
 8133   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8134   effect(KILL cr);
 8135 
 8136   ins_cost(125); // XXX
 8137   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8138   opcode(0x81); /* Opcode 81 /5 id */
 8139   ins_encode(REX_mem_wide(dst),
 8140              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8141   ins_pipe(ialu_mem_imm);
 8142 %}
 8143 
 8144 // Subtract from a pointer
 8145 // XXX hmpf???
 8146 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8147 %{
 8148   match(Set dst (AddP dst (SubI zero src)));
 8149   effect(KILL cr);
 8150 
 8151   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8152   opcode(0x2B);
 8153   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8154   ins_pipe(ialu_reg_reg);
 8155 %}
 8156 
 8157 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8158 %{
 8159   match(Set dst (SubI zero dst));
 8160   effect(KILL cr);
 8161 
 8162   format %{ &quot;negl    $dst\t# int&quot; %}
 8163   opcode(0xF7, 0x03);  // Opcode F7 /3
 8164   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8165   ins_pipe(ialu_reg);
 8166 %}
 8167 
 8168 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8169 %{
 8170   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8171   effect(KILL cr);
 8172 
 8173   format %{ &quot;negl    $dst\t# int&quot; %}
 8174   opcode(0xF7, 0x03);  // Opcode F7 /3
 8175   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8176   ins_pipe(ialu_reg);
 8177 %}
 8178 
 8179 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8180 %{
 8181   match(Set dst (SubL zero dst));
 8182   effect(KILL cr);
 8183 
 8184   format %{ &quot;negq    $dst\t# long&quot; %}
 8185   opcode(0xF7, 0x03);  // Opcode F7 /3
 8186   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8187   ins_pipe(ialu_reg);
 8188 %}
 8189 
 8190 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8191 %{
 8192   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8193   effect(KILL cr);
 8194 
 8195   format %{ &quot;negq    $dst\t# long&quot; %}
 8196   opcode(0xF7, 0x03);  // Opcode F7 /3
 8197   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8198   ins_pipe(ialu_reg);
 8199 %}
 8200 
 8201 //----------Multiplication/Division Instructions-------------------------------
 8202 // Integer Multiplication Instructions
 8203 // Multiply Register
 8204 
 8205 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8206 %{
 8207   match(Set dst (MulI dst src));
 8208   effect(KILL cr);
 8209 
 8210   ins_cost(300);
 8211   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8212   opcode(0x0F, 0xAF);
 8213   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8214   ins_pipe(ialu_reg_reg_alu0);
 8215 %}
 8216 
 8217 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8218 %{
 8219   match(Set dst (MulI src imm));
 8220   effect(KILL cr);
 8221 
 8222   ins_cost(300);
 8223   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8224   opcode(0x69); /* 69 /r id */
 8225   ins_encode(REX_reg_reg(dst, src),
 8226              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8227   ins_pipe(ialu_reg_reg_alu0);
 8228 %}
 8229 
 8230 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8231 %{
 8232   match(Set dst (MulI dst (LoadI src)));
 8233   effect(KILL cr);
 8234 
 8235   ins_cost(350);
 8236   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8237   opcode(0x0F, 0xAF);
 8238   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8239   ins_pipe(ialu_reg_mem_alu0);
 8240 %}
 8241 
 8242 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8243 %{
 8244   match(Set dst (MulI (LoadI src) imm));
 8245   effect(KILL cr);
 8246 
 8247   ins_cost(300);
 8248   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8249   opcode(0x69); /* 69 /r id */
 8250   ins_encode(REX_reg_mem(dst, src),
 8251              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8252   ins_pipe(ialu_reg_mem_alu0);
 8253 %}
 8254 
 8255 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8256 %{
 8257   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8258   effect(KILL cr, KILL src2);
 8259 
 8260   expand %{ mulI_rReg(dst, src1, cr);
 8261            mulI_rReg(src2, src3, cr);
 8262            addI_rReg(dst, src2, cr); %}
 8263 %}
 8264 
 8265 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8266 %{
 8267   match(Set dst (MulL dst src));
 8268   effect(KILL cr);
 8269 
 8270   ins_cost(300);
 8271   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8272   opcode(0x0F, 0xAF);
 8273   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8274   ins_pipe(ialu_reg_reg_alu0);
 8275 %}
 8276 
 8277 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8278 %{
 8279   match(Set dst (MulL src imm));
 8280   effect(KILL cr);
 8281 
 8282   ins_cost(300);
 8283   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8284   opcode(0x69); /* 69 /r id */
 8285   ins_encode(REX_reg_reg_wide(dst, src),
 8286              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8287   ins_pipe(ialu_reg_reg_alu0);
 8288 %}
 8289 
 8290 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8291 %{
 8292   match(Set dst (MulL dst (LoadL src)));
 8293   effect(KILL cr);
 8294 
 8295   ins_cost(350);
 8296   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8297   opcode(0x0F, 0xAF);
 8298   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8299   ins_pipe(ialu_reg_mem_alu0);
 8300 %}
 8301 
 8302 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8303 %{
 8304   match(Set dst (MulL (LoadL src) imm));
 8305   effect(KILL cr);
 8306 
 8307   ins_cost(300);
 8308   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8309   opcode(0x69); /* 69 /r id */
 8310   ins_encode(REX_reg_mem_wide(dst, src),
 8311              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8312   ins_pipe(ialu_reg_mem_alu0);
 8313 %}
 8314 
 8315 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8316 %{
 8317   match(Set dst (MulHiL src rax));
 8318   effect(USE_KILL rax, KILL cr);
 8319 
 8320   ins_cost(300);
 8321   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8322   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8323   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8324   ins_pipe(ialu_reg_reg_alu0);
 8325 %}
 8326 
 8327 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8328                    rFlagsReg cr)
 8329 %{
 8330   match(Set rax (DivI rax div));
 8331   effect(KILL rdx, KILL cr);
 8332 
 8333   ins_cost(30*100+10*100); // XXX
 8334   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8335             &quot;jne,s   normal\n\t&quot;
 8336             &quot;xorl    rdx, rdx\n\t&quot;
 8337             &quot;cmpl    $div, -1\n\t&quot;
 8338             &quot;je,s    done\n&quot;
 8339     &quot;normal: cdql\n\t&quot;
 8340             &quot;idivl   $div\n&quot;
 8341     &quot;done:&quot;        %}
 8342   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8343   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8344   ins_pipe(ialu_reg_reg_alu0);
 8345 %}
 8346 
 8347 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8348                    rFlagsReg cr)
 8349 %{
 8350   match(Set rax (DivL rax div));
 8351   effect(KILL rdx, KILL cr);
 8352 
 8353   ins_cost(30*100+10*100); // XXX
 8354   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8355             &quot;cmpq    rax, rdx\n\t&quot;
 8356             &quot;jne,s   normal\n\t&quot;
 8357             &quot;xorl    rdx, rdx\n\t&quot;
 8358             &quot;cmpq    $div, -1\n\t&quot;
 8359             &quot;je,s    done\n&quot;
 8360     &quot;normal: cdqq\n\t&quot;
 8361             &quot;idivq   $div\n&quot;
 8362     &quot;done:&quot;        %}
 8363   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8364   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8365   ins_pipe(ialu_reg_reg_alu0);
 8366 %}
 8367 
 8368 // Integer DIVMOD with Register, both quotient and mod results
 8369 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8370                              rFlagsReg cr)
 8371 %{
 8372   match(DivModI rax div);
 8373   effect(KILL cr);
 8374 
 8375   ins_cost(30*100+10*100); // XXX
 8376   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8377             &quot;jne,s   normal\n\t&quot;
 8378             &quot;xorl    rdx, rdx\n\t&quot;
 8379             &quot;cmpl    $div, -1\n\t&quot;
 8380             &quot;je,s    done\n&quot;
 8381     &quot;normal: cdql\n\t&quot;
 8382             &quot;idivl   $div\n&quot;
 8383     &quot;done:&quot;        %}
 8384   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8385   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8386   ins_pipe(pipe_slow);
 8387 %}
 8388 
 8389 // Long DIVMOD with Register, both quotient and mod results
 8390 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8391                              rFlagsReg cr)
 8392 %{
 8393   match(DivModL rax div);
 8394   effect(KILL cr);
 8395 
 8396   ins_cost(30*100+10*100); // XXX
 8397   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8398             &quot;cmpq    rax, rdx\n\t&quot;
 8399             &quot;jne,s   normal\n\t&quot;
 8400             &quot;xorl    rdx, rdx\n\t&quot;
 8401             &quot;cmpq    $div, -1\n\t&quot;
 8402             &quot;je,s    done\n&quot;
 8403     &quot;normal: cdqq\n\t&quot;
 8404             &quot;idivq   $div\n&quot;
 8405     &quot;done:&quot;        %}
 8406   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8407   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8408   ins_pipe(pipe_slow);
 8409 %}
 8410 
 8411 //----------- DivL-By-Constant-Expansions--------------------------------------
 8412 // DivI cases are handled by the compiler
 8413 
 8414 // Magic constant, reciprocal of 10
 8415 instruct loadConL_0x6666666666666667(rRegL dst)
 8416 %{
 8417   effect(DEF dst);
 8418 
 8419   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8420   ins_encode(load_immL(dst, 0x6666666666666667));
 8421   ins_pipe(ialu_reg);
 8422 %}
 8423 
 8424 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8425 %{
 8426   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8427 
 8428   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8429   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8430   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8431   ins_pipe(ialu_reg_reg_alu0);
 8432 %}
 8433 
 8434 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8435 %{
 8436   effect(USE_DEF dst, KILL cr);
 8437 
 8438   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8439   opcode(0xC1, 0x7); /* C1 /7 ib */
 8440   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8441   ins_pipe(ialu_reg);
 8442 %}
 8443 
 8444 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8445 %{
 8446   effect(USE_DEF dst, KILL cr);
 8447 
 8448   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8449   opcode(0xC1, 0x7); /* C1 /7 ib */
 8450   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8451   ins_pipe(ialu_reg);
 8452 %}
 8453 
 8454 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8455 %{
 8456   match(Set dst (DivL src div));
 8457 
 8458   ins_cost((5+8)*100);
 8459   expand %{
 8460     rax_RegL rax;                     // Killed temp
 8461     rFlagsReg cr;                     // Killed
 8462     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8463     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8464     sarL_rReg_63(src, cr);            // sarq  src, 63
 8465     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8466     subL_rReg(dst, src, cr);          // subl  rdx, src
 8467   %}
 8468 %}
 8469 
 8470 //-----------------------------------------------------------------------------
 8471 
 8472 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8473                    rFlagsReg cr)
 8474 %{
 8475   match(Set rdx (ModI rax div));
 8476   effect(KILL rax, KILL cr);
 8477 
 8478   ins_cost(300); // XXX
 8479   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8480             &quot;jne,s   normal\n\t&quot;
 8481             &quot;xorl    rdx, rdx\n\t&quot;
 8482             &quot;cmpl    $div, -1\n\t&quot;
 8483             &quot;je,s    done\n&quot;
 8484     &quot;normal: cdql\n\t&quot;
 8485             &quot;idivl   $div\n&quot;
 8486     &quot;done:&quot;        %}
 8487   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8488   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8489   ins_pipe(ialu_reg_reg_alu0);
 8490 %}
 8491 
 8492 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8493                    rFlagsReg cr)
 8494 %{
 8495   match(Set rdx (ModL rax div));
 8496   effect(KILL rax, KILL cr);
 8497 
 8498   ins_cost(300); // XXX
 8499   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8500             &quot;cmpq    rax, rdx\n\t&quot;
 8501             &quot;jne,s   normal\n\t&quot;
 8502             &quot;xorl    rdx, rdx\n\t&quot;
 8503             &quot;cmpq    $div, -1\n\t&quot;
 8504             &quot;je,s    done\n&quot;
 8505     &quot;normal: cdqq\n\t&quot;
 8506             &quot;idivq   $div\n&quot;
 8507     &quot;done:&quot;        %}
 8508   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8509   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8510   ins_pipe(ialu_reg_reg_alu0);
 8511 %}
 8512 
 8513 // Integer Shift Instructions
 8514 // Shift Left by one
 8515 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8516 %{
 8517   match(Set dst (LShiftI dst shift));
 8518   effect(KILL cr);
 8519 
 8520   format %{ &quot;sall    $dst, $shift&quot; %}
 8521   opcode(0xD1, 0x4); /* D1 /4 */
 8522   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8523   ins_pipe(ialu_reg);
 8524 %}
 8525 
 8526 // Shift Left by one
 8527 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8528 %{
 8529   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8530   effect(KILL cr);
 8531 
 8532   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8533   opcode(0xD1, 0x4); /* D1 /4 */
 8534   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8535   ins_pipe(ialu_mem_imm);
 8536 %}
 8537 
 8538 // Shift Left by 8-bit immediate
 8539 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8540 %{
 8541   match(Set dst (LShiftI dst shift));
 8542   effect(KILL cr);
 8543 
 8544   format %{ &quot;sall    $dst, $shift&quot; %}
 8545   opcode(0xC1, 0x4); /* C1 /4 ib */
 8546   ins_encode(reg_opc_imm(dst, shift));
 8547   ins_pipe(ialu_reg);
 8548 %}
 8549 
 8550 // Shift Left by 8-bit immediate
 8551 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8552 %{
 8553   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8554   effect(KILL cr);
 8555 
 8556   format %{ &quot;sall    $dst, $shift&quot; %}
 8557   opcode(0xC1, 0x4); /* C1 /4 ib */
 8558   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8559   ins_pipe(ialu_mem_imm);
 8560 %}
 8561 
 8562 // Shift Left by variable
 8563 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8564 %{
 8565   match(Set dst (LShiftI dst shift));
 8566   effect(KILL cr);
 8567 
 8568   format %{ &quot;sall    $dst, $shift&quot; %}
 8569   opcode(0xD3, 0x4); /* D3 /4 */
 8570   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8571   ins_pipe(ialu_reg_reg);
 8572 %}
 8573 
 8574 // Shift Left by variable
 8575 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8576 %{
 8577   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8578   effect(KILL cr);
 8579 
 8580   format %{ &quot;sall    $dst, $shift&quot; %}
 8581   opcode(0xD3, 0x4); /* D3 /4 */
 8582   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8583   ins_pipe(ialu_mem_reg);
 8584 %}
 8585 
 8586 // Arithmetic shift right by one
 8587 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8588 %{
 8589   match(Set dst (RShiftI dst shift));
 8590   effect(KILL cr);
 8591 
 8592   format %{ &quot;sarl    $dst, $shift&quot; %}
 8593   opcode(0xD1, 0x7); /* D1 /7 */
 8594   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8595   ins_pipe(ialu_reg);
 8596 %}
 8597 
 8598 // Arithmetic shift right by one
 8599 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8600 %{
 8601   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8602   effect(KILL cr);
 8603 
 8604   format %{ &quot;sarl    $dst, $shift&quot; %}
 8605   opcode(0xD1, 0x7); /* D1 /7 */
 8606   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8607   ins_pipe(ialu_mem_imm);
 8608 %}
 8609 
 8610 // Arithmetic Shift Right by 8-bit immediate
 8611 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8612 %{
 8613   match(Set dst (RShiftI dst shift));
 8614   effect(KILL cr);
 8615 
 8616   format %{ &quot;sarl    $dst, $shift&quot; %}
 8617   opcode(0xC1, 0x7); /* C1 /7 ib */
 8618   ins_encode(reg_opc_imm(dst, shift));
 8619   ins_pipe(ialu_mem_imm);
 8620 %}
 8621 
 8622 // Arithmetic Shift Right by 8-bit immediate
 8623 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8624 %{
 8625   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8626   effect(KILL cr);
 8627 
 8628   format %{ &quot;sarl    $dst, $shift&quot; %}
 8629   opcode(0xC1, 0x7); /* C1 /7 ib */
 8630   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8631   ins_pipe(ialu_mem_imm);
 8632 %}
 8633 
 8634 // Arithmetic Shift Right by variable
 8635 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8636 %{
 8637   match(Set dst (RShiftI dst shift));
 8638   effect(KILL cr);
 8639 
 8640   format %{ &quot;sarl    $dst, $shift&quot; %}
 8641   opcode(0xD3, 0x7); /* D3 /7 */
 8642   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8643   ins_pipe(ialu_reg_reg);
 8644 %}
 8645 
 8646 // Arithmetic Shift Right by variable
 8647 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8648 %{
 8649   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8650   effect(KILL cr);
 8651 
 8652   format %{ &quot;sarl    $dst, $shift&quot; %}
 8653   opcode(0xD3, 0x7); /* D3 /7 */
 8654   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8655   ins_pipe(ialu_mem_reg);
 8656 %}
 8657 
 8658 // Logical shift right by one
 8659 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8660 %{
 8661   match(Set dst (URShiftI dst shift));
 8662   effect(KILL cr);
 8663 
 8664   format %{ &quot;shrl    $dst, $shift&quot; %}
 8665   opcode(0xD1, 0x5); /* D1 /5 */
 8666   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8667   ins_pipe(ialu_reg);
 8668 %}
 8669 
 8670 // Logical shift right by one
 8671 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8672 %{
 8673   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8674   effect(KILL cr);
 8675 
 8676   format %{ &quot;shrl    $dst, $shift&quot; %}
 8677   opcode(0xD1, 0x5); /* D1 /5 */
 8678   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8679   ins_pipe(ialu_mem_imm);
 8680 %}
 8681 
 8682 // Logical Shift Right by 8-bit immediate
 8683 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8684 %{
 8685   match(Set dst (URShiftI dst shift));
 8686   effect(KILL cr);
 8687 
 8688   format %{ &quot;shrl    $dst, $shift&quot; %}
 8689   opcode(0xC1, 0x5); /* C1 /5 ib */
 8690   ins_encode(reg_opc_imm(dst, shift));
 8691   ins_pipe(ialu_reg);
 8692 %}
 8693 
 8694 // Logical Shift Right by 8-bit immediate
 8695 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8696 %{
 8697   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8698   effect(KILL cr);
 8699 
 8700   format %{ &quot;shrl    $dst, $shift&quot; %}
 8701   opcode(0xC1, 0x5); /* C1 /5 ib */
 8702   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8703   ins_pipe(ialu_mem_imm);
 8704 %}
 8705 
 8706 // Logical Shift Right by variable
 8707 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8708 %{
 8709   match(Set dst (URShiftI dst shift));
 8710   effect(KILL cr);
 8711 
 8712   format %{ &quot;shrl    $dst, $shift&quot; %}
 8713   opcode(0xD3, 0x5); /* D3 /5 */
 8714   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8715   ins_pipe(ialu_reg_reg);
 8716 %}
 8717 
 8718 // Logical Shift Right by variable
 8719 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8720 %{
 8721   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8722   effect(KILL cr);
 8723 
 8724   format %{ &quot;shrl    $dst, $shift&quot; %}
 8725   opcode(0xD3, 0x5); /* D3 /5 */
 8726   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8727   ins_pipe(ialu_mem_reg);
 8728 %}
 8729 
 8730 // Long Shift Instructions
 8731 // Shift Left by one
 8732 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8733 %{
 8734   match(Set dst (LShiftL dst shift));
 8735   effect(KILL cr);
 8736 
 8737   format %{ &quot;salq    $dst, $shift&quot; %}
 8738   opcode(0xD1, 0x4); /* D1 /4 */
 8739   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8740   ins_pipe(ialu_reg);
 8741 %}
 8742 
 8743 // Shift Left by one
 8744 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8745 %{
 8746   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8747   effect(KILL cr);
 8748 
 8749   format %{ &quot;salq    $dst, $shift&quot; %}
 8750   opcode(0xD1, 0x4); /* D1 /4 */
 8751   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8752   ins_pipe(ialu_mem_imm);
 8753 %}
 8754 
 8755 // Shift Left by 8-bit immediate
 8756 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8757 %{
 8758   match(Set dst (LShiftL dst shift));
 8759   effect(KILL cr);
 8760 
 8761   format %{ &quot;salq    $dst, $shift&quot; %}
 8762   opcode(0xC1, 0x4); /* C1 /4 ib */
 8763   ins_encode(reg_opc_imm_wide(dst, shift));
 8764   ins_pipe(ialu_reg);
 8765 %}
 8766 
 8767 // Shift Left by 8-bit immediate
 8768 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8769 %{
 8770   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8771   effect(KILL cr);
 8772 
 8773   format %{ &quot;salq    $dst, $shift&quot; %}
 8774   opcode(0xC1, 0x4); /* C1 /4 ib */
 8775   ins_encode(REX_mem_wide(dst), OpcP,
 8776              RM_opc_mem(secondary, dst), Con8or32(shift));
 8777   ins_pipe(ialu_mem_imm);
 8778 %}
 8779 
 8780 // Shift Left by variable
 8781 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8782 %{
 8783   match(Set dst (LShiftL dst shift));
 8784   effect(KILL cr);
 8785 
 8786   format %{ &quot;salq    $dst, $shift&quot; %}
 8787   opcode(0xD3, 0x4); /* D3 /4 */
 8788   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8789   ins_pipe(ialu_reg_reg);
 8790 %}
 8791 
 8792 // Shift Left by variable
 8793 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8794 %{
 8795   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8796   effect(KILL cr);
 8797 
 8798   format %{ &quot;salq    $dst, $shift&quot; %}
 8799   opcode(0xD3, 0x4); /* D3 /4 */
 8800   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8801   ins_pipe(ialu_mem_reg);
 8802 %}
 8803 
 8804 // Arithmetic shift right by one
 8805 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8806 %{
 8807   match(Set dst (RShiftL dst shift));
 8808   effect(KILL cr);
 8809 
 8810   format %{ &quot;sarq    $dst, $shift&quot; %}
 8811   opcode(0xD1, 0x7); /* D1 /7 */
 8812   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8813   ins_pipe(ialu_reg);
 8814 %}
 8815 
 8816 // Arithmetic shift right by one
 8817 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8818 %{
 8819   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8820   effect(KILL cr);
 8821 
 8822   format %{ &quot;sarq    $dst, $shift&quot; %}
 8823   opcode(0xD1, 0x7); /* D1 /7 */
 8824   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8825   ins_pipe(ialu_mem_imm);
 8826 %}
 8827 
 8828 // Arithmetic Shift Right by 8-bit immediate
 8829 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8830 %{
 8831   match(Set dst (RShiftL dst shift));
 8832   effect(KILL cr);
 8833 
 8834   format %{ &quot;sarq    $dst, $shift&quot; %}
 8835   opcode(0xC1, 0x7); /* C1 /7 ib */
 8836   ins_encode(reg_opc_imm_wide(dst, shift));
 8837   ins_pipe(ialu_mem_imm);
 8838 %}
 8839 
 8840 // Arithmetic Shift Right by 8-bit immediate
 8841 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8842 %{
 8843   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8844   effect(KILL cr);
 8845 
 8846   format %{ &quot;sarq    $dst, $shift&quot; %}
 8847   opcode(0xC1, 0x7); /* C1 /7 ib */
 8848   ins_encode(REX_mem_wide(dst), OpcP,
 8849              RM_opc_mem(secondary, dst), Con8or32(shift));
 8850   ins_pipe(ialu_mem_imm);
 8851 %}
 8852 
 8853 // Arithmetic Shift Right by variable
 8854 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8855 %{
 8856   match(Set dst (RShiftL dst shift));
 8857   effect(KILL cr);
 8858 
 8859   format %{ &quot;sarq    $dst, $shift&quot; %}
 8860   opcode(0xD3, 0x7); /* D3 /7 */
 8861   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8862   ins_pipe(ialu_reg_reg);
 8863 %}
 8864 
 8865 // Arithmetic Shift Right by variable
 8866 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8867 %{
 8868   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8869   effect(KILL cr);
 8870 
 8871   format %{ &quot;sarq    $dst, $shift&quot; %}
 8872   opcode(0xD3, 0x7); /* D3 /7 */
 8873   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8874   ins_pipe(ialu_mem_reg);
 8875 %}
 8876 
 8877 // Logical shift right by one
 8878 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8879 %{
 8880   match(Set dst (URShiftL dst shift));
 8881   effect(KILL cr);
 8882 
 8883   format %{ &quot;shrq    $dst, $shift&quot; %}
 8884   opcode(0xD1, 0x5); /* D1 /5 */
 8885   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8886   ins_pipe(ialu_reg);
 8887 %}
 8888 
 8889 // Logical shift right by one
 8890 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8891 %{
 8892   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8893   effect(KILL cr);
 8894 
 8895   format %{ &quot;shrq    $dst, $shift&quot; %}
 8896   opcode(0xD1, 0x5); /* D1 /5 */
 8897   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8898   ins_pipe(ialu_mem_imm);
 8899 %}
 8900 
 8901 // Logical Shift Right by 8-bit immediate
 8902 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8903 %{
 8904   match(Set dst (URShiftL dst shift));
 8905   effect(KILL cr);
 8906 
 8907   format %{ &quot;shrq    $dst, $shift&quot; %}
 8908   opcode(0xC1, 0x5); /* C1 /5 ib */
 8909   ins_encode(reg_opc_imm_wide(dst, shift));
 8910   ins_pipe(ialu_reg);
 8911 %}
 8912 
 8913 
 8914 // Logical Shift Right by 8-bit immediate
 8915 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8916 %{
 8917   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8918   effect(KILL cr);
 8919 
 8920   format %{ &quot;shrq    $dst, $shift&quot; %}
 8921   opcode(0xC1, 0x5); /* C1 /5 ib */
 8922   ins_encode(REX_mem_wide(dst), OpcP,
 8923              RM_opc_mem(secondary, dst), Con8or32(shift));
 8924   ins_pipe(ialu_mem_imm);
 8925 %}
 8926 
 8927 // Logical Shift Right by variable
 8928 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8929 %{
 8930   match(Set dst (URShiftL dst shift));
 8931   effect(KILL cr);
 8932 
 8933   format %{ &quot;shrq    $dst, $shift&quot; %}
 8934   opcode(0xD3, 0x5); /* D3 /5 */
 8935   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8936   ins_pipe(ialu_reg_reg);
 8937 %}
 8938 
 8939 // Logical Shift Right by variable
 8940 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8941 %{
 8942   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8943   effect(KILL cr);
 8944 
 8945   format %{ &quot;shrq    $dst, $shift&quot; %}
 8946   opcode(0xD3, 0x5); /* D3 /5 */
 8947   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8948   ins_pipe(ialu_mem_reg);
 8949 %}
 8950 
 8951 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8952 // This idiom is used by the compiler for the i2b bytecode.
 8953 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 8954 %{
 8955   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8956 
 8957   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 8958   opcode(0x0F, 0xBE);
 8959   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8960   ins_pipe(ialu_reg_reg);
 8961 %}
 8962 
 8963 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8964 // This idiom is used by the compiler the i2s bytecode.
 8965 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 8966 %{
 8967   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8968 
 8969   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 8970   opcode(0x0F, 0xBF);
 8971   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8972   ins_pipe(ialu_reg_reg);
 8973 %}
 8974 
 8975 // ROL/ROR instructions
 8976 
 8977 // ROL expand
 8978 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 8979   effect(KILL cr, USE_DEF dst);
 8980 
 8981   format %{ &quot;roll    $dst&quot; %}
 8982   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 8983   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8984   ins_pipe(ialu_reg);
 8985 %}
 8986 
 8987 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 8988   effect(USE_DEF dst, USE shift, KILL cr);
 8989 
 8990   format %{ &quot;roll    $dst, $shift&quot; %}
 8991   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 8992   ins_encode( reg_opc_imm(dst, shift) );
 8993   ins_pipe(ialu_reg);
 8994 %}
 8995 
 8996 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 8997 %{
 8998   effect(USE_DEF dst, USE shift, KILL cr);
 8999 
 9000   format %{ &quot;roll    $dst, $shift&quot; %}
 9001   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9002   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9003   ins_pipe(ialu_reg_reg);
 9004 %}
 9005 // end of ROL expand
 9006 
 9007 // Rotate Left by one
 9008 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9009 %{
 9010   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9011 
 9012   expand %{
 9013     rolI_rReg_imm1(dst, cr);
 9014   %}
 9015 %}
 9016 
 9017 // Rotate Left by 8-bit immediate
 9018 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9019 %{
 9020   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9021   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9022 
 9023   expand %{
 9024     rolI_rReg_imm8(dst, lshift, cr);
 9025   %}
 9026 %}
 9027 
 9028 // Rotate Left by variable
 9029 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9030 %{
 9031   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9032 
 9033   expand %{
 9034     rolI_rReg_CL(dst, shift, cr);
 9035   %}
 9036 %}
 9037 
 9038 // Rotate Left by variable
 9039 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9040 %{
 9041   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9042 
 9043   expand %{
 9044     rolI_rReg_CL(dst, shift, cr);
 9045   %}
 9046 %}
 9047 
 9048 // ROR expand
 9049 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9050 %{
 9051   effect(USE_DEF dst, KILL cr);
 9052 
 9053   format %{ &quot;rorl    $dst&quot; %}
 9054   opcode(0xD1, 0x1); /* D1 /1 */
 9055   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9056   ins_pipe(ialu_reg);
 9057 %}
 9058 
 9059 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9060 %{
 9061   effect(USE_DEF dst, USE shift, KILL cr);
 9062 
 9063   format %{ &quot;rorl    $dst, $shift&quot; %}
 9064   opcode(0xC1, 0x1); /* C1 /1 ib */
 9065   ins_encode(reg_opc_imm(dst, shift));
 9066   ins_pipe(ialu_reg);
 9067 %}
 9068 
 9069 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9070 %{
 9071   effect(USE_DEF dst, USE shift, KILL cr);
 9072 
 9073   format %{ &quot;rorl    $dst, $shift&quot; %}
 9074   opcode(0xD3, 0x1); /* D3 /1 */
 9075   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9076   ins_pipe(ialu_reg_reg);
 9077 %}
 9078 // end of ROR expand
 9079 
 9080 // Rotate Right by one
 9081 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9082 %{
 9083   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9084 
 9085   expand %{
 9086     rorI_rReg_imm1(dst, cr);
 9087   %}
 9088 %}
 9089 
 9090 // Rotate Right by 8-bit immediate
 9091 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9092 %{
 9093   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9094   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9095 
 9096   expand %{
 9097     rorI_rReg_imm8(dst, rshift, cr);
 9098   %}
 9099 %}
 9100 
 9101 // Rotate Right by variable
 9102 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9103 %{
 9104   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9105 
 9106   expand %{
 9107     rorI_rReg_CL(dst, shift, cr);
 9108   %}
 9109 %}
 9110 
 9111 // Rotate Right by variable
 9112 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9113 %{
 9114   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9115 
 9116   expand %{
 9117     rorI_rReg_CL(dst, shift, cr);
 9118   %}
 9119 %}
 9120 
 9121 // for long rotate
 9122 // ROL expand
 9123 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9124   effect(USE_DEF dst, KILL cr);
 9125 
 9126   format %{ &quot;rolq    $dst&quot; %}
 9127   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9128   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9129   ins_pipe(ialu_reg);
 9130 %}
 9131 
 9132 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9133   effect(USE_DEF dst, USE shift, KILL cr);
 9134 
 9135   format %{ &quot;rolq    $dst, $shift&quot; %}
 9136   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9137   ins_encode( reg_opc_imm_wide(dst, shift) );
 9138   ins_pipe(ialu_reg);
 9139 %}
 9140 
 9141 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9142 %{
 9143   effect(USE_DEF dst, USE shift, KILL cr);
 9144 
 9145   format %{ &quot;rolq    $dst, $shift&quot; %}
 9146   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9147   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9148   ins_pipe(ialu_reg_reg);
 9149 %}
 9150 // end of ROL expand
 9151 
 9152 // Rotate Left by one
 9153 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9154 %{
 9155   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9156 
 9157   expand %{
 9158     rolL_rReg_imm1(dst, cr);
 9159   %}
 9160 %}
 9161 
 9162 // Rotate Left by 8-bit immediate
 9163 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9164 %{
 9165   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9166   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9167 
 9168   expand %{
 9169     rolL_rReg_imm8(dst, lshift, cr);
 9170   %}
 9171 %}
 9172 
 9173 // Rotate Left by variable
 9174 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9175 %{
 9176   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9177 
 9178   expand %{
 9179     rolL_rReg_CL(dst, shift, cr);
 9180   %}
 9181 %}
 9182 
 9183 // Rotate Left by variable
 9184 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9185 %{
 9186   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9187 
 9188   expand %{
 9189     rolL_rReg_CL(dst, shift, cr);
 9190   %}
 9191 %}
 9192 
 9193 // ROR expand
 9194 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9195 %{
 9196   effect(USE_DEF dst, KILL cr);
 9197 
 9198   format %{ &quot;rorq    $dst&quot; %}
 9199   opcode(0xD1, 0x1); /* D1 /1 */
 9200   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9201   ins_pipe(ialu_reg);
 9202 %}
 9203 
 9204 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9205 %{
 9206   effect(USE_DEF dst, USE shift, KILL cr);
 9207 
 9208   format %{ &quot;rorq    $dst, $shift&quot; %}
 9209   opcode(0xC1, 0x1); /* C1 /1 ib */
 9210   ins_encode(reg_opc_imm_wide(dst, shift));
 9211   ins_pipe(ialu_reg);
 9212 %}
 9213 
 9214 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9215 %{
 9216   effect(USE_DEF dst, USE shift, KILL cr);
 9217 
 9218   format %{ &quot;rorq    $dst, $shift&quot; %}
 9219   opcode(0xD3, 0x1); /* D3 /1 */
 9220   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9221   ins_pipe(ialu_reg_reg);
 9222 %}
 9223 // end of ROR expand
 9224 
 9225 // Rotate Right by one
 9226 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9227 %{
 9228   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9229 
 9230   expand %{
 9231     rorL_rReg_imm1(dst, cr);
 9232   %}
 9233 %}
 9234 
 9235 // Rotate Right by 8-bit immediate
 9236 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9237 %{
 9238   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9239   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9240 
 9241   expand %{
 9242     rorL_rReg_imm8(dst, rshift, cr);
 9243   %}
 9244 %}
 9245 
 9246 // Rotate Right by variable
 9247 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9248 %{
 9249   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9250 
 9251   expand %{
 9252     rorL_rReg_CL(dst, shift, cr);
 9253   %}
 9254 %}
 9255 
 9256 // Rotate Right by variable
 9257 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9258 %{
 9259   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9260 
 9261   expand %{
 9262     rorL_rReg_CL(dst, shift, cr);
 9263   %}
 9264 %}
 9265 
 9266 // Logical Instructions
 9267 
 9268 // Integer Logical Instructions
 9269 
 9270 // And Instructions
 9271 // And Register with Register
 9272 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9273 %{
 9274   match(Set dst (AndI dst src));
 9275   effect(KILL cr);
 9276 
 9277   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9278   opcode(0x23);
 9279   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9280   ins_pipe(ialu_reg_reg);
 9281 %}
 9282 
 9283 // And Register with Immediate 255
 9284 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9285 %{
 9286   match(Set dst (AndI dst src));
 9287 
 9288   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9289   opcode(0x0F, 0xB6);
 9290   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9291   ins_pipe(ialu_reg);
 9292 %}
 9293 
 9294 // And Register with Immediate 255 and promote to long
 9295 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9296 %{
 9297   match(Set dst (ConvI2L (AndI src mask)));
 9298 
 9299   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9300   opcode(0x0F, 0xB6);
 9301   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9302   ins_pipe(ialu_reg);
 9303 %}
 9304 
 9305 // And Register with Immediate 65535
 9306 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9307 %{
 9308   match(Set dst (AndI dst src));
 9309 
 9310   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9311   opcode(0x0F, 0xB7);
 9312   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9313   ins_pipe(ialu_reg);
 9314 %}
 9315 
 9316 // And Register with Immediate 65535 and promote to long
 9317 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9318 %{
 9319   match(Set dst (ConvI2L (AndI src mask)));
 9320 
 9321   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9322   opcode(0x0F, 0xB7);
 9323   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9324   ins_pipe(ialu_reg);
 9325 %}
 9326 
 9327 // And Register with Immediate
 9328 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9329 %{
 9330   match(Set dst (AndI dst src));
 9331   effect(KILL cr);
 9332 
 9333   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9334   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9335   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9336   ins_pipe(ialu_reg);
 9337 %}
 9338 
 9339 // And Register with Memory
 9340 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9341 %{
 9342   match(Set dst (AndI dst (LoadI src)));
 9343   effect(KILL cr);
 9344 
 9345   ins_cost(125);
 9346   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9347   opcode(0x23);
 9348   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9349   ins_pipe(ialu_reg_mem);
 9350 %}
 9351 
 9352 // And Memory with Register
 9353 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9354 %{
 9355   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9356   effect(KILL cr);
 9357 
 9358   ins_cost(150);
 9359   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9360   opcode(0x20);
 9361   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9362   ins_pipe(ialu_mem_reg);
 9363 %}
 9364 
 9365 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9366 %{
 9367   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9368   effect(KILL cr);
 9369 
 9370   ins_cost(150);
 9371   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9372   opcode(0x21); /* Opcode 21 /r */
 9373   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9374   ins_pipe(ialu_mem_reg);
 9375 %}
 9376 
 9377 // And Memory with Immediate
 9378 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9379 %{
 9380   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9381   effect(KILL cr);
 9382 
 9383   ins_cost(125);
 9384   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9385   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9386   ins_encode(REX_mem(dst), OpcSE(src),
 9387              RM_opc_mem(secondary, dst), Con8or32(src));
 9388   ins_pipe(ialu_mem_imm);
 9389 %}
 9390 
 9391 // BMI1 instructions
 9392 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9393   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9394   predicate(UseBMI1Instructions);
 9395   effect(KILL cr);
 9396 
 9397   ins_cost(125);
 9398   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9399 
 9400   ins_encode %{
 9401     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9402   %}
 9403   ins_pipe(ialu_reg_mem);
 9404 %}
 9405 
 9406 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9407   match(Set dst (AndI (XorI src1 minus_1) src2));
 9408   predicate(UseBMI1Instructions);
 9409   effect(KILL cr);
 9410 
 9411   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9412 
 9413   ins_encode %{
 9414     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9415   %}
 9416   ins_pipe(ialu_reg);
 9417 %}
 9418 
 9419 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9420   match(Set dst (AndI (SubI imm_zero src) src));
 9421   predicate(UseBMI1Instructions);
 9422   effect(KILL cr);
 9423 
 9424   format %{ &quot;blsil  $dst, $src&quot; %}
 9425 
 9426   ins_encode %{
 9427     __ blsil($dst$$Register, $src$$Register);
 9428   %}
 9429   ins_pipe(ialu_reg);
 9430 %}
 9431 
 9432 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9433   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9434   predicate(UseBMI1Instructions);
 9435   effect(KILL cr);
 9436 
 9437   ins_cost(125);
 9438   format %{ &quot;blsil  $dst, $src&quot; %}
 9439 
 9440   ins_encode %{
 9441     __ blsil($dst$$Register, $src$$Address);
 9442   %}
 9443   ins_pipe(ialu_reg_mem);
 9444 %}
 9445 
 9446 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9447 %{
 9448   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9449   predicate(UseBMI1Instructions);
 9450   effect(KILL cr);
 9451 
 9452   ins_cost(125);
 9453   format %{ &quot;blsmskl $dst, $src&quot; %}
 9454 
 9455   ins_encode %{
 9456     __ blsmskl($dst$$Register, $src$$Address);
 9457   %}
 9458   ins_pipe(ialu_reg_mem);
 9459 %}
 9460 
 9461 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9462 %{
 9463   match(Set dst (XorI (AddI src minus_1) src));
 9464   predicate(UseBMI1Instructions);
 9465   effect(KILL cr);
 9466 
 9467   format %{ &quot;blsmskl $dst, $src&quot; %}
 9468 
 9469   ins_encode %{
 9470     __ blsmskl($dst$$Register, $src$$Register);
 9471   %}
 9472 
 9473   ins_pipe(ialu_reg);
 9474 %}
 9475 
 9476 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9477 %{
 9478   match(Set dst (AndI (AddI src minus_1) src) );
 9479   predicate(UseBMI1Instructions);
 9480   effect(KILL cr);
 9481 
 9482   format %{ &quot;blsrl  $dst, $src&quot; %}
 9483 
 9484   ins_encode %{
 9485     __ blsrl($dst$$Register, $src$$Register);
 9486   %}
 9487 
 9488   ins_pipe(ialu_reg_mem);
 9489 %}
 9490 
 9491 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9492 %{
 9493   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9494   predicate(UseBMI1Instructions);
 9495   effect(KILL cr);
 9496 
 9497   ins_cost(125);
 9498   format %{ &quot;blsrl  $dst, $src&quot; %}
 9499 
 9500   ins_encode %{
 9501     __ blsrl($dst$$Register, $src$$Address);
 9502   %}
 9503 
 9504   ins_pipe(ialu_reg);
 9505 %}
 9506 
 9507 // Or Instructions
 9508 // Or Register with Register
 9509 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9510 %{
 9511   match(Set dst (OrI dst src));
 9512   effect(KILL cr);
 9513 
 9514   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9515   opcode(0x0B);
 9516   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9517   ins_pipe(ialu_reg_reg);
 9518 %}
 9519 
 9520 // Or Register with Immediate
 9521 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9522 %{
 9523   match(Set dst (OrI dst src));
 9524   effect(KILL cr);
 9525 
 9526   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9527   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9528   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9529   ins_pipe(ialu_reg);
 9530 %}
 9531 
 9532 // Or Register with Memory
 9533 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9534 %{
 9535   match(Set dst (OrI dst (LoadI src)));
 9536   effect(KILL cr);
 9537 
 9538   ins_cost(125);
 9539   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9540   opcode(0x0B);
 9541   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9542   ins_pipe(ialu_reg_mem);
 9543 %}
 9544 
 9545 // Or Memory with Register
 9546 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9547 %{
 9548   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9549   effect(KILL cr);
 9550 
 9551   ins_cost(150);
 9552   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9553   opcode(0x08);
 9554   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9555   ins_pipe(ialu_mem_reg);
 9556 %}
 9557 
 9558 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9559 %{
 9560   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9561   effect(KILL cr);
 9562 
 9563   ins_cost(150);
 9564   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9565   opcode(0x09); /* Opcode 09 /r */
 9566   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9567   ins_pipe(ialu_mem_reg);
 9568 %}
 9569 
 9570 // Or Memory with Immediate
 9571 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9572 %{
 9573   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9574   effect(KILL cr);
 9575 
 9576   ins_cost(125);
 9577   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9578   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9579   ins_encode(REX_mem(dst), OpcSE(src),
 9580              RM_opc_mem(secondary, dst), Con8or32(src));
 9581   ins_pipe(ialu_mem_imm);
 9582 %}
 9583 
 9584 // Xor Instructions
 9585 // Xor Register with Register
 9586 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9587 %{
 9588   match(Set dst (XorI dst src));
 9589   effect(KILL cr);
 9590 
 9591   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9592   opcode(0x33);
 9593   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9594   ins_pipe(ialu_reg_reg);
 9595 %}
 9596 
 9597 // Xor Register with Immediate -1
 9598 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9599   match(Set dst (XorI dst imm));
 9600 
 9601   format %{ &quot;not    $dst&quot; %}
 9602   ins_encode %{
 9603      __ notl($dst$$Register);
 9604   %}
 9605   ins_pipe(ialu_reg);
 9606 %}
 9607 
 9608 // Xor Register with Immediate
 9609 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9610 %{
 9611   match(Set dst (XorI dst src));
 9612   effect(KILL cr);
 9613 
 9614   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9615   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9616   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9617   ins_pipe(ialu_reg);
 9618 %}
 9619 
 9620 // Xor Register with Memory
 9621 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9622 %{
 9623   match(Set dst (XorI dst (LoadI src)));
 9624   effect(KILL cr);
 9625 
 9626   ins_cost(125);
 9627   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9628   opcode(0x33);
 9629   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9630   ins_pipe(ialu_reg_mem);
 9631 %}
 9632 
 9633 // Xor Memory with Register
 9634 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9635 %{
 9636   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9637   effect(KILL cr);
 9638 
 9639   ins_cost(150);
 9640   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9641   opcode(0x30);
 9642   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9643   ins_pipe(ialu_mem_reg);
 9644 %}
 9645 
 9646 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9647 %{
 9648   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9649   effect(KILL cr);
 9650 
 9651   ins_cost(150);
 9652   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9653   opcode(0x31); /* Opcode 31 /r */
 9654   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9655   ins_pipe(ialu_mem_reg);
 9656 %}
 9657 
 9658 // Xor Memory with Immediate
 9659 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9660 %{
 9661   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9662   effect(KILL cr);
 9663 
 9664   ins_cost(125);
 9665   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9666   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9667   ins_encode(REX_mem(dst), OpcSE(src),
 9668              RM_opc_mem(secondary, dst), Con8or32(src));
 9669   ins_pipe(ialu_mem_imm);
 9670 %}
 9671 
 9672 
 9673 // Long Logical Instructions
 9674 
 9675 // And Instructions
 9676 // And Register with Register
 9677 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9678 %{
 9679   match(Set dst (AndL dst src));
 9680   effect(KILL cr);
 9681 
 9682   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9683   opcode(0x23);
 9684   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9685   ins_pipe(ialu_reg_reg);
 9686 %}
 9687 
 9688 // And Register with Immediate 255
 9689 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9690 %{
 9691   match(Set dst (AndL dst src));
 9692 
 9693   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9694   opcode(0x0F, 0xB6);
 9695   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9696   ins_pipe(ialu_reg);
 9697 %}
 9698 
 9699 // And Register with Immediate 65535
 9700 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9701 %{
 9702   match(Set dst (AndL dst src));
 9703 
 9704   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9705   opcode(0x0F, 0xB7);
 9706   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9707   ins_pipe(ialu_reg);
 9708 %}
 9709 
 9710 // And Register with Immediate
 9711 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9712 %{
 9713   match(Set dst (AndL dst src));
 9714   effect(KILL cr);
 9715 
 9716   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9717   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9718   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9719   ins_pipe(ialu_reg);
 9720 %}
 9721 
 9722 // And Register with Memory
 9723 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9724 %{
 9725   match(Set dst (AndL dst (LoadL src)));
 9726   effect(KILL cr);
 9727 
 9728   ins_cost(125);
 9729   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9730   opcode(0x23);
 9731   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9732   ins_pipe(ialu_reg_mem);
 9733 %}
 9734 
 9735 // And Memory with Register
 9736 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9737 %{
 9738   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9739   effect(KILL cr);
 9740 
 9741   ins_cost(150);
 9742   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9743   opcode(0x21); /* Opcode 21 /r */
 9744   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9745   ins_pipe(ialu_mem_reg);
 9746 %}
 9747 
 9748 // And Memory with Immediate
 9749 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9750 %{
 9751   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9752   effect(KILL cr);
 9753 
 9754   ins_cost(125);
 9755   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9756   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9757   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9758              RM_opc_mem(secondary, dst), Con8or32(src));
 9759   ins_pipe(ialu_mem_imm);
 9760 %}
 9761 
 9762 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9763 %{
 9764   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9765   // because AND/OR works well enough for 8/32-bit values.
 9766   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9767 
 9768   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9769   effect(KILL cr);
 9770 
 9771   ins_cost(125);
 9772   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9773   ins_encode %{
 9774     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9775   %}
 9776   ins_pipe(ialu_mem_imm);
 9777 %}
 9778 
 9779 // BMI1 instructions
 9780 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9781   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9782   predicate(UseBMI1Instructions);
 9783   effect(KILL cr);
 9784 
 9785   ins_cost(125);
 9786   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9787 
 9788   ins_encode %{
 9789     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9790   %}
 9791   ins_pipe(ialu_reg_mem);
 9792 %}
 9793 
 9794 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9795   match(Set dst (AndL (XorL src1 minus_1) src2));
 9796   predicate(UseBMI1Instructions);
 9797   effect(KILL cr);
 9798 
 9799   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9800 
 9801   ins_encode %{
 9802   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9803   %}
 9804   ins_pipe(ialu_reg_mem);
 9805 %}
 9806 
 9807 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9808   match(Set dst (AndL (SubL imm_zero src) src));
 9809   predicate(UseBMI1Instructions);
 9810   effect(KILL cr);
 9811 
 9812   format %{ &quot;blsiq  $dst, $src&quot; %}
 9813 
 9814   ins_encode %{
 9815     __ blsiq($dst$$Register, $src$$Register);
 9816   %}
 9817   ins_pipe(ialu_reg);
 9818 %}
 9819 
 9820 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9821   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9822   predicate(UseBMI1Instructions);
 9823   effect(KILL cr);
 9824 
 9825   ins_cost(125);
 9826   format %{ &quot;blsiq  $dst, $src&quot; %}
 9827 
 9828   ins_encode %{
 9829     __ blsiq($dst$$Register, $src$$Address);
 9830   %}
 9831   ins_pipe(ialu_reg_mem);
 9832 %}
 9833 
 9834 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9835 %{
 9836   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9837   predicate(UseBMI1Instructions);
 9838   effect(KILL cr);
 9839 
 9840   ins_cost(125);
 9841   format %{ &quot;blsmskq $dst, $src&quot; %}
 9842 
 9843   ins_encode %{
 9844     __ blsmskq($dst$$Register, $src$$Address);
 9845   %}
 9846   ins_pipe(ialu_reg_mem);
 9847 %}
 9848 
 9849 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9850 %{
 9851   match(Set dst (XorL (AddL src minus_1) src));
 9852   predicate(UseBMI1Instructions);
 9853   effect(KILL cr);
 9854 
 9855   format %{ &quot;blsmskq $dst, $src&quot; %}
 9856 
 9857   ins_encode %{
 9858     __ blsmskq($dst$$Register, $src$$Register);
 9859   %}
 9860 
 9861   ins_pipe(ialu_reg);
 9862 %}
 9863 
 9864 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9865 %{
 9866   match(Set dst (AndL (AddL src minus_1) src) );
 9867   predicate(UseBMI1Instructions);
 9868   effect(KILL cr);
 9869 
 9870   format %{ &quot;blsrq  $dst, $src&quot; %}
 9871 
 9872   ins_encode %{
 9873     __ blsrq($dst$$Register, $src$$Register);
 9874   %}
 9875 
 9876   ins_pipe(ialu_reg);
 9877 %}
 9878 
 9879 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9880 %{
 9881   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9882   predicate(UseBMI1Instructions);
 9883   effect(KILL cr);
 9884 
 9885   ins_cost(125);
 9886   format %{ &quot;blsrq  $dst, $src&quot; %}
 9887 
 9888   ins_encode %{
 9889     __ blsrq($dst$$Register, $src$$Address);
 9890   %}
 9891 
 9892   ins_pipe(ialu_reg);
 9893 %}
 9894 
 9895 // Or Instructions
 9896 // Or Register with Register
 9897 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9898 %{
 9899   match(Set dst (OrL dst src));
 9900   effect(KILL cr);
 9901 
 9902   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9903   opcode(0x0B);
 9904   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9905   ins_pipe(ialu_reg_reg);
 9906 %}
 9907 
 9908 // Use any_RegP to match R15 (TLS register) without spilling.
 9909 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
 9910   match(Set dst (OrL dst (CastP2X src)));
 9911   effect(KILL cr);
 9912 
 9913   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9914   opcode(0x0B);
 9915   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9916   ins_pipe(ialu_reg_reg);
 9917 %}
 9918 
 9919 
 9920 // Or Register with Immediate
 9921 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9922 %{
 9923   match(Set dst (OrL dst src));
 9924   effect(KILL cr);
 9925 
 9926   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9927   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9928   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9929   ins_pipe(ialu_reg);
 9930 %}
 9931 
 9932 // Or Register with Memory
 9933 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9934 %{
 9935   match(Set dst (OrL dst (LoadL src)));
 9936   effect(KILL cr);
 9937 
 9938   ins_cost(125);
 9939   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9940   opcode(0x0B);
 9941   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9942   ins_pipe(ialu_reg_mem);
 9943 %}
 9944 
 9945 // Or Memory with Register
 9946 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9947 %{
 9948   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9949   effect(KILL cr);
 9950 
 9951   ins_cost(150);
 9952   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9953   opcode(0x09); /* Opcode 09 /r */
 9954   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9955   ins_pipe(ialu_mem_reg);
 9956 %}
 9957 
 9958 // Or Memory with Immediate
 9959 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9960 %{
 9961   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9962   effect(KILL cr);
 9963 
 9964   ins_cost(125);
 9965   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9966   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9967   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9968              RM_opc_mem(secondary, dst), Con8or32(src));
 9969   ins_pipe(ialu_mem_imm);
 9970 %}
 9971 
 9972 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
 9973 %{
 9974   // con should be a pure 64-bit power of 2 immediate
 9975   // because AND/OR works well enough for 8/32-bit values.
 9976   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
 9977 
 9978   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
 9979   effect(KILL cr);
 9980 
 9981   ins_cost(125);
 9982   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
 9983   ins_encode %{
 9984     __ btsq($dst$$Address, log2_long((julong)$con$$constant));
 9985   %}
 9986   ins_pipe(ialu_mem_imm);
 9987 %}
 9988 
 9989 // Xor Instructions
 9990 // Xor Register with Register
 9991 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9992 %{
 9993   match(Set dst (XorL dst src));
 9994   effect(KILL cr);
 9995 
 9996   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
 9997   opcode(0x33);
 9998   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9999   ins_pipe(ialu_reg_reg);
10000 %}
10001 
10002 // Xor Register with Immediate -1
10003 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10004   match(Set dst (XorL dst imm));
10005 
10006   format %{ &quot;notq   $dst&quot; %}
10007   ins_encode %{
10008      __ notq($dst$$Register);
10009   %}
10010   ins_pipe(ialu_reg);
10011 %}
10012 
10013 // Xor Register with Immediate
10014 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10015 %{
10016   match(Set dst (XorL dst src));
10017   effect(KILL cr);
10018 
10019   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10020   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10021   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10022   ins_pipe(ialu_reg);
10023 %}
10024 
10025 // Xor Register with Memory
10026 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10027 %{
10028   match(Set dst (XorL dst (LoadL src)));
10029   effect(KILL cr);
10030 
10031   ins_cost(125);
10032   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10033   opcode(0x33);
10034   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10035   ins_pipe(ialu_reg_mem);
10036 %}
10037 
10038 // Xor Memory with Register
10039 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10040 %{
10041   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10042   effect(KILL cr);
10043 
10044   ins_cost(150);
10045   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10046   opcode(0x31); /* Opcode 31 /r */
10047   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10048   ins_pipe(ialu_mem_reg);
10049 %}
10050 
10051 // Xor Memory with Immediate
10052 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10053 %{
10054   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10055   effect(KILL cr);
10056 
10057   ins_cost(125);
10058   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10059   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10060   ins_encode(REX_mem_wide(dst), OpcSE(src),
10061              RM_opc_mem(secondary, dst), Con8or32(src));
10062   ins_pipe(ialu_mem_imm);
10063 %}
10064 
10065 // Convert Int to Boolean
10066 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10067 %{
10068   match(Set dst (Conv2B src));
10069   effect(KILL cr);
10070 
10071   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10072             &quot;setnz   $dst\n\t&quot;
10073             &quot;movzbl  $dst, $dst&quot; %}
10074   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10075              setNZ_reg(dst),
10076              REX_reg_breg(dst, dst), // movzbl
10077              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10078   ins_pipe(pipe_slow); // XXX
10079 %}
10080 
10081 // Convert Pointer to Boolean
10082 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10083 %{
10084   match(Set dst (Conv2B src));
10085   effect(KILL cr);
10086 
10087   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10088             &quot;setnz   $dst\n\t&quot;
10089             &quot;movzbl  $dst, $dst&quot; %}
10090   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10091              setNZ_reg(dst),
10092              REX_reg_breg(dst, dst), // movzbl
10093              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10094   ins_pipe(pipe_slow); // XXX
10095 %}
10096 
10097 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10098 %{
10099   match(Set dst (CmpLTMask p q));
10100   effect(KILL cr);
10101 
10102   ins_cost(400);
10103   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10104             &quot;setlt   $dst\n\t&quot;
10105             &quot;movzbl  $dst, $dst\n\t&quot;
10106             &quot;negl    $dst&quot; %}
10107   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10108              setLT_reg(dst),
10109              REX_reg_breg(dst, dst), // movzbl
10110              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10111              neg_reg(dst));
10112   ins_pipe(pipe_slow);
10113 %}
10114 
10115 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10116 %{
10117   match(Set dst (CmpLTMask dst zero));
10118   effect(KILL cr);
10119 
10120   ins_cost(100);
10121   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10122   ins_encode %{
10123   __ sarl($dst$$Register, 31);
10124   %}
10125   ins_pipe(ialu_reg);
10126 %}
10127 
10128 /* Better to save a register than avoid a branch */
10129 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10130 %{
10131   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10132   effect(KILL cr);
10133   ins_cost(300);
10134   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10135             &quot;jge     done\n\t&quot;
10136             &quot;addl    $p,$y\n&quot;
10137             &quot;done:   &quot; %}
10138   ins_encode %{
10139     Register Rp = $p$$Register;
10140     Register Rq = $q$$Register;
10141     Register Ry = $y$$Register;
10142     Label done;
10143     __ subl(Rp, Rq);
10144     __ jccb(Assembler::greaterEqual, done);
10145     __ addl(Rp, Ry);
10146     __ bind(done);
10147   %}
10148   ins_pipe(pipe_cmplt);
10149 %}
10150 
10151 /* Better to save a register than avoid a branch */
10152 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10153 %{
10154   match(Set y (AndI (CmpLTMask p q) y));
10155   effect(KILL cr);
10156 
10157   ins_cost(300);
10158 
10159   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10160             &quot;jlt     done\n\t&quot;
10161             &quot;xorl    $y, $y\n&quot;
10162             &quot;done:   &quot; %}
10163   ins_encode %{
10164     Register Rp = $p$$Register;
10165     Register Rq = $q$$Register;
10166     Register Ry = $y$$Register;
10167     Label done;
10168     __ cmpl(Rp, Rq);
10169     __ jccb(Assembler::less, done);
10170     __ xorl(Ry, Ry);
10171     __ bind(done);
10172   %}
10173   ins_pipe(pipe_cmplt);
10174 %}
10175 
10176 
10177 //---------- FP Instructions------------------------------------------------
10178 
10179 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10180 %{
10181   match(Set cr (CmpF src1 src2));
10182 
10183   ins_cost(145);
10184   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10185             &quot;jnp,s   exit\n\t&quot;
10186             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10187             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10188             &quot;popfq\n&quot;
10189     &quot;exit:&quot; %}
10190   ins_encode %{
10191     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10192     emit_cmpfp_fixup(_masm);
10193   %}
10194   ins_pipe(pipe_slow);
10195 %}
10196 
10197 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10198   match(Set cr (CmpF src1 src2));
10199 
10200   ins_cost(100);
10201   format %{ &quot;ucomiss $src1, $src2&quot; %}
10202   ins_encode %{
10203     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10204   %}
10205   ins_pipe(pipe_slow);
10206 %}
10207 
10208 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10209 %{
10210   match(Set cr (CmpF src1 (LoadF src2)));
10211 
10212   ins_cost(145);
10213   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10214             &quot;jnp,s   exit\n\t&quot;
10215             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10216             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10217             &quot;popfq\n&quot;
10218     &quot;exit:&quot; %}
10219   ins_encode %{
10220     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10221     emit_cmpfp_fixup(_masm);
10222   %}
10223   ins_pipe(pipe_slow);
10224 %}
10225 
10226 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10227   match(Set cr (CmpF src1 (LoadF src2)));
10228 
10229   ins_cost(100);
10230   format %{ &quot;ucomiss $src1, $src2&quot; %}
10231   ins_encode %{
10232     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10233   %}
10234   ins_pipe(pipe_slow);
10235 %}
10236 
10237 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10238   match(Set cr (CmpF src con));
10239 
10240   ins_cost(145);
10241   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10242             &quot;jnp,s   exit\n\t&quot;
10243             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10244             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10245             &quot;popfq\n&quot;
10246     &quot;exit:&quot; %}
10247   ins_encode %{
10248     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10249     emit_cmpfp_fixup(_masm);
10250   %}
10251   ins_pipe(pipe_slow);
10252 %}
10253 
10254 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10255   match(Set cr (CmpF src con));
10256   ins_cost(100);
10257   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10258   ins_encode %{
10259     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10260   %}
10261   ins_pipe(pipe_slow);
10262 %}
10263 
10264 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10265 %{
10266   match(Set cr (CmpD src1 src2));
10267 
10268   ins_cost(145);
10269   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10270             &quot;jnp,s   exit\n\t&quot;
10271             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10272             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10273             &quot;popfq\n&quot;
10274     &quot;exit:&quot; %}
10275   ins_encode %{
10276     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10277     emit_cmpfp_fixup(_masm);
10278   %}
10279   ins_pipe(pipe_slow);
10280 %}
10281 
10282 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10283   match(Set cr (CmpD src1 src2));
10284 
10285   ins_cost(100);
10286   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10287   ins_encode %{
10288     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10289   %}
10290   ins_pipe(pipe_slow);
10291 %}
10292 
10293 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10294 %{
10295   match(Set cr (CmpD src1 (LoadD src2)));
10296 
10297   ins_cost(145);
10298   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10299             &quot;jnp,s   exit\n\t&quot;
10300             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10301             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10302             &quot;popfq\n&quot;
10303     &quot;exit:&quot; %}
10304   ins_encode %{
10305     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10306     emit_cmpfp_fixup(_masm);
10307   %}
10308   ins_pipe(pipe_slow);
10309 %}
10310 
10311 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10312   match(Set cr (CmpD src1 (LoadD src2)));
10313 
10314   ins_cost(100);
10315   format %{ &quot;ucomisd $src1, $src2&quot; %}
10316   ins_encode %{
10317     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10318   %}
10319   ins_pipe(pipe_slow);
10320 %}
10321 
10322 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10323   match(Set cr (CmpD src con));
10324 
10325   ins_cost(145);
10326   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10327             &quot;jnp,s   exit\n\t&quot;
10328             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10329             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10330             &quot;popfq\n&quot;
10331     &quot;exit:&quot; %}
10332   ins_encode %{
10333     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10334     emit_cmpfp_fixup(_masm);
10335   %}
10336   ins_pipe(pipe_slow);
10337 %}
10338 
10339 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10340   match(Set cr (CmpD src con));
10341   ins_cost(100);
10342   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10343   ins_encode %{
10344     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10345   %}
10346   ins_pipe(pipe_slow);
10347 %}
10348 
10349 // Compare into -1,0,1
10350 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10351 %{
10352   match(Set dst (CmpF3 src1 src2));
10353   effect(KILL cr);
10354 
10355   ins_cost(275);
10356   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10357             &quot;movl    $dst, #-1\n\t&quot;
10358             &quot;jp,s    done\n\t&quot;
10359             &quot;jb,s    done\n\t&quot;
10360             &quot;setne   $dst\n\t&quot;
10361             &quot;movzbl  $dst, $dst\n&quot;
10362     &quot;done:&quot; %}
10363   ins_encode %{
10364     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10365     emit_cmpfp3(_masm, $dst$$Register);
10366   %}
10367   ins_pipe(pipe_slow);
10368 %}
10369 
10370 // Compare into -1,0,1
10371 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10372 %{
10373   match(Set dst (CmpF3 src1 (LoadF src2)));
10374   effect(KILL cr);
10375 
10376   ins_cost(275);
10377   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10378             &quot;movl    $dst, #-1\n\t&quot;
10379             &quot;jp,s    done\n\t&quot;
10380             &quot;jb,s    done\n\t&quot;
10381             &quot;setne   $dst\n\t&quot;
10382             &quot;movzbl  $dst, $dst\n&quot;
10383     &quot;done:&quot; %}
10384   ins_encode %{
10385     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10386     emit_cmpfp3(_masm, $dst$$Register);
10387   %}
10388   ins_pipe(pipe_slow);
10389 %}
10390 
10391 // Compare into -1,0,1
10392 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10393   match(Set dst (CmpF3 src con));
10394   effect(KILL cr);
10395 
10396   ins_cost(275);
10397   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10398             &quot;movl    $dst, #-1\n\t&quot;
10399             &quot;jp,s    done\n\t&quot;
10400             &quot;jb,s    done\n\t&quot;
10401             &quot;setne   $dst\n\t&quot;
10402             &quot;movzbl  $dst, $dst\n&quot;
10403     &quot;done:&quot; %}
10404   ins_encode %{
10405     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10406     emit_cmpfp3(_masm, $dst$$Register);
10407   %}
10408   ins_pipe(pipe_slow);
10409 %}
10410 
10411 // Compare into -1,0,1
10412 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10413 %{
10414   match(Set dst (CmpD3 src1 src2));
10415   effect(KILL cr);
10416 
10417   ins_cost(275);
10418   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10419             &quot;movl    $dst, #-1\n\t&quot;
10420             &quot;jp,s    done\n\t&quot;
10421             &quot;jb,s    done\n\t&quot;
10422             &quot;setne   $dst\n\t&quot;
10423             &quot;movzbl  $dst, $dst\n&quot;
10424     &quot;done:&quot; %}
10425   ins_encode %{
10426     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10427     emit_cmpfp3(_masm, $dst$$Register);
10428   %}
10429   ins_pipe(pipe_slow);
10430 %}
10431 
10432 // Compare into -1,0,1
10433 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10434 %{
10435   match(Set dst (CmpD3 src1 (LoadD src2)));
10436   effect(KILL cr);
10437 
10438   ins_cost(275);
10439   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10440             &quot;movl    $dst, #-1\n\t&quot;
10441             &quot;jp,s    done\n\t&quot;
10442             &quot;jb,s    done\n\t&quot;
10443             &quot;setne   $dst\n\t&quot;
10444             &quot;movzbl  $dst, $dst\n&quot;
10445     &quot;done:&quot; %}
10446   ins_encode %{
10447     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10448     emit_cmpfp3(_masm, $dst$$Register);
10449   %}
10450   ins_pipe(pipe_slow);
10451 %}
10452 
10453 // Compare into -1,0,1
10454 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10455   match(Set dst (CmpD3 src con));
10456   effect(KILL cr);
10457 
10458   ins_cost(275);
10459   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10460             &quot;movl    $dst, #-1\n\t&quot;
10461             &quot;jp,s    done\n\t&quot;
10462             &quot;jb,s    done\n\t&quot;
10463             &quot;setne   $dst\n\t&quot;
10464             &quot;movzbl  $dst, $dst\n&quot;
10465     &quot;done:&quot; %}
10466   ins_encode %{
10467     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10468     emit_cmpfp3(_masm, $dst$$Register);
10469   %}
10470   ins_pipe(pipe_slow);
10471 %}
10472 
10473 //----------Arithmetic Conversion Instructions---------------------------------
10474 
10475 instruct convF2D_reg_reg(regD dst, regF src)
10476 %{
10477   match(Set dst (ConvF2D src));
10478 
10479   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10480   ins_encode %{
10481     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10482   %}
10483   ins_pipe(pipe_slow); // XXX
10484 %}
10485 
10486 instruct convF2D_reg_mem(regD dst, memory src)
10487 %{
10488   match(Set dst (ConvF2D (LoadF src)));
10489 
10490   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10491   ins_encode %{
10492     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10493   %}
10494   ins_pipe(pipe_slow); // XXX
10495 %}
10496 
10497 instruct convD2F_reg_reg(regF dst, regD src)
10498 %{
10499   match(Set dst (ConvD2F src));
10500 
10501   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10502   ins_encode %{
10503     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10504   %}
10505   ins_pipe(pipe_slow); // XXX
10506 %}
10507 
10508 instruct convD2F_reg_mem(regF dst, memory src)
10509 %{
10510   match(Set dst (ConvD2F (LoadD src)));
10511 
10512   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10513   ins_encode %{
10514     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10515   %}
10516   ins_pipe(pipe_slow); // XXX
10517 %}
10518 
10519 // XXX do mem variants
10520 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10521 %{
10522   match(Set dst (ConvF2I src));
10523   effect(KILL cr);
10524   format %{ &quot;convert_f2i $dst,$src&quot; %}
10525   ins_encode %{
10526     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10527   %}
10528   ins_pipe(pipe_slow);
10529 %}
10530 
10531 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10532 %{
10533   match(Set dst (ConvF2L src));
10534   effect(KILL cr);
10535   format %{ &quot;convert_f2l $dst,$src&quot;%}
10536   ins_encode %{
10537     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10538   %}
10539   ins_pipe(pipe_slow);
10540 %}
10541 
10542 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10543 %{
10544   match(Set dst (ConvD2I src));
10545   effect(KILL cr);
10546   format %{ &quot;convert_d2i $dst,$src&quot;%}
10547   ins_encode %{
10548     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10549   %}
10550   ins_pipe(pipe_slow);
10551 %}
10552 
10553 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10554 %{
10555   match(Set dst (ConvD2L src));
10556   effect(KILL cr);
10557   format %{ &quot;convert_d2l $dst,$src&quot;%}
10558   ins_encode %{
10559     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10560   %}
10561   ins_pipe(pipe_slow);
10562 %}
10563 
10564 instruct convI2F_reg_reg(regF dst, rRegI src)
10565 %{
10566   predicate(!UseXmmI2F);
10567   match(Set dst (ConvI2F src));
10568 
10569   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10570   ins_encode %{
10571     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10572   %}
10573   ins_pipe(pipe_slow); // XXX
10574 %}
10575 
10576 instruct convI2F_reg_mem(regF dst, memory src)
10577 %{
10578   match(Set dst (ConvI2F (LoadI src)));
10579 
10580   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10581   ins_encode %{
10582     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10583   %}
10584   ins_pipe(pipe_slow); // XXX
10585 %}
10586 
10587 instruct convI2D_reg_reg(regD dst, rRegI src)
10588 %{
10589   predicate(!UseXmmI2D);
10590   match(Set dst (ConvI2D src));
10591 
10592   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10593   ins_encode %{
10594     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10595   %}
10596   ins_pipe(pipe_slow); // XXX
10597 %}
10598 
10599 instruct convI2D_reg_mem(regD dst, memory src)
10600 %{
10601   match(Set dst (ConvI2D (LoadI src)));
10602 
10603   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10604   ins_encode %{
10605     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10606   %}
10607   ins_pipe(pipe_slow); // XXX
10608 %}
10609 
10610 instruct convXI2F_reg(regF dst, rRegI src)
10611 %{
10612   predicate(UseXmmI2F);
10613   match(Set dst (ConvI2F src));
10614 
10615   format %{ &quot;movdl $dst, $src\n\t&quot;
10616             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10617   ins_encode %{
10618     __ movdl($dst$$XMMRegister, $src$$Register);
10619     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10620   %}
10621   ins_pipe(pipe_slow); // XXX
10622 %}
10623 
10624 instruct convXI2D_reg(regD dst, rRegI src)
10625 %{
10626   predicate(UseXmmI2D);
10627   match(Set dst (ConvI2D src));
10628 
10629   format %{ &quot;movdl $dst, $src\n\t&quot;
10630             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10631   ins_encode %{
10632     __ movdl($dst$$XMMRegister, $src$$Register);
10633     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10634   %}
10635   ins_pipe(pipe_slow); // XXX
10636 %}
10637 
10638 instruct convL2F_reg_reg(regF dst, rRegL src)
10639 %{
10640   match(Set dst (ConvL2F src));
10641 
10642   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10643   ins_encode %{
10644     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10645   %}
10646   ins_pipe(pipe_slow); // XXX
10647 %}
10648 
10649 instruct convL2F_reg_mem(regF dst, memory src)
10650 %{
10651   match(Set dst (ConvL2F (LoadL src)));
10652 
10653   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10654   ins_encode %{
10655     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10656   %}
10657   ins_pipe(pipe_slow); // XXX
10658 %}
10659 
10660 instruct convL2D_reg_reg(regD dst, rRegL src)
10661 %{
10662   match(Set dst (ConvL2D src));
10663 
10664   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10665   ins_encode %{
10666     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10667   %}
10668   ins_pipe(pipe_slow); // XXX
10669 %}
10670 
10671 instruct convL2D_reg_mem(regD dst, memory src)
10672 %{
10673   match(Set dst (ConvL2D (LoadL src)));
10674 
10675   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10676   ins_encode %{
10677     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10678   %}
10679   ins_pipe(pipe_slow); // XXX
10680 %}
10681 
10682 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10683 %{
10684   match(Set dst (ConvI2L src));
10685 
10686   ins_cost(125);
10687   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10688   ins_encode %{
10689     __ movslq($dst$$Register, $src$$Register);
10690   %}
10691   ins_pipe(ialu_reg_reg);
10692 %}
10693 
10694 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10695 // %{
10696 //   match(Set dst (ConvI2L src));
10697 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10698 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10699 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10700 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10701 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10702 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10703 
10704 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10705 //   ins_encode(enc_copy(dst, src));
10706 // //   opcode(0x63); // needs REX.W
10707 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10708 //   ins_pipe(ialu_reg_reg);
10709 // %}
10710 
10711 // Zero-extend convert int to long
10712 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10713 %{
10714   match(Set dst (AndL (ConvI2L src) mask));
10715 
10716   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10717   ins_encode %{
10718     if ($dst$$reg != $src$$reg) {
10719       __ movl($dst$$Register, $src$$Register);
10720     }
10721   %}
10722   ins_pipe(ialu_reg_reg);
10723 %}
10724 
10725 // Zero-extend convert int to long
10726 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10727 %{
10728   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10729 
10730   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10731   ins_encode %{
10732     __ movl($dst$$Register, $src$$Address);
10733   %}
10734   ins_pipe(ialu_reg_mem);
10735 %}
10736 
10737 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10738 %{
10739   match(Set dst (AndL src mask));
10740 
10741   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10742   ins_encode %{
10743     __ movl($dst$$Register, $src$$Register);
10744   %}
10745   ins_pipe(ialu_reg_reg);
10746 %}
10747 
10748 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10749 %{
10750   match(Set dst (ConvL2I src));
10751 
10752   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10753   ins_encode %{
10754     __ movl($dst$$Register, $src$$Register);
10755   %}
10756   ins_pipe(ialu_reg_reg);
10757 %}
10758 
10759 
10760 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10761   match(Set dst (MoveF2I src));
10762   effect(DEF dst, USE src);
10763 
10764   ins_cost(125);
10765   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10766   ins_encode %{
10767     __ movl($dst$$Register, Address(rsp, $src$$disp));
10768   %}
10769   ins_pipe(ialu_reg_mem);
10770 %}
10771 
10772 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10773   match(Set dst (MoveI2F src));
10774   effect(DEF dst, USE src);
10775 
10776   ins_cost(125);
10777   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10778   ins_encode %{
10779     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10780   %}
10781   ins_pipe(pipe_slow);
10782 %}
10783 
10784 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10785   match(Set dst (MoveD2L src));
10786   effect(DEF dst, USE src);
10787 
10788   ins_cost(125);
10789   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10790   ins_encode %{
10791     __ movq($dst$$Register, Address(rsp, $src$$disp));
10792   %}
10793   ins_pipe(ialu_reg_mem);
10794 %}
10795 
10796 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10797   predicate(!UseXmmLoadAndClearUpper);
10798   match(Set dst (MoveL2D src));
10799   effect(DEF dst, USE src);
10800 
10801   ins_cost(125);
10802   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10803   ins_encode %{
10804     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10805   %}
10806   ins_pipe(pipe_slow);
10807 %}
10808 
10809 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10810   predicate(UseXmmLoadAndClearUpper);
10811   match(Set dst (MoveL2D src));
10812   effect(DEF dst, USE src);
10813 
10814   ins_cost(125);
10815   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10816   ins_encode %{
10817     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10818   %}
10819   ins_pipe(pipe_slow);
10820 %}
10821 
10822 
10823 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10824   match(Set dst (MoveF2I src));
10825   effect(DEF dst, USE src);
10826 
10827   ins_cost(95); // XXX
10828   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10829   ins_encode %{
10830     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10831   %}
10832   ins_pipe(pipe_slow);
10833 %}
10834 
10835 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10836   match(Set dst (MoveI2F src));
10837   effect(DEF dst, USE src);
10838 
10839   ins_cost(100);
10840   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10841   ins_encode %{
10842     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10843   %}
10844   ins_pipe( ialu_mem_reg );
10845 %}
10846 
10847 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10848   match(Set dst (MoveD2L src));
10849   effect(DEF dst, USE src);
10850 
10851   ins_cost(95); // XXX
10852   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10853   ins_encode %{
10854     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10855   %}
10856   ins_pipe(pipe_slow);
10857 %}
10858 
10859 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10860   match(Set dst (MoveL2D src));
10861   effect(DEF dst, USE src);
10862 
10863   ins_cost(100);
10864   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10865   ins_encode %{
10866     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10867   %}
10868   ins_pipe(ialu_mem_reg);
10869 %}
10870 
10871 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10872   match(Set dst (MoveF2I src));
10873   effect(DEF dst, USE src);
10874   ins_cost(85);
10875   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10876   ins_encode %{
10877     __ movdl($dst$$Register, $src$$XMMRegister);
10878   %}
10879   ins_pipe( pipe_slow );
10880 %}
10881 
10882 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10883   match(Set dst (MoveD2L src));
10884   effect(DEF dst, USE src);
10885   ins_cost(85);
10886   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10887   ins_encode %{
10888     __ movdq($dst$$Register, $src$$XMMRegister);
10889   %}
10890   ins_pipe( pipe_slow );
10891 %}
10892 
10893 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10894   match(Set dst (MoveI2F src));
10895   effect(DEF dst, USE src);
10896   ins_cost(100);
10897   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10898   ins_encode %{
10899     __ movdl($dst$$XMMRegister, $src$$Register);
10900   %}
10901   ins_pipe( pipe_slow );
10902 %}
10903 
10904 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10905   match(Set dst (MoveL2D src));
10906   effect(DEF dst, USE src);
10907   ins_cost(100);
10908   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10909   ins_encode %{
10910      __ movdq($dst$$XMMRegister, $src$$Register);
10911   %}
10912   ins_pipe( pipe_slow );
10913 %}
10914 
10915 
10916 // =======================================================================
10917 // fast clearing of an array
10918 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
10919                   Universe dummy, rFlagsReg cr)
10920 %{
10921   predicate(!((ClearArrayNode*)n)-&gt;is_large());
10922   match(Set dummy (ClearArray cnt base));
10923   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
10924 
10925   format %{ $$template
10926     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
10927     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10928     $$emit$$&quot;jg      LARGE\n\t&quot;
10929     $$emit$$&quot;dec     rcx\n\t&quot;
10930     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10931     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10932     $$emit$$&quot;dec     rcx\n\t&quot;
10933     $$emit$$&quot;jge     LOOP\n\t&quot;
10934     $$emit$$&quot;jmp     DONE\n\t&quot;
10935     $$emit$$&quot;# LARGE:\n\t&quot;
10936     if (UseFastStosb) {
10937        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10938        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10939     } else if (UseXMMForObjInit) {
10940        $$emit$$&quot;mov     rdi,rax\n\t&quot;
10941        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
10942        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10943        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10944        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10945        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
10946        $$emit$$&quot;add     0x40,rax\n\t&quot;
10947        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10948        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10949        $$emit$$&quot;jge     L_loop\n\t&quot;
10950        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10951        $$emit$$&quot;jl      L_tail\n\t&quot;
10952        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10953        $$emit$$&quot;add     0x20,rax\n\t&quot;
10954        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10955        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10956        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10957        $$emit$$&quot;jle     L_end\n\t&quot;
10958        $$emit$$&quot;dec     rcx\n\t&quot;
10959        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
10960        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
10961        $$emit$$&quot;add     0x8,rax\n\t&quot;
10962        $$emit$$&quot;dec     rcx\n\t&quot;
10963        $$emit$$&quot;jge     L_sloop\n\t&quot;
10964        $$emit$$&quot;# L_end:\n\t&quot;
10965     } else {
10966        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
10967     }
10968     $$emit$$&quot;# DONE&quot;
10969   %}
10970   ins_encode %{
10971     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
10972                  $tmp$$XMMRegister, false);
10973   %}
10974   ins_pipe(pipe_slow);
10975 %}
10976 
10977 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
10978                         Universe dummy, rFlagsReg cr)
10979 %{
10980   predicate(((ClearArrayNode*)n)-&gt;is_large());
10981   match(Set dummy (ClearArray cnt base));
10982   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
10983 
10984   format %{ $$template
10985     if (UseFastStosb) {
10986        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
10987        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10988        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
10989     } else if (UseXMMForObjInit) {
10990        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;
10991        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
10992        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10993        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10994        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10995        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
10996        $$emit$$&quot;add     0x40,rax\n\t&quot;
10997        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10998        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10999        $$emit$$&quot;jge     L_loop\n\t&quot;
11000        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11001        $$emit$$&quot;jl      L_tail\n\t&quot;
11002        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11003        $$emit$$&quot;add     0x20,rax\n\t&quot;
11004        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11005        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11006        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11007        $$emit$$&quot;jle     L_end\n\t&quot;
11008        $$emit$$&quot;dec     rcx\n\t&quot;
11009        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11010        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11011        $$emit$$&quot;add     0x8,rax\n\t&quot;
11012        $$emit$$&quot;dec     rcx\n\t&quot;
11013        $$emit$$&quot;jge     L_sloop\n\t&quot;
11014        $$emit$$&quot;# L_end:\n\t&quot;
11015     } else {
11016        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11017        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11018     }
11019   %}
11020   ins_encode %{
11021     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11022                  $tmp$$XMMRegister, true);
11023   %}
11024   ins_pipe(pipe_slow);
11025 %}
11026 
11027 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11028                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11029 %{
11030   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11031   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11032   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11033 
11034   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11035   ins_encode %{
11036     __ string_compare($str1$$Register, $str2$$Register,
11037                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11038                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11039   %}
11040   ins_pipe( pipe_slow );
11041 %}
11042 
11043 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11044                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11045 %{
11046   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11047   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11048   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11049 
11050   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11051   ins_encode %{
11052     __ string_compare($str1$$Register, $str2$$Register,
11053                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11054                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11055   %}
11056   ins_pipe( pipe_slow );
11057 %}
11058 
11059 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11060                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11061 %{
11062   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11063   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11064   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11065 
11066   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11067   ins_encode %{
11068     __ string_compare($str1$$Register, $str2$$Register,
11069                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11070                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11071   %}
11072   ins_pipe( pipe_slow );
11073 %}
11074 
11075 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11076                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11077 %{
11078   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11079   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11080   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11081 
11082   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11083   ins_encode %{
11084     __ string_compare($str2$$Register, $str1$$Register,
11085                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11086                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11087   %}
11088   ins_pipe( pipe_slow );
11089 %}
11090 
11091 // fast search of substring with known size.
11092 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11093                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11094 %{
11095   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11096   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11097   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11098 
11099   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11100   ins_encode %{
11101     int icnt2 = (int)$int_cnt2$$constant;
11102     if (icnt2 &gt;= 16) {
11103       // IndexOf for constant substrings with size &gt;= 16 elements
11104       // which don&#39;t need to be loaded through stack.
11105       __ string_indexofC8($str1$$Register, $str2$$Register,
11106                           $cnt1$$Register, $cnt2$$Register,
11107                           icnt2, $result$$Register,
11108                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11109     } else {
11110       // Small strings are loaded through stack if they cross page boundary.
11111       __ string_indexof($str1$$Register, $str2$$Register,
11112                         $cnt1$$Register, $cnt2$$Register,
11113                         icnt2, $result$$Register,
11114                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11115     }
11116   %}
11117   ins_pipe( pipe_slow );
11118 %}
11119 
11120 // fast search of substring with known size.
11121 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11122                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11123 %{
11124   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11125   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11126   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11127 
11128   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11129   ins_encode %{
11130     int icnt2 = (int)$int_cnt2$$constant;
11131     if (icnt2 &gt;= 8) {
11132       // IndexOf for constant substrings with size &gt;= 8 elements
11133       // which don&#39;t need to be loaded through stack.
11134       __ string_indexofC8($str1$$Register, $str2$$Register,
11135                           $cnt1$$Register, $cnt2$$Register,
11136                           icnt2, $result$$Register,
11137                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11138     } else {
11139       // Small strings are loaded through stack if they cross page boundary.
11140       __ string_indexof($str1$$Register, $str2$$Register,
11141                         $cnt1$$Register, $cnt2$$Register,
11142                         icnt2, $result$$Register,
11143                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11144     }
11145   %}
11146   ins_pipe( pipe_slow );
11147 %}
11148 
11149 // fast search of substring with known size.
11150 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11151                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11152 %{
11153   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11154   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11155   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11156 
11157   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11158   ins_encode %{
11159     int icnt2 = (int)$int_cnt2$$constant;
11160     if (icnt2 &gt;= 8) {
11161       // IndexOf for constant substrings with size &gt;= 8 elements
11162       // which don&#39;t need to be loaded through stack.
11163       __ string_indexofC8($str1$$Register, $str2$$Register,
11164                           $cnt1$$Register, $cnt2$$Register,
11165                           icnt2, $result$$Register,
11166                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11167     } else {
11168       // Small strings are loaded through stack if they cross page boundary.
11169       __ string_indexof($str1$$Register, $str2$$Register,
11170                         $cnt1$$Register, $cnt2$$Register,
11171                         icnt2, $result$$Register,
11172                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11173     }
11174   %}
11175   ins_pipe( pipe_slow );
11176 %}
11177 
11178 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11179                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11180 %{
11181   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11182   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11183   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11184 
11185   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11186   ins_encode %{
11187     __ string_indexof($str1$$Register, $str2$$Register,
11188                       $cnt1$$Register, $cnt2$$Register,
11189                       (-1), $result$$Register,
11190                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11191   %}
11192   ins_pipe( pipe_slow );
11193 %}
11194 
11195 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11196                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11197 %{
11198   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11199   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11200   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11201 
11202   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11203   ins_encode %{
11204     __ string_indexof($str1$$Register, $str2$$Register,
11205                       $cnt1$$Register, $cnt2$$Register,
11206                       (-1), $result$$Register,
11207                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11208   %}
11209   ins_pipe( pipe_slow );
11210 %}
11211 
11212 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11213                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11214 %{
11215   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11216   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11217   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11218 
11219   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11220   ins_encode %{
11221     __ string_indexof($str1$$Register, $str2$$Register,
11222                       $cnt1$$Register, $cnt2$$Register,
11223                       (-1), $result$$Register,
11224                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11225   %}
11226   ins_pipe( pipe_slow );
11227 %}
11228 
11229 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11230                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11231 %{
11232   predicate(UseSSE42Intrinsics);
11233   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11234   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11235   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11236   ins_encode %{
11237     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11238                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11239   %}
11240   ins_pipe( pipe_slow );
11241 %}
11242 
11243 // fast string equals
11244 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11245                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11246 %{
11247   match(Set result (StrEquals (Binary str1 str2) cnt));
11248   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11249 
11250   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11251   ins_encode %{
11252     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11253                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11254                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11255   %}
11256   ins_pipe( pipe_slow );
11257 %}
11258 
11259 // fast array equals
11260 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11261                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11262 %{
11263   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11264   match(Set result (AryEq ary1 ary2));
11265   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11266 
11267   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11268   ins_encode %{
11269     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11270                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11271                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11272   %}
11273   ins_pipe( pipe_slow );
11274 %}
11275 
11276 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11277                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11278 %{
11279   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11280   match(Set result (AryEq ary1 ary2));
11281   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11282 
11283   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11284   ins_encode %{
11285     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11286                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11287                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11288   %}
11289   ins_pipe( pipe_slow );
11290 %}
11291 
11292 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11293                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11294 %{
11295   match(Set result (HasNegatives ary1 len));
11296   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11297 
11298   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11299   ins_encode %{
11300     __ has_negatives($ary1$$Register, $len$$Register,
11301                      $result$$Register, $tmp3$$Register,
11302                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11303   %}
11304   ins_pipe( pipe_slow );
11305 %}
11306 
11307 // fast char[] to byte[] compression
11308 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11309                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11310   match(Set result (StrCompressedCopy src (Binary dst len)));
11311   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11312 
11313   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11314   ins_encode %{
11315     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11316                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11317                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11318   %}
11319   ins_pipe( pipe_slow );
11320 %}
11321 
11322 // fast byte[] to char[] inflation
11323 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11324                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11325   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11326   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11327 
11328   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11329   ins_encode %{
11330     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11331                           $tmp1$$XMMRegister, $tmp2$$Register);
11332   %}
11333   ins_pipe( pipe_slow );
11334 %}
11335 
11336 // encode char[] to byte[] in ISO_8859_1
11337 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11338                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11339                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11340   match(Set result (EncodeISOArray src (Binary dst len)));
11341   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11342 
11343   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11344   ins_encode %{
11345     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11346                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11347                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11348   %}
11349   ins_pipe( pipe_slow );
11350 %}
11351 
11352 //----------Overflow Math Instructions-----------------------------------------
11353 
11354 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11355 %{
11356   match(Set cr (OverflowAddI op1 op2));
11357   effect(DEF cr, USE_KILL op1, USE op2);
11358 
11359   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11360 
11361   ins_encode %{
11362     __ addl($op1$$Register, $op2$$Register);
11363   %}
11364   ins_pipe(ialu_reg_reg);
11365 %}
11366 
11367 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11368 %{
11369   match(Set cr (OverflowAddI op1 op2));
11370   effect(DEF cr, USE_KILL op1, USE op2);
11371 
11372   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11373 
11374   ins_encode %{
11375     __ addl($op1$$Register, $op2$$constant);
11376   %}
11377   ins_pipe(ialu_reg_reg);
11378 %}
11379 
11380 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11381 %{
11382   match(Set cr (OverflowAddL op1 op2));
11383   effect(DEF cr, USE_KILL op1, USE op2);
11384 
11385   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11386   ins_encode %{
11387     __ addq($op1$$Register, $op2$$Register);
11388   %}
11389   ins_pipe(ialu_reg_reg);
11390 %}
11391 
11392 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11393 %{
11394   match(Set cr (OverflowAddL op1 op2));
11395   effect(DEF cr, USE_KILL op1, USE op2);
11396 
11397   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11398   ins_encode %{
11399     __ addq($op1$$Register, $op2$$constant);
11400   %}
11401   ins_pipe(ialu_reg_reg);
11402 %}
11403 
11404 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11405 %{
11406   match(Set cr (OverflowSubI op1 op2));
11407 
11408   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11409   ins_encode %{
11410     __ cmpl($op1$$Register, $op2$$Register);
11411   %}
11412   ins_pipe(ialu_reg_reg);
11413 %}
11414 
11415 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11416 %{
11417   match(Set cr (OverflowSubI op1 op2));
11418 
11419   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11420   ins_encode %{
11421     __ cmpl($op1$$Register, $op2$$constant);
11422   %}
11423   ins_pipe(ialu_reg_reg);
11424 %}
11425 
11426 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11427 %{
11428   match(Set cr (OverflowSubL op1 op2));
11429 
11430   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11431   ins_encode %{
11432     __ cmpq($op1$$Register, $op2$$Register);
11433   %}
11434   ins_pipe(ialu_reg_reg);
11435 %}
11436 
11437 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11438 %{
11439   match(Set cr (OverflowSubL op1 op2));
11440 
11441   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11442   ins_encode %{
11443     __ cmpq($op1$$Register, $op2$$constant);
11444   %}
11445   ins_pipe(ialu_reg_reg);
11446 %}
11447 
11448 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11449 %{
11450   match(Set cr (OverflowSubI zero op2));
11451   effect(DEF cr, USE_KILL op2);
11452 
11453   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11454   ins_encode %{
11455     __ negl($op2$$Register);
11456   %}
11457   ins_pipe(ialu_reg_reg);
11458 %}
11459 
11460 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11461 %{
11462   match(Set cr (OverflowSubL zero op2));
11463   effect(DEF cr, USE_KILL op2);
11464 
11465   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11466   ins_encode %{
11467     __ negq($op2$$Register);
11468   %}
11469   ins_pipe(ialu_reg_reg);
11470 %}
11471 
11472 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11473 %{
11474   match(Set cr (OverflowMulI op1 op2));
11475   effect(DEF cr, USE_KILL op1, USE op2);
11476 
11477   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11478   ins_encode %{
11479     __ imull($op1$$Register, $op2$$Register);
11480   %}
11481   ins_pipe(ialu_reg_reg_alu0);
11482 %}
11483 
11484 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11485 %{
11486   match(Set cr (OverflowMulI op1 op2));
11487   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11488 
11489   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11490   ins_encode %{
11491     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11492   %}
11493   ins_pipe(ialu_reg_reg_alu0);
11494 %}
11495 
11496 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11497 %{
11498   match(Set cr (OverflowMulL op1 op2));
11499   effect(DEF cr, USE_KILL op1, USE op2);
11500 
11501   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11502   ins_encode %{
11503     __ imulq($op1$$Register, $op2$$Register);
11504   %}
11505   ins_pipe(ialu_reg_reg_alu0);
11506 %}
11507 
11508 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11509 %{
11510   match(Set cr (OverflowMulL op1 op2));
11511   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11512 
11513   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11514   ins_encode %{
11515     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11516   %}
11517   ins_pipe(ialu_reg_reg_alu0);
11518 %}
11519 
11520 
11521 //----------Control Flow Instructions------------------------------------------
11522 // Signed compare Instructions
11523 
11524 // XXX more variants!!
11525 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11526 %{
11527   match(Set cr (CmpI op1 op2));
11528   effect(DEF cr, USE op1, USE op2);
11529 
11530   format %{ &quot;cmpl    $op1, $op2&quot; %}
11531   opcode(0x3B);  /* Opcode 3B /r */
11532   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11533   ins_pipe(ialu_cr_reg_reg);
11534 %}
11535 
11536 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11537 %{
11538   match(Set cr (CmpI op1 op2));
11539 
11540   format %{ &quot;cmpl    $op1, $op2&quot; %}
11541   opcode(0x81, 0x07); /* Opcode 81 /7 */
11542   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11543   ins_pipe(ialu_cr_reg_imm);
11544 %}
11545 
11546 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11547 %{
11548   match(Set cr (CmpI op1 (LoadI op2)));
11549 
11550   ins_cost(500); // XXX
11551   format %{ &quot;cmpl    $op1, $op2&quot; %}
11552   opcode(0x3B); /* Opcode 3B /r */
11553   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11554   ins_pipe(ialu_cr_reg_mem);
11555 %}
11556 
11557 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11558 %{
11559   match(Set cr (CmpI src zero));
11560 
11561   format %{ &quot;testl   $src, $src&quot; %}
11562   opcode(0x85);
11563   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11564   ins_pipe(ialu_cr_reg_imm);
11565 %}
11566 
11567 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11568 %{
11569   match(Set cr (CmpI (AndI src con) zero));
11570 
11571   format %{ &quot;testl   $src, $con&quot; %}
11572   opcode(0xF7, 0x00);
11573   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11574   ins_pipe(ialu_cr_reg_imm);
11575 %}
11576 
11577 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11578 %{
11579   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11580 
11581   format %{ &quot;testl   $src, $mem&quot; %}
11582   opcode(0x85);
11583   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11584   ins_pipe(ialu_cr_reg_mem);
11585 %}
11586 
11587 // Unsigned compare Instructions; really, same as signed except they
11588 // produce an rFlagsRegU instead of rFlagsReg.
11589 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11590 %{
11591   match(Set cr (CmpU op1 op2));
11592 
11593   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11594   opcode(0x3B); /* Opcode 3B /r */
11595   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11596   ins_pipe(ialu_cr_reg_reg);
11597 %}
11598 
11599 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11600 %{
11601   match(Set cr (CmpU op1 op2));
11602 
11603   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11604   opcode(0x81,0x07); /* Opcode 81 /7 */
11605   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11606   ins_pipe(ialu_cr_reg_imm);
11607 %}
11608 
11609 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11610 %{
11611   match(Set cr (CmpU op1 (LoadI op2)));
11612 
11613   ins_cost(500); // XXX
11614   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11615   opcode(0x3B); /* Opcode 3B /r */
11616   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11617   ins_pipe(ialu_cr_reg_mem);
11618 %}
11619 
11620 // // // Cisc-spilled version of cmpU_rReg
11621 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11622 // //%{
11623 // //  match(Set cr (CmpU (LoadI op1) op2));
11624 // //
11625 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11626 // //  ins_cost(500);
11627 // //  opcode(0x39);  /* Opcode 39 /r */
11628 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11629 // //%}
11630 
11631 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11632 %{
11633   match(Set cr (CmpU src zero));
11634 
11635   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11636   opcode(0x85);
11637   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11638   ins_pipe(ialu_cr_reg_imm);
11639 %}
11640 
11641 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11642 %{
11643   match(Set cr (CmpP op1 op2));
11644 
11645   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11646   opcode(0x3B); /* Opcode 3B /r */
11647   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11648   ins_pipe(ialu_cr_reg_reg);
11649 %}
11650 
11651 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11652 %{
11653   match(Set cr (CmpP op1 (LoadP op2)));
11654   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11655 
11656   ins_cost(500); // XXX
11657   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11658   opcode(0x3B); /* Opcode 3B /r */
11659   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11660   ins_pipe(ialu_cr_reg_mem);
11661 %}
11662 
11663 // // // Cisc-spilled version of cmpP_rReg
11664 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11665 // //%{
11666 // //  match(Set cr (CmpP (LoadP op1) op2));
11667 // //
11668 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11669 // //  ins_cost(500);
11670 // //  opcode(0x39);  /* Opcode 39 /r */
11671 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11672 // //%}
11673 
11674 // XXX this is generalized by compP_rReg_mem???
11675 // Compare raw pointer (used in out-of-heap check).
11676 // Only works because non-oop pointers must be raw pointers
11677 // and raw pointers have no anti-dependencies.
11678 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11679 %{
11680   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11681             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11682   match(Set cr (CmpP op1 (LoadP op2)));
11683 
11684   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11685   opcode(0x3B); /* Opcode 3B /r */
11686   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11687   ins_pipe(ialu_cr_reg_mem);
11688 %}
11689 
11690 // This will generate a signed flags result. This should be OK since
11691 // any compare to a zero should be eq/neq.
11692 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11693 %{
11694   match(Set cr (CmpP src zero));
11695 
11696   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11697   opcode(0x85);
11698   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11699   ins_pipe(ialu_cr_reg_imm);
11700 %}
11701 
11702 // This will generate a signed flags result. This should be OK since
11703 // any compare to a zero should be eq/neq.
11704 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11705 %{
11706   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11707             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11708   match(Set cr (CmpP (LoadP op) zero));
11709 
11710   ins_cost(500); // XXX
11711   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11712   opcode(0xF7); /* Opcode F7 /0 */
11713   ins_encode(REX_mem_wide(op),
11714              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11715   ins_pipe(ialu_cr_reg_imm);
11716 %}
11717 
11718 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11719 %{
11720   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11721             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11722   match(Set cr (CmpP (LoadP mem) zero));
11723 
11724   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11725   ins_encode %{
11726     __ cmpq(r12, $mem$$Address);
11727   %}
11728   ins_pipe(ialu_cr_reg_mem);
11729 %}
11730 
11731 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11732 %{
11733   match(Set cr (CmpN op1 op2));
11734 
11735   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11736   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11737   ins_pipe(ialu_cr_reg_reg);
11738 %}
11739 
11740 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11741 %{
11742   match(Set cr (CmpN src (LoadN mem)));
11743 
11744   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11745   ins_encode %{
11746     __ cmpl($src$$Register, $mem$$Address);
11747   %}
11748   ins_pipe(ialu_cr_reg_mem);
11749 %}
11750 
11751 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11752   match(Set cr (CmpN op1 op2));
11753 
11754   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11755   ins_encode %{
11756     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11757   %}
11758   ins_pipe(ialu_cr_reg_imm);
11759 %}
11760 
11761 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11762 %{
11763   match(Set cr (CmpN src (LoadN mem)));
11764 
11765   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11766   ins_encode %{
11767     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11768   %}
11769   ins_pipe(ialu_cr_reg_mem);
11770 %}
11771 
11772 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11773   match(Set cr (CmpN op1 op2));
11774 
11775   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11776   ins_encode %{
11777     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11778   %}
11779   ins_pipe(ialu_cr_reg_imm);
11780 %}
11781 
11782 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11783 %{
11784   match(Set cr (CmpN src (LoadNKlass mem)));
11785 
11786   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11787   ins_encode %{
11788     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11789   %}
11790   ins_pipe(ialu_cr_reg_mem);
11791 %}
11792 
11793 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11794   match(Set cr (CmpN src zero));
11795 
11796   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11797   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11798   ins_pipe(ialu_cr_reg_imm);
11799 %}
11800 
11801 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11802 %{
11803   predicate(CompressedOops::base() != NULL);
11804   match(Set cr (CmpN (LoadN mem) zero));
11805 
11806   ins_cost(500); // XXX
11807   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11808   ins_encode %{
11809     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11810   %}
11811   ins_pipe(ialu_cr_reg_mem);
11812 %}
11813 
11814 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11815 %{
11816   predicate(CompressedOops::base() == NULL);
11817   match(Set cr (CmpN (LoadN mem) zero));
11818 
11819   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11820   ins_encode %{
11821     __ cmpl(r12, $mem$$Address);
11822   %}
11823   ins_pipe(ialu_cr_reg_mem);
11824 %}
11825 
11826 // Yanked all unsigned pointer compare operations.
11827 // Pointer compares are done with CmpP which is already unsigned.
11828 
11829 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11830 %{
11831   match(Set cr (CmpL op1 op2));
11832 
11833   format %{ &quot;cmpq    $op1, $op2&quot; %}
11834   opcode(0x3B);  /* Opcode 3B /r */
11835   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11836   ins_pipe(ialu_cr_reg_reg);
11837 %}
11838 
11839 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11840 %{
11841   match(Set cr (CmpL op1 op2));
11842 
11843   format %{ &quot;cmpq    $op1, $op2&quot; %}
11844   opcode(0x81, 0x07); /* Opcode 81 /7 */
11845   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11846   ins_pipe(ialu_cr_reg_imm);
11847 %}
11848 
11849 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11850 %{
11851   match(Set cr (CmpL op1 (LoadL op2)));
11852 
11853   format %{ &quot;cmpq    $op1, $op2&quot; %}
11854   opcode(0x3B); /* Opcode 3B /r */
11855   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11856   ins_pipe(ialu_cr_reg_mem);
11857 %}
11858 
11859 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11860 %{
11861   match(Set cr (CmpL src zero));
11862 
11863   format %{ &quot;testq   $src, $src&quot; %}
11864   opcode(0x85);
11865   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11866   ins_pipe(ialu_cr_reg_imm);
11867 %}
11868 
11869 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11870 %{
11871   match(Set cr (CmpL (AndL src con) zero));
11872 
11873   format %{ &quot;testq   $src, $con\t# long&quot; %}
11874   opcode(0xF7, 0x00);
11875   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11876   ins_pipe(ialu_cr_reg_imm);
11877 %}
11878 
11879 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11880 %{
11881   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11882 
11883   format %{ &quot;testq   $src, $mem&quot; %}
11884   opcode(0x85);
11885   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11886   ins_pipe(ialu_cr_reg_mem);
11887 %}
11888 
11889 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11890 %{
11891   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11892 
11893   format %{ &quot;testq   $src, $mem&quot; %}
11894   opcode(0x85);
11895   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11896   ins_pipe(ialu_cr_reg_mem);
11897 %}
11898 
11899 // Manifest a CmpL result in an integer register.  Very painful.
11900 // This is the test to avoid.
11901 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11902 %{
11903   match(Set dst (CmpL3 src1 src2));
11904   effect(KILL flags);
11905 
11906   ins_cost(275); // XXX
11907   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11908             &quot;movl    $dst, -1\n\t&quot;
11909             &quot;jl,s    done\n\t&quot;
11910             &quot;setne   $dst\n\t&quot;
11911             &quot;movzbl  $dst, $dst\n\t&quot;
11912     &quot;done:&quot; %}
11913   ins_encode(cmpl3_flag(src1, src2, dst));
11914   ins_pipe(pipe_slow);
11915 %}
11916 
11917 // Unsigned long compare Instructions; really, same as signed long except they
11918 // produce an rFlagsRegU instead of rFlagsReg.
11919 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
11920 %{
11921   match(Set cr (CmpUL op1 op2));
11922 
11923   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11924   opcode(0x3B);  /* Opcode 3B /r */
11925   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11926   ins_pipe(ialu_cr_reg_reg);
11927 %}
11928 
11929 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
11930 %{
11931   match(Set cr (CmpUL op1 op2));
11932 
11933   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11934   opcode(0x81, 0x07); /* Opcode 81 /7 */
11935   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11936   ins_pipe(ialu_cr_reg_imm);
11937 %}
11938 
11939 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
11940 %{
11941   match(Set cr (CmpUL op1 (LoadL op2)));
11942 
11943   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11944   opcode(0x3B); /* Opcode 3B /r */
11945   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11946   ins_pipe(ialu_cr_reg_mem);
11947 %}
11948 
11949 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
11950 %{
11951   match(Set cr (CmpUL src zero));
11952 
11953   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
11954   opcode(0x85);
11955   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11956   ins_pipe(ialu_cr_reg_imm);
11957 %}
11958 
11959 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
11960 %{
11961   match(Set cr (CmpI (LoadB mem) imm));
11962 
11963   ins_cost(125);
11964   format %{ &quot;cmpb    $mem, $imm&quot; %}
11965   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
11966   ins_pipe(ialu_cr_reg_mem);
11967 %}
11968 
11969 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
11970 %{
11971   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
11972 
11973   ins_cost(125);
11974   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
11975   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11976   ins_pipe(ialu_cr_reg_mem);
11977 %}
11978 
11979 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
11980 %{
11981   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
11982 
11983   ins_cost(125);
11984   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
11985   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11986   ins_pipe(ialu_cr_reg_mem);
11987 %}
11988 
11989 //----------Max and Min--------------------------------------------------------
11990 // Min Instructions
11991 
11992 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
11993 %{
11994   effect(USE_DEF dst, USE src, USE cr);
11995 
11996   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
11997   opcode(0x0F, 0x4F);
11998   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11999   ins_pipe(pipe_cmov_reg);
12000 %}
12001 
12002 
12003 instruct minI_rReg(rRegI dst, rRegI src)
12004 %{
12005   match(Set dst (MinI dst src));
12006 
12007   ins_cost(200);
12008   expand %{
12009     rFlagsReg cr;
12010     compI_rReg(cr, dst, src);
12011     cmovI_reg_g(dst, src, cr);
12012   %}
12013 %}
12014 
12015 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12016 %{
12017   effect(USE_DEF dst, USE src, USE cr);
12018 
12019   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12020   opcode(0x0F, 0x4C);
12021   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12022   ins_pipe(pipe_cmov_reg);
12023 %}
12024 
12025 
12026 instruct maxI_rReg(rRegI dst, rRegI src)
12027 %{
12028   match(Set dst (MaxI dst src));
12029 
12030   ins_cost(200);
12031   expand %{
12032     rFlagsReg cr;
12033     compI_rReg(cr, dst, src);
12034     cmovI_reg_l(dst, src, cr);
12035   %}
12036 %}
12037 
12038 // ============================================================================
12039 // Branch Instructions
12040 
12041 // Jump Direct - Label defines a relative address from JMP+1
12042 instruct jmpDir(label labl)
12043 %{
12044   match(Goto);
12045   effect(USE labl);
12046 
12047   ins_cost(300);
12048   format %{ &quot;jmp     $labl&quot; %}
12049   size(5);
12050   ins_encode %{
12051     Label* L = $labl$$label;
12052     __ jmp(*L, false); // Always long jump
12053   %}
12054   ins_pipe(pipe_jmp);
12055 %}
12056 
12057 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12058 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12059 %{
12060   match(If cop cr);
12061   effect(USE labl);
12062 
12063   ins_cost(300);
12064   format %{ &quot;j$cop     $labl&quot; %}
12065   size(6);
12066   ins_encode %{
12067     Label* L = $labl$$label;
12068     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12069   %}
12070   ins_pipe(pipe_jcc);
12071 %}
12072 
12073 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12074 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12075 %{
12076   predicate(!n-&gt;has_vector_mask_set());
12077   match(CountedLoopEnd cop cr);
12078   effect(USE labl);
12079 
12080   ins_cost(300);
12081   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12082   size(6);
12083   ins_encode %{
12084     Label* L = $labl$$label;
12085     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12086   %}
12087   ins_pipe(pipe_jcc);
12088 %}
12089 
12090 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12091 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12092   predicate(!n-&gt;has_vector_mask_set());
12093   match(CountedLoopEnd cop cmp);
12094   effect(USE labl);
12095 
12096   ins_cost(300);
12097   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12098   size(6);
12099   ins_encode %{
12100     Label* L = $labl$$label;
12101     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12102   %}
12103   ins_pipe(pipe_jcc);
12104 %}
12105 
12106 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12107   predicate(!n-&gt;has_vector_mask_set());
12108   match(CountedLoopEnd cop cmp);
12109   effect(USE labl);
12110 
12111   ins_cost(200);
12112   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12113   size(6);
12114   ins_encode %{
12115     Label* L = $labl$$label;
12116     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12117   %}
12118   ins_pipe(pipe_jcc);
12119 %}
12120 
12121 // mask version
12122 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12123 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12124 %{
12125   predicate(n-&gt;has_vector_mask_set());
12126   match(CountedLoopEnd cop cr);
12127   effect(USE labl);
12128 
12129   ins_cost(400);
12130   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12131             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12132   size(10);
12133   ins_encode %{
12134     Label* L = $labl$$label;
12135     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12136     __ restorevectmask();
12137   %}
12138   ins_pipe(pipe_jcc);
12139 %}
12140 
12141 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12142 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12143   predicate(n-&gt;has_vector_mask_set());
12144   match(CountedLoopEnd cop cmp);
12145   effect(USE labl);
12146 
12147   ins_cost(400);
12148   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12149             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12150   size(10);
12151   ins_encode %{
12152     Label* L = $labl$$label;
12153     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12154     __ restorevectmask();
12155   %}
12156   ins_pipe(pipe_jcc);
12157 %}
12158 
12159 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12160   predicate(n-&gt;has_vector_mask_set());
12161   match(CountedLoopEnd cop cmp);
12162   effect(USE labl);
12163 
12164   ins_cost(300);
12165   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12166             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12167   size(10);
12168   ins_encode %{
12169     Label* L = $labl$$label;
12170     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12171     __ restorevectmask();
12172   %}
12173   ins_pipe(pipe_jcc);
12174 %}
12175 
12176 // Jump Direct Conditional - using unsigned comparison
12177 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12178   match(If cop cmp);
12179   effect(USE labl);
12180 
12181   ins_cost(300);
12182   format %{ &quot;j$cop,u   $labl&quot; %}
12183   size(6);
12184   ins_encode %{
12185     Label* L = $labl$$label;
12186     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12187   %}
12188   ins_pipe(pipe_jcc);
12189 %}
12190 
12191 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12192   match(If cop cmp);
12193   effect(USE labl);
12194 
12195   ins_cost(200);
12196   format %{ &quot;j$cop,u   $labl&quot; %}
12197   size(6);
12198   ins_encode %{
12199     Label* L = $labl$$label;
12200     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12201   %}
12202   ins_pipe(pipe_jcc);
12203 %}
12204 
12205 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12206   match(If cop cmp);
12207   effect(USE labl);
12208 
12209   ins_cost(200);
12210   format %{ $$template
12211     if ($cop$$cmpcode == Assembler::notEqual) {
12212       $$emit$$&quot;jp,u    $labl\n\t&quot;
12213       $$emit$$&quot;j$cop,u   $labl&quot;
12214     } else {
12215       $$emit$$&quot;jp,u    done\n\t&quot;
12216       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12217       $$emit$$&quot;done:&quot;
12218     }
12219   %}
12220   ins_encode %{
12221     Label* l = $labl$$label;
12222     if ($cop$$cmpcode == Assembler::notEqual) {
12223       __ jcc(Assembler::parity, *l, false);
12224       __ jcc(Assembler::notEqual, *l, false);
12225     } else if ($cop$$cmpcode == Assembler::equal) {
12226       Label done;
12227       __ jccb(Assembler::parity, done);
12228       __ jcc(Assembler::equal, *l, false);
12229       __ bind(done);
12230     } else {
12231        ShouldNotReachHere();
12232     }
12233   %}
12234   ins_pipe(pipe_jcc);
12235 %}
12236 
12237 // ============================================================================
12238 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12239 // superklass array for an instance of the superklass.  Set a hidden
12240 // internal cache on a hit (cache is checked with exposed code in
12241 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12242 // encoding ALSO sets flags.
12243 
12244 instruct partialSubtypeCheck(rdi_RegP result,
12245                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12246                              rFlagsReg cr)
12247 %{
12248   match(Set result (PartialSubtypeCheck sub super));
12249   effect(KILL rcx, KILL cr);
12250 
12251   ins_cost(1100);  // slightly larger than the next version
12252   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12253             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12254             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12255             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12256             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12257             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12258             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12259     &quot;miss:\t&quot; %}
12260 
12261   opcode(0x1); // Force a XOR of RDI
12262   ins_encode(enc_PartialSubtypeCheck());
12263   ins_pipe(pipe_slow);
12264 %}
12265 
12266 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12267                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12268                                      immP0 zero,
12269                                      rdi_RegP result)
12270 %{
12271   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12272   effect(KILL rcx, KILL result);
12273 
12274   ins_cost(1000);
12275   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12276             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12277             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12278             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12279             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12280             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12281     &quot;miss:\t&quot; %}
12282 
12283   opcode(0x0); // No need to XOR RDI
12284   ins_encode(enc_PartialSubtypeCheck());
12285   ins_pipe(pipe_slow);
12286 %}
12287 
12288 // ============================================================================
12289 // Branch Instructions -- short offset versions
12290 //
12291 // These instructions are used to replace jumps of a long offset (the default
12292 // match) with jumps of a shorter offset.  These instructions are all tagged
12293 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12294 // match rules in general matching.  Instead, the ADLC generates a conversion
12295 // method in the MachNode which can be used to do in-place replacement of the
12296 // long variant with the shorter variant.  The compiler will determine if a
12297 // branch can be taken by the is_short_branch_offset() predicate in the machine
12298 // specific code section of the file.
12299 
12300 // Jump Direct - Label defines a relative address from JMP+1
12301 instruct jmpDir_short(label labl) %{
12302   match(Goto);
12303   effect(USE labl);
12304 
12305   ins_cost(300);
12306   format %{ &quot;jmp,s   $labl&quot; %}
12307   size(2);
12308   ins_encode %{
12309     Label* L = $labl$$label;
12310     __ jmpb(*L);
12311   %}
12312   ins_pipe(pipe_jmp);
12313   ins_short_branch(1);
12314 %}
12315 
12316 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12317 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12318   match(If cop cr);
12319   effect(USE labl);
12320 
12321   ins_cost(300);
12322   format %{ &quot;j$cop,s   $labl&quot; %}
12323   size(2);
12324   ins_encode %{
12325     Label* L = $labl$$label;
12326     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12327   %}
12328   ins_pipe(pipe_jcc);
12329   ins_short_branch(1);
12330 %}
12331 
12332 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12333 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12334   match(CountedLoopEnd cop cr);
12335   effect(USE labl);
12336 
12337   ins_cost(300);
12338   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12339   size(2);
12340   ins_encode %{
12341     Label* L = $labl$$label;
12342     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12343   %}
12344   ins_pipe(pipe_jcc);
12345   ins_short_branch(1);
12346 %}
12347 
12348 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12349 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12350   match(CountedLoopEnd cop cmp);
12351   effect(USE labl);
12352 
12353   ins_cost(300);
12354   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12355   size(2);
12356   ins_encode %{
12357     Label* L = $labl$$label;
12358     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12359   %}
12360   ins_pipe(pipe_jcc);
12361   ins_short_branch(1);
12362 %}
12363 
12364 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12365   match(CountedLoopEnd cop cmp);
12366   effect(USE labl);
12367 
12368   ins_cost(300);
12369   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12370   size(2);
12371   ins_encode %{
12372     Label* L = $labl$$label;
12373     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12374   %}
12375   ins_pipe(pipe_jcc);
12376   ins_short_branch(1);
12377 %}
12378 
12379 // Jump Direct Conditional - using unsigned comparison
12380 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12381   match(If cop cmp);
12382   effect(USE labl);
12383 
12384   ins_cost(300);
12385   format %{ &quot;j$cop,us  $labl&quot; %}
12386   size(2);
12387   ins_encode %{
12388     Label* L = $labl$$label;
12389     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12390   %}
12391   ins_pipe(pipe_jcc);
12392   ins_short_branch(1);
12393 %}
12394 
12395 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12396   match(If cop cmp);
12397   effect(USE labl);
12398 
12399   ins_cost(300);
12400   format %{ &quot;j$cop,us  $labl&quot; %}
12401   size(2);
12402   ins_encode %{
12403     Label* L = $labl$$label;
12404     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12405   %}
12406   ins_pipe(pipe_jcc);
12407   ins_short_branch(1);
12408 %}
12409 
12410 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12411   match(If cop cmp);
12412   effect(USE labl);
12413 
12414   ins_cost(300);
12415   format %{ $$template
12416     if ($cop$$cmpcode == Assembler::notEqual) {
12417       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12418       $$emit$$&quot;j$cop,u,s  $labl&quot;
12419     } else {
12420       $$emit$$&quot;jp,u,s  done\n\t&quot;
12421       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12422       $$emit$$&quot;done:&quot;
12423     }
12424   %}
12425   size(4);
12426   ins_encode %{
12427     Label* l = $labl$$label;
12428     if ($cop$$cmpcode == Assembler::notEqual) {
12429       __ jccb(Assembler::parity, *l);
12430       __ jccb(Assembler::notEqual, *l);
12431     } else if ($cop$$cmpcode == Assembler::equal) {
12432       Label done;
12433       __ jccb(Assembler::parity, done);
12434       __ jccb(Assembler::equal, *l);
12435       __ bind(done);
12436     } else {
12437        ShouldNotReachHere();
12438     }
12439   %}
12440   ins_pipe(pipe_jcc);
12441   ins_short_branch(1);
12442 %}
12443 
12444 // ============================================================================
12445 // inlined locking and unlocking
12446 
12447 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12448   predicate(Compile::current()-&gt;use_rtm());
12449   match(Set cr (FastLock object box));
12450   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12451   ins_cost(300);
12452   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12453   ins_encode %{
12454     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12455                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12456                  _counters, _rtm_counters, _stack_rtm_counters,
12457                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12458                  true, ra_-&gt;C-&gt;profile_rtm());
12459   %}
12460   ins_pipe(pipe_slow);
12461 %}
12462 
12463 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr, rRegP cx1) %{
12464   predicate(!Compile::current()-&gt;use_rtm());
12465   match(Set cr (FastLock object box));
12466   effect(TEMP tmp, TEMP scr, TEMP cx1, USE_KILL box);
12467   ins_cost(300);
12468   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12469   ins_encode %{
12470     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12471                  $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);
12472   %}
12473   ins_pipe(pipe_slow);
12474 %}
12475 
12476 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12477   match(Set cr (FastUnlock object box));
12478   effect(TEMP tmp, USE_KILL box);
12479   ins_cost(300);
12480   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12481   ins_encode %{
12482     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12483   %}
12484   ins_pipe(pipe_slow);
12485 %}
12486 
12487 
12488 // ============================================================================
12489 // Safepoint Instructions
12490 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12491 %{
12492   match(SafePoint poll);
12493   effect(KILL cr, USE poll);
12494 
12495   format %{ &quot;testl   rax, [$poll]\t&quot;
12496             &quot;# Safepoint: poll for GC&quot; %}
12497   ins_cost(125);
12498   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12499   ins_encode %{
12500     __ relocate(relocInfo::poll_type);
12501     address pre_pc = __ pc();
12502     __ testl(rax, Address($poll$$Register, 0));
12503     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12504   %}
12505   ins_pipe(ialu_reg_mem);
12506 %}
12507 
12508 // ============================================================================
12509 // Procedure Call/Return Instructions
12510 // Call Java Static Instruction
12511 // Note: If this code changes, the corresponding ret_addr_offset() and
12512 //       compute_padding() functions will have to be adjusted.
12513 instruct CallStaticJavaDirect(method meth) %{
12514   match(CallStaticJava);
12515   effect(USE meth);
12516 
12517   ins_cost(300);
12518   format %{ &quot;call,static &quot; %}
12519   opcode(0xE8); /* E8 cd */
12520   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12521   ins_pipe(pipe_slow);
12522   ins_alignment(4);
12523 %}
12524 
12525 // Call Java Dynamic Instruction
12526 // Note: If this code changes, the corresponding ret_addr_offset() and
12527 //       compute_padding() functions will have to be adjusted.
12528 instruct CallDynamicJavaDirect(method meth)
12529 %{
12530   match(CallDynamicJava);
12531   effect(USE meth);
12532 
12533   ins_cost(300);
12534   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12535             &quot;call,dynamic &quot; %}
12536   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12537   ins_pipe(pipe_slow);
12538   ins_alignment(4);
12539 %}
12540 
12541 // Call Runtime Instruction
12542 instruct CallRuntimeDirect(method meth)
12543 %{
12544   match(CallRuntime);
12545   effect(USE meth);
12546 
12547   ins_cost(300);
12548   format %{ &quot;call,runtime &quot; %}
12549   ins_encode(clear_avx, Java_To_Runtime(meth));
12550   ins_pipe(pipe_slow);
12551 %}
12552 
12553 // Call runtime without safepoint
12554 instruct CallLeafDirect(method meth)
12555 %{
12556   match(CallLeaf);
12557   effect(USE meth);
12558 
12559   ins_cost(300);
12560   format %{ &quot;call_leaf,runtime &quot; %}
12561   ins_encode(clear_avx, Java_To_Runtime(meth));
12562   ins_pipe(pipe_slow);
12563 %}
12564 
12565 //
12566 instruct CallNativeDirect(method meth)
12567 %{
12568   match(CallNative);
12569   effect(USE meth);
12570 
12571   ins_cost(300);
12572   format %{ &quot;call_native &quot; %}
12573   ins_encode(clear_avx, Java_To_Runtime(meth));
12574   ins_pipe(pipe_slow);
12575 %}
12576 
12577 // Call runtime without safepoint
12578 instruct CallLeafNoFPDirect(method meth)
12579 %{
12580   match(CallLeafNoFP);
12581   effect(USE meth);
12582 
12583   ins_cost(300);
12584   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12585   ins_encode(clear_avx, Java_To_Runtime(meth));
12586   ins_pipe(pipe_slow);
12587 %}
12588 
12589 // Return Instruction
12590 // Remove the return address &amp; jump to it.
12591 // Notice: We always emit a nop after a ret to make sure there is room
12592 // for safepoint patching
12593 instruct Ret()
12594 %{
12595   match(Return);
12596 
12597   format %{ &quot;ret&quot; %}
12598   opcode(0xC3);
12599   ins_encode(OpcP);
12600   ins_pipe(pipe_jmp);
12601 %}
12602 
12603 // Tail Call; Jump from runtime stub to Java code.
12604 // Also known as an &#39;interprocedural jump&#39;.
12605 // Target of jump will eventually return to caller.
12606 // TailJump below removes the return address.
<a name="1" id="anc1"></a><span class="line-modified">12607 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_ptr)</span>
12608 %{
<a name="2" id="anc2"></a><span class="line-modified">12609   match(TailCall jump_target method_ptr);</span>
12610 
12611   ins_cost(300);
<a name="3" id="anc3"></a><span class="line-modified">12612   format %{ &quot;jmp     $jump_target\t# rbx holds method&quot; %}</span>
12613   opcode(0xFF, 0x4); /* Opcode FF /4 */
12614   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12615   ins_pipe(pipe_jmp);
12616 %}
12617 
12618 // Tail Jump; remove the return address; jump to target.
12619 // TailCall above leaves the return address around.
12620 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12621 %{
12622   match(TailJump jump_target ex_oop);
12623 
12624   ins_cost(300);
12625   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12626             &quot;jmp     $jump_target&quot; %}
12627   opcode(0xFF, 0x4); /* Opcode FF /4 */
12628   ins_encode(Opcode(0x5a), // popq rdx
12629              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12630   ins_pipe(pipe_jmp);
12631 %}
12632 
12633 // Create exception oop: created by stack-crawling runtime code.
12634 // Created exception is now available to this handler, and is setup
12635 // just prior to jumping to this handler.  No code emitted.
12636 instruct CreateException(rax_RegP ex_oop)
12637 %{
12638   match(Set ex_oop (CreateEx));
12639 
12640   size(0);
12641   // use the following format syntax
12642   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12643   ins_encode();
12644   ins_pipe(empty);
12645 %}
12646 
12647 // Rethrow exception:
12648 // The exception oop will come in the first argument position.
12649 // Then JUMP (not call) to the rethrow stub code.
12650 instruct RethrowException()
12651 %{
12652   match(Rethrow);
12653 
12654   // use the following format syntax
12655   format %{ &quot;jmp     rethrow_stub&quot; %}
12656   ins_encode(enc_rethrow);
12657   ins_pipe(pipe_jmp);
12658 %}
12659 
12660 // ============================================================================
12661 // This name is KNOWN by the ADLC and cannot be changed.
12662 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12663 // for this guy.
12664 instruct tlsLoadP(r15_RegP dst) %{
12665   match(Set dst (ThreadLocal));
12666   effect(DEF dst);
12667 
12668   size(0);
12669   format %{ &quot;# TLS is in R15&quot; %}
12670   ins_encode( /*empty encoding*/ );
12671   ins_pipe(ialu_reg_reg);
12672 %}
12673 
12674 
12675 //----------PEEPHOLE RULES-----------------------------------------------------
12676 // These must follow all instruction definitions as they use the names
12677 // defined in the instructions definitions.
12678 //
12679 // peepmatch ( root_instr_name [preceding_instruction]* );
12680 //
12681 // peepconstraint %{
12682 // (instruction_number.operand_name relational_op instruction_number.operand_name
12683 //  [, ...] );
12684 // // instruction numbers are zero-based using left to right order in peepmatch
12685 //
12686 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12687 // // provide an instruction_number.operand_name for each operand that appears
12688 // // in the replacement instruction&#39;s match rule
12689 //
12690 // ---------VM FLAGS---------------------------------------------------------
12691 //
12692 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12693 //
12694 // Each peephole rule is given an identifying number starting with zero and
12695 // increasing by one in the order seen by the parser.  An individual peephole
12696 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12697 // on the command-line.
12698 //
12699 // ---------CURRENT LIMITATIONS----------------------------------------------
12700 //
12701 // Only match adjacent instructions in same basic block
12702 // Only equality constraints
12703 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12704 // Only one replacement instruction
12705 //
12706 // ---------EXAMPLE----------------------------------------------------------
12707 //
12708 // // pertinent parts of existing instructions in architecture description
12709 // instruct movI(rRegI dst, rRegI src)
12710 // %{
12711 //   match(Set dst (CopyI src));
12712 // %}
12713 //
12714 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12715 // %{
12716 //   match(Set dst (AddI dst src));
12717 //   effect(KILL cr);
12718 // %}
12719 //
12720 // // Change (inc mov) to lea
12721 // peephole %{
12722 //   // increment preceeded by register-register move
12723 //   peepmatch ( incI_rReg movI );
12724 //   // require that the destination register of the increment
12725 //   // match the destination register of the move
12726 //   peepconstraint ( 0.dst == 1.dst );
12727 //   // construct a replacement instruction that sets
12728 //   // the destination to ( move&#39;s source register + one )
12729 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12730 // %}
12731 //
12732 
12733 // Implementation no longer uses movX instructions since
12734 // machine-independent system no longer uses CopyX nodes.
12735 //
12736 // peephole
12737 // %{
12738 //   peepmatch (incI_rReg movI);
12739 //   peepconstraint (0.dst == 1.dst);
12740 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12741 // %}
12742 
12743 // peephole
12744 // %{
12745 //   peepmatch (decI_rReg movI);
12746 //   peepconstraint (0.dst == 1.dst);
12747 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12748 // %}
12749 
12750 // peephole
12751 // %{
12752 //   peepmatch (addI_rReg_imm movI);
12753 //   peepconstraint (0.dst == 1.dst);
12754 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12755 // %}
12756 
12757 // peephole
12758 // %{
12759 //   peepmatch (incL_rReg movL);
12760 //   peepconstraint (0.dst == 1.dst);
12761 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12762 // %}
12763 
12764 // peephole
12765 // %{
12766 //   peepmatch (decL_rReg movL);
12767 //   peepconstraint (0.dst == 1.dst);
12768 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12769 // %}
12770 
12771 // peephole
12772 // %{
12773 //   peepmatch (addL_rReg_imm movL);
12774 //   peepconstraint (0.dst == 1.dst);
12775 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12776 // %}
12777 
12778 // peephole
12779 // %{
12780 //   peepmatch (addP_rReg_imm movP);
12781 //   peepconstraint (0.dst == 1.dst);
12782 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12783 // %}
12784 
12785 // // Change load of spilled value to only a spill
12786 // instruct storeI(memory mem, rRegI src)
12787 // %{
12788 //   match(Set mem (StoreI mem src));
12789 // %}
12790 //
12791 // instruct loadI(rRegI dst, memory mem)
12792 // %{
12793 //   match(Set dst (LoadI mem));
12794 // %}
12795 //
12796 
12797 peephole
12798 %{
12799   peepmatch (loadI storeI);
12800   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12801   peepreplace (storeI(1.mem 1.mem 1.src));
12802 %}
12803 
12804 peephole
12805 %{
12806   peepmatch (loadL storeL);
12807   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12808   peepreplace (storeL(1.mem 1.mem 1.src));
12809 %}
12810 
12811 //----------SMARTSPILL RULES---------------------------------------------------
12812 // These must follow all instruction definitions as they use the names
12813 // defined in the instructions definitions.
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>