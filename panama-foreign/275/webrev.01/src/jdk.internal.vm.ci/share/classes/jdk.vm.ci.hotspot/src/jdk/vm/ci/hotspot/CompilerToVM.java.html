<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package jdk.vm.ci.hotspot;
  25 
  26 import static jdk.vm.ci.common.InitTimer.timer;
  27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  28 
  29 import java.lang.reflect.Executable;
  30 import java.lang.reflect.Field;
  31 
  32 import jdk.vm.ci.code.BytecodeFrame;
  33 import jdk.vm.ci.code.InstalledCode;
  34 import jdk.vm.ci.code.InvalidInstalledCodeException;
  35 import jdk.vm.ci.code.TargetDescription;
  36 import jdk.vm.ci.code.stack.InspectedFrameVisitor;
  37 import jdk.vm.ci.common.InitTimer;
  38 import jdk.vm.ci.common.JVMCIError;
  39 import jdk.vm.ci.meta.Constant;
  40 import jdk.vm.ci.meta.ConstantReflectionProvider;
  41 import jdk.vm.ci.meta.JavaConstant;
  42 import jdk.vm.ci.meta.JavaKind;
  43 import jdk.vm.ci.meta.JavaType;
  44 import jdk.vm.ci.meta.ResolvedJavaMethod;
  45 import jdk.vm.ci.meta.ResolvedJavaType;
  46 
  47 /**
  48  * Calls from Java into HotSpot. The behavior of all the methods in this class that take a native
  49  * pointer as an argument (e.g., {@link #getSymbol(long)}) is undefined if the argument does not
  50  * denote a valid native object.
  51  */
  52 final class CompilerToVM {
  53     /**
  54      * Initializes the native part of the JVMCI runtime.
  55      */
  56     private static native void registerNatives();
  57 
  58     /**
  59      * These values mirror the equivalent values from {@code Unsafe} but are appropriate for the JVM
  60      * being compiled against.
  61      */
  62     // Checkstyle: stop
  63     final int ARRAY_BOOLEAN_BASE_OFFSET;
  64     final int ARRAY_BYTE_BASE_OFFSET;
  65     final int ARRAY_SHORT_BASE_OFFSET;
  66     final int ARRAY_CHAR_BASE_OFFSET;
  67     final int ARRAY_INT_BASE_OFFSET;
  68     final int ARRAY_LONG_BASE_OFFSET;
  69     final int ARRAY_FLOAT_BASE_OFFSET;
  70     final int ARRAY_DOUBLE_BASE_OFFSET;
  71     final int ARRAY_OBJECT_BASE_OFFSET;
  72     final int ARRAY_BOOLEAN_INDEX_SCALE;
  73     final int ARRAY_BYTE_INDEX_SCALE;
  74     final int ARRAY_SHORT_INDEX_SCALE;
  75     final int ARRAY_CHAR_INDEX_SCALE;
  76     final int ARRAY_INT_INDEX_SCALE;
  77     final int ARRAY_LONG_INDEX_SCALE;
  78     final int ARRAY_FLOAT_INDEX_SCALE;
  79     final int ARRAY_DOUBLE_INDEX_SCALE;
  80     final int ARRAY_OBJECT_INDEX_SCALE;
  81     // Checkstyle: resume
  82 
  83     @SuppressWarnings(&quot;try&quot;)
  84     CompilerToVM() {
  85         try (InitTimer t = timer(&quot;CompilerToVM.registerNatives&quot;)) {
  86             registerNatives();
  87             ARRAY_BOOLEAN_BASE_OFFSET = arrayBaseOffset(JavaKind.Boolean);
  88             ARRAY_BYTE_BASE_OFFSET = arrayBaseOffset(JavaKind.Byte);
  89             ARRAY_SHORT_BASE_OFFSET = arrayBaseOffset(JavaKind.Short);
  90             ARRAY_CHAR_BASE_OFFSET = arrayBaseOffset(JavaKind.Char);
  91             ARRAY_INT_BASE_OFFSET = arrayBaseOffset(JavaKind.Int);
  92             ARRAY_LONG_BASE_OFFSET = arrayBaseOffset(JavaKind.Long);
  93             ARRAY_FLOAT_BASE_OFFSET = arrayBaseOffset(JavaKind.Float);
  94             ARRAY_DOUBLE_BASE_OFFSET = arrayBaseOffset(JavaKind.Double);
  95             ARRAY_OBJECT_BASE_OFFSET = arrayBaseOffset(JavaKind.Object);
  96             ARRAY_BOOLEAN_INDEX_SCALE = arrayIndexScale(JavaKind.Boolean);
  97             ARRAY_BYTE_INDEX_SCALE = arrayIndexScale(JavaKind.Byte);
  98             ARRAY_SHORT_INDEX_SCALE = arrayIndexScale(JavaKind.Short);
  99             ARRAY_CHAR_INDEX_SCALE = arrayIndexScale(JavaKind.Char);
 100             ARRAY_INT_INDEX_SCALE = arrayIndexScale(JavaKind.Int);
 101             ARRAY_LONG_INDEX_SCALE = arrayIndexScale(JavaKind.Long);
 102             ARRAY_FLOAT_INDEX_SCALE = arrayIndexScale(JavaKind.Float);
 103             ARRAY_DOUBLE_INDEX_SCALE = arrayIndexScale(JavaKind.Double);
 104             ARRAY_OBJECT_INDEX_SCALE = arrayIndexScale(JavaKind.Object);
 105         }
 106     }
 107 
 108     native int arrayBaseOffset(JavaKind kind);
 109 
 110     native int arrayIndexScale(JavaKind kind);
 111 
 112     /**
 113      * Gets the {@link CompilerToVM} instance associated with the singleton
 114      * {@link HotSpotJVMCIRuntime} instance.
 115      */
 116     public static CompilerToVM compilerToVM() {
 117         return runtime().getCompilerToVM();
 118     }
 119 
 120     /**
 121      * Copies the original bytecode of {@code method} into a new byte array and returns it.
 122      *
 123      * @return a new byte array containing the original bytecode of {@code method}
 124      */
 125     native byte[] getBytecode(HotSpotResolvedJavaMethodImpl method);
 126 
 127     /**
 128      * Gets the number of entries in {@code method}&#39;s exception handler table or 0 if it has no
 129      * exception handler table.
 130      */
 131     native int getExceptionTableLength(HotSpotResolvedJavaMethodImpl method);
 132 
 133     /**
 134      * Gets the address of the first entry in {@code method}&#39;s exception handler table.
 135      *
 136      * Each entry is a native object described by these fields:
 137      *
 138      * &lt;ul&gt;
 139      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementSize}&lt;/li&gt;
 140      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementStartPcOffset}&lt;/li&gt;
 141      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementEndPcOffset}&lt;/li&gt;
 142      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementHandlerPcOffset}&lt;/li&gt;
 143      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementCatchTypeIndexOffset}
 144      * &lt;/ul&gt;
 145      *
 146      * @return 0 if {@code method} has no exception handlers (i.e.
 147      *         {@code getExceptionTableLength(method) == 0})
 148      */
 149     native long getExceptionTableStart(HotSpotResolvedJavaMethodImpl method);
 150 
 151     /**
 152      * Determines whether {@code method} is currently compilable by the JVMCI compiler being used by
 153      * the VM. This can return false if JVMCI compilation failed earlier for {@code method}, a
 154      * breakpoint is currently set in {@code method} or {@code method} contains other bytecode
 155      * features that require special handling by the VM.
 156      */
 157     native boolean isCompilable(HotSpotResolvedJavaMethodImpl method);
 158 
 159     /**
 160      * Determines if {@code method} is targeted by a VM directive (e.g.,
 161      * {@code -XX:CompileCommand=dontinline,&lt;pattern&gt;}) or annotation (e.g.,
 162      * {@code jdk.internal.vm.annotation.DontInline}) that specifies it should not be inlined.
 163      */
 164     native boolean hasNeverInlineDirective(HotSpotResolvedJavaMethodImpl method);
 165 
 166     /**
 167      * Determines if {@code method} should be inlined at any cost. This could be because:
 168      * &lt;ul&gt;
 169      * &lt;li&gt;a CompileOracle directive may forces inlining of this methods&lt;/li&gt;
 170      * &lt;li&gt;an annotation forces inlining of this method&lt;/li&gt;
 171      * &lt;/ul&gt;
 172      */
 173     native boolean shouldInlineMethod(HotSpotResolvedJavaMethodImpl method);
 174 
 175     /**
 176      * Used to implement {@link ResolvedJavaType#findUniqueConcreteMethod(ResolvedJavaMethod)}.
 177      *
 178      * @param method the method on which to base the search
 179      * @param actualHolderType the best known type of receiver
 180      * @return the method result or 0 is there is no unique concrete method for {@code method}
 181      */
 182     native HotSpotResolvedJavaMethodImpl findUniqueConcreteMethod(HotSpotResolvedObjectTypeImpl actualHolderType, HotSpotResolvedJavaMethodImpl method);
 183 
 184     /**
 185      * Gets the implementor for the interface class {@code type}.
 186      *
 187      * @return the implementor if there is a single implementor, {@code null} if there is no
 188      *         implementor, or {@code type} itself if there is more than one implementor
 189      * @throws IllegalArgumentException if type is not an interface type
 190      */
 191     native HotSpotResolvedObjectTypeImpl getImplementor(HotSpotResolvedObjectTypeImpl type);
 192 
 193     /**
 194      * Determines if {@code method} is ignored by security stack walks.
 195      */
 196     native boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethodImpl method);
 197 
 198     /**
 199      * Converts a name to a type.
 200      *
 201      * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
 202      * @param accessingClass the context of resolution. A value of {@code null} implies that the
 203      *            class should be resolved with the class loader.
 204      * @param resolve force resolution to a {@link ResolvedJavaType}. If true, this method will
 205      *            either return a {@link ResolvedJavaType} or throw an exception
 206      * @return the type for {@code name} or 0 if resolution failed and {@code resolve == false}
 207      * @throws ClassNotFoundException if {@code resolve == true} and the resolution failed
 208      */
 209     native HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, boolean resolve) throws ClassNotFoundException;
 210 
 211     native HotSpotResolvedJavaType lookupClass(Class&lt;?&gt; javaClass);
 212 
 213     /**
 214      * Resolves the entry at index {@code cpi} in {@code constantPool} to an object, looking in the
 215      * constant pool cache first.
 216      *
 217      * The behavior of this method is undefined if {@code cpi} does not denote one of the following
 218      * entry types: {@code JVM_CONSTANT_String}, {@code JVM_CONSTANT_MethodHandle},
 219      * {@code JVM_CONSTANT_MethodHandleInError}, {@code JVM_CONSTANT_MethodType} and
 220      * {@code JVM_CONSTANT_MethodTypeInError}.
 221      */
 222     native HotSpotObjectConstantImpl resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi);
 223 
 224     /**
 225      * Gets the {@code JVM_CONSTANT_NameAndType} index from the entry at index {@code cpi} in
 226      * {@code constantPool}.
 227      *
 228      * The behavior of this method is undefined if {@code cpi} does not denote an entry containing a
 229      * {@code JVM_CONSTANT_NameAndType} index.
 230      */
 231     native int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, int cpi);
 232 
 233     /**
 234      * Gets the name of the {@code JVM_CONSTANT_NameAndType} entry referenced by another entry
 235      * denoted by {@code which} in {@code constantPool}.
 236      *
 237      * The behavior of this method is undefined if {@code which} does not denote a entry that
 238      * references a {@code JVM_CONSTANT_NameAndType} entry.
 239      */
 240     native String lookupNameInPool(HotSpotConstantPool constantPool, int which);
 241 
 242     /**
 243      * Gets the signature of the {@code JVM_CONSTANT_NameAndType} entry referenced by another entry
 244      * denoted by {@code which} in {@code constantPool}.
 245      *
 246      * The behavior of this method is undefined if {@code which} does not denote a entry that
 247      * references a {@code JVM_CONSTANT_NameAndType} entry.
 248      */
 249     native String lookupSignatureInPool(HotSpotConstantPool constantPool, int which);
 250 
 251     /**
 252      * Gets the {@code JVM_CONSTANT_Class} index from the entry at index {@code cpi} in
 253      * {@code constantPool}.
 254      *
 255      * The behavior of this method is undefined if {@code cpi} does not denote an entry containing a
 256      * {@code JVM_CONSTANT_Class} index.
 257      */
 258     native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int cpi);
 259 
 260     /**
 261      * Looks up a class denoted by the {@code JVM_CONSTANT_Class} entry at index {@code cpi} in
 262      * {@code constantPool}. This method does not perform any resolution.
 263      *
 264      * The behavior of this method is undefined if {@code cpi} does not denote a
 265      * {@code JVM_CONSTANT_Class} entry.
 266      *
 267      * @return the resolved class entry or a String otherwise
 268      */
 269     native Object lookupKlassInPool(HotSpotConstantPool constantPool, int cpi);
 270 
 271     /**
 272      * Looks up a method denoted by the entry at index {@code cpi} in {@code constantPool}. This
 273      * method does not perform any resolution.
 274      *
 275      * The behavior of this method is undefined if {@code cpi} does not denote an entry representing
 276      * a method.
 277      *
 278      * @param opcode the opcode of the instruction for which the lookup is being performed or
 279      *            {@code -1}. If non-negative, then resolution checks specific to the bytecode it
 280      *            denotes are performed if the method is already resolved. Should any of these
 281      *            checks fail, 0 is returned.
 282      * @return the resolved method entry, 0 otherwise
 283      */
 284     native HotSpotResolvedJavaMethodImpl lookupMethodInPool(HotSpotConstantPool constantPool, int cpi, byte opcode);
 285 
 286     // TODO resolving JVM_CONSTANT_Dynamic
 287 
 288     /**
 289      * Ensures that the type referenced by the specified {@code JVM_CONSTANT_InvokeDynamic} entry at
 290      * index {@code cpi} in {@code constantPool} is loaded and initialized.
 291      *
 292      * The behavior of this method is undefined if {@code cpi} does not denote a
 293      * {@code JVM_CONSTANT_InvokeDynamic} entry.
 294      */
 295     native void resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, int cpi);
 296 
 297     /**
 298      * If {@code cpi} denotes an entry representing a
 299      * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9&quot;&gt;signature
 300      * polymorphic&lt;/a&gt; method, this method ensures that the type referenced by the entry is loaded
 301      * and initialized. It {@code cpi} does not denote a signature polymorphic method, this method
 302      * does nothing.
 303      */
 304     native void resolveInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);
 305 
 306     /**
 307      * If {@code cpi} denotes an entry representing a resolved dynamic adapter (see
 308      * {@link #resolveInvokeDynamicInPool} and {@link #resolveInvokeHandleInPool}), return the
 309      * opcode of the instruction for which the resolution was performed ({@code invokedynamic} or
 310      * {@code invokevirtual}), or {@code -1} otherwise.
 311      */
 312     native int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);
 313 
 314     /**
 315      * Gets the list of type names (in the format of {@link JavaType#getName()}) denoting the
 316      * classes that define signature polymorphic methods.
 317      */
 318     native String[] getSignaturePolymorphicHolders();
 319 
 320     /**
 321      * Gets the resolved type denoted by the entry at index {@code cpi} in {@code constantPool}.
 322      *
 323      * The behavior of this method is undefined if {@code cpi} does not denote an entry representing
 324      * a class.
 325      *
 326      * @throws LinkageError if resolution failed
 327      */
 328     native HotSpotResolvedObjectTypeImpl resolveTypeInPool(HotSpotConstantPool constantPool, int cpi) throws LinkageError;
 329 
 330     /**
 331      * Looks up and attempts to resolve the {@code JVM_CONSTANT_Field} entry for at index
 332      * {@code cpi} in {@code constantPool}. For some opcodes, checks are performed that require the
 333      * {@code method} that contains {@code opcode} to be specified. The values returned in
 334      * {@code info} are:
 335      *
 336      * &lt;pre&gt;
 337      *     [ flags,  // fieldDescriptor::access_flags()
 338      *       offset, // fieldDescriptor::offset()
 339      *       index   // fieldDescriptor::index()
 340      *     ]
 341      * &lt;/pre&gt;
 342      *
 343      * The behavior of this method is undefined if {@code cpi} does not denote a
 344      * {@code JVM_CONSTANT_Field} entry.
 345      *
 346      * @param info an array in which the details of the field are returned
 347      * @return the type defining the field if resolution is successful, 0 otherwise
 348      */
 349     native HotSpotResolvedObjectTypeImpl resolveFieldInPool(HotSpotConstantPool constantPool, int cpi, HotSpotResolvedJavaMethodImpl method, byte opcode, int[] info);
 350 
 351     /**
 352      * Converts {@code cpci} from an index into the cache for {@code constantPool} to an index
 353      * directly into {@code constantPool}.
 354      *
 355      * The behavior of this method is undefined if {@code ccpi} is an invalid constant pool cache
 356      * index.
 357      */
 358     native int constantPoolRemapInstructionOperandFromCache(HotSpotConstantPool constantPool, int cpci);
 359 
 360     /**
 361      * Gets the appendix object (if any) associated with the entry at index {@code cpi} in
 362      * {@code constantPool}.
 363      */
 364     native HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, int cpi);
 365 
 366     /**
 367      * Installs the result of a compilation into the code cache.
 368      *
 369      * @param target the target where this code should be installed
 370      * @param compiledCode the result of a compilation
 371      * @param code the details of the installed CodeBlob are written to this object
 372      * @return the outcome of the installation which will be one of
 373      *         {@link HotSpotVMConfig#codeInstallResultOk},
 374      *         {@link HotSpotVMConfig#codeInstallResultCacheFull},
 375      *         {@link HotSpotVMConfig#codeInstallResultCodeTooLarge} or
 376      *         {@link HotSpotVMConfig#codeInstallResultDependenciesFailed}.
 377      * @throws JVMCIError if there is something wrong with the compiled code or the associated
 378      *             metadata.
 379      */
 380     native int installCode(TargetDescription target, HotSpotCompiledCode compiledCode, InstalledCode code, long failedSpeculationsAddress, byte[] speculations);
 381 
 382     /**
 383      * Generates the VM metadata for some compiled code and copies them into {@code metaData}. This
 384      * method does not install anything into the code cache.
 385      *
 386      * @param target the target where this code would be installed
 387      * @param compiledCode the result of a compilation
 388      * @param metaData the metadata is written to this object
 389      * @return the outcome of the installation which will be one of
 390      *         {@link HotSpotVMConfig#codeInstallResultOk},
 391      *         {@link HotSpotVMConfig#codeInstallResultCacheFull},
 392      *         {@link HotSpotVMConfig#codeInstallResultCodeTooLarge} or
 393      *         {@link HotSpotVMConfig#codeInstallResultDependenciesFailed}.
 394      * @throws JVMCIError if there is something wrong with the compiled code or the metadata
 395      */
 396     native int getMetadata(TargetDescription target, HotSpotCompiledCode compiledCode, HotSpotMetaData metaData);
 397 
 398     /**
 399      * Resets all compilation statistics.
 400      */
 401     native void resetCompilationStatistics();
 402 
 403     /**
 404      * Reads the database of VM info. The return value encodes the info in a nested object array
 405      * that is described by the pseudo Java object {@code info} below:
 406      *
 407      * &lt;pre&gt;
 408      *     info = [
 409      *         VMField[] vmFields,
 410      *         [String name, Long size, ...] vmTypeSizes,
 411      *         [String name, Long value, ...] vmConstants,
 412      *         [String name, Long value, ...] vmAddresses,
 413      *         VMFlag[] vmFlags
 414      *         VMIntrinsicMethod[] vmIntrinsics
 415      *     ]
 416      * &lt;/pre&gt;
 417      *
 418      * @return VM info as encoded above
 419      */
 420     native Object[] readConfiguration();
 421 
 422     /**
 423      * Resolves the implementation of {@code method} for virtual dispatches on objects of dynamic
 424      * type {@code exactReceiver}. This resolution process only searches &quot;up&quot; the class hierarchy of
 425      * {@code exactReceiver}.
 426      *
 427      * @param caller the caller or context type used to perform access checks
 428      * @return the link-time resolved method (might be abstract) or {@code null} if it is either a
 429      *         signature polymorphic method or can not be linked.
 430      */
 431     native HotSpotResolvedJavaMethodImpl resolveMethod(HotSpotResolvedObjectTypeImpl exactReceiver, HotSpotResolvedJavaMethodImpl method, HotSpotResolvedObjectTypeImpl caller);
 432 
 433     /**
 434      * Gets the static initializer of {@code type}.
 435      *
 436      * @return {@code null} if {@code type} has no static initializer
 437      */
 438     native HotSpotResolvedJavaMethodImpl getClassInitializer(HotSpotResolvedObjectTypeImpl type);
 439 
 440     /**
 441      * Determines if {@code type} or any of its currently loaded subclasses overrides
 442      * {@code Object.finalize()}.
 443      */
 444     native boolean hasFinalizableSubclass(HotSpotResolvedObjectTypeImpl type);
 445 
 446     /**
 447      * Gets the method corresponding to {@code executable}.
 448      */
 449     native HotSpotResolvedJavaMethodImpl asResolvedJavaMethod(Executable executable);
 450 
 451     /**
 452      * Gets the maximum absolute offset of a PC relative call to {@code address} from any position
 453      * in the code cache.
 454      *
 455      * @param address an address that may be called from any code in the code cache
 456      * @return -1 if {@code address == 0}
 457      */
 458     native long getMaxCallTargetOffset(long address);
 459 
 460     /**
 461      * Gets a textual disassembly of {@code codeBlob}.
 462      *
 463      * @return a non-zero length string containing a disassembly of {@code codeBlob} or null if
 464      *         {@code codeBlob} could not be disassembled for some reason
 465      */
 466     // The HotSpot disassembler seems not to be thread safe so it&#39;s better to synchronize its usage
 467     synchronized native String disassembleCodeBlob(InstalledCode installedCode);
 468 
 469     /**
 470      * Gets a stack trace element for {@code method} at bytecode index {@code bci}.
 471      */
 472     native StackTraceElement getStackTraceElement(HotSpotResolvedJavaMethodImpl method, int bci);
 473 
 474     /**
 475      * Executes some {@code installedCode} with arguments {@code args}.
 476      *
 477      * @return the result of executing {@code nmethodMirror}
 478      * @throws InvalidInstalledCodeException if {@code nmethodMirror} has been invalidated
 479      */
 480     native Object executeHotSpotNmethod(Object[] args, HotSpotNmethod nmethodMirror) throws InvalidInstalledCodeException;
 481 
 482     /**
 483      * Gets the line number table for {@code method}. The line number table is encoded as (bci,
 484      * source line number) pairs.
 485      *
 486      * @return the line number table for {@code method} or null if it doesn&#39;t have one
 487      */
 488     native long[] getLineNumberTable(HotSpotResolvedJavaMethodImpl method);
 489 
 490     /**
 491      * Gets the number of entries in the local variable table for {@code method}.
 492      *
 493      * @return the number of entries in the local variable table for {@code method}
 494      */
 495     native int getLocalVariableTableLength(HotSpotResolvedJavaMethodImpl method);
 496 
 497     /**
 498      * Gets the address of the first entry in the local variable table for {@code method}.
 499      *
 500      * Each entry is a native object described by these fields:
 501      *
 502      * &lt;ul&gt;
 503      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementSize}&lt;/li&gt;
 504      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementLengthOffset}&lt;/li&gt;
 505      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementNameCpIndexOffset}&lt;/li&gt;
 506      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementDescriptorCpIndexOffset}&lt;/li&gt;
 507      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementSlotOffset}
 508      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementStartBciOffset}
 509      * &lt;/ul&gt;
 510      *
 511      * @return 0 if {@code method} does not have a local variable table
 512      */
 513     native long getLocalVariableTableStart(HotSpotResolvedJavaMethodImpl method);
 514 
 515     /**
 516      * Reads an object pointer within a VM data structure. That is, any {@link VMField} whose
 517      * {@link VMField#type type} is {@code &quot;oop&quot;} (e.g., {@code Klass::_java_mirror},
 518      * {@code JavaThread::_threadObj}).
 519      *
 520      * Note that {@code Unsafe.getObject(Object, long)} cannot be used for this since it does a
 521      * {@code narrowOop} read if the VM is using compressed oops whereas oops within VM data
 522      * structures are (currently) always uncompressed.
 523      *
 524      * @param address address of an oop field within a VM data structure
 525      */
 526     native HotSpotObjectConstantImpl readUncompressedOop(long address);
 527 
 528     /**
 529      * Sets flags on {@code method} indicating that it should never be inlined or compiled by the
 530      * VM.
 531      */
 532     native void setNotInlinableOrCompilable(HotSpotResolvedJavaMethodImpl method);
 533 
 534     /**
 535      * Invalidates the profiling information for {@code method} and (re)initializes it such that
 536      * profiling restarts upon its next invocation.
 537      */
 538     native void reprofile(HotSpotResolvedJavaMethodImpl method);
 539 
 540     /**
 541      * Invalidates {@code nmethodMirror} such that {@link InvalidInstalledCodeException} will be
 542      * raised the next time {@code nmethodMirror} is {@linkplain #executeHotSpotNmethod executed}.
 543      * The {@code nmethod} associated with {@code nmethodMirror} is also made non-entrant and any
 544      * current activations of the {@code nmethod} are deoptimized.
 545      */
 546     native void invalidateHotSpotNmethod(HotSpotNmethod nmethodMirror);
 547 
 548     /**
 549      * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
 550      */
 551     native long[] collectCounters();
 552 
 553     /**
 554      * Get the current number of counters allocated for use by JVMCI. Should be the same value as
 555      * the flag {@code JVMCICounterSize}.
 556      */
 557     native int getCountersSize();
 558 
 559     /**
 560      * Attempt to change the size of the counters allocated for JVMCI. This requires a safepoint to
 561      * safely reallocate the storage but it&#39;s advisable to increase the size in reasonable chunks.
 562      */
 563     native boolean setCountersSize(int newSize);
 564 
 565     /**
 566      * Determines if {@code metaspaceMethodData} is mature.
 567      */
 568     native boolean isMature(long metaspaceMethodData);
 569 
 570     /**
 571      * Generate a unique id to identify the result of the compile.
 572      */
 573     native int allocateCompileId(HotSpotResolvedJavaMethodImpl method, int entryBCI);
 574 
 575     /**
 576      * Determines if {@code method} has OSR compiled code identified by {@code entryBCI} for
 577      * compilation level {@code level}.
 578      */
 579     native boolean hasCompiledCodeForOSR(HotSpotResolvedJavaMethodImpl method, int entryBCI, int level);
 580 
 581     /**
 582      * Gets the value of {@code metaspaceSymbol} as a String.
 583      */
 584     native String getSymbol(long metaspaceSymbol);
 585 
 586     /**
 587      * @see jdk.vm.ci.code.stack.StackIntrospection#iterateFrames
 588      */
 589     native &lt;T&gt; T iterateFrames(ResolvedJavaMethod[] initialMethods, ResolvedJavaMethod[] matchingMethods, int initialSkip, InspectedFrameVisitor&lt;T&gt; visitor);
 590 
 591     /**
 592      * Materializes all virtual objects within {@code stackFrame} and updates its locals.
 593      *
 594      * @param invalidate if {@code true}, the compiled method for the stack frame will be
 595      *            invalidated
 596      */
 597     native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
 598 
 599     /**
 600      * Gets the v-table index for interface method {@code method} in the receiver {@code type} or
 601      * {@link HotSpotVMConfig#invalidVtableIndex} if {@code method} is not in {@code type}&#39;s
 602      * v-table.
 603      *
 604      * @throws InternalError if {@code type} is an interface or {@code method} is not held by an
 605      *             interface or class represented by {@code type} is not initialized
 606      */
 607     native int getVtableIndexForInterfaceMethod(HotSpotResolvedObjectTypeImpl type, HotSpotResolvedJavaMethodImpl method);
 608 
 609     /**
 610      * Determines if debug info should also be emitted at non-safepoint locations.
 611      */
 612     native boolean shouldDebugNonSafepoints();
 613 
 614     /**
 615      * Writes {@code length} bytes from {@code bytes} starting at offset {@code offset} to HotSpot&#39;s
 616      * log stream.
 617      *
 618      * @param flush specifies if the log stream should be flushed after writing
 619      * @param canThrow specifies if an error in the {@code bytes}, {@code offset} or {@code length}
 620      *            arguments should result in an exception or a negative return value
 621      * @return 0 on success, -1 if {@code bytes == null &amp;&amp; !canThrow}, -2 if {@code !canThrow} and
 622      *         copying would cause access of data outside array bounds
 623      * @throws NullPointerException if {@code bytes == null}
 624      * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
 625      */
 626     native int writeDebugOutput(byte[] bytes, int offset, int length, boolean flush, boolean canThrow);
 627 
 628     /**
 629      * Flush HotSpot&#39;s log stream.
 630      */
 631     native void flushDebugOutput();
 632 
 633     /**
 634      * Read a HotSpot Method* value from the memory location described by {@code base} plus
 635      * {@code displacement} and return the {@link HotSpotResolvedJavaMethodImpl} wrapping it. This
 636      * method does no checking that the memory location actually contains a valid pointer and may
 637      * crash the VM if an invalid location is provided. If the {@code base} is null then
 638      * {@code displacement} is used by itself. If {@code base} is a
 639      * {@link HotSpotResolvedJavaMethodImpl}, {@link HotSpotConstantPool} or
 640      * {@link HotSpotResolvedObjectTypeImpl} then the metaspace pointer is fetched from that object
 641      * and added to {@code displacement}. Any other non-null object type causes an
 642      * {@link IllegalArgumentException} to be thrown.
 643      *
 644      * @param base an object to read from or null
 645      * @param displacement
 646      * @return null or the resolved method for this location
 647      */
 648     native HotSpotResolvedJavaMethodImpl getResolvedJavaMethod(HotSpotObjectConstantImpl base, long displacement);
 649 
 650     /**
 651      * Gets the {@code ConstantPool*} associated with {@code object} and returns a
 652      * {@link HotSpotConstantPool} wrapping it.
 653      *
 654      * @param object a {@link HotSpotResolvedJavaMethodImpl} or
 655      *            {@link HotSpotResolvedObjectTypeImpl} object
 656      * @return a {@link HotSpotConstantPool} wrapping the {@code ConstantPool*} associated with
 657      *         {@code object}
 658      * @throws NullPointerException if {@code object == null}
 659      * @throws IllegalArgumentException if {@code object} is neither a
 660      *             {@link HotSpotResolvedJavaMethodImpl} nor a {@link HotSpotResolvedObjectTypeImpl}
 661      */
 662     native HotSpotConstantPool getConstantPool(MetaspaceObject object);
 663 
 664     /**
 665      * Read a HotSpot Klass* value from the memory location described by {@code base} plus
 666      * {@code displacement} and return the {@link HotSpotResolvedObjectTypeImpl} wrapping it. This
 667      * method does no checking that the memory location actually contains a valid pointer and may
 668      * crash the VM if an invalid location is provided. If the {@code base} is null then
 669      * {@code displacement} is used by itself. If {@code base} is a
 670      * {@link HotSpotResolvedJavaMethodImpl}, {@link HotSpotConstantPool} or
 671      * {@link HotSpotResolvedObjectTypeImpl} then the metaspace pointer is fetched from that object
 672      * and added to {@code displacement}. Any other non-null object type causes an
 673      * {@link IllegalArgumentException} to be thrown.
 674      *
 675      * @param base an object to read from or null
 676      * @param displacement
 677      * @param compressed true if the location contains a compressed Klass*
 678      * @return null or the resolved method for this location
 679      */
 680     private native HotSpotResolvedObjectTypeImpl getResolvedJavaType0(Object base, long displacement, boolean compressed);
 681 
 682     HotSpotResolvedObjectTypeImpl getResolvedJavaType(MetaspaceObject base, long displacement, boolean compressed) {
 683         return getResolvedJavaType0(base, displacement, compressed);
 684     }
 685 
 686     HotSpotResolvedObjectTypeImpl getResolvedJavaType(HotSpotObjectConstantImpl base, long displacement, boolean compressed) {
 687         return getResolvedJavaType0(base, displacement, compressed);
 688     }
 689 
 690     HotSpotResolvedObjectTypeImpl getResolvedJavaType(long displacement, boolean compressed) {
 691         return getResolvedJavaType0(null, displacement, compressed);
 692     }
 693 
 694     /**
 695      * Return the size of the HotSpot ProfileData* pointed at by {@code position}. If
 696      * {@code position} is outside the space of the MethodData then an
 697      * {@link IllegalArgumentException} is thrown. A {@code position} inside the MethodData but that
 698      * isn&#39;t pointing at a valid ProfileData will crash the VM.
 699      *
 700      * @param metaspaceMethodData
 701      * @param position
 702      * @return the size of the ProfileData item pointed at by {@code position}
 703      * @throws IllegalArgumentException if an out of range position is given
 704      */
 705     native int methodDataProfileDataSize(long metaspaceMethodData, int position);
 706 
 707     /**
 708      * Gets the fingerprint for a given Klass*.
 709      *
 710      * @param metaspaceKlass
 711      * @return the value of the fingerprint (zero for arrays and synthetic classes).
 712      */
 713     native long getFingerprint(long metaspaceKlass);
 714 
 715     /**
 716      * Return the amount of native stack required for the interpreter frames represented by
 717      * {@code frame}. This is used when emitting the stack banging code to ensure that there is
 718      * enough space for the frames during deoptimization.
 719      *
 720      * @param frame
 721      * @return the number of bytes required for deoptimization of this frame state
 722      */
 723     native int interpreterFrameSize(BytecodeFrame frame);
 724 
 725     /**
 726      * Invokes non-public method {@code java.lang.invoke.LambdaForm.compileToBytecode()} on
 727      * {@code lambdaForm} (which must be a {@code java.lang.invoke.LambdaForm} instance).
 728      */
 729     native void compileToBytecode(HotSpotObjectConstantImpl lambdaForm);
 730 
 731     /**
 732      * Gets the value of the VM flag named {@code name}.
 733      *
 734      * @param name name of a VM option
 735      * @return {@code this} if the named VM option doesn&#39;t exist, a {@link String} or {@code null}
 736      *         if its type is {@code ccstr} or {@code ccstrlist}, a {@link Double} if its type is
 737      *         {@code double}, a {@link Boolean} if its type is {@code bool} otherwise a
 738      *         {@link Long}
 739      */
 740     native Object getFlagValue(String name);
 741 
 742     /**
 743      * Gets the host class for {@code type}.
 744      */
 745     native HotSpotResolvedObjectTypeImpl getHostClass(HotSpotResolvedObjectTypeImpl type);
 746 
 747     /**
 748      * Gets the object at the address {@code oopAddress}.
 749      *
 750      * @param oopAddress a valid {@code oopDesc**} value
 751      */
 752     native Object getObjectAtAddress(long oopAddress);
 753 
 754     /**
 755      * @see ResolvedJavaType#getInterfaces()
 756      */
 757     native HotSpotResolvedObjectTypeImpl[] getInterfaces(HotSpotResolvedObjectTypeImpl type);
 758 
 759     /**
 760      * @see ResolvedJavaType#getComponentType()
 761      */
 762     native HotSpotResolvedJavaType getComponentType(HotSpotResolvedObjectTypeImpl type);
 763 
 764     /**
 765      * Get the array class for {@code type}. This can&#39;t be done symbolically since anonymous types
 766      * can&#39;t be looked up by name.
 767      */
 768     native HotSpotResolvedObjectTypeImpl getArrayType(HotSpotResolvedJavaType type);
 769 
 770     /**
 771      * Forces initialization of {@code type}.
 772      */
 773     native void ensureInitialized(HotSpotResolvedObjectTypeImpl type);
 774 
 775     /**
 776      * Forces linking of {@code type}.
 777      */
 778     native void ensureLinked(HotSpotResolvedObjectTypeImpl type);
 779 
 780     /**
 781      * Checks if {@code object} is a String and is an interned string value.
 782      */
 783     native boolean isInternedString(HotSpotObjectConstantImpl object);
 784 
 785     /**
 786      * Gets the {@linkplain System#identityHashCode(Object) identity} has code for the object
 787      * represented by this constant.
 788      */
 789     native int getIdentityHashCode(HotSpotObjectConstantImpl object);
 790 
 791     /**
 792      * Converts a constant object representing a boxed primitive into a boxed primitive.
 793      */
 794     native Object unboxPrimitive(HotSpotObjectConstantImpl object);
 795 
 796     /**
 797      * Converts a boxed primitive into a JavaConstant representing the same value.
 798      */
 799     native HotSpotObjectConstantImpl boxPrimitive(Object source);
 800 
 801     /**
 802      * Gets the {@link ResolvedJavaMethod}s for all the constructors of the type {@code holder}.
 803      */
 804     native ResolvedJavaMethod[] getDeclaredConstructors(HotSpotResolvedObjectTypeImpl holder);
 805 
 806     /**
 807      * Gets the {@link ResolvedJavaMethod}s for all the non-constructor methods of the type
 808      * {@code holder}.
 809      */
 810     native ResolvedJavaMethod[] getDeclaredMethods(HotSpotResolvedObjectTypeImpl holder);
 811 
 812     /**
 813      * Reads the current value of a static field.
 814      */
 815     native JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl resolvedObjectType, HotSpotResolvedJavaField field, boolean isVolatile);
 816 
 817     /**
 818      * Reads the current value of an instance field.
 819      */
 820     native JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedJavaField field, boolean isVolatile);
 821 
 822     /**
 823      * @see ResolvedJavaType#isInstance(JavaConstant)
 824      */
 825     native boolean isInstance(HotSpotResolvedObjectTypeImpl holder, HotSpotObjectConstantImpl object);
 826 
 827     /**
 828      * @see ResolvedJavaType#isAssignableFrom(ResolvedJavaType)
 829      */
 830     native boolean isAssignableFrom(HotSpotResolvedObjectTypeImpl holder, HotSpotResolvedObjectTypeImpl otherType);
 831 
 832     /**
 833      * @see ConstantReflectionProvider#asJavaType(Constant)
 834      */
 835     native HotSpotResolvedJavaType asJavaType(HotSpotObjectConstantImpl object);
 836 
 837     /**
 838      * Converts a String constant into a String.
 839      */
 840     native String asString(HotSpotObjectConstantImpl object);
 841 
 842     /**
 843      * Compares the contents of {@code xHandle} and {@code yHandle} for pointer equality.
 844      */
 845     native boolean equals(HotSpotObjectConstantImpl x, long xHandle, HotSpotObjectConstantImpl y, long yHandle);
 846 
 847     /**
 848      * Gets a {@link JavaConstant} wrapping the {@link java.lang.Class} mirror for {@code type}.
 849      */
 850     native HotSpotObjectConstantImpl getJavaMirror(HotSpotResolvedJavaType type);
 851 
 852     /**
 853      * Returns the length of the array if {@code object} represents an array or -1 otherwise.
 854      */
 855     native int getArrayLength(HotSpotObjectConstantImpl object);
 856 
 857     /**
 858      * Reads the element at {@code index} if {@code object} is an array. Elements of an object array
 859      * are returned as {@link JavaConstant}s and primitives are returned as boxed values. The value
 860      * {@code null} is returned if the {@code index} is out of range or object is not an array.
 861      */
 862     native Object readArrayElement(HotSpotObjectConstantImpl object, int index);
 863 
 864     /**
 865      * Reads a byte sized value from {@code displacement} in {@code object}.
 866      */
 867     native byte getByte(HotSpotObjectConstantImpl object, long displacement);
 868 
 869     /**
 870      * Reads a short sized value from {@code displacement} in {@code object}.
 871      */
 872     native short getShort(HotSpotObjectConstantImpl object, long displacement);
 873 
 874     /**
 875      * Reads an int sized value from {@code displacement} in {@code object}.
 876      */
 877     native int getInt(HotSpotObjectConstantImpl object, long displacement);
 878 
 879     /**
 880      * Reads a long sized value from {@code displacement} in {@code object}.
 881      */
 882     native long getLong(HotSpotObjectConstantImpl object, long displacement);
 883 
 884     /**
 885      * Reads a Java object from {@code displacement} in {@code object}.
 886      */
 887     native HotSpotObjectConstantImpl getObject(HotSpotObjectConstantImpl object, long displacement);
 888 
 889     /**
 890      * @see HotSpotJVMCIRuntime#registerNativeMethods
 891      */
 892     native long[] registerNativeMethods(Class&lt;?&gt; clazz);
 893 
 894     /**
 895      * @see HotSpotJVMCIRuntime#translate(Object)
 896      */
 897     native long translate(Object obj);
 898 
 899     /**
 900      * @see HotSpotJVMCIRuntime#unhand(Class, long)
 901      */
 902     native Object unhand(long handle);
 903 
 904     /**
 905      * Updates {@code address} and {@code entryPoint} fields of {@code nmethodMirror} based on the
 906      * current state of the {@code nmethod} identified by {@code address} and
 907      * {@code nmethodMirror.compileId} in the code cache.
 908      */
 909     native void updateHotSpotNmethod(HotSpotNmethod nmethodMirror);
 910 
 911     /**
 912      * @see InstalledCode#getCode()
 913      */
 914     native byte[] getCode(HotSpotInstalledCode code);
 915 
 916     /**
 917      * Gets a {@link Executable} corresponding to {@code method}.
 918      */
 919     native Executable asReflectionExecutable(HotSpotResolvedJavaMethodImpl method);
 920 
 921     /**
 922      * Gets a {@link Field} denoted by {@code holder} and {@code index}.
 923      *
 924      * @param holder the class in which the requested field is declared
 925      * @param fieldIndex the {@code fieldDescriptor::index()} denoting the field
 926      */
 927     native Field asReflectionField(HotSpotResolvedObjectTypeImpl holder, int fieldIndex);
 928 
 929     /**
 930      * @see HotSpotJVMCIRuntime#getIntrinsificationTrustPredicate(Class...)
 931      */
 932     native boolean isTrustedForIntrinsics(HotSpotResolvedObjectTypeImpl type);
 933 
 934     /**
 935      * Releases the resources backing the global JNI {@code handle}. This is equivalent to the
 936      * {@code DeleteGlobalRef} JNI function.
 937      */
 938     native void deleteGlobalHandle(long handle);
 939 
 940     /**
 941      * Gets the failed speculations pointed to by {@code *failedSpeculationsAddress}.
 942      *
 943      * @param currentFailures the known failures at {@code failedSpeculationsAddress}
 944      * @return the list of failed speculations with each entry being a single speculation in the
 945      *         format emitted by {@link HotSpotSpeculationEncoding#toByteArray()}
 946      */
 947     native byte[][] getFailedSpeculations(long failedSpeculationsAddress, byte[][] currentFailures);
 948 
 949     /**
 950      * Gets the address of the {@code MethodData::_failed_speculations} field in the
 951      * {@code MethodData} associated with {@code method}. This will create and install the
 952      * {@code MethodData} if it didn&#39;t already exist.
 953      */
 954     native long getFailedSpeculationsAddress(HotSpotResolvedJavaMethodImpl method);
 955 
 956     /**
 957      * Frees the failed speculations pointed to by {@code *failedSpeculationsAddress}.
 958      */
 959     native void releaseFailedSpeculations(long failedSpeculationsAddress);
 960 
 961     /**
 962      * Adds a speculation to the failed speculations pointed to by
 963      * {@code *failedSpeculationsAddress}.
 964      *
 965      * @return {@code false} if the speculation could not be appended to the list
 966      */
 967     native boolean addFailedSpeculation(long failedSpeculationsAddress, byte[] speculation);
 968 
 969     /**
 970      * @see HotSpotJVMCIRuntime#isCurrentThreadAttached()
 971      */
 972     native boolean isCurrentThreadAttached();
 973 
 974     /**
 975      * @see HotSpotJVMCIRuntime#getCurrentJavaThread()
 976      */
 977     native long getCurrentJavaThread();
 978 
 979     /**
 980      * @see HotSpotJVMCIRuntime#attachCurrentThread
 981      */
 982     native boolean attachCurrentThread(boolean asDaemon);
 983 
 984     /**
 985      * @see HotSpotJVMCIRuntime#detachCurrentThread()
 986      */
 987     native void detachCurrentThread();
 988 
 989     /**
 990      * @see HotSpotJVMCIRuntime#exitHotSpot(int)
 991      */
 992     native void callSystemExit(int status);
 993 
 994     /**
 995      * @see JFR.Ticks#now
 996      */
 997     native long ticksNow();
 998 
 999     /**
1000      * Adds phases in HotSpot JFR.
1001      *
1002      * @see JFR.CompilerPhaseEvent#registerPhases and JFR.CompilerPhaseEvent#write
1003      */
1004     native int registerCompilerPhases(String[] phases);
1005 
1006     /**
1007      * @see JFR.CompilerPhaseEvent#write
1008      */
1009     native void notifyCompilerPhaseEvent(long startTime, int phase, int compileId, int level);
1010 
1011     /**
1012      * @see JFR.CompilerInliningEvent#write
1013      */
1014     native void notifyCompilerInliningEvent(int compileId, HotSpotResolvedJavaMethodImpl caller, HotSpotResolvedJavaMethodImpl callee, boolean succeeded, String message, int bci);
1015 
1016 }
    </pre>
  </body>
</html>