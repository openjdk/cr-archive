<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libfontmanager/harfbuzz/hb-aat-layout-morx-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright Â© 2017  Google, Inc.
   3  *
   4  *  This is part of HarfBuzz, a text shaping library.
   5  *
   6  * Permission is hereby granted, without written agreement and without
   7  * license or royalty fees, to use, copy, modify, and distribute this
   8  * software and its documentation for any purpose, provided that the
   9  * above copyright notice and the following two paragraphs appear in
  10  * all copies of this software.
  11  *
  12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  16  * DAMAGE.
  17  *
  18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  23  *
  24  * Google Author(s): Behdad Esfahbod
  25  */
  26 
  27 #ifndef HB_AAT_LAYOUT_MORX_TABLE_HH
  28 #define HB_AAT_LAYOUT_MORX_TABLE_HH
  29 
  30 #include &quot;hb-open-type.hh&quot;
  31 #include &quot;hb-aat-layout-common.hh&quot;
  32 #include &quot;hb-ot-layout-common.hh&quot;
  33 #include &quot;hb-aat-map.hh&quot;
  34 
  35 /*
  36  * morx -- Extended Glyph Metamorphosis
  37  * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6morx.html
  38  * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6mort.html
  39  */
  40 #define HB_AAT_TAG_morx HB_TAG(&#39;m&#39;,&#39;o&#39;,&#39;r&#39;,&#39;x&#39;)
  41 #define HB_AAT_TAG_mort HB_TAG(&#39;m&#39;,&#39;o&#39;,&#39;r&#39;,&#39;t&#39;)
  42 
  43 
  44 namespace AAT {
  45 
  46 using namespace OT;
  47 
  48 template &lt;typename Types&gt;
  49 struct RearrangementSubtable
  50 {
  51   typedef typename Types::HBUINT HBUINT;
  52 
  53   typedef void EntryData;
  54 
  55   struct driver_context_t
  56   {
  57     static constexpr bool in_place = true;
  58     enum Flags
  59     {
  60       MarkFirst         = 0x8000,       /* If set, make the current glyph the first
  61                                          * glyph to be rearranged. */
  62       DontAdvance       = 0x4000,       /* If set, don&#39;t advance to the next glyph
  63                                          * before going to the new state. This means
  64                                          * that the glyph index doesn&#39;t change, even
  65                                          * if the glyph at that index has changed. */
  66       MarkLast          = 0x2000,       /* If set, make the current glyph the last
  67                                          * glyph to be rearranged. */
  68       Reserved          = 0x1FF0,       /* These bits are reserved and should be set to 0. */
  69       Verb              = 0x000F,       /* The type of rearrangement specified. */
  70     };
  71 
  72     driver_context_t (const RearrangementSubtable *table HB_UNUSED) :
  73         ret (false),
  74         start (0), end (0) {}
  75 
  76     bool is_actionable (StateTableDriver&lt;Types, EntryData&gt; *driver HB_UNUSED,
  77                         const Entry&lt;EntryData&gt; &amp;entry)
  78     {
  79       return (entry.flags &amp; Verb) &amp;&amp; start &lt; end;
  80     }
  81     void transition (StateTableDriver&lt;Types, EntryData&gt; *driver,
  82                      const Entry&lt;EntryData&gt; &amp;entry)
  83     {
  84       hb_buffer_t *buffer = driver-&gt;buffer;
  85       unsigned int flags = entry.flags;
  86 
  87       if (flags &amp; MarkFirst)
  88         start = buffer-&gt;idx;
  89 
  90       if (flags &amp; MarkLast)
  91         end = MIN (buffer-&gt;idx + 1, buffer-&gt;len);
  92 
  93       if ((flags &amp; Verb) &amp;&amp; start &lt; end)
  94       {
  95         /* The following map has two nibbles, for start-side
  96          * and end-side. Values of 0,1,2 mean move that many
  97          * to the other side. Value of 3 means move 2 and
  98          * flip them. */
  99         const unsigned char map[16] =
 100         {
 101           0x00, /* 0    no change */
 102           0x10, /* 1    Ax =&gt; xA */
 103           0x01, /* 2    xD =&gt; Dx */
 104           0x11, /* 3    AxD =&gt; DxA */
 105           0x20, /* 4    ABx =&gt; xAB */
 106           0x30, /* 5    ABx =&gt; xBA */
 107           0x02, /* 6    xCD =&gt; CDx */
 108           0x03, /* 7    xCD =&gt; DCx */
 109           0x12, /* 8    AxCD =&gt; CDxA */
 110           0x13, /* 9    AxCD =&gt; DCxA */
 111           0x21, /* 10   ABxD =&gt; DxAB */
 112           0x31, /* 11   ABxD =&gt; DxBA */
 113           0x22, /* 12   ABxCD =&gt; CDxAB */
 114           0x32, /* 13   ABxCD =&gt; CDxBA */
 115           0x23, /* 14   ABxCD =&gt; DCxAB */
 116           0x33, /* 15   ABxCD =&gt; DCxBA */
 117         };
 118 
 119         unsigned int m = map[flags &amp; Verb];
 120         unsigned int l = MIN&lt;unsigned int&gt; (2, m &gt;&gt; 4);
 121         unsigned int r = MIN&lt;unsigned int&gt; (2, m &amp; 0x0F);
 122         bool reverse_l = 3 == (m &gt;&gt; 4);
 123         bool reverse_r = 3 == (m &amp; 0x0F);
 124 
 125         if (end - start &gt;= l + r)
 126         {
 127           buffer-&gt;merge_clusters (start, MIN (buffer-&gt;idx + 1, buffer-&gt;len));
 128           buffer-&gt;merge_clusters (start, end);
 129 
 130           hb_glyph_info_t *info = buffer-&gt;info;
 131           hb_glyph_info_t buf[4];
 132 
 133           memcpy (buf, info + start, l * sizeof (buf[0]));
 134           memcpy (buf + 2, info + end - r, r * sizeof (buf[0]));
 135 
 136           if (l != r)
 137             memmove (info + start + r, info + start + l, (end - start - l - r) * sizeof (buf[0]));
 138 
 139           memcpy (info + start, buf + 2, r * sizeof (buf[0]));
 140           memcpy (info + end - l, buf, l * sizeof (buf[0]));
 141           if (reverse_l)
 142           {
 143             buf[0] = info[end - 1];
 144             info[end - 1] = info[end - 2];
 145             info[end - 2] = buf[0];
 146           }
 147           if (reverse_r)
 148           {
 149             buf[0] = info[start];
 150             info[start] = info[start + 1];
 151             info[start + 1] = buf[0];
 152           }
 153         }
 154       }
 155     }
 156 
 157     public:
 158     bool ret;
 159     private:
 160     unsigned int start;
 161     unsigned int end;
 162   };
 163 
 164   bool apply (hb_aat_apply_context_t *c) const
 165   {
 166     TRACE_APPLY (this);
 167 
 168     driver_context_t dc (this);
 169 
 170     StateTableDriver&lt;Types, EntryData&gt; driver (machine, c-&gt;buffer, c-&gt;face);
 171     driver.drive (&amp;dc);
 172 
 173     return_trace (dc.ret);
 174   }
 175 
 176   bool sanitize (hb_sanitize_context_t *c) const
 177   {
 178     TRACE_SANITIZE (this);
 179     return_trace (machine.sanitize (c));
 180   }
 181 
 182   protected:
 183   StateTable&lt;Types, EntryData&gt;  machine;
 184   public:
 185   DEFINE_SIZE_STATIC (16);
 186 };
 187 
 188 template &lt;typename Types&gt;
 189 struct ContextualSubtable
 190 {
 191   typedef typename Types::HBUINT HBUINT;
 192 
 193   struct EntryData
 194   {
 195     HBUINT16    markIndex;      /* Index of the substitution table for the
 196                                  * marked glyph (use 0xFFFF for none). */
 197     HBUINT16    currentIndex;   /* Index of the substitution table for the
 198                                  * current glyph (use 0xFFFF for none). */
 199     public:
 200     DEFINE_SIZE_STATIC (4);
 201   };
 202 
 203   struct driver_context_t
 204   {
 205     static constexpr bool in_place = true;
 206     enum Flags
 207     {
 208       SetMark           = 0x8000,       /* If set, make the current glyph the marked glyph. */
 209       DontAdvance       = 0x4000,       /* If set, don&#39;t advance to the next glyph before
 210                                          * going to the new state. */
 211       Reserved          = 0x3FFF,       /* These bits are reserved and should be set to 0. */
 212     };
 213 
 214     driver_context_t (const ContextualSubtable *table_,
 215                              hb_aat_apply_context_t *c_) :
 216         ret (false),
 217         c (c_),
 218         mark_set (false),
 219         mark (0),
 220         table (table_),
 221         subs (table+table-&gt;substitutionTables) {}
 222 
 223     bool is_actionable (StateTableDriver&lt;Types, EntryData&gt; *driver,
 224                         const Entry&lt;EntryData&gt; &amp;entry)
 225     {
 226       hb_buffer_t *buffer = driver-&gt;buffer;
 227 
 228       if (buffer-&gt;idx == buffer-&gt;len &amp;&amp; !mark_set)
 229         return false;
 230 
 231       return entry.data.markIndex != 0xFFFF || entry.data.currentIndex != 0xFFFF;
 232     }
 233     void transition (StateTableDriver&lt;Types, EntryData&gt; *driver,
 234                      const Entry&lt;EntryData&gt; &amp;entry)
 235     {
 236       hb_buffer_t *buffer = driver-&gt;buffer;
 237 
 238       /* Looks like CoreText applies neither mark nor current substitution for
 239        * end-of-text if mark was not explicitly set. */
 240       if (buffer-&gt;idx == buffer-&gt;len &amp;&amp; !mark_set)
 241         return;
 242 
 243       const GlyphID *replacement;
 244 
 245       replacement = nullptr;
 246       if (Types::extended)
 247       {
 248         if (entry.data.markIndex != 0xFFFF)
 249         {
 250           const Lookup&lt;GlyphID&gt; &amp;lookup = subs[entry.data.markIndex];
 251           replacement = lookup.get_value (buffer-&gt;info[mark].codepoint, driver-&gt;num_glyphs);
 252         }
 253       }
 254       else
 255       {
 256         unsigned int offset = entry.data.markIndex + buffer-&gt;info[mark].codepoint;
 257         const UnsizedArrayOf&lt;GlyphID&gt; &amp;subs_old = (const UnsizedArrayOf&lt;GlyphID&gt; &amp;) subs;
 258         replacement = &amp;subs_old[Types::wordOffsetToIndex (offset, table, subs_old.arrayZ)];
 259         if (!replacement-&gt;sanitize (&amp;c-&gt;sanitizer) || !*replacement)
 260           replacement = nullptr;
 261       }
 262       if (replacement)
 263       {
 264         buffer-&gt;unsafe_to_break (mark, MIN (buffer-&gt;idx + 1, buffer-&gt;len));
 265         buffer-&gt;info[mark].codepoint = *replacement;
 266         ret = true;
 267       }
 268 
 269       replacement = nullptr;
 270       unsigned int idx = MIN (buffer-&gt;idx, buffer-&gt;len - 1);
 271       if (Types::extended)
 272       {
 273         if (entry.data.currentIndex != 0xFFFF)
 274         {
 275           const Lookup&lt;GlyphID&gt; &amp;lookup = subs[entry.data.currentIndex];
 276           replacement = lookup.get_value (buffer-&gt;info[idx].codepoint, driver-&gt;num_glyphs);
 277         }
 278       }
 279       else
 280       {
 281         unsigned int offset = entry.data.currentIndex + buffer-&gt;info[idx].codepoint;
 282         const UnsizedArrayOf&lt;GlyphID&gt; &amp;subs_old = (const UnsizedArrayOf&lt;GlyphID&gt; &amp;) subs;
 283         replacement = &amp;subs_old[Types::wordOffsetToIndex (offset, table, subs_old.arrayZ)];
 284         if (!replacement-&gt;sanitize (&amp;c-&gt;sanitizer) || !*replacement)
 285           replacement = nullptr;
 286       }
 287       if (replacement)
 288       {
 289         buffer-&gt;info[idx].codepoint = *replacement;
 290         ret = true;
 291       }
 292 
 293       if (entry.flags &amp; SetMark)
 294       {
 295         mark_set = true;
 296         mark = buffer-&gt;idx;
 297       }
 298     }
 299 
 300     public:
 301     bool ret;
 302     private:
 303     hb_aat_apply_context_t *c;
 304     bool mark_set;
 305     unsigned int mark;
 306     const ContextualSubtable *table;
 307     const UnsizedOffsetListOf&lt;Lookup&lt;GlyphID&gt;, HBUINT, false&gt; &amp;subs;
 308   };
 309 
 310   bool apply (hb_aat_apply_context_t *c) const
 311   {
 312     TRACE_APPLY (this);
 313 
 314     driver_context_t dc (this, c);
 315 
 316     StateTableDriver&lt;Types, EntryData&gt; driver (machine, c-&gt;buffer, c-&gt;face);
 317     driver.drive (&amp;dc);
 318 
 319     return_trace (dc.ret);
 320   }
 321 
 322   bool sanitize (hb_sanitize_context_t *c) const
 323   {
 324     TRACE_SANITIZE (this);
 325 
 326     unsigned int num_entries = 0;
 327     if (unlikely (!machine.sanitize (c, &amp;num_entries))) return_trace (false);
 328 
 329     if (!Types::extended)
 330       return_trace (substitutionTables.sanitize (c, this, 0));
 331 
 332     unsigned int num_lookups = 0;
 333 
 334     const Entry&lt;EntryData&gt; *entries = machine.get_entries ();
 335     for (unsigned int i = 0; i &lt; num_entries; i++)
 336     {
 337       const EntryData &amp;data = entries[i].data;
 338 
 339       if (data.markIndex != 0xFFFF)
 340         num_lookups = MAX&lt;unsigned int&gt; (num_lookups, 1 + data.markIndex);
 341       if (data.currentIndex != 0xFFFF)
 342         num_lookups = MAX&lt;unsigned int&gt; (num_lookups, 1 + data.currentIndex);
 343     }
 344 
 345     return_trace (substitutionTables.sanitize (c, this, num_lookups));
 346   }
 347 
 348   protected:
 349   StateTable&lt;Types, EntryData&gt;
 350                 machine;
 351   NNOffsetTo&lt;UnsizedOffsetListOf&lt;Lookup&lt;GlyphID&gt;, HBUINT, false&gt;, HBUINT&gt;
 352                 substitutionTables;
 353   public:
 354   DEFINE_SIZE_STATIC (20);
 355 };
 356 
 357 
 358 template &lt;bool extended&gt;
 359 struct LigatureEntry;
 360 
 361 template &lt;&gt;
 362 struct LigatureEntry&lt;true&gt;
 363 {
 364   enum Flags
 365   {
 366     SetComponent        = 0x8000,       /* Push this glyph onto the component stack for
 367                                          * eventual processing. */
 368     DontAdvance         = 0x4000,       /* Leave the glyph pointer at this glyph for the
 369                                            next iteration. */
 370     PerformAction       = 0x2000,       /* Use the ligActionIndex to process a ligature
 371                                          * group. */
 372     Reserved            = 0x1FFF,       /* These bits are reserved and should be set to 0. */
 373   };
 374 
 375   struct EntryData
 376   {
 377     HBUINT16    ligActionIndex; /* Index to the first ligActionTable entry
 378                                  * for processing this group, if indicated
 379                                  * by the flags. */
 380     public:
 381     DEFINE_SIZE_STATIC (2);
 382   };
 383 
 384   static bool performAction (const Entry&lt;EntryData&gt; &amp;entry)
 385   { return entry.flags &amp; PerformAction; }
 386 
 387   static unsigned int ligActionIndex (const Entry&lt;EntryData&gt; &amp;entry)
 388   { return entry.data.ligActionIndex; }
 389 };
 390 template &lt;&gt;
 391 struct LigatureEntry&lt;false&gt;
 392 {
 393   enum Flags
 394   {
 395     SetComponent        = 0x8000,       /* Push this glyph onto the component stack for
 396                                          * eventual processing. */
 397     DontAdvance         = 0x4000,       /* Leave the glyph pointer at this glyph for the
 398                                            next iteration. */
 399     Offset              = 0x3FFF,       /* Byte offset from beginning of subtable to the
 400                                          * ligature action list. This value must be a
 401                                          * multiple of 4. */
 402   };
 403 
 404   typedef void EntryData;
 405 
 406   static bool performAction (const Entry&lt;EntryData&gt; &amp;entry)
 407   { return entry.flags &amp; Offset; }
 408 
 409   static unsigned int ligActionIndex (const Entry&lt;EntryData&gt; &amp;entry)
 410   { return entry.flags &amp; Offset; }
 411 };
 412 
 413 
 414 template &lt;typename Types&gt;
 415 struct LigatureSubtable
 416 {
 417   typedef typename Types::HBUINT HBUINT;
 418 
 419   typedef LigatureEntry&lt;Types::extended&gt; LigatureEntryT;
 420   typedef typename LigatureEntryT::EntryData EntryData;
 421 
 422   struct driver_context_t
 423   {
 424     static constexpr bool in_place = false;
 425     enum
 426     {
 427       DontAdvance       = LigatureEntryT::DontAdvance,
 428     };
 429     enum LigActionFlags
 430     {
 431       LigActionLast     = 0x80000000,   /* This is the last action in the list. This also
 432                                          * implies storage. */
 433       LigActionStore    = 0x40000000,   /* Store the ligature at the current cumulated index
 434                                          * in the ligature table in place of the marked
 435                                          * (i.e. currently-popped) glyph. */
 436       LigActionOffset   = 0x3FFFFFFF,   /* A 30-bit value which is sign-extended to 32-bits
 437                                          * and added to the glyph ID, resulting in an index
 438                                          * into the component table. */
 439     };
 440 
 441     driver_context_t (const LigatureSubtable *table_,
 442                       hb_aat_apply_context_t *c_) :
 443         ret (false),
 444         c (c_),
 445         table (table_),
 446         ligAction (table+table-&gt;ligAction),
 447         component (table+table-&gt;component),
 448         ligature (table+table-&gt;ligature),
 449         match_length (0) {}
 450 
 451     bool is_actionable (StateTableDriver&lt;Types, EntryData&gt; *driver HB_UNUSED,
 452                         const Entry&lt;EntryData&gt; &amp;entry)
 453     {
 454       return LigatureEntryT::performAction (entry);
 455     }
 456     void transition (StateTableDriver&lt;Types, EntryData&gt; *driver,
 457                      const Entry&lt;EntryData&gt; &amp;entry)
 458     {
 459       hb_buffer_t *buffer = driver-&gt;buffer;
 460 
 461       DEBUG_MSG (APPLY, nullptr, &quot;Ligature transition at %u&quot;, buffer-&gt;idx);
 462       if (entry.flags &amp; LigatureEntryT::SetComponent)
 463       {
 464         /* Never mark same index twice, in case DontAdvance was used... */
 465         if (match_length &amp;&amp; match_positions[(match_length - 1u) % ARRAY_LENGTH (match_positions)] == buffer-&gt;out_len)
 466           match_length--;
 467 
 468         match_positions[match_length++ % ARRAY_LENGTH (match_positions)] = buffer-&gt;out_len;
 469         DEBUG_MSG (APPLY, nullptr, &quot;Set component at %u&quot;, buffer-&gt;out_len);
 470       }
 471 
 472       if (LigatureEntryT::performAction (entry))
 473       {
 474         DEBUG_MSG (APPLY, nullptr, &quot;Perform action with %u&quot;, match_length);
 475         unsigned int end = buffer-&gt;out_len;
 476 
 477         if (unlikely (!match_length))
 478           return;
 479 
 480         if (buffer-&gt;idx &gt;= buffer-&gt;len)
 481           return; /* TODO Work on previous instead? */
 482 
 483         unsigned int cursor = match_length;
 484 
 485         unsigned int action_idx = LigatureEntryT::ligActionIndex (entry);
 486         action_idx = Types::offsetToIndex (action_idx, table, ligAction.arrayZ);
 487         const HBUINT32 *actionData = &amp;ligAction[action_idx];
 488 
 489         unsigned int ligature_idx = 0;
 490         unsigned int action;
 491         do
 492         {
 493           if (unlikely (!cursor))
 494           {
 495             /* Stack underflow.  Clear the stack. */
 496             DEBUG_MSG (APPLY, nullptr, &quot;Stack underflow&quot;);
 497             match_length = 0;
 498             break;
 499           }
 500 
 501           DEBUG_MSG (APPLY, nullptr, &quot;Moving to stack position %u&quot;, cursor - 1);
 502           buffer-&gt;move_to (match_positions[--cursor % ARRAY_LENGTH (match_positions)]);
 503 
 504           if (unlikely (!actionData-&gt;sanitize (&amp;c-&gt;sanitizer))) break;
 505           action = *actionData;
 506 
 507           uint32_t uoffset = action &amp; LigActionOffset;
 508           if (uoffset &amp; 0x20000000)
 509             uoffset |= 0xC0000000; /* Sign-extend. */
 510           int32_t offset = (int32_t) uoffset;
 511           unsigned int component_idx = buffer-&gt;cur().codepoint + offset;
 512           component_idx = Types::wordOffsetToIndex (component_idx, table, component.arrayZ);
 513           const HBUINT16 &amp;componentData = component[component_idx];
 514           if (unlikely (!componentData.sanitize (&amp;c-&gt;sanitizer))) break;
 515           ligature_idx += componentData;
 516 
 517           DEBUG_MSG (APPLY, nullptr, &quot;Action store %u last %u&quot;,
 518                      bool (action &amp; LigActionStore),
 519                      bool (action &amp; LigActionLast));
 520           if (action &amp; (LigActionStore | LigActionLast))
 521           {
 522             ligature_idx = Types::offsetToIndex (ligature_idx, table, ligature.arrayZ);
 523             const GlyphID &amp;ligatureData = ligature[ligature_idx];
 524             if (unlikely (!ligatureData.sanitize (&amp;c-&gt;sanitizer))) break;
 525             hb_codepoint_t lig = ligatureData;
 526 
 527             DEBUG_MSG (APPLY, nullptr, &quot;Produced ligature %u&quot;, lig);
 528             buffer-&gt;replace_glyph (lig);
 529 
 530             unsigned int lig_end = match_positions[(match_length - 1u) % ARRAY_LENGTH (match_positions)] + 1u;
 531             /* Now go and delete all subsequent components. */
 532             while (match_length - 1u &gt; cursor)
 533             {
 534               DEBUG_MSG (APPLY, nullptr, &quot;Skipping ligature component&quot;);
 535               buffer-&gt;move_to (match_positions[--match_length % ARRAY_LENGTH (match_positions)]);
 536               buffer-&gt;replace_glyph (DELETED_GLYPH);
 537             }
 538 
 539             buffer-&gt;move_to (lig_end);
 540             buffer-&gt;merge_out_clusters (match_positions[cursor % ARRAY_LENGTH (match_positions)], buffer-&gt;out_len);
 541           }
 542 
 543           actionData++;
 544         }
 545         while (!(action &amp; LigActionLast));
 546         buffer-&gt;move_to (end);
 547       }
 548     }
 549 
 550     public:
 551     bool ret;
 552     private:
 553     hb_aat_apply_context_t *c;
 554     const LigatureSubtable *table;
 555     const UnsizedArrayOf&lt;HBUINT32&gt; &amp;ligAction;
 556     const UnsizedArrayOf&lt;HBUINT16&gt; &amp;component;
 557     const UnsizedArrayOf&lt;GlyphID&gt; &amp;ligature;
 558     unsigned int match_length;
 559     unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];
 560   };
 561 
 562   bool apply (hb_aat_apply_context_t *c) const
 563   {
 564     TRACE_APPLY (this);
 565 
 566     driver_context_t dc (this, c);
 567 
 568     StateTableDriver&lt;Types, EntryData&gt; driver (machine, c-&gt;buffer, c-&gt;face);
 569     driver.drive (&amp;dc);
 570 
 571     return_trace (dc.ret);
 572   }
 573 
 574   bool sanitize (hb_sanitize_context_t *c) const
 575   {
 576     TRACE_SANITIZE (this);
 577     /* The rest of array sanitizations are done at run-time. */
 578     return_trace (c-&gt;check_struct (this) &amp;&amp; machine.sanitize (c) &amp;&amp;
 579                   ligAction &amp;&amp; component &amp;&amp; ligature);
 580   }
 581 
 582   protected:
 583   StateTable&lt;Types, EntryData&gt;
 584                 machine;
 585   NNOffsetTo&lt;UnsizedArrayOf&lt;HBUINT32&gt;, HBUINT&gt;
 586                 ligAction;      /* Offset to the ligature action table. */
 587   NNOffsetTo&lt;UnsizedArrayOf&lt;HBUINT16&gt;, HBUINT&gt;
 588                 component;      /* Offset to the component table. */
 589   NNOffsetTo&lt;UnsizedArrayOf&lt;GlyphID&gt;, HBUINT&gt;
 590                 ligature;       /* Offset to the actual ligature lists. */
 591   public:
 592   DEFINE_SIZE_STATIC (28);
 593 };
 594 
 595 template &lt;typename Types&gt;
 596 struct NoncontextualSubtable
 597 {
 598   bool apply (hb_aat_apply_context_t *c) const
 599   {
 600     TRACE_APPLY (this);
 601 
 602     bool ret = false;
 603     unsigned int num_glyphs = c-&gt;face-&gt;get_num_glyphs ();
 604 
 605     hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
 606     unsigned int count = c-&gt;buffer-&gt;len;
 607     for (unsigned int i = 0; i &lt; count; i++)
 608     {
 609       const GlyphID *replacement = substitute.get_value (info[i].codepoint, num_glyphs);
 610       if (replacement)
 611       {
 612         info[i].codepoint = *replacement;
 613         ret = true;
 614       }
 615     }
 616 
 617     return_trace (ret);
 618   }
 619 
 620   bool sanitize (hb_sanitize_context_t *c) const
 621   {
 622     TRACE_SANITIZE (this);
 623     return_trace (substitute.sanitize (c));
 624   }
 625 
 626   protected:
 627   Lookup&lt;GlyphID&gt;       substitute;
 628   public:
 629   DEFINE_SIZE_MIN (2);
 630 };
 631 
 632 template &lt;typename Types&gt;
 633 struct InsertionSubtable
 634 {
 635   typedef typename Types::HBUINT HBUINT;
 636 
 637   struct EntryData
 638   {
 639     HBUINT16    currentInsertIndex;     /* Zero-based index into the insertion glyph table.
 640                                          * The number of glyphs to be inserted is contained
 641                                          * in the currentInsertCount field in the flags.
 642                                          * A value of 0xFFFF indicates no insertion is to
 643                                          * be done. */
 644     HBUINT16    markedInsertIndex;      /* Zero-based index into the insertion glyph table.
 645                                          * The number of glyphs to be inserted is contained
 646                                          * in the markedInsertCount field in the flags.
 647                                          * A value of 0xFFFF indicates no insertion is to
 648                                          * be done. */
 649     public:
 650     DEFINE_SIZE_STATIC (4);
 651   };
 652 
 653   struct driver_context_t
 654   {
 655     static constexpr bool in_place = false;
 656     enum Flags
 657     {
 658       SetMark           = 0x8000,       /* If set, mark the current glyph. */
 659       DontAdvance       = 0x4000,       /* If set, don&#39;t advance to the next glyph before
 660                                          * going to the new state.  This does not mean
 661                                          * that the glyph pointed to is the same one as
 662                                          * before. If you&#39;ve made insertions immediately
 663                                          * downstream of the current glyph, the next glyph
 664                                          * processed would in fact be the first one
 665                                          * inserted. */
 666       CurrentIsKashidaLike= 0x2000,     /* If set, and the currentInsertList is nonzero,
 667                                          * then the specified glyph list will be inserted
 668                                          * as a kashida-like insertion, either before or
 669                                          * after the current glyph (depending on the state
 670                                          * of the currentInsertBefore flag). If clear, and
 671                                          * the currentInsertList is nonzero, then the
 672                                          * specified glyph list will be inserted as a
 673                                          * split-vowel-like insertion, either before or
 674                                          * after the current glyph (depending on the state
 675                                          * of the currentInsertBefore flag). */
 676       MarkedIsKashidaLike= 0x1000,      /* If set, and the markedInsertList is nonzero,
 677                                          * then the specified glyph list will be inserted
 678                                          * as a kashida-like insertion, either before or
 679                                          * after the marked glyph (depending on the state
 680                                          * of the markedInsertBefore flag). If clear, and
 681                                          * the markedInsertList is nonzero, then the
 682                                          * specified glyph list will be inserted as a
 683                                          * split-vowel-like insertion, either before or
 684                                          * after the marked glyph (depending on the state
 685                                          * of the markedInsertBefore flag). */
 686       CurrentInsertBefore= 0x0800,      /* If set, specifies that insertions are to be made
 687                                          * to the left of the current glyph. If clear,
 688                                          * they&#39;re made to the right of the current glyph. */
 689       MarkedInsertBefore= 0x0400,       /* If set, specifies that insertions are to be
 690                                          * made to the left of the marked glyph. If clear,
 691                                          * they&#39;re made to the right of the marked glyph. */
 692       CurrentInsertCount= 0x3E0,        /* This 5-bit field is treated as a count of the
 693                                          * number of glyphs to insert at the current
 694                                          * position. Since zero means no insertions, the
 695                                          * largest number of insertions at any given
 696                                          * current location is 31 glyphs. */
 697       MarkedInsertCount= 0x001F,        /* This 5-bit field is treated as a count of the
 698                                          * number of glyphs to insert at the marked
 699                                          * position. Since zero means no insertions, the
 700                                          * largest number of insertions at any given
 701                                          * marked location is 31 glyphs. */
 702     };
 703 
 704     driver_context_t (const InsertionSubtable *table,
 705                       hb_aat_apply_context_t *c_) :
 706         ret (false),
 707         c (c_),
 708         mark (0),
 709         insertionAction (table+table-&gt;insertionAction) {}
 710 
 711     bool is_actionable (StateTableDriver&lt;Types, EntryData&gt; *driver HB_UNUSED,
 712                         const Entry&lt;EntryData&gt; &amp;entry)
 713     {
 714       return (entry.flags &amp; (CurrentInsertCount | MarkedInsertCount)) &amp;&amp;
 715              (entry.data.currentInsertIndex != 0xFFFF ||entry.data.markedInsertIndex != 0xFFFF);
 716     }
 717     void transition (StateTableDriver&lt;Types, EntryData&gt; *driver,
 718                      const Entry&lt;EntryData&gt; &amp;entry)
 719     {
 720       hb_buffer_t *buffer = driver-&gt;buffer;
 721       unsigned int flags = entry.flags;
 722 
 723       unsigned mark_loc = buffer-&gt;out_len;
 724 
 725       if (entry.data.markedInsertIndex != 0xFFFF)
 726       {
 727         unsigned int count = (flags &amp; MarkedInsertCount);
 728         unsigned int start = entry.data.markedInsertIndex;
 729         const GlyphID *glyphs = &amp;insertionAction[start];
 730         if (unlikely (!c-&gt;sanitizer.check_array (glyphs, count))) count = 0;
 731 
 732         bool before = flags &amp; MarkedInsertBefore;
 733 
 734         unsigned int end = buffer-&gt;out_len;
 735         buffer-&gt;move_to (mark);
 736 
 737         if (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; !before)
 738           buffer-&gt;copy_glyph ();
 739         /* TODO We ignore KashidaLike setting. */
 740         for (unsigned int i = 0; i &lt; count; i++)
 741           buffer-&gt;output_glyph (glyphs[i]);
 742         if (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; !before)
 743           buffer-&gt;skip_glyph ();
 744 
 745         buffer-&gt;move_to (end + count);
 746 
 747         buffer-&gt;unsafe_to_break_from_outbuffer (mark, MIN (buffer-&gt;idx + 1, buffer-&gt;len));
 748       }
 749 
 750       if (flags &amp; SetMark)
 751         mark = mark_loc;
 752 
 753       if (entry.data.currentInsertIndex != 0xFFFF)
 754       {
 755         unsigned int count = (flags &amp; CurrentInsertCount) &gt;&gt; 5;
 756         unsigned int start = entry.data.currentInsertIndex;
 757         const GlyphID *glyphs = &amp;insertionAction[start];
 758         if (unlikely (!c-&gt;sanitizer.check_array (glyphs, count))) count = 0;
 759 
 760         bool before = flags &amp; CurrentInsertBefore;
 761 
 762         unsigned int end = buffer-&gt;out_len;
 763 
 764         if (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; !before)
 765           buffer-&gt;copy_glyph ();
 766         /* TODO We ignore KashidaLike setting. */
 767         for (unsigned int i = 0; i &lt; count; i++)
 768           buffer-&gt;output_glyph (glyphs[i]);
 769         if (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; !before)
 770           buffer-&gt;skip_glyph ();
 771 
 772         /* Humm. Not sure where to move to.  There&#39;s this wording under
 773          * DontAdvance flag:
 774          *
 775          * &quot;If set, don&#39;t update the glyph index before going to the new state.
 776          * This does not mean that the glyph pointed to is the same one as
 777          * before. If you&#39;ve made insertions immediately downstream of the
 778          * current glyph, the next glyph processed would in fact be the first
 779          * one inserted.&quot;
 780          *
 781          * This suggests that if DontAdvance is NOT set, we should move to
 782          * end+count.  If it *was*, then move to end, such that newly inserted
 783          * glyphs are now visible.
 784          *
 785          * https://github.com/harfbuzz/harfbuzz/issues/1224#issuecomment-427691417
 786          */
 787         buffer-&gt;move_to ((flags &amp; DontAdvance) ? end : end + count);
 788       }
 789     }
 790 
 791     public:
 792     bool ret;
 793     private:
 794     hb_aat_apply_context_t *c;
 795     unsigned int mark;
 796     const UnsizedArrayOf&lt;GlyphID&gt; &amp;insertionAction;
 797   };
 798 
 799   bool apply (hb_aat_apply_context_t *c) const
 800   {
 801     TRACE_APPLY (this);
 802 
 803     driver_context_t dc (this, c);
 804 
 805     StateTableDriver&lt;Types, EntryData&gt; driver (machine, c-&gt;buffer, c-&gt;face);
 806     driver.drive (&amp;dc);
 807 
 808     return_trace (dc.ret);
 809   }
 810 
 811   bool sanitize (hb_sanitize_context_t *c) const
 812   {
 813     TRACE_SANITIZE (this);
 814     /* The rest of array sanitizations are done at run-time. */
 815     return_trace (c-&gt;check_struct (this) &amp;&amp; machine.sanitize (c) &amp;&amp;
 816                   insertionAction);
 817   }
 818 
 819   protected:
 820   StateTable&lt;Types, EntryData&gt;
 821                 machine;
 822   NNOffsetTo&lt;UnsizedArrayOf&lt;GlyphID&gt;, HBUINT&gt;
 823                 insertionAction;        /* Byte offset from stateHeader to the start of
 824                                          * the insertion glyph table. */
 825   public:
 826   DEFINE_SIZE_STATIC (20);
 827 };
 828 
 829 
 830 struct Feature
 831 {
 832   bool sanitize (hb_sanitize_context_t *c) const
 833   {
 834     TRACE_SANITIZE (this);
 835     return_trace (c-&gt;check_struct (this));
 836   }
 837 
 838   public:
 839   HBUINT16      featureType;    /* The type of feature. */
 840   HBUINT16      featureSetting; /* The feature&#39;s setting (aka selector). */
 841   HBUINT32      enableFlags;    /* Flags for the settings that this feature
 842                                  * and setting enables. */
 843   HBUINT32      disableFlags;   /* Complement of flags for the settings that this
 844                                  * feature and setting disable. */
 845 
 846   public:
 847   DEFINE_SIZE_STATIC (12);
 848 };
 849 
 850 template &lt;typename Types&gt;
 851 struct ChainSubtable
 852 {
 853   typedef typename Types::HBUINT HBUINT;
 854 
 855   template &lt;typename T&gt;
 856   friend struct Chain;
 857 
 858   unsigned int get_size () const     { return length; }
 859   unsigned int get_type () const     { return coverage &amp; 0xFF; }
 860   unsigned int get_coverage () const { return coverage &gt;&gt; (sizeof (HBUINT) * 8 - 8); }
 861 
 862   enum Coverage
 863   {
 864     Vertical            = 0x80, /* If set, this subtable will only be applied
 865                                  * to vertical text. If clear, this subtable
 866                                  * will only be applied to horizontal text. */
 867     Backwards           = 0x40, /* If set, this subtable will process glyphs
 868                                  * in descending order. If clear, it will
 869                                  * process the glyphs in ascending order. */
 870     AllDirections       = 0x20, /* If set, this subtable will be applied to
 871                                  * both horizontal and vertical text (i.e.
 872                                  * the state of bit 0x80000000 is ignored). */
 873     Logical             = 0x10, /* If set, this subtable will process glyphs
 874                                  * in logical order (or reverse logical order,
 875                                  * depending on the value of bit 0x80000000). */
 876   };
 877   enum Type
 878   {
 879     Rearrangement       = 0,
 880     Contextual          = 1,
 881     Ligature            = 2,
 882     Noncontextual       = 4,
 883     Insertion           = 5
 884   };
 885 
 886   template &lt;typename context_t&gt;
 887   typename context_t::return_t dispatch (context_t *c) const
 888   {
 889     unsigned int subtable_type = get_type ();
 890     TRACE_DISPATCH (this, subtable_type);
 891     switch (subtable_type) {
 892     case Rearrangement:         return_trace (c-&gt;dispatch (u.rearrangement));
 893     case Contextual:            return_trace (c-&gt;dispatch (u.contextual));
 894     case Ligature:              return_trace (c-&gt;dispatch (u.ligature));
 895     case Noncontextual:         return_trace (c-&gt;dispatch (u.noncontextual));
 896     case Insertion:             return_trace (c-&gt;dispatch (u.insertion));
 897     default:                    return_trace (c-&gt;default_return_value ());
 898     }
 899   }
 900 
 901   bool apply (hb_aat_apply_context_t *c) const
 902   {
 903     TRACE_APPLY (this);
 904     hb_sanitize_with_object_t with (&amp;c-&gt;sanitizer, this);
 905     return_trace (dispatch (c));
 906   }
 907 
 908   bool sanitize (hb_sanitize_context_t *c) const
 909   {
 910     TRACE_SANITIZE (this);
 911     if (!length.sanitize (c) ||
 912         length &lt;= min_size ||
 913         !c-&gt;check_range (this, length))
 914       return_trace (false);
 915 
 916     hb_sanitize_with_object_t with (c, this);
 917     return_trace (dispatch (c));
 918   }
 919 
 920   protected:
 921   HBUINT        length;         /* Total subtable length, including this header. */
 922   HBUINT        coverage;       /* Coverage flags and subtable type. */
 923   HBUINT32      subFeatureFlags;/* The 32-bit mask identifying which subtable this is. */
 924   union {
 925   RearrangementSubtable&lt;Types&gt;  rearrangement;
 926   ContextualSubtable&lt;Types&gt;     contextual;
 927   LigatureSubtable&lt;Types&gt;       ligature;
 928   NoncontextualSubtable&lt;Types&gt;  noncontextual;
 929   InsertionSubtable&lt;Types&gt;      insertion;
 930   } u;
 931   public:
 932   DEFINE_SIZE_MIN (2 * sizeof (HBUINT) + 4);
 933 };
 934 
 935 template &lt;typename Types&gt;
 936 struct Chain
 937 {
 938   typedef typename Types::HBUINT HBUINT;
 939 
 940   hb_mask_t compile_flags (const hb_aat_map_builder_t *map) const
 941   {
 942     hb_mask_t flags = defaultFlags;
 943     {
 944       unsigned int count = featureCount;
 945       for (unsigned i = 0; i &lt; count; i++)
 946       {
 947         const Feature &amp;feature = featureZ[i];
 948         hb_aat_layout_feature_type_t type = (hb_aat_layout_feature_type_t) (unsigned int) feature.featureType;
 949         hb_aat_layout_feature_selector_t setting = (hb_aat_layout_feature_selector_t) (unsigned int) feature.featureSetting;
 950       retry:
 951         const hb_aat_map_builder_t::feature_info_t *info = map-&gt;features.bsearch (type);
 952         if (info &amp;&amp; info-&gt;setting == setting)
 953         {
 954           flags &amp;= feature.disableFlags;
 955           flags |= feature.enableFlags;
 956         }
 957         else if (type == HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE &amp;&amp; setting == HB_AAT_LAYOUT_FEATURE_SELECTOR_SMALL_CAPS)
 958         {
 959           /* Deprecated. https://github.com/harfbuzz/harfbuzz/issues/1342 */
 960           type = HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE;
 961           setting = HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS;
 962           goto retry;
 963         }
 964       }
 965     }
 966     return flags;
 967   }
 968 
 969   void apply (hb_aat_apply_context_t *c,
 970                      hb_mask_t flags) const
 971   {
 972     const ChainSubtable&lt;Types&gt; *subtable = &amp;StructAfter&lt;ChainSubtable&lt;Types&gt; &gt; (featureZ.as_array (featureCount));
 973     unsigned int count = subtableCount;
 974     for (unsigned int i = 0; i &lt; count; i++)
 975     {
 976       bool reverse;
 977 
 978       if (!(subtable-&gt;subFeatureFlags &amp; flags))
 979         goto skip;
 980 
 981       if (!(subtable-&gt;get_coverage() &amp; ChainSubtable&lt;Types&gt;::AllDirections) &amp;&amp;
 982           HB_DIRECTION_IS_VERTICAL (c-&gt;buffer-&gt;props.direction) !=
 983           bool (subtable-&gt;get_coverage() &amp; ChainSubtable&lt;Types&gt;::Vertical))
 984         goto skip;
 985 
 986       /* Buffer contents is always in logical direction.  Determine if
 987        * we need to reverse before applying this subtable.  We reverse
 988        * back after if we did reverse indeed.
 989        *
 990        * Quoting the spac:
 991        * &quot;&quot;&quot;
 992        * Bits 28 and 30 of the coverage field control the order in which
 993        * glyphs are processed when the subtable is run by the layout engine.
 994        * Bit 28 is used to indicate if the glyph processing direction is
 995        * the same as logical order or layout order. Bit 30 is used to
 996        * indicate whether glyphs are processed forwards or backwards within
 997        * that order.
 998 
 999                 Bit 30  Bit 28  Interpretation for Horizontal Text
1000                 0       0       The subtable is processed in layout order
1001                                 (the same order as the glyphs, which is
1002                                 always left-to-right).
1003                 1       0       The subtable is processed in reverse layout order
1004                                 (the order opposite that of the glyphs, which is
1005                                 always right-to-left).
1006                 0       1       The subtable is processed in logical order
1007                                 (the same order as the characters, which may be
1008                                 left-to-right or right-to-left).
1009                 1       1       The subtable is processed in reverse logical order
1010                                 (the order opposite that of the characters, which
1011                                 may be right-to-left or left-to-right).
1012        */
1013       reverse = subtable-&gt;get_coverage () &amp; ChainSubtable&lt;Types&gt;::Logical ?
1014                 bool (subtable-&gt;get_coverage () &amp; ChainSubtable&lt;Types&gt;::Backwards) :
1015                 bool (subtable-&gt;get_coverage () &amp; ChainSubtable&lt;Types&gt;::Backwards) !=
1016                 HB_DIRECTION_IS_BACKWARD (c-&gt;buffer-&gt;props.direction);
1017 
1018       if (!c-&gt;buffer-&gt;message (c-&gt;font, &quot;start chain subtable %d&quot;, c-&gt;lookup_index))
1019         goto skip;
1020 
1021       if (reverse)
1022         c-&gt;buffer-&gt;reverse ();
1023 
1024       subtable-&gt;apply (c);
1025 
1026       if (reverse)
1027         c-&gt;buffer-&gt;reverse ();
1028 
1029       (void) c-&gt;buffer-&gt;message (c-&gt;font, &quot;end chain subtable %d&quot;, c-&gt;lookup_index);
1030 
1031       if (unlikely (!c-&gt;buffer-&gt;successful)) return;
1032 
1033     skip:
1034       subtable = &amp;StructAfter&lt;ChainSubtable&lt;Types&gt; &gt; (*subtable);
1035       c-&gt;set_lookup_index (c-&gt;lookup_index + 1);
1036     }
1037   }
1038 
1039   unsigned int get_size () const { return length; }
1040 
1041   bool sanitize (hb_sanitize_context_t *c, unsigned int version HB_UNUSED) const
1042   {
1043     TRACE_SANITIZE (this);
1044     if (!length.sanitize (c) ||
1045         length &lt; min_size ||
1046         !c-&gt;check_range (this, length))
1047       return_trace (false);
1048 
1049     if (!c-&gt;check_array (featureZ.arrayZ, featureCount))
1050       return_trace (false);
1051 
1052     const ChainSubtable&lt;Types&gt; *subtable = &amp;StructAfter&lt;ChainSubtable&lt;Types&gt; &gt; (featureZ.as_array (featureCount));
1053     unsigned int count = subtableCount;
1054     for (unsigned int i = 0; i &lt; count; i++)
1055     {
1056       if (!subtable-&gt;sanitize (c))
1057         return_trace (false);
1058       subtable = &amp;StructAfter&lt;ChainSubtable&lt;Types&gt; &gt; (*subtable);
1059     }
1060 
1061     return_trace (true);
1062   }
1063 
1064   protected:
1065   HBUINT32      defaultFlags;   /* The default specification for subtables. */
1066   HBUINT32      length;         /* Total byte count, including this header. */
1067   HBUINT        featureCount;   /* Number of feature subtable entries. */
1068   HBUINT        subtableCount;  /* The number of subtables in the chain. */
1069 
1070   UnsizedArrayOf&lt;Feature&gt;       featureZ;       /* Features. */
1071 /*ChainSubtable firstSubtable;*//* Subtables. */
1072 /*subtableGlyphCoverageArray*/  /* Only if version &gt;= 3. We don&#39;t use. */
1073 
1074   public:
1075   DEFINE_SIZE_MIN (8 + 2 * sizeof (HBUINT));
1076 };
1077 
1078 
1079 /*
1080  * The &#39;mort&#39;/&#39;morx&#39; Table
1081  */
1082 
1083 template &lt;typename Types&gt;
1084 struct mortmorx
1085 {
1086   static constexpr hb_tag_t tableTag = HB_AAT_TAG_morx;
1087 
1088   bool has_data () const { return version != 0; }
1089 
1090   void compile_flags (const hb_aat_map_builder_t *mapper,
1091                       hb_aat_map_t *map) const
1092   {
1093     const Chain&lt;Types&gt; *chain = &amp;firstChain;
1094     unsigned int count = chainCount;
1095     for (unsigned int i = 0; i &lt; count; i++)
1096     {
1097       map-&gt;chain_flags.push (chain-&gt;compile_flags (mapper));
1098       chain = &amp;StructAfter&lt;Chain&lt;Types&gt; &gt; (*chain);
1099     }
1100   }
1101 
1102   void apply (hb_aat_apply_context_t *c) const
1103   {
1104     if (unlikely (!c-&gt;buffer-&gt;successful)) return;
1105     c-&gt;set_lookup_index (0);
1106     const Chain&lt;Types&gt; *chain = &amp;firstChain;
1107     unsigned int count = chainCount;
1108     for (unsigned int i = 0; i &lt; count; i++)
1109     {
1110       chain-&gt;apply (c, c-&gt;plan-&gt;aat_map.chain_flags[i]);
1111       if (unlikely (!c-&gt;buffer-&gt;successful)) return;
1112       chain = &amp;StructAfter&lt;Chain&lt;Types&gt; &gt; (*chain);
1113     }
1114   }
1115 
1116   bool sanitize (hb_sanitize_context_t *c) const
1117   {
1118     TRACE_SANITIZE (this);
1119     if (!version.sanitize (c) || !version || !chainCount.sanitize (c))
1120       return_trace (false);
1121 
1122     const Chain&lt;Types&gt; *chain = &amp;firstChain;
1123     unsigned int count = chainCount;
1124     for (unsigned int i = 0; i &lt; count; i++)
1125     {
1126       if (!chain-&gt;sanitize (c, version))
1127         return_trace (false);
1128       chain = &amp;StructAfter&lt;Chain&lt;Types&gt; &gt; (*chain);
1129     }
1130 
1131     return_trace (true);
1132   }
1133 
1134   protected:
1135   HBUINT16      version;        /* Version number of the glyph metamorphosis table.
1136                                  * 1, 2, or 3. */
1137   HBUINT16      unused;         /* Set to 0. */
1138   HBUINT32      chainCount;     /* Number of metamorphosis chains contained in this
1139                                  * table. */
1140   Chain&lt;Types&gt;  firstChain;     /* Chains. */
1141 
1142   public:
1143   DEFINE_SIZE_MIN (8);
1144 };
1145 
1146 struct morx : mortmorx&lt;ExtendedTypes&gt;
1147 {
1148   static constexpr hb_tag_t tableTag = HB_AAT_TAG_morx;
1149 };
1150 struct mort : mortmorx&lt;ObsoleteTypes&gt;
1151 {
1152   static constexpr hb_tag_t tableTag = HB_AAT_TAG_mort;
1153 };
1154 
1155 
1156 } /* namespace AAT */
1157 
1158 
1159 #endif /* HB_AAT_LAYOUT_MORX_TABLE_HH */
    </pre>
  </body>
</html>