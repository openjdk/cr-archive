<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libharfbuzz/hb.hh</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2007,2008,2009  Red Hat, Inc.
  3  * Copyright © 2011,2012  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_HH
 30 #define HB_HH
 31 
 32 #ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC
 33 #if defined(_MSC_VER)
 34 #pragma warning( disable: 4068 ) /* Unknown pragma */
 35 #endif
 36 #if defined(__GNUC__) || defined(__clang__)
 37 /* Rules:
 38  *
 39  * - All pragmas are declared GCC even if they are clang ones.  Otherwise GCC
 40  *   nags, even though we instruct it to ignore -Wunknown-pragmas. ¯\_(ツ)_/¯
 41  *
 42  * - Within each category, keep sorted.
 43  *
 44  * - Warnings whose scope can be expanded in future compiler versions shall
 45  *   be declared as &quot;warning&quot;.  Otherwise, either ignored or error.
 46  */
 47 
 48 /* Setup.  Don&#39;t sort order within this category. */
 49 #ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_WARNING
 50 #pragma GCC diagnostic warning &quot;-Wall&quot;
 51 #pragma GCC diagnostic warning &quot;-Wextra&quot;
 52 #endif
 53 #ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_IGNORED
 54 #pragma GCC diagnostic ignored &quot;-Wpragmas&quot;
 55 #pragma GCC diagnostic ignored &quot;-Wunknown-pragmas&quot;
 56 #pragma GCC diagnostic ignored &quot;-Wunknown-warning-option&quot;
 57 #endif
 58 #ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_WARNING
 59 //#pragma GCC diagnostic warning &quot;-Weverything&quot;
 60 #endif
 61 
 62 /* Error.  Should never happen. */
 63 #ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_ERROR
 64 #pragma GCC diagnostic error   &quot;-Wc++11-narrowing&quot;
 65 #pragma GCC diagnostic error   &quot;-Wcast-align&quot;
 66 #pragma GCC diagnostic error   &quot;-Wcast-function-type&quot;
 67 #pragma GCC diagnostic error   &quot;-Wdelete-non-virtual-dtor&quot;
 68 #pragma GCC diagnostic error   &quot;-Wformat-security&quot;
 69 #pragma GCC diagnostic error   &quot;-Wimplicit-function-declaration&quot;
 70 #pragma GCC diagnostic error   &quot;-Winit-self&quot;
 71 #pragma GCC diagnostic error   &quot;-Wmissing-braces&quot;
 72 #pragma GCC diagnostic error   &quot;-Wmissing-declarations&quot;
 73 #pragma GCC diagnostic error   &quot;-Wmissing-prototypes&quot;
 74 #pragma GCC diagnostic error   &quot;-Wnested-externs&quot;
 75 #pragma GCC diagnostic error   &quot;-Wold-style-definition&quot;
 76 #pragma GCC diagnostic error   &quot;-Wpointer-arith&quot;
 77 #pragma GCC diagnostic error   &quot;-Wredundant-decls&quot;
 78 #pragma GCC diagnostic error   &quot;-Wreorder&quot;
 79 #pragma GCC diagnostic error   &quot;-Wsign-compare&quot;
 80 #pragma GCC diagnostic error   &quot;-Wstrict-prototypes&quot;
 81 #pragma GCC diagnostic error   &quot;-Wstring-conversion&quot;
 82 #pragma GCC diagnostic error   &quot;-Wswitch-enum&quot;
 83 #pragma GCC diagnostic error   &quot;-Wtautological-overlap-compare&quot;
 84 #pragma GCC diagnostic error   &quot;-Wunneeded-internal-declaration&quot;
 85 #pragma GCC diagnostic error   &quot;-Wunused&quot;
 86 #pragma GCC diagnostic error   &quot;-Wunused-local-typedefs&quot;
 87 #pragma GCC diagnostic error   &quot;-Wunused-value&quot;
 88 #pragma GCC diagnostic error   &quot;-Wunused-variable&quot;
 89 #pragma GCC diagnostic error   &quot;-Wvla&quot;
 90 #pragma GCC diagnostic error   &quot;-Wwrite-strings&quot;
 91 #endif
 92 
 93 /* Warning.  To be investigated if happens. */
 94 #ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_WARNING
 95 #pragma GCC diagnostic warning &quot;-Wbuiltin-macro-redefined&quot;
 96 #pragma GCC diagnostic warning &quot;-Wdisabled-optimization&quot;
 97 #pragma GCC diagnostic warning &quot;-Wformat=2&quot;
 98 #pragma GCC diagnostic warning &quot;-Wignored-pragma-optimize&quot;
 99 #pragma GCC diagnostic warning &quot;-Wlogical-op&quot;
100 #pragma GCC diagnostic warning &quot;-Wmaybe-uninitialized&quot;
101 #pragma GCC diagnostic warning &quot;-Wmissing-format-attribute&quot;
102 #pragma GCC diagnostic warning &quot;-Wundef&quot;
103 #endif
104 
105 /* Ignored currently, but should be fixed at some point. */
106 #ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_IGNORED
107 #pragma GCC diagnostic ignored &quot;-Wconversion&quot;                   // TODO fix
108 #pragma GCC diagnostic ignored &quot;-Wformat-signedness&quot;            // TODO fix
109 #pragma GCC diagnostic ignored &quot;-Wshadow&quot;                       // TODO fix
110 #pragma GCC diagnostic ignored &quot;-Wunsafe-loop-optimizations&quot;    // TODO fix
111 #pragma GCC diagnostic ignored &quot;-Wunused-parameter&quot;             // TODO fix
112 #endif
113 
114 /* Ignored intentionally. */
115 #ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_IGNORED
116 #pragma GCC diagnostic ignored &quot;-Wclass-memaccess&quot;
117 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
118 #pragma GCC diagnostic ignored &quot;-Wformat-zero-length&quot;
119 #pragma GCC diagnostic ignored &quot;-Wmissing-field-initializers&quot;
120 #pragma GCC diagnostic ignored &quot;-Wpacked&quot; // Erratic impl in clang
121 #pragma GCC diagnostic ignored &quot;-Wstrict-aliasing&quot;
122 #pragma GCC diagnostic ignored &quot;-Wtype-limits&quot;
123 #endif
124 
125 #endif
126 #endif
127 
128 #ifdef HAVE_CONFIG_H
129 #include &quot;config.h&quot;
130 #endif
131 
132 /*
133  * Following added based on what AC_USE_SYSTEM_EXTENSIONS adds to
134  * config.h.in.  Copied here for the convenience of those embedding
135  * HarfBuzz and not using our build system.
136  */
137 /* Enable extensions on AIX 3, Interix.  */
138 #ifndef _ALL_SOURCE
139 # define _ALL_SOURCE 1
140 #endif
141 /* Enable GNU extensions on systems that have them.  */
142 #ifndef _GNU_SOURCE
143 # define _GNU_SOURCE 1
144 #endif
145 /* Enable threading extensions on Solaris.  */
146 #ifndef _POSIX_PTHREAD_SEMANTICS
147 # define _POSIX_PTHREAD_SEMANTICS 1
148 #endif
149 /* Enable extensions on HP NonStop.  */
150 #ifndef _TANDEM_SOURCE
151 # define _TANDEM_SOURCE 1
152 #endif
153 /* Enable general extensions on Solaris.  */
154 #ifndef __EXTENSIONS__
155 # define __EXTENSIONS__ 1
156 #endif
157 
158 #if defined (_MSC_VER) &amp;&amp; defined (HB_DLL_EXPORT)
159 #define HB_EXTERN __declspec (dllexport) extern
160 #endif
161 
162 #include &quot;hb.h&quot;
163 #define HB_H_IN
164 #include &quot;hb-ot.h&quot;
165 #define HB_OT_H_IN
166 #include &quot;hb-aat.h&quot;
167 #define HB_AAT_H_IN
168 
169 #include &quot;hb-aat.h&quot;
170 
171 #include &lt;math.h&gt;
172 #include &lt;stdlib.h&gt;
173 #include &lt;stddef.h&gt;
174 #include &lt;string.h&gt;
175 #include &lt;assert.h&gt;
176 #include &lt;errno.h&gt;
177 #include &lt;stdio.h&gt;
178 #include &lt;stdarg.h&gt;
179 
180 #if (defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1500) || defined(__MINGW32__)
181 #include &lt;intrin.h&gt;
182 #endif
183 
184 #define HB_PASTE1(a,b) a##b
185 #define HB_PASTE(a,b) HB_PASTE1(a,b)
186 
187 
188 /* Compile-time custom allocator support. */
189 
190 #if defined(hb_malloc_impl) \
191  &amp;&amp; defined(hb_calloc_impl) \
192  &amp;&amp; defined(hb_realloc_impl) \
193  &amp;&amp; defined(hb_free_impl)
194 extern &quot;C&quot; void* hb_malloc_impl(size_t size);
195 extern &quot;C&quot; void* hb_calloc_impl(size_t nmemb, size_t size);
196 extern &quot;C&quot; void* hb_realloc_impl(void *ptr, size_t size);
197 extern &quot;C&quot; void  hb_free_impl(void *ptr);
198 #define malloc hb_malloc_impl
199 #define calloc hb_calloc_impl
200 #define realloc hb_realloc_impl
201 #define free hb_free_impl
202 
203 #if defined(hb_memalign_impl)
204 extern &quot;C&quot; int hb_memalign_impl(void **memptr, size_t alignment, size_t size);
205 #define posix_memalign hb_memalign_impl
206 #else
207 #undef HAVE_POSIX_MEMALIGN
208 #endif
209 
210 #endif
211 
212 
213 /*
214  * Compiler attributes
215  */
216 
217 #if __cplusplus &lt; 201103L
218 
219 #ifndef nullptr
220 #define nullptr NULL
221 #endif
222 
223 #ifndef constexpr
224 #define constexpr const
225 #endif
226 
227 #ifndef static_assert
228 #define static_assert(e, msg) \
229         HB_UNUSED typedef int HB_PASTE(static_assertion_failed_at_line_, __LINE__) [(e) ? 1 : -1]
230 #endif // static_assert
231 
232 #if defined(__GNUC__)
233 #if (__GNUC__ &lt; 4 || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &lt; 8))
234 #define thread_local __thread
235 #endif
236 #else
237 #define thread_local
238 #endif
239 
240 template &lt;typename T&gt;
241 struct _hb_alignof
242 {
243   struct s
244   {
245     char c;
246     T t;
247   };
248   static constexpr size_t value = offsetof (s, t);
249 };
250 #ifndef alignof
251 #define alignof(x) (_hb_alignof&lt;x&gt;::value)
252 #endif
253 
254 /* https://github.com/harfbuzz/harfbuzz/issues/1127 */
255 #ifndef explicit_operator
256 #define explicit_operator operator
257 #endif
258 
259 #else /* __cplusplus &gt;= 201103L */
260 
261 /* https://github.com/harfbuzz/harfbuzz/issues/1127 */
262 #ifndef explicit_operator
263 #define explicit_operator explicit operator
264 #endif
265 
266 #endif /* __cplusplus &lt; 201103L */
267 
268 
269 #if (defined(__GNUC__) || defined(__clang__)) &amp;&amp; defined(__OPTIMIZE__)
270 #define likely(expr) (__builtin_expect (!!(expr), 1))
271 #define unlikely(expr) (__builtin_expect (!!(expr), 0))
272 #else
273 #define likely(expr) (expr)
274 #define unlikely(expr) (expr)
275 #endif
276 
277 #if !defined(__GNUC__) &amp;&amp; !defined(__clang__)
278 #undef __attribute__
279 #define __attribute__(x)
280 #endif
281 
282 #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3)
283 #define HB_PURE_FUNC    __attribute__((pure))
284 #define HB_CONST_FUNC   __attribute__((const))
285 #define HB_PRINTF_FUNC(format_idx, arg_idx) __attribute__((__format__ (__printf__, format_idx, arg_idx)))
286 #else
287 #define HB_PURE_FUNC
288 #define HB_CONST_FUNC
289 #define HB_PRINTF_FUNC(format_idx, arg_idx)
290 #endif
291 #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)
292 #define HB_UNUSED       __attribute__((unused))
293 #elif defined(_MSC_VER) /* https://github.com/harfbuzz/harfbuzz/issues/635 */
294 #define HB_UNUSED __pragma(warning(suppress: 4100 4101))
295 #else
296 #define HB_UNUSED
297 #endif
298 
299 #ifndef HB_INTERNAL
300 # if !defined(HB_NO_VISIBILITY) &amp;&amp; !defined(__MINGW32__) &amp;&amp; !defined(__CYGWIN__) &amp;&amp; !defined(_MSC_VER) &amp;&amp; !defined(__SUNPRO_CC)
301 #  define HB_INTERNAL __attribute__((__visibility__(&quot;hidden&quot;)))
302 # elif defined(__MINGW32__)
303    /* We use -export-symbols on mingw32, since it does not support visibility attributes. */
304 #  define HB_INTERNAL
305 # elif defined (_MSC_VER) &amp;&amp; defined (HB_DLL_EXPORT)
306    /* We do not try to export internal symbols on Visual Studio */
307 #  define HB_INTERNAL
308 #else
309 #  define HB_INTERNAL
310 #  define HB_NO_VISIBILITY 1
311 # endif
312 #endif
313 
314 #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3)
315 #define HB_FUNC __PRETTY_FUNCTION__
316 #elif defined(_MSC_VER)
317 #define HB_FUNC __FUNCSIG__
318 #else
319 #define HB_FUNC __func__
320 #endif
321 
322 #if defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &lt; 0x5140)
323 /* https://github.com/harfbuzz/harfbuzz/issues/630 */
324 #define __restrict
325 #endif
326 
327 /*
328  * Borrowed from https://bugzilla.mozilla.org/show_bug.cgi?id=1215411
329  * HB_FALLTHROUGH is an annotation to suppress compiler warnings about switch
330  * cases that fall through without a break or return statement. HB_FALLTHROUGH
331  * is only needed on cases that have code:
332  *
333  * switch (foo) {
334  *   case 1: // These cases have no code. No fallthrough annotations are needed.
335  *   case 2:
336  *   case 3:
337  *     foo = 4; // This case has code, so a fallthrough annotation is needed:
338  *     HB_FALLTHROUGH;
339  *   default:
340  *     return foo;
341  * }
342  */
343 #if defined(__clang__) &amp;&amp; __cplusplus &gt;= 201103L
344    /* clang&#39;s fallthrough annotations are only available starting in C++11. */
345 #  define HB_FALLTHROUGH [[clang::fallthrough]]
346 #elif defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 7)
347    /* GNU fallthrough attribute is available from GCC7 */
348 #  define HB_FALLTHROUGH __attribute__((fallthrough))
349 #elif defined(_MSC_VER)
350    /*
351     * MSVC&#39;s __fallthrough annotations are checked by /analyze (Code Analysis):
352     * https://msdn.microsoft.com/en-us/library/ms235402%28VS.80%29.aspx
353     */
354 #  include &lt;sal.h&gt;
355 #  define HB_FALLTHROUGH __fallthrough
356 #else
357 #  define HB_FALLTHROUGH /* FALLTHROUGH */
358 #endif
359 
360 #if defined(__clang__)
361 /* Disable certain sanitizer errors. */
362 /* https://github.com/harfbuzz/harfbuzz/issues/1247 */
363 #define HB_NO_SANITIZE_SIGNED_INTEGER_OVERFLOW __attribute__((no_sanitize(&quot;signed-integer-overflow&quot;)))
364 #else
365 #define HB_NO_SANITIZE_SIGNED_INTEGER_OVERFLOW
366 #endif
367 
368 
369 #ifdef _WIN32
370    /* We need Windows Vista for both Uniscribe backend and for
371     * MemoryBarrier.  We don&#39;t support compiling on Windows XP,
372     * though we run on it fine. */
373 #  if defined(_WIN32_WINNT) &amp;&amp; _WIN32_WINNT &lt; 0x0600
374 #    undef _WIN32_WINNT
375 #  endif
376 #  ifndef _WIN32_WINNT
377 #    if !defined(WINAPI_FAMILY) || !(WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)
378 #      define _WIN32_WINNT 0x0600
379 #    endif
380 #  endif
381 #  ifndef WIN32_LEAN_AND_MEAN
382 #    define WIN32_LEAN_AND_MEAN 1
383 #  endif
384 #  ifndef STRICT
385 #    define STRICT 1
386 #  endif
387 
388 #  if defined(_WIN32_WCE)
389      /* Some things not defined on Windows CE. */
390 #    define vsnprintf _vsnprintf
391 #    define getenv(Name) nullptr
392 #    if _WIN32_WCE &lt; 0x800
393 #      define setlocale(Category, Locale) &quot;C&quot;
394 static int errno = 0; /* Use something better? */
395 #    endif
396 #  elif defined(WINAPI_FAMILY) &amp;&amp; (WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)
397 #    define getenv(Name) nullptr
398 #  endif
399 #  if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900
400 #    define snprintf _snprintf
401 #  endif
402 #endif
403 
404 #if defined(HAVE_ATEXIT) &amp;&amp; !defined(HB_USE_ATEXIT)
405 /* atexit() is only safe to be called from shared libraries on certain
406  * platforms.  Whitelist.
407  * https://bugs.freedesktop.org/show_bug.cgi?id=82246 */
408 #  if defined(__linux) &amp;&amp; defined(__GLIBC_PREREQ)
409 #    if __GLIBC_PREREQ(2,3)
410 /* From atexit() manpage, it&#39;s safe with glibc 2.2.3 on Linux. */
411 #      define HB_USE_ATEXIT 1
412 #    endif
413 #  elif defined(_MSC_VER) || defined(__MINGW32__)
414 /* For MSVC:
415  * https://msdn.microsoft.com/en-us/library/tze57ck3.aspx
416  * https://msdn.microsoft.com/en-us/library/zk17ww08.aspx
417  * mingw32 headers say atexit is safe to use in shared libraries.
418  */
419 #    define HB_USE_ATEXIT 1
420 #  elif defined(__ANDROID__)
421 /* This is available since Android NKD r8 or r8b:
422  * https://issuetracker.google.com/code/p/android/issues/detail?id=6455
423  */
424 #    define HB_USE_ATEXIT 1
425 #  elif defined(__APPLE__)
426 /* For macOS and related platforms, the atexit man page indicates
427  * that it will be invoked when the library is unloaded, not only
428  * at application exit.
429  */
430 #    define HB_USE_ATEXIT 1
431 #  endif
432 #endif
433 #ifdef HB_NO_ATEXIT
434 #  undef HB_USE_ATEXIT
435 #endif
436 #ifndef HB_USE_ATEXIT
437 #  define HB_USE_ATEXIT 0
438 #endif
439 
440 #define HB_STMT_START do
441 #define HB_STMT_END   while (0)
442 
443 /* Static-assert as expression. */
444 template &lt;unsigned int cond&gt; class hb_assert_constant_t;
445 template &lt;&gt; class hb_assert_constant_t&lt;1&gt; {};
446 #define ASSERT_STATIC_EXPR_ZERO(_cond) (0 * (unsigned int) sizeof (hb_assert_constant_t&lt;_cond&gt;))
447 
448 /* Lets assert int types.  Saves trouble down the road. */
449 static_assert ((sizeof (int8_t) == 1), &quot;&quot;);
450 static_assert ((sizeof (uint8_t) == 1), &quot;&quot;);
451 static_assert ((sizeof (int16_t) == 2), &quot;&quot;);
452 static_assert ((sizeof (uint16_t) == 2), &quot;&quot;);
453 static_assert ((sizeof (int32_t) == 4), &quot;&quot;);
454 static_assert ((sizeof (uint32_t) == 4), &quot;&quot;);
455 static_assert ((sizeof (int64_t) == 8), &quot;&quot;);
456 static_assert ((sizeof (uint64_t) == 8), &quot;&quot;);
457 static_assert ((sizeof (hb_codepoint_t) == 4), &quot;&quot;);
458 static_assert ((sizeof (hb_position_t) == 4), &quot;&quot;);
459 static_assert ((sizeof (hb_mask_t) == 4), &quot;&quot;);
460 static_assert ((sizeof (hb_var_int_t) == 4), &quot;&quot;);
461 
462 
463 #if __cplusplus &gt;= 201103L
464 
465 /* We only enable these with C++11 or later, since earlier language
466  * does not allow structs with constructors in unions, and we need
467  * those. */
468 
469 #define HB_NO_COPY_ASSIGN(TypeName) \
470   TypeName(const TypeName&amp;); \
471   void operator=(const TypeName&amp;)
472 #define HB_NO_COPY_ASSIGN_TEMPLATE(TypeName, T) \
473   TypeName(const TypeName&lt;T&gt;&amp;); \
474   void operator=(const TypeName&lt;T&gt;&amp;)
475 #define HB_NO_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) \
476   TypeName(const TypeName&lt;T1, T2&gt;&amp;); \
477   void operator=(const TypeName&lt;T1, T2&gt;&amp;)
478 #define HB_NO_CREATE_COPY_ASSIGN(TypeName) \
479   TypeName(); \
480   TypeName(const TypeName&amp;); \
481   void operator=(const TypeName&amp;)
482 #define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE(TypeName, T) \
483   TypeName(); \
484   TypeName(const TypeName&lt;T&gt;&amp;); \
485   void operator=(const TypeName&lt;T&gt;&amp;)
486 #define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) \
487   TypeName(); \
488   TypeName(const TypeName&lt;T1, T2&gt;&amp;); \
489   void operator=(const TypeName&lt;T1, T2&gt;&amp;)
490 
491 #else /* __cpluspplus &gt;= 201103L */
492 
493 #define HB_NO_COPY_ASSIGN(TypeName) static_assert (true, &quot;&quot;)
494 #define HB_NO_COPY_ASSIGN_TEMPLATE(TypeName, T) static_assert (true, &quot;&quot;)
495 #define HB_NO_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) static_assert (true, &quot;&quot;)
496 #define HB_NO_CREATE_COPY_ASSIGN(TypeName) static_assert (true, &quot;&quot;)
497 #define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE(TypeName, T) static_assert (true, &quot;&quot;)
498 #define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) static_assert (true, &quot;&quot;)
499 
500 #endif /* __cpluspplus &gt;= 201103L */
501 
502 
503 /*
504  * Compiler-assisted vectorization parameters.
505  */
506 
507 /*
508  * Disable vectorization for now.  To correctly use them, we should
509  * use posix_memalign() to allocate in hb_vector_t.  Otherwise, can
510  * cause misaligned access.
511  *
512  * https://bugs.chromium.org/p/chromium/issues/detail?id=860184
513  */
514 #if !defined(HB_VECTOR_SIZE)
515 #  define HB_VECTOR_SIZE 0
516 #endif
517 
518 /* The `vector_size&#39; attribute was introduced in gcc 3.1. */
519 #if !defined(HB_VECTOR_SIZE)
520 #  if defined( __GNUC__ ) &amp;&amp; ( __GNUC__ &gt;= 4 )
521 #    define HB_VECTOR_SIZE 128
522 #  else
523 #    define HB_VECTOR_SIZE 0
524 #  endif
525 #endif
526 static_assert (0 == (HB_VECTOR_SIZE &amp; (HB_VECTOR_SIZE - 1)), &quot;HB_VECTOR_SIZE is not power of 2.&quot;);
527 static_assert (0 == (HB_VECTOR_SIZE % 64), &quot;HB_VECTOR_SIZE is not multiple of 64.&quot;);
528 #if HB_VECTOR_SIZE
529 typedef uint64_t hb_vector_size_impl_t __attribute__((vector_size (HB_VECTOR_SIZE / 8)));
530 #else
531 typedef uint64_t hb_vector_size_impl_t;
532 #endif
533 
534 
535 /* HB_NDEBUG disables some sanity checks that are very safe to disable and
536  * should be disabled in production systems.  If NDEBUG is defined, enable
537  * HB_NDEBUG; but if it&#39;s desirable that normal assert()s (which are very
538  * light-weight) to be enabled, then HB_DEBUG can be defined to disable
539  * the costlier checks. */
540 #ifdef NDEBUG
541 #define HB_NDEBUG 1
542 #endif
543 
544 
545 /* Flags */
546 
547 /* Enable bitwise ops on enums marked as flags_t */
548 /* To my surprise, looks like the function resolver is happy to silently cast
549  * one enum to another...  So this doesn&#39;t provide the type-checking that I
550  * originally had in mind... :(.
551  *
552  * For MSVC warnings, see: https://github.com/harfbuzz/harfbuzz/pull/163
553  */
554 #ifdef _MSC_VER
555 # pragma warning(disable:4200)
556 # pragma warning(disable:4800)
557 #endif
558 #define HB_MARK_AS_FLAG_T(T) \
559         extern &quot;C++&quot; { \
560           static inline T operator | (T l, T r) { return T ((unsigned) l | (unsigned) r); } \
561           static inline T operator &amp; (T l, T r) { return T ((unsigned) l &amp; (unsigned) r); } \
562           static inline T operator ^ (T l, T r) { return T ((unsigned) l ^ (unsigned) r); } \
563           static inline T operator ~ (T r) { return T (~(unsigned int) r); } \
564           static inline T&amp; operator |= (T &amp;l, T r) { l = l | r; return l; } \
565           static inline T&amp; operator &amp;= (T&amp; l, T r) { l = l &amp; r; return l; } \
566           static inline T&amp; operator ^= (T&amp; l, T r) { l = l ^ r; return l; } \
567         } \
568         static_assert (true, &quot;&quot;)
569 
570 /* Useful for set-operations on small enums.
571  * For example, for testing &quot;x ∈ {x1, x2, x3}&quot; use:
572  * (FLAG_UNSAFE(x) &amp; (FLAG(x1) | FLAG(x2) | FLAG(x3)))
573  */
574 #define FLAG(x) (ASSERT_STATIC_EXPR_ZERO ((unsigned)(x) &lt; 32) + (((uint32_t) 1U) &lt;&lt; (unsigned)(x)))
575 #define FLAG_UNSAFE(x) ((unsigned)(x) &lt; 32 ? (((uint32_t) 1U) &lt;&lt; (unsigned)(x)) : 0)
576 #define FLAG_RANGE(x,y) (ASSERT_STATIC_EXPR_ZERO ((x) &lt; (y)) + FLAG(y+1) - FLAG(x))
577 #define FLAG64(x) (ASSERT_STATIC_EXPR_ZERO ((unsigned)(x) &lt; 64) + (((uint64_t) 1ULL) &lt;&lt; (unsigned)(x)))
578 #define FLAG64_UNSAFE(x) ((unsigned)(x) &lt; 64 ? (((uint64_t) 1ULL) &lt;&lt; (unsigned)(x)) : 0)
579 
580 
581 /* Size signifying variable-sized array */
582 #define VAR 1
583 
584 
585 /* fallback for round() */
586 static inline double
587 _hb_round (double x)
588 {
589   if (x &gt;= 0)
590     return floor (x + 0.5);
591   else
592     return ceil (x - 0.5);
593 }
594 #if !defined (HAVE_ROUND) &amp;&amp; !defined (HAVE_DECL_ROUND)
595 #define round(x) _hb_round(x)
596 #endif
597 
598 
599 /* fallback for posix_memalign() */
600 static inline int
601 _hb_memalign(void **memptr, size_t alignment, size_t size)
602 {
603   if (unlikely (0 != (alignment &amp; (alignment - 1)) ||
604                 !alignment ||
605                 0 != (alignment &amp; (sizeof (void *) - 1))))
606     return EINVAL;
607 
608   char *p = (char *) malloc (size + alignment - 1);
609   if (unlikely (!p))
610     return ENOMEM;
611 
612   size_t off = (size_t) p &amp; (alignment - 1);
613   if (off)
614     p += alignment - off;
615 
616   *memptr = (void *) p;
617 
618   return 0;
619 }
620 #if !defined(posix_memalign) &amp;&amp; !defined(HAVE_POSIX_MEMALIGN)
621 #define posix_memalign _hb_memalign
622 #endif
623 
624 
625 /*
626  * For lack of a better place, put Zawgyi script hack here.
627  * https://github.com/harfbuzz/harfbuzz/issues/1162
628  */
629 
630 #define HB_SCRIPT_MYANMAR_ZAWGYI        ((hb_script_t) HB_TAG (&#39;Q&#39;,&#39;a&#39;,&#39;a&#39;,&#39;g&#39;))
631 
632 
633 /* Some really basic things everyone wants. */
634 template &lt;typename T&gt; struct hb_remove_const { typedef T value; };
635 template &lt;typename T&gt; struct hb_remove_const&lt;const T&gt; { typedef T value; };
636 #define hb_remove_const(T) hb_remove_const&lt;T&gt;::value
637 template &lt;typename T&gt; struct hb_remove_reference { typedef T value; };
638 template &lt;typename T&gt; struct hb_remove_reference&lt;T &amp;&gt; { typedef T value; };
639 #define hb_remove_reference(T) hb_remove_reference&lt;T&gt;::value
640 template &lt;typename T&gt; struct hb_remove_pointer { typedef T value; };
641 template &lt;typename T&gt; struct hb_remove_pointer&lt;T *&gt; { typedef T value; };
642 #define hb_remove_pointer(T) hb_remove_pointer&lt;T&gt;::value
643 
644 
645 /* Headers we include for everyone.  Keep topologically sorted by dependency.
646  * They express dependency amongst themselves, but no other file should include
647  * them directly.*/
648 #include &quot;hb-atomic.hh&quot;
649 #include &quot;hb-mutex.hh&quot;
650 #include &quot;hb-null.hh&quot;
651 #include &quot;hb-dsalgs.hh&quot; // Requires: hb-null
652 #include &quot;hb-iter.hh&quot;   // Requires: hb-null
653 #include &quot;hb-debug.hh&quot;  // Requires: hb-atomic hb-dsalgs
654 #include &quot;hb-array.hh&quot;  // Requires: hb-dsalgs hb-iter hb-null
655 #include &quot;hb-vector.hh&quot; // Requires: hb-array hb-null
656 #include &quot;hb-object.hh&quot; // Requires: hb-atomic hb-mutex hb-vector
657 
658 #endif /* HB_HH */
<a name="1" id="anc1"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="1" type="hidden" />
</body>
</html>