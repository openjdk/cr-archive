<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libharfbuzz/hb-ot-shape-complex-indic.cc</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright Â© 2011,2012  Google, Inc.
   3  *
   4  *  This is part of HarfBuzz, a text shaping library.
   5  *
   6  * Permission is hereby granted, without written agreement and without
   7  * license or royalty fees, to use, copy, modify, and distribute this
   8  * software and its documentation for any purpose, provided that the
   9  * above copyright notice and the following two paragraphs appear in
  10  * all copies of this software.
  11  *
  12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  16  * DAMAGE.
  17  *
  18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  23  *
  24  * Google Author(s): Behdad Esfahbod
  25  */
  26 
  27 #include &quot;hb-ot-shape-complex-indic.hh&quot;
  28 #include &quot;hb-ot-shape-complex-vowel-constraints.hh&quot;
  29 #include &quot;hb-ot-layout.hh&quot;
  30 
  31 
  32 /*
  33  * Indic shaper.
  34  */
  35 
  36 
  37 /*
  38  * Indic configurations.  Note that we do not want to keep every single script-specific
  39  * behavior in these tables necessarily.  This should mainly be used for per-script
  40  * properties that are cheaper keeping here, than in the code.  Ie. if, say, one and
  41  * only one script has an exception, that one script can be if&#39;ed directly in the code,
  42  * instead of adding a new flag in these structs.
  43  */
  44 
  45 enum base_position_t {
  46   BASE_POS_LAST_SINHALA,
  47   BASE_POS_LAST
  48 };
  49 enum reph_position_t {
  50   REPH_POS_AFTER_MAIN  = POS_AFTER_MAIN,
  51   REPH_POS_BEFORE_SUB  = POS_BEFORE_SUB,
  52   REPH_POS_AFTER_SUB   = POS_AFTER_SUB,
  53   REPH_POS_BEFORE_POST = POS_BEFORE_POST,
  54   REPH_POS_AFTER_POST  = POS_AFTER_POST
  55 };
  56 enum reph_mode_t {
  57   REPH_MODE_IMPLICIT,  /* Reph formed out of initial Ra,H sequence. */
  58   REPH_MODE_EXPLICIT,  /* Reph formed out of initial Ra,H,ZWJ sequence. */
  59   REPH_MODE_LOG_REPHA  /* Encoded Repha character, needs reordering. */
  60 };
  61 enum blwf_mode_t {
  62   BLWF_MODE_PRE_AND_POST, /* Below-forms feature applied to pre-base and post-base. */
  63   BLWF_MODE_POST_ONLY     /* Below-forms feature applied to post-base only. */
  64 };
  65 struct indic_config_t
  66 {
  67   hb_script_t     script;
  68   bool            has_old_spec;
  69   hb_codepoint_t  virama;
  70   base_position_t base_pos;
  71   reph_position_t reph_pos;
  72   reph_mode_t     reph_mode;
  73   blwf_mode_t     blwf_mode;
  74 };
  75 
  76 static const indic_config_t indic_configs[] =
  77 {
  78   /* Default.  Should be first. */
  79   {HB_SCRIPT_INVALID,   false,      0,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  80   {HB_SCRIPT_DEVANAGARI,true, 0x094Du,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  81   {HB_SCRIPT_BENGALI,   true, 0x09CDu,BASE_POS_LAST, REPH_POS_AFTER_SUB,  REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  82   {HB_SCRIPT_GURMUKHI,  true, 0x0A4Du,BASE_POS_LAST, REPH_POS_BEFORE_SUB, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  83   {HB_SCRIPT_GUJARATI,  true, 0x0ACDu,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  84   {HB_SCRIPT_ORIYA,     true, 0x0B4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  85   {HB_SCRIPT_TAMIL,     true, 0x0BCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  86   {HB_SCRIPT_TELUGU,    true, 0x0C4Du,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_POST_ONLY},
  87   {HB_SCRIPT_KANNADA,   true, 0x0CCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_POST_ONLY},
  88   {HB_SCRIPT_MALAYALAM, true, 0x0D4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_LOG_REPHA,BLWF_MODE_PRE_AND_POST},
  89   {HB_SCRIPT_SINHALA,   false,0x0DCAu,BASE_POS_LAST_SINHALA,
  90                                                      REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_PRE_AND_POST},
  91 };
  92 
  93 
  94 
  95 /*
  96  * Indic shaper.
  97  */
  98 
  99 static const hb_ot_map_feature_t
 100 indic_features[] =
 101 {
 102   /*
 103    * Basic features.
 104    * These features are applied in order, one at a time, after initial_reordering.
 105    */
 106   {HB_TAG(&#39;n&#39;,&#39;u&#39;,&#39;k&#39;,&#39;t&#39;), F_GLOBAL_MANUAL_JOINERS},
 107   {HB_TAG(&#39;a&#39;,&#39;k&#39;,&#39;h&#39;,&#39;n&#39;), F_GLOBAL_MANUAL_JOINERS},
 108   {HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},
 109   {HB_TAG(&#39;r&#39;,&#39;k&#39;,&#39;r&#39;,&#39;f&#39;), F_GLOBAL_MANUAL_JOINERS},
 110   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},
 111   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},
 112   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},
 113   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},
 114   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},
 115   {HB_TAG(&#39;v&#39;,&#39;a&#39;,&#39;t&#39;,&#39;u&#39;), F_GLOBAL_MANUAL_JOINERS},
 116   {HB_TAG(&#39;c&#39;,&#39;j&#39;,&#39;c&#39;,&#39;t&#39;), F_GLOBAL_MANUAL_JOINERS},
 117   /*
 118    * Other features.
 119    * These features are applied all at once, after final_reordering
 120    * but before clearing syllables.
 121    * Default Bengali font in Windows for example has intermixed
 122    * lookups for init,pres,abvs,blws features.
 123    */
 124   {HB_TAG(&#39;i&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;),        F_MANUAL_JOINERS},
 125   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},
 126   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},
 127   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},
 128   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},
 129   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;n&#39;), F_GLOBAL_MANUAL_JOINERS},
 130   /*
 131    * Positioning features.
 132    * We don&#39;t care about the types.
 133    */
 134   {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
 135   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
 136   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
 137 };
 138 
 139 /*
 140  * Must be in the same order as the indic_features array.
 141  */
 142 enum {
 143   _NUKT,
 144   _AKHN,
 145   RPHF,
 146   _RKRF,
 147   PREF,
 148   BLWF,
 149   ABVF,
 150   HALF,
 151   PSTF,
 152   _VATU,
 153   _CJCT,
 154 
 155   INIT,
 156   _PRES,
 157   _ABVS,
 158   _BLWS,
 159   _PSTS,
 160   _HALN,
 161 
 162   _DIST,
 163   _ABVM,
 164   _BLWM,
 165 
 166   INDIC_NUM_FEATURES,
 167   INDIC_BASIC_FEATURES = INIT, /* Don&#39;t forget to update this! */
 168 };
 169 
 170 static void
 171 setup_syllables (const hb_ot_shape_plan_t *plan,
 172                  hb_font_t *font,
 173                  hb_buffer_t *buffer);
 174 static void
 175 initial_reordering (const hb_ot_shape_plan_t *plan,
 176                     hb_font_t *font,
 177                     hb_buffer_t *buffer);
 178 static void
 179 final_reordering (const hb_ot_shape_plan_t *plan,
 180                   hb_font_t *font,
 181                   hb_buffer_t *buffer);
 182 static void
 183 clear_syllables (const hb_ot_shape_plan_t *plan,
 184                  hb_font_t *font,
 185                  hb_buffer_t *buffer);
 186 
 187 static void
 188 collect_features_indic (hb_ot_shape_planner_t *plan)
 189 {
 190   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 191 
 192   /* Do this before any lookups have been applied. */
 193   map-&gt;add_gsub_pause (setup_syllables);
 194 
 195   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));
 196   /* The Indic specs do not require ccmp, but we apply it here since if
 197    * there is a use of it, it&#39;s typically at the beginning. */
 198   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));
 199 
 200 
 201   unsigned int i = 0;
 202   map-&gt;add_gsub_pause (initial_reordering);
 203 
 204   for (; i &lt; INDIC_BASIC_FEATURES; i++) {
 205     map-&gt;add_feature (indic_features[i]);
 206     map-&gt;add_gsub_pause (nullptr);
 207   }
 208 
 209   map-&gt;add_gsub_pause (final_reordering);
 210 
 211   for (; i &lt; INDIC_NUM_FEATURES; i++)
 212     map-&gt;add_feature (indic_features[i]);
 213 
 214   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));
 215   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));
 216 
 217   map-&gt;add_gsub_pause (clear_syllables);
 218 }
 219 
 220 static void
 221 override_features_indic (hb_ot_shape_planner_t *plan)
 222 {
 223   plan-&gt;map.disable_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;));
 224 }
 225 
 226 
 227 struct would_substitute_feature_t
 228 {
 229   void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)
 230   {
 231     zero_context = zero_context_;
 232     map-&gt;get_stage_lookups (0/*GSUB*/,
 233                             map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
 234                             &amp;lookups, &amp;count);
 235   }
 236 
 237   bool would_substitute (const hb_codepoint_t *glyphs,
 238                          unsigned int          glyphs_count,
 239                          hb_face_t            *face) const
 240   {
 241     for (unsigned int i = 0; i &lt; count; i++)
 242       if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
 243         return true;
 244     return false;
 245   }
 246 
 247   private:
 248   const hb_ot_map_t::lookup_map_t *lookups;
 249   unsigned int count;
 250   bool zero_context;
 251 };
 252 
 253 struct indic_shape_plan_t
 254 {
 255   bool load_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const
 256   {
 257     hb_codepoint_t glyph = virama_glyph.get_relaxed ();
 258     if (unlikely (glyph == (hb_codepoint_t) -1))
 259     {
 260       if (!config-&gt;virama || !font-&gt;get_nominal_glyph (config-&gt;virama, &amp;glyph))
 261         glyph = 0;
 262       /* Technically speaking, the spec says we should apply &#39;locl&#39; to virama too.
 263        * Maybe one day... */
 264 
 265       /* Our get_nominal_glyph() function needs a font, so we can&#39;t get the virama glyph
 266        * during shape planning...  Instead, overwrite it here. */
 267       virama_glyph.set_relaxed ((int) glyph);
 268     }
 269 
 270     *pglyph = glyph;
 271     return glyph != 0;
 272   }
 273 
 274   const indic_config_t *config;
 275 
 276   bool is_old_spec;
 277   bool uniscribe_bug_compatible;
 278   mutable hb_atomic_int_t virama_glyph;
 279 
 280   would_substitute_feature_t rphf;
 281   would_substitute_feature_t pref;
 282   would_substitute_feature_t blwf;
 283   would_substitute_feature_t pstf;
 284 
 285   hb_mask_t mask_array[INDIC_NUM_FEATURES];
 286 };
 287 
 288 static void *
 289 data_create_indic (const hb_ot_shape_plan_t *plan)
 290 {
 291   indic_shape_plan_t *indic_plan = (indic_shape_plan_t *) calloc (1, sizeof (indic_shape_plan_t));
 292   if (unlikely (!indic_plan))
 293     return nullptr;
 294 
 295   indic_plan-&gt;config = &amp;indic_configs[0];
 296   for (unsigned int i = 1; i &lt; ARRAY_LENGTH (indic_configs); i++)
 297     if (plan-&gt;props.script == indic_configs[i].script) {
 298       indic_plan-&gt;config = &amp;indic_configs[i];
 299       break;
 300     }
 301 
 302   indic_plan-&gt;is_old_spec = indic_plan-&gt;config-&gt;has_old_spec &amp;&amp; ((plan-&gt;map.chosen_script[0] &amp; 0x000000FFu) != &#39;2&#39;);
 303   indic_plan-&gt;uniscribe_bug_compatible = hb_options ().uniscribe_bug_compatible;
 304   indic_plan-&gt;virama_glyph.set_relaxed (-1);
 305 
 306   /* Use zero-context would_substitute() matching for new-spec of the main
 307    * Indic scripts, and scripts with one spec only, but not for old-specs.
 308    * The new-spec for all dual-spec scripts says zero-context matching happens.
 309    *
 310    * However, testing with Malayalam shows that old and new spec both allow
 311    * context.  Testing with Bengali new-spec however shows that it doesn&#39;t.
 312    * So, the heuristic here is the way it is.  It should *only* be changed,
 313    * as we discover more cases of what Windows does.  DON&#39;T TOUCH OTHERWISE.
 314    */
 315   bool zero_context = !indic_plan-&gt;is_old_spec &amp;&amp; plan-&gt;props.script != HB_SCRIPT_MALAYALAM;
 316   indic_plan-&gt;rphf.init (&amp;plan-&gt;map, HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;), zero_context);
 317   indic_plan-&gt;pref.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), zero_context);
 318   indic_plan-&gt;blwf.init (&amp;plan-&gt;map, HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), zero_context);
 319   indic_plan-&gt;pstf.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), zero_context);
 320 
 321   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (indic_plan-&gt;mask_array); i++)
 322     indic_plan-&gt;mask_array[i] = (indic_features[i].flags &amp; F_GLOBAL) ?
 323                                  0 : plan-&gt;map.get_1_mask (indic_features[i].tag);
 324 
 325   return indic_plan;
 326 }
 327 
 328 static void
 329 data_destroy_indic (void *data)
 330 {
 331   free (data);
 332 }
 333 
 334 static indic_position_t
 335 consonant_position_from_face (const indic_shape_plan_t *indic_plan,
 336                               const hb_codepoint_t consonant,
 337                               const hb_codepoint_t virama,
 338                               hb_face_t *face)
 339 {
 340   /* For old-spec, the order of glyphs is Consonant,Virama,
 341    * whereas for new-spec, it&#39;s Virama,Consonant.  However,
 342    * some broken fonts (like Free Sans) simply copied lookups
 343    * from old-spec to new-spec without modification.
 344    * And oddly enough, Uniscribe seems to respect those lookups.
 345    * Eg. in the sequence U+0924,U+094D,U+0930, Uniscribe finds
 346    * base at 0.  The font however, only has lookups matching
 347    * 930,94D in &#39;blwf&#39;, not the expected 94D,930 (with new-spec
 348    * table).  As such, we simply match both sequences.  Seems
 349    * to work. */
 350   hb_codepoint_t glyphs[3] = {virama, consonant, virama};
 351   if (indic_plan-&gt;blwf.would_substitute (glyphs  , 2, face) ||
 352       indic_plan-&gt;blwf.would_substitute (glyphs+1, 2, face))
 353     return POS_BELOW_C;
 354   if (indic_plan-&gt;pstf.would_substitute (glyphs  , 2, face) ||
 355       indic_plan-&gt;pstf.would_substitute (glyphs+1, 2, face))
 356     return POS_POST_C;
 357   if (indic_plan-&gt;pref.would_substitute (glyphs  , 2, face) ||
 358       indic_plan-&gt;pref.would_substitute (glyphs+1, 2, face))
 359     return POS_POST_C;
 360   return POS_BASE_C;
 361 }
 362 
 363 
 364 enum syllable_type_t {
 365   consonant_syllable,
 366   vowel_syllable,
 367   standalone_cluster,
 368   symbol_cluster,
 369   broken_cluster,
 370   non_indic_cluster,
 371 };
 372 
 373 #include &quot;hb-ot-shape-complex-indic-machine.hh&quot;
 374 
 375 
 376 static void
 377 setup_masks_indic (const hb_ot_shape_plan_t *plan HB_UNUSED,
 378                    hb_buffer_t              *buffer,
 379                    hb_font_t                *font HB_UNUSED)
 380 {
 381   HB_BUFFER_ALLOCATE_VAR (buffer, indic_category);
 382   HB_BUFFER_ALLOCATE_VAR (buffer, indic_position);
 383 
 384   /* We cannot setup masks here.  We save information about characters
 385    * and setup masks later on in a pause-callback. */
 386 
 387   unsigned int count = buffer-&gt;len;
 388   hb_glyph_info_t *info = buffer-&gt;info;
 389   for (unsigned int i = 0; i &lt; count; i++)
 390     set_indic_properties (info[i]);
 391 }
 392 
 393 static void
 394 setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
 395                  hb_font_t *font HB_UNUSED,
 396                  hb_buffer_t *buffer)
 397 {
 398   find_syllables (buffer);
 399   foreach_syllable (buffer, start, end)
 400     buffer-&gt;unsafe_to_break (start, end);
 401 }
 402 
 403 static int
 404 compare_indic_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
 405 {
 406   int a = pa-&gt;indic_position();
 407   int b = pb-&gt;indic_position();
 408 
 409   return a &lt; b ? -1 : a == b ? 0 : +1;
 410 }
 411 
 412 
 413 
 414 static void
 415 update_consonant_positions (const hb_ot_shape_plan_t *plan,
 416                             hb_font_t         *font,
 417                             hb_buffer_t       *buffer)
 418 {
 419   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
 420 
 421   if (indic_plan-&gt;config-&gt;base_pos != BASE_POS_LAST)
 422     return;
 423 
 424   hb_codepoint_t virama;
 425   if (indic_plan-&gt;load_virama_glyph (font, &amp;virama))
 426   {
 427     hb_face_t *face = font-&gt;face;
 428     unsigned int count = buffer-&gt;len;
 429     hb_glyph_info_t *info = buffer-&gt;info;
 430     for (unsigned int i = 0; i &lt; count; i++)
 431       if (info[i].indic_position() == POS_BASE_C)
 432       {
 433         hb_codepoint_t consonant = info[i].codepoint;
 434         info[i].indic_position() = consonant_position_from_face (indic_plan, consonant, virama, face);
 435       }
 436   }
 437 }
 438 
 439 
 440 /* Rules from:
 441  * https://docs.microsqoft.com/en-us/typography/script-development/devanagari */
 442 
 443 static void
 444 initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,
 445                                        hb_face_t *face,
 446                                        hb_buffer_t *buffer,
 447                                        unsigned int start, unsigned int end)
 448 {
 449   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
 450   hb_glyph_info_t *info = buffer-&gt;info;
 451 
 452   /* https://github.com/harfbuzz/harfbuzz/issues/435#issuecomment-335560167
 453    * // For compatibility with legacy usage in Kannada,
 454    * // Ra+h+ZWJ must behave like Ra+ZWJ+h...
 455    */
 456   if (buffer-&gt;props.script == HB_SCRIPT_KANNADA &amp;&amp;
 457       start + 3 &lt;= end &amp;&amp;
 458       is_one_of (info[start  ], FLAG (OT_Ra)) &amp;&amp;
 459       is_one_of (info[start+1], FLAG (OT_H)) &amp;&amp;
 460       is_one_of (info[start+2], FLAG (OT_ZWJ)))
 461   {
 462     buffer-&gt;merge_clusters (start+1, start+3);
 463     hb_glyph_info_t tmp = info[start+1];
 464     info[start+1] = info[start+2];
 465     info[start+2] = tmp;
 466   }
 467 
 468   /* 1. Find base consonant:
 469    *
 470    * The shaping engine finds the base consonant of the syllable, using the
 471    * following algorithm: starting from the end of the syllable, move backwards
 472    * until a consonant is found that does not have a below-base or post-base
 473    * form (post-base forms have to follow below-base forms), or that is not a
 474    * pre-base-reordering Ra, or arrive at the first consonant. The consonant
 475    * stopped at will be the base.
 476    *
 477    *   o If the syllable starts with Ra + Halant (in a script that has Reph)
 478    *     and has more than one consonant, Ra is excluded from candidates for
 479    *     base consonants.
 480    */
 481 
 482   unsigned int base = end;
 483   bool has_reph = false;
 484 
 485   {
 486     /* -&gt; If the syllable starts with Ra + Halant (in a script that has Reph)
 487      *    and has more than one consonant, Ra is excluded from candidates for
 488      *    base consonants. */
 489     unsigned int limit = start;
 490     if (indic_plan-&gt;mask_array[RPHF] &amp;&amp;
 491         start + 3 &lt;= end &amp;&amp;
 492         (
 493          (indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_IMPLICIT &amp;&amp; !is_joiner (info[start + 2])) ||
 494          (indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_EXPLICIT &amp;&amp; info[start + 2].indic_category() == OT_ZWJ)
 495         ))
 496     {
 497       /* See if it matches the &#39;rphf&#39; feature. */
 498       hb_codepoint_t glyphs[3] = {info[start].codepoint,
 499                                   info[start + 1].codepoint,
 500                                   indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_EXPLICIT ?
 501                                     info[start + 2].codepoint : 0};
 502       if (indic_plan-&gt;rphf.would_substitute (glyphs, 2, face) ||
 503           (indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_EXPLICIT &amp;&amp;
 504            indic_plan-&gt;rphf.would_substitute (glyphs, 3, face)))
 505       {
 506         limit += 2;
 507         while (limit &lt; end &amp;&amp; is_joiner (info[limit]))
 508           limit++;
 509         base = start;
 510         has_reph = true;
 511       }
 512     } else if (indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_LOG_REPHA &amp;&amp; info[start].indic_category() == OT_Repha)
 513     {
 514         limit += 1;
 515         while (limit &lt; end &amp;&amp; is_joiner (info[limit]))
 516           limit++;
 517         base = start;
 518         has_reph = true;
 519     }
 520 
 521     switch (indic_plan-&gt;config-&gt;base_pos)
 522     {
 523       case BASE_POS_LAST:
 524       {
 525         /* -&gt; starting from the end of the syllable, move backwards */
 526         unsigned int i = end;
 527         bool seen_below = false;
 528         do {
 529           i--;
 530           /* -&gt; until a consonant is found */
 531           if (is_consonant (info[i]))
 532           {
 533             /* -&gt; that does not have a below-base or post-base form
 534              * (post-base forms have to follow below-base forms), */
 535             if (info[i].indic_position() != POS_BELOW_C &amp;&amp;
 536                 (info[i].indic_position() != POS_POST_C || seen_below))
 537             {
 538               base = i;
 539               break;
 540             }
 541             if (info[i].indic_position() == POS_BELOW_C)
 542               seen_below = true;
 543 
 544             /* -&gt; or that is not a pre-base-reordering Ra,
 545              *
 546              * IMPLEMENTATION NOTES:
 547              *
 548              * Our pre-base-reordering Ra&#39;s are marked POS_POST_C, so will be skipped
 549              * by the logic above already.
 550              */
 551 
 552             /* -&gt; or arrive at the first consonant. The consonant stopped at will
 553              * be the base. */
 554             base = i;
 555           }
 556           else
 557           {
 558             /* A ZWJ after a Halant stops the base search, and requests an explicit
 559              * half form.
 560              * A ZWJ before a Halant, requests a subjoined form instead, and hence
 561              * search continues.  This is particularly important for Bengali
 562              * sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya. */
 563             if (start &lt; i &amp;&amp;
 564                 info[i].indic_category() == OT_ZWJ &amp;&amp;
 565                 info[i - 1].indic_category() == OT_H)
 566               break;
 567           }
 568         } while (i &gt; limit);
 569       }
 570       break;
 571 
 572       case BASE_POS_LAST_SINHALA:
 573       {
 574         /* Sinhala base positioning is slightly different from main Indic, in that:
 575          * 1. Its ZWJ behavior is different,
 576          * 2. We don&#39;t need to look into the font for consonant positions.
 577          */
 578 
 579         if (!has_reph)
 580           base = limit;
 581 
 582         /* Find the last base consonant that is not blocked by ZWJ.  If there is
 583          * a ZWJ right before a base consonant, that would request a subjoined form. */
 584         for (unsigned int i = limit; i &lt; end; i++)
 585           if (is_consonant (info[i]))
 586           {
 587             if (limit &lt; i &amp;&amp; info[i - 1].indic_category() == OT_ZWJ)
 588               break;
 589             else
 590               base = i;
 591           }
 592 
 593         /* Mark all subsequent consonants as below. */
 594         for (unsigned int i = base + 1; i &lt; end; i++)
 595           if (is_consonant (info[i]))
 596             info[i].indic_position() = POS_BELOW_C;
 597       }
 598       break;
 599     }
 600 
 601     /* -&gt; If the syllable starts with Ra + Halant (in a script that has Reph)
 602      *    and has more than one consonant, Ra is excluded from candidates for
 603      *    base consonants.
 604      *
 605      *  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ. */
 606     if (has_reph &amp;&amp; base == start &amp;&amp; limit - base &lt;= 2) {
 607       /* Have no other consonant, so Reph is not formed and Ra becomes base. */
 608       has_reph = false;
 609     }
 610   }
 611 
 612 
 613   /* 2. Decompose and reorder Matras:
 614    *
 615    * Each matra and any syllable modifier sign in the syllable are moved to the
 616    * appropriate position relative to the consonant(s) in the syllable. The
 617    * shaping engine decomposes two- or three-part matras into their constituent
 618    * parts before any repositioning. Matra characters are classified by which
 619    * consonant in a conjunct they have affinity for and are reordered to the
 620    * following positions:
 621    *
 622    *   o Before first half form in the syllable
 623    *   o After subjoined consonants
 624    *   o After post-form consonant
 625    *   o After main consonant (for above marks)
 626    *
 627    * IMPLEMENTATION NOTES:
 628    *
 629    * The normalize() routine has already decomposed matras for us, so we don&#39;t
 630    * need to worry about that.
 631    */
 632 
 633 
 634   /* 3.  Reorder marks to canonical order:
 635    *
 636    * Adjacent nukta and halant or nukta and vedic sign are always repositioned
 637    * if necessary, so that the nukta is first.
 638    *
 639    * IMPLEMENTATION NOTES:
 640    *
 641    * We don&#39;t need to do this: the normalize() routine already did this for us.
 642    */
 643 
 644 
 645   /* Reorder characters */
 646 
 647   for (unsigned int i = start; i &lt; base; i++)
 648     info[i].indic_position() = MIN (POS_PRE_C, (indic_position_t) info[i].indic_position());
 649 
 650   if (base &lt; end)
 651     info[base].indic_position() = POS_BASE_C;
 652 
 653   /* Mark final consonants.  A final consonant is one appearing after a matra.
 654    * Happens in Sinhala. */
 655   for (unsigned int i = base + 1; i &lt; end; i++)
 656     if (info[i].indic_category() == OT_M) {
 657       for (unsigned int j = i + 1; j &lt; end; j++)
 658         if (is_consonant (info[j])) {
 659          info[j].indic_position() = POS_FINAL_C;
 660          break;
 661        }
 662       break;
 663     }
 664 
 665   /* Handle beginning Ra */
 666   if (has_reph)
 667     info[start].indic_position() = POS_RA_TO_BECOME_REPH;
 668 
 669   /* For old-style Indic script tags, move the first post-base Halant after
 670    * last consonant.
 671    *
 672    * Reports suggest that in some scripts Uniscribe does this only if there
 673    * is *not* a Halant after last consonant already.  We know that is the
 674    * case for Kannada, while it reorders unconditionally in other scripts,
 675    * eg. Malayalam, Bengali, and Devanagari.  We don&#39;t currently know about
 676    * other scripts, so we blacklist Kannada.
 677    *
 678    * Kannada test case:
 679    * U+0C9A,U+0CCD,U+0C9A,U+0CCD
 680    * With some versions of Lohit Kannada.
 681    * https://bugs.freedesktop.org/show_bug.cgi?id=59118
 682    *
 683    * Malayalam test case:
 684    * U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D
 685    * With lohit-ttf-20121122/Lohit-Malayalam.ttf
 686    *
 687    * Bengali test case:
 688    * U+0998,U+09CD,U+09AF,U+09CD
 689    * With Windows XP vrinda.ttf
 690    * https://github.com/harfbuzz/harfbuzz/issues/1073
 691    *
 692    * Devanagari test case:
 693    * U+091F,U+094D,U+0930,U+094D
 694    * With chandas.ttf
 695    * https://github.com/harfbuzz/harfbuzz/issues/1071
 696    */
 697   if (indic_plan-&gt;is_old_spec)
 698   {
 699     bool disallow_double_halants = buffer-&gt;props.script == HB_SCRIPT_KANNADA;
 700     for (unsigned int i = base + 1; i &lt; end; i++)
 701       if (info[i].indic_category() == OT_H)
 702       {
 703         unsigned int j;
 704         for (j = end - 1; j &gt; i; j--)
 705           if (is_consonant (info[j]) ||
 706               (disallow_double_halants &amp;&amp; info[j].indic_category() == OT_H))
 707             break;
 708         if (info[j].indic_category() != OT_H &amp;&amp; j &gt; i) {
 709           /* Move Halant to after last consonant. */
 710           hb_glyph_info_t t = info[i];
 711           memmove (&amp;info[i], &amp;info[i + 1], (j - i) * sizeof (info[0]));
 712           info[j] = t;
 713         }
 714         break;
 715       }
 716   }
 717 
 718   /* Attach misc marks to previous char to move with them. */
 719   {
 720     indic_position_t last_pos = POS_START;
 721     for (unsigned int i = start; i &lt; end; i++)
 722     {
 723       if ((FLAG_UNSAFE (info[i].indic_category()) &amp; (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | FLAG (OT_H))))
 724       {
 725         info[i].indic_position() = last_pos;
 726         if (unlikely (info[i].indic_category() == OT_H &amp;&amp;
 727                       info[i].indic_position() == POS_PRE_M))
 728         {
 729           /*
 730            * Uniscribe doesn&#39;t move the Halant with Left Matra.
 731            * TEST: U+092B,U+093F,U+094DE
 732            * We follow.  This is important for the Sinhala
 733            * U+0DDA split matra since it decomposes to U+0DD9,U+0DCA
 734            * where U+0DD9 is a left matra and U+0DCA is the virama.
 735            * We don&#39;t want to move the virama with the left matra.
 736            * TEST: U+0D9A,U+0DDA
 737            */
 738           for (unsigned int j = i; j &gt; start; j--)
 739             if (info[j - 1].indic_position() != POS_PRE_M) {
 740               info[i].indic_position() = info[j - 1].indic_position();
 741               break;
 742             }
 743         }
 744       } else if (info[i].indic_position() != POS_SMVD) {
 745         last_pos = (indic_position_t) info[i].indic_position();
 746       }
 747     }
 748   }
 749   /* For post-base consonants let them own anything before them
 750    * since the last consonant or matra. */
 751   {
 752     unsigned int last = base;
 753     for (unsigned int i = base + 1; i &lt; end; i++)
 754       if (is_consonant (info[i]))
 755       {
 756         for (unsigned int j = last + 1; j &lt; i; j++)
 757           if (info[j].indic_position() &lt; POS_SMVD)
 758             info[j].indic_position() = info[i].indic_position();
 759         last = i;
 760       } else if (info[i].indic_category() == OT_M)
 761         last = i;
 762   }
 763 
 764 
 765   {
 766     /* Use syllable() for sort accounting temporarily. */
 767     unsigned int syllable = info[start].syllable();
 768     for (unsigned int i = start; i &lt; end; i++)
 769       info[i].syllable() = i - start;
 770 
 771     /* Sit tight, rock &#39;n roll! */
 772     hb_stable_sort (info + start, end - start, compare_indic_order);
 773     /* Find base again */
 774     base = end;
 775     for (unsigned int i = start; i &lt; end; i++)
 776       if (info[i].indic_position() == POS_BASE_C)
 777       {
 778         base = i;
 779         break;
 780       }
 781     /* Things are out-of-control for post base positions, they may shuffle
 782      * around like crazy.  In old-spec mode, we move halants around, so in
 783      * that case merge all clusters after base.  Otherwise, check the sort
 784      * order and merge as needed.
 785      * For pre-base stuff, we handle cluster issues in final reordering.
 786      *
 787      * We could use buffer-&gt;sort() for this, if there was no special
 788      * reordering of pre-base stuff happening later...
 789      * We don&#39;t want to merge_clusters all of that, which buffer-&gt;sort()
 790      * would.
 791      */
 792     if (indic_plan-&gt;is_old_spec || end - start &gt; 127)
 793       buffer-&gt;merge_clusters (base, end);
 794     else
 795     {
 796       /* Note!  syllable() is a one-byte field. */
 797       for (unsigned int i = base; i &lt; end; i++)
 798         if (info[i].syllable() != 255)
 799         {
 800           unsigned int max = i;
 801           unsigned int j = start + info[i].syllable();
 802           while (j != i)
 803           {
 804             max = MAX (max, j);
 805             unsigned int next = start + info[j].syllable();
 806             info[j].syllable() = 255; /* So we don&#39;t process j later again. */
 807             j = next;
 808           }
 809           if (i != max)
 810             buffer-&gt;merge_clusters (i, max + 1);
 811         }
 812     }
 813 
 814     /* Put syllable back in. */
 815     for (unsigned int i = start; i &lt; end; i++)
 816       info[i].syllable() = syllable;
 817   }
 818 
 819   /* Setup masks now */
 820 
 821   {
 822     hb_mask_t mask;
 823 
 824     /* Reph */
 825     for (unsigned int i = start; i &lt; end &amp;&amp; info[i].indic_position() == POS_RA_TO_BECOME_REPH; i++)
 826       info[i].mask |= indic_plan-&gt;mask_array[RPHF];
 827 
 828     /* Pre-base */
 829     mask = indic_plan-&gt;mask_array[HALF];
 830     if (!indic_plan-&gt;is_old_spec &amp;&amp;
 831         indic_plan-&gt;config-&gt;blwf_mode == BLWF_MODE_PRE_AND_POST)
 832       mask |= indic_plan-&gt;mask_array[BLWF];
 833     for (unsigned int i = start; i &lt; base; i++)
 834       info[i].mask  |= mask;
 835     /* Base */
 836     mask = 0;
 837     if (base &lt; end)
 838       info[base].mask |= mask;
 839     /* Post-base */
 840     mask = indic_plan-&gt;mask_array[BLWF] | indic_plan-&gt;mask_array[ABVF] | indic_plan-&gt;mask_array[PSTF];
 841     for (unsigned int i = base + 1; i &lt; end; i++)
 842       info[i].mask  |= mask;
 843   }
 844 
 845   if (indic_plan-&gt;is_old_spec &amp;&amp;
 846       buffer-&gt;props.script == HB_SCRIPT_DEVANAGARI)
 847   {
 848     /* Old-spec eye-lash Ra needs special handling.  From the
 849      * spec:
 850      *
 851      * &quot;The feature &#39;below-base form&#39; is applied to consonants
 852      * having below-base forms and following the base consonant.
 853      * The exception is vattu, which may appear below half forms
 854      * as well as below the base glyph. The feature &#39;below-base
 855      * form&#39; will be applied to all such occurrences of Ra as well.&quot;
 856      *
 857      * Test case: U+0924,U+094D,U+0930,U+094d,U+0915
 858      * with Sanskrit 2003 font.
 859      *
 860      * However, note that Ra,Halant,ZWJ is the correct way to
 861      * request eyelash form of Ra, so we wouldbn&#39;t inhibit it
 862      * in that sequence.
 863      *
 864      * Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915
 865      */
 866     for (unsigned int i = start; i + 1 &lt; base; i++)
 867       if (info[i  ].indic_category() == OT_Ra &amp;&amp;
 868           info[i+1].indic_category() == OT_H  &amp;&amp;
 869           (i + 2 == base ||
 870            info[i+2].indic_category() != OT_ZWJ))
 871       {
 872         info[i  ].mask |= indic_plan-&gt;mask_array[BLWF];
 873         info[i+1].mask |= indic_plan-&gt;mask_array[BLWF];
 874       }
 875   }
 876 
 877   unsigned int pref_len = 2;
 878   if (indic_plan-&gt;mask_array[PREF] &amp;&amp; base + pref_len &lt; end)
 879   {
 880     /* Find a Halant,Ra sequence and mark it for pre-base-reordering processing. */
 881     for (unsigned int i = base + 1; i + pref_len - 1 &lt; end; i++) {
 882       hb_codepoint_t glyphs[2];
 883       for (unsigned int j = 0; j &lt; pref_len; j++)
 884         glyphs[j] = info[i + j].codepoint;
 885       if (indic_plan-&gt;pref.would_substitute (glyphs, pref_len, face))
 886       {
 887         for (unsigned int j = 0; j &lt; pref_len; j++)
 888           info[i++].mask |= indic_plan-&gt;mask_array[PREF];
 889         break;
 890       }
 891     }
 892   }
 893 
 894   /* Apply ZWJ/ZWNJ effects */
 895   for (unsigned int i = start + 1; i &lt; end; i++)
 896     if (is_joiner (info[i])) {
 897       bool non_joiner = info[i].indic_category() == OT_ZWNJ;
 898       unsigned int j = i;
 899 
 900       do {
 901         j--;
 902 
 903         /* ZWJ/ZWNJ should disable CJCT.  They do that by simply
 904          * being there, since we don&#39;t skip them for the CJCT
 905          * feature (ie. F_MANUAL_ZWJ) */
 906 
 907         /* A ZWNJ disables HALF. */
 908         if (non_joiner)
 909           info[j].mask &amp;= ~indic_plan-&gt;mask_array[HALF];
 910 
 911       } while (j &gt; start &amp;&amp; !is_consonant (info[j]));
 912     }
 913 }
 914 
 915 static void
 916 initial_reordering_standalone_cluster (const hb_ot_shape_plan_t *plan,
 917                                        hb_face_t *face,
 918                                        hb_buffer_t *buffer,
 919                                        unsigned int start, unsigned int end)
 920 {
 921   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
 922 
 923   /* We treat placeholder/dotted-circle as if they are consonants, so we
 924    * should just chain.  Only if not in compatibility mode that is... */
 925 
 926   if (indic_plan-&gt;uniscribe_bug_compatible)
 927   {
 928     /* For dotted-circle, this is what Uniscribe does:
 929      * If dotted-circle is the last glyph, it just does nothing.
 930      * Ie. It doesn&#39;t form Reph. */
 931     if (buffer-&gt;info[end - 1].indic_category() == OT_DOTTEDCIRCLE)
 932       return;
 933   }
 934 
 935   initial_reordering_consonant_syllable (plan, face, buffer, start, end);
 936 }
 937 
 938 static void
 939 initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
 940                              hb_face_t *face,
 941                              hb_buffer_t *buffer,
 942                              unsigned int start, unsigned int end)
 943 {
 944   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
 945   switch (syllable_type)
 946   {
 947     case vowel_syllable: /* We made the vowels look like consonants.  So let&#39;s call the consonant logic! */
 948     case consonant_syllable:
 949      initial_reordering_consonant_syllable (plan, face, buffer, start, end);
 950      break;
 951 
 952     case broken_cluster: /* We already inserted dotted-circles, so just call the standalone_cluster. */
 953     case standalone_cluster:
 954      initial_reordering_standalone_cluster (plan, face, buffer, start, end);
 955      break;
 956 
 957     case symbol_cluster:
 958     case non_indic_cluster:
 959       break;
 960   }
 961 }
 962 
 963 static inline void
 964 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
 965                        hb_font_t *font,
 966                        hb_buffer_t *buffer)
 967 {
 968   /* Note: This loop is extra overhead, but should not be measurable.
 969    * TODO Use a buffer scratch flag to remove the loop. */
 970   bool has_broken_syllables = false;
 971   unsigned int count = buffer-&gt;len;
 972   hb_glyph_info_t *info = buffer-&gt;info;
 973   for (unsigned int i = 0; i &lt; count; i++)
 974     if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
 975     {
 976       has_broken_syllables = true;
 977       break;
 978     }
 979   if (likely (!has_broken_syllables))
 980     return;
 981 
 982 
 983   hb_codepoint_t dottedcircle_glyph;
 984   if (!font-&gt;get_nominal_glyph (0x25CCu, &amp;dottedcircle_glyph))
 985     return;
 986 
 987   hb_glyph_info_t dottedcircle = {0};
 988   dottedcircle.codepoint = 0x25CCu;
 989   set_indic_properties (dottedcircle);
 990   dottedcircle.codepoint = dottedcircle_glyph;
 991 
 992   buffer-&gt;clear_output ();
 993 
 994   buffer-&gt;idx = 0;
 995   unsigned int last_syllable = 0;
 996   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
 997   {
 998     unsigned int syllable = buffer-&gt;cur().syllable();
 999     syllable_type_t syllable_type = (syllable_type_t) (syllable &amp; 0x0F);
1000     if (unlikely (last_syllable != syllable &amp;&amp; syllable_type == broken_cluster))
1001     {
1002       last_syllable = syllable;
1003 
1004       hb_glyph_info_t ginfo = dottedcircle;
1005       ginfo.cluster = buffer-&gt;cur().cluster;
1006       ginfo.mask = buffer-&gt;cur().mask;
1007       ginfo.syllable() = buffer-&gt;cur().syllable();
1008       /* TODO Set glyph_props? */
1009 
1010       /* Insert dottedcircle after possible Repha. */
1011       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
1012              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
1013              buffer-&gt;cur().indic_category() == OT_Repha)
1014         buffer-&gt;next_glyph ();
1015 
1016       buffer-&gt;output_info (ginfo);
1017     }
1018     else
1019       buffer-&gt;next_glyph ();
1020   }
1021   buffer-&gt;swap_buffers ();
1022 }
1023 
1024 static void
1025 initial_reordering (const hb_ot_shape_plan_t *plan,
1026                     hb_font_t *font,
1027                     hb_buffer_t *buffer)
1028 {
1029   update_consonant_positions (plan, font, buffer);
1030   insert_dotted_circles (plan, font, buffer);
1031 
1032   foreach_syllable (buffer, start, end)
1033     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
1034 }
1035 
1036 static void
1037 final_reordering_syllable (const hb_ot_shape_plan_t *plan,
1038                            hb_buffer_t *buffer,
1039                            unsigned int start, unsigned int end)
1040 {
1041   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
1042   hb_glyph_info_t *info = buffer-&gt;info;
1043 
1044 
1045   /* This function relies heavily on halant glyphs.  Lots of ligation
1046    * and possibly multiple substitutions happened prior to this
1047    * phase, and that might have messed up our properties.  Recover
1048    * from a particular case of that where we&#39;re fairly sure that a
1049    * class of OT_H is desired but has been lost. */
1050   /* We don&#39;t call load_virama_glyph(), since we know it&#39;s already
1051    * loaded. */
1052   hb_codepoint_t virama_glyph = indic_plan-&gt;virama_glyph.get_relaxed ();
1053   if (virama_glyph)
1054   {
1055     for (unsigned int i = start; i &lt; end; i++)
1056       if (info[i].codepoint == virama_glyph &amp;&amp;
1057           _hb_glyph_info_ligated (&amp;info[i]) &amp;&amp;
1058           _hb_glyph_info_multiplied (&amp;info[i]))
1059       {
1060         /* This will make sure that this glyph passes is_halant() test. */
1061         info[i].indic_category() = OT_H;
1062         _hb_glyph_info_clear_ligated_and_multiplied (&amp;info[i]);
1063       }
1064   }
1065 
1066 
1067   /* 4. Final reordering:
1068    *
1069    * After the localized forms and basic shaping forms GSUB features have been
1070    * applied (see below), the shaping engine performs some final glyph
1071    * reordering before applying all the remaining font features to the entire
1072    * syllable.
1073    */
1074 
1075   bool try_pref = !!indic_plan-&gt;mask_array[PREF];
1076 
1077   /* Find base again */
1078   unsigned int base;
1079   for (base = start; base &lt; end; base++)
1080     if (info[base].indic_position() &gt;= POS_BASE_C)
1081     {
1082       if (try_pref &amp;&amp; base + 1 &lt; end)
1083       {
1084         for (unsigned int i = base + 1; i &lt; end; i++)
1085           if ((info[i].mask &amp; indic_plan-&gt;mask_array[PREF]) != 0)
1086           {
1087             if (!(_hb_glyph_info_substituted (&amp;info[i]) &amp;&amp;
1088                   _hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i])))
1089             {
1090               /* Ok, this was a &#39;pref&#39; candidate but didn&#39;t form any.
1091                * Base is around here... */
1092               base = i;
1093               while (base &lt; end &amp;&amp; is_halant (info[base]))
1094                 base++;
1095               info[base].indic_position() = POS_BASE_C;
1096 
1097               try_pref = false;
1098             }
1099             break;
1100           }
1101       }
1102       /* For Malayalam, skip over unformed below- (but NOT post-) forms. */
1103       if (buffer-&gt;props.script == HB_SCRIPT_MALAYALAM)
1104       {
1105         for (unsigned int i = base + 1; i &lt; end; i++)
1106         {
1107           while (i &lt; end &amp;&amp; is_joiner (info[i]))
1108             i++;
1109           if (i == end || !is_halant (info[i]))
1110             break;
1111           i++; /* Skip halant. */
1112           while (i &lt; end &amp;&amp; is_joiner (info[i]))
1113             i++;
1114           if (i &lt; end &amp;&amp; is_consonant (info[i]) &amp;&amp; info[i].indic_position() == POS_BELOW_C)
1115           {
1116             base = i;
1117             info[base].indic_position() = POS_BASE_C;
1118           }
1119         }
1120       }
1121 
1122       if (start &lt; base &amp;&amp; info[base].indic_position() &gt; POS_BASE_C)
1123         base--;
1124       break;
1125     }
1126   if (base == end &amp;&amp; start &lt; base &amp;&amp;
1127       is_one_of (info[base - 1], FLAG (OT_ZWJ)))
1128     base--;
1129   if (base &lt; end)
1130     while (start &lt; base &amp;&amp;
1131            is_one_of (info[base], (FLAG (OT_N) | FLAG (OT_H))))
1132       base--;
1133 
1134 
1135   /*   o Reorder matras:
1136    *
1137    *     If a pre-base matra character had been reordered before applying basic
1138    *     features, the glyph can be moved closer to the main consonant based on
1139    *     whether half-forms had been formed. Actual position for the matra is
1140    *     defined as âafter last standalone halant glyph, after initial matra
1141    *     position and before the main consonantâ. If ZWJ or ZWNJ follow this
1142    *     halant, position is moved after it.
1143    *
1144    * IMPLEMENTATION NOTES:
1145    *
1146    * It looks like the last sentence is wrong.  Testing, with Windows 7 Uniscribe
1147    * and Devanagari shows that the behavior is best described as:
1148    *
1149    * &quot;If ZWJ follows this halant, matra is NOT repositioned after this halant.
1150    *  If ZWNJ follows this halant, position is moved after it.&quot;
1151    *
1152    * Test case, with Adobe Devanagari or Nirmala UI:
1153    *
1154    *   U+091F,U+094D,U+200C,U+092F,U+093F
1155    *   (Matra moves to the middle, after ZWNJ.)
1156    *
1157    *   U+091F,U+094D,U+200D,U+092F,U+093F
1158    *   (Matra does NOT move, stays to the left.)
1159    *
1160    * https://github.com/harfbuzz/harfbuzz/issues/1070
1161    */
1162 
1163   if (start + 1 &lt; end &amp;&amp; start &lt; base) /* Otherwise there can&#39;t be any pre-base matra characters. */
1164   {
1165     /* If we lost track of base, alas, position before last thingy. */
1166     unsigned int new_pos = base == end ? base - 2 : base - 1;
1167 
1168     /* Malayalam / Tamil do not have &quot;half&quot; forms or explicit virama forms.
1169      * The glyphs formed by &#39;half&#39; are Chillus or ligated explicit viramas.
1170      * We want to position matra after them.
1171      */
1172     if (buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp; buffer-&gt;props.script != HB_SCRIPT_TAMIL)
1173     {
1174     search:
1175       while (new_pos &gt; start &amp;&amp;
1176              !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_H)))))
1177         new_pos--;
1178 
1179       /* If we found no Halant we are done.
1180        * Otherwise only proceed if the Halant does
1181        * not belong to the Matra itself! */
1182       if (is_halant (info[new_pos]) &amp;&amp;
1183           info[new_pos].indic_position() != POS_PRE_M)
1184       {
1185 #if 0 // See comment above
1186         /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */
1187         if (new_pos + 1 &lt; end &amp;&amp; is_joiner (info[new_pos + 1]))
1188           new_pos++;
1189 #endif
1190         if (new_pos + 1 &lt; end)
1191         {
1192           /* -&gt; If ZWJ follows this halant, matra is NOT repositioned after this halant. */
1193           if (info[new_pos + 1].indic_category() == OT_ZWJ)
1194           {
1195             /* Keep searching. */
1196             if (new_pos &gt; start)
1197             {
1198               new_pos--;
1199               goto search;
1200             }
1201           }
1202           /* -&gt; If ZWNJ follows this halant, position is moved after it. */
1203           if (info[new_pos + 1].indic_category() == OT_ZWNJ)
1204             new_pos++;
1205         }
1206       }
1207       else
1208         new_pos = start; /* No move. */
1209     }
1210 
1211     if (start &lt; new_pos &amp;&amp; info[new_pos].indic_position () != POS_PRE_M)
1212     {
1213       /* Now go see if there&#39;s actually any matras... */
1214       for (unsigned int i = new_pos; i &gt; start; i--)
1215         if (info[i - 1].indic_position () == POS_PRE_M)
1216         {
1217           unsigned int old_pos = i - 1;
1218           if (old_pos &lt; base &amp;&amp; base &lt;= new_pos) /* Shouldn&#39;t actually happen. */
1219             base--;
1220 
1221           hb_glyph_info_t tmp = info[old_pos];
1222           memmove (&amp;info[old_pos], &amp;info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));
1223           info[new_pos] = tmp;
1224 
1225           /* Note: this merge_clusters() is intentionally *after* the reordering.
1226            * Indic matra reordering is special and tricky... */
1227           buffer-&gt;merge_clusters (new_pos, MIN (end, base + 1));
1228 
1229           new_pos--;
1230         }
1231     } else {
1232       for (unsigned int i = start; i &lt; base; i++)
1233         if (info[i].indic_position () == POS_PRE_M) {
1234           buffer-&gt;merge_clusters (i, MIN (end, base + 1));
1235           break;
1236         }
1237     }
1238   }
1239 
1240 
1241   /*   o Reorder reph:
1242    *
1243    *     Rephâs original position is always at the beginning of the syllable,
1244    *     (i.e. it is not reordered at the character reordering stage). However,
1245    *     it will be reordered according to the basic-forms shaping results.
1246    *     Possible positions for reph, depending on the script, are; after main,
1247    *     before post-base consonant forms, and after post-base consonant forms.
1248    */
1249 
1250   /* Two cases:
1251    *
1252    * - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then
1253    *   we should only move it if the sequence ligated to the repha form.
1254    *
1255    * - If repha is encoded separately and in the logical position, we should only
1256    *   move it if it did NOT ligate.  If it ligated, it&#39;s probably the font trying
1257    *   to make it work without the reordering.
1258    */
1259   if (start + 1 &lt; end &amp;&amp;
1260       info[start].indic_position() == POS_RA_TO_BECOME_REPH &amp;&amp;
1261       ((info[start].indic_category() == OT_Repha) ^
1262        _hb_glyph_info_ligated_and_didnt_multiply (&amp;info[start])))
1263   {
1264     unsigned int new_reph_pos;
1265     reph_position_t reph_pos = indic_plan-&gt;config-&gt;reph_pos;
1266 
1267     /*       1. If reph should be positioned after post-base consonant forms,
1268      *          proceed to step 5.
1269      */
1270     if (reph_pos == REPH_POS_AFTER_POST)
1271     {
1272       goto reph_step_5;
1273     }
1274 
1275     /*       2. If the reph repositioning class is not after post-base: target
1276      *          position is after the first explicit halant glyph between the
1277      *          first post-reph consonant and last main consonant. If ZWJ or ZWNJ
1278      *          are following this halant, position is moved after it. If such
1279      *          position is found, this is the target position. Otherwise,
1280      *          proceed to the next step.
1281      *
1282      *          Note: in old-implementation fonts, where classifications were
1283      *          fixed in shaping engine, there was no case where reph position
1284      *          will be found on this step.
1285      */
1286     {
1287       new_reph_pos = start + 1;
1288       while (new_reph_pos &lt; base &amp;&amp; !is_halant (info[new_reph_pos]))
1289         new_reph_pos++;
1290 
1291       if (new_reph_pos &lt; base &amp;&amp; is_halant (info[new_reph_pos]))
1292       {
1293         /* -&gt;If ZWJ or ZWNJ are following this halant, position is moved after it. */
1294         if (new_reph_pos + 1 &lt; base &amp;&amp; is_joiner (info[new_reph_pos + 1]))
1295           new_reph_pos++;
1296         goto reph_move;
1297       }
1298     }
1299 
1300     /*       3. If reph should be repositioned after the main consonant: find the
1301      *          first consonant not ligated with main, or find the first
1302      *          consonant that is not a potential pre-base-reordering Ra.
1303      */
1304     if (reph_pos == REPH_POS_AFTER_MAIN)
1305     {
1306       new_reph_pos = base;
1307       while (new_reph_pos + 1 &lt; end &amp;&amp; info[new_reph_pos + 1].indic_position() &lt;= POS_AFTER_MAIN)
1308         new_reph_pos++;
1309       if (new_reph_pos &lt; end)
1310         goto reph_move;
1311     }
1312 
1313     /*       4. If reph should be positioned before post-base consonant, find
1314      *          first post-base classified consonant not ligated with main. If no
1315      *          consonant is found, the target position should be before the
1316      *          first matra, syllable modifier sign or vedic sign.
1317      */
1318     /* This is our take on what step 4 is trying to say (and failing, BADLY). */
1319     if (reph_pos == REPH_POS_AFTER_SUB)
1320     {
1321       new_reph_pos = base;
1322       while (new_reph_pos + 1 &lt; end &amp;&amp;
1323              !( FLAG_UNSAFE (info[new_reph_pos + 1].indic_position()) &amp; (FLAG (POS_POST_C) | FLAG (POS_AFTER_POST) | FLAG (POS_SMVD))))
1324         new_reph_pos++;
1325       if (new_reph_pos &lt; end)
1326         goto reph_move;
1327     }
1328 
1329     /*       5. If no consonant is found in steps 3 or 4, move reph to a position
1330      *          immediately before the first post-base matra, syllable modifier
1331      *          sign or vedic sign that has a reordering class after the intended
1332      *          reph position. For example, if the reordering position for reph
1333      *          is post-main, it will skip above-base matras that also have a
1334      *          post-main position.
1335      */
1336     reph_step_5:
1337     {
1338       /* Copied from step 2. */
1339       new_reph_pos = start + 1;
1340       while (new_reph_pos &lt; base &amp;&amp; !is_halant (info[new_reph_pos]))
1341         new_reph_pos++;
1342 
1343       if (new_reph_pos &lt; base &amp;&amp; is_halant (info[new_reph_pos]))
1344       {
1345         /* -&gt;If ZWJ or ZWNJ are following this halant, position is moved after it. */
1346         if (new_reph_pos + 1 &lt; base &amp;&amp; is_joiner (info[new_reph_pos + 1]))
1347           new_reph_pos++;
1348         goto reph_move;
1349       }
1350     }
1351 
1352     /*       6. Otherwise, reorder reph to the end of the syllable.
1353      */
1354     {
1355       new_reph_pos = end - 1;
1356       while (new_reph_pos &gt; start &amp;&amp; info[new_reph_pos].indic_position() == POS_SMVD)
1357         new_reph_pos--;
1358 
1359       /*
1360        * If the Reph is to be ending up after a Matra,Halant sequence,
1361        * position it before that Halant so it can interact with the Matra.
1362        * However, if it&#39;s a plain Consonant,Halant we shouldn&#39;t do that.
1363        * Uniscribe doesn&#39;t do this.
1364        * TEST: U+0930,U+094D,U+0915,U+094B,U+094D
1365        */
1366       if (!indic_plan-&gt;uniscribe_bug_compatible &amp;&amp;
1367           unlikely (is_halant (info[new_reph_pos]))) {
1368         for (unsigned int i = base + 1; i &lt; new_reph_pos; i++)
1369           if (info[i].indic_category() == OT_M) {
1370             /* Ok, got it. */
1371             new_reph_pos--;
1372           }
1373       }
1374       goto reph_move;
1375     }
1376 
1377     reph_move:
1378     {
1379       /* Move */
1380       buffer-&gt;merge_clusters (start, new_reph_pos + 1);
1381       hb_glyph_info_t reph = info[start];
1382       memmove (&amp;info[start], &amp;info[start + 1], (new_reph_pos - start) * sizeof (info[0]));
1383       info[new_reph_pos] = reph;
1384 
1385       if (start &lt; base &amp;&amp; base &lt;= new_reph_pos)
1386         base--;
1387     }
1388   }
1389 
1390 
1391   /*   o Reorder pre-base-reordering consonants:
1392    *
1393    *     If a pre-base-reordering consonant is found, reorder it according to
1394    *     the following rules:
1395    */
1396 
1397   if (try_pref &amp;&amp; base + 1 &lt; end) /* Otherwise there can&#39;t be any pre-base-reordering Ra. */
1398   {
1399     for (unsigned int i = base + 1; i &lt; end; i++)
1400       if ((info[i].mask &amp; indic_plan-&gt;mask_array[PREF]) != 0)
1401       {
1402         /*       1. Only reorder a glyph produced by substitution during application
1403          *          of the &lt;pref&gt; feature. (Note that a font may shape a Ra consonant with
1404          *          the feature generally but block it in certain contexts.)
1405          */
1406         /* Note: We just check that something got substituted.  We don&#39;t check that
1407          * the &lt;pref&gt; feature actually did it...
1408          *
1409          * Reorder pref only if it ligated. */
1410         if (_hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i]))
1411         {
1412           /*
1413            *       2. Try to find a target position the same way as for pre-base matra.
1414            *          If it is found, reorder pre-base consonant glyph.
1415            *
1416            *       3. If position is not found, reorder immediately before main
1417            *          consonant.
1418            */
1419 
1420           unsigned int new_pos = base;
1421           /* Malayalam / Tamil do not have &quot;half&quot; forms or explicit virama forms.
1422            * The glyphs formed by &#39;half&#39; are Chillus or ligated explicit viramas.
1423            * We want to position matra after them.
1424            */
1425           if (buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp; buffer-&gt;props.script != HB_SCRIPT_TAMIL)
1426           {
1427             while (new_pos &gt; start &amp;&amp;
1428                    !(is_one_of (info[new_pos - 1], FLAG(OT_M) | FLAG (OT_H))))
1429               new_pos--;
1430           }
1431 
1432           if (new_pos &gt; start &amp;&amp; is_halant (info[new_pos - 1]))
1433           {
1434             /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */
1435             if (new_pos &lt; end &amp;&amp; is_joiner (info[new_pos]))
1436               new_pos++;
1437           }
1438 
1439           {
1440             unsigned int old_pos = i;
1441 
1442             buffer-&gt;merge_clusters (new_pos, old_pos + 1);
1443             hb_glyph_info_t tmp = info[old_pos];
1444             memmove (&amp;info[new_pos + 1], &amp;info[new_pos], (old_pos - new_pos) * sizeof (info[0]));
1445             info[new_pos] = tmp;
1446 
1447             if (new_pos &lt;= base &amp;&amp; base &lt; old_pos)
1448               base++;
1449           }
1450         }
1451 
1452         break;
1453       }
1454   }
1455 
1456 
1457   /* Apply &#39;init&#39; to the Left Matra if it&#39;s a word start. */
1458   if (info[start].indic_position () == POS_PRE_M)
1459   {
1460     if (!start ||
1461         !(FLAG_UNSAFE (_hb_glyph_info_get_general_category (&amp;info[start - 1])) &amp;
1462          FLAG_RANGE (HB_UNICODE_GENERAL_CATEGORY_FORMAT, HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))
1463       info[start].mask |= indic_plan-&gt;mask_array[INIT];
1464     else
1465       buffer-&gt;unsafe_to_break (start - 1, start + 1);
1466   }
1467 
1468 
1469   /*
1470    * Finish off the clusters and go home!
1471    */
1472   if (indic_plan-&gt;uniscribe_bug_compatible)
1473   {
1474     switch ((hb_tag_t) plan-&gt;props.script)
1475     {
1476       case HB_SCRIPT_TAMIL:
1477       case HB_SCRIPT_SINHALA:
1478         break;
1479 
1480       default:
1481         /* Uniscribe merges the entire syllable into a single cluster... Except for Tamil &amp; Sinhala.
1482          * This means, half forms are submerged into the main consonant&#39;s cluster.
1483          * This is unnecessary, and makes cursor positioning harder, but that&#39;s what
1484          * Uniscribe does. */
1485         buffer-&gt;merge_clusters (start, end);
1486         break;
1487     }
1488   }
1489 }
1490 
1491 
1492 static void
1493 final_reordering (const hb_ot_shape_plan_t *plan,
1494                   hb_font_t *font HB_UNUSED,
1495                   hb_buffer_t *buffer)
1496 {
1497   unsigned int count = buffer-&gt;len;
1498   if (unlikely (!count)) return;
1499 
1500   foreach_syllable (buffer, start, end)
1501     final_reordering_syllable (plan, buffer, start, end);
1502 
1503   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_category);
1504   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_position);
1505 }
1506 
1507 
1508 static void
1509 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
1510                  hb_font_t *font HB_UNUSED,
1511                  hb_buffer_t *buffer)
1512 {
1513   hb_glyph_info_t *info = buffer-&gt;info;
1514   unsigned int count = buffer-&gt;len;
1515   for (unsigned int i = 0; i &lt; count; i++)
1516     info[i].syllable() = 0;
1517 }
1518 
1519 
1520 static void
1521 preprocess_text_indic (const hb_ot_shape_plan_t *plan,
1522                        hb_buffer_t              *buffer,
1523                        hb_font_t                *font)
1524 {
1525   _hb_preprocess_text_vowel_constraints (plan, buffer, font);
1526 }
1527 
1528 static bool
1529 decompose_indic (const hb_ot_shape_normalize_context_t *c,
1530                  hb_codepoint_t  ab,
1531                  hb_codepoint_t *a,
1532                  hb_codepoint_t *b)
1533 {
1534   switch (ab)
1535   {
1536     /* Don&#39;t decompose these. */
1537     case 0x0931u  : return false; /* DEVANAGARI LETTER RRA */
1538     // https://github.com/harfbuzz/harfbuzz/issues/779
1539     case 0x09DCu  : return false; /* BENGALI LETTER RRA */
1540     case 0x09DDu  : return false; /* BENGALI LETTER RHA */
1541     case 0x0B94u  : return false; /* TAMIL LETTER AU */
1542 
1543 
1544     /*
1545      * Decompose split matras that don&#39;t have Unicode decompositions.
1546      */
1547 
1548 #if 0
1549     /* Gujarati */
1550     /* This one has no decomposition in Unicode, but needs no decomposition either. */
1551     /* case 0x0AC9u  : return false; */
1552 
1553     /* Oriya */
1554     case 0x0B57u  : *a = no decomp, -&gt; RIGHT; return true;
1555 #endif
1556   }
1557 
1558   if ((ab == 0x0DDAu || hb_in_range&lt;hb_codepoint_t&gt; (ab, 0x0DDCu, 0x0DDEu)))
1559   {
1560     /*
1561      * Sinhala split matras...  Let the fun begin.
1562      *
1563      * These four characters have Unicode decompositions.  However, Uniscribe
1564      * decomposes them &quot;Khmer-style&quot;, that is, it uses the character itself to
1565      * get the second half.  The first half of all four decompositions is always
1566      * U+0DD9.
1567      *
1568      * Now, there are buggy fonts, namely, the widely used lklug.ttf, that are
1569      * broken with Uniscribe.  But we need to support them.  As such, we only
1570      * do the Uniscribe-style decomposition if the character is transformed into
1571      * its &quot;sec.half&quot; form by the &#39;pstf&#39; feature.  Otherwise, we fall back to
1572      * Unicode decomposition.
1573      *
1574      * Note that we can&#39;t unconditionally use Unicode decomposition.  That would
1575      * break some other fonts, that are designed to work with Uniscribe, and
1576      * don&#39;t have positioning features for the Unicode-style decomposition.
1577      *
1578      * Argh...
1579      *
1580      * The Uniscribe behavior is now documented in the newly published Sinhala
1581      * spec in 2012:
1582      *
1583      *   https://docs.microsoft.com/en-us/typography/script-development/sinhala#shaping
1584      */
1585 
1586     const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) c-&gt;plan-&gt;data;
1587 
1588     hb_codepoint_t glyph;
1589 
1590     if (hb_options ().uniscribe_bug_compatible ||
1591         (c-&gt;font-&gt;get_nominal_glyph (ab, &amp;glyph) &amp;&amp;
1592          indic_plan-&gt;pstf.would_substitute (&amp;glyph, 1, c-&gt;font-&gt;face)))
1593     {
1594       /* Ok, safe to use Uniscribe-style decomposition. */
1595       *a = 0x0DD9u;
1596       *b = ab;
1597       return true;
1598     }
1599   }
1600 
1601   return (bool) c-&gt;unicode-&gt;decompose (ab, a, b);
1602 }
1603 
1604 static bool
1605 compose_indic (const hb_ot_shape_normalize_context_t *c,
1606                hb_codepoint_t  a,
1607                hb_codepoint_t  b,
1608                hb_codepoint_t *ab)
1609 {
1610   /* Avoid recomposing split matras. */
1611   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
1612     return false;
1613 
1614   /* Composition-exclusion exceptions that we want to recompose. */
1615   if (a == 0x09AFu &amp;&amp; b == 0x09BCu) { *ab = 0x09DFu; return true; }
1616 
1617   return (bool) c-&gt;unicode-&gt;compose (a, b, ab);
1618 }
1619 
1620 
1621 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_indic =
1622 {
1623   collect_features_indic,
1624   override_features_indic,
1625   data_create_indic,
1626   data_destroy_indic,
1627   preprocess_text_indic,
1628   nullptr, /* postprocess_glyphs */
1629   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
1630   decompose_indic,
1631   compose_indic,
1632   setup_masks_indic,
1633   HB_TAG_NONE, /* gpos_tag */
1634   nullptr, /* reorder_marks */
1635   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
1636   false, /* fallback_position */
1637 };
<a name="1" id="anc1"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="1" type="hidden" />
</body>
</html>