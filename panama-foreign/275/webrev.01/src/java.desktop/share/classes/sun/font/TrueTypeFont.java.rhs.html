<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/sun/font/TrueTypeFont.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.font;
  27 
  28 import java.awt.Font;
  29 import java.awt.FontFormatException;
  30 import java.awt.GraphicsEnvironment;
  31 import java.awt.geom.Point2D;
  32 import java.io.FileNotFoundException;
  33 import java.io.IOException;
  34 import java.io.RandomAccessFile;
  35 import java.io.UnsupportedEncodingException;
  36 import java.nio.ByteBuffer;
  37 import java.nio.CharBuffer;
  38 import java.nio.IntBuffer;
  39 import java.nio.ShortBuffer;
  40 import java.nio.channels.ClosedChannelException;
  41 import java.nio.channels.FileChannel;
  42 import java.security.AccessController;
  43 import java.security.PrivilegedActionException;
  44 import java.security.PrivilegedExceptionAction;
  45 import java.util.HashMap;
  46 import java.util.HashSet;
  47 import java.util.Locale;
  48 import java.util.Map;
  49 
  50 import sun.java2d.Disposer;
  51 import sun.java2d.DisposerRecord;
  52 import sun.security.action.GetPropertyAction;
  53 
  54 /**
  55  * TrueTypeFont is not called SFntFont because it is not expected
  56  * to handle all types that may be housed in a such a font file.
  57  * If additional types are supported later, it may make sense to
  58  * create an SFnt superclass. Eg to handle sfnt-housed postscript fonts.
  59  * OpenType fonts are handled by this class, and possibly should be
  60  * represented by a subclass.
  61  * An instance stores some information from the font file to faciliate
  62  * faster access. File size, the table directory and the names of the font
  63  * are the most important of these. It amounts to approx 400 bytes
  64  * for a typical font. Systems with mutiple locales sometimes have up to 400
  65  * font files, and an app which loads all font files would need around
  66  * 160Kbytes. So storing any more info than this would be expensive.
  67  */
  68 public class TrueTypeFont extends FileFont {
  69 
  70    /* -- Tags for required TrueType tables */
  71     public static final int cmapTag = 0x636D6170; // &#39;cmap&#39;
  72     public static final int glyfTag = 0x676C7966; // &#39;glyf&#39;
  73     public static final int headTag = 0x68656164; // &#39;head&#39;
  74     public static final int hheaTag = 0x68686561; // &#39;hhea&#39;
  75     public static final int hmtxTag = 0x686D7478; // &#39;hmtx&#39;
  76     public static final int locaTag = 0x6C6F6361; // &#39;loca&#39;
  77     public static final int maxpTag = 0x6D617870; // &#39;maxp&#39;
  78     public static final int nameTag = 0x6E616D65; // &#39;name&#39;
  79     public static final int postTag = 0x706F7374; // &#39;post&#39;
  80     public static final int os_2Tag = 0x4F532F32; // &#39;OS/2&#39;
  81 
  82     /* -- Tags for opentype related tables */
  83     public static final int GDEFTag = 0x47444546; // &#39;GDEF&#39;
  84     public static final int GPOSTag = 0x47504F53; // &#39;GPOS&#39;
  85     public static final int GSUBTag = 0x47535542; // &#39;GSUB&#39;
  86     public static final int mortTag = 0x6D6F7274; // &#39;mort&#39;
  87     public static final int morxTag = 0x6D6F7278; // &#39;morx&#39;
  88 
  89     /* -- Tags for non-standard tables */
  90     public static final int fdscTag = 0x66647363; // &#39;fdsc&#39; - gxFont descriptor
  91     public static final int fvarTag = 0x66766172; // &#39;fvar&#39; - gxFont variations
  92     public static final int featTag = 0x66656174; // &#39;feat&#39; - layout features
  93     public static final int EBLCTag = 0x45424C43; // &#39;EBLC&#39; - embedded bitmaps
  94     public static final int gaspTag = 0x67617370; // &#39;gasp&#39; - hint/smooth sizes
  95 
  96     /* --  Other tags */
  97     public static final int ttcfTag = 0x74746366; // &#39;ttcf&#39; - TTC file
  98     public static final int v1ttTag = 0x00010000; // &#39;v1tt&#39; - Version 1 TT font
  99     public static final int trueTag = 0x74727565; // &#39;true&#39; - Version 2 TT font
 100     public static final int ottoTag = 0x4f54544f; // &#39;otto&#39; - OpenType font
 101 
 102     /* -- ID&#39;s used in the &#39;name&#39; table */
 103     public static final int MAC_PLATFORM_ID = 1;
 104     public static final int MACROMAN_SPECIFIC_ID = 0;
 105     public static final int MACROMAN_ENGLISH_LANG = 0;
 106 
 107     public static final int MS_PLATFORM_ID = 3;
 108     /* MS locale id for US English is the &quot;default&quot; */
 109     public static final short ENGLISH_LOCALE_ID = 0x0409; // 1033 decimal
 110     public static final int FAMILY_NAME_ID = 1;
 111     // public static final int STYLE_WEIGHT_ID = 2; // currently unused.
 112     public static final int FULL_NAME_ID = 4;
 113     public static final int POSTSCRIPT_NAME_ID = 6;
 114 
 115     private static final short US_LCID = 0x0409;  // US English - default
 116 
 117     private static Map&lt;String, Short&gt; lcidMap;
 118 
 119     static class DirectoryEntry {
 120         int tag;
 121         int offset;
 122         int length;
 123     }
 124 
 125     /* There is a pool which limits the number of fd&#39;s that are in
 126      * use. Normally fd&#39;s are closed as they are replaced in the pool.
 127      * But if an instance of this class becomes unreferenced, then there
 128      * needs to be a way to close the fd. A finalize() method could do this,
 129      * but using the Disposer class will ensure its called in a more timely
 130      * manner. This is not something which should be relied upon to free
 131      * fd&#39;s - its a safeguard.
 132      */
 133     private static class TTDisposerRecord implements DisposerRecord {
 134 
 135         FileChannel channel = null;
 136 
 137         public synchronized void dispose() {
 138             try {
 139                 if (channel != null) {
 140                     channel.close();
 141                 }
 142             } catch (IOException e) {
 143             } finally {
 144                 channel = null;
 145             }
 146         }
 147     }
 148 
 149     TTDisposerRecord disposerRecord = new TTDisposerRecord();
 150 
 151     /* &gt; 0 only if this font is a part of a collection */
 152     int fontIndex = 0;
 153 
 154     /* Number of fonts in this collection. ==1 if not a collection */
 155     int directoryCount = 1;
 156 
 157     /* offset in file of table directory for this font */
 158     int directoryOffset; // 12 if its not a collection.
 159 
 160     /* number of table entries in the directory/offsets table */
 161     int numTables;
 162 
 163     /* The contents of the directory/offsets table */
 164     DirectoryEntry []tableDirectory;
 165 
 166 //     protected byte []gposTable = null;
 167 //     protected byte []gdefTable = null;
 168 //     protected byte []gsubTable = null;
 169 //     protected byte []mortTable = null;
 170 //     protected boolean hintsTabledChecked = false;
 171 //     protected boolean containsHintsTable = false;
 172 
 173     /* These fields are set from os/2 table info. */
 174     private boolean supportsJA;
 175     private boolean supportsCJK;
 176 
 177     /* These are for faster access to the name of the font as
 178      * typically exposed via API to applications.
 179      */
 180     private Locale nameLocale;
 181     private String localeFamilyName;
 182     private String localeFullName;
 183 
 184     /*
 185      * Used on Windows to validate the font selected by GDI for (sub-pixel
 186      * antialiased) rendering. For &#39;standalone&#39; fonts it&#39;s equal to the font
 187      * file size, for collection (TTC, OTC) members it&#39;s the number of bytes in
 188      * the collection file from the start of this font&#39;s offset table till the
 189      * end of the file.
 190      */
 191     int fontDataSize;
 192 
 193     public TrueTypeFont(String platname, Object nativeNames, int fIndex,
 194                  boolean javaRasterizer)
 195         throws FontFormatException
 196     {
 197         this(platname, nativeNames, fIndex, javaRasterizer, true);
 198     }
 199 
 200     /**
 201      * - does basic verification of the file
 202      * - reads the header table for this font (within a collection)
 203      * - reads the names (full, family).
 204      * - determines the style of the font.
 205      * - initializes the CMAP
 206      * @throws FontFormatException if the font can&#39;t be opened
 207      * or fails verification,  or there&#39;s no usable cmap
 208      */
 209     public TrueTypeFont(String platname, Object nativeNames, int fIndex,
 210                  boolean javaRasterizer, boolean useFilePool)
 211         throws FontFormatException {
 212         super(platname, nativeNames);
 213         useJavaRasterizer = javaRasterizer;
 214         fontRank = Font2D.TTF_RANK;
 215         try {
 216             verify(useFilePool);
 217             init(fIndex);
 218             if (!useFilePool) {
 219                close();
 220             }
 221         } catch (Throwable t) {
 222             close();
 223             if (t instanceof FontFormatException) {
 224                 throw (FontFormatException)t;
 225             } else {
 226                 throw new FontFormatException(&quot;Unexpected runtime exception.&quot;);
 227             }
 228         }
 229         Disposer.addObjectRecord(this, disposerRecord);
 230     }
 231 
 232     private synchronized FileChannel open() throws FontFormatException {
 233         return open(true);
 234     }
 235 
 236     /* This is intended to be called, and the returned value used,
 237      * from within a block synchronized on this font object.
 238      * ie the channel returned may be nulled out at any time by &quot;close()&quot;
 239      * unless the caller holds a lock.
 240      * Deadlock warning: FontManager.addToPool(..) acquires a global lock,
 241      * which means nested locks may be in effect.
 242      */
 243     private synchronized FileChannel open(boolean usePool)
 244                                      throws FontFormatException {
 245         if (disposerRecord.channel == null) {
 246             if (FontUtilities.isLogging()) {
<a name="1" id="anc1"></a><span class="line-modified"> 247                 FontUtilities.logInfo(&quot;open TTF: &quot; + platName);</span>
 248             }
 249             try {
 250                 RandomAccessFile raf = AccessController.doPrivileged(
 251                     new PrivilegedExceptionAction&lt;RandomAccessFile&gt;() {
 252                         public RandomAccessFile run() throws FileNotFoundException {
 253                             return new RandomAccessFile(platName, &quot;r&quot;);
 254                     }
 255                 });
 256                 disposerRecord.channel = raf.getChannel();
 257                 fileSize = (int)disposerRecord.channel.size();
 258                 if (usePool) {
 259                     FontManager fm = FontManagerFactory.getInstance();
 260                     if (fm instanceof SunFontManager) {
 261                         ((SunFontManager) fm).addToPool(this);
 262                     }
 263                 }
 264             } catch (PrivilegedActionException e) {
 265                 close();
 266                 Throwable reason = e.getCause();
 267                 if (reason == null) {
 268                     reason = e;
 269                 }
 270                 throw new FontFormatException(reason.toString());
 271             } catch (ClosedChannelException e) {
 272                 /* NIO I/O is interruptible, recurse to retry operation.
 273                  * The call to channel.size() above can throw this exception.
 274                  * Clear interrupts before recursing in case NIO didn&#39;t.
 275                  * Note that close() sets disposerRecord.channel to null.
 276                  */
 277                 Thread.interrupted();
 278                 close();
 279                 open();
 280             } catch (IOException e) {
 281                 close();
 282                 throw new FontFormatException(e.toString());
 283             }
 284         }
 285         return disposerRecord.channel;
 286     }
 287 
 288     protected synchronized void close() {
 289         disposerRecord.dispose();
 290     }
 291 
 292 
 293     int readBlock(ByteBuffer buffer, int offset, int length) {
 294         int bread = 0;
 295         try {
 296             synchronized (this) {
 297                 if (disposerRecord.channel == null) {
 298                     open();
 299                 }
 300                 if (offset + length &gt; fileSize) {
 301                     if (offset &gt;= fileSize) {
 302                         /* Since the caller ensures that offset is &lt; fileSize
 303                          * this condition suggests that fileSize is now
 304                          * different than the value we originally provided
 305                          * to native when the scaler was created.
 306                          * Also fileSize is updated every time we
 307                          * open() the file here, but in native the value
 308                          * isn&#39;t updated. If the file has changed whilst we
 309                          * are executing we want to bail, not spin.
 310                          */
 311                         if (FontUtilities.isLogging()) {
 312                             String msg = &quot;Read offset is &quot; + offset +
<a name="2" id="anc2"></a><span class="line-modified"> 313                                     &quot; file size is &quot; + fileSize+</span>
<span class="line-modified"> 314                                     &quot; file is &quot; + platName;</span>
<span class="line-modified"> 315                             FontUtilities.logSevere(msg);</span>
 316                         }
 317                         return -1;
 318                     } else {
 319                         length = fileSize - offset;
 320                     }
 321                 }
 322                 buffer.clear();
 323                 disposerRecord.channel.position(offset);
 324                 while (bread &lt; length) {
 325                     int cnt = disposerRecord.channel.read(buffer);
 326                     if (cnt == -1) {
 327                         String msg = &quot;Unexpected EOF &quot; + this;
 328                         int currSize = (int)disposerRecord.channel.size();
 329                         if (currSize != fileSize) {
 330                             msg += &quot; File size was &quot; + fileSize +
 331                                 &quot; and now is &quot; + currSize;
 332                         }
 333                         if (FontUtilities.isLogging()) {
<a name="3" id="anc3"></a><span class="line-modified"> 334                             FontUtilities.logSevere(msg);</span>
 335                         }
 336                         // We could still flip() the buffer here because
 337                         // it&#39;s possible that we did read some data in
 338                         // an earlier loop, and we probably should
 339                         // return that to the caller. Although if
 340                         // the caller expected 8K of data and we return
 341                         // only a few bytes then maybe it&#39;s better instead to
 342                         // set bread = -1 to indicate failure.
 343                         // The following is therefore using arbitrary values
 344                         // but is meant to allow cases where enough
 345                         // data was read to probably continue.
 346                         if (bread &gt; length/2 || bread &gt; 16384) {
 347                             buffer.flip();
 348                             if (FontUtilities.isLogging()) {
<a name="4" id="anc4"></a><span class="line-modified"> 349                                 msg = &quot;Returning &quot; + bread + &quot; bytes instead of &quot; + length;</span>
<span class="line-modified"> 350                                 FontUtilities.logSevere(msg);</span>

 351                             }
 352                         } else {
 353                             bread = -1;
 354                         }
 355                         throw new IOException(msg);
 356                     }
 357                     bread += cnt;
 358                 }
 359                 buffer.flip();
 360                 if (bread &gt; length) { // possible if buffer.size() &gt; length
 361                     bread = length;
 362                 }
 363             }
 364         } catch (FontFormatException e) {
 365             if (FontUtilities.isLogging()) {
<a name="5" id="anc5"></a><span class="line-modified"> 366                 FontUtilities.getLogger().severe(&quot;While reading &quot; + platName, e);</span>

 367             }
 368             bread = -1; // signal EOF
 369             deregisterFontAndClearStrikeCache();
 370         } catch (ClosedChannelException e) {
 371             /* NIO I/O is interruptible, recurse to retry operation.
 372              * Clear interrupts before recursing in case NIO didn&#39;t.
 373              */
 374             Thread.interrupted();
 375             close();
 376             return readBlock(buffer, offset, length);
 377         } catch (IOException e) {
 378             /* If we did not read any bytes at all and the exception is
 379              * not a recoverable one (ie is not ClosedChannelException) then
 380              * we should indicate that there is no point in re-trying.
 381              * Other than an attempt to read past the end of the file it
 382              * seems unlikely this would occur as problems opening the
 383              * file are handled as a FontFormatException.
 384              */
 385             if (FontUtilities.isLogging()) {
<a name="6" id="anc6"></a><span class="line-modified"> 386                 FontUtilities.getLogger().severe(&quot;While reading &quot; + platName, e);</span>

 387             }
 388             if (bread == 0) {
 389                 bread = -1; // signal EOF
 390                 deregisterFontAndClearStrikeCache();
 391             }
 392         }
 393         return bread;
 394     }
 395 
 396     ByteBuffer readBlock(int offset, int length) {
 397 
 398         ByteBuffer buffer = ByteBuffer.allocate(length);
 399         try {
 400             synchronized (this) {
 401                 if (disposerRecord.channel == null) {
 402                     open();
 403                 }
 404                 if (offset + length &gt; fileSize) {
 405                     if (offset &gt; fileSize) {
 406                         return null; // assert?
 407                     } else {
 408                         buffer = ByteBuffer.allocate(fileSize-offset);
 409                     }
 410                 }
 411                 disposerRecord.channel.position(offset);
 412                 disposerRecord.channel.read(buffer);
 413                 buffer.flip();
 414             }
 415         } catch (FontFormatException e) {
 416             return null;
 417         } catch (ClosedChannelException e) {
 418             /* NIO I/O is interruptible, recurse to retry operation.
 419              * Clear interrupts before recursing in case NIO didn&#39;t.
 420              */
 421             Thread.interrupted();
 422             close();
 423             readBlock(buffer, offset, length);
 424         } catch (IOException e) {
 425             return null;
 426         }
 427         return buffer;
 428     }
 429 
 430     /* This is used by native code which can&#39;t allocate a direct byte
 431      * buffer because of bug 4845371. It, and references to it in native
 432      * code in scalerMethods.c can be removed once that bug is fixed.
 433      * 4845371 is now fixed but we&#39;ll keep this around as it doesn&#39;t cost
 434      * us anything if its never used/called.
 435      */
 436     byte[] readBytes(int offset, int length) {
 437         ByteBuffer buffer = readBlock(offset, length);
 438         if (buffer.hasArray()) {
 439             return buffer.array();
 440         } else {
 441             byte[] bufferBytes = new byte[buffer.limit()];
 442             buffer.get(bufferBytes);
 443             return bufferBytes;
 444         }
 445     }
 446 
 447     private void verify(boolean usePool) throws FontFormatException {
 448         open(usePool);
 449     }
 450 
 451     /* sizes, in bytes, of TT/TTC header records */
 452     private static final int TTCHEADERSIZE = 12;
 453     private static final int DIRECTORYHEADERSIZE = 12;
 454     private static final int DIRECTORYENTRYSIZE = 16;
 455 
 456     protected void init(int fIndex) throws FontFormatException  {
 457         int headerOffset = 0;
 458         ByteBuffer buffer = readBlock(0, TTCHEADERSIZE);
 459         try {
 460             switch (buffer.getInt()) {
 461 
 462             case ttcfTag:
 463                 buffer.getInt(); // skip TTC version ID
 464                 directoryCount = buffer.getInt();
 465                 if (fIndex &gt;= directoryCount) {
 466                     throw new FontFormatException(&quot;Bad collection index&quot;);
 467                 }
 468                 fontIndex = fIndex;
 469                 buffer = readBlock(TTCHEADERSIZE+4*fIndex, 4);
 470                 headerOffset = buffer.getInt();
 471                 fontDataSize = Math.max(0, fileSize - headerOffset);
 472                 break;
 473 
 474             case v1ttTag:
 475             case trueTag:
 476             case ottoTag:
 477                 fontDataSize = fileSize;
 478                 break;
 479 
 480             default:
 481                 throw new FontFormatException(&quot;Unsupported sfnt &quot; +
 482                                               getPublicFileName());
 483             }
 484 
 485             /* Now have the offset of this TT font (possibly within a TTC)
 486              * After the TT version/scaler type field, is the short
 487              * representing the number of tables in the table directory.
 488              * The table directory begins at 12 bytes after the header.
 489              * Each table entry is 16 bytes long (4 32-bit ints)
 490              */
 491             buffer = readBlock(headerOffset+4, 2);
 492             numTables = buffer.getShort();
 493             directoryOffset = headerOffset+DIRECTORYHEADERSIZE;
 494             ByteBuffer bbuffer = readBlock(directoryOffset,
 495                                            numTables*DIRECTORYENTRYSIZE);
 496             IntBuffer ibuffer = bbuffer.asIntBuffer();
 497             DirectoryEntry table;
 498             tableDirectory = new DirectoryEntry[numTables];
 499             for (int i=0; i&lt;numTables;i++) {
 500                 tableDirectory[i] = table = new DirectoryEntry();
 501                 table.tag   =  ibuffer.get();
 502                 /* checksum */ ibuffer.get();
 503                 table.offset = ibuffer.get() &amp; 0x7FFFFFFF;
 504                 table.length = ibuffer.get() &amp; 0x7FFFFFFF;
 505                 if (table.offset + table.length &gt; fileSize) {
 506                     throw new FontFormatException(&quot;bad table, tag=&quot;+table.tag);
 507                 }
 508             }
 509 
 510             if (getDirectoryEntry(headTag) == null) {
 511                 throw new FontFormatException(&quot;missing head table&quot;);
 512             }
 513             if (getDirectoryEntry(maxpTag) == null) {
 514                 throw new FontFormatException(&quot;missing maxp table&quot;);
 515             }
 516             if (getDirectoryEntry(hmtxTag) != null
 517                     &amp;&amp; getDirectoryEntry(hheaTag) == null) {
 518                 throw new FontFormatException(&quot;missing hhea table&quot;);
 519             }
 520             initNames();
 521         } catch (Exception e) {
 522             if (FontUtilities.isLogging()) {
<a name="7" id="anc7"></a><span class="line-modified"> 523                 FontUtilities.logSevere(e.toString());</span>
 524             }
 525             if (e instanceof FontFormatException) {
 526                 throw (FontFormatException)e;
 527             } else {
 528                 throw new FontFormatException(e.toString());
 529             }
 530         }
 531         if (familyName == null || fullName == null) {
 532             throw new FontFormatException(&quot;Font name not found&quot;);
 533         }
 534         /* The os2_Table is needed to gather some info, but we don&#39;t
 535          * want to keep it around (as a field) so obtain it once and
 536          * pass it to the code that needs it.
 537          */
 538         ByteBuffer os2_Table = getTableBuffer(os_2Tag);
 539         setStyle(os2_Table);
 540         setCJKSupport(os2_Table);
 541     }
 542 
 543     /* The array index corresponds to a bit offset in the TrueType
 544      * font&#39;s OS/2 compatibility table&#39;s code page ranges fields.
 545      * These are two 32 bit unsigned int fields at offsets 78 and 82.
 546      * We are only interested in determining if the font supports
 547      * the windows encodings we expect as the default encoding in
 548      * supported locales, so we only map the first of these fields.
 549      */
 550     static final String[] encoding_mapping = {
 551         &quot;cp1252&quot;,    /*  0:Latin 1  */
 552         &quot;cp1250&quot;,    /*  1:Latin 2  */
 553         &quot;cp1251&quot;,    /*  2:Cyrillic */
 554         &quot;cp1253&quot;,    /*  3:Greek    */
 555         &quot;cp1254&quot;,    /*  4:Turkish/Latin 5  */
 556         &quot;cp1255&quot;,    /*  5:Hebrew   */
 557         &quot;cp1256&quot;,    /*  6:Arabic   */
 558         &quot;cp1257&quot;,    /*  7:Windows Baltic   */
 559         &quot;&quot;,          /*  8:reserved for alternate ANSI */
 560         &quot;&quot;,          /*  9:reserved for alternate ANSI */
 561         &quot;&quot;,          /* 10:reserved for alternate ANSI */
 562         &quot;&quot;,          /* 11:reserved for alternate ANSI */
 563         &quot;&quot;,          /* 12:reserved for alternate ANSI */
 564         &quot;&quot;,          /* 13:reserved for alternate ANSI */
 565         &quot;&quot;,          /* 14:reserved for alternate ANSI */
 566         &quot;&quot;,          /* 15:reserved for alternate ANSI */
 567         &quot;ms874&quot;,     /* 16:Thai     */
 568         &quot;ms932&quot;,     /* 17:JIS/Japanese */
 569         &quot;gbk&quot;,       /* 18:PRC GBK Cp950  */
 570         &quot;ms949&quot;,     /* 19:Korean Extended Wansung */
 571         &quot;ms950&quot;,     /* 20:Chinese (Taiwan, Hongkong, Macau) */
 572         &quot;ms1361&quot;,    /* 21:Korean Johab */
 573         &quot;&quot;,          /* 22 */
 574         &quot;&quot;,          /* 23 */
 575         &quot;&quot;,          /* 24 */
 576         &quot;&quot;,          /* 25 */
 577         &quot;&quot;,          /* 26 */
 578         &quot;&quot;,          /* 27 */
 579         &quot;&quot;,          /* 28 */
 580         &quot;&quot;,          /* 29 */
 581         &quot;&quot;,          /* 30 */
 582         &quot;&quot;,          /* 31 */
 583     };
 584 
 585     /* This maps two letter language codes to a Windows code page.
 586      * Note that eg Cp1252 (the first subarray) is not exactly the same as
 587      * Latin-1 since Windows code pages are do not necessarily correspond.
 588      * There are two codepages for zh and ko so if a font supports
 589      * only one of these ranges then we need to distinguish based on
 590      * country. So far this only seems to matter for zh.
 591      * REMIND: Unicode locales such as Hindi do not have a code page so
 592      * this whole mechanism needs to be revised to map languages to
 593      * the Unicode ranges either when this fails, or as an additional
 594      * validating test. Basing it on Unicode ranges should get us away
 595      * from needing to map to this small and incomplete set of Windows
 596      * code pages which looks odd on non-Windows platforms.
 597      */
 598     private static final String[][] languages = {
 599 
 600         /* cp1252/Latin 1 */
 601         { &quot;en&quot;, &quot;ca&quot;, &quot;da&quot;, &quot;de&quot;, &quot;es&quot;, &quot;fi&quot;, &quot;fr&quot;, &quot;is&quot;, &quot;it&quot;,
 602           &quot;nl&quot;, &quot;no&quot;, &quot;pt&quot;, &quot;sq&quot;, &quot;sv&quot;, },
 603 
 604          /* cp1250/Latin2 */
 605         { &quot;cs&quot;, &quot;cz&quot;, &quot;et&quot;, &quot;hr&quot;, &quot;hu&quot;, &quot;nr&quot;, &quot;pl&quot;, &quot;ro&quot;, &quot;sk&quot;,
 606           &quot;sl&quot;, &quot;sq&quot;, &quot;sr&quot;, },
 607 
 608         /* cp1251/Cyrillic */
 609         { &quot;bg&quot;, &quot;mk&quot;, &quot;ru&quot;, &quot;sh&quot;, &quot;uk&quot; },
 610 
 611         /* cp1253/Greek*/
 612         { &quot;el&quot; },
 613 
 614          /* cp1254/Turkish,Latin 5 */
 615         { &quot;tr&quot; },
 616 
 617          /* cp1255/Hebrew */
 618         { &quot;he&quot; },
 619 
 620         /* cp1256/Arabic */
 621         { &quot;ar&quot; },
 622 
 623          /* cp1257/Windows Baltic */
 624         { &quot;et&quot;, &quot;lt&quot;, &quot;lv&quot; },
 625 
 626         /* ms874/Thai */
 627         { &quot;th&quot; },
 628 
 629          /* ms932/Japanese */
 630         { &quot;ja&quot; },
 631 
 632         /* gbk/Chinese (PRC GBK Cp950) */
 633         { &quot;zh&quot;, &quot;zh_CN&quot;, },
 634 
 635         /* ms949/Korean Extended Wansung */
 636         { &quot;ko&quot; },
 637 
 638         /* ms950/Chinese (Taiwan, Hongkong, Macau) */
 639         { &quot;zh_HK&quot;, &quot;zh_TW&quot;, },
 640 
 641         /* ms1361/Korean Johab */
 642         { &quot;ko&quot; },
 643     };
 644 
 645     private static final String[] codePages = {
 646         &quot;cp1252&quot;,
 647         &quot;cp1250&quot;,
 648         &quot;cp1251&quot;,
 649         &quot;cp1253&quot;,
 650         &quot;cp1254&quot;,
 651         &quot;cp1255&quot;,
 652         &quot;cp1256&quot;,
 653         &quot;cp1257&quot;,
 654         &quot;ms874&quot;,
 655         &quot;ms932&quot;,
 656         &quot;gbk&quot;,
 657         &quot;ms949&quot;,
 658         &quot;ms950&quot;,
 659         &quot;ms1361&quot;,
 660     };
 661 
 662     private static String defaultCodePage = null;
 663     static String getCodePage() {
 664 
 665         if (defaultCodePage != null) {
 666             return defaultCodePage;
 667         }
 668 
 669         if (FontUtilities.isWindows) {
 670             defaultCodePage =
 671                 AccessController.doPrivileged(new GetPropertyAction(&quot;file.encoding&quot;));
 672         } else {
 673             if (languages.length != codePages.length) {
 674                 throw new InternalError(&quot;wrong code pages array length&quot;);
 675             }
 676             Locale locale = sun.awt.SunToolkit.getStartupLocale();
 677 
 678             String language = locale.getLanguage();
 679             if (language != null) {
 680                 if (language.equals(&quot;zh&quot;)) {
 681                     String country = locale.getCountry();
 682                     if (country != null) {
 683                         language = language + &quot;_&quot; + country;
 684                     }
 685                 }
 686                 for (int i=0; i&lt;languages.length;i++) {
 687                     for (int l=0;l&lt;languages[i].length; l++) {
 688                         if (language.equals(languages[i][l])) {
 689                             defaultCodePage = codePages[i];
 690                             return defaultCodePage;
 691                         }
 692                     }
 693                 }
 694             }
 695         }
 696         if (defaultCodePage == null) {
 697             defaultCodePage = &quot;&quot;;
 698         }
 699         return defaultCodePage;
 700     }
 701 
 702     /* Theoretically, reserved bits must not be set, include symbol bits */
 703     public static final int reserved_bits1 = 0x80000000;
 704     public static final int reserved_bits2 = 0x0000ffff;
 705     @Override
 706     boolean supportsEncoding(String encoding) {
 707         if (encoding == null) {
 708             encoding = getCodePage();
 709         }
 710         if (&quot;&quot;.equals(encoding)) {
 711             return false;
 712         }
 713 
 714         encoding = encoding.toLowerCase();
 715 
 716         /* java_props_md.c has a couple of special cases
 717          * if language packs are installed. In these encodings the
 718          * fontconfig files pick up different fonts :
 719          * SimSun-18030 and MingLiU_HKSCS. Since these fonts will
 720          * indicate they support the base encoding, we need to rewrite
 721          * these encodings here before checking the map/array.
 722          */
 723         if (encoding.equals(&quot;gb18030&quot;)) {
 724             encoding = &quot;gbk&quot;;
 725         } else if (encoding.equals(&quot;ms950_hkscs&quot;)) {
 726             encoding = &quot;ms950&quot;;
 727         }
 728 
 729         ByteBuffer buffer = getTableBuffer(os_2Tag);
 730         /* required info is at offsets 78 and 82 */
 731         if (buffer == null || buffer.capacity() &lt; 86) {
 732             return false;
 733         }
 734 
 735         int range1 = buffer.getInt(78); /* ulCodePageRange1 */
 736         // int range2 = buffer.getInt(82); /* ulCodePageRange2 */
 737 
 738         /* This test is too stringent for Arial on Solaris (and perhaps
 739          * other fonts). Arial has at least one reserved bit set for an
 740          * unknown reason.
 741          */
 742         // if (((range1 &amp; reserved_bits1) | (range2 &amp; reserved_bits2)) != 0) {
 743         //     return false;
 744         // }
 745 
 746         for (int em=0; em&lt;encoding_mapping.length; em++) {
 747             if (encoding_mapping[em].equals(encoding)) {
 748                 if (((1 &lt;&lt; em) &amp; range1) != 0) {
 749                     return true;
 750                 }
 751             }
 752         }
 753         return false;
 754     }
 755 
 756 
 757     /* Use info in the os_2Table to test CJK support */
 758     private void setCJKSupport(ByteBuffer os2Table) {
 759         /* required info is in ulong at offset 46 */
 760         if (os2Table == null || os2Table.capacity() &lt; 50) {
 761             return;
 762         }
 763         int range2 = os2Table.getInt(46); /* ulUnicodeRange2 */
 764 
 765         /* Any of these bits set in the 32-63 range indicate a font with
 766          * support for a CJK range. We aren&#39;t looking at some other bits
 767          * in the 64-69 range such as half width forms as its unlikely a font
 768          * would include those and none of these.
 769          */
 770         supportsCJK = ((range2 &amp; 0x29bf0000) != 0);
 771 
 772         /* This should be generalised, but for now just need to know if
 773          * Hiragana or Katakana ranges are supported by the font.
 774          * In the 4 longs representing unicode ranges supported
 775          * bits 49 &amp; 50 indicate hiragana and katakana
 776          * This is bits 17 &amp; 18 in the 2nd ulong. If either is supported
 777          * we presume this is a JA font.
 778          */
 779         supportsJA = ((range2 &amp; 0x60000) != 0);
 780     }
 781 
 782     boolean supportsJA() {
 783         return supportsJA;
 784     }
 785 
 786      ByteBuffer getTableBuffer(int tag) {
 787         DirectoryEntry entry = null;
 788 
 789         for (int i=0;i&lt;numTables;i++) {
 790             if (tableDirectory[i].tag == tag) {
 791                 entry = tableDirectory[i];
 792                 break;
 793             }
 794         }
 795         if (entry == null || entry.length == 0 ||
 796             entry.offset+entry.length &gt; fileSize) {
 797             return null;
 798         }
 799 
 800         int bread = 0;
 801         ByteBuffer buffer = ByteBuffer.allocate(entry.length);
 802         synchronized (this) {
 803             try {
 804                 if (disposerRecord.channel == null) {
 805                     open();
 806                 }
 807                 disposerRecord.channel.position(entry.offset);
 808                 bread = disposerRecord.channel.read(buffer);
 809                 buffer.flip();
 810             } catch (ClosedChannelException e) {
 811                 /* NIO I/O is interruptible, recurse to retry operation.
 812                  * Clear interrupts before recursing in case NIO didn&#39;t.
 813                  */
 814                 Thread.interrupted();
 815                 close();
 816                 return getTableBuffer(tag);
 817             } catch (IOException e) {
 818                 return null;
 819             } catch (FontFormatException e) {
 820                 return null;
 821             }
 822 
 823             if (bread &lt; entry.length) {
 824                 return null;
 825             } else {
 826                 return buffer;
 827             }
 828         }
 829     }
 830 
 831     @Override
 832     protected byte[] getTableBytes(int tag) {
 833         ByteBuffer buffer = getTableBuffer(tag);
 834         if (buffer == null) {
 835             return null;
 836         } else if (buffer.hasArray()) {
 837             try {
 838                 return buffer.array();
 839             } catch (Exception re) {
 840             }
 841         }
 842         byte []data = new byte[getTableSize(tag)];
 843         buffer.get(data);
 844         return data;
 845     }
 846 
 847     int getTableSize(int tag) {
 848         for (int i=0;i&lt;numTables;i++) {
 849             if (tableDirectory[i].tag == tag) {
 850                 return tableDirectory[i].length;
 851             }
 852         }
 853         return 0;
 854     }
 855 
 856     int getTableOffset(int tag) {
 857         for (int i=0;i&lt;numTables;i++) {
 858             if (tableDirectory[i].tag == tag) {
 859                 return tableDirectory[i].offset;
 860             }
 861         }
 862         return 0;
 863     }
 864 
 865     DirectoryEntry getDirectoryEntry(int tag) {
 866         for (int i=0;i&lt;numTables;i++) {
 867             if (tableDirectory[i].tag == tag) {
 868                 return tableDirectory[i];
 869             }
 870         }
 871         return null;
 872     }
 873 
 874     /* Used to determine if this size has embedded bitmaps, which
 875      * for CJK fonts should be used in preference to LCD glyphs.
 876      */
 877     boolean useEmbeddedBitmapsForSize(int ptSize) {
 878         if (!supportsCJK) {
 879             return false;
 880         }
 881         if (getDirectoryEntry(EBLCTag) == null) {
 882             return false;
 883         }
 884         ByteBuffer eblcTable = getTableBuffer(EBLCTag);
 885         int numSizes = eblcTable.getInt(4);
 886         /* The bitmapSizeTable&#39;s start at offset of 8.
 887          * Each bitmapSizeTable entry is 48 bytes.
 888          * The offset of ppemY in the entry is 45.
 889          */
 890         for (int i=0;i&lt;numSizes;i++) {
 891             int ppemY = eblcTable.get(8+(i*48)+45) &amp;0xff;
 892             if (ppemY == ptSize) {
 893                 return true;
 894             }
 895         }
 896         return false;
 897     }
 898 
 899     public String getFullName() {
 900         return fullName;
 901     }
 902 
 903     /* This probably won&#39;t get called but is there to support the
 904      * contract() of setStyle() defined in the superclass.
 905      */
 906     @Override
 907     protected void setStyle() {
 908         setStyle(getTableBuffer(os_2Tag));
 909     }
 910 
 911     private int fontWidth = 0;
 912     @Override
 913     public int getWidth() {
 914        return (fontWidth &gt; 0) ? fontWidth : super.getWidth();
 915     }
 916 
 917     private int fontWeight = 0;
 918     @Override
 919     public int getWeight() {
 920        return (fontWeight &gt; 0) ? fontWeight : super.getWeight();
 921     }
 922 
 923     /* TrueTypeFont can use the fsSelection fields of OS/2 table
 924      * to determine the style. In the unlikely case that doesn&#39;t exist,
 925      * can use macStyle in the &#39;head&#39; table but simpler to
 926      * fall back to super class algorithm of looking for well known string.
 927      * A very few fonts don&#39;t specify this information, but I only
 928      * came across one: Lucida Sans Thai Typewriter Oblique in
 929      * /usr/openwin/lib/locale/th_TH/X11/fonts/TrueType/lucidai.ttf
 930      * that explicitly specified the wrong value. It says its regular.
 931      * I didn&#39;t find any fonts that were inconsistent (ie regular plus some
 932      * other value).
 933      */
 934     private static final int fsSelectionItalicBit  = 0x00001;
 935     private static final int fsSelectionBoldBit    = 0x00020;
 936     private static final int fsSelectionRegularBit = 0x00040;
 937     private void setStyle(ByteBuffer os_2Table) {
 938         if (os_2Table == null) {
 939             return;
 940         }
 941         if (os_2Table.capacity() &gt;= 8) {
 942             fontWeight = os_2Table.getChar(4) &amp; 0xffff;
 943             fontWidth  = os_2Table.getChar(6) &amp; 0xffff;
 944         }
 945         /* fsSelection is unsigned short at buffer offset 62 */
 946         if (os_2Table.capacity() &lt; 64) {
 947             super.setStyle();
 948             return;
 949         }
 950         int fsSelection = os_2Table.getChar(62) &amp; 0xffff;
 951         int italic  = fsSelection &amp; fsSelectionItalicBit;
 952         int bold    = fsSelection &amp; fsSelectionBoldBit;
 953         int regular = fsSelection &amp; fsSelectionRegularBit;
 954 //      System.out.println(&quot;platname=&quot;+platName+&quot; font=&quot;+fullName+
 955 //                         &quot; family=&quot;+familyName+
 956 //                         &quot; R=&quot;+regular+&quot; I=&quot;+italic+&quot; B=&quot;+bold);
 957         if (regular!=0 &amp;&amp; ((italic|bold)!=0)) {
 958             /* This is inconsistent. Try using the font name algorithm */
 959             super.setStyle();
 960             return;
 961         } else if ((regular|italic|bold) == 0) {
 962             /* No style specified. Try using the font name algorithm */
 963             super.setStyle();
 964             return;
 965         }
 966         switch (bold|italic) {
 967         case fsSelectionItalicBit:
 968             style = Font.ITALIC;
 969             break;
 970         case fsSelectionBoldBit:
 971             style = Font.BOLD;
 972             break;
 973         case fsSelectionBoldBit|fsSelectionItalicBit:
 974             style = Font.BOLD|Font.ITALIC;
 975         }
 976     }
 977 
 978     private float stSize, stPos, ulSize, ulPos;
 979 
 980     private void setStrikethroughMetrics(ByteBuffer os_2Table, int upem) {
 981         if (os_2Table == null || os_2Table.capacity() &lt; 30 || upem &lt; 0) {
 982             stSize = .05f;
 983             stPos = -.4f;
 984             return;
 985         }
 986         ShortBuffer sb = os_2Table.asShortBuffer();
 987         stSize = sb.get(13) / (float)upem;
 988         stPos = -sb.get(14) / (float)upem;
 989     }
 990 
 991     private void setUnderlineMetrics(ByteBuffer postTable, int upem) {
 992         if (postTable == null || postTable.capacity() &lt; 12 || upem &lt; 0) {
 993             ulSize = .05f;
 994             ulPos = .1f;
 995             return;
 996         }
 997         ShortBuffer sb = postTable.asShortBuffer();
 998         ulSize = sb.get(5) / (float)upem;
 999         ulPos = -sb.get(4) / (float)upem;
1000     }
1001 
1002     @Override
1003     public void getStyleMetrics(float pointSize, float[] metrics, int offset) {
1004 
1005         if (ulSize == 0f &amp;&amp; ulPos == 0f) {
1006 
1007             ByteBuffer head_Table = getTableBuffer(headTag);
1008             int upem = -1;
1009             if (head_Table != null &amp;&amp; head_Table.capacity() &gt;= 18) {
1010                 ShortBuffer sb = head_Table.asShortBuffer();
1011                 upem = sb.get(9) &amp; 0xffff;
1012                 if (upem &lt; 16 || upem &gt; 16384) {
1013                     upem = 2048;
1014                 }
1015             }
1016 
1017             ByteBuffer os2_Table = getTableBuffer(os_2Tag);
1018             setStrikethroughMetrics(os2_Table, upem);
1019 
1020             ByteBuffer post_Table = getTableBuffer(postTag);
1021             setUnderlineMetrics(post_Table, upem);
1022         }
1023 
1024         metrics[offset] = stPos * pointSize;
1025         metrics[offset+1] = stSize * pointSize;
1026 
1027         metrics[offset+2] = ulPos * pointSize;
1028         metrics[offset+3] = ulSize * pointSize;
1029     }
1030 
1031     private String makeString(byte[] bytes, int len,
1032                              short platformID, short encoding) {
1033 
1034         if (platformID == MAC_PLATFORM_ID) {
1035             encoding = -1; // hack so we can re-use the code below.
1036         }
1037 
1038         /* Check for fonts using encodings 2-&gt;6 is just for
1039          * some old DBCS fonts, apparently mostly on Solaris.
1040          * Some of these fonts encode ascii names as double-byte characters.
1041          * ie with a leading zero byte for what properly should be a
1042          * single byte-char.
1043          */
1044         if (encoding &gt;=2 &amp;&amp; encoding &lt;= 6) {
1045              byte[] oldbytes = bytes;
1046              int oldlen = len;
1047              bytes = new byte[oldlen];
1048              len = 0;
1049              for (int i=0; i&lt;oldlen; i++) {
1050                  if (oldbytes[i] != 0) {
1051                      bytes[len++] = oldbytes[i];
1052                  }
1053              }
1054          }
1055 
1056         String charset;
1057         switch (encoding) {
1058             case -1: charset = &quot;US-ASCII&quot;;break;
1059             case 1:  charset = &quot;UTF-16&quot;;  break; // most common case first.
1060             case 0:  charset = &quot;UTF-16&quot;;  break; // symbol uses this
1061             case 2:  charset = &quot;SJIS&quot;;    break;
1062             case 3:  charset = &quot;GBK&quot;;     break;
1063             case 4:  charset = &quot;MS950&quot;;   break;
1064             case 5:  charset = &quot;EUC_KR&quot;;  break;
1065             case 6:  charset = &quot;Johab&quot;;   break;
1066             default: charset = &quot;UTF-16&quot;;  break;
1067         }
1068 
1069         try {
1070             return new String(bytes, 0, len, charset);
1071         } catch (UnsupportedEncodingException e) {
1072             if (FontUtilities.isLogging()) {
<a name="8" id="anc8"></a><span class="line-modified">1073                 FontUtilities.logWarning(e + &quot; EncodingID=&quot; + encoding);</span>
1074             }
1075             return new String(bytes, 0, len);
1076         } catch (Throwable t) {
1077             return null;
1078         }
1079     }
1080 
1081     protected void initNames() {
1082 
1083         byte[] name = new byte[256];
1084         ByteBuffer buffer = getTableBuffer(nameTag);
1085 
1086         if (buffer != null) {
1087             ShortBuffer sbuffer = buffer.asShortBuffer();
1088             sbuffer.get(); // format - not needed.
1089             short numRecords = sbuffer.get();
1090             /* The name table uses unsigned shorts. Many of these
1091              * are known small values that fit in a short.
1092              * The values that are sizes or offsets into the table could be
1093              * greater than 32767, so read and store those as ints
1094              */
1095             int stringPtr = sbuffer.get() &amp; 0xffff;
1096 
1097             nameLocale = sun.awt.SunToolkit.getStartupLocale();
1098             short nameLocaleID = getLCIDFromLocale(nameLocale);
1099             languageCompatibleLCIDs =
1100                 getLanguageCompatibleLCIDsFromLocale(nameLocale);
1101 
1102             for (int i=0; i&lt;numRecords; i++) {
1103                 short platformID = sbuffer.get();
1104                 if (platformID != MS_PLATFORM_ID &amp;&amp;
1105                     platformID != MAC_PLATFORM_ID) {
1106                     sbuffer.position(sbuffer.position()+5);
1107                     continue; // skip over this record.
1108                 }
1109                 short encodingID = sbuffer.get();
1110                 short langID     = sbuffer.get();
1111                 short nameID     = sbuffer.get();
1112                 int nameLen    = ((int) sbuffer.get()) &amp; 0xffff;
1113                 int namePtr    = (((int) sbuffer.get()) &amp; 0xffff) + stringPtr;
1114                 String tmpName = null;
1115 
1116                 // only want MacRoman encoding and English name on Mac.
1117                 if ((platformID == MAC_PLATFORM_ID) &amp;&amp;
1118                     (encodingID != MACROMAN_SPECIFIC_ID ||
1119                      langID != MACROMAN_ENGLISH_LANG)) {
1120                     continue;
1121                 }
1122 
1123                 switch (nameID) {
1124 
1125                 case FAMILY_NAME_ID:
1126                     boolean compatible = false;
1127                     if (familyName == null || langID == ENGLISH_LOCALE_ID ||
1128                         langID == nameLocaleID ||
1129                         (localeFamilyName == null &amp;&amp;
1130                          (compatible = isLanguageCompatible(langID))))
1131                     {
1132                         buffer.position(namePtr);
1133                         buffer.get(name, 0, nameLen);
1134                         tmpName = makeString(name, nameLen, platformID, encodingID);
1135                         if (familyName == null || langID == ENGLISH_LOCALE_ID){
1136                             familyName = tmpName;
1137                         }
1138                         if (langID == nameLocaleID ||
1139                             (localeFamilyName == null &amp;&amp; compatible))
1140                         {
1141                             localeFamilyName = tmpName;
1142                         }
1143                     }
1144 /*
1145                     for (int ii=0;ii&lt;nameLen;ii++) {
1146                         int val = (int)name[ii]&amp;0xff;
1147                         System.err.print(Integer.toHexString(val)+ &quot; &quot;);
1148                     }
1149                     System.err.println();
1150                     System.err.println(&quot;familyName=&quot;+familyName +
1151                                        &quot; nameLen=&quot;+nameLen+
1152                                        &quot; langID=&quot;+langID+ &quot; eid=&quot;+encodingID +
1153                                        &quot; str len=&quot;+familyName.length());
1154 
1155 */
1156                     break;
1157 
1158                 case FULL_NAME_ID:
1159                     compatible = false;
1160                     if (fullName == null || langID == ENGLISH_LOCALE_ID ||
1161                         langID == nameLocaleID ||
1162                         (localeFullName == null &amp;&amp;
1163                          (compatible = isLanguageCompatible(langID))))
1164                     {
1165                         buffer.position(namePtr);
1166                         buffer.get(name, 0, nameLen);
1167                         tmpName = makeString(name, nameLen, platformID, encodingID);
1168 
1169                         if (fullName == null || langID == ENGLISH_LOCALE_ID) {
1170                             fullName = tmpName;
1171                         }
1172                         if (langID == nameLocaleID ||
1173                             (localeFullName == null &amp;&amp; compatible))
1174                         {
1175                             localeFullName = tmpName;
1176                         }
1177                     }
1178                     break;
1179                 }
1180             }
1181             if (localeFamilyName == null) {
1182                 localeFamilyName = familyName;
1183             }
1184             if (localeFullName == null) {
1185                 localeFullName = fullName;
1186             }
1187         }
1188     }
1189 
1190     /* Return the requested name in the requested locale, for the
1191      * MS platform ID. If the requested locale isn&#39;t found, return US
1192      * English, if that isn&#39;t found, return null and let the caller
1193      * figure out how to handle that.
1194      */
1195     protected String lookupName(short findLocaleID, int findNameID) {
1196         String foundName = null;
1197         byte[] name = new byte[1024];
1198 
1199         ByteBuffer buffer = getTableBuffer(nameTag);
1200         if (buffer != null) {
1201             ShortBuffer sbuffer = buffer.asShortBuffer();
1202             sbuffer.get(); // format - not needed.
1203             short numRecords = sbuffer.get();
1204 
1205             /* The name table uses unsigned shorts. Many of these
1206              * are known small values that fit in a short.
1207              * The values that are sizes or offsets into the table could be
1208              * greater than 32767, so read and store those as ints
1209              */
1210             int stringPtr = ((int) sbuffer.get()) &amp; 0xffff;
1211 
1212             for (int i=0; i&lt;numRecords; i++) {
1213                 short platformID = sbuffer.get();
1214                 if (platformID != MS_PLATFORM_ID) {
1215                     sbuffer.position(sbuffer.position()+5);
1216                     continue; // skip over this record.
1217                 }
1218                 short encodingID = sbuffer.get();
1219                 short langID     = sbuffer.get();
1220                 short nameID     = sbuffer.get();
1221                 int   nameLen    = ((int) sbuffer.get()) &amp; 0xffff;
1222                 int   namePtr    = (((int) sbuffer.get()) &amp; 0xffff) + stringPtr;
1223                 if (nameID == findNameID &amp;&amp;
1224                     ((foundName == null &amp;&amp; langID == ENGLISH_LOCALE_ID)
1225                      || langID == findLocaleID)) {
1226                     buffer.position(namePtr);
1227                     buffer.get(name, 0, nameLen);
1228                     foundName = makeString(name, nameLen, platformID, encodingID);
1229                     if (langID == findLocaleID) {
1230                         return foundName;
1231                     }
1232                 }
1233             }
1234         }
1235         return foundName;
1236     }
1237 
1238     /**
1239      * @return number of logical fonts. Is &quot;1&quot; for all but TTC files
1240      */
1241     public int getFontCount() {
1242         return directoryCount;
1243     }
1244 
1245     protected synchronized FontScaler getScaler() {
1246         if (scaler == null) {
1247             scaler = FontScaler.getScaler(this, fontIndex,
1248                 supportsCJK, fileSize);
1249         }
1250         return scaler;
1251     }
1252 
1253 
1254     /* Postscript name is rarely requested. Don&#39;t waste cycles locating it
1255      * as part of font creation, nor storage to hold it. Get it only on demand.
1256      */
1257     @Override
1258     public String getPostscriptName() {
1259         String name = lookupName(ENGLISH_LOCALE_ID, POSTSCRIPT_NAME_ID);
1260         if (name == null) {
1261             return fullName;
1262         } else {
1263             return name;
1264         }
1265     }
1266 
1267     @Override
1268     public String getFontName(Locale locale) {
1269         if (locale == null) {
1270             return fullName;
1271         } else if (locale.equals(nameLocale) &amp;&amp; localeFullName != null) {
1272             return localeFullName;
1273         } else {
1274             short localeID = getLCIDFromLocale(locale);
1275             String name = lookupName(localeID, FULL_NAME_ID);
1276             if (name == null) {
1277                 return fullName;
1278             } else {
1279                 return name;
1280             }
1281         }
1282     }
1283 
1284     // Return a Microsoft LCID from the given Locale.
1285     // Used when getting localized font data.
1286 
1287     private static void addLCIDMapEntry(Map&lt;String, Short&gt; map,
1288                                         String key, short value) {
1289         map.put(key, Short.valueOf(value));
1290     }
1291 
1292     private static synchronized void createLCIDMap() {
1293         if (lcidMap != null) {
1294             return;
1295         }
1296 
1297         Map&lt;String, Short&gt; map = new HashMap&lt;&gt;(200);
1298 
1299         // the following statements are derived from the langIDMap
1300         // in src/windows/native/java/lang/java_props_md.c using the following
1301         // awk script:
1302         //    $1~/\/\*/   { next}
1303         //    $3~/\?\?/   { next }
1304         //    $3!~/_/     { next }
1305         //    $1~/0x0409/ { next }
1306         //    $1~/0x0c0a/ { next }
1307         //    $1~/0x042c/ { next }
1308         //    $1~/0x0443/ { next }
1309         //    $1~/0x0812/ { next }
1310         //    $1~/0x04/   { print &quot;        addLCIDMapEntry(map, &quot; substr($3, 0, 3) &quot;\&quot;, (short) &quot; substr($1, 0, 6) &quot;);&quot; ; next }
1311         //    $3~/,/      { print &quot;        addLCIDMapEntry(map, &quot; $3  &quot; (short) &quot; substr($1, 0, 6) &quot;);&quot; ; next }
1312         //                { print &quot;        addLCIDMapEntry(map, &quot; $3 &quot;, (short) &quot; substr($1, 0, 6) &quot;);&quot; ; next }
1313         // The lines of this script:
1314         // - eliminate comments
1315         // - eliminate questionable locales
1316         // - eliminate language-only locales
1317         // - eliminate the default LCID value
1318         // - eliminate a few other unneeded LCID values
1319         // - print language-only locale entries for x04* LCID values
1320         //   (apparently Microsoft doesn&#39;t use language-only LCID values -
1321         //   see http://www.microsoft.com/OpenType/otspec/name.htm
1322         // - print complete entries for all other LCID values
1323         // Run
1324         //     awk -f awk-script langIDMap &gt; statements
1325         addLCIDMapEntry(map, &quot;ar&quot;, (short) 0x0401);
1326         addLCIDMapEntry(map, &quot;bg&quot;, (short) 0x0402);
1327         addLCIDMapEntry(map, &quot;ca&quot;, (short) 0x0403);
1328         addLCIDMapEntry(map, &quot;zh&quot;, (short) 0x0404);
1329         addLCIDMapEntry(map, &quot;cs&quot;, (short) 0x0405);
1330         addLCIDMapEntry(map, &quot;da&quot;, (short) 0x0406);
1331         addLCIDMapEntry(map, &quot;de&quot;, (short) 0x0407);
1332         addLCIDMapEntry(map, &quot;el&quot;, (short) 0x0408);
1333         addLCIDMapEntry(map, &quot;es&quot;, (short) 0x040a);
1334         addLCIDMapEntry(map, &quot;fi&quot;, (short) 0x040b);
1335         addLCIDMapEntry(map, &quot;fr&quot;, (short) 0x040c);
1336         addLCIDMapEntry(map, &quot;iw&quot;, (short) 0x040d);
1337         addLCIDMapEntry(map, &quot;hu&quot;, (short) 0x040e);
1338         addLCIDMapEntry(map, &quot;is&quot;, (short) 0x040f);
1339         addLCIDMapEntry(map, &quot;it&quot;, (short) 0x0410);
1340         addLCIDMapEntry(map, &quot;ja&quot;, (short) 0x0411);
1341         addLCIDMapEntry(map, &quot;ko&quot;, (short) 0x0412);
1342         addLCIDMapEntry(map, &quot;nl&quot;, (short) 0x0413);
1343         addLCIDMapEntry(map, &quot;no&quot;, (short) 0x0414);
1344         addLCIDMapEntry(map, &quot;pl&quot;, (short) 0x0415);
1345         addLCIDMapEntry(map, &quot;pt&quot;, (short) 0x0416);
1346         addLCIDMapEntry(map, &quot;rm&quot;, (short) 0x0417);
1347         addLCIDMapEntry(map, &quot;ro&quot;, (short) 0x0418);
1348         addLCIDMapEntry(map, &quot;ru&quot;, (short) 0x0419);
1349         addLCIDMapEntry(map, &quot;hr&quot;, (short) 0x041a);
1350         addLCIDMapEntry(map, &quot;sk&quot;, (short) 0x041b);
1351         addLCIDMapEntry(map, &quot;sq&quot;, (short) 0x041c);
1352         addLCIDMapEntry(map, &quot;sv&quot;, (short) 0x041d);
1353         addLCIDMapEntry(map, &quot;th&quot;, (short) 0x041e);
1354         addLCIDMapEntry(map, &quot;tr&quot;, (short) 0x041f);
1355         addLCIDMapEntry(map, &quot;ur&quot;, (short) 0x0420);
1356         addLCIDMapEntry(map, &quot;in&quot;, (short) 0x0421);
1357         addLCIDMapEntry(map, &quot;uk&quot;, (short) 0x0422);
1358         addLCIDMapEntry(map, &quot;be&quot;, (short) 0x0423);
1359         addLCIDMapEntry(map, &quot;sl&quot;, (short) 0x0424);
1360         addLCIDMapEntry(map, &quot;et&quot;, (short) 0x0425);
1361         addLCIDMapEntry(map, &quot;lv&quot;, (short) 0x0426);
1362         addLCIDMapEntry(map, &quot;lt&quot;, (short) 0x0427);
1363         addLCIDMapEntry(map, &quot;fa&quot;, (short) 0x0429);
1364         addLCIDMapEntry(map, &quot;vi&quot;, (short) 0x042a);
1365         addLCIDMapEntry(map, &quot;hy&quot;, (short) 0x042b);
1366         addLCIDMapEntry(map, &quot;eu&quot;, (short) 0x042d);
1367         addLCIDMapEntry(map, &quot;mk&quot;, (short) 0x042f);
1368         addLCIDMapEntry(map, &quot;tn&quot;, (short) 0x0432);
1369         addLCIDMapEntry(map, &quot;xh&quot;, (short) 0x0434);
1370         addLCIDMapEntry(map, &quot;zu&quot;, (short) 0x0435);
1371         addLCIDMapEntry(map, &quot;af&quot;, (short) 0x0436);
1372         addLCIDMapEntry(map, &quot;ka&quot;, (short) 0x0437);
1373         addLCIDMapEntry(map, &quot;fo&quot;, (short) 0x0438);
1374         addLCIDMapEntry(map, &quot;hi&quot;, (short) 0x0439);
1375         addLCIDMapEntry(map, &quot;mt&quot;, (short) 0x043a);
1376         addLCIDMapEntry(map, &quot;se&quot;, (short) 0x043b);
1377         addLCIDMapEntry(map, &quot;gd&quot;, (short) 0x043c);
1378         addLCIDMapEntry(map, &quot;ms&quot;, (short) 0x043e);
1379         addLCIDMapEntry(map, &quot;kk&quot;, (short) 0x043f);
1380         addLCIDMapEntry(map, &quot;ky&quot;, (short) 0x0440);
1381         addLCIDMapEntry(map, &quot;sw&quot;, (short) 0x0441);
1382         addLCIDMapEntry(map, &quot;tt&quot;, (short) 0x0444);
1383         addLCIDMapEntry(map, &quot;bn&quot;, (short) 0x0445);
1384         addLCIDMapEntry(map, &quot;pa&quot;, (short) 0x0446);
1385         addLCIDMapEntry(map, &quot;gu&quot;, (short) 0x0447);
1386         addLCIDMapEntry(map, &quot;ta&quot;, (short) 0x0449);
1387         addLCIDMapEntry(map, &quot;te&quot;, (short) 0x044a);
1388         addLCIDMapEntry(map, &quot;kn&quot;, (short) 0x044b);
1389         addLCIDMapEntry(map, &quot;ml&quot;, (short) 0x044c);
1390         addLCIDMapEntry(map, &quot;mr&quot;, (short) 0x044e);
1391         addLCIDMapEntry(map, &quot;sa&quot;, (short) 0x044f);
1392         addLCIDMapEntry(map, &quot;mn&quot;, (short) 0x0450);
1393         addLCIDMapEntry(map, &quot;cy&quot;, (short) 0x0452);
1394         addLCIDMapEntry(map, &quot;gl&quot;, (short) 0x0456);
1395         addLCIDMapEntry(map, &quot;dv&quot;, (short) 0x0465);
1396         addLCIDMapEntry(map, &quot;qu&quot;, (short) 0x046b);
1397         addLCIDMapEntry(map, &quot;mi&quot;, (short) 0x0481);
1398         addLCIDMapEntry(map, &quot;ar_IQ&quot;, (short) 0x0801);
1399         addLCIDMapEntry(map, &quot;zh_CN&quot;, (short) 0x0804);
1400         addLCIDMapEntry(map, &quot;de_CH&quot;, (short) 0x0807);
1401         addLCIDMapEntry(map, &quot;en_GB&quot;, (short) 0x0809);
1402         addLCIDMapEntry(map, &quot;es_MX&quot;, (short) 0x080a);
1403         addLCIDMapEntry(map, &quot;fr_BE&quot;, (short) 0x080c);
1404         addLCIDMapEntry(map, &quot;it_CH&quot;, (short) 0x0810);
1405         addLCIDMapEntry(map, &quot;nl_BE&quot;, (short) 0x0813);
1406         addLCIDMapEntry(map, &quot;no_NO_NY&quot;, (short) 0x0814);
1407         addLCIDMapEntry(map, &quot;pt_PT&quot;, (short) 0x0816);
1408         addLCIDMapEntry(map, &quot;ro_MD&quot;, (short) 0x0818);
1409         addLCIDMapEntry(map, &quot;ru_MD&quot;, (short) 0x0819);
1410         addLCIDMapEntry(map, &quot;sr_CS&quot;, (short) 0x081a);
1411         addLCIDMapEntry(map, &quot;sv_FI&quot;, (short) 0x081d);
1412         addLCIDMapEntry(map, &quot;az_AZ&quot;, (short) 0x082c);
1413         addLCIDMapEntry(map, &quot;se_SE&quot;, (short) 0x083b);
1414         addLCIDMapEntry(map, &quot;ga_IE&quot;, (short) 0x083c);
1415         addLCIDMapEntry(map, &quot;ms_BN&quot;, (short) 0x083e);
1416         addLCIDMapEntry(map, &quot;uz_UZ&quot;, (short) 0x0843);
1417         addLCIDMapEntry(map, &quot;qu_EC&quot;, (short) 0x086b);
1418         addLCIDMapEntry(map, &quot;ar_EG&quot;, (short) 0x0c01);
1419         addLCIDMapEntry(map, &quot;zh_HK&quot;, (short) 0x0c04);
1420         addLCIDMapEntry(map, &quot;de_AT&quot;, (short) 0x0c07);
1421         addLCIDMapEntry(map, &quot;en_AU&quot;, (short) 0x0c09);
1422         addLCIDMapEntry(map, &quot;fr_CA&quot;, (short) 0x0c0c);
1423         addLCIDMapEntry(map, &quot;sr_CS&quot;, (short) 0x0c1a);
1424         addLCIDMapEntry(map, &quot;se_FI&quot;, (short) 0x0c3b);
1425         addLCIDMapEntry(map, &quot;qu_PE&quot;, (short) 0x0c6b);
1426         addLCIDMapEntry(map, &quot;ar_LY&quot;, (short) 0x1001);
1427         addLCIDMapEntry(map, &quot;zh_SG&quot;, (short) 0x1004);
1428         addLCIDMapEntry(map, &quot;de_LU&quot;, (short) 0x1007);
1429         addLCIDMapEntry(map, &quot;en_CA&quot;, (short) 0x1009);
1430         addLCIDMapEntry(map, &quot;es_GT&quot;, (short) 0x100a);
1431         addLCIDMapEntry(map, &quot;fr_CH&quot;, (short) 0x100c);
1432         addLCIDMapEntry(map, &quot;hr_BA&quot;, (short) 0x101a);
1433         addLCIDMapEntry(map, &quot;ar_DZ&quot;, (short) 0x1401);
1434         addLCIDMapEntry(map, &quot;zh_MO&quot;, (short) 0x1404);
1435         addLCIDMapEntry(map, &quot;de_LI&quot;, (short) 0x1407);
1436         addLCIDMapEntry(map, &quot;en_NZ&quot;, (short) 0x1409);
1437         addLCIDMapEntry(map, &quot;es_CR&quot;, (short) 0x140a);
1438         addLCIDMapEntry(map, &quot;fr_LU&quot;, (short) 0x140c);
1439         addLCIDMapEntry(map, &quot;bs_BA&quot;, (short) 0x141a);
1440         addLCIDMapEntry(map, &quot;ar_MA&quot;, (short) 0x1801);
1441         addLCIDMapEntry(map, &quot;en_IE&quot;, (short) 0x1809);
1442         addLCIDMapEntry(map, &quot;es_PA&quot;, (short) 0x180a);
1443         addLCIDMapEntry(map, &quot;fr_MC&quot;, (short) 0x180c);
1444         addLCIDMapEntry(map, &quot;sr_BA&quot;, (short) 0x181a);
1445         addLCIDMapEntry(map, &quot;ar_TN&quot;, (short) 0x1c01);
1446         addLCIDMapEntry(map, &quot;en_ZA&quot;, (short) 0x1c09);
1447         addLCIDMapEntry(map, &quot;es_DO&quot;, (short) 0x1c0a);
1448         addLCIDMapEntry(map, &quot;sr_BA&quot;, (short) 0x1c1a);
1449         addLCIDMapEntry(map, &quot;ar_OM&quot;, (short) 0x2001);
1450         addLCIDMapEntry(map, &quot;en_JM&quot;, (short) 0x2009);
1451         addLCIDMapEntry(map, &quot;es_VE&quot;, (short) 0x200a);
1452         addLCIDMapEntry(map, &quot;ar_YE&quot;, (short) 0x2401);
1453         addLCIDMapEntry(map, &quot;es_CO&quot;, (short) 0x240a);
1454         addLCIDMapEntry(map, &quot;ar_SY&quot;, (short) 0x2801);
1455         addLCIDMapEntry(map, &quot;en_BZ&quot;, (short) 0x2809);
1456         addLCIDMapEntry(map, &quot;es_PE&quot;, (short) 0x280a);
1457         addLCIDMapEntry(map, &quot;ar_JO&quot;, (short) 0x2c01);
1458         addLCIDMapEntry(map, &quot;en_TT&quot;, (short) 0x2c09);
1459         addLCIDMapEntry(map, &quot;es_AR&quot;, (short) 0x2c0a);
1460         addLCIDMapEntry(map, &quot;ar_LB&quot;, (short) 0x3001);
1461         addLCIDMapEntry(map, &quot;en_ZW&quot;, (short) 0x3009);
1462         addLCIDMapEntry(map, &quot;es_EC&quot;, (short) 0x300a);
1463         addLCIDMapEntry(map, &quot;ar_KW&quot;, (short) 0x3401);
1464         addLCIDMapEntry(map, &quot;en_PH&quot;, (short) 0x3409);
1465         addLCIDMapEntry(map, &quot;es_CL&quot;, (short) 0x340a);
1466         addLCIDMapEntry(map, &quot;ar_AE&quot;, (short) 0x3801);
1467         addLCIDMapEntry(map, &quot;es_UY&quot;, (short) 0x380a);
1468         addLCIDMapEntry(map, &quot;ar_BH&quot;, (short) 0x3c01);
1469         addLCIDMapEntry(map, &quot;es_PY&quot;, (short) 0x3c0a);
1470         addLCIDMapEntry(map, &quot;ar_QA&quot;, (short) 0x4001);
1471         addLCIDMapEntry(map, &quot;es_BO&quot;, (short) 0x400a);
1472         addLCIDMapEntry(map, &quot;es_SV&quot;, (short) 0x440a);
1473         addLCIDMapEntry(map, &quot;es_HN&quot;, (short) 0x480a);
1474         addLCIDMapEntry(map, &quot;es_NI&quot;, (short) 0x4c0a);
1475         addLCIDMapEntry(map, &quot;es_PR&quot;, (short) 0x500a);
1476 
1477         lcidMap = map;
1478     }
1479 
1480     private static short getLCIDFromLocale(Locale locale) {
1481         // optimize for common case
1482         if (locale.equals(Locale.US)) {
1483             return US_LCID;
1484         }
1485 
1486         if (lcidMap == null) {
1487             createLCIDMap();
1488         }
1489 
1490         String key = locale.toString();
1491         while (!&quot;&quot;.equals(key)) {
1492             Short lcidObject = lcidMap.get(key);
1493             if (lcidObject != null) {
1494                 return lcidObject.shortValue();
1495             }
1496             int pos = key.lastIndexOf(&#39;_&#39;);
1497             if (pos &lt; 1) {
1498                 return US_LCID;
1499             }
1500             key = key.substring(0, pos);
1501         }
1502 
1503         return US_LCID;
1504     }
1505 
1506     @Override
1507     public String getFamilyName(Locale locale) {
1508         if (locale == null) {
1509             return familyName;
1510         } else if (locale.equals(nameLocale) &amp;&amp; localeFamilyName != null) {
1511             return localeFamilyName;
1512         } else {
1513             short localeID = getLCIDFromLocale(locale);
1514             String name = lookupName(localeID, FAMILY_NAME_ID);
1515             if (name == null) {
1516                 return familyName;
1517             } else {
1518                 return name;
1519             }
1520         }
1521     }
1522 
1523     public CharToGlyphMapper getMapper() {
1524         if (mapper == null) {
1525             mapper = new TrueTypeGlyphMapper(this);
1526         }
1527         return mapper;
1528     }
1529 
1530     /* This duplicates initNames() but that has to run fast as its used
1531      * during typical start-up and the information here is likely never
1532      * needed.
1533      */
1534     protected void initAllNames(int requestedID, HashSet&lt;String&gt; names) {
1535         byte[] name = new byte[256];
1536         ByteBuffer buffer = getTableBuffer(nameTag);
1537 
1538         if (buffer != null) {
1539             ShortBuffer sbuffer = buffer.asShortBuffer();
1540             sbuffer.get(); // format - not needed.
1541             short numRecords = sbuffer.get();
1542 
1543             /* The name table uses unsigned shorts. Many of these
1544              * are known small values that fit in a short.
1545              * The values that are sizes or offsets into the table could be
1546              * greater than 32767, so read and store those as ints
1547              */
1548             int stringPtr = ((int) sbuffer.get()) &amp; 0xffff;
1549             for (int i=0; i&lt;numRecords; i++) {
1550                 short platformID = sbuffer.get();
1551                 if (platformID != MS_PLATFORM_ID) {
1552                     sbuffer.position(sbuffer.position()+5);
1553                     continue; // skip over this record.
1554                 }
1555                 short encodingID = sbuffer.get();
1556                 /* short langID = */ sbuffer.get();
1557                 short nameID     = sbuffer.get();
1558                 int   nameLen    = ((int) sbuffer.get()) &amp; 0xffff;
1559                 int   namePtr    = (((int) sbuffer.get()) &amp; 0xffff) + stringPtr;
1560 
1561                 if (nameID == requestedID) {
1562                     buffer.position(namePtr);
1563                     buffer.get(name, 0, nameLen);
1564                     names.add(makeString(name, nameLen, platformID, encodingID));
1565                 }
1566             }
1567         }
1568     }
1569 
1570     String[] getAllFamilyNames() {
1571         HashSet&lt;String&gt; aSet = new HashSet&lt;&gt;();
1572         try {
1573             initAllNames(FAMILY_NAME_ID, aSet);
1574         } catch (Exception e) {
1575             /* In case of malformed font */
1576         }
1577         return aSet.toArray(new String[0]);
1578     }
1579 
1580     String[] getAllFullNames() {
1581         HashSet&lt;String&gt; aSet = new HashSet&lt;&gt;();
1582         try {
1583             initAllNames(FULL_NAME_ID, aSet);
1584         } catch (Exception e) {
1585             /* In case of malformed font */
1586         }
1587         return aSet.toArray(new String[0]);
1588     }
1589 
1590     /*  Used by the OpenType engine for mark positioning.
1591      */
1592     @Override
1593     Point2D.Float getGlyphPoint(long pScalerContext,
1594                                 int glyphCode, int ptNumber) {
1595         try {
1596             return getScaler().getGlyphPoint(pScalerContext,
1597                                              glyphCode, ptNumber);
1598         } catch(FontScalerException fe) {
1599             return null;
1600         }
1601     }
1602 
1603     private char[] gaspTable;
1604 
1605     private char[] getGaspTable() {
1606 
1607         if (gaspTable != null) {
1608             return gaspTable;
1609         }
1610 
1611         ByteBuffer buffer = getTableBuffer(gaspTag);
1612         if (buffer == null) {
1613             return gaspTable = new char[0];
1614         }
1615 
1616         CharBuffer cbuffer = buffer.asCharBuffer();
1617         char format = cbuffer.get();
1618         /* format &quot;1&quot; has appeared for some Windows Vista fonts.
1619          * Its presently undocumented but the existing values
1620          * seem to be still valid so we can use it.
1621          */
1622         if (format &gt; 1) { // unrecognised format
1623             return gaspTable = new char[0];
1624         }
1625 
1626         char numRanges = cbuffer.get();
1627         if (4+numRanges*4 &gt; getTableSize(gaspTag)) { // sanity check
1628             return gaspTable = new char[0];
1629         }
1630         gaspTable = new char[2*numRanges];
1631         cbuffer.get(gaspTable);
1632         return gaspTable;
1633     }
1634 
1635     /* This is to obtain info from the TT &#39;gasp&#39; (grid-fitting and
1636      * scan-conversion procedure) table which specifies three combinations:
1637      * Hint, Smooth (greyscale), Hint and Smooth.
1638      * In this simplified scheme we don&#39;t distinguish the latter two. We
1639      * hint even at small sizes, so as to preserve metrics consistency.
1640      * If the information isn&#39;t available default values are substituted.
1641      * The more precise defaults we&#39;d do if we distinguished the cases are:
1642      * Bold (no other style) fonts :
1643      * 0-8 : Smooth ( do grey)
1644      * 9+  : Hint + smooth (gridfit + grey)
1645      * Plain, Italic and Bold-Italic fonts :
1646      * 0-8 : Smooth ( do grey)
1647      * 9-17 : Hint (gridfit)
1648      * 18+  : Hint + smooth (gridfit + grey)
1649      * The defaults should rarely come into play as most TT fonts provide
1650      * better defaults.
1651      * REMIND: consider unpacking the table into an array of booleans
1652      * for faster use.
1653      */
1654     @Override
1655     public boolean useAAForPtSize(int ptsize) {
1656 
1657         char[] gasp = getGaspTable();
1658         if (gasp.length &gt; 0) {
1659             for (int i=0;i&lt;gasp.length;i+=2) {
1660                 if (ptsize &lt;= gasp[i]) {
1661                     return ((gasp[i+1] &amp; 0x2) != 0); // bit 2 means DO_GRAY;
1662                 }
1663             }
1664             return true;
1665         }
1666 
1667         if (style == Font.BOLD) {
1668             return true;
1669         } else {
1670             return ptsize &lt;= 8 || ptsize &gt;= 18;
1671         }
1672     }
1673 
1674     @Override
1675     public boolean hasSupplementaryChars() {
1676         return ((TrueTypeGlyphMapper)getMapper()).hasSupplementaryChars();
1677     }
1678 
1679     @Override
1680     public String toString() {
1681         return &quot;** TrueType Font: Family=&quot;+familyName+ &quot; Name=&quot;+fullName+
1682             &quot; style=&quot;+style+&quot; fileName=&quot;+getPublicFileName();
1683     }
1684 
1685 
1686     private static Map&lt;String, short[]&gt; lcidLanguageCompatibilityMap;
1687     private static final short[] EMPTY_COMPATIBLE_LCIDS = new short[0];
1688 
1689     // the language compatible LCIDs for this font&#39;s nameLocale
1690     private short[] languageCompatibleLCIDs;
1691 
1692     /*
1693      * Returns true if the given lcid&#39;s language is compatible
1694      * to the language of the startup Locale. I.e. if
1695      * startupLocale.getLanguage().equals(lcidLocale.getLanguage()) would
1696      * return true.
1697      */
1698     private boolean isLanguageCompatible(short lcid){
1699         for (short s : languageCompatibleLCIDs) {
1700             if (s == lcid) {
1701                 return true;
1702             }
1703         }
1704         return false;
1705     }
1706 
1707     /*
1708      * Returns an array of all the language compatible LCIDs for the
1709      * given Locale. This array is later used to find compatible
1710      * locales.
1711      */
1712     private static short[] getLanguageCompatibleLCIDsFromLocale(Locale locale) {
1713         if (lcidLanguageCompatibilityMap == null) {
1714             createLCIDMap();
1715             createLCIDLanguageCompatibilityMap();
1716         }
1717         String language = locale.getLanguage();
1718         short[] result = lcidLanguageCompatibilityMap.get(language);
1719         return result == null ? EMPTY_COMPATIBLE_LCIDS : result;
1720     }
1721 
1722 //     private static void prtLine(String s) {
1723 //        System.out.println(s);
1724 //     }
1725 
1726 //     /*
1727 //      * Initializes the map from Locale keys (e.g. &quot;en_BZ&quot; or &quot;de&quot;)
1728 //      * to language compatible LCIDs.
1729 //      * This map could be statically created based on the fixed known set
1730 //      * added to lcidMap.
1731 //      */
1732 //     private static void createLCIDLanguageCompatibilityMap() {
1733 //         if (lcidLanguageCompatibilityMap != null) {
1734 //             return;
1735 //         }
1736 //         HashMap&lt;String, List&lt;Short&gt;&gt; result = new HashMap&lt;&gt;();
1737 //         for (Entry&lt;String, Short&gt; e : lcidMap.entrySet()) {
1738 //             String language = e.getKey();
1739 //             int index = language.indexOf(&#39;_&#39;);
1740 //             if (index != -1) {
1741 //                 language = language.substring(0, index);
1742 //             }
1743 //             List&lt;Short&gt; list = result.get(language);
1744 //             if (list == null) {
1745 //                 list = new ArrayList&lt;&gt;();
1746 //                 result.put(language, list);
1747 //             }
1748 //             if (index == -1) {
1749 //                 list.add(0, e.getValue());
1750 //             } else{
1751 //                 list.add(e.getValue());
1752 //             }
1753 //         }
1754 //         Map&lt;String, short[]&gt; compMap = new HashMap&lt;&gt;();
1755 //         for (Entry&lt;String, List&lt;Short&gt;&gt; e : result.entrySet()) {
1756 //             if (e.getValue().size() &gt; 1) {
1757 //                 List&lt;Short&gt; list = e.getValue();
1758 //                 short[] shorts = new short[list.size()];
1759 //                 for (int i = 0; i &lt; shorts.length; i++) {
1760 //                     shorts[i] = list.get(i);
1761 //                 }
1762 //                 compMap.put(e.getKey(), shorts);
1763 //             }
1764 //         }
1765 
1766 //         /* Now dump code to init the map to System.out */
1767 //         prtLine(&quot;    private static void createLCIDLanguageCompatibilityMap() {&quot;);
1768 //         prtLine(&quot;&quot;);
1769 
1770 //         prtLine(&quot;        Map&lt;String, short[]&gt; map = new HashMap&lt;&gt;();&quot;);
1771 //         prtLine(&quot;&quot;);
1772 //         prtLine(&quot;        short[] sarr;&quot;);
1773 //         for (Entry&lt;String, short[]&gt; e : compMap.entrySet()) {
1774 //             String lang = e.getKey();
1775 //             short[] ids = e.getValue();
1776 //             StringBuilder sb = new StringBuilder(&quot;sarr = new short[] { &quot;);
1777 //             for (int i = 0; i &lt; ids.length; i++) {
1778 //                 sb.append(ids[i]+&quot;, &quot;);
1779 //             }
1780 //             sb.append(&quot;}&quot;);
1781 //             prtLine(&quot;        &quot; + sb + &quot;;&quot;);
1782 //             prtLine(&quot;        map.put(\&quot;&quot; + lang + &quot;\&quot;, sarr);&quot;);
1783 //         }
1784 //         prtLine(&quot;&quot;);
1785 //         prtLine(&quot;        lcidLanguageCompatibilityMap = map;&quot;);
1786 //         prtLine(&quot;    }&quot;);
1787 //         /* done dumping map */
1788 
1789 //         lcidLanguageCompatibilityMap = compMap;
1790 //     }
1791 
1792     private static void createLCIDLanguageCompatibilityMap() {
1793 
1794         Map&lt;String, short[]&gt; map = new HashMap&lt;&gt;();
1795 
1796         short[] sarr;
1797         sarr = new short[] { 1031, 3079, 5127, 2055, 4103, };
1798         map.put(&quot;de&quot;, sarr);
1799         sarr = new short[] { 1044, 2068, };
1800         map.put(&quot;no&quot;, sarr);
1801         sarr = new short[] { 1049, 2073, };
1802         map.put(&quot;ru&quot;, sarr);
1803         sarr = new short[] { 1053, 2077, };
1804         map.put(&quot;sv&quot;, sarr);
1805         sarr = new short[] { 1046, 2070, };
1806         map.put(&quot;pt&quot;, sarr);
1807         sarr = new short[] { 1131, 3179, 2155, };
1808         map.put(&quot;qu&quot;, sarr);
1809         sarr = new short[] { 1086, 2110, };
1810         map.put(&quot;ms&quot;, sarr);
1811         sarr = new short[] { 11273, 3081, 12297, 8201, 10249, 4105, 13321, 6153, 7177, 5129, 2057, };
1812         map.put(&quot;en&quot;, sarr);
1813         sarr = new short[] { 1050, 4122, };
1814         map.put(&quot;hr&quot;, sarr);
1815         sarr = new short[] { 1040, 2064, };
1816         map.put(&quot;it&quot;, sarr);
1817         sarr = new short[] { 1036, 5132, 6156, 2060, 3084, 4108, };
1818         map.put(&quot;fr&quot;, sarr);
1819         sarr = new short[] { 1034, 12298, 14346, 2058, 8202, 19466, 17418, 9226, 13322, 5130, 7178, 11274, 16394, 4106, 10250, 6154, 18442, 20490, 15370, };
1820         map.put(&quot;es&quot;, sarr);
1821         sarr = new short[] { 1028, 3076, 5124, 4100, 2052, };
1822         map.put(&quot;zh&quot;, sarr);
1823         sarr = new short[] { 1025, 8193, 16385, 9217, 2049, 14337, 15361, 11265, 13313, 10241, 7169, 12289, 4097, 5121, 6145, 3073, };
1824         map.put(&quot;ar&quot;, sarr);
1825         sarr = new short[] { 1083, 3131, 2107, };
1826         map.put(&quot;se&quot;, sarr);
1827         sarr = new short[] { 1048, 2072, };
1828         map.put(&quot;ro&quot;, sarr);
1829         sarr = new short[] { 1043, 2067, };
1830         map.put(&quot;nl&quot;, sarr);
1831         sarr = new short[] { 7194, 3098, };
1832         map.put(&quot;sr&quot;, sarr);
1833 
1834         lcidLanguageCompatibilityMap = map;
1835     }
1836 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>