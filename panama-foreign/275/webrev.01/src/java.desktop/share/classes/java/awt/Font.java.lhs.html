<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/java/awt/Font.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.awt;
  27 
  28 import java.awt.font.FontRenderContext;
  29 import java.awt.font.GlyphVector;
  30 import java.awt.font.LineMetrics;
  31 import java.awt.font.TextAttribute;
  32 import java.awt.font.TextLayout;
  33 import java.awt.geom.AffineTransform;
  34 import java.awt.geom.Point2D;
  35 import java.awt.geom.Rectangle2D;
  36 import java.awt.peer.FontPeer;
  37 import java.io.*;
  38 import java.lang.ref.SoftReference;
  39 import java.nio.file.Files;
  40 import java.security.AccessController;
  41 import java.security.PrivilegedExceptionAction;
  42 import java.text.AttributedCharacterIterator.Attribute;
  43 import java.text.CharacterIterator;
  44 import java.util.EventListener;
  45 import java.util.Hashtable;
  46 import java.util.Locale;
  47 import java.util.Map;
  48 
  49 import sun.awt.ComponentFactory;
  50 import sun.font.StandardGlyphVector;
  51 
  52 import sun.font.AttributeMap;
  53 import sun.font.AttributeValues;
  54 import sun.font.CompositeFont;
  55 import sun.font.CreatedFontTracker;
  56 import sun.font.Font2D;
  57 import sun.font.Font2DHandle;
  58 import sun.font.FontAccess;
  59 import sun.font.FontDesignMetrics;
  60 import sun.font.FontManager;
  61 import sun.font.FontManagerFactory;
  62 import sun.font.FontUtilities;
  63 import sun.font.GlyphLayout;
  64 import sun.font.FontLineMetrics;
  65 import sun.font.CoreMetrics;
  66 
  67 import static sun.font.EAttribute.*;
  68 
  69 /**
  70  * The {@code Font} class represents fonts, which are used to
  71  * render text in a visible way.
  72  * A font provides the information needed to map sequences of
  73  * &lt;em&gt;characters&lt;/em&gt; to sequences of &lt;em&gt;glyphs&lt;/em&gt;
  74  * and to render sequences of glyphs on {@code Graphics} and
  75  * {@code Component} objects.
  76  *
  77  * &lt;h2&gt;Characters and Glyphs&lt;/h2&gt;
  78  *
  79  * A &lt;em&gt;character&lt;/em&gt; is a symbol that represents an item such as a letter,
  80  * a digit, or punctuation in an abstract way. For example, {@code &#39;g&#39;},
  81  * LATIN SMALL LETTER G, is a character.
  82  * &lt;p&gt;
  83  * A &lt;em&gt;glyph&lt;/em&gt; is a shape used to render a character or a sequence of
  84  * characters. In simple writing systems, such as Latin, typically one glyph
  85  * represents one character. In general, however, characters and glyphs do not
  86  * have one-to-one correspondence. For example, the character &#39;&amp;aacute;&#39;
  87  * LATIN SMALL LETTER A WITH ACUTE, can be represented by
  88  * two glyphs: one for &#39;a&#39; and one for &#39;&amp;acute;&#39;. On the other hand, the
  89  * two-character string &quot;fi&quot; can be represented by a single glyph, an
  90  * &quot;fi&quot; ligature. In complex writing systems, such as Arabic or the South
  91  * and South-East Asian writing systems, the relationship between characters
  92  * and glyphs can be more complicated and involve context-dependent selection
  93  * of glyphs as well as glyph reordering.
  94  *
  95  * A font encapsulates the collection of glyphs needed to render a selected set
  96  * of characters as well as the tables needed to map sequences of characters to
  97  * corresponding sequences of glyphs.
  98  *
  99  * &lt;h2&gt;Physical and Logical Fonts&lt;/h2&gt;
 100  *
 101  * The Java Platform distinguishes between two kinds of fonts:
 102  * &lt;em&gt;physical&lt;/em&gt; fonts and &lt;em&gt;logical&lt;/em&gt; fonts.
 103  * &lt;p&gt;
 104  * &lt;em&gt;Physical&lt;/em&gt; fonts are the actual font libraries containing glyph data
 105  * and tables to map from character sequences to glyph sequences, using a font
 106  * technology such as TrueType or PostScript Type 1.
 107  * All implementations of the Java Platform must support TrueType fonts;
 108  * support for other font technologies is implementation dependent.
 109  * Physical fonts may use names such as Helvetica, Palatino, HonMincho, or
 110  * any number of other font names.
 111  * Typically, each physical font supports only a limited set of writing
 112  * systems, for example, only Latin characters or only Japanese and Basic
 113  * Latin.
 114  * The set of available physical fonts varies between configurations.
 115  * Applications that require specific fonts can bundle them and instantiate
 116  * them using the {@link #createFont createFont} method.
 117  * &lt;p&gt;
 118  * &lt;em&gt;Logical&lt;/em&gt; fonts are the five font families defined by the Java
 119  * platform which must be supported by any Java runtime environment:
 120  * Serif, SansSerif, Monospaced, Dialog, and DialogInput.
 121  * These logical fonts are not actual font libraries. Instead, the logical
 122  * font names are mapped to physical fonts by the Java runtime environment.
 123  * The mapping is implementation and usually locale dependent, so the look
 124  * and the metrics provided by them vary.
 125  * Typically, each logical font name maps to several physical fonts in order to
 126  * cover a large range of characters.
 127  * &lt;p&gt;
 128  * Peered AWT components, such as {@link Label Label} and
 129  * {@link TextField TextField}, can only use logical fonts.
 130  * &lt;p&gt;
 131  * For a discussion of the relative advantages and disadvantages of using
 132  * physical or logical fonts, see the
 133  * &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/2d/text/fonts.html#advantages-and-disadvantages&quot;&gt;
 134  *    Physical and Logical Fonts&lt;/a&gt;
 135  * in &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/index.html&quot;&gt;The Java Tutorials&lt;/a&gt;
 136  * document.
 137  *
 138  * &lt;h2&gt;Font Faces and Names&lt;/h2&gt;
 139  *
 140  * A {@code Font}
 141  * can have many faces, such as heavy, medium, oblique, gothic and
 142  * regular. All of these faces have similar typographic design.
 143  * &lt;p&gt;
 144  * There are three different names that you can get from a
 145  * {@code Font} object.  The &lt;em&gt;logical font name&lt;/em&gt; is simply the
 146  * name that was used to construct the font.
 147  * The &lt;em&gt;font face name&lt;/em&gt;, or just &lt;em&gt;font name&lt;/em&gt; for
 148  * short, is the name of a particular font face, like Helvetica Bold. The
 149  * &lt;em&gt;family name&lt;/em&gt; is the name of the font family that determines the
 150  * typographic design across several faces, like Helvetica.
 151  * &lt;p&gt;
 152  * The {@code Font} class represents an instance of a font face from
 153  * a collection of  font faces that are present in the system resources
 154  * of the host system.  As examples, Arial Bold and Courier Bold Italic
 155  * are font faces.  There can be several {@code Font} objects
 156  * associated with a font face, each differing in size, style, transform
 157  * and font features.
 158  * &lt;p&gt;
 159  * Glyphs may not always be rendered with the requested properties (e.g, font
 160  * and style) due to platform limitations such as the absence of suitable
 161  * platform fonts to implement a logical font.
 162  * &lt;p&gt;
 163  * The {@link GraphicsEnvironment#getAllFonts() getAllFonts} method
 164  * of the {@code GraphicsEnvironment} class returns an
 165  * array of all font faces available in the system. These font faces are
 166  * returned as {@code Font} objects with a size of 1, identity
 167  * transform and default font features. These
 168  * base fonts can then be used to derive new {@code Font} objects
 169  * with varying sizes, styles, transforms and font features via the
 170  * {@code deriveFont} methods in this class.
 171  *
 172  * &lt;h2&gt;Font and TextAttribute&lt;/h2&gt;
 173  *
 174  * &lt;p&gt;{@code Font} supports most
 175  * {@code TextAttribute}s.  This makes some operations, such as
 176  * rendering underlined text, convenient since it is not
 177  * necessary to explicitly construct a {@code TextLayout} object.
 178  * Attributes can be set on a Font by constructing or deriving it
 179  * using a {@code Map} of {@code TextAttribute} values.
 180  *
 181  * &lt;p&gt;The values of some {@code TextAttributes} are not
 182  * serializable, and therefore attempting to serialize an instance of
 183  * {@code Font} that has such values will not serialize them.
 184  * This means a Font deserialized from such a stream will not compare
 185  * equal to the original Font that contained the non-serializable
 186  * attributes.  This should very rarely pose a problem
 187  * since these attributes are typically used only in special
 188  * circumstances and are unlikely to be serialized.
 189  *
 190  * &lt;ul&gt;
 191  * &lt;li&gt;{@code FOREGROUND} and {@code BACKGROUND} use
 192  * {@code Paint} values. The subclass {@code Color} is
 193  * serializable, while {@code GradientPaint} and
 194  * {@code TexturePaint} are not.&lt;/li&gt;
 195  * &lt;li&gt;{@code CHAR_REPLACEMENT} uses
 196  * {@code GraphicAttribute} values.  The subclasses
 197  * {@code ShapeGraphicAttribute} and
 198  * {@code ImageGraphicAttribute} are not serializable.&lt;/li&gt;
 199  * &lt;li&gt;{@code INPUT_METHOD_HIGHLIGHT} uses
 200  * {@code InputMethodHighlight} values, which are
 201  * not serializable.  See {@link java.awt.im.InputMethodHighlight}.&lt;/li&gt;
 202  * &lt;/ul&gt;
 203  *
 204  * &lt;p&gt;Clients who create custom subclasses of {@code Paint} and
 205  * {@code GraphicAttribute} can make them serializable and
 206  * avoid this problem.  Clients who use input method highlights can
 207  * convert these to the platform-specific attributes for that
 208  * highlight on the current platform and set them on the Font as
 209  * a workaround.
 210  *
 211  * &lt;p&gt;The {@code Map}-based constructor and
 212  * {@code deriveFont} APIs ignore the FONT attribute, and it is
 213  * not retained by the Font; the static {@link #getFont} method should
 214  * be used if the FONT attribute might be present.  See {@link
 215  * java.awt.font.TextAttribute#FONT} for more information.&lt;/p&gt;
 216  *
 217  * &lt;p&gt;Several attributes will cause additional rendering overhead
 218  * and potentially invoke layout.  If a {@code Font} has such
 219  * attributes, the &lt;code&gt;{@link #hasLayoutAttributes()}&lt;/code&gt; method
 220  * will return true.&lt;/p&gt;
 221  *
 222  * &lt;p&gt;Note: Font rotations can cause text baselines to be rotated.  In
 223  * order to account for this (rare) possibility, font APIs are
 224  * specified to return metrics and take parameters &#39;in
 225  * baseline-relative coordinates&#39;.  This maps the &#39;x&#39; coordinate to
 226  * the advance along the baseline, (positive x is forward along the
 227  * baseline), and the &#39;y&#39; coordinate to a distance along the
 228  * perpendicular to the baseline at &#39;x&#39; (positive y is 90 degrees
 229  * clockwise from the baseline vector).  APIs for which this is
 230  * especially important are called out as having &#39;baseline-relative
 231  * coordinates.&#39;
 232  */
 233 public class Font implements java.io.Serializable
 234 {
 235     private static class FontAccessImpl extends FontAccess {
 236         public Font2D getFont2D(Font font) {
 237             return font.getFont2D();
 238         }
 239 
 240         public void setFont2D(Font font, Font2DHandle handle) {
 241             font.font2DHandle = handle;
 242         }
 243 
 244         public void setCreatedFont(Font font) {
 245             font.createdFont = true;
 246         }
 247 
 248         public boolean isCreatedFont(Font font) {
 249             return font.createdFont;
 250         }
 251 
 252         @Override
 253         public FontPeer getFontPeer(final Font font) {
 254             return font.getFontPeer();
 255         }
 256     }
 257 
 258     static {
 259         /* ensure that the necessary native libraries are loaded */
 260         Toolkit.loadLibraries();
 261         initIDs();
 262         FontAccess.setFontAccess(new FontAccessImpl());
 263     }
 264 
 265     /**
 266      * This is now only used during serialization.  Typically
 267      * it is null.
 268      *
 269      * @serial
 270      * @see #getAttributes()
 271      */
 272     private Hashtable&lt;Object, Object&gt; fRequestedAttributes;
 273 
 274     /*
 275      * Constants to be used for logical font family names.
 276      */
 277 
 278     /**
 279      * A String constant for the canonical family name of the
 280      * logical font &quot;Dialog&quot;. It is useful in Font construction
 281      * to provide compile-time verification of the name.
 282      * @since 1.6
 283      */
 284     public static final String DIALOG = &quot;Dialog&quot;;
 285 
 286     /**
 287      * A String constant for the canonical family name of the
 288      * logical font &quot;DialogInput&quot;. It is useful in Font construction
 289      * to provide compile-time verification of the name.
 290      * @since 1.6
 291      */
 292     public static final String DIALOG_INPUT = &quot;DialogInput&quot;;
 293 
 294     /**
 295      * A String constant for the canonical family name of the
 296      * logical font &quot;SansSerif&quot;. It is useful in Font construction
 297      * to provide compile-time verification of the name.
 298      * @since 1.6
 299      */
 300     public static final String SANS_SERIF = &quot;SansSerif&quot;;
 301 
 302     /**
 303      * A String constant for the canonical family name of the
 304      * logical font &quot;Serif&quot;. It is useful in Font construction
 305      * to provide compile-time verification of the name.
 306      * @since 1.6
 307      */
 308     public static final String SERIF = &quot;Serif&quot;;
 309 
 310     /**
 311      * A String constant for the canonical family name of the
 312      * logical font &quot;Monospaced&quot;. It is useful in Font construction
 313      * to provide compile-time verification of the name.
 314      * @since 1.6
 315      */
 316     public static final String MONOSPACED = &quot;Monospaced&quot;;
 317 
 318     /*
 319      * Constants to be used for styles. Can be combined to mix
 320      * styles.
 321      */
 322 
 323     /**
 324      * The plain style constant.
 325      */
 326     public static final int PLAIN       = 0;
 327 
 328     /**
 329      * The bold style constant.  This can be combined with the other style
 330      * constants (except PLAIN) for mixed styles.
 331      */
 332     public static final int BOLD        = 1;
 333 
 334     /**
 335      * The italicized style constant.  This can be combined with the other
 336      * style constants (except PLAIN) for mixed styles.
 337      */
 338     public static final int ITALIC      = 2;
 339 
 340     /**
 341      * The baseline used in most Roman scripts when laying out text.
 342      */
 343     public static final int ROMAN_BASELINE = 0;
 344 
 345     /**
 346      * The baseline used in ideographic scripts like Chinese, Japanese,
 347      * and Korean when laying out text.
 348      */
 349     public static final int CENTER_BASELINE = 1;
 350 
 351     /**
 352      * The baseline used in Devanagari and similar scripts when laying
 353      * out text.
 354      */
 355     public static final int HANGING_BASELINE = 2;
 356 
 357     /**
 358      * Identify a font resource of type TRUETYPE.
 359      * Used to specify a TrueType font resource to the
 360      * {@link #createFont} method.
 361      * The TrueType format was extended to become the OpenType
 362      * format, which adds support for fonts with Postscript outlines,
 363      * this tag therefore references these fonts, as well as those
 364      * with TrueType outlines.
 365      * @since 1.3
 366      */
 367 
 368     public static final int TRUETYPE_FONT = 0;
 369 
 370     /**
 371      * Identify a font resource of type TYPE1.
 372      * Used to specify a Type1 font resource to the
 373      * {@link #createFont} method.
 374      * @since 1.5
 375      */
 376     public static final int TYPE1_FONT = 1;
 377 
 378     /**
 379      * The logical name of this {@code Font}, as passed to the
 380      * constructor.
 381      * @since 1.0
 382      *
 383      * @serial
 384      * @see #getName
 385      */
 386     protected String name;
 387 
 388     /**
 389      * The style of this {@code Font}, as passed to the constructor.
 390      * This style can be PLAIN, BOLD, ITALIC, or BOLD+ITALIC.
 391      * @since 1.0
 392      *
 393      * @serial
 394      * @see #getStyle()
 395      */
 396     protected int style;
 397 
 398     /**
 399      * The point size of this {@code Font}, rounded to integer.
 400      * @since 1.0
 401      *
 402      * @serial
 403      * @see #getSize()
 404      */
 405     protected int size;
 406 
 407     /**
 408      * The point size of this {@code Font} in {@code float}.
 409      *
 410      * @serial
 411      * @see #getSize()
 412      * @see #getSize2D()
 413      */
 414     protected float pointSize;
 415 
 416     /**
 417      * The platform specific font information.
 418      */
 419     private transient FontPeer peer;
 420     private transient long pData;       // native JDK1.1 font pointer
 421     private transient Font2DHandle font2DHandle;
 422 
 423     private transient AttributeValues values;
 424     private transient boolean hasLayoutAttributes;
 425 
 426     /*
 427      * If the origin of a Font is a created font then this attribute
 428      * must be set on all derived fonts too.
 429      */
 430     private transient boolean createdFont = false;
 431 
 432     /*
 433      * This is true if the font transform is not identity.  It
 434      * is used to avoid unnecessary instantiation of an AffineTransform.
 435      */
 436     private transient boolean nonIdentityTx;
 437 
 438     /*
 439      * A cached value used when a transform is required for internal
 440      * use.  This must not be exposed to callers since AffineTransform
 441      * is mutable.
 442      */
 443     private static final AffineTransform identityTx = new AffineTransform();
 444 
 445     /*
 446      * JDK 1.1 serialVersionUID
 447      */
 448     private static final long serialVersionUID = -4206021311591459213L;
 449 
 450     /**
 451      * Gets the peer of this {@code Font}.
 452      *
 453      * @return the peer of the {@code Font}.
 454      */
 455     private FontPeer getFontPeer() {
 456         if(peer == null) {
 457             Toolkit tk = Toolkit.getDefaultToolkit();
 458             if (tk instanceof ComponentFactory) {
 459                 peer = ((ComponentFactory) tk).getFontPeer(name, style);
 460             }
 461         }
 462         return peer;
 463     }
 464 
 465     /**
 466      * Return the AttributeValues object associated with this
 467      * font.  Most of the time, the internal object is null.
 468      * If required, it will be created from the &#39;standard&#39;
 469      * state on the font.  Only non-default values will be
 470      * set in the AttributeValues object.
 471      *
 472      * &lt;p&gt;Since the AttributeValues object is mutable, and it
 473      * is cached in the font, care must be taken to ensure that
 474      * it is not mutated.
 475      */
 476     private AttributeValues getAttributeValues() {
 477         if (values == null) {
 478             AttributeValues valuesTmp = new AttributeValues();
 479             valuesTmp.setFamily(name);
 480             valuesTmp.setSize(pointSize); // expects the float value.
 481 
 482             if ((style &amp; BOLD) != 0) {
 483                 valuesTmp.setWeight(2); // WEIGHT_BOLD
 484             }
 485 
 486             if ((style &amp; ITALIC) != 0) {
 487                 valuesTmp.setPosture(.2f); // POSTURE_OBLIQUE
 488             }
 489             valuesTmp.defineAll(PRIMARY_MASK); // for streaming compatibility
 490             values = valuesTmp;
 491         }
 492 
 493         return values;
 494     }
 495 
 496     private Font2D getFont2D() {
 497         FontManager fm = FontManagerFactory.getInstance();
 498         if (font2DHandle == null) {
 499             font2DHandle =
 500                 fm.findFont2D(name, style,
 501                               FontManager.LOGICAL_FALLBACK).handle;
 502         }
 503         /* Do not cache the de-referenced font2D. It must be explicitly
 504          * de-referenced to pick up a valid font in the event that the
 505          * original one is marked invalid
 506          */
 507         return font2DHandle.font2D;
 508     }
 509 
 510     /**
 511      * Creates a new {@code Font} from the specified name, style and
 512      * point size.
 513      * &lt;p&gt;
 514      * The font name can be a font face name or a font family name.
 515      * It is used together with the style to find an appropriate font face.
 516      * When a font family name is specified, the style argument is used to
 517      * select the most appropriate face from the family. When a font face
 518      * name is specified, the face&#39;s style and the style argument are
 519      * merged to locate the best matching font from the same family.
 520      * For example if face name &quot;Arial Bold&quot; is specified with style
 521      * {@code Font.ITALIC}, the font system looks for a face in the
 522      * &quot;Arial&quot; family that is bold and italic, and may associate the font
 523      * instance with the physical font face &quot;Arial Bold Italic&quot;.
 524      * The style argument is merged with the specified face&#39;s style, not
 525      * added or subtracted.
 526      * This means, specifying a bold face and a bold style does not
 527      * double-embolden the font, and specifying a bold face and a plain
 528      * style does not lighten the font.
 529      * &lt;p&gt;
 530      * If no face for the requested style can be found, the font system
 531      * may apply algorithmic styling to achieve the desired style.
 532      * For example, if {@code ITALIC} is requested, but no italic
 533      * face is available, glyphs from the plain face may be algorithmically
 534      * obliqued (slanted).
 535      * &lt;p&gt;
 536      * Font name lookup is case insensitive, using the case folding
 537      * rules of the US locale.
 538      * &lt;p&gt;
 539      * If the {@code name} parameter represents something other than a
 540      * logical font, i.e. is interpreted as a physical font face or family, and
 541      * this cannot be mapped by the implementation to a physical font or a
 542      * compatible alternative, then the font system will map the Font
 543      * instance to &quot;Dialog&quot;, such that for example, the family as reported
 544      * by {@link #getFamily() getFamily} will be &quot;Dialog&quot;.
 545      *
 546      * @param name the font name.  This can be a font face name or a font
 547      * family name, and may represent either a logical font or a physical
 548      * font found in this {@code GraphicsEnvironment}.
 549      * The family names for logical fonts are: Dialog, DialogInput,
 550      * Monospaced, Serif, or SansSerif. Pre-defined String constants exist
 551      * for all of these names, for example, {@code DIALOG}. If {@code name} is
 552      * {@code null}, the &lt;em&gt;logical font name&lt;/em&gt; of the new
 553      * {@code Font} as returned by {@code getName()} is set to
 554      * the name &quot;Default&quot;.
 555      * @param style the style constant for the {@code Font}
 556      * The style argument is an integer bitmask that may
 557      * be {@code PLAIN}, or a bitwise union of {@code BOLD} and/or
 558      * {@code ITALIC} (for example, {@code ITALIC} or {@code BOLD|ITALIC}).
 559      * If the style argument does not conform to one of the expected
 560      * integer bitmasks then the style is set to {@code PLAIN}.
 561      * @param size the point size of the {@code Font}
 562      * @see GraphicsEnvironment#getAllFonts
 563      * @see GraphicsEnvironment#getAvailableFontFamilyNames
 564      * @since 1.0
 565      */
 566     public Font(String name, int style, int size) {
 567         this.name = (name != null) ? name : &quot;Default&quot;;
 568         this.style = (style &amp; ~0x03) == 0 ? style : 0;
 569         this.size = size;
 570         this.pointSize = size;
 571     }
 572 
 573     private Font(String name, int style, float sizePts) {
 574         this.name = (name != null) ? name : &quot;Default&quot;;
 575         this.style = (style &amp; ~0x03) == 0 ? style : 0;
 576         this.size = (int)(sizePts + 0.5);
 577         this.pointSize = sizePts;
 578     }
 579 
 580     /* This constructor is used by deriveFont when attributes is null */
 581     private Font(String name, int style, float sizePts,
 582                  boolean created, Font2DHandle handle) {
 583         this(name, style, sizePts);
 584         this.createdFont = created;
 585         /* Fonts created from a stream will use the same font2D instance
 586          * as the parent.
 587          * One exception is that if the derived font is requested to be
 588          * in a different style, then also check if its a CompositeFont
 589          * and if so build a new CompositeFont from components of that style.
 590          * CompositeFonts can only be marked as &quot;created&quot; if they are used
 591          * to add fall backs to a physical font. And non-composites are
 592          * always from &quot;Font.createFont()&quot; and shouldn&#39;t get this treatment.
 593          */
 594         if (created) {
 595             if (handle.font2D instanceof CompositeFont &amp;&amp;
 596                 handle.font2D.getStyle() != style) {
 597                 FontManager fm = FontManagerFactory.getInstance();
 598                 this.font2DHandle = fm.getNewComposite(null, style, handle);
 599             } else {
 600                 this.font2DHandle = handle;
 601             }
 602         }
 603     }
 604 
 605     /* used to implement Font.createFont */
 606     private Font(File fontFile, int fontFormat,
 607                  boolean isCopy, CreatedFontTracker tracker)
 608         throws FontFormatException {
 609         this.createdFont = true;
 610         /* Font2D instances created by this method track their font file
 611          * so that when the Font2D is GC&#39;d it can also remove the file.
 612          */
 613         FontManager fm = FontManagerFactory.getInstance();
 614         Font2D[] fonts =
 615             fm.createFont2D(fontFile, fontFormat, false, isCopy, tracker);
 616         this.font2DHandle = fonts[0].handle;
 617         this.name = this.font2DHandle.font2D.getFontName(Locale.getDefault());
 618         this.style = Font.PLAIN;
 619         this.size = 1;
 620         this.pointSize = 1f;
 621     }
 622 
 623     /* This constructor is used when one font is derived from another.
 624      * Fonts created from a stream will use the same font2D instance as the
 625      * parent. They can be distinguished because the &quot;created&quot; argument
 626      * will be &quot;true&quot;. Since there is no way to recreate these fonts they
 627      * need to have the handle to the underlying font2D passed in.
 628      * &quot;created&quot; is also true when a special composite is referenced by the
 629      * handle for essentially the same reasons.
 630      * But when deriving a font in these cases two particular attributes
 631      * need special attention: family/face and style.
 632      * The &quot;composites&quot; in these cases need to be recreated with optimal
 633      * fonts for the new values of family and style.
 634      * For fonts created with createFont() these are treated differently.
 635      * JDK can often synthesise a different style (bold from plain
 636      * for example). For fonts created with &quot;createFont&quot; this is a reasonable
 637      * solution but its also possible (although rare) to derive a font with a
 638      * different family attribute. In this case JDK needs
 639      * to break the tie with the original Font2D and find a new Font.
 640      * The oldName and oldStyle are supplied so they can be compared with
 641      * what the Font2D and the values. To speed things along :
 642      * oldName == null will be interpreted as the name is unchanged.
 643      * oldStyle = -1 will be interpreted as the style is unchanged.
 644      * In these cases there is no need to interrogate &quot;values&quot;.
 645      */
 646     private Font(AttributeValues values, String oldName, int oldStyle,
 647                  boolean created, Font2DHandle handle) {
 648 
 649         this.createdFont = created;
 650         if (created) {
 651             this.font2DHandle = handle;
 652 
 653             String newName = null;
 654             if (oldName != null) {
 655                 newName = values.getFamily();
 656                 if (oldName.equals(newName)) newName = null;
 657             }
 658             int newStyle = 0;
 659             if (oldStyle == -1) {
 660                 newStyle = -1;
 661             } else {
 662                 if (values.getWeight() &gt;= 2f)   newStyle  = BOLD;
 663                 if (values.getPosture() &gt;= .2f) newStyle |= ITALIC;
 664                 if (oldStyle == newStyle)       newStyle  = -1;
 665             }
 666             if (handle.font2D instanceof CompositeFont) {
 667                 if (newStyle != -1 || newName != null) {
 668                     FontManager fm = FontManagerFactory.getInstance();
 669                     this.font2DHandle =
 670                         fm.getNewComposite(newName, newStyle, handle);
 671                 }
 672             } else if (newName != null) {
 673                 this.createdFont = false;
 674                 this.font2DHandle = null;
 675             }
 676         }
 677         initFromValues(values);
 678     }
 679 
 680     /**
 681      * Creates a new {@code Font} with the specified attributes.
 682      * Only keys defined in {@link java.awt.font.TextAttribute TextAttribute}
 683      * are recognized.  In addition the FONT attribute is
 684      *  not recognized by this constructor
 685      * (see {@link #getAvailableAttributes}). Only attributes that have
 686      * values of valid types will affect the new {@code Font}.
 687      * &lt;p&gt;
 688      * If {@code attributes} is {@code null}, a new
 689      * {@code Font} is initialized with default values.
 690      * @see java.awt.font.TextAttribute
 691      * @param attributes the attributes to assign to the new
 692      *          {@code Font}, or {@code null}
 693      */
 694     public Font(Map&lt;? extends Attribute, ?&gt; attributes) {
 695         initFromValues(AttributeValues.fromMap(attributes, RECOGNIZED_MASK));
 696     }
 697 
 698     /**
 699      * Creates a new {@code Font} from the specified {@code font}.
 700      * This constructor is intended for use by subclasses.
 701      * @param font from which to create this {@code Font}.
 702      * @throws NullPointerException if {@code font} is null
 703      * @since 1.6
 704      */
 705     protected Font(Font font) {
 706         if (font.values != null) {
 707             initFromValues(font.getAttributeValues().clone());
 708         } else {
 709             this.name = font.name;
 710             this.style = font.style;
 711             this.size = font.size;
 712             this.pointSize = font.pointSize;
 713         }
 714         this.font2DHandle = font.font2DHandle;
 715         this.createdFont = font.createdFont;
 716     }
 717 
 718     /**
 719      * Font recognizes all attributes except FONT.
 720      */
 721     private static final int RECOGNIZED_MASK = AttributeValues.MASK_ALL
 722         &amp; ~AttributeValues.getMask(EFONT);
 723 
 724     /**
 725      * These attributes are considered primary by the FONT attribute.
 726      */
 727     private static final int PRIMARY_MASK =
 728         AttributeValues.getMask(EFAMILY, EWEIGHT, EWIDTH, EPOSTURE, ESIZE,
 729                                 ETRANSFORM, ESUPERSCRIPT, ETRACKING);
 730 
 731     /**
 732      * These attributes are considered secondary by the FONT attribute.
 733      */
 734     private static final int SECONDARY_MASK =
 735         RECOGNIZED_MASK &amp; ~PRIMARY_MASK;
 736 
 737     /**
 738      * These attributes are handled by layout.
 739      */
 740     private static final int LAYOUT_MASK =
 741         AttributeValues.getMask(ECHAR_REPLACEMENT, EFOREGROUND, EBACKGROUND,
 742                                 EUNDERLINE, ESTRIKETHROUGH, ERUN_DIRECTION,
 743                                 EBIDI_EMBEDDING, EJUSTIFICATION,
 744                                 EINPUT_METHOD_HIGHLIGHT, EINPUT_METHOD_UNDERLINE,
 745                                 ESWAP_COLORS, ENUMERIC_SHAPING, EKERNING,
 746                                 ELIGATURES, ETRACKING, ESUPERSCRIPT);
 747 
 748     private static final int EXTRA_MASK =
 749             AttributeValues.getMask(ETRANSFORM, ESUPERSCRIPT, EWIDTH);
 750 
 751     /**
 752      * Initialize the standard Font fields from the values object.
 753      */
 754     private void initFromValues(AttributeValues values) {
 755         this.values = values;
 756         values.defineAll(PRIMARY_MASK); // for 1.5 streaming compatibility
 757 
 758         this.name = values.getFamily();
 759         this.pointSize = values.getSize();
 760         this.size = (int)(values.getSize() + 0.5);
 761         if (values.getWeight() &gt;= 2f) this.style |= BOLD; // not == 2f
 762         if (values.getPosture() &gt;= .2f) this.style |= ITALIC; // not  == .2f
 763 
 764         this.nonIdentityTx = values.anyNonDefault(EXTRA_MASK);
 765         this.hasLayoutAttributes =  values.anyNonDefault(LAYOUT_MASK);
 766     }
 767 
 768     /**
 769      * Returns true if any part of the specified text is from a
 770      * complex script for which the implementation will need to invoke
 771      * layout processing in order to render correctly when using
 772      * {@link Graphics#drawString(String,int,int) drawString(String,int,int)}
 773      * and other text rendering methods. Measurement of the text
 774      * may similarly need the same extra processing.
 775      * The {@code start} and {@code end} indices are provided so that
 776      * the application can request only a subset of the text be considered.
 777      * The last char index examined is at {@code &quot;end-1&quot;},
 778      * i.e a request to examine the entire array would be
 779      * &lt;pre&gt;
 780      * {@code Font.textRequiresLayout(chars, 0, chars.length);}
 781      * &lt;/pre&gt;
 782      * An application may find this information helpful in
 783      * performance sensitive code.
 784      * &lt;p&gt;
 785      * Note that even if this method returns {@code false}, layout processing
 786      * may still be invoked when used with any {@code Font}
 787      * for which {@link #hasLayoutAttributes()} returns {@code true},
 788      * so that method will need to be consulted for the specific font,
 789      * in order to obtain an answer which accounts for such font attributes.
 790      *
 791      * @param chars the text.
 792      * @param start the index of the first char to examine.
 793      * @param end the ending index, exclusive.
 794      * @return {@code true} if the specified text will need special layout.
 795      * @throws NullPointerException if {@code chars} is null.
 796      * @throws ArrayIndexOutOfBoundsException if {@code start} is negative or
 797      * {@code end} is greater than the length of the {@code chars} array.
 798      * @since 9
 799      */
 800     public static boolean textRequiresLayout(char[] chars,
 801                                              int start, int end) {
 802         if (chars == null) {
 803            throw new NullPointerException(&quot;null char array&quot;);
 804         }
 805         if (start &lt; 0 || end &gt; chars.length) {
 806             throw new ArrayIndexOutOfBoundsException(&quot;start &lt; 0 or end &gt; len&quot;);
 807         }
 808         return FontUtilities.isComplexScript(chars, start, end);
 809     }
 810 
 811     /**
 812      * Returns a {@code Font} appropriate to the attributes.
 813      * If {@code attributes} contains a {@code FONT} attribute
 814      * with a valid {@code Font} as its value, it will be
 815      * merged with any remaining attributes.  See
 816      * {@link java.awt.font.TextAttribute#FONT} for more
 817      * information.
 818      *
 819      * @param attributes the attributes to assign to the new
 820      *          {@code Font}
 821      * @return a new {@code Font} created with the specified
 822      *          attributes
 823      * @throws NullPointerException if {@code attributes} is null.
 824      * @since 1.2
 825      * @see java.awt.font.TextAttribute
 826      */
 827     public static Font getFont(Map&lt;? extends Attribute, ?&gt; attributes) {
 828         // optimize for two cases:
 829         // 1) FONT attribute, and nothing else
 830         // 2) attributes, but no FONT
 831 
 832         // avoid turning the attributemap into a regular map for no reason
 833         if (attributes instanceof AttributeMap &amp;&amp;
 834             ((AttributeMap)attributes).getValues() != null) {
 835             AttributeValues values = ((AttributeMap)attributes).getValues();
 836             if (values.isNonDefault(EFONT)) {
 837                 Font font = values.getFont();
 838                 if (!values.anyDefined(SECONDARY_MASK)) {
 839                     return font;
 840                 }
 841                 // merge
 842                 values = font.getAttributeValues().clone();
 843                 values.merge(attributes, SECONDARY_MASK);
 844                 return new Font(values, font.name, font.style,
 845                                 font.createdFont, font.font2DHandle);
 846             }
 847             return new Font(attributes);
 848         }
 849 
 850         Font font = (Font)attributes.get(TextAttribute.FONT);
 851         if (font != null) {
 852             if (attributes.size() &gt; 1) { // oh well, check for anything else
 853                 AttributeValues values = font.getAttributeValues().clone();
 854                 values.merge(attributes, SECONDARY_MASK);
 855                 return new Font(values, font.name, font.style,
 856                                 font.createdFont, font.font2DHandle);
 857             }
 858 
 859             return font;
 860         }
 861 
 862         return new Font(attributes);
 863     }
 864 
 865     /**
 866      * Used with the byte count tracker for fonts created from streams.
 867      * If a thread can create temp files anyway, no point in counting
 868      * font bytes.
 869      */
 870     private static boolean hasTempPermission() {
 871 
 872         if (System.getSecurityManager() == null) {
 873             return true;
 874         }
 875         File f = null;
 876         boolean hasPerm = false;
 877         try {
 878             f = Files.createTempFile(&quot;+~JT&quot;, &quot;.tmp&quot;).toFile();
 879             f.delete();
 880             f = null;
 881             hasPerm = true;
 882         } catch (Throwable t) {
 883             /* inc. any kind of SecurityException */
 884         }
 885         return hasPerm;
 886     }
 887 
 888 
 889     /**
 890      * Returns a new array of {@code Font} decoded from the specified stream.
 891      * The returned {@code Font[]} will have at least one element.
 892      * &lt;p&gt;
 893      * The explicit purpose of this variation on the
 894      * {@code createFont(int, InputStream)} method is to support font
 895      * sources which represent a TrueType/OpenType font collection and
 896      * be able to return all individual fonts in that collection.
 897      * Consequently this method will throw {@code FontFormatException}
 898      * if the data source does not contain at least one TrueType/OpenType
 899      * font. The same exception will also be thrown if any of the fonts in
 900      * the collection does not contain the required font tables.
 901      * &lt;p&gt;
 902      * The condition &quot;at least one&quot;, allows for the stream to represent
 903      * a single OpenType/TrueType font. That is, it does not have to be
 904      * a collection.
 905      * Each {@code Font} element of the returned array is
 906      * created with a point size of 1 and style {@link #PLAIN PLAIN}.
 907      * This base font can then be used with the {@code deriveFont}
 908      * methods in this class to derive new {@code Font} objects with
 909      * varying sizes, styles, transforms and font features.
 910      * &lt;p&gt;This method does not close the {@link InputStream}.
 911      * &lt;p&gt;
 912      * To make each {@code Font} available to Font constructors it
 913      * must be registered in the {@code GraphicsEnvironment} by calling
 914      * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.
 915      * @param fontStream an {@code InputStream} object representing the
 916      * input data for the font or font collection.
 917      * @return a new {@code Font[]}.
 918      * @throws FontFormatException if the {@code fontStream} data does
 919      *     not contain the required font tables for any of the elements of
 920      *     the collection, or if it contains no fonts at all.
 921      * @throws IOException if the {@code fontStream} cannot be completely read.
 922      * @see GraphicsEnvironment#registerFont(Font)
 923      * @since 9
 924      */
 925     public static Font[] createFonts(InputStream fontStream)
 926         throws FontFormatException, IOException {
 927 
 928         final int fontFormat = Font.TRUETYPE_FONT;
 929         if (hasTempPermission()) {
 930             return createFont0(fontFormat, fontStream, true, null);
 931         }
 932 
 933         // Otherwise, be extra conscious of pending temp file creation and
 934         // resourcefully handle the temp file resources, among other things.
 935         CreatedFontTracker tracker = CreatedFontTracker.getTracker();
 936         boolean acquired = false;
 937         try {
 938             acquired = tracker.acquirePermit();
 939             if (!acquired) {
 940                 throw new IOException(&quot;Timed out waiting for resources.&quot;);
 941             }
 942             return createFont0(fontFormat, fontStream, true, tracker);
 943         } catch (InterruptedException e) {
 944             throw new IOException(&quot;Problem reading font data.&quot;);
 945         } finally {
 946             if (acquired) {
 947                 tracker.releasePermit();
 948             }
 949         }
 950     }
 951 
 952     /* used to implement Font.createFont */
 953     private Font(Font2D font2D) {
 954 
 955         this.createdFont = true;
 956         this.font2DHandle = font2D.handle;
 957         this.name = font2D.getFontName(Locale.getDefault());
 958         this.style = Font.PLAIN;
 959         this.size = 1;
 960         this.pointSize = 1f;
 961     }
 962 
 963     /**
 964      * Returns a new array of {@code Font} decoded from the specified file.
 965      * The returned {@code Font[]} will have at least one element.
 966      * &lt;p&gt;
 967      * The explicit purpose of this variation on the
 968      * {@code createFont(int, File)} method is to support font
 969      * sources which represent a TrueType/OpenType font collection and
 970      * be able to return all individual fonts in that collection.
 971      * Consequently this method will throw {@code FontFormatException}
 972      * if the data source does not contain at least one TrueType/OpenType
 973      * font. The same exception will also be thrown if any of the fonts in
 974      * the collection does not contain the required font tables.
 975      * &lt;p&gt;
 976      * The condition &quot;at least one&quot;, allows for the stream to represent
 977      * a single OpenType/TrueType font. That is, it does not have to be
 978      * a collection.
 979      * Each {@code Font} element of the returned array is
 980      * created with a point size of 1 and style {@link #PLAIN PLAIN}.
 981      * This base font can then be used with the {@code deriveFont}
 982      * methods in this class to derive new {@code Font} objects with
 983      * varying sizes, styles, transforms and font features.
 984      * &lt;p&gt;
 985      * To make each {@code Font} available to Font constructors it
 986      * must be registered in the {@code GraphicsEnvironment} by calling
 987      * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.
 988      * @param fontFile a {@code File} object containing the
 989      * input data for the font or font collection.
 990      * @return a new {@code Font[]}.
 991      * @throws FontFormatException if the {@code File} does
 992      *     not contain the required font tables for any of the elements of
 993      *     the collection, or if it contains no fonts at all.
 994      * @throws IOException if the {@code fontFile} cannot be read.
 995      * @see GraphicsEnvironment#registerFont(Font)
 996      * @since 9
 997      */
 998     public static Font[] createFonts(File fontFile)
 999             throws FontFormatException, IOException
1000     {
1001         int fontFormat = Font.TRUETYPE_FONT;
1002         fontFile = checkFontFile(fontFormat, fontFile);
1003         FontManager fm = FontManagerFactory.getInstance();
1004         Font2D[] font2DArr =
1005             fm.createFont2D(fontFile, fontFormat, true, false, null);
1006         int num = font2DArr.length;
1007         Font[] fonts = new Font[num];
1008         for (int i = 0; i &lt; num; i++) {
1009            fonts[i] = new Font(font2DArr[i]);
1010         }
1011         return fonts;
1012     }
1013 
1014     /**
1015      * Returns a new {@code Font} using the specified font type
1016      * and input data.  The new {@code Font} is
1017      * created with a point size of 1 and style {@link #PLAIN PLAIN}.
1018      * This base font can then be used with the {@code deriveFont}
1019      * methods in this class to derive new {@code Font} objects with
1020      * varying sizes, styles, transforms and font features.  This
1021      * method does not close the {@link InputStream}.
1022      * &lt;p&gt;
1023      * To make the {@code Font} available to Font constructors the
1024      * returned {@code Font} must be registered in the
1025      * {@code GraphicsEnvironment} by calling
1026      * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.
1027      * @param fontFormat the type of the {@code Font}, which is
1028      * {@link #TRUETYPE_FONT TRUETYPE_FONT} if a TrueType resource is specified.
1029      * or {@link #TYPE1_FONT TYPE1_FONT} if a Type 1 resource is specified.
1030      * @param fontStream an {@code InputStream} object representing the
1031      * input data for the font.
1032      * @return a new {@code Font} created with the specified font type.
1033      * @throws IllegalArgumentException if {@code fontFormat} is not
1034      *     {@code TRUETYPE_FONT} or {@code TYPE1_FONT}.
1035      * @throws FontFormatException if the {@code fontStream} data does
1036      *     not contain the required font tables for the specified format.
1037      * @throws IOException if the {@code fontStream}
1038      *     cannot be completely read.
1039      * @see GraphicsEnvironment#registerFont(Font)
1040      * @since 1.3
1041      */
1042     public static Font createFont(int fontFormat, InputStream fontStream)
1043         throws java.awt.FontFormatException, java.io.IOException {
1044 
1045         if (hasTempPermission()) {
1046             return createFont0(fontFormat, fontStream, false, null)[0];
1047         }
1048 
1049         // Otherwise, be extra conscious of pending temp file creation and
1050         // resourcefully handle the temp file resources, among other things.
1051         CreatedFontTracker tracker = CreatedFontTracker.getTracker();
1052         boolean acquired = false;
1053         try {
1054             acquired = tracker.acquirePermit();
1055             if (!acquired) {
1056                 throw new IOException(&quot;Timed out waiting for resources.&quot;);
1057             }
1058             return createFont0(fontFormat, fontStream, false, tracker)[0];
1059         } catch (InterruptedException e) {
1060             throw new IOException(&quot;Problem reading font data.&quot;);
1061         } finally {
1062             if (acquired) {
1063                 tracker.releasePermit();
1064             }
1065         }
1066     }
1067 
1068     private static Font[] createFont0(int fontFormat, InputStream fontStream,
1069                                       boolean allFonts,
1070                                       CreatedFontTracker tracker)
1071         throws java.awt.FontFormatException, java.io.IOException {
1072 
1073         if (fontFormat != Font.TRUETYPE_FONT &amp;&amp;
1074             fontFormat != Font.TYPE1_FONT) {
1075             throw new IllegalArgumentException (&quot;font format not recognized&quot;);
1076         }
1077         boolean copiedFontData = false;
1078         try {
1079             final File tFile = AccessController.doPrivileged(
1080                 new PrivilegedExceptionAction&lt;File&gt;() {
1081                     public File run() throws IOException {
1082                         return Files.createTempFile(&quot;+~JF&quot;, &quot;.tmp&quot;).toFile();
1083                     }
1084                 }
1085             );
1086             if (tracker != null) {
1087                 tracker.add(tFile);
1088             }
1089 
1090             int totalSize = 0;
1091             try {
1092                 final OutputStream outStream =
1093                     AccessController.doPrivileged(
1094                         new PrivilegedExceptionAction&lt;OutputStream&gt;() {
1095                             public OutputStream run() throws IOException {
1096                                 return new FileOutputStream(tFile);
1097                             }
1098                         }
1099                     );
1100                 if (tracker != null) {
1101                     tracker.set(tFile, outStream);
1102                 }
1103                 try {
1104                     byte[] buf = new byte[8192];
1105                     for (;;) {
1106                         int bytesRead = fontStream.read(buf);
1107                         if (bytesRead &lt; 0) {
1108                             break;
1109                         }
1110                         if (tracker != null) {
1111                             if (totalSize+bytesRead &gt; CreatedFontTracker.MAX_FILE_SIZE) {
1112                                 throw new IOException(&quot;File too big.&quot;);
1113                             }
1114                             if (totalSize+tracker.getNumBytes() &gt;
1115                                 CreatedFontTracker.MAX_TOTAL_BYTES)
1116                               {
1117                                 throw new IOException(&quot;Total files too big.&quot;);
1118                             }
1119                             totalSize += bytesRead;
1120                             tracker.addBytes(bytesRead);
1121                         }
1122                         outStream.write(buf, 0, bytesRead);
1123                     }
1124                     /* don&#39;t close the input stream */
1125                 } finally {
1126                     outStream.close();
1127                 }
1128                 /* After all references to a Font2D are dropped, the file
1129                  * will be removed. To support long-lived AppContexts,
1130                  * we need to then decrement the byte count by the size
1131                  * of the file.
1132                  * If the data isn&#39;t a valid font, the implementation will
1133                  * delete the tmp file and decrement the byte count
1134                  * in the tracker object before returning from the
1135                  * constructor, so we can set &#39;copiedFontData&#39; to true here
1136                  * without waiting for the results of that constructor.
1137                  */
1138                 copiedFontData = true;
1139                 FontManager fm = FontManagerFactory.getInstance();
1140                  Font2D[] font2DArr =
1141                     fm.createFont2D(tFile, fontFormat, allFonts, true, tracker);
1142                 int num = font2DArr.length;
1143                 Font[] fonts = new Font[num];
1144                 for (int i = 0; i &lt; num; i++) {
1145                    fonts[i] = new Font(font2DArr[i]);
1146                 }
1147                 return fonts;
1148             } finally {
1149                 if (tracker != null) {
1150                     tracker.remove(tFile);
1151                 }
1152                 if (!copiedFontData) {
1153                     if (tracker != null) {
1154                         tracker.subBytes(totalSize);
1155                     }
1156                     AccessController.doPrivileged(
1157                         new PrivilegedExceptionAction&lt;Void&gt;() {
1158                             public Void run() {
1159                                 tFile.delete();
1160                                 return null;
1161                             }
1162                         }
1163                     );
1164                 }
1165             }
1166         } catch (Throwable t) {
1167             if (t instanceof FontFormatException) {
1168                 throw (FontFormatException)t;
1169             }
1170             if (t instanceof IOException) {
1171                 throw (IOException)t;
1172             }
1173             Throwable cause = t.getCause();
1174             if (cause instanceof FontFormatException) {
1175                 throw (FontFormatException)cause;
1176             }
1177             throw new IOException(&quot;Problem reading font data.&quot;);
1178         }
1179     }
1180 
1181     /**
1182      * Returns a new {@code Font} using the specified font type
1183      * and the specified font file.  The new {@code Font} is
1184      * created with a point size of 1 and style {@link #PLAIN PLAIN}.
1185      * This base font can then be used with the {@code deriveFont}
1186      * methods in this class to derive new {@code Font} objects with
1187      * varying sizes, styles, transforms and font features.
1188      * @param fontFormat the type of the {@code Font}, which is
1189      * {@link #TRUETYPE_FONT TRUETYPE_FONT} if a TrueType resource is
1190      * specified or {@link #TYPE1_FONT TYPE1_FONT} if a Type 1 resource is
1191      * specified.
1192      * So long as the returned font, or its derived fonts are referenced
1193      * the implementation may continue to access {@code fontFile}
1194      * to retrieve font data. Thus the results are undefined if the file
1195      * is changed, or becomes inaccessible.
1196      * &lt;p&gt;
1197      * To make the {@code Font} available to Font constructors the
1198      * returned {@code Font} must be registered in the
1199      * {@code GraphicsEnvironment} by calling
1200      * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.
1201      * @param fontFile a {@code File} object representing the
1202      * input data for the font.
1203      * @return a new {@code Font} created with the specified font type.
1204      * @throws IllegalArgumentException if {@code fontFormat} is not
1205      *     {@code TRUETYPE_FONT} or {@code TYPE1_FONT}.
1206      * @throws NullPointerException if {@code fontFile} is null.
1207      * @throws IOException if the {@code fontFile} cannot be read.
1208      * @throws FontFormatException if {@code fontFile} does
1209      *     not contain the required font tables for the specified format.
1210      * @throws SecurityException if the executing code does not have
1211      * permission to read from the file.
1212      * @see GraphicsEnvironment#registerFont(Font)
1213      * @since 1.5
1214      */
1215     public static Font createFont(int fontFormat, File fontFile)
1216         throws java.awt.FontFormatException, java.io.IOException {
1217 
1218         fontFile = checkFontFile(fontFormat, fontFile);
1219         return new Font(fontFile, fontFormat, false, null);
1220     }
1221 
1222     private static File checkFontFile(int fontFormat, File fontFile)
1223         throws FontFormatException, IOException {
1224 
1225         fontFile = new File(fontFile.getPath());
1226 
1227         if (fontFormat != Font.TRUETYPE_FONT &amp;&amp;
1228             fontFormat != Font.TYPE1_FONT) {
1229             throw new IllegalArgumentException (&quot;font format not recognized&quot;);
1230         }
1231         SecurityManager sm = System.getSecurityManager();
1232         if (sm != null) {
1233             FilePermission filePermission =
1234                 new FilePermission(fontFile.getPath(), &quot;read&quot;);
1235             sm.checkPermission(filePermission);
1236         }
1237         if (!fontFile.canRead()) {
1238             throw new IOException(&quot;Can&#39;t read &quot; + fontFile);
1239         }
1240         return fontFile;
1241     }
1242 
1243     /**
1244      * Returns a copy of the transform associated with this
1245      * {@code Font}.  This transform is not necessarily the one
1246      * used to construct the font.  If the font has algorithmic
1247      * superscripting or width adjustment, this will be incorporated
1248      * into the returned {@code AffineTransform}.
1249      * &lt;p&gt;
1250      * Typically, fonts will not be transformed.  Clients generally
1251      * should call {@link #isTransformed} first, and only call this
1252      * method if {@code isTransformed} returns true.
1253      *
1254      * @return an {@link AffineTransform} object representing the
1255      *          transform attribute of this {@code Font} object.
1256      */
1257     public AffineTransform getTransform() {
1258         /* The most common case is the identity transform.  Most callers
1259          * should call isTransformed() first, to decide if they need to
1260          * get the transform, but some may not.  Here we check to see
1261          * if we have a nonidentity transform, and only do the work to
1262          * fetch and/or compute it if so, otherwise we return a new
1263          * identity transform.
1264          *
1265          * Note that the transform is _not_ necessarily the same as
1266          * the transform passed in as an Attribute in a Map, as the
1267          * transform returned will also reflect the effects of WIDTH and
1268          * SUPERSCRIPT attributes.  Clients who want the actual transform
1269          * need to call getRequestedAttributes.
1270          */
1271         if (nonIdentityTx) {
1272             AttributeValues values = getAttributeValues();
1273 
1274             AffineTransform at = values.isNonDefault(ETRANSFORM)
1275                 ? new AffineTransform(values.getTransform())
1276                 : new AffineTransform();
1277 
1278             if (values.getSuperscript() != 0) {
1279                 // can&#39;t get ascent and descent here, recursive call to this fn,
1280                 // so use pointsize
1281                 // let users combine super- and sub-scripting
1282 
1283                 int superscript = values.getSuperscript();
1284 
1285                 double trans = 0;
1286                 int n = 0;
1287                 boolean up = superscript &gt; 0;
1288                 int sign = up ? -1 : 1;
1289                 int ss = up ? superscript : -superscript;
1290 
1291                 while ((ss &amp; 7) &gt; n) {
1292                     int newn = ss &amp; 7;
1293                     trans += sign * (ssinfo[newn] - ssinfo[n]);
1294                     ss &gt;&gt;= 3;
1295                     sign = -sign;
1296                     n = newn;
1297                 }
1298                 trans *= pointSize;
1299                 double scale = Math.pow(2./3., n);
1300 
1301                 at.preConcatenate(AffineTransform.getTranslateInstance(0, trans));
1302                 at.scale(scale, scale);
1303 
1304                 // note on placement and italics
1305                 // We preconcatenate the transform because we don&#39;t want to translate along
1306                 // the italic angle, but purely perpendicular to the baseline.  While this
1307                 // looks ok for superscripts, it can lead subscripts to stack on each other
1308                 // and bring the following text too close.  The way we deal with potential
1309                 // collisions that can occur in the case of italics is by adjusting the
1310                 // horizontal spacing of the adjacent glyphvectors.  Examine the italic
1311                 // angle of both vectors, if one is non-zero, compute the minimum ascent
1312                 // and descent, and then the x position at each for each vector along its
1313                 // italic angle starting from its (offset) baseline.  Compute the difference
1314                 // between the x positions and use the maximum difference to adjust the
1315                 // position of the right gv.
1316             }
1317 
1318             if (values.isNonDefault(EWIDTH)) {
1319                 at.scale(values.getWidth(), 1f);
1320             }
1321 
1322             return at;
1323         }
1324 
1325         return new AffineTransform();
1326     }
1327 
1328     // x = r^0 + r^1 + r^2... r^n
1329     // rx = r^1 + r^2 + r^3... r^(n+1)
1330     // x - rx = r^0 - r^(n+1)
1331     // x (1 - r) = r^0 - r^(n+1)
1332     // x = (r^0 - r^(n+1)) / (1 - r)
1333     // x = (1 - r^(n+1)) / (1 - r)
1334 
1335     // scale ratio is 2/3
1336     // trans = 1/2 of ascent * x
1337     // assume ascent is 3/4 of point size
1338 
1339     private static final float[] ssinfo = {
1340         0.0f,
1341         0.375f,
1342         0.625f,
1343         0.7916667f,
1344         0.9027778f,
1345         0.9768519f,
1346         1.0262346f,
1347         1.0591564f,
1348     };
1349 
1350     /**
1351      * Returns the family name of this {@code Font}.
1352      *
1353      * &lt;p&gt;The family name of a font is font specific. Two fonts such as
1354      * Helvetica Italic and Helvetica Bold have the same family name,
1355      * &lt;i&gt;Helvetica&lt;/i&gt;, whereas their font face names are
1356      * &lt;i&gt;Helvetica Bold&lt;/i&gt; and &lt;i&gt;Helvetica Italic&lt;/i&gt;. The list of
1357      * available family names may be obtained by using the
1358      * {@link GraphicsEnvironment#getAvailableFontFamilyNames()} method.
1359      *
1360      * &lt;p&gt;Use {@code getName} to get the logical name of the font.
1361      * Use {@code getFontName} to get the font face name of the font.
1362      * @return a {@code String} that is the family name of this
1363      *          {@code Font}.
1364      *
1365      * @see #getName
1366      * @see #getFontName
1367      * @since 1.1
1368      */
1369     public String getFamily() {
1370         return getFamily_NoClientCode();
1371     }
1372     // NOTE: This method is called by privileged threads.
1373     //       We implement this functionality in a package-private
1374     //       method to insure that it cannot be overridden by client
1375     //       subclasses.
1376     //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
1377     final String getFamily_NoClientCode() {
1378         return getFamily(Locale.getDefault());
1379     }
1380 
1381     /**
1382      * Returns the family name of this {@code Font}, localized for
1383      * the specified locale.
1384      *
1385      * &lt;p&gt;The family name of a font is font specific. Two fonts such as
1386      * Helvetica Italic and Helvetica Bold have the same family name,
1387      * &lt;i&gt;Helvetica&lt;/i&gt;, whereas their font face names are
1388      * &lt;i&gt;Helvetica Bold&lt;/i&gt; and &lt;i&gt;Helvetica Italic&lt;/i&gt;. The list of
1389      * available family names may be obtained by using the
1390      * {@link GraphicsEnvironment#getAvailableFontFamilyNames()} method.
1391      *
1392      * &lt;p&gt;Use {@code getFontName} to get the font face name of the font.
1393      * @param l locale for which to get the family name
1394      * @return a {@code String} representing the family name of the
1395      *          font, localized for the specified locale.
1396      * @see #getFontName
1397      * @see java.util.Locale
1398      * @since 1.2
1399      */
1400     public String getFamily(Locale l) {
1401         if (l == null) {
1402             throw new NullPointerException(&quot;null locale doesn&#39;t mean default&quot;);
1403         }
1404         return getFont2D().getFamilyName(l);
1405     }
1406 
1407     /**
1408      * Returns the postscript name of this {@code Font}.
1409      * Use {@code getFamily} to get the family name of the font.
1410      * Use {@code getFontName} to get the font face name of the font.
1411      * @return a {@code String} representing the postscript name of
1412      *          this {@code Font}.
1413      * @since 1.2
1414      */
1415     public String getPSName() {
1416         return getFont2D().getPostscriptName();
1417     }
1418 
1419     /**
1420      * Returns the logical name of this {@code Font}.
1421      * Use {@code getFamily} to get the family name of the font.
1422      * Use {@code getFontName} to get the font face name of the font.
1423      * @return a {@code String} representing the logical name of
1424      *          this {@code Font}.
1425      * @see #getFamily
1426      * @see #getFontName
1427      * @since 1.0
1428      */
1429     public String getName() {
1430         return name;
1431     }
1432 
1433     /**
1434      * Returns the font face name of this {@code Font}.  For example,
1435      * Helvetica Bold could be returned as a font face name.
1436      * Use {@code getFamily} to get the family name of the font.
1437      * Use {@code getName} to get the logical name of the font.
1438      * @return a {@code String} representing the font face name of
1439      *          this {@code Font}.
1440      * @see #getFamily
1441      * @see #getName
1442      * @since 1.2
1443      */
1444     public String getFontName() {
1445       return getFontName(Locale.getDefault());
1446     }
1447 
1448     /**
1449      * Returns the font face name of the {@code Font}, localized
1450      * for the specified locale. For example, Helvetica Fett could be
1451      * returned as the font face name.
1452      * Use {@code getFamily} to get the family name of the font.
1453      * @param l a locale for which to get the font face name
1454      * @return a {@code String} representing the font face name,
1455      *          localized for the specified locale.
1456      * @see #getFamily
1457      * @see java.util.Locale
1458      */
1459     public String getFontName(Locale l) {
1460         if (l == null) {
1461             throw new NullPointerException(&quot;null locale doesn&#39;t mean default&quot;);
1462         }
1463         return getFont2D().getFontName(l);
1464     }
1465 
1466     /**
1467      * Returns the style of this {@code Font}.  The style can be
1468      * PLAIN, BOLD, ITALIC, or BOLD+ITALIC.
1469      * @return the style of this {@code Font}
1470      * @see #isPlain
1471      * @see #isBold
1472      * @see #isItalic
1473      * @since 1.0
1474      */
1475     public int getStyle() {
1476         return style;
1477     }
1478 
1479     /**
1480      * Returns the point size of this {@code Font}, rounded to
1481      * an integer.
1482      * Most users are familiar with the idea of using &lt;i&gt;point size&lt;/i&gt; to
1483      * specify the size of glyphs in a font. This point size defines a
1484      * measurement between the baseline of one line to the baseline of the
1485      * following line in a single spaced text document. The point size is
1486      * based on &lt;i&gt;typographic points&lt;/i&gt;, approximately 1/72 of an inch.
1487      * &lt;p&gt;
1488      * The Java(tm)2D API adopts the convention that one point is
1489      * equivalent to one unit in user coordinates.  When using a
1490      * normalized transform for converting user space coordinates to
1491      * device space coordinates 72 user
1492      * space units equal 1 inch in device space.  In this case one point
1493      * is 1/72 of an inch.
1494      * @return the point size of this {@code Font} in 1/72 of an
1495      *          inch units.
1496      * @see #getSize2D
1497      * @see GraphicsConfiguration#getDefaultTransform
1498      * @see GraphicsConfiguration#getNormalizingTransform
1499      * @since 1.0
1500      */
1501     public int getSize() {
1502         return size;
1503     }
1504 
1505     /**
1506      * Returns the point size of this {@code Font} in
1507      * {@code float} value.
1508      * @return the point size of this {@code Font} as a
1509      * {@code float} value.
1510      * @see #getSize
1511      * @since 1.2
1512      */
1513     public float getSize2D() {
1514         return pointSize;
1515     }
1516 
1517     /**
1518      * Indicates whether or not this {@code Font} object&#39;s style is
1519      * PLAIN.
1520      * @return    {@code true} if this {@code Font} has a
1521      *            PLAIN style;
1522      *            {@code false} otherwise.
1523      * @see       java.awt.Font#getStyle
1524      * @since     1.0
1525      */
1526     public boolean isPlain() {
1527         return style == 0;
1528     }
1529 
1530     /**
1531      * Indicates whether or not this {@code Font} object&#39;s style is
1532      * BOLD.
1533      * @return    {@code true} if this {@code Font} object&#39;s
1534      *            style is BOLD;
1535      *            {@code false} otherwise.
1536      * @see       java.awt.Font#getStyle
1537      * @since     1.0
1538      */
1539     public boolean isBold() {
1540         return (style &amp; BOLD) != 0;
1541     }
1542 
1543     /**
1544      * Indicates whether or not this {@code Font} object&#39;s style is
1545      * ITALIC.
1546      * @return    {@code true} if this {@code Font} object&#39;s
1547      *            style is ITALIC;
1548      *            {@code false} otherwise.
1549      * @see       java.awt.Font#getStyle
1550      * @since     1.0
1551      */
1552     public boolean isItalic() {
1553         return (style &amp; ITALIC) != 0;
1554     }
1555 
1556     /**
1557      * Indicates whether or not this {@code Font} object has a
1558      * transform that affects its size in addition to the Size
1559      * attribute.
1560      * @return  {@code true} if this {@code Font} object
1561      *          has a non-identity AffineTransform attribute.
1562      *          {@code false} otherwise.
1563      * @see     java.awt.Font#getTransform
1564      * @since   1.4
1565      */
1566     public boolean isTransformed() {
1567         return nonIdentityTx;
1568     }
1569 
1570     /**
1571      * Return true if this Font contains attributes that require extra
1572      * layout processing.
1573      * @return true if the font has layout attributes
1574      * @since 1.6
1575      */
1576     public boolean hasLayoutAttributes() {
1577         return hasLayoutAttributes;
1578     }
1579 
1580     /**
1581      * Returns a {@code Font} object from the system properties list.
1582      * {@code nm} is treated as the name of a system property to be
1583      * obtained.  The {@code String} value of this property is then
1584      * interpreted as a {@code Font} object according to the
1585      * specification of {@code Font.decode(String)}
1586      * If the specified property is not found, or the executing code does
1587      * not have permission to read the property, null is returned instead.
1588      *
1589      * @param nm the property name
1590      * @return a {@code Font} object that the property name
1591      *          describes, or null if no such property exists.
1592      * @throws NullPointerException if nm is null.
1593      * @since 1.2
1594      * @see #decode(String)
1595      */
1596     public static Font getFont(String nm) {
1597         return getFont(nm, null);
1598     }
1599 
1600     /**
1601      * Returns the {@code Font} that the {@code str}
1602      * argument describes.
1603      * To ensure that this method returns the desired Font,
1604      * format the {@code str} parameter in
1605      * one of these ways
1606      *
1607      * &lt;ul&gt;
1608      * &lt;li&gt;&lt;em&gt;fontname-style-pointsize&lt;/em&gt;
1609      * &lt;li&gt;&lt;em&gt;fontname-pointsize&lt;/em&gt;
1610      * &lt;li&gt;&lt;em&gt;fontname-style&lt;/em&gt;
1611      * &lt;li&gt;&lt;em&gt;fontname&lt;/em&gt;
1612      * &lt;li&gt;&lt;em&gt;fontname style pointsize&lt;/em&gt;
1613      * &lt;li&gt;&lt;em&gt;fontname pointsize&lt;/em&gt;
1614      * &lt;li&gt;&lt;em&gt;fontname style&lt;/em&gt;
1615      * &lt;li&gt;&lt;em&gt;fontname&lt;/em&gt;
1616      * &lt;/ul&gt;
1617      * in which &lt;i&gt;style&lt;/i&gt; is one of the four
1618      * case-insensitive strings:
1619      * {@code &quot;PLAIN&quot;}, {@code &quot;BOLD&quot;}, {@code &quot;BOLDITALIC&quot;}, or
1620      * {@code &quot;ITALIC&quot;}, and pointsize is a positive decimal integer
1621      * representation of the point size.
1622      * For example, if you want a font that is Arial, bold, with
1623      * a point size of 18, you would call this method with:
1624      * &quot;Arial-BOLD-18&quot;.
1625      * This is equivalent to calling the Font constructor :
1626      * {@code new Font(&quot;Arial&quot;, Font.BOLD, 18);}
1627      * and the values are interpreted as specified by that constructor.
1628      * &lt;p&gt;
1629      * A valid trailing decimal field is always interpreted as the pointsize.
1630      * Therefore a fontname containing a trailing decimal value should not
1631      * be used in the fontname only form.
1632      * &lt;p&gt;
1633      * If a style name field is not one of the valid style strings, it is
1634      * interpreted as part of the font name, and the default style is used.
1635      * &lt;p&gt;
1636      * Only one of &#39; &#39; or &#39;-&#39; may be used to separate fields in the input.
1637      * The identified separator is the one closest to the end of the string
1638      * which separates a valid pointsize, or a valid style name from
1639      * the rest of the string.
1640      * Null (empty) pointsize and style fields are treated
1641      * as valid fields with the default value for that field.
1642      *&lt;p&gt;
1643      * Some font names may include the separator characters &#39; &#39; or &#39;-&#39;.
1644      * If {@code str} is not formed with 3 components, e.g. such that
1645      * {@code style} or {@code pointsize} fields are not present in
1646      * {@code str}, and {@code fontname} also contains a
1647      * character determined to be the separator character
1648      * then these characters where they appear as intended to be part of
1649      * {@code fontname} may instead be interpreted as separators
1650      * so the font name may not be properly recognised.
1651      *
1652      * &lt;p&gt;
1653      * The default size is 12 and the default style is PLAIN.
1654      * If {@code str} does not specify a valid size, the returned
1655      * {@code Font} has a size of 12.  If {@code str} does not
1656      * specify a valid style, the returned Font has a style of PLAIN.
1657      * If you do not specify a valid font name in
1658      * the {@code str} argument, this method will return
1659      * a font with the family name &quot;Dialog&quot;.
1660      * To determine what font family names are available on
1661      * your system, use the
1662      * {@link GraphicsEnvironment#getAvailableFontFamilyNames()} method.
1663      * If {@code str} is {@code null}, a new {@code Font}
1664      * is returned with the family name &quot;Dialog&quot;, a size of 12 and a
1665      * PLAIN style.
1666      * @param str the name of the font, or {@code null}
1667      * @return the {@code Font} object that {@code str}
1668      *          describes, or a new default {@code Font} if
1669      *          {@code str} is {@code null}.
1670      * @see #getFamily
1671      * @since 1.1
1672      */
1673     public static Font decode(String str) {
1674         String fontName = str;
1675         String styleName = &quot;&quot;;
1676         int fontSize = 12;
1677         int fontStyle = Font.PLAIN;
1678 
1679         if (str == null) {
1680             return new Font(DIALOG, fontStyle, fontSize);
1681         }
1682 
1683         int lastHyphen = str.lastIndexOf(&#39;-&#39;);
1684         int lastSpace = str.lastIndexOf(&#39; &#39;);
1685         char sepChar = (lastHyphen &gt; lastSpace) ? &#39;-&#39; : &#39; &#39;;
1686         int sizeIndex = str.lastIndexOf(sepChar);
1687         int styleIndex = str.lastIndexOf(sepChar, sizeIndex-1);
1688         int strlen = str.length();
1689 
1690         if (sizeIndex &gt; 0 &amp;&amp; sizeIndex+1 &lt; strlen) {
1691             try {
1692                 fontSize =
1693                     Integer.valueOf(str.substring(sizeIndex+1)).intValue();
1694                 if (fontSize &lt;= 0) {
1695                     fontSize = 12;
1696                 }
1697             } catch (NumberFormatException e) {
1698                 /* It wasn&#39;t a valid size, if we didn&#39;t also find the
1699                  * start of the style string perhaps this is the style */
1700                 styleIndex = sizeIndex;
1701                 sizeIndex = strlen;
1702                 if (str.charAt(sizeIndex-1) == sepChar) {
1703                     sizeIndex--;
1704                 }
1705             }
1706         }
1707 
1708         if (styleIndex &gt;= 0 &amp;&amp; styleIndex+1 &lt; strlen) {
1709             styleName = str.substring(styleIndex+1, sizeIndex);
1710             styleName = styleName.toLowerCase(Locale.ENGLISH);
1711             if (styleName.equals(&quot;bolditalic&quot;)) {
1712                 fontStyle = Font.BOLD | Font.ITALIC;
1713             } else if (styleName.equals(&quot;italic&quot;)) {
1714                 fontStyle = Font.ITALIC;
1715             } else if (styleName.equals(&quot;bold&quot;)) {
1716                 fontStyle = Font.BOLD;
1717             } else if (styleName.equals(&quot;plain&quot;)) {
1718                 fontStyle = Font.PLAIN;
1719             } else {
1720                 /* this string isn&#39;t any of the expected styles, so
1721                  * assume its part of the font name
1722                  */
1723                 styleIndex = sizeIndex;
1724                 if (str.charAt(styleIndex-1) == sepChar) {
1725                     styleIndex--;
1726                 }
1727             }
1728             fontName = str.substring(0, styleIndex);
1729 
1730         } else {
1731             int fontEnd = strlen;
1732             if (styleIndex &gt; 0) {
1733                 fontEnd = styleIndex;
1734             } else if (sizeIndex &gt; 0) {
1735                 fontEnd = sizeIndex;
1736             }
1737             if (fontEnd &gt; 0 &amp;&amp; str.charAt(fontEnd-1) == sepChar) {
1738                 fontEnd--;
1739             }
1740             fontName = str.substring(0, fontEnd);
1741         }
1742 
1743         return new Font(fontName, fontStyle, fontSize);
1744     }
1745 
1746     /**
1747      * Gets the specified {@code Font} from the system properties
1748      * list.  As in the {@code getProperty} method of
1749      * {@code System}, the first
1750      * argument is treated as the name of a system property to be
1751      * obtained.  The {@code String} value of this property is then
1752      * interpreted as a {@code Font} object.
1753      * &lt;p&gt;
1754      * The property value should be one of the forms accepted by
1755      * {@code Font.decode(String)}
1756      * If the specified property is not found, or the executing code does not
1757      * have permission to read the property, the {@code font}
1758      * argument is returned instead.
1759      * @param nm the case-insensitive property name
1760      * @param font a default {@code Font} to return if property
1761      *          {@code nm} is not defined
1762      * @return    the {@code Font} value of the property.
1763      * @throws NullPointerException if nm is null.
1764      * @see #decode(String)
1765      */
1766     public static Font getFont(String nm, Font font) {
1767         String str = null;
1768         try {
1769             str =System.getProperty(nm);
1770         } catch(SecurityException e) {
1771         }
1772         if (str == null) {
1773             return font;
1774         }
1775         return decode ( str );
1776     }
1777 
1778     transient int hash;
1779     /**
1780      * Returns a hashcode for this {@code Font}.
1781      * @return     a hashcode value for this {@code Font}.
1782      * @since      1.0
1783      */
1784     public int hashCode() {
1785         if (hash == 0) {
1786             hash = name.hashCode() ^ style ^ size;
1787             /* It is possible many fonts differ only in transform.
1788              * So include the transform in the hash calculation.
1789              * nonIdentityTx is set whenever there is a transform in
1790              * &#39;values&#39;. The tests for null are required because it can
1791              * also be set for other reasons.
1792              */
1793             if (nonIdentityTx &amp;&amp;
1794                 values != null &amp;&amp; values.getTransform() != null) {
1795                 hash ^= values.getTransform().hashCode();
1796             }
1797         }
1798         return hash;
1799     }
1800 
1801     /**
1802      * Compares this {@code Font} object to the specified
1803      * {@code Object}.
1804      * @param obj the {@code Object} to compare
1805      * @return {@code true} if the objects are the same
1806      *          or if the argument is a {@code Font} object
1807      *          describing the same font as this object;
1808      *          {@code false} otherwise.
1809      * @since 1.0
1810      */
1811     public boolean equals(Object obj) {
1812         if (obj == this) {
1813             return true;
1814         }
1815 
1816         if (obj instanceof Font) {
1817             Font font = (Font)obj;
1818             if (size == font.size &amp;&amp;
1819                 style == font.style &amp;&amp;
1820                 nonIdentityTx == font.nonIdentityTx &amp;&amp;
1821                 hasLayoutAttributes == font.hasLayoutAttributes &amp;&amp;
1822                 pointSize == font.pointSize &amp;&amp;
1823                 name.equals(font.name)) {
1824 
1825                 /* &#39;values&#39; is usually initialized lazily, except when
1826                  * the font is constructed from a Map, or derived using
1827                  * a Map or other values. So if only one font has
1828                  * the field initialized we need to initialize it in
1829                  * the other instance and compare.
1830                  */
1831                 if (values == null) {
1832                     if (font.values == null) {
1833                         return true;
1834                     } else {
1835                         return getAttributeValues().equals(font.values);
1836                     }
1837                 } else {
1838                     return values.equals(font.getAttributeValues());
1839                 }
1840             }
1841         }
1842         return false;
1843     }
1844 
1845     /**
1846      * Converts this {@code Font} object to a {@code String}
1847      * representation.
1848      * @return     a {@code String} representation of this
1849      *          {@code Font} object.
1850      * @since      1.0
1851      */
1852     // NOTE: This method may be called by privileged threads.
1853     //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
1854     public String toString() {
1855         String  strStyle;
1856 
1857         if (isBold()) {
1858             strStyle = isItalic() ? &quot;bolditalic&quot; : &quot;bold&quot;;
1859         } else {
1860             strStyle = isItalic() ? &quot;italic&quot; : &quot;plain&quot;;
1861         }
1862 
1863         return getClass().getName() + &quot;[family=&quot; + getFamily() + &quot;,name=&quot; + name + &quot;,style=&quot; +
1864             strStyle + &quot;,size=&quot; + size + &quot;]&quot;;
1865     } // toString()
1866 
1867 
1868     /** Serialization support.  A {@code readObject}
1869      *  method is necessary because the constructor creates
1870      *  the font&#39;s peer, and we can&#39;t serialize the peer.
1871      *  Similarly the computed font &quot;family&quot; may be different
1872      *  at {@code readObject} time than at
1873      *  {@code writeObject} time.  An integer version is
1874      *  written so that future versions of this class will be
1875      *  able to recognize serialized output from this one.
1876      */
1877     /**
1878      * The {@code Font} Serializable Data Form.
1879      *
1880      * @serial
1881      */
1882     private int fontSerializedDataVersion = 1;
1883 
1884     /**
1885      * Writes default serializable fields to a stream.
1886      *
1887      * @param s the {@code ObjectOutputStream} to write
1888      * @see AWTEventMulticaster#save(ObjectOutputStream, String, EventListener)
1889      * @see #readObject(java.io.ObjectInputStream)
1890      */
1891     private void writeObject(java.io.ObjectOutputStream s)
1892       throws java.io.IOException
1893     {
1894         if (values != null) {
1895           synchronized(values) {
1896             // transient
1897             fRequestedAttributes = values.toSerializableHashtable();
1898             s.defaultWriteObject();
1899             fRequestedAttributes = null;
1900           }
1901         } else {
1902           s.defaultWriteObject();
1903         }
1904     }
1905 
1906     /**
1907      * Reads the {@code ObjectInputStream}.
1908      * Unrecognized keys or values will be ignored.
1909      *
1910      * @param s the {@code ObjectInputStream} to read
1911      * @serial
1912      * @see #writeObject(java.io.ObjectOutputStream)
1913      */
1914     private void readObject(java.io.ObjectInputStream s)
1915       throws java.lang.ClassNotFoundException,
1916              java.io.IOException
1917     {
1918         s.defaultReadObject();
1919         if (pointSize == 0) {
1920             pointSize = (float)size;
1921         }
1922 
1923         // Handle fRequestedAttributes.
1924         // in 1.5, we always streamed out the font values plus
1925         // TRANSFORM, SUPERSCRIPT, and WIDTH, regardless of whether the
1926         // values were default or not.  In 1.6 we only stream out
1927         // defined values.  So, 1.6 streams in from a 1.5 stream,
1928         // it check each of these values and &#39;undefines&#39; it if the
1929         // value is the default.
1930 
1931         if (fRequestedAttributes != null) {
1932             try {
1933             values = getAttributeValues(); // init
1934             AttributeValues extras =
1935                 AttributeValues.fromSerializableHashtable(fRequestedAttributes);
1936             if (!AttributeValues.is16Hashtable(fRequestedAttributes)) {
1937                 extras.unsetDefault(); // if legacy stream, undefine these
1938             }
1939             values = getAttributeValues().merge(extras);
1940             this.nonIdentityTx = values.anyNonDefault(EXTRA_MASK);
1941             this.hasLayoutAttributes =  values.anyNonDefault(LAYOUT_MASK);
1942             } catch (Throwable t) {
1943                 throw new IOException(t);
1944             } finally {
1945             fRequestedAttributes = null; // don&#39;t need it any more
1946         }
1947     }
1948     }
1949 
1950     /**
1951      * Returns the number of glyphs in this {@code Font}. Glyph codes
1952      * for this {@code Font} range from 0 to
1953      * {@code getNumGlyphs()} - 1.
1954      * @return the number of glyphs in this {@code Font}.
1955      * @since 1.2
1956      */
1957     public int getNumGlyphs() {
1958         return  getFont2D().getNumGlyphs();
1959     }
1960 
1961     /**
1962      * Returns the glyphCode which is used when this {@code Font}
1963      * does not have a glyph for a specified unicode code point.
1964      * @return the glyphCode of this {@code Font}.
1965      * @since 1.2
1966      */
1967     public int getMissingGlyphCode() {
1968         return getFont2D().getMissingGlyphCode();
1969     }
1970 
1971     /**
1972      * Returns the baseline appropriate for displaying this character.
1973      * &lt;p&gt;
1974      * Large fonts can support different writing systems, and each system can
1975      * use a different baseline.
1976      * The character argument determines the writing system to use. Clients
1977      * should not assume all characters use the same baseline.
1978      *
1979      * @param c a character used to identify the writing system
1980      * @return the baseline appropriate for the specified character.
1981      * @see LineMetrics#getBaselineOffsets
1982      * @see #ROMAN_BASELINE
1983      * @see #CENTER_BASELINE
1984      * @see #HANGING_BASELINE
1985      * @since 1.2
1986      */
1987     public byte getBaselineFor(char c) {
1988         return getFont2D().getBaselineFor(c);
1989     }
1990 
1991     /**
1992      * Returns a map of font attributes available in this
1993      * {@code Font}.  Attributes include things like ligatures and
1994      * glyph substitution.
1995      * @return the attributes map of this {@code Font}.
1996      */
1997     public Map&lt;TextAttribute,?&gt; getAttributes(){
1998         return new AttributeMap(getAttributeValues());
1999     }
2000 
2001     /**
2002      * Returns the keys of all the attributes supported by this
2003      * {@code Font}.  These attributes can be used to derive other
2004      * fonts.
2005      * @return an array containing the keys of all the attributes
2006      *          supported by this {@code Font}.
2007      * @since 1.2
2008      */
2009     public Attribute[] getAvailableAttributes() {
2010         // FONT is not supported by Font
2011 
2012         Attribute[] attributes = {
2013             TextAttribute.FAMILY,
2014             TextAttribute.WEIGHT,
2015             TextAttribute.WIDTH,
2016             TextAttribute.POSTURE,
2017             TextAttribute.SIZE,
2018             TextAttribute.TRANSFORM,
2019             TextAttribute.SUPERSCRIPT,
2020             TextAttribute.CHAR_REPLACEMENT,
2021             TextAttribute.FOREGROUND,
2022             TextAttribute.BACKGROUND,
2023             TextAttribute.UNDERLINE,
2024             TextAttribute.STRIKETHROUGH,
2025             TextAttribute.RUN_DIRECTION,
2026             TextAttribute.BIDI_EMBEDDING,
2027             TextAttribute.JUSTIFICATION,
2028             TextAttribute.INPUT_METHOD_HIGHLIGHT,
2029             TextAttribute.INPUT_METHOD_UNDERLINE,
2030             TextAttribute.SWAP_COLORS,
2031             TextAttribute.NUMERIC_SHAPING,
2032             TextAttribute.KERNING,
2033             TextAttribute.LIGATURES,
2034             TextAttribute.TRACKING,
2035         };
2036 
2037         return attributes;
2038     }
2039 
2040     /**
2041      * Creates a new {@code Font} object by replicating this
2042      * {@code Font} object and applying a new style and size.
2043      * @param style the style for the new {@code Font}
2044      * @param size the size for the new {@code Font}
2045      * @return a new {@code Font} object.
2046      * @since 1.2
2047      */
2048     public Font deriveFont(int style, float size){
2049         if (values == null) {
2050             return new Font(name, style, size, createdFont, font2DHandle);
2051         }
2052         AttributeValues newValues = getAttributeValues().clone();
2053         int oldStyle = (this.style != style) ? this.style : -1;
2054         applyStyle(style, newValues);
2055         newValues.setSize(size);
2056         return new Font(newValues, null, oldStyle, createdFont, font2DHandle);
2057     }
2058 
2059     /**
2060      * Creates a new {@code Font} object by replicating this
2061      * {@code Font} object and applying a new style and transform.
2062      * @param style the style for the new {@code Font}
2063      * @param trans the {@code AffineTransform} associated with the
2064      * new {@code Font}
2065      * @return a new {@code Font} object.
2066      * @throws IllegalArgumentException if {@code trans} is
2067      *         {@code null}
2068      * @since 1.2
2069      */
2070     public Font deriveFont(int style, AffineTransform trans){
2071         AttributeValues newValues = getAttributeValues().clone();
2072         int oldStyle = (this.style != style) ? this.style : -1;
2073         applyStyle(style, newValues);
2074         applyTransform(trans, newValues);
2075         return new Font(newValues, null, oldStyle, createdFont, font2DHandle);
2076     }
2077 
2078     /**
2079      * Creates a new {@code Font} object by replicating the current
2080      * {@code Font} object and applying a new size to it.
2081      * @param size the size for the new {@code Font}.
2082      * @return a new {@code Font} object.
2083      * @since 1.2
2084      */
2085     public Font deriveFont(float size){
2086         if (values == null) {
2087             return new Font(name, style, size, createdFont, font2DHandle);
2088         }
2089         AttributeValues newValues = getAttributeValues().clone();
2090         newValues.setSize(size);
2091         return new Font(newValues, null, -1, createdFont, font2DHandle);
2092     }
2093 
2094     /**
2095      * Creates a new {@code Font} object by replicating the current
2096      * {@code Font} object and applying a new transform to it.
2097      * @param trans the {@code AffineTransform} associated with the
2098      * new {@code Font}
2099      * @return a new {@code Font} object.
2100      * @throws IllegalArgumentException if {@code trans} is
2101      *         {@code null}
2102      * @since 1.2
2103      */
2104     public Font deriveFont(AffineTransform trans){
2105         AttributeValues newValues = getAttributeValues().clone();
2106         applyTransform(trans, newValues);
2107         return new Font(newValues, null, -1, createdFont, font2DHandle);
2108     }
2109 
2110     /**
2111      * Creates a new {@code Font} object by replicating the current
2112      * {@code Font} object and applying a new style to it.
2113      * @param style the style for the new {@code Font}
2114      * @return a new {@code Font} object.
2115      * @since 1.2
2116      */
2117     public Font deriveFont(int style){
2118         if (values == null) {
2119            return new Font(name, style, size, createdFont, font2DHandle);
2120         }
2121         AttributeValues newValues = getAttributeValues().clone();
2122         int oldStyle = (this.style != style) ? this.style : -1;
2123         applyStyle(style, newValues);
2124         return new Font(newValues, null, oldStyle, createdFont, font2DHandle);
2125     }
2126 
2127     /**
2128      * Creates a new {@code Font} object by replicating the current
2129      * {@code Font} object and applying a new set of font attributes
2130      * to it.
2131      *
2132      * @param attributes a map of attributes enabled for the new
2133      * {@code Font}
2134      * @return a new {@code Font} object.
2135      * @since 1.2
2136      */
2137     public Font deriveFont(Map&lt;? extends Attribute, ?&gt; attributes) {
2138         if (attributes == null) {
2139             return this;
2140         }
2141         AttributeValues newValues = getAttributeValues().clone();
2142         newValues.merge(attributes, RECOGNIZED_MASK);
2143 
2144         return new Font(newValues, name, style, createdFont, font2DHandle);
2145     }
2146 
2147     /**
2148      * Checks if this {@code Font} has a glyph for the specified
2149      * character.
2150      *
2151      * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; This method cannot handle
2152      * &lt;a href=&quot;../../../java.base/java/lang/Character.html#supplementary&quot;&gt;
2153      * supplementary characters&lt;/a&gt;.
2154      * To support all Unicode characters, including
2155      * supplementary characters, use the {@link #canDisplay(int)}
2156      * method or {@code canDisplayUpTo} methods.
2157      *
2158      * @param c the character for which a glyph is needed
2159      * @return {@code true} if this {@code Font} has a glyph for this
2160      *          character; {@code false} otherwise.
2161      * @since 1.2
2162      */
2163     public boolean canDisplay(char c){
2164         return getFont2D().canDisplay(c);
2165     }
2166 
2167     /**
2168      * Checks if this {@code Font} has a glyph for the specified
2169      * character.
2170      *
2171      * @param codePoint the character (Unicode code point) for which a glyph
2172      *        is needed.
2173      * @return {@code true} if this {@code Font} has a glyph for the
2174      *          character; {@code false} otherwise.
2175      * @throws IllegalArgumentException if the code point is not a valid Unicode
2176      *          code point.
2177      * @see Character#isValidCodePoint(int)
2178      * @since 1.5
2179      */
2180     public boolean canDisplay(int codePoint) {
2181         if (!Character.isValidCodePoint(codePoint)) {
2182             throw new IllegalArgumentException(&quot;invalid code point: &quot; +
2183                                                Integer.toHexString(codePoint));
2184         }
2185         return getFont2D().canDisplay(codePoint);
2186     }
2187 
2188     /**
2189      * Indicates whether or not this {@code Font} can display a
2190      * specified {@code String}.  For strings with Unicode encoding,
2191      * it is important to know if a particular font can display the
2192      * string. This method returns an offset into the {@code String}
2193      * {@code str} which is the first character this
2194      * {@code Font} cannot display without using the missing glyph
2195      * code. If the {@code Font} can display all characters, -1 is
2196      * returned.
2197      * @param str a {@code String} object
2198      * @return an offset into {@code str} that points
2199      *          to the first character in {@code str} that this
2200      *          {@code Font} cannot display; or {@code -1} if
2201      *          this {@code Font} can display all characters in
2202      *          {@code str}.
2203      * @since 1.2
2204      */
2205     public int canDisplayUpTo(String str) {
2206         Font2D font2d = getFont2D();
2207         int len = str.length();
2208         for (int i = 0; i &lt; len; i++) {
2209             char c = str.charAt(i);
2210             if (font2d.canDisplay(c)) {
2211                 continue;
2212             }
2213             if (!Character.isHighSurrogate(c)) {
2214                 return i;
2215             }
2216             if (!font2d.canDisplay(str.codePointAt(i))) {
2217                 return i;
2218             }
2219             i++;
2220         }
2221         return -1;
2222     }
2223 
2224     /**
2225      * Indicates whether or not this {@code Font} can display
2226      * the characters in the specified {@code text}
2227      * starting at {@code start} and ending at
2228      * {@code limit}.  This method is a convenience overload.
2229      * @param text the specified array of {@code char} values
2230      * @param start the specified starting offset (in
2231      *              {@code char}s) into the specified array of
2232      *              {@code char} values
2233      * @param limit the specified ending offset (in
2234      *              {@code char}s) into the specified array of
2235      *              {@code char} values
2236      * @return an offset into {@code text} that points
2237      *          to the first character in {@code text} that this
2238      *          {@code Font} cannot display; or {@code -1} if
2239      *          this {@code Font} can display all characters in
2240      *          {@code text}.
2241      * @since 1.2
2242      */
2243     public int canDisplayUpTo(char[] text, int start, int limit) {
2244         Font2D font2d = getFont2D();
2245         for (int i = start; i &lt; limit; i++) {
2246             char c = text[i];
2247             if (font2d.canDisplay(c)) {
2248                 continue;
2249             }
2250             if (!Character.isHighSurrogate(c)) {
2251                 return i;
2252             }
2253             if (!font2d.canDisplay(Character.codePointAt(text, i, limit))) {
2254                 return i;
2255             }
2256             i++;
2257         }
2258         return -1;
2259     }
2260 
2261     /**
2262      * Indicates whether or not this {@code Font} can display the
2263      * text specified by the {@code iter} starting at
2264      * {@code start} and ending at {@code limit}.
2265      *
2266      * @param iter  a {@link CharacterIterator} object
2267      * @param start the specified starting offset into the specified
2268      *              {@code CharacterIterator}.
2269      * @param limit the specified ending offset into the specified
2270      *              {@code CharacterIterator}.
2271      * @return an offset into {@code iter} that points
2272      *          to the first character in {@code iter} that this
2273      *          {@code Font} cannot display; or {@code -1} if
2274      *          this {@code Font} can display all characters in
2275      *          {@code iter}.
2276      * @since 1.2
2277      */
2278     public int canDisplayUpTo(CharacterIterator iter, int start, int limit) {
2279         Font2D font2d = getFont2D();
2280         char c = iter.setIndex(start);
2281         for (int i = start; i &lt; limit; i++, c = iter.next()) {
2282             if (font2d.canDisplay(c)) {
2283                 continue;
2284             }
2285             if (!Character.isHighSurrogate(c)) {
2286                 return i;
2287             }
2288             char c2 = iter.next();
2289             // c2 could be CharacterIterator.DONE which is not a low surrogate.
2290             if (!Character.isLowSurrogate(c2)) {
2291                 return i;
2292             }
2293             if (!font2d.canDisplay(Character.toCodePoint(c, c2))) {
2294                 return i;
2295             }
2296             i++;
2297         }
2298         return -1;
2299     }
2300 
2301     /**
2302      * Returns the italic angle of this {@code Font}.  The italic angle
2303      * is the inverse slope of the caret which best matches the posture of this
2304      * {@code Font}.
2305      * @see TextAttribute#POSTURE
2306      * @return the angle of the ITALIC style of this {@code Font}.
2307      */
2308     public float getItalicAngle() {
2309         return getItalicAngle(null);
2310     }
2311 
2312     /* The FRC hints don&#39;t affect the value of the italic angle but
2313      * we need to pass them in to look up a strike.
2314      * If we can pass in ones already being used it can prevent an extra
2315      * strike from being allocated. Note that since italic angle is
2316      * a property of the font, the font transform is needed not the
2317      * device transform. Finally, this is private but the only caller of this
2318      * in the JDK - and the only likely caller - is in this same class.
2319      */
2320     private float getItalicAngle(FontRenderContext frc) {
2321         Object aa, fm;
2322         if (frc == null) {
2323             aa = RenderingHints.VALUE_TEXT_ANTIALIAS_OFF;
2324             fm = RenderingHints.VALUE_FRACTIONALMETRICS_OFF;
2325         } else {
2326             aa = frc.getAntiAliasingHint();
2327             fm = frc.getFractionalMetricsHint();
2328         }
2329         return getFont2D().getItalicAngle(this, identityTx, aa, fm);
2330     }
2331 
2332     /**
2333      * Checks whether or not this {@code Font} has uniform
2334      * line metrics.  A logical {@code Font} might be a
2335      * composite font, which means that it is composed of different
2336      * physical fonts to cover different code ranges.  Each of these
2337      * fonts might have different {@code LineMetrics}.  If the
2338      * logical {@code Font} is a single
2339      * font then the metrics would be uniform.
2340      * @return {@code true} if this {@code Font} has
2341      * uniform line metrics; {@code false} otherwise.
2342      */
2343     public boolean hasUniformLineMetrics() {
2344         return false;   // REMIND always safe, but prevents caller optimize
2345     }
2346 
2347     private transient SoftReference&lt;FontLineMetrics&gt; flmref;
2348     private FontLineMetrics defaultLineMetrics(FontRenderContext frc) {
2349         FontLineMetrics flm = null;
2350         if (flmref == null
2351             || (flm = flmref.get()) == null
2352             || !flm.frc.equals(frc)) {
2353 
2354             /* The device transform in the frc is not used in obtaining line
2355              * metrics, although it probably should be: REMIND find why not?
2356              * The font transform is used but its applied in getFontMetrics, so
2357              * just pass identity here
2358              */
2359             float [] metrics = new float[8];
2360             getFont2D().getFontMetrics(this, identityTx,
2361                                        frc.getAntiAliasingHint(),
2362                                        frc.getFractionalMetricsHint(),
2363                                        metrics);
2364             float ascent  = metrics[0];
2365             float descent = metrics[1];
2366             float leading = metrics[2];
2367             float ssOffset = 0;
2368             if (values != null &amp;&amp; values.getSuperscript() != 0) {
2369                 ssOffset = (float)getTransform().getTranslateY();
2370                 ascent -= ssOffset;
2371                 descent += ssOffset;
2372             }
2373             float height = ascent + descent + leading;
2374 
2375             int baselineIndex = 0; // need real index, assumes roman for everything
2376             // need real baselines eventually
2377             float[] baselineOffsets = { 0, (descent/2f - ascent) / 2f, -ascent };
2378 
2379             float strikethroughOffset = metrics[4];
2380             float strikethroughThickness = metrics[5];
2381 
2382             float underlineOffset = metrics[6];
2383             float underlineThickness = metrics[7];
2384 
2385             float italicAngle = getItalicAngle(frc);
2386 
2387             if (isTransformed()) {
2388                 AffineTransform ctx = values.getCharTransform(); // extract rotation
2389                 if (ctx != null) {
2390                     Point2D.Float pt = new Point2D.Float();
2391                     pt.setLocation(0, strikethroughOffset);
2392                     ctx.deltaTransform(pt, pt);
2393                     strikethroughOffset = pt.y;
2394                     pt.setLocation(0, strikethroughThickness);
2395                     ctx.deltaTransform(pt, pt);
2396                     strikethroughThickness = pt.y;
2397                     pt.setLocation(0, underlineOffset);
2398                     ctx.deltaTransform(pt, pt);
2399                     underlineOffset = pt.y;
2400                     pt.setLocation(0, underlineThickness);
2401                     ctx.deltaTransform(pt, pt);
2402                     underlineThickness = pt.y;
2403                 }
2404             }
2405             strikethroughOffset += ssOffset;
2406             underlineOffset += ssOffset;
2407 
2408             CoreMetrics cm = new CoreMetrics(ascent, descent, leading, height,
2409                                              baselineIndex, baselineOffsets,
2410                                              strikethroughOffset, strikethroughThickness,
2411                                              underlineOffset, underlineThickness,
2412                                              ssOffset, italicAngle);
2413 
2414             flm = new FontLineMetrics(0, cm, frc);
2415             flmref = new SoftReference&lt;FontLineMetrics&gt;(flm);
2416         }
2417 
2418         return (FontLineMetrics)flm.clone();
2419     }
2420 
2421     /**
2422      * Returns a {@link LineMetrics} object created with the specified
2423      * {@code String} and {@link FontRenderContext}.
2424      * @param str the specified {@code String}
2425      * @param frc the specified {@code FontRenderContext}
2426      * @return a {@code LineMetrics} object created with the
2427      * specified {@code String} and {@link FontRenderContext}.
2428      */
2429     public LineMetrics getLineMetrics( String str, FontRenderContext frc) {
2430         FontLineMetrics flm = defaultLineMetrics(frc);
2431         flm.numchars = str.length();
2432         return flm;
2433     }
2434 
2435     /**
2436      * Returns a {@code LineMetrics} object created with the
2437      * specified arguments.
2438      * @param str the specified {@code String}
2439      * @param beginIndex the initial offset of {@code str}
2440      * @param limit the end offset of {@code str}
2441      * @param frc the specified {@code FontRenderContext}
2442      * @return a {@code LineMetrics} object created with the
2443      * specified arguments.
2444      */
2445     public LineMetrics getLineMetrics( String str,
2446                                     int beginIndex, int limit,
2447                                     FontRenderContext frc) {
2448         FontLineMetrics flm = defaultLineMetrics(frc);
2449         int numChars = limit - beginIndex;
2450         flm.numchars = (numChars &lt; 0)? 0: numChars;
2451         return flm;
2452     }
2453 
2454     /**
2455      * Returns a {@code LineMetrics} object created with the
2456      * specified arguments.
2457      * @param chars an array of characters
2458      * @param beginIndex the initial offset of {@code chars}
2459      * @param limit the end offset of {@code chars}
2460      * @param frc the specified {@code FontRenderContext}
2461      * @return a {@code LineMetrics} object created with the
2462      * specified arguments.
2463      */
2464     public LineMetrics getLineMetrics(char [] chars,
2465                                     int beginIndex, int limit,
2466                                     FontRenderContext frc) {
2467         FontLineMetrics flm = defaultLineMetrics(frc);
2468         int numChars = limit - beginIndex;
2469         flm.numchars = (numChars &lt; 0)? 0: numChars;
2470         return flm;
2471     }
2472 
2473     /**
2474      * Returns a {@code LineMetrics} object created with the
2475      * specified arguments.
2476      * @param ci the specified {@code CharacterIterator}
2477      * @param beginIndex the initial offset in {@code ci}
2478      * @param limit the end offset of {@code ci}
2479      * @param frc the specified {@code FontRenderContext}
2480      * @return a {@code LineMetrics} object created with the
2481      * specified arguments.
2482      */
2483     public LineMetrics getLineMetrics(CharacterIterator ci,
2484                                     int beginIndex, int limit,
2485                                     FontRenderContext frc) {
2486         FontLineMetrics flm = defaultLineMetrics(frc);
2487         int numChars = limit - beginIndex;
2488         flm.numchars = (numChars &lt; 0)? 0: numChars;
2489         return flm;
2490     }
2491 
2492     /**
2493      * Returns the logical bounds of the specified {@code String} in
2494      * the specified {@code FontRenderContext}.  The logical bounds
2495      * contains the origin, ascent, advance, and height, which includes
2496      * the leading.  The logical bounds does not always enclose all the
2497      * text.  For example, in some languages and in some fonts, accent
2498      * marks can be positioned above the ascent or below the descent.
2499      * To obtain a visual bounding box, which encloses all the text,
2500      * use the {@link TextLayout#getBounds() getBounds} method of
2501      * {@code TextLayout}.
2502      * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
2503      * (see {@link java.awt.Font class notes}).
2504      * @param str the specified {@code String}
2505      * @param frc the specified {@code FontRenderContext}
2506      * @return a {@link Rectangle2D} that is the bounding box of the
2507      * specified {@code String} in the specified
2508      * {@code FontRenderContext}.
2509      * @see FontRenderContext
2510      * @see Font#createGlyphVector
2511      * @since 1.2
2512      */
2513     public Rectangle2D getStringBounds( String str, FontRenderContext frc) {
2514         char[] array = str.toCharArray();
2515         return getStringBounds(array, 0, array.length, frc);
2516     }
2517 
2518    /**
2519      * Returns the logical bounds of the specified {@code String} in
2520      * the specified {@code FontRenderContext}.  The logical bounds
2521      * contains the origin, ascent, advance, and height, which includes
2522      * the leading.  The logical bounds does not always enclose all the
2523      * text.  For example, in some languages and in some fonts, accent
2524      * marks can be positioned above the ascent or below the descent.
2525      * To obtain a visual bounding box, which encloses all the text,
2526      * use the {@link TextLayout#getBounds() getBounds} method of
2527      * {@code TextLayout}.
2528      * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
2529      * (see {@link java.awt.Font class notes}).
2530      * @param str the specified {@code String}
2531      * @param beginIndex the initial offset of {@code str}
2532      * @param limit the end offset of {@code str}
2533      * @param frc the specified {@code FontRenderContext}
2534      * @return a {@code Rectangle2D} that is the bounding box of the
2535      * specified {@code String} in the specified
2536      * {@code FontRenderContext}.
2537      * @throws IndexOutOfBoundsException if {@code beginIndex} is
2538      *         less than zero, or {@code limit} is greater than the
2539      *         length of {@code str}, or {@code beginIndex}
2540      *         is greater than {@code limit}.
2541      * @see FontRenderContext
2542      * @see Font#createGlyphVector
2543      * @since 1.2
2544      */
2545     public Rectangle2D getStringBounds( String str,
2546                                     int beginIndex, int limit,
2547                                         FontRenderContext frc) {
2548         String substr = str.substring(beginIndex, limit);
2549         return getStringBounds(substr, frc);
2550     }
2551 
2552    /**
2553      * Returns the logical bounds of the specified array of characters
2554      * in the specified {@code FontRenderContext}.  The logical
2555      * bounds contains the origin, ascent, advance, and height, which
2556      * includes the leading.  The logical bounds does not always enclose
2557      * all the text.  For example, in some languages and in some fonts,
2558      * accent marks can be positioned above the ascent or below the
2559      * descent.  To obtain a visual bounding box, which encloses all the
2560      * text, use the {@link TextLayout#getBounds() getBounds} method of
2561      * {@code TextLayout}.
2562      * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
2563      * (see {@link java.awt.Font class notes}).
2564      * @param chars an array of characters
2565      * @param beginIndex the initial offset in the array of
2566      * characters
2567      * @param limit the end offset in the array of characters
2568      * @param frc the specified {@code FontRenderContext}
2569      * @return a {@code Rectangle2D} that is the bounding box of the
2570      * specified array of characters in the specified
2571      * {@code FontRenderContext}.
2572      * @throws IndexOutOfBoundsException if {@code beginIndex} is
2573      *         less than zero, or {@code limit} is greater than the
2574      *         length of {@code chars}, or {@code beginIndex}
2575      *         is greater than {@code limit}.
2576      * @see FontRenderContext
2577      * @see Font#createGlyphVector
2578      * @since 1.2
2579      */
2580     public Rectangle2D getStringBounds(char [] chars,
2581                                     int beginIndex, int limit,
2582                                        FontRenderContext frc) {
2583         if (beginIndex &lt; 0) {
2584             throw new IndexOutOfBoundsException(&quot;beginIndex: &quot; + beginIndex);
2585         }
2586         if (limit &gt; chars.length) {
2587             throw new IndexOutOfBoundsException(&quot;limit: &quot; + limit);
2588         }
2589         if (beginIndex &gt; limit) {
2590             throw new IndexOutOfBoundsException(&quot;range length: &quot; +
2591                                                 (limit - beginIndex));
2592         }
2593 
2594         // this code should be in textlayout
2595         // quick check for simple text, assume GV ok to use if simple
2596 
2597         boolean simple = values == null ||
2598             (values.getKerning() == 0 &amp;&amp; values.getLigatures() == 0 &amp;&amp;
2599               values.getBaselineTransform() == null);
2600         if (simple) {
2601             simple = ! FontUtilities.isComplexText(chars, beginIndex, limit);
2602         }
2603 
<a name="1" id="anc1"></a><span class="line-modified">2604         if (simple) {</span>
2605             FontDesignMetrics metrics = FontDesignMetrics.getMetrics(this, frc);
2606             return metrics.getSimpleBounds(chars, beginIndex, limit-beginIndex);
2607         } else {
2608             // need char array constructor on textlayout
2609             String str = new String(chars, beginIndex, limit - beginIndex);
2610             TextLayout tl = new TextLayout(str, this, frc);
2611             return new Rectangle2D.Float(0, -tl.getAscent(), tl.getAdvance(),
2612                                          tl.getAscent() + tl.getDescent() +
2613                                          tl.getLeading());
2614         }
2615     }
2616 
2617    /**
2618      * Returns the logical bounds of the characters indexed in the
2619      * specified {@link CharacterIterator} in the
2620      * specified {@code FontRenderContext}.  The logical bounds
2621      * contains the origin, ascent, advance, and height, which includes
2622      * the leading.  The logical bounds does not always enclose all the
2623      * text.  For example, in some languages and in some fonts, accent
2624      * marks can be positioned above the ascent or below the descent.
2625      * To obtain a visual bounding box, which encloses all the text,
2626      * use the {@link TextLayout#getBounds() getBounds} method of
2627      * {@code TextLayout}.
2628      * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
2629      * (see {@link java.awt.Font class notes}).
2630      * @param ci the specified {@code CharacterIterator}
2631      * @param beginIndex the initial offset in {@code ci}
2632      * @param limit the end offset in {@code ci}
2633      * @param frc the specified {@code FontRenderContext}
2634      * @return a {@code Rectangle2D} that is the bounding box of the
2635      * characters indexed in the specified {@code CharacterIterator}
2636      * in the specified {@code FontRenderContext}.
2637      * @see FontRenderContext
2638      * @see Font#createGlyphVector
2639      * @since 1.2
2640      * @throws IndexOutOfBoundsException if {@code beginIndex} is
2641      *         less than the start index of {@code ci}, or
2642      *         {@code limit} is greater than the end index of
2643      *         {@code ci}, or {@code beginIndex} is greater
2644      *         than {@code limit}
2645      */
2646     public Rectangle2D getStringBounds(CharacterIterator ci,
2647                                     int beginIndex, int limit,
2648                                        FontRenderContext frc) {
2649         int start = ci.getBeginIndex();
2650         int end = ci.getEndIndex();
2651 
2652         if (beginIndex &lt; start) {
2653             throw new IndexOutOfBoundsException(&quot;beginIndex: &quot; + beginIndex);
2654         }
2655         if (limit &gt; end) {
2656             throw new IndexOutOfBoundsException(&quot;limit: &quot; + limit);
2657         }
2658         if (beginIndex &gt; limit) {
2659             throw new IndexOutOfBoundsException(&quot;range length: &quot; +
2660                                                 (limit - beginIndex));
2661         }
2662 
2663         char[]  arr = new char[limit - beginIndex];
2664 
2665         ci.setIndex(beginIndex);
2666         for(int idx = 0; idx &lt; arr.length; idx++) {
2667             arr[idx] = ci.current();
2668             ci.next();
2669         }
2670 
2671         return getStringBounds(arr,0,arr.length,frc);
2672     }
2673 
2674     /**
2675      * Returns the bounds for the character with the maximum
2676      * bounds as defined in the specified {@code FontRenderContext}.
2677      * &lt;p&gt;Note: The returned bounds is in baseline-relative coordinates
2678      * (see {@link java.awt.Font class notes}).
2679      * @param frc the specified {@code FontRenderContext}
2680      * @return a {@code Rectangle2D} that is the bounding box
2681      * for the character with the maximum bounds.
2682      */
2683     public Rectangle2D getMaxCharBounds(FontRenderContext frc) {
2684         float [] metrics = new float[4];
2685 
2686         getFont2D().getFontMetrics(this, frc, metrics);
2687 
2688         return new Rectangle2D.Float(0, -metrics[0],
2689                                 metrics[3],
2690                                 metrics[0] + metrics[1] + metrics[2]);
2691     }
2692 
2693     /**
2694      * Creates a {@link java.awt.font.GlyphVector GlyphVector} by
2695      * mapping characters to glyphs one-to-one based on the
2696      * Unicode cmap in this {@code Font}.  This method does no other
2697      * processing besides the mapping of glyphs to characters.  This
2698      * means that this method is not useful for some scripts, such
2699      * as Arabic, Hebrew, Thai, and Indic, that require reordering,
2700      * shaping, or ligature substitution.
2701      * @param frc the specified {@code FontRenderContext}
2702      * @param str the specified {@code String}
2703      * @return a new {@code GlyphVector} created with the
2704      * specified {@code String} and the specified
2705      * {@code FontRenderContext}.
2706      */
2707     public GlyphVector createGlyphVector(FontRenderContext frc, String str)
2708     {
2709         return (GlyphVector)new StandardGlyphVector(this, str, frc);
2710     }
2711 
2712     /**
2713      * Creates a {@link java.awt.font.GlyphVector GlyphVector} by
2714      * mapping characters to glyphs one-to-one based on the
2715      * Unicode cmap in this {@code Font}.  This method does no other
2716      * processing besides the mapping of glyphs to characters.  This
2717      * means that this method is not useful for some scripts, such
2718      * as Arabic, Hebrew, Thai, and Indic, that require reordering,
2719      * shaping, or ligature substitution.
2720      * @param frc the specified {@code FontRenderContext}
2721      * @param chars the specified array of characters
2722      * @return a new {@code GlyphVector} created with the
2723      * specified array of characters and the specified
2724      * {@code FontRenderContext}.
2725      */
2726     public GlyphVector createGlyphVector(FontRenderContext frc, char[] chars)
2727     {
2728         return (GlyphVector)new StandardGlyphVector(this, chars, frc);
2729     }
2730 
2731     /**
2732      * Creates a {@link java.awt.font.GlyphVector GlyphVector} by
2733      * mapping the specified characters to glyphs one-to-one based on the
2734      * Unicode cmap in this {@code Font}.  This method does no other
2735      * processing besides the mapping of glyphs to characters.  This
2736      * means that this method is not useful for some scripts, such
2737      * as Arabic, Hebrew, Thai, and Indic, that require reordering,
2738      * shaping, or ligature substitution.
2739      * @param frc the specified {@code FontRenderContext}
2740      * @param ci the specified {@code CharacterIterator}
2741      * @return a new {@code GlyphVector} created with the
2742      * specified {@code CharacterIterator} and the specified
2743      * {@code FontRenderContext}.
2744      */
2745     public GlyphVector createGlyphVector(   FontRenderContext frc,
2746                                             CharacterIterator ci)
2747     {
2748         return (GlyphVector)new StandardGlyphVector(this, ci, frc);
2749     }
2750 
2751     /**
2752      * Creates a {@link java.awt.font.GlyphVector GlyphVector} by
2753      * mapping characters to glyphs one-to-one based on the
2754      * Unicode cmap in this {@code Font}.  This method does no other
2755      * processing besides the mapping of glyphs to characters.  This
2756      * means that this method is not useful for some scripts, such
2757      * as Arabic, Hebrew, Thai, and Indic, that require reordering,
2758      * shaping, or ligature substitution.
2759      * @param frc the specified {@code FontRenderContext}
2760      * @param glyphCodes the specified integer array
2761      * @return a new {@code GlyphVector} created with the
2762      * specified integer array and the specified
2763      * {@code FontRenderContext}.
2764      */
2765     public GlyphVector createGlyphVector(   FontRenderContext frc,
2766                                             int [] glyphCodes)
2767     {
2768         return (GlyphVector)new StandardGlyphVector(this, glyphCodes, frc);
2769     }
2770 
2771     /**
2772      * Returns a new {@code GlyphVector} object, performing full
2773      * layout of the text if possible.  Full layout is required for
2774      * complex text, such as Arabic or Hindi.  Support for different
2775      * scripts depends on the font and implementation.
2776      * &lt;p&gt;
2777      * Layout requires bidi analysis, as performed by
2778      * {@code Bidi}, and should only be performed on text that
2779      * has a uniform direction.  The direction is indicated in the
2780      * flags parameter,by using LAYOUT_RIGHT_TO_LEFT to indicate a
2781      * right-to-left (Arabic and Hebrew) run direction, or
2782      * LAYOUT_LEFT_TO_RIGHT to indicate a left-to-right (English)
2783      * run direction.
2784      * &lt;p&gt;
2785      * In addition, some operations, such as Arabic shaping, require
2786      * context, so that the characters at the start and limit can have
2787      * the proper shapes.  Sometimes the data in the buffer outside
2788      * the provided range does not have valid data.  The values
2789      * LAYOUT_NO_START_CONTEXT and LAYOUT_NO_LIMIT_CONTEXT can be
2790      * added to the flags parameter to indicate that the text before
2791      * start, or after limit, respectively, should not be examined
2792      * for context.
2793      * &lt;p&gt;
2794      * All other values for the flags parameter are reserved.
2795      *
2796      * @param frc the specified {@code FontRenderContext}
2797      * @param text the text to layout
2798      * @param start the start of the text to use for the {@code GlyphVector}
2799      * @param limit the limit of the text to use for the {@code GlyphVector}
2800      * @param flags control flags as described above
2801      * @return a new {@code GlyphVector} representing the text between
2802      * start and limit, with glyphs chosen and positioned so as to best represent
2803      * the text
2804      * @throws ArrayIndexOutOfBoundsException if start or limit is
2805      * out of bounds
2806      * @see java.text.Bidi
2807      * @see #LAYOUT_LEFT_TO_RIGHT
2808      * @see #LAYOUT_RIGHT_TO_LEFT
2809      * @see #LAYOUT_NO_START_CONTEXT
2810      * @see #LAYOUT_NO_LIMIT_CONTEXT
2811      * @since 1.4
2812      */
2813     public GlyphVector layoutGlyphVector(FontRenderContext frc,
2814                                          char[] text,
2815                                          int start,
2816                                          int limit,
2817                                          int flags) {
2818 
2819         GlyphLayout gl = GlyphLayout.get(null); // !!! no custom layout engines
2820         StandardGlyphVector gv = gl.layout(this, frc, text,
2821                                            start, limit-start, flags, null);
2822         GlyphLayout.done(gl);
2823         return gv;
2824     }
2825 
2826     /**
2827      * A flag to layoutGlyphVector indicating that text is left-to-right as
2828      * determined by Bidi analysis.
2829      */
2830     public static final int LAYOUT_LEFT_TO_RIGHT = 0;
2831 
2832     /**
2833      * A flag to layoutGlyphVector indicating that text is right-to-left as
2834      * determined by Bidi analysis.
2835      */
2836     public static final int LAYOUT_RIGHT_TO_LEFT = 1;
2837 
2838     /**
2839      * A flag to layoutGlyphVector indicating that text in the char array
2840      * before the indicated start should not be examined.
2841      */
2842     public static final int LAYOUT_NO_START_CONTEXT = 2;
2843 
2844     /**
2845      * A flag to layoutGlyphVector indicating that text in the char array
2846      * after the indicated limit should not be examined.
2847      */
2848     public static final int LAYOUT_NO_LIMIT_CONTEXT = 4;
2849 
2850 
2851     private static void applyTransform(AffineTransform trans, AttributeValues values) {
2852         if (trans == null) {
2853             throw new IllegalArgumentException(&quot;transform must not be null&quot;);
2854         }
2855         values.setTransform(trans);
2856     }
2857 
2858     private static void applyStyle(int style, AttributeValues values) {
2859         // WEIGHT_BOLD, WEIGHT_REGULAR
2860         values.setWeight((style &amp; BOLD) != 0 ? 2f : 1f);
2861         // POSTURE_OBLIQUE, POSTURE_REGULAR
2862         values.setPosture((style &amp; ITALIC) != 0 ? .2f : 0f);
2863     }
2864 
2865     /*
2866      * Initialize JNI field and method IDs
2867      */
2868     private static native void initIDs();
2869 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>