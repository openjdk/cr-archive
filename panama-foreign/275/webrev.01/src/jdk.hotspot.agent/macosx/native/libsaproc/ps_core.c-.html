<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &lt;jni.h&gt;
  26 #include &lt;unistd.h&gt;
  27 #include &lt;fcntl.h&gt;
  28 #include &lt;string.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stddef.h&gt;
  31 #include &quot;libproc_impl.h&quot;
  32 #include &quot;ps_core_common.h&quot;
  33 
  34 #ifdef __APPLE__
  35 #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
  36 #endif
  37 
  38 // This file has the libproc implementation to read core files.
  39 // For live processes, refer to ps_proc.c. Portions of this is adapted
  40 // /modelled after Solaris libproc.so (in particular Pcore.c)
  41 
  42 //---------------------------------------------------------------------------
  43 // functions to handle map_info
  44 
  45 // Order mappings based on virtual address.  We use this function as the
  46 // callback for sorting the array of map_info pointers.
  47 static int core_cmp_mapping(const void *lhsp, const void *rhsp)
  48 {
  49   const map_info *lhs = *((const map_info **)lhsp);
  50   const map_info *rhs = *((const map_info **)rhsp);
  51 
  52   if (lhs-&gt;vaddr == rhs-&gt;vaddr) {
  53     return (0);
  54   }
  55 
  56   return (lhs-&gt;vaddr &lt; rhs-&gt;vaddr ? -1 : 1);
  57 }
  58 
  59 // we sort map_info by starting virtual address so that we can do
  60 // binary search to read from an address.
  61 static bool sort_map_array(struct ps_prochandle* ph) {
  62   size_t num_maps = ph-&gt;core-&gt;num_maps;
  63   map_info* map = ph-&gt;core-&gt;maps;
  64   int i = 0;
  65 
  66   // allocate map_array
  67   map_info** array;
  68   if ( (array = (map_info**) malloc(sizeof(map_info*) * num_maps)) == NULL) {
  69     print_debug(&quot;can&#39;t allocate memory for map array\n&quot;);
  70     return false;
  71   }
  72 
  73   // add maps to array
  74   while (map) {
  75     array[i] = map;
  76     i++;
  77     map = map-&gt;next;
  78   }
  79 
  80   // sort is called twice. If this is second time, clear map array
  81   if (ph-&gt;core-&gt;map_array) {
  82     free(ph-&gt;core-&gt;map_array);
  83   }
  84   ph-&gt;core-&gt;map_array = array;
  85   // sort the map_info array by base virtual address.
  86   qsort(ph-&gt;core-&gt;map_array, ph-&gt;core-&gt;num_maps, sizeof (map_info*),
  87         core_cmp_mapping);
  88 
  89   // print map
  90   if (is_debug()) {
  91     int j = 0;
  92     print_debug(&quot;---- sorted virtual address map ----\n&quot;);
  93     for (j = 0; j &lt; ph-&gt;core-&gt;num_maps; j++) {
  94       print_debug(&quot;base = 0x%lx\tsize = %d\n&quot;, ph-&gt;core-&gt;map_array[j]-&gt;vaddr,
  95                   ph-&gt;core-&gt;map_array[j]-&gt;memsz);
  96     }
  97   }
  98 
  99   return true;
 100 }
 101 
 102 #ifndef MIN
 103 #define MIN(x, y) (((x) &lt; (y))? (x): (y))
 104 #endif
 105 
 106 static bool core_read_data(struct ps_prochandle* ph, uintptr_t addr, char *buf, size_t size) {
 107    ssize_t resid = size;
 108    int page_size=sysconf(_SC_PAGE_SIZE);
 109    while (resid != 0) {
 110       map_info *mp = core_lookup(ph, addr);
 111       uintptr_t mapoff;
 112       ssize_t len, rem;
 113       off_t off;
 114       int fd;
 115 
 116       if (mp == NULL) {
 117          break;  /* No mapping for this address */
 118       }
 119 
 120       fd = mp-&gt;fd;
 121       mapoff = addr - mp-&gt;vaddr;
 122       len = MIN(resid, mp-&gt;memsz - mapoff);
 123       off = mp-&gt;offset + mapoff;
 124 
 125       if ((len = pread(fd, buf, len, off)) &lt;= 0) {
 126          break;
 127       }
 128 
 129       resid -= len;
 130       addr += len;
 131       buf = (char *)buf + len;
 132 
 133       // mappings always start at page boundary. But, may end in fractional
 134       // page. fill zeros for possible fractional page at the end of a mapping.
 135       rem = mp-&gt;memsz % page_size;
 136       if (rem &gt; 0) {
 137          rem = page_size - rem;
 138          len = MIN(resid, rem);
 139          resid -= len;
 140          addr += len;
 141          // we are not assuming &#39;buf&#39; to be zero initialized.
 142          memset(buf, 0, len);
 143          buf += len;
 144       }
 145    }
 146 
 147    if (resid) {
 148       print_debug(&quot;core read failed for %d byte(s) @ 0x%lx (%d more bytes)\n&quot;,
 149               size, addr, resid);
 150       return false;
 151    } else {
 152       return true;
 153    }
 154 }
 155 
 156 // null implementation for write
 157 static bool core_write_data(struct ps_prochandle* ph,
 158                              uintptr_t addr, const char *buf , size_t size) {
 159    return false;
 160 }
 161 
 162 static bool core_get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id,
 163                           struct reg* regs) {
 164    // for core we have cached the lwp regs after segment parsed
 165    sa_thread_info* thr = ph-&gt;threads;
 166    while (thr) {
 167      if (thr-&gt;lwp_id == lwp_id) {
 168        memcpy(regs, &amp;thr-&gt;regs, sizeof(struct reg));
 169        return true;
 170      }
 171      thr = thr-&gt;next;
 172    }
 173    return false;
 174 }
 175 
 176 static bool core_get_lwp_info(struct ps_prochandle *ph, lwpid_t id, void *info) {
 177    print_debug(&quot;core_get_lwp_info not implemented\n&quot;);
 178    return false;
 179 }
 180 
 181 static ps_prochandle_ops core_ops = {
 182    .release=  core_release,
 183    .p_pread=  core_read_data,
 184    .p_pwrite= core_write_data,
 185    .get_lwp_regs= core_get_lwp_regs,
 186    .get_lwp_info= core_get_lwp_info
 187 };
 188 
 189 // from this point, mainly two blocks divided by def __APPLE__
 190 // one for Macosx, the other for regular Bsd
 191 
 192 #ifdef __APPLE__
 193 
 194 void print_thread(sa_thread_info *threadinfo) {
 195   print_debug(&quot;thread added: %d\n&quot;, threadinfo-&gt;lwp_id);
 196   print_debug(&quot;registers:\n&quot;);
 197   print_debug(&quot;  r_r15: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_r15);
 198   print_debug(&quot;  r_r14: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_r14);
 199   print_debug(&quot;  r_r13: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_r13);
 200   print_debug(&quot;  r_r12: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_r12);
 201   print_debug(&quot;  r_r11: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_r11);
 202   print_debug(&quot;  r_r10: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_r10);
 203   print_debug(&quot;  r_r9:  0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_r9);
 204   print_debug(&quot;  r_r8:  0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_r8);
 205   print_debug(&quot;  r_rdi: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rdi);
 206   print_debug(&quot;  r_rsi: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rsi);
 207   print_debug(&quot;  r_rbp: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rbp);
 208   print_debug(&quot;  r_rbx: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rbx);
 209   print_debug(&quot;  r_rdx: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rdx);
 210   print_debug(&quot;  r_rcx: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rcx);
 211   print_debug(&quot;  r_rax: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rax);
 212   print_debug(&quot;  r_fs:  0x%&quot; PRIx32 &quot;\n&quot;, threadinfo-&gt;regs.r_fs);
 213   print_debug(&quot;  r_gs:  0x%&quot; PRIx32 &quot;\n&quot;, threadinfo-&gt;regs.r_gs);
 214   print_debug(&quot;  r_rip  0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rip);
 215   print_debug(&quot;  r_cs:  0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_cs);
 216   print_debug(&quot;  r_rsp: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rsp);
 217   print_debug(&quot;  r_rflags: 0x%&quot; PRIx64 &quot;\n&quot;, threadinfo-&gt;regs.r_rflags);
 218 }
 219 
 220 // read all segments64 commands from core file
 221 // read all thread commands from core file
 222 static bool read_core_segments(struct ps_prochandle* ph) {
 223   int i = 0;
 224   int num_threads = 0;
 225   int fd = ph-&gt;core-&gt;core_fd;
 226   off_t offset = 0;
 227   mach_header_64      fhead;
 228   load_command        lcmd;
 229   segment_command_64  segcmd;
 230   // thread_command      thrcmd;
 231 
 232   lseek(fd, offset, SEEK_SET);
 233   if(read(fd, (void *)&amp;fhead, sizeof(mach_header_64)) != sizeof(mach_header_64)) {
 234      goto err;
 235   }
 236   print_debug(&quot;total commands: %d\n&quot;, fhead.ncmds);
 237   offset += sizeof(mach_header_64);
 238   for (i = 0; i &lt; fhead.ncmds; i++) {
 239     lseek(fd, offset, SEEK_SET);
 240     if (read(fd, (void *)&amp;lcmd, sizeof(load_command)) != sizeof(load_command)) {
 241       goto err;
 242     }
 243     offset += lcmd.cmdsize;    // next command position
 244     if (lcmd.cmd == LC_SEGMENT_64) {
 245       lseek(fd, -sizeof(load_command), SEEK_CUR);
 246       if (read(fd, (void *)&amp;segcmd, sizeof(segment_command_64)) != sizeof(segment_command_64)) {
 247         print_debug(&quot;failed to read LC_SEGMENT_64 i = %d!\n&quot;, i);
 248         goto err;
 249       }
 250       if (add_map_info(ph, fd, segcmd.fileoff, segcmd.vmaddr, segcmd.vmsize) == NULL) {
 251         print_debug(&quot;Failed to add map_info at i = %d\n&quot;, i);
 252         goto err;
 253       }
 254       print_debug(&quot;segment added: %&quot; PRIu64 &quot; 0x%&quot; PRIx64 &quot; %d\n&quot;,
 255                    segcmd.fileoff, segcmd.vmaddr, segcmd.vmsize);
 256     } else if (lcmd.cmd == LC_THREAD || lcmd.cmd == LC_UNIXTHREAD) {
 257       typedef struct thread_fc {
 258         uint32_t  flavor;
 259         uint32_t  count;
 260       } thread_fc;
 261       thread_fc fc;
 262       uint32_t size = sizeof(load_command);
 263       while (size &lt; lcmd.cmdsize) {
 264         if (read(fd, (void *)&amp;fc, sizeof(thread_fc)) != sizeof(thread_fc)) {
 265           printf(&quot;Reading flavor, count failed.\n&quot;);
 266           goto err;
 267         }
 268         size += sizeof(thread_fc);
 269         if (fc.flavor == x86_THREAD_STATE) {
 270           x86_thread_state_t thrstate;
 271           if (read(fd, (void *)&amp;thrstate, sizeof(x86_thread_state_t)) != sizeof(x86_thread_state_t)) {
 272             printf(&quot;Reading flavor, count failed.\n&quot;);
 273             goto err;
 274           }
 275           size += sizeof(x86_thread_state_t);
 276           // create thread info list, update lwp_id later
 277           sa_thread_info* newthr = add_thread_info(ph, (pthread_t) -1, (lwpid_t) num_threads++);
 278           if (newthr == NULL) {
 279             printf(&quot;create thread_info failed\n&quot;);
 280             goto err;
 281           }
 282 
 283           // note __DARWIN_UNIX03 depengs on other definitions
 284 #if __DARWIN_UNIX03
 285 #define get_register_v(regst, regname) \
 286   regst.uts.ts64.__##regname
 287 #else
 288 #define get_register_v(regst, regname) \
 289   regst.uts.ts64.##regname
 290 #endif // __DARWIN_UNIX03
 291           newthr-&gt;regs.r_rax = get_register_v(thrstate, rax);
 292           newthr-&gt;regs.r_rbx = get_register_v(thrstate, rbx);
 293           newthr-&gt;regs.r_rcx = get_register_v(thrstate, rcx);
 294           newthr-&gt;regs.r_rdx = get_register_v(thrstate, rdx);
 295           newthr-&gt;regs.r_rdi = get_register_v(thrstate, rdi);
 296           newthr-&gt;regs.r_rsi = get_register_v(thrstate, rsi);
 297           newthr-&gt;regs.r_rbp = get_register_v(thrstate, rbp);
 298           newthr-&gt;regs.r_rsp = get_register_v(thrstate, rsp);
 299           newthr-&gt;regs.r_r8  = get_register_v(thrstate, r8);
 300           newthr-&gt;regs.r_r9  = get_register_v(thrstate, r9);
 301           newthr-&gt;regs.r_r10 = get_register_v(thrstate, r10);
 302           newthr-&gt;regs.r_r11 = get_register_v(thrstate, r11);
 303           newthr-&gt;regs.r_r12 = get_register_v(thrstate, r12);
 304           newthr-&gt;regs.r_r13 = get_register_v(thrstate, r13);
 305           newthr-&gt;regs.r_r14 = get_register_v(thrstate, r14);
 306           newthr-&gt;regs.r_r15 = get_register_v(thrstate, r15);
 307           newthr-&gt;regs.r_rip = get_register_v(thrstate, rip);
 308           newthr-&gt;regs.r_rflags = get_register_v(thrstate, rflags);
 309           newthr-&gt;regs.r_cs  = get_register_v(thrstate, cs);
 310           newthr-&gt;regs.r_fs  = get_register_v(thrstate, fs);
 311           newthr-&gt;regs.r_gs  = get_register_v(thrstate, gs);
 312           print_thread(newthr);
 313         } else if (fc.flavor == x86_FLOAT_STATE) {
 314           x86_float_state_t flstate;
 315           if (read(fd, (void *)&amp;flstate, sizeof(x86_float_state_t)) != sizeof(x86_float_state_t)) {
 316             print_debug(&quot;Reading flavor, count failed.\n&quot;);
 317             goto err;
 318           }
 319           size += sizeof(x86_float_state_t);
 320         } else if (fc.flavor == x86_EXCEPTION_STATE) {
 321           x86_exception_state_t excpstate;
 322           if (read(fd, (void *)&amp;excpstate, sizeof(x86_exception_state_t)) != sizeof(x86_exception_state_t)) {
 323             printf(&quot;Reading flavor, count failed.\n&quot;);
 324             goto err;
 325           }
 326           size += sizeof(x86_exception_state_t);
 327         }
 328       }
 329     }
 330   }
 331   return true;
 332 err:
 333   return false;
 334 }
 335 
 336 /**local function **/
 337 bool exists(const char *fname) {
 338   return access(fname, F_OK) == 0;
 339 }
 340 
 341 // we check: 1. lib
 342 //           2. lib/server
 343 //           3. jre/lib
 344 //           4. jre/lib/server
 345 // from: 1. exe path
 346 //       2. JAVA_HOME
 347 //       3. DYLD_LIBRARY_PATH
 348 static bool get_real_path(struct ps_prochandle* ph, char *rpath) {
 349   /** check if they exist in JAVA ***/
 350   char* execname = ph-&gt;core-&gt;exec_path;
 351   char  filepath[4096];
 352   char* filename = strrchr(rpath, &#39;/&#39;);               // like /libjvm.dylib
 353   if (filename == NULL) {
 354     return false;
 355   }
 356 
 357   char* posbin = strstr(execname, &quot;/bin/java&quot;);
 358   if (posbin != NULL) {
 359     memcpy(filepath, execname, posbin - execname);    // not include trailing &#39;/&#39;
 360     filepath[posbin - execname] = &#39;\0&#39;;
 361   } else {
 362     char* java_home = getenv(&quot;JAVA_HOME&quot;);
 363     if (java_home != NULL) {
 364       strcpy(filepath, java_home);
 365     } else {
 366       char* dyldpath = getenv(&quot;DYLD_LIBRARY_PATH&quot;);
 367       char* save_ptr;
 368       char* dypath = strtok_r(dyldpath, &quot;:&quot;, &amp;save_ptr);
 369       while (dypath != NULL) {
 370         strcpy(filepath, dypath);
 371         strcat(filepath, filename);
 372         if (exists(filepath)) {
 373            strcpy(rpath, filepath);
 374            return true;
 375         }
 376         dypath = strtok_r(NULL, &quot;:&quot;, &amp;save_ptr);
 377       }
 378       // not found
 379       return false;
 380     }
 381   }
 382   // for exec and java_home, jdkpath now is filepath
 383   size_t filepath_base_size = strlen(filepath);
 384 
 385   // first try /lib/ and /lib/server
 386   strcat(filepath, &quot;/lib&quot;);
 387   strcat(filepath, filename);
 388   if (exists(filepath)) {
 389     strcpy(rpath, filepath);
 390     return true;
 391   }
 392   char* pos = strstr(filepath, filename);    // like /libjvm.dylib
 393   *pos = &#39;\0&#39;;
 394   strcat(filepath, &quot;/server&quot;);
 395   strcat(filepath, filename);
 396   if (exists(filepath)) {
 397     strcpy(rpath, filepath);
 398     return true;
 399   }
 400 
 401   // then try /jre/lib/ and /jre/lib/server
 402   filepath[filepath_base_size] = &#39;\0&#39;;
 403   strcat(filepath, &quot;/jre/lib&quot;);
 404   strcat(filepath, filename);
 405   if (exists(filepath)) {
 406     strcpy(rpath, filepath);
 407     return true;
 408   }
 409   pos = strstr(filepath, filename);
 410   *pos = &#39;\0&#39;;
 411   strcat(filepath, &quot;/server&quot;);
 412   strcat(filepath, filename);
 413   if (exists(filepath)) {
 414     strcpy(rpath, filepath);
 415     return true;
 416   }
 417 
 418   return false;
 419 }
 420 
 421 static bool read_shared_lib_info(struct ps_prochandle* ph) {
 422   static int pagesize = 0;
 423   int fd = ph-&gt;core-&gt;core_fd;
 424   int i = 0, j;
 425   uint32_t  v;
 426   mach_header_64 header;        // used to check if a file header in segment
 427   load_command lcmd;
 428   dylib_command dylibcmd;
 429 
 430   char name[BUF_SIZE];  // use to store name
 431 
 432   if (pagesize == 0) {
 433     pagesize = getpagesize();
 434     print_debug(&quot;page size is %d\n&quot;, pagesize);
 435   }
 436   for (j = 0; j &lt; ph-&gt;core-&gt;num_maps; j++) {
 437     map_info *iter = ph-&gt;core-&gt;map_array[j];   // head
 438     off_t fpos = iter-&gt;offset;
 439     if (iter-&gt;fd != fd) {
 440       // only search core file!
 441       continue;
 442     }
 443     print_debug(&quot;map_info %d: vmaddr = 0x%016&quot; PRIx64 &quot;  fileoff = %&quot; PRIu64 &quot;  vmsize = %&quot; PRIu64 &quot;\n&quot;,
 444                            j, iter-&gt;vaddr, iter-&gt;offset, iter-&gt;memsz);
 445     lseek(fd, fpos, SEEK_SET);
 446     // we assume .dylib loaded at segment address --- which is true for JVM libraries
 447     // multiple files may be loaded in one segment.
 448     // if first word is not a magic word, means this segment does not contain lib file.
 449     if (read(fd, (void *)&amp;v, sizeof(uint32_t)) == sizeof(uint32_t)) {
 450       if (v != MH_MAGIC_64) {
 451         continue;
 452       }
 453     } else {
 454       // may be encountered last map, which is not readable
 455       continue;
 456     }
 457     while (ltell(fd) - iter-&gt;offset &lt; iter-&gt;memsz) {
 458       lseek(fd, fpos, SEEK_SET);
 459       if (read(fd, (void *)&amp;v, sizeof(uint32_t)) != sizeof(uint32_t)) {
 460         break;
 461       }
 462       if (v != MH_MAGIC_64) {
 463         fpos = (ltell(fd) + pagesize -1)/pagesize * pagesize;
 464         continue;
 465       }
 466       lseek(fd, -sizeof(uint32_t), SEEK_CUR);
 467       // this is the file begining to core file.
 468       if (read(fd, (void *)&amp;header, sizeof(mach_header_64)) != sizeof(mach_header_64)) {
 469         goto err;
 470       }
 471       fpos = ltell(fd);
 472 
 473       // found a mach-o file in this segment
 474       for (i = 0; i &lt; header.ncmds; i++) {
 475         // read commands in this &quot;file&quot;
 476         // LC_ID_DYLIB is the file itself for a .dylib
 477         lseek(fd, fpos, SEEK_SET);
 478         if (read(fd, (void *)&amp;lcmd, sizeof(load_command)) != sizeof(load_command)) {
 479           return false;   // error
 480         }
 481         fpos += lcmd.cmdsize;  // next command position
 482         // make sure still within seg size.
 483         if (fpos  - lcmd.cmdsize - iter-&gt;offset &gt; iter-&gt;memsz) {
 484           print_debug(&quot;Warning: out of segement limit: %ld \n&quot;, fpos  - lcmd.cmdsize - iter-&gt;offset);
 485           break;  // no need to iterate all commands
 486         }
 487         if (lcmd.cmd == LC_ID_DYLIB) {
 488           lseek(fd, -sizeof(load_command), SEEK_CUR);
 489           if (read(fd, (void *)&amp;dylibcmd, sizeof(dylib_command)) != sizeof(dylib_command)) {
 490             return false;
 491           }
 492           /**** name stored at dylib_command.dylib.name.offset, is a C string  */
 493           lseek(fd, dylibcmd.dylib.name.offset - sizeof(dylib_command), SEEK_CUR);
 494           int j = 0;
 495           while (j &lt; BUF_SIZE) {
 496             read(fd, (void *)(name + j), sizeof(char));
 497             if (name[j] == &#39;\0&#39;) break;
 498             j++;
 499           }
 500           print_debug(&quot;%s\n&quot;, name);
 501           // changed name from @rpath/xxxx.dylib to real path
 502           if (strrchr(name, &#39;@&#39;)) {
 503             get_real_path(ph, name);
 504             print_debug(&quot;get_real_path returned: %s\n&quot;, name);
 505           }
 506           add_lib_info(ph, name, iter-&gt;vaddr);
 507           break;
 508         }
 509       }
 510       // done with the file, advanced to next page to search more files
 511       fpos = (ltell(fd) + pagesize - 1) / pagesize * pagesize;
 512     }
 513   }
 514   return true;
 515 err:
 516   return false;
 517 }
 518 
 519 bool read_macho64_header(int fd, mach_header_64* core_header) {
 520   bool is_macho = false;
 521   if (fd &lt; 0) return false;
 522   off_t pos = ltell(fd);
 523   lseek(fd, 0, SEEK_SET);
 524   if (read(fd, (void *)core_header, sizeof(mach_header_64)) != sizeof(mach_header_64)) {
 525     is_macho = false;
 526   } else {
 527     is_macho = (core_header-&gt;magic ==  MH_MAGIC_64 || core_header-&gt;magic ==  MH_CIGAM_64);
 528   }
 529   lseek(fd, pos, SEEK_SET);
 530   return is_macho;
 531 }
 532 
 533 // the one and only one exposed stuff from this file
 534 struct ps_prochandle* Pgrab_core(const char* exec_file, const char* core_file) {
 535   mach_header_64 core_header;
 536   mach_header_64 exec_header;
 537 
 538   struct ps_prochandle* ph = (struct ps_prochandle*) calloc(1, sizeof(struct ps_prochandle));
 539   if (ph == NULL) {
 540     print_debug(&quot;cant allocate ps_prochandle\n&quot;);
 541     return NULL;
 542   }
 543 
 544   if ((ph-&gt;core = (struct core_data*) calloc(1, sizeof(struct core_data))) == NULL) {
 545     free(ph);
 546     print_debug(&quot;can&#39;t allocate ps_prochandle\n&quot;);
 547     return NULL;
 548   }
 549 
 550   // initialize ph
 551   ph-&gt;ops = &amp;core_ops;
 552   ph-&gt;core-&gt;core_fd   = -1;
 553   ph-&gt;core-&gt;exec_fd   = -1;
 554   ph-&gt;core-&gt;interp_fd = -1;
 555 
 556   print_debug(&quot;exec: %s   core: %s&quot;, exec_file, core_file);
 557 
 558   strncpy(ph-&gt;core-&gt;exec_path, exec_file, sizeof(ph-&gt;core-&gt;exec_path));
 559 
 560   // open the core file
 561   if ((ph-&gt;core-&gt;core_fd = open(core_file, O_RDONLY)) &lt; 0) {
 562     print_error(&quot;can&#39;t open core file\n&quot;);
 563     goto err;
 564   }
 565 
 566   // read core file header
 567   if (read_macho64_header(ph-&gt;core-&gt;core_fd, &amp;core_header) != true || core_header.filetype != MH_CORE) {
 568     print_debug(&quot;core file is not a valid Mach-O file\n&quot;);
 569     goto err;
 570   }
 571 
 572   if ((ph-&gt;core-&gt;exec_fd = open(exec_file, O_RDONLY)) &lt; 0) {
 573     print_error(&quot;can&#39;t open executable file\n&quot;);
 574     goto err;
 575   }
 576 
 577   if (read_macho64_header(ph-&gt;core-&gt;exec_fd, &amp;exec_header) != true ||
 578                           exec_header.filetype != MH_EXECUTE) {
 579     print_error(&quot;executable file is not a valid Mach-O file\n&quot;);
 580     goto err;
 581   }
 582 
 583   // process core file segments
 584   if (read_core_segments(ph) != true) {
 585     print_error(&quot;failed to read core segments\n&quot;);
 586     goto err;
 587   }
 588 
 589   // allocate and sort maps into map_array, we need to do this
 590   // here because read_shared_lib_info needs to read from debuggee
 591   // address space
 592   if (sort_map_array(ph) != true) {
 593     print_error(&quot;failed to sort segment map array\n&quot;);
 594     goto err;
 595   }
 596 
 597   if (read_shared_lib_info(ph) != true) {
 598     print_error(&quot;failed to read libraries\n&quot;);
 599     goto err;
 600   }
 601 
 602   // sort again because we have added more mappings from shared objects
 603   if (sort_map_array(ph) != true) {
 604     print_error(&quot;failed to sort segment map array\n&quot;);
 605     goto err;
 606   }
 607 
 608   if (init_classsharing_workaround(ph) != true) {
 609     print_error(&quot;failed to workaround classshareing\n&quot;);
 610     goto err;
 611   }
 612 
 613   print_debug(&quot;Leave Pgrab_core\n&quot;);
 614   return ph;
 615 
 616 err:
 617   Prelease(ph);
 618   return NULL;
 619 }
 620 
 621 #else // __APPLE__ (none macosx)
 622 
 623 // read regs and create thread from core file
 624 static bool core_handle_prstatus(struct ps_prochandle* ph, const char* buf, size_t nbytes) {
 625    // we have to read prstatus_t from buf
 626    // assert(nbytes == sizeof(prstaus_t), &quot;size mismatch on prstatus_t&quot;);
 627    prstatus_t* prstat = (prstatus_t*) buf;
 628    sa_thread_info* newthr;
 629    print_debug(&quot;got integer regset for lwp %d\n&quot;, prstat-&gt;pr_pid);
 630    // we set pthread_t to -1 for core dump
 631    if((newthr = add_thread_info(ph, (pthread_t) -1,  prstat-&gt;pr_pid)) == NULL)
 632       return false;
 633 
 634    // copy regs
 635    memcpy(&amp;newthr-&gt;regs, &amp;prstat-&gt;pr_reg, sizeof(struct reg));
 636 
 637    if (is_debug()) {
 638       print_debug(&quot;integer regset\n&quot;);
 639 #if defined(i586) || defined(i386)
 640       // print the regset
 641       print_debug(&quot;\teax = 0x%x\n&quot;, newthr-&gt;regs.r_eax);
 642       print_debug(&quot;\tebx = 0x%x\n&quot;, newthr-&gt;regs.r_ebx);
 643       print_debug(&quot;\tecx = 0x%x\n&quot;, newthr-&gt;regs.r_ecx);
 644       print_debug(&quot;\tedx = 0x%x\n&quot;, newthr-&gt;regs.r_edx);
 645       print_debug(&quot;\tesp = 0x%x\n&quot;, newthr-&gt;regs.r_esp);
 646       print_debug(&quot;\tebp = 0x%x\n&quot;, newthr-&gt;regs.r_ebp);
 647       print_debug(&quot;\tesi = 0x%x\n&quot;, newthr-&gt;regs.r_esi);
 648       print_debug(&quot;\tedi = 0x%x\n&quot;, newthr-&gt;regs.r_edi);
 649       print_debug(&quot;\teip = 0x%x\n&quot;, newthr-&gt;regs.r_eip);
 650 #endif
 651 
 652 #if defined(amd64) || defined(x86_64)
 653       // print the regset
 654       print_debug(&quot;\tr15 = 0x%lx\n&quot;, newthr-&gt;regs.r_r15);
 655       print_debug(&quot;\tr14 = 0x%lx\n&quot;, newthr-&gt;regs.r_r14);
 656       print_debug(&quot;\tr13 = 0x%lx\n&quot;, newthr-&gt;regs.r_r13);
 657       print_debug(&quot;\tr12 = 0x%lx\n&quot;, newthr-&gt;regs.r_r12);
 658       print_debug(&quot;\trbp = 0x%lx\n&quot;, newthr-&gt;regs.r_rbp);
 659       print_debug(&quot;\trbx = 0x%lx\n&quot;, newthr-&gt;regs.r_rbx);
 660       print_debug(&quot;\tr11 = 0x%lx\n&quot;, newthr-&gt;regs.r_r11);
 661       print_debug(&quot;\tr10 = 0x%lx\n&quot;, newthr-&gt;regs.r_r10);
 662       print_debug(&quot;\tr9 = 0x%lx\n&quot;, newthr-&gt;regs.r_r9);
 663       print_debug(&quot;\tr8 = 0x%lx\n&quot;, newthr-&gt;regs.r_r8);
 664       print_debug(&quot;\trax = 0x%lx\n&quot;, newthr-&gt;regs.r_rax);
 665       print_debug(&quot;\trcx = 0x%lx\n&quot;, newthr-&gt;regs.r_rcx);
 666       print_debug(&quot;\trdx = 0x%lx\n&quot;, newthr-&gt;regs.r_rdx);
 667       print_debug(&quot;\trsi = 0x%lx\n&quot;, newthr-&gt;regs.r_rsi);
 668       print_debug(&quot;\trdi = 0x%lx\n&quot;, newthr-&gt;regs.r_rdi);
 669       //print_debug(&quot;\torig_rax = 0x%lx\n&quot;, newthr-&gt;regs.orig_rax);
 670       print_debug(&quot;\trip = 0x%lx\n&quot;, newthr-&gt;regs.r_rip);
 671       print_debug(&quot;\tcs = 0x%lx\n&quot;, newthr-&gt;regs.r_cs);
 672       //print_debug(&quot;\teflags = 0x%lx\n&quot;, newthr-&gt;regs.eflags);
 673       print_debug(&quot;\trsp = 0x%lx\n&quot;, newthr-&gt;regs.r_rsp);
 674       print_debug(&quot;\tss = 0x%lx\n&quot;, newthr-&gt;regs.r_ss);
 675       //print_debug(&quot;\tfs_base = 0x%lx\n&quot;, newthr-&gt;regs.fs_base);
 676       //print_debug(&quot;\tgs_base = 0x%lx\n&quot;, newthr-&gt;regs.gs_base);
 677       //print_debug(&quot;\tds = 0x%lx\n&quot;, newthr-&gt;regs.ds);
 678       //print_debug(&quot;\tes = 0x%lx\n&quot;, newthr-&gt;regs.es);
 679       //print_debug(&quot;\tfs = 0x%lx\n&quot;, newthr-&gt;regs.fs);
 680       //print_debug(&quot;\tgs = 0x%lx\n&quot;, newthr-&gt;regs.gs);
 681 #endif
 682    }
 683 
 684    return true;
 685 }
 686 
 687 #define ROUNDUP(x, y)  ((((x)+((y)-1))/(y))*(y))
 688 
 689 // read NT_PRSTATUS entries from core NOTE segment
 690 static bool core_handle_note(struct ps_prochandle* ph, ELF_PHDR* note_phdr) {
 691    char* buf = NULL;
 692    char* p = NULL;
 693    size_t size = note_phdr-&gt;p_filesz;
 694 
 695    // we are interested in just prstatus entries. we will ignore the rest.
 696    // Advance the seek pointer to the start of the PT_NOTE data
 697    if (lseek(ph-&gt;core-&gt;core_fd, note_phdr-&gt;p_offset, SEEK_SET) == (off_t)-1) {
 698       print_debug(&quot;failed to lseek to PT_NOTE data\n&quot;);
 699       return false;
 700    }
 701 
 702    // Now process the PT_NOTE structures.  Each one is preceded by
 703    // an Elf{32/64}_Nhdr structure describing its type and size.
 704    if ( (buf = (char*) malloc(size)) == NULL) {
 705       print_debug(&quot;can&#39;t allocate memory for reading core notes\n&quot;);
 706       goto err;
 707    }
 708 
 709    // read notes into buffer
 710    if (read(ph-&gt;core-&gt;core_fd, buf, size) != size) {
 711       print_debug(&quot;failed to read notes, core file must have been truncated\n&quot;);
 712       goto err;
 713    }
 714 
 715    p = buf;
 716    while (p &lt; buf + size) {
 717       ELF_NHDR* notep = (ELF_NHDR*) p;
 718       char* descdata  = p + sizeof(ELF_NHDR) + ROUNDUP(notep-&gt;n_namesz, 4);
 719       print_debug(&quot;Note header with n_type = %d and n_descsz = %u\n&quot;,
 720                                    notep-&gt;n_type, notep-&gt;n_descsz);
 721 
 722       if (notep-&gt;n_type == NT_PRSTATUS) {
 723         if (core_handle_prstatus(ph, descdata, notep-&gt;n_descsz) != true) {
 724           return false;
 725         }
 726       }
 727       p = descdata + ROUNDUP(notep-&gt;n_descsz, 4);
 728    }
 729 
 730    free(buf);
 731    return true;
 732 
 733 err:
 734    if (buf) free(buf);
 735    return false;
 736 }
 737 
 738 // read all segments from core file
 739 static bool read_core_segments(struct ps_prochandle* ph, ELF_EHDR* core_ehdr) {
 740    int i = 0;
 741    ELF_PHDR* phbuf = NULL;
 742    ELF_PHDR* core_php = NULL;
 743 
 744    if ((phbuf =  read_program_header_table(ph-&gt;core-&gt;core_fd, core_ehdr)) == NULL)
 745       return false;
 746 
 747    /*
 748     * Now iterate through the program headers in the core file.
 749     * We&#39;re interested in two types of Phdrs: PT_NOTE (which
 750     * contains a set of saved /proc structures), and PT_LOAD (which
 751     * represents a memory mapping from the process&#39;s address space).
 752     *
 753     * Difference b/w Solaris PT_NOTE and Linux/BSD PT_NOTE:
 754     *
 755     *     In Solaris there are two PT_NOTE segments the first PT_NOTE (if present)
 756     *     contains /proc structs in the pre-2.6 unstructured /proc format. the last
 757     *     PT_NOTE has data in new /proc format.
 758     *
 759     *     In Solaris, there is only one pstatus (process status). pstatus contains
 760     *     integer register set among other stuff. For each LWP, we have one lwpstatus
 761     *     entry that has integer regset for that LWP.
 762     *
 763     *     Linux threads are actually &#39;clone&#39;d processes. To support core analysis
 764     *     of &quot;multithreaded&quot; process, Linux creates more than one pstatus (called
 765     *     &quot;prstatus&quot;) entry in PT_NOTE. Each prstatus entry has integer regset for one
 766     *     &quot;thread&quot;. Please refer to Linux kernel src file &#39;fs/binfmt_elf.c&#39;, in particular
 767     *     function &quot;elf_core_dump&quot;.
 768     */
 769 
 770     for (core_php = phbuf, i = 0; i &lt; core_ehdr-&gt;e_phnum; i++) {
 771       switch (core_php-&gt;p_type) {
 772          case PT_NOTE:
 773             if (core_handle_note(ph, core_php) != true) {
 774               goto err;
 775             }
 776             break;
 777 
 778          case PT_LOAD: {
 779             if (core_php-&gt;p_filesz != 0) {
 780                if (add_map_info(ph, ph-&gt;core-&gt;core_fd, core_php-&gt;p_offset,
 781                   core_php-&gt;p_vaddr, core_php-&gt;p_filesz) == NULL) goto err;
 782             }
 783             break;
 784          }
 785       }
 786 
 787       core_php++;
 788    }
 789 
 790    free(phbuf);
 791    return true;
 792 err:
 793    free(phbuf);
 794    return false;
 795 }
 796 
 797 // read segments of a shared object
 798 static bool read_lib_segments(struct ps_prochandle* ph, int lib_fd, ELF_EHDR* lib_ehdr, uintptr_t lib_base) {
 799   int i = 0;
 800   ELF_PHDR* phbuf;
 801   ELF_PHDR* lib_php = NULL;
 802 
 803   int page_size=sysconf(_SC_PAGE_SIZE);
 804 
 805   if ((phbuf = read_program_header_table(lib_fd, lib_ehdr)) == NULL) {
 806     return false;
 807   }
 808 
 809   // we want to process only PT_LOAD segments that are not writable.
 810   // i.e., text segments. The read/write/exec (data) segments would
 811   // have been already added from core file segments.
 812   for (lib_php = phbuf, i = 0; i &lt; lib_ehdr-&gt;e_phnum; i++) {
 813     if ((lib_php-&gt;p_type == PT_LOAD) &amp;&amp; !(lib_php-&gt;p_flags &amp; PF_W) &amp;&amp; (lib_php-&gt;p_filesz != 0)) {
 814 
 815       uintptr_t target_vaddr = lib_php-&gt;p_vaddr + lib_base;
 816       map_info *existing_map = core_lookup(ph, target_vaddr);
 817 
 818       if (existing_map == NULL){
 819         if (add_map_info(ph, lib_fd, lib_php-&gt;p_offset,
 820                           target_vaddr, lib_php-&gt;p_filesz) == NULL) {
 821           goto err;
 822         }
 823       } else {
 824         if ((existing_map-&gt;memsz != page_size) &amp;&amp;
 825             (existing_map-&gt;fd != lib_fd) &amp;&amp;
 826             (existing_map-&gt;memsz != lib_php-&gt;p_filesz)){
 827 
 828           print_debug(&quot;address conflict @ 0x%lx (size = %ld, flags = %d\n)&quot;,
 829                         target_vaddr, lib_php-&gt;p_filesz, lib_php-&gt;p_flags);
 830           goto err;
 831         }
 832 
 833         /* replace PT_LOAD segment with library segment */
 834         print_debug(&quot;overwrote with new address mapping (memsz %ld -&gt; %ld)\n&quot;,
 835                      existing_map-&gt;memsz, lib_php-&gt;p_filesz);
 836 
 837         existing_map-&gt;fd = lib_fd;
 838         existing_map-&gt;offset = lib_php-&gt;p_offset;
 839         existing_map-&gt;memsz = lib_php-&gt;p_filesz;
 840       }
 841     }
 842 
 843     lib_php++;
 844   }
 845 
 846   free(phbuf);
 847   return true;
 848 err:
 849   free(phbuf);
 850   return false;
 851 }
 852 
 853 // process segments from interpreter (ld.so or ld-linux.so or ld-elf.so)
 854 static bool read_interp_segments(struct ps_prochandle* ph) {
 855    ELF_EHDR interp_ehdr;
 856 
 857    if (read_elf_header(ph-&gt;core-&gt;interp_fd, &amp;interp_ehdr) != true) {
 858        print_debug(&quot;interpreter is not a valid ELF file\n&quot;);
 859        return false;
 860    }
 861 
 862    if (read_lib_segments(ph, ph-&gt;core-&gt;interp_fd, &amp;interp_ehdr, ph-&gt;core-&gt;ld_base_addr) != true) {
 863        print_debug(&quot;can&#39;t read segments of interpreter\n&quot;);
 864        return false;
 865    }
 866 
 867    return true;
 868 }
 869 
 870 // process segments of a a.out
 871 static bool read_exec_segments(struct ps_prochandle* ph, ELF_EHDR* exec_ehdr) {
 872    int i = 0;
 873    ELF_PHDR* phbuf = NULL;
 874    ELF_PHDR* exec_php = NULL;
 875 
 876    if ((phbuf = read_program_header_table(ph-&gt;core-&gt;exec_fd, exec_ehdr)) == NULL)
 877       return false;
 878 
 879    for (exec_php = phbuf, i = 0; i &lt; exec_ehdr-&gt;e_phnum; i++) {
 880       switch (exec_php-&gt;p_type) {
 881 
 882          // add mappings for PT_LOAD segments
 883          case PT_LOAD: {
 884             // add only non-writable segments of non-zero filesz
 885             if (!(exec_php-&gt;p_flags &amp; PF_W) &amp;&amp; exec_php-&gt;p_filesz != 0) {
 886                if (add_map_info(ph, ph-&gt;core-&gt;exec_fd, exec_php-&gt;p_offset, exec_php-&gt;p_vaddr, exec_php-&gt;p_filesz) == NULL) goto err;
 887             }
 888             break;
 889          }
 890 
 891          // read the interpreter and it&#39;s segments
 892          case PT_INTERP: {
 893             char interp_name[BUF_SIZE];
 894 
 895             pread(ph-&gt;core-&gt;exec_fd, interp_name, MIN(exec_php-&gt;p_filesz, BUF_SIZE), exec_php-&gt;p_offset);
 896             print_debug(&quot;ELF interpreter %s\n&quot;, interp_name);
 897             // read interpreter segments as well
 898             if ((ph-&gt;core-&gt;interp_fd = pathmap_open(interp_name)) &lt; 0) {
 899                print_debug(&quot;can&#39;t open runtime loader\n&quot;);
 900                goto err;
 901             }
 902             break;
 903          }
 904 
 905          // from PT_DYNAMIC we want to read address of first link_map addr
 906          case PT_DYNAMIC: {
 907             ph-&gt;core-&gt;dynamic_addr = exec_php-&gt;p_vaddr;
 908             print_debug(&quot;address of _DYNAMIC is 0x%lx\n&quot;, ph-&gt;core-&gt;dynamic_addr);
 909             break;
 910          }
 911 
 912       } // switch
 913       exec_php++;
 914    } // for
 915 
 916    free(phbuf);
 917    return true;
 918 err:
 919    free(phbuf);
 920    return false;
 921 }
 922 
 923 #define FIRST_LINK_MAP_OFFSET offsetof(struct r_debug,  r_map)
 924 #define LD_BASE_OFFSET        offsetof(struct r_debug,  r_ldbase)
 925 #define LINK_MAP_ADDR_OFFSET  offsetof(struct link_map, l_addr)
 926 #define LINK_MAP_NAME_OFFSET  offsetof(struct link_map, l_name)
 927 #define LINK_MAP_NEXT_OFFSET  offsetof(struct link_map, l_next)
 928 
 929 // read shared library info from runtime linker&#39;s data structures.
 930 // This work is done by librtlb_db in Solaris
 931 static bool read_shared_lib_info(struct ps_prochandle* ph) {
 932   uintptr_t addr = ph-&gt;core-&gt;dynamic_addr;
 933   uintptr_t debug_base;
 934   uintptr_t first_link_map_addr;
 935   uintptr_t ld_base_addr;
 936   uintptr_t link_map_addr;
 937   uintptr_t lib_base_diff;
 938   uintptr_t lib_base;
 939   uintptr_t lib_name_addr;
 940   char lib_name[BUF_SIZE];
 941   ELF_DYN dyn;
 942   ELF_EHDR elf_ehdr;
 943   int lib_fd;
 944 
 945   // _DYNAMIC has information of the form
 946   //         [tag] [data] [tag] [data] .....
 947   // Both tag and data are pointer sized.
 948   // We look for dynamic info with DT_DEBUG. This has shared object info.
 949   // refer to struct r_debug in link.h
 950 
 951   dyn.d_tag = DT_NULL;
 952   while (dyn.d_tag != DT_DEBUG) {
 953     if (ps_pread(ph, (psaddr_t) addr, &amp;dyn, sizeof(ELF_DYN)) != PS_OK) {
 954       print_debug(&quot;can&#39;t read debug info from _DYNAMIC\n&quot;);
 955       return false;
 956     }
 957     addr += sizeof(ELF_DYN);
 958   }
 959 
 960   // we have got Dyn entry with DT_DEBUG
 961   debug_base = dyn.d_un.d_ptr;
 962   // at debug_base we have struct r_debug. This has first link map in r_map field
 963   if (ps_pread(ph, (psaddr_t) debug_base + FIRST_LINK_MAP_OFFSET,
 964                  &amp;first_link_map_addr, sizeof(uintptr_t)) != PS_OK) {
 965     print_debug(&quot;can&#39;t read first link map address\n&quot;);
 966     return false;
 967   }
 968 
 969   // read ld_base address from struct r_debug
 970 #if 0  // There is no r_ldbase member on BSD
 971   if (ps_pread(ph, (psaddr_t) debug_base + LD_BASE_OFFSET, &amp;ld_base_addr,
 972                   sizeof(uintptr_t)) != PS_OK) {
 973     print_debug(&quot;can&#39;t read ld base address\n&quot;);
 974     return false;
 975   }
 976   ph-&gt;core-&gt;ld_base_addr = ld_base_addr;
 977 #else
 978   ph-&gt;core-&gt;ld_base_addr = 0;
 979 #endif
 980 
 981   print_debug(&quot;interpreter base address is 0x%lx\n&quot;, ld_base_addr);
 982 
 983   // now read segments from interp (i.e ld.so or ld-linux.so or ld-elf.so)
 984   if (read_interp_segments(ph) != true) {
 985     return false;
 986   }
 987 
 988   // after adding interpreter (ld.so) mappings sort again
 989   if (sort_map_array(ph) != true) {
 990     return false;
 991   }
 992 
 993   print_debug(&quot;first link map is at 0x%lx\n&quot;, first_link_map_addr);
 994 
 995   link_map_addr = first_link_map_addr;
 996   while (link_map_addr != 0) {
 997     // read library base address of the .so. Note that even though &lt;sys/link.h&gt; calls
 998     // link_map-&gt;l_addr as &quot;base address&quot;,  this is * not * really base virtual
 999     // address of the shared object. This is actually the difference b/w the virtual
1000     // address mentioned in shared object and the actual virtual base where runtime
1001     // linker loaded it. We use &quot;base diff&quot; in read_lib_segments call below.
1002 
1003     if (ps_pread(ph, (psaddr_t) link_map_addr + LINK_MAP_ADDR_OFFSET,
1004                  &amp;lib_base_diff, sizeof(uintptr_t)) != PS_OK) {
1005       print_debug(&quot;can&#39;t read shared object base address diff\n&quot;);
1006       return false;
1007     }
1008 
1009     // read address of the name
1010     if (ps_pread(ph, (psaddr_t) link_map_addr + LINK_MAP_NAME_OFFSET,
1011                   &amp;lib_name_addr, sizeof(uintptr_t)) != PS_OK) {
1012       print_debug(&quot;can&#39;t read address of shared object name\n&quot;);
1013       return false;
1014     }
1015 
1016     // read name of the shared object
1017     if (read_string(ph, (uintptr_t) lib_name_addr, lib_name, sizeof(lib_name)) != true) {
1018       print_debug(&quot;can&#39;t read shared object name\n&quot;);
1019       return false;
1020     }
1021 
1022     if (lib_name[0] != &#39;\0&#39;) {
1023       // ignore empty lib names
1024       lib_fd = pathmap_open(lib_name);
1025 
1026       if (lib_fd &lt; 0) {
1027         print_debug(&quot;can&#39;t open shared object %s\n&quot;, lib_name);
1028         // continue with other libraries...
1029       } else {
1030         if (read_elf_header(lib_fd, &amp;elf_ehdr)) {
1031           lib_base = lib_base_diff + find_base_address(lib_fd, &amp;elf_ehdr);
1032           print_debug(&quot;reading library %s @ 0x%lx [ 0x%lx ]\n&quot;,
1033                        lib_name, lib_base, lib_base_diff);
1034           // while adding library mappings we need to use &quot;base difference&quot;.
1035           if (! read_lib_segments(ph, lib_fd, &amp;elf_ehdr, lib_base_diff)) {
1036             print_debug(&quot;can&#39;t read shared object&#39;s segments\n&quot;);
1037             close(lib_fd);
1038             return false;
1039           }
1040           add_lib_info_fd(ph, lib_name, lib_fd, lib_base);
1041           // Map info is added for the library (lib_name) so
1042           // we need to re-sort it before calling the p_pdread.
1043           if (sort_map_array(ph) != true) {
1044             return false;
1045           }
1046         } else {
1047           print_debug(&quot;can&#39;t read ELF header for shared object %s\n&quot;, lib_name);
1048           close(lib_fd);
1049           // continue with other libraries...
1050         }
1051       }
1052     }
1053 
1054     // read next link_map address
1055     if (ps_pread(ph, (psaddr_t) link_map_addr + LINK_MAP_NEXT_OFFSET,
1056                   &amp;link_map_addr, sizeof(uintptr_t)) != PS_OK) {
1057       print_debug(&quot;can&#39;t read next link in link_map\n&quot;);
1058       return false;
1059     }
1060   }
1061 
1062   return true;
1063 }
1064 
1065 // the one and only one exposed stuff from this file
1066 struct ps_prochandle* Pgrab_core(const char* exec_file, const char* core_file) {
1067   ELF_EHDR core_ehdr;
1068   ELF_EHDR exec_ehdr;
1069 
1070   struct ps_prochandle* ph = (struct ps_prochandle*) calloc(1, sizeof(struct ps_prochandle));
1071   if (ph == NULL) {
1072     print_debug(&quot;can&#39;t allocate ps_prochandle\n&quot;);
1073     return NULL;
1074   }
1075 
1076   if ((ph-&gt;core = (struct core_data*) calloc(1, sizeof(struct core_data))) == NULL) {
1077     free(ph);
1078     print_debug(&quot;can&#39;t allocate ps_prochandle\n&quot;);
1079     return NULL;
1080   }
1081 
1082   // initialize ph
1083   ph-&gt;ops = &amp;core_ops;
1084   ph-&gt;core-&gt;core_fd   = -1;
1085   ph-&gt;core-&gt;exec_fd   = -1;
1086   ph-&gt;core-&gt;interp_fd = -1;
1087 
1088   print_debug(&quot;exec: %s   core: %s&quot;, exec_file, core_file);
1089 
1090   // open the core file
1091   if ((ph-&gt;core-&gt;core_fd = open(core_file, O_RDONLY)) &lt; 0) {
1092     print_debug(&quot;can&#39;t open core file\n&quot;);
1093     goto err;
1094   }
1095 
1096   // read core file ELF header
1097   if (read_elf_header(ph-&gt;core-&gt;core_fd, &amp;core_ehdr) != true || core_ehdr.e_type != ET_CORE) {
1098     print_debug(&quot;core file is not a valid ELF ET_CORE file\n&quot;);
1099     goto err;
1100   }
1101 
1102   if ((ph-&gt;core-&gt;exec_fd = open(exec_file, O_RDONLY)) &lt; 0) {
1103     print_debug(&quot;can&#39;t open executable file\n&quot;);
1104     goto err;
1105   }
1106 
1107   if (read_elf_header(ph-&gt;core-&gt;exec_fd, &amp;exec_ehdr) != true || exec_ehdr.e_type != ET_EXEC) {
1108     print_debug(&quot;executable file is not a valid ELF ET_EXEC file\n&quot;);
1109     goto err;
1110   }
1111 
1112   // process core file segments
1113   if (read_core_segments(ph, &amp;core_ehdr) != true) {
1114     goto err;
1115   }
1116 
1117   // process exec file segments
1118   if (read_exec_segments(ph, &amp;exec_ehdr) != true) {
1119     goto err;
1120   }
1121 
1122   // exec file is also treated like a shared object for symbol search
1123   if (add_lib_info_fd(ph, exec_file, ph-&gt;core-&gt;exec_fd,
1124                       (uintptr_t)0 + find_base_address(ph-&gt;core-&gt;exec_fd, &amp;exec_ehdr)) == NULL) {
1125     goto err;
1126   }
1127 
1128   // allocate and sort maps into map_array, we need to do this
1129   // here because read_shared_lib_info needs to read from debuggee
1130   // address space
1131   if (sort_map_array(ph) != true) {
1132     goto err;
1133   }
1134 
1135   if (read_shared_lib_info(ph) != true) {
1136     goto err;
1137   }
1138 
1139   // sort again because we have added more mappings from shared objects
1140   if (sort_map_array(ph) != true) {
1141     goto err;
1142   }
1143 
1144   if (init_classsharing_workaround(ph) != true) {
1145     goto err;
1146   }
1147 
1148   print_debug(&quot;Leave Pgrab_core\n&quot;);
1149   return ph;
1150 
1151 err:
1152   Prelease(ph);
1153   return NULL;
1154 }
1155 
1156 #endif // __APPLE__
    </pre>
  </body>
</html>