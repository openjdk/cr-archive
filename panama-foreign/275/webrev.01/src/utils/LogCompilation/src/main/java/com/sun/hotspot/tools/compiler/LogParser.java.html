<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/LogParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 /**
  26  * A SAX based parser of LogCompilation output from HotSpot.  It takes a complete
  27  */
  28 
  29 package com.sun.hotspot.tools.compiler;
  30 
  31 import java.io.FileReader;
  32 import java.io.PrintStream;
  33 import java.io.Reader;
  34 import java.util.ArrayDeque;
  35 import java.util.ArrayList;
  36 import java.util.Comparator;
  37 import java.util.Deque;
  38 import java.util.HashMap;
  39 import java.util.LinkedHashMap;
  40 import java.util.regex.Pattern;
  41 
  42 import javax.xml.parsers.SAXParser;
  43 import javax.xml.parsers.SAXParserFactory;
  44 
  45 import org.xml.sax.Attributes;
  46 import org.xml.sax.ErrorHandler;
  47 import org.xml.sax.InputSource;
  48 import org.xml.sax.Locator;
  49 import org.xml.sax.helpers.DefaultHandler;
  50 
  51 /**
  52  * A SAX parser for HotSpot compilation logs. The bulk of the parsing and event
  53  * maintenance work is done in the {@link #startElement(String,String,String,Attributes)}
  54  * and {@link #endElement(String,String,String)} methods.
  55  */
  56 public class LogParser extends DefaultHandler implements ErrorHandler {
  57 
  58     static final Pattern spacePattern = Pattern.compile(&quot; &quot;);
  59 
  60     /**
  61      * Map internal array type descriptors to Java names.
  62      */
  63     static final HashMap&lt;String, String&gt; type2printableMap;
  64 
  65     /**
  66      * Map Java primitive type names to internal type descriptors.
  67      */
  68     static final HashMap&lt;String, String&gt; type2vmtypeMap;
  69 
  70     static {
  71         type2printableMap = new HashMap&lt;&gt;();
  72         type2printableMap.put(&quot;[I&quot;, &quot;int[]&quot;);
  73         type2printableMap.put(&quot;[C&quot;, &quot;char[]&quot;);
  74         type2printableMap.put(&quot;[Z&quot;, &quot;boolean[]&quot;);
  75         type2printableMap.put(&quot;[L&quot;, &quot;Object[]&quot;);
  76         type2printableMap.put(&quot;[B&quot;, &quot;byte[]&quot;);
  77 
  78         type2vmtypeMap = new HashMap&lt;&gt;();
  79         type2vmtypeMap.put(&quot;void&quot;, &quot;V&quot;);
  80         type2vmtypeMap.put(&quot;boolean&quot;, &quot;Z&quot;);
  81         type2vmtypeMap.put(&quot;byte&quot;, &quot;B&quot;);
  82         type2vmtypeMap.put(&quot;char&quot;, &quot;C&quot;);
  83         type2vmtypeMap.put(&quot;short&quot;, &quot;S&quot;);
  84         type2vmtypeMap.put(&quot;int&quot;, &quot;I&quot;);
  85         type2vmtypeMap.put(&quot;long&quot;, &quot;J&quot;);
  86         type2vmtypeMap.put(&quot;float&quot;, &quot;F&quot;);
  87         type2vmtypeMap.put(&quot;double&quot;, &quot;D&quot;);
  88     }
  89 
  90     static String[] bytecodes = new String[] {
  91         &quot;nop&quot;,
  92         &quot;aconst_null&quot;,
  93         &quot;iconst_m1&quot;,
  94         &quot;iconst_0&quot;,
  95         &quot;iconst_1&quot;,
  96         &quot;iconst_2&quot;,
  97         &quot;iconst_3&quot;,
  98         &quot;iconst_4&quot;,
  99         &quot;iconst_5&quot;,
 100         &quot;lconst_0&quot;,
 101         &quot;lconst_1&quot;,
 102         &quot;fconst_0&quot;,
 103         &quot;fconst_1&quot;,
 104         &quot;fconst_2&quot;,
 105         &quot;dconst_0&quot;,
 106         &quot;dconst_1&quot;,
 107         &quot;bipush&quot;,
 108         &quot;sipush&quot;,
 109         &quot;ldc&quot;,
 110         &quot;ldc_w&quot;,
 111         &quot;ldc2_w&quot;,
 112         &quot;iload&quot;,
 113         &quot;lload&quot;,
 114         &quot;fload&quot;,
 115         &quot;dload&quot;,
 116         &quot;aload&quot;,
 117         &quot;iload_0&quot;,
 118         &quot;iload_1&quot;,
 119         &quot;iload_2&quot;,
 120         &quot;iload_3&quot;,
 121         &quot;lload_0&quot;,
 122         &quot;lload_1&quot;,
 123         &quot;lload_2&quot;,
 124         &quot;lload_3&quot;,
 125         &quot;fload_0&quot;,
 126         &quot;fload_1&quot;,
 127         &quot;fload_2&quot;,
 128         &quot;fload_3&quot;,
 129         &quot;dload_0&quot;,
 130         &quot;dload_1&quot;,
 131         &quot;dload_2&quot;,
 132         &quot;dload_3&quot;,
 133         &quot;aload_0&quot;,
 134         &quot;aload_1&quot;,
 135         &quot;aload_2&quot;,
 136         &quot;aload_3&quot;,
 137         &quot;iaload&quot;,
 138         &quot;laload&quot;,
 139         &quot;faload&quot;,
 140         &quot;daload&quot;,
 141         &quot;aaload&quot;,
 142         &quot;baload&quot;,
 143         &quot;caload&quot;,
 144         &quot;saload&quot;,
 145         &quot;istore&quot;,
 146         &quot;lstore&quot;,
 147         &quot;fstore&quot;,
 148         &quot;dstore&quot;,
 149         &quot;astore&quot;,
 150         &quot;istore_0&quot;,
 151         &quot;istore_1&quot;,
 152         &quot;istore_2&quot;,
 153         &quot;istore_3&quot;,
 154         &quot;lstore_0&quot;,
 155         &quot;lstore_1&quot;,
 156         &quot;lstore_2&quot;,
 157         &quot;lstore_3&quot;,
 158         &quot;fstore_0&quot;,
 159         &quot;fstore_1&quot;,
 160         &quot;fstore_2&quot;,
 161         &quot;fstore_3&quot;,
 162         &quot;dstore_0&quot;,
 163         &quot;dstore_1&quot;,
 164         &quot;dstore_2&quot;,
 165         &quot;dstore_3&quot;,
 166         &quot;astore_0&quot;,
 167         &quot;astore_1&quot;,
 168         &quot;astore_2&quot;,
 169         &quot;astore_3&quot;,
 170         &quot;iastore&quot;,
 171         &quot;lastore&quot;,
 172         &quot;fastore&quot;,
 173         &quot;dastore&quot;,
 174         &quot;aastore&quot;,
 175         &quot;bastore&quot;,
 176         &quot;castore&quot;,
 177         &quot;sastore&quot;,
 178         &quot;pop&quot;,
 179         &quot;pop2&quot;,
 180         &quot;dup&quot;,
 181         &quot;dup_x1&quot;,
 182         &quot;dup_x2&quot;,
 183         &quot;dup2&quot;,
 184         &quot;dup2_x1&quot;,
 185         &quot;dup2_x2&quot;,
 186         &quot;swap&quot;,
 187         &quot;iadd&quot;,
 188         &quot;ladd&quot;,
 189         &quot;fadd&quot;,
 190         &quot;dadd&quot;,
 191         &quot;isub&quot;,
 192         &quot;lsub&quot;,
 193         &quot;fsub&quot;,
 194         &quot;dsub&quot;,
 195         &quot;imul&quot;,
 196         &quot;lmul&quot;,
 197         &quot;fmul&quot;,
 198         &quot;dmul&quot;,
 199         &quot;idiv&quot;,
 200         &quot;ldiv&quot;,
 201         &quot;fdiv&quot;,
 202         &quot;ddiv&quot;,
 203         &quot;irem&quot;,
 204         &quot;lrem&quot;,
 205         &quot;frem&quot;,
 206         &quot;drem&quot;,
 207         &quot;ineg&quot;,
 208         &quot;lneg&quot;,
 209         &quot;fneg&quot;,
 210         &quot;dneg&quot;,
 211         &quot;ishl&quot;,
 212         &quot;lshl&quot;,
 213         &quot;ishr&quot;,
 214         &quot;lshr&quot;,
 215         &quot;iushr&quot;,
 216         &quot;lushr&quot;,
 217         &quot;iand&quot;,
 218         &quot;land&quot;,
 219         &quot;ior&quot;,
 220         &quot;lor&quot;,
 221         &quot;ixor&quot;,
 222         &quot;lxor&quot;,
 223         &quot;iinc&quot;,
 224         &quot;i2l&quot;,
 225         &quot;i2f&quot;,
 226         &quot;i2d&quot;,
 227         &quot;l2i&quot;,
 228         &quot;l2f&quot;,
 229         &quot;l2d&quot;,
 230         &quot;f2i&quot;,
 231         &quot;f2l&quot;,
 232         &quot;f2d&quot;,
 233         &quot;d2i&quot;,
 234         &quot;d2l&quot;,
 235         &quot;d2f&quot;,
 236         &quot;i2b&quot;,
 237         &quot;i2c&quot;,
 238         &quot;i2s&quot;,
 239         &quot;lcmp&quot;,
 240         &quot;fcmpl&quot;,
 241         &quot;fcmpg&quot;,
 242         &quot;dcmpl&quot;,
 243         &quot;dcmpg&quot;,
 244         &quot;ifeq&quot;,
 245         &quot;ifne&quot;,
 246         &quot;iflt&quot;,
 247         &quot;ifge&quot;,
 248         &quot;ifgt&quot;,
 249         &quot;ifle&quot;,
 250         &quot;if_icmpeq&quot;,
 251         &quot;if_icmpne&quot;,
 252         &quot;if_icmplt&quot;,
 253         &quot;if_icmpge&quot;,
 254         &quot;if_icmpgt&quot;,
 255         &quot;if_icmple&quot;,
 256         &quot;if_acmpeq&quot;,
 257         &quot;if_acmpne&quot;,
 258         &quot;goto&quot;,
 259         &quot;jsr&quot;,
 260         &quot;ret&quot;,
 261         &quot;tableswitch&quot;,
 262         &quot;lookupswitch&quot;,
 263         &quot;ireturn&quot;,
 264         &quot;lreturn&quot;,
 265         &quot;freturn&quot;,
 266         &quot;dreturn&quot;,
 267         &quot;areturn&quot;,
 268         &quot;return&quot;,
 269         &quot;getstatic&quot;,
 270         &quot;putstatic&quot;,
 271         &quot;getfield&quot;,
 272         &quot;putfield&quot;,
 273         &quot;invokevirtual&quot;,
 274         &quot;invokespecial&quot;,
 275         &quot;invokestatic&quot;,
 276         &quot;invokeinterface&quot;,
 277         &quot;invokedynamic&quot;,
 278         &quot;new&quot;,
 279         &quot;newarray&quot;,
 280         &quot;anewarray&quot;,
 281         &quot;arraylength&quot;,
 282         &quot;athrow&quot;,
 283         &quot;checkcast&quot;,
 284         &quot;instanceof&quot;,
 285         &quot;monitorenter&quot;,
 286         &quot;monitorexit&quot;,
 287         &quot;wide&quot;,
 288         &quot;multianewarray&quot;,
 289         &quot;ifnull&quot;,
 290         &quot;ifnonnull&quot;,
 291         &quot;goto_w&quot;,
 292         &quot;jsr_w&quot;,
 293         &quot;breakpoint&quot;
 294     };
 295 
 296     /**
 297      * Sort log events by start time.
 298      */
 299     static Comparator&lt;LogEvent&gt; sortByStart = new Comparator&lt;LogEvent&gt;() {
 300 
 301         public int compare(LogEvent a, LogEvent b) {
 302             double difference = (a.getStart() - b.getStart());
 303             if (difference &lt; 0) {
 304                 return -1;
 305             }
 306             if (difference &gt; 0) {
 307                 return 1;
 308             }
 309             return 0;
 310         }
 311 
 312         @Override
 313         public boolean equals(Object other) {
 314             return false;
 315         }
 316 
 317         @Override
 318         public int hashCode() {
 319             return 7;
 320         }
 321     };
 322 
 323     /**
 324      * Sort log events first by the name of the compiled method, then by start
 325      * time. In case one of the events has no associated compilation (or the
 326      * associated compilation has no method name), the event with a compilation
 327      * and/or name is considered the larger one.
 328      */
 329     static Comparator&lt;LogEvent&gt; sortByNameAndStart = new Comparator&lt;LogEvent&gt;() {
 330 
 331         public int compare(LogEvent a, LogEvent b) {
 332             Compilation c1 = a.getCompilation();
 333             Compilation c2 = b.getCompilation();
 334             if (c1 != null &amp;&amp; c1.getMethod() != null &amp;&amp; c2 != null &amp;&amp; c2.getMethod() != null) {
 335                 int result = c1.getMethod().toString().compareTo(c2.getMethod().toString());
 336                 if (result != 0) {
 337                     return result;
 338                 }
 339             } else if ((c1 == null || c1.getMethod() == null) &amp;&amp; c2 != null &amp;&amp; c2.getMethod() != null) {
 340                 return -1;
 341             } else if ((c2 == null || c2.getMethod() == null) &amp;&amp; c1 != null &amp;&amp; c1.getMethod() != null) {
 342                 return 1;
 343             }
 344             return Double.compare(a.getStart(), b.getStart());
 345         }
 346 
 347         public boolean equals(Object other) {
 348             return false;
 349         }
 350 
 351         @Override
 352         public int hashCode() {
 353             return 7;
 354         }
 355     };
 356 
 357     /**
 358      * Sort log events by duration.
 359      */
 360     static Comparator&lt;LogEvent&gt; sortByElapsed = new Comparator&lt;LogEvent&gt;() {
 361 
 362         public int compare(LogEvent a, LogEvent b) {
 363             double difference = (a.getElapsedTime() - b.getElapsedTime());
 364             if (difference &lt; 0) {
 365                 return -1;
 366             }
 367             if (difference &gt; 0) {
 368                 return 1;
 369             }
 370             return 0;
 371         }
 372 
 373         @Override
 374         public boolean equals(Object other) {
 375             return false;
 376         }
 377 
 378         @Override
 379         public int hashCode() {
 380             return 7;
 381         }
 382     };
 383 
 384     /**
 385      * Shrink-wrapped representation of a JVMState (tailored to meet this
 386      * tool&#39;s needs). It only records a method and bytecode instruction index.
 387      */
 388     class Jvms {
 389         Jvms(Method method, int bci) {
 390             this.method = method;
 391             this.bci = bci;
 392         }
 393         final public Method method;
 394         final public int bci;
 395         final public String toString() {
 396             return &quot;@&quot; + bci + &quot; &quot; + method;
 397         }
 398     }
 399 
 400     /**
 401      * Representation of a lock elimination. Locks, corresponding to
 402      * synchronized blocks and method calls, may be eliminated if the object in
 403      * question is guaranteed to be used thread-locally.
 404      */
 405     class LockElimination extends BasicLogEvent {
 406 
 407         /**
 408          * Track all locations from which this lock was eliminated.
 409          */
 410         ArrayList&lt;Jvms&gt; jvms = new ArrayList&lt;&gt;(1);
 411 
 412         /**
 413          * The kind of lock (coarsened, nested, non-escaping, unknown).
 414          */
 415         final String kind;
 416 
 417         /**
 418          * The lock class (unlock, lock, unknown).
 419          */
 420         final String classId;
 421 
 422         /**
 423          * The precise type of lock.
 424          */
 425         final String tagName;
 426 
 427         LockElimination(String tagName, double start, String id, String kind, String classId) {
 428             super(start, id);
 429             this.kind = kind;
 430             this.classId = classId;
 431             this.tagName = tagName;
 432         }
 433 
 434         @Override
 435         public void print(PrintStream stream, boolean printID) {
 436             if (printID) {
 437                 stream.printf(&quot;%s &quot;, getId());
 438             }
 439             stream.printf(&quot;%s %s %s  %.3f &quot;, tagName, kind, classId, getStart());
 440             stream.print(jvms.toString());
 441             stream.print(&quot;\n&quot;);
 442         }
 443 
 444         void addJVMS(Method method, int bci) {
 445             jvms.add(new Jvms(method, bci));
 446         }
 447 
 448     }
 449 
 450     /**
 451      * A list of log events. This is populated with the events found in the
 452      * compilation log file during parsing.
 453      */
 454     private ArrayList&lt;LogEvent&gt; events = new ArrayList&lt;&gt;();
 455 
 456     /**
 457      * Map compilation log IDs to type names.
 458      */
 459     private HashMap&lt;String, String&gt; types = new HashMap&lt;&gt;();
 460 
 461     /**
 462      * Map compilation log IDs to methods.
 463      */
 464     private HashMap&lt;String, Method&gt; methods = new HashMap&lt;&gt;();
 465 
 466     /**
 467      * Map compilation IDs ({@see #makeId()}) to newly created nmethods.
 468      */
 469     private LinkedHashMap&lt;String, NMethod&gt; nmethods = new LinkedHashMap&lt;&gt;();
 470 
 471     /**
 472      * Map compilation task IDs {@see #makeId()}) to {@link Compilation}
 473      * objects.
 474      */
 475     private HashMap&lt;String, Compilation&gt; compiles = new HashMap&lt;&gt;();
 476 
 477     /**
 478      * Track compilation failure reasons.
 479      */
 480     private String failureReason;
 481 
 482     /**
 483      * The current bytecode instruction index.
 484      */
 485     private int current_bci;
 486 
 487     /**
 488      * The current bytecode instruction.
 489      */
 490     private int current_bytecode;
 491 
 492     /**
 493      * A sequence of {@link CallSite}s representing a call stack. A scope
 494      * typically holds several {@link CallSite}s that represent calls
 495      * originating from that scope.
 496      *
 497      * New scopes are typically pushed when parse log events are encountered
 498      * ({@see #startElement()}) and popped when parsing of a given Java method
 499      * is done ({@see #endElement()}). Parsing events can be nested. Several
 500      * other events add information to scopes ({@see #startElement()}).
 501      */
 502     private Deque&lt;CallSite&gt; scopes = new ArrayDeque&lt;&gt;();
 503 
 504     /**
 505      * The current compilation.
 506      */
 507     private Compilation compile;
 508 
 509     /**
 510      * The {@linkplain CallSite compilation scope} currently in focus.
 511      */
 512     private CallSite site;
 513 
 514     /**
 515      * The {@linkplain CallSite method handle call site} currently under
 516      * observation.
 517      */
 518     private CallSite methodHandleSite;
 519 
 520     /**
 521      * Keep track of potentially nested compiler {@linkplain Phase phases}.
 522      */
 523     private Deque&lt;Phase&gt; phaseStack = new ArrayDeque&lt;&gt;();
 524 
 525     /**
 526      * The {@linkplain LockElimination lock elimination event} currently being
 527      * processed.
 528      */
 529     private LockElimination currentLockElimination;
 530 
 531     /**
 532      * The {@linkplain UncommonTrapEvent uncommon trap event} currently being
 533      * processed.
 534      */
 535     private UncommonTrapEvent currentTrap;
 536 
 537     /**
 538      * During the processing of a late inline event, this stack holds the
 539      * {@link CallSite}s that represent the inlining event&#39;s call stack.
 540      */
 541     private Deque&lt;CallSite&gt; lateInlineScope;
 542 
 543     /**
 544      * Denote whether a late inlining event is currently being processed.
 545      */
 546     private boolean lateInlining;
 547 
 548     /**
 549      * A document locator to provide better error messages: this allows the
 550      * tool to display in which line of the log file the problem occurred.
 551      */
 552     private Locator locator;
 553 
 554     /**
 555      * Record the location in a replace_string_concat.
 556      */
 557     private boolean expectStringConcatTrap = false;
 558 
 559     /**
 560      * Callback for the SAX framework to set the document locator.
 561      */
 562     @Override
 563     public void setDocumentLocator(Locator locator) {
 564         this.locator = locator;
 565     }
 566 
 567     /**
 568      * Report an internal error explicitly raised, i.e., not derived from an
 569      * exception.
 570      *
 571      * @param msg The error message to report.
 572      */
 573     private void reportInternalError(String msg) {
 574         reportInternalError(msg, null);
 575     }
 576 
 577     /**
 578      * Report an internal error derived from an exception.
 579      *
 580      * @param msg The beginning of the error message to report. The message
 581      * from the exception will be appended to this.
 582      * @param e The exception that led to the internal error.
 583      */
 584     private void reportInternalError(String msg, Exception e) {
 585         if (locator != null) {
 586             msg += &quot; at &quot; + locator.getLineNumber() + &quot;:&quot; + locator.getColumnNumber();
 587             if (e != null) {
 588                 msg += &quot; - &quot; + e.getMessage();
 589             }
 590         }
 591         if (e != null) {
 592             throw new Error(msg, e);
 593         } else {
 594             throw new Error(msg);
 595         }
 596     }
 597 
 598     /**
 599      * Parse a long hexadecimal address into a {@code long} value. As Java only
 600      * supports positive {@code long} values, extra error handling and parsing
 601      * logic is provided.
 602      */
 603     long parseLong(String l) {
 604         try {
 605             return Long.decode(l).longValue();
 606         } catch (NumberFormatException nfe) {
 607             int split = l.length() - 8;
 608             String s1 = &quot;0x&quot; + l.substring(split);
 609             String s2 = l.substring(0, split);
 610             long v1 = Long.decode(s1).longValue() &amp; 0xffffffffL;
 611             long v2 = (Long.decode(s2).longValue() &amp; 0xffffffffL) &lt;&lt; 32;
 612             if (!l.equals(&quot;0x&quot; + Long.toHexString(v1 + v2))) {
 613                 System.out.println(l);
 614                 System.out.println(s1);
 615                 System.out.println(s2);
 616                 System.out.println(v1);
 617                 System.out.println(v2);
 618                 System.out.println(Long.toHexString(v1 + v2));
 619                 reportInternalError(&quot;bad conversion&quot;);
 620             }
 621             return v1 + v2;
 622         }
 623     }
 624 
 625     /**
 626      * Entry point for log file parsing with a file name.
 627      *
 628      * @param file The name of the log file to parse.
 629      * @param cleanup Whether to perform bad XML cleanup during parsing (this
 630      * is relevant for some log files generated by the 1.5 JVM).
 631      * @return a list of {@link LogEvent} instances describing the events found
 632      * in the log file.
 633      */
 634     public static ArrayList&lt;LogEvent&gt; parse(String file, boolean cleanup) throws Exception {
 635         return parse(new FileReader(file), cleanup);
 636     }
 637 
 638     /**
 639      * Entry point for log file parsing with a file reader.
 640      * {@link #parse(String,boolean)}
 641      */
 642     public static ArrayList&lt;LogEvent&gt; parse(Reader reader, boolean cleanup) throws Exception {
 643         // Create the XML input factory
 644         SAXParserFactory factory = SAXParserFactory.newInstance();
 645 
 646         // Create the XML LogEvent reader
 647         SAXParser p = factory.newSAXParser();
 648 
 649         if (cleanup) {
 650             // some versions of the log have slightly malformed XML, so clean it
 651             // up before passing it to SAX
 652             reader = new LogCleanupReader(reader);
 653         }
 654 
 655         LogParser log = new LogParser();
 656         try {
 657             p.parse(new InputSource(reader), log);
 658         } catch (Throwable th) {
 659             th.printStackTrace();
 660             // Carry on with what we&#39;ve got...
 661         }
 662 
 663         // Associate compilations with their NMethods and other kinds of events
 664         for (LogEvent e : log.events) {
 665             if (e instanceof BasicLogEvent) {
 666                 BasicLogEvent ble = (BasicLogEvent) e;
 667                 Compilation c = log.compiles.get(ble.getId());
 668                 if (c == null) {
 669                     if (!(ble instanceof NMethod)) {
 670                         throw new InternalError(&quot;only nmethods should have a null compilation, here&#39;s a &quot; + ble.getClass());
 671                     }
 672                     continue;
 673                 }
 674                 ble.setCompilation(c);
 675                 if (ble instanceof NMethod) {
 676                     c.setNMethod((NMethod) ble);
 677                 }
 678             }
 679         }
 680 
 681         return log.events;
 682     }
 683 
 684     /**
 685      * Retrieve a given attribute&#39;s value from a collection of XML tag
 686      * attributes. Report an error if the requested attribute is not found.
 687      *
 688      * @param attr A collection of XML tag attributes.
 689      * @param name The name of the attribute the value of which is to be found.
 690      * @return The value of the requested attribute, or {@code null} if it was
 691      * not found.
 692      */
 693     String search(Attributes attr, String name) {
 694         String result = attr.getValue(name);
 695         if (result != null) {
 696             return result;
 697         } else {
 698             reportInternalError(&quot;can&#39;t find &quot; + name);
 699             return null;
 700         }
 701     }
 702 
 703     /**
 704      * Retrieve a given attribute&#39;s value from a collection of XML tag
 705      * attributes. Return a default value if the requested attribute is not
 706      * found.
 707      *
 708      * @param attr A collection of XML tag attributes.
 709      * @param name The name of the attribute the value of which is to be found.
 710      * @param defaultValue The default value to return if the attribute is not
 711      * found.
 712      * @return The value of the requested attribute, or the default value if it
 713      * was not found.
 714      */
 715     String search(Attributes attr, String name, String defaultValue) {
 716         String result = attr.getValue(name);
 717         if (result != null) {
 718             return result;
 719         }
 720         return defaultValue;
 721     }
 722 
 723     /**
 724      * Map a type ID from the compilation log to an actual type name. In case
 725      * the type represents an internal array type descriptor, return a
 726      * Java-level name. If the type ID cannot be mapped to a name, raise an
 727      * error.
 728      */
 729     String type(String id) {
 730         String result = types.get(id);
 731         String remapped = type2printableMap.get(result);
 732         if (remapped != null) {
 733             return remapped;
 734         }
 735         return result;
 736     }
 737 
 738     /**
 739      * Register a mapping from log file type ID to type name.
 740      */
 741     void type(String id, String name) {
 742         assert type(id) == null;
 743         types.put(id, name);
 744     }
 745 
 746     /**
 747      * Map a log file type ID to an internal type declarator.
 748      */
 749     String sigtype(String id) {
 750         String result = types.get(id);
 751         String remapped = type2vmtypeMap.get(result);
 752         if (remapped != null) {
 753             return remapped;
 754         }
 755         if (result == null) {
 756             reportInternalError(id);
 757         }
 758         if (result.charAt(0) == &#39;[&#39;) {
 759             return result;
 760         }
 761         return &quot;L&quot; + result + &quot;;&quot;;
 762     }
 763 
 764     /**
 765      * Retrieve a method based on the log file ID it was registered under.
 766      * Raise an error if the ID does not map to a method.
 767      */
 768     Method method(String id) {
 769         Method result = methods.get(id);
 770         if (result == null) {
 771             reportInternalError(id);
 772         }
 773         return result;
 774     }
 775 
 776     /**
 777      * From a compilation ID and kind, assemble a compilation ID for inclusion
 778      * in the output.
 779      *
 780      * @param atts A collection of XML attributes from which the required
 781      * attributes are retrieved.
 782      */
 783     public String makeId(Attributes atts) {
 784         String id = atts.getValue(&quot;compile_id&quot;);
 785         String kind = atts.getValue(&quot;kind&quot;);
 786         if (kind != null &amp;&amp; kind.equals(&quot;osr&quot;)) {
 787             id += &quot;%&quot;;
 788         }
 789         return id;
 790     }
 791 
 792     /**
 793      * Process the start of a compilation log XML element.&lt;ul&gt;
 794      * &lt;li&gt;&lt;b&gt;phase:&lt;/b&gt; record the beginning of a compilation phase, pushing
 795      * it on the {@linkplain #phaseStack phase stack} and collecting
 796      * information about the compiler graph.&lt;/li&gt;
 797      * &lt;li&gt;&lt;b&gt;phase_done:&lt;/b&gt; record the end of a compilation phase, popping it
 798      * off the {@linkplain #phaseStack phase stack} and collecting information
 799      * about the compiler graph (number of nodes and live nodes).&lt;/li&gt;
 800      * &lt;li&gt;&lt;b&gt;task:&lt;/b&gt; register the start of a new compilation.&lt;/li&gt;
 801      * &lt;li&gt;&lt;b&gt;type:&lt;/b&gt; register a type.&lt;/li&gt;
 802      * &lt;li&gt;&lt;b&gt;bc:&lt;/b&gt; note the current bytecode index and instruction name,
 803      * updating {@link #current_bci} and {@link #current_bytecode}.&lt;/li&gt;
 804      * &lt;li&gt;&lt;b&gt;klass:&lt;/b&gt; register a type (class).&lt;/li&gt;
 805      * &lt;li&gt;&lt;b&gt;method:&lt;/b&gt; register a Java method.&lt;/li&gt;
 806      * &lt;li&gt;&lt;b&gt;call:&lt;/b&gt; process a call, populating {@link #site} with the
 807      * appropriate data.&lt;/li&gt;
 808      * &lt;li&gt;&lt;b&gt;regalloc:&lt;/b&gt; record the register allocator&#39;s trip count in the
 809      * {@linkplain #compile current compilation}.&lt;/li&gt;
 810      * &lt;li&gt;&lt;b&gt;inline_fail:&lt;/b&gt; record the reason for a failed inline
 811      * operation.&lt;/li&gt;
 812      * &lt;li&gt;&lt;b&gt;inline_success:&lt;/b&gt; record a successful inlining operation,
 813      * noting the success reason in the {@linkplain #site call site}.&lt;/li&gt;
 814      * &lt;li&gt;&lt;b&gt;failure:&lt;/b&gt; note a compilation failure, storing the reason
 815      * description in {@link #failureReason}.&lt;/li&gt;
 816      * &lt;li&gt;&lt;b&gt;task_done:&lt;/b&gt; register the end of a compilation, recording time
 817      * stamp and success information.&lt;/li&gt;
 818      * &lt;li&gt;&lt;b&gt;make_not_entrant:&lt;/b&gt; deal with making a native method
 819      * non-callable (e.g., during an OSR compilation, if there are still
 820      * activations) or a zombie (when the method can be deleted).&lt;/li&gt;
 821      * &lt;li&gt;&lt;b&gt;uncommon_trap:&lt;/b&gt; process an uncommon trap, setting the
 822      * {@link #currentTrap} field.&lt;/li&gt;
 823      * &lt;li&gt;&lt;b&gt;eliminate_lock:&lt;/b&gt; record the start of a lock elimination,
 824      * setting the {@link #currentLockElimination} event.&lt;/li&gt;
 825      * &lt;li&gt;&lt;b&gt;late_inline:&lt;/b&gt; start processing a late inline decision:
 826      * initialize the {@linkplain #lateInlineScope inline scope stack}, create
 827      * an {@linkplain #site initial scope} with a bogus bytecode index and the
 828      * right inline ID, and push the scope with the inline ID attached. Note
 829      * that most of late inlining processing happens in
 830      * {@link #endElement(String,String,String)}.&lt;/li&gt;
 831      * &lt;li&gt;&lt;b&gt;jvms:&lt;/b&gt; record a {@linkplain Jvms JVMState}. Depending on the
 832      * context in which this event is encountered, this can mean adding
 833      * information to the currently being processed trap, lock elimination, or
 834      * inlining operation.&lt;/li&gt;
 835      * &lt;li&gt;&lt;b&gt;inline_id:&lt;/b&gt; set the inline ID in the
 836      * {@linkplain #site current call site}.&lt;/li&gt;
 837      * &lt;li&gt;&lt;b&gt;nmethod:&lt;/b&gt; record the creation of a new {@link NMethod} and
 838      * store it in the {@link #nmethods} map.&lt;/li&gt;
 839      * &lt;li&gt;&lt;b&gt;parse:&lt;/b&gt; begin parsing a Java method&#39;s bytecode and
 840      * transforming it into an initial compiler IR graph.&lt;/li&gt;
 841      * &lt;li&gt;&lt;b&gt;parse_done:&lt;/b&gt; finish parsing a Java method&#39;s bytecode.&lt;/li&gt;
 842      * &lt;/ul&gt;
 843      */
 844     @Override
 845     public void startElement(String uri, String localName, String qname, Attributes atts) {
 846         if (qname.equals(&quot;phase&quot;)) {
 847             Phase p = new Phase(search(atts, &quot;name&quot;),
 848                     Double.parseDouble(search(atts, &quot;stamp&quot;)),
 849                     Integer.parseInt(search(atts, &quot;nodes&quot;, &quot;0&quot;)),
 850                     Integer.parseInt(search(atts, &quot;live&quot;, &quot;0&quot;)));
 851             phaseStack.push(p);
 852         } else if (qname.equals(&quot;phase_done&quot;)) {
 853             Phase p = phaseStack.pop();
 854             String phaseName = search(atts, &quot;name&quot;, null);
 855             if (phaseName != null &amp;&amp; !p.getId().equals(phaseName)) {
 856                 System.out.println(&quot;phase: &quot; + p.getId());
 857                 reportInternalError(&quot;phase name mismatch&quot;);
 858             }
 859             p.setEnd(Double.parseDouble(search(atts, &quot;stamp&quot;)));
 860             p.setEndNodes(Integer.parseInt(search(atts, &quot;nodes&quot;, &quot;0&quot;)));
 861             p.setEndLiveNodes(Integer.parseInt(search(atts, &quot;live&quot;, &quot;0&quot;)));
 862             compile.getPhases().add(p);
 863         } else if (qname.equals(&quot;task&quot;)) {
 864             String id = makeId(atts);
 865 
 866             // Create the new Compilation instance and populate it with readily
 867             // available data.
 868             compile = new Compilation(Integer.parseInt(search(atts, &quot;compile_id&quot;, &quot;-1&quot;)));
 869             compile.setStart(Double.parseDouble(search(atts, &quot;stamp&quot;)));
 870             compile.setICount(search(atts, &quot;count&quot;, &quot;0&quot;));
 871             compile.setBCount(search(atts, &quot;backedge_count&quot;, &quot;0&quot;));
 872             compile.setBCI(Integer.parseInt(search(atts, &quot;osr_bci&quot;, &quot;-1&quot;)));
 873             String compiler = atts.getValue(&quot;compiler&quot;);
 874             assert compiler == null : &quot;Compiler is not specified in task&quot;;
 875             long level = parseLong(search(atts, &quot;level&quot;, &quot;0&quot;));
 876             if (level != 0) {
 877                 compile.setLevel(level);
 878             }
 879             // Extract the name of the compiled method.
 880             String[] parts = spacePattern.split(atts.getValue(&quot;method&quot;));
 881             String methodName = parts[0] + &quot;::&quot; + parts[1];
 882 
 883             // Continue collecting compilation meta-data.
 884             String kind = atts.getValue(&quot;compile_kind&quot;);
 885             if (kind == null) {
 886                 kind = &quot;normal&quot;;
 887             }
 888             if (kind.equals(&quot;osr&quot;)) {
 889                 compile.setOsr(true);
 890             } else if (kind.equals(&quot;c2i&quot;)) {
 891                 compile.setSpecial(&quot;--- adapter &quot; + methodName);
 892             } else {
 893                 compile.setSpecial(compile.getId() + &quot; &quot; + methodName + &quot; (0 bytes)&quot;);
 894             }
 895 
 896             // Build a dummy method to stuff in the Compilation at the
 897             // beginning.
 898             Method m = new Method();
 899             m.setHolder(parts[0]);
 900             m.setName(parts[1]);
 901             m.setSignature(parts[2]);
 902             m.setFlags(&quot;0&quot;);
 903             m.setBytes(search(atts, &quot;bytes&quot;, &quot;unknown&quot;));
 904             m.setLevel(compile.getLevel());
 905             compile.setMethod(m);
 906             events.add(compile);
 907             compiles.put(id, compile);
 908             site = compile.getCall();
 909         } else if (qname.equals(&quot;type&quot;)) {
 910             type(search(atts, &quot;id&quot;), search(atts, &quot;name&quot;));
 911         } else if (qname.equals(&quot;bc&quot;)) {
 912             current_bci = Integer.parseInt(search(atts, &quot;bci&quot;));
 913             current_bytecode = Integer.parseInt(search(atts, &quot;code&quot;));
 914         } else if (qname.equals(&quot;klass&quot;)) {
 915             type(search(atts, &quot;id&quot;), search(atts, &quot;name&quot;));
 916         } else if (qname.equals(&quot;method&quot;)) {
 917             String id = search(atts, &quot;id&quot;);
 918             Method m = new Method();
 919             m.setHolder(type(search(atts, &quot;holder&quot;)));
 920             m.setName(search(atts, &quot;name&quot;));
 921             m.setReturnType(type(search(atts, &quot;return&quot;)));
 922             String arguments = atts.getValue(&quot;arguments&quot;);;
 923             if (arguments == null) {
 924                 m.setSignature(&quot;()&quot; + sigtype(atts.getValue(&quot;return&quot;)));
 925             } else {
 926                 String[] args = spacePattern.split(arguments);
 927                 StringBuilder sb = new StringBuilder(&quot;(&quot;);
 928                 for (int i = 0; i &lt; args.length; i++) {
 929                     sb.append(sigtype(args[i]));
 930                 }
 931                 sb.append(&quot;)&quot;);
 932                 sb.append(sigtype(atts.getValue(&quot;return&quot;)));
 933                 m.setSignature(sb.toString());
 934             }
 935 
 936             if (search(atts, &quot;unloaded&quot;, &quot;0&quot;).equals(&quot;0&quot;)) {
 937                m.setBytes(search(atts, &quot;bytes&quot;));
 938                m.setIICount(search(atts, &quot;iicount&quot;));
 939                m.setFlags(search(atts, &quot;flags&quot;));
 940             }
 941             String compiler = search(atts, &quot;compiler&quot;, &quot;&quot;);
 942             m.setCompiler(compiler);
 943             long level = parseLong(search(atts, &quot;level&quot;, &quot;0&quot;));
 944             if (level != 0) {
 945                 m.setLevel(level);
 946             }
 947             methods.put(id, m);
 948         } else if (qname.equals(&quot;call&quot;)) {
 949             if (methodHandleSite != null) {
 950                 methodHandleSite = null;
 951             }
 952             Method m = method(search(atts, &quot;method&quot;));
 953             if (lateInlining &amp;&amp; scopes.size() == 0) {
 954                 // re-attempting already seen call site (late inlining for MH invokes)
 955                 if (m != site.getMethod()) {
 956                     if (current_bci != site.getBci()) {
 957                         System.err.println(m + &quot; bci: &quot; + current_bci);
 958                         System.err.println(site.getMethod() +  &quot; bci: &quot; + site.getBci());
 959                         reportInternalError(&quot;bci mismatch after late inlining&quot;);
 960                     }
 961                     site.setMethod(m);
 962                 }
 963             } else {
 964                 // We&#39;re dealing with a new call site; the called method is
 965                 // likely to be parsed next.
 966                 site = new CallSite(current_bci, m);
 967             }
 968             site.setCount(Integer.parseInt(search(atts, &quot;count&quot;, &quot;0&quot;)));
 969             String receiver = atts.getValue(&quot;receiver&quot;);
 970             if (receiver != null) {
 971                 site.setReceiver(type(receiver));
 972                 site.setReceiver_count(Integer.parseInt(search(atts, &quot;receiver_count&quot;)));
 973             }
 974             int methodHandle = Integer.parseInt(search(atts, &quot;method_handle_intrinsic&quot;, &quot;0&quot;));
 975             if (lateInlining &amp;&amp; scopes.size() == 0) {
 976                 // The call was already added before this round of late
 977                 // inlining. Ignore.
 978             } else if (methodHandle == 0) {
 979                 scopes.peek().add(site);
 980             } else {
 981                 // method handle call site can be followed by another
 982                 // call (in case it is inlined). If that happens we
 983                 // discard the method handle call site. So we keep
 984                 // track of it but don&#39;t add it to the list yet.
 985                 methodHandleSite = site;
 986             }
 987         } else if (qname.equals(&quot;intrinsic&quot;)) {
 988             String id = atts.getValue(&quot;id&quot;);
 989             assert id != null : &quot;intrinsic id is null&quot;;
 990             CallSite cs = (site != null) ? site : scopes.peek();
 991             assert cs != null : &quot;no CallSite?&quot;;
 992             cs.setIntrinsicName(id);
 993         } else if (qname.equals(&quot;regalloc&quot;)) {
 994             compile.setAttempts(Integer.parseInt(search(atts, &quot;attempts&quot;)));
 995         } else if (qname.equals(&quot;replace_string_concat&quot;)) {
 996             expectStringConcatTrap = true;
 997         } else if (qname.equals(&quot;inline_fail&quot;)) {
 998             if (methodHandleSite != null) {
 999                 scopes.peek().add(methodHandleSite);
1000                 methodHandleSite = null;
1001             }
1002             if (lateInlining &amp;&amp; scopes.size() == 0) {
1003                 site.setReason(&quot;fail: &quot; + search(atts, &quot;reason&quot;));
1004                 lateInlining = false;
1005             } else {
1006                 scopes.peek().last().setReason(&quot;fail: &quot; + search(atts, &quot;reason&quot;));
1007             }
1008         } else if (qname.equals(&quot;inline_success&quot;)) {
1009             if (methodHandleSite != null) {
1010                 reportInternalError(&quot;method handle site should have been replaced&quot;);
1011             }
1012             site.setReason(&quot;succeed: &quot; + search(atts, &quot;reason&quot;));
1013         } else if (qname.equals(&quot;failure&quot;)) {
1014             failureReason = search(atts, &quot;reason&quot;);
1015         } else if (qname.equals(&quot;task_done&quot;)) {
1016             compile.setEnd(Double.parseDouble(search(atts, &quot;stamp&quot;)));
1017             if (Integer.parseInt(search(atts, &quot;success&quot;)) == 0) {
1018                 compile.setFailureReason(failureReason);
1019                 failureReason = null;
1020             }
1021         } else if (qname.equals(&quot;make_not_entrant&quot;)) {
1022             String id = makeId(atts);
1023             NMethod nm = nmethods.get(id);
1024             if (nm == null) reportInternalError(&quot;nm == null&quot;);
1025             LogEvent e = new MakeNotEntrantEvent(Double.parseDouble(search(atts, &quot;stamp&quot;)), id,
1026                                                  atts.getValue(&quot;zombie&quot;) != null, nm);
1027             events.add(e);
1028         } else if (qname.equals(&quot;uncommon_trap&quot;)) {
1029             String id = atts.getValue(&quot;compile_id&quot;);
1030             if (id != null) {
1031                 id = makeId(atts);
1032                 currentTrap = new UncommonTrapEvent(Double.parseDouble(search(atts, &quot;stamp&quot;)),
1033                         id,
1034                         atts.getValue(&quot;reason&quot;),
1035                         atts.getValue(&quot;action&quot;),
1036                         Integer.parseInt(search(atts, &quot;count&quot;, &quot;0&quot;)));
1037                 events.add(currentTrap);
1038             } else {
1039                 if (atts.getValue(&quot;method&quot;) != null) {
1040                     // These are messages from ciTypeFlow that don&#39;t
1041                     // actually correspond to generated code.
1042                     return;
1043                 }
1044                 try {
1045                     UncommonTrap unc = new UncommonTrap(Integer.parseInt(search(atts, &quot;bci&quot;)),
1046                             search(atts, &quot;reason&quot;),
1047                             search(atts, &quot;action&quot;),
1048                             bytecodes[current_bytecode]);
1049                     if (scopes.size() == 0) {
1050                         // There may be a dangling site not yet in scopes after a late_inline
1051                         if (site != null) {
1052                             site.add(unc);
1053                         } else {
1054                             reportInternalError(&quot;scope underflow&quot;);
1055                         }
1056                     } else {
1057                         scopes.peek().add(unc);
1058                     }
1059                 } catch (Error e) {
1060                     e.printStackTrace();
1061                 }
1062             }
1063         } else if (qname.startsWith(&quot;eliminate_lock&quot;)) {
1064             String id = atts.getValue(&quot;compile_id&quot;);
1065             if (id != null) {
1066                 id = makeId(atts);
1067                 String kind = atts.getValue(&quot;kind&quot;);
1068                 String classId = atts.getValue(&quot;class_id&quot;);
1069                 currentLockElimination = new LockElimination(qname, Double.parseDouble(search(atts, &quot;stamp&quot;)), id, kind, classId);
1070                 events.add(currentLockElimination);
1071             }
1072         } else if (qname.equals(&quot;late_inline&quot;)) {
1073             long inlineId = 0;
1074             try {
1075                 inlineId = Long.parseLong(search(atts, &quot;inline_id&quot;));
1076             } catch (InternalError ex) {
1077                 // Log files from older hotspots may lack inline_id,
1078                 // and zero is an acceptable substitute that allows processing to continue.
1079             }
1080             lateInlineScope = new ArrayDeque&lt;&gt;();
1081             Method m = method(search(atts, &quot;method&quot;));
1082             site = new CallSite(-999, m);
1083             site.setInlineId(inlineId);
1084             lateInlineScope.push(site);
1085         } else if (qname.equals(&quot;jvms&quot;)) {
1086             // &lt;jvms bci=&#39;4&#39; method=&#39;java/io/DataInputStream readChar ()C&#39; bytes=&#39;40&#39; count=&#39;5815&#39; iicount=&#39;20815&#39;/&gt;
1087             if (currentTrap != null) {
1088                 String[] parts = spacePattern.split(atts.getValue(&quot;method&quot;));
1089                 currentTrap.addMethodAndBCI(parts[0].replace(&#39;/&#39;, &#39;.&#39;) + &#39;.&#39; + parts[1] + parts[2], Integer.parseInt(atts.getValue(&quot;bci&quot;)));
1090             } else if (currentLockElimination != null) {
1091                   currentLockElimination.addJVMS(method(atts.getValue(&quot;method&quot;)), Integer.parseInt(atts.getValue(&quot;bci&quot;)));
1092             } else if (lateInlineScope != null) {
1093                 current_bci = Integer.parseInt(search(atts, &quot;bci&quot;));
1094                 Method m = method(search(atts, &quot;method&quot;));
1095                 site = new CallSite(current_bci, m);
1096                 lateInlineScope.push(site);
1097             } else if (expectStringConcatTrap == true) {
1098                 // Record the location of the replace_string_concat for the
1099                 // uncommon_trap &#39;intrinsic_or_type_checked_inlining&#39; that should follow it
1100                 current_bci = Integer.parseInt(search(atts, &quot;bci&quot;));
1101                 Method m = method(search(atts, &quot;method&quot;));
1102                 site = new CallSite(current_bci, m);
1103             } else {
1104                 // Ignore &lt;eliminate_allocation type=&#39;667&#39;&gt;,
1105             }
1106         } else if (qname.equals(&quot;inline_id&quot;)) {
1107             if (methodHandleSite != null) {
1108                 reportInternalError(&quot;method handle site should have been replaced&quot;);
1109             }
1110             long id = Long.parseLong(search(atts, &quot;id&quot;));
1111             site.setInlineId(id);
1112         } else if (qname.equals(&quot;nmethod&quot;)) {
1113             String id = makeId(atts);
1114             NMethod nm = new NMethod(Double.parseDouble(search(atts, &quot;stamp&quot;)),
1115                     id,
1116                     parseLong(atts.getValue(&quot;address&quot;)),
1117                     parseLong(atts.getValue(&quot;size&quot;)));
1118             String level = atts.getValue(&quot;level&quot;);
1119             if (level != null) {
1120                 nm.setLevel(parseLong(level));
1121             }
1122             String compiler = search(atts, &quot;compiler&quot;, &quot;&quot;);
1123             nm.setCompiler(compiler);
1124             nmethods.put(id, nm);
1125             events.add(nm);
1126         } else if (qname.equals(&quot;parse&quot;)) {
1127             if (failureReason != null &amp;&amp; scopes.size() == 0 &amp;&amp; !lateInlining) {
1128                 // A compilation just failed, and we&#39;re back at a top
1129                 // compilation scope.
1130                 failureReason = null;
1131                 compile.reset();
1132                 site = compile.getCall();
1133             }
1134 
1135             // Error checking.
1136             if (methodHandleSite != null) {
1137                 reportInternalError(&quot;method handle site should have been replaced&quot;);
1138             }
1139             Method m = method(search(atts, &quot;method&quot;)); // this is the method being parsed
1140             if (lateInlining &amp;&amp; scopes.size() == 0) {
1141                 if (site.getMethod() != m) {
1142                     reportInternalError(&quot;Unexpected method mismatch during late inlining (method at call site: &quot; +
1143                         site.getMethod() + &quot;, method being parsed: &quot; + m + &quot;)&quot;);
1144                 }
1145             }
1146 
1147             if (scopes.size() == 0 &amp;&amp; !lateInlining) {
1148                 // The method being parsed is actually the method being
1149                 // compiled; i.e., we&#39;re dealing with a compilation top scope,
1150                 // which we must consequently push to the scopes stack.
1151                 compile.setMethod(m);
1152                 scopes.push(site);
1153             } else {
1154                 // The method being parsed is *not* the current compilation&#39;s
1155                 // top scope; i.e., we&#39;re dealing with an actual call site
1156                 // in the top scope or somewhere further down a call stack.
1157                 if (site != null &amp;&amp; site.getMethod() == m) {
1158                     // We&#39;re dealing with monomorphic inlining that didn&#39;t have
1159                     // to be narrowed down, because the receiver was known
1160                     // beforehand.
1161                     scopes.push(site);
1162                 } else if (scopes.peek().getCalls().size() &gt; 2 &amp;&amp; m == scopes.peek().lastButOne().getMethod()) {
1163                     // We&#39;re dealing with an at least bimorphic call site, and
1164                     // the compiler has now decided to parse the last-but-one
1165                     // method. The last one may already have been parsed for
1166                     // inlining.
1167                     scopes.push(scopes.peek().lastButOne());
1168                 } else {
1169                     // The method has been narrowed down to the one we&#39;re now
1170                     // going to parse, which is inlined here. It&#39;s monomorphic
1171                     // inlining, but was not immediately clear as such.
1172                     //
1173                     // C1 prints multiple method tags during inlining when it
1174                     // narrows the method being inlined. Example:
1175                     //   ...
1176                     //   &lt;method id=&quot;813&quot; holder=&quot;694&quot; name=&quot;toString&quot; return=&quot;695&quot; flags=&quot;1&quot; bytes=&quot;36&quot; iicount=&quot;1&quot;/&gt;
1177                     //   &lt;call method=&quot;813&quot; instr=&quot;invokevirtual&quot;/&gt;
1178                     //   &lt;inline_success reason=&quot;receiver is statically known&quot;/&gt;
1179                     //   &lt;method id=&quot;814&quot; holder=&quot;792&quot; name=&quot;toString&quot; return=&quot;695&quot; flags=&quot;1&quot; bytes=&quot;5&quot; iicount=&quot;3&quot;/&gt;
1180                     //   &lt;parse method=&quot;814&quot;&gt;
1181                     //   ...
1182                     site.setMethod(m);
1183                     scopes.push(site);
1184                 }
1185             }
1186         } else if (qname.equals(&quot;parse_done&quot;)) {
1187             // Attach collected information about IR nodes to the current
1188             // parsing scope before it&#39;s popped off the stack in endElement()
1189             // (see where the parse tag is handled).
1190             CallSite call = scopes.peek();
1191             call.setEndNodes(Integer.parseInt(search(atts, &quot;nodes&quot;, &quot;0&quot;)));
1192             call.setEndLiveNodes(Integer.parseInt(search(atts, &quot;live&quot;, &quot;0&quot;)));
1193             call.setTimeStamp(Double.parseDouble(search(atts, &quot;stamp&quot;)));
1194         }
1195     }
1196 
1197     /**
1198      * Process the end of a compilation log XML element.&lt;ul&gt;
1199      * &lt;li&gt;&lt;b&gt;parse:&lt;/b&gt; finish transforming a Java method&#39;s bytecode
1200      * instructions to an initial compiler IR graph.&lt;/li&gt;
1201      * &lt;li&gt;&lt;b&gt;uncommon_trap:&lt;/b&gt; record the end of processing an uncommon trap,
1202      * resetting {@link #currentTrap}.&lt;/li&gt;
1203      * &lt;li&gt;&lt;b&gt;eliminate_lock:&lt;/b&gt; record the end of a lock elimination,
1204      * resetting {@link #currentLockElimination}.&lt;/li&gt;
1205      * &lt;li&gt;&lt;b&gt;late_inline:&lt;/b&gt; the closing tag for late_inline does not denote
1206      * the end of a late inlining operation, but the end of the descriptive log
1207      * data given at its beginning. That is, we&#39;re now in the position to
1208      * assemble details about the inlining chain (bytecode instruction index in
1209      * caller, called method). The {@link #lateInlining} flag is set to
1210      * {@code true} here. (It will be reset when parsing the inlined methods is
1211      * done; this happens for the successful case in this method as well, when
1212      * {@code parse} elements are processed; and for inlining failures, in
1213      * {@link #startElement(String,String,String,Attributes)}, when {@code inline_fail} elements are
1214      * processed.)&lt;/li&gt;
1215      * &lt;li&gt;&lt;b&gt;task:&lt;/b&gt; perform cleanup at the end of a compilation. Note that
1216      * the explicit {@code task_done} event is handled in
1217      * {@link #startElement(String,String,String,Attributes)}.&lt;/li&gt;
1218      * &lt;/ul&gt;
1219      */
1220     @Override
1221     public void endElement(String uri, String localName, String qname) {
1222         try {
1223             if (qname.equals(&quot;parse&quot;)) {
1224                 // Finish dealing with the current call scope. If no more are
1225                 // left, no late inlining can be going on.
1226                 scopes.pop();
1227                 if (scopes.size() == 0) {
1228                     lateInlining = false;
1229                 }
1230                 // Don&#39;t carry a stale site to the next parse
1231                 site = null;
1232             } else if (qname.equals(&quot;uncommon_trap&quot;)) {
1233                 currentTrap = null;
1234             } else if (qname.startsWith(&quot;eliminate_lock&quot;)) {
1235                 currentLockElimination = null;
1236             } else if (qname.equals(&quot;late_inline&quot;)) {
1237                 // Populate late inlining info.
1238                 if (scopes.size() != 0) {
1239                     reportInternalError(&quot;scopes should be empty for late inline&quot;);
1240                 }
1241                 // late inline scopes are specified in reverse order:
1242                 // compiled method should be on top of stack.
1243                 CallSite caller = lateInlineScope.pop();
1244                 Method m = compile.getMethod();
1245                 if (!m.equals(caller.getMethod())) {
1246                     reportInternalError(String.format(&quot;call site and late_inline info don&#39;t match:\n  method %s\n  caller method %s, bci %d&quot;, m, caller.getMethod(), current_bci));
1247                 }
1248 
1249                 // Walk down the inlining chain and assemble bci+callee info.
1250                 // This needs to be converted from caller+bci info contained in
1251                 // the late_inline data.
1252                 CallSite lateInlineSite = compile.getLateInlineCall();
1253                 ArrayDeque&lt;CallSite&gt; thisCallScopes = new ArrayDeque&lt;&gt;();
1254                 do {
1255                     current_bci = caller.getBci();
1256                     // Next inlined call.
1257                     caller = lateInlineScope.pop();
1258                     CallSite callee = new CallSite(current_bci, caller.getMethod());
1259                     callee.setInlineId(caller.getInlineId());
1260                     thisCallScopes.addLast(callee);
1261                     lateInlineSite.add(callee);
1262                     lateInlineSite = callee;
1263                 } while (!lateInlineScope.isEmpty());
1264 
1265                 site = compile.getCall().findCallSite(thisCallScopes);
1266                 if (site == null) {
1267                     // Call site could not be found - report the problem in detail.
1268                     System.err.println(&quot;call scopes:&quot;);
1269                     for (CallSite c : thisCallScopes) {
1270                         System.err.println(c.getMethod() + &quot; &quot; + c.getBci() + &quot; &quot; + c.getInlineId());
1271                     }
1272                     CallSite c = thisCallScopes.getLast();
1273                     if (c.getInlineId() != 0) {
1274                         System.err.println(&quot;Looking for call site in entire tree:&quot;);
1275                         ArrayDeque&lt;CallSite&gt; stack = compile.getCall().findCallSite2(c);
1276                         for (CallSite c2 : stack) {
1277                             System.err.println(c2.getMethod() + &quot; &quot; + c2.getBci() + &quot; &quot; + c2.getInlineId());
1278                         }
1279                     }
1280                     System.err.println(caller.getMethod() + &quot; bci: &quot; + current_bci);
1281                     reportInternalError(&quot;couldn&#39;t find call site&quot;);
1282                 }
1283                 lateInlining = true;
1284 
1285                 if (caller.getBci() != -999) {
1286                     System.out.println(caller.getMethod());
1287                     reportInternalError(&quot;broken late_inline info&quot;);
1288                 }
1289                 if (site.getMethod() != caller.getMethod()) {
1290                     if (site.getInlineId() == caller.getInlineId()) {
1291                         site.setMethod(caller.getMethod());
1292                     } else {
1293                         System.out.println(site.getMethod());
1294                         System.out.println(caller.getMethod());
1295                         reportInternalError(&quot;call site and late_inline info don&#39;t match&quot;);
1296                     }
1297                 }
1298                 // late_inline is followed by parse with scopes.size() == 0,
1299                 // &#39;site&#39; will be pushed to scopes.
1300                 lateInlineScope = null;
1301             } else if (qname.equals(&quot;task&quot;)) {
1302                 types.clear();
1303                 methods.clear();
1304                 site = null;
1305                 lateInlining = false;
1306             } else if (qname.equals(&quot;replace_string_concat&quot;)) {
1307                 expectStringConcatTrap = false;
1308             }
1309         } catch (Exception e) {
1310             reportInternalError(&quot;exception while processing end element&quot;, e);
1311         }
1312     }
1313 
1314     //
1315     // Handlers for problems that occur in XML parsing itself.
1316     //
1317 
1318     @Override
1319     public void warning(org.xml.sax.SAXParseException e) {
1320         System.err.println(e.getMessage() + &quot; at line &quot; + e.getLineNumber() + &quot;, column &quot; + e.getColumnNumber());
1321         e.printStackTrace();
1322     }
1323 
1324     @Override
1325     public void error(org.xml.sax.SAXParseException e) {
1326         System.err.println(e.getMessage() + &quot; at line &quot; + e.getLineNumber() + &quot;, column &quot; + e.getColumnNumber());
1327         e.printStackTrace();
1328     }
1329 
1330     @Override
1331     public void fatalError(org.xml.sax.SAXParseException e) {
1332         System.err.println(e.getMessage() + &quot; at line &quot; + e.getLineNumber() + &quot;, column &quot; + e.getColumnNumber());
1333         e.printStackTrace();
1334     }
1335 }
    </pre>
  </body>
</html>