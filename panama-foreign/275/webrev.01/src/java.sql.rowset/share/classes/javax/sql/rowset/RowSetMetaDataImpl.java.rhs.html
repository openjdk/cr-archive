<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.sql.rowset/share/classes/javax/sql/rowset/RowSetMetaDataImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.sql.rowset;
  27 
  28 import java.sql.*;
  29 import javax.sql.*;
  30 import java.io.*;
  31 
  32 import java.lang.reflect.*;
  33 
  34 /**
  35  * Provides implementations for the methods that set and get
  36  * metadata information about a &lt;code&gt;RowSet&lt;/code&gt; object&#39;s columns.
  37  * A &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt; object keeps track of the
  38  * number of columns in the rowset and maintains an internal array
  39  * of column attributes for each column.
  40  * &lt;P&gt;
  41  * A &lt;code&gt;RowSet&lt;/code&gt; object creates a &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt;
  42  * object internally in order to set and retrieve information about
  43  * its columns.
  44  * &lt;P&gt;
  45  * NOTE: All metadata in a &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt; object
  46  * should be considered as unavailable until the &lt;code&gt;RowSet&lt;/code&gt; object
  47  * that it describes is populated.
  48  * Therefore, any &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt; method that retrieves information
  49  * is defined as having unspecified behavior when it is called
  50  * before the &lt;code&gt;RowSet&lt;/code&gt; object contains data.
  51  *
  52  * @since 1.5
  53  */
  54 public class RowSetMetaDataImpl implements RowSetMetaData,  Serializable {
<a name="2" id="anc2"></a><span class="line-added">  55     /**</span>
<span class="line-added">  56      * Constructs a {@code RowSetMetaDataImpl} object.</span>
<span class="line-added">  57      */</span>
<span class="line-added">  58     public RowSetMetaDataImpl() {}</span>
  59 
  60     /**
  61      * The number of columns in the &lt;code&gt;RowSet&lt;/code&gt; object that created
  62      * this &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt; object.
  63      * @serial
  64      */
  65     private int colCount;
  66 
  67     /**
  68      * An array of &lt;code&gt;ColInfo&lt;/code&gt; objects used to store information
  69      * about each column in the &lt;code&gt;RowSet&lt;/code&gt; object for which
  70      * this &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt; object was created. The first
  71      * &lt;code&gt;ColInfo&lt;/code&gt; object in this array contains information about
  72      * the first column in the &lt;code&gt;RowSet&lt;/code&gt; object, the second element
  73      * contains information about the second column, and so on.
  74      * @serial
  75      */
  76     private ColInfo[] colInfo;
  77 
  78     /**
  79      * Checks to see that the designated column is a valid column number for
  80      * the &lt;code&gt;RowSet&lt;/code&gt; object for which this &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt;
  81      * was created. To be valid, a column number must be greater than
  82      * &lt;code&gt;0&lt;/code&gt; and less than or equal to the number of columns in a row.
  83      * @throws SQLException with the message &quot;Invalid column index&quot;
  84      *        if the given column number is out of the range of valid column
  85      *        numbers for the &lt;code&gt;RowSet&lt;/code&gt; object
  86      */
  87     private void checkColRange(int col) throws SQLException {
  88         if (col &lt;= 0 || col &gt; colCount) {
  89             throw new SQLException(&quot;Invalid column index :&quot;+col);
  90         }
  91     }
  92 
  93     /**
  94      * Checks to see that the given SQL type is a valid column type and throws an
  95      * &lt;code&gt;SQLException&lt;/code&gt; object if it is not.
  96      * To be valid, a SQL type must be one of the constant values
  97      * in the &lt;code&gt;&lt;a href=&quot;../../sql/Types.html&quot;&gt;java.sql.Types&lt;/a&gt;&lt;/code&gt;
  98      * class.
  99      *
 100      * @param SQLType an &lt;code&gt;int&lt;/code&gt; defined in the class &lt;code&gt;java.sql.Types&lt;/code&gt;
 101      * @throws SQLException if the given &lt;code&gt;int&lt;/code&gt; is not a constant defined in the
 102      *         class &lt;code&gt;java.sql.Types&lt;/code&gt;
 103      */
 104     private void checkColType(int SQLType) throws SQLException {
 105         try {
 106             Class&lt;?&gt; c = java.sql.Types.class;
 107             Field[] publicFields = c.getFields();
 108             int fieldValue = 0;
 109             for (int i = 0; i &lt; publicFields.length; i++) {
 110                 fieldValue = publicFields[i].getInt(c);
 111                 if (fieldValue == SQLType) {
 112                     return;
 113                  }
 114             }
 115         } catch (Exception e) {
 116             throw new SQLException(e.getMessage());
 117         }
 118         throw new SQLException(&quot;Invalid SQL type for column&quot;);
 119     }
 120 
 121     /**
 122      * Sets to the given number the number of columns in the &lt;code&gt;RowSet&lt;/code&gt;
 123      * object for which this &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt; object was created.
 124      *
 125      * @param columnCount an &lt;code&gt;int&lt;/code&gt; giving the number of columns in the
 126      *        &lt;code&gt;RowSet&lt;/code&gt; object
 127      * @throws SQLException if the given number is equal to or less than zero
 128      */
 129     public void setColumnCount(int columnCount) throws SQLException {
 130 
 131         if (columnCount &lt;= 0) {
 132             throw new SQLException(&quot;Invalid column count. Cannot be less &quot; +
 133                 &quot;or equal to zero&quot;);
 134             }
 135 
 136        colCount = columnCount;
 137 
 138        // If the colCount is Integer.MAX_VALUE,
 139        // we do not initialize the colInfo object.
 140        // even if we try to initialize the colCount with
 141        // colCount = Integer.MAx_VALUE-1, the colInfo
 142        // initialization fails throwing an ERROR
 143        // OutOfMemory Exception. So we do not initialize
 144        // colInfo at Integer.MAX_VALUE. This is to pass TCK.
 145 
 146        if(!(colCount == Integer.MAX_VALUE)) {
 147             colInfo = new ColInfo[colCount + 1];
 148 
 149            for (int i=1; i &lt;= colCount; i++) {
 150                  colInfo[i] = new ColInfo();
 151            }
 152        }
 153 
 154 
 155     }
 156 
 157     /**
 158      * Sets whether the designated column is automatically
 159      * numbered, thus read-only, to the given &lt;code&gt;boolean&lt;/code&gt;
 160      * value.
 161      *
 162      * @param columnIndex the first column is 1, the second is 2, and so on;
 163      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns
 164      *        in the rowset, inclusive
 165      * @param property &lt;code&gt;true&lt;/code&gt; if the given column is
 166      *                 automatically incremented; &lt;code&gt;false&lt;/code&gt;
 167      *                 otherwise
 168      * @throws SQLException if a database access error occurs or
 169      *         the given index is out of bounds
 170      */
 171     public void setAutoIncrement(int columnIndex, boolean property) throws SQLException {
 172         checkColRange(columnIndex);
 173         colInfo[columnIndex].autoIncrement = property;
 174     }
 175 
 176     /**
 177      * Sets whether the name of the designated column is case sensitive to
 178      * the given &lt;code&gt;boolean&lt;/code&gt;.
 179      *
 180      * @param columnIndex the first column is 1, the second is 2, and so on;
 181      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns
 182      *        in the rowset, inclusive
 183      * @param property &lt;code&gt;true&lt;/code&gt; to indicate that the column
 184      *                 name is case sensitive; &lt;code&gt;false&lt;/code&gt; otherwise
 185      * @throws SQLException if a database access error occurs or
 186      *         the given column number is out of bounds
 187      */
 188     public void setCaseSensitive(int columnIndex, boolean property) throws SQLException {
 189         checkColRange(columnIndex);
 190         colInfo[columnIndex].caseSensitive = property;
 191     }
 192 
 193     /**
 194      * Sets whether a value stored in the designated column can be used
 195      * in a &lt;code&gt;WHERE&lt;/code&gt; clause to the given &lt;code&gt;boolean&lt;/code&gt; value.
 196      *
 197      * @param columnIndex the first column is 1, the second is 2, and so on;
 198      *                    must be between &lt;code&gt;1&lt;/code&gt; and the number
 199      *                    of columns in the rowset, inclusive
 200      * @param property &lt;code&gt;true&lt;/code&gt; to indicate that a column
 201      *                 value can be used in a &lt;code&gt;WHERE&lt;/code&gt; clause;
 202      *                 &lt;code&gt;false&lt;/code&gt; otherwise
 203      *
 204      * @throws SQLException if a database access error occurs or
 205      *         the given column number is out of bounds
 206      */
 207     public void setSearchable(int columnIndex, boolean property)
 208         throws SQLException {
 209         checkColRange(columnIndex);
 210         colInfo[columnIndex].searchable = property;
 211     }
 212 
 213     /**
 214      * Sets whether a value stored in the designated column is a cash
 215      * value to the given &lt;code&gt;boolean&lt;/code&gt;.
 216      *
 217      * @param columnIndex the first column is 1, the second is 2, and so on;
 218      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns,
 219      * inclusive between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 220      * @param property true if the value is a cash value; false otherwise.
 221      * @throws SQLException if a database access error occurs
 222      *         or the given column number is out of bounds
 223      */
 224     public void setCurrency(int columnIndex, boolean property)
 225         throws SQLException {
 226         checkColRange(columnIndex);
 227         colInfo[columnIndex].currency = property;
 228     }
 229 
 230     /**
 231      * Sets whether a value stored in the designated column can be set
 232      * to &lt;code&gt;NULL&lt;/code&gt; to the given constant from the interface
 233      * &lt;code&gt;ResultSetMetaData&lt;/code&gt;.
 234      *
 235      * @param columnIndex the first column is 1, the second is 2, and so on;
 236      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 237      * @param property one of the following &lt;code&gt;ResultSetMetaData&lt;/code&gt; constants:
 238      *                 &lt;code&gt;columnNoNulls&lt;/code&gt;,
 239      *                 &lt;code&gt;columnNullable&lt;/code&gt;, or
 240      *                 &lt;code&gt;columnNullableUnknown&lt;/code&gt;
 241      *
 242      * @throws SQLException if a database access error occurs,
 243      *         the given column number is out of bounds, or the value supplied
 244      *         for the &lt;i&gt;property&lt;/i&gt; parameter is not one of the following
 245      *         constants:
 246      *           &lt;code&gt;ResultSetMetaData.columnNoNulls&lt;/code&gt;,
 247      *           &lt;code&gt;ResultSetMetaData.columnNullable&lt;/code&gt;, or
 248      *           &lt;code&gt;ResultSetMetaData.columnNullableUnknown&lt;/code&gt;
 249      */
 250     public void setNullable(int columnIndex, int property) throws SQLException {
 251         if ((property &lt; ResultSetMetaData.columnNoNulls) ||
 252             property &gt; ResultSetMetaData.columnNullableUnknown) {
 253                 throw new SQLException(&quot;Invalid nullable constant set. Must be &quot; +
 254                     &quot;either columnNoNulls, columnNullable or columnNullableUnknown&quot;);
 255         }
 256         checkColRange(columnIndex);
 257         colInfo[columnIndex].nullable = property;
 258     }
 259 
 260     /**
 261      * Sets whether a value stored in the designated column is a signed
 262      * number to the given &lt;code&gt;boolean&lt;/code&gt;.
 263      *
 264      * @param columnIndex the first column is 1, the second is 2, and so on;
 265      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 266      * @param property &lt;code&gt;true&lt;/code&gt; to indicate that a column
 267      *                 value is a signed number;
 268      *                 &lt;code&gt;false&lt;/code&gt; to indicate that it is not
 269      * @throws SQLException if a database access error occurs
 270      *         or the given column number is out of bounds
 271      */
 272     public void setSigned(int columnIndex, boolean property) throws SQLException {
 273         checkColRange(columnIndex);
 274         colInfo[columnIndex].signed = property;
 275     }
 276 
 277     /**
 278      * Sets the normal maximum number of chars in the designated column
 279      * to the given number.
 280      *
 281      * @param columnIndex the first column is 1, the second is 2, and so on;
 282      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 283      * @param size the maximum size of the column in chars; must be
 284      *        &lt;code&gt;0&lt;/code&gt; or more
 285      * @throws SQLException if a database access error occurs,
 286      *        the given column number is out of bounds, or &lt;i&gt;size&lt;/i&gt; is
 287      *        less than &lt;code&gt;0&lt;/code&gt;
 288      */
 289     public void setColumnDisplaySize(int columnIndex, int size) throws SQLException {
 290         if (size &lt; 0) {
 291             throw new SQLException(&quot;Invalid column display size. Cannot be less &quot; +
 292                 &quot;than zero&quot;);
 293         }
 294         checkColRange(columnIndex);
 295         colInfo[columnIndex].columnDisplaySize = size;
 296     }
 297 
 298     /**
 299      * Sets the suggested column label for use in printouts and
 300      * displays, if any, to &lt;i&gt;label&lt;/i&gt;. If &lt;i&gt;label&lt;/i&gt; is
 301      * &lt;code&gt;null&lt;/code&gt;, the column label is set to an empty string
 302      * (&quot;&quot;).
 303      *
 304      * @param columnIndex the first column is 1, the second is 2, and so on;
 305      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 306      * @param label the column label to be used in printouts and displays; if the
 307      *        column label is &lt;code&gt;null&lt;/code&gt;, an empty &lt;code&gt;String&lt;/code&gt; is
 308      *        set
 309      * @throws SQLException if a database access error occurs
 310      *         or the given column index is out of bounds
 311      */
 312     public void setColumnLabel(int columnIndex, String label) throws SQLException {
 313         checkColRange(columnIndex);
 314         if (label != null) {
 315             colInfo[columnIndex].columnLabel = label;
 316         } else {
 317             colInfo[columnIndex].columnLabel = &quot;&quot;;
 318         }
 319     }
 320 
 321     /**
 322      * Sets the column name of the designated column to the given name.
 323      *
 324      * @param columnIndex the first column is 1, the second is 2, and so on;
 325      *      must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 326      * @param columnName a &lt;code&gt;String&lt;/code&gt; object indicating the column name;
 327      *      if the given name is &lt;code&gt;null&lt;/code&gt;, an empty &lt;code&gt;String&lt;/code&gt;
 328      *      is set
 329      * @throws SQLException if a database access error occurs or the given column
 330      *      index is out of bounds
 331      */
 332     public void setColumnName(int columnIndex, String columnName) throws SQLException {
 333         checkColRange(columnIndex);
 334         if (columnName != null) {
 335             colInfo[columnIndex].columnName = columnName;
 336         } else {
 337             colInfo[columnIndex].columnName = &quot;&quot;;
 338         }
 339     }
 340 
 341     /**
 342      * Sets the designated column&#39;s table&#39;s schema name, if any, to
 343      * &lt;i&gt;schemaName&lt;/i&gt;. If &lt;i&gt;schemaName&lt;/i&gt; is &lt;code&gt;null&lt;/code&gt;,
 344      * the schema name is set to an empty string (&quot;&quot;).
 345      *
 346      * @param columnIndex the first column is 1, the second is 2, and so on;
 347      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 348      * @param schemaName the schema name for the table from which a value in the
 349      *        designated column was derived; may be an empty &lt;code&gt;String&lt;/code&gt;
 350      *        or &lt;code&gt;null&lt;/code&gt;
 351      * @throws SQLException if a database access error occurs
 352      *        or the given column number is out of bounds
 353      */
 354     public void setSchemaName(int columnIndex, String schemaName) throws SQLException {
 355         checkColRange(columnIndex);
 356         if (schemaName != null ) {
 357             colInfo[columnIndex].schemaName = schemaName;
 358         } else {
 359             colInfo[columnIndex].schemaName = &quot;&quot;;
 360         }
 361     }
 362 
 363     /**
 364      * Sets the total number of decimal digits in a value stored in the
 365      * designated column to the given number.
 366      *
 367      * @param columnIndex the first column is 1, the second is 2, and so on;
 368      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 369      * @param precision the total number of decimal digits; must be &lt;code&gt;0&lt;/code&gt;
 370      *        or more
 371      * @throws SQLException if a database access error occurs,
 372      *         &lt;i&gt;columnIndex&lt;/i&gt; is out of bounds, or &lt;i&gt;precision&lt;/i&gt;
 373      *         is less than &lt;code&gt;0&lt;/code&gt;
 374      */
 375     public void setPrecision(int columnIndex, int precision) throws SQLException {
 376 
 377         if (precision &lt; 0) {
 378             throw new SQLException(&quot;Invalid precision value. Cannot be less &quot; +
 379                 &quot;than zero&quot;);
 380         }
 381         checkColRange(columnIndex);
 382         colInfo[columnIndex].colPrecision = precision;
 383     }
 384 
 385     /**
 386      * Sets the number of digits to the right of the decimal point in a value
 387      * stored in the designated column to the given number.
 388      *
 389      * @param columnIndex the first column is 1, the second is 2, and so on;
 390      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 391      * @param scale the number of digits to the right of the decimal point; must be
 392      *        zero or greater
 393      * @throws SQLException if a database access error occurs,
 394      *         &lt;i&gt;columnIndex&lt;/i&gt; is out of bounds, or &lt;i&gt;scale&lt;/i&gt;
 395      *         is less than &lt;code&gt;0&lt;/code&gt;
 396      */
 397     public void setScale(int columnIndex, int scale) throws SQLException {
 398         if (scale &lt; 0) {
 399             throw new SQLException(&quot;Invalid scale size. Cannot be less &quot; +
 400                 &quot;than zero&quot;);
 401         }
 402         checkColRange(columnIndex);
 403         colInfo[columnIndex].colScale = scale;
 404     }
 405 
 406     /**
 407      * Sets the name of the table from which the designated column
 408      * was derived to the given table name.
 409      *
 410      * @param columnIndex the first column is 1, the second is 2, and so on;
 411      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 412      * @param tableName the column&#39;s table name; may be &lt;code&gt;null&lt;/code&gt; or an
 413      *        empty string
 414      * @throws SQLException if a database access error occurs
 415      *         or the given column number is out of bounds
 416      */
 417     public void setTableName(int columnIndex, String tableName) throws SQLException {
 418         checkColRange(columnIndex);
 419         if (tableName != null) {
 420             colInfo[columnIndex].tableName = tableName;
 421         } else {
 422             colInfo[columnIndex].tableName = &quot;&quot;;
 423         }
 424     }
 425 
 426     /**
 427      * Sets the catalog name of the table from which the designated
 428      * column was derived to &lt;i&gt;catalogName&lt;/i&gt;. If &lt;i&gt;catalogName&lt;/i&gt;
 429      * is &lt;code&gt;null&lt;/code&gt;, the catalog name is set to an empty string.
 430      *
 431      * @param columnIndex the first column is 1, the second is 2, and so on;
 432      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 433      * @param catalogName the column&#39;s table&#39;s catalog name; if the catalogName
 434      *        is &lt;code&gt;null&lt;/code&gt;, an empty &lt;code&gt;String&lt;/code&gt; is set
 435      * @throws SQLException if a database access error occurs
 436      *         or the given column number is out of bounds
 437      */
 438     public void setCatalogName(int columnIndex, String catalogName) throws SQLException {
 439         checkColRange(columnIndex);
 440         if (catalogName != null)
 441             colInfo[columnIndex].catName = catalogName;
 442         else
 443             colInfo[columnIndex].catName = &quot;&quot;;
 444     }
 445 
 446     /**
 447      * Sets the SQL type code for values stored in the designated column
 448      * to the given type code from the class &lt;code&gt;java.sql.Types&lt;/code&gt;.
 449      *
 450      * @param columnIndex the first column is 1, the second is 2, and so on;
 451      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 452      * @param SQLType the designated column&#39;s SQL type, which must be one of the
 453      *                constants in the class &lt;code&gt;java.sql.Types&lt;/code&gt;
 454      * @throws SQLException if a database access error occurs,
 455      *         the given column number is out of bounds, or the column type
 456      *         specified is not one of the constants in
 457      *         &lt;code&gt;java.sql.Types&lt;/code&gt;
 458      * @see java.sql.Types
 459      */
 460     public void setColumnType(int columnIndex, int SQLType) throws SQLException {
 461         // examine java.sql.Type reflectively, loop on the fields and check
 462         // this. Separate out into a private method
 463         checkColType(SQLType);
 464         checkColRange(columnIndex);
 465         colInfo[columnIndex].colType = SQLType;
 466     }
 467 
 468     /**
 469      * Sets the type name used by the data source for values stored in the
 470      * designated column to the given type name.
 471      *
 472      * @param columnIndex the first column is 1, the second is 2, and so on;
 473      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 474      * @param typeName the data source-specific type name; if &lt;i&gt;typeName&lt;/i&gt; is
 475      *        &lt;code&gt;null&lt;/code&gt;, an empty &lt;code&gt;String&lt;/code&gt; is set
 476      * @throws SQLException if a database access error occurs
 477      *         or the given column number is out of bounds
 478      */
 479     public void setColumnTypeName(int columnIndex, String typeName)
 480         throws SQLException {
 481         checkColRange(columnIndex);
 482         if (typeName != null) {
 483             colInfo[columnIndex].colTypeName = typeName;
 484         } else {
 485             colInfo[columnIndex].colTypeName = &quot;&quot;;
 486         }
 487     }
 488 
 489     /**
 490      * Retrieves the number of columns in the &lt;code&gt;RowSet&lt;/code&gt; object
 491      * for which this &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt; object was created.
 492      *
 493      * @return the number of columns
 494      * @throws SQLException if an error occurs determining the column count
 495      */
 496     public int getColumnCount() throws SQLException {
 497         return colCount;
 498     }
 499 
 500     /**
 501      * Retrieves whether a value stored in the designated column is
 502      * automatically numbered, and thus readonly.
 503      *
 504      * @param columnIndex the first column is 1, the second is 2, and so on;
 505      *         must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 506      * @return &lt;code&gt;true&lt;/code&gt; if the column is automatically numbered;
 507      *         &lt;code&gt;false&lt;/code&gt; otherwise
 508      * @throws SQLException if a database access error occurs
 509      * or the given column number is out of bounds
 510      */
 511     public boolean isAutoIncrement(int columnIndex) throws SQLException {
 512         checkColRange(columnIndex);
 513         return colInfo[columnIndex].autoIncrement;
 514     }
 515 
 516     /**
 517      * Indicates whether the case of the designated column&#39;s name
 518      * matters.
 519      *
 520      * @param columnIndex the first column is 1, the second is 2, and so on;
 521      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 522      * @return &lt;code&gt;true&lt;/code&gt; if the column name is case sensitive;
 523      *          &lt;code&gt;false&lt;/code&gt; otherwise
 524      * @throws SQLException if a database access error occurs
 525      * or the given column number is out of bounds
 526      */
 527     public boolean isCaseSensitive(int columnIndex) throws SQLException {
 528         checkColRange(columnIndex);
 529         return colInfo[columnIndex].caseSensitive;
 530     }
 531 
 532     /**
 533      * Indicates whether a value stored in the designated column
 534      * can be used in a &lt;code&gt;WHERE&lt;/code&gt; clause.
 535      *
 536      * @param columnIndex the first column is 1, the second is 2, and so on;
 537      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 538      * @return &lt;code&gt;true&lt;/code&gt; if a value in the designated column can be used in a
 539      *         &lt;code&gt;WHERE&lt;/code&gt; clause; &lt;code&gt;false&lt;/code&gt; otherwise
 540      * @throws SQLException if a database access error occurs
 541      *         or the given column number is out of bounds
 542      */
 543     public boolean isSearchable(int columnIndex) throws SQLException {
 544         checkColRange(columnIndex);
 545         return colInfo[columnIndex].searchable;
 546     }
 547 
 548     /**
 549      * Indicates whether a value stored in the designated column
 550      * is a cash value.
 551      *
 552      * @param columnIndex the first column is 1, the second is 2, and so on;
 553      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 554      * @return &lt;code&gt;true&lt;/code&gt; if a value in the designated column is a cash value;
 555      *         &lt;code&gt;false&lt;/code&gt; otherwise
 556      * @throws SQLException if a database access error occurs
 557      *         or the given column number is out of bounds
 558      */
 559     public boolean isCurrency(int columnIndex) throws SQLException {
 560         checkColRange(columnIndex);
 561         return colInfo[columnIndex].currency;
 562     }
 563 
 564     /**
 565      * Retrieves a constant indicating whether it is possible
 566      * to store a &lt;code&gt;NULL&lt;/code&gt; value in the designated column.
 567      *
 568      * @param columnIndex the first column is 1, the second is 2, and so on;
 569      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 570      * @return a constant from the &lt;code&gt;ResultSetMetaData&lt;/code&gt; interface;
 571      *         either &lt;code&gt;columnNoNulls&lt;/code&gt;,
 572      *         &lt;code&gt;columnNullable&lt;/code&gt;, or
 573      *         &lt;code&gt;columnNullableUnknown&lt;/code&gt;
 574      * @throws SQLException if a database access error occurs
 575      *         or the given column number is out of bounds
 576      */
 577     public int isNullable(int columnIndex) throws SQLException {
 578         checkColRange(columnIndex);
 579         return colInfo[columnIndex].nullable;
 580     }
 581 
 582     /**
 583      * Indicates whether a value stored in the designated column is
 584      * a signed number.
 585      *
 586      * @param columnIndex the first column is 1, the second is 2, and so on;
 587      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 588      * @return &lt;code&gt;true&lt;/code&gt; if a value in the designated column is a signed
 589      *         number; &lt;code&gt;false&lt;/code&gt; otherwise
 590      * @throws SQLException if a database access error occurs
 591      *         or the given column number is out of bounds
 592      */
 593     public boolean isSigned(int columnIndex) throws SQLException {
 594         checkColRange(columnIndex);
 595         return colInfo[columnIndex].signed;
 596     }
 597 
 598     /**
 599      * Retrieves the normal maximum width in chars of the designated column.
 600      *
 601      * @param columnIndex the first column is 1, the second is 2, and so on;
 602      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 603      * @return the maximum number of chars that can be displayed in the designated
 604      *         column
 605      * @throws SQLException if a database access error occurs
 606      *         or the given column number is out of bounds
 607      */
 608     public int getColumnDisplaySize(int columnIndex) throws SQLException {
 609         checkColRange(columnIndex);
 610         return colInfo[columnIndex].columnDisplaySize;
 611     }
 612 
 613     /**
 614      * Retrieves the suggested column title for the designated
 615      * column for use in printouts and displays.
 616      *
 617      * @param columnIndex the first column is 1, the second is 2, and so on;
 618      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 619      * @return the suggested column name to use in printouts and displays
 620      * @throws SQLException if a database access error occurs
 621      *         or the given column number is out of bounds
 622      */
 623     public String getColumnLabel(int columnIndex) throws SQLException {
 624         checkColRange(columnIndex);
 625         return colInfo[columnIndex].columnLabel;
 626     }
 627 
 628     /**
 629      * Retrieves the name of the designated column.
 630      *
 631      * @param columnIndex the first column is 1, the second is 2, and so on;
 632      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 633      * @return the column name of the designated column
 634      * @throws SQLException if a database access error occurs
 635      * or the given column number is out of bounds
 636      */
 637     public String getColumnName(int columnIndex) throws SQLException {
 638         checkColRange(columnIndex);
 639         return colInfo[columnIndex].columnName;
 640     }
 641 
 642     /**
 643      * Retrieves the schema name of the table from which the value
 644      * in the designated column was derived.
 645      *
 646      * @param columnIndex the first column is 1, the second is 2, and so on;
 647      *         must be between &lt;code&gt;1&lt;/code&gt; and the number of columns,
 648      *         inclusive
 649      * @return the schema name or an empty &lt;code&gt;String&lt;/code&gt; if no schema
 650      *         name is available
 651      * @throws SQLException if a database access error occurs
 652      * or the given column number is out of bounds
 653      */
 654     public String getSchemaName(int columnIndex) throws SQLException {
 655         checkColRange(columnIndex);
 656         String str =&quot;&quot;;
 657         if(colInfo[columnIndex].schemaName == null){
 658         } else {
 659               str = colInfo[columnIndex].schemaName;
 660         }
 661         return str;
 662     }
 663 
 664     /**
 665      * Retrieves the total number of digits for values stored in
 666      * the designated column.
 667      *
 668      * @param columnIndex the first column is 1, the second is 2, and so on;
 669      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 670      * @return the precision for values stored in the designated column
 671      * @throws SQLException if a database access error occurs
 672      * or the given column number is out of bounds
 673      */
 674     public int getPrecision(int columnIndex) throws SQLException {
 675         checkColRange(columnIndex);
 676         return colInfo[columnIndex].colPrecision;
 677     }
 678 
 679     /**
 680      * Retrieves the number of digits to the right of the decimal point
 681      * for values stored in the designated column.
 682      *
 683      * @param columnIndex the first column is 1, the second is 2, and so on;
 684      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 685      * @return the scale for values stored in the designated column
 686      * @throws SQLException if a database access error occurs
 687      * or the given column number is out of bounds
 688      */
 689     public int getScale(int columnIndex) throws SQLException {
 690         checkColRange(columnIndex);
 691         return colInfo[columnIndex].colScale;
 692     }
 693 
 694     /**
 695      * Retrieves the name of the table from which the value
 696      * in the designated column was derived.
 697      *
 698      * @param columnIndex the first column is 1, the second is 2, and so on;
 699      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 700      * @return the table name or an empty &lt;code&gt;String&lt;/code&gt; if no table name
 701      *         is available
 702      * @throws SQLException if a database access error occurs
 703      * or the given column number is out of bounds
 704      */
 705     public String getTableName(int columnIndex) throws SQLException {
 706         checkColRange(columnIndex);
 707         return colInfo[columnIndex].tableName;
 708     }
 709 
 710     /**
 711      * Retrieves the catalog name of the table from which the value
 712      * in the designated column was derived.
 713      *
 714      * @param columnIndex the first column is 1, the second is 2, and so on;
 715      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 716      * @return the catalog name of the column&#39;s table or an empty
 717      *         &lt;code&gt;String&lt;/code&gt; if no catalog name is available
 718      * @throws SQLException if a database access error occurs
 719      * or the given column number is out of bounds
 720      */
 721     public String getCatalogName(int columnIndex) throws SQLException {
 722         checkColRange(columnIndex);
 723         String str =&quot;&quot;;
 724         if(colInfo[columnIndex].catName == null){
 725         } else {
 726            str = colInfo[columnIndex].catName;
 727         }
 728         return str;
 729     }
 730 
 731     /**
 732      * Retrieves the type code (one of the &lt;code&gt;java.sql.Types&lt;/code&gt;
 733      * constants) for the SQL type of the value stored in the
 734      * designated column.
 735      *
 736      * @param columnIndex the first column is 1, the second is 2, and so on;
 737      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 738      * @return an &lt;code&gt;int&lt;/code&gt; representing the SQL type of values
 739      * stored in the designated column
 740      * @throws SQLException if a database access error occurs
 741      * or the given column number is out of bounds
 742      * @see java.sql.Types
 743      */
 744     public int getColumnType(int columnIndex) throws SQLException {
 745         checkColRange(columnIndex);
 746         return colInfo[columnIndex].colType;
 747     }
 748 
 749     /**
 750      * Retrieves the DBMS-specific type name for values stored in the
 751      * designated column.
 752      *
 753      * @param columnIndex the first column is 1, the second is 2, and so on;
 754      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 755      * @return the type name used by the data source
 756      * @throws SQLException if a database access error occurs
 757      * or the given column number is out of bounds
 758      */
 759     public String getColumnTypeName(int columnIndex) throws SQLException {
 760         checkColRange(columnIndex);
 761         return colInfo[columnIndex].colTypeName;
 762     }
 763 
 764 
 765     /**
 766      * Indicates whether the designated column is definitely
 767      * not writable, thus readonly.
 768      *
 769      * @param columnIndex the first column is 1, the second is 2, and so on;
 770      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 771      * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;RowSet&lt;/code&gt; object is read-Only
 772      * and thus not updatable; &lt;code&gt;false&lt;/code&gt; otherwise
 773      * @throws SQLException if a database access error occurs
 774      * or the given column number is out of bounds
 775      */
 776     public boolean isReadOnly(int columnIndex) throws SQLException {
 777         checkColRange(columnIndex);
 778         return colInfo[columnIndex].readOnly;
 779     }
 780 
 781     /**
 782      * Indicates whether it is possible for a write operation on
 783      * the designated column to succeed. A return value of
 784      * &lt;code&gt;true&lt;/code&gt; means that a write operation may or may
 785      * not succeed.
 786      *
 787      * @param columnIndex the first column is 1, the second is 2, and so on;
 788      *         must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 789      * @return &lt;code&gt;true&lt;/code&gt; if a write operation on the designated column may
 790      *          will succeed; &lt;code&gt;false&lt;/code&gt; otherwise
 791      * @throws SQLException if a database access error occurs
 792      *         or the given column number is out of bounds
 793      */
 794     public boolean isWritable(int columnIndex) throws SQLException {
 795         checkColRange(columnIndex);
 796         return colInfo[columnIndex].writable;
 797     }
 798 
 799     /**
 800      * Indicates whether a write operation on the designated column
 801      * will definitely succeed.
 802      *
 803      * @param columnIndex the first column is 1, the second is 2, and so on;
 804      * must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 805      * @return &lt;code&gt;true&lt;/code&gt; if a write operation on the designated column will
 806      *         definitely succeed; &lt;code&gt;false&lt;/code&gt; otherwise
 807      * @throws SQLException if a database access error occurs
 808      * or the given column number is out of bounds
 809      */
 810     public  boolean isDefinitelyWritable(int columnIndex) throws SQLException {
 811         checkColRange(columnIndex);
 812         return true;
 813     }
 814 
 815     /**
 816      * Retrieves the fully-qualified name of the class in the Java
 817      * programming language to which a value in the designated column
 818      * will be mapped.  For example, if the value is an &lt;code&gt;int&lt;/code&gt;,
 819      * the class name returned by this method will be
 820      * &lt;code&gt;java.lang.Integer&lt;/code&gt;.
 821      * &lt;P&gt;
 822      * If the value in the designated column has a custom mapping,
 823      * this method returns the name of the class that implements
 824      * &lt;code&gt;SQLData&lt;/code&gt;. When the method &lt;code&gt;ResultSet.getObject&lt;/code&gt;
 825      * is called to retrieve a value from the designated column, it will
 826      * create an instance of this class or one of its subclasses.
 827      *
 828      * @param columnIndex the first column is 1, the second is 2, and so on;
 829      *        must be between &lt;code&gt;1&lt;/code&gt; and the number of columns, inclusive
 830      * @return the fully-qualified name of the class in the Java programming
 831      *        language that would be used by the method &lt;code&gt;RowSet.getObject&lt;/code&gt; to
 832      *        retrieve the value in the specified column. This is the class
 833      *        name used for custom mapping when there is a custom mapping.
 834      * @throws SQLException if a database access error occurs
 835      *         or the given column number is out of bounds
 836      */
 837     public String getColumnClassName(int columnIndex) throws SQLException {
 838         String className = String.class.getName();
 839 
 840         int sqlType = getColumnType(columnIndex);
 841 
 842         switch (sqlType) {
 843 
 844         case Types.NUMERIC:
 845         case Types.DECIMAL:
 846             className = java.math.BigDecimal.class.getName();
 847             break;
 848 
 849         case Types.BIT:
 850             className = java.lang.Boolean.class.getName();
 851             break;
 852 
 853         case Types.TINYINT:
 854             className = java.lang.Byte.class.getName();
 855             break;
 856 
 857         case Types.SMALLINT:
 858             className = java.lang.Short.class.getName();
 859             break;
 860 
 861         case Types.INTEGER:
 862             className = java.lang.Integer.class.getName();
 863             break;
 864 
 865         case Types.BIGINT:
 866             className = java.lang.Long.class.getName();
 867             break;
 868 
 869         case Types.REAL:
 870             className = java.lang.Float.class.getName();
 871             break;
 872 
 873         case Types.FLOAT:
 874         case Types.DOUBLE:
 875             className = java.lang.Double.class.getName();
 876             break;
 877 
 878         case Types.BINARY:
 879         case Types.VARBINARY:
 880         case Types.LONGVARBINARY:
 881             className = &quot;byte[]&quot;;
 882             break;
 883 
 884         case Types.DATE:
 885             className = java.sql.Date.class.getName();
 886             break;
 887 
 888         case Types.TIME:
 889             className = java.sql.Time.class.getName();
 890             break;
 891 
 892         case Types.TIMESTAMP:
 893             className = java.sql.Timestamp.class.getName();
 894             break;
 895 
 896         case Types.BLOB:
 897             className = java.sql.Blob.class.getName();
 898             break;
 899 
 900         case Types.CLOB:
 901             className = java.sql.Clob.class.getName();
 902             break;
 903         }
 904 
 905         return className;
 906     }
 907 
 908     /**
 909      * Returns an object that implements the given interface to allow access to non-standard methods,
 910      * or standard methods not exposed by the proxy.
 911      * The result may be either the object found to implement the interface or a proxy for that object.
 912      * If the receiver implements the interface then that is the object. If the receiver is a wrapper
 913      * and the wrapped object implements the interface then that is the object. Otherwise the object is
 914      *  the result of calling &lt;code&gt;unwrap&lt;/code&gt; recursively on the wrapped object. If the receiver is not a
 915      * wrapper and does not implement the interface, then an &lt;code&gt;SQLException&lt;/code&gt; is thrown.
 916      *
 917      * @param iface A Class defining an interface that the result must implement.
 918      * @return an object that implements the interface. May be a proxy for the actual implementing object.
 919      * @throws java.sql.SQLException If no object found that implements the interface
 920      * @since 1.6
 921      */
 922     public &lt;T&gt; T unwrap(java.lang.Class&lt;T&gt; iface) throws java.sql.SQLException {
 923 
 924         if(isWrapperFor(iface)) {
 925             return iface.cast(this);
 926         } else {
 927             throw new SQLException(&quot;unwrap failed for:&quot;+ iface);
 928         }
 929     }
 930 
 931     /**
 932      * Returns true if this either implements the interface argument or is directly or indirectly a wrapper
 933      * for an object that does. Returns false otherwise. If this implements the interface then return true,
 934      * else if this is a wrapper then return the result of recursively calling &lt;code&gt;isWrapperFor&lt;/code&gt; on the wrapped
 935      * object. If this does not implement the interface and is not a wrapper, return false.
 936      * This method should be implemented as a low-cost operation compared to &lt;code&gt;unwrap&lt;/code&gt; so that
 937      * callers can use this method to avoid expensive &lt;code&gt;unwrap&lt;/code&gt; calls that may fail. If this method
 938      * returns true then calling &lt;code&gt;unwrap&lt;/code&gt; with the same argument should succeed.
 939      *
 940      * @param interfaces a Class defining an interface.
 941      * @return true if this implements the interface or directly or indirectly wraps an object that does.
 942      * @throws java.sql.SQLException  if an error occurs while determining whether this is a wrapper
 943      * for an object with the given interface.
 944      * @since 1.6
 945      */
 946     public boolean isWrapperFor(Class&lt;?&gt; interfaces) throws SQLException {
 947         return interfaces.isInstance(this);
 948     }
 949 
 950     static final long serialVersionUID = 6893806403181801867L;
 951 
 952     private class ColInfo implements Serializable {
 953         /**
 954          * The field that indicates whether the value in this column is a number
 955          * that is incremented automatically, which makes the value read-only.
 956          * &lt;code&gt;true&lt;/code&gt; means that the value in this column
 957          * is automatically numbered; &lt;code&gt;false&lt;/code&gt; means that it is not.
 958          *
 959          * @serial
 960          */
 961         public boolean autoIncrement;
 962 
 963         /**
 964          * The field that indicates whether the value in this column is case sensitive.
 965          * &lt;code&gt;true&lt;/code&gt; means that it is; &lt;code&gt;false&lt;/code&gt; that it is not.
 966          *
 967          * @serial
 968          */
 969         public boolean caseSensitive;
 970 
 971         /**
 972          * The field that indicates whether the value in this column is a cash value
 973          * &lt;code&gt;true&lt;/code&gt; means that it is; &lt;code&gt;false&lt;/code&gt; that it is not.
 974          *
 975          * @serial
 976          */
 977         public boolean currency;
 978 
 979         /**
 980          * The field that indicates whether the value in this column is nullable.
 981          * The possible values are the &lt;code&gt;ResultSet&lt;/code&gt; constants
 982          * &lt;code&gt;columnNoNulls&lt;/code&gt;, &lt;code&gt;columnNullable&lt;/code&gt;, and
 983          * &lt;code&gt;columnNullableUnknown&lt;/code&gt;.
 984          *
 985          * @serial
 986          */
 987         public int nullable;
 988 
 989         /**
 990          * The field that indicates whether the value in this column is a signed number.
 991          * &lt;code&gt;true&lt;/code&gt; means that it is; &lt;code&gt;false&lt;/code&gt; that it is not.
 992          *
 993          * @serial
 994          */
 995         public boolean signed;
 996 
 997         /**
 998          * The field that indicates whether the value in this column can be used in
 999          * a &lt;code&gt;WHERE&lt;/code&gt; clause.
1000          * &lt;code&gt;true&lt;/code&gt; means that it can; &lt;code&gt;false&lt;/code&gt; that it cannot.
1001          *
1002          * @serial
1003          */
1004         public boolean searchable;
1005 
1006         /**
1007          * The field that indicates the normal maximum width in characters for
1008          * this column.
1009          *
1010          * @serial
1011          */
1012         public int columnDisplaySize;
1013 
1014         /**
1015          * The field that holds the suggested column title for this column, to be
1016          * used in printing and displays.
1017          *
1018          * @serial
1019          */
1020         public String columnLabel;
1021 
1022         /**
1023          * The field that holds the name of this column.
1024          *
1025          * @serial
1026          */
1027         public  String columnName;
1028 
1029         /**
1030          * The field that holds the schema name for the table from which this column
1031          * was derived.
1032          *
1033          * @serial
1034          */
1035         public String schemaName;
1036 
1037         /**
1038          * The field that holds the precision of the value in this column.  For number
1039          * types, the precision is the total number of decimal digits; for character types,
1040          * it is the maximum number of characters; for binary types, it is the maximum
1041          * length in bytes.
1042          *
1043          * @serial
1044          */
1045         public int colPrecision;
1046 
1047         /**
1048          * The field that holds the scale (number of digits to the right of the decimal
1049          * point) of the value in this column.
1050          *
1051          * @serial
1052          */
1053         public int colScale;
1054 
1055         /**
1056          * The field that holds the name of the table from which this column
1057          * was derived.  This value may be the empty string if there is no
1058          * table name, such as when this column is produced by a join.
1059          *
1060          * @serial
1061          */
1062         public String tableName =&quot;&quot;;
1063 
1064         /**
1065          * The field that holds the catalog name for the table from which this column
1066          * was derived.  If the DBMS does not support catalogs, the value may be the
1067          * empty string.
1068          *
1069          * @serial
1070          */
1071         public String catName;
1072 
1073         /**
1074          * The field that holds the type code from the class &lt;code&gt;java.sql.Types&lt;/code&gt;
1075          * indicating the type of the value in this column.
1076          *
1077          * @serial
1078          */
1079         public int colType;
1080 
1081         /**
1082          * The field that holds the type name used by this particular data source
1083          * for the value stored in this column.
1084          *
1085          * @serial
1086          */
1087         public String colTypeName;
1088 
1089         /**
1090          * The field that holds the updatability boolean per column of a RowSet
1091          *
1092          * @serial
1093          */
1094         public boolean readOnly = false;
1095 
1096         /**
1097          * The field that hold the writable boolean per column of a RowSet
1098          *
1099          *@serial
1100          */
1101         public boolean writable = true;
1102 
1103         static final long serialVersionUID = 5490834817919311283L;
1104     }
1105 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>