<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.tools.javac.api.Formattable.LocalizedString;
  29 import com.sun.tools.javac.code.*;
  30 import com.sun.tools.javac.code.Scope.WriteableScope;
  31 import com.sun.tools.javac.code.Source.Feature;
  32 import com.sun.tools.javac.code.Symbol.*;
  33 import com.sun.tools.javac.code.Type.*;
  34 import com.sun.tools.javac.comp.Attr.ResultInfo;
  35 import com.sun.tools.javac.comp.Check.CheckContext;
  36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
  39 import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
  40 import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
  41 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  42 import com.sun.tools.javac.jvm.*;
  43 import com.sun.tools.javac.main.Option;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  46 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  47 import com.sun.tools.javac.tree.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  50 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  51 import com.sun.tools.javac.util.*;
  52 import com.sun.tools.javac.util.DefinedBy.Api;
  53 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  55 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  56 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  57 
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.EnumSet;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.Map;
  65 import java.util.Set;
  66 import java.util.function.BiFunction;
  67 import java.util.function.BiPredicate;
  68 import java.util.function.Consumer;
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.stream.Stream;
  72 
  73 import javax.lang.model.element.ElementVisitor;
  74 
  75 import static com.sun.tools.javac.code.Flags.*;
  76 import static com.sun.tools.javac.code.Flags.BLOCK;
  77 import static com.sun.tools.javac.code.Flags.STATIC;
  78 import static com.sun.tools.javac.code.Kinds.*;
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 import static com.sun.tools.javac.code.TypeTag.*;
  81 import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
  82 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  83 import static com.sun.tools.javac.util.Iterators.createCompoundIterator;
  84 
  85 /** Helper class for name resolution, used mostly by the attribution phase.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class Resolve {
  93     protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
  94 
  95     Names names;
  96     Log log;
  97     Symtab syms;
  98     Attr attr;
  99     DeferredAttr deferredAttr;
 100     Check chk;
 101     Infer infer;
 102     ClassFinder finder;
 103     ModuleFinder moduleFinder;
 104     Types types;
 105     JCDiagnostic.Factory diags;
 106     public final boolean allowFunctionalInterfaceMostSpecific;
 107     public final boolean allowModules;
 108     public final boolean allowRecords;
 109     public final boolean checkVarargsAccessAfterResolution;
 110     private final boolean compactMethodDiags;
 111     private final boolean allowLocalVariableTypeInference;
 112     private final boolean allowYieldStatement;
 113     final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
 114 
 115     WriteableScope polymorphicSignatureScope;
 116 
 117     protected Resolve(Context context) {
 118         context.put(resolveKey, this);
 119         syms = Symtab.instance(context);
 120 
 121         varNotFound = new SymbolNotFoundError(ABSENT_VAR);
 122         methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
 123         typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
 124         referenceNotFound = ReferenceLookupResult.error(methodNotFound);
 125 
 126         names = Names.instance(context);
 127         log = Log.instance(context);
 128         attr = Attr.instance(context);
 129         deferredAttr = DeferredAttr.instance(context);
 130         chk = Check.instance(context);
 131         infer = Infer.instance(context);
 132         finder = ClassFinder.instance(context);
 133         moduleFinder = ModuleFinder.instance(context);
 134         types = Types.instance(context);
 135         diags = JCDiagnostic.Factory.instance(context);
 136         Preview preview = Preview.instance(context);
 137         Source source = Source.instance(context);
 138         Options options = Options.instance(context);
 139         compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
 140                 options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
 141         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
 142         Target target = Target.instance(context);
 143         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
 144         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
 145         allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 146                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 147         checkVarargsAccessAfterResolution =
 148                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
 149         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
 150         allowModules = Feature.MODULES.allowedInSource(source);
 151         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 152                 Feature.RECORDS.allowedInSource(source);
 153     }
 154 
 155     /** error symbols, which are returned when resolution fails
 156      */
 157     private final SymbolNotFoundError varNotFound;
 158     private final SymbolNotFoundError methodNotFound;
 159     private final SymbolNotFoundError typeNotFound;
 160 
 161     /** empty reference lookup result */
 162     private final ReferenceLookupResult referenceNotFound;
 163 
 164     public static Resolve instance(Context context) {
 165         Resolve instance = context.get(resolveKey);
 166         if (instance == null)
 167             instance = new Resolve(context);
 168         return instance;
 169     }
 170 
 171     private static Symbol bestOf(Symbol s1,
 172                                  Symbol s2) {
 173         return s1.kind.betterThan(s2.kind) ? s1 : s2;
 174     }
 175 
 176     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Verbose resolution diagnostics support&quot;&gt;
 177     enum VerboseResolutionMode {
 178         SUCCESS(&quot;success&quot;),
 179         FAILURE(&quot;failure&quot;),
 180         APPLICABLE(&quot;applicable&quot;),
 181         INAPPLICABLE(&quot;inapplicable&quot;),
 182         DEFERRED_INST(&quot;deferred-inference&quot;),
 183         PREDEF(&quot;predef&quot;),
 184         OBJECT_INIT(&quot;object-init&quot;),
 185         INTERNAL(&quot;internal&quot;);
 186 
 187         final String opt;
 188 
 189         private VerboseResolutionMode(String opt) {
 190             this.opt = opt;
 191         }
 192 
 193         static EnumSet&lt;VerboseResolutionMode&gt; getVerboseResolutionMode(Options opts) {
 194             String s = opts.get(&quot;debug.verboseResolution&quot;);
 195             EnumSet&lt;VerboseResolutionMode&gt; res = EnumSet.noneOf(VerboseResolutionMode.class);
 196             if (s == null) return res;
 197             if (s.contains(&quot;all&quot;)) {
 198                 res = EnumSet.allOf(VerboseResolutionMode.class);
 199             }
 200             Collection&lt;String&gt; args = Arrays.asList(s.split(&quot;,&quot;));
 201             for (VerboseResolutionMode mode : values()) {
 202                 if (args.contains(mode.opt)) {
 203                     res.add(mode);
 204                 } else if (args.contains(&quot;-&quot; + mode.opt)) {
 205                     res.remove(mode);
 206                 }
 207             }
 208             return res;
 209         }
 210     }
 211 
 212     void reportVerboseResolutionDiagnostic(DiagnosticPosition dpos, Name name, Type site,
 213             List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, Symbol bestSoFar) {
 214         boolean success = !bestSoFar.kind.isResolutionError();
 215 
 216         if (success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.SUCCESS)) {
 217             return;
 218         } else if (!success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.FAILURE)) {
 219             return;
 220         }
 221 
 222         if (bestSoFar.name == names.init &amp;&amp;
 223                 bestSoFar.owner == syms.objectType.tsym &amp;&amp;
 224                 !verboseResolutionMode.contains(VerboseResolutionMode.OBJECT_INIT)) {
 225             return; //skip diags for Object constructor resolution
 226         } else if (site == syms.predefClass.type &amp;&amp;
 227                 !verboseResolutionMode.contains(VerboseResolutionMode.PREDEF)) {
 228             return; //skip spurious diags for predef symbols (i.e. operators)
 229         } else if (currentResolutionContext.internalResolution &amp;&amp;
 230                 !verboseResolutionMode.contains(VerboseResolutionMode.INTERNAL)) {
 231             return;
 232         }
 233 
 234         int pos = 0;
 235         int mostSpecificPos = -1;
 236         ListBuffer&lt;JCDiagnostic&gt; subDiags = new ListBuffer&lt;&gt;();
 237         for (Candidate c : currentResolutionContext.candidates) {
 238             if (currentResolutionContext.step != c.step ||
 239                     (c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.APPLICABLE)) ||
 240                     (!c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.INAPPLICABLE))) {
 241                 continue;
 242             } else {
 243                 subDiags.append(c.isApplicable() ?
 244                         getVerboseApplicableCandidateDiag(pos, c.sym, c.mtype) :
 245                         getVerboseInapplicableCandidateDiag(pos, c.sym, c.details));
 246                 if (c.sym == bestSoFar)
 247                     mostSpecificPos = pos;
 248                 pos++;
 249             }
 250         }
 251         String key = success ? &quot;verbose.resolve.multi&quot; : &quot;verbose.resolve.multi.1&quot;;
 252         List&lt;Type&gt; argtypes2 = argtypes.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, bestSoFar, currentResolutionContext.step));
 253         JCDiagnostic main = diags.note(log.currentSource(), dpos, key, name,
 254                 site.tsym, mostSpecificPos, currentResolutionContext.step,
 255                 methodArguments(argtypes2),
 256                 methodArguments(typeargtypes));
 257         JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());
 258         log.report(d);
 259     }
 260 
 261     JCDiagnostic getVerboseApplicableCandidateDiag(int pos, Symbol sym, Type inst) {
 262         JCDiagnostic subDiag = null;
 263         if (sym.type.hasTag(FORALL)) {
 264             subDiag = diags.fragment(Fragments.PartialInstSig(inst));
 265         }
 266 
 267         String key = subDiag == null ?
 268                 &quot;applicable.method.found&quot; :
 269                 &quot;applicable.method.found.1&quot;;
 270 
 271         return diags.fragment(key, pos, sym, subDiag);
 272     }
 273 
 274     JCDiagnostic getVerboseInapplicableCandidateDiag(int pos, Symbol sym, JCDiagnostic subDiag) {
 275         return diags.fragment(Fragments.NotApplicableMethodFound(pos, sym, subDiag));
 276     }
 277     // &lt;/editor-fold&gt;
 278 
 279 /* ************************************************************************
 280  * Identifier resolution
 281  *************************************************************************/
 282 
 283     /** An environment is &quot;static&quot; if its static level is greater than
 284      *  the one of its outer environment
 285      */
 286     protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
 287         return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
 288     }
 289 
 290     /** An environment is an &quot;initializer&quot; if it is a constructor or
 291      *  an instance initializer.
 292      */
 293     static boolean isInitializer(Env&lt;AttrContext&gt; env) {
 294         Symbol owner = env.info.scope.owner;
 295         return owner.isConstructor() ||
 296             owner.owner.kind == TYP &amp;&amp;
 297             (owner.kind == VAR ||
 298              owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
 299             (owner.flags() &amp; STATIC) == 0;
 300     }
 301 
 302     /** Is class accessible in given environment?
 303      *  @param env    The current environment.
 304      *  @param c      The class whose accessibility is checked.
 305      */
 306     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
 307         return isAccessible(env, c, false);
 308     }
 309 
 310     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {
 311 
 312         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 313            to refer to an inaccessible type
 314         */
 315         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 316             return true;
 317 
 318         if (env.info.visitingServiceImplementation &amp;&amp;
 319             env.toplevel.modle == c.packge().modle) {
 320             return true;
 321         }
 322 
 323         boolean isAccessible = false;
 324         switch ((short)(c.flags() &amp; AccessFlags)) {
 325             case PRIVATE:
 326                 isAccessible =
 327                     env.enclClass.sym.outermostClass() ==
 328                     c.owner.outermostClass();
 329                 break;
 330             case 0:
 331                 isAccessible =
 332                     env.toplevel.packge == c.owner // fast special case
 333                     ||
 334                     env.toplevel.packge == c.packge();
 335                 break;
 336             default: // error recovery
 337                 isAccessible = true;
 338                 break;
 339             case PUBLIC:
 340                 if (allowModules) {
 341                     ModuleSymbol currModule = env.toplevel.modle;
 342                     currModule.complete();
 343                     PackageSymbol p = c.packge();
 344                     isAccessible =
 345                         currModule == p.modle ||
 346                         currModule.visiblePackages.get(p.fullname) == p ||
 347                         p == syms.rootPackage ||
 348                         (p.modle == syms.unnamedModule &amp;&amp; currModule.readModules.contains(p.modle));
 349                 } else {
 350                     isAccessible = true;
 351                 }
 352                 break;
 353             case PROTECTED:
 354                 isAccessible =
 355                     env.toplevel.packge == c.owner // fast special case
 356                     ||
 357                     env.toplevel.packge == c.packge()
 358                     ||
 359                     isInnerSubClass(env.enclClass.sym, c.owner);
 360                 break;
 361         }
 362         return (checkInner == false || c.type.getEnclosingType() == Type.noType) ?
 363             isAccessible :
 364             isAccessible &amp;&amp; isAccessible(env, c.type.getEnclosingType(), checkInner);
 365     }
 366     //where
 367         /** Is given class a subclass of given base class, or an inner class
 368          *  of a subclass?
 369          *  Return null if no such class exists.
 370          *  @param c     The class which is the subclass or is contained in it.
 371          *  @param base  The base class
 372          */
 373         private boolean isInnerSubClass(ClassSymbol c, Symbol base) {
 374             while (c != null &amp;&amp; !c.isSubClass(base, types)) {
 375                 c = c.owner.enclClass();
 376             }
 377             return c != null;
 378         }
 379 
 380     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t) {
 381         return isAccessible(env, t, false);
 382     }
 383 
 384     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t, boolean checkInner) {
 385         return (t.hasTag(ARRAY))
 386             ? isAccessible(env, types.cvarUpperBound(types.elemtype(t)))
 387             : isAccessible(env, t.tsym, checkInner);
 388     }
 389 
 390     /** Is symbol accessible as a member of given type in given environment?
 391      *  @param env    The current environment.
 392      *  @param site   The type of which the tested symbol is regarded
 393      *                as a member.
 394      *  @param sym    The symbol.
 395      */
 396     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
 397         return isAccessible(env, site, sym, false);
 398     }
 399     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym, boolean checkInner) {
 400         if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) return false;
 401 
 402         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 403            to refer to an inaccessible type
 404         */
 405         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 406             return true;
 407 
 408         if (env.info.visitingServiceImplementation &amp;&amp;
 409             env.toplevel.modle == sym.packge().modle) {
 410             return true;
 411         }
 412 
 413         switch ((short)(sym.flags() &amp; AccessFlags)) {
 414         case PRIVATE:
 415             return
 416                 (env.enclClass.sym == sym.owner // fast special case
 417                  ||
 418                  env.enclClass.sym.outermostClass() ==
 419                  sym.owner.outermostClass())
 420                 &amp;&amp;
 421                 sym.isInheritedIn(site.tsym, types);
 422         case 0:
 423             return
 424                 (env.toplevel.packge == sym.owner.owner // fast special case
 425                  ||
 426                  env.toplevel.packge == sym.packge())
 427                 &amp;&amp;
 428                 isAccessible(env, site, checkInner)
 429                 &amp;&amp;
 430                 sym.isInheritedIn(site.tsym, types)
 431                 &amp;&amp;
 432                 notOverriddenIn(site, sym);
 433         case PROTECTED:
 434             return
 435                 (env.toplevel.packge == sym.owner.owner // fast special case
 436                  ||
 437                  env.toplevel.packge == sym.packge()
 438                  ||
 439                  isProtectedAccessible(sym, env.enclClass.sym, site)
 440                  ||
 441                  // OK to select instance method or field from &#39;super&#39; or type name
 442                  // (but type names should be disallowed elsewhere!)
 443                  env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0 &amp;&amp; sym.kind != TYP)
 444                 &amp;&amp;
 445                 isAccessible(env, site, checkInner)
 446                 &amp;&amp;
 447                 notOverriddenIn(site, sym);
 448         default: // this case includes erroneous combinations as well
 449             return isAccessible(env, site, checkInner) &amp;&amp; notOverriddenIn(site, sym);
 450         }
 451     }
 452     //where
 453     /* `sym&#39; is accessible only if not overridden by
 454      * another symbol which is a member of `site&#39;
 455      * (because, if it is overridden, `sym&#39; is not strictly
 456      * speaking a member of `site&#39;). A polymorphic signature method
 457      * cannot be overridden (e.g. MH.invokeExact(Object[])).
 458      */
 459     private boolean notOverriddenIn(Type site, Symbol sym) {
 460         if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())
 461             return true;
 462         else {
 463             Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
 464             return (s2 == null || s2 == sym || sym.owner == s2.owner ||
 465                     !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));
 466         }
 467     }
 468     //where
 469         /** Is given protected symbol accessible if it is selected from given site
 470          *  and the selection takes place in given class?
 471          *  @param sym     The symbol with protected access
 472          *  @param c       The class where the access takes place
 473          *  @site          The type of the qualifier
 474          */
 475         private
 476         boolean isProtectedAccessible(Symbol sym, ClassSymbol c, Type site) {
 477             Type newSite = site.hasTag(TYPEVAR) ? site.getUpperBound() : site;
 478             while (c != null &amp;&amp;
 479                    !(c.isSubClass(sym.owner, types) &amp;&amp;
 480                      (c.flags() &amp; INTERFACE) == 0 &amp;&amp;
 481                      // In JLS 2e 6.6.2.1, the subclass restriction applies
 482                      // only to instance fields and methods -- types are excluded
 483                      // regardless of whether they are declared &#39;static&#39; or not.
 484                      ((sym.flags() &amp; STATIC) != 0 || sym.kind == TYP || newSite.tsym.isSubClass(c, types))))
 485                 c = c.owner.enclClass();
 486             return c != null;
 487         }
 488 
 489     /**
 490      * Performs a recursive scan of a type looking for accessibility problems
 491      * from current attribution environment
 492      */
 493     void checkAccessibleType(Env&lt;AttrContext&gt; env, Type t) {
 494         accessibilityChecker.visit(t, env);
 495     }
 496 
 497     /**
 498      * Accessibility type-visitor
 499      */
 500     Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt; accessibilityChecker =
 501             new Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt;() {
 502 
 503         void visit(List&lt;Type&gt; ts, Env&lt;AttrContext&gt; env) {
 504             for (Type t : ts) {
 505                 visit(t, env);
 506             }
 507         }
 508 
 509         public Void visitType(Type t, Env&lt;AttrContext&gt; env) {
 510             return null;
 511         }
 512 
 513         @Override
 514         public Void visitArrayType(ArrayType t, Env&lt;AttrContext&gt; env) {
 515             visit(t.elemtype, env);
 516             return null;
 517         }
 518 
 519         @Override
 520         public Void visitClassType(ClassType t, Env&lt;AttrContext&gt; env) {
 521             visit(t.getTypeArguments(), env);
 522             if (!isAccessible(env, t, true)) {
 523                 accessBase(new AccessError(env, null, t.tsym), env.tree.pos(), env.enclClass.sym, t, t.tsym.name, true);
 524             }
 525             return null;
 526         }
 527 
 528         @Override
 529         public Void visitWildcardType(WildcardType t, Env&lt;AttrContext&gt; env) {
 530             visit(t.type, env);
 531             return null;
 532         }
 533 
 534         @Override
 535         public Void visitMethodType(MethodType t, Env&lt;AttrContext&gt; env) {
 536             visit(t.getParameterTypes(), env);
 537             visit(t.getReturnType(), env);
 538             visit(t.getThrownTypes(), env);
 539             return null;
 540         }
 541     };
 542 
 543     /** Try to instantiate the type of a method so that it fits
 544      *  given type arguments and argument types. If successful, return
 545      *  the method&#39;s instantiated type, else return null.
 546      *  The instantiation will take into account an additional leading
 547      *  formal parameter if the method is an instance method seen as a member
 548      *  of an under determined site. In this case, we treat site as an additional
 549      *  parameter and the parameters of the class containing the method as
 550      *  additional type variables that get instantiated.
 551      *
 552      *  @param env         The current environment
 553      *  @param site        The type of which the method is a member.
 554      *  @param m           The method symbol.
 555      *  @param argtypes    The invocation&#39;s given value arguments.
 556      *  @param typeargtypes    The invocation&#39;s given type arguments.
 557      *  @param allowBoxing Allow boxing conversions of arguments.
 558      *  @param useVarargs Box trailing arguments into an array for varargs.
 559      */
 560     Type rawInstantiate(Env&lt;AttrContext&gt; env,
 561                         Type site,
 562                         Symbol m,
 563                         ResultInfo resultInfo,
 564                         List&lt;Type&gt; argtypes,
 565                         List&lt;Type&gt; typeargtypes,
 566                         boolean allowBoxing,
 567                         boolean useVarargs,
 568                         Warner warn) throws Infer.InferenceException {
 569         Type mt = types.memberType(site, m);
 570         // tvars is the list of formal type variables for which type arguments
 571         // need to inferred.
 572         List&lt;Type&gt; tvars = List.nil();
 573         if (typeargtypes == null) typeargtypes = List.nil();
 574         if (!mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 575             // This is not a polymorphic method, but typeargs are supplied
 576             // which is fine, see JLS 15.12.2.1
 577         } else if (mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 578             ForAll pmt = (ForAll) mt;
 579             if (typeargtypes.length() != pmt.tvars.length())
 580                  // not enough args
 581                 throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));
 582             // Check type arguments are within bounds
 583             List&lt;Type&gt; formals = pmt.tvars;
 584             List&lt;Type&gt; actuals = typeargtypes;
 585             while (formals.nonEmpty() &amp;&amp; actuals.nonEmpty()) {
 586                 List&lt;Type&gt; bounds = types.subst(types.getBounds((TypeVar)formals.head),
 587                                                 pmt.tvars, typeargtypes);
 588                 for (; bounds.nonEmpty(); bounds = bounds.tail) {
 589                     if (!types.isSubtypeUnchecked(actuals.head, bounds.head, warn)) {
 590                         throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));
 591                     }
 592                 }
 593                 formals = formals.tail;
 594                 actuals = actuals.tail;
 595             }
 596             mt = types.subst(pmt.qtype, pmt.tvars, typeargtypes);
 597         } else if (mt.hasTag(FORALL)) {
 598             ForAll pmt = (ForAll) mt;
 599             List&lt;Type&gt; tvars1 = types.newInstances(pmt.tvars);
 600             tvars = tvars.appendList(tvars1);
 601             mt = types.subst(pmt.qtype, pmt.tvars, tvars1);
 602         }
 603 
 604         // find out whether we need to go the slow route via infer
 605         boolean instNeeded = tvars.tail != null; /*inlined: tvars.nonEmpty()*/
 606         for (List&lt;Type&gt; l = argtypes;
 607              l.tail != null/*inlined: l.nonEmpty()*/ &amp;&amp; !instNeeded;
 608              l = l.tail) {
 609             if (l.head.hasTag(FORALL)) instNeeded = true;
 610         }
 611 
 612         if (instNeeded) {
 613             return infer.instantiateMethod(env,
 614                                     tvars,
 615                                     (MethodType)mt,
 616                                     resultInfo,
 617                                     (MethodSymbol)m,
 618                                     argtypes,
 619                                     allowBoxing,
 620                                     useVarargs,
 621                                     currentResolutionContext,
 622                                     warn);
 623         }
 624 
 625         DeferredAttr.DeferredAttrContext dc = currentResolutionContext.deferredAttrContext(m, infer.emptyContext, resultInfo, warn);
 626         currentResolutionContext.methodCheck.argumentsAcceptable(env, dc,
 627                                 argtypes, mt.getParameterTypes(), warn);
 628         dc.complete();
 629         return mt;
 630     }
 631 
 632     Type checkMethod(Env&lt;AttrContext&gt; env,
 633                      Type site,
 634                      Symbol m,
 635                      ResultInfo resultInfo,
 636                      List&lt;Type&gt; argtypes,
 637                      List&lt;Type&gt; typeargtypes,
 638                      Warner warn) {
 639         MethodResolutionContext prevContext = currentResolutionContext;
 640         try {
 641             currentResolutionContext = new MethodResolutionContext();
 642             currentResolutionContext.attrMode = (resultInfo.pt == Infer.anyPoly) ?
 643                     AttrMode.SPECULATIVE : DeferredAttr.AttrMode.CHECK;
 644             if (env.tree.hasTag(JCTree.Tag.REFERENCE)) {
 645                 //method/constructor references need special check class
 646                 //to handle inference variables in &#39;argtypes&#39; (might happen
 647                 //during an unsticking round)
 648                 currentResolutionContext.methodCheck =
 649                         new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
 650             }
 651             MethodResolutionPhase step = currentResolutionContext.step = env.info.pendingResolutionPhase;
 652             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 653                     step.isBoxingRequired(), step.isVarargsRequired(), warn);
 654         }
 655         finally {
 656             currentResolutionContext = prevContext;
 657         }
 658     }
 659 
 660     /** Same but returns null instead throwing a NoInstanceException
 661      */
 662     Type instantiate(Env&lt;AttrContext&gt; env,
 663                      Type site,
 664                      Symbol m,
 665                      ResultInfo resultInfo,
 666                      List&lt;Type&gt; argtypes,
 667                      List&lt;Type&gt; typeargtypes,
 668                      boolean allowBoxing,
 669                      boolean useVarargs,
 670                      Warner warn) {
 671         try {
 672             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 673                                   allowBoxing, useVarargs, warn);
 674         } catch (InapplicableMethodException ex) {
 675             return null;
 676         }
 677     }
 678 
 679     /**
 680      * This interface defines an entry point that should be used to perform a
 681      * method check. A method check usually consist in determining as to whether
 682      * a set of types (actuals) is compatible with another set of types (formals).
 683      * Since the notion of compatibility can vary depending on the circumstances,
 684      * this interfaces allows to easily add new pluggable method check routines.
 685      */
 686     interface MethodCheck {
 687         /**
 688          * Main method check routine. A method check usually consist in determining
 689          * as to whether a set of types (actuals) is compatible with another set of
 690          * types (formals). If an incompatibility is found, an unchecked exception
 691          * is assumed to be thrown.
 692          */
 693         void argumentsAcceptable(Env&lt;AttrContext&gt; env,
 694                                 DeferredAttrContext deferredAttrContext,
 695                                 List&lt;Type&gt; argtypes,
 696                                 List&lt;Type&gt; formals,
 697                                 Warner warn);
 698 
 699         /**
 700          * Retrieve the method check object that will be used during a
 701          * most specific check.
 702          */
 703         MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals);
 704     }
 705 
 706     /**
 707      * Helper enum defining all method check diagnostics (used by resolveMethodCheck).
 708      */
 709     enum MethodCheckDiag {
 710         /**
 711          * Actuals and formals differs in length.
 712          */
 713         ARITY_MISMATCH(&quot;arg.length.mismatch&quot;, &quot;infer.arg.length.mismatch&quot;),
 714         /**
 715          * An actual is incompatible with a formal.
 716          */
 717         ARG_MISMATCH(&quot;no.conforming.assignment.exists&quot;, &quot;infer.no.conforming.assignment.exists&quot;),
 718         /**
 719          * An actual is incompatible with the varargs element type.
 720          */
 721         VARARG_MISMATCH(&quot;varargs.argument.mismatch&quot;, &quot;infer.varargs.argument.mismatch&quot;),
 722         /**
 723          * The varargs element type is inaccessible.
 724          */
 725         INACCESSIBLE_VARARGS(&quot;inaccessible.varargs.type&quot;, &quot;inaccessible.varargs.type&quot;);
 726 
 727         final String basicKey;
 728         final String inferKey;
 729 
 730         MethodCheckDiag(String basicKey, String inferKey) {
 731             this.basicKey = basicKey;
 732             this.inferKey = inferKey;
 733         }
 734 
 735         String regex() {
 736             return String.format(&quot;([a-z]*\\.)*(%s|%s)&quot;, basicKey, inferKey);
 737         }
 738     }
 739 
 740     /**
 741      * Dummy method check object. All methods are deemed applicable, regardless
 742      * of their formal parameter types.
 743      */
 744     MethodCheck nilMethodCheck = new MethodCheck() {
 745         public void argumentsAcceptable(Env&lt;AttrContext&gt; env, DeferredAttrContext deferredAttrContext, List&lt;Type&gt; argtypes, List&lt;Type&gt; formals, Warner warn) {
 746             //do nothing - method always applicable regardless of actuals
 747         }
 748 
 749         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 750             return this;
 751         }
 752     };
 753 
 754     /**
 755      * Base class for &#39;real&#39; method checks. The class defines the logic for
 756      * iterating through formals and actuals and provides and entry point
 757      * that can be used by subclasses in order to define the actual check logic.
 758      */
 759     abstract class AbstractMethodCheck implements MethodCheck {
 760         @Override
 761         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 762                                     DeferredAttrContext deferredAttrContext,
 763                                     List&lt;Type&gt; argtypes,
 764                                     List&lt;Type&gt; formals,
 765                                     Warner warn) {
 766             //should we expand formals?
 767             boolean useVarargs = deferredAttrContext.phase.isVarargsRequired();
 768             JCTree callTree = treeForDiagnostics(env);
 769             List&lt;JCExpression&gt; trees = TreeInfo.args(callTree);
 770 
 771             //inference context used during this method check
 772             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
 773 
 774             Type varargsFormal = useVarargs ? formals.last() : null;
 775 
 776             if (varargsFormal == null &amp;&amp;
 777                     argtypes.size() != formals.size()) {
 778                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 779             }
 780 
 781             while (argtypes.nonEmpty() &amp;&amp; formals.head != varargsFormal) {
 782                 DiagnosticPosition pos = trees != null ? trees.head : null;
 783                 checkArg(pos, false, argtypes.head, formals.head, deferredAttrContext, warn);
 784                 argtypes = argtypes.tail;
 785                 formals = formals.tail;
 786                 trees = trees != null ? trees.tail : trees;
 787             }
 788 
 789             if (formals.head != varargsFormal) {
 790                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 791             }
 792 
 793             if (useVarargs) {
 794                 //note: if applicability check is triggered by most specific test,
 795                 //the last argument of a varargs is _not_ an array type (see JLS 15.12.2.5)
 796                 final Type elt = types.elemtype(varargsFormal);
 797                 while (argtypes.nonEmpty()) {
 798                     DiagnosticPosition pos = trees != null ? trees.head : null;
 799                     checkArg(pos, true, argtypes.head, elt, deferredAttrContext, warn);
 800                     argtypes = argtypes.tail;
 801                     trees = trees != null ? trees.tail : trees;
 802                 }
 803             }
 804         }
 805 
 806             // where
 807             private JCTree treeForDiagnostics(Env&lt;AttrContext&gt; env) {
 808                 return env.info.preferredTreeForDiagnostics != null ? env.info.preferredTreeForDiagnostics : env.tree;
 809             }
 810 
 811         /**
 812          * Does the actual argument conforms to the corresponding formal?
 813          */
 814         abstract void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn);
 815 
 816         protected void reportMC(DiagnosticPosition pos, MethodCheckDiag diag, InferenceContext inferenceContext, Object... args) {
 817             boolean inferDiag = inferenceContext != infer.emptyContext;
 818             if (inferDiag &amp;&amp; (!diag.inferKey.equals(diag.basicKey))) {
 819                 Object[] args2 = new Object[args.length + 1];
 820                 System.arraycopy(args, 0, args2, 1, args.length);
 821                 args2[0] = inferenceContext.inferenceVars();
 822                 args = args2;
 823             }
 824             String key = inferDiag ? diag.inferKey : diag.basicKey;
 825             throw inferDiag ?
 826                 infer.error(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args)) :
 827                 methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));
 828         }
 829 
 830         /**
 831          * To eliminate the overhead associated with allocating an exception object in such an
 832          * hot execution path, we use flyweight pattern - and share the same exception instance
 833          * across multiple method check failures.
 834          */
 835         class SharedInapplicableMethodException extends InapplicableMethodException {
 836             private static final long serialVersionUID = 0;
 837 
 838             SharedInapplicableMethodException() {
 839                 super(null);
 840             }
 841 
 842             SharedInapplicableMethodException setMessage(JCDiagnostic details) {
 843                 this.diagnostic = details;
 844                 return this;
 845             }
 846         }
 847 
 848         SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();
 849 
 850         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 851             return nilMethodCheck;
 852         }
 853 
 854     }
 855 
 856     /**
 857      * Arity-based method check. A method is applicable if the number of actuals
 858      * supplied conforms to the method signature.
 859      */
 860     MethodCheck arityMethodCheck = new AbstractMethodCheck() {
 861         @Override
 862         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 863             //do nothing - actual always compatible to formals
 864         }
 865 
 866         @Override
 867         public String toString() {
 868             return &quot;arityMethodCheck&quot;;
 869         }
 870     };
 871 
 872     /**
 873      * Main method applicability routine. Given a list of actual types A,
 874      * a list of formal types F, determines whether the types in A are
 875      * compatible (by method invocation conversion) with the types in F.
 876      *
 877      * Since this routine is shared between overload resolution and method
 878      * type-inference, a (possibly empty) inference context is used to convert
 879      * formal types to the corresponding &#39;undet&#39; form ahead of a compatibility
 880      * check so that constraints can be propagated and collected.
 881      *
 882      * Moreover, if one or more types in A is a deferred type, this routine uses
 883      * DeferredAttr in order to perform deferred attribution. If one or more actual
 884      * deferred types are stuck, they are placed in a queue and revisited later
 885      * after the remainder of the arguments have been seen. If this is not sufficient
 886      * to &#39;unstuck&#39; the argument, a cyclic inference error is called out.
 887      *
 888      * A method check handler (see above) is used in order to report errors.
 889      */
 890     MethodCheck resolveMethodCheck = new AbstractMethodCheck() {
 891 
 892         @Override
 893         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 894             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 895             mresult.check(pos, actual);
 896         }
 897 
 898         @Override
 899         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 900                                     DeferredAttrContext deferredAttrContext,
 901                                     List&lt;Type&gt; argtypes,
 902                                     List&lt;Type&gt; formals,
 903                                     Warner warn) {
 904             super.argumentsAcceptable(env, deferredAttrContext, argtypes, formals, warn);
 905             // should we check varargs element type accessibility?
 906             if (deferredAttrContext.phase.isVarargsRequired()) {
 907                 if (deferredAttrContext.mode == AttrMode.CHECK || !checkVarargsAccessAfterResolution) {
 908                     varargsAccessible(env, types.elemtype(formals.last()), deferredAttrContext.inferenceContext);
 909                 }
 910             }
 911         }
 912 
 913         /**
 914          * Test that the runtime array element type corresponding to &#39;t&#39; is accessible.  &#39;t&#39; should be the
 915          * varargs element type of either the method invocation type signature (after inference completes)
 916          * or the method declaration signature (before inference completes).
 917          */
 918         private void varargsAccessible(final Env&lt;AttrContext&gt; env, final Type t, final InferenceContext inferenceContext) {
 919             if (inferenceContext.free(t)) {
 920                 inferenceContext.addFreeTypeListener(List.of(t),
 921                         solvedContext -&gt; varargsAccessible(env, solvedContext.asInstType(t), solvedContext));
 922             } else {
 923                 if (!isAccessible(env, types.erasure(t))) {
 924                     Symbol location = env.enclClass.sym;
 925                     reportMC(env.tree, MethodCheckDiag.INACCESSIBLE_VARARGS, inferenceContext, t, Kinds.kindName(location), location);
 926                 }
 927             }
 928         }
 929 
 930         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 931                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 932             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 933                 MethodCheckDiag methodDiag = varargsCheck ?
 934                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 935 
 936                 @Override
 937                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 938                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 939                 }
 940             };
 941             return new MethodResultInfo(to, checkContext);
 942         }
 943 
 944         @Override
 945         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 946             return new MostSpecificCheck(actuals);
 947         }
 948 
 949         @Override
 950         public String toString() {
 951             return &quot;resolveMethodCheck&quot;;
 952         }
 953     };
 954 
 955     /**
 956      * This class handles method reference applicability checks; since during
 957      * these checks it&#39;s sometime possible to have inference variables on
 958      * the actual argument types list, the method applicability check must be
 959      * extended so that inference variables are &#39;opened&#39; as needed.
 960      */
 961     class MethodReferenceCheck extends AbstractMethodCheck {
 962 
 963         InferenceContext pendingInferenceContext;
 964 
 965         MethodReferenceCheck(InferenceContext pendingInferenceContext) {
 966             this.pendingInferenceContext = pendingInferenceContext;
 967         }
 968 
 969         @Override
 970         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 971             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 972             mresult.check(pos, actual);
 973         }
 974 
 975         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 976                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 977             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 978                 MethodCheckDiag methodDiag = varargsCheck ?
 979                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 980 
 981                 @Override
 982                 public boolean compatible(Type found, Type req, Warner warn) {
 983                     found = pendingInferenceContext.asUndetVar(found);
 984                     if (found.hasTag(UNDETVAR) &amp;&amp; req.isPrimitive()) {
 985                         req = types.boxedClass(req).type;
 986                     }
 987                     return super.compatible(found, req, warn);
 988                 }
 989 
 990                 @Override
 991                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 992                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 993                 }
 994             };
 995             return new MethodResultInfo(to, checkContext);
 996         }
 997 
 998         @Override
 999         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1000             return new MostSpecificCheck(actuals);
1001         }
1002 
1003         @Override
1004         public String toString() {
1005             return &quot;MethodReferenceCheck&quot;;
1006         }
1007     }
1008 
1009     /**
1010      * Check context to be used during method applicability checks. A method check
1011      * context might contain inference variables.
1012      */
1013     abstract class MethodCheckContext implements CheckContext {
1014 
1015         boolean strict;
1016         DeferredAttrContext deferredAttrContext;
1017         Warner rsWarner;
1018 
1019         public MethodCheckContext(boolean strict, DeferredAttrContext deferredAttrContext, Warner rsWarner) {
1020            this.strict = strict;
1021            this.deferredAttrContext = deferredAttrContext;
1022            this.rsWarner = rsWarner;
1023         }
1024 
1025         public boolean compatible(Type found, Type req, Warner warn) {
1026             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
1027             return strict ?
1028                     types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :
1029                     types.isConvertible(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn);
1030         }
1031 
1032         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1033             throw new InapplicableMethodException(details);
1034         }
1035 
1036         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
1037             return rsWarner;
1038         }
1039 
1040         public InferenceContext inferenceContext() {
1041             return deferredAttrContext.inferenceContext;
1042         }
1043 
1044         public DeferredAttrContext deferredAttrContext() {
1045             return deferredAttrContext;
1046         }
1047 
1048         @Override
1049         public String toString() {
1050             return &quot;MethodCheckContext&quot;;
1051         }
1052     }
1053 
1054     /**
1055      * ResultInfo class to be used during method applicability checks. Check
1056      * for deferred types goes through special path.
1057      */
1058     class MethodResultInfo extends ResultInfo {
1059 
1060         public MethodResultInfo(Type pt, CheckContext checkContext) {
1061             attr.super(KindSelector.VAL, pt, checkContext);
1062         }
1063 
1064         @Override
1065         protected Type check(DiagnosticPosition pos, Type found) {
1066             if (found.hasTag(DEFERRED)) {
1067                 DeferredType dt = (DeferredType)found;
1068                 return dt.check(this);
1069             } else {
1070                 Type uResult = U(found);
1071                 Type capturedType = pos == null || pos.getTree() == null ?
1072                         types.capture(uResult) :
1073                         checkContext.inferenceContext()
1074                             .cachedCapture(pos.getTree(), uResult, true);
1075                 return super.check(pos, chk.checkNonVoid(pos, capturedType));
1076             }
1077         }
1078 
1079         /**
1080          * javac has a long-standing &#39;simplification&#39; (see 6391995):
1081          * given an actual argument type, the method check is performed
1082          * on its upper bound. This leads to inconsistencies when an
1083          * argument type is checked against itself. For example, given
1084          * a type-variable T, it is not true that {@code U(T) &lt;: T},
1085          * so we need to guard against that.
1086          */
1087         private Type U(Type found) {
1088             return found == pt ?
1089                     found : types.cvarUpperBound(found);
1090         }
1091 
1092         @Override
1093         protected MethodResultInfo dup(Type newPt) {
1094             return new MethodResultInfo(newPt, checkContext);
1095         }
1096 
1097         @Override
1098         protected ResultInfo dup(CheckContext newContext) {
1099             return new MethodResultInfo(pt, newContext);
1100         }
1101 
1102         @Override
1103         protected ResultInfo dup(Type newPt, CheckContext newContext) {
1104             return new MethodResultInfo(newPt, newContext);
1105         }
1106     }
1107 
1108     /**
1109      * Most specific method applicability routine. Given a list of actual types A,
1110      * a list of formal types F1, and a list of formal types F2, the routine determines
1111      * as to whether the types in F1 can be considered more specific than those in F2 w.r.t.
1112      * argument types A.
1113      */
1114     class MostSpecificCheck implements MethodCheck {
1115 
1116         List&lt;Type&gt; actuals;
1117 
1118         MostSpecificCheck(List&lt;Type&gt; actuals) {
1119             this.actuals = actuals;
1120         }
1121 
1122         @Override
1123         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
1124                                     DeferredAttrContext deferredAttrContext,
1125                                     List&lt;Type&gt; formals1,
1126                                     List&lt;Type&gt; formals2,
1127                                     Warner warn) {
1128             formals2 = adjustArgs(formals2, deferredAttrContext.msym, formals1.length(), deferredAttrContext.phase.isVarargsRequired());
1129             while (formals2.nonEmpty()) {
1130                 ResultInfo mresult = methodCheckResult(formals2.head, deferredAttrContext, warn, actuals.head);
1131                 mresult.check(null, formals1.head);
1132                 formals1 = formals1.tail;
1133                 formals2 = formals2.tail;
1134                 actuals = actuals.isEmpty() ? actuals : actuals.tail;
1135             }
1136         }
1137 
1138        /**
1139         * Create a method check context to be used during the most specific applicability check
1140         */
1141         ResultInfo methodCheckResult(Type to, DeferredAttr.DeferredAttrContext deferredAttrContext,
1142                Warner rsWarner, Type actual) {
1143             return attr.new ResultInfo(KindSelector.VAL, to,
1144                    new MostSpecificCheckContext(deferredAttrContext, rsWarner, actual));
1145         }
1146 
1147         /**
1148          * Subclass of method check context class that implements most specific
1149          * method conversion. If the actual type under analysis is a deferred type
1150          * a full blown structural analysis is carried out.
1151          */
1152         class MostSpecificCheckContext extends MethodCheckContext {
1153 
1154             Type actual;
1155 
1156             public MostSpecificCheckContext(DeferredAttrContext deferredAttrContext, Warner rsWarner, Type actual) {
1157                 super(true, deferredAttrContext, rsWarner);
1158                 this.actual = actual;
1159             }
1160 
1161             public boolean compatible(Type found, Type req, Warner warn) {
1162                 if (allowFunctionalInterfaceMostSpecific &amp;&amp;
1163                         unrelatedFunctionalInterfaces(found, req) &amp;&amp;
1164                         (actual != null &amp;&amp; actual.getTag() == DEFERRED)) {
1165                     DeferredType dt = (DeferredType) actual;
1166                     JCTree speculativeTree = dt.speculativeTree(deferredAttrContext);
1167                     if (speculativeTree != deferredAttr.stuckTree) {
1168                         return functionalInterfaceMostSpecific(found, req, speculativeTree);
1169                     }
1170                 }
1171                 return compatibleBySubtyping(found, req);
1172             }
1173 
1174             private boolean compatibleBySubtyping(Type found, Type req) {
1175                 if (!strict &amp;&amp; found.isPrimitive() != req.isPrimitive()) {
1176                     found = found.isPrimitive() ? types.boxedClass(found).type : types.unboxedType(found);
1177                 }
1178                 return types.isSubtypeNoCapture(found, deferredAttrContext.inferenceContext.asUndetVar(req));
1179             }
1180 
1181             /** Whether {@code t} and {@code s} are unrelated functional interface types. */
1182             private boolean unrelatedFunctionalInterfaces(Type t, Type s) {
1183                 return types.isFunctionalInterface(t.tsym) &amp;&amp;
1184                        types.isFunctionalInterface(s.tsym) &amp;&amp;
1185                        unrelatedInterfaces(t, s);
1186             }
1187 
1188             /** Whether {@code t} and {@code s} are unrelated interface types; recurs on intersections. **/
1189             private boolean unrelatedInterfaces(Type t, Type s) {
1190                 if (t.isCompound()) {
1191                     for (Type ti : types.interfaces(t)) {
1192                         if (!unrelatedInterfaces(ti, s)) {
1193                             return false;
1194                         }
1195                     }
1196                     return true;
1197                 } else if (s.isCompound()) {
1198                     for (Type si : types.interfaces(s)) {
1199                         if (!unrelatedInterfaces(t, si)) {
1200                             return false;
1201                         }
1202                     }
1203                     return true;
1204                 } else {
1205                     return types.asSuper(t, s.tsym) == null &amp;&amp; types.asSuper(s, t.tsym) == null;
1206                 }
1207             }
1208 
1209             /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1210             private boolean functionalInterfaceMostSpecific(Type t, Type s, JCTree tree) {
1211                 Type tDesc = types.findDescriptorType(types.capture(t));
1212                 Type tDescNoCapture = types.findDescriptorType(t);
1213                 Type sDesc = types.findDescriptorType(s);
1214                 final List&lt;Type&gt; tTypeParams = tDesc.getTypeArguments();
1215                 final List&lt;Type&gt; tTypeParamsNoCapture = tDescNoCapture.getTypeArguments();
1216                 final List&lt;Type&gt; sTypeParams = sDesc.getTypeArguments();
1217 
1218                 // compare type parameters
1219                 if (tDesc.hasTag(FORALL) &amp;&amp; !types.hasSameBounds((ForAll) tDesc, (ForAll) tDescNoCapture)) {
1220                     return false;
1221                 }
1222                 // can&#39;t use Types.hasSameBounds on sDesc because bounds may have ivars
1223                 List&lt;Type&gt; tIter = tTypeParams;
1224                 List&lt;Type&gt; sIter = sTypeParams;
1225                 while (tIter.nonEmpty() &amp;&amp; sIter.nonEmpty()) {
1226                     Type tBound = tIter.head.getUpperBound();
1227                     Type sBound = types.subst(sIter.head.getUpperBound(), sTypeParams, tTypeParams);
1228                     if (tBound.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sBound)) {
1229                         return false;
1230                     }
1231                     if (!types.isSameType(tBound, inferenceContext().asUndetVar(sBound))) {
1232                         return false;
1233                     }
1234                     tIter = tIter.tail;
1235                     sIter = sIter.tail;
1236                 }
1237                 if (!tIter.isEmpty() || !sIter.isEmpty()) {
1238                     return false;
1239                 }
1240 
1241                 // compare parameters
1242                 List&lt;Type&gt; tParams = tDesc.getParameterTypes();
1243                 List&lt;Type&gt; tParamsNoCapture = tDescNoCapture.getParameterTypes();
1244                 List&lt;Type&gt; sParams = sDesc.getParameterTypes();
1245                 while (tParams.nonEmpty() &amp;&amp; tParamsNoCapture.nonEmpty() &amp;&amp; sParams.nonEmpty()) {
1246                     Type tParam = tParams.head;
1247                     Type tParamNoCapture = types.subst(tParamsNoCapture.head, tTypeParamsNoCapture, tTypeParams);
1248                     Type sParam = types.subst(sParams.head, sTypeParams, tTypeParams);
1249                     if (tParam.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sParam)) {
1250                         return false;
1251                     }
1252                     if (!types.isSubtype(inferenceContext().asUndetVar(sParam), tParam)) {
1253                         return false;
1254                     }
1255                     if (!types.isSameType(tParamNoCapture, inferenceContext().asUndetVar(sParam))) {
1256                         return false;
1257                     }
1258                     tParams = tParams.tail;
1259                     tParamsNoCapture = tParamsNoCapture.tail;
1260                     sParams = sParams.tail;
1261                 }
1262                 if (!tParams.isEmpty() || !tParamsNoCapture.isEmpty() || !sParams.isEmpty()) {
1263                     return false;
1264                 }
1265 
1266                 // compare returns
1267                 Type tRet = tDesc.getReturnType();
1268                 Type sRet = types.subst(sDesc.getReturnType(), sTypeParams, tTypeParams);
1269                 if (tRet.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sRet)) {
1270                     return false;
1271                 }
1272                 MostSpecificFunctionReturnChecker msc = new MostSpecificFunctionReturnChecker(tRet, sRet);
1273                 msc.scan(tree);
1274                 return msc.result;
1275             }
1276 
1277             /**
1278              * Tests whether one functional interface type can be considered more specific
1279              * than another unrelated functional interface type for the scanned expression.
1280              */
1281             class MostSpecificFunctionReturnChecker extends DeferredAttr.PolyScanner {
1282 
1283                 final Type tRet;
1284                 final Type sRet;
1285                 boolean result;
1286 
1287                 /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1288                 MostSpecificFunctionReturnChecker(Type tRet, Type sRet) {
1289                     this.tRet = tRet;
1290                     this.sRet = sRet;
1291                     result = true;
1292                 }
1293 
1294                 @Override
1295                 void skip(JCTree tree) {
1296                     result &amp;= false;
1297                 }
1298 
1299                 @Override
1300                 public void visitConditional(JCConditional tree) {
1301                     scan(asExpr(tree.truepart));
1302                     scan(asExpr(tree.falsepart));
1303                 }
1304 
1305                 @Override
1306                 public void visitReference(JCMemberReference tree) {
1307                     if (sRet.hasTag(VOID)) {
1308                         result &amp;= true;
1309                     } else if (tRet.hasTag(VOID)) {
1310                         result &amp;= false;
1311                     } else if (tRet.isPrimitive() != sRet.isPrimitive()) {
1312                         boolean retValIsPrimitive =
1313                                 tree.refPolyKind == PolyKind.STANDALONE &amp;&amp;
1314                                 tree.sym.type.getReturnType().isPrimitive();
1315                         result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1316                                   (retValIsPrimitive != sRet.isPrimitive());
1317                     } else {
1318                         result &amp;= compatibleBySubtyping(tRet, sRet);
1319                     }
1320                 }
1321 
1322                 @Override
1323                 public void visitParens(JCParens tree) {
1324                     scan(asExpr(tree.expr));
1325                 }
1326 
1327                 @Override
1328                 public void visitLambda(JCLambda tree) {
1329                     if (sRet.hasTag(VOID)) {
1330                         result &amp;= true;
1331                     } else if (tRet.hasTag(VOID)) {
1332                         result &amp;= false;
1333                     } else {
1334                         List&lt;JCExpression&gt; lambdaResults = lambdaResults(tree);
1335                         if (!lambdaResults.isEmpty() &amp;&amp; unrelatedFunctionalInterfaces(tRet, sRet)) {
1336                             for (JCExpression expr : lambdaResults) {
1337                                 result &amp;= functionalInterfaceMostSpecific(tRet, sRet, expr);
1338                             }
1339                         } else if (!lambdaResults.isEmpty() &amp;&amp; tRet.isPrimitive() != sRet.isPrimitive()) {
1340                             for (JCExpression expr : lambdaResults) {
1341                                 boolean retValIsPrimitive = expr.isStandalone() &amp;&amp; expr.type.isPrimitive();
1342                                 result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1343                                         (retValIsPrimitive != sRet.isPrimitive());
1344                             }
1345                         } else {
1346                             result &amp;= compatibleBySubtyping(tRet, sRet);
1347                         }
1348                     }
1349                 }
1350                 //where
1351 
1352                 private List&lt;JCExpression&gt; lambdaResults(JCLambda lambda) {
1353                     if (lambda.getBodyKind() == JCTree.JCLambda.BodyKind.EXPRESSION) {
1354                         return List.of(asExpr((JCExpression) lambda.body));
1355                     } else {
1356                         final ListBuffer&lt;JCExpression&gt; buffer = new ListBuffer&lt;&gt;();
1357                         DeferredAttr.LambdaReturnScanner lambdaScanner =
1358                                 new DeferredAttr.LambdaReturnScanner() {
1359                                     @Override
1360                                     public void visitReturn(JCReturn tree) {
1361                                         if (tree.expr != null) {
1362                                             buffer.append(asExpr(tree.expr));
1363                                         }
1364                                     }
1365                                 };
1366                         lambdaScanner.scan(lambda.body);
1367                         return buffer.toList();
1368                     }
1369                 }
1370 
1371                 private JCExpression asExpr(JCExpression expr) {
1372                     if (expr.type.hasTag(DEFERRED)) {
1373                         JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);
1374                         if (speculativeTree != deferredAttr.stuckTree) {
1375                             expr = (JCExpression)speculativeTree;
1376                         }
1377                     }
1378                     return expr;
1379                 }
1380             }
1381 
1382         }
1383 
1384         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1385             Assert.error(&quot;Cannot get here!&quot;);
1386             return null;
1387         }
1388     }
1389 
1390     public static class InapplicableMethodException extends RuntimeException {
1391         private static final long serialVersionUID = 0;
1392 
1393         transient JCDiagnostic diagnostic;
1394 
1395         InapplicableMethodException(JCDiagnostic diag) {
1396             this.diagnostic = diag;
1397         }
1398 
1399         public JCDiagnostic getDiagnostic() {
1400             return diagnostic;
1401         }
1402     }
1403 
1404 /* ***************************************************************************
1405  *  Symbol lookup
1406  *  the following naming conventions for arguments are used
1407  *
1408  *       env      is the environment where the symbol was mentioned
1409  *       site     is the type of which the symbol is a member
1410  *       name     is the symbol&#39;s name
1411  *                if no arguments are given
1412  *       argtypes are the value arguments, if we search for a method
1413  *
1414  *  If no symbol was found, a ResolveError detailing the problem is returned.
1415  ****************************************************************************/
1416 
1417     /** Find field. Synthetic fields are always skipped.
1418      *  @param env     The current environment.
1419      *  @param site    The original type from where the selection takes place.
1420      *  @param name    The name of the field.
1421      *  @param c       The class to search for the field. This is always
1422      *                 a superclass or implemented interface of site&#39;s class.
1423      */
1424     Symbol findField(Env&lt;AttrContext&gt; env,
1425                      Type site,
1426                      Name name,
1427                      TypeSymbol c) {
1428         while (c.type.hasTag(TYPEVAR))
1429             c = c.type.getUpperBound().tsym;
1430         Symbol bestSoFar = varNotFound;
1431         Symbol sym;
1432         for (Symbol s : c.members().getSymbolsByName(name)) {
1433             if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1434                 return isAccessible(env, site, s)
1435                     ? s : new AccessError(env, site, s);
1436             }
1437         }
1438         Type st = types.supertype(c.type);
1439         if (st != null &amp;&amp; (st.hasTag(CLASS) || st.hasTag(TYPEVAR))) {
1440             sym = findField(env, site, name, st.tsym);
1441             bestSoFar = bestOf(bestSoFar, sym);
1442         }
1443         for (List&lt;Type&gt; l = types.interfaces(c.type);
1444              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
1445              l = l.tail) {
1446             sym = findField(env, site, name, l.head.tsym);
1447             if (bestSoFar.exists() &amp;&amp; sym.exists() &amp;&amp;
1448                 sym.owner != bestSoFar.owner)
1449                 bestSoFar = new AmbiguityError(bestSoFar, sym);
1450             else
1451                 bestSoFar = bestOf(bestSoFar, sym);
1452         }
1453         return bestSoFar;
1454     }
1455 
1456     /** Resolve a field identifier, throw a fatal error if not found.
1457      *  @param pos       The position to use for error reporting.
1458      *  @param env       The environment current at the method invocation.
1459      *  @param site      The type of the qualifying expression, in which
1460      *                   identifier is searched.
1461      *  @param name      The identifier&#39;s name.
1462      */
1463     public VarSymbol resolveInternalField(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
1464                                           Type site, Name name) {
1465         Symbol sym = findField(env, site, name, site.tsym);
1466         if (sym.kind == VAR) return (VarSymbol)sym;
1467         else throw new FatalError(
1468                  diags.fragment(Fragments.FatalErrCantLocateField(name)));
1469     }
1470 
1471     /** Find unqualified variable or field with given name.
1472      *  Synthetic fields always skipped.
1473      *  @param env     The current environment.
1474      *  @param name    The name of the variable or field.
1475      */
1476     Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {
1477         Symbol bestSoFar = varNotFound;
1478         Env&lt;AttrContext&gt; env1 = env;
1479         boolean staticOnly = false;
1480         while (env1.outer != null) {
1481             Symbol sym = null;
1482             if (isStatic(env1)) staticOnly = true;
1483             for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
1484                 if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1485                     sym = s;
1486                     break;
1487                 }
1488             }
1489             if (sym == null) {
1490                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
1491             }
1492             if (sym.exists()) {
1493                 if (staticOnly &amp;&amp;
1494                    (sym.flags() &amp; STATIC) == 0 &amp;&amp;
1495                     sym.kind == VAR &amp;&amp;
1496                         // if it is a field
1497                         (sym.owner.kind == TYP ||
1498                         // or it is a local variable but it is not declared inside of the static local type
1499                         // then error
1500                         allowRecords &amp;&amp;
1501                         (sym.owner.kind == MTH) &amp;&amp;
1502                         env1 != env &amp;&amp;
1503                         !isInnerClassOfMethod(sym.owner, env.tree.hasTag(CLASSDEF) ?
1504                                 ((JCClassDecl)env.tree).sym :
1505                                 env.enclClass.sym)))
1506                     return new StaticError(sym);
1507                 else
1508                     return sym;
1509             } else {
1510                 bestSoFar = bestOf(bestSoFar, sym);
1511             }
1512 
1513             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1514             env1 = env1.outer;
1515         }
1516 
1517         Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);
1518         if (sym.exists())
1519             return sym;
1520         if (bestSoFar.exists())
1521             return bestSoFar;
1522 
1523         Symbol origin = null;
1524         for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {
1525             for (Symbol currentSymbol : sc.getSymbolsByName(name)) {
1526                 if (currentSymbol.kind != VAR)
1527                     continue;
1528                 // invariant: sym.kind == Symbol.Kind.VAR
1529                 if (!bestSoFar.kind.isResolutionError() &amp;&amp;
1530                     currentSymbol.owner != bestSoFar.owner)
1531                     return new AmbiguityError(bestSoFar, currentSymbol);
1532                 else if (!bestSoFar.kind.betterThan(VAR)) {
1533                     origin = sc.getOrigin(currentSymbol).owner;
1534                     bestSoFar = isAccessible(env, origin.type, currentSymbol)
1535                         ? currentSymbol : new AccessError(env, origin.type, currentSymbol);
1536                 }
1537             }
1538             if (bestSoFar.exists()) break;
1539         }
1540         if (bestSoFar.kind == VAR &amp;&amp; bestSoFar.owner.type != origin.type)
1541             return bestSoFar.clone(origin);
1542         else
1543             return bestSoFar;
1544     }
1545 
1546     Warner noteWarner = new Warner();
1547 
1548     /** Select the best method for a call site among two choices.
1549      *  @param env              The current environment.
1550      *  @param site             The original type from where the
1551      *                          selection takes place.
1552      *  @param argtypes         The invocation&#39;s value arguments,
1553      *  @param typeargtypes     The invocation&#39;s type arguments,
1554      *  @param sym              Proposed new best match.
1555      *  @param bestSoFar        Previously found best match.
1556      *  @param allowBoxing Allow boxing conversions of arguments.
1557      *  @param useVarargs Box trailing arguments into an array for varargs.
1558      */
1559     @SuppressWarnings(&quot;fallthrough&quot;)
1560     Symbol selectBest(Env&lt;AttrContext&gt; env,
1561                       Type site,
1562                       List&lt;Type&gt; argtypes,
1563                       List&lt;Type&gt; typeargtypes,
1564                       Symbol sym,
1565                       Symbol bestSoFar,
1566                       boolean allowBoxing,
1567                       boolean useVarargs) {
1568         if (sym.kind == ERR ||
1569                 (site.tsym != sym.owner &amp;&amp; !sym.isInheritedIn(site.tsym, types)) ||
1570                 !notOverriddenIn(site, sym)) {
1571             return bestSoFar;
1572         } else if (useVarargs &amp;&amp; (sym.flags() &amp; VARARGS) == 0) {
1573             return bestSoFar.kind.isResolutionError() ?
1574                     new BadVarargsMethod((ResolveError)bestSoFar.baseSymbol()) :
1575                     bestSoFar;
1576         }
1577         Assert.check(!sym.kind.isResolutionError());
1578         try {
1579             types.noWarnings.clear();
1580             Type mt = rawInstantiate(env, site, sym, null, argtypes, typeargtypes,
1581                                allowBoxing, useVarargs, types.noWarnings);
1582             currentResolutionContext.addApplicableCandidate(sym, mt);
1583         } catch (InapplicableMethodException ex) {
1584             currentResolutionContext.addInapplicableCandidate(sym, ex.getDiagnostic());
1585             switch (bestSoFar.kind) {
1586                 case ABSENT_MTH:
1587                     return new InapplicableSymbolError(currentResolutionContext);
1588                 case WRONG_MTH:
1589                     bestSoFar = new InapplicableSymbolsError(currentResolutionContext);
1590                 default:
1591                     return bestSoFar;
1592             }
1593         }
1594         if (!isAccessible(env, site, sym)) {
1595             return (bestSoFar.kind == ABSENT_MTH)
1596                 ? new AccessError(env, site, sym)
1597                 : bestSoFar;
1598         }
1599         return (bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS)
1600             ? sym
1601             : mostSpecific(argtypes, sym, bestSoFar, env, site, useVarargs);
1602     }
1603 
1604     /* Return the most specific of the two methods for a call,
1605      *  given that both are accessible and applicable.
1606      *  @param m1               A new candidate for most specific.
1607      *  @param m2               The previous most specific candidate.
1608      *  @param env              The current environment.
1609      *  @param site             The original type from where the selection
1610      *                          takes place.
1611      *  @param allowBoxing Allow boxing conversions of arguments.
1612      *  @param useVarargs Box trailing arguments into an array for varargs.
1613      */
1614     Symbol mostSpecific(List&lt;Type&gt; argtypes, Symbol m1,
1615                         Symbol m2,
1616                         Env&lt;AttrContext&gt; env,
1617                         final Type site,
1618                         boolean useVarargs) {
1619         switch (m2.kind) {
1620         case MTH:
1621             if (m1 == m2) return m1;
1622             boolean m1SignatureMoreSpecific =
1623                     signatureMoreSpecific(argtypes, env, site, m1, m2, useVarargs);
1624             boolean m2SignatureMoreSpecific =
1625                     signatureMoreSpecific(argtypes, env, site, m2, m1, useVarargs);
1626             if (m1SignatureMoreSpecific &amp;&amp; m2SignatureMoreSpecific) {
1627                 Type mt1 = types.memberType(site, m1);
1628                 Type mt2 = types.memberType(site, m2);
1629                 if (!types.overrideEquivalent(mt1, mt2))
1630                     return ambiguityError(m1, m2);
1631 
1632                 // same signature; select (a) the non-bridge method, or
1633                 // (b) the one that overrides the other, or (c) the concrete
1634                 // one, or (d) merge both abstract signatures
1635                 if ((m1.flags() &amp; BRIDGE) != (m2.flags() &amp; BRIDGE))
1636                     return ((m1.flags() &amp; BRIDGE) != 0) ? m2 : m1;
1637 
1638                 if (m1.baseSymbol() == m2.baseSymbol()) {
1639                     // this is the same imported symbol which has been cloned twice.
1640                     // Return the first one (either will do).
1641                     return m1;
1642                 }
1643 
1644                 // if one overrides or hides the other, use it
1645                 TypeSymbol m1Owner = (TypeSymbol)m1.owner;
1646                 TypeSymbol m2Owner = (TypeSymbol)m2.owner;
1647                 // the two owners can never be the same if the target methods are compiled from source,
1648                 // but we need to protect against cases where the methods are defined in some classfile
1649                 // and make sure we issue an ambiguity error accordingly (by skipping the logic below).
1650                 if (m1Owner != m2Owner) {
1651                     if (types.asSuper(m1Owner.type, m2Owner) != null &amp;&amp;
1652                         ((m1.owner.flags_field &amp; INTERFACE) == 0 ||
1653                          (m2.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1654                         m1.overrides(m2, m1Owner, types, false))
1655                         return m1;
1656                     if (types.asSuper(m2Owner.type, m1Owner) != null &amp;&amp;
1657                         ((m2.owner.flags_field &amp; INTERFACE) == 0 ||
1658                          (m1.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1659                         m2.overrides(m1, m2Owner, types, false))
1660                         return m2;
1661                 }
1662                 boolean m1Abstract = (m1.flags() &amp; ABSTRACT) != 0;
1663                 boolean m2Abstract = (m2.flags() &amp; ABSTRACT) != 0;
1664                 if (m1Abstract &amp;&amp; !m2Abstract) return m2;
1665                 if (m2Abstract &amp;&amp; !m1Abstract) return m1;
1666                 // both abstract or both concrete
1667                 return ambiguityError(m1, m2);
1668             }
1669             if (m1SignatureMoreSpecific) return m1;
1670             if (m2SignatureMoreSpecific) return m2;
1671             return ambiguityError(m1, m2);
1672         case AMBIGUOUS:
1673             //compare m1 to ambiguous methods in m2
1674             AmbiguityError e = (AmbiguityError)m2.baseSymbol();
1675             boolean m1MoreSpecificThanAnyAmbiguous = true;
1676             boolean allAmbiguousMoreSpecificThanM1 = true;
1677             for (Symbol s : e.ambiguousSyms) {
1678                 Symbol moreSpecific = mostSpecific(argtypes, m1, s, env, site, useVarargs);
1679                 m1MoreSpecificThanAnyAmbiguous &amp;= moreSpecific == m1;
1680                 allAmbiguousMoreSpecificThanM1 &amp;= moreSpecific == s;
1681             }
1682             if (m1MoreSpecificThanAnyAmbiguous)
1683                 return m1;
1684             //if m1 is more specific than some ambiguous methods, but other ambiguous methods are
1685             //more specific than m1, add it as a new ambiguous method:
1686             if (!allAmbiguousMoreSpecificThanM1)
1687                 e.addAmbiguousSymbol(m1);
1688             return e;
1689         default:
1690             throw new AssertionError();
1691         }
1692     }
1693     //where
1694     private boolean signatureMoreSpecific(List&lt;Type&gt; actuals, Env&lt;AttrContext&gt; env, Type site, Symbol m1, Symbol m2, boolean useVarargs) {
1695         noteWarner.clear();
1696         int maxLength = Math.max(
1697                             Math.max(m1.type.getParameterTypes().length(), actuals.length()),
1698                             m2.type.getParameterTypes().length());
1699         MethodResolutionContext prevResolutionContext = currentResolutionContext;
1700         try {
1701             currentResolutionContext = new MethodResolutionContext();
1702             currentResolutionContext.step = prevResolutionContext.step;
1703             currentResolutionContext.methodCheck =
1704                     prevResolutionContext.methodCheck.mostSpecificCheck(actuals);
1705             Type mst = instantiate(env, site, m2, null,
1706                     adjustArgs(types.cvarLowerBounds(types.memberType(site, m1).getParameterTypes()), m1, maxLength, useVarargs), null,
1707                     false, useVarargs, noteWarner);
1708             return mst != null &amp;&amp;
1709                     !noteWarner.hasLint(Lint.LintCategory.UNCHECKED);
1710         } finally {
1711             currentResolutionContext = prevResolutionContext;
1712         }
1713     }
1714 
1715     List&lt;Type&gt; adjustArgs(List&lt;Type&gt; args, Symbol msym, int length, boolean allowVarargs) {
1716         if ((msym.flags() &amp; VARARGS) != 0 &amp;&amp; allowVarargs) {
1717             Type varargsElem = types.elemtype(args.last());
1718             if (varargsElem == null) {
1719                 Assert.error(&quot;Bad varargs = &quot; + args.last() + &quot; &quot; + msym);
1720             }
1721             List&lt;Type&gt; newArgs = args.reverse().tail.prepend(varargsElem).reverse();
1722             while (newArgs.length() &lt; length) {
1723                 newArgs = newArgs.append(newArgs.last());
1724             }
1725             return newArgs;
1726         } else {
1727             return args;
1728         }
1729     }
1730     //where
1731     Symbol ambiguityError(Symbol m1, Symbol m2) {
1732         if (((m1.flags() | m2.flags()) &amp; CLASH) != 0) {
1733             return (m1.flags() &amp; CLASH) == 0 ? m1 : m2;
1734         } else {
1735             return new AmbiguityError(m1, m2);
1736         }
1737     }
1738 
1739     Symbol findMethodInScope(Env&lt;AttrContext&gt; env,
1740             Type site,
1741             Name name,
1742             List&lt;Type&gt; argtypes,
1743             List&lt;Type&gt; typeargtypes,
1744             Scope sc,
1745             Symbol bestSoFar,
1746             boolean allowBoxing,
1747             boolean useVarargs,
1748             boolean abstractok) {
1749         for (Symbol s : sc.getSymbolsByName(name, new LookupFilter(abstractok))) {
1750             bestSoFar = selectBest(env, site, argtypes, typeargtypes, s,
1751                     bestSoFar, allowBoxing, useVarargs);
1752         }
1753         return bestSoFar;
1754     }
1755     //where
1756         class LookupFilter implements Filter&lt;Symbol&gt; {
1757 
1758             boolean abstractOk;
1759 
1760             LookupFilter(boolean abstractOk) {
1761                 this.abstractOk = abstractOk;
1762             }
1763 
1764             public boolean accepts(Symbol s) {
1765                 long flags = s.flags();
1766                 return s.kind == MTH &amp;&amp;
1767                         (flags &amp; SYNTHETIC) == 0 &amp;&amp;
1768                         (abstractOk ||
1769                         (flags &amp; DEFAULT) != 0 ||
1770                         (flags &amp; ABSTRACT) == 0);
1771             }
1772         }
1773 
1774     /** Find best qualified method matching given name, type and value
1775      *  arguments.
1776      *  @param env       The current environment.
1777      *  @param site      The original type from where the selection
1778      *                   takes place.
1779      *  @param name      The method&#39;s name.
1780      *  @param argtypes  The method&#39;s value arguments.
1781      *  @param typeargtypes The method&#39;s type arguments
1782      *  @param allowBoxing Allow boxing conversions of arguments.
1783      *  @param useVarargs Box trailing arguments into an array for varargs.
1784      */
1785     Symbol findMethod(Env&lt;AttrContext&gt; env,
1786                       Type site,
1787                       Name name,
1788                       List&lt;Type&gt; argtypes,
1789                       List&lt;Type&gt; typeargtypes,
1790                       boolean allowBoxing,
1791                       boolean useVarargs) {
1792         Symbol bestSoFar = methodNotFound;
1793         bestSoFar = findMethod(env,
1794                           site,
1795                           name,
1796                           argtypes,
1797                           typeargtypes,
1798                           site.tsym.type,
1799                           bestSoFar,
1800                           allowBoxing,
1801                           useVarargs);
1802         return bestSoFar;
1803     }
1804     // where
1805     private Symbol findMethod(Env&lt;AttrContext&gt; env,
1806                               Type site,
1807                               Name name,
1808                               List&lt;Type&gt; argtypes,
1809                               List&lt;Type&gt; typeargtypes,
1810                               Type intype,
1811                               Symbol bestSoFar,
1812                               boolean allowBoxing,
1813                               boolean useVarargs) {
1814         @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})
1815         List&lt;Type&gt;[] itypes = (List&lt;Type&gt;[])new List[] { List.&lt;Type&gt;nil(), List.&lt;Type&gt;nil() };
1816 
1817         InterfaceLookupPhase iphase = InterfaceLookupPhase.ABSTRACT_OK;
1818         for (TypeSymbol s : superclasses(intype)) {
1819             bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1820                     s.members(), bestSoFar, allowBoxing, useVarargs, true);
1821             if (name == names.init) return bestSoFar;
1822             iphase = (iphase == null) ? null : iphase.update(s, this);
1823             if (iphase != null) {
1824                 for (Type itype : types.interfaces(s.type)) {
1825                     itypes[iphase.ordinal()] = types.union(types.closure(itype), itypes[iphase.ordinal()]);
1826                 }
1827             }
1828         }
1829 
1830         Symbol concrete = bestSoFar.kind.isValid() &amp;&amp;
1831                 (bestSoFar.flags() &amp; ABSTRACT) == 0 ?
1832                 bestSoFar : methodNotFound;
1833 
1834         for (InterfaceLookupPhase iphase2 : InterfaceLookupPhase.values()) {
1835             //keep searching for abstract methods
1836             for (Type itype : itypes[iphase2.ordinal()]) {
1837                 if (!itype.isInterface()) continue; //skip j.l.Object (included by Types.closure())
1838                 if (iphase2 == InterfaceLookupPhase.DEFAULT_OK &amp;&amp;
1839                         (itype.tsym.flags() &amp; DEFAULT) == 0) continue;
1840                 bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1841                         itype.tsym.members(), bestSoFar, allowBoxing, useVarargs, true);
1842                 if (concrete != bestSoFar &amp;&amp;
1843                     concrete.kind.isValid() &amp;&amp;
1844                     bestSoFar.kind.isValid() &amp;&amp;
1845                         types.isSubSignature(concrete.type, bestSoFar.type)) {
1846                     //this is an hack - as javac does not do full membership checks
1847                     //most specific ends up comparing abstract methods that might have
1848                     //been implemented by some concrete method in a subclass and,
1849                     //because of raw override, it is possible for an abstract method
1850                     //to be more specific than the concrete method - so we need
1851                     //to explicitly call that out (see CR 6178365)
1852                     bestSoFar = concrete;
1853                 }
1854             }
1855         }
1856         return bestSoFar;
1857     }
1858 
1859     enum InterfaceLookupPhase {
1860         ABSTRACT_OK() {
1861             @Override
1862             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1863                 //We should not look for abstract methods if receiver is a concrete class
1864                 //(as concrete classes are expected to implement all abstracts coming
1865                 //from superinterfaces)
1866                 if ((s.flags() &amp; (ABSTRACT | INTERFACE | ENUM)) != 0) {
1867                     return this;
1868                 } else {
1869                     return DEFAULT_OK;
1870                 }
1871             }
1872         },
1873         DEFAULT_OK() {
1874             @Override
1875             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1876                 return this;
1877             }
1878         };
1879 
1880         abstract InterfaceLookupPhase update(Symbol s, Resolve rs);
1881     }
1882 
1883     /**
1884      * Return an Iterable object to scan the superclasses of a given type.
1885      * It&#39;s crucial that the scan is done lazily, as we don&#39;t want to accidentally
1886      * access more supertypes than strictly needed (as this could trigger completion
1887      * errors if some of the not-needed supertypes are missing/ill-formed).
1888      */
1889     Iterable&lt;TypeSymbol&gt; superclasses(final Type intype) {
1890         return () -&gt; new Iterator&lt;TypeSymbol&gt;() {
1891 
1892             List&lt;TypeSymbol&gt; seen = List.nil();
1893             TypeSymbol currentSym = symbolFor(intype);
1894             TypeSymbol prevSym = null;
1895 
1896             public boolean hasNext() {
1897                 if (currentSym == syms.noSymbol) {
1898                     currentSym = symbolFor(types.supertype(prevSym.type));
1899                 }
1900                 return currentSym != null;
1901             }
1902 
1903             public TypeSymbol next() {
1904                 prevSym = currentSym;
1905                 currentSym = syms.noSymbol;
1906                 Assert.check(prevSym != null || prevSym != syms.noSymbol);
1907                 return prevSym;
1908             }
1909 
1910             public void remove() {
1911                 throw new UnsupportedOperationException();
1912             }
1913 
1914             TypeSymbol symbolFor(Type t) {
1915                 if (!t.hasTag(CLASS) &amp;&amp;
1916                         !t.hasTag(TYPEVAR)) {
1917                     return null;
1918                 }
1919                 t = types.skipTypeVars(t, false);
1920                 if (seen.contains(t.tsym)) {
1921                     //degenerate case in which we have a circular
1922                     //class hierarchy - because of ill-formed classfiles
1923                     return null;
1924                 }
1925                 seen = seen.prepend(t.tsym);
1926                 return t.tsym;
1927             }
1928         };
1929     }
1930 
1931     /** Find unqualified method matching given name, type and value arguments.
1932      *  @param env       The current environment.
1933      *  @param name      The method&#39;s name.
1934      *  @param argtypes  The method&#39;s value arguments.
1935      *  @param typeargtypes  The method&#39;s type arguments.
1936      *  @param allowBoxing Allow boxing conversions of arguments.
1937      *  @param useVarargs Box trailing arguments into an array for varargs.
1938      */
1939     Symbol findFun(Env&lt;AttrContext&gt; env, Name name,
1940                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
1941                    boolean allowBoxing, boolean useVarargs) {
1942         Symbol bestSoFar = methodNotFound;
1943         Env&lt;AttrContext&gt; env1 = env;
1944         boolean staticOnly = false;
1945         while (env1.outer != null) {
1946             if (isStatic(env1)) staticOnly = true;
1947             Assert.check(env1.info.preferredTreeForDiagnostics == null);
1948             env1.info.preferredTreeForDiagnostics = env.tree;
1949             try {
1950                 Symbol sym = findMethod(
1951                     env1, env1.enclClass.sym.type, name, argtypes, typeargtypes,
1952                     allowBoxing, useVarargs);
1953                 if (sym.exists()) {
1954                     if (staticOnly &amp;&amp;
1955                         sym.kind == MTH &amp;&amp;
1956                         sym.owner.kind == TYP &amp;&amp;
1957                         (sym.flags() &amp; STATIC) == 0) return new StaticError(sym);
1958                     else return sym;
1959                 } else {
1960                     bestSoFar = bestOf(bestSoFar, sym);
1961                 }
1962             } finally {
1963                 env1.info.preferredTreeForDiagnostics = null;
1964             }
1965             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1966             env1 = env1.outer;
1967         }
1968 
1969         Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
1970                                 typeargtypes, allowBoxing, useVarargs);
1971         if (sym.exists())
1972             return sym;
1973 
1974         for (Symbol currentSym : env.toplevel.namedImportScope.getSymbolsByName(name)) {
1975             Symbol origin = env.toplevel.namedImportScope.getOrigin(currentSym).owner;
1976             if (currentSym.kind == MTH) {
1977                 if (currentSym.owner.type != origin.type)
1978                     currentSym = currentSym.clone(origin);
1979                 if (!isAccessible(env, origin.type, currentSym))
1980                     currentSym = new AccessError(env, origin.type, currentSym);
1981                 bestSoFar = selectBest(env, origin.type,
1982                                        argtypes, typeargtypes,
1983                                        currentSym, bestSoFar,
1984                                        allowBoxing, useVarargs);
1985             }
1986         }
1987         if (bestSoFar.exists())
1988             return bestSoFar;
1989 
1990         for (Symbol currentSym : env.toplevel.starImportScope.getSymbolsByName(name)) {
1991             Symbol origin = env.toplevel.starImportScope.getOrigin(currentSym).owner;
1992             if (currentSym.kind == MTH) {
1993                 if (currentSym.owner.type != origin.type)
1994                     currentSym = currentSym.clone(origin);
1995                 if (!isAccessible(env, origin.type, currentSym))
1996                     currentSym = new AccessError(env, origin.type, currentSym);
1997                 bestSoFar = selectBest(env, origin.type,
1998                                        argtypes, typeargtypes,
1999                                        currentSym, bestSoFar,
2000                                        allowBoxing, useVarargs);
2001             }
2002         }
2003         return bestSoFar;
2004     }
2005 
2006     /** Load toplevel or member class with given fully qualified name and
2007      *  verify that it is accessible.
2008      *  @param env       The current environment.
2009      *  @param name      The fully qualified name of the class to be loaded.
2010      */
2011     Symbol loadClass(Env&lt;AttrContext&gt; env, Name name, RecoveryLoadClass recoveryLoadClass) {
2012         try {
2013             ClassSymbol c = finder.loadClass(env.toplevel.modle, name);
2014             return isAccessible(env, c) ? c : new AccessError(env, null, c);
2015         } catch (ClassFinder.BadClassFile err) {
2016             return new BadClassFileError(err);
2017         } catch (CompletionFailure ex) {
2018             Symbol candidate = recoveryLoadClass.loadClass(env, name);
2019 
2020             if (candidate != null) {
2021                 return candidate;
2022             }
2023 
2024             return typeNotFound;
2025         }
2026     }
2027 
2028     public interface RecoveryLoadClass {
2029         Symbol loadClass(Env&lt;AttrContext&gt; env, Name name);
2030     }
2031 
2032     private final RecoveryLoadClass noRecovery = (env, name) -&gt; null;
2033 
2034     private final RecoveryLoadClass doRecoveryLoadClass = new RecoveryLoadClass() {
2035         @Override public Symbol loadClass(Env&lt;AttrContext&gt; env, Name name) {
2036             List&lt;Name&gt; candidates = Convert.classCandidates(name);
2037             return lookupInvisibleSymbol(env, name,
2038                                          n -&gt; () -&gt; createCompoundIterator(candidates,
2039                                                                            c -&gt; syms.getClassesForName(c)
2040                                                                                     .iterator()),
2041                                          (ms, n) -&gt; {
2042                 for (Name candidate : candidates) {
2043                     try {
2044                         return finder.loadClass(ms, candidate);
2045                     } catch (CompletionFailure cf) {
2046                         //ignore
2047                     }
2048                 }
2049                 return null;
2050             }, sym -&gt; sym.kind == Kind.TYP, typeNotFound);
2051         }
2052     };
2053 
2054     private final RecoveryLoadClass namedImportScopeRecovery = (env, name) -&gt; {
2055         Scope importScope = env.toplevel.namedImportScope;
2056         Symbol existing = importScope.findFirst(Convert.shortName(name),
2057                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2058 
2059         if (existing != null) {
2060             return new InvisibleSymbolError(env, true, existing);
2061         }
2062         return null;
2063     };
2064 
2065     private final RecoveryLoadClass starImportScopeRecovery = (env, name) -&gt; {
2066         Scope importScope = env.toplevel.starImportScope;
2067         Symbol existing = importScope.findFirst(Convert.shortName(name),
2068                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2069 
2070         if (existing != null) {
2071             try {
2072                 existing = finder.loadClass(existing.packge().modle, name);
2073 
2074                 return new InvisibleSymbolError(env, true, existing);
2075             } catch (CompletionFailure cf) {
2076                 //ignore
2077             }
2078         }
2079 
2080         return null;
2081     };
2082 
2083     Symbol lookupPackage(Env&lt;AttrContext&gt; env, Name name) {
2084         PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, name);
2085 
2086         if (allowModules &amp;&amp; isImportOnDemand(env, name)) {
2087             if (pack.members().isEmpty()) {
2088                 return lookupInvisibleSymbol(env, name, syms::getPackagesForName, syms::enterPackage, sym -&gt; {
2089                     sym.complete();
2090                     return !sym.members().isEmpty();
2091                 }, pack);
2092             }
2093         }
2094 
2095         return pack;
2096     }
2097 
2098     private boolean isImportOnDemand(Env&lt;AttrContext&gt; env, Name name) {
2099         if (!env.tree.hasTag(IMPORT))
2100             return false;
2101 
2102         JCTree qualid = ((JCImport) env.tree).qualid;
2103 
2104         if (!qualid.hasTag(SELECT))
2105             return false;
2106 
2107         if (TreeInfo.name(qualid) != names.asterisk)
2108             return false;
2109 
2110         return TreeInfo.fullName(((JCFieldAccess) qualid).selected) == name;
2111     }
2112 
2113     private &lt;S extends Symbol&gt; Symbol lookupInvisibleSymbol(Env&lt;AttrContext&gt; env,
2114                                                             Name name,
2115                                                             Function&lt;Name, Iterable&lt;S&gt;&gt; get,
2116                                                             BiFunction&lt;ModuleSymbol, Name, S&gt; load,
2117                                                             Predicate&lt;S&gt; validate,
2118                                                             Symbol defaultResult) {
2119         //even if a class/package cannot be found in the current module and among packages in modules
2120         //it depends on that are exported for any or this module, the class/package may exist internally
2121         //in some of these modules, or may exist in a module on which this module does not depend.
2122         //Provide better diagnostic in such cases by looking for the class in any module:
2123         Iterable&lt;? extends S&gt; candidates = get.apply(name);
2124 
2125         for (S sym : candidates) {
2126             if (validate.test(sym))
2127                 return createInvisibleSymbolError(env, sym);
2128         }
2129 
2130         Set&lt;ModuleSymbol&gt; recoverableModules = new HashSet&lt;&gt;(syms.getAllModules());
2131 
2132         recoverableModules.add(syms.unnamedModule);
2133         recoverableModules.remove(env.toplevel.modle);
2134 
2135         for (ModuleSymbol ms : recoverableModules) {
2136             //avoid overly eager completing classes from source-based modules, as those
2137             //may not be completable with the current compiler settings:
2138             if (ms.sourceLocation == null) {
2139                 if (ms.classLocation == null) {
2140                     ms = moduleFinder.findModule(ms);
2141                 }
2142 
2143                 if (ms.kind != ERR) {
2144                     S sym = load.apply(ms, name);
2145 
2146                     if (sym != null &amp;&amp; validate.test(sym)) {
2147                         return createInvisibleSymbolError(env, sym);
2148                     }
2149                 }
2150             }
2151         }
2152 
2153         return defaultResult;
2154     }
2155 
2156     private Symbol createInvisibleSymbolError(Env&lt;AttrContext&gt; env, Symbol sym) {
2157         if (symbolPackageVisible(env, sym)) {
2158             return new AccessError(env, null, sym);
2159         } else {
2160             return new InvisibleSymbolError(env, false, sym);
2161         }
2162     }
2163 
2164     private boolean symbolPackageVisible(Env&lt;AttrContext&gt; env, Symbol sym) {
2165         ModuleSymbol envMod = env.toplevel.modle;
2166         PackageSymbol symPack = sym.packge();
2167         return envMod == symPack.modle ||
2168                envMod.visiblePackages.containsKey(symPack.fullname);
2169     }
2170 
2171     /**
2172      * Find a type declared in a scope (not inherited).  Return null
2173      * if none is found.
2174      *  @param env       The current environment.
2175      *  @param site      The original type from where the selection takes
2176      *                   place.
2177      *  @param name      The type&#39;s name.
2178      *  @param c         The class to search for the member type. This is
2179      *                   always a superclass or implemented interface of
2180      *                   site&#39;s class.
2181      */
2182     Symbol findImmediateMemberType(Env&lt;AttrContext&gt; env,
2183                                    Type site,
2184                                    Name name,
2185                                    TypeSymbol c) {
2186         for (Symbol sym : c.members().getSymbolsByName(name)) {
2187             if (sym.kind == TYP) {
2188                 return isAccessible(env, site, sym)
2189                     ? sym
2190                     : new AccessError(env, site, sym);
2191             }
2192         }
2193         return typeNotFound;
2194     }
2195 
2196     /** Find a member type inherited from a superclass or interface.
2197      *  @param env       The current environment.
2198      *  @param site      The original type from where the selection takes
2199      *                   place.
2200      *  @param name      The type&#39;s name.
2201      *  @param c         The class to search for the member type. This is
2202      *                   always a superclass or implemented interface of
2203      *                   site&#39;s class.
2204      */
2205     Symbol findInheritedMemberType(Env&lt;AttrContext&gt; env,
2206                                    Type site,
2207                                    Name name,
2208                                    TypeSymbol c) {
2209         Symbol bestSoFar = typeNotFound;
2210         Symbol sym;
2211         Type st = types.supertype(c.type);
2212         if (st != null &amp;&amp; st.hasTag(CLASS)) {
2213             sym = findMemberType(env, site, name, st.tsym);
2214             bestSoFar = bestOf(bestSoFar, sym);
2215         }
2216         for (List&lt;Type&gt; l = types.interfaces(c.type);
2217              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
2218              l = l.tail) {
2219             sym = findMemberType(env, site, name, l.head.tsym);
2220             if (!bestSoFar.kind.isResolutionError() &amp;&amp;
2221                 !sym.kind.isResolutionError() &amp;&amp;
2222                 sym.owner != bestSoFar.owner)
2223                 bestSoFar = new AmbiguityError(bestSoFar, sym);
2224             else
2225                 bestSoFar = bestOf(bestSoFar, sym);
2226         }
2227         return bestSoFar;
2228     }
2229 
2230     /** Find qualified member type.
2231      *  @param env       The current environment.
2232      *  @param site      The original type from where the selection takes
2233      *                   place.
2234      *  @param name      The type&#39;s name.
2235      *  @param c         The class to search for the member type. This is
2236      *                   always a superclass or implemented interface of
2237      *                   site&#39;s class.
2238      */
2239     Symbol findMemberType(Env&lt;AttrContext&gt; env,
2240                           Type site,
2241                           Name name,
2242                           TypeSymbol c) {
2243         Symbol sym = findImmediateMemberType(env, site, name, c);
2244 
2245         if (sym != typeNotFound)
2246             return sym;
2247 
2248         return findInheritedMemberType(env, site, name, c);
2249 
2250     }
2251 
2252     /** Find a global type in given scope and load corresponding class.
2253      *  @param env       The current environment.
2254      *  @param scope     The scope in which to look for the type.
2255      *  @param name      The type&#39;s name.
2256      */
2257     Symbol findGlobalType(Env&lt;AttrContext&gt; env, Scope scope, Name name, RecoveryLoadClass recoveryLoadClass) {
2258         Symbol bestSoFar = typeNotFound;
2259         for (Symbol s : scope.getSymbolsByName(name)) {
2260             Symbol sym = loadClass(env, s.flatName(), recoveryLoadClass);
2261             if (bestSoFar.kind == TYP &amp;&amp; sym.kind == TYP &amp;&amp;
2262                 bestSoFar != sym)
2263                 return new AmbiguityError(bestSoFar, sym);
2264             else
2265                 bestSoFar = bestOf(bestSoFar, sym);
2266         }
2267         return bestSoFar;
2268     }
2269 
2270     Symbol findTypeVar(Env&lt;AttrContext&gt; currentEnv, Env&lt;AttrContext&gt; originalEnv, Name name, boolean staticOnly) {
2271         for (Symbol sym : currentEnv.info.scope.getSymbolsByName(name)) {
2272             if (sym.kind == TYP) {
2273                 if (staticOnly &amp;&amp;
2274                     sym.type.hasTag(TYPEVAR) &amp;&amp;
2275                     ((sym.owner.kind == TYP) ||
2276                     // are we trying to access a TypeVar defined in a method from a local static type: interface, enum or record?
2277                     allowRecords &amp;&amp;
2278                     (sym.owner.kind == MTH &amp;&amp;
2279                     currentEnv != originalEnv &amp;&amp;
2280                     !isInnerClassOfMethod(sym.owner, originalEnv.tree.hasTag(CLASSDEF) ?
2281                             ((JCClassDecl)originalEnv.tree).sym :
2282                             originalEnv.enclClass.sym)))) {
2283                     return new StaticError(sym);
2284                 }
2285                 return sym;
2286             }
2287         }
2288         return typeNotFound;
2289     }
2290 
2291     boolean isInnerClassOfMethod(Symbol msym, Symbol csym) {
2292         while (csym.owner != msym) {
2293             if (csym.isStatic()) return false;
2294             csym = csym.owner.enclClass();
2295         }
2296         return (csym.owner == msym &amp;&amp; !csym.isStatic());
2297     }
2298 
2299     /** Find an unqualified type symbol.
2300      *  @param env       The current environment.
2301      *  @param name      The type&#39;s name.
2302      */
2303     Symbol findType(Env&lt;AttrContext&gt; env, Name name) {
2304         if (name == names.empty)
2305             return typeNotFound; // do not allow inadvertent &quot;lookup&quot; of anonymous types
2306         Symbol bestSoFar = typeNotFound;
2307         Symbol sym;
2308         boolean staticOnly = false;
2309         for (Env&lt;AttrContext&gt; env1 = env; env1.outer != null; env1 = env1.outer) {
2310             if (isStatic(env1)) staticOnly = true;
2311             // First, look for a type variable and the first member type
2312             final Symbol tyvar = findTypeVar(env1, env, name, staticOnly);
2313             sym = findImmediateMemberType(env1, env1.enclClass.sym.type,
2314                                           name, env1.enclClass.sym);
2315 
2316             // Return the type variable if we have it, and have no
2317             // immediate member, OR the type variable is for a method.
2318             if (tyvar != typeNotFound) {
2319                 if (env.baseClause || sym == typeNotFound ||
2320                     (tyvar.kind == TYP &amp;&amp; tyvar.exists() &amp;&amp;
2321                      tyvar.owner.kind == MTH)) {
2322                     return tyvar;
2323                 }
2324             }
2325 
2326             // If the environment is a class def, finish up,
2327             // otherwise, do the entire findMemberType
2328             if (sym == typeNotFound)
2329                 sym = findInheritedMemberType(env1, env1.enclClass.sym.type,
2330                                               name, env1.enclClass.sym);
2331 
2332             if (staticOnly &amp;&amp; sym.kind == TYP &amp;&amp;
2333                 sym.type.hasTag(CLASS) &amp;&amp;
2334                 sym.type.getEnclosingType().hasTag(CLASS) &amp;&amp;
2335                 env1.enclClass.sym.type.isParameterized() &amp;&amp;
2336                 sym.type.getEnclosingType().isParameterized())
2337                 return new StaticError(sym);
2338             else if (sym.exists()) return sym;
2339             else bestSoFar = bestOf(bestSoFar, sym);
2340 
2341             JCClassDecl encl = env1.baseClause ? (JCClassDecl)env1.tree : env1.enclClass;
2342             if ((encl.sym.flags() &amp; STATIC) != 0)
2343                 staticOnly = true;
2344         }
2345 
2346         if (!env.tree.hasTag(IMPORT)) {
2347             sym = findGlobalType(env, env.toplevel.namedImportScope, name, namedImportScopeRecovery);
2348             if (sym.exists()) return sym;
2349             else bestSoFar = bestOf(bestSoFar, sym);
2350 
2351             sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
2352             if (sym.exists()) return sym;
2353             else bestSoFar = bestOf(bestSoFar, sym);
2354 
2355             sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
2356             if (sym.exists()) return sym;
2357             else bestSoFar = bestOf(bestSoFar, sym);
2358 
2359             sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
2360             if (sym.exists()) return sym;
2361             else bestSoFar = bestOf(bestSoFar, sym);
2362         }
2363 
2364         return bestSoFar;
2365     }
2366 
2367     /** Find an unqualified identifier which matches a specified kind set.
2368      *  @param pos       position on which report warnings, if any;
2369      *                   null warnings should not be reported
2370      *  @param env       The current environment.
2371      *  @param name      The identifier&#39;s name.
2372      *  @param kind      Indicates the possible symbol kinds
2373      *                   (a subset of VAL, TYP, PCK).
2374      */
2375     Symbol findIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2376         return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);
2377     }
2378 
2379     Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2380         Symbol bestSoFar = typeNotFound;
2381         Symbol sym;
2382 
2383         if (kind.contains(KindSelector.VAL)) {
2384             sym = findVar(env, name);
2385             if (sym.exists()) return sym;
2386             else bestSoFar = bestOf(bestSoFar, sym);
2387         }
2388 
2389         if (kind.contains(KindSelector.TYP)) {
2390             sym = findType(env, name);
2391 
2392             if (sym.exists()) return sym;
2393             else bestSoFar = bestOf(bestSoFar, sym);
2394         }
2395 
2396         if (kind.contains(KindSelector.PCK))
2397             return lookupPackage(env, name);
2398         else return bestSoFar;
2399     }
2400 
2401     /** Find an identifier in a package which matches a specified kind set.
2402      *  @param pos       position on which report warnings, if any;
2403      *                   null warnings should not be reported
2404      *  @param env       The current environment.
2405      *  @param name      The identifier&#39;s name.
2406      *  @param kind      Indicates the possible symbol kinds
2407      *                   (a nonempty subset of TYP, PCK).
2408      */
2409     Symbol findIdentInPackage(DiagnosticPosition pos,
2410                               Env&lt;AttrContext&gt; env, TypeSymbol pck,
2411                               Name name, KindSelector kind) {
2412         return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);
2413     }
2414 
2415     Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
2416                               Name name, KindSelector kind) {
2417         Name fullname = TypeSymbol.formFullName(name, pck);
2418         Symbol bestSoFar = typeNotFound;
2419         if (kind.contains(KindSelector.TYP)) {
2420             RecoveryLoadClass recoveryLoadClass =
2421                     allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
2422                     !pck.exists() &amp;&amp; !env.info.attributionMode.isSpeculative ?
2423                         doRecoveryLoadClass : noRecovery;
2424             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
2425             if (sym.exists()) {
2426                 // don&#39;t allow programs to use flatnames
2427                 if (name == sym.name) return sym;
2428             }
2429             else bestSoFar = bestOf(bestSoFar, sym);
2430         }
2431         if (kind.contains(KindSelector.PCK)) {
2432             return lookupPackage(env, fullname);
2433         }
2434         return bestSoFar;
2435     }
2436 
2437     /** Find an identifier among the members of a given type `site&#39;.
2438      *  @param pos       position on which report warnings, if any;
2439      *                   null warnings should not be reported
2440      *  @param env       The current environment.
2441      *  @param site      The type containing the symbol to be found.
2442      *  @param name      The identifier&#39;s name.
2443      *  @param kind      Indicates the possible symbol kinds
2444      *                   (a subset of VAL, TYP).
2445      */
2446     Symbol findIdentInType(DiagnosticPosition pos,
2447                            Env&lt;AttrContext&gt; env, Type site,
2448                            Name name, KindSelector kind) {
2449         return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);
2450     }
2451 
2452     Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
2453                            Name name, KindSelector kind) {
2454         Symbol bestSoFar = typeNotFound;
2455         Symbol sym;
2456         if (kind.contains(KindSelector.VAL)) {
2457             sym = findField(env, site, name, site.tsym);
2458             if (sym.exists()) return sym;
2459             else bestSoFar = bestOf(bestSoFar, sym);
2460         }
2461 
2462         if (kind.contains(KindSelector.TYP)) {
2463             sym = findMemberType(env, site, name, site.tsym);
2464             if (sym.exists()) return sym;
2465             else bestSoFar = bestOf(bestSoFar, sym);
2466         }
2467         return bestSoFar;
2468     }
2469 
2470     private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {
2471         if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {
2472             if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var)) {
2473                 bestSoFar = new BadRestrictedTypeError(names.var);
2474             } else if (name.equals(names.yield)) {
2475                 if (allowYieldStatement) {
2476                     bestSoFar = new BadRestrictedTypeError(names.yield);
2477                 } else if (pos != null) {
2478                     log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));
2479                 }
2480             }
2481         }
2482         return bestSoFar;
2483     }
2484 
2485 /* ***************************************************************************
2486  *  Access checking
2487  *  The following methods convert ResolveErrors to ErrorSymbols, issuing
2488  *  an error message in the process
2489  ****************************************************************************/
2490 
2491     /** If `sym&#39; is a bad symbol: report error and return errSymbol
2492      *  else pass through unchanged,
2493      *  additional arguments duplicate what has been used in trying to find the
2494      *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we
2495      *  expect misses to happen frequently.
2496      *
2497      *  @param sym       The symbol that was found, or a ResolveError.
2498      *  @param pos       The position to use for error reporting.
2499      *  @param location  The symbol the served as a context for this lookup
2500      *  @param site      The original type from where the selection took place.
2501      *  @param name      The symbol&#39;s name.
2502      *  @param qualified Did we get here through a qualified expression resolution?
2503      *  @param argtypes  The invocation&#39;s value arguments,
2504      *                   if we looked for a method.
2505      *  @param typeargtypes  The invocation&#39;s type arguments,
2506      *                   if we looked for a method.
2507      *  @param logResolveHelper helper class used to log resolve errors
2508      */
2509     Symbol accessInternal(Symbol sym,
2510                   DiagnosticPosition pos,
2511                   Symbol location,
2512                   Type site,
2513                   Name name,
2514                   boolean qualified,
2515                   List&lt;Type&gt; argtypes,
2516                   List&lt;Type&gt; typeargtypes,
2517                   LogResolveHelper logResolveHelper) {
2518         if (sym.kind.isResolutionError()) {
2519             ResolveError errSym = (ResolveError)sym.baseSymbol();
2520             sym = errSym.access(name, qualified ? site.tsym : syms.noSymbol);
2521             argtypes = logResolveHelper.getArgumentTypes(errSym, sym, name, argtypes);
2522             if (logResolveHelper.resolveDiagnosticNeeded(site, argtypes, typeargtypes)) {
2523                 logResolveError(errSym, pos, location, site, name, argtypes, typeargtypes);
2524             }
2525         }
2526         return sym;
2527     }
2528 
2529     /**
2530      * Variant of the generalized access routine, to be used for generating method
2531      * resolution diagnostics
2532      */
2533     Symbol accessMethod(Symbol sym,
2534                   DiagnosticPosition pos,
2535                   Symbol location,
2536                   Type site,
2537                   Name name,
2538                   boolean qualified,
2539                   List&lt;Type&gt; argtypes,
2540                   List&lt;Type&gt; typeargtypes) {
2541         return accessInternal(sym, pos, location, site, name, qualified, argtypes, typeargtypes, methodLogResolveHelper);
2542     }
2543 
2544     /** Same as original accessMethod(), but without location.
2545      */
2546     Symbol accessMethod(Symbol sym,
2547                   DiagnosticPosition pos,
2548                   Type site,
2549                   Name name,
2550                   boolean qualified,
2551                   List&lt;Type&gt; argtypes,
2552                   List&lt;Type&gt; typeargtypes) {
2553         return accessMethod(sym, pos, site.tsym, site, name, qualified, argtypes, typeargtypes);
2554     }
2555 
2556     /**
2557      * Variant of the generalized access routine, to be used for generating variable,
2558      * type resolution diagnostics
2559      */
2560     Symbol accessBase(Symbol sym,
2561                   DiagnosticPosition pos,
2562                   Symbol location,
2563                   Type site,
2564                   Name name,
2565                   boolean qualified) {
2566         return accessInternal(sym, pos, location, site, name, qualified, List.nil(), null, basicLogResolveHelper);
2567     }
2568 
2569     /** Same as original accessBase(), but without location.
2570      */
2571     Symbol accessBase(Symbol sym,
2572                   DiagnosticPosition pos,
2573                   Type site,
2574                   Name name,
2575                   boolean qualified) {
2576         return accessBase(sym, pos, site.tsym, site, name, qualified);
2577     }
2578 
2579     interface LogResolveHelper {
2580         boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes);
2581         List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes);
2582     }
2583 
2584     LogResolveHelper basicLogResolveHelper = new LogResolveHelper() {
2585         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2586             return !site.isErroneous();
2587         }
2588         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2589             return argtypes;
2590         }
2591     };
2592 
2593     LogResolveHelper methodLogResolveHelper = new LogResolveHelper() {
2594         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2595             return !site.isErroneous() &amp;&amp;
2596                         !Type.isErroneous(argtypes) &amp;&amp;
2597                         (typeargtypes == null || !Type.isErroneous(typeargtypes));
2598         }
2599         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2600             return argtypes.map(new ResolveDeferredRecoveryMap(AttrMode.SPECULATIVE, accessedSym, currentResolutionContext.step));
2601         }
2602     };
2603 
2604     class ResolveDeferredRecoveryMap extends DeferredAttr.RecoveryDeferredTypeMap {
2605 
2606         public ResolveDeferredRecoveryMap(AttrMode mode, Symbol msym, MethodResolutionPhase step) {
2607             deferredAttr.super(mode, msym, step);
2608         }
2609 
2610         @Override
2611         protected Type typeOf(DeferredType dt, Type pt) {
2612             Type res = super.typeOf(dt, pt);
2613             if (!res.isErroneous()) {
2614                 switch (TreeInfo.skipParens(dt.tree).getTag()) {
2615                     case LAMBDA:
2616                     case REFERENCE:
2617                         return dt;
2618                     case CONDEXPR:
2619                         return res == Type.recoveryType ?
2620                                 dt : res;
2621                 }
2622             }
2623             return res;
2624         }
2625     }
2626 
2627     /** Check that sym is not an abstract method.
2628      */
2629     void checkNonAbstract(DiagnosticPosition pos, Symbol sym) {
2630         if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
2631             log.error(pos,
2632                       Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
2633     }
2634 
2635 /* ***************************************************************************
2636  *  Name resolution
2637  *  Naming conventions are as for symbol lookup
2638  *  Unlike the find... methods these methods will report access errors
2639  ****************************************************************************/
2640 
2641     /** Resolve an unqualified (non-method) identifier.
2642      *  @param pos       The position to use for error reporting.
2643      *  @param env       The environment current at the identifier use.
2644      *  @param name      The identifier&#39;s name.
2645      *  @param kind      The set of admissible symbol kinds for the identifier.
2646      */
2647     Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2648                         Name name, KindSelector kind) {
2649         return accessBase(
2650             findIdent(pos, env, name, kind),
2651             pos, env.enclClass.sym.type, name, false);
2652     }
2653 
2654     /** Resolve an unqualified method identifier.
2655      *  @param pos       The position to use for error reporting.
2656      *  @param env       The environment current at the method invocation.
2657      *  @param name      The identifier&#39;s name.
2658      *  @param argtypes  The types of the invocation&#39;s value arguments.
2659      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2660      */
2661     Symbol resolveMethod(DiagnosticPosition pos,
2662                          Env&lt;AttrContext&gt; env,
2663                          Name name,
2664                          List&lt;Type&gt; argtypes,
2665                          List&lt;Type&gt; typeargtypes) {
2666         return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
2667                 new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {
2668                     @Override
2669                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2670                         return findFun(env, name, argtypes, typeargtypes,
2671                                 phase.isBoxingRequired(),
2672                                 phase.isVarargsRequired());
2673                     }});
2674     }
2675 
2676     /** Resolve a qualified method identifier
2677      *  @param pos       The position to use for error reporting.
2678      *  @param env       The environment current at the method invocation.
2679      *  @param site      The type of the qualifying expression, in which
2680      *                   identifier is searched.
2681      *  @param name      The identifier&#39;s name.
2682      *  @param argtypes  The types of the invocation&#39;s value arguments.
2683      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2684      */
2685     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2686                                   Type site, Name name, List&lt;Type&gt; argtypes,
2687                                   List&lt;Type&gt; typeargtypes) {
2688         return resolveQualifiedMethod(pos, env, site.tsym, site, name, argtypes, typeargtypes);
2689     }
2690     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2691                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2692                                   List&lt;Type&gt; typeargtypes) {
2693         return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);
2694     }
2695     private Symbol resolveQualifiedMethod(MethodResolutionContext resolveContext,
2696                                   DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2697                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2698                                   List&lt;Type&gt; typeargtypes) {
2699         return lookupMethod(env, pos, location, resolveContext, new BasicLookupHelper(name, site, argtypes, typeargtypes) {
2700             @Override
2701             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2702                 return findMethod(env, site, name, argtypes, typeargtypes,
2703                         phase.isBoxingRequired(),
2704                         phase.isVarargsRequired());
2705             }
2706             @Override
2707             Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2708                 if (sym.kind.isResolutionError()) {
2709                     sym = super.access(env, pos, location, sym);
2710                 } else {
2711                     MethodSymbol msym = (MethodSymbol)sym;
2712                     if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
2713                         env.info.pendingResolutionPhase = BASIC;
2714                         return findPolymorphicSignatureInstance(env, sym, argtypes);
2715                     }
2716                 }
2717                 return sym;
2718             }
2719         });
2720     }
2721 
2722     /** Find or create an implicit method of exactly the given type (after erasure).
2723      *  Searches in a side table, not the main scope of the site.
2724      *  This emulates the lookup process required by JSR 292 in JVM.
2725      *  @param env       Attribution environment
2726      *  @param spMethod  signature polymorphic method - i.e. MH.invokeExact
2727      *  @param argtypes  The required argument types
2728      */
2729     Symbol findPolymorphicSignatureInstance(Env&lt;AttrContext&gt; env,
2730                                             final Symbol spMethod,
2731                                             List&lt;Type&gt; argtypes) {
2732         Type mtype = infer.instantiatePolymorphicSignatureInstance(env,
2733                 (MethodSymbol)spMethod, currentResolutionContext, argtypes);
2734         return findPolymorphicSignatureInstance(spMethod, mtype);
2735     }
2736 
2737     Symbol findPolymorphicSignatureInstance(final Symbol spMethod,
2738                                             Type mtype) {
2739         for (Symbol sym : polymorphicSignatureScope.getSymbolsByName(spMethod.name)) {
2740             // Check that there is already a method symbol for the method
2741             // type and owner
2742             if (types.isSameType(mtype, sym.type) &amp;&amp;
2743                 spMethod.owner == sym.owner) {
2744                 return sym;
2745             }
2746         }
2747 
2748         // Create the desired method
2749         // Retain static modifier is to support invocations to
2750         // MethodHandle.linkTo* methods
2751         long flags = ABSTRACT | HYPOTHETICAL |
2752                      spMethod.flags() &amp; (Flags.AccessFlags | Flags.STATIC);
2753         Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {
2754             @Override
2755             public Symbol baseSymbol() {
2756                 return spMethod;
2757             }
2758         };
2759         if (!mtype.isErroneous()) { // Cache only if kosher.
2760             polymorphicSignatureScope.enter(msym);
2761         }
2762         return msym;
2763     }
2764 
2765     /** Resolve a qualified method identifier, throw a fatal error if not
2766      *  found.
2767      *  @param pos       The position to use for error reporting.
2768      *  @param env       The environment current at the method invocation.
2769      *  @param site      The type of the qualifying expression, in which
2770      *                   identifier is searched.
2771      *  @param name      The identifier&#39;s name.
2772      *  @param argtypes  The types of the invocation&#39;s value arguments.
2773      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2774      */
2775     public MethodSymbol resolveInternalMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2776                                         Type site, Name name,
2777                                         List&lt;Type&gt; argtypes,
2778                                         List&lt;Type&gt; typeargtypes) {
2779         MethodResolutionContext resolveContext = new MethodResolutionContext();
2780         resolveContext.internalResolution = true;
2781         Symbol sym = resolveQualifiedMethod(resolveContext, pos, env, site.tsym,
2782                 site, name, argtypes, typeargtypes);
2783         if (sym.kind == MTH) return (MethodSymbol)sym;
2784         else throw new FatalError(
2785                  diags.fragment(Fragments.FatalErrCantLocateMeth(name)));
2786     }
2787 
2788     /** Resolve constructor.
2789      *  @param pos       The position to use for error reporting.
2790      *  @param env       The environment current at the constructor invocation.
2791      *  @param site      The type of class for which a constructor is searched.
2792      *  @param argtypes  The types of the constructor invocation&#39;s value
2793      *                   arguments.
2794      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2795      *                   arguments.
2796      */
2797     Symbol resolveConstructor(DiagnosticPosition pos,
2798                               Env&lt;AttrContext&gt; env,
2799                               Type site,
2800                               List&lt;Type&gt; argtypes,
2801                               List&lt;Type&gt; typeargtypes) {
2802         return resolveConstructor(new MethodResolutionContext(), pos, env, site, argtypes, typeargtypes);
2803     }
2804 
2805     private Symbol resolveConstructor(MethodResolutionContext resolveContext,
2806                               final DiagnosticPosition pos,
2807                               Env&lt;AttrContext&gt; env,
2808                               Type site,
2809                               List&lt;Type&gt; argtypes,
2810                               List&lt;Type&gt; typeargtypes) {
2811         return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2812             @Override
2813             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2814                 return findConstructor(pos, env, site, argtypes, typeargtypes,
2815                         phase.isBoxingRequired(),
2816                         phase.isVarargsRequired());
2817             }
2818         });
2819     }
2820 
2821     /** Resolve a constructor, throw a fatal error if not found.
2822      *  @param pos       The position to use for error reporting.
2823      *  @param env       The environment current at the method invocation.
2824      *  @param site      The type to be constructed.
2825      *  @param argtypes  The types of the invocation&#39;s value arguments.
2826      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2827      */
2828     public MethodSymbol resolveInternalConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2829                                         Type site,
2830                                         List&lt;Type&gt; argtypes,
2831                                         List&lt;Type&gt; typeargtypes) {
2832         MethodResolutionContext resolveContext = new MethodResolutionContext();
2833         resolveContext.internalResolution = true;
2834         Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
2835         if (sym.kind == MTH) return (MethodSymbol)sym;
2836         else throw new FatalError(
2837                  diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
2838     }
2839 
2840     Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2841                               Type site, List&lt;Type&gt; argtypes,
2842                               List&lt;Type&gt; typeargtypes,
2843                               boolean allowBoxing,
2844                               boolean useVarargs) {
2845         Symbol sym = findMethod(env, site,
2846                                     names.init, argtypes,
2847                                     typeargtypes, allowBoxing,
2848                                     useVarargs);
2849         chk.checkDeprecated(pos, env.info.scope.owner, sym);
2850         chk.checkPreview(pos, sym);
2851         return sym;
2852     }
2853 
2854     /** Resolve constructor using diamond inference.
2855      *  @param pos       The position to use for error reporting.
2856      *  @param env       The environment current at the constructor invocation.
2857      *  @param site      The type of class for which a constructor is searched.
2858      *                   The scope of this class has been touched in attribution.
2859      *  @param argtypes  The types of the constructor invocation&#39;s value
2860      *                   arguments.
2861      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2862      *                   arguments.
2863      */
2864     Symbol resolveDiamond(DiagnosticPosition pos,
2865                               Env&lt;AttrContext&gt; env,
2866                               Type site,
2867                               List&lt;Type&gt; argtypes,
2868                               List&lt;Type&gt; typeargtypes) {
2869         return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
2870                 new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2871                     @Override
2872                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2873                         return findDiamond(env, site, argtypes, typeargtypes,
2874                                 phase.isBoxingRequired(),
2875                                 phase.isVarargsRequired());
2876                     }
2877                     @Override
2878                     Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2879                         if (sym.kind.isResolutionError()) {
2880                             if (sym.kind != WRONG_MTH &amp;&amp;
2881                                 sym.kind != WRONG_MTHS) {
2882                                 sym = super.access(env, pos, location, sym);
2883                             } else {
2884                                 final JCDiagnostic details = sym.kind == WRONG_MTH ?
2885                                                 ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
2886                                                 null;
2887                                 sym = new DiamondError(sym, currentResolutionContext);
2888                                 sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);
2889                                 env.info.pendingResolutionPhase = currentResolutionContext.step;
2890                             }
2891                         }
2892                         return sym;
2893                     }});
2894     }
2895 
2896     /** This method scans all the constructor symbol in a given class scope -
2897      *  assuming that the original scope contains a constructor of the kind:
2898      *  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo,
2899      *  a method check is executed against the modified constructor type:
2900      *  {@code &lt;X,Y&gt;Foo&lt;X,Y&gt;(X x, Y y)}. This is crucial in order to enable diamond
2901      *  inference. The inferred return type of the synthetic constructor IS
2902      *  the inferred type for the diamond operator.
2903      */
2904     private Symbol findDiamond(Env&lt;AttrContext&gt; env,
2905                               Type site,
2906                               List&lt;Type&gt; argtypes,
2907                               List&lt;Type&gt; typeargtypes,
2908                               boolean allowBoxing,
2909                               boolean useVarargs) {
2910         Symbol bestSoFar = methodNotFound;
2911         TypeSymbol tsym = site.tsym.isInterface() ? syms.objectType.tsym : site.tsym;
2912         for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {
2913             //- System.out.println(&quot; e &quot; + e.sym);
2914             if (sym.kind == MTH &amp;&amp;
2915                 (sym.flags_field &amp; SYNTHETIC) == 0) {
2916                     List&lt;Type&gt; oldParams = sym.type.hasTag(FORALL) ?
2917                             ((ForAll)sym.type).tvars :
2918                             List.nil();
2919                     Type constrType = new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),
2920                                                  types.createMethodTypeWithReturn(sym.type.asMethodType(), site));
2921                     MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {
2922                         @Override
2923                         public Symbol baseSymbol() {
2924                             return sym;
2925                         }
2926                     };
2927                     bestSoFar = selectBest(env, site, argtypes, typeargtypes,
2928                             newConstr,
2929                             bestSoFar,
2930                             allowBoxing,
2931                             useVarargs);
2932             }
2933         }
2934         return bestSoFar;
2935     }
2936 
2937     Symbol getMemberReference(DiagnosticPosition pos,
2938             Env&lt;AttrContext&gt; env,
2939             JCMemberReference referenceTree,
2940             Type site,
2941             Name name) {
2942 
2943         site = types.capture(site);
2944 
2945         ReferenceLookupHelper lookupHelper = makeReferenceLookupHelper(
2946                 referenceTree, site, name, List.nil(), null, VARARITY);
2947 
2948         Env&lt;AttrContext&gt; newEnv = env.dup(env.tree, env.info.dup());
2949         Symbol sym = lookupMethod(newEnv, env.tree.pos(), site.tsym,
2950                 nilMethodCheck, lookupHelper);
2951 
2952         env.info.pendingResolutionPhase = newEnv.info.pendingResolutionPhase;
2953 
2954         return sym;
2955     }
2956 
2957     ReferenceLookupHelper makeReferenceLookupHelper(JCMemberReference referenceTree,
2958                                   Type site,
2959                                   Name name,
2960                                   List&lt;Type&gt; argtypes,
2961                                   List&lt;Type&gt; typeargtypes,
2962                                   MethodResolutionPhase maxPhase) {
2963         if (!name.equals(names.init)) {
2964             //method reference
2965             return new MethodReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase);
2966         } else if (site.hasTag(ARRAY)) {
2967             //array constructor reference
2968             return new ArrayConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2969         } else {
2970             //class constructor reference
2971             return new ConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2972         }
2973     }
2974 
2975     /**
2976      * Resolution of member references is typically done as a single
2977      * overload resolution step, where the argument types A are inferred from
2978      * the target functional descriptor.
2979      *
2980      * If the member reference is a method reference with a type qualifier,
2981      * a two-step lookup process is performed. The first step uses the
2982      * expected argument list A, while the second step discards the first
2983      * type from A (which is treated as a receiver type).
2984      *
2985      * There are two cases in which inference is performed: (i) if the member
2986      * reference is a constructor reference and the qualifier type is raw - in
2987      * which case diamond inference is used to infer a parameterization for the
2988      * type qualifier; (ii) if the member reference is an unbound reference
2989      * where the type qualifier is raw - in that case, during the unbound lookup
2990      * the receiver argument type is used to infer an instantiation for the raw
2991      * qualifier type.
2992      *
2993      * When a multi-step resolution process is exploited, the process of picking
2994      * the resulting symbol is delegated to an helper class {@link com.sun.tools.javac.comp.Resolve.ReferenceChooser}.
2995      *
2996      * This routine returns a pair (T,S), where S is the member reference symbol,
2997      * and T is the type of the class in which S is defined. This is necessary as
2998      * the type T might be dynamically inferred (i.e. if constructor reference
2999      * has a raw qualifier).
3000      */
3001     Pair&lt;Symbol, ReferenceLookupHelper&gt; resolveMemberReference(Env&lt;AttrContext&gt; env,
3002                                   JCMemberReference referenceTree,
3003                                   Type site,
3004                                   Name name,
3005                                   List&lt;Type&gt; argtypes,
3006                                   List&lt;Type&gt; typeargtypes,
3007                                   Type descriptor,
3008                                   MethodCheck methodCheck,
3009                                   InferenceContext inferenceContext,
3010                                   ReferenceChooser referenceChooser) {
3011 
3012         //step 1 - bound lookup
3013         ReferenceLookupHelper boundLookupHelper = makeReferenceLookupHelper(
3014                 referenceTree, site, name, argtypes, typeargtypes, VARARITY);
3015         Env&lt;AttrContext&gt; boundEnv = env.dup(env.tree, env.info.dup());
3016         MethodResolutionContext boundSearchResolveContext = new MethodResolutionContext();
3017         boundSearchResolveContext.methodCheck = methodCheck;
3018         Symbol boundSym = lookupMethod(boundEnv, env.tree.pos(),
3019                 site.tsym, boundSearchResolveContext, boundLookupHelper);
3020         ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext);
3021 
3022         //step 2 - unbound lookup
3023         Symbol unboundSym = methodNotFound;
3024         Env&lt;AttrContext&gt; unboundEnv = env.dup(env.tree, env.info.dup());
3025         ReferenceLookupHelper unboundLookupHelper = boundLookupHelper.unboundLookup(inferenceContext);
3026         ReferenceLookupResult unboundRes = referenceNotFound;
3027         if (unboundLookupHelper != null) {
3028             MethodResolutionContext unboundSearchResolveContext =
3029                     new MethodResolutionContext();
3030             unboundSearchResolveContext.methodCheck = methodCheck;
3031             unboundSym = lookupMethod(unboundEnv, env.tree.pos(),
3032                     site.tsym, unboundSearchResolveContext, unboundLookupHelper);
3033             unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext);
3034         }
3035 
3036         //merge results
3037         Pair&lt;Symbol, ReferenceLookupHelper&gt; res;
3038         ReferenceLookupResult bestRes = referenceChooser.result(boundRes, unboundRes);
3039         res = new Pair&lt;&gt;(bestRes.sym,
3040                 bestRes == unboundRes ? unboundLookupHelper : boundLookupHelper);
3041         env.info.pendingResolutionPhase = bestRes == unboundRes ?
3042                 unboundEnv.info.pendingResolutionPhase :
3043                 boundEnv.info.pendingResolutionPhase;
3044 
3045         if (!res.fst.kind.isResolutionError()) {
3046             //handle sigpoly method references
3047             MethodSymbol msym = (MethodSymbol)res.fst;
3048             if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
3049                 env.info.pendingResolutionPhase = BASIC;
3050                 res = new Pair&lt;&gt;(findPolymorphicSignatureInstance(msym, descriptor), res.snd);
3051             }
3052         }
3053 
3054         return res;
3055     }
3056 
3057     /**
3058      * This class is used to represent a method reference lookup result. It keeps track of two
3059      * things: (i) the symbol found during a method reference lookup and (ii) the static kind
3060      * of the lookup (see {@link com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind}).
3061      */
3062     static class ReferenceLookupResult {
3063 
3064         /**
3065          * Static kind associated with a method reference lookup. Erroneous lookups end up with
3066          * the UNDEFINED kind; successful lookups will end up with either STATIC, NON_STATIC,
3067          * depending on whether all applicable candidates are static or non-static methods,
3068          * respectively. If a successful lookup has both static and non-static applicable methods,
3069          * its kind is set to BOTH.
3070          */
3071         enum StaticKind {
3072             STATIC,
3073             NON_STATIC,
3074             BOTH,
3075             UNDEFINED;
3076 
3077             /**
3078              * Retrieve the static kind associated with a given (method) symbol.
3079              */
3080             static StaticKind from(Symbol s) {
3081                 return s.isStatic() ?
3082                         STATIC : NON_STATIC;
3083             }
3084 
3085             /**
3086              * Merge two static kinds together.
3087              */
3088             static StaticKind reduce(StaticKind sk1, StaticKind sk2) {
3089                 if (sk1 == UNDEFINED) {
3090                     return sk2;
3091                 } else if (sk2 == UNDEFINED) {
3092                     return sk1;
3093                 } else {
3094                     return sk1 == sk2 ? sk1 : BOTH;
3095                 }
3096             }
3097         }
3098 
3099         /** The static kind. */
3100         StaticKind staticKind;
3101 
3102         /** The lookup result. */
3103         Symbol sym;
3104 
3105         ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext) {
3106             this(sym, staticKind(sym, resolutionContext));
3107         }
3108 
3109         private ReferenceLookupResult(Symbol sym, StaticKind staticKind) {
3110             this.staticKind = staticKind;
3111             this.sym = sym;
3112         }
3113 
3114         private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext) {
3115             switch (sym.kind) {
3116                 case MTH:
3117                 case AMBIGUOUS:
3118                     return resolutionContext.candidates.stream()
3119                             .filter(c -&gt; c.isApplicable() &amp;&amp; c.step == resolutionContext.step)
3120                             .map(c -&gt; StaticKind.from(c.sym))
3121                             .reduce(StaticKind::reduce)
3122                             .orElse(StaticKind.UNDEFINED);
3123                 default:
3124                     return StaticKind.UNDEFINED;
3125             }
3126         }
3127 
3128         /**
3129          * Does this result corresponds to a successful lookup (i.e. one where a method has been found?)
3130          */
3131         boolean isSuccess() {
3132             return staticKind != StaticKind.UNDEFINED;
3133         }
3134 
3135         /**
3136          * Does this result have given static kind?
3137          */
3138         boolean hasKind(StaticKind sk) {
3139             return this.staticKind == sk;
3140         }
3141 
3142         /**
3143          * Error recovery helper: can this lookup result be ignored (for the purpose of returning
3144          * some &#39;better&#39; result) ?
3145          */
3146         boolean canIgnore() {
3147             switch (sym.kind) {
3148                 case ABSENT_MTH:
3149                     return true;
3150                 case WRONG_MTH:
3151                     InapplicableSymbolError errSym =
3152                             (InapplicableSymbolError)sym.baseSymbol();
3153                     return new Template(MethodCheckDiag.ARITY_MISMATCH.regex())
3154                             .matches(errSym.errCandidate().snd);
3155                 case WRONG_MTHS:
3156                     InapplicableSymbolsError errSyms =
3157                             (InapplicableSymbolsError)sym.baseSymbol();
3158                     return errSyms.filterCandidates(errSyms.mapCandidates()).isEmpty();
3159                 default:
3160                     return false;
3161             }
3162         }
3163 
3164         static ReferenceLookupResult error(Symbol sym) {
3165             return new ReferenceLookupResult(sym, StaticKind.UNDEFINED);
3166         }
3167     }
3168 
3169     /**
3170      * This abstract class embodies the logic that converts one (bound lookup) or two (unbound lookup)
3171      * {@code ReferenceLookupResult} objects into a (@code Symbol), which is then regarded as the
3172      * result of method reference resolution.
3173      */
3174     abstract class ReferenceChooser {
3175         /**
3176          * Generate a result from a pair of lookup result objects. This method delegates to the
3177          * appropriate result generation routine.
3178          */
3179         ReferenceLookupResult result(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3180             return unboundRes != referenceNotFound ?
3181                     unboundResult(boundRes, unboundRes) :
3182                     boundResult(boundRes);
3183         }
3184 
3185         /**
3186          * Generate a symbol from a given bound lookup result.
3187          */
3188         abstract ReferenceLookupResult boundResult(ReferenceLookupResult boundRes);
3189 
3190         /**
3191          * Generate a symbol from a pair of bound/unbound lookup results.
3192          */
3193         abstract ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes);
3194     }
3195 
3196     /**
3197      * This chooser implements the selection strategy used during a full lookup; this logic
3198      * is described in JLS SE 8 (15.3.2).
3199      */
3200     ReferenceChooser basicReferenceChooser = new ReferenceChooser() {
3201 
3202         @Override
3203         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3204             return !boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC) ?
3205                     boundRes : //the search produces a non-static method
3206                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3207         }
3208 
3209         @Override
3210         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3211             if (boundRes.hasKind(StaticKind.STATIC) &amp;&amp;
3212                     (!unboundRes.isSuccess() || unboundRes.hasKind(StaticKind.STATIC))) {
3213                 //the first search produces a static method and no non-static method is applicable
3214                 //during the second search
3215                 return boundRes;
3216             } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &amp;&amp;
3217                     (!boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC))) {
3218                 //the second search produces a non-static method and no static method is applicable
3219                 //during the first search
3220                 return unboundRes;
3221             } else if (boundRes.isSuccess() &amp;&amp; unboundRes.isSuccess()) {
3222                 //both searches produce some result; ambiguity (error recovery)
3223                 return ReferenceLookupResult.error(ambiguityError(boundRes.sym, unboundRes.sym));
3224             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3225                 //Both searches failed to produce a result with correct staticness (i.e. first search
3226                 //produces an non-static method). Alternatively, a given search produced a result
3227                 //with the right staticness, but the other search has applicable methods with wrong
3228                 //staticness (error recovery)
3229                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3230                         boundRes.sym : unboundRes.sym, true));
3231             } else {
3232                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3233                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3234                         unboundRes : boundRes;
3235             }
3236         }
3237     };
3238 
3239     /**
3240      * This chooser implements the selection strategy used during an arity-based lookup; this logic
3241      * is described in JLS SE 8 (15.12.2.1).
3242      */
3243     ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
3244 
3245         @Override
3246         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3247             return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?
3248                     boundRes : //the search has at least one applicable non-static method
3249                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3250         }
3251 
3252         @Override
3253         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3254             if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
3255                 //the first search has at least one applicable static method
3256                 return boundRes;
3257             } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
3258                 //the second search has at least one applicable non-static method
3259                 return unboundRes;
3260             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3261                 //either the first search produces a non-static method, or second search produces
3262                 //a non-static method (error recovery)
3263                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3264                         boundRes.sym : unboundRes.sym, true));
3265             } else {
3266                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3267                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3268                         unboundRes : boundRes;
3269             }
3270         }
3271     };
3272 
3273     /**
3274      * Helper for defining custom method-like lookup logic; a lookup helper
3275      * provides hooks for (i) the actual lookup logic and (ii) accessing the
3276      * lookup result (this step might result in compiler diagnostics to be generated)
3277      */
3278     abstract class LookupHelper {
3279 
3280         /** name of the symbol to lookup */
3281         Name name;
3282 
3283         /** location in which the lookup takes place */
3284         Type site;
3285 
3286         /** actual types used during the lookup */
3287         List&lt;Type&gt; argtypes;
3288 
3289         /** type arguments used during the lookup */
3290         List&lt;Type&gt; typeargtypes;
3291 
3292         /** Max overload resolution phase handled by this helper */
3293         MethodResolutionPhase maxPhase;
3294 
3295         LookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3296             this.name = name;
3297             this.site = site;
3298             this.argtypes = argtypes;
3299             this.typeargtypes = typeargtypes;
3300             this.maxPhase = maxPhase;
3301         }
3302 
3303         /**
3304          * Should lookup stop at given phase with given result
3305          */
3306         final boolean shouldStop(Symbol sym, MethodResolutionPhase phase) {
3307             return phase.ordinal() &gt; maxPhase.ordinal() ||
3308                 !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;
3309         }
3310 
3311         /**
3312          * Search for a symbol under a given overload resolution phase - this method
3313          * is usually called several times, once per each overload resolution phase
3314          */
3315         abstract Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3316 
3317         /**
3318          * Dump overload resolution info
3319          */
3320         void debug(DiagnosticPosition pos, Symbol sym) {
3321             //do nothing
3322         }
3323 
3324         /**
3325          * Validate the result of the lookup
3326          */
3327         abstract Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym);
3328     }
3329 
3330     abstract class BasicLookupHelper extends LookupHelper {
3331 
3332         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3333             this(name, site, argtypes, typeargtypes, MethodResolutionPhase.VARARITY);
3334         }
3335 
3336         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3337             super(name, site, argtypes, typeargtypes, maxPhase);
3338         }
3339 
3340         @Override
3341         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3342             Symbol sym = doLookup(env, phase);
3343             if (sym.kind == AMBIGUOUS) {
3344                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3345                 sym = a_err.mergeAbstracts(site);
3346             }
3347             return sym;
3348         }
3349 
3350         abstract Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3351 
3352         @Override
3353         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3354             if (sym.kind.isResolutionError()) {
3355                 //if nothing is found return the &#39;first&#39; error
3356                 sym = accessMethod(sym, pos, location, site, name, true, argtypes, typeargtypes);
3357             }
3358             return sym;
3359         }
3360 
3361         @Override
3362         void debug(DiagnosticPosition pos, Symbol sym) {
3363             reportVerboseResolutionDiagnostic(pos, name, site, argtypes, typeargtypes, sym);
3364         }
3365     }
3366 
3367     /**
3368      * Helper class for member reference lookup. A reference lookup helper
3369      * defines the basic logic for member reference lookup; a method gives
3370      * access to an &#39;unbound&#39; helper used to perform an unbound member
3371      * reference lookup.
3372      */
3373     abstract class ReferenceLookupHelper extends LookupHelper {
3374 
3375         /** The member reference tree */
3376         JCMemberReference referenceTree;
3377 
3378         ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3379                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3380             super(name, site, argtypes, typeargtypes, maxPhase);
3381             this.referenceTree = referenceTree;
3382         }
3383 
3384         /**
3385          * Returns an unbound version of this lookup helper. By default, this
3386          * method returns an dummy lookup helper.
3387          */
3388         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3389             return null;
3390         }
3391 
3392         /**
3393          * Get the kind of the member reference
3394          */
3395         abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);
3396 
3397         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3398             if (sym.kind == AMBIGUOUS) {
3399                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3400                 sym = a_err.mergeAbstracts(site);
3401             }
3402             //skip error reporting
3403             return sym;
3404         }
3405     }
3406 
3407     /**
3408      * Helper class for method reference lookup. The lookup logic is based
3409      * upon Resolve.findMethod; in certain cases, this helper class has a
3410      * corresponding unbound helper class (see UnboundMethodReferenceLookupHelper).
3411      * In such cases, non-static lookup results are thrown away.
3412      */
3413     class MethodReferenceLookupHelper extends ReferenceLookupHelper {
3414 
3415         /** The original method reference lookup site. */
3416         Type originalSite;
3417 
3418         MethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3419                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3420             super(referenceTree, name, types.skipTypeVars(site, true), argtypes, typeargtypes, maxPhase);
3421             this.originalSite = site;
3422         }
3423 
3424         @Override
3425         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3426             return findMethod(env, site, name, argtypes, typeargtypes,
3427                     phase.isBoxingRequired(), phase.isVarargsRequired());
3428         }
3429 
3430         @Override
3431         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3432             if (TreeInfo.isStaticSelector(referenceTree.expr, names)) {
3433                 if (argtypes.nonEmpty() &amp;&amp;
3434                         (argtypes.head.hasTag(NONE) ||
3435                         types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {
3436                     return new UnboundMethodReferenceLookupHelper(referenceTree, name,
3437                             originalSite, argtypes, typeargtypes, maxPhase);
3438                 } else {
3439                     return new ReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase) {
3440                         @Override
3441                         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3442                             return this;
3443                         }
3444 
3445                         @Override
3446                         Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3447                             return methodNotFound;
3448                         }
3449 
3450                         @Override
3451                         ReferenceKind referenceKind(Symbol sym) {
3452                             Assert.error();
3453                             return null;
3454                         }
3455                     };
3456                 }
3457             } else {
3458                 return super.unboundLookup(inferenceContext);
3459             }
3460         }
3461 
3462         @Override
3463         ReferenceKind referenceKind(Symbol sym) {
3464             if (sym.isStatic()) {
3465                 return ReferenceKind.STATIC;
3466             } else {
3467                 Name selName = TreeInfo.name(referenceTree.getQualifierExpression());
3468                 return selName != null &amp;&amp; selName == names._super ?
3469                         ReferenceKind.SUPER :
3470                         ReferenceKind.BOUND;
3471             }
3472         }
3473     }
3474 
3475     /**
3476      * Helper class for unbound method reference lookup. Essentially the same
3477      * as the basic method reference lookup helper; main difference is that static
3478      * lookup results are thrown away. If qualifier type is raw, an attempt to
3479      * infer a parameterized type is made using the first actual argument (that
3480      * would otherwise be ignored during the lookup).
3481      */
3482     class UnboundMethodReferenceLookupHelper extends MethodReferenceLookupHelper {
3483 
3484         UnboundMethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3485                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3486             super(referenceTree, name, site, argtypes.tail, typeargtypes, maxPhase);
3487             if (site.isRaw() &amp;&amp; !argtypes.head.hasTag(NONE)) {
3488                 Type asSuperSite = types.asSuper(argtypes.head, site.tsym);
3489                 this.site = types.skipTypeVars(asSuperSite, true);
3490             }
3491         }
3492 
3493         @Override
3494         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3495             return this;
3496         }
3497 
3498         @Override
3499         ReferenceKind referenceKind(Symbol sym) {
3500             return ReferenceKind.UNBOUND;
3501         }
3502     }
3503 
3504     /**
3505      * Helper class for array constructor lookup; an array constructor lookup
3506      * is simulated by looking up a method that returns the array type specified
3507      * as qualifier, and that accepts a single int parameter (size of the array).
3508      */
3509     class ArrayConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3510 
3511         ArrayConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3512                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3513             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3514         }
3515 
3516         @Override
3517         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3518             WriteableScope sc = WriteableScope.create(syms.arrayClass);
3519             MethodSymbol arrayConstr = new MethodSymbol(PUBLIC, name, null, site.tsym);
3520             arrayConstr.type = new MethodType(List.of(syms.intType), site, List.nil(), syms.methodClass);
3521             sc.enter(arrayConstr);
3522             return findMethodInScope(env, site, name, argtypes, typeargtypes, sc, methodNotFound, phase.isBoxingRequired(), phase.isVarargsRequired(), false);
3523         }
3524 
3525         @Override
3526         ReferenceKind referenceKind(Symbol sym) {
3527             return ReferenceKind.ARRAY_CTOR;
3528         }
3529     }
3530 
3531     /**
3532      * Helper class for constructor reference lookup. The lookup logic is based
3533      * upon either Resolve.findMethod or Resolve.findDiamond - depending on
3534      * whether the constructor reference needs diamond inference (this is the case
3535      * if the qualifier type is raw). A special erroneous symbol is returned
3536      * if the lookup returns the constructor of an inner class and there&#39;s no
3537      * enclosing instance in scope.
3538      */
3539     class ConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3540 
3541         boolean needsInference;
3542 
3543         ConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3544                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3545             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3546             if (site.isRaw()) {
3547                 this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());
3548                 needsInference = true;
3549             }
3550         }
3551 
3552         @Override
3553         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3554             Symbol sym = needsInference ?
3555                 findDiamond(env, site, argtypes, typeargtypes, phase.isBoxingRequired(), phase.isVarargsRequired()) :
3556                 findMethod(env, site, name, argtypes, typeargtypes,
3557                         phase.isBoxingRequired(), phase.isVarargsRequired());
3558             return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;
3559         }
3560 
3561         @Override
3562         ReferenceKind referenceKind(Symbol sym) {
3563             return site.getEnclosingType().hasTag(NONE) ?
3564                     ReferenceKind.TOPLEVEL : ReferenceKind.IMPLICIT_INNER;
3565         }
3566     }
3567 
3568     /**
3569      * Main overload resolution routine. On each overload resolution step, a
3570      * lookup helper class is used to perform the method/constructor lookup;
3571      * at the end of the lookup, the helper is used to validate the results
3572      * (this last step might trigger overload resolution diagnostics).
3573      */
3574     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, MethodCheck methodCheck, LookupHelper lookupHelper) {
3575         MethodResolutionContext resolveContext = new MethodResolutionContext();
3576         resolveContext.methodCheck = methodCheck;
3577         return lookupMethod(env, pos, location, resolveContext, lookupHelper);
3578     }
3579 
3580     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location,
3581             MethodResolutionContext resolveContext, LookupHelper lookupHelper) {
3582         MethodResolutionContext prevResolutionContext = currentResolutionContext;
3583         try {
3584             Symbol bestSoFar = methodNotFound;
3585             currentResolutionContext = resolveContext;
3586             for (MethodResolutionPhase phase : methodResolutionSteps) {
3587                 if (lookupHelper.shouldStop(bestSoFar, phase))
3588                     break;
3589                 MethodResolutionPhase prevPhase = currentResolutionContext.step;
3590                 Symbol prevBest = bestSoFar;
3591                 currentResolutionContext.step = phase;
3592                 Symbol sym = lookupHelper.lookup(env, phase);
3593                 lookupHelper.debug(pos, sym);
3594                 bestSoFar = phase.mergeResults(bestSoFar, sym);
3595                 env.info.pendingResolutionPhase = (prevBest == bestSoFar) ? prevPhase : phase;
3596             }
3597             return lookupHelper.access(env, pos, location, bestSoFar);
3598         } finally {
3599             currentResolutionContext = prevResolutionContext;
3600         }
3601     }
3602 
3603     /**
3604      * Resolve `c.name&#39; where name == this or name == super.
3605      * @param pos           The position to use for error reporting.
3606      * @param env           The environment current at the expression.
3607      * @param c             The qualifier.
3608      * @param name          The identifier&#39;s name.
3609      */
3610     Symbol resolveSelf(DiagnosticPosition pos,
3611                        Env&lt;AttrContext&gt; env,
3612                        TypeSymbol c,
3613                        Name name) {
3614         Env&lt;AttrContext&gt; env1 = env;
3615         boolean staticOnly = false;
3616         while (env1.outer != null) {
3617             if (isStatic(env1)) staticOnly = true;
3618             if (env1.enclClass.sym == c) {
3619                 Symbol sym = env1.info.scope.findFirst(name);
3620                 if (sym != null) {
3621                     if (staticOnly) sym = new StaticError(sym);
3622                     return accessBase(sym, pos, env.enclClass.sym.type,
3623                                   name, true);
3624                 }
3625             }
3626             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
3627             env1 = env1.outer;
3628         }
3629         if (c.isInterface() &amp;&amp;
3630             name == names._super &amp;&amp; !isStatic(env) &amp;&amp;
3631             types.isDirectSuperInterface(c, env.enclClass.sym)) {
3632             //this might be a default super call if one of the superinterfaces is &#39;c&#39;
3633             for (Type t : pruneInterfaces(env.enclClass.type)) {
3634                 if (t.tsym == c) {
3635                     env.info.defaultSuperCallSite = t;
3636                     return new VarSymbol(0, names._super,
3637                             types.asSuper(env.enclClass.type, c), env.enclClass.sym);
3638                 }
3639             }
3640             //find a direct super type that is a subtype of &#39;c&#39;
3641             for (Type i : types.directSupertypes(env.enclClass.type)) {
3642                 if (i.tsym.isSubClass(c, types) &amp;&amp; i.tsym != c) {
3643                     log.error(pos,
3644                               Errors.IllegalDefaultSuperCall(c,
3645                                                              Fragments.RedundantSupertype(c, i)));
3646                     return syms.errSymbol;
3647                 }
3648             }
3649             Assert.error();
3650         }
3651         log.error(pos, Errors.NotEnclClass(c));
3652         return syms.errSymbol;
3653     }
3654     //where
3655     private List&lt;Type&gt; pruneInterfaces(Type t) {
3656         ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
3657         for (Type t1 : types.interfaces(t)) {
3658             boolean shouldAdd = true;
3659             for (Type t2 : types.directSupertypes(t)) {
3660                 if (t1 != t2 &amp;&amp; types.isSubtypeNoCapture(t2, t1)) {
3661                     shouldAdd = false;
3662                 }
3663             }
3664             if (shouldAdd) {
3665                 result.append(t1);
3666             }
3667         }
3668         return result.toList();
3669     }
3670 
3671 
3672     /**
3673      * Resolve `c.this&#39; for an enclosing class c that contains the
3674      * named member.
3675      * @param pos           The position to use for error reporting.
3676      * @param env           The environment current at the expression.
3677      * @param member        The member that must be contained in the result.
3678      */
3679     Symbol resolveSelfContaining(DiagnosticPosition pos,
3680                                  Env&lt;AttrContext&gt; env,
3681                                  Symbol member,
3682                                  boolean isSuperCall) {
3683         Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);
3684         if (sym == null) {
3685             log.error(pos, Errors.EnclClassRequired(member));
3686             return syms.errSymbol;
3687         } else {
3688             return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);
3689         }
3690     }
3691 
3692     boolean enclosingInstanceMissing(Env&lt;AttrContext&gt; env, Type type) {
3693         if (type.hasTag(CLASS) &amp;&amp; type.getEnclosingType().hasTag(CLASS)) {
3694             Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);
3695             return encl == null || encl.kind.isResolutionError();
3696         }
3697         return false;
3698     }
3699 
3700     private Symbol resolveSelfContainingInternal(Env&lt;AttrContext&gt; env,
3701                                  Symbol member,
3702                                  boolean isSuperCall) {
3703         Name name = names._this;
3704         Env&lt;AttrContext&gt; env1 = isSuperCall ? env.outer : env;
3705         boolean staticOnly = false;
3706         if (env1 != null) {
3707             while (env1 != null &amp;&amp; env1.outer != null) {
3708                 if (isStatic(env1)) staticOnly = true;
3709                 if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {
3710                     Symbol sym = env1.info.scope.findFirst(name);
3711                     if (sym != null) {
3712                         if (staticOnly) sym = new StaticError(sym);
3713                         return sym;
3714                     }
3715                 }
3716                 if ((env1.enclClass.sym.flags() &amp; STATIC) != 0)
3717                     staticOnly = true;
3718                 env1 = env1.outer;
3719             }
3720         }
3721         return null;
3722     }
3723 
3724     /**
3725      * Resolve an appropriate implicit this instance for t&#39;s container.
3726      * JLS 8.8.5.1 and 15.9.2
3727      */
3728     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t) {
3729         return resolveImplicitThis(pos, env, t, false);
3730     }
3731 
3732     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t, boolean isSuperCall) {
3733         Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)
3734                          ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)
3735                          : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;
3736         if (env.info.isSelfCall &amp;&amp; thisType.tsym == env.enclClass.sym) {
3737             log.error(pos, Errors.CantRefBeforeCtorCalled(&quot;this&quot;));
3738         }
3739         return thisType;
3740     }
3741 
3742 /* ***************************************************************************
3743  *  ResolveError classes, indicating error situations when accessing symbols
3744  ****************************************************************************/
3745 
3746     //used by TransTypes when checking target type of synthetic cast
3747     public void logAccessErrorInternal(Env&lt;AttrContext&gt; env, JCTree tree, Type type) {
3748         AccessError error = new AccessError(env, env.enclClass.type, type.tsym);
3749         logResolveError(error, tree.pos(), env.enclClass.sym, env.enclClass.type, null, null, null);
3750     }
3751     //where
3752     private void logResolveError(ResolveError error,
3753             DiagnosticPosition pos,
3754             Symbol location,
3755             Type site,
3756             Name name,
3757             List&lt;Type&gt; argtypes,
3758             List&lt;Type&gt; typeargtypes) {
3759         JCDiagnostic d = error.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
3760                 pos, location, site, name, argtypes, typeargtypes);
3761         if (d != null) {
3762             d.setFlag(DiagnosticFlag.RESOLVE_ERROR);
3763             log.report(d);
3764         }
3765     }
3766 
3767     private final LocalizedString noArgs = new LocalizedString(&quot;compiler.misc.no.args&quot;);
3768 
3769     public Object methodArguments(List&lt;Type&gt; argtypes) {
3770         if (argtypes == null || argtypes.isEmpty()) {
3771             return noArgs;
3772         } else {
3773             ListBuffer&lt;Object&gt; diagArgs = new ListBuffer&lt;&gt;();
3774             for (Type t : argtypes) {
3775                 if (t.hasTag(DEFERRED)) {
3776                     diagArgs.append(((DeferredAttr.DeferredType)t).tree);
3777                 } else {
3778                     diagArgs.append(t);
3779                 }
3780             }
3781             return diagArgs;
3782         }
3783     }
3784 
3785     /**
3786      * Root class for resolution errors. Subclass of ResolveError
3787      * represent a different kinds of resolution error - as such they must
3788      * specify how they map into concrete compiler diagnostics.
3789      */
3790     abstract class ResolveError extends Symbol {
3791 
3792         /** The name of the kind of error, for debugging only. */
3793         final String debugName;
3794 
3795         ResolveError(Kind kind, String debugName) {
3796             super(kind, 0, null, null, null);
3797             this.debugName = debugName;
3798         }
3799 
3800         @Override @DefinedBy(Api.LANGUAGE_MODEL)
3801         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
3802             throw new AssertionError();
3803         }
3804 
3805         @Override
3806         public String toString() {
3807             return debugName;
3808         }
3809 
3810         @Override
3811         public boolean exists() {
3812             return false;
3813         }
3814 
3815         @Override
3816         public boolean isStatic() {
3817             return false;
3818         }
3819 
3820         /**
3821          * Create an external representation for this erroneous symbol to be
3822          * used during attribution - by default this returns the symbol of a
3823          * brand new error type which stores the original type found
3824          * during resolution.
3825          *
3826          * @param name     the name used during resolution
3827          * @param location the location from which the symbol is accessed
3828          */
3829         protected Symbol access(Name name, TypeSymbol location) {
3830             return types.createErrorType(name, location, syms.errSymbol.type).tsym;
3831         }
3832 
3833         /**
3834          * Create a diagnostic representing this resolution error.
3835          *
3836          * @param dkind     The kind of the diagnostic to be created (e.g error).
3837          * @param pos       The position to be used for error reporting.
3838          * @param site      The original type from where the selection took place.
3839          * @param name      The name of the symbol to be resolved.
3840          * @param argtypes  The invocation&#39;s value arguments,
3841          *                  if we looked for a method.
3842          * @param typeargtypes  The invocation&#39;s type arguments,
3843          *                      if we looked for a method.
3844          */
3845         abstract JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3846                 DiagnosticPosition pos,
3847                 Symbol location,
3848                 Type site,
3849                 Name name,
3850                 List&lt;Type&gt; argtypes,
3851                 List&lt;Type&gt; typeargtypes);
3852     }
3853 
3854     /**
3855      * This class is the root class of all resolution errors caused by
3856      * an invalid symbol being found during resolution.
3857      */
3858     abstract class InvalidSymbolError extends ResolveError {
3859 
3860         /** The invalid symbol found during resolution */
3861         Symbol sym;
3862 
3863         InvalidSymbolError(Kind kind, Symbol sym, String debugName) {
3864             super(kind, debugName);
3865             this.sym = sym;
3866         }
3867 
3868         @Override
3869         public boolean exists() {
3870             return true;
3871         }
3872 
3873         @Override
3874         public String toString() {
3875              return super.toString() + &quot; wrongSym=&quot; + sym;
3876         }
3877 
3878         @Override
3879         public Symbol access(Name name, TypeSymbol location) {
3880             if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
3881                 return types.createErrorType(name, location, sym.type).tsym;
3882             else
3883                 return sym;
3884         }
3885     }
3886 
3887     class BadRestrictedTypeError extends ResolveError {
3888         private final Name typeName;
3889         BadRestrictedTypeError(Name typeName) {
3890             super(Kind.BAD_RESTRICTED_TYPE, &quot;bad var use&quot;);
3891             this.typeName = typeName;
3892         }
3893 
3894         @Override
3895         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3896             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.restricted.type&quot;, typeName);
3897         }
3898     }
3899 
3900     /**
3901      * InvalidSymbolError error class indicating that a symbol matching a
3902      * given name does not exists in a given site.
3903      */
3904     class SymbolNotFoundError extends ResolveError {
3905 
3906         SymbolNotFoundError(Kind kind) {
3907             this(kind, &quot;symbol not found error&quot;);
3908         }
3909 
3910         SymbolNotFoundError(Kind kind, String debugName) {
3911             super(kind, debugName);
3912         }
3913 
3914         @Override
3915         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3916                 DiagnosticPosition pos,
3917                 Symbol location,
3918                 Type site,
3919                 Name name,
3920                 List&lt;Type&gt; argtypes,
3921                 List&lt;Type&gt; typeargtypes) {
3922             argtypes = argtypes == null ? List.nil() : argtypes;
3923             typeargtypes = typeargtypes == null ? List.nil() : typeargtypes;
3924             if (name == names.error)
3925                 return null;
3926 
3927             boolean hasLocation = false;
3928             if (location == null) {
3929                 location = site.tsym;
3930             }
3931             if (!location.name.isEmpty()) {
3932                 if (location.kind == PCK &amp;&amp; !site.tsym.exists()) {
3933                     return diags.create(dkind, log.currentSource(), pos,
3934                         &quot;doesnt.exist&quot;, location);
3935                 }
3936                 hasLocation = !location.name.equals(names._this) &amp;&amp;
3937                         !location.name.equals(names._super);
3938             }
3939             boolean isConstructor = name == names.init;
3940             KindName kindname = isConstructor ? KindName.CONSTRUCTOR : kind.absentKind();
3941             Name idname = isConstructor ? site.tsym.name : name;
3942             String errKey = getErrorKey(kindname, typeargtypes.nonEmpty(), hasLocation);
3943             if (hasLocation) {
3944                 return diags.create(dkind, log.currentSource(), pos,
3945                         errKey, kindname, idname, //symbol kindname, name
3946                         typeargtypes, args(argtypes), //type parameters and arguments (if any)
3947                         getLocationDiag(location, site)); //location kindname, type
3948             }
3949             else {
3950                 return diags.create(dkind, log.currentSource(), pos,
3951                         errKey, kindname, idname, //symbol kindname, name
3952                         typeargtypes, args(argtypes)); //type parameters and arguments (if any)
3953             }
3954         }
3955         //where
3956         private Object args(List&lt;Type&gt; args) {
3957             return args.isEmpty() ? args : methodArguments(args);
3958         }
3959 
3960         private String getErrorKey(KindName kindname, boolean hasTypeArgs, boolean hasLocation) {
3961             String key = &quot;cant.resolve&quot;;
3962             String suffix = hasLocation ? &quot;.location&quot; : &quot;&quot;;
3963             switch (kindname) {
3964                 case METHOD:
3965                 case CONSTRUCTOR: {
3966                     suffix += &quot;.args&quot;;
3967                     suffix += hasTypeArgs ? &quot;.params&quot; : &quot;&quot;;
3968                 }
3969             }
3970             return key + suffix;
3971         }
3972         private JCDiagnostic getLocationDiag(Symbol location, Type site) {
3973             if (location.kind == VAR) {
3974                 return diags.fragment(Fragments.Location1(kindName(location),
3975                                                           location,
3976                                                           location.type));
3977             } else {
3978                 return diags.fragment(Fragments.Location(typeKindName(site),
3979                                       site,
3980                                       null));
3981             }
3982         }
3983     }
3984 
3985     /**
3986      * InvalidSymbolError error class indicating that a given symbol
3987      * (either a method, a constructor or an operand) is not applicable
3988      * given an actual arguments/type argument list.
3989      */
3990     class InapplicableSymbolError extends ResolveError {
3991 
3992         protected MethodResolutionContext resolveContext;
3993 
3994         InapplicableSymbolError(MethodResolutionContext context) {
3995             this(WRONG_MTH, &quot;inapplicable symbol error&quot;, context);
3996         }
3997 
3998         protected InapplicableSymbolError(Kind kind, String debugName, MethodResolutionContext context) {
3999             super(kind, debugName);
4000             this.resolveContext = context;
4001         }
4002 
4003         @Override
4004         public String toString() {
4005             return super.toString();
4006         }
4007 
4008         @Override
4009         public boolean exists() {
4010             return true;
4011         }
4012 
4013         @Override
4014         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4015                 DiagnosticPosition pos,
4016                 Symbol location,
4017                 Type site,
4018                 Name name,
4019                 List&lt;Type&gt; argtypes,
4020                 List&lt;Type&gt; typeargtypes) {
4021             if (name == names.error)
4022                 return null;
4023 
4024             Pair&lt;Symbol, JCDiagnostic&gt; c = errCandidate();
4025             if (compactMethodDiags) {
4026                 JCDiagnostic simpleDiag =
4027                     MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd);
4028                 if (simpleDiag != null) {
4029                     return simpleDiag;
4030                 }
4031             }
4032             Symbol ws = c.fst.asMemberOf(site, types);
4033             return diags.create(dkind, log.currentSource(), pos,
4034                       &quot;cant.apply.symbol&quot;,
4035                       kindName(ws),
4036                       ws.name == names.init ? ws.owner.name : ws.name,
4037                       methodArguments(ws.type.getParameterTypes()),
4038                       methodArguments(argtypes),
4039                       kindName(ws.owner),
4040                       ws.owner.type,
4041                       c.snd);
4042         }
4043 
4044         @Override
4045         public Symbol access(Name name, TypeSymbol location) {
4046             Symbol sym = bestCandidate();
4047             return types.createErrorType(name, location, sym != null ? sym.type : syms.errSymbol.type).tsym;
4048         }
4049 
4050         protected Symbol bestCandidate() {
4051             return errCandidate().fst;
4052         }
4053 
4054         protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4055             Candidate bestSoFar = null;
4056             for (Candidate c : resolveContext.candidates) {
4057                 if (c.isApplicable()) continue;
4058                 bestSoFar = c;
4059             }
4060             Assert.checkNonNull(bestSoFar);
4061             return new Pair&lt;&gt;(bestSoFar.sym, bestSoFar.details);
4062         }
4063     }
4064 
4065     /**
4066      * ResolveError error class indicating that a symbol (either methods, constructors or operand)
4067      * is not applicable given an actual arguments/type argument list.
4068      */
4069     class InapplicableSymbolsError extends InapplicableSymbolError {
4070 
4071         InapplicableSymbolsError(MethodResolutionContext context) {
4072             super(WRONG_MTHS, &quot;inapplicable symbols&quot;, context);
4073         }
4074 
4075         @Override
4076         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4077                 DiagnosticPosition pos,
4078                 Symbol location,
4079                 Type site,
4080                 Name name,
4081                 List&lt;Type&gt; argtypes,
4082                 List&lt;Type&gt; typeargtypes) {
4083             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4084             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = compactMethodDiags ?
4085                     filterCandidates(candidatesMap) :
4086                     mapCandidates();
4087             if (filteredCandidates.isEmpty()) {
4088                 filteredCandidates = candidatesMap;
4089             }
4090             boolean truncatedDiag = candidatesMap.size() != filteredCandidates.size();
4091             if (filteredCandidates.size() &gt; 1) {
4092                 JCDiagnostic err = diags.create(dkind,
4093                         null,
4094                         truncatedDiag ?
4095                             EnumSet.of(DiagnosticFlag.COMPRESSED) :
4096                             EnumSet.noneOf(DiagnosticFlag.class),
4097                         log.currentSource(),
4098                         pos,
4099                         &quot;cant.apply.symbols&quot;,
4100                         name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),
4101                         name == names.init ? site.tsym.name : name,
4102                         methodArguments(argtypes));
4103                 return new JCDiagnostic.MultilineDiagnostic(err, candidateDetails(filteredCandidates, site));
4104             } else if (filteredCandidates.size() == 1) {
4105                 Map.Entry&lt;Symbol, JCDiagnostic&gt; _e =
4106                                 filteredCandidates.entrySet().iterator().next();
4107                 final Pair&lt;Symbol, JCDiagnostic&gt; p = new Pair&lt;&gt;(_e.getKey(), _e.getValue());
4108                 JCDiagnostic d = new InapplicableSymbolError(resolveContext) {
4109                     @Override
4110                     protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4111                         return p;
4112                     }
4113                 }.getDiagnostic(dkind, pos,
4114                     location, site, name, argtypes, typeargtypes);
4115                 if (truncatedDiag) {
4116                     d.setFlag(DiagnosticFlag.COMPRESSED);
4117                 }
4118                 return d;
4119             } else {
4120                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind, pos,
4121                     location, site, name, argtypes, typeargtypes);
4122             }
4123         }
4124         //where
4125             private Map&lt;Symbol, JCDiagnostic&gt; mapCandidates() {
4126                 MostSpecificMap candidates = new MostSpecificMap();
4127                 for (Candidate c : resolveContext.candidates) {
4128                     if (c.isApplicable()) continue;
4129                     candidates.put(c);
4130                 }
4131                 return candidates;
4132             }
4133 
4134             @SuppressWarnings(&quot;serial&quot;)
4135             private class MostSpecificMap extends LinkedHashMap&lt;Symbol, JCDiagnostic&gt; {
4136                 private void put(Candidate c) {
4137                     ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
4138                     for (Symbol s : keySet()) {
4139                         if (s == c.sym) {
4140                             continue;
4141                         }
4142                         if (c.sym.overrides(s, (TypeSymbol)s.owner, types, false)) {
4143                             overridden.add(s);
4144                         } else if (s.overrides(c.sym, (TypeSymbol)c.sym.owner, types, false)) {
4145                             return;
4146                         }
4147                     }
4148                     for (Symbol s : overridden) {
4149                         remove(s);
4150                     }
4151                     put(c.sym, c.details);
4152                 }
4153             }
4154 
4155             Map&lt;Symbol, JCDiagnostic&gt; filterCandidates(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap) {
4156                 Map&lt;Symbol, JCDiagnostic&gt; candidates = new LinkedHashMap&lt;&gt;();
4157                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4158                     JCDiagnostic d = _entry.getValue();
4159                     if (!new Template(MethodCheckDiag.ARITY_MISMATCH.regex()).matches(d)) {
4160                         candidates.put(_entry.getKey(), d);
4161                     }
4162                 }
4163                 return candidates;
4164             }
4165 
4166             private List&lt;JCDiagnostic&gt; candidateDetails(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap, Type site) {
4167                 List&lt;JCDiagnostic&gt; details = List.nil();
4168                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4169                     Symbol sym = _entry.getKey();
4170                     JCDiagnostic detailDiag =
4171                             diags.fragment(Fragments.InapplicableMethod(Kinds.kindName(sym),
4172                                                                         sym.location(site, types),
4173                                                                         sym.asMemberOf(site, types),
4174                                                                         _entry.getValue()));
4175                     details = details.prepend(detailDiag);
4176                 }
4177                 //typically members are visited in reverse order (see Scope)
4178                 //so we need to reverse the candidate list so that candidates
4179                 //conform to source order
4180                 return details;
4181             }
4182 
4183         @Override
4184         protected Symbol bestCandidate() {
4185             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4186             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = filterCandidates(candidatesMap);
4187             if (filteredCandidates.size() == 1) {
4188                 return filteredCandidates.keySet().iterator().next();
4189             }
4190             return null;
4191         }
4192     }
4193 
4194     /**
4195      * DiamondError error class indicating that a constructor symbol is not applicable
4196      * given an actual arguments/type argument list using diamond inference.
4197      */
4198     class DiamondError extends InapplicableSymbolError {
4199 
4200         Symbol sym;
4201 
4202         public DiamondError(Symbol sym, MethodResolutionContext context) {
4203             super(sym.kind, &quot;diamondError&quot;, context);
4204             this.sym = sym;
4205         }
4206 
4207         JCDiagnostic getDetails() {
4208             return (sym.kind == WRONG_MTH) ?
4209                     ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
4210                     null;
4211         }
4212 
4213         @Override
4214         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
4215                 Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4216             JCDiagnostic details = getDetails();
4217             if (details != null &amp;&amp; compactMethodDiags) {
4218                 JCDiagnostic simpleDiag =
4219                         MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, details);
4220                 if (simpleDiag != null) {
4221                     return simpleDiag;
4222                 }
4223             }
4224             String key = details == null ?
4225                 &quot;cant.apply.diamond&quot; :
4226                 &quot;cant.apply.diamond.1&quot;;
4227             return diags.create(dkind, log.currentSource(), pos, key,
4228                     Fragments.Diamond(site.tsym), details);
4229         }
4230     }
4231 
4232     /**
4233      * An InvalidSymbolError error class indicating that a symbol is not
4234      * accessible from a given site
4235      */
4236     class AccessError extends InvalidSymbolError {
4237 
4238         private Env&lt;AttrContext&gt; env;
4239         private Type site;
4240 
4241         AccessError(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
4242             super(HIDDEN, sym, &quot;access error&quot;);
4243             this.env = env;
4244             this.site = site;
4245         }
4246 
4247         @Override
4248         public boolean exists() {
4249             return false;
4250         }
4251 
4252         @Override
4253         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4254                 DiagnosticPosition pos,
4255                 Symbol location,
4256                 Type site,
4257                 Name name,
4258                 List&lt;Type&gt; argtypes,
4259                 List&lt;Type&gt; typeargtypes) {
4260             if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) {
4261                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind,
4262                         pos, location, site, name, argtypes, typeargtypes);
4263             }
4264             else if ((sym.flags() &amp; PUBLIC) != 0
4265                 || (env != null &amp;&amp; this.site != null
4266                     &amp;&amp; !isAccessible(env, this.site))) {
4267                 if (sym.owner.kind == PCK) {
4268                     return diags.create(dkind, log.currentSource(),
4269                             pos, &quot;not.def.access.package.cant.access&quot;,
4270                         sym, sym.location(), inaccessiblePackageReason(env, sym.packge()));
4271                 } else if (   sym.packge() != syms.rootPackage
4272                            &amp;&amp; !symbolPackageVisible(env, sym)) {
4273                     return diags.create(dkind, log.currentSource(),
4274                             pos, &quot;not.def.access.class.intf.cant.access.reason&quot;,
4275                             sym, sym.location(), sym.location().packge(),
4276                             inaccessiblePackageReason(env, sym.packge()));
4277                 } else {
4278                     return diags.create(dkind, log.currentSource(),
4279                             pos, &quot;not.def.access.class.intf.cant.access&quot;,
4280                         sym, sym.location());
4281                 }
4282             }
4283             else if ((sym.flags() &amp; (PRIVATE | PROTECTED)) != 0) {
4284                 return diags.create(dkind, log.currentSource(),
4285                         pos, &quot;report.access&quot;, sym,
4286                         asFlagSet(sym.flags() &amp; (PRIVATE | PROTECTED)),
4287                         sym.location());
4288             }
4289             else {
4290                 return diags.create(dkind, log.currentSource(),
4291                         pos, &quot;not.def.public.cant.access&quot;, sym, sym.location());
4292             }
4293         }
4294 
4295         private String toString(Type type) {
4296             StringBuilder sb = new StringBuilder();
4297             sb.append(type);
4298             if (type != null) {
4299                 sb.append(&quot;[tsym:&quot;).append(type.tsym);
4300                 if (type.tsym != null)
4301                     sb.append(&quot;packge:&quot;).append(type.tsym.packge());
4302                 sb.append(&quot;]&quot;);
4303             }
4304             return sb.toString();
4305         }
4306     }
4307 
4308     class InvisibleSymbolError extends InvalidSymbolError {
4309 
4310         private final Env&lt;AttrContext&gt; env;
4311         private final boolean suppressError;
4312 
4313         InvisibleSymbolError(Env&lt;AttrContext&gt; env, boolean suppressError, Symbol sym) {
4314             super(HIDDEN, sym, &quot;invisible class error&quot;);
4315             this.env = env;
4316             this.suppressError = suppressError;
4317             this.name = sym.name;
4318         }
4319 
4320         @Override
4321         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4322                 DiagnosticPosition pos,
4323                 Symbol location,
4324                 Type site,
4325                 Name name,
4326                 List&lt;Type&gt; argtypes,
4327                 List&lt;Type&gt; typeargtypes) {
4328             if (suppressError)
4329                 return null;
4330 
4331             if (sym.kind == PCK) {
4332                 JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4333                 return diags.create(dkind, log.currentSource(),
4334                         pos, &quot;package.not.visible&quot;, sym, details);
4335             }
4336 
4337             JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4338 
4339             if (pos.getTree() != null) {
4340                 Symbol o = sym;
4341                 JCTree tree = pos.getTree();
4342 
4343                 while (o.kind != PCK &amp;&amp; tree.hasTag(SELECT)) {
4344                     o = o.owner;
4345                     tree = ((JCFieldAccess) tree).selected;
4346                 }
4347 
4348                 if (o.kind == PCK) {
4349                     pos = tree.pos();
4350 
4351                     return diags.create(dkind, log.currentSource(),
4352                             pos, &quot;package.not.visible&quot;, o, details);
4353                 }
4354             }
4355 
4356             return diags.create(dkind, log.currentSource(),
4357                     pos, &quot;not.def.access.package.cant.access&quot;, sym, sym.packge(), details);
4358         }
4359     }
4360 
4361     JCDiagnostic inaccessiblePackageReason(Env&lt;AttrContext&gt; env, PackageSymbol sym) {
4362         //no dependency:
4363         if (!env.toplevel.modle.readModules.contains(sym.modle)) {
4364             //does not read:
4365             if (sym.modle != syms.unnamedModule) {
4366                 if (env.toplevel.modle != syms.unnamedModule) {
4367                     return diags.fragment(Fragments.NotDefAccessDoesNotRead(env.toplevel.modle,
4368                                                                             sym,
4369                                                                             sym.modle));
4370                 } else {
4371                     return diags.fragment(Fragments.NotDefAccessDoesNotReadFromUnnamed(sym,
4372                                                                                        sym.modle));
4373                 }
4374             } else {
4375                 return diags.fragment(Fragments.NotDefAccessDoesNotReadUnnamed(sym,
4376                                                                                env.toplevel.modle));
4377             }
4378         } else {
4379             if (sym.packge().modle.exports.stream().anyMatch(e -&gt; e.packge == sym)) {
4380                 //not exported to this module:
4381                 if (env.toplevel.modle != syms.unnamedModule) {
4382                     return diags.fragment(Fragments.NotDefAccessNotExportedToModule(sym,
4383                                                                                     sym.modle,
4384                                                                                     env.toplevel.modle));
4385                 } else {
4386                     return diags.fragment(Fragments.NotDefAccessNotExportedToModuleFromUnnamed(sym,
4387                                                                                                sym.modle));
4388                 }
4389             } else {
4390                 //not exported:
4391                 if (env.toplevel.modle != syms.unnamedModule) {
4392                     return diags.fragment(Fragments.NotDefAccessNotExported(sym,
4393                                                                             sym.modle));
4394                 } else {
4395                     return diags.fragment(Fragments.NotDefAccessNotExportedFromUnnamed(sym,
4396                                                                                        sym.modle));
4397                 }
4398             }
4399         }
4400     }
4401 
4402     /**
4403      * InvalidSymbolError error class indicating that an instance member
4404      * has erroneously been accessed from a static context.
4405      */
4406     class StaticError extends InvalidSymbolError {
4407 
4408         StaticError(Symbol sym) {
4409             super(STATICERR, sym, &quot;static error&quot;);
4410         }
4411 
4412         @Override
4413         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4414                 DiagnosticPosition pos,
4415                 Symbol location,
4416                 Type site,
4417                 Name name,
4418                 List&lt;Type&gt; argtypes,
4419                 List&lt;Type&gt; typeargtypes) {
4420             Symbol errSym = ((sym.kind == TYP &amp;&amp; sym.type.hasTag(CLASS))
4421                 ? types.erasure(sym.type).tsym
4422                 : sym);
4423             return diags.create(dkind, log.currentSource(), pos,
4424                     &quot;non-static.cant.be.ref&quot;, kindName(sym), errSym);
4425         }
4426     }
4427 
4428     /**
4429      * InvalidSymbolError error class indicating that a pair of symbols
4430      * (either methods, constructors or operands) are ambiguous
4431      * given an actual arguments/type argument list.
4432      */
4433     class AmbiguityError extends ResolveError {
4434 
4435         /** The other maximally specific symbol */
4436         List&lt;Symbol&gt; ambiguousSyms = List.nil();
4437 
4438         @Override
4439         public boolean exists() {
4440             return true;
4441         }
4442 
4443         AmbiguityError(Symbol sym1, Symbol sym2) {
4444             super(AMBIGUOUS, &quot;ambiguity error&quot;);
4445             ambiguousSyms = flatten(sym2).appendList(flatten(sym1));
4446         }
4447 
4448         private List&lt;Symbol&gt; flatten(Symbol sym) {
4449             if (sym.kind == AMBIGUOUS) {
4450                 return ((AmbiguityError)sym.baseSymbol()).ambiguousSyms;
4451             } else {
4452                 return List.of(sym);
4453             }
4454         }
4455 
4456         AmbiguityError addAmbiguousSymbol(Symbol s) {
4457             ambiguousSyms = ambiguousSyms.prepend(s);
4458             return this;
4459         }
4460 
4461         @Override
4462         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4463                 DiagnosticPosition pos,
4464                 Symbol location,
4465                 Type site,
4466                 Name name,
4467                 List&lt;Type&gt; argtypes,
4468                 List&lt;Type&gt; typeargtypes) {
4469             List&lt;Symbol&gt; diagSyms = ambiguousSyms.reverse();
4470             Symbol s1 = diagSyms.head;
4471             Symbol s2 = diagSyms.tail.head;
4472             Name sname = s1.name;
4473             if (sname == names.init) sname = s1.owner.name;
4474             return diags.create(dkind, log.currentSource(),
4475                     pos, &quot;ref.ambiguous&quot;, sname,
4476                     kindName(s1),
4477                     s1,
4478                     s1.location(site, types),
4479                     kindName(s2),
4480                     s2,
4481                     s2.location(site, types));
4482         }
4483 
4484         /**
4485          * If multiple applicable methods are found during overload and none of them
4486          * is more specific than the others, attempt to merge their signatures.
4487          */
4488         Symbol mergeAbstracts(Type site) {
4489             List&lt;Symbol&gt; ambiguousInOrder = ambiguousSyms.reverse();
4490             return types.mergeAbstracts(ambiguousInOrder, site, true).orElse(this);
4491         }
4492 
4493         @Override
4494         protected Symbol access(Name name, TypeSymbol location) {
4495             Symbol firstAmbiguity = ambiguousSyms.last();
4496             return firstAmbiguity.kind == TYP ?
4497                     types.createErrorType(name, location, firstAmbiguity.type).tsym :
4498                     firstAmbiguity;
4499         }
4500     }
4501 
4502     class BadVarargsMethod extends ResolveError {
4503 
4504         ResolveError delegatedError;
4505 
4506         BadVarargsMethod(ResolveError delegatedError) {
4507             super(delegatedError.kind, &quot;badVarargs&quot;);
4508             this.delegatedError = delegatedError;
4509         }
4510 
4511         @Override
4512         public Symbol baseSymbol() {
4513             return delegatedError.baseSymbol();
4514         }
4515 
4516         @Override
4517         protected Symbol access(Name name, TypeSymbol location) {
4518             return delegatedError.access(name, location);
4519         }
4520 
4521         @Override
4522         public boolean exists() {
4523             return true;
4524         }
4525 
4526         @Override
4527         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4528             return delegatedError.getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes);
4529         }
4530     }
4531 
4532     /**
4533      * BadMethodReferenceError error class indicating that a method reference symbol has been found,
4534      * but with the wrong staticness.
4535      */
4536     class BadMethodReferenceError extends StaticError {
4537 
4538         boolean unboundLookup;
4539 
4540         public BadMethodReferenceError(Symbol sym, boolean unboundLookup) {
4541             super(sym);
4542             this.unboundLookup = unboundLookup;
4543         }
4544 
4545         @Override
4546         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4547             final String key;
4548             if (!unboundLookup) {
4549                 key = &quot;bad.static.method.in.bound.lookup&quot;;
4550             } else if (sym.isStatic()) {
4551                 key = &quot;bad.static.method.in.unbound.lookup&quot;;
4552             } else {
4553                 key = &quot;bad.instance.method.in.unbound.lookup&quot;;
4554             }
4555             return sym.kind.isResolutionError() ?
4556                     ((ResolveError)sym).getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes) :
4557                     diags.create(dkind, log.currentSource(), pos, key, Kinds.kindName(sym), sym);
4558         }
4559     }
4560 
4561     /**
4562      * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,
4563      * but pointing to a class for which an enclosing instance is not available.
4564      */
4565     class BadConstructorReferenceError extends InvalidSymbolError {
4566 
4567         public BadConstructorReferenceError(Symbol sym) {
4568             super(MISSING_ENCL, sym, &quot;BadConstructorReferenceError&quot;);
4569         }
4570 
4571         @Override
4572         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4573            return diags.create(dkind, log.currentSource(), pos,
4574                 &quot;cant.access.inner.cls.constr&quot;, site.tsym.name, argtypes, site.getEnclosingType());
4575         }
4576     }
4577 
4578     class BadClassFileError extends InvalidSymbolError {
4579 
4580         private final CompletionFailure ex;
4581 
4582         public BadClassFileError(CompletionFailure ex) {
4583             super(HIDDEN, ex.sym, &quot;BadClassFileError&quot;);
4584             this.name = sym.name;
4585             this.ex = ex;
4586         }
4587 
4588         @Override
4589         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4590             JCDiagnostic d = diags.create(dkind, log.currentSource(), pos,
4591                 &quot;cant.access&quot;, ex.sym, ex.getDetailValue());
4592 
4593             d.setFlag(DiagnosticFlag.NON_DEFERRABLE);
4594             return d;
4595         }
4596 
4597     }
4598 
4599     /**
4600      * Helper class for method resolution diagnostic simplification.
4601      * Certain resolution diagnostic are rewritten as simpler diagnostic
4602      * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
4603      * is stripped away, as it doesn&#39;t carry additional info. The logic
4604      * for matching a given diagnostic is given in terms of a template
4605      * hierarchy: a diagnostic template can be specified programmatically,
4606      * so that only certain diagnostics are matched. Each templete is then
4607      * associated with a rewriter object that carries out the task of rewtiting
4608      * the diagnostic to a simpler one.
4609      */
4610     static class MethodResolutionDiagHelper {
4611 
4612         /**
4613          * A diagnostic rewriter transforms a method resolution diagnostic
4614          * into a simpler one
4615          */
4616         interface DiagnosticRewriter {
4617             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4618                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4619                     DiagnosticType preferredKind, JCDiagnostic d);
4620         }
4621 
4622         /**
4623          * A diagnostic template is made up of two ingredients: (i) a regular
4624          * expression for matching a diagnostic key and (ii) a list of sub-templates
4625          * for matching diagnostic arguments.
4626          */
4627         static class Template {
4628 
4629             /** regex used to match diag key */
4630             String regex;
4631 
4632             /** templates used to match diagnostic args */
4633             Template[] subTemplates;
4634 
4635             Template(String key, Template... subTemplates) {
4636                 this.regex = key;
4637                 this.subTemplates = subTemplates;
4638             }
4639 
4640             /**
4641              * Returns true if the regex matches the diagnostic key and if
4642              * all diagnostic arguments are matches by corresponding sub-templates.
4643              */
4644             boolean matches(Object o) {
4645                 JCDiagnostic d = (JCDiagnostic)o;
4646                 Object[] args = d.getArgs();
4647                 if (!d.getCode().matches(regex) ||
4648                         subTemplates.length != d.getArgs().length) {
4649                     return false;
4650                 }
4651                 for (int i = 0; i &lt; args.length ; i++) {
4652                     if (!subTemplates[i].matches(args[i])) {
4653                         return false;
4654                     }
4655                 }
4656                 return true;
4657             }
4658         }
4659 
4660         /**
4661          * Common rewriter for all argument mismatch simplifications.
4662          */
4663         static class ArgMismatchRewriter implements DiagnosticRewriter {
4664 
4665             /** the index of the subdiagnostic to be used as primary. */
4666             int causeIndex;
4667 
4668             public ArgMismatchRewriter(int causeIndex) {
4669                 this.causeIndex = causeIndex;
4670             }
4671 
4672             @Override
4673             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4674                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4675                     DiagnosticType preferredKind, JCDiagnostic d) {
4676                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
4677                 DiagnosticPosition pos = d.getDiagnosticPosition();
4678                 if (pos == null) {
4679                     pos = preferredPos;
4680                 }
4681                 return diags.create(preferredKind, preferredSource, pos,
4682                         &quot;prob.found.req&quot;, cause);
4683             }
4684         }
4685 
4686         /** a dummy template that match any diagnostic argument */
4687         static final Template skip = new Template(&quot;&quot;) {
4688             @Override
4689             boolean matches(Object d) {
4690                 return true;
4691             }
4692         };
4693 
4694         /** template for matching inference-free arguments mismatch failures */
4695         static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
4696 
4697         /** template for matching inference related arguments mismatch failures */
4698         static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
4699             @Override
4700             boolean matches(Object o) {
4701                 if (!super.matches(o)) {
4702                     return false;
4703                 }
4704                 JCDiagnostic d = (JCDiagnostic)o;
4705                 @SuppressWarnings(&quot;unchecked&quot;)
4706                 List&lt;Type&gt; tvars = (List&lt;Type&gt;)d.getArgs()[0];
4707                 return !containsAny(d, tvars);
4708             }
4709 
4710             BiPredicate&lt;Object, List&lt;Type&gt;&gt; containsPredicate = (o, ts) -&gt; {
4711                 if (o instanceof Type) {
4712                     return ((Type)o).containsAny(ts);
4713                 } else if (o instanceof JCDiagnostic) {
4714                     return containsAny((JCDiagnostic)o, ts);
4715                 } else {
4716                     return false;
4717                 }
4718             };
4719 
4720             boolean containsAny(JCDiagnostic d, List&lt;Type&gt; ts) {
4721                 return Stream.of(d.getArgs())
4722                         .anyMatch(o -&gt; containsPredicate.test(o, ts));
4723             }
4724         };
4725 
4726         /** rewriter map used for method resolution simplification */
4727         static final Map&lt;Template, DiagnosticRewriter&gt; rewriters = new LinkedHashMap&lt;&gt;();
4728 
4729         static {
4730             rewriters.put(argMismatchTemplate, new ArgMismatchRewriter(0));
4731             rewriters.put(inferArgMismatchTemplate, new ArgMismatchRewriter(1));
4732         }
4733 
4734         /**
4735          * Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it,
4736          * and rewrite it accordingly.
4737          */
4738         static JCDiagnostic rewrite(JCDiagnostic.Factory diags, DiagnosticPosition pos, DiagnosticSource source,
4739                                     DiagnosticType dkind, JCDiagnostic d) {
4740             for (Map.Entry&lt;Template, DiagnosticRewriter&gt; _entry : rewriters.entrySet()) {
4741                 if (_entry.getKey().matches(d)) {
4742                     JCDiagnostic simpleDiag =
4743                             _entry.getValue().rewriteDiagnostic(diags, pos, source, dkind, d);
4744                     simpleDiag.setFlag(DiagnosticFlag.COMPRESSED);
4745                     return simpleDiag;
4746                 }
4747             }
4748             return null;
4749         }
4750     }
4751 
4752     enum MethodResolutionPhase {
4753         BASIC(false, false),
4754         BOX(true, false),
4755         VARARITY(true, true) {
4756             @Override
4757             public Symbol mergeResults(Symbol bestSoFar, Symbol sym) {
4758                 //Check invariants (see {@code LookupHelper.shouldStop})
4759                 Assert.check(bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS);
4760                 if (!sym.kind.isResolutionError()) {
4761                     //varargs resolution successful
4762                     return sym;
4763                 } else {
4764                     //pick best error
4765                     switch (bestSoFar.kind) {
4766                         case WRONG_MTH:
4767                         case WRONG_MTHS:
4768                             //Override previous errors if they were caused by argument mismatch.
4769                             //This generally means preferring current symbols - but we need to pay
4770                             //attention to the fact that the varargs lookup returns &#39;less&#39; candidates
4771                             //than the previous rounds, and adjust that accordingly.
4772                             switch (sym.kind) {
4773                                 case WRONG_MTH:
4774                                     //if the previous round matched more than one method, return that
4775                                     //result instead
4776                                     return bestSoFar.kind == WRONG_MTHS ?
4777                                             bestSoFar : sym;
4778                                 case ABSENT_MTH:
4779                                     //do not override erroneous symbol if the arity lookup did not
4780                                     //match any method
4781                                     return bestSoFar;
4782                                 case WRONG_MTHS:
4783                                 default:
4784                                     //safe to override
4785                                     return sym;
4786                             }
4787                         default:
4788                             //otherwise, return first error
4789                             return bestSoFar;
4790                     }
4791                 }
4792             }
4793         };
4794 
4795         final boolean isBoxingRequired;
4796         final boolean isVarargsRequired;
4797 
4798         MethodResolutionPhase(boolean isBoxingRequired, boolean isVarargsRequired) {
4799            this.isBoxingRequired = isBoxingRequired;
4800            this.isVarargsRequired = isVarargsRequired;
4801         }
4802 
4803         public boolean isBoxingRequired() {
4804             return isBoxingRequired;
4805         }
4806 
4807         public boolean isVarargsRequired() {
4808             return isVarargsRequired;
4809         }
4810 
4811         public Symbol mergeResults(Symbol prev, Symbol sym) {
4812             return sym;
4813         }
4814     }
4815 
4816     final List&lt;MethodResolutionPhase&gt; methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
4817 
4818     /**
4819      * A resolution context is used to keep track of intermediate results of
4820      * overload resolution, such as list of method that are not applicable
4821      * (used to generate more precise diagnostics) and so on. Resolution contexts
4822      * can be nested - this means that when each overload resolution routine should
4823      * work within the resolution context it created.
4824      */
4825     class MethodResolutionContext {
4826 
4827         private List&lt;Candidate&gt; candidates = List.nil();
4828 
4829         MethodResolutionPhase step = null;
4830 
4831         MethodCheck methodCheck = resolveMethodCheck;
4832 
4833         private boolean internalResolution = false;
4834         private DeferredAttr.AttrMode attrMode = DeferredAttr.AttrMode.SPECULATIVE;
4835 
4836         void addInapplicableCandidate(Symbol sym, JCDiagnostic details) {
4837             Candidate c = new Candidate(currentResolutionContext.step, sym, details, null);
4838             candidates = candidates.append(c);
4839         }
4840 
4841         void addApplicableCandidate(Symbol sym, Type mtype) {
4842             Candidate c = new Candidate(currentResolutionContext.step, sym, null, mtype);
4843             candidates = candidates.append(c);
4844         }
4845 
4846         DeferredAttrContext deferredAttrContext(Symbol sym, InferenceContext inferenceContext, ResultInfo pendingResult, Warner warn) {
4847             DeferredAttrContext parent = (pendingResult == null)
4848                 ? deferredAttr.emptyDeferredAttrContext
4849                 : pendingResult.checkContext.deferredAttrContext();
4850             return deferredAttr.new DeferredAttrContext(attrMode, sym, step,
4851                     inferenceContext, parent, warn);
4852         }
4853 
4854         /**
4855          * This class represents an overload resolution candidate. There are two
4856          * kinds of candidates: applicable methods and inapplicable methods;
4857          * applicable methods have a pointer to the instantiated method type,
4858          * while inapplicable candidates contain further details about the
4859          * reason why the method has been considered inapplicable.
4860          */
4861         @SuppressWarnings(&quot;overrides&quot;)
4862         class Candidate {
4863 
4864             final MethodResolutionPhase step;
4865             final Symbol sym;
4866             final JCDiagnostic details;
4867             final Type mtype;
4868 
4869             private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details, Type mtype) {
4870                 this.step = step;
4871                 this.sym = sym;
4872                 this.details = details;
4873                 this.mtype = mtype;
4874             }
4875 
4876             boolean isApplicable() {
4877                 return mtype != null;
4878             }
4879         }
4880 
4881         DeferredAttr.AttrMode attrMode() {
4882             return attrMode;
4883         }
4884 
4885         boolean internal() {
4886             return internalResolution;
4887         }
4888     }
4889 
4890     MethodResolutionContext currentResolutionContext = null;
4891 }
    </pre>
  </body>
</html>