<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/DeferredAttr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  29 import com.sun.source.tree.NewClassTree;
  30 import com.sun.tools.javac.code.*;
  31 import com.sun.tools.javac.code.Type.ErrorType;
  32 import com.sun.tools.javac.code.Type.MethodType;
  33 import com.sun.tools.javac.code.Type.StructuralTypeMapping;
  34 import com.sun.tools.javac.code.Types.TypeMapping;
  35 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  36 import com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph;
  37 import com.sun.tools.javac.comp.Resolve.ResolveError;
  38 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  39 import com.sun.tools.javac.tree.*;
  40 import com.sun.tools.javac.util.*;
  41 import com.sun.tools.javac.util.DefinedBy.Api;
  42 import com.sun.tools.javac.util.GraphUtils.DependencyKind;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.comp.Attr.ResultInfo;
  45 import com.sun.tools.javac.comp.Resolve.MethodResolutionPhase;
  46 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  47 import com.sun.tools.javac.tree.JCTree.*;
  48 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  49 import com.sun.tools.javac.util.Log.DeferredDiagnosticHandler;
  50 import com.sun.tools.javac.util.Log.DiagnosticHandler;
  51 
  52 import java.util.ArrayList;
  53 import java.util.Collection;
  54 import java.util.Collections;
  55 import java.util.EnumSet;
  56 import java.util.HashSet;
  57 import java.util.LinkedHashSet;
  58 import java.util.Map;
  59 import java.util.Set;
  60 import java.util.WeakHashMap;
  61 import java.util.function.Supplier;
  62 
  63 import com.sun.source.tree.MemberReferenceTree;
  64 import com.sun.tools.javac.code.Type;
  65 import com.sun.tools.javac.tree.JCTree.JCMemberReference.OverloadKind;
  66 
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import com.sun.tools.javac.comp.Annotate.Queues;
  69 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  70 
  71 /**
  72  * This is an helper class that is used to perform deferred type-analysis.
  73  * Each time a poly expression occurs in argument position, javac attributes it
  74  * with a temporary &#39;deferred type&#39; that is checked (possibly multiple times)
  75  * against an expected formal type.
  76  *
  77  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  78  *  If you write code that depends on this, you do so at your own risk.
  79  *  This code and its internal interfaces are subject to change or
  80  *  deletion without notice.&lt;/b&gt;
  81  */
  82 public class DeferredAttr extends JCTree.Visitor {
  83     protected static final Context.Key&lt;DeferredAttr&gt; deferredAttrKey = new Context.Key&lt;&gt;();
  84 
  85     final Annotate annotate;
  86     final Attr attr;
  87     final ArgumentAttr argumentAttr;
  88     final Check chk;
  89     final JCDiagnostic.Factory diags;
  90     final Enter enter;
  91     final Infer infer;
  92     final Resolve rs;
  93     final Log log;
  94     final Symtab syms;
  95     final TreeMaker make;
  96     final TreeCopier&lt;Void&gt; treeCopier;
  97     final TypeMapping&lt;Void&gt; deferredCopier;
  98     final Types types;
  99     final Flow flow;
 100     final Names names;
 101     final TypeEnvs typeEnvs;
 102     final DeferredCompletionFailureHandler dcfh;
 103 
 104     public static DeferredAttr instance(Context context) {
 105         DeferredAttr instance = context.get(deferredAttrKey);
 106         if (instance == null)
 107             instance = new DeferredAttr(context);
 108         return instance;
 109     }
 110 
 111     protected DeferredAttr(Context context) {
 112         context.put(deferredAttrKey, this);
 113         annotate = Annotate.instance(context);
 114         attr = Attr.instance(context);
 115         argumentAttr = ArgumentAttr.instance(context);
 116         chk = Check.instance(context);
 117         diags = JCDiagnostic.Factory.instance(context);
 118         enter = Enter.instance(context);
 119         infer = Infer.instance(context);
 120         rs = Resolve.instance(context);
 121         log = Log.instance(context);
 122         syms = Symtab.instance(context);
 123         make = TreeMaker.instance(context);
 124         types = Types.instance(context);
 125         flow = Flow.instance(context);
 126         names = Names.instance(context);
 127         stuckTree = make.Ident(names.empty).setType(Type.stuckType);
 128         typeEnvs = TypeEnvs.instance(context);
 129         dcfh = DeferredCompletionFailureHandler.instance(context);
 130         emptyDeferredAttrContext =
 131             new DeferredAttrContext(AttrMode.CHECK, null, MethodResolutionPhase.BOX, infer.emptyContext, null, null) {
 132                 @Override
 133                 void addDeferredAttrNode(DeferredType dt, ResultInfo ri, DeferredStuckPolicy deferredStuckPolicy) {
 134                     Assert.error(&quot;Empty deferred context!&quot;);
 135                 }
 136                 @Override
 137                 void complete() {
 138                     Assert.error(&quot;Empty deferred context!&quot;);
 139                 }
 140 
 141                 @Override
 142                 public String toString() {
 143                     return &quot;Empty deferred context!&quot;;
 144                 }
 145             };
 146 
 147         // For speculative attribution, skip the class definition in &lt;&gt;.
 148         treeCopier =
 149             new TreeCopier&lt;Void&gt;(make) {
 150                 @Override @DefinedBy(Api.COMPILER_TREE)
 151                 public JCTree visitNewClass(NewClassTree node, Void p) {
 152                     JCNewClass t = (JCNewClass) node;
 153                     if (TreeInfo.isDiamond(t)) {
 154                         JCExpression encl = copy(t.encl, p);
 155                         List&lt;JCExpression&gt; typeargs = copy(t.typeargs, p);
 156                         JCExpression clazz = copy(t.clazz, p);
 157                         List&lt;JCExpression&gt; args = copy(t.args, p);
 158                         JCClassDecl def = null;
 159                         return make.at(t.pos).SpeculativeNewClass(encl, typeargs, clazz, args, def, t.def != null);
 160                     } else {
 161                         return super.visitNewClass(node, p);
 162                     }
 163                 }
 164 
 165                 @Override @DefinedBy(Api.COMPILER_TREE)
 166                 public JCTree visitMemberReference(MemberReferenceTree node, Void p) {
 167                     JCMemberReference t = (JCMemberReference) node;
 168                     JCExpression expr = copy(t.expr, p);
 169                     List&lt;JCExpression&gt; typeargs = copy(t.typeargs, p);
 170                     /** once the value for overloadKind is determined for a copy, it can be safely forwarded to
 171                      *  the copied tree, we want to profit from that
 172                      */
 173                     JCMemberReference result = new JCMemberReference(t.mode, t.name, expr, typeargs) {
 174                         @Override
 175                         public void setOverloadKind(OverloadKind overloadKind) {
 176                             OverloadKind previous = t.getOverloadKind();
 177                             if (previous == null || previous == OverloadKind.ERROR) {
 178                                 t.setOverloadKind(overloadKind);
 179                             } else {
 180                                 Assert.check(previous == overloadKind || overloadKind == OverloadKind.ERROR);
 181                             }
 182                         }
 183 
 184                         @Override
 185                         public OverloadKind getOverloadKind() {
 186                             return t.getOverloadKind();
 187                         }
 188                     };
 189                     result.pos = t.pos;
 190                     return result;
 191                 }
 192             };
 193         deferredCopier = new TypeMapping&lt;Void&gt; () {
 194                 @Override
 195                 public Type visitType(Type t, Void v) {
 196                     if (t.hasTag(DEFERRED)) {
 197                         DeferredType dt = (DeferredType) t;
 198                         return new DeferredType(treeCopier.copy(dt.tree), dt.env);
 199                     }
 200                     return t;
 201                 }
 202             };
 203     }
 204 
 205     /** shared tree for stuck expressions */
 206     final JCTree stuckTree;
 207 
 208     /**
 209      * This type represents a deferred type. A deferred type starts off with
 210      * no information on the underlying expression type. Such info needs to be
 211      * discovered through type-checking the deferred type against a target-type.
 212      * Every deferred type keeps a pointer to the AST node from which it originated.
 213      */
 214     public class DeferredType extends Type {
 215 
 216         public JCExpression tree;
 217         Env&lt;AttrContext&gt; env;
 218         AttrMode mode;
 219         Set&lt;Symbol&gt; notPertinentToApplicability = new HashSet&lt;&gt;();
 220         SpeculativeCache speculativeCache;
 221 
 222         DeferredType(JCExpression tree, Env&lt;AttrContext&gt; env) {
 223             super(null, TypeMetadata.EMPTY);
 224             this.tree = tree;
 225             this.env = attr.copyEnv(env);
 226             this.speculativeCache = new SpeculativeCache();
 227         }
 228 
 229         @Override
 230         public DeferredType cloneWithMetadata(TypeMetadata md) {
 231             throw new AssertionError(&quot;Cannot add metadata to a deferred type&quot;);
 232         }
 233 
 234         @Override
 235         public TypeTag getTag() {
 236             return DEFERRED;
 237         }
 238 
 239         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 240         public String toString() {
 241             return &quot;DeferredType&quot;;
 242         }
 243 
 244         /**
 245          * A speculative cache is used to keep track of all overload resolution rounds
 246          * that triggered speculative attribution on a given deferred type. Each entry
 247          * stores a pointer to the speculative tree and the resolution phase in which the entry
 248          * has been added.
 249          */
 250         class SpeculativeCache {
 251 
 252             private Map&lt;Symbol, List&lt;Entry&gt;&gt; cache = new WeakHashMap&lt;&gt;();
 253 
 254             class Entry {
 255                 JCTree speculativeTree;
 256                 ResultInfo resultInfo;
 257 
 258                 public Entry(JCTree speculativeTree, ResultInfo resultInfo) {
 259                     this.speculativeTree = speculativeTree;
 260                     this.resultInfo = resultInfo;
 261                 }
 262 
 263                 boolean matches(MethodResolutionPhase phase) {
 264                     return resultInfo.checkContext.deferredAttrContext().phase == phase;
 265                 }
 266             }
 267 
 268             /**
 269              * Retrieve a speculative cache entry corresponding to given symbol
 270              * and resolution phase
 271              */
 272             Entry get(Symbol msym, MethodResolutionPhase phase) {
 273                 List&lt;Entry&gt; entries = cache.get(msym);
 274                 if (entries == null) return null;
 275                 for (Entry e : entries) {
 276                     if (e.matches(phase)) return e;
 277                 }
 278                 return null;
 279             }
 280 
 281             /**
 282              * Stores a speculative cache entry corresponding to given symbol
 283              * and resolution phase
 284              */
 285             void put(JCTree speculativeTree, ResultInfo resultInfo) {
 286                 Symbol msym = resultInfo.checkContext.deferredAttrContext().msym;
 287                 List&lt;Entry&gt; entries = cache.get(msym);
 288                 if (entries == null) {
 289                     entries = List.nil();
 290                 }
 291                 cache.put(msym, entries.prepend(new Entry(speculativeTree, resultInfo)));
 292             }
 293         }
 294 
 295         /**
 296          * Get the type that has been computed during a speculative attribution round
 297          */
 298         Type speculativeType(Symbol msym, MethodResolutionPhase phase) {
 299             SpeculativeCache.Entry e = speculativeCache.get(msym, phase);
 300             return e != null ? e.speculativeTree.type : Type.noType;
 301         }
 302 
 303         JCTree speculativeTree(DeferredAttrContext deferredAttrContext) {
 304             DeferredType.SpeculativeCache.Entry e = speculativeCache.get(deferredAttrContext.msym, deferredAttrContext.phase);
 305             return e != null ? e.speculativeTree : stuckTree;
 306         }
 307 
 308         DeferredTypeCompleter completer() {
 309             return basicCompleter;
 310         }
 311 
 312         /**
 313          * Check a deferred type against a potential target-type. Depending on
 314          * the current attribution mode, a normal vs. speculative attribution
 315          * round is performed on the underlying AST node. There can be only one
 316          * speculative round for a given target method symbol; moreover, a normal
 317          * attribution round must follow one or more speculative rounds.
 318          */
 319         Type check(ResultInfo resultInfo) {
 320             DeferredStuckPolicy deferredStuckPolicy;
 321             if (resultInfo.pt.hasTag(NONE) || resultInfo.pt.isErroneous()) {
 322                 deferredStuckPolicy = dummyStuckPolicy;
 323             } else if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.SPECULATIVE ||
 324                     resultInfo.checkContext.deferredAttrContext().insideOverloadPhase()) {
 325                 deferredStuckPolicy = new OverloadStuckPolicy(resultInfo, this);
 326             } else {
 327                 deferredStuckPolicy = new CheckStuckPolicy(resultInfo, this);
 328             }
 329             return check(resultInfo, deferredStuckPolicy, completer());
 330         }
 331 
 332         private Type check(ResultInfo resultInfo, DeferredStuckPolicy deferredStuckPolicy,
 333                 DeferredTypeCompleter deferredTypeCompleter) {
 334             DeferredAttrContext deferredAttrContext =
 335                     resultInfo.checkContext.deferredAttrContext();
 336             Assert.check(deferredAttrContext != emptyDeferredAttrContext);
 337             if (deferredStuckPolicy.isStuck()) {
 338                 notPertinentToApplicability.add(deferredAttrContext.msym);
 339                 deferredAttrContext.addDeferredAttrNode(this, resultInfo, deferredStuckPolicy);
 340                 return Type.noType;
 341             } else {
 342                 try {
 343                     return deferredTypeCompleter.complete(this, resultInfo, deferredAttrContext);
 344                 } finally {
 345                     mode = deferredAttrContext.mode;
 346                 }
 347             }
 348         }
 349     }
 350 
 351     /**
 352      * A completer for deferred types. Defines an entry point for type-checking
 353      * a deferred type.
 354      */
 355     interface DeferredTypeCompleter {
 356         /**
 357          * Entry point for type-checking a deferred type. Depending on the
 358          * circumstances, type-checking could amount to full attribution
 359          * or partial structural check (aka potential applicability).
 360          */
 361         Type complete(DeferredType dt, ResultInfo resultInfo, DeferredAttrContext deferredAttrContext);
 362     }
 363 
 364 
 365     /**
 366      * A basic completer for deferred types. This completer type-checks a deferred type
 367      * using attribution; depending on the attribution mode, this could be either standard
 368      * or speculative attribution.
 369      */
 370     DeferredTypeCompleter basicCompleter = new DeferredTypeCompleter() {
 371         public Type complete(DeferredType dt, ResultInfo resultInfo, DeferredAttrContext deferredAttrContext) {
 372             switch (deferredAttrContext.mode) {
 373                 case SPECULATIVE:
 374                     //Note: if a symbol is imported twice we might do two identical
 375                     //speculative rounds...
 376                     Assert.check(dt.mode == null || dt.mode == AttrMode.SPECULATIVE);
 377                     JCTree speculativeTree = attribSpeculative(dt.tree, dt.env, resultInfo);
 378                     dt.speculativeCache.put(speculativeTree, resultInfo);
 379                     return speculativeTree.type;
 380                 case CHECK:
 381                     Assert.check(dt.mode != null);
 382                     return attr.attribTree(dt.tree, dt.env, resultInfo);
 383             }
 384             Assert.error();
 385             return null;
 386         }
 387     };
 388 
 389     /**
 390      * Policy for detecting stuck expressions. Different criteria might cause
 391      * an expression to be judged as stuck, depending on whether the check
 392      * is performed during overload resolution or after most specific.
 393      */
 394     interface DeferredStuckPolicy {
 395         /**
 396          * Has the policy detected that a given expression should be considered stuck?
 397          */
 398         boolean isStuck();
 399         /**
 400          * Get the set of inference variables a given expression depends upon.
 401          */
 402         Set&lt;Type&gt; stuckVars();
 403         /**
 404          * Get the set of inference variables which might get new constraints
 405          * if a given expression is being type-checked.
 406          */
 407         Set&lt;Type&gt; depVars();
 408     }
 409 
 410     /**
 411      * Basic stuck policy; an expression is never considered to be stuck.
 412      */
 413     DeferredStuckPolicy dummyStuckPolicy = new DeferredStuckPolicy() {
 414         @Override
 415         public boolean isStuck() {
 416             return false;
 417         }
 418         @Override
 419         public Set&lt;Type&gt; stuckVars() {
 420             return Collections.emptySet();
 421         }
 422         @Override
 423         public Set&lt;Type&gt; depVars() {
 424             return Collections.emptySet();
 425         }
 426     };
 427 
 428     /**
 429      * The &#39;mode&#39; in which the deferred type is to be type-checked
 430      */
 431     public enum AttrMode {
 432         /**
 433          * A speculative type-checking round is used during overload resolution
 434          * mainly to generate constraints on inference variables. Side-effects
 435          * arising from type-checking the expression associated with the deferred
 436          * type are reversed after the speculative round finishes. This means the
 437          * expression tree will be left in a blank state.
 438          */
 439         SPECULATIVE,
 440         /**
 441          * This is the plain type-checking mode. Produces side-effects on the underlying AST node
 442          */
 443         CHECK
 444     }
 445 
 446     /**
 447      * Performs speculative attribution of a lambda body and returns the speculative lambda tree,
 448      * in the absence of a target-type. Since {@link Attr#visitLambda(JCLambda)} cannot type-check
 449      * lambda bodies w/o a suitable target-type, this routine &#39;unrolls&#39; the lambda by turning it
 450      * into a regular block, speculatively type-checks the block and then puts back the pieces.
 451      */
 452     JCLambda attribSpeculativeLambda(JCLambda that, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 453         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
 454         stats.addAll(that.params);
 455         if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
 456             stats.add(make.Return((JCExpression)that.body));
 457         } else {
 458             stats.add((JCBlock)that.body);
 459         }
 460         JCBlock lambdaBlock = make.at(that.pos).Block(0, stats.toList());
 461         Env&lt;AttrContext&gt; localEnv = attr.lambdaEnv(that, env);
 462         try {
 463             localEnv.info.returnResult = resultInfo;
 464             JCBlock speculativeTree = (JCBlock)attribSpeculative(lambdaBlock, localEnv, resultInfo);
 465             List&lt;JCVariableDecl&gt; args = speculativeTree.getStatements().stream()
 466                     .filter(s -&gt; s.hasTag(Tag.VARDEF))
 467                     .map(t -&gt; (JCVariableDecl)t)
 468                     .collect(List.collector());
 469             JCTree lambdaBody = speculativeTree.getStatements().last();
 470             if (lambdaBody.hasTag(Tag.RETURN)) {
 471                 lambdaBody = ((JCReturn)lambdaBody).expr;
 472             }
 473             JCLambda speculativeLambda = make.Lambda(args, lambdaBody);
 474             attr.preFlow(speculativeLambda);
 475             flow.analyzeLambda(env, speculativeLambda, make, false);
 476             return speculativeLambda;
 477         } finally {
 478             localEnv.info.scope.leave();
 479         }
 480     }
 481 
 482     /**
 483      * Routine that performs speculative type-checking; the input AST node is
 484      * cloned (to avoid side-effects cause by Attr) and compiler state is
 485      * restored after type-checking. All diagnostics (but critical ones) are
 486      * disabled during speculative type-checking.
 487      */
 488     JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 489         return attribSpeculative(tree, env, resultInfo, treeCopier,
 490                 null, AttributionMode.SPECULATIVE, null);
 491     }
 492 
 493     JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo, LocalCacheContext localCache) {
 494         return attribSpeculative(tree, env, resultInfo, treeCopier,
 495                 null, AttributionMode.SPECULATIVE, localCache);
 496     }
 497 
 498     &lt;Z&gt; JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo, TreeCopier&lt;Z&gt; deferredCopier,
 499                                  Supplier&lt;DiagnosticHandler&gt; diagHandlerCreator, AttributionMode attributionMode,
 500                                  LocalCacheContext localCache) {
 501         final JCTree newTree = deferredCopier.copy(tree);
 502         return attribSpeculative(newTree, env, resultInfo, diagHandlerCreator, attributionMode, localCache);
 503     }
 504 
 505     /**
 506      * Attribute the given tree, mostly reverting side-effects applied to shared
 507      * compiler state. Exceptions include the ArgumentAttr.argumentTypeCache,
 508      * changes to which may be preserved if localCache is null and errors reported
 509      * outside of the speculatively attributed tree.
 510      */
 511     &lt;Z&gt; JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo,
 512                               Supplier&lt;DiagnosticHandler&gt; diagHandlerCreator, AttributionMode attributionMode,
 513                               LocalCacheContext localCache) {
 514         Env&lt;AttrContext&gt; speculativeEnv = env.dup(tree, env.info.dup(env.info.scope.dupUnshared(env.info.scope.owner)));
 515         speculativeEnv.info.attributionMode = attributionMode;
 516         Log.DiagnosticHandler deferredDiagnosticHandler = diagHandlerCreator != null ? diagHandlerCreator.get() : new DeferredAttrDiagHandler(log, tree);
 517         DeferredCompletionFailureHandler.Handler prevCFHandler = dcfh.setHandler(dcfh.speculativeCodeHandler);
 518         Queues prevQueues = annotate.setQueues(new Queues());
 519         int nwarnings = log.nwarnings;
 520         log.nwarnings = 0;
 521         try {
 522             attr.attribTree(tree, speculativeEnv, resultInfo);
 523             return tree;
 524         } finally {
 525             annotate.setQueues(prevQueues);
 526             dcfh.setHandler(prevCFHandler);
 527             log.nwarnings += nwarnings;
 528             enter.unenter(env.toplevel, tree);
 529             log.popDiagnosticHandler(deferredDiagnosticHandler);
 530             if (localCache != null) {
 531                 localCache.leave();
 532             }
 533         }
 534     }
 535     //where
 536         static class DeferredAttrDiagHandler extends Log.DeferredDiagnosticHandler {
 537 
 538             static class PosScanner extends TreeScanner {
 539                 DiagnosticPosition pos;
 540                 boolean found = false;
 541 
 542                 PosScanner(DiagnosticPosition pos) {
 543                     this.pos = pos;
 544                 }
 545 
 546                 @Override
 547                 public void scan(JCTree tree) {
 548                     if (tree != null &amp;&amp;
 549                             tree.pos() == pos) {
 550                         found = true;
 551                     }
 552                     super.scan(tree);
 553                 }
 554             }
 555 
 556             DeferredAttrDiagHandler(Log log, JCTree newTree) {
 557                 super(log, d -&gt; {
 558                     PosScanner posScanner = new PosScanner(d.getDiagnosticPosition());
 559                     posScanner.scan(newTree);
 560                     return posScanner.found;
 561                 });
 562             }
 563         }
 564 
 565     /**
 566      * A deferred context is created on each method check. A deferred context is
 567      * used to keep track of information associated with the method check, such as
 568      * the symbol of the method being checked, the overload resolution phase,
 569      * the kind of attribution mode to be applied to deferred types and so forth.
 570      * As deferred types are processed (by the method check routine) stuck AST nodes
 571      * are added (as new deferred attribution nodes) to this context. The complete()
 572      * routine makes sure that all pending nodes are properly processed, by
 573      * progressively instantiating all inference variables on which one or more
 574      * deferred attribution node is stuck.
 575      */
 576     class DeferredAttrContext {
 577 
 578         /** attribution mode */
 579         final AttrMode mode;
 580 
 581         /** symbol of the method being checked */
 582         final Symbol msym;
 583 
 584         /** method resolution step */
 585         final Resolve.MethodResolutionPhase phase;
 586 
 587         /** inference context */
 588         final InferenceContext inferenceContext;
 589 
 590         /** parent deferred context */
 591         final DeferredAttrContext parent;
 592 
 593         /** Warner object to report warnings */
 594         final Warner warn;
 595 
 596         /** list of deferred attribution nodes to be processed */
 597         ArrayList&lt;DeferredAttrNode&gt; deferredAttrNodes = new ArrayList&lt;&gt;();
 598 
 599         DeferredAttrContext(AttrMode mode, Symbol msym, MethodResolutionPhase phase,
 600                 InferenceContext inferenceContext, DeferredAttrContext parent, Warner warn) {
 601             this.mode = mode;
 602             this.msym = msym;
 603             this.phase = phase;
 604             this.parent = parent;
 605             this.warn = warn;
 606             this.inferenceContext = inferenceContext;
 607         }
 608 
 609         /**
 610          * Adds a node to the list of deferred attribution nodes - used by Resolve.rawCheckArgumentsApplicable
 611          * Nodes added this way act as &#39;roots&#39; for the out-of-order method checking process.
 612          */
 613         void addDeferredAttrNode(final DeferredType dt, ResultInfo resultInfo,
 614                 DeferredStuckPolicy deferredStuckPolicy) {
 615             deferredAttrNodes.add(new DeferredAttrNode(dt, resultInfo, deferredStuckPolicy));
 616         }
 617 
 618         /**
 619          * Incrementally process all nodes, by skipping &#39;stuck&#39; nodes and attributing
 620          * &#39;unstuck&#39; ones. If at any point no progress can be made (no &#39;unstuck&#39; nodes)
 621          * some inference variable might get eagerly instantiated so that all nodes
 622          * can be type-checked.
 623          */
 624         void complete() {
 625             while (!deferredAttrNodes.isEmpty()) {
 626                 boolean progress = false;
 627                 //scan a defensive copy of the node list - this is because a deferred
 628                 //attribution round can add new nodes to the list
 629                 for (DeferredAttrNode deferredAttrNode : List.from(deferredAttrNodes)) {
 630                     if (deferredAttrNode.process(this)) {
 631                         deferredAttrNodes.remove(deferredAttrNode);
 632                         progress = true;
 633                     }
 634                 }
 635                 if (!progress) {
 636                     if (insideOverloadPhase()) {
 637                         for (DeferredAttrNode deferredNode: deferredAttrNodes) {
 638                             deferredNode.dt.tree.type = Type.noType;
 639                         }
 640                         return;
 641                     }
 642                     //remove all variables that have already been instantiated
 643                     //from the list of stuck variables
 644                     try {
 645                         //find stuck expression to unstuck
 646                         DeferredAttrNode toUnstuck = pickDeferredNode();
 647                         inferenceContext.solveAny(List.from(toUnstuck.deferredStuckPolicy.stuckVars()), warn);
 648                         inferenceContext.notifyChange();
 649                     } catch (Infer.GraphStrategy.NodeNotFoundException ex) {
 650                         //this means that we are in speculative mode and the
 651                         //set of constraints are too tight for progress to be made.
 652                         //Just leave the remaining expressions as stuck.
 653                         break;
 654                     }
 655                 }
 656             }
 657         }
 658 
 659         public boolean insideOverloadPhase() {
 660             DeferredAttrContext dac = this;
 661             if (dac == emptyDeferredAttrContext) {
 662                 return false;
 663             }
 664             if (dac.mode == AttrMode.SPECULATIVE) {
 665                 return true;
 666             }
 667             return dac.parent.insideOverloadPhase();
 668         }
 669 
 670         /**
 671          * Pick the deferred node to be unstuck. First, deferred nodes are organized into a graph
 672          * (see {@code DeferredAttrContext.buildStuckGraph()}, where a node N1 depends on another node N2
 673          * if its input variable depends (as per the inference graph) on the output variables of N2
 674          * (see {@code DeferredAttrContext.canInfluence()}.
 675          *
 676          * Then, the chosen deferred node is the first strongly connected component containing exactly
 677          * one node found in such a graph. If no such component is found, the first deferred node is chosen.
 678          */
 679         DeferredAttrNode pickDeferredNode() {
 680             List&lt;StuckNode&gt; stuckGraph = buildStuckGraph();
 681             //compute tarjan on the stuck graph
 682             List&lt;? extends StuckNode&gt; csn = GraphUtils.tarjan(stuckGraph).get(0);
 683             return csn.length() == 1 ? csn.get(0).data : deferredAttrNodes.get(0);
 684         }
 685 
 686         List&lt;StuckNode&gt; buildStuckGraph() {
 687             //first, build inference graph
 688             infer.doIncorporation(inferenceContext, warn);
 689             InferenceGraph graph = infer.new GraphSolver(inferenceContext, types.noWarnings)
 690                     .new InferenceGraph();
 691             //then, build stuck graph
 692             List&lt;StuckNode&gt; nodes = deferredAttrNodes.stream()
 693                     .map(StuckNode::new)
 694                     .collect(List.collector());
 695             //init stuck expression graph; a deferred node A depends on a deferred node B iff
 696             //B&#39;s output variables can influence A&#39;s input variables.
 697             for (StuckNode sn1 : nodes) {
 698                 for (StuckNode sn2 : nodes) {
 699                     if (sn1 != sn2 &amp;&amp; canInfluence(graph, sn2, sn1)) {
 700                         sn1.deps.add(sn2);
 701                     }
 702                 }
 703             }
 704             return nodes;
 705         }
 706 
 707         boolean canInfluence(InferenceGraph graph, StuckNode sn1, StuckNode sn2) {
 708             Set&lt;Type&gt; outputVars = sn1.data.deferredStuckPolicy.depVars();
 709             for (Type inputVar : sn2.data.deferredStuckPolicy.stuckVars()) {
 710                 InferenceGraph.Node inputNode = graph.findNode(inputVar);
 711                 //already solved stuck vars do not appear in the graph
 712                 if (inputNode != null) {
 713                     Set&lt;InferenceGraph.Node&gt; inputClosure = inputNode.closure();
 714                     if (outputVars.stream()
 715                             .map(graph::findNode)
 716                             .anyMatch(inputClosure::contains)) {
 717                         return true;
 718                     }
 719                 }
 720             }
 721             return false;
 722         }
 723 
 724         class StuckNode extends GraphUtils.TarjanNode&lt;DeferredAttrNode, StuckNode&gt; {
 725 
 726             Set&lt;StuckNode&gt; deps = new HashSet&lt;&gt;();
 727 
 728             StuckNode(DeferredAttrNode data) {
 729                 super(data);
 730             }
 731 
 732             @Override
 733             public DependencyKind[] getSupportedDependencyKinds() {
 734                 return new DependencyKind[] { Infer.DependencyKind.STUCK };
 735             }
 736 
 737             @Override
 738             public Collection&lt;? extends StuckNode&gt; getDependenciesByKind(DependencyKind dk) {
 739                 if (dk == Infer.DependencyKind.STUCK) {
 740                     return deps;
 741                 } else {
 742                     throw new IllegalStateException();
 743                 }
 744             }
 745 
 746             @Override
 747             public Iterable&lt;? extends StuckNode&gt; getAllDependencies() {
 748                 return deps;
 749             }
 750         }
 751     }
 752 
 753     /**
 754      * Class representing a deferred attribution node. It keeps track of
 755      * a deferred type, along with the expected target type information.
 756      */
 757     class DeferredAttrNode {
 758 
 759         /** underlying deferred type */
 760         DeferredType dt;
 761 
 762         /** underlying target type information */
 763         ResultInfo resultInfo;
 764 
 765         /** stuck policy associated with this node */
 766         DeferredStuckPolicy deferredStuckPolicy;
 767 
 768         DeferredAttrNode(DeferredType dt, ResultInfo resultInfo, DeferredStuckPolicy deferredStuckPolicy) {
 769             this.dt = dt;
 770             this.resultInfo = resultInfo;
 771             this.deferredStuckPolicy = deferredStuckPolicy;
 772         }
 773 
 774         /**
 775          * Process a deferred attribution node.
 776          * Invariant: a stuck node cannot be processed.
 777          */
 778         @SuppressWarnings(&quot;fallthrough&quot;)
 779         boolean process(final DeferredAttrContext deferredAttrContext) {
 780             switch (deferredAttrContext.mode) {
 781                 case SPECULATIVE:
 782                     if (deferredStuckPolicy.isStuck()) {
 783                         dt.check(resultInfo, dummyStuckPolicy, new StructuralStuckChecker());
 784                         return true;
 785                     } else {
 786                         Assert.error(&quot;Cannot get here&quot;);
 787                     }
 788                 case CHECK:
 789                     if (deferredStuckPolicy.isStuck()) {
 790                         //stuck expression - see if we can propagate
 791                         if (deferredAttrContext.parent != emptyDeferredAttrContext &amp;&amp;
 792                                 Type.containsAny(deferredAttrContext.parent.inferenceContext.inferencevars,
 793                                         List.from(deferredStuckPolicy.stuckVars()))) {
 794                             deferredAttrContext.parent.addDeferredAttrNode(dt,
 795                                     resultInfo.dup(new Check.NestedCheckContext(resultInfo.checkContext) {
 796                                 @Override
 797                                 public InferenceContext inferenceContext() {
 798                                     return deferredAttrContext.parent.inferenceContext;
 799                                 }
 800                                 @Override
 801                                 public DeferredAttrContext deferredAttrContext() {
 802                                     return deferredAttrContext.parent;
 803                                 }
 804                             }), deferredStuckPolicy);
 805                             dt.tree.type = Type.stuckType;
 806                             return true;
 807                         } else {
 808                             return false;
 809                         }
 810                     } else {
 811                         Assert.check(!deferredAttrContext.insideOverloadPhase(),
 812                                 &quot;attribution shouldn&#39;t be happening here&quot;);
 813                         ResultInfo instResultInfo =
 814                                 resultInfo.dup(deferredAttrContext.inferenceContext.asInstType(resultInfo.pt));
 815                         dt.check(instResultInfo, dummyStuckPolicy, basicCompleter);
 816                         return true;
 817                     }
 818                 default:
 819                     throw new AssertionError(&quot;Bad mode&quot;);
 820             }
 821         }
 822 
 823         /**
 824          * Structural checker for stuck expressions
 825          */
 826         class StructuralStuckChecker extends TreeScanner implements DeferredTypeCompleter {
 827 
 828             ResultInfo resultInfo;
 829             InferenceContext inferenceContext;
 830             Env&lt;AttrContext&gt; env;
 831 
 832             public Type complete(DeferredType dt, ResultInfo resultInfo, DeferredAttrContext deferredAttrContext) {
 833                 this.resultInfo = resultInfo;
 834                 this.inferenceContext = deferredAttrContext.inferenceContext;
 835                 this.env = dt.env;
 836                 dt.tree.accept(this);
 837                 dt.speculativeCache.put(stuckTree, resultInfo);
 838                 return Type.noType;
 839             }
 840 
 841             @Override
 842             public void visitLambda(JCLambda tree) {
 843                 Check.CheckContext checkContext = resultInfo.checkContext;
 844                 Type pt = resultInfo.pt;
 845                 if (!inferenceContext.inferencevars.contains(pt)) {
 846                     //must be a functional descriptor
 847                     Type descriptorType = null;
 848                     try {
 849                         descriptorType = types.findDescriptorType(pt);
 850                     } catch (Types.FunctionDescriptorLookupError ex) {
 851                         checkContext.report(null, ex.getDiagnostic());
 852                     }
 853 
 854                     if (descriptorType.getParameterTypes().length() != tree.params.length()) {
 855                         checkContext.report(tree,
 856                                 diags.fragment(Fragments.IncompatibleArgTypesInLambda));
 857                     }
 858 
 859                     Type currentReturnType = descriptorType.getReturnType();
 860                     boolean returnTypeIsVoid = currentReturnType.hasTag(VOID);
 861                     if (tree.getBodyKind() == BodyKind.EXPRESSION) {
 862                         boolean isExpressionCompatible = !returnTypeIsVoid ||
 863                             TreeInfo.isExpressionStatement((JCExpression)tree.getBody());
 864                         if (!isExpressionCompatible) {
 865                             resultInfo.checkContext.report(tree.pos(),
 866                                 diags.fragment(Fragments.IncompatibleRetTypeInLambda(Fragments.MissingRetVal(currentReturnType))));
 867                         }
 868                     } else {
 869                         LambdaBodyStructChecker lambdaBodyChecker =
 870                                 new LambdaBodyStructChecker();
 871 
 872                         tree.body.accept(lambdaBodyChecker);
 873                         boolean isVoidCompatible = lambdaBodyChecker.isVoidCompatible;
 874 
 875                         if (returnTypeIsVoid) {
 876                             if (!isVoidCompatible) {
 877                                 resultInfo.checkContext.report(tree.pos(),
 878                                     diags.fragment(Fragments.UnexpectedRetVal));
 879                             }
 880                         } else {
 881                             boolean isValueCompatible = lambdaBodyChecker.isPotentiallyValueCompatible
 882                                 &amp;&amp; !canLambdaBodyCompleteNormally(tree);
 883                             if (!isValueCompatible &amp;&amp; !isVoidCompatible) {
 884                                 log.error(tree.body.pos(),
 885                                           Errors.LambdaBodyNeitherValueNorVoidCompatible);
 886                             }
 887 
 888                             if (!isValueCompatible) {
 889                                 resultInfo.checkContext.report(tree.pos(),
 890                                     diags.fragment(Fragments.IncompatibleRetTypeInLambda(Fragments.MissingRetVal(currentReturnType))));
 891                             }
 892                         }
 893                     }
 894                 }
 895             }
 896 
 897             boolean canLambdaBodyCompleteNormally(JCLambda tree) {
 898                 List&lt;JCVariableDecl&gt; oldParams = tree.params;
 899                 LocalCacheContext localCacheContext = argumentAttr.withLocalCacheContext();
 900                 try {
 901                     tree.params = tree.params.stream()
 902                             .map(vd -&gt; make.VarDef(vd.mods, vd.name, make.Erroneous(), null))
 903                             .collect(List.collector());
 904                     return attribSpeculativeLambda(tree, env, attr.unknownExprInfo).canCompleteNormally;
 905                 } finally {
 906                     localCacheContext.leave();
 907                     tree.params = oldParams;
 908                 }
 909             }
 910 
 911             @Override
 912             public void visitNewClass(JCNewClass tree) {
 913                 //do nothing
 914             }
 915 
 916             @Override
 917             public void visitApply(JCMethodInvocation tree) {
 918                 //do nothing
 919             }
 920 
 921             @Override
<a name="1" id="anc1"></a><span class="line-added"> 922             public void visitConditional(JCTree.JCConditional tree) {</span>
<span class="line-added"> 923                 //skip tree.cond</span>
<span class="line-added"> 924                 scan(tree.truepart);</span>
<span class="line-added"> 925                 scan(tree.falsepart);</span>
<span class="line-added"> 926             }</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928             @Override</span>
 929             public void visitReference(JCMemberReference tree) {
 930                 Assert.checkNonNull(tree.getOverloadKind());
 931                 Check.CheckContext checkContext = resultInfo.checkContext;
 932                 Type pt = resultInfo.pt;
 933                 if (!inferenceContext.inferencevars.contains(pt)) {
 934                     Type descriptor = null;
 935                     try {
 936                         descriptor = types.findDescriptorType(pt);
 937                     } catch (Types.FunctionDescriptorLookupError ex) {
 938                         checkContext.report(null, ex.getDiagnostic());
 939                     }
 940                     Env&lt;AttrContext&gt; localEnv = env.dup(tree);
 941                     JCExpression exprTree;
 942                     exprTree = (JCExpression)attribSpeculative(tree.getQualifierExpression(), localEnv,
 943                             attr.memberReferenceQualifierResult(tree), argumentAttr.withLocalCacheContext());
 944                     ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();
 945                     for (Type t : descriptor.getParameterTypes()) {
 946                         argtypes.append(Type.noType);
 947                     }
 948                     JCMemberReference mref2 = new TreeCopier&lt;Void&gt;(make).copy(tree);
 949                     mref2.expr = exprTree;
 950                     Symbol lookupSym =
 951                             rs.resolveMemberReference(localEnv, mref2, exprTree.type,
 952                                     tree.name, argtypes.toList(), List.nil(), descriptor, rs.arityMethodCheck,
 953                                     inferenceContext, rs.structuralReferenceChooser).fst;
 954                     switch (lookupSym.kind) {
 955                         case WRONG_MTH:
 956                         case WRONG_MTHS:
 957                             //note: as argtypes are erroneous types, type-errors must
 958                             //have been caused by arity mismatch
 959                             checkContext.report(tree, diags.fragment(Fragments.IncompatibleArgTypesInMref));
 960                             break;
 961                         case ABSENT_MTH:
 962                         case STATICERR:
 963                             //if no method found, or method found with wrong staticness, report better message
 964                             checkContext.report(tree, ((ResolveError)lookupSym).getDiagnostic(DiagnosticType.FRAGMENT,
 965                                     tree, exprTree.type.tsym, exprTree.type, tree.name, argtypes.toList(), List.nil()));
 966                             break;
 967                     }
 968                 }
 969             }
 970         }
 971 
 972         /* This visitor looks for return statements, its analysis will determine if
 973          * a lambda body is void or value compatible. We must analyze return
 974          * statements contained in the lambda body only, thus any return statement
 975          * contained in an inner class or inner lambda body, should be ignored.
 976          */
 977         class LambdaBodyStructChecker extends TreeScanner {
 978             boolean isVoidCompatible = true;
 979             boolean isPotentiallyValueCompatible = true;
 980 
 981             @Override
 982             public void visitClassDef(JCClassDecl tree) {
 983                 // do nothing
 984             }
 985 
 986             @Override
 987             public void visitLambda(JCLambda tree) {
 988                 // do nothing
 989             }
 990 
 991             @Override
 992             public void visitNewClass(JCNewClass tree) {
 993                 // do nothing
 994             }
 995 
 996             @Override
 997             public void visitReturn(JCReturn tree) {
 998                 if (tree.expr != null) {
 999                     isVoidCompatible = false;
1000                 } else {
1001                     isPotentiallyValueCompatible = false;
1002                 }
1003             }
1004         }
1005     }
1006 
1007     /** an empty deferred attribution context - all methods throw exceptions */
1008     final DeferredAttrContext emptyDeferredAttrContext;
1009 
1010     /**
1011      * Map a list of types possibly containing one or more deferred types
1012      * into a list of ordinary types. Each deferred type D is mapped into a type T,
1013      * where T is computed by retrieving the type that has already been
1014      * computed for D during a previous deferred attribution round of the given kind.
1015      */
1016     class DeferredTypeMap&lt;T&gt; extends StructuralTypeMapping&lt;T&gt; {
1017         DeferredAttrContext deferredAttrContext;
1018 
1019         protected DeferredTypeMap(AttrMode mode, Symbol msym, MethodResolutionPhase phase) {
1020             this.deferredAttrContext = new DeferredAttrContext(mode, msym, phase,
1021                     infer.emptyContext, emptyDeferredAttrContext, types.noWarnings);
1022         }
1023 
1024         @Override
1025         public Type visitType(Type t, T p) {
1026             if (!t.hasTag(DEFERRED)) {
1027                 return super.visitType(t, p);
1028             } else {
1029                 DeferredType dt = (DeferredType)t;
1030                 return typeOf(dt, p);
1031             }
1032         }
1033 
1034         protected Type typeOf(DeferredType dt, T p) {
1035             switch (deferredAttrContext.mode) {
1036                 case CHECK:
1037                     return dt.tree.type == null ? Type.noType : dt.tree.type;
1038                 case SPECULATIVE:
1039                     return dt.speculativeType(deferredAttrContext.msym, deferredAttrContext.phase);
1040             }
1041             Assert.error();
1042             return null;
1043         }
1044     }
1045 
1046     /**
1047      * Specialized recovery deferred mapping.
1048      * Each deferred type D is mapped into a type T, where T is computed either by
1049      * (i) retrieving the type that has already been computed for D during a previous
1050      * attribution round (as before), or (ii) by synthesizing a new type R for D
1051      * (the latter step is useful in a recovery scenario).
1052      */
1053     public class RecoveryDeferredTypeMap extends DeferredTypeMap&lt;Type&gt; {
1054 
1055         public RecoveryDeferredTypeMap(AttrMode mode, Symbol msym, MethodResolutionPhase phase) {
1056             super(mode, msym, phase != null ? phase : MethodResolutionPhase.BOX);
1057         }
1058 
1059         @Override
1060         protected Type typeOf(DeferredType dt, Type pt) {
1061             Type owntype = super.typeOf(dt, pt);
1062             return owntype == Type.noType ?
1063                         recover(dt, pt) : owntype;
1064         }
1065 
1066         @Override
1067         public Type visitMethodType(Type.MethodType t, Type pt) {
1068             if (t.hasTag(METHOD) &amp;&amp; deferredAttrContext.mode == AttrMode.CHECK) {
1069                 Type mtype = deferredAttrContext.msym.type;
1070                 mtype = mtype.hasTag(ERROR) ? ((ErrorType)mtype).getOriginalType() : null;
1071                 if (mtype != null &amp;&amp; mtype.hasTag(METHOD)) {
1072                     List&lt;Type&gt; argtypes1 = map(t.getParameterTypes(), mtype.getParameterTypes());
1073                     Type restype1 = visit(t.getReturnType(), mtype.getReturnType());
1074                     List&lt;Type&gt; thrown1 = map(t.getThrownTypes(), mtype.getThrownTypes());
1075                     if (argtypes1 == t.getParameterTypes() &amp;&amp;
1076                         restype1 == t.getReturnType() &amp;&amp;
1077                         thrown1 == t.getThrownTypes()) return t;
1078                     else return new MethodType(argtypes1, restype1, thrown1, t.tsym);
1079                 }
1080             }
1081             return super.visitMethodType(t, pt);
1082         }
1083 
1084         /**
1085          * Synthesize a type for a deferred type that hasn&#39;t been previously
1086          * reduced to an ordinary type. Functional deferred types and conditionals
1087          * are mapped to themselves, in order to have a richer diagnostic
1088          * representation. Remaining deferred types are attributed using
1089          * a default expected type (j.l.Object).
1090          */
1091         private Type recover(DeferredType dt, Type pt) {
1092             boolean isLambdaOrMemberRef =
1093                     dt.tree.hasTag(REFERENCE) || dt.tree.hasTag(LAMBDA);
1094             boolean needsRecoveryType =
1095                     pt == null || (isLambdaOrMemberRef &amp;&amp; !types.isFunctionalInterface(pt));
1096             Type ptRecovery = needsRecoveryType ? Type.recoveryType: pt;
1097             dt.check(attr.new RecoveryInfo(deferredAttrContext, ptRecovery) {
1098                 @Override
1099                 protected Type check(DiagnosticPosition pos, Type found) {
1100                     return chk.checkNonVoid(pos, super.check(pos, found));
1101                 }
1102             });
1103             return super.visit(dt);
1104         }
1105 
1106         private List&lt;Type&gt; map(List&lt;Type&gt; ts, List&lt;Type&gt; pts) {
1107             if (ts.nonEmpty()) {
1108                 List&lt;Type&gt; tail1 = map(ts.tail, pts != null ? pts.tail : null);
1109                 Type t = visit(ts.head, pts != null &amp;&amp; pts.nonEmpty() ? pts.head : null);
1110                 if (tail1 != ts.tail || t != ts.head)
1111                     return tail1.prepend(t);
1112             }
1113             return ts;
1114         }
1115     }
1116 
1117     /**
1118      * A special tree scanner that would only visit portions of a given tree.
1119      * The set of nodes visited by the scanner can be customized at construction-time.
1120      */
1121     abstract static class FilterScanner extends com.sun.tools.javac.tree.TreeScanner {
1122 
1123         final Filter&lt;JCTree&gt; treeFilter;
1124 
1125         FilterScanner(final Set&lt;JCTree.Tag&gt; validTags) {
1126             this.treeFilter = t -&gt; validTags.contains(t.getTag());
1127         }
1128 
1129         @Override
1130         public void scan(JCTree tree) {
1131             if (tree != null) {
1132                 if (treeFilter.accepts(tree)) {
1133                     super.scan(tree);
1134                 } else {
1135                     skip(tree);
1136                 }
1137             }
1138         }
1139 
1140         /**
1141          * handler that is executed when a node has been discarded
1142          */
1143         void skip(JCTree tree) {}
1144     }
1145 
1146     /**
1147      * A tree scanner suitable for visiting the target-type dependent nodes of
1148      * a given argument expression.
1149      */
1150     static class PolyScanner extends FilterScanner {
1151 
1152         PolyScanner() {
1153             super(EnumSet.of(CONDEXPR, PARENS, LAMBDA, REFERENCE));
1154         }
1155     }
1156 
1157     /**
1158      * A tree scanner suitable for visiting the target-type dependent nodes nested
1159      * within a lambda expression body.
1160      */
1161     static class LambdaReturnScanner extends FilterScanner {
1162 
1163         LambdaReturnScanner() {
1164             super(EnumSet.of(BLOCK, CASE, CATCH, DOLOOP, FOREACHLOOP,
1165                     FORLOOP, IF, RETURN, SYNCHRONIZED, SWITCH, TRY, WHILELOOP));
1166         }
1167     }
1168 
1169     /**
1170      * A tree scanner suitable for visiting the target-type dependent nodes nested
1171      * within a switch expression body.
1172      */
1173     static class SwitchExpressionScanner extends FilterScanner {
1174 
1175         SwitchExpressionScanner() {
1176             super(EnumSet.of(BLOCK, CASE, CATCH, DOLOOP, FOREACHLOOP,
1177                     FORLOOP, IF, SYNCHRONIZED, SWITCH, TRY, WHILELOOP, YIELD));
1178         }
1179     }
1180 
1181     /**
1182      * This visitor is used to check that structural expressions conform
1183      * to their target - this step is required as inference could end up
1184      * inferring types that make some of the nested expressions incompatible
1185      * with their corresponding instantiated target
1186      */
1187     class CheckStuckPolicy extends PolyScanner implements DeferredStuckPolicy, Infer.FreeTypeListener {
1188 
1189         Type pt;
1190         InferenceContext inferenceContext;
1191         Set&lt;Type&gt; stuckVars = new LinkedHashSet&lt;&gt;();
1192         Set&lt;Type&gt; depVars = new LinkedHashSet&lt;&gt;();
1193 
1194         @Override
1195         public boolean isStuck() {
1196             return !stuckVars.isEmpty();
1197         }
1198 
1199         @Override
1200         public Set&lt;Type&gt; stuckVars() {
1201             return stuckVars;
1202         }
1203 
1204         @Override
1205         public Set&lt;Type&gt; depVars() {
1206             return depVars;
1207         }
1208 
1209         public CheckStuckPolicy(ResultInfo resultInfo, DeferredType dt) {
1210             this.pt = resultInfo.pt;
1211             this.inferenceContext = resultInfo.checkContext.inferenceContext();
1212             scan(dt.tree);
1213             if (!stuckVars.isEmpty()) {
1214                 resultInfo.checkContext.inferenceContext()
1215                         .addFreeTypeListener(List.from(stuckVars), this);
1216             }
1217         }
1218 
1219         @Override
1220         public void typesInferred(InferenceContext inferenceContext) {
1221             stuckVars.clear();
1222         }
1223 
1224         @Override
1225         public void visitLambda(JCLambda tree) {
1226             if (inferenceContext.inferenceVars().contains(pt)) {
1227                 stuckVars.add(pt);
1228             }
1229             if (!types.isFunctionalInterface(pt)) {
1230                 return;
1231             }
1232             Type descType = types.findDescriptorType(pt);
1233             List&lt;Type&gt; freeArgVars = inferenceContext.freeVarsIn(descType.getParameterTypes());
1234             if (tree.paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1235                     freeArgVars.nonEmpty()) {
1236                 stuckVars.addAll(freeArgVars);
1237                 depVars.addAll(inferenceContext.freeVarsIn(descType.getReturnType()));
1238             }
1239             scanLambdaBody(tree, descType.getReturnType());
1240         }
1241 
1242         @Override
1243         public void visitReference(JCMemberReference tree) {
1244             scan(tree.expr);
1245             if (inferenceContext.inferenceVars().contains(pt)) {
1246                 stuckVars.add(pt);
1247                 return;
1248             }
1249             if (!types.isFunctionalInterface(pt)) {
1250                 return;
1251             }
1252 
1253             Type descType = types.findDescriptorType(pt);
1254             List&lt;Type&gt; freeArgVars = inferenceContext.freeVarsIn(descType.getParameterTypes());
1255             if (freeArgVars.nonEmpty() &amp;&amp;
1256                     tree.getOverloadKind() != JCMemberReference.OverloadKind.UNOVERLOADED) {
1257                 stuckVars.addAll(freeArgVars);
1258                 depVars.addAll(inferenceContext.freeVarsIn(descType.getReturnType()));
1259             }
1260         }
1261 
1262         void scanLambdaBody(JCLambda lambda, final Type pt) {
1263             if (lambda.getBodyKind() == JCTree.JCLambda.BodyKind.EXPRESSION) {
1264                 Type prevPt = this.pt;
1265                 try {
1266                     this.pt = pt;
1267                     scan(lambda.body);
1268                 } finally {
1269                     this.pt = prevPt;
1270                 }
1271             } else {
1272                 LambdaReturnScanner lambdaScanner = new LambdaReturnScanner() {
1273                     @Override
1274                     public void visitReturn(JCReturn tree) {
1275                         if (tree.expr != null) {
1276                             Type prevPt = CheckStuckPolicy.this.pt;
1277                             try {
1278                                 CheckStuckPolicy.this.pt = pt;
1279                                 CheckStuckPolicy.this.scan(tree.expr);
1280                             } finally {
1281                                 CheckStuckPolicy.this.pt = prevPt;
1282                             }
1283                         }
1284                     }
1285                 };
1286                 lambdaScanner.scan(lambda.body);
1287             }
1288         }
1289     }
1290 
1291     /**
1292      * This visitor is used to check that structural expressions conform
1293      * to their target - this step is required as inference could end up
1294      * inferring types that make some of the nested expressions incompatible
1295      * with their corresponding instantiated target
1296      */
1297     class OverloadStuckPolicy extends CheckStuckPolicy implements DeferredStuckPolicy {
1298 
1299         boolean stuck;
1300 
1301         @Override
1302         public boolean isStuck() {
1303             return super.isStuck() || stuck;
1304         }
1305 
1306         public OverloadStuckPolicy(ResultInfo resultInfo, DeferredType dt) {
1307             super(resultInfo, dt);
1308         }
1309 
1310         @Override
1311         public void visitLambda(JCLambda tree) {
1312             super.visitLambda(tree);
1313             if (tree.paramKind == JCLambda.ParameterKind.IMPLICIT) {
1314                 stuck = true;
1315             }
1316         }
1317 
1318         @Override
1319         public void visitReference(JCMemberReference tree) {
1320             super.visitReference(tree);
1321             if (tree.getOverloadKind() != JCMemberReference.OverloadKind.UNOVERLOADED) {
1322                 stuck = true;
1323             }
1324         }
1325     }
1326 
1327     /**
1328      * Mode of attribution (used in AttrContext).
1329      */
1330     enum AttributionMode {
1331         /**Normal, non-speculative, attribution.*/
1332         FULL(false),
1333         /**Speculative attribution on behalf of an Analyzer.*/
1334         ANALYZER(true),
1335         /**Speculative attribution.*/
1336         SPECULATIVE(true);
1337 
1338         AttributionMode(boolean isSpeculative) {
1339             this.isSpeculative = isSpeculative;
1340         }
1341 
1342         boolean isSpeculative() {
1343             return isSpeculative;
1344         }
1345 
1346         final boolean isSpeculative;
1347     }
1348 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>