<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.tools.javac.api.Formattable.LocalizedString;
  29 import com.sun.tools.javac.code.*;
  30 import com.sun.tools.javac.code.Scope.WriteableScope;
  31 import com.sun.tools.javac.code.Source.Feature;
  32 import com.sun.tools.javac.code.Symbol.*;
  33 import com.sun.tools.javac.code.Type.*;
  34 import com.sun.tools.javac.comp.Attr.ResultInfo;
  35 import com.sun.tools.javac.comp.Check.CheckContext;
  36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
  39 import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
  40 import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
  41 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  42 import com.sun.tools.javac.jvm.*;
  43 import com.sun.tools.javac.main.Option;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  46 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  47 import com.sun.tools.javac.tree.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  50 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  51 import com.sun.tools.javac.util.*;
  52 import com.sun.tools.javac.util.DefinedBy.Api;
  53 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  55 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  56 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  57 
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.EnumSet;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.Map;
  65 import java.util.Set;
  66 import java.util.function.BiFunction;
  67 import java.util.function.BiPredicate;
  68 import java.util.function.Consumer;
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.stream.Stream;
  72 
  73 import javax.lang.model.element.ElementVisitor;
  74 
  75 import static com.sun.tools.javac.code.Flags.*;
  76 import static com.sun.tools.javac.code.Flags.BLOCK;
  77 import static com.sun.tools.javac.code.Flags.STATIC;
  78 import static com.sun.tools.javac.code.Kinds.*;
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 import static com.sun.tools.javac.code.TypeTag.*;
  81 import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
  82 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  83 import static com.sun.tools.javac.util.Iterators.createCompoundIterator;
  84 
  85 /** Helper class for name resolution, used mostly by the attribution phase.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class Resolve {
  93     protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
  94 
  95     Names names;
  96     Log log;
  97     Symtab syms;
  98     Attr attr;
  99     DeferredAttr deferredAttr;
 100     Check chk;
 101     Infer infer;
 102     ClassFinder finder;
 103     ModuleFinder moduleFinder;
 104     Types types;
 105     JCDiagnostic.Factory diags;
 106     public final boolean allowFunctionalInterfaceMostSpecific;
 107     public final boolean allowModules;
 108     public final boolean allowRecords;
 109     public final boolean checkVarargsAccessAfterResolution;
 110     private final boolean compactMethodDiags;
 111     private final boolean allowLocalVariableTypeInference;
 112     private final boolean allowYieldStatement;
 113     final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
 114 
 115     WriteableScope polymorphicSignatureScope;
 116 
 117     protected Resolve(Context context) {
 118         context.put(resolveKey, this);
 119         syms = Symtab.instance(context);
 120 
 121         varNotFound = new SymbolNotFoundError(ABSENT_VAR);
 122         methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
 123         typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
 124         referenceNotFound = ReferenceLookupResult.error(methodNotFound);
 125 
 126         names = Names.instance(context);
 127         log = Log.instance(context);
 128         attr = Attr.instance(context);
 129         deferredAttr = DeferredAttr.instance(context);
 130         chk = Check.instance(context);
 131         infer = Infer.instance(context);
 132         finder = ClassFinder.instance(context);
 133         moduleFinder = ModuleFinder.instance(context);
 134         types = Types.instance(context);
 135         diags = JCDiagnostic.Factory.instance(context);
 136         Preview preview = Preview.instance(context);
 137         Source source = Source.instance(context);
 138         Options options = Options.instance(context);
 139         compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
 140                 options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
 141         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
 142         Target target = Target.instance(context);
 143         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
 144         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
 145         allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 146                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 147         checkVarargsAccessAfterResolution =
 148                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
 149         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
 150         allowModules = Feature.MODULES.allowedInSource(source);
 151         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 152                 Feature.RECORDS.allowedInSource(source);
 153     }
 154 
 155     /** error symbols, which are returned when resolution fails
 156      */
 157     private final SymbolNotFoundError varNotFound;
 158     private final SymbolNotFoundError methodNotFound;
 159     private final SymbolNotFoundError typeNotFound;
 160 
 161     /** empty reference lookup result */
 162     private final ReferenceLookupResult referenceNotFound;
 163 
 164     public static Resolve instance(Context context) {
 165         Resolve instance = context.get(resolveKey);
 166         if (instance == null)
 167             instance = new Resolve(context);
 168         return instance;
 169     }
 170 
 171     private static Symbol bestOf(Symbol s1,
 172                                  Symbol s2) {
 173         return s1.kind.betterThan(s2.kind) ? s1 : s2;
 174     }
 175 
 176     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Verbose resolution diagnostics support&quot;&gt;
 177     enum VerboseResolutionMode {
 178         SUCCESS(&quot;success&quot;),
 179         FAILURE(&quot;failure&quot;),
 180         APPLICABLE(&quot;applicable&quot;),
 181         INAPPLICABLE(&quot;inapplicable&quot;),
 182         DEFERRED_INST(&quot;deferred-inference&quot;),
 183         PREDEF(&quot;predef&quot;),
 184         OBJECT_INIT(&quot;object-init&quot;),
 185         INTERNAL(&quot;internal&quot;);
 186 
 187         final String opt;
 188 
 189         private VerboseResolutionMode(String opt) {
 190             this.opt = opt;
 191         }
 192 
 193         static EnumSet&lt;VerboseResolutionMode&gt; getVerboseResolutionMode(Options opts) {
 194             String s = opts.get(&quot;debug.verboseResolution&quot;);
 195             EnumSet&lt;VerboseResolutionMode&gt; res = EnumSet.noneOf(VerboseResolutionMode.class);
 196             if (s == null) return res;
 197             if (s.contains(&quot;all&quot;)) {
 198                 res = EnumSet.allOf(VerboseResolutionMode.class);
 199             }
 200             Collection&lt;String&gt; args = Arrays.asList(s.split(&quot;,&quot;));
 201             for (VerboseResolutionMode mode : values()) {
 202                 if (args.contains(mode.opt)) {
 203                     res.add(mode);
 204                 } else if (args.contains(&quot;-&quot; + mode.opt)) {
 205                     res.remove(mode);
 206                 }
 207             }
 208             return res;
 209         }
 210     }
 211 
 212     void reportVerboseResolutionDiagnostic(DiagnosticPosition dpos, Name name, Type site,
 213             List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, Symbol bestSoFar) {
 214         boolean success = !bestSoFar.kind.isResolutionError();
 215 
 216         if (success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.SUCCESS)) {
 217             return;
 218         } else if (!success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.FAILURE)) {
 219             return;
 220         }
 221 
 222         if (bestSoFar.name == names.init &amp;&amp;
 223                 bestSoFar.owner == syms.objectType.tsym &amp;&amp;
 224                 !verboseResolutionMode.contains(VerboseResolutionMode.OBJECT_INIT)) {
 225             return; //skip diags for Object constructor resolution
 226         } else if (site == syms.predefClass.type &amp;&amp;
 227                 !verboseResolutionMode.contains(VerboseResolutionMode.PREDEF)) {
 228             return; //skip spurious diags for predef symbols (i.e. operators)
 229         } else if (currentResolutionContext.internalResolution &amp;&amp;
 230                 !verboseResolutionMode.contains(VerboseResolutionMode.INTERNAL)) {
 231             return;
 232         }
 233 
 234         int pos = 0;
 235         int mostSpecificPos = -1;
 236         ListBuffer&lt;JCDiagnostic&gt; subDiags = new ListBuffer&lt;&gt;();
 237         for (Candidate c : currentResolutionContext.candidates) {
 238             if (currentResolutionContext.step != c.step ||
 239                     (c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.APPLICABLE)) ||
 240                     (!c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.INAPPLICABLE))) {
 241                 continue;
 242             } else {
 243                 subDiags.append(c.isApplicable() ?
 244                         getVerboseApplicableCandidateDiag(pos, c.sym, c.mtype) :
 245                         getVerboseInapplicableCandidateDiag(pos, c.sym, c.details));
 246                 if (c.sym == bestSoFar)
 247                     mostSpecificPos = pos;
 248                 pos++;
 249             }
 250         }
 251         String key = success ? &quot;verbose.resolve.multi&quot; : &quot;verbose.resolve.multi.1&quot;;
 252         List&lt;Type&gt; argtypes2 = argtypes.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, bestSoFar, currentResolutionContext.step));
 253         JCDiagnostic main = diags.note(log.currentSource(), dpos, key, name,
 254                 site.tsym, mostSpecificPos, currentResolutionContext.step,
 255                 methodArguments(argtypes2),
 256                 methodArguments(typeargtypes));
 257         JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());
 258         log.report(d);
 259     }
 260 
 261     JCDiagnostic getVerboseApplicableCandidateDiag(int pos, Symbol sym, Type inst) {
 262         JCDiagnostic subDiag = null;
 263         if (sym.type.hasTag(FORALL)) {
 264             subDiag = diags.fragment(Fragments.PartialInstSig(inst));
 265         }
 266 
 267         String key = subDiag == null ?
 268                 &quot;applicable.method.found&quot; :
 269                 &quot;applicable.method.found.1&quot;;
 270 
 271         return diags.fragment(key, pos, sym, subDiag);
 272     }
 273 
 274     JCDiagnostic getVerboseInapplicableCandidateDiag(int pos, Symbol sym, JCDiagnostic subDiag) {
 275         return diags.fragment(Fragments.NotApplicableMethodFound(pos, sym, subDiag));
 276     }
 277     // &lt;/editor-fold&gt;
 278 
 279 /* ************************************************************************
 280  * Identifier resolution
 281  *************************************************************************/
 282 
 283     /** An environment is &quot;static&quot; if its static level is greater than
 284      *  the one of its outer environment
 285      */
 286     protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
 287         return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
 288     }
 289 
 290     /** An environment is an &quot;initializer&quot; if it is a constructor or
 291      *  an instance initializer.
 292      */
 293     static boolean isInitializer(Env&lt;AttrContext&gt; env) {
 294         Symbol owner = env.info.scope.owner;
 295         return owner.isConstructor() ||
 296             owner.owner.kind == TYP &amp;&amp;
 297             (owner.kind == VAR ||
 298              owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
 299             (owner.flags() &amp; STATIC) == 0;
 300     }
 301 
 302     /** Is class accessible in given environment?
 303      *  @param env    The current environment.
 304      *  @param c      The class whose accessibility is checked.
 305      */
 306     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
 307         return isAccessible(env, c, false);
 308     }
 309 
 310     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {
 311 
 312         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 313            to refer to an inaccessible type
 314         */
 315         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 316             return true;
 317 
 318         if (env.info.visitingServiceImplementation &amp;&amp;
 319             env.toplevel.modle == c.packge().modle) {
 320             return true;
 321         }
 322 
 323         boolean isAccessible = false;
 324         switch ((short)(c.flags() &amp; AccessFlags)) {
 325             case PRIVATE:
 326                 isAccessible =
 327                     env.enclClass.sym.outermostClass() ==
 328                     c.owner.outermostClass();
 329                 break;
 330             case 0:
 331                 isAccessible =
 332                     env.toplevel.packge == c.owner // fast special case
 333                     ||
 334                     env.toplevel.packge == c.packge();
 335                 break;
 336             default: // error recovery
 337                 isAccessible = true;
 338                 break;
 339             case PUBLIC:
 340                 if (allowModules) {
 341                     ModuleSymbol currModule = env.toplevel.modle;
 342                     currModule.complete();
 343                     PackageSymbol p = c.packge();
 344                     isAccessible =
 345                         currModule == p.modle ||
 346                         currModule.visiblePackages.get(p.fullname) == p ||
 347                         p == syms.rootPackage ||
 348                         (p.modle == syms.unnamedModule &amp;&amp; currModule.readModules.contains(p.modle));
 349                 } else {
 350                     isAccessible = true;
 351                 }
 352                 break;
 353             case PROTECTED:
 354                 isAccessible =
 355                     env.toplevel.packge == c.owner // fast special case
 356                     ||
 357                     env.toplevel.packge == c.packge()
 358                     ||
 359                     isInnerSubClass(env.enclClass.sym, c.owner);
 360                 break;
 361         }
 362         return (checkInner == false || c.type.getEnclosingType() == Type.noType) ?
 363             isAccessible :
 364             isAccessible &amp;&amp; isAccessible(env, c.type.getEnclosingType(), checkInner);
 365     }
 366     //where
 367         /** Is given class a subclass of given base class, or an inner class
 368          *  of a subclass?
 369          *  Return null if no such class exists.
 370          *  @param c     The class which is the subclass or is contained in it.
 371          *  @param base  The base class
 372          */
 373         private boolean isInnerSubClass(ClassSymbol c, Symbol base) {
 374             while (c != null &amp;&amp; !c.isSubClass(base, types)) {
 375                 c = c.owner.enclClass();
 376             }
 377             return c != null;
 378         }
 379 
 380     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t) {
 381         return isAccessible(env, t, false);
 382     }
 383 
 384     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t, boolean checkInner) {
 385         return (t.hasTag(ARRAY))
 386             ? isAccessible(env, types.cvarUpperBound(types.elemtype(t)))
 387             : isAccessible(env, t.tsym, checkInner);
 388     }
 389 
 390     /** Is symbol accessible as a member of given type in given environment?
 391      *  @param env    The current environment.
 392      *  @param site   The type of which the tested symbol is regarded
 393      *                as a member.
 394      *  @param sym    The symbol.
 395      */
 396     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
 397         return isAccessible(env, site, sym, false);
 398     }
 399     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym, boolean checkInner) {
 400         if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) return false;
 401 
 402         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 403            to refer to an inaccessible type
 404         */
 405         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 406             return true;
 407 
 408         if (env.info.visitingServiceImplementation &amp;&amp;
 409             env.toplevel.modle == sym.packge().modle) {
 410             return true;
 411         }
 412 
 413         switch ((short)(sym.flags() &amp; AccessFlags)) {
 414         case PRIVATE:
 415             return
 416                 (env.enclClass.sym == sym.owner // fast special case
 417                  ||
 418                  env.enclClass.sym.outermostClass() ==
 419                  sym.owner.outermostClass())
 420                 &amp;&amp;
 421                 sym.isInheritedIn(site.tsym, types);
 422         case 0:
 423             return
 424                 (env.toplevel.packge == sym.owner.owner // fast special case
 425                  ||
 426                  env.toplevel.packge == sym.packge())
 427                 &amp;&amp;
 428                 isAccessible(env, site, checkInner)
 429                 &amp;&amp;
 430                 sym.isInheritedIn(site.tsym, types)
 431                 &amp;&amp;
 432                 notOverriddenIn(site, sym);
 433         case PROTECTED:
 434             return
 435                 (env.toplevel.packge == sym.owner.owner // fast special case
 436                  ||
 437                  env.toplevel.packge == sym.packge()
 438                  ||
 439                  isProtectedAccessible(sym, env.enclClass.sym, site)
 440                  ||
 441                  // OK to select instance method or field from &#39;super&#39; or type name
 442                  // (but type names should be disallowed elsewhere!)
 443                  env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0 &amp;&amp; sym.kind != TYP)
 444                 &amp;&amp;
 445                 isAccessible(env, site, checkInner)
 446                 &amp;&amp;
 447                 notOverriddenIn(site, sym);
 448         default: // this case includes erroneous combinations as well
 449             return isAccessible(env, site, checkInner) &amp;&amp; notOverriddenIn(site, sym);
 450         }
 451     }
 452     //where
 453     /* `sym&#39; is accessible only if not overridden by
 454      * another symbol which is a member of `site&#39;
 455      * (because, if it is overridden, `sym&#39; is not strictly
 456      * speaking a member of `site&#39;). A polymorphic signature method
 457      * cannot be overridden (e.g. MH.invokeExact(Object[])).
 458      */
 459     private boolean notOverriddenIn(Type site, Symbol sym) {
 460         if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())
 461             return true;
 462         else {
 463             Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
 464             return (s2 == null || s2 == sym || sym.owner == s2.owner ||
 465                     !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));
 466         }
 467     }
 468     //where
 469         /** Is given protected symbol accessible if it is selected from given site
 470          *  and the selection takes place in given class?
 471          *  @param sym     The symbol with protected access
 472          *  @param c       The class where the access takes place
 473          *  @site          The type of the qualifier
 474          */
 475         private
 476         boolean isProtectedAccessible(Symbol sym, ClassSymbol c, Type site) {
 477             Type newSite = site.hasTag(TYPEVAR) ? site.getUpperBound() : site;
 478             while (c != null &amp;&amp;
 479                    !(c.isSubClass(sym.owner, types) &amp;&amp;
 480                      (c.flags() &amp; INTERFACE) == 0 &amp;&amp;
 481                      // In JLS 2e 6.6.2.1, the subclass restriction applies
 482                      // only to instance fields and methods -- types are excluded
 483                      // regardless of whether they are declared &#39;static&#39; or not.
 484                      ((sym.flags() &amp; STATIC) != 0 || sym.kind == TYP || newSite.tsym.isSubClass(c, types))))
 485                 c = c.owner.enclClass();
 486             return c != null;
 487         }
 488 
 489     /**
 490      * Performs a recursive scan of a type looking for accessibility problems
 491      * from current attribution environment
 492      */
 493     void checkAccessibleType(Env&lt;AttrContext&gt; env, Type t) {
 494         accessibilityChecker.visit(t, env);
 495     }
 496 
 497     /**
 498      * Accessibility type-visitor
 499      */
 500     Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt; accessibilityChecker =
 501             new Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt;() {
 502 
 503         void visit(List&lt;Type&gt; ts, Env&lt;AttrContext&gt; env) {
 504             for (Type t : ts) {
 505                 visit(t, env);
 506             }
 507         }
 508 
 509         public Void visitType(Type t, Env&lt;AttrContext&gt; env) {
 510             return null;
 511         }
 512 
 513         @Override
 514         public Void visitArrayType(ArrayType t, Env&lt;AttrContext&gt; env) {
 515             visit(t.elemtype, env);
 516             return null;
 517         }
 518 
 519         @Override
 520         public Void visitClassType(ClassType t, Env&lt;AttrContext&gt; env) {
 521             visit(t.getTypeArguments(), env);
 522             if (!isAccessible(env, t, true)) {
 523                 accessBase(new AccessError(env, null, t.tsym), env.tree.pos(), env.enclClass.sym, t, t.tsym.name, true);
 524             }
 525             return null;
 526         }
 527 
 528         @Override
 529         public Void visitWildcardType(WildcardType t, Env&lt;AttrContext&gt; env) {
 530             visit(t.type, env);
 531             return null;
 532         }
 533 
 534         @Override
 535         public Void visitMethodType(MethodType t, Env&lt;AttrContext&gt; env) {
 536             visit(t.getParameterTypes(), env);
 537             visit(t.getReturnType(), env);
 538             visit(t.getThrownTypes(), env);
 539             return null;
 540         }
 541     };
 542 
 543     /** Try to instantiate the type of a method so that it fits
 544      *  given type arguments and argument types. If successful, return
 545      *  the method&#39;s instantiated type, else return null.
 546      *  The instantiation will take into account an additional leading
 547      *  formal parameter if the method is an instance method seen as a member
 548      *  of an under determined site. In this case, we treat site as an additional
 549      *  parameter and the parameters of the class containing the method as
 550      *  additional type variables that get instantiated.
 551      *
 552      *  @param env         The current environment
 553      *  @param site        The type of which the method is a member.
 554      *  @param m           The method symbol.
 555      *  @param argtypes    The invocation&#39;s given value arguments.
 556      *  @param typeargtypes    The invocation&#39;s given type arguments.
 557      *  @param allowBoxing Allow boxing conversions of arguments.
 558      *  @param useVarargs Box trailing arguments into an array for varargs.
 559      */
 560     Type rawInstantiate(Env&lt;AttrContext&gt; env,
 561                         Type site,
 562                         Symbol m,
 563                         ResultInfo resultInfo,
 564                         List&lt;Type&gt; argtypes,
 565                         List&lt;Type&gt; typeargtypes,
 566                         boolean allowBoxing,
 567                         boolean useVarargs,
 568                         Warner warn) throws Infer.InferenceException {
 569         Type mt = types.memberType(site, m);
 570         // tvars is the list of formal type variables for which type arguments
 571         // need to inferred.
 572         List&lt;Type&gt; tvars = List.nil();
 573         if (typeargtypes == null) typeargtypes = List.nil();
 574         if (!mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 575             // This is not a polymorphic method, but typeargs are supplied
 576             // which is fine, see JLS 15.12.2.1
 577         } else if (mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 578             ForAll pmt = (ForAll) mt;
 579             if (typeargtypes.length() != pmt.tvars.length())
 580                  // not enough args
 581                 throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));
 582             // Check type arguments are within bounds
 583             List&lt;Type&gt; formals = pmt.tvars;
 584             List&lt;Type&gt; actuals = typeargtypes;
 585             while (formals.nonEmpty() &amp;&amp; actuals.nonEmpty()) {
 586                 List&lt;Type&gt; bounds = types.subst(types.getBounds((TypeVar)formals.head),
 587                                                 pmt.tvars, typeargtypes);
 588                 for (; bounds.nonEmpty(); bounds = bounds.tail) {
 589                     if (!types.isSubtypeUnchecked(actuals.head, bounds.head, warn)) {
 590                         throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));
 591                     }
 592                 }
 593                 formals = formals.tail;
 594                 actuals = actuals.tail;
 595             }
 596             mt = types.subst(pmt.qtype, pmt.tvars, typeargtypes);
 597         } else if (mt.hasTag(FORALL)) {
 598             ForAll pmt = (ForAll) mt;
 599             List&lt;Type&gt; tvars1 = types.newInstances(pmt.tvars);
 600             tvars = tvars.appendList(tvars1);
 601             mt = types.subst(pmt.qtype, pmt.tvars, tvars1);
 602         }
 603 
 604         // find out whether we need to go the slow route via infer
 605         boolean instNeeded = tvars.tail != null; /*inlined: tvars.nonEmpty()*/
 606         for (List&lt;Type&gt; l = argtypes;
 607              l.tail != null/*inlined: l.nonEmpty()*/ &amp;&amp; !instNeeded;
 608              l = l.tail) {
 609             if (l.head.hasTag(FORALL)) instNeeded = true;
 610         }
 611 
 612         if (instNeeded) {
 613             return infer.instantiateMethod(env,
 614                                     tvars,
 615                                     (MethodType)mt,
 616                                     resultInfo,
 617                                     (MethodSymbol)m,
 618                                     argtypes,
 619                                     allowBoxing,
 620                                     useVarargs,
 621                                     currentResolutionContext,
 622                                     warn);
 623         }
 624 
 625         DeferredAttr.DeferredAttrContext dc = currentResolutionContext.deferredAttrContext(m, infer.emptyContext, resultInfo, warn);
 626         currentResolutionContext.methodCheck.argumentsAcceptable(env, dc,
 627                                 argtypes, mt.getParameterTypes(), warn);
 628         dc.complete();
 629         return mt;
 630     }
 631 
 632     Type checkMethod(Env&lt;AttrContext&gt; env,
 633                      Type site,
 634                      Symbol m,
 635                      ResultInfo resultInfo,
 636                      List&lt;Type&gt; argtypes,
 637                      List&lt;Type&gt; typeargtypes,
 638                      Warner warn) {
 639         MethodResolutionContext prevContext = currentResolutionContext;
 640         try {
 641             currentResolutionContext = new MethodResolutionContext();
 642             currentResolutionContext.attrMode = (resultInfo.pt == Infer.anyPoly) ?
 643                     AttrMode.SPECULATIVE : DeferredAttr.AttrMode.CHECK;
 644             if (env.tree.hasTag(JCTree.Tag.REFERENCE)) {
 645                 //method/constructor references need special check class
 646                 //to handle inference variables in &#39;argtypes&#39; (might happen
 647                 //during an unsticking round)
 648                 currentResolutionContext.methodCheck =
 649                         new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
 650             }
 651             MethodResolutionPhase step = currentResolutionContext.step = env.info.pendingResolutionPhase;
 652             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 653                     step.isBoxingRequired(), step.isVarargsRequired(), warn);
 654         }
 655         finally {
 656             currentResolutionContext = prevContext;
 657         }
 658     }
 659 
 660     /** Same but returns null instead throwing a NoInstanceException
 661      */
 662     Type instantiate(Env&lt;AttrContext&gt; env,
 663                      Type site,
 664                      Symbol m,
 665                      ResultInfo resultInfo,
 666                      List&lt;Type&gt; argtypes,
 667                      List&lt;Type&gt; typeargtypes,
 668                      boolean allowBoxing,
 669                      boolean useVarargs,
 670                      Warner warn) {
 671         try {
 672             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 673                                   allowBoxing, useVarargs, warn);
 674         } catch (InapplicableMethodException ex) {
 675             return null;
 676         }
 677     }
 678 
 679     /**
 680      * This interface defines an entry point that should be used to perform a
 681      * method check. A method check usually consist in determining as to whether
 682      * a set of types (actuals) is compatible with another set of types (formals).
 683      * Since the notion of compatibility can vary depending on the circumstances,
 684      * this interfaces allows to easily add new pluggable method check routines.
 685      */
 686     interface MethodCheck {
 687         /**
 688          * Main method check routine. A method check usually consist in determining
 689          * as to whether a set of types (actuals) is compatible with another set of
 690          * types (formals). If an incompatibility is found, an unchecked exception
 691          * is assumed to be thrown.
 692          */
 693         void argumentsAcceptable(Env&lt;AttrContext&gt; env,
 694                                 DeferredAttrContext deferredAttrContext,
 695                                 List&lt;Type&gt; argtypes,
 696                                 List&lt;Type&gt; formals,
 697                                 Warner warn);
 698 
 699         /**
 700          * Retrieve the method check object that will be used during a
 701          * most specific check.
 702          */
 703         MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals);
 704     }
 705 
 706     /**
 707      * Helper enum defining all method check diagnostics (used by resolveMethodCheck).
 708      */
 709     enum MethodCheckDiag {
 710         /**
 711          * Actuals and formals differs in length.
 712          */
 713         ARITY_MISMATCH(&quot;arg.length.mismatch&quot;, &quot;infer.arg.length.mismatch&quot;),
 714         /**
 715          * An actual is incompatible with a formal.
 716          */
 717         ARG_MISMATCH(&quot;no.conforming.assignment.exists&quot;, &quot;infer.no.conforming.assignment.exists&quot;),
 718         /**
 719          * An actual is incompatible with the varargs element type.
 720          */
 721         VARARG_MISMATCH(&quot;varargs.argument.mismatch&quot;, &quot;infer.varargs.argument.mismatch&quot;),
 722         /**
 723          * The varargs element type is inaccessible.
 724          */
 725         INACCESSIBLE_VARARGS(&quot;inaccessible.varargs.type&quot;, &quot;inaccessible.varargs.type&quot;);
 726 
 727         final String basicKey;
 728         final String inferKey;
 729 
 730         MethodCheckDiag(String basicKey, String inferKey) {
 731             this.basicKey = basicKey;
 732             this.inferKey = inferKey;
 733         }
 734 
 735         String regex() {
 736             return String.format(&quot;([a-z]*\\.)*(%s|%s)&quot;, basicKey, inferKey);
 737         }
 738     }
 739 
 740     /**
 741      * Dummy method check object. All methods are deemed applicable, regardless
 742      * of their formal parameter types.
 743      */
 744     MethodCheck nilMethodCheck = new MethodCheck() {
 745         public void argumentsAcceptable(Env&lt;AttrContext&gt; env, DeferredAttrContext deferredAttrContext, List&lt;Type&gt; argtypes, List&lt;Type&gt; formals, Warner warn) {
 746             //do nothing - method always applicable regardless of actuals
 747         }
 748 
 749         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 750             return this;
 751         }
 752     };
 753 
 754     /**
 755      * Base class for &#39;real&#39; method checks. The class defines the logic for
 756      * iterating through formals and actuals and provides and entry point
 757      * that can be used by subclasses in order to define the actual check logic.
 758      */
 759     abstract class AbstractMethodCheck implements MethodCheck {
 760         @Override
 761         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 762                                     DeferredAttrContext deferredAttrContext,
 763                                     List&lt;Type&gt; argtypes,
 764                                     List&lt;Type&gt; formals,
 765                                     Warner warn) {
 766             //should we expand formals?
 767             boolean useVarargs = deferredAttrContext.phase.isVarargsRequired();
 768             JCTree callTree = treeForDiagnostics(env);
 769             List&lt;JCExpression&gt; trees = TreeInfo.args(callTree);
 770 
 771             //inference context used during this method check
 772             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
 773 
 774             Type varargsFormal = useVarargs ? formals.last() : null;
 775 
 776             if (varargsFormal == null &amp;&amp;
 777                     argtypes.size() != formals.size()) {
 778                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 779             }
 780 
 781             while (argtypes.nonEmpty() &amp;&amp; formals.head != varargsFormal) {
 782                 DiagnosticPosition pos = trees != null ? trees.head : null;
 783                 checkArg(pos, false, argtypes.head, formals.head, deferredAttrContext, warn);
 784                 argtypes = argtypes.tail;
 785                 formals = formals.tail;
 786                 trees = trees != null ? trees.tail : trees;
 787             }
 788 
 789             if (formals.head != varargsFormal) {
 790                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 791             }
 792 
 793             if (useVarargs) {
 794                 //note: if applicability check is triggered by most specific test,
 795                 //the last argument of a varargs is _not_ an array type (see JLS 15.12.2.5)
 796                 final Type elt = types.elemtype(varargsFormal);
 797                 while (argtypes.nonEmpty()) {
 798                     DiagnosticPosition pos = trees != null ? trees.head : null;
 799                     checkArg(pos, true, argtypes.head, elt, deferredAttrContext, warn);
 800                     argtypes = argtypes.tail;
 801                     trees = trees != null ? trees.tail : trees;
 802                 }
 803             }
 804         }
 805 
 806             // where
 807             private JCTree treeForDiagnostics(Env&lt;AttrContext&gt; env) {
 808                 return env.info.preferredTreeForDiagnostics != null ? env.info.preferredTreeForDiagnostics : env.tree;
 809             }
 810 
 811         /**
 812          * Does the actual argument conforms to the corresponding formal?
 813          */
 814         abstract void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn);
 815 
 816         protected void reportMC(DiagnosticPosition pos, MethodCheckDiag diag, InferenceContext inferenceContext, Object... args) {
 817             boolean inferDiag = inferenceContext != infer.emptyContext;
 818             if (inferDiag &amp;&amp; (!diag.inferKey.equals(diag.basicKey))) {
 819                 Object[] args2 = new Object[args.length + 1];
 820                 System.arraycopy(args, 0, args2, 1, args.length);
 821                 args2[0] = inferenceContext.inferenceVars();
 822                 args = args2;
 823             }
 824             String key = inferDiag ? diag.inferKey : diag.basicKey;
 825             throw inferDiag ?
 826                 infer.error(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args)) :
 827                 methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));
 828         }
 829 
 830         /**
 831          * To eliminate the overhead associated with allocating an exception object in such an
 832          * hot execution path, we use flyweight pattern - and share the same exception instance
 833          * across multiple method check failures.
 834          */
 835         class SharedInapplicableMethodException extends InapplicableMethodException {
 836             private static final long serialVersionUID = 0;
 837 
 838             SharedInapplicableMethodException() {
 839                 super(null);
 840             }
 841 
 842             SharedInapplicableMethodException setMessage(JCDiagnostic details) {
 843                 this.diagnostic = details;
 844                 return this;
 845             }
 846         }
 847 
 848         SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();
 849 
 850         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 851             return nilMethodCheck;
 852         }
 853 
 854     }
 855 
 856     /**
 857      * Arity-based method check. A method is applicable if the number of actuals
 858      * supplied conforms to the method signature.
 859      */
 860     MethodCheck arityMethodCheck = new AbstractMethodCheck() {
 861         @Override
 862         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 863             //do nothing - actual always compatible to formals
 864         }
 865 
 866         @Override
 867         public String toString() {
 868             return &quot;arityMethodCheck&quot;;
 869         }
 870     };
 871 
 872     /**
 873      * Main method applicability routine. Given a list of actual types A,
 874      * a list of formal types F, determines whether the types in A are
 875      * compatible (by method invocation conversion) with the types in F.
 876      *
 877      * Since this routine is shared between overload resolution and method
 878      * type-inference, a (possibly empty) inference context is used to convert
 879      * formal types to the corresponding &#39;undet&#39; form ahead of a compatibility
 880      * check so that constraints can be propagated and collected.
 881      *
 882      * Moreover, if one or more types in A is a deferred type, this routine uses
 883      * DeferredAttr in order to perform deferred attribution. If one or more actual
 884      * deferred types are stuck, they are placed in a queue and revisited later
 885      * after the remainder of the arguments have been seen. If this is not sufficient
 886      * to &#39;unstuck&#39; the argument, a cyclic inference error is called out.
 887      *
 888      * A method check handler (see above) is used in order to report errors.
 889      */
 890     MethodCheck resolveMethodCheck = new AbstractMethodCheck() {
 891 
 892         @Override
 893         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 894             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 895             mresult.check(pos, actual);
 896         }
 897 
 898         @Override
 899         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 900                                     DeferredAttrContext deferredAttrContext,
 901                                     List&lt;Type&gt; argtypes,
 902                                     List&lt;Type&gt; formals,
 903                                     Warner warn) {
 904             super.argumentsAcceptable(env, deferredAttrContext, argtypes, formals, warn);
 905             // should we check varargs element type accessibility?
 906             if (deferredAttrContext.phase.isVarargsRequired()) {
 907                 if (deferredAttrContext.mode == AttrMode.CHECK || !checkVarargsAccessAfterResolution) {
 908                     varargsAccessible(env, types.elemtype(formals.last()), deferredAttrContext.inferenceContext);
 909                 }
 910             }
 911         }
 912 
 913         /**
 914          * Test that the runtime array element type corresponding to &#39;t&#39; is accessible.  &#39;t&#39; should be the
 915          * varargs element type of either the method invocation type signature (after inference completes)
 916          * or the method declaration signature (before inference completes).
 917          */
 918         private void varargsAccessible(final Env&lt;AttrContext&gt; env, final Type t, final InferenceContext inferenceContext) {
 919             if (inferenceContext.free(t)) {
 920                 inferenceContext.addFreeTypeListener(List.of(t),
 921                         solvedContext -&gt; varargsAccessible(env, solvedContext.asInstType(t), solvedContext));
 922             } else {
 923                 if (!isAccessible(env, types.erasure(t))) {
 924                     Symbol location = env.enclClass.sym;
 925                     reportMC(env.tree, MethodCheckDiag.INACCESSIBLE_VARARGS, inferenceContext, t, Kinds.kindName(location), location);
 926                 }
 927             }
 928         }
 929 
 930         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 931                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 932             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 933                 MethodCheckDiag methodDiag = varargsCheck ?
 934                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 935 
 936                 @Override
 937                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 938                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 939                 }
 940             };
 941             return new MethodResultInfo(to, checkContext);
 942         }
 943 
 944         @Override
 945         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 946             return new MostSpecificCheck(actuals);
 947         }
 948 
 949         @Override
 950         public String toString() {
 951             return &quot;resolveMethodCheck&quot;;
 952         }
 953     };
 954 
 955     /**
 956      * This class handles method reference applicability checks; since during
 957      * these checks it&#39;s sometime possible to have inference variables on
 958      * the actual argument types list, the method applicability check must be
 959      * extended so that inference variables are &#39;opened&#39; as needed.
 960      */
 961     class MethodReferenceCheck extends AbstractMethodCheck {
 962 
 963         InferenceContext pendingInferenceContext;
 964 
 965         MethodReferenceCheck(InferenceContext pendingInferenceContext) {
 966             this.pendingInferenceContext = pendingInferenceContext;
 967         }
 968 
 969         @Override
 970         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 971             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 972             mresult.check(pos, actual);
 973         }
 974 
 975         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 976                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 977             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 978                 MethodCheckDiag methodDiag = varargsCheck ?
 979                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 980 
 981                 @Override
 982                 public boolean compatible(Type found, Type req, Warner warn) {
 983                     found = pendingInferenceContext.asUndetVar(found);
 984                     if (found.hasTag(UNDETVAR) &amp;&amp; req.isPrimitive()) {
 985                         req = types.boxedClass(req).type;
 986                     }
 987                     return super.compatible(found, req, warn);
 988                 }
 989 
 990                 @Override
 991                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 992                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 993                 }
 994             };
 995             return new MethodResultInfo(to, checkContext);
 996         }
 997 
 998         @Override
 999         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1000             return new MostSpecificCheck(actuals);
1001         }
1002 
1003         @Override
1004         public String toString() {
1005             return &quot;MethodReferenceCheck&quot;;
1006         }
1007     }
1008 
1009     /**
1010      * Check context to be used during method applicability checks. A method check
1011      * context might contain inference variables.
1012      */
1013     abstract class MethodCheckContext implements CheckContext {
1014 
1015         boolean strict;
1016         DeferredAttrContext deferredAttrContext;
1017         Warner rsWarner;
1018 
1019         public MethodCheckContext(boolean strict, DeferredAttrContext deferredAttrContext, Warner rsWarner) {
1020            this.strict = strict;
1021            this.deferredAttrContext = deferredAttrContext;
1022            this.rsWarner = rsWarner;
1023         }
1024 
1025         public boolean compatible(Type found, Type req, Warner warn) {
1026             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
1027             return strict ?
1028                     types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :
1029                     types.isConvertible(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn);
1030         }
1031 
1032         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1033             throw new InapplicableMethodException(details);
1034         }
1035 
1036         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
1037             return rsWarner;
1038         }
1039 
1040         public InferenceContext inferenceContext() {
1041             return deferredAttrContext.inferenceContext;
1042         }
1043 
1044         public DeferredAttrContext deferredAttrContext() {
1045             return deferredAttrContext;
1046         }
1047 
1048         @Override
1049         public String toString() {
1050             return &quot;MethodCheckContext&quot;;
1051         }
1052     }
1053 
1054     /**
1055      * ResultInfo class to be used during method applicability checks. Check
1056      * for deferred types goes through special path.
1057      */
1058     class MethodResultInfo extends ResultInfo {
1059 
1060         public MethodResultInfo(Type pt, CheckContext checkContext) {
1061             attr.super(KindSelector.VAL, pt, checkContext);
1062         }
1063 
1064         @Override
1065         protected Type check(DiagnosticPosition pos, Type found) {
1066             if (found.hasTag(DEFERRED)) {
1067                 DeferredType dt = (DeferredType)found;
1068                 return dt.check(this);
1069             } else {
1070                 Type uResult = U(found);
1071                 Type capturedType = pos == null || pos.getTree() == null ?
1072                         types.capture(uResult) :
1073                         checkContext.inferenceContext()
1074                             .cachedCapture(pos.getTree(), uResult, true);
1075                 return super.check(pos, chk.checkNonVoid(pos, capturedType));
1076             }
1077         }
1078 
1079         /**
1080          * javac has a long-standing &#39;simplification&#39; (see 6391995):
1081          * given an actual argument type, the method check is performed
1082          * on its upper bound. This leads to inconsistencies when an
1083          * argument type is checked against itself. For example, given
1084          * a type-variable T, it is not true that {@code U(T) &lt;: T},
1085          * so we need to guard against that.
1086          */
1087         private Type U(Type found) {
1088             return found == pt ?
1089                     found : types.cvarUpperBound(found);
1090         }
1091 
1092         @Override
1093         protected MethodResultInfo dup(Type newPt) {
1094             return new MethodResultInfo(newPt, checkContext);
1095         }
1096 
1097         @Override
1098         protected ResultInfo dup(CheckContext newContext) {
1099             return new MethodResultInfo(pt, newContext);
1100         }
1101 
1102         @Override
1103         protected ResultInfo dup(Type newPt, CheckContext newContext) {
1104             return new MethodResultInfo(newPt, newContext);
1105         }
1106     }
1107 
1108     /**
1109      * Most specific method applicability routine. Given a list of actual types A,
1110      * a list of formal types F1, and a list of formal types F2, the routine determines
1111      * as to whether the types in F1 can be considered more specific than those in F2 w.r.t.
1112      * argument types A.
1113      */
1114     class MostSpecificCheck implements MethodCheck {
1115 
1116         List&lt;Type&gt; actuals;
1117 
1118         MostSpecificCheck(List&lt;Type&gt; actuals) {
1119             this.actuals = actuals;
1120         }
1121 
1122         @Override
1123         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
1124                                     DeferredAttrContext deferredAttrContext,
1125                                     List&lt;Type&gt; formals1,
1126                                     List&lt;Type&gt; formals2,
1127                                     Warner warn) {
1128             formals2 = adjustArgs(formals2, deferredAttrContext.msym, formals1.length(), deferredAttrContext.phase.isVarargsRequired());
1129             while (formals2.nonEmpty()) {
1130                 ResultInfo mresult = methodCheckResult(formals2.head, deferredAttrContext, warn, actuals.head);
1131                 mresult.check(null, formals1.head);
1132                 formals1 = formals1.tail;
1133                 formals2 = formals2.tail;
1134                 actuals = actuals.isEmpty() ? actuals : actuals.tail;
1135             }
1136         }
1137 
1138        /**
1139         * Create a method check context to be used during the most specific applicability check
1140         */
1141         ResultInfo methodCheckResult(Type to, DeferredAttr.DeferredAttrContext deferredAttrContext,
1142                Warner rsWarner, Type actual) {
1143             return attr.new ResultInfo(KindSelector.VAL, to,
1144                    new MostSpecificCheckContext(deferredAttrContext, rsWarner, actual));
1145         }
1146 
1147         /**
1148          * Subclass of method check context class that implements most specific
1149          * method conversion. If the actual type under analysis is a deferred type
1150          * a full blown structural analysis is carried out.
1151          */
1152         class MostSpecificCheckContext extends MethodCheckContext {
1153 
1154             Type actual;
1155 
1156             public MostSpecificCheckContext(DeferredAttrContext deferredAttrContext, Warner rsWarner, Type actual) {
1157                 super(true, deferredAttrContext, rsWarner);
1158                 this.actual = actual;
1159             }
1160 
1161             public boolean compatible(Type found, Type req, Warner warn) {
1162                 if (allowFunctionalInterfaceMostSpecific &amp;&amp;
1163                         unrelatedFunctionalInterfaces(found, req) &amp;&amp;
1164                         (actual != null &amp;&amp; actual.getTag() == DEFERRED)) {
1165                     DeferredType dt = (DeferredType) actual;
1166                     JCTree speculativeTree = dt.speculativeTree(deferredAttrContext);
1167                     if (speculativeTree != deferredAttr.stuckTree) {
1168                         return functionalInterfaceMostSpecific(found, req, speculativeTree);
1169                     }
1170                 }
1171                 return compatibleBySubtyping(found, req);
1172             }
1173 
1174             private boolean compatibleBySubtyping(Type found, Type req) {
1175                 if (!strict &amp;&amp; found.isPrimitive() != req.isPrimitive()) {
1176                     found = found.isPrimitive() ? types.boxedClass(found).type : types.unboxedType(found);
1177                 }
1178                 return types.isSubtypeNoCapture(found, deferredAttrContext.inferenceContext.asUndetVar(req));
1179             }
1180 
1181             /** Whether {@code t} and {@code s} are unrelated functional interface types. */
1182             private boolean unrelatedFunctionalInterfaces(Type t, Type s) {
1183                 return types.isFunctionalInterface(t.tsym) &amp;&amp;
1184                        types.isFunctionalInterface(s.tsym) &amp;&amp;
1185                        unrelatedInterfaces(t, s);
1186             }
1187 
1188             /** Whether {@code t} and {@code s} are unrelated interface types; recurs on intersections. **/
1189             private boolean unrelatedInterfaces(Type t, Type s) {
1190                 if (t.isCompound()) {
1191                     for (Type ti : types.interfaces(t)) {
1192                         if (!unrelatedInterfaces(ti, s)) {
1193                             return false;
1194                         }
1195                     }
1196                     return true;
1197                 } else if (s.isCompound()) {
1198                     for (Type si : types.interfaces(s)) {
1199                         if (!unrelatedInterfaces(t, si)) {
1200                             return false;
1201                         }
1202                     }
1203                     return true;
1204                 } else {
1205                     return types.asSuper(t, s.tsym) == null &amp;&amp; types.asSuper(s, t.tsym) == null;
1206                 }
1207             }
1208 
1209             /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1210             private boolean functionalInterfaceMostSpecific(Type t, Type s, JCTree tree) {
1211                 Type tDesc = types.findDescriptorType(types.capture(t));
1212                 Type tDescNoCapture = types.findDescriptorType(t);
1213                 Type sDesc = types.findDescriptorType(s);
1214                 final List&lt;Type&gt; tTypeParams = tDesc.getTypeArguments();
1215                 final List&lt;Type&gt; tTypeParamsNoCapture = tDescNoCapture.getTypeArguments();
1216                 final List&lt;Type&gt; sTypeParams = sDesc.getTypeArguments();
1217 
1218                 // compare type parameters
1219                 if (tDesc.hasTag(FORALL) &amp;&amp; !types.hasSameBounds((ForAll) tDesc, (ForAll) tDescNoCapture)) {
1220                     return false;
1221                 }
1222                 // can&#39;t use Types.hasSameBounds on sDesc because bounds may have ivars
1223                 List&lt;Type&gt; tIter = tTypeParams;
1224                 List&lt;Type&gt; sIter = sTypeParams;
1225                 while (tIter.nonEmpty() &amp;&amp; sIter.nonEmpty()) {
1226                     Type tBound = tIter.head.getUpperBound();
1227                     Type sBound = types.subst(sIter.head.getUpperBound(), sTypeParams, tTypeParams);
1228                     if (tBound.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sBound)) {
1229                         return false;
1230                     }
1231                     if (!types.isSameType(tBound, inferenceContext().asUndetVar(sBound))) {
1232                         return false;
1233                     }
1234                     tIter = tIter.tail;
1235                     sIter = sIter.tail;
1236                 }
1237                 if (!tIter.isEmpty() || !sIter.isEmpty()) {
1238                     return false;
1239                 }
1240 
1241                 // compare parameters
1242                 List&lt;Type&gt; tParams = tDesc.getParameterTypes();
1243                 List&lt;Type&gt; tParamsNoCapture = tDescNoCapture.getParameterTypes();
1244                 List&lt;Type&gt; sParams = sDesc.getParameterTypes();
1245                 while (tParams.nonEmpty() &amp;&amp; tParamsNoCapture.nonEmpty() &amp;&amp; sParams.nonEmpty()) {
1246                     Type tParam = tParams.head;
1247                     Type tParamNoCapture = types.subst(tParamsNoCapture.head, tTypeParamsNoCapture, tTypeParams);
1248                     Type sParam = types.subst(sParams.head, sTypeParams, tTypeParams);
1249                     if (tParam.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sParam)) {
1250                         return false;
1251                     }
1252                     if (!types.isSubtype(inferenceContext().asUndetVar(sParam), tParam)) {
1253                         return false;
1254                     }
1255                     if (!types.isSameType(tParamNoCapture, inferenceContext().asUndetVar(sParam))) {
1256                         return false;
1257                     }
1258                     tParams = tParams.tail;
1259                     tParamsNoCapture = tParamsNoCapture.tail;
1260                     sParams = sParams.tail;
1261                 }
1262                 if (!tParams.isEmpty() || !tParamsNoCapture.isEmpty() || !sParams.isEmpty()) {
1263                     return false;
1264                 }
1265 
1266                 // compare returns
1267                 Type tRet = tDesc.getReturnType();
1268                 Type sRet = types.subst(sDesc.getReturnType(), sTypeParams, tTypeParams);
1269                 if (tRet.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sRet)) {
1270                     return false;
1271                 }
1272                 MostSpecificFunctionReturnChecker msc = new MostSpecificFunctionReturnChecker(tRet, sRet);
1273                 msc.scan(tree);
1274                 return msc.result;
1275             }
1276 
1277             /**
1278              * Tests whether one functional interface type can be considered more specific
1279              * than another unrelated functional interface type for the scanned expression.
1280              */
1281             class MostSpecificFunctionReturnChecker extends DeferredAttr.PolyScanner {
1282 
1283                 final Type tRet;
1284                 final Type sRet;
1285                 boolean result;
1286 
1287                 /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1288                 MostSpecificFunctionReturnChecker(Type tRet, Type sRet) {
1289                     this.tRet = tRet;
1290                     this.sRet = sRet;
1291                     result = true;
1292                 }
1293 
1294                 @Override
1295                 void skip(JCTree tree) {
1296                     result &amp;= false;
1297                 }
1298 
1299                 @Override
1300                 public void visitConditional(JCConditional tree) {
1301                     scan(asExpr(tree.truepart));
1302                     scan(asExpr(tree.falsepart));
1303                 }
1304 
1305                 @Override
1306                 public void visitReference(JCMemberReference tree) {
1307                     if (sRet.hasTag(VOID)) {
1308                         result &amp;= true;
1309                     } else if (tRet.hasTag(VOID)) {
1310                         result &amp;= false;
1311                     } else if (tRet.isPrimitive() != sRet.isPrimitive()) {
1312                         boolean retValIsPrimitive =
1313                                 tree.refPolyKind == PolyKind.STANDALONE &amp;&amp;
1314                                 tree.sym.type.getReturnType().isPrimitive();
1315                         result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1316                                   (retValIsPrimitive != sRet.isPrimitive());
1317                     } else {
1318                         result &amp;= compatibleBySubtyping(tRet, sRet);
1319                     }
1320                 }
1321 
1322                 @Override
1323                 public void visitParens(JCParens tree) {
1324                     scan(asExpr(tree.expr));
1325                 }
1326 
1327                 @Override
1328                 public void visitLambda(JCLambda tree) {
1329                     if (sRet.hasTag(VOID)) {
1330                         result &amp;= true;
1331                     } else if (tRet.hasTag(VOID)) {
1332                         result &amp;= false;
1333                     } else {
1334                         List&lt;JCExpression&gt; lambdaResults = lambdaResults(tree);
1335                         if (!lambdaResults.isEmpty() &amp;&amp; unrelatedFunctionalInterfaces(tRet, sRet)) {
1336                             for (JCExpression expr : lambdaResults) {
1337                                 result &amp;= functionalInterfaceMostSpecific(tRet, sRet, expr);
1338                             }
1339                         } else if (!lambdaResults.isEmpty() &amp;&amp; tRet.isPrimitive() != sRet.isPrimitive()) {
1340                             for (JCExpression expr : lambdaResults) {
1341                                 boolean retValIsPrimitive = expr.isStandalone() &amp;&amp; expr.type.isPrimitive();
1342                                 result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1343                                         (retValIsPrimitive != sRet.isPrimitive());
1344                             }
1345                         } else {
1346                             result &amp;= compatibleBySubtyping(tRet, sRet);
1347                         }
1348                     }
1349                 }
1350                 //where
1351 
1352                 private List&lt;JCExpression&gt; lambdaResults(JCLambda lambda) {
1353                     if (lambda.getBodyKind() == JCTree.JCLambda.BodyKind.EXPRESSION) {
1354                         return List.of(asExpr((JCExpression) lambda.body));
1355                     } else {
1356                         final ListBuffer&lt;JCExpression&gt; buffer = new ListBuffer&lt;&gt;();
1357                         DeferredAttr.LambdaReturnScanner lambdaScanner =
1358                                 new DeferredAttr.LambdaReturnScanner() {
1359                                     @Override
1360                                     public void visitReturn(JCReturn tree) {
1361                                         if (tree.expr != null) {
1362                                             buffer.append(asExpr(tree.expr));
1363                                         }
1364                                     }
1365                                 };
1366                         lambdaScanner.scan(lambda.body);
1367                         return buffer.toList();
1368                     }
1369                 }
1370 
1371                 private JCExpression asExpr(JCExpression expr) {
1372                     if (expr.type.hasTag(DEFERRED)) {
1373                         JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);
1374                         if (speculativeTree != deferredAttr.stuckTree) {
1375                             expr = (JCExpression)speculativeTree;
1376                         }
1377                     }
1378                     return expr;
1379                 }
1380             }
1381 
1382         }
1383 
1384         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1385             Assert.error(&quot;Cannot get here!&quot;);
1386             return null;
1387         }
1388     }
1389 
1390     public static class InapplicableMethodException extends RuntimeException {
1391         private static final long serialVersionUID = 0;
1392 
1393         transient JCDiagnostic diagnostic;
1394 
1395         InapplicableMethodException(JCDiagnostic diag) {
1396             this.diagnostic = diag;
1397         }
1398 
1399         public JCDiagnostic getDiagnostic() {
1400             return diagnostic;
1401         }
1402     }
1403 
1404 /* ***************************************************************************
1405  *  Symbol lookup
1406  *  the following naming conventions for arguments are used
1407  *
1408  *       env      is the environment where the symbol was mentioned
1409  *       site     is the type of which the symbol is a member
1410  *       name     is the symbol&#39;s name
1411  *                if no arguments are given
1412  *       argtypes are the value arguments, if we search for a method
1413  *
1414  *  If no symbol was found, a ResolveError detailing the problem is returned.
1415  ****************************************************************************/
1416 
1417     /** Find field. Synthetic fields are always skipped.
1418      *  @param env     The current environment.
1419      *  @param site    The original type from where the selection takes place.
1420      *  @param name    The name of the field.
1421      *  @param c       The class to search for the field. This is always
1422      *                 a superclass or implemented interface of site&#39;s class.
1423      */
1424     Symbol findField(Env&lt;AttrContext&gt; env,
1425                      Type site,
1426                      Name name,
1427                      TypeSymbol c) {
1428         while (c.type.hasTag(TYPEVAR))
1429             c = c.type.getUpperBound().tsym;
1430         Symbol bestSoFar = varNotFound;
1431         Symbol sym;
1432         for (Symbol s : c.members().getSymbolsByName(name)) {
1433             if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1434                 return isAccessible(env, site, s)
1435                     ? s : new AccessError(env, site, s);
1436             }
1437         }
1438         Type st = types.supertype(c.type);
1439         if (st != null &amp;&amp; (st.hasTag(CLASS) || st.hasTag(TYPEVAR))) {
1440             sym = findField(env, site, name, st.tsym);
1441             bestSoFar = bestOf(bestSoFar, sym);
1442         }
1443         for (List&lt;Type&gt; l = types.interfaces(c.type);
1444              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
1445              l = l.tail) {
1446             sym = findField(env, site, name, l.head.tsym);
1447             if (bestSoFar.exists() &amp;&amp; sym.exists() &amp;&amp;
1448                 sym.owner != bestSoFar.owner)
1449                 bestSoFar = new AmbiguityError(bestSoFar, sym);
1450             else
1451                 bestSoFar = bestOf(bestSoFar, sym);
1452         }
1453         return bestSoFar;
1454     }
1455 
1456     /** Resolve a field identifier, throw a fatal error if not found.
1457      *  @param pos       The position to use for error reporting.
1458      *  @param env       The environment current at the method invocation.
1459      *  @param site      The type of the qualifying expression, in which
1460      *                   identifier is searched.
1461      *  @param name      The identifier&#39;s name.
1462      */
1463     public VarSymbol resolveInternalField(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
1464                                           Type site, Name name) {
1465         Symbol sym = findField(env, site, name, site.tsym);
1466         if (sym.kind == VAR) return (VarSymbol)sym;
1467         else throw new FatalError(
1468                  diags.fragment(Fragments.FatalErrCantLocateField(name)));
1469     }
1470 
1471     /** Find unqualified variable or field with given name.
1472      *  Synthetic fields always skipped.
1473      *  @param env     The current environment.
1474      *  @param name    The name of the variable or field.
1475      */
1476     Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {
1477         Symbol bestSoFar = varNotFound;
1478         Env&lt;AttrContext&gt; env1 = env;
1479         boolean staticOnly = false;
1480         while (env1.outer != null) {
1481             Symbol sym = null;
1482             if (isStatic(env1)) staticOnly = true;
1483             for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
1484                 if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1485                     sym = s;
1486                     break;
1487                 }
1488             }
1489             if (sym == null) {
1490                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
1491             }
1492             if (sym.exists()) {
1493                 if (staticOnly &amp;&amp;
1494                    (sym.flags() &amp; STATIC) == 0 &amp;&amp;
1495                     sym.kind == VAR &amp;&amp;
1496                         // if it is a field
1497                         (sym.owner.kind == TYP ||
1498                         // or it is a local variable but it is not declared inside of the static local type
1499                         // then error
1500                         allowRecords &amp;&amp;
1501                         (sym.owner.kind == MTH) &amp;&amp;
1502                         env1 != env &amp;&amp;
1503                         !isInnerClassOfMethod(sym.owner, env.tree.hasTag(CLASSDEF) ?
1504                                 ((JCClassDecl)env.tree).sym :
1505                                 env.enclClass.sym)))
1506                     return new StaticError(sym);
1507                 else
1508                     return sym;
1509             } else {
1510                 bestSoFar = bestOf(bestSoFar, sym);
1511             }
1512 
1513             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1514             env1 = env1.outer;
1515         }
1516 
1517         Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);
1518         if (sym.exists())
1519             return sym;
1520         if (bestSoFar.exists())
1521             return bestSoFar;
1522 
1523         Symbol origin = null;
1524         for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {
1525             for (Symbol currentSymbol : sc.getSymbolsByName(name)) {
1526                 if (currentSymbol.kind != VAR)
1527                     continue;
1528                 // invariant: sym.kind == Symbol.Kind.VAR
1529                 if (!bestSoFar.kind.isResolutionError() &amp;&amp;
1530                     currentSymbol.owner != bestSoFar.owner)
1531                     return new AmbiguityError(bestSoFar, currentSymbol);
1532                 else if (!bestSoFar.kind.betterThan(VAR)) {
1533                     origin = sc.getOrigin(currentSymbol).owner;
1534                     bestSoFar = isAccessible(env, origin.type, currentSymbol)
1535                         ? currentSymbol : new AccessError(env, origin.type, currentSymbol);
1536                 }
1537             }
1538             if (bestSoFar.exists()) break;
1539         }
1540         if (bestSoFar.kind == VAR &amp;&amp; bestSoFar.owner.type != origin.type)
1541             return bestSoFar.clone(origin);
1542         else
1543             return bestSoFar;
1544     }
1545 
1546     Warner noteWarner = new Warner();
1547 
1548     /** Select the best method for a call site among two choices.
1549      *  @param env              The current environment.
1550      *  @param site             The original type from where the
1551      *                          selection takes place.
1552      *  @param argtypes         The invocation&#39;s value arguments,
1553      *  @param typeargtypes     The invocation&#39;s type arguments,
1554      *  @param sym              Proposed new best match.
1555      *  @param bestSoFar        Previously found best match.
1556      *  @param allowBoxing Allow boxing conversions of arguments.
1557      *  @param useVarargs Box trailing arguments into an array for varargs.
1558      */
1559     @SuppressWarnings(&quot;fallthrough&quot;)
1560     Symbol selectBest(Env&lt;AttrContext&gt; env,
1561                       Type site,
1562                       List&lt;Type&gt; argtypes,
1563                       List&lt;Type&gt; typeargtypes,
1564                       Symbol sym,
1565                       Symbol bestSoFar,
1566                       boolean allowBoxing,
1567                       boolean useVarargs) {
1568         if (sym.kind == ERR ||
1569                 (site.tsym != sym.owner &amp;&amp; !sym.isInheritedIn(site.tsym, types)) ||
1570                 !notOverriddenIn(site, sym)) {
1571             return bestSoFar;
1572         } else if (useVarargs &amp;&amp; (sym.flags() &amp; VARARGS) == 0) {
1573             return bestSoFar.kind.isResolutionError() ?
1574                     new BadVarargsMethod((ResolveError)bestSoFar.baseSymbol()) :
1575                     bestSoFar;
1576         }
1577         Assert.check(!sym.kind.isResolutionError());
1578         try {
1579             types.noWarnings.clear();
1580             Type mt = rawInstantiate(env, site, sym, null, argtypes, typeargtypes,
1581                                allowBoxing, useVarargs, types.noWarnings);
1582             currentResolutionContext.addApplicableCandidate(sym, mt);
1583         } catch (InapplicableMethodException ex) {
1584             currentResolutionContext.addInapplicableCandidate(sym, ex.getDiagnostic());
1585             switch (bestSoFar.kind) {
1586                 case ABSENT_MTH:
1587                     return new InapplicableSymbolError(currentResolutionContext);
1588                 case WRONG_MTH:
1589                     bestSoFar = new InapplicableSymbolsError(currentResolutionContext);
1590                 default:
1591                     return bestSoFar;
1592             }
1593         }
1594         if (!isAccessible(env, site, sym)) {
1595             return (bestSoFar.kind == ABSENT_MTH)
1596                 ? new AccessError(env, site, sym)
1597                 : bestSoFar;
1598         }
1599         return (bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS)
1600             ? sym
1601             : mostSpecific(argtypes, sym, bestSoFar, env, site, useVarargs);
1602     }
1603 
1604     /* Return the most specific of the two methods for a call,
1605      *  given that both are accessible and applicable.
1606      *  @param m1               A new candidate for most specific.
1607      *  @param m2               The previous most specific candidate.
1608      *  @param env              The current environment.
1609      *  @param site             The original type from where the selection
1610      *                          takes place.
1611      *  @param allowBoxing Allow boxing conversions of arguments.
1612      *  @param useVarargs Box trailing arguments into an array for varargs.
1613      */
1614     Symbol mostSpecific(List&lt;Type&gt; argtypes, Symbol m1,
1615                         Symbol m2,
1616                         Env&lt;AttrContext&gt; env,
1617                         final Type site,
1618                         boolean useVarargs) {
1619         switch (m2.kind) {
1620         case MTH:
1621             if (m1 == m2) return m1;
1622             boolean m1SignatureMoreSpecific =
1623                     signatureMoreSpecific(argtypes, env, site, m1, m2, useVarargs);
1624             boolean m2SignatureMoreSpecific =
1625                     signatureMoreSpecific(argtypes, env, site, m2, m1, useVarargs);
1626             if (m1SignatureMoreSpecific &amp;&amp; m2SignatureMoreSpecific) {
1627                 Type mt1 = types.memberType(site, m1);
1628                 Type mt2 = types.memberType(site, m2);
1629                 if (!types.overrideEquivalent(mt1, mt2))
1630                     return ambiguityError(m1, m2);
1631 
1632                 // same signature; select (a) the non-bridge method, or
1633                 // (b) the one that overrides the other, or (c) the concrete
1634                 // one, or (d) merge both abstract signatures
1635                 if ((m1.flags() &amp; BRIDGE) != (m2.flags() &amp; BRIDGE))
1636                     return ((m1.flags() &amp; BRIDGE) != 0) ? m2 : m1;
1637 
1638                 if (m1.baseSymbol() == m2.baseSymbol()) {
1639                     // this is the same imported symbol which has been cloned twice.
1640                     // Return the first one (either will do).
1641                     return m1;
1642                 }
1643 
1644                 // if one overrides or hides the other, use it
1645                 TypeSymbol m1Owner = (TypeSymbol)m1.owner;
1646                 TypeSymbol m2Owner = (TypeSymbol)m2.owner;
1647                 // the two owners can never be the same if the target methods are compiled from source,
1648                 // but we need to protect against cases where the methods are defined in some classfile
1649                 // and make sure we issue an ambiguity error accordingly (by skipping the logic below).
1650                 if (m1Owner != m2Owner) {
1651                     if (types.asSuper(m1Owner.type, m2Owner) != null &amp;&amp;
1652                         ((m1.owner.flags_field &amp; INTERFACE) == 0 ||
1653                          (m2.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1654                         m1.overrides(m2, m1Owner, types, false))
1655                         return m1;
1656                     if (types.asSuper(m2Owner.type, m1Owner) != null &amp;&amp;
1657                         ((m2.owner.flags_field &amp; INTERFACE) == 0 ||
1658                          (m1.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1659                         m2.overrides(m1, m2Owner, types, false))
1660                         return m2;
1661                 }
1662                 boolean m1Abstract = (m1.flags() &amp; ABSTRACT) != 0;
1663                 boolean m2Abstract = (m2.flags() &amp; ABSTRACT) != 0;
1664                 if (m1Abstract &amp;&amp; !m2Abstract) return m2;
1665                 if (m2Abstract &amp;&amp; !m1Abstract) return m1;
1666                 // both abstract or both concrete
1667                 return ambiguityError(m1, m2);
1668             }
1669             if (m1SignatureMoreSpecific) return m1;
1670             if (m2SignatureMoreSpecific) return m2;
1671             return ambiguityError(m1, m2);
1672         case AMBIGUOUS:
1673             //compare m1 to ambiguous methods in m2
1674             AmbiguityError e = (AmbiguityError)m2.baseSymbol();
1675             boolean m1MoreSpecificThanAnyAmbiguous = true;
1676             boolean allAmbiguousMoreSpecificThanM1 = true;
1677             for (Symbol s : e.ambiguousSyms) {
1678                 Symbol moreSpecific = mostSpecific(argtypes, m1, s, env, site, useVarargs);
1679                 m1MoreSpecificThanAnyAmbiguous &amp;= moreSpecific == m1;
1680                 allAmbiguousMoreSpecificThanM1 &amp;= moreSpecific == s;
1681             }
1682             if (m1MoreSpecificThanAnyAmbiguous)
1683                 return m1;
1684             //if m1 is more specific than some ambiguous methods, but other ambiguous methods are
1685             //more specific than m1, add it as a new ambiguous method:
1686             if (!allAmbiguousMoreSpecificThanM1)
1687                 e.addAmbiguousSymbol(m1);
1688             return e;
1689         default:
1690             throw new AssertionError();
1691         }
1692     }
1693     //where
1694     private boolean signatureMoreSpecific(List&lt;Type&gt; actuals, Env&lt;AttrContext&gt; env, Type site, Symbol m1, Symbol m2, boolean useVarargs) {
1695         noteWarner.clear();
1696         int maxLength = Math.max(
1697                             Math.max(m1.type.getParameterTypes().length(), actuals.length()),
1698                             m2.type.getParameterTypes().length());
1699         MethodResolutionContext prevResolutionContext = currentResolutionContext;
1700         try {
1701             currentResolutionContext = new MethodResolutionContext();
1702             currentResolutionContext.step = prevResolutionContext.step;
1703             currentResolutionContext.methodCheck =
1704                     prevResolutionContext.methodCheck.mostSpecificCheck(actuals);
1705             Type mst = instantiate(env, site, m2, null,
1706                     adjustArgs(types.cvarLowerBounds(types.memberType(site, m1).getParameterTypes()), m1, maxLength, useVarargs), null,
1707                     false, useVarargs, noteWarner);
1708             return mst != null &amp;&amp;
1709                     !noteWarner.hasLint(Lint.LintCategory.UNCHECKED);
1710         } finally {
1711             currentResolutionContext = prevResolutionContext;
1712         }
1713     }
1714 
1715     List&lt;Type&gt; adjustArgs(List&lt;Type&gt; args, Symbol msym, int length, boolean allowVarargs) {
1716         if ((msym.flags() &amp; VARARGS) != 0 &amp;&amp; allowVarargs) {
1717             Type varargsElem = types.elemtype(args.last());
1718             if (varargsElem == null) {
1719                 Assert.error(&quot;Bad varargs = &quot; + args.last() + &quot; &quot; + msym);
1720             }
1721             List&lt;Type&gt; newArgs = args.reverse().tail.prepend(varargsElem).reverse();
1722             while (newArgs.length() &lt; length) {
1723                 newArgs = newArgs.append(newArgs.last());
1724             }
1725             return newArgs;
1726         } else {
1727             return args;
1728         }
1729     }
1730     //where
1731     Symbol ambiguityError(Symbol m1, Symbol m2) {
1732         if (((m1.flags() | m2.flags()) &amp; CLASH) != 0) {
1733             return (m1.flags() &amp; CLASH) == 0 ? m1 : m2;
1734         } else {
1735             return new AmbiguityError(m1, m2);
1736         }
1737     }
1738 
1739     Symbol findMethodInScope(Env&lt;AttrContext&gt; env,
1740             Type site,
1741             Name name,
1742             List&lt;Type&gt; argtypes,
1743             List&lt;Type&gt; typeargtypes,
1744             Scope sc,
1745             Symbol bestSoFar,
1746             boolean allowBoxing,
1747             boolean useVarargs,
1748             boolean abstractok) {
1749         for (Symbol s : sc.getSymbolsByName(name, new LookupFilter(abstractok))) {
1750             bestSoFar = selectBest(env, site, argtypes, typeargtypes, s,
1751                     bestSoFar, allowBoxing, useVarargs);
1752         }
1753         return bestSoFar;
1754     }
1755     //where
1756         class LookupFilter implements Filter&lt;Symbol&gt; {
1757 
1758             boolean abstractOk;
1759 
1760             LookupFilter(boolean abstractOk) {
1761                 this.abstractOk = abstractOk;
1762             }
1763 
1764             public boolean accepts(Symbol s) {
1765                 long flags = s.flags();
1766                 return s.kind == MTH &amp;&amp;
1767                         (flags &amp; SYNTHETIC) == 0 &amp;&amp;
1768                         (abstractOk ||
1769                         (flags &amp; DEFAULT) != 0 ||
1770                         (flags &amp; ABSTRACT) == 0);
1771             }
1772         }
1773 
1774     /** Find best qualified method matching given name, type and value
1775      *  arguments.
1776      *  @param env       The current environment.
1777      *  @param site      The original type from where the selection
1778      *                   takes place.
1779      *  @param name      The method&#39;s name.
1780      *  @param argtypes  The method&#39;s value arguments.
1781      *  @param typeargtypes The method&#39;s type arguments
1782      *  @param allowBoxing Allow boxing conversions of arguments.
1783      *  @param useVarargs Box trailing arguments into an array for varargs.
1784      */
1785     Symbol findMethod(Env&lt;AttrContext&gt; env,
1786                       Type site,
1787                       Name name,
1788                       List&lt;Type&gt; argtypes,
1789                       List&lt;Type&gt; typeargtypes,
1790                       boolean allowBoxing,
1791                       boolean useVarargs) {
1792         Symbol bestSoFar = methodNotFound;
1793         bestSoFar = findMethod(env,
1794                           site,
1795                           name,
1796                           argtypes,
1797                           typeargtypes,
1798                           site.tsym.type,
1799                           bestSoFar,
1800                           allowBoxing,
1801                           useVarargs);
1802         return bestSoFar;
1803     }
1804     // where
1805     private Symbol findMethod(Env&lt;AttrContext&gt; env,
1806                               Type site,
1807                               Name name,
1808                               List&lt;Type&gt; argtypes,
1809                               List&lt;Type&gt; typeargtypes,
1810                               Type intype,
1811                               Symbol bestSoFar,
1812                               boolean allowBoxing,
1813                               boolean useVarargs) {
1814         @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})
1815         List&lt;Type&gt;[] itypes = (List&lt;Type&gt;[])new List[] { List.&lt;Type&gt;nil(), List.&lt;Type&gt;nil() };
1816 
1817         InterfaceLookupPhase iphase = InterfaceLookupPhase.ABSTRACT_OK;
1818         for (TypeSymbol s : superclasses(intype)) {
1819             bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1820                     s.members(), bestSoFar, allowBoxing, useVarargs, true);
1821             if (name == names.init) return bestSoFar;
1822             iphase = (iphase == null) ? null : iphase.update(s, this);
1823             if (iphase != null) {
1824                 for (Type itype : types.interfaces(s.type)) {
1825                     itypes[iphase.ordinal()] = types.union(types.closure(itype), itypes[iphase.ordinal()]);
1826                 }
1827             }
1828         }
1829 
1830         Symbol concrete = bestSoFar.kind.isValid() &amp;&amp;
1831                 (bestSoFar.flags() &amp; ABSTRACT) == 0 ?
1832                 bestSoFar : methodNotFound;
1833 
1834         for (InterfaceLookupPhase iphase2 : InterfaceLookupPhase.values()) {
1835             //keep searching for abstract methods
1836             for (Type itype : itypes[iphase2.ordinal()]) {
1837                 if (!itype.isInterface()) continue; //skip j.l.Object (included by Types.closure())
1838                 if (iphase2 == InterfaceLookupPhase.DEFAULT_OK &amp;&amp;
1839                         (itype.tsym.flags() &amp; DEFAULT) == 0) continue;
1840                 bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1841                         itype.tsym.members(), bestSoFar, allowBoxing, useVarargs, true);
1842                 if (concrete != bestSoFar &amp;&amp;
1843                     concrete.kind.isValid() &amp;&amp;
1844                     bestSoFar.kind.isValid() &amp;&amp;
1845                         types.isSubSignature(concrete.type, bestSoFar.type)) {
1846                     //this is an hack - as javac does not do full membership checks
1847                     //most specific ends up comparing abstract methods that might have
1848                     //been implemented by some concrete method in a subclass and,
1849                     //because of raw override, it is possible for an abstract method
1850                     //to be more specific than the concrete method - so we need
1851                     //to explicitly call that out (see CR 6178365)
1852                     bestSoFar = concrete;
1853                 }
1854             }
1855         }
1856         return bestSoFar;
1857     }
1858 
1859     enum InterfaceLookupPhase {
1860         ABSTRACT_OK() {
1861             @Override
1862             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1863                 //We should not look for abstract methods if receiver is a concrete class
1864                 //(as concrete classes are expected to implement all abstracts coming
1865                 //from superinterfaces)
1866                 if ((s.flags() &amp; (ABSTRACT | INTERFACE | ENUM)) != 0) {
1867                     return this;
1868                 } else {
1869                     return DEFAULT_OK;
1870                 }
1871             }
1872         },
1873         DEFAULT_OK() {
1874             @Override
1875             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1876                 return this;
1877             }
1878         };
1879 
1880         abstract InterfaceLookupPhase update(Symbol s, Resolve rs);
1881     }
1882 
1883     /**
1884      * Return an Iterable object to scan the superclasses of a given type.
1885      * It&#39;s crucial that the scan is done lazily, as we don&#39;t want to accidentally
1886      * access more supertypes than strictly needed (as this could trigger completion
1887      * errors if some of the not-needed supertypes are missing/ill-formed).
1888      */
1889     Iterable&lt;TypeSymbol&gt; superclasses(final Type intype) {
1890         return () -&gt; new Iterator&lt;TypeSymbol&gt;() {
1891 
1892             List&lt;TypeSymbol&gt; seen = List.nil();
1893             TypeSymbol currentSym = symbolFor(intype);
1894             TypeSymbol prevSym = null;
1895 
1896             public boolean hasNext() {
1897                 if (currentSym == syms.noSymbol) {
1898                     currentSym = symbolFor(types.supertype(prevSym.type));
1899                 }
1900                 return currentSym != null;
1901             }
1902 
1903             public TypeSymbol next() {
1904                 prevSym = currentSym;
1905                 currentSym = syms.noSymbol;
1906                 Assert.check(prevSym != null || prevSym != syms.noSymbol);
1907                 return prevSym;
1908             }
1909 
1910             public void remove() {
1911                 throw new UnsupportedOperationException();
1912             }
1913 
1914             TypeSymbol symbolFor(Type t) {
1915                 if (!t.hasTag(CLASS) &amp;&amp;
1916                         !t.hasTag(TYPEVAR)) {
1917                     return null;
1918                 }
1919                 t = types.skipTypeVars(t, false);
1920                 if (seen.contains(t.tsym)) {
1921                     //degenerate case in which we have a circular
1922                     //class hierarchy - because of ill-formed classfiles
1923                     return null;
1924                 }
1925                 seen = seen.prepend(t.tsym);
1926                 return t.tsym;
1927             }
1928         };
1929     }
1930 
1931     /** Find unqualified method matching given name, type and value arguments.
1932      *  @param env       The current environment.
1933      *  @param name      The method&#39;s name.
1934      *  @param argtypes  The method&#39;s value arguments.
1935      *  @param typeargtypes  The method&#39;s type arguments.
1936      *  @param allowBoxing Allow boxing conversions of arguments.
1937      *  @param useVarargs Box trailing arguments into an array for varargs.
1938      */
1939     Symbol findFun(Env&lt;AttrContext&gt; env, Name name,
1940                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
1941                    boolean allowBoxing, boolean useVarargs) {
1942         Symbol bestSoFar = methodNotFound;
1943         Env&lt;AttrContext&gt; env1 = env;
1944         boolean staticOnly = false;
1945         while (env1.outer != null) {
1946             if (isStatic(env1)) staticOnly = true;
1947             Assert.check(env1.info.preferredTreeForDiagnostics == null);
1948             env1.info.preferredTreeForDiagnostics = env.tree;
1949             try {
1950                 Symbol sym = findMethod(
1951                     env1, env1.enclClass.sym.type, name, argtypes, typeargtypes,
1952                     allowBoxing, useVarargs);
1953                 if (sym.exists()) {
1954                     if (staticOnly &amp;&amp;
1955                         sym.kind == MTH &amp;&amp;
1956                         sym.owner.kind == TYP &amp;&amp;
1957                         (sym.flags() &amp; STATIC) == 0) return new StaticError(sym);
1958                     else return sym;
1959                 } else {
1960                     bestSoFar = bestOf(bestSoFar, sym);
1961                 }
1962             } finally {
1963                 env1.info.preferredTreeForDiagnostics = null;
1964             }
1965             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1966             env1 = env1.outer;
1967         }
1968 
1969         Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
1970                                 typeargtypes, allowBoxing, useVarargs);
1971         if (sym.exists())
1972             return sym;
1973 
1974         for (Symbol currentSym : env.toplevel.namedImportScope.getSymbolsByName(name)) {
1975             Symbol origin = env.toplevel.namedImportScope.getOrigin(currentSym).owner;
1976             if (currentSym.kind == MTH) {
1977                 if (currentSym.owner.type != origin.type)
1978                     currentSym = currentSym.clone(origin);
1979                 if (!isAccessible(env, origin.type, currentSym))
1980                     currentSym = new AccessError(env, origin.type, currentSym);
1981                 bestSoFar = selectBest(env, origin.type,
1982                                        argtypes, typeargtypes,
1983                                        currentSym, bestSoFar,
1984                                        allowBoxing, useVarargs);
1985             }
1986         }
1987         if (bestSoFar.exists())
1988             return bestSoFar;
1989 
1990         for (Symbol currentSym : env.toplevel.starImportScope.getSymbolsByName(name)) {
1991             Symbol origin = env.toplevel.starImportScope.getOrigin(currentSym).owner;
1992             if (currentSym.kind == MTH) {
1993                 if (currentSym.owner.type != origin.type)
1994                     currentSym = currentSym.clone(origin);
1995                 if (!isAccessible(env, origin.type, currentSym))
1996                     currentSym = new AccessError(env, origin.type, currentSym);
1997                 bestSoFar = selectBest(env, origin.type,
1998                                        argtypes, typeargtypes,
1999                                        currentSym, bestSoFar,
2000                                        allowBoxing, useVarargs);
2001             }
2002         }
2003         return bestSoFar;
2004     }
2005 
2006     /** Load toplevel or member class with given fully qualified name and
2007      *  verify that it is accessible.
2008      *  @param env       The current environment.
2009      *  @param name      The fully qualified name of the class to be loaded.
2010      */
2011     Symbol loadClass(Env&lt;AttrContext&gt; env, Name name, RecoveryLoadClass recoveryLoadClass) {
2012         try {
2013             ClassSymbol c = finder.loadClass(env.toplevel.modle, name);
2014             return isAccessible(env, c) ? c : new AccessError(env, null, c);
2015         } catch (ClassFinder.BadClassFile err) {
2016             return new BadClassFileError(err);
2017         } catch (CompletionFailure ex) {
2018             Symbol candidate = recoveryLoadClass.loadClass(env, name);
2019 
2020             if (candidate != null) {
2021                 return candidate;
2022             }
2023 
2024             return typeNotFound;
2025         }
2026     }
2027 
2028     public interface RecoveryLoadClass {
2029         Symbol loadClass(Env&lt;AttrContext&gt; env, Name name);
2030     }
2031 
2032     private final RecoveryLoadClass noRecovery = (env, name) -&gt; null;
2033 
2034     private final RecoveryLoadClass doRecoveryLoadClass = new RecoveryLoadClass() {
2035         @Override public Symbol loadClass(Env&lt;AttrContext&gt; env, Name name) {
2036             List&lt;Name&gt; candidates = Convert.classCandidates(name);
2037             return lookupInvisibleSymbol(env, name,
2038                                          n -&gt; () -&gt; createCompoundIterator(candidates,
2039                                                                            c -&gt; syms.getClassesForName(c)
2040                                                                                     .iterator()),
2041                                          (ms, n) -&gt; {
2042                 for (Name candidate : candidates) {
2043                     try {
2044                         return finder.loadClass(ms, candidate);
2045                     } catch (CompletionFailure cf) {
2046                         //ignore
2047                     }
2048                 }
2049                 return null;
2050             }, sym -&gt; sym.kind == Kind.TYP, typeNotFound);
2051         }
2052     };
2053 
2054     private final RecoveryLoadClass namedImportScopeRecovery = (env, name) -&gt; {
2055         Scope importScope = env.toplevel.namedImportScope;
2056         Symbol existing = importScope.findFirst(Convert.shortName(name),
2057                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2058 
2059         if (existing != null) {
2060             return new InvisibleSymbolError(env, true, existing);
2061         }
2062         return null;
2063     };
2064 
2065     private final RecoveryLoadClass starImportScopeRecovery = (env, name) -&gt; {
2066         Scope importScope = env.toplevel.starImportScope;
2067         Symbol existing = importScope.findFirst(Convert.shortName(name),
2068                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2069 
2070         if (existing != null) {
2071             try {
2072                 existing = finder.loadClass(existing.packge().modle, name);
2073 
2074                 return new InvisibleSymbolError(env, true, existing);
2075             } catch (CompletionFailure cf) {
2076                 //ignore
2077             }
2078         }
2079 
2080         return null;
2081     };
2082 
2083     Symbol lookupPackage(Env&lt;AttrContext&gt; env, Name name) {
2084         PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, name);
2085 
2086         if (allowModules &amp;&amp; isImportOnDemand(env, name)) {
2087             if (pack.members().isEmpty()) {
2088                 return lookupInvisibleSymbol(env, name, syms::getPackagesForName, syms::enterPackage, sym -&gt; {
2089                     sym.complete();
2090                     return !sym.members().isEmpty();
2091                 }, pack);
2092             }
2093         }
2094 
2095         return pack;
2096     }
2097 
2098     private boolean isImportOnDemand(Env&lt;AttrContext&gt; env, Name name) {
2099         if (!env.tree.hasTag(IMPORT))
2100             return false;
2101 
2102         JCTree qualid = ((JCImport) env.tree).qualid;
2103 
2104         if (!qualid.hasTag(SELECT))
2105             return false;
2106 
2107         if (TreeInfo.name(qualid) != names.asterisk)
2108             return false;
2109 
2110         return TreeInfo.fullName(((JCFieldAccess) qualid).selected) == name;
2111     }
2112 
2113     private &lt;S extends Symbol&gt; Symbol lookupInvisibleSymbol(Env&lt;AttrContext&gt; env,
2114                                                             Name name,
2115                                                             Function&lt;Name, Iterable&lt;S&gt;&gt; get,
2116                                                             BiFunction&lt;ModuleSymbol, Name, S&gt; load,
2117                                                             Predicate&lt;S&gt; validate,
2118                                                             Symbol defaultResult) {
2119         //even if a class/package cannot be found in the current module and among packages in modules
2120         //it depends on that are exported for any or this module, the class/package may exist internally
2121         //in some of these modules, or may exist in a module on which this module does not depend.
2122         //Provide better diagnostic in such cases by looking for the class in any module:
2123         Iterable&lt;? extends S&gt; candidates = get.apply(name);
2124 
2125         for (S sym : candidates) {
2126             if (validate.test(sym))
2127                 return createInvisibleSymbolError(env, sym);
2128         }
2129 
2130         Set&lt;ModuleSymbol&gt; recoverableModules = new HashSet&lt;&gt;(syms.getAllModules());
2131 
2132         recoverableModules.add(syms.unnamedModule);
2133         recoverableModules.remove(env.toplevel.modle);
2134 
2135         for (ModuleSymbol ms : recoverableModules) {
2136             //avoid overly eager completing classes from source-based modules, as those
2137             //may not be completable with the current compiler settings:
2138             if (ms.sourceLocation == null) {
2139                 if (ms.classLocation == null) {
2140                     ms = moduleFinder.findModule(ms);
2141                 }
2142 
2143                 if (ms.kind != ERR) {
2144                     S sym = load.apply(ms, name);
2145 
2146                     if (sym != null &amp;&amp; validate.test(sym)) {
2147                         return createInvisibleSymbolError(env, sym);
2148                     }
2149                 }
2150             }
2151         }
2152 
2153         return defaultResult;
2154     }
2155 
2156     private Symbol createInvisibleSymbolError(Env&lt;AttrContext&gt; env, Symbol sym) {
2157         if (symbolPackageVisible(env, sym)) {
2158             return new AccessError(env, null, sym);
2159         } else {
2160             return new InvisibleSymbolError(env, false, sym);
2161         }
2162     }
2163 
2164     private boolean symbolPackageVisible(Env&lt;AttrContext&gt; env, Symbol sym) {
2165         ModuleSymbol envMod = env.toplevel.modle;
2166         PackageSymbol symPack = sym.packge();
2167         return envMod == symPack.modle ||
2168                envMod.visiblePackages.containsKey(symPack.fullname);
2169     }
2170 
2171     /**
2172      * Find a type declared in a scope (not inherited).  Return null
2173      * if none is found.
2174      *  @param env       The current environment.
2175      *  @param site      The original type from where the selection takes
2176      *                   place.
2177      *  @param name      The type&#39;s name.
2178      *  @param c         The class to search for the member type. This is
2179      *                   always a superclass or implemented interface of
2180      *                   site&#39;s class.
2181      */
2182     Symbol findImmediateMemberType(Env&lt;AttrContext&gt; env,
2183                                    Type site,
2184                                    Name name,
2185                                    TypeSymbol c) {
2186         for (Symbol sym : c.members().getSymbolsByName(name)) {
2187             if (sym.kind == TYP) {
2188                 return isAccessible(env, site, sym)
2189                     ? sym
2190                     : new AccessError(env, site, sym);
2191             }
2192         }
2193         return typeNotFound;
2194     }
2195 
2196     /** Find a member type inherited from a superclass or interface.
2197      *  @param env       The current environment.
2198      *  @param site      The original type from where the selection takes
2199      *                   place.
2200      *  @param name      The type&#39;s name.
2201      *  @param c         The class to search for the member type. This is
2202      *                   always a superclass or implemented interface of
2203      *                   site&#39;s class.
2204      */
2205     Symbol findInheritedMemberType(Env&lt;AttrContext&gt; env,
2206                                    Type site,
2207                                    Name name,
2208                                    TypeSymbol c) {
2209         Symbol bestSoFar = typeNotFound;
2210         Symbol sym;
2211         Type st = types.supertype(c.type);
2212         if (st != null &amp;&amp; st.hasTag(CLASS)) {
2213             sym = findMemberType(env, site, name, st.tsym);
2214             bestSoFar = bestOf(bestSoFar, sym);
2215         }
2216         for (List&lt;Type&gt; l = types.interfaces(c.type);
2217              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
2218              l = l.tail) {
2219             sym = findMemberType(env, site, name, l.head.tsym);
2220             if (!bestSoFar.kind.isResolutionError() &amp;&amp;
2221                 !sym.kind.isResolutionError() &amp;&amp;
2222                 sym.owner != bestSoFar.owner)
2223                 bestSoFar = new AmbiguityError(bestSoFar, sym);
2224             else
2225                 bestSoFar = bestOf(bestSoFar, sym);
2226         }
2227         return bestSoFar;
2228     }
2229 
2230     /** Find qualified member type.
2231      *  @param env       The current environment.
2232      *  @param site      The original type from where the selection takes
2233      *                   place.
2234      *  @param name      The type&#39;s name.
2235      *  @param c         The class to search for the member type. This is
2236      *                   always a superclass or implemented interface of
2237      *                   site&#39;s class.
2238      */
2239     Symbol findMemberType(Env&lt;AttrContext&gt; env,
2240                           Type site,
2241                           Name name,
2242                           TypeSymbol c) {
2243         Symbol sym = findImmediateMemberType(env, site, name, c);
2244 
2245         if (sym != typeNotFound)
2246             return sym;
2247 
2248         return findInheritedMemberType(env, site, name, c);
2249 
2250     }
2251 
2252     /** Find a global type in given scope and load corresponding class.
2253      *  @param env       The current environment.
2254      *  @param scope     The scope in which to look for the type.
2255      *  @param name      The type&#39;s name.
2256      */
2257     Symbol findGlobalType(Env&lt;AttrContext&gt; env, Scope scope, Name name, RecoveryLoadClass recoveryLoadClass) {
2258         Symbol bestSoFar = typeNotFound;
2259         for (Symbol s : scope.getSymbolsByName(name)) {
2260             Symbol sym = loadClass(env, s.flatName(), recoveryLoadClass);
2261             if (bestSoFar.kind == TYP &amp;&amp; sym.kind == TYP &amp;&amp;
2262                 bestSoFar != sym)
2263                 return new AmbiguityError(bestSoFar, sym);
2264             else
2265                 bestSoFar = bestOf(bestSoFar, sym);
2266         }
2267         return bestSoFar;
2268     }
2269 
2270     Symbol findTypeVar(Env&lt;AttrContext&gt; currentEnv, Env&lt;AttrContext&gt; originalEnv, Name name, boolean staticOnly) {
2271         for (Symbol sym : currentEnv.info.scope.getSymbolsByName(name)) {
2272             if (sym.kind == TYP) {
2273                 if (staticOnly &amp;&amp;
2274                     sym.type.hasTag(TYPEVAR) &amp;&amp;
2275                     ((sym.owner.kind == TYP) ||
2276                     // are we trying to access a TypeVar defined in a method from a local static type: interface, enum or record?
2277                     allowRecords &amp;&amp;
2278                     (sym.owner.kind == MTH &amp;&amp;
2279                     currentEnv != originalEnv &amp;&amp;
2280                     !isInnerClassOfMethod(sym.owner, originalEnv.tree.hasTag(CLASSDEF) ?
2281                             ((JCClassDecl)originalEnv.tree).sym :
2282                             originalEnv.enclClass.sym)))) {
2283                     return new StaticError(sym);
2284                 }
2285                 return sym;
2286             }
2287         }
2288         return typeNotFound;
2289     }
2290 
2291     boolean isInnerClassOfMethod(Symbol msym, Symbol csym) {
2292         if (csym.owner == msym &amp;&amp; !csym.isStatic()) {
2293             return true;
2294         } else if (csym.owner.kind == TYP) {
2295             return isInnerClassOfMethod(msym, csym.owner);
2296         } else {
2297             return false;
2298         }
2299     }
2300 
2301     /** Find an unqualified type symbol.
2302      *  @param env       The current environment.
2303      *  @param name      The type&#39;s name.
2304      */
2305     Symbol findType(Env&lt;AttrContext&gt; env, Name name) {
2306         if (name == names.empty)
2307             return typeNotFound; // do not allow inadvertent &quot;lookup&quot; of anonymous types
2308         Symbol bestSoFar = typeNotFound;
2309         Symbol sym;
2310         boolean staticOnly = false;
2311         for (Env&lt;AttrContext&gt; env1 = env; env1.outer != null; env1 = env1.outer) {
2312             if (isStatic(env1)) staticOnly = true;
2313             // First, look for a type variable and the first member type
2314             final Symbol tyvar = findTypeVar(env1, env, name, staticOnly);
2315             sym = findImmediateMemberType(env1, env1.enclClass.sym.type,
2316                                           name, env1.enclClass.sym);
2317 
2318             // Return the type variable if we have it, and have no
2319             // immediate member, OR the type variable is for a method.
2320             if (tyvar != typeNotFound) {
2321                 if (env.baseClause || sym == typeNotFound ||
2322                     (tyvar.kind == TYP &amp;&amp; tyvar.exists() &amp;&amp;
2323                      tyvar.owner.kind == MTH)) {
2324                     return tyvar;
2325                 }
2326             }
2327 
2328             // If the environment is a class def, finish up,
2329             // otherwise, do the entire findMemberType
2330             if (sym == typeNotFound)
2331                 sym = findInheritedMemberType(env1, env1.enclClass.sym.type,
2332                                               name, env1.enclClass.sym);
2333 
2334             if (staticOnly &amp;&amp; sym.kind == TYP &amp;&amp;
2335                 sym.type.hasTag(CLASS) &amp;&amp;
2336                 sym.type.getEnclosingType().hasTag(CLASS) &amp;&amp;
2337                 env1.enclClass.sym.type.isParameterized() &amp;&amp;
2338                 sym.type.getEnclosingType().isParameterized())
2339                 return new StaticError(sym);
2340             else if (sym.exists()) return sym;
2341             else bestSoFar = bestOf(bestSoFar, sym);
2342 
2343             JCClassDecl encl = env1.baseClause ? (JCClassDecl)env1.tree : env1.enclClass;
2344             if ((encl.sym.flags() &amp; STATIC) != 0)
2345                 staticOnly = true;
2346         }
2347 
2348         if (!env.tree.hasTag(IMPORT)) {
2349             sym = findGlobalType(env, env.toplevel.namedImportScope, name, namedImportScopeRecovery);
2350             if (sym.exists()) return sym;
2351             else bestSoFar = bestOf(bestSoFar, sym);
2352 
2353             sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
2354             if (sym.exists()) return sym;
2355             else bestSoFar = bestOf(bestSoFar, sym);
2356 
2357             sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
2358             if (sym.exists()) return sym;
2359             else bestSoFar = bestOf(bestSoFar, sym);
2360 
2361             sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
2362             if (sym.exists()) return sym;
2363             else bestSoFar = bestOf(bestSoFar, sym);
2364         }
2365 
2366         return bestSoFar;
2367     }
2368 
2369     /** Find an unqualified identifier which matches a specified kind set.
2370      *  @param pos       position on which report warnings, if any;
2371      *                   null warnings should not be reported
2372      *  @param env       The current environment.
2373      *  @param name      The identifier&#39;s name.
2374      *  @param kind      Indicates the possible symbol kinds
2375      *                   (a subset of VAL, TYP, PCK).
2376      */
2377     Symbol findIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2378         return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);
2379     }
2380 
2381     Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2382         Symbol bestSoFar = typeNotFound;
2383         Symbol sym;
2384 
2385         if (kind.contains(KindSelector.VAL)) {
2386             sym = findVar(env, name);
2387             if (sym.exists()) return sym;
2388             else bestSoFar = bestOf(bestSoFar, sym);
2389         }
2390 
2391         if (kind.contains(KindSelector.TYP)) {
2392             sym = findType(env, name);
2393 
2394             if (sym.exists()) return sym;
2395             else bestSoFar = bestOf(bestSoFar, sym);
2396         }
2397 
2398         if (kind.contains(KindSelector.PCK))
2399             return lookupPackage(env, name);
2400         else return bestSoFar;
2401     }
2402 
2403     /** Find an identifier in a package which matches a specified kind set.
2404      *  @param pos       position on which report warnings, if any;
2405      *                   null warnings should not be reported
2406      *  @param env       The current environment.
2407      *  @param name      The identifier&#39;s name.
2408      *  @param kind      Indicates the possible symbol kinds
2409      *                   (a nonempty subset of TYP, PCK).
2410      */
2411     Symbol findIdentInPackage(DiagnosticPosition pos,
2412                               Env&lt;AttrContext&gt; env, TypeSymbol pck,
2413                               Name name, KindSelector kind) {
2414         return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);
2415     }
2416 
2417     Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
2418                               Name name, KindSelector kind) {
2419         Name fullname = TypeSymbol.formFullName(name, pck);
2420         Symbol bestSoFar = typeNotFound;
2421         if (kind.contains(KindSelector.TYP)) {
2422             RecoveryLoadClass recoveryLoadClass =
2423                     allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
2424                     !pck.exists() &amp;&amp; !env.info.attributionMode.isSpeculative ?
2425                         doRecoveryLoadClass : noRecovery;
2426             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
2427             if (sym.exists()) {
2428                 // don&#39;t allow programs to use flatnames
2429                 if (name == sym.name) return sym;
2430             }
2431             else bestSoFar = bestOf(bestSoFar, sym);
2432         }
2433         if (kind.contains(KindSelector.PCK)) {
2434             return lookupPackage(env, fullname);
2435         }
2436         return bestSoFar;
2437     }
2438 
2439     /** Find an identifier among the members of a given type `site&#39;.
2440      *  @param pos       position on which report warnings, if any;
2441      *                   null warnings should not be reported
2442      *  @param env       The current environment.
2443      *  @param site      The type containing the symbol to be found.
2444      *  @param name      The identifier&#39;s name.
2445      *  @param kind      Indicates the possible symbol kinds
2446      *                   (a subset of VAL, TYP).
2447      */
2448     Symbol findIdentInType(DiagnosticPosition pos,
2449                            Env&lt;AttrContext&gt; env, Type site,
2450                            Name name, KindSelector kind) {
2451         return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);
2452     }
2453 
2454     Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
2455                            Name name, KindSelector kind) {
2456         Symbol bestSoFar = typeNotFound;
2457         Symbol sym;
2458         if (kind.contains(KindSelector.VAL)) {
2459             sym = findField(env, site, name, site.tsym);
2460             if (sym.exists()) return sym;
2461             else bestSoFar = bestOf(bestSoFar, sym);
2462         }
2463 
2464         if (kind.contains(KindSelector.TYP)) {
2465             sym = findMemberType(env, site, name, site.tsym);
2466             if (sym.exists()) return sym;
2467             else bestSoFar = bestOf(bestSoFar, sym);
2468         }
2469         return bestSoFar;
2470     }
2471 
2472     private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {
2473         if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {
2474             if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var)) {
2475                 bestSoFar = new BadRestrictedTypeError(names.var);
2476             } else if (name.equals(names.yield)) {
2477                 if (allowYieldStatement) {
2478                     bestSoFar = new BadRestrictedTypeError(names.yield);
2479                 } else if (pos != null) {
2480                     log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));
2481                 }
2482             }
2483         }
2484         return bestSoFar;
2485     }
2486 
2487 /* ***************************************************************************
2488  *  Access checking
2489  *  The following methods convert ResolveErrors to ErrorSymbols, issuing
2490  *  an error message in the process
2491  ****************************************************************************/
2492 
2493     /** If `sym&#39; is a bad symbol: report error and return errSymbol
2494      *  else pass through unchanged,
2495      *  additional arguments duplicate what has been used in trying to find the
2496      *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we
2497      *  expect misses to happen frequently.
2498      *
2499      *  @param sym       The symbol that was found, or a ResolveError.
2500      *  @param pos       The position to use for error reporting.
2501      *  @param location  The symbol the served as a context for this lookup
2502      *  @param site      The original type from where the selection took place.
2503      *  @param name      The symbol&#39;s name.
2504      *  @param qualified Did we get here through a qualified expression resolution?
2505      *  @param argtypes  The invocation&#39;s value arguments,
2506      *                   if we looked for a method.
2507      *  @param typeargtypes  The invocation&#39;s type arguments,
2508      *                   if we looked for a method.
2509      *  @param logResolveHelper helper class used to log resolve errors
2510      */
2511     Symbol accessInternal(Symbol sym,
2512                   DiagnosticPosition pos,
2513                   Symbol location,
2514                   Type site,
2515                   Name name,
2516                   boolean qualified,
2517                   List&lt;Type&gt; argtypes,
2518                   List&lt;Type&gt; typeargtypes,
2519                   LogResolveHelper logResolveHelper) {
2520         if (sym.kind.isResolutionError()) {
2521             ResolveError errSym = (ResolveError)sym.baseSymbol();
2522             sym = errSym.access(name, qualified ? site.tsym : syms.noSymbol);
2523             argtypes = logResolveHelper.getArgumentTypes(errSym, sym, name, argtypes);
2524             if (logResolveHelper.resolveDiagnosticNeeded(site, argtypes, typeargtypes)) {
2525                 logResolveError(errSym, pos, location, site, name, argtypes, typeargtypes);
2526             }
2527         }
2528         return sym;
2529     }
2530 
2531     /**
2532      * Variant of the generalized access routine, to be used for generating method
2533      * resolution diagnostics
2534      */
2535     Symbol accessMethod(Symbol sym,
2536                   DiagnosticPosition pos,
2537                   Symbol location,
2538                   Type site,
2539                   Name name,
2540                   boolean qualified,
2541                   List&lt;Type&gt; argtypes,
2542                   List&lt;Type&gt; typeargtypes) {
2543         return accessInternal(sym, pos, location, site, name, qualified, argtypes, typeargtypes, methodLogResolveHelper);
2544     }
2545 
2546     /** Same as original accessMethod(), but without location.
2547      */
2548     Symbol accessMethod(Symbol sym,
2549                   DiagnosticPosition pos,
2550                   Type site,
2551                   Name name,
2552                   boolean qualified,
2553                   List&lt;Type&gt; argtypes,
2554                   List&lt;Type&gt; typeargtypes) {
2555         return accessMethod(sym, pos, site.tsym, site, name, qualified, argtypes, typeargtypes);
2556     }
2557 
2558     /**
2559      * Variant of the generalized access routine, to be used for generating variable,
2560      * type resolution diagnostics
2561      */
2562     Symbol accessBase(Symbol sym,
2563                   DiagnosticPosition pos,
2564                   Symbol location,
2565                   Type site,
2566                   Name name,
2567                   boolean qualified) {
2568         return accessInternal(sym, pos, location, site, name, qualified, List.nil(), null, basicLogResolveHelper);
2569     }
2570 
2571     /** Same as original accessBase(), but without location.
2572      */
2573     Symbol accessBase(Symbol sym,
2574                   DiagnosticPosition pos,
2575                   Type site,
2576                   Name name,
2577                   boolean qualified) {
2578         return accessBase(sym, pos, site.tsym, site, name, qualified);
2579     }
2580 
2581     interface LogResolveHelper {
2582         boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes);
2583         List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes);
2584     }
2585 
2586     LogResolveHelper basicLogResolveHelper = new LogResolveHelper() {
2587         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2588             return !site.isErroneous();
2589         }
2590         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2591             return argtypes;
2592         }
2593     };
2594 
2595     LogResolveHelper methodLogResolveHelper = new LogResolveHelper() {
2596         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2597             return !site.isErroneous() &amp;&amp;
2598                         !Type.isErroneous(argtypes) &amp;&amp;
2599                         (typeargtypes == null || !Type.isErroneous(typeargtypes));
2600         }
2601         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2602             return argtypes.map(new ResolveDeferredRecoveryMap(AttrMode.SPECULATIVE, accessedSym, currentResolutionContext.step));
2603         }
2604     };
2605 
2606     class ResolveDeferredRecoveryMap extends DeferredAttr.RecoveryDeferredTypeMap {
2607 
2608         public ResolveDeferredRecoveryMap(AttrMode mode, Symbol msym, MethodResolutionPhase step) {
2609             deferredAttr.super(mode, msym, step);
2610         }
2611 
2612         @Override
2613         protected Type typeOf(DeferredType dt, Type pt) {
2614             Type res = super.typeOf(dt, pt);
2615             if (!res.isErroneous()) {
2616                 switch (TreeInfo.skipParens(dt.tree).getTag()) {
2617                     case LAMBDA:
2618                     case REFERENCE:
2619                         return dt;
2620                     case CONDEXPR:
2621                         return res == Type.recoveryType ?
2622                                 dt : res;
2623                 }
2624             }
2625             return res;
2626         }
2627     }
2628 
2629     /** Check that sym is not an abstract method.
2630      */
2631     void checkNonAbstract(DiagnosticPosition pos, Symbol sym) {
2632         if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
2633             log.error(pos,
2634                       Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
2635     }
2636 
2637 /* ***************************************************************************
2638  *  Name resolution
2639  *  Naming conventions are as for symbol lookup
2640  *  Unlike the find... methods these methods will report access errors
2641  ****************************************************************************/
2642 
2643     /** Resolve an unqualified (non-method) identifier.
2644      *  @param pos       The position to use for error reporting.
2645      *  @param env       The environment current at the identifier use.
2646      *  @param name      The identifier&#39;s name.
2647      *  @param kind      The set of admissible symbol kinds for the identifier.
2648      */
2649     Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2650                         Name name, KindSelector kind) {
2651         return accessBase(
2652             findIdent(pos, env, name, kind),
2653             pos, env.enclClass.sym.type, name, false);
2654     }
2655 
2656     /** Resolve an unqualified method identifier.
2657      *  @param pos       The position to use for error reporting.
2658      *  @param env       The environment current at the method invocation.
2659      *  @param name      The identifier&#39;s name.
2660      *  @param argtypes  The types of the invocation&#39;s value arguments.
2661      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2662      */
2663     Symbol resolveMethod(DiagnosticPosition pos,
2664                          Env&lt;AttrContext&gt; env,
2665                          Name name,
2666                          List&lt;Type&gt; argtypes,
2667                          List&lt;Type&gt; typeargtypes) {
2668         return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
2669                 new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {
2670                     @Override
2671                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2672                         return findFun(env, name, argtypes, typeargtypes,
2673                                 phase.isBoxingRequired(),
2674                                 phase.isVarargsRequired());
2675                     }});
2676     }
2677 
2678     /** Resolve a qualified method identifier
2679      *  @param pos       The position to use for error reporting.
2680      *  @param env       The environment current at the method invocation.
2681      *  @param site      The type of the qualifying expression, in which
2682      *                   identifier is searched.
2683      *  @param name      The identifier&#39;s name.
2684      *  @param argtypes  The types of the invocation&#39;s value arguments.
2685      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2686      */
2687     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2688                                   Type site, Name name, List&lt;Type&gt; argtypes,
2689                                   List&lt;Type&gt; typeargtypes) {
2690         return resolveQualifiedMethod(pos, env, site.tsym, site, name, argtypes, typeargtypes);
2691     }
2692     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2693                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2694                                   List&lt;Type&gt; typeargtypes) {
2695         return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);
2696     }
2697     private Symbol resolveQualifiedMethod(MethodResolutionContext resolveContext,
2698                                   DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2699                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2700                                   List&lt;Type&gt; typeargtypes) {
2701         return lookupMethod(env, pos, location, resolveContext, new BasicLookupHelper(name, site, argtypes, typeargtypes) {
2702             @Override
2703             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2704                 return findMethod(env, site, name, argtypes, typeargtypes,
2705                         phase.isBoxingRequired(),
2706                         phase.isVarargsRequired());
2707             }
2708             @Override
2709             Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2710                 if (sym.kind.isResolutionError()) {
2711                     sym = super.access(env, pos, location, sym);
2712                 } else {
2713                     MethodSymbol msym = (MethodSymbol)sym;
2714                     if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
2715                         env.info.pendingResolutionPhase = BASIC;
2716                         return findPolymorphicSignatureInstance(env, sym, argtypes);
2717                     }
2718                 }
2719                 return sym;
2720             }
2721         });
2722     }
2723 
2724     /** Find or create an implicit method of exactly the given type (after erasure).
2725      *  Searches in a side table, not the main scope of the site.
2726      *  This emulates the lookup process required by JSR 292 in JVM.
2727      *  @param env       Attribution environment
2728      *  @param spMethod  signature polymorphic method - i.e. MH.invokeExact
2729      *  @param argtypes  The required argument types
2730      */
2731     Symbol findPolymorphicSignatureInstance(Env&lt;AttrContext&gt; env,
2732                                             final Symbol spMethod,
2733                                             List&lt;Type&gt; argtypes) {
2734         Type mtype = infer.instantiatePolymorphicSignatureInstance(env,
2735                 (MethodSymbol)spMethod, currentResolutionContext, argtypes);
2736         return findPolymorphicSignatureInstance(spMethod, mtype);
2737     }
2738 
2739     Symbol findPolymorphicSignatureInstance(final Symbol spMethod,
2740                                             Type mtype) {
2741         for (Symbol sym : polymorphicSignatureScope.getSymbolsByName(spMethod.name)) {
2742             // Check that there is already a method symbol for the method
2743             // type and owner
2744             if (types.isSameType(mtype, sym.type) &amp;&amp;
2745                 spMethod.owner == sym.owner) {
2746                 return sym;
2747             }
2748         }
2749 
2750         // Create the desired method
2751         // Retain static modifier is to support invocations to
2752         // MethodHandle.linkTo* methods
2753         long flags = ABSTRACT | HYPOTHETICAL |
2754                      spMethod.flags() &amp; (Flags.AccessFlags | Flags.STATIC);
2755         Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {
2756             @Override
2757             public Symbol baseSymbol() {
2758                 return spMethod;
2759             }
2760         };
2761         if (!mtype.isErroneous()) { // Cache only if kosher.
2762             polymorphicSignatureScope.enter(msym);
2763         }
2764         return msym;
2765     }
2766 
2767     /** Resolve a qualified method identifier, throw a fatal error if not
2768      *  found.
2769      *  @param pos       The position to use for error reporting.
2770      *  @param env       The environment current at the method invocation.
2771      *  @param site      The type of the qualifying expression, in which
2772      *                   identifier is searched.
2773      *  @param name      The identifier&#39;s name.
2774      *  @param argtypes  The types of the invocation&#39;s value arguments.
2775      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2776      */
2777     public MethodSymbol resolveInternalMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2778                                         Type site, Name name,
2779                                         List&lt;Type&gt; argtypes,
2780                                         List&lt;Type&gt; typeargtypes) {
2781         MethodResolutionContext resolveContext = new MethodResolutionContext();
2782         resolveContext.internalResolution = true;
2783         Symbol sym = resolveQualifiedMethod(resolveContext, pos, env, site.tsym,
2784                 site, name, argtypes, typeargtypes);
2785         if (sym.kind == MTH) return (MethodSymbol)sym;
2786         else throw new FatalError(
2787                  diags.fragment(Fragments.FatalErrCantLocateMeth(name)));
2788     }
2789 
2790     /** Resolve constructor.
2791      *  @param pos       The position to use for error reporting.
2792      *  @param env       The environment current at the constructor invocation.
2793      *  @param site      The type of class for which a constructor is searched.
2794      *  @param argtypes  The types of the constructor invocation&#39;s value
2795      *                   arguments.
2796      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2797      *                   arguments.
2798      */
2799     Symbol resolveConstructor(DiagnosticPosition pos,
2800                               Env&lt;AttrContext&gt; env,
2801                               Type site,
2802                               List&lt;Type&gt; argtypes,
2803                               List&lt;Type&gt; typeargtypes) {
2804         return resolveConstructor(new MethodResolutionContext(), pos, env, site, argtypes, typeargtypes);
2805     }
2806 
2807     private Symbol resolveConstructor(MethodResolutionContext resolveContext,
2808                               final DiagnosticPosition pos,
2809                               Env&lt;AttrContext&gt; env,
2810                               Type site,
2811                               List&lt;Type&gt; argtypes,
2812                               List&lt;Type&gt; typeargtypes) {
2813         return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2814             @Override
2815             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2816                 return findConstructor(pos, env, site, argtypes, typeargtypes,
2817                         phase.isBoxingRequired(),
2818                         phase.isVarargsRequired());
2819             }
2820         });
2821     }
2822 
2823     /** Resolve a constructor, throw a fatal error if not found.
2824      *  @param pos       The position to use for error reporting.
2825      *  @param env       The environment current at the method invocation.
2826      *  @param site      The type to be constructed.
2827      *  @param argtypes  The types of the invocation&#39;s value arguments.
2828      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2829      */
2830     public MethodSymbol resolveInternalConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2831                                         Type site,
2832                                         List&lt;Type&gt; argtypes,
2833                                         List&lt;Type&gt; typeargtypes) {
2834         MethodResolutionContext resolveContext = new MethodResolutionContext();
2835         resolveContext.internalResolution = true;
2836         Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
2837         if (sym.kind == MTH) return (MethodSymbol)sym;
2838         else throw new FatalError(
2839                  diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
2840     }
2841 
2842     Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2843                               Type site, List&lt;Type&gt; argtypes,
2844                               List&lt;Type&gt; typeargtypes,
2845                               boolean allowBoxing,
2846                               boolean useVarargs) {
2847         Symbol sym = findMethod(env, site,
2848                                     names.init, argtypes,
2849                                     typeargtypes, allowBoxing,
2850                                     useVarargs);
2851         chk.checkDeprecated(pos, env.info.scope.owner, sym);
2852         chk.checkPreview(pos, sym);
2853         return sym;
2854     }
2855 
2856     /** Resolve constructor using diamond inference.
2857      *  @param pos       The position to use for error reporting.
2858      *  @param env       The environment current at the constructor invocation.
2859      *  @param site      The type of class for which a constructor is searched.
2860      *                   The scope of this class has been touched in attribution.
2861      *  @param argtypes  The types of the constructor invocation&#39;s value
2862      *                   arguments.
2863      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2864      *                   arguments.
2865      */
2866     Symbol resolveDiamond(DiagnosticPosition pos,
2867                               Env&lt;AttrContext&gt; env,
2868                               Type site,
2869                               List&lt;Type&gt; argtypes,
2870                               List&lt;Type&gt; typeargtypes) {
2871         return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
2872                 new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2873                     @Override
2874                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2875                         return findDiamond(env, site, argtypes, typeargtypes,
2876                                 phase.isBoxingRequired(),
2877                                 phase.isVarargsRequired());
2878                     }
2879                     @Override
2880                     Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2881                         if (sym.kind.isResolutionError()) {
2882                             if (sym.kind != WRONG_MTH &amp;&amp;
2883                                 sym.kind != WRONG_MTHS) {
2884                                 sym = super.access(env, pos, location, sym);
2885                             } else {
2886                                 final JCDiagnostic details = sym.kind == WRONG_MTH ?
2887                                                 ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
2888                                                 null;
2889                                 sym = new DiamondError(sym, currentResolutionContext);
2890                                 sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);
2891                                 env.info.pendingResolutionPhase = currentResolutionContext.step;
2892                             }
2893                         }
2894                         return sym;
2895                     }});
2896     }
2897 
2898     /** This method scans all the constructor symbol in a given class scope -
2899      *  assuming that the original scope contains a constructor of the kind:
2900      *  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo,
2901      *  a method check is executed against the modified constructor type:
2902      *  {@code &lt;X,Y&gt;Foo&lt;X,Y&gt;(X x, Y y)}. This is crucial in order to enable diamond
2903      *  inference. The inferred return type of the synthetic constructor IS
2904      *  the inferred type for the diamond operator.
2905      */
2906     private Symbol findDiamond(Env&lt;AttrContext&gt; env,
2907                               Type site,
2908                               List&lt;Type&gt; argtypes,
2909                               List&lt;Type&gt; typeargtypes,
2910                               boolean allowBoxing,
2911                               boolean useVarargs) {
2912         Symbol bestSoFar = methodNotFound;
2913         TypeSymbol tsym = site.tsym.isInterface() ? syms.objectType.tsym : site.tsym;
2914         for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {
2915             //- System.out.println(&quot; e &quot; + e.sym);
2916             if (sym.kind == MTH &amp;&amp;
2917                 (sym.flags_field &amp; SYNTHETIC) == 0) {
2918                     List&lt;Type&gt; oldParams = sym.type.hasTag(FORALL) ?
2919                             ((ForAll)sym.type).tvars :
2920                             List.nil();
2921                     Type constrType = new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),
2922                                                  types.createMethodTypeWithReturn(sym.type.asMethodType(), site));
2923                     MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {
2924                         @Override
2925                         public Symbol baseSymbol() {
2926                             return sym;
2927                         }
2928                     };
2929                     bestSoFar = selectBest(env, site, argtypes, typeargtypes,
2930                             newConstr,
2931                             bestSoFar,
2932                             allowBoxing,
2933                             useVarargs);
2934             }
2935         }
2936         return bestSoFar;
2937     }
2938 
2939     Symbol getMemberReference(DiagnosticPosition pos,
2940             Env&lt;AttrContext&gt; env,
2941             JCMemberReference referenceTree,
2942             Type site,
2943             Name name) {
2944 
2945         site = types.capture(site);
2946 
2947         ReferenceLookupHelper lookupHelper = makeReferenceLookupHelper(
2948                 referenceTree, site, name, List.nil(), null, VARARITY);
2949 
2950         Env&lt;AttrContext&gt; newEnv = env.dup(env.tree, env.info.dup());
2951         Symbol sym = lookupMethod(newEnv, env.tree.pos(), site.tsym,
2952                 nilMethodCheck, lookupHelper);
2953 
2954         env.info.pendingResolutionPhase = newEnv.info.pendingResolutionPhase;
2955 
2956         return sym;
2957     }
2958 
2959     ReferenceLookupHelper makeReferenceLookupHelper(JCMemberReference referenceTree,
2960                                   Type site,
2961                                   Name name,
2962                                   List&lt;Type&gt; argtypes,
2963                                   List&lt;Type&gt; typeargtypes,
2964                                   MethodResolutionPhase maxPhase) {
2965         if (!name.equals(names.init)) {
2966             //method reference
2967             return new MethodReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase);
2968         } else if (site.hasTag(ARRAY)) {
2969             //array constructor reference
2970             return new ArrayConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2971         } else {
2972             //class constructor reference
2973             return new ConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2974         }
2975     }
2976 
2977     /**
2978      * Resolution of member references is typically done as a single
2979      * overload resolution step, where the argument types A are inferred from
2980      * the target functional descriptor.
2981      *
2982      * If the member reference is a method reference with a type qualifier,
2983      * a two-step lookup process is performed. The first step uses the
2984      * expected argument list A, while the second step discards the first
2985      * type from A (which is treated as a receiver type).
2986      *
2987      * There are two cases in which inference is performed: (i) if the member
2988      * reference is a constructor reference and the qualifier type is raw - in
2989      * which case diamond inference is used to infer a parameterization for the
2990      * type qualifier; (ii) if the member reference is an unbound reference
2991      * where the type qualifier is raw - in that case, during the unbound lookup
2992      * the receiver argument type is used to infer an instantiation for the raw
2993      * qualifier type.
2994      *
2995      * When a multi-step resolution process is exploited, the process of picking
2996      * the resulting symbol is delegated to an helper class {@link com.sun.tools.javac.comp.Resolve.ReferenceChooser}.
2997      *
2998      * This routine returns a pair (T,S), where S is the member reference symbol,
2999      * and T is the type of the class in which S is defined. This is necessary as
3000      * the type T might be dynamically inferred (i.e. if constructor reference
3001      * has a raw qualifier).
3002      */
3003     Pair&lt;Symbol, ReferenceLookupHelper&gt; resolveMemberReference(Env&lt;AttrContext&gt; env,
3004                                   JCMemberReference referenceTree,
3005                                   Type site,
3006                                   Name name,
3007                                   List&lt;Type&gt; argtypes,
3008                                   List&lt;Type&gt; typeargtypes,
3009                                   Type descriptor,
3010                                   MethodCheck methodCheck,
3011                                   InferenceContext inferenceContext,
3012                                   ReferenceChooser referenceChooser) {
3013 
3014         //step 1 - bound lookup
3015         ReferenceLookupHelper boundLookupHelper = makeReferenceLookupHelper(
3016                 referenceTree, site, name, argtypes, typeargtypes, VARARITY);
3017         Env&lt;AttrContext&gt; boundEnv = env.dup(env.tree, env.info.dup());
3018         MethodResolutionContext boundSearchResolveContext = new MethodResolutionContext();
3019         boundSearchResolveContext.methodCheck = methodCheck;
3020         Symbol boundSym = lookupMethod(boundEnv, env.tree.pos(),
3021                 site.tsym, boundSearchResolveContext, boundLookupHelper);
3022         ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext);
3023 
3024         //step 2 - unbound lookup
3025         Symbol unboundSym = methodNotFound;
3026         Env&lt;AttrContext&gt; unboundEnv = env.dup(env.tree, env.info.dup());
3027         ReferenceLookupHelper unboundLookupHelper = boundLookupHelper.unboundLookup(inferenceContext);
3028         ReferenceLookupResult unboundRes = referenceNotFound;
3029         if (unboundLookupHelper != null) {
3030             MethodResolutionContext unboundSearchResolveContext =
3031                     new MethodResolutionContext();
3032             unboundSearchResolveContext.methodCheck = methodCheck;
3033             unboundSym = lookupMethod(unboundEnv, env.tree.pos(),
3034                     site.tsym, unboundSearchResolveContext, unboundLookupHelper);
3035             unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext);
3036         }
3037 
3038         //merge results
3039         Pair&lt;Symbol, ReferenceLookupHelper&gt; res;
3040         ReferenceLookupResult bestRes = referenceChooser.result(boundRes, unboundRes);
3041         res = new Pair&lt;&gt;(bestRes.sym,
3042                 bestRes == unboundRes ? unboundLookupHelper : boundLookupHelper);
3043         env.info.pendingResolutionPhase = bestRes == unboundRes ?
3044                 unboundEnv.info.pendingResolutionPhase :
3045                 boundEnv.info.pendingResolutionPhase;
3046 
3047         if (!res.fst.kind.isResolutionError()) {
3048             //handle sigpoly method references
3049             MethodSymbol msym = (MethodSymbol)res.fst;
3050             if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
3051                 env.info.pendingResolutionPhase = BASIC;
3052                 res = new Pair&lt;&gt;(findPolymorphicSignatureInstance(msym, descriptor), res.snd);
3053             }
3054         }
3055 
3056         return res;
3057     }
3058 
3059     /**
3060      * This class is used to represent a method reference lookup result. It keeps track of two
3061      * things: (i) the symbol found during a method reference lookup and (ii) the static kind
3062      * of the lookup (see {@link com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind}).
3063      */
3064     static class ReferenceLookupResult {
3065 
3066         /**
3067          * Static kind associated with a method reference lookup. Erroneous lookups end up with
3068          * the UNDEFINED kind; successful lookups will end up with either STATIC, NON_STATIC,
3069          * depending on whether all applicable candidates are static or non-static methods,
3070          * respectively. If a successful lookup has both static and non-static applicable methods,
3071          * its kind is set to BOTH.
3072          */
3073         enum StaticKind {
3074             STATIC,
3075             NON_STATIC,
3076             BOTH,
3077             UNDEFINED;
3078 
3079             /**
3080              * Retrieve the static kind associated with a given (method) symbol.
3081              */
3082             static StaticKind from(Symbol s) {
3083                 return s.isStatic() ?
3084                         STATIC : NON_STATIC;
3085             }
3086 
3087             /**
3088              * Merge two static kinds together.
3089              */
3090             static StaticKind reduce(StaticKind sk1, StaticKind sk2) {
3091                 if (sk1 == UNDEFINED) {
3092                     return sk2;
3093                 } else if (sk2 == UNDEFINED) {
3094                     return sk1;
3095                 } else {
3096                     return sk1 == sk2 ? sk1 : BOTH;
3097                 }
3098             }
3099         }
3100 
3101         /** The static kind. */
3102         StaticKind staticKind;
3103 
3104         /** The lookup result. */
3105         Symbol sym;
3106 
3107         ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext) {
3108             this(sym, staticKind(sym, resolutionContext));
3109         }
3110 
3111         private ReferenceLookupResult(Symbol sym, StaticKind staticKind) {
3112             this.staticKind = staticKind;
3113             this.sym = sym;
3114         }
3115 
3116         private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext) {
3117             switch (sym.kind) {
3118                 case MTH:
3119                 case AMBIGUOUS:
3120                     return resolutionContext.candidates.stream()
3121                             .filter(c -&gt; c.isApplicable() &amp;&amp; c.step == resolutionContext.step)
3122                             .map(c -&gt; StaticKind.from(c.sym))
3123                             .reduce(StaticKind::reduce)
3124                             .orElse(StaticKind.UNDEFINED);
3125                 default:
3126                     return StaticKind.UNDEFINED;
3127             }
3128         }
3129 
3130         /**
3131          * Does this result corresponds to a successful lookup (i.e. one where a method has been found?)
3132          */
3133         boolean isSuccess() {
3134             return staticKind != StaticKind.UNDEFINED;
3135         }
3136 
3137         /**
3138          * Does this result have given static kind?
3139          */
3140         boolean hasKind(StaticKind sk) {
3141             return this.staticKind == sk;
3142         }
3143 
3144         /**
3145          * Error recovery helper: can this lookup result be ignored (for the purpose of returning
3146          * some &#39;better&#39; result) ?
3147          */
3148         boolean canIgnore() {
3149             switch (sym.kind) {
3150                 case ABSENT_MTH:
3151                     return true;
3152                 case WRONG_MTH:
3153                     InapplicableSymbolError errSym =
3154                             (InapplicableSymbolError)sym.baseSymbol();
3155                     return new Template(MethodCheckDiag.ARITY_MISMATCH.regex())
3156                             .matches(errSym.errCandidate().snd);
3157                 case WRONG_MTHS:
3158                     InapplicableSymbolsError errSyms =
3159                             (InapplicableSymbolsError)sym.baseSymbol();
3160                     return errSyms.filterCandidates(errSyms.mapCandidates()).isEmpty();
3161                 default:
3162                     return false;
3163             }
3164         }
3165 
3166         static ReferenceLookupResult error(Symbol sym) {
3167             return new ReferenceLookupResult(sym, StaticKind.UNDEFINED);
3168         }
3169     }
3170 
3171     /**
3172      * This abstract class embodies the logic that converts one (bound lookup) or two (unbound lookup)
3173      * {@code ReferenceLookupResult} objects into a (@code Symbol), which is then regarded as the
3174      * result of method reference resolution.
3175      */
3176     abstract class ReferenceChooser {
3177         /**
3178          * Generate a result from a pair of lookup result objects. This method delegates to the
3179          * appropriate result generation routine.
3180          */
3181         ReferenceLookupResult result(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3182             return unboundRes != referenceNotFound ?
3183                     unboundResult(boundRes, unboundRes) :
3184                     boundResult(boundRes);
3185         }
3186 
3187         /**
3188          * Generate a symbol from a given bound lookup result.
3189          */
3190         abstract ReferenceLookupResult boundResult(ReferenceLookupResult boundRes);
3191 
3192         /**
3193          * Generate a symbol from a pair of bound/unbound lookup results.
3194          */
3195         abstract ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes);
3196     }
3197 
3198     /**
3199      * This chooser implements the selection strategy used during a full lookup; this logic
3200      * is described in JLS SE 8 (15.3.2).
3201      */
3202     ReferenceChooser basicReferenceChooser = new ReferenceChooser() {
3203 
3204         @Override
3205         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3206             return !boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC) ?
3207                     boundRes : //the search produces a non-static method
3208                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3209         }
3210 
3211         @Override
3212         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3213             if (boundRes.hasKind(StaticKind.STATIC) &amp;&amp;
3214                     (!unboundRes.isSuccess() || unboundRes.hasKind(StaticKind.STATIC))) {
3215                 //the first search produces a static method and no non-static method is applicable
3216                 //during the second search
3217                 return boundRes;
3218             } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &amp;&amp;
3219                     (!boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC))) {
3220                 //the second search produces a non-static method and no static method is applicable
3221                 //during the first search
3222                 return unboundRes;
3223             } else if (boundRes.isSuccess() &amp;&amp; unboundRes.isSuccess()) {
3224                 //both searches produce some result; ambiguity (error recovery)
3225                 return ReferenceLookupResult.error(ambiguityError(boundRes.sym, unboundRes.sym));
3226             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3227                 //Both searches failed to produce a result with correct staticness (i.e. first search
3228                 //produces an non-static method). Alternatively, a given search produced a result
3229                 //with the right staticness, but the other search has applicable methods with wrong
3230                 //staticness (error recovery)
3231                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3232                         boundRes.sym : unboundRes.sym, true));
3233             } else {
3234                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3235                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3236                         unboundRes : boundRes;
3237             }
3238         }
3239     };
3240 
3241     /**
3242      * This chooser implements the selection strategy used during an arity-based lookup; this logic
3243      * is described in JLS SE 8 (15.12.2.1).
3244      */
3245     ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
3246 
3247         @Override
3248         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3249             return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?
3250                     boundRes : //the search has at least one applicable non-static method
3251                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3252         }
3253 
3254         @Override
3255         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3256             if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
3257                 //the first search has at least one applicable static method
3258                 return boundRes;
3259             } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
3260                 //the second search has at least one applicable non-static method
3261                 return unboundRes;
3262             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3263                 //either the first search produces a non-static method, or second search produces
3264                 //a non-static method (error recovery)
3265                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3266                         boundRes.sym : unboundRes.sym, true));
3267             } else {
3268                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3269                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3270                         unboundRes : boundRes;
3271             }
3272         }
3273     };
3274 
3275     /**
3276      * Helper for defining custom method-like lookup logic; a lookup helper
3277      * provides hooks for (i) the actual lookup logic and (ii) accessing the
3278      * lookup result (this step might result in compiler diagnostics to be generated)
3279      */
3280     abstract class LookupHelper {
3281 
3282         /** name of the symbol to lookup */
3283         Name name;
3284 
3285         /** location in which the lookup takes place */
3286         Type site;
3287 
3288         /** actual types used during the lookup */
3289         List&lt;Type&gt; argtypes;
3290 
3291         /** type arguments used during the lookup */
3292         List&lt;Type&gt; typeargtypes;
3293 
3294         /** Max overload resolution phase handled by this helper */
3295         MethodResolutionPhase maxPhase;
3296 
3297         LookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3298             this.name = name;
3299             this.site = site;
3300             this.argtypes = argtypes;
3301             this.typeargtypes = typeargtypes;
3302             this.maxPhase = maxPhase;
3303         }
3304 
3305         /**
3306          * Should lookup stop at given phase with given result
3307          */
3308         final boolean shouldStop(Symbol sym, MethodResolutionPhase phase) {
3309             return phase.ordinal() &gt; maxPhase.ordinal() ||
3310                 !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;
3311         }
3312 
3313         /**
3314          * Search for a symbol under a given overload resolution phase - this method
3315          * is usually called several times, once per each overload resolution phase
3316          */
3317         abstract Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3318 
3319         /**
3320          * Dump overload resolution info
3321          */
3322         void debug(DiagnosticPosition pos, Symbol sym) {
3323             //do nothing
3324         }
3325 
3326         /**
3327          * Validate the result of the lookup
3328          */
3329         abstract Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym);
3330     }
3331 
3332     abstract class BasicLookupHelper extends LookupHelper {
3333 
3334         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3335             this(name, site, argtypes, typeargtypes, MethodResolutionPhase.VARARITY);
3336         }
3337 
3338         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3339             super(name, site, argtypes, typeargtypes, maxPhase);
3340         }
3341 
3342         @Override
3343         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3344             Symbol sym = doLookup(env, phase);
3345             if (sym.kind == AMBIGUOUS) {
3346                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3347                 sym = a_err.mergeAbstracts(site);
3348             }
3349             return sym;
3350         }
3351 
3352         abstract Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3353 
3354         @Override
3355         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3356             if (sym.kind.isResolutionError()) {
3357                 //if nothing is found return the &#39;first&#39; error
3358                 sym = accessMethod(sym, pos, location, site, name, true, argtypes, typeargtypes);
3359             }
3360             return sym;
3361         }
3362 
3363         @Override
3364         void debug(DiagnosticPosition pos, Symbol sym) {
3365             reportVerboseResolutionDiagnostic(pos, name, site, argtypes, typeargtypes, sym);
3366         }
3367     }
3368 
3369     /**
3370      * Helper class for member reference lookup. A reference lookup helper
3371      * defines the basic logic for member reference lookup; a method gives
3372      * access to an &#39;unbound&#39; helper used to perform an unbound member
3373      * reference lookup.
3374      */
3375     abstract class ReferenceLookupHelper extends LookupHelper {
3376 
3377         /** The member reference tree */
3378         JCMemberReference referenceTree;
3379 
3380         ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3381                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3382             super(name, site, argtypes, typeargtypes, maxPhase);
3383             this.referenceTree = referenceTree;
3384         }
3385 
3386         /**
3387          * Returns an unbound version of this lookup helper. By default, this
3388          * method returns an dummy lookup helper.
3389          */
3390         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3391             return null;
3392         }
3393 
3394         /**
3395          * Get the kind of the member reference
3396          */
3397         abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);
3398 
3399         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3400             if (sym.kind == AMBIGUOUS) {
3401                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3402                 sym = a_err.mergeAbstracts(site);
3403             }
3404             //skip error reporting
3405             return sym;
3406         }
3407     }
3408 
3409     /**
3410      * Helper class for method reference lookup. The lookup logic is based
3411      * upon Resolve.findMethod; in certain cases, this helper class has a
3412      * corresponding unbound helper class (see UnboundMethodReferenceLookupHelper).
3413      * In such cases, non-static lookup results are thrown away.
3414      */
3415     class MethodReferenceLookupHelper extends ReferenceLookupHelper {
3416 
3417         /** The original method reference lookup site. */
3418         Type originalSite;
3419 
3420         MethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3421                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3422             super(referenceTree, name, types.skipTypeVars(site, true), argtypes, typeargtypes, maxPhase);
3423             this.originalSite = site;
3424         }
3425 
3426         @Override
3427         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3428             return findMethod(env, site, name, argtypes, typeargtypes,
3429                     phase.isBoxingRequired(), phase.isVarargsRequired());
3430         }
3431 
3432         @Override
3433         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3434             if (TreeInfo.isStaticSelector(referenceTree.expr, names)) {
3435                 if (argtypes.nonEmpty() &amp;&amp;
3436                         (argtypes.head.hasTag(NONE) ||
3437                         types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {
3438                     return new UnboundMethodReferenceLookupHelper(referenceTree, name,
3439                             originalSite, argtypes, typeargtypes, maxPhase);
3440                 } else {
3441                     return new ReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase) {
3442                         @Override
3443                         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3444                             return this;
3445                         }
3446 
3447                         @Override
3448                         Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3449                             return methodNotFound;
3450                         }
3451 
3452                         @Override
3453                         ReferenceKind referenceKind(Symbol sym) {
3454                             Assert.error();
3455                             return null;
3456                         }
3457                     };
3458                 }
3459             } else {
3460                 return super.unboundLookup(inferenceContext);
3461             }
3462         }
3463 
3464         @Override
3465         ReferenceKind referenceKind(Symbol sym) {
3466             if (sym.isStatic()) {
3467                 return ReferenceKind.STATIC;
3468             } else {
3469                 Name selName = TreeInfo.name(referenceTree.getQualifierExpression());
3470                 return selName != null &amp;&amp; selName == names._super ?
3471                         ReferenceKind.SUPER :
3472                         ReferenceKind.BOUND;
3473             }
3474         }
3475     }
3476 
3477     /**
3478      * Helper class for unbound method reference lookup. Essentially the same
3479      * as the basic method reference lookup helper; main difference is that static
3480      * lookup results are thrown away. If qualifier type is raw, an attempt to
3481      * infer a parameterized type is made using the first actual argument (that
3482      * would otherwise be ignored during the lookup).
3483      */
3484     class UnboundMethodReferenceLookupHelper extends MethodReferenceLookupHelper {
3485 
3486         UnboundMethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3487                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3488             super(referenceTree, name, site, argtypes.tail, typeargtypes, maxPhase);
3489             if (site.isRaw() &amp;&amp; !argtypes.head.hasTag(NONE)) {
3490                 Type asSuperSite = types.asSuper(argtypes.head, site.tsym);
3491                 this.site = types.skipTypeVars(asSuperSite, true);
3492             }
3493         }
3494 
3495         @Override
3496         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3497             return this;
3498         }
3499 
3500         @Override
3501         ReferenceKind referenceKind(Symbol sym) {
3502             return ReferenceKind.UNBOUND;
3503         }
3504     }
3505 
3506     /**
3507      * Helper class for array constructor lookup; an array constructor lookup
3508      * is simulated by looking up a method that returns the array type specified
3509      * as qualifier, and that accepts a single int parameter (size of the array).
3510      */
3511     class ArrayConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3512 
3513         ArrayConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3514                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3515             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3516         }
3517 
3518         @Override
3519         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3520             WriteableScope sc = WriteableScope.create(syms.arrayClass);
3521             MethodSymbol arrayConstr = new MethodSymbol(PUBLIC, name, null, site.tsym);
3522             arrayConstr.type = new MethodType(List.of(syms.intType), site, List.nil(), syms.methodClass);
3523             sc.enter(arrayConstr);
3524             return findMethodInScope(env, site, name, argtypes, typeargtypes, sc, methodNotFound, phase.isBoxingRequired(), phase.isVarargsRequired(), false);
3525         }
3526 
3527         @Override
3528         ReferenceKind referenceKind(Symbol sym) {
3529             return ReferenceKind.ARRAY_CTOR;
3530         }
3531     }
3532 
3533     /**
3534      * Helper class for constructor reference lookup. The lookup logic is based
3535      * upon either Resolve.findMethod or Resolve.findDiamond - depending on
3536      * whether the constructor reference needs diamond inference (this is the case
3537      * if the qualifier type is raw). A special erroneous symbol is returned
3538      * if the lookup returns the constructor of an inner class and there&#39;s no
3539      * enclosing instance in scope.
3540      */
3541     class ConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3542 
3543         boolean needsInference;
3544 
3545         ConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3546                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3547             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3548             if (site.isRaw()) {
3549                 this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());
3550                 needsInference = true;
3551             }
3552         }
3553 
3554         @Override
3555         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3556             Symbol sym = needsInference ?
3557                 findDiamond(env, site, argtypes, typeargtypes, phase.isBoxingRequired(), phase.isVarargsRequired()) :
3558                 findMethod(env, site, name, argtypes, typeargtypes,
3559                         phase.isBoxingRequired(), phase.isVarargsRequired());
3560             return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;
3561         }
3562 
3563         @Override
3564         ReferenceKind referenceKind(Symbol sym) {
3565             return site.getEnclosingType().hasTag(NONE) ?
3566                     ReferenceKind.TOPLEVEL : ReferenceKind.IMPLICIT_INNER;
3567         }
3568     }
3569 
3570     /**
3571      * Main overload resolution routine. On each overload resolution step, a
3572      * lookup helper class is used to perform the method/constructor lookup;
3573      * at the end of the lookup, the helper is used to validate the results
3574      * (this last step might trigger overload resolution diagnostics).
3575      */
3576     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, MethodCheck methodCheck, LookupHelper lookupHelper) {
3577         MethodResolutionContext resolveContext = new MethodResolutionContext();
3578         resolveContext.methodCheck = methodCheck;
3579         return lookupMethod(env, pos, location, resolveContext, lookupHelper);
3580     }
3581 
3582     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location,
3583             MethodResolutionContext resolveContext, LookupHelper lookupHelper) {
3584         MethodResolutionContext prevResolutionContext = currentResolutionContext;
3585         try {
3586             Symbol bestSoFar = methodNotFound;
3587             currentResolutionContext = resolveContext;
3588             for (MethodResolutionPhase phase : methodResolutionSteps) {
3589                 if (lookupHelper.shouldStop(bestSoFar, phase))
3590                     break;
3591                 MethodResolutionPhase prevPhase = currentResolutionContext.step;
3592                 Symbol prevBest = bestSoFar;
3593                 currentResolutionContext.step = phase;
3594                 Symbol sym = lookupHelper.lookup(env, phase);
3595                 lookupHelper.debug(pos, sym);
3596                 bestSoFar = phase.mergeResults(bestSoFar, sym);
3597                 env.info.pendingResolutionPhase = (prevBest == bestSoFar) ? prevPhase : phase;
3598             }
3599             return lookupHelper.access(env, pos, location, bestSoFar);
3600         } finally {
3601             currentResolutionContext = prevResolutionContext;
3602         }
3603     }
3604 
3605     /**
3606      * Resolve `c.name&#39; where name == this or name == super.
3607      * @param pos           The position to use for error reporting.
3608      * @param env           The environment current at the expression.
3609      * @param c             The qualifier.
3610      * @param name          The identifier&#39;s name.
3611      */
3612     Symbol resolveSelf(DiagnosticPosition pos,
3613                        Env&lt;AttrContext&gt; env,
3614                        TypeSymbol c,
3615                        Name name) {
3616         Env&lt;AttrContext&gt; env1 = env;
3617         boolean staticOnly = false;
3618         while (env1.outer != null) {
3619             if (isStatic(env1)) staticOnly = true;
3620             if (env1.enclClass.sym == c) {
3621                 Symbol sym = env1.info.scope.findFirst(name);
3622                 if (sym != null) {
3623                     if (staticOnly) sym = new StaticError(sym);
3624                     return accessBase(sym, pos, env.enclClass.sym.type,
3625                                   name, true);
3626                 }
3627             }
3628             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
3629             env1 = env1.outer;
3630         }
3631         if (c.isInterface() &amp;&amp;
3632             name == names._super &amp;&amp; !isStatic(env) &amp;&amp;
3633             types.isDirectSuperInterface(c, env.enclClass.sym)) {
3634             //this might be a default super call if one of the superinterfaces is &#39;c&#39;
3635             for (Type t : pruneInterfaces(env.enclClass.type)) {
3636                 if (t.tsym == c) {
3637                     env.info.defaultSuperCallSite = t;
3638                     return new VarSymbol(0, names._super,
3639                             types.asSuper(env.enclClass.type, c), env.enclClass.sym);
3640                 }
3641             }
3642             //find a direct super type that is a subtype of &#39;c&#39;
3643             for (Type i : types.directSupertypes(env.enclClass.type)) {
3644                 if (i.tsym.isSubClass(c, types) &amp;&amp; i.tsym != c) {
3645                     log.error(pos,
3646                               Errors.IllegalDefaultSuperCall(c,
3647                                                              Fragments.RedundantSupertype(c, i)));
3648                     return syms.errSymbol;
3649                 }
3650             }
3651             Assert.error();
3652         }
3653         log.error(pos, Errors.NotEnclClass(c));
3654         return syms.errSymbol;
3655     }
3656     //where
3657     private List&lt;Type&gt; pruneInterfaces(Type t) {
3658         ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
3659         for (Type t1 : types.interfaces(t)) {
3660             boolean shouldAdd = true;
3661             for (Type t2 : types.directSupertypes(t)) {
3662                 if (t1 != t2 &amp;&amp; types.isSubtypeNoCapture(t2, t1)) {
3663                     shouldAdd = false;
3664                 }
3665             }
3666             if (shouldAdd) {
3667                 result.append(t1);
3668             }
3669         }
3670         return result.toList();
3671     }
3672 
3673 
3674     /**
3675      * Resolve `c.this&#39; for an enclosing class c that contains the
3676      * named member.
3677      * @param pos           The position to use for error reporting.
3678      * @param env           The environment current at the expression.
3679      * @param member        The member that must be contained in the result.
3680      */
3681     Symbol resolveSelfContaining(DiagnosticPosition pos,
3682                                  Env&lt;AttrContext&gt; env,
3683                                  Symbol member,
3684                                  boolean isSuperCall) {
3685         Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);
3686         if (sym == null) {
3687             log.error(pos, Errors.EnclClassRequired(member));
3688             return syms.errSymbol;
3689         } else {
3690             return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);
3691         }
3692     }
3693 
3694     boolean enclosingInstanceMissing(Env&lt;AttrContext&gt; env, Type type) {
3695         if (type.hasTag(CLASS) &amp;&amp; type.getEnclosingType().hasTag(CLASS)) {
3696             Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);
3697             return encl == null || encl.kind.isResolutionError();
3698         }
3699         return false;
3700     }
3701 
3702     private Symbol resolveSelfContainingInternal(Env&lt;AttrContext&gt; env,
3703                                  Symbol member,
3704                                  boolean isSuperCall) {
3705         Name name = names._this;
3706         Env&lt;AttrContext&gt; env1 = isSuperCall ? env.outer : env;
3707         boolean staticOnly = false;
3708         if (env1 != null) {
3709             while (env1 != null &amp;&amp; env1.outer != null) {
3710                 if (isStatic(env1)) staticOnly = true;
3711                 if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {
3712                     Symbol sym = env1.info.scope.findFirst(name);
3713                     if (sym != null) {
3714                         if (staticOnly) sym = new StaticError(sym);
3715                         return sym;
3716                     }
3717                 }
3718                 if ((env1.enclClass.sym.flags() &amp; STATIC) != 0)
3719                     staticOnly = true;
3720                 env1 = env1.outer;
3721             }
3722         }
3723         return null;
3724     }
3725 
3726     /**
3727      * Resolve an appropriate implicit this instance for t&#39;s container.
3728      * JLS 8.8.5.1 and 15.9.2
3729      */
3730     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t) {
3731         return resolveImplicitThis(pos, env, t, false);
3732     }
3733 
3734     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t, boolean isSuperCall) {
3735         Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)
3736                          ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)
3737                          : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;
3738         if (env.info.isSelfCall &amp;&amp; thisType.tsym == env.enclClass.sym) {
3739             log.error(pos, Errors.CantRefBeforeCtorCalled(&quot;this&quot;));
3740         }
3741         return thisType;
3742     }
3743 
3744 /* ***************************************************************************
3745  *  ResolveError classes, indicating error situations when accessing symbols
3746  ****************************************************************************/
3747 
3748     //used by TransTypes when checking target type of synthetic cast
3749     public void logAccessErrorInternal(Env&lt;AttrContext&gt; env, JCTree tree, Type type) {
3750         AccessError error = new AccessError(env, env.enclClass.type, type.tsym);
3751         logResolveError(error, tree.pos(), env.enclClass.sym, env.enclClass.type, null, null, null);
3752     }
3753     //where
3754     private void logResolveError(ResolveError error,
3755             DiagnosticPosition pos,
3756             Symbol location,
3757             Type site,
3758             Name name,
3759             List&lt;Type&gt; argtypes,
3760             List&lt;Type&gt; typeargtypes) {
3761         JCDiagnostic d = error.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
3762                 pos, location, site, name, argtypes, typeargtypes);
3763         if (d != null) {
3764             d.setFlag(DiagnosticFlag.RESOLVE_ERROR);
3765             log.report(d);
3766         }
3767     }
3768 
3769     private final LocalizedString noArgs = new LocalizedString(&quot;compiler.misc.no.args&quot;);
3770 
3771     public Object methodArguments(List&lt;Type&gt; argtypes) {
3772         if (argtypes == null || argtypes.isEmpty()) {
3773             return noArgs;
3774         } else {
3775             ListBuffer&lt;Object&gt; diagArgs = new ListBuffer&lt;&gt;();
3776             for (Type t : argtypes) {
3777                 if (t.hasTag(DEFERRED)) {
3778                     diagArgs.append(((DeferredAttr.DeferredType)t).tree);
3779                 } else {
3780                     diagArgs.append(t);
3781                 }
3782             }
3783             return diagArgs;
3784         }
3785     }
3786 
3787     /**
3788      * Root class for resolution errors. Subclass of ResolveError
3789      * represent a different kinds of resolution error - as such they must
3790      * specify how they map into concrete compiler diagnostics.
3791      */
3792     abstract class ResolveError extends Symbol {
3793 
3794         /** The name of the kind of error, for debugging only. */
3795         final String debugName;
3796 
3797         ResolveError(Kind kind, String debugName) {
3798             super(kind, 0, null, null, null);
3799             this.debugName = debugName;
3800         }
3801 
3802         @Override @DefinedBy(Api.LANGUAGE_MODEL)
3803         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
3804             throw new AssertionError();
3805         }
3806 
3807         @Override
3808         public String toString() {
3809             return debugName;
3810         }
3811 
3812         @Override
3813         public boolean exists() {
3814             return false;
3815         }
3816 
3817         @Override
3818         public boolean isStatic() {
3819             return false;
3820         }
3821 
3822         /**
3823          * Create an external representation for this erroneous symbol to be
3824          * used during attribution - by default this returns the symbol of a
3825          * brand new error type which stores the original type found
3826          * during resolution.
3827          *
3828          * @param name     the name used during resolution
3829          * @param location the location from which the symbol is accessed
3830          */
3831         protected Symbol access(Name name, TypeSymbol location) {
3832             return types.createErrorType(name, location, syms.errSymbol.type).tsym;
3833         }
3834 
3835         /**
3836          * Create a diagnostic representing this resolution error.
3837          *
3838          * @param dkind     The kind of the diagnostic to be created (e.g error).
3839          * @param pos       The position to be used for error reporting.
3840          * @param site      The original type from where the selection took place.
3841          * @param name      The name of the symbol to be resolved.
3842          * @param argtypes  The invocation&#39;s value arguments,
3843          *                  if we looked for a method.
3844          * @param typeargtypes  The invocation&#39;s type arguments,
3845          *                      if we looked for a method.
3846          */
3847         abstract JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3848                 DiagnosticPosition pos,
3849                 Symbol location,
3850                 Type site,
3851                 Name name,
3852                 List&lt;Type&gt; argtypes,
3853                 List&lt;Type&gt; typeargtypes);
3854     }
3855 
3856     /**
3857      * This class is the root class of all resolution errors caused by
3858      * an invalid symbol being found during resolution.
3859      */
3860     abstract class InvalidSymbolError extends ResolveError {
3861 
3862         /** The invalid symbol found during resolution */
3863         Symbol sym;
3864 
3865         InvalidSymbolError(Kind kind, Symbol sym, String debugName) {
3866             super(kind, debugName);
3867             this.sym = sym;
3868         }
3869 
3870         @Override
3871         public boolean exists() {
3872             return true;
3873         }
3874 
3875         @Override
3876         public String toString() {
3877              return super.toString() + &quot; wrongSym=&quot; + sym;
3878         }
3879 
3880         @Override
3881         public Symbol access(Name name, TypeSymbol location) {
3882             if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
3883                 return types.createErrorType(name, location, sym.type).tsym;
3884             else
3885                 return sym;
3886         }
3887     }
3888 
3889     class BadRestrictedTypeError extends ResolveError {
3890         private final Name typeName;
3891         BadRestrictedTypeError(Name typeName) {
3892             super(Kind.BAD_RESTRICTED_TYPE, &quot;bad var use&quot;);
3893             this.typeName = typeName;
3894         }
3895 
3896         @Override
3897         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3898             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.restricted.type&quot;, typeName);
3899         }
3900     }
3901 
3902     /**
3903      * InvalidSymbolError error class indicating that a symbol matching a
3904      * given name does not exists in a given site.
3905      */
3906     class SymbolNotFoundError extends ResolveError {
3907 
3908         SymbolNotFoundError(Kind kind) {
3909             this(kind, &quot;symbol not found error&quot;);
3910         }
3911 
3912         SymbolNotFoundError(Kind kind, String debugName) {
3913             super(kind, debugName);
3914         }
3915 
3916         @Override
3917         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3918                 DiagnosticPosition pos,
3919                 Symbol location,
3920                 Type site,
3921                 Name name,
3922                 List&lt;Type&gt; argtypes,
3923                 List&lt;Type&gt; typeargtypes) {
3924             argtypes = argtypes == null ? List.nil() : argtypes;
3925             typeargtypes = typeargtypes == null ? List.nil() : typeargtypes;
3926             if (name == names.error)
3927                 return null;
3928 
3929             boolean hasLocation = false;
3930             if (location == null) {
3931                 location = site.tsym;
3932             }
3933             if (!location.name.isEmpty()) {
3934                 if (location.kind == PCK &amp;&amp; !site.tsym.exists()) {
3935                     return diags.create(dkind, log.currentSource(), pos,
3936                         &quot;doesnt.exist&quot;, location);
3937                 }
3938                 hasLocation = !location.name.equals(names._this) &amp;&amp;
3939                         !location.name.equals(names._super);
3940             }
3941             boolean isConstructor = name == names.init;
3942             KindName kindname = isConstructor ? KindName.CONSTRUCTOR : kind.absentKind();
3943             Name idname = isConstructor ? site.tsym.name : name;
3944             String errKey = getErrorKey(kindname, typeargtypes.nonEmpty(), hasLocation);
3945             if (hasLocation) {
3946                 return diags.create(dkind, log.currentSource(), pos,
3947                         errKey, kindname, idname, //symbol kindname, name
3948                         typeargtypes, args(argtypes), //type parameters and arguments (if any)
3949                         getLocationDiag(location, site)); //location kindname, type
3950             }
3951             else {
3952                 return diags.create(dkind, log.currentSource(), pos,
3953                         errKey, kindname, idname, //symbol kindname, name
3954                         typeargtypes, args(argtypes)); //type parameters and arguments (if any)
3955             }
3956         }
3957         //where
3958         private Object args(List&lt;Type&gt; args) {
3959             return args.isEmpty() ? args : methodArguments(args);
3960         }
3961 
3962         private String getErrorKey(KindName kindname, boolean hasTypeArgs, boolean hasLocation) {
3963             String key = &quot;cant.resolve&quot;;
3964             String suffix = hasLocation ? &quot;.location&quot; : &quot;&quot;;
3965             switch (kindname) {
3966                 case METHOD:
3967                 case CONSTRUCTOR: {
3968                     suffix += &quot;.args&quot;;
3969                     suffix += hasTypeArgs ? &quot;.params&quot; : &quot;&quot;;
3970                 }
3971             }
3972             return key + suffix;
3973         }
3974         private JCDiagnostic getLocationDiag(Symbol location, Type site) {
3975             if (location.kind == VAR) {
3976                 return diags.fragment(Fragments.Location1(kindName(location),
3977                                                           location,
3978                                                           location.type));
3979             } else {
3980                 return diags.fragment(Fragments.Location(typeKindName(site),
3981                                       site,
3982                                       null));
3983             }
3984         }
3985     }
3986 
3987     /**
3988      * InvalidSymbolError error class indicating that a given symbol
3989      * (either a method, a constructor or an operand) is not applicable
3990      * given an actual arguments/type argument list.
3991      */
3992     class InapplicableSymbolError extends ResolveError {
3993 
3994         protected MethodResolutionContext resolveContext;
3995 
3996         InapplicableSymbolError(MethodResolutionContext context) {
3997             this(WRONG_MTH, &quot;inapplicable symbol error&quot;, context);
3998         }
3999 
4000         protected InapplicableSymbolError(Kind kind, String debugName, MethodResolutionContext context) {
4001             super(kind, debugName);
4002             this.resolveContext = context;
4003         }
4004 
4005         @Override
4006         public String toString() {
4007             return super.toString();
4008         }
4009 
4010         @Override
4011         public boolean exists() {
4012             return true;
4013         }
4014 
4015         @Override
4016         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4017                 DiagnosticPosition pos,
4018                 Symbol location,
4019                 Type site,
4020                 Name name,
4021                 List&lt;Type&gt; argtypes,
4022                 List&lt;Type&gt; typeargtypes) {
4023             if (name == names.error)
4024                 return null;
4025 
4026             Pair&lt;Symbol, JCDiagnostic&gt; c = errCandidate();
4027             if (compactMethodDiags) {
4028                 JCDiagnostic simpleDiag =
4029                     MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd);
4030                 if (simpleDiag != null) {
4031                     return simpleDiag;
4032                 }
4033             }
4034             Symbol ws = c.fst.asMemberOf(site, types);
4035             return diags.create(dkind, log.currentSource(), pos,
4036                       &quot;cant.apply.symbol&quot;,
4037                       kindName(ws),
4038                       ws.name == names.init ? ws.owner.name : ws.name,
4039                       methodArguments(ws.type.getParameterTypes()),
4040                       methodArguments(argtypes),
4041                       kindName(ws.owner),
4042                       ws.owner.type,
4043                       c.snd);
4044         }
4045 
4046         @Override
4047         public Symbol access(Name name, TypeSymbol location) {
4048             Symbol sym = bestCandidate();
4049             return types.createErrorType(name, location, sym != null ? sym.type : syms.errSymbol.type).tsym;
4050         }
4051 
4052         protected Symbol bestCandidate() {
4053             return errCandidate().fst;
4054         }
4055 
4056         protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4057             Candidate bestSoFar = null;
4058             for (Candidate c : resolveContext.candidates) {
4059                 if (c.isApplicable()) continue;
4060                 bestSoFar = c;
4061             }
4062             Assert.checkNonNull(bestSoFar);
4063             return new Pair&lt;&gt;(bestSoFar.sym, bestSoFar.details);
4064         }
4065     }
4066 
4067     /**
4068      * ResolveError error class indicating that a symbol (either methods, constructors or operand)
4069      * is not applicable given an actual arguments/type argument list.
4070      */
4071     class InapplicableSymbolsError extends InapplicableSymbolError {
4072 
4073         InapplicableSymbolsError(MethodResolutionContext context) {
4074             super(WRONG_MTHS, &quot;inapplicable symbols&quot;, context);
4075         }
4076 
4077         @Override
4078         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4079                 DiagnosticPosition pos,
4080                 Symbol location,
4081                 Type site,
4082                 Name name,
4083                 List&lt;Type&gt; argtypes,
4084                 List&lt;Type&gt; typeargtypes) {
4085             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4086             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = compactMethodDiags ?
4087                     filterCandidates(candidatesMap) :
4088                     mapCandidates();
4089             if (filteredCandidates.isEmpty()) {
4090                 filteredCandidates = candidatesMap;
4091             }
4092             boolean truncatedDiag = candidatesMap.size() != filteredCandidates.size();
4093             if (filteredCandidates.size() &gt; 1) {
4094                 JCDiagnostic err = diags.create(dkind,
4095                         null,
4096                         truncatedDiag ?
4097                             EnumSet.of(DiagnosticFlag.COMPRESSED) :
4098                             EnumSet.noneOf(DiagnosticFlag.class),
4099                         log.currentSource(),
4100                         pos,
4101                         &quot;cant.apply.symbols&quot;,
4102                         name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),
4103                         name == names.init ? site.tsym.name : name,
4104                         methodArguments(argtypes));
4105                 return new JCDiagnostic.MultilineDiagnostic(err, candidateDetails(filteredCandidates, site));
4106             } else if (filteredCandidates.size() == 1) {
4107                 Map.Entry&lt;Symbol, JCDiagnostic&gt; _e =
4108                                 filteredCandidates.entrySet().iterator().next();
4109                 final Pair&lt;Symbol, JCDiagnostic&gt; p = new Pair&lt;&gt;(_e.getKey(), _e.getValue());
4110                 JCDiagnostic d = new InapplicableSymbolError(resolveContext) {
4111                     @Override
4112                     protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4113                         return p;
4114                     }
4115                 }.getDiagnostic(dkind, pos,
4116                     location, site, name, argtypes, typeargtypes);
4117                 if (truncatedDiag) {
4118                     d.setFlag(DiagnosticFlag.COMPRESSED);
4119                 }
4120                 return d;
4121             } else {
4122                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind, pos,
4123                     location, site, name, argtypes, typeargtypes);
4124             }
4125         }
4126         //where
4127             private Map&lt;Symbol, JCDiagnostic&gt; mapCandidates() {
4128                 MostSpecificMap candidates = new MostSpecificMap();
4129                 for (Candidate c : resolveContext.candidates) {
4130                     if (c.isApplicable()) continue;
4131                     candidates.put(c);
4132                 }
4133                 return candidates;
4134             }
4135 
4136             @SuppressWarnings(&quot;serial&quot;)
4137             private class MostSpecificMap extends LinkedHashMap&lt;Symbol, JCDiagnostic&gt; {
4138                 private void put(Candidate c) {
4139                     ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
4140                     for (Symbol s : keySet()) {
4141                         if (s == c.sym) {
4142                             continue;
4143                         }
4144                         if (c.sym.overrides(s, (TypeSymbol)s.owner, types, false)) {
4145                             overridden.add(s);
4146                         } else if (s.overrides(c.sym, (TypeSymbol)c.sym.owner, types, false)) {
4147                             return;
4148                         }
4149                     }
4150                     for (Symbol s : overridden) {
4151                         remove(s);
4152                     }
4153                     put(c.sym, c.details);
4154                 }
4155             }
4156 
4157             Map&lt;Symbol, JCDiagnostic&gt; filterCandidates(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap) {
4158                 Map&lt;Symbol, JCDiagnostic&gt; candidates = new LinkedHashMap&lt;&gt;();
4159                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4160                     JCDiagnostic d = _entry.getValue();
4161                     if (!new Template(MethodCheckDiag.ARITY_MISMATCH.regex()).matches(d)) {
4162                         candidates.put(_entry.getKey(), d);
4163                     }
4164                 }
4165                 return candidates;
4166             }
4167 
4168             private List&lt;JCDiagnostic&gt; candidateDetails(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap, Type site) {
4169                 List&lt;JCDiagnostic&gt; details = List.nil();
4170                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4171                     Symbol sym = _entry.getKey();
4172                     JCDiagnostic detailDiag =
4173                             diags.fragment(Fragments.InapplicableMethod(Kinds.kindName(sym),
4174                                                                         sym.location(site, types),
4175                                                                         sym.asMemberOf(site, types),
4176                                                                         _entry.getValue()));
4177                     details = details.prepend(detailDiag);
4178                 }
4179                 //typically members are visited in reverse order (see Scope)
4180                 //so we need to reverse the candidate list so that candidates
4181                 //conform to source order
4182                 return details;
4183             }
4184 
4185         @Override
4186         protected Symbol bestCandidate() {
4187             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4188             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = filterCandidates(candidatesMap);
4189             if (filteredCandidates.size() == 1) {
4190                 return filteredCandidates.keySet().iterator().next();
4191             }
4192             return null;
4193         }
4194     }
4195 
4196     /**
4197      * DiamondError error class indicating that a constructor symbol is not applicable
4198      * given an actual arguments/type argument list using diamond inference.
4199      */
4200     class DiamondError extends InapplicableSymbolError {
4201 
4202         Symbol sym;
4203 
4204         public DiamondError(Symbol sym, MethodResolutionContext context) {
4205             super(sym.kind, &quot;diamondError&quot;, context);
4206             this.sym = sym;
4207         }
4208 
4209         JCDiagnostic getDetails() {
4210             return (sym.kind == WRONG_MTH) ?
4211                     ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
4212                     null;
4213         }
4214 
4215         @Override
4216         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
4217                 Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4218             JCDiagnostic details = getDetails();
4219             if (details != null &amp;&amp; compactMethodDiags) {
4220                 JCDiagnostic simpleDiag =
4221                         MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, details);
4222                 if (simpleDiag != null) {
4223                     return simpleDiag;
4224                 }
4225             }
4226             String key = details == null ?
4227                 &quot;cant.apply.diamond&quot; :
4228                 &quot;cant.apply.diamond.1&quot;;
4229             return diags.create(dkind, log.currentSource(), pos, key,
4230                     Fragments.Diamond(site.tsym), details);
4231         }
4232     }
4233 
4234     /**
4235      * An InvalidSymbolError error class indicating that a symbol is not
4236      * accessible from a given site
4237      */
4238     class AccessError extends InvalidSymbolError {
4239 
4240         private Env&lt;AttrContext&gt; env;
4241         private Type site;
4242 
4243         AccessError(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
4244             super(HIDDEN, sym, &quot;access error&quot;);
4245             this.env = env;
4246             this.site = site;
4247         }
4248 
4249         @Override
4250         public boolean exists() {
4251             return false;
4252         }
4253 
4254         @Override
4255         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4256                 DiagnosticPosition pos,
4257                 Symbol location,
4258                 Type site,
4259                 Name name,
4260                 List&lt;Type&gt; argtypes,
4261                 List&lt;Type&gt; typeargtypes) {
4262             if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) {
4263                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind,
4264                         pos, location, site, name, argtypes, typeargtypes);
4265             }
4266             else if ((sym.flags() &amp; PUBLIC) != 0
4267                 || (env != null &amp;&amp; this.site != null
4268                     &amp;&amp; !isAccessible(env, this.site))) {
4269                 if (sym.owner.kind == PCK) {
4270                     return diags.create(dkind, log.currentSource(),
4271                             pos, &quot;not.def.access.package.cant.access&quot;,
4272                         sym, sym.location(), inaccessiblePackageReason(env, sym.packge()));
4273                 } else if (   sym.packge() != syms.rootPackage
4274                            &amp;&amp; !symbolPackageVisible(env, sym)) {
4275                     return diags.create(dkind, log.currentSource(),
4276                             pos, &quot;not.def.access.class.intf.cant.access.reason&quot;,
4277                             sym, sym.location(), sym.location().packge(),
4278                             inaccessiblePackageReason(env, sym.packge()));
4279                 } else {
4280                     return diags.create(dkind, log.currentSource(),
4281                             pos, &quot;not.def.access.class.intf.cant.access&quot;,
4282                         sym, sym.location());
4283                 }
4284             }
4285             else if ((sym.flags() &amp; (PRIVATE | PROTECTED)) != 0) {
4286                 return diags.create(dkind, log.currentSource(),
4287                         pos, &quot;report.access&quot;, sym,
4288                         asFlagSet(sym.flags() &amp; (PRIVATE | PROTECTED)),
4289                         sym.location());
4290             }
4291             else {
4292                 return diags.create(dkind, log.currentSource(),
4293                         pos, &quot;not.def.public.cant.access&quot;, sym, sym.location());
4294             }
4295         }
4296 
4297         private String toString(Type type) {
4298             StringBuilder sb = new StringBuilder();
4299             sb.append(type);
4300             if (type != null) {
4301                 sb.append(&quot;[tsym:&quot;).append(type.tsym);
4302                 if (type.tsym != null)
4303                     sb.append(&quot;packge:&quot;).append(type.tsym.packge());
4304                 sb.append(&quot;]&quot;);
4305             }
4306             return sb.toString();
4307         }
4308     }
4309 
4310     class InvisibleSymbolError extends InvalidSymbolError {
4311 
4312         private final Env&lt;AttrContext&gt; env;
4313         private final boolean suppressError;
4314 
4315         InvisibleSymbolError(Env&lt;AttrContext&gt; env, boolean suppressError, Symbol sym) {
4316             super(HIDDEN, sym, &quot;invisible class error&quot;);
4317             this.env = env;
4318             this.suppressError = suppressError;
4319             this.name = sym.name;
4320         }
4321 
4322         @Override
4323         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4324                 DiagnosticPosition pos,
4325                 Symbol location,
4326                 Type site,
4327                 Name name,
4328                 List&lt;Type&gt; argtypes,
4329                 List&lt;Type&gt; typeargtypes) {
4330             if (suppressError)
4331                 return null;
4332 
4333             if (sym.kind == PCK) {
4334                 JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4335                 return diags.create(dkind, log.currentSource(),
4336                         pos, &quot;package.not.visible&quot;, sym, details);
4337             }
4338 
4339             JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4340 
4341             if (pos.getTree() != null) {
4342                 Symbol o = sym;
4343                 JCTree tree = pos.getTree();
4344 
4345                 while (o.kind != PCK &amp;&amp; tree.hasTag(SELECT)) {
4346                     o = o.owner;
4347                     tree = ((JCFieldAccess) tree).selected;
4348                 }
4349 
4350                 if (o.kind == PCK) {
4351                     pos = tree.pos();
4352 
4353                     return diags.create(dkind, log.currentSource(),
4354                             pos, &quot;package.not.visible&quot;, o, details);
4355                 }
4356             }
4357 
4358             return diags.create(dkind, log.currentSource(),
4359                     pos, &quot;not.def.access.package.cant.access&quot;, sym, sym.packge(), details);
4360         }
4361     }
4362 
4363     JCDiagnostic inaccessiblePackageReason(Env&lt;AttrContext&gt; env, PackageSymbol sym) {
4364         //no dependency:
4365         if (!env.toplevel.modle.readModules.contains(sym.modle)) {
4366             //does not read:
4367             if (sym.modle != syms.unnamedModule) {
4368                 if (env.toplevel.modle != syms.unnamedModule) {
4369                     return diags.fragment(Fragments.NotDefAccessDoesNotRead(env.toplevel.modle,
4370                                                                             sym,
4371                                                                             sym.modle));
4372                 } else {
4373                     return diags.fragment(Fragments.NotDefAccessDoesNotReadFromUnnamed(sym,
4374                                                                                        sym.modle));
4375                 }
4376             } else {
4377                 return diags.fragment(Fragments.NotDefAccessDoesNotReadUnnamed(sym,
4378                                                                                env.toplevel.modle));
4379             }
4380         } else {
4381             if (sym.packge().modle.exports.stream().anyMatch(e -&gt; e.packge == sym)) {
4382                 //not exported to this module:
4383                 if (env.toplevel.modle != syms.unnamedModule) {
4384                     return diags.fragment(Fragments.NotDefAccessNotExportedToModule(sym,
4385                                                                                     sym.modle,
4386                                                                                     env.toplevel.modle));
4387                 } else {
4388                     return diags.fragment(Fragments.NotDefAccessNotExportedToModuleFromUnnamed(sym,
4389                                                                                                sym.modle));
4390                 }
4391             } else {
4392                 //not exported:
4393                 if (env.toplevel.modle != syms.unnamedModule) {
4394                     return diags.fragment(Fragments.NotDefAccessNotExported(sym,
4395                                                                             sym.modle));
4396                 } else {
4397                     return diags.fragment(Fragments.NotDefAccessNotExportedFromUnnamed(sym,
4398                                                                                        sym.modle));
4399                 }
4400             }
4401         }
4402     }
4403 
4404     /**
4405      * InvalidSymbolError error class indicating that an instance member
4406      * has erroneously been accessed from a static context.
4407      */
4408     class StaticError extends InvalidSymbolError {
4409 
4410         StaticError(Symbol sym) {
4411             super(STATICERR, sym, &quot;static error&quot;);
4412         }
4413 
4414         @Override
4415         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4416                 DiagnosticPosition pos,
4417                 Symbol location,
4418                 Type site,
4419                 Name name,
4420                 List&lt;Type&gt; argtypes,
4421                 List&lt;Type&gt; typeargtypes) {
4422             Symbol errSym = ((sym.kind == TYP &amp;&amp; sym.type.hasTag(CLASS))
4423                 ? types.erasure(sym.type).tsym
4424                 : sym);
4425             return diags.create(dkind, log.currentSource(), pos,
4426                     &quot;non-static.cant.be.ref&quot;, kindName(sym), errSym);
4427         }
4428     }
4429 
4430     /**
4431      * InvalidSymbolError error class indicating that a pair of symbols
4432      * (either methods, constructors or operands) are ambiguous
4433      * given an actual arguments/type argument list.
4434      */
4435     class AmbiguityError extends ResolveError {
4436 
4437         /** The other maximally specific symbol */
4438         List&lt;Symbol&gt; ambiguousSyms = List.nil();
4439 
4440         @Override
4441         public boolean exists() {
4442             return true;
4443         }
4444 
4445         AmbiguityError(Symbol sym1, Symbol sym2) {
4446             super(AMBIGUOUS, &quot;ambiguity error&quot;);
4447             ambiguousSyms = flatten(sym2).appendList(flatten(sym1));
4448         }
4449 
4450         private List&lt;Symbol&gt; flatten(Symbol sym) {
4451             if (sym.kind == AMBIGUOUS) {
4452                 return ((AmbiguityError)sym.baseSymbol()).ambiguousSyms;
4453             } else {
4454                 return List.of(sym);
4455             }
4456         }
4457 
4458         AmbiguityError addAmbiguousSymbol(Symbol s) {
4459             ambiguousSyms = ambiguousSyms.prepend(s);
4460             return this;
4461         }
4462 
4463         @Override
4464         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4465                 DiagnosticPosition pos,
4466                 Symbol location,
4467                 Type site,
4468                 Name name,
4469                 List&lt;Type&gt; argtypes,
4470                 List&lt;Type&gt; typeargtypes) {
4471             List&lt;Symbol&gt; diagSyms = ambiguousSyms.reverse();
4472             Symbol s1 = diagSyms.head;
4473             Symbol s2 = diagSyms.tail.head;
4474             Name sname = s1.name;
4475             if (sname == names.init) sname = s1.owner.name;
4476             return diags.create(dkind, log.currentSource(),
4477                     pos, &quot;ref.ambiguous&quot;, sname,
4478                     kindName(s1),
4479                     s1,
4480                     s1.location(site, types),
4481                     kindName(s2),
4482                     s2,
4483                     s2.location(site, types));
4484         }
4485 
4486         /**
4487          * If multiple applicable methods are found during overload and none of them
4488          * is more specific than the others, attempt to merge their signatures.
4489          */
4490         Symbol mergeAbstracts(Type site) {
4491             List&lt;Symbol&gt; ambiguousInOrder = ambiguousSyms.reverse();
4492             return types.mergeAbstracts(ambiguousInOrder, site, true).orElse(this);
4493         }
4494 
4495         @Override
4496         protected Symbol access(Name name, TypeSymbol location) {
4497             Symbol firstAmbiguity = ambiguousSyms.last();
4498             return firstAmbiguity.kind == TYP ?
4499                     types.createErrorType(name, location, firstAmbiguity.type).tsym :
4500                     firstAmbiguity;
4501         }
4502     }
4503 
4504     class BadVarargsMethod extends ResolveError {
4505 
4506         ResolveError delegatedError;
4507 
4508         BadVarargsMethod(ResolveError delegatedError) {
4509             super(delegatedError.kind, &quot;badVarargs&quot;);
4510             this.delegatedError = delegatedError;
4511         }
4512 
4513         @Override
4514         public Symbol baseSymbol() {
4515             return delegatedError.baseSymbol();
4516         }
4517 
4518         @Override
4519         protected Symbol access(Name name, TypeSymbol location) {
4520             return delegatedError.access(name, location);
4521         }
4522 
4523         @Override
4524         public boolean exists() {
4525             return true;
4526         }
4527 
4528         @Override
4529         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4530             return delegatedError.getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes);
4531         }
4532     }
4533 
4534     /**
4535      * BadMethodReferenceError error class indicating that a method reference symbol has been found,
4536      * but with the wrong staticness.
4537      */
4538     class BadMethodReferenceError extends StaticError {
4539 
4540         boolean unboundLookup;
4541 
4542         public BadMethodReferenceError(Symbol sym, boolean unboundLookup) {
4543             super(sym);
4544             this.unboundLookup = unboundLookup;
4545         }
4546 
4547         @Override
4548         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4549             final String key;
4550             if (!unboundLookup) {
4551                 key = &quot;bad.static.method.in.bound.lookup&quot;;
4552             } else if (sym.isStatic()) {
4553                 key = &quot;bad.static.method.in.unbound.lookup&quot;;
4554             } else {
4555                 key = &quot;bad.instance.method.in.unbound.lookup&quot;;
4556             }
4557             return sym.kind.isResolutionError() ?
4558                     ((ResolveError)sym).getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes) :
4559                     diags.create(dkind, log.currentSource(), pos, key, Kinds.kindName(sym), sym);
4560         }
4561     }
4562 
4563     /**
4564      * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,
4565      * but pointing to a class for which an enclosing instance is not available.
4566      */
4567     class BadConstructorReferenceError extends InvalidSymbolError {
4568 
4569         public BadConstructorReferenceError(Symbol sym) {
4570             super(MISSING_ENCL, sym, &quot;BadConstructorReferenceError&quot;);
4571         }
4572 
4573         @Override
4574         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4575            return diags.create(dkind, log.currentSource(), pos,
4576                 &quot;cant.access.inner.cls.constr&quot;, site.tsym.name, argtypes, site.getEnclosingType());
4577         }
4578     }
4579 
4580     class BadClassFileError extends InvalidSymbolError {
4581 
4582         private final CompletionFailure ex;
4583 
4584         public BadClassFileError(CompletionFailure ex) {
4585             super(HIDDEN, ex.sym, &quot;BadClassFileError&quot;);
4586             this.name = sym.name;
4587             this.ex = ex;
4588         }
4589 
4590         @Override
4591         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4592             JCDiagnostic d = diags.create(dkind, log.currentSource(), pos,
4593                 &quot;cant.access&quot;, ex.sym, ex.getDetailValue());
4594 
4595             d.setFlag(DiagnosticFlag.NON_DEFERRABLE);
4596             return d;
4597         }
4598 
4599     }
4600 
4601     /**
4602      * Helper class for method resolution diagnostic simplification.
4603      * Certain resolution diagnostic are rewritten as simpler diagnostic
4604      * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
4605      * is stripped away, as it doesn&#39;t carry additional info. The logic
4606      * for matching a given diagnostic is given in terms of a template
4607      * hierarchy: a diagnostic template can be specified programmatically,
4608      * so that only certain diagnostics are matched. Each templete is then
4609      * associated with a rewriter object that carries out the task of rewtiting
4610      * the diagnostic to a simpler one.
4611      */
4612     static class MethodResolutionDiagHelper {
4613 
4614         /**
4615          * A diagnostic rewriter transforms a method resolution diagnostic
4616          * into a simpler one
4617          */
4618         interface DiagnosticRewriter {
4619             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4620                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4621                     DiagnosticType preferredKind, JCDiagnostic d);
4622         }
4623 
4624         /**
4625          * A diagnostic template is made up of two ingredients: (i) a regular
4626          * expression for matching a diagnostic key and (ii) a list of sub-templates
4627          * for matching diagnostic arguments.
4628          */
4629         static class Template {
4630 
4631             /** regex used to match diag key */
4632             String regex;
4633 
4634             /** templates used to match diagnostic args */
4635             Template[] subTemplates;
4636 
4637             Template(String key, Template... subTemplates) {
4638                 this.regex = key;
4639                 this.subTemplates = subTemplates;
4640             }
4641 
4642             /**
4643              * Returns true if the regex matches the diagnostic key and if
4644              * all diagnostic arguments are matches by corresponding sub-templates.
4645              */
4646             boolean matches(Object o) {
4647                 JCDiagnostic d = (JCDiagnostic)o;
4648                 Object[] args = d.getArgs();
4649                 if (!d.getCode().matches(regex) ||
4650                         subTemplates.length != d.getArgs().length) {
4651                     return false;
4652                 }
4653                 for (int i = 0; i &lt; args.length ; i++) {
4654                     if (!subTemplates[i].matches(args[i])) {
4655                         return false;
4656                     }
4657                 }
4658                 return true;
4659             }
4660         }
4661 
4662         /**
4663          * Common rewriter for all argument mismatch simplifications.
4664          */
4665         static class ArgMismatchRewriter implements DiagnosticRewriter {
4666 
4667             /** the index of the subdiagnostic to be used as primary. */
4668             int causeIndex;
4669 
4670             public ArgMismatchRewriter(int causeIndex) {
4671                 this.causeIndex = causeIndex;
4672             }
4673 
4674             @Override
4675             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4676                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4677                     DiagnosticType preferredKind, JCDiagnostic d) {
4678                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
4679                 DiagnosticPosition pos = d.getDiagnosticPosition();
4680                 if (pos == null) {
4681                     pos = preferredPos;
4682                 }
4683                 return diags.create(preferredKind, preferredSource, pos,
4684                         &quot;prob.found.req&quot;, cause);
4685             }
4686         }
4687 
4688         /** a dummy template that match any diagnostic argument */
4689         static final Template skip = new Template(&quot;&quot;) {
4690             @Override
4691             boolean matches(Object d) {
4692                 return true;
4693             }
4694         };
4695 
4696         /** template for matching inference-free arguments mismatch failures */
4697         static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
4698 
4699         /** template for matching inference related arguments mismatch failures */
4700         static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
4701             @Override
4702             boolean matches(Object o) {
4703                 if (!super.matches(o)) {
4704                     return false;
4705                 }
4706                 JCDiagnostic d = (JCDiagnostic)o;
4707                 @SuppressWarnings(&quot;unchecked&quot;)
4708                 List&lt;Type&gt; tvars = (List&lt;Type&gt;)d.getArgs()[0];
4709                 return !containsAny(d, tvars);
4710             }
4711 
4712             BiPredicate&lt;Object, List&lt;Type&gt;&gt; containsPredicate = (o, ts) -&gt; {
4713                 if (o instanceof Type) {
4714                     return ((Type)o).containsAny(ts);
4715                 } else if (o instanceof JCDiagnostic) {
4716                     return containsAny((JCDiagnostic)o, ts);
4717                 } else {
4718                     return false;
4719                 }
4720             };
4721 
4722             boolean containsAny(JCDiagnostic d, List&lt;Type&gt; ts) {
4723                 return Stream.of(d.getArgs())
4724                         .anyMatch(o -&gt; containsPredicate.test(o, ts));
4725             }
4726         };
4727 
4728         /** rewriter map used for method resolution simplification */
4729         static final Map&lt;Template, DiagnosticRewriter&gt; rewriters = new LinkedHashMap&lt;&gt;();
4730 
4731         static {
4732             rewriters.put(argMismatchTemplate, new ArgMismatchRewriter(0));
4733             rewriters.put(inferArgMismatchTemplate, new ArgMismatchRewriter(1));
4734         }
4735 
4736         /**
4737          * Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it,
4738          * and rewrite it accordingly.
4739          */
4740         static JCDiagnostic rewrite(JCDiagnostic.Factory diags, DiagnosticPosition pos, DiagnosticSource source,
4741                                     DiagnosticType dkind, JCDiagnostic d) {
4742             for (Map.Entry&lt;Template, DiagnosticRewriter&gt; _entry : rewriters.entrySet()) {
4743                 if (_entry.getKey().matches(d)) {
4744                     JCDiagnostic simpleDiag =
4745                             _entry.getValue().rewriteDiagnostic(diags, pos, source, dkind, d);
4746                     simpleDiag.setFlag(DiagnosticFlag.COMPRESSED);
4747                     return simpleDiag;
4748                 }
4749             }
4750             return null;
4751         }
4752     }
4753 
4754     enum MethodResolutionPhase {
4755         BASIC(false, false),
4756         BOX(true, false),
4757         VARARITY(true, true) {
4758             @Override
4759             public Symbol mergeResults(Symbol bestSoFar, Symbol sym) {
4760                 //Check invariants (see {@code LookupHelper.shouldStop})
4761                 Assert.check(bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS);
4762                 if (!sym.kind.isResolutionError()) {
4763                     //varargs resolution successful
4764                     return sym;
4765                 } else {
4766                     //pick best error
4767                     switch (bestSoFar.kind) {
4768                         case WRONG_MTH:
4769                         case WRONG_MTHS:
4770                             //Override previous errors if they were caused by argument mismatch.
4771                             //This generally means preferring current symbols - but we need to pay
4772                             //attention to the fact that the varargs lookup returns &#39;less&#39; candidates
4773                             //than the previous rounds, and adjust that accordingly.
4774                             switch (sym.kind) {
4775                                 case WRONG_MTH:
4776                                     //if the previous round matched more than one method, return that
4777                                     //result instead
4778                                     return bestSoFar.kind == WRONG_MTHS ?
4779                                             bestSoFar : sym;
4780                                 case ABSENT_MTH:
4781                                     //do not override erroneous symbol if the arity lookup did not
4782                                     //match any method
4783                                     return bestSoFar;
4784                                 case WRONG_MTHS:
4785                                 default:
4786                                     //safe to override
4787                                     return sym;
4788                             }
4789                         default:
4790                             //otherwise, return first error
4791                             return bestSoFar;
4792                     }
4793                 }
4794             }
4795         };
4796 
4797         final boolean isBoxingRequired;
4798         final boolean isVarargsRequired;
4799 
4800         MethodResolutionPhase(boolean isBoxingRequired, boolean isVarargsRequired) {
4801            this.isBoxingRequired = isBoxingRequired;
4802            this.isVarargsRequired = isVarargsRequired;
4803         }
4804 
4805         public boolean isBoxingRequired() {
4806             return isBoxingRequired;
4807         }
4808 
4809         public boolean isVarargsRequired() {
4810             return isVarargsRequired;
4811         }
4812 
4813         public Symbol mergeResults(Symbol prev, Symbol sym) {
4814             return sym;
4815         }
4816     }
4817 
4818     final List&lt;MethodResolutionPhase&gt; methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
4819 
4820     /**
4821      * A resolution context is used to keep track of intermediate results of
4822      * overload resolution, such as list of method that are not applicable
4823      * (used to generate more precise diagnostics) and so on. Resolution contexts
4824      * can be nested - this means that when each overload resolution routine should
4825      * work within the resolution context it created.
4826      */
4827     class MethodResolutionContext {
4828 
4829         private List&lt;Candidate&gt; candidates = List.nil();
4830 
4831         MethodResolutionPhase step = null;
4832 
4833         MethodCheck methodCheck = resolveMethodCheck;
4834 
4835         private boolean internalResolution = false;
4836         private DeferredAttr.AttrMode attrMode = DeferredAttr.AttrMode.SPECULATIVE;
4837 
4838         void addInapplicableCandidate(Symbol sym, JCDiagnostic details) {
4839             Candidate c = new Candidate(currentResolutionContext.step, sym, details, null);
4840             candidates = candidates.append(c);
4841         }
4842 
4843         void addApplicableCandidate(Symbol sym, Type mtype) {
4844             Candidate c = new Candidate(currentResolutionContext.step, sym, null, mtype);
4845             candidates = candidates.append(c);
4846         }
4847 
4848         DeferredAttrContext deferredAttrContext(Symbol sym, InferenceContext inferenceContext, ResultInfo pendingResult, Warner warn) {
4849             DeferredAttrContext parent = (pendingResult == null)
4850                 ? deferredAttr.emptyDeferredAttrContext
4851                 : pendingResult.checkContext.deferredAttrContext();
4852             return deferredAttr.new DeferredAttrContext(attrMode, sym, step,
4853                     inferenceContext, parent, warn);
4854         }
4855 
4856         /**
4857          * This class represents an overload resolution candidate. There are two
4858          * kinds of candidates: applicable methods and inapplicable methods;
4859          * applicable methods have a pointer to the instantiated method type,
4860          * while inapplicable candidates contain further details about the
4861          * reason why the method has been considered inapplicable.
4862          */
4863         @SuppressWarnings(&quot;overrides&quot;)
4864         class Candidate {
4865 
4866             final MethodResolutionPhase step;
4867             final Symbol sym;
4868             final JCDiagnostic details;
4869             final Type mtype;
4870 
4871             private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details, Type mtype) {
4872                 this.step = step;
4873                 this.sym = sym;
4874                 this.details = details;
4875                 this.mtype = mtype;
4876             }
4877 
4878             boolean isApplicable() {
4879                 return mtype != null;
4880             }
4881         }
4882 
4883         DeferredAttr.AttrMode attrMode() {
4884             return attrMode;
4885         }
4886 
4887         boolean internal() {
4888             return internalResolution;
4889         }
4890     }
4891 
4892     MethodResolutionContext currentResolutionContext = null;
4893 }
    </pre>
  </body>
</html>