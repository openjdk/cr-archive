<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/man/javac.1</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 .\&quot; Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
   2 .\&quot; DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3 .\&quot;
   4 .\&quot; This code is free software; you can redistribute it and/or modify it
   5 .\&quot; under the terms of the GNU General Public License version 2 only, as
   6 .\&quot; published by the Free Software Foundation.
   7 .\&quot;
   8 .\&quot; This code is distributed in the hope that it will be useful, but WITHOUT
   9 .\&quot; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10 .\&quot; FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
  11 .\&quot; version 2 for more details (a copy is included in the LICENSE file that
  12 .\&quot; accompanied this code).
  13 .\&quot;
  14 .\&quot; You should have received a copy of the GNU General Public License version
  15 .\&quot; 2 along with this work; if not, write to the Free Software Foundation,
  16 .\&quot; Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17 .\&quot;
  18 .\&quot; Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19 .\&quot; or visit www.oracle.com if you need additional information or have any
  20 .\&quot; questions.
  21 .\&quot;
  22 .\&quot; Automatically generated by Pandoc 2.3.1
  23 .\&quot;
  24 .TH &quot;JAVAC&quot; &quot;1&quot; &quot;2020&quot; &quot;JDK 14&quot; &quot;JDK Commands&quot;
  25 .hy
  26 .SH NAME
  27 .PP
  28 javac \- read Java declarations and compile them into class files
  29 .SH SYNOPSIS
  30 .PP
  31 \f[CB]javac\f[R] [\f[I]options\f[R]] [\f[I]sourcefiles\-or\-classnames\f[R]]
  32 .TP
  33 .B \f[I]options\f[R]
  34 Command\-line options.
  35 .RS
  36 .RE
  37 .TP
  38 .B \f[I]sourcefiles\-or\-classnames\f[R]
  39 Source files to be compiled (for example, \f[CB]Shape.java\f[R]) or the
  40 names of previously compiled classes to be processed for annotations
  41 (for example, \f[CB]geometry.MyShape\f[R]).
  42 .RS
  43 .RE
  44 .SH DESCRIPTION
  45 .PP
  46 The \f[CB]javac\f[R] command reads \f[I]source files\f[R] that contain
  47 module, package and type declarations written in the Java programming
  48 language, and compiles them into \f[I]class files\f[R] that run on the
  49 Java Virtual Machine.
  50 .PP
  51 The \f[CB]javac\f[R] command can also \f[B]process annotations\f[R] in Java
  52 source files and classes.
  53 .PP
  54 Source files must have a file name extension of \f[CB]\&amp;.java\f[R].
  55 Class files have a file name extension of \f[CB]\&amp;.class\f[R].
  56 Both source and class files normally have file names that identify the
  57 contents.
  58 For example, a class called \f[CB]Shape\f[R] would be declared in a source
  59 file called \f[CB]Shape.java\f[R], and compiled into a class file called
  60 \f[CB]Shape.class\f[R].
  61 .PP
  62 There are two ways to specify source files to \f[CB]javac\f[R]:
  63 .IP \[bu] 2
  64 For a small number of source files, you can list their file names on the
  65 command line.
  66 .IP \[bu] 2
  67 For a large number of source files, you can use the
  68 \f[B]\f[BC]\@\f[B]\f[BI]filename\f[B]\f[R] option on the command line to
  69 specify an \f[I]argument file\f[R] that lists their file names.
  70 See \f[B]Standard Options\f[R] for a description of the option and
  71 \f[B]Command\-Line Argument Files\f[R] for a description of
  72 \f[CB]javac\f[R] argument files.
  73 .PP
  74 The order of source files specified on the command line or in an
  75 argument file is not important.
  76 \f[CB]javac\f[R] will compile the files together, as a group, and will
  77 automatically resolve any dependencies between the declarations in the
  78 various source files.
  79 .PP
  80 \f[CB]javac\f[R] expects that source files are arranged in one or more
  81 directory hierarchies on the file system, described in \f[B]Arrangement
  82 of Source Code\f[R].
  83 .PP
  84 To compile a source file, \f[CB]javac\f[R] needs to find the declaration
  85 of every class or interface that is used, extended, or implemented by
  86 the code in the source file.
  87 This lets \f[CB]javac\f[R] check that the code has the right to access
  88 those classes and interfaces.
  89 Rather than specifying the source files of those classes and interfaces
  90 explicitly, you can use command\-line options to tell \f[CB]javac\f[R]
  91 where to search for their source files.
  92 If you have compiled those source files previously, you can use options
  93 to tell \f[CB]javac\f[R] where to search for the corresponding class
  94 files.
  95 The options, which all have names ending in &quot;path&quot;, are described in
  96 \f[B]Standard Options\f[R], and further described in \f[B]Configuring a
  97 Compilation\f[R] and \f[B]Searching for Module, Package and Type
  98 Declarations\f[R].
  99 .PP
 100 By default, \f[CB]javac\f[R] compiles each source file to a class file in
 101 the same directory as the source file.
 102 However, it is recommended to specify a separate destination directory
 103 with the \f[B]\f[BC]\-d\f[B]\f[R] option.
 104 .PP
 105 Command\-line \f[B]options\f[R] and \f[B]environment variables\f[R] also
 106 control how \f[CB]javac\f[R] performs various tasks:
 107 .IP \[bu] 2
 108 Compiling code to run on earlier releases of the JDK.
 109 .IP \[bu] 2
 110 Compiling code to run under a debugger.
 111 .IP \[bu] 2
 112 Checking for stylistic issues in Java source code.
 113 .IP \[bu] 2
 114 Checking for problems in \f[CB]javadoc\f[R] comments
 115 (\f[CB]/**\ ...\ */\f[R]).
 116 .IP \[bu] 2
 117 Processing annotations in source files and class files.
 118 .IP \[bu] 2
 119 Upgrading and patching modules in the compile\-time environment.
 120 .PP
 121 \f[CB]javac\f[R] supports \f[B]Compiling for Earlier Releases Of The
 122 Platform\f[R] and can also be invoked from Java code using one of a
 123 number of \f[B]APIs\f[R]
 124 .SH OPTIONS
 125 .PP
 126 \f[CB]javac\f[R] provides \f[B]standard options\f[R], and \f[B]extra
 127 options\f[R] that are either non\-standard or are for advanced use.
 128 .PP
 129 Some options take one or more arguments.
 130 If an argument contains spaces or other whitespace characters, the value
 131 should be quoted according to the conventions of the environment being
 132 used to invoke javac.
 133 If the option begins with a single dash (\f[CB]\-\f[R]) the argument
 134 should either directly follow the option name, or should be separated
 135 with a colon (\f[CB]:\f[R]) or whitespace, depending on the option.
 136 If the option begins with a double dash (\f[CB]\-\-\f[R]), the argument
 137 may be separated either by whitespace or by an equals (\f[CB]=\f[R])
 138 character with no additional whitespace.
 139 For example,
 140 .IP
 141 .nf
 142 \f[CB]
 143 \-Aname=&quot;J.\ Duke&quot;
 144 \-proc:only
 145 \-d\ myDirectory
 146 \-\-module\-version\ 3
 147 \-\-module\-version=3
 148 \f[R]
 149 .fi
 150 .PP
 151 In the following lists of options, an argument of \f[I]path\f[R]
 152 represents a search path, composed of a list of file system locations
 153 separated by the platform path separator character, (semicolon
 154 \f[CB];\f[R] on Windows, or colon \f[CB]:\f[R] on other systems.) Depending
 155 on the option, the file system locations may be directories, JAR files
 156 or JMOD files.
 157 .SS Standard Options
 158 .TP
 159 .B \f[CB]\@\f[R]\f[I]filename\f[R]
 160 Reads options and file names from a file.
 161 To shorten or simplify the \f[CB]javac\f[R] command, you can specify one
 162 or more files that contain arguments to the \f[CB]javac\f[R] command
 163 (except \f[B]\f[BC]\-J\f[B]\f[R] options).
 164 This lets you to create \f[CB]javac\f[R] commands of any length on any
 165 operating system.
 166 See \f[B]Command\-Line Argument Files\f[R].
 167 .RS
 168 .RE
 169 .TP
 170 .B \f[CB]\-A\f[R]\f[I]key\f[R][\f[CB]=\f[R]\f[I]value\f[R]]
 171 Specifies options to pass to annotation processors.
 172 These options are not interpreted by \f[CB]javac\f[R] directly, but are
 173 made available for use by individual processors.
 174 The \f[I]key\f[R] value should be one or more identifiers separated by a
 175 dot (\f[CB]\&amp;.\f[R]).
 176 .RS
 177 .RE
 178 .TP
 179 .B \f[CB]\-\-add\-modules\f[R] \f[I]module\f[R]\f[CB],\f[R]\f[I]module\f[R]
 180 Specifies root modules to resolve in addition to the initial modules, or
 181 all modules on the module path if \f[I]module\f[R] is
 182 \f[CB]ALL\-MODULE\-PATH\f[R].
 183 .RS
 184 .RE
 185 .TP
 186 .B \f[CB]\-\-boot\-class\-path\f[R] \f[I]path\f[R] or \f[CB]\-bootclasspath\f[R] \f[I]path\f[R]
 187 Overrides the location of the bootstrap class files.
 188 .RS
 189 .PP
 190 \f[B]Note:\f[R] This can only be used when compiling for releases prior
 191 to JDK 9.
 192 As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
 193 \f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
 194 details.
 195 For JDK 9 or later, see \f[B]\f[BC]\-\-system\f[B]\f[R].
 196 .RE
 197 .TP
 198 .B \f[CB]\-\-class\-path\f[R] \f[I]path\f[R], \f[CB]\-classpath\f[R] \f[I]path\f[R], or \f[CB]\-cp\f[R] \f[I]path\f[R]
 199 Specifies where to find user class files and annotation processors.
 200 This class path overrides the user class path in the \f[CB]CLASSPATH\f[R]
 201 environment variable.
 202 .RS
 203 .IP \[bu] 2
 204 If \f[CB]\-\-class\-path\f[R], \f[CB]\-classpath\f[R], or \f[CB]\-cp\f[R] are
 205 not specified, then the user class path is the value of the
 206 \f[CB]CLASSPATH\f[R] environment variable, if that is set, or else the
 207 current directory.
 208 .IP \[bu] 2
 209 If not compiling code for modules, if the
 210 \f[B]\f[BC]\-\-source\-path\f[B]\f[R] or \-sourcepath` option is not
 211 specified, then the user class path is also searched for source files.
 212 .IP \[bu] 2
 213 If the \f[B]\f[BC]\-processorpath\f[B]\f[R] option is not specified, then
 214 the class path is also searched for annotation processors.
 215 .RE
 216 .TP
 217 .B \f[CB]\-d\f[R] \f[I]directory\f[R]
 218 Sets the destination directory (or \f[I]class output directory\f[R]) for
 219 class files.
 220 If a class is part of a package, then \f[CB]javac\f[R] puts the class file
 221 in a subdirectory that reflects the module name (if appropriate) and
 222 package name.
 223 The directory, and any necessary subdirectories, will be created if they
 224 do not already exist.
 225 .RS
 226 .PP
 227 If the \f[CB]\-d\f[R] option is not specified, then \f[CB]javac\f[R] puts
 228 each class file in the same directory as the source file from which it
 229 was generated.
 230 .PP
 231 Except when compiling code for multiple modules, the contents of the
 232 class output directory will be organized in a package hierarchy.
 233 When compiling code for multiple modules, the contents of the output
 234 directory will be organized in a module hierarchy, with the contents of
 235 each module in a separate subdirectory, each organized as a package
 236 hierarchy.
 237 .PP
 238 \f[B]Note:\f[R] When compiling code for one or more modules, the class
 239 output directory will automatically be checked when searching for
 240 previously compiled classes.
 241 When not compiling for modules, for backwards compatibility, the
 242 directory is \f[I]not\f[R] automatically checked for previously compiled
 243 classes, and so it is recommended to specify the class output directory
 244 as one of the locations on the user class path, using the
 245 \f[CB]\-\-class\-path\f[R] option or one of its alternate forms.
 246 .RE
 247 .TP
 248 .B \f[CB]\-deprecation\f[R]
 249 Shows a description of each use or override of a deprecated member or
 250 class.
 251 Without the \f[CB]\-deprecation\f[R] option, \f[CB]javac\f[R] shows a
 252 summary of the source files that use or override deprecated members or
 253 classes.
 254 The \f[CB]\-deprecation\f[R] option is shorthand for
 255 \f[CB]\-Xlint:deprecation\f[R].
 256 .RS
 257 .RE
 258 .TP
 259 .B \f[CB]\-\-enable\-preview\f[R]
 260 Enables preview language features.
 261 Used in conjunction with either \f[B]\f[BC]\-source\f[B]\f[R] or
 262 \f[B]\f[BC]\-\-release\f[B]\f[R].
 263 .RS
 264 .RE
 265 .TP
 266 .B \f[CB]\-encoding\f[R] \f[I]encoding\f[R]
 267 Specifies character encoding used by source files, such as EUC\-JP and
 268 UTF\-8.
 269 If the \f[CB]\-encoding\f[R] option is not specified, then the platform
 270 default converter is used.
 271 .RS
 272 .RE
 273 .TP
 274 .B \f[CB]\-endorseddirs\f[R] \f[I]directories\f[R]
 275 Overrides the location of the endorsed standards path.
 276 .RS
 277 .PP
 278 \f[B]Note:\f[R] This can only be used when compiling for releases prior
 279 to JDK 9.
 280 As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
 281 \f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
 282 details.
 283 .RE
 284 .TP
 285 .B \f[CB]\-extdirs\f[R] \f[I]directories\f[R]
 286 Overrides the location of the installed extensions.
 287 \f[CB]directories\f[R] is a list of directories, separated by the platform
 288 path separator (\f[CB];\f[R] on Windows, and \f[CB]:\f[R] otherwise).
 289 Each JAR file in the specified directories is searched for class files.
 290 All JAR files found become part of the class path.
 291 .RS
 292 .PP
 293 If you are compiling for a release of the platform that supports the
 294 Extension Mechanism, then this option specifies the directories that
 295 contain the extension classes.
 296 See [Compiling for Other Releases of the Platform].
 297 .PP
 298 \f[B]Note:\f[R] This can only be used when compiling for releases prior
 299 to JDK 9.
 300 As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
 301 \f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
 302 details.
 303 .RE
 304 .TP
 305 .B \f[CB]\-g\f[R]
 306 Generates all debugging information, including local variables.
 307 By default, only line number and source file information is generated.
 308 .RS
 309 .RE
 310 .TP
 311 .B \f[CB]\-g:\f[R][\f[CB]lines\f[R], \f[CB]vars\f[R], \f[CB]source\f[R]]
 312 Generates only the kinds of debugging information specified by the
 313 comma\-separated list of keywords.
 314 Valid keywords are:
 315 .RS
 316 .TP
 317 .B \f[CB]lines\f[R]
 318 Line number debugging information.
 319 .RS
 320 .RE
 321 .TP
 322 .B \f[CB]vars\f[R]
 323 Local variable debugging information.
 324 .RS
 325 .RE
 326 .TP
 327 .B \f[CB]source\f[R]
 328 Source file debugging information.
 329 .RS
 330 .RE
 331 .RE
 332 .TP
 333 .B \f[CB]\-g:none\f[R]
 334 Does not generate debugging information.
 335 .RS
 336 .RE
 337 .TP
 338 .B \f[CB]\-h\f[R] \f[I]directory\f[R]
 339 Specifies where to place generated native header files.
 340 .RS
 341 .PP
 342 When you specify this option, a native header file is generated for each
 343 class that contains native methods or that has one or more constants
 344 annotated with the \f[B]\f[BC]java.lang.annotation.Native\f[B]\f[R]
 345 annotation.
 346 If the class is part of a package, then the compiler puts the native
 347 header file in a subdirectory that reflects the module name (if
 348 appropriate) and package name.
 349 The directory, and any necessary subdirectories, will be created if they
 350 do not already exist.
 351 .RE
 352 .TP
 353 .B \f[CB]\-\-help\f[R], \f[CB]\-help\f[R] or \f[CB]\-?\f[R]
 354 Prints a synopsis of the standard options.
 355 .RS
 356 .RE
 357 .TP
 358 .B \f[CB]\-\-help\-extra\f[R] or \f[CB]\-X\f[R]
 359 Prints a synopsis of the set of extra options.
 360 .RS
 361 .RE
 362 .TP
 363 .B \f[CB]\-implicit:\f[R][\f[CB]none\f[R], \f[CB]class\f[R]]
 364 Specifies whether or not to generate class files for implicitly
 365 referenced files:
 366 .RS
 367 .IP \[bu] 2
 368 \f[CB]\-implicit:class\f[R] \-\-\- Automatically generates class files.
 369 .IP \[bu] 2
 370 \f[CB]\-implicit:none\f[R] \-\-\- Suppresses class file generation.
 371 .PP
 372 If this option is not specified, then the default automatically
 373 generates class files.
 374 In this case, the compiler issues a warning if any class files are
 375 generated when also doing annotation processing.
 376 The warning is not issued when the \f[CB]\-implicit\f[R] option is
 377 explicitly set.
 378 See \f[B]Searching for Module, Package and Type Declarations\f[R].
 379 .RE
 380 .TP
 381 .B \f[CB]\-J\f[R]\f[I]option\f[R]
 382 Passes \f[I]option\f[R] to the runtime system, where \f[I]option\f[R] is
 383 one of the Java options described on \f[B]java\f[R] command.
 384 For example, \f[CB]\-J\-Xms48m\f[R] sets the startup memory to 48 MB.
 385 .RS
 386 .PP
 387 \f[B]Note:\f[R] The \f[CB]CLASSPATH\f[R] environment variable,
 388 \f[CB]\-classpath\f[R] option, \f[CB]\-bootclasspath\f[R] option, and
 389 \f[CB]\-extdirs\f[R] option do not specify the classes used to run
 390 \f[CB]javac\f[R].
 391 Trying to customize the compiler implementation with these options and
 392 variables is risky and often does not accomplish what you want.
 393 If you must customize the compiler implementation, then use the
 394 \f[CB]\-J\f[R] option to pass options through to the underlying Java
 395 launcher.
 396 .RE
 397 .TP
 398 .B \f[CB]\-\-limit\-modules\f[R] \f[I]module\f[R]\f[CB],\f[R]\f[I]module\f[R]*
 399 Limits the universe of observable modules.
 400 .RS
 401 .RE
 402 .TP
 403 .B \f[CB]\-\-module\f[R] \f[I]module\-name\f[R] (\f[CB],\f[R]\f[I]module\-name\f[R])* or \f[CB]\-m\f[R] \f[I]module\-name\f[R] (\f[CB],\f[R]\f[I]module\-name\f[R])*
 404 Compiles those source files in the named modules that are newer than the
 405 corresponding files in the output directory.
 406 .RS
 407 .RE
 408 .TP
 409 .B \f[CB]\-\-module\-path\f[R] \f[I]path\f[R] or \f[CB]\-p\f[R] \f[I]path\f[R]
 410 Specifies where to find application modules.
 411 .RS
 412 .RE
 413 .TP
 414 .B \f[CB]\-\-module\-source\-path\f[R] \f[I]module\-source\-path\f[R]
 415 Specifies where to find source files when compiling code in multiple
 416 modules.
 417 See [Compilation Modes] and \f[B]The Module Source Path Option\f[R].
 418 .RS
 419 .RE
 420 .TP
 421 .B \f[CB]\-\-module\-version\f[R] \f[I]version\f[R]
 422 Specifies the version of modules that are being compiled.
 423 .RS
 424 .RE
 425 .TP
 426 .B \f[CB]\-nowarn\f[R]
 427 Disables warning messages.
 428 This option operates the same as the \f[CB]\-Xlint:none\f[R] option.
 429 .RS
 430 .RE
 431 .TP
 432 .B \f[CB]\-parameters\f[R]
 433 Generates metadata for reflection on method parameters.
 434 Stores formal parameter names of constructors and methods in the
 435 generated class file so that the method
 436 \f[CB]java.lang.reflect.Executable.getParameters\f[R] from the Reflection
 437 API can retrieve them.
 438 .RS
 439 .RE
 440 .TP
 441 .B \f[CB]\-proc:\f[R][\f[CB]none\f[R], \f[CB]only\f[R]]
 442 Controls whether annotation processing and compilation are done.
 443 \f[CB]\-proc:none\f[R] means that compilation takes place without
 444 annotation processing.
 445 \f[CB]\-proc:only\f[R] means that only annotation processing is done,
 446 without any subsequent compilation.
 447 .RS
 448 .RE
 449 .TP
 450 .B \f[CB]\-processor\f[R] \f[I]class1\f[R][\f[CB],\f[R]\f[I]class2\f[R]\f[CB],\f[R]\f[I]class3\f[R]...]
 451 Names of the annotation processors to run.
 452 This bypasses the default discovery process.
 453 .RS
 454 .RE
 455 .TP
 456 .B \f[CB]\-\-processor\-module\-path\f[R] \f[I]path\f[R]
 457 Specifies the module path used for finding annotation processors.
 458 .RS
 459 .RE
 460 .TP
 461 .B \f[CB]\-\-processor\-path\f[R] \f[I]path\f[R] or \f[CB]\-processorpath\f[R] \f[I]path\f[R]
 462 Specifies where to find annotation processors.
 463 If this option is not used, then the class path is searched for
 464 processors.
 465 .RS
 466 .RE
 467 .TP
 468 .B \f[CB]\-profile\f[R] \f[I]profile\f[R]
 469 Checks that the API used is available in the specified profile.
 470 .RS
 471 .PP
 472 \f[B]Note:\f[R] This can only be used when compiling for releases prior
 473 to JDK 9.
 474 As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
 475 \f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
 476 details.
 477 .RE
 478 .TP
 479 .B \f[CB]\-\-release\f[R] \f[I]release\f[R]
 480 Compiles source code according to the rules of the Java programming
 481 language for the specified Java SE release, generating class files which
 482 target that release.
 483 Source code is compiled against the combined Java SE and JDK API for the
 484 specified release.
 485 .RS
 486 .PP
 487 The supported values of \f[I]release\f[R] are the current Java SE release
 488 and a limited number of previous releases, detailed in the command\-line
 489 help.
 490 .PP
 491 For the current release, the Java SE API consists of the
 492 \f[CB]java.*\f[R], \f[CB]javax.*\f[R], and \f[CB]org.*\f[R] packages that are
 493 exported by the Java SE modules in the release; the JDK API consists of
 494 the \f[CB]com.*\f[R] and \f[CB]jdk.*\f[R] packages that are exported by the
 495 JDK modules in the release, plus the \f[CB]javax.*\f[R] packages that are
 496 exported by standard, but non\-Java SE, modules in the release.
 497 .PP
 498 For previous releases, the Java SE API and the JDK API are as defined in
 499 that release.
 500 .PP
 501 \f[B]Note:\f[R] When using \f[CB]\-\-release\f[R], you cannot also use the
 502 \f[B]\f[BC]\-\-source\f[B]\f[R]/\f[CB]\-source\f[R] or
 503 \f[B]\f[BC]\-\-target\f[B]\f[R]/\f[CB]\-target\f[R] options.
 504 .PP
 505 \f[B]Note:\f[R] When using \f[CB]\-\-release\f[R] to specify a release that
 506 supports the Java Platform Module System, the \f[CB]\-\-add\-exports\f[R]
 507 option cannot be used to enlarge the set of packages exported by the
 508 Java SE, JDK, and standard modules in the specified release.
 509 .RE
 510 .TP
 511 .B \f[CB]\-s\f[R] \f[I]directory\f[R]
 512 Specifies the directory used to place the generated source files.
 513 If a class is part of a package, then the compiler puts the source file
 514 in a subdirectory that reflects the module name (if appropriate) and
 515 package name.
 516 The directory, and any necessary subdirectories, will be created if they
 517 do not already exist.
 518 .RS
 519 .PP
 520 Except when compiling code for multiple modules, the contents of the
 521 source output directory will be organized in a package hierarchy.
 522 When compiling code for multiple modules, the contents of the source
 523 output directory will be organized in a module hierarchy, with the
 524 contents of each module in a separate subdirectory, each organized as a
 525 package hierarchy.
 526 .RE
 527 .TP
 528 .B \f[CB]\-\-source\f[R] \f[I]release\f[R] or \f[CB]\-source\f[R] \f[I]release\f[R]
 529 Compiles source code according to the rules of the Java programming
 530 language for the specified Java SE release.
 531 The supported values of \f[I]release\f[R] are the current Java SE release
 532 and a limited number of previous releases, detailed in the command\-line
 533 help.
 534 .RS
 535 .PP
 536 If the option is not specified, the default is to compile source code
 537 according to the rules of the Java programming language for the current
 538 Java SE release.
 539 .RE
 540 .TP
 541 .B \f[CB]\-\-source\-path\f[R] \f[I]path\f[R] or \f[CB]\-sourcepath\f[R] \f[I]path\f[R]
 542 Specifies where to find source files.
 543 Except when compiling multiple modules together, this is the source code
 544 path used to search for class or interface definitions.
 545 .RS
 546 .PP
 547 \f[B]Note:\f[R] Classes found through the class path might be recompiled
 548 when their source files are also found.
 549 See \f[B]Searching for Module, Package and Type Declarations\f[R].
 550 .RE
 551 .TP
 552 .B \f[CB]\-\-system\f[R] \f[I]jdk\f[R] | \f[CB]none\f[R]
 553 Overrides the location of system modules.
 554 .RS
 555 .RE
 556 .TP
 557 .B \f[CB]\-\-target\f[R] \f[I]release\f[R] or \f[CB]\-target\f[R] \f[I]release\f[R]
 558 Generates \f[CB]class\f[R] files suitable for the specified Java SE
 559 release.
 560 The supported values of \f[I]release\f[R] are the current Java SE release
 561 and a limited number of previous releases, detailed in the command\-line
 562 help.
 563 .RS
 564 .PP
 565 \f[B]Note:\f[R] The target release must be equal to or higher than the
 566 source release.
 567 (See \f[B]\f[BC]\-\-source\f[B]\f[R].)
 568 .RE
 569 .TP
 570 .B \f[CB]\-\-upgrade\-module\-path\f[R] \f[I]path\f[R]
 571 Overrides the location of upgradeable modules.
 572 .RS
 573 .RE
 574 .TP
 575 .B \f[CB]\-verbose\f[R]
 576 Outputs messages about what the compiler is doing.
 577 Messages include information about each class loaded and each source
 578 file compiled.
 579 .RS
 580 .RE
 581 .TP
 582 .B \f[CB]\-\-version\f[R] or \f[CB]\-version\f[R]
 583 Prints version information.
 584 .RS
 585 .RE
 586 .TP
 587 .B \f[CB]\-Werror\f[R]
 588 Terminates compilation when warnings occur.
 589 .RS
 590 .RE
 591 .SS Extra Options
 592 .TP
 593 .B \f[CB]\-\-add\-exports\f[R] \f[I]module\f[R]\f[CB]/\f[R]\f[I]package\f[R]\f[CB]=\f[R]\f[I]other\-module\f[R](\f[CB],\f[R]\f[I]other\-module\f[R])*
 594 Specifies a package to be considered as exported from its defining
 595 module to additional modules or to all unnamed modules when the value of
 596 \f[I]other\-module\f[R] is \f[CB]ALL\-UNNAMED\f[R].
 597 .RS
 598 .RE
 599 .TP
 600 .B \f[CB]\-\-add\-reads\f[R] \f[I]module\f[R]\f[CB]=\f[R]\f[I]other\-module\f[R](\f[CB],\f[R]\f[I]other\-module\f[R])*
 601 Specifies additional modules to be considered as required by a given
 602 module.
 603 .RS
 604 .RE
 605 .TP
 606 .B \f[CB]\-\-default\-module\-for\-created\-files\f[R] \f[I]module\-name\f[R]
 607 Specifies the fallback target module for files created by annotation
 608 processors, if none is specified or inferred.
 609 .RS
 610 .RE
 611 .TP
 612 .B \f[CB]\-Djava.endorsed.dirs=\f[R]\f[I]dirs\f[R]
 613 Overrides the location of the endorsed standards path.
 614 .RS
 615 .PP
 616 \f[B]Note:\f[R] This can only be used when compiling for releases prior
 617 to JDK 9.
 618 As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
 619 \f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
 620 details.
 621 .RE
 622 .TP
 623 .B \f[CB]\-Djava.ext.dirs=\f[R]\f[I]dirs\f[R]
 624 Overrides the location of installed extensions.
 625 .RS
 626 .PP
 627 \f[B]Note:\f[R] This can only be used when compiling for releases prior
 628 to JDK 9.
 629 As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
 630 \f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
 631 details.
 632 .RE
 633 .TP
 634 .B \f[CB]\-\-doclint\-format\f[R] [\f[CB]html4\f[R]|\f[CB]html5\f[R]]
 635 Specifies the format for documentation comments.
 636 .RS
 637 .RE
 638 .TP
 639 .B \f[CB]\-\-patch\-module\f[R] \f[I]module\f[R]\f[CB]=\f[R]\f[I]path\f[R]
 640 Overrides or augments a module with classes and resources in JAR files
 641 or directories.
 642 .RS
 643 .RE
 644 .TP
 645 .B \f[CB]\-Xbootclasspath:\f[R]\f[I]path\f[R]
 646 Overrides the location of the bootstrap class files.
 647 .RS
 648 .PP
 649 \f[B]Note:\f[R] This can only be used when compiling for releases prior
 650 to JDK 9.
 651 As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
 652 \f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
 653 details.
 654 .RE
 655 .TP
 656 .B \f[CB]\-Xbootclasspath/a:\f[R]\f[I]path\f[R]
 657 Adds a suffix to the bootstrap class path.
 658 .RS
 659 .PP
 660 \f[B]Note:\f[R] This can only be used when compiling for releases prior
 661 to JDK 9.
 662 As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
 663 \f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
 664 details.
 665 .RE
 666 .TP
 667 .B \f[CB]\-Xbootclasspath/p:\f[R]\f[I]path\f[R]
 668 Adds a prefix to the bootstrap class path.
 669 .RS
 670 .PP
 671 \f[B]Note:\f[R] This can only be used when compiling for releases prior
 672 to JDK 9.
 673 As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
 674 \f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
 675 details.
 676 .RE
 677 .TP
 678 .B \f[CB]\-Xdiags:\f[R][\f[CB]compact\f[R], \f[CB]verbose\f[R]]
 679 Selects a diagnostic mode.
 680 .RS
 681 .RE
 682 .TP
 683 .B \f[CB]\-Xdoclint\f[R]
 684 Enables recommended checks for problems in \f[CB]javadoc\f[R] comments
 685 .RS
 686 .RE
 687 .TP
 688 .B \f[CB]\-Xdoclint:\f[R](\f[CB]all\f[R]|\f[CB]none\f[R]|[\f[CB]\-\f[R]]\f[I]group\f[R])[\f[CB]/\f[R]\f[I]access\f[R]]
 689 Enables or disables specific groups of checks,
 690 .RS
 691 .PP
 692 \f[I]group\f[R] can have one of the following values:
 693 .IP \[bu] 2
 694 \f[CB]accessibility\f[R]
 695 .IP \[bu] 2
 696 \f[CB]html\f[R]
 697 .IP \[bu] 2
 698 \f[CB]missing\f[R]
 699 .IP \[bu] 2
 700 \f[CB]reference\f[R]
 701 .IP \[bu] 2
 702 \f[CB]syntax\f[R]
 703 .PP
 704 The variable \f[I]access\f[R] specifies the minimum visibility level of
 705 classes and members that the \f[CB]\-Xdoclint\f[R] option checks.
 706 It can have one of the following values (in order of most to least
 707 visible):
 708 .IP \[bu] 2
 709 \f[CB]public\f[R]
 710 .IP \[bu] 2
 711 \f[CB]protected\f[R]
 712 .IP \[bu] 2
 713 \f[CB]package\f[R]
 714 .IP \[bu] 2
 715 \f[CB]private\f[R]
 716 .PP
 717 The default \f[I]access\f[R] level is \f[CB]private\f[R].
 718 .PP
 719 For more information about these groups of checks, see the
 720 \f[CB]\-Xdoclint\f[R] option of the \f[CB]javadoc\f[R] command.
 721 The \f[CB]\-Xdoclint\f[R] option is disabled by default in the
 722 \f[CB]javac\f[R] command.
 723 .PP
 724 For example, the following option checks classes and members (with all
 725 groups of checks) that have the access level of protected and higher
 726 (which includes protected and public):
 727 .RS
 728 .PP
 729 \f[CB]\-Xdoclint:all/protected\f[R]
 730 .RE
 731 .PP
 732 The following option enables all groups of checks for all access levels,
 733 except it will not check for HTML errors for classes and members that
 734 have the access level of package and higher (which includes package,
 735 protected and public):
 736 .RS
 737 .PP
 738 \f[CB]\-Xdoclint:all,\-html/package\f[R]
 739 .RE
 740 .RE
 741 .TP
 742 .B \f[CB]\-Xdoclint/package:\f[R][\f[CB]\-\f[R]]\f[I]packages\f[R](\f[CB],\f[R][\f[CB]\-\f[R]]\f[I]package\f[R])*
 743 Enables or disables checks in specific packages.
 744 Each \f[I]package\f[R] is either the qualified name of a package or a
 745 package name prefix followed by \f[CB]\&amp;.*\f[R], which expands to all
 746 sub\-packages of the given package.
 747 Each \f[I]package\f[R] can be prefixed with a hyphen (\f[CB]\-\f[R]) to
 748 disable checks for a specified package or packages.
 749 .RS
 750 .RE
 751 .TP
 752 .B \f[CB]\-Xlint\f[R]
 753 Enables all recommended warnings.
 754 In this release, enabling all available warnings is recommended.
 755 .RS
 756 .RE
 757 .TP
 758 .B \f[CB]\-Xlint:\f[R][\f[CB]\-\f[R]]\f[I]key\f[R](\f[CB],\f[R][\f[CB]\-\f[R]]\f[I]key\f[R])*
 759 Supplies warnings to enable or disable, separated by comma.
 760 Precede a key by a hyphen (\f[CB]\-\f[R]) to disable the specified
 761 warning.
 762 .RS
 763 .PP
 764 Supported values for \f[I]key\f[R] are:
 765 .IP \[bu] 2
 766 \f[CB]all\f[R]: Enables all warnings.
 767 .IP \[bu] 2
 768 \f[CB]auxiliaryclass\f[R]: Warns about an auxiliary class that\[aq]s
 769 hidden in a source file, and is used from other files.
 770 .IP \[bu] 2
 771 \f[CB]cast\f[R]: Warns about the use of unnecessary casts.
 772 .IP \[bu] 2
 773 \f[CB]classfile\f[R]: Warns about the issues related to classfile
 774 contents.
 775 .IP \[bu] 2
 776 \f[CB]deprecation\f[R]: Warns about the use of deprecated items.
 777 .IP \[bu] 2
 778 \f[CB]dep\-ann\f[R]: Warns about the items marked as deprecated in
 779 \f[CB]javadoc\f[R] but without the \f[CB]\@Deprecated\f[R] annotation.
 780 .IP \[bu] 2
 781 \f[CB]divzero\f[R]: Warns about the division by the constant integer 0.
 782 .IP \[bu] 2
 783 \f[CB]empty\f[R]: Warns about an empty statement after \f[CB]if\f[R].
 784 .IP \[bu] 2
 785 \f[CB]exports\f[R]: Warns about the issues regarding module exports.
 786 .IP \[bu] 2
 787 \f[CB]fallthrough\f[R]: Warns about the falling through from one case of a
 788 switch statement to the next.
 789 .IP \[bu] 2
 790 \f[CB]finally\f[R]: Warns about \f[CB]finally\f[R] clauses that do not
 791 terminate normally.
 792 .IP \[bu] 2
 793 \f[CB]module\f[R]: Warns about the module system\-related issues.
 794 .IP \[bu] 2
 795 \f[CB]opens\f[R]: Warns about the issues related to module opens.
 796 .IP \[bu] 2
 797 \f[CB]options\f[R]: Warns about the issues relating to use of command line
 798 options.
 799 .IP \[bu] 2
 800 \f[CB]overloads\f[R]: Warns about the issues related to method overloads.
 801 .IP \[bu] 2
 802 \f[CB]overrides\f[R]: Warns about the issues related to method overrides.
 803 .IP \[bu] 2
 804 \f[CB]path\f[R]: Warns about the invalid path elements on the command l
 805 ine.
 806 .IP \[bu] 2
 807 \f[CB]processing\f[R]: Warns about the issues related to annotation
 808 processing.
 809 .IP \[bu] 2
 810 \f[CB]rawtypes\f[R]: Warns about the use of raw types.
 811 .IP \[bu] 2
 812 \f[CB]removal\f[R]: Warns about the use of an API that has been marked for
 813 removal.
 814 .IP \[bu] 2
 815 \f[CB]requires\-automatic\f[R]: Warns developers about the use of
 816 automatic modules in requires clauses.
 817 .IP \[bu] 2
 818 \f[CB]requires\-transitive\-automatic\f[R]: Warns about automatic modules
 819 in requires transitive.
 820 .IP \[bu] 2
 821 \f[CB]serial\f[R]: Warns about the serializable classes that do not
 822 provide a serial version ID.
 823 Also warns about access to non\-public members from a serializable
 824 element.
 825 .IP \[bu] 2
 826 \f[CB]static\f[R]: Warns about the accessing a static member using an
 827 instance.
 828 .IP \[bu] 2
 829 \f[CB]try\f[R]: Warns about the issues relating to the use of try blocks (
 830 that is, try\-with\-resources).
 831 .IP \[bu] 2
 832 \f[CB]unchecked\f[R]: Warns about the unchecked operations.
 833 .IP \[bu] 2
 834 \f[CB]varargs\f[R]: Warns about the potentially unsafe \f[CB]vararg\f[R]
 835 methods.
 836 .IP \[bu] 2
 837 \f[CB]none\f[R]: Disables all warnings.
 838 .PP
 839 See \f[B]Examples of Using \-Xlint keys\f[R].
 840 .RE
 841 .TP
 842 .B \f[CB]\-Xmaxerrs\f[R] \f[I]number\f[R]
 843 Sets the maximum number of errors to print.
 844 .RS
 845 .RE
 846 .TP
 847 .B \f[CB]\-Xmaxwarns\f[R] \f[I]number\f[R]
 848 Sets the maximum number of warnings to print.
 849 .RS
 850 .RE
 851 .TP
 852 .B \f[CB]\-Xpkginfo:\f[R][\f[CB]always\f[R], \f[CB]legacy\f[R], \f[CB]nonempty\f[R]]
 853 Specifies when and how the \f[CB]javac\f[R] command generates
 854 \f[CB]package\-info.class\f[R] files from \f[CB]package\-info.java\f[R]
 855 files using one of the following options:
 856 .RS
 857 .TP
 858 .B \f[CB]always\f[R]
 859 Generates a \f[CB]package\-info.class\f[R] file for every
 860 \f[CB]package\-info.java\f[R] file.
 861 This option may be useful if you use a build system such as Ant, which
 862 checks that each \f[CB]\&amp;.java\f[R] file has a corresponding
 863 \f[CB]\&amp;.class\f[R] file.
 864 .RS
 865 .RE
 866 .TP
 867 .B \f[CB]legacy\f[R]
 868 Generates a \f[CB]package\-info.class\f[R] file only if
 869 \f[CB]package\-info.java\f[R] contains annotations.
 870 This option does not generate a \f[CB]package\-info.class\f[R] file if
 871 \f[CB]package\-info.java\f[R] contains only comments.
 872 .RS
 873 .PP
 874 \f[B]Note:\f[R] A \f[CB]package\-info.class\f[R] file might be generated
 875 but be empty if all the annotations in the \f[CB]package\-info.java\f[R]
 876 file have \f[CB]RetentionPolicy.SOURCE\f[R].
 877 .RE
 878 .TP
 879 .B \f[CB]nonempty\f[R]
 880 Generates a \f[CB]package\-info.class\f[R] file only if
 881 \f[CB]package\-info.java\f[R] contains annotations with
 882 \f[CB]RetentionPolicy.CLASS\f[R] or \f[CB]RetentionPolicy.RUNTIME\f[R].
 883 .RS
 884 .RE
 885 .RE
 886 .TP
 887 .B \f[CB]\-Xplugin:\f[R]\f[I]name\f[R] \f[I]args\f[R]
 888 Specifies the name and optional arguments for a plug\-in to be run.
 889 If \f[I]args\f[R] are provided, \f[I]name\f[R] and \f[I]args\f[R] should be
 890 quoted or otherwise escape the whitespace characters between the name
 891 and all the arguments.
 892 For details on the API for a plugin, see the API documentation for
 893 \f[B]jdk.compiler/com.sun.source.util.Plugin\f[R].
 894 .RS
 895 .RE
 896 .TP
 897 .B \f[CB]\-Xprefer:\f[R][\f[CB]source\f[R], \f[CB]newer\f[R]]
 898 Specifies which file to read when both a source file and class file are
 899 found for an implicitly compiled class using one of the following
 900 options.
 901 See \f[B]Searching for Module, Package and Type Declarations\f[R].
 902 .RS
 903 .IP \[bu] 2
 904 \f[CB]\-Xprefer:newer\f[R]: Reads the newer of the source or class files
 905 for a type (default).
 906 .IP \[bu] 2
 907 \f[CB]\-Xprefer:source\f[R] : Reads the source file.
 908 Use \f[CB]\-Xprefer:source\f[R] when you want to be sure that any
 909 annotation processors can access annotations declared with a retention
 910 policy of \f[CB]SOURCE\f[R].
 911 .RE
 912 .TP
 913 .B \f[CB]\-Xprint\f[R]
 914 Prints a textual representation of specified types for debugging
 915 purposes.
 916 This does not perform annotation processing or compilation.
 917 The format of the output could change.
 918 .RS
 919 .RE
 920 .TP
 921 .B \f[CB]\-XprintProcessorInfo\f[R]
 922 Prints information about which annotations a processor is asked to
 923 process.
 924 .RS
 925 .RE
 926 .TP
 927 .B \f[CB]\-XprintRounds\f[R]
 928 Prints information about initial and subsequent annotation processing
 929 rounds.
 930 .RS
 931 .RE
 932 .TP
 933 .B \f[CB]\-Xstdout\f[R] \f[I]filename\f[R]
 934 Sends compiler messages to the named file.
 935 By default, compiler messages go to \f[CB]System.err\f[R].
 936 .RS
 937 .RE
 938 .SH ENVIRONMENT VARIABLES
 939 .SS CLASSPATH
 940 .PP
 941 If the \f[B]\f[BC]\-\-class\-path\f[B]\f[R] option or any of its
 942 alternate forms are not specified, the class path will default to the
 943 value of the \f[CB]CLASSPATH\f[R] environment variable if it is set.
 944 However, it is recommended that this environment variable should
 945 \f[I]not\f[R] be set, and that the \f[CB]\-\-class\-path\f[R] option should
 946 be used to provide an explicit value for the class path when one is
 947 required.
 948 .SS JDK_JAVAC_OPTIONS
 949 .PP
 950 The content of the \f[CB]JDK_JAVAC_OPTIONS\f[R] environment variable,
 951 separated by white\-spaces ( ) or white\-space characters (\f[CB]\\n\f[R],
 952 \f[CB]\\t\f[R], \f[CB]\\r\f[R], or \f[CB]\\f\f[R]) is prepended to the command
 953 line arguments passed to \f[CB]javac\f[R] as a list of arguments.
 954 .PP
 955 The encoding requirement for the environment variable is the same as the
 956 \f[CB]javac\f[R] command line on the system.
 957 \f[CB]JDK_JAVAC_OPTIONS\f[R] environment variable content is treated in
 958 the same manner as that specified in the command line.
 959 .PP
 960 Single quotes (\f[CB]\[aq]\f[R]) or double quotes (\f[CB]&quot;\f[R]) can be used
 961 to enclose arguments that contain whitespace characters.
 962 All content between the open quote and the first matching close quote
 963 are preserved by simply removing the pair of quotes.
 964 In case a matching quote is not found, the launcher will abort with an
 965 error message.
 966 \f[CB]\@\f[R]\f[I]files\f[R] are supported as they are specified in the
 967 command line.
 968 However, as in \f[CB]\@\f[R]\f[I]files\f[R], use of a wildcard is not
 969 supported.
 970 .PP
 971 \f[B]Examples of quoting arguments containing white spaces:\f[R]
 972 .RS
 973 .PP
 974 \f[CB]export\ JDK_JAVAC_OPTIONS=\[aq]\@&quot;C:\\white\ spaces\\argfile&quot;\[aq]\f[R]
 975 .RE
 976 .RS
 977 .PP
 978 \f[CB]export\ JDK_JAVAC_OPTIONS=\[aq]&quot;\@C:\\white\ spaces\\argfile&quot;\[aq]\f[R]
 979 .RE
 980 .RS
 981 .PP
 982 \f[CB]export\ JDK_JAVAC_OPTIONS=\[aq]\@C:\\&quot;white\ spaces&quot;\\argfile\[aq]\f[R]
 983 .RE
 984 .SH COMMAND\-LINE ARGUMENT FILES
 985 .PP
 986 An argument file can include command\-line options and source file names
 987 in any combination.
 988 The arguments within a file can be separated by spaces or new line
 989 characters.
 990 If a file name contains embedded spaces, then put the whole file name in
 991 double quotation marks.
 992 .PP
 993 File names within an argument file are relative to the current
 994 directory, not to the location of the argument file.
 995 Wildcards (\f[CB]*\f[R]) are not allowed in these lists (such as for
 996 specifying \f[CB]*.java\f[R]).
 997 Use of the at sign (\f[CB]\@\f[R]) to recursively interpret files is not
 998 supported.
 999 The \f[CB]\-J\f[R] options are not supported because they\[aq]re passed to
1000 the launcher, which does not support argument files.
1001 .PP
1002 When executing the \f[CB]javac\f[R] command, pass in the path and name of
1003 each argument file with the at sign (\f[CB]\@\f[R]) leading character.
1004 When the \f[CB]javac\f[R] command encounters an argument beginning with
1005 the at sign (\f[CB]\@\f[R]), it expands the contents of that file into the
1006 argument list.
1007 .SS Examples of Using javac \@filename
1008 .TP
1009 .B Single Argument File
1010 You could use a single argument file named \f[CB]argfile\f[R] to hold all
1011 \f[CB]javac\f[R] arguments:
1012 .RS
1013 .RS
1014 .PP
1015 \f[CB]javac\ \@argfile\f[R]
1016 .RE
1017 .PP
1018 This argument file could contain the contents of both files shown in the
1019 following \f[B]Two Argument Files\f[R] example.
1020 .RE
1021 .TP
1022 .B Two Argument Files
1023 You can create two argument files: one for the \f[CB]javac\f[R] options
1024 and the other for the source file names.
1025 Note that the following lists have no line\-continuation characters.
1026 .RS
1027 .PP
1028 Create a file named \f[CB]options\f[R] that contains the following:
1029 .PP
1030 \f[B]Oracle Solaris, Linux, and macOS:\f[R]
1031 .IP
1032 .nf
1033 \f[CB]
1034 \-d\ classes
1035 \-g
1036 \-sourcepath\ /java/pubs/ws/1.3/src/share/classes
1037 \f[R]
1038 .fi
1039 .PP
1040 \f[B]Windows:\f[R]
1041 .IP
1042 .nf
1043 \f[CB]
1044 \-d\ classes
1045 \-g
1046 \-sourcepath\ C:\\java\\pubs\\ws\\1.3\\src\\share\\classes
1047 \f[R]
1048 .fi
1049 .PP
1050 Create a file named \f[CB]classes\f[R] that contains the following:
1051 .IP
1052 .nf
1053 \f[CB]
1054 MyClass1.java
1055 MyClass2.java
1056 MyClass3.java
1057 \f[R]
1058 .fi
1059 .PP
1060 Then, run the \f[CB]javac\f[R] command as follows:
1061 .RS
1062 .PP
1063 \f[CB]javac\ \@options\ \@classes\f[R]
1064 .RE
1065 .RE
1066 .TP
1067 .B Argument Files with Paths
1068 The argument files can have paths, but any file names inside the files
1069 are relative to the current working directory (not \f[CB]path1\f[R] or
1070 \f[CB]path2\f[R]):
1071 .RS
1072 .RS
1073 .PP
1074 \f[CB]javac\ \@path1/options\ \@path2/classes\f[R]
1075 .RE
1076 .RE
1077 .SH ARRANGEMENT OF SOURCE CODE
1078 .PP
1079 In the Java language, classes and interfaces can be organized into
1080 packages, and packages can be organized into modules.
1081 \f[CB]javac\f[R] expects that the physical arrangement of source files in
1082 directories of the file system will mirror the organization of classes
1083 into packages, and packages into modules.
1084 .PP
1085 It is a widely adopted convention that module names and package names
1086 begin with a lower\-case letter, and that class names begin with an
1087 upper\-case letter.
1088 .SS Arrangement of Source Code for a Package
1089 .PP
1090 When classes and interfaces are organized into a package, the package is
1091 represented as a directory, and any subpackages are represented as
1092 subdirectories.
1093 .PP
1094 For example:
1095 .IP \[bu] 2
1096 The package \f[CB]p\f[R] is represented as a directory called \f[CB]p\f[R].
1097 .IP \[bu] 2
1098 The package \f[CB]p.q\f[R] \-\- that is, the subpackage \f[CB]q\f[R] of
1099 package \f[CB]p\f[R] \-\- is represented as the subdirectory \f[CB]q\f[R] of
1100 directory \f[CB]p\f[R].
1101 The directory tree representing package \f[CB]p.q\f[R] is therefore
1102 \f[CB]p\\q\f[R] on Windows, and \f[CB]p/q\f[R] on other systems.
1103 .IP \[bu] 2
1104 The package \f[CB]p.q.r\f[R] is represented as the directory tree
1105 \f[CB]p\\q\\r\f[R] (on Windows) or \f[CB]p/q/r\f[R] (on other systems).
1106 .PP
1107 Within a directory or subdirectory, \f[CB]\&amp;.java\f[R] files represent
1108 classes and interfaces in the corresponding package or subpackage.
1109 .PP
1110 For example:
1111 .IP \[bu] 2
1112 The class \f[CB]X\f[R] declared in package \f[CB]p\f[R] is represented by
1113 the file \f[CB]X.java\f[R] in the \f[CB]p\f[R] directory.
1114 .IP \[bu] 2
1115 The class \f[CB]Y\f[R] declared in package \f[CB]p.q\f[R] is represented by
1116 the file \f[CB]Y.java\f[R] in the \f[CB]q\f[R] subdirectory of directory
1117 \f[CB]p\f[R].
1118 .IP \[bu] 2
1119 The class \f[CB]Z\f[R] declared in package \f[CB]p.q.r\f[R] is represented
1120 by the file \f[CB]Z.java\f[R] in the \f[CB]r\f[R] subdirectory of
1121 \f[CB]p\\q\f[R] (on Windows) or \f[CB]p/q\f[R] (on other systems).
1122 .PP
1123 In some situations, it is convenient to split the code into separate
1124 directories, each structured as described above, and the aggregate list
1125 of directories specified to \f[CB]javac\f[R].
1126 .SS Arrangement of Source Code for a Module
1127 .PP
1128 In the Java language, a module is a set of packages designed for reuse.
1129 In addition to \f[CB]\&amp;.java\f[R] files for classes and interfaces, each
1130 module has a source file called \f[CB]module\-info.java\f[R] which:
1131 .IP &quot;1.&quot; 3
1132 declares the module\[aq]s name;
1133 .IP &quot;2.&quot; 3
1134 lists the packages exported by the module (to allow reuse by other
1135 modules);
1136 .IP &quot;3.&quot; 3
1137 lists other modules required by the module (to reuse their exported
1138 packages).
1139 .PP
1140 When packages are organized into a module, the module is represented by
1141 one or more directories representing the packages in the module, one of
1142 which contains the \f[CB]module\-info.java\f[R] file.
1143 It may be convenient, but it is not required, to use a single directory,
1144 named after the module, to contain the \f[CB]module\-info.java\f[R] file
1145 alongside the directory tree which represents the packages in the module
1146 (i.e., the \f[I]package hierarchy\f[R] described above).
1147 The exact arrangement of source code for a module is typically dictated
1148 by the conventions adopted by a development environment (IDE) or build
1149 system.
1150 .PP
1151 For example:
1152 .IP \[bu] 2
1153 The module \f[CB]a.b.c\f[R] may be represented by the directory
1154 \f[CB]a.b.c\f[R], on all systems.
1155 .IP \[bu] 2
1156 The module\[aq]s declaration is represented by the file
1157 \f[CB]module\-info.java\f[R] in the \f[CB]a.b.c\f[R] directory.
1158 .IP \[bu] 2
1159 If the module contains package \f[CB]p.q.r\f[R], then the \f[CB]a.b.c\f[R]
1160 directory contains the directory tree \f[CB]p\\q\\r\f[R] (on Windows) or
1161 \f[CB]p/q/r\f[R] (on other systems).
1162 .PP
1163 The development environment may prescribe some directory hierarchy
1164 between the directory named for the module and the source files to be
1165 read by \f[CB]javac\f[R].
1166 .PP
1167 For example:
1168 .IP \[bu] 2
1169 The module \f[CB]a.b.c\f[R] may be represented by the directory
1170 \f[CB]a.b.c\f[R]
1171 .IP \[bu] 2
1172 The module\[aq]s declaration and the module\[aq]s packages may be in
1173 some subdirectory of \f[CB]a.b.c\f[R], such as \f[CB]src\\main\\java\f[R]
1174 (on Windows) or \f[CB]src/main/java\f[R] (on other systems).
1175 .SH CONFIGURING A COMPILATION
1176 .PP
1177 This section describes how to configure \f[CB]javac\f[R] to perform a
1178 basic compilation.
1179 .PP
1180 See \f[B]Configuring the Module System\f[R] for additional details for
1181 use when compiling for a release of the platform that supports modules.
1182 .SS Source Files
1183 .IP \[bu] 2
1184 Specify the source files to be compiled on the command line.
1185 .PP
1186 If there are no compilation errors, the corresponding class files will
1187 be placed in the \f[B]output directory\f[R].
1188 .PP
1189 Some systems may limit the amount you can put on a command line; to work
1190 around those limits, you can use \f[B]argument files\f[R].
1191 .PP
1192 When compiling code for modules, you can also specify source files
1193 indirectly, by using the \f[B]\f[BC]\-\-module\f[B]\f[R] or \f[CB]\-m\f[R]
1194 option.
1195 .SS Output Directory
1196 .IP \[bu] 2
1197 Use the \f[B]\f[BC]\-d\f[B]\f[R] option to specify an output directory in
1198 which to put the compiled class files.
1199 .PP
1200 This will normally be organized in a \f[B]package hierarchy\f[R], unless
1201 you are compiling source code from multiple modules, in which case it
1202 will be organized as a \f[B]module hierarchy\f[R].
1203 .PP
1204 When the compilation has been completed, if you are compiling one or
1205 more modules, you can place the output directory on the module path for
1206 the Java \f[B]launcher\f[R]; otherwise, you can place the place the
1207 output directory on the class path for the Java launcher.
1208 .SS Precompiled Code
1209 .PP
1210 The code to be compiled may refer to libraries beyond what is provided
1211 by the platform.
1212 If so, you must place these libraries on the class path or module path.
1213 If the library code is not in a module, place it on the class path; if
1214 it is in a module, place it on the module path.
1215 .IP \[bu] 2
1216 Use the \f[B]\f[BC]\-\-class\-path\f[B]\f[R] option to specify libraries
1217 to be placed on the class path.
1218 Locations on the class path should be organized in a \f[B]package
1219 hierarchy\f[R].
1220 You can also use alternate forms of the option: \f[CB]\-classpath\f[R] or
1221 \f[CB]\-cp\f[R].
1222 .IP \[bu] 2
1223 Use the \f[B]\f[BC]\-\-module\-path\f[B]\f[R] option to specify libraries
1224 to be placed on the module path.
1225 Locations on the module path should either be modules or directories of
1226 modules.
1227 You can also use an alternate form of the option: \f[CB]\-p\f[R].
1228 .RS 2
1229 .PP
1230 See \f[B]Configuring the Module System\f[R] for details on how to modify
1231 the default configuration of library modules.
1232 .RE
1233 .PP
1234 \f[B]Note\f[R]: the options for the class path and module path are not
1235 mutually exclusive, although it is not common to specify the class path
1236 when compiling code for one or more modules.
1237 .SS Additional Source Files
1238 .PP
1239 The code to be compiled may refer to types in additional source files
1240 that are not specified on the command line.
1241 If so, you must put those source files on either the source path or
1242 module path.
1243 You can only specify one of these options: if you are not compiling code
1244 for a module, or if you are only compiling code for a single module, use
1245 the source path; if you are compiling code for multiple modules, use the
1246 module source path.
1247 .IP \[bu] 2
1248 Use the \f[B]\f[BC]\-\-source\-path\f[B]\f[R] option to specify the
1249 locations of additional source files that may be read by javac.
1250 Locations on the source path should be organized in a \f[B]package
1251 hierarchy\f[R].
1252 You can also use an alternate form of the option: \f[CB]\-sourcepath\f[R].
1253 .IP \[bu] 2
1254 Use the \f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R] option one or more
1255 times to specify the location of additional source files in different
1256 modules that may be read by javac, or when compiling source files in
1257 multiple modules.
1258 You can either specify the locations for each module
1259 \f[B]individually\f[R], or you can organize the source files so that you
1260 can specify the locations all \f[B]together\f[R].
1261 For more details, see \f[B]The Module Source Path Option\f[R].
1262 .PP
1263 If you want to be able to refer to types in additional source files but
1264 do not want them to be compiled, use the \f[B]\f[BC]\-implicit\f[B]\f[R]
1265 option.
1266 .PP
1267 \f[B]Note\f[R]: if you are compiling code for multiple modules, you must
1268 always specify a module source path, and all source files specified on
1269 the command line must be in one of the directories on the module source
1270 path, or in a subdirectory thereof.
1271 .SS Example of Compiling Multiple Source Files
1272 .PP
1273 This example compiles the \f[CB]Aloha.java\f[R], \f[CB]GutenTag.java\f[R],
1274 \f[CB]Hello.java\f[R], and \f[CB]Hi.java\f[R] source files in the
1275 \f[CB]greetings\f[R] package.
1276 .PP
1277 \f[B]Oracle Solaris, Linux, and macOS:\f[R]
1278 .IP
1279 .nf
1280 \f[CB]
1281 %\ javac\ greetings/*.java
1282 %\ ls\ greetings
1283 Aloha.class\ \ \ \ \ \ \ \ \ GutenTag.class\ \ \ \ \ \ Hello.class\ \ \ \ \ \ \ \ \ Hi.class
1284 Aloha.java\ \ \ \ \ \ \ \ \ \ GutenTag.java\ \ \ \ \ \ \ Hello.java\ \ \ \ \ \ \ \ \ \ Hi.java
1285 \f[R]
1286 .fi
1287 .PP
1288 \f[B]Windows:\f[R]
1289 .IP
1290 .nf
1291 \f[CB]
1292 C:\\&gt;javac\ greetings\\*.java
1293 C:\\&gt;dir\ greetings
1294 Aloha.class\ \ \ \ \ \ \ \ \ GutenTag.class\ \ \ \ \ \ Hello.class\ \ \ \ \ \ \ \ \ Hi.class
1295 Aloha.java\ \ \ \ \ \ \ \ \ \ GutenTag.java\ \ \ \ \ \ \ Hello.java\ \ \ \ \ \ \ \ \ \ Hi.java
1296 \f[R]
1297 .fi
1298 .SS Example of Specifying a User Class Path
1299 .PP
1300 After changing one of the source files in the previous example,
1301 recompile it:
1302 .PP
1303 \f[B]Oracle Solaris, Linux, and macOS:\f[R]
1304 .IP
1305 .nf
1306 \f[CB]
1307 pwd
1308 /examples
1309 javac\ greetings/Hi.java
1310 \f[R]
1311 .fi
1312 .PP
1313 \f[B]Windows:\f[R]
1314 .IP
1315 .nf
1316 \f[CB]
1317 C:\\&gt;cd
1318 \\examples
1319 C:\\&gt;javac\ greetings\\Hi.java
1320 \f[R]
1321 .fi
1322 .PP
1323 Because \f[CB]greetings.Hi\f[R] refers to other classes in the
1324 \f[CB]greetings\f[R] package, the compiler needs to find these other
1325 classes.
1326 The previous example works because the default user class path is the
1327 directory that contains the package directory.
1328 If you want to recompile this file without concern for which directory
1329 you are in, then add the examples directory to the user class path by
1330 setting \f[CB]CLASSPATH\f[R].
1331 This example uses the \f[CB]\-classpath\f[R] option.
1332 .PP
1333 \f[B]Oracle Solaris, Linux, and macOS:\f[R]
1334 .RS
1335 .PP
1336 \f[CB]javac\ \-classpath\ /examples\ /examples/greetings/Hi.java\f[R]
1337 .RE
1338 .PP
1339 \f[B]Windows:\f[R]
1340 .RS
1341 .PP
1342 \f[CB]C:\\&gt;javac\ \-classpath\ \\examples\ \\examples\\greetings\\Hi.java\f[R]
1343 .RE
1344 .PP
1345 If you change \f[CB]greetings.Hi\f[R] to use a banner utility, then that
1346 utility also needs to be accessible through the user class path.
1347 .PP
1348 \f[B]Oracle Solaris, Linux, and macOS:\f[R]
1349 .IP
1350 .nf
1351 \f[CB]
1352 javac\ \-classpath\ /examples:/lib/Banners.jar\ \\
1353 \ \ \ \ \ \ \ \ \ \ \ \ /examples/greetings/Hi.java
1354 \f[R]
1355 .fi
1356 .PP
1357 \f[B]Windows:\f[R]
1358 .IP
1359 .nf
1360 \f[CB]
1361 C:\\&gt;javac\ \-classpath\ \\examples;\\lib\\Banners.jar\ ^
1362 \ \ \ \ \ \ \ \ \ \ \ \ \\examples\\greetings\\Hi.java
1363 \f[R]
1364 .fi
1365 .PP
1366 To execute a class in the \f[CB]greetings\f[R] package, the program needs
1367 access to the \f[CB]greetings\f[R] package, and to the classes that the
1368 \f[CB]greetings\f[R] classes use.
1369 .PP
1370 \f[B]Oracle Solaris, Linux, and macOS:\f[R]
1371 .RS
1372 .PP
1373 \f[CB]java\ \-classpath\ /examples:/lib/Banners.jar\ greetings.Hi\f[R]
1374 .RE
1375 .PP
1376 \f[B]Windows:\f[R]
1377 .RS
1378 .PP
1379 \f[CB]C:\\&gt;java\ \-classpath\ \\examples;\\lib\\Banners.jar\ greetings.Hi\f[R]
1380 .RE
1381 .SH CONFIGURING THE MODULE SYSTEM
1382 .PP
1383 If you want to include additional modules in your compilation, use the
1384 \f[B]\f[BC]\-\-add\-modules\f[B]\f[R] option.
1385 This may be necessary when you are compiling code that is not in a
1386 module, or which is in an automatic module, and the code refers to API
1387 in the additional modules.
1388 .PP
1389 If you want to restrict the set of modules in your compilation, use the
1390 \f[B]\f[BC]\-\-limit\-modules\f[B]\f[R] option.
1391 This may be useful if you want to ensure that the code you are compiling
1392 is capable of running on a system with a limited set of modules
1393 installed.
1394 .PP
1395 If you want to break encapsulation and specify that additional packages
1396 should be considered as exported from a module, use the
1397 \f[B]\f[BC]\-\-add\-exports\f[B]\f[R] option.
1398 This may be useful when performing white\-box testing; relying on access
1399 to internal API in production code is strongly discouraged.
1400 .PP
1401 If you want to specify that additional packages should be considered as
1402 required by a module, use the \f[B]\f[BC]\-\-add\-reads\f[B]\f[R] option.
1403 This may be useful when performing white\-box testing; relying on access
1404 to internal API in production code is strongly discouraged.
1405 .PP
1406 You can patch additional content into any module using the
1407 \f[B]\f[BC]\-\-patch\-module\f[B]\f[R] option.
1408 See [Patching a Module] for more details.
1409 .SH SEARCHING FOR MODULE, PACKAGE AND TYPE DECLARATIONS
1410 .PP
1411 To compile a source file, the compiler often needs information about a
1412 module or type, but the declaration is not in the source files specified
1413 on the command line.
1414 .PP
1415 \f[CB]javac\f[R] needs type information for every class or interface used,
1416 extended, or implemented in the source file.
1417 This includes classes and interfaces not explicitly mentioned in the
1418 source file, but that provide information through inheritance.
1419 .PP
1420 For example, when you create a subclass of \f[CB]java.awt.Window\f[R], you
1421 are also using the ancestor classes of \f[CB]Window\f[R]:
1422 \f[CB]java.awt.Container\f[R], \f[CB]java.awt.Component\f[R], and
1423 \f[CB]java.lang.Object\f[R].
1424 .PP
1425 When compiling code for a module, the compiler also needs to have
1426 available the declaration of that module.
1427 .PP
1428 A successful search may produce a class file, a source file, or both.
1429 If both are found, then you can use the \f[B]\f[BC]\-Xprefer\f[B]\f[R]
1430 option to instruct the compiler which to use.
1431 .PP
1432 If a search finds and uses a source file, then by default \f[CB]javac\f[R]
1433 compiles that source file.
1434 This behavior can be altered with \f[B]\f[BC]\-implicit\f[B]\f[R].
1435 .PP
1436 The compiler might not discover the need for some type information until
1437 after annotation processing completes.
1438 When the type information is found in a source file and no
1439 \f[B]\f[BC]\-implicit\f[B]\f[R] option is specified, the compiler gives a
1440 warning that the file is being compiled without being subject to
1441 annotation processing.
1442 To disable the warning, either specify the file on the command line (so
1443 that it will be subject to annotation processing) or use the
1444 \f[B]\f[BC]\-implicit\f[B]\f[R] option to specify whether or not class
1445 files should be generated for such source files.
1446 .PP
1447 The way that \f[CB]javac\f[R] locates the declarations of those types
1448 depends on whether the reference exists within code for a module or not.
1449 .SS Searching Package Oriented Paths
1450 .PP
1451 When searching for a source or class file on a path composed of package
1452 oriented locations, \f[CB]javac\f[R] will check each location on the path
1453 in turn for the possible presence of the file.
1454 The first occurrence of a particular file shadows (hides) any subsequent
1455 occurrences of like\-named files.
1456 This shadowing does not affect any search for any files with a different
1457 name.
1458 This can be convenient when searching for source files, which may be
1459 grouped in different locations, such as shared code, platform\-specific
1460 code and generated code.
1461 It can also be useful when injecting alternate versions of a class file
1462 into a package, to debugging or other instrumentation reasons.
1463 But, it can also be dangerous, such as when putting incompatible
1464 different versions of a library on the class path.
1465 .SS Searching Module Oriented Paths
1466 .PP
1467 Prior to scanning any module paths for any package or type declarations,
1468 \f[CB]javac\f[R] will lazily scan the following paths and locations to
1469 determine the modules that will be used in the compilation.
1470 .IP \[bu] 2
1471 The module source path (see the
1472 \f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R] option)
1473 .IP \[bu] 2
1474 The path for upgradeable modules (see the
1475 \f[B]\f[BC]\-\-upgrade\-module\-path\f[B]\f[R] option)
1476 .IP \[bu] 2
1477 The system modules (see the \f[B]\f[BC]\-\-system\f[B]\f[R] option)
1478 .IP \[bu] 2
1479 The user module path ( see the \f[B]\f[BC]\-\-module\-path\f[B]\f[R]
1480 option)
1481 .PP
1482 For any module, the first occurrence of the module during the scan
1483 completely shadows (hides) any subsequent appearance of a like\-named
1484 module.
1485 While locating the modules, \f[CB]javac\f[R] is able to determine the
1486 packages exported by the module and to associate with each module a
1487 package oriented path for the contents of the module.
1488 For any previously compiled module, this path will typically be a single
1489 entry for either a directory or a file that provides an internal
1490 directory\-like hierarchy, such as a JAR file.
1491 Thus, when searching for a type that is in a package that is known to be
1492 exported by a module, \f[CB]javac\f[R] can locate the declaration directly
1493 and efficiently.
1494 .SS Searching for the Declaration of a Module
1495 .PP
1496 If the module has been previously compiled, the module declaration is
1497 located in a file named \f[CB]module\-info.class\f[R] in the root of the
1498 package hierarchy for the content of the module.
1499 .PP
1500 If the module is one of those currently being compiled, the module
1501 declaration will be either the file named \f[CB]module\-info.class\f[R] in
1502 the root of the package hierarchy for the module in the class output
1503 directory, or the file named \f[CB]module\-info.java\f[R] in one of the
1504 locations on the source path or one the module source path for the
1505 module.
1506 .SS Searching for the Declaration of a Type When the Reference is not in
1507 a Module
1508 .PP
1509 When searching for a type that is referenced in code that is not in a
1510 module, \f[CB]javac\f[R] will look in the following places:
1511 .IP \[bu] 2
1512 The platform classes (or the types in exported packages of the platform
1513 modules) (This is for compiled class files only.)
1514 .IP \[bu] 2
1515 Types in exported packages of any modules on the module path, if
1516 applicable.
1517 (This is for compiled class files only.)
1518 .IP \[bu] 2
1519 Types in packages on the class path and/or source path:
1520 .RS 2
1521 .IP \[bu] 2
1522 If both are specified, \f[CB]javac\f[R] looks for compiled class files on
1523 the class path and for source files on the source path.
1524 .IP \[bu] 2
1525 If the class path is specified, but not source path, \f[CB]javac\f[R]
1526 looks for both compiled class files and source files on the class path.
1527 .IP \[bu] 2
1528 If the class path is not specified, it defaults to the current
1529 directory.
1530 .RE
1531 .PP
1532 When looking for a type on the class path and/or source path, if both a
1533 compiled class file and a source file are found, the most recently
1534 modified file will be used by default.
1535 If the source file is newer, it will be compiled and will may override
1536 any previously compiled version of the file.
1537 You can use the \f[B]\f[BC]\-Xprefer\f[B]\f[R] option to override the
1538 default behavior.
1539 .SS Searching for the Declaration of a Type When the Reference is in a
1540 Module
1541 .PP
1542 When searching for a type that is referenced in code in a module,
1543 \f[CB]javac\f[R] will examine the declaration of the enclosing module to
1544 determine if the type is in a package that is exported from another
1545 module that is readable by the enclosing module.
1546 If so, \f[CB]javac\f[R] will simply and directly go to the definition of
1547 that module to find the definition of the required type.
1548 Unless the module is another of the modules being compiled,
1549 \f[CB]javac\f[R] will only look for compiled class files files.
1550 In other words, \f[CB]javac\f[R] will not look for source files in
1551 platform modules or modules on the module path.
1552 .PP
1553 If the type being referenced is not in some other readable module,
1554 \f[CB]javac\f[R] will examine the module being compiled to try and find
1555 the declaration of the type.
1556 \f[CB]javac\f[R] will look for the declaration of the type as follows:
1557 .IP \[bu] 2
1558 Source files specified on the command line or on the source path or
1559 module source path.
1560 .IP \[bu] 2
1561 Previously compiled files in the output directory.
1562 .SH DIRECTORY HIERARCHIES
1563 .PP
1564 \f[CB]javac\f[R] generally assumes that source files and compiled class
1565 files will be organized in a file system directory hierarchy or in a
1566 type of file that supports in an internal directory hierarchy, such as a
1567 JAR file.
1568 Three different kinds of hierarchy are supported: a \f[I]package
1569 hierarchy\f[R], a \f[I]module hierarchy\f[R], and a \f[I]module source
1570 hierarchy\f[R].
1571 .PP
1572 While \f[CB]javac\f[R] is fairly relaxed about the organization of source
1573 code, beyond the expectation that source will be organized in one or
1574 package hierarchies, and can generally accomodate organizations
1575 prescribed by development environments and build tools, Java tools in
1576 general, and \f[CB]javac\f[R] and the Java launcher in particular, are
1577 more stringent regarding the organization of compiled class files, and
1578 will be organized in package hierarchies or module hierarchies, as
1579 appropriate.
1580 .PP
1581 The location of these hierarchies are specified to \f[CB]javac\f[R] with
1582 command\-line options, whose names typically end in &quot;path&quot;, like
1583 \f[B]\f[BC]\-\-source\-path\f[B]\f[R] or
1584 \f[B]\f[BC]\-\-class\-path\f[B]\f[R].
1585 Also as a general rule, path options whose name includes the word
1586 \f[CB]module\f[R], like \f[B]\f[BC]\-\-module\-path\f[B]\f[R], are used to
1587 specify module hierarchies, although some module\-related path options
1588 allow a package hierarchy to be specified on a per\-module basis.
1589 All other path options are used to specify package hierarchies.
1590 .SS Package Hierarchy
1591 .PP
1592 In a package hierarchy, directories and subdirectories are used to
1593 represent the component parts of the package name, with the source file
1594 or compiled class file for a type being stored as a file with an
1595 extension of \f[CB]\&amp;.java\f[R] or \f[CB]\&amp;.class\f[R] in the most nested
1596 directory.
1597 .PP
1598 For example, in a package hierarchy, the source file for a class
1599 \f[CB]com.example.MyClass\f[R] will be stored in the file
1600 \f[I]com/example/MyClass.java\f[R]
1601 .SS Module Hierarchy
1602 .PP
1603 In a module hierarchy, the first level of directories are named for the
1604 modules in the hierarchy; within each of those directories the contents
1605 of the module are organized in package hierarchies.
1606 .PP
1607 For example, in a module hierarchy, the compiled class file for a type
1608 called \f[CB]com.example.MyClass\f[R] in a module called
1609 \f[CB]my.library\f[R] will be stored in
1610 \f[I]my.library/com/example/MyClass.class\f[R].
1611 .PP
1612 The various output directories used by \f[CB]javac\f[R] (the class output
1613 directory, the source output directory, and native header output
1614 directory) will all be organized in a module hierarchy when multiple
1615 modules are being compiled.
1616 .SS Module Source Hierarchy
1617 .PP
1618 Although the source for each individual module should always be
1619 organized in a package hierarchy, it may be convenient to group those
1620 hierarchies into a module source hierarchy.
1621 This is similar to a module hierarchy, except that there may be
1622 intervening directories between the directory for the module and the
1623 directory that is the root of the package hierarchy for the source code
1624 of the module.
1625 .PP
1626 For example, in a module source hierarchy, the source file for a type
1627 called \f[CB]com.example.MyClass\f[R] in a module called
1628 \f[CB]my.library\f[R] may be stored in a file such as
1629 \f[I]my.library/src/main/java/com/example/MyClass.java\f[R].
1630 .SH THE MODULE SOURCE PATH OPTION
1631 .PP
1632 The \f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R] option has two forms: a
1633 \f[I]module\-specific form\f[R], in which a package path is given for
1634 each module containing code to be compiled, and a
1635 \f[I]module\-pattern\f[R] form, in which the source path for each module
1636 is specified by a pattern.
1637 The module\-specific form is generally simpler to use when only a small
1638 number of modules are involved; the module\-pattern form may be more
1639 convenient when the number of modules is large and the modules are
1640 organized in a regular manner that can be described by a pattern.
1641 .PP
1642 Multiple instances of the \f[CB]\-\-module\-source\-path\f[R] option may
1643 be given, each one using either the module\-pattern form or the
1644 module\-specific form, subject to the following limitations:
1645 .IP \[bu] 2
1646 the module\-pattern form may be used at most once
1647 .IP \[bu] 2
1648 the module\-specific form may be used at most once for any given module
1649 .PP
1650 If the module\-specific form is used for any module, the associated
1651 search path overrides any path that might otherwise have been inferred
1652 from the module\-pattern form.
1653 .SS Module\-specific form
1654 .PP
1655 The module\-specific form allows an explicit search path to be given for
1656 any specific module.
1657 This form is:
1658 .IP \[bu] 2
1659 \f[CB]\-\-module\-source\-path\f[R]
1660 \f[I]module\-name\f[R]\f[CB]=\f[R]\f[I]file\-path\f[R]
1661 (\f[I]path\-separator\f[R] \f[I]file\-path\f[R])*
1662 .PP
1663 The path separator character is \f[CB];\f[R] on Windows, and \f[CB]:\f[R]
1664 otherwise.
1665 .PP
1666 \f[B]Note:\f[R] this is similar to the form used for the
1667 \f[B]\f[BC]\-\-patch\-module\f[B]\f[R] option.
1668 .SS Module\-pattern form
1669 .PP
1670 The module\-pattern form allows a concise specification of the module
1671 source path for any number of modules organized in regular manner.
1672 .IP \[bu] 2
1673 \f[CB]\-\-module\-source\-path\f[R] \f[I]pattern\f[R]
1674 .PP
1675 The pattern is defined by the following rules, which are applied in
1676 order:
1677 .IP \[bu] 2
1678 The argument is considered to be a series of segments separated by the
1679 path separator character (\f[CB];\f[R] on Windows, and \f[CB]:\f[R]
1680 otherwise).
1681 .IP \[bu] 2
1682 Each segment containing curly braces of the form
1683 .RS 2
1684 .IP
1685 .nf
1686 \f[CB]
1687 string1{alt1\ (\ ,alt2\ )*\ }\ string2
1688 \f[R]
1689 .fi
1690 .PP
1691 is considered to be replaced by a series of segments formed by
1692 &quot;expanding&quot; the braces:
1693 .IP
1694 .nf
1695 \f[CB]
1696 string1\ alt1\ string2
1697 string1\ alt2\ string2
1698 and\ so\ on...
1699 \f[R]
1700 .fi
1701 .PP
1702 The braces may be nested.
1703 .PP
1704 This rule is applied for all such usages of braces.
1705 .RE
1706 .IP \[bu] 2
1707 Each segment must have at most one asterisk (\f[CB]*\f[R]).
1708 If a segment does not contain an asterisk, it is considered to be as
1709 though the file separator character and an asterisk are appended.
1710 .RS 2
1711 .PP
1712 For any module \f[I]M\f[R], the source path for that module is formed
1713 from the series of segments obtained by substituting the module name
1714 \f[I]M\f[R] for the asterisk in each segment.
1715 .PP
1716 \f[B]Note\f[R]: in this context, the asterisk is just used as a special
1717 marker, to denote the position in the path of the module name.
1718 It should not be confused with the use of \f[CB]*\f[R] as a file name
1719 wildcard character, as found on most operating systems.
1720 .RE
1721 .SH PATCHING MODULES
1722 .PP
1723 javac allows any content, whether in source or compiled form, to be
1724 patched into any module using the \f[B]\f[BC]\-\-patch\-module\f[B]\f[R]
1725 option.
1726 You may want to do this to compile alternative implementations of a
1727 class to be patched at runtime into a JVM, or to inject additional
1728 classes into the module, such as when testing.
1729 .PP
1730 The form of the option is:
1731 .IP \[bu] 2
1732 \f[CB]\-\-patch\-module\f[R]
1733 \f[I]module\-name\f[R]\f[CB]=\f[R]\f[I]file\-path\f[R]
1734 (\f[I]path\-separator\f[R] \f[I]file\-path\f[R] )*
1735 .PP
1736 The path separator character is \f[CB];\f[R] on Windows, and \f[CB]:\f[R]
1737 otherwise.
1738 The paths given for the module must specify the root of a package
1739 hierarchy for the contents of the module
1740 .PP
1741 The option may be given at most once for any given module.
1742 Any content on the path will hide any like\-named content later in the
1743 path and in the patched module.
1744 .PP
1745 When patching source code into more than one module, the
1746 \f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R] must also be used, so that
1747 the output directory is organized in a module hierarchy, and capable of
1748 holding the compiled class files for the modules being compiled.
1749 .SH ANNOTATION PROCESSING
1750 .PP
1751 The \f[CB]javac\f[R] command provides direct support for annotation
1752 processing.
1753 .PP
1754 The API for annotation processors is defined in the
1755 \f[CB]javax.annotation.processing\f[R] and \f[CB]javax.lang.model\f[R]
1756 packages and subpackages.
1757 .SS How Annotation Processing Works
1758 .PP
1759 Unless annotation processing is disabled with the
1760 \f[B]\f[BC]\-proc:none\f[B]\f[R] option, the compiler searches for any
1761 annotation processors that are available.
1762 The search path can be specified with the
1763 \f[B]\f[BC]\-processorpath\f[B]\f[R] option.
1764 If no path is specified, then the user class path is used.
1765 Processors are located by means of service provider\-configuration files
1766 named \f[CB]META\-INF/services/javax.annotation.processing\f[R].
1767 Processor on the search path.
1768 Such files should contain the names of any annotation processors to be
1769 used, listed one per line.
1770 Alternatively, processors can be specified explicitly, using the
1771 \f[B]\f[BC]\-processor\f[B]\f[R] option.
1772 .PP
1773 After scanning the source files and classes on the command line to
1774 determine what annotations are present, the compiler queries the
1775 processors to determine what annotations they process.
1776 When a match is found, the processor is called.
1777 A processor can claim the annotations it processes, in which case no
1778 further attempt is made to find any processors for those annotations.
1779 After all of the annotations are claimed, the compiler does not search
1780 for additional processors.
1781 .PP
1782 If any processors generate new source files, then another round of
1783 annotation processing occurs: Any newly generated source files are
1784 scanned, and the annotations processed as before.
1785 Any processors called on previous rounds are also called on all
1786 subsequent rounds.
1787 This continues until no new source files are generated.
1788 .PP
1789 After a round occurs where no new source files are generated, the
1790 annotation processors are called one last time, to give them a chance to
1791 complete any remaining work.
1792 Finally, unless the \f[B]\f[BC]\-proc:only\f[B]\f[R] option is used, the
1793 compiler compiles the original and all generated source files.
1794 .PP
1795 If you use an annotation processor that generates additional source
1796 files to be included in the compilation, you can specify a default
1797 module to be used for the newly generated files, for use when a module
1798 declaration is not also generated.
1799 In this case, use the
1800 \f[B]\f[BC]\-\-default\-module\-for\-created\-files\f[B]\f[R] option.
1801 .SS Compilation Environment and Runtime Environment.
1802 .PP
1803 The declarations in source files and previously compiled class files are
1804 analyzed by \f[CB]javac\f[R] in a \f[I]compilation environment\f[R] that is
1805 distinct from the \f[I]runtime environment\f[R] used to execute
1806 \f[CB]javac\f[R] itself.
1807 Although there is a deliberate similarity between many \f[CB]javac\f[R]
1808 options and like\-named options for the Java \f[B]launcher\f[R], such as
1809 \f[CB]\-\-class\-path\f[R], \f[CB]\-\-module\-path\f[R] and so on, it is
1810 important to understand that in general the \f[CB]javac\f[R] options just
1811 affect the environment in which the source files are compiled, and do
1812 not affect the operation of \f[CB]javac\f[R] itself.
1813 .PP
1814 The distinction between the compilation environment and runtime
1815 environment is significant when it comes to using annotation processors.
1816 Although annotations processors process elements (declarations) that
1817 exist in the compilation environment, the annotation processor itself is
1818 executed in the runtime environment.
1819 If an annotation processor has dependencies on libraries that are not in
1820 modules, the libraries can be placed, along with the annotation
1821 processor itself, on the processor path.
1822 (See the \f[B]\f[BC]\-\-processor\-path\f[B]\f[R] option.) If the
1823 annotation processor and its dependencies are in modules, you should use
1824 the processor module path instead.
1825 (See the \f[B]\f[BC]\-\-processor\-module\-path\f[B]\f[R] option.) When
1826 those are insufficient, it may be necessary to provide further
1827 configuration of the runtime environment.
1828 This can be done in two ways:
1829 .IP &quot;1.&quot; 3
1830 If \f[CB]javac\f[R] is invoked from the command line, options can be
1831 passed to the underlying runtime by prefixing the option with
1832 \f[B]\f[BC]\-J\f[B]\f[R].
1833 .IP &quot;2.&quot; 3
1834 You can start an instance of a Java Virtual Machine directly and use
1835 command line options and API to configure an environment in which
1836 \f[CB]javac\f[R] can be invoked via one of its \f[B]APIs\f[R].
1837 .SH COMPILING FOR EARLIER RELEASES OF THE PLATFORM
1838 .PP
1839 \f[CB]javac\f[R] can compile code that is to be used on other releases of
1840 the platform, using either the \f[B]\f[BC]\-\-release\f[B]\f[R] option,
1841 or the \f[B]\f[BC]\-\-source\f[B]\f[R]/\f[CB]\-source\f[R] and
1842 \f[B]\f[BC]\-\-target\f[B]\f[R]/\f[CB]\-target\f[R] options, together with
1843 additional options to specify the platform classes.
1844 .PP
1845 Depending on the desired platform release, there are some restrictions
1846 on some of the options that can be used.
1847 .IP \[bu] 2
1848 When compiling for JDK 8 and earlier releases, you cannot use any option
1849 that is intended for use with the module system.
1850 This includes all of the following options:
1851 .RS 2
1852 .IP \[bu] 2
1853 \f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R],
1854 \f[B]\f[BC]\-\-upgrade\-module\-path\f[B]\f[R],
1855 \f[B]\f[BC]\-\-system\f[B]\f[R], \f[B]\f[BC]\-\-module\-path\f[B]\f[R],
1856 \f[B]\f[BC]\-\-add\-modules\f[B]\f[R],
1857 \f[B]\f[BC]\-\-add\-exports\f[B]\f[R], \f[CB]\-\-add\-opens\f[R],
1858 \f[B]\f[BC]\-\-add\-reads\f[B]\f[R],
1859 \f[B]\f[BC]\-\-limit\-modules\f[B]\f[R],
1860 \f[B]\f[BC]\-\-patch\-module\f[B]\f[R]
1861 .PP
1862 If you use the \f[CB]\-\-source\f[R]/\f[CB]\-source\f[R] or
1863 \f[CB]\-\-target\f[R]/\f[CB]\-target\f[R] options, you should also set the
1864 appropriate platform classes using the boot class path family of
1865 options.
1866 .RE
1867 .IP \[bu] 2
1868 When compiling for JDK 9 and later releases, you cannot use any option
1869 that is intended to configure the boot class path.
1870 This includes all of the following options:
1871 .RS 2
1872 .IP \[bu] 2
1873 \f[B]\f[BC]\-Xbootclasspath/p:\f[B]\f[R],
1874 \f[B]\f[BC]\-Xbootclasspath\f[B]\f[R],
1875 \f[B]\f[BC]\-Xbootclasspath/a:\f[B]\f[R],
1876 \f[B]\f[BC]\-endorseddirs\f[B]\f[R],
1877 \f[B]\f[BC]\-Djava.endorsed.dirs\f[B]\f[R],
1878 \f[B]\f[BC]\-extdirs\f[B]\f[R], \f[B]\f[BC]\-Djava.ext.dirs\f[B]\f[R],
1879 \f[B]\f[BC]\-profile\f[B]\f[R]
1880 .PP
1881 If you use the \f[CB]\-\-source\f[R]/\f[CB]\-source\f[R] or
1882 \f[CB]\-\-target\f[R]/\f[CB]\-target\f[R] options, you should also set the
1883 appropriate platform classes using the \f[CB]\-\-system\f[R] option to
1884 give the location of an appropriate installed release of JDK.
1885 .RE
1886 .PP
1887 When using the \f[CB]\-\-release\f[R] option, only the supported
1888 documented API for that release may be used; you cannot use any options
1889 to break encapsulation to access any internal classes.
1890 .SH APIS
1891 .PP
1892 The \f[CB]javac\f[R] compiler can be invoked using an API in three
1893 different ways:
1894 .TP
1895 .B The \f[B]Java Compiler API\f[R]
1896 This provides the most flexible way to invoke the compiler, including
1897 the ability to compile source files provided in memory buffers or other
1898 non\-standard file systems.
1899 .RS
1900 .RE
1901 .TP
1902 .B The \f[B]ToolProvider API\f[R]
1903 A \f[CB]ToolProvider\f[R] for \f[CB]javac\f[R] can be obtained by calling
1904 \f[CB]ToolProvider.findFirst(&quot;javac&quot;)\f[R].
1905 This returns an object with the equivalent functionality of the
1906 command\-line tool.
1907 .RS
1908 .PP
1909 \f[B]Note\f[R]: This API should not be confused with the like\-named API
1910 in the \f[B]\f[BC]javax.tools\f[B]\f[R] package.
1911 .RE
1912 .TP
1913 .B The \f[CB]javac\f[R] \f[B]Legacy API\f[R]
1914 This API is retained for backward compatibility only.
1915 All new code should use either the Java Compiler API or the ToolProvider
1916 API.
1917 .RS
1918 .RE
1919 .PP
1920 \f[B]Note:\f[R] All other classes and methods found in a package with
1921 names that start with \f[CB]com.sun.tools.javac\f[R] (subpackages of
1922 \f[CB]com.sun.tools.javac\f[R]) are strictly internal and subject to
1923 change at any time.
1924 .SH EXAMPLES OF USING \-XLINT KEYS
1925 .TP
1926 .B \f[CB]cast\f[R]
1927 Warns about unnecessary and redundant casts, for example:
1928 .RS
1929 .RS
1930 .PP
1931 \f[CB]String\ s\ =\ (String)\ &quot;Hello!&quot;\f[R]
1932 .RE
1933 .RE
1934 .TP
1935 .B \f[CB]classfile\f[R]
1936 Warns about issues related to class file contents.
1937 .RS
1938 .RE
1939 .TP
1940 .B \f[CB]deprecation\f[R]
1941 Warns about the use of deprecated items.
1942 For example:
1943 .RS
1944 .IP
1945 .nf
1946 \f[CB]
1947 java.util.Date\ myDate\ =\ new\ java.util.Date();
1948 int\ currentDay\ =\ myDate.getDay();
1949 \f[R]
1950 .fi
1951 .PP
1952 The method \f[CB]java.util.Date.getDay\f[R] has been deprecated since JDK
1953 1.1.
1954 .RE
1955 .TP
1956 .B \f[CB]dep\-ann\f[R]
1957 Warns about items that are documented with the \f[CB]\@deprecated\f[R]
1958 Javadoc comment, but do not have the \f[CB]\@Deprecated\f[R] annotation,
1959 for example:
1960 .RS
1961 .IP
1962 .nf
1963 \f[CB]
1964 /**
1965 \ \ *\ \@deprecated\ As\ of\ Java\ SE\ 7,\ replaced\ by\ {\@link\ #newMethod()}
1966 \ \ */
1967 public\ static\ void\ deprecatedMethod()\ {\ }
1968 public\ static\ void\ newMethod()\ {\ }
1969 \f[R]
1970 .fi
1971 .RE
1972 .TP
1973 .B \f[CB]divzero\f[R]
1974 Warns about division by the constant integer 0, for example:
1975 .RS
1976 .RS
1977 .PP
1978 \f[CB]int\ divideByZero\ =\ 42\ /\ 0;\f[R]
1979 .RE
1980 .RE
1981 .TP
1982 .B \f[CB]empty\f[R]
1983 Warns about empty statements after \f[CB]if\f[R]statements, for example:
1984 .RS
1985 .IP
1986 .nf
1987 \f[CB]
1988 class\ E\ {
1989 \ \ \ \ void\ m()\ {
1990 \ \ \ \ \ \ \ \ \ if\ (true)\ ;
1991 \ \ \ \ }
1992 }
1993 \f[R]
1994 .fi
1995 .RE
1996 .TP
1997 .B \f[CB]fallthrough\f[R]
1998 Checks the switch blocks for fall\-through cases and provides a warning
1999 message for any that are found.
2000 Fall\-through cases are cases in a switch block, other than the last
2001 case in the block, whose code does not include a \f[CB]break\f[R]
2002 statement, allowing code execution to fall through from that case to the
2003 next case.
2004 For example, the code following the case 1 label in this switch block
2005 does not end with a \f[CB]break\f[R] statement:
2006 .RS
2007 .IP
2008 .nf
2009 \f[CB]
2010 switch\ (x)\ {
2011 case\ 1:
2012 \ \ System.out.println(&quot;1&quot;);
2013 \ \ //\ No\ break\ statement\ here.
2014 case\ 2:
2015 \ \ System.out.println(&quot;2&quot;);
2016 }
2017 \f[R]
2018 .fi
2019 .PP
2020 If the \f[CB]\-Xlint:fallthrough\f[R] option was used when compiling this
2021 code, then the compiler emits a warning about possible fall\-through
2022 into case, with the line number of the case in question.
2023 .RE
2024 .TP
2025 .B \f[CB]finally\f[R]
2026 Warns about \f[CB]finally\f[R] clauses that cannot be completed normally,
2027 for example:
2028 .RS
2029 .IP
2030 .nf
2031 \f[CB]
2032 public\ static\ int\ m()\ {
2033 \ \ try\ {
2034 \ \ \ \ \ throw\ new\ NullPointerException();
2035 \ \ }\ \ catch\ (NullPointerException();\ {
2036 \ \ \ \ \ System.err.println(&quot;Caught\ NullPointerException.&quot;);
2037 \ \ \ \ \ return\ 1;
2038 \ \ \ }\ finally\ {
2039 \ \ \ \ \ return\ 0;
2040 \ \ \ }
2041 \ \ }
2042 \f[R]
2043 .fi
2044 .PP
2045 The compiler generates a warning for the \f[CB]finally\f[R] block in this
2046 example.
2047 When the \f[CB]int\f[R] method is called, it returns a value of 0.
2048 A \f[CB]finally\f[R] block executes when the \f[CB]try\f[R] block exits.
2049 In this example, when control is transferred to the \f[CB]catch\f[R]
2050 block, the \f[CB]int\f[R] method exits.
2051 However, the \f[CB]finally\f[R] block must execute, so it\[aq]s executed,
2052 even though control was transferred outside the method.
2053 .RE
2054 .TP
2055 .B \f[CB]options\f[R]
2056 Warns about issues that related to the use of command\-line options.
2057 See \f[B]Compiling for Earlier Releases of the Platform\f[R].
2058 .RS
2059 .RE
2060 .TP
2061 .B \f[CB]overrides\f[R]
2062 Warns about issues related to method overrides.
2063 For example, consider the following two classes:
2064 .RS
2065 .IP
2066 .nf
2067 \f[CB]
2068 public\ class\ ClassWithVarargsMethod\ {
2069 \ \ void\ varargsMethod(String...\ s)\ {\ }
2070 }
2071 
2072 public\ class\ ClassWithOverridingMethod\ extends\ ClassWithVarargsMethod\ {
2073 \ \ \ \@Override
2074 \ \ \ void\ varargsMethod(String[]\ s)\ {\ }
2075 }
2076 \f[R]
2077 .fi
2078 .PP
2079 The compiler generates a warning similar to the following:.
2080 .IP
2081 .nf
2082 \f[CB]
2083 warning:\ [override]\ varargsMethod(String[])\ in\ ClassWithOverridingMethod
2084 overrides\ varargsMethod(String...)\ in\ ClassWithVarargsMethod;\ overriding
2085 method\ is\ missing\ \[aq]...\[aq]
2086 \f[R]
2087 .fi
2088 .PP
2089 When the compiler encounters a \f[CB]varargs\f[R] method, it translates
2090 the \f[CB]varargs\f[R] formal parameter into an array.
2091 In the method \f[CB]ClassWithVarargsMethod.varargsMethod\f[R], the
2092 compiler translates the \f[CB]varargs\f[R] formal parameter
2093 \f[CB]String...\ s\f[R] to the formal parameter \f[CB]String[]\ s\f[R], an
2094 array that matches the formal parameter of the method
2095 \f[CB]ClassWithOverridingMethod.varargsMethod\f[R].
2096 Consequently, this example compiles.
2097 .RE
2098 .TP
2099 .B \f[CB]path\f[R]
2100 Warns about invalid path elements and nonexistent path directories on
2101 the command line (with regard to the class path, the source path, and
2102 other paths).
2103 Such warnings cannot be suppressed with the \f[CB]\@SuppressWarnings\f[R]
2104 annotation.
2105 For example:
2106 .RS
2107 .IP \[bu] 2
2108 \f[B]Oracle Solaris, Linux, and macOS:\f[R]
2109 \f[CB]javac\ \-Xlint:path\ \-classpath\ /nonexistentpath\ Example.java\f[R]
2110 .IP \[bu] 2
2111 \f[B]Windows:\f[R]
2112 \f[CB]javac\ \-Xlint:path\ \-classpath\ C:\\nonexistentpath\ Example.java\f[R]
2113 .RE
2114 .TP
2115 .B \f[CB]processing\f[R]
2116 Warns about issues related to annotation processing.
2117 The compiler generates this warning when you have a class that has an
2118 annotation, and you use an annotation processor that cannot handle that
2119 type of exception.
2120 For example, the following is a simple annotation processor:
2121 .RS
2122 .PP
2123 \f[B]Source file AnnocProc.java\f[R]:
2124 .IP
2125 .nf
2126 \f[CB]
2127 import\ java.util.*;
2128 import\ javax.annotation.processing.*;
2129 import\ javax.lang.model.*;
2130 import\ javaz.lang.model.element.*;
2131 
2132 \@SupportedAnnotationTypes(&quot;NotAnno&quot;)
2133 public\ class\ AnnoProc\ extends\ AbstractProcessor\ {
2134 \ \ public\ boolean\ process(Set&lt;?\ extends\ TypeElement&gt;\ elems,\ RoundEnvironment\ renv){
2135 \ \ \ \ \ return\ true;
2136 \ \ }
2137 
2138 \ \ public\ SourceVersion\ getSupportedSourceVersion()\ {
2139 \ \ \ \ \ return\ SourceVersion.latest();
2140 \ \ \ }
2141 }
2142 \f[R]
2143 .fi
2144 .PP
2145 \f[B]Source file AnnosWithoutProcessors.java\f[R]:
2146 .IP
2147 .nf
2148 \f[CB]
2149 \@interface\ Anno\ {\ }
2150 
2151 \@Anno
2152 class\ AnnosWithoutProcessors\ {\ }
2153 \f[R]
2154 .fi
2155 .PP
2156 The following commands compile the annotation processor
2157 \f[CB]AnnoProc\f[R], then run this annotation processor against the source
2158 file \f[CB]AnnosWithoutProcessors.java\f[R]:
2159 .IP
2160 .nf
2161 \f[CB]
2162 javac\ AnnoProc.java
2163 javac\ \-cp\ .\ \-Xlint:processing\ \-processor\ AnnoProc\ \-proc:only\ AnnosWithoutProcessors.java
2164 \f[R]
2165 .fi
2166 .PP
2167 When the compiler runs the annotation processor against the source file
2168 \f[CB]AnnosWithoutProcessors.java\f[R], it generates the following
2169 warning:
2170 .IP
2171 .nf
2172 \f[CB]
2173 warning:\ [processing]\ No\ processor\ claimed\ any\ of\ these\ annotations:\ Anno
2174 \f[R]
2175 .fi
2176 .PP
2177 To resolve this issue, you can rename the annotation defined and used in
2178 the class \f[CB]AnnosWithoutProcessors\f[R] from \f[CB]Anno\f[R] to
2179 \f[CB]NotAnno\f[R].
2180 .RE
2181 .TP
2182 .B \f[CB]rawtypes\f[R]
2183 Warns about unchecked operations on raw types.
2184 The following statement generates a \f[CB]rawtypes\f[R] warning:
2185 .RS
2186 .RS
2187 .PP
2188 \f[CB]void\ countElements(List\ l)\ {\ ...\ }\f[R]
2189 .RE
2190 .PP
2191 The following example does not generate a \f[CB]rawtypes\f[R] warning:
2192 .RS
2193 .PP
2194 \f[CB]void\ countElements(List&lt;?&gt;\ l)\ {\ ...\ }\f[R]
2195 .RE
2196 .PP
2197 \f[CB]List\f[R] is a raw type.
2198 However, \f[CB]List&lt;?&gt;\f[R] is an unbounded wildcard parameterized type.
2199 Because \f[CB]List\f[R] is a parameterized interface, always specify its
2200 type argument.
2201 In this example, the \f[CB]List\f[R] formal argument is specified with an
2202 unbounded wildcard (\f[CB]?\f[R]) as its formal type parameter, which
2203 means that the \f[CB]countElements\f[R] method can accept any
2204 instantiation of the \f[CB]List\f[R] interface.
2205 .RE
2206 .TP
2207 .B \f[CB]serial\f[R]
2208 Warns about missing \f[CB]serialVersionUID\f[R] definitions on
2209 serializable classes.
2210 For example:
2211 .RS
2212 .IP
2213 .nf
2214 \f[CB]
2215 public\ class\ PersistentTime\ implements\ Serializable
2216 {
2217 \ \ private\ Date\ time;
2218 
2219 \ \ \ public\ PersistentTime()\ {
2220 \ \ \ \ \ time\ =\ Calendar.getInstance().getTime();
2221 \ \ \ }
2222 
2223 \ \ \ public\ Date\ getTime()\ {
2224 \ \ \ \ \ return\ time;
2225 \ \ \ }
2226 }
2227 \f[R]
2228 .fi
2229 .PP
2230 The compiler generates the following warning:
2231 .IP
2232 .nf
2233 \f[CB]
2234 warning:\ [serial]\ serializable\ class\ PersistentTime\ has\ no\ definition\ of
2235 serialVersionUID
2236 \f[R]
2237 .fi
2238 .PP
2239 If a serializable class does not explicitly declare a field named
2240 \f[CB]serialVersionUID\f[R], then the serialization runtime environment
2241 calculates a default \f[CB]serialVersionUID\f[R] value for that class
2242 based on various aspects of the class, as described in the Java Object
2243 Serialization Specification.
2244 However, it\[aq]s strongly recommended that all serializable classes
2245 explicitly declare \f[CB]serialVersionUID\f[R] values because the default
2246 process of computing \f[CB]serialVersionUID\f[R] values is highly
2247 sensitive to class details that can vary depending on compiler
2248 implementations.
2249 As a result, this might cause an unexpected
2250 \f[CB]InvalidClassExceptions\f[R] during deserialization.
2251 To guarantee a consistent \f[CB]serialVersionUID\f[R] value across
2252 different Java compiler implementations, a serializable class must
2253 declare an explicit \f[CB]serialVersionUID\f[R] value.
2254 .RE
2255 .TP
2256 .B \f[CB]static\f[R]
2257 Warns about issues relating to the use of static variables, for example:
2258 .RS
2259 .IP
2260 .nf
2261 \f[CB]
2262 class\ XLintStatic\ {
2263 \ \ \ \ static\ void\ m1()\ {\ }
2264 \ \ \ \ void\ m2()\ {\ this.m1();\ }
2265 }
2266 \f[R]
2267 .fi
2268 .PP
2269 The compiler generates the following warning:
2270 .IP
2271 .nf
2272 \f[CB]
2273 warning:\ [static]\ static\ method\ should\ be\ qualified\ by\ type\ name,
2274 XLintStatic,\ instead\ of\ by\ an\ expression
2275 \f[R]
2276 .fi
2277 .PP
2278 To resolve this issue, you can call the \f[CB]static\f[R] method
2279 \f[CB]m1\f[R] as follows:
2280 .RS
2281 .PP
2282 \f[CB]XLintStatic.m1();\f[R]
2283 .RE
2284 .PP
2285 Alternately, you can remove the \f[CB]static\f[R] keyword from the
2286 declaration of the method \f[CB]m1\f[R].
2287 .RE
2288 .TP
2289 .B \f[CB]try\f[R]
2290 Warns about issues relating to the use of \f[CB]try\f[R] blocks, including
2291 try\-with\-resources statements.
2292 For example, a warning is generated for the following statement because
2293 the resource \f[CB]ac\f[R] declared in the \f[CB]try\f[R] block is not used:
2294 .RS
2295 .IP
2296 .nf
2297 \f[CB]
2298 try\ (\ AutoCloseable\ ac\ =\ getResource()\ )\ {\ \ \ \ //\ do\ nothing}
2299 \f[R]
2300 .fi
2301 .RE
2302 .TP
2303 .B \f[CB]unchecked\f[R]
2304 Gives more detail for unchecked conversion warnings that are mandated by
2305 the Java Language Specification, for example:
2306 .RS
2307 .IP
2308 .nf
2309 \f[CB]
2310 List\ l\ =\ new\ ArrayList&lt;Number&gt;();
2311 List&lt;String&gt;\ ls\ =\ l;\ \ \ \ \ \ \ //\ unchecked\ warning
2312 \f[R]
2313 .fi
2314 .PP
2315 During type erasure, the types \f[CB]ArrayList&lt;Number&gt;\f[R] and
2316 \f[CB]List&lt;String&gt;\f[R] become \f[CB]ArrayList\f[R] and \f[CB]List\f[R],
2317 respectively.
2318 .PP
2319 The \f[CB]ls\f[R] command has the parameterized type
2320 \f[CB]List&lt;String&gt;\f[R].
2321 When the \f[CB]List\f[R] referenced by \f[CB]l\f[R] is assigned to
2322 \f[CB]ls\f[R], the compiler generates an unchecked warning.
2323 At compile time, the compiler and JVM cannot determine whether
2324 \f[CB]l\f[R] refers to a \f[CB]List&lt;String&gt;\f[R] type.
2325 In this case, \f[CB]l\f[R] does not refer to a \f[CB]List&lt;String&gt;\f[R] type.
2326 As a result, heap pollution occurs.
2327 .PP
2328 A heap pollution situation occurs when the \f[CB]List\f[R] object
2329 \f[CB]l\f[R], whose static type is \f[CB]List&lt;Number&gt;\f[R], is assigned to
2330 another \f[CB]List\f[R] object, \f[CB]ls\f[R], that has a different static
2331 type, \f[CB]List&lt;String&gt;\f[R].
2332 However, the compiler still allows this assignment.
2333 It must allow this assignment to preserve backward compatibility with
2334 releases of Java SE that do not support generics.
2335 Because of type erasure, \f[CB]List&lt;Number&gt;\f[R] and \f[CB]List&lt;String&gt;\f[R]
2336 both become \f[CB]List\f[R].
2337 Consequently, the compiler allows the assignment of the object
2338 \f[CB]l\f[R], which has a raw type of \f[CB]List\f[R], to the object
2339 \f[CB]ls\f[R].
2340 .RE
2341 .TP
2342 .B \f[CB]varargs\f[R]
2343 Warns about unsafe use of variable arguments (\f[CB]varargs\f[R]) methods,
2344 in particular, those that contain non\-reifiable arguments, for example:
2345 .RS
2346 .IP
2347 .nf
2348 \f[CB]
2349 public\ class\ ArrayBuilder\ {
2350 \ \ public\ static\ &lt;T&gt;\ void\ addToList\ (List&lt;T&gt;\ listArg,\ T...\ elements)\ {
2351 \ \ \ \ for\ (T\ x\ :\ elements)\ {
2352 \ \ \ \ \ \ listArg.add(x);
2353 \ \ \ \ }
2354 \ \ }
2355 }
2356 \f[R]
2357 .fi
2358 .PP
2359 A non\-reifiable type is a type whose type information is not fully
2360 available at runtime.
2361 .PP
2362 The compiler generates the following warning for the definition of the
2363 method \f[CB]ArrayBuilder.addToList\f[R]:
2364 .IP
2365 .nf
2366 \f[CB]
2367 warning:\ [varargs]\ Possible\ heap\ pollution\ from\ parameterized\ vararg\ type\ T
2368 \f[R]
2369 .fi
2370 .PP
2371 When the compiler encounters a varargs method, it translates the
2372 \f[CB]varargs\f[R] formal parameter into an array.
2373 However, the Java programming language does not permit the creation of
2374 arrays of parameterized types.
2375 In the method \f[CB]ArrayBuilder.addToList\f[R], the compiler translates
2376 the \f[CB]varargs\f[R] formal parameter \f[CB]T...\f[R] elements to the
2377 formal parameter \f[CB]T[]\f[R] elements, an array.
2378 However, because of type erasure, the compiler converts the
2379 \f[CB]varargs\f[R] formal parameter to \f[CB]Object[]\f[R] elements.
2380 Consequently, there\[aq]s a possibility of heap pollution.
2381 .RE
    </pre>
  </body>
</html>