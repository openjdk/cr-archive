<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.security.auth/share/classes/com/sun/security/auth/module/Krb5LoginModule.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 package com.sun.security.auth.module;
  28 
  29 import java.io.*;
  30 import java.text.MessageFormat;
  31 import java.util.*;
  32 
  33 import javax.security.auth.*;
  34 import javax.security.auth.kerberos.KerberosTicket;
  35 import javax.security.auth.kerberos.KerberosPrincipal;
  36 import javax.security.auth.kerberos.KerberosKey;
  37 import javax.security.auth.kerberos.KeyTab;
  38 import javax.security.auth.callback.*;
  39 import javax.security.auth.login.*;
  40 import javax.security.auth.spi.*;
  41 
  42 import sun.security.krb5.*;
  43 import sun.security.jgss.krb5.Krb5Util;
  44 import sun.security.krb5.Credentials;
  45 import sun.security.util.HexDumpEncoder;
  46 import static sun.security.util.ResourcesMgr.getAuthResourceString;
  47 
  48 /**
  49  * This {@code LoginModule} authenticates users using
  50  * Kerberos protocols.
  51  *
  52  * &lt;p&gt; The configuration entry for {@code Krb5LoginModule} has
  53  * several options that control the authentication process and
  54  * additions to the {@code Subject}&#39;s private credential
  55  * set. Irrespective of these options, the {@code Subject}&#39;s
  56  * principal set and private credentials set are updated only when
  57  * {@code commit} is called.
  58  * When {@code commit} is called, the {@code KerberosPrincipal}
  59  * is added to the {@code Subject}&#39;s principal set (unless the
  60  * {@code principal} is specified as &quot;*&quot;). If {@code isInitiator}
  61  * is true, the {@code KerberosTicket} is
  62  * added to the {@code Subject}&#39;s private credentials.
  63  *
  64  * &lt;p&gt; If the configuration entry for {@code KerberosLoginModule}
  65  * has the option {@code storeKey} set to true, then
  66  * {@code KerberosKey} or {@code KeyTab} will also be added to the
  67  * subject&#39;s private credentials. {@code KerberosKey}, the principal&#39;s
  68  * key(s) will be derived from user&#39;s password, and {@code KeyTab} is
  69  * the keytab used when {@code useKeyTab} is set to true. The
  70  * {@code KeyTab} object is restricted to be used by the specified
  71  * principal unless the principal value is &quot;*&quot;.
  72  *
  73  * &lt;p&gt; This {@code LoginModule} recognizes the {@code doNotPrompt}
  74  * option. If set to true the user will not be prompted for the password.
  75  *
  76  * &lt;p&gt; The user can  specify the location of the ticket cache by using
  77  * the option {@code ticketCache} in the configuration entry.
  78  *
  79  * &lt;p&gt;The user can specify the keytab location by using
  80  * the option {@code keyTab}
  81  * in the configuration entry.
  82  *
  83  * &lt;p&gt; The principal name can be specified in the configuration entry
  84  * by using the option {@code principal}. The principal name
  85  * can either be a simple user name, a service name such as
  86  * {@code host/mission.eng.sun.com}, or &quot;*&quot;. The principal can also
  87  * be set using the system property {@systemProperty sun.security.krb5.principal}.
  88  * This property is checked during login. If this property is not set, then
  89  * the principal name from the configuration is used. In the
  90  * case where the principal property is not set and the principal
  91  * entry also does not exist, the user is prompted for the name.
  92  * When this property of entry is set, and {@code useTicketCache}
  93  * is set to true, only TGT belonging to this principal is used.
  94  *
  95  * &lt;p&gt; The following is a list of configuration options supported
  96  * for {@code Krb5LoginModule}:
  97  * &lt;blockquote&gt;&lt;dl&gt;
  98  * &lt;dt&gt;{@code refreshKrb5Config}:&lt;/dt&gt;
  99  * &lt;dd&gt; Set this to true, if you want the configuration
 100  * to be refreshed before the {@code login} method is called.&lt;/dd&gt;
 101  * &lt;dt&gt;{@code useTicketCache}:&lt;/dt&gt;
 102  * &lt;dd&gt;Set this to true, if you want the
 103  * TGT to be obtained from the ticket cache. Set this option
 104  * to false if you do not want this module to use the ticket cache.
 105  * (Default is False).
 106  * This module will search for the ticket
 107  * cache in the following locations: On Linux
 108  * it will look for the ticket cache in /tmp/krb5cc_{@code uid}
 109  * where the uid is numeric user identifier. If the ticket cache is
 110  * not available in the above location, or if we are on a
 111  * Windows platform, it will look for the cache as
 112  * {user.home}{file.separator}krb5cc_{user.name}.
 113  * You can override the ticket cache location by using
 114  * {@code ticketCache}.
 115  * For Windows, if a ticket cannot be retrieved from the file ticket cache,
 116  * it will use Local Security Authority (LSA) API to get the TGT.
 117  * &lt;dt&gt;{@code ticketCache}:&lt;/dt&gt;
 118  * &lt;dd&gt;Set this to the name of the ticket
 119  * cache that  contains user&#39;s TGT.
 120  * If this is set,  {@code useTicketCache}
 121  * must also be set to true; Otherwise a configuration error will
 122  * be returned.&lt;/dd&gt;
 123  * &lt;dt&gt;{@code renewTGT}:&lt;/dt&gt;
 124  * &lt;dd&gt;Set this to true, if you want to renew the TGT when it&#39;s more than
 125  * half-way expired (the time until expiration is less than the time
 126  * since start time). If this is set, {@code useTicketCache} must also be
 127  * set to true; otherwise a configuration error will be returned.&lt;/dd&gt;
 128  * &lt;dt&gt;{@code doNotPrompt}:&lt;/dt&gt;
 129  * &lt;dd&gt;Set this to true if you do not want to be
 130  * prompted for the password
 131  * if credentials can not be obtained from the cache, the keytab,
 132  * or through shared state.(Default is false)
 133  * If set to true, credential must be obtained through cache, keytab,
 134  * or shared state. Otherwise, authentication will fail.&lt;/dd&gt;
 135  * &lt;dt&gt;{@code useKeyTab}:&lt;/dt&gt;
 136  * &lt;dd&gt;Set this to true if you
 137  * want the module to get the principal&#39;s key from the
 138  * the keytab.(default value is False)
 139  * If {@code keytab} is not set then
 140  * the module will locate the keytab from the
 141  * Kerberos configuration file.
 142  * If it is not specified in the Kerberos configuration file
 143  * then it will look for the file
 144  * {@code {user.home}{file.separator}}krb5.keytab.&lt;/dd&gt;
 145  * &lt;dt&gt;{@code keyTab}:&lt;/dt&gt;
 146  * &lt;dd&gt;Set this to the file name of the
 147  * keytab to get principal&#39;s secret key.&lt;/dd&gt;
 148  * &lt;dt&gt;{@code storeKey}:&lt;/dt&gt;
 149  * &lt;dd&gt;Set this to true to if you want the keytab or the
 150  * principal&#39;s key to be stored in the Subject&#39;s private credentials.
 151  * For {@code isInitiator} being false, if {@code principal}
 152  * is &quot;*&quot;, the {@link KeyTab} stored can be used by anyone, otherwise,
 153  * it&#39;s restricted to be used by the specified principal only.&lt;/dd&gt;
 154  * &lt;dt&gt;{@code principal}:&lt;/dt&gt;
 155  * &lt;dd&gt;The name of the principal that should
 156  * be used. The principal can be a simple username such as
 157  * &quot;{@code testuser}&quot; or a service name such as
 158  * &quot;{@code host/testhost.eng.sun.com}&quot;. You can use the
 159  * {@code principal}  option to set the principal when there are
 160  * credentials for multiple principals in the
 161  * {@code keyTab} or when you want a specific ticket cache only.
 162  * The principal can also be set using the system property
 163  * {@code sun.security.krb5.principal}. In addition, if this
 164  * system property is defined, then it will be used. If this property
 165  * is not set, then the principal name from the configuration will be
 166  * used.
 167  * The principal name can be set to &quot;*&quot; when {@code isInitiator} is false.
 168  * In this case, the acceptor is not bound to a single principal. It can
 169  * act as any principal an initiator requests if keys for that principal
 170  * can be found. When {@code isInitiator} is true, the principal name
 171  * cannot be set to &quot;*&quot;.
 172  * &lt;/dd&gt;
 173  * &lt;dt&gt;{@code isInitiator}:&lt;/dt&gt;
 174  * &lt;dd&gt;Set this to true, if initiator. Set this to false, if acceptor only.
 175  * (Default is true).
 176  * Note: Do not set this value to false for initiators.&lt;/dd&gt;
 177  * &lt;/dl&gt;&lt;/blockquote&gt;
 178  *
 179  * &lt;p&gt; This {@code LoginModule} also recognizes the following additional
 180  * {@code Configuration}
 181  * options that enable you to share username and passwords across different
 182  * authentication modules:
 183  * &lt;blockquote&gt;&lt;dl&gt;
 184  *
 185  *    &lt;dt&gt;{@code useFirstPass}:&lt;/dt&gt;
 186  *                   &lt;dd&gt;if, true, this LoginModule retrieves the
 187  *                   username and password from the module&#39;s shared state,
 188  *                   using &quot;javax.security.auth.login.name&quot; and
 189  *                   &quot;javax.security.auth.login.password&quot; as the respective
 190  *                   keys. The retrieved values are used for authentication.
 191  *                   If authentication fails, no attempt for a retry
 192  *                   is made, and the failure is reported back to the
 193  *                   calling application.&lt;/dd&gt;
 194  *
 195  *    &lt;dt&gt;{@code tryFirstPass}:&lt;/dt&gt;
 196  *                   &lt;dd&gt;if, true, this LoginModule retrieves the
 197  *                   the username and password from the module&#39;s shared
 198  *                   state using &quot;javax.security.auth.login.name&quot; and
 199  *                   &quot;javax.security.auth.login.password&quot; as the respective
 200  *                   keys.  The retrieved values are used for
 201  *                   authentication.
 202  *                   If authentication fails, the module uses the
 203  *                   CallbackHandler to retrieve a new username
 204  *                   and password, and another attempt to authenticate
 205  *                   is made. If the authentication fails,
 206  *                   the failure is reported back to the calling application&lt;/dd&gt;
 207  *
 208  *    &lt;dt&gt;{@code storePass}:&lt;/dt&gt;
 209  *                   &lt;dd&gt;if, true, this LoginModule stores the username and
 210  *                   password obtained from the CallbackHandler in the
 211  *                   modules shared state, using
 212  *                   &quot;javax.security.auth.login.name&quot; and
 213  *                   &quot;javax.security.auth.login.password&quot; as the respective
 214  *                   keys.  This is not performed if existing values already
 215  *                   exist for the username and password in the shared
 216  *                   state, or if authentication fails.&lt;/dd&gt;
 217  *
 218  *    &lt;dt&gt;{@code clearPass}:&lt;/dt&gt;
 219  *                   &lt;dd&gt;if, true, this LoginModule clears the
 220  *                   username and password stored in the module&#39;s shared
 221  *                   state  after both phases of authentication
 222  *                   (login and commit) have completed.&lt;/dd&gt;
 223  * &lt;/dl&gt;&lt;/blockquote&gt;
 224  * &lt;p&gt;If the principal system property or key is already provided, the value of
 225  * &quot;javax.security.auth.login.name&quot; in the shared state is ignored.
 226  * &lt;p&gt;When multiple mechanisms to retrieve a ticket or key is provided, the
 227  * preference order is:
 228  * &lt;ol&gt;
 229  * &lt;li&gt;ticket cache
 230  * &lt;li&gt;keytab
 231  * &lt;li&gt;shared state
 232  * &lt;li&gt;user prompt
 233  * &lt;/ol&gt;
 234  *
 235  * &lt;p&gt;Note that if any step fails, it will fallback to the next step.
 236  * There&#39;s only one exception, if the shared state step fails and
 237  * {@code useFirstPass = true}, no user prompt is made.
 238  * &lt;p&gt;Examples of some configuration values for Krb5LoginModule in
 239  * JAAS config file and the results are:
 240  * &lt;blockquote&gt;
 241  * &lt;pre&gt;{@code
 242  * doNotPrompt = true}&lt;/pre&gt;
 243  * This is an illegal combination since none of {@code useTicketCache,
 244  * useKeyTab, useFirstPass} and {@code tryFirstPass}
 245  * is set and the user can not be prompted for the password.
 246  *
 247  * &lt;pre&gt;{@code
 248  * ticketCache = &lt;filename&gt;}&lt;/pre&gt;
 249  * This is an illegal combination since {@code useTicketCache}
 250  * is not set to true and the ticketCache is set. A configuration error
 251  * will occur.
 252  *
 253  * &lt;pre&gt;{@code
 254  * renewTGT = true}&lt;/pre&gt;
 255  * This is an illegal combination since {@code useTicketCache} is
 256  * not set to true and renewTGT is set. A configuration error will occur.
 257  *
 258  * &lt;pre&gt;{@code
 259  * storeKey = true  useTicketCache = true  doNotPrompt = true}&lt;/pre&gt;
 260  * This is an illegal combination since  {@code storeKey} is set to
 261  * true but the key can not be obtained either by prompting the user or from
 262  * the keytab, or from the shared state. A configuration error will occur.
 263  *
 264  * &lt;pre&gt;{@code
 265  * keyTab = &lt;filename&gt;  doNotPrompt = true}&lt;/pre&gt;
 266  * This is an illegal combination since useKeyTab is not set to true and
 267  * the keyTab is set. A configuration error will occur.
 268  *
 269  * &lt;pre&gt;{@code
 270  * debug = true}&lt;/pre&gt;
 271  * Prompt the user for the principal name and the password.
 272  * Use the authentication exchange to get TGT from the KDC and
 273  * populate the {@code Subject} with the principal and TGT.
 274  * Output debug messages.
 275  *
 276  * &lt;pre&gt;{@code
 277  * useTicketCache = true  doNotPrompt = true}&lt;/pre&gt;
 278  * Check the default cache for TGT and populate the {@code Subject}
 279  * with the principal and TGT. If the TGT is not available,
 280  * do not prompt the user, instead fail the authentication.
 281  *
 282  * &lt;pre&gt;{@code
 283  * principal = &lt;name&gt;  useTicketCache = true  doNotPrompt = true}&lt;/pre&gt;
 284  * Get the TGT from the default cache for the principal and populate the
 285  * Subject&#39;s principal and private creds set. If ticket cache is
 286  * not available or does not contain the principal&#39;s TGT
 287  * authentication will fail.
 288  *
 289  * &lt;pre&gt;{@code
 290  * useTicketCache = true
 291  * ticketCache = &lt;file name&gt;
 292  * useKeyTab = true
 293  * keyTab = &lt;keytab filename&gt;
 294  * principal = &lt;principal name&gt;
 295  * doNotPrompt = true}&lt;/pre&gt;
 296  * Search the cache for the principal&#39;s TGT. If it is not available
 297  * use the key in the keytab to perform authentication exchange with the
 298  * KDC and acquire the TGT.
 299  * The Subject will be populated with the principal and the TGT.
 300  * If the key is not available or valid then authentication will fail.
 301  *
 302  * &lt;pre&gt;{@code
 303  * useTicketCache = true  ticketCache = &lt;filename&gt;}&lt;/pre&gt;
 304  * The TGT will be obtained from the cache specified.
 305  * The Kerberos principal name used will be the principal name in
 306  * the Ticket cache. If the TGT is not available in the
 307  * ticket cache the user will be prompted for the principal name
 308  * and the password. The TGT will be obtained using the authentication
 309  * exchange with the KDC.
 310  * The Subject will be populated with the TGT.
 311  *
 312  * &lt;pre&gt;{@code
 313  * useKeyTab = true  keyTab=&lt;keytab filename&gt;  principal = &lt;principal name&gt;  storeKey = true}&lt;/pre&gt;
 314  * The key for the principal will be retrieved from the keytab.
 315  * If the key is not available in the keytab the user will be prompted
 316  * for the principal&#39;s password. The Subject will be populated
 317  * with the principal&#39;s key either from the keytab or derived from the
 318  * password entered.
 319  *
 320  * &lt;pre&gt;{@code
 321  * useKeyTab = true  keyTab = &lt;keytabname&gt;  storeKey = true  doNotPrompt = false}&lt;/pre&gt;
 322  * The user will be prompted for the service principal name.
 323  * If the principal&#39;s
 324  * longterm key is available in the keytab , it will be added to the
 325  * Subject&#39;s private credentials. An authentication exchange will be
 326  * attempted with the principal name and the key from the Keytab.
 327  * If successful the TGT will be added to the
 328  * Subject&#39;s private credentials set. Otherwise the authentication will fail.
 329  *
 330  * &lt;pre&gt;{@code
 331  * isInitiator = false  useKeyTab = true  keyTab = &lt;keytabname&gt;  storeKey = true  principal = *}&lt;/pre&gt;
 332  * The acceptor will be an unbound acceptor and it can act as any principal
 333  * as long that principal has keys in the keytab.
 334  *
 335  * &lt;pre&gt;{@code
 336  * useTicketCache = true
 337  * ticketCache = &lt;file name&gt;
 338  * useKeyTab = true
 339  * keyTab = &lt;file name&gt;
 340  * storeKey = true
 341  * principal = &lt;principal name&gt;}&lt;/pre&gt;
 342  * The client&#39;s TGT will be retrieved from the ticket cache and added to the
 343  * {@code Subject}&#39;s private credentials. If the TGT is not available
 344  * in the ticket cache, or the TGT&#39;s client name does not match the principal
 345  * name, Java will use a secret key to obtain the TGT using the authentication
 346  * exchange and added to the Subject&#39;s private credentials.
 347  * This secret key will be first retrieved from the keytab. If the key
 348  * is not available, the user will be prompted for the password. In either
 349  * case, the key derived from the password will be added to the
 350  * Subject&#39;s private credentials set.
 351  *
 352  * &lt;pre&gt;{@code
 353  * isInitiator = false}&lt;/pre&gt;
 354  * Configured to act as acceptor only, credentials are not acquired
 355  * via AS exchange. For acceptors only, set this value to false.
 356  * For initiators, do not set this value to false.
 357  *
 358  * &lt;pre&gt;{@code
 359  * isInitiator = true}&lt;/pre&gt;
 360  * Configured to act as initiator, credentials are acquired
 361  * via AS exchange. For initiators, set this value to true, or leave this
 362  * option unset, in which case default value (true) will be used.
 363  *
 364  * &lt;/blockquote&gt;
 365  *
 366  * @author Ram Marti
 367  */
 368 
 369 public class Krb5LoginModule implements LoginModule {
 370 
 371     // initial state
 372     private Subject subject;
 373     private CallbackHandler callbackHandler;
 374     private Map&lt;String, Object&gt; sharedState;
 375     private Map&lt;String, ?&gt; options;
 376 
 377     // configurable option
 378     private boolean debug = false;
 379     private boolean storeKey = false;
 380     private boolean doNotPrompt = false;
 381     private boolean useTicketCache = false;
 382     private boolean useKeyTab = false;
 383     private String ticketCacheName = null;
 384     private String keyTabName = null;
 385     private String princName = null;
 386 
 387     private boolean useFirstPass = false;
 388     private boolean tryFirstPass = false;
 389     private boolean storePass = false;
 390     private boolean clearPass = false;
 391     private boolean refreshKrb5Config = false;
 392     private boolean renewTGT = false;
 393 
 394     // specify if initiator.
 395     // perform authentication exchange if initiator
 396     private boolean isInitiator = true;
 397 
 398     // the authentication status
 399     private boolean succeeded = false;
 400     private boolean commitSucceeded = false;
 401     private String username;
 402 
 403     // Encryption keys calculated from password. Assigned when storekey == true
 404     // and useKeyTab == false (or true but not found)
 405     private EncryptionKey[] encKeys = null;
 406 
 407     KeyTab ktab = null;
 408 
 409     private Credentials cred = null;
 410 
 411     private PrincipalName principal = null;
 412     private KerberosPrincipal kerbClientPrinc = null;
 413     private KerberosTicket kerbTicket = null;
 414     private KerberosKey[] kerbKeys = null;
 415     private StringBuffer krb5PrincName = null;
 416     private boolean unboundServer = false;
 417     private char[] password = null;
 418 
 419     private static final String NAME = &quot;javax.security.auth.login.name&quot;;
 420     private static final String PWD = &quot;javax.security.auth.login.password&quot;;
 421 
<a name="1" id="anc1"></a><span class="line-added"> 422     /**</span>
<span class="line-added"> 423      * Creates a {@code Krb5LoginModule}.</span>
<span class="line-added"> 424      */</span>
<span class="line-added"> 425     public Krb5LoginModule() {}</span>
<span class="line-added"> 426 </span>
 427     /**
 428      * Initialize this {@code LoginModule}.
 429      *
 430      * @param subject the {@code Subject} to be authenticated.
 431      *
 432      * @param callbackHandler a {@code CallbackHandler} for
 433      *                  communication with the end user (prompting for
 434      *                  usernames and passwords, for example).
 435      *
 436      * @param sharedState shared {@code LoginModule} state.
 437      *
 438      * @param options options specified in the login
 439      *                  {@code Configuration} for this particular
 440      *                  {@code LoginModule}.
 441      */
 442     // Unchecked warning from (Map&lt;String, Object&gt;)sharedState is safe
 443     // since javax.security.auth.login.LoginContext passes a raw HashMap.
 444     // Unchecked warnings from options.get(String) are safe since we are
 445     // passing known keys.
 446     @SuppressWarnings(&quot;unchecked&quot;)
 447     public void initialize(Subject subject,
 448                            CallbackHandler callbackHandler,
 449                            Map&lt;String, ?&gt; sharedState,
 450                            Map&lt;String, ?&gt; options) {
 451 
 452         this.subject = subject;
 453         this.callbackHandler = callbackHandler;
 454         this.sharedState = (Map&lt;String, Object&gt;)sharedState;
 455         this.options = options;
 456 
 457         // initialize any configured options
 458 
 459         debug = &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;debug&quot;));
 460         storeKey = &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;storeKey&quot;));
 461         doNotPrompt = &quot;true&quot;.equalsIgnoreCase((String)options.get
 462                                               (&quot;doNotPrompt&quot;));
 463         useTicketCache = &quot;true&quot;.equalsIgnoreCase((String)options.get
 464                                                  (&quot;useTicketCache&quot;));
 465         useKeyTab = &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;useKeyTab&quot;));
 466         ticketCacheName = (String)options.get(&quot;ticketCache&quot;);
 467         keyTabName = (String)options.get(&quot;keyTab&quot;);
 468         if (keyTabName != null) {
 469             keyTabName = sun.security.krb5.internal.ktab.KeyTab.normalize(
 470                          keyTabName);
 471         }
 472         princName = (String)options.get(&quot;principal&quot;);
 473         refreshKrb5Config =
 474             &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;refreshKrb5Config&quot;));
 475         renewTGT =
 476             &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;renewTGT&quot;));
 477 
 478         // check isInitiator value
 479         String isInitiatorValue = ((String)options.get(&quot;isInitiator&quot;));
 480         if (isInitiatorValue == null) {
 481             // use default, if value not set
 482         } else {
 483             isInitiator = &quot;true&quot;.equalsIgnoreCase(isInitiatorValue);
 484         }
 485 
 486         tryFirstPass =
 487             &quot;true&quot;.equalsIgnoreCase
 488             ((String)options.get(&quot;tryFirstPass&quot;));
 489         useFirstPass =
 490             &quot;true&quot;.equalsIgnoreCase
 491             ((String)options.get(&quot;useFirstPass&quot;));
 492         storePass =
 493             &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;storePass&quot;));
 494         clearPass =
 495             &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;clearPass&quot;));
 496         if (debug) {
 497             System.out.print(&quot;Debug is  &quot; + debug
 498                              + &quot; storeKey &quot; + storeKey
 499                              + &quot; useTicketCache &quot; + useTicketCache
 500                              + &quot; useKeyTab &quot; + useKeyTab
 501                              + &quot; doNotPrompt &quot; + doNotPrompt
 502                              + &quot; ticketCache is &quot; + ticketCacheName
 503                              + &quot; isInitiator &quot; + isInitiator
 504                              + &quot; KeyTab is &quot; + keyTabName
 505                              + &quot; refreshKrb5Config is &quot; + refreshKrb5Config
 506                              + &quot; principal is &quot; + princName
 507                              + &quot; tryFirstPass is &quot; + tryFirstPass
 508                              + &quot; useFirstPass is &quot; + useFirstPass
 509                              + &quot; storePass is &quot; + storePass
 510                              + &quot; clearPass is &quot; + clearPass + &quot;\n&quot;);
 511         }
 512     }
 513 
 514 
 515     /**
 516      * Authenticate the user
 517      *
 518      * @return true in all cases since this {@code LoginModule}
 519      *          should not be ignored.
 520      *
 521      * @exception FailedLoginException if the authentication fails.
 522      *
 523      * @exception LoginException if this {@code LoginModule}
 524      *          is unable to perform the authentication.
 525      */
 526     public boolean login() throws LoginException {
 527 
 528         if (refreshKrb5Config) {
 529             try {
 530                 if (debug) {
 531                     System.out.println(&quot;Refreshing Kerberos configuration&quot;);
 532                 }
 533                 sun.security.krb5.Config.refresh();
 534             } catch (KrbException ke) {
 535                 LoginException le = new LoginException(ke.getMessage());
 536                 le.initCause(ke);
 537                 throw le;
 538             }
 539         }
 540         String principalProperty = System.getProperty
 541             (&quot;sun.security.krb5.principal&quot;);
 542         if (principalProperty != null) {
 543             krb5PrincName = new StringBuffer(principalProperty);
 544         } else {
 545             if (princName != null) {
 546                 krb5PrincName = new StringBuffer(princName);
 547             }
 548         }
 549 
 550         validateConfiguration();
 551 
 552         if (krb5PrincName != null &amp;&amp; krb5PrincName.toString().equals(&quot;*&quot;)) {
 553             unboundServer = true;
 554         }
 555 
 556         if (tryFirstPass) {
 557             try {
 558                 attemptAuthentication(true);
 559                 if (debug)
 560                     System.out.println(&quot;\t\t[Krb5LoginModule] &quot; +
 561                                        &quot;authentication succeeded&quot;);
 562                 succeeded = true;
 563                 cleanState();
 564                 return true;
 565             } catch (LoginException le) {
 566                 // authentication failed -- try again below by prompting
 567                 cleanState();
 568                 if (debug) {
 569                     System.out.println(&quot;\t\t[Krb5LoginModule] &quot; +
 570                                        &quot;tryFirstPass failed with:&quot; +
 571                                        le.getMessage());
 572                 }
 573             }
 574         } else if (useFirstPass) {
 575             try {
 576                 attemptAuthentication(true);
 577                 succeeded = true;
 578                 cleanState();
 579                 return true;
 580             } catch (LoginException e) {
 581                 // authentication failed -- clean out state
 582                 if (debug) {
 583                     System.out.println(&quot;\t\t[Krb5LoginModule] &quot; +
 584                                        &quot;authentication failed \n&quot; +
 585                                        e.getMessage());
 586                 }
 587                 succeeded = false;
 588                 cleanState();
 589                 throw e;
 590             }
 591         }
 592 
 593         // attempt the authentication by getting the username and pwd
 594         // by prompting or configuration i.e. not from shared state
 595 
 596         try {
 597             attemptAuthentication(false);
 598             succeeded = true;
 599             cleanState();
 600             return true;
 601         } catch (LoginException e) {
 602             // authentication failed -- clean out state
 603             if (debug) {
 604                 System.out.println(&quot;\t\t[Krb5LoginModule] &quot; +
 605                                    &quot;authentication failed \n&quot; +
 606                                    e.getMessage());
 607             }
 608             succeeded = false;
 609             cleanState();
 610             throw e;
 611         }
 612     }
 613     /**
 614      * process the configuration options
 615      * Get the TGT either out of
 616      * cache or from the KDC using the password entered
 617      * Check the  permission before getting the TGT
 618      */
 619 
 620     private void attemptAuthentication(boolean getPasswdFromSharedState)
 621         throws LoginException {
 622 
 623         /*
 624          * Check the creds cache to see whether
 625          * we have TGT for this client principal
 626          */
 627         if (krb5PrincName != null) {
 628             try {
 629                 principal = new PrincipalName
 630                     (krb5PrincName.toString(),
 631                      PrincipalName.KRB_NT_PRINCIPAL);
 632             } catch (KrbException e) {
 633                 LoginException le = new LoginException(e.getMessage());
 634                 le.initCause(e);
 635                 throw le;
 636             }
 637         }
 638 
 639         try {
 640             if (useTicketCache) {
 641                 // ticketCacheName == null implies the default cache
 642                 if (debug)
 643                     System.out.println(&quot;Acquire TGT from Cache&quot;);
 644                 cred  = Credentials.acquireTGTFromCache
 645                     (principal, ticketCacheName);
 646 
 647                 if (cred != null) {
 648                     if (renewTGT &amp;&amp; isOld(cred)) {
 649                         // renew if ticket is old.
 650                         Credentials newCred = renewCredentials(cred);
 651                         if (newCred != null) {
 652                             newCred.setProxy(cred.getProxy());
 653                             cred = newCred;
 654                         }
 655                     }
 656                     if (!isCurrent(cred)) {
 657                         // credentials have expired
 658                         cred = null;
 659                         if (debug)
 660                             System.out.println(&quot;Credentials are&quot; +
 661                                     &quot; no longer valid&quot;);
 662                     }
 663                 }
 664 
 665                 if (cred != null) {
 666                    // get the principal name from the ticket cache
 667                    if (principal == null) {
 668                         principal = cred.getClient();
 669                    }
 670                 }
 671                 if (debug) {
 672                     System.out.println(&quot;Principal is &quot; + principal);
 673                     if (cred == null) {
 674                         System.out.println
 675                             (&quot;null credentials from Ticket Cache&quot;);
 676                     }
 677                 }
 678             }
 679 
 680             // cred = null indicates that we didn&#39;t get the creds
 681             // from the cache or useTicketCache was false
 682 
 683             if (cred == null) {
 684                 // We need the principal name whether we use keytab
 685                 // or AS Exchange
 686                 if (principal == null) {
 687                     promptForName(getPasswdFromSharedState);
 688                     principal = new PrincipalName
 689                         (krb5PrincName.toString(),
 690                          PrincipalName.KRB_NT_PRINCIPAL);
 691                 }
 692 
 693                 /*
 694                  * Before dynamic KeyTab support (6894072), here we check if
 695                  * the keytab contains keys for the principal. If no, keytab
 696                  * will not be used and password is prompted for.
 697                  *
 698                  * After 6894072, we normally don&#39;t check it, and expect the
 699                  * keys can be populated until a real connection is made. The
 700                  * check is still done when isInitiator == true, where the keys
 701                  * will be used right now.
 702                  *
 703                  * Probably tricky relations:
 704                  *
 705                  * useKeyTab is config flag, but when it&#39;s true but the ktab
 706                  * does not contains keys for principal, we would use password
 707                  * and keep the flag unchanged (for reuse?). In this method,
 708                  * we use (ktab != null) to check whether keytab is used.
 709                  * After this method (and when storeKey == true), we use
 710                  * (encKeys == null) to check.
 711                  */
 712                 if (useKeyTab) {
 713                     if (!unboundServer) {
 714                         KerberosPrincipal kp =
 715                                 new KerberosPrincipal(principal.getName());
 716                         ktab = (keyTabName == null)
 717                                 ? KeyTab.getInstance(kp)
 718                                 : KeyTab.getInstance(kp, new File(keyTabName));
 719                     } else {
 720                         ktab = (keyTabName == null)
 721                                 ? KeyTab.getUnboundInstance()
 722                                 : KeyTab.getUnboundInstance(new File(keyTabName));
 723                     }
 724                     if (isInitiator) {
 725                         if (Krb5Util.keysFromJavaxKeyTab(ktab, principal).length
 726                                 == 0) {
 727                             ktab = null;
 728                             if (debug) {
 729                                 System.out.println
 730                                     (&quot;Key for the principal &quot; +
 731                                      principal  +
 732                                      &quot; not available in &quot; +
 733                                      ((keyTabName == null) ?
 734                                       &quot;default key tab&quot; : keyTabName));
 735                             }
 736                         }
 737                     }
 738                 }
 739 
 740                 KrbAsReqBuilder builder;
 741 
 742                 if (ktab == null) {
 743                     promptForPass(getPasswdFromSharedState);
 744                     builder = new KrbAsReqBuilder(principal, password);
 745                     if (isInitiator) {
 746                         // XXX Even if isInitiator=false, it might be
 747                         // better to do an AS-REQ so that keys can be
 748                         // updated with PA info
 749                         cred = builder.action().getCreds();
 750                     }
 751                     if (storeKey) {
 752                         encKeys = builder.getKeys(isInitiator);
 753                         // When encKeys is empty, the login actually fails.
 754                         // For compatibility, exception is thrown in commit().
 755                     }
 756                 } else {
 757                     builder = new KrbAsReqBuilder(principal, ktab);
 758                     if (isInitiator) {
 759                         cred = builder.action().getCreds();
 760                     }
 761                 }
 762                 builder.destroy();
 763 
 764                 if (debug) {
 765                     System.out.println(&quot;principal is &quot; + principal);
 766                     HexDumpEncoder hd = new HexDumpEncoder();
 767                     if (ktab != null) {
 768                         System.out.println(&quot;Will use keytab&quot;);
 769                     } else if (storeKey) {
 770                         for (int i = 0; i &lt; encKeys.length; i++) {
 771                             System.out.println(&quot;EncryptionKey: keyType=&quot; +
 772                                 encKeys[i].getEType() +
 773                                 &quot; keyBytes (hex dump)=&quot; +
 774                                 hd.encodeBuffer(encKeys[i].getBytes()));
 775                         }
 776                     }
 777                 }
 778 
 779                 // we should hava a non-null cred
 780                 if (isInitiator &amp;&amp; (cred == null)) {
 781                     throw new LoginException
 782                         (&quot;TGT Can not be obtained from the KDC &quot;);
 783                 }
 784 
 785             }
 786         } catch (KrbException e) {
 787             LoginException le = new LoginException(e.getMessage());
 788             le.initCause(e);
 789             throw le;
 790         } catch (IOException ioe) {
 791             LoginException ie = new LoginException(ioe.getMessage());
 792             ie.initCause(ioe);
 793             throw ie;
 794         }
 795     }
 796 
 797     private void promptForName(boolean getPasswdFromSharedState)
 798         throws LoginException {
 799         krb5PrincName = new StringBuffer(&quot;&quot;);
 800         if (getPasswdFromSharedState) {
 801             // use the name saved by the first module in the stack
 802             username = (String)sharedState.get(NAME);
 803             if (debug) {
 804                 System.out.println
 805                     (&quot;username from shared state is &quot; + username + &quot;\n&quot;);
 806             }
 807             if (username == null) {
 808                 System.out.println
 809                     (&quot;username from shared state is null\n&quot;);
 810                 throw new LoginException
 811                     (&quot;Username can not be obtained from sharedstate &quot;);
 812             }
 813             if (debug) {
 814                 System.out.println
 815                     (&quot;username from shared state is &quot; + username + &quot;\n&quot;);
 816             }
 817             if (username != null &amp;&amp; username.length() &gt; 0) {
 818                 krb5PrincName.insert(0, username);
 819                 return;
 820             }
 821         }
 822 
 823         if (doNotPrompt) {
 824             throw new LoginException
 825                 (&quot;Unable to obtain Principal Name for authentication &quot;);
 826         } else {
 827             if (callbackHandler == null)
 828                 throw new LoginException(&quot;No CallbackHandler &quot;
 829                                          + &quot;available &quot;
 830                                          + &quot;to garner authentication &quot;
 831                                          + &quot;information from the user&quot;);
 832             try {
 833                 String defUsername = System.getProperty(&quot;user.name&quot;);
 834 
 835                 Callback[] callbacks = new Callback[1];
 836                 MessageFormat form = new MessageFormat(
 837                                        getAuthResourceString(
 838                                        &quot;Kerberos.username.defUsername.&quot;));
 839                 Object[] source =  {defUsername};
 840                 callbacks[0] = new NameCallback(form.format(source));
 841                 callbackHandler.handle(callbacks);
 842                 username = ((NameCallback)callbacks[0]).getName();
 843                 if (username == null || username.length() == 0)
 844                     username = defUsername;
 845                 krb5PrincName.insert(0, username);
 846 
 847             } catch (java.io.IOException ioe) {
 848                 throw new LoginException(ioe.getMessage());
 849             } catch (UnsupportedCallbackException uce) {
 850                 throw new LoginException
 851                     (uce.getMessage()
 852                      +&quot; not available to garner &quot;
 853                      +&quot; authentication information &quot;
 854                      +&quot; from the user&quot;);
 855             }
 856         }
 857     }
 858 
 859     private void promptForPass(boolean getPasswdFromSharedState)
 860         throws LoginException {
 861 
 862         if (getPasswdFromSharedState) {
 863             // use the password saved by the first module in the stack
 864             password = (char[])sharedState.get(PWD);
 865             if (password == null) {
 866                 if (debug) {
 867                     System.out.println
 868                         (&quot;Password from shared state is null&quot;);
 869                 }
 870                 throw new LoginException
 871                     (&quot;Password can not be obtained from sharedstate &quot;);
 872             }
 873             if (debug) {
 874                 System.out.println
 875                     (&quot;password is &quot; + new String(password));
 876             }
 877             return;
 878         }
 879         if (doNotPrompt) {
 880             throw new LoginException
 881                 (&quot;Unable to obtain password from user\n&quot;);
 882         } else {
 883             if (callbackHandler == null)
 884                 throw new LoginException(&quot;No CallbackHandler &quot;
 885                                          + &quot;available &quot;
 886                                          + &quot;to garner authentication &quot;
 887                                          + &quot;information from the user&quot;);
 888             try {
 889                 Callback[] callbacks = new Callback[1];
 890                 String userName = krb5PrincName.toString();
 891                 MessageFormat form = new MessageFormat(
 892                                          getAuthResourceString(
 893                                          &quot;Kerberos.password.for.username.&quot;));
 894                 Object[] source = {userName};
 895                 callbacks[0] = new PasswordCallback(
 896                                                     form.format(source),
 897                                                     false);
 898                 callbackHandler.handle(callbacks);
 899                 char[] tmpPassword = ((PasswordCallback)
 900                                       callbacks[0]).getPassword();
 901                 if (tmpPassword == null) {
 902                     throw new LoginException(&quot;No password provided&quot;);
 903                 }
 904                 password = new char[tmpPassword.length];
 905                 System.arraycopy(tmpPassword, 0,
 906                                  password, 0, tmpPassword.length);
 907                 ((PasswordCallback)callbacks[0]).clearPassword();
 908 
 909 
 910                 // clear tmpPassword
 911                 for (int i = 0; i &lt; tmpPassword.length; i++)
 912                     tmpPassword[i] = &#39; &#39;;
 913                 tmpPassword = null;
 914                 if (debug) {
 915                     System.out.println(&quot;\t\t[Krb5LoginModule] &quot; +
 916                                        &quot;user entered username: &quot; +
 917                                        krb5PrincName);
 918                     System.out.println();
 919                 }
 920             } catch (java.io.IOException ioe) {
 921                 throw new LoginException(ioe.getMessage());
 922             } catch (UnsupportedCallbackException uce) {
 923                 throw new LoginException(uce.getMessage()
 924                                          +&quot; not available to garner &quot;
 925                                          +&quot; authentication information &quot;
 926                                          + &quot;from the user&quot;);
 927             }
 928         }
 929     }
 930 
 931     private void validateConfiguration() throws LoginException {
 932         if (doNotPrompt &amp;&amp; !useTicketCache &amp;&amp; !useKeyTab
 933                 &amp;&amp; !tryFirstPass &amp;&amp; !useFirstPass)
 934             throw new LoginException
 935                 (&quot;Configuration Error&quot;
 936                  + &quot; - either doNotPrompt should be &quot;
 937                  + &quot; false or at least one of useTicketCache, &quot;
 938                  + &quot; useKeyTab, tryFirstPass and useFirstPass&quot;
 939                  + &quot; should be true&quot;);
 940         if (ticketCacheName != null &amp;&amp; !useTicketCache)
 941             throw new LoginException
 942                 (&quot;Configuration Error &quot;
 943                  + &quot; - useTicketCache should be set &quot;
 944                  + &quot;to true to use the ticket cache&quot;
 945                  + ticketCacheName);
 946         if (keyTabName != null &amp; !useKeyTab)
 947             throw new LoginException
 948                 (&quot;Configuration Error - useKeyTab should be set to true &quot;
 949                  + &quot;to use the keytab&quot; + keyTabName);
 950         if (storeKey &amp;&amp; doNotPrompt &amp;&amp; !useKeyTab
 951                 &amp;&amp; !tryFirstPass &amp;&amp; !useFirstPass)
 952             throw new LoginException
 953                 (&quot;Configuration Error - either doNotPrompt should be set to &quot;
 954                  + &quot; false or at least one of tryFirstPass, useFirstPass &quot;
 955                  + &quot;or useKeyTab must be set to true for storeKey option&quot;);
 956         if (renewTGT &amp;&amp; !useTicketCache)
 957             throw new LoginException
 958                 (&quot;Configuration Error&quot;
 959                  + &quot; - either useTicketCache should be &quot;
 960                  + &quot; true or renewTGT should be false&quot;);
 961         if (krb5PrincName != null &amp;&amp; krb5PrincName.toString().equals(&quot;*&quot;)) {
 962             if (isInitiator) {
 963                 throw new LoginException
 964                     (&quot;Configuration Error&quot;
 965                     + &quot; - principal cannot be * when isInitiator is true&quot;);
 966             }
 967         }
 968     }
 969 
 970     private static boolean isCurrent(Credentials creds)
 971     {
 972         Date endTime = creds.getEndTime();
 973         if (endTime != null) {
 974             return (System.currentTimeMillis() &lt;= endTime.getTime());
 975         }
 976         return true;
 977     }
 978 
 979     private static boolean isOld(Credentials creds)
 980     {
 981         Date endTime = creds.getEndTime();
 982         if (endTime != null) {
 983             Date authTime = creds.getAuthTime();
 984             long now = System.currentTimeMillis();
 985             if (authTime != null) {
 986                 // pass the mid between auth and end
 987                 return now - authTime.getTime() &gt; endTime.getTime() - now;
 988             } else {
 989                 // will expire in less than 2 hours
 990                 return now &lt;= endTime.getTime() - 1000*3600*2L;
 991             }
 992         }
 993         return false;
 994     }
 995 
 996     private Credentials renewCredentials(Credentials creds)
 997     {
 998         Credentials lcreds;
 999         try {
1000             if (!creds.isRenewable())
1001                 throw new RefreshFailedException(&quot;This ticket&quot; +
1002                                 &quot; is not renewable&quot;);
1003             if (creds.getRenewTill() == null) {
1004                 // Renewable ticket without renew-till. Illegal and ignored.
1005                 return creds;
1006             }
1007             if (System.currentTimeMillis() &gt; cred.getRenewTill().getTime())
1008                 throw new RefreshFailedException(&quot;This ticket is past &quot;
1009                                              + &quot;its last renewal time.&quot;);
1010             lcreds = creds.renew();
1011             if (debug)
1012                 System.out.println(&quot;Renewed Kerberos Ticket&quot;);
1013         } catch (Exception e) {
1014             lcreds = null;
1015             if (debug)
1016                 System.out.println(&quot;Ticket could not be renewed : &quot;
1017                                 + e.getMessage());
1018         }
1019         return lcreds;
1020     }
1021 
1022     /**
1023      * This method is called if the LoginContext&#39;s
1024      * overall authentication succeeded
1025      * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL
1026      * LoginModules succeeded).
1027      *
1028      * &lt;p&gt; If this LoginModule&#39;s own authentication attempt
1029      * succeeded (checked by retrieving the private state saved by the
1030      * {@code login} method), then this method associates a
1031      * {@code Krb5Principal}
1032      * with the {@code Subject} located in the
1033      * {@code LoginModule}. It adds Kerberos Credentials to the
1034      *  the Subject&#39;s private credentials set. If this LoginModule&#39;s own
1035      * authentication attempted failed, then this method removes
1036      * any state that was originally saved.
1037      *
1038      * @exception LoginException if the commit fails.
1039      *
1040      * @return true if this LoginModule&#39;s own login and commit
1041      *          attempts succeeded, or false otherwise.
1042      */
1043 
1044     public boolean commit() throws LoginException {
1045 
1046         /*
1047          * Let us add the Krb5 Creds to the Subject&#39;s
1048          * private credentials. The credentials are of type
1049          * KerberosKey or KerberosTicket
1050          */
1051         if (succeeded == false) {
1052             return false;
1053         } else {
1054 
1055             if (isInitiator &amp;&amp; (cred == null)) {
1056                 succeeded = false;
1057                 throw new LoginException(&quot;Null Client Credential&quot;);
1058             }
1059 
1060             if (subject.isReadOnly()) {
1061                 cleanKerberosCred();
1062                 throw new LoginException(&quot;Subject is Readonly&quot;);
1063             }
1064 
1065             /*
1066              * Add the Principal (authenticated identity)
1067              * to the Subject&#39;s principal set and
1068              * add the credentials (TGT or Service key) to the
1069              * Subject&#39;s private credentials
1070              */
1071 
1072             Set&lt;Object&gt; privCredSet =  subject.getPrivateCredentials();
1073             Set&lt;java.security.Principal&gt; princSet  = subject.getPrincipals();
1074             kerbClientPrinc = new KerberosPrincipal(principal.getName());
1075 
1076             // create Kerberos Ticket
1077             if (isInitiator) {
1078                 kerbTicket = Krb5Util.credsToTicket(cred);
1079                 if (cred.getProxy() != null) {
1080                     KerberosSecrets.getJavaxSecurityAuthKerberosAccess()
1081                             .kerberosTicketSetProxy(kerbTicket,Krb5Util.credsToTicket(cred.getProxy()));
1082                 }
1083             }
1084 
1085             if (storeKey &amp;&amp; encKeys != null) {
1086                 if (encKeys.length == 0) {
1087                     succeeded = false;
1088                     throw new LoginException(&quot;Null Server Key &quot;);
1089                 }
1090 
1091                 kerbKeys = new KerberosKey[encKeys.length];
1092                 for (int i = 0; i &lt; encKeys.length; i ++) {
1093                     Integer temp = encKeys[i].getKeyVersionNumber();
1094                     kerbKeys[i] = new KerberosKey(kerbClientPrinc,
1095                                           encKeys[i].getBytes(),
1096                                           encKeys[i].getEType(),
1097                                           (temp == null?
1098                                           0: temp.intValue()));
1099                 }
1100 
1101             }
1102             // Let us add the kerbClientPrinc,kerbTicket and KeyTab/KerbKey (if
1103             // storeKey is true)
1104 
1105             // We won&#39;t add &quot;*&quot; as a KerberosPrincipal
1106             if (!unboundServer &amp;&amp;
1107                     !princSet.contains(kerbClientPrinc)) {
1108                 princSet.add(kerbClientPrinc);
1109             }
1110 
1111             // add the TGT
1112             if (kerbTicket != null) {
1113                 if (!privCredSet.contains(kerbTicket))
1114                     privCredSet.add(kerbTicket);
1115             }
1116 
1117             if (storeKey) {
1118                 if (encKeys == null) {
1119                     if (ktab != null) {
1120                         if (!privCredSet.contains(ktab)) {
1121                             privCredSet.add(ktab);
1122                         }
1123                     } else {
1124                         succeeded = false;
1125                         throw new LoginException(&quot;No key to store&quot;);
1126                     }
1127                 } else {
1128                     for (int i = 0; i &lt; kerbKeys.length; i ++) {
1129                         if (!privCredSet.contains(kerbKeys[i])) {
1130                             privCredSet.add(kerbKeys[i]);
1131                         }
1132                         encKeys[i].destroy();
1133                         encKeys[i] = null;
1134                         if (debug) {
1135                             System.out.println(&quot;Added server&#39;s key&quot;
1136                                             + kerbKeys[i]);
1137                             System.out.println(&quot;\t\t[Krb5LoginModule] &quot; +
1138                                            &quot;added Krb5Principal  &quot; +
1139                                            kerbClientPrinc.toString()
1140                                            + &quot; to Subject&quot;);
1141                         }
1142                     }
1143                 }
1144             }
1145         }
1146         commitSucceeded = true;
1147         if (debug)
1148             System.out.println(&quot;Commit Succeeded \n&quot;);
1149         return true;
1150     }
1151 
1152     /**
1153      * This method is called if the LoginContext&#39;s
1154      * overall authentication failed.
1155      * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL
1156      * LoginModules did not succeed).
1157      *
1158      * &lt;p&gt; If this LoginModule&#39;s own authentication attempt
1159      * succeeded (checked by retrieving the private state saved by the
1160      * {@code login} and {@code commit} methods),
1161      * then this method cleans up any state that was originally saved.
1162      *
1163      * @exception LoginException if the abort fails.
1164      *
1165      * @return false if this LoginModule&#39;s own login and/or commit attempts
1166      *          failed, and true otherwise.
1167      */
1168 
1169     public boolean abort() throws LoginException {
1170         if (succeeded == false) {
1171             return false;
1172         } else if (succeeded == true &amp;&amp; commitSucceeded == false) {
1173             // login succeeded but overall authentication failed
1174             succeeded = false;
1175             cleanKerberosCred();
1176         } else {
1177             // overall authentication succeeded and commit succeeded,
1178             // but someone else&#39;s commit failed
1179             logout();
1180         }
1181         return true;
1182     }
1183 
1184     /**
1185      * Logout the user.
1186      *
1187      * &lt;p&gt; This method removes the {@code Krb5Principal}
1188      * that was added by the {@code commit} method.
1189      *
1190      * @exception LoginException if the logout fails.
1191      *
1192      * @return true in all cases since this {@code LoginModule}
1193      *          should not be ignored.
1194      */
1195     public boolean logout() throws LoginException {
1196 
1197         if (debug) {
1198             System.out.println(&quot;\t\t[Krb5LoginModule]: &quot; +
1199                 &quot;Entering logout&quot;);
1200         }
1201 
1202         if (subject.isReadOnly()) {
1203             cleanKerberosCred();
1204             throw new LoginException(&quot;Subject is Readonly&quot;);
1205         }
1206 
1207         subject.getPrincipals().remove(kerbClientPrinc);
1208            // Let us remove all Kerberos credentials stored in the Subject
1209         Iterator&lt;Object&gt; it = subject.getPrivateCredentials().iterator();
1210         while (it.hasNext()) {
1211             Object o = it.next();
1212             if (o instanceof KerberosTicket ||
1213                     o instanceof KerberosKey ||
1214                     o instanceof KeyTab) {
1215                 it.remove();
1216             }
1217         }
1218         // clean the kerberos ticket and keys
1219         cleanKerberosCred();
1220 
1221         succeeded = false;
1222         commitSucceeded = false;
1223         if (debug) {
1224             System.out.println(&quot;\t\t[Krb5LoginModule]: &quot; +
1225                                &quot;logged out Subject&quot;);
1226         }
1227         return true;
1228     }
1229 
1230     /**
1231      * Clean Kerberos credentials
1232      */
1233     private void cleanKerberosCred() throws LoginException {
1234         // Clean the ticket and server key
1235         try {
1236             if (kerbTicket != null)
1237                 kerbTicket.destroy();
1238             if (kerbKeys != null) {
1239                 for (int i = 0; i &lt; kerbKeys.length; i++) {
1240                     kerbKeys[i].destroy();
1241                 }
1242             }
1243         } catch (DestroyFailedException e) {
1244             throw new LoginException
1245                 (&quot;Destroy Failed on Kerberos Private Credentials&quot;);
1246         }
1247         kerbTicket = null;
1248         kerbKeys = null;
1249         kerbClientPrinc = null;
1250     }
1251 
1252     /**
1253      * Clean out the state
1254      */
1255     private void cleanState() {
1256 
1257         // save input as shared state only if
1258         // authentication succeeded
1259         if (succeeded) {
1260             if (storePass &amp;&amp;
1261                 !sharedState.containsKey(NAME) &amp;&amp;
1262                 !sharedState.containsKey(PWD)) {
1263                 sharedState.put(NAME, username);
1264                 sharedState.put(PWD, password);
1265             }
1266         } else {
1267             // remove temp results for the next try
1268             encKeys = null;
1269             ktab = null;
1270             principal = null;
1271         }
1272         username = null;
1273         password = null;
1274         if (krb5PrincName != null &amp;&amp; krb5PrincName.length() != 0)
1275             krb5PrincName.delete(0, krb5PrincName.length());
1276         krb5PrincName = null;
1277         if (clearPass) {
1278             sharedState.remove(NAME);
1279             sharedState.remove(PWD);
1280         }
1281     }
1282 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>