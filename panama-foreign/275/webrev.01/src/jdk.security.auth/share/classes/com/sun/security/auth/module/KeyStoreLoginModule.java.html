<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.security.auth/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.auth.module;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.net.MalformedURLException;
 32 import java.net.URL;
 33 import java.security.*;
 34 import java.security.cert.*;
 35 import java.security.cert.Certificate;
 36 import java.security.cert.X509Certificate;
 37 import java.util.*;
 38 import javax.security.auth.Destroyable;
 39 import javax.security.auth.DestroyFailedException;
 40 import javax.security.auth.Subject;
 41 import javax.security.auth.x500.*;
 42 import javax.security.auth.callback.Callback;
 43 import javax.security.auth.callback.CallbackHandler;
 44 import javax.security.auth.callback.ConfirmationCallback;
 45 import javax.security.auth.callback.NameCallback;
 46 import javax.security.auth.callback.PasswordCallback;
 47 import javax.security.auth.callback.TextOutputCallback;
 48 import javax.security.auth.callback.UnsupportedCallbackException;
 49 import javax.security.auth.login.FailedLoginException;
 50 import javax.security.auth.login.LoginException;
 51 import javax.security.auth.spi.LoginModule;
 52 
 53 import sun.security.util.Password;
 54 import static sun.security.util.ResourcesMgr.getAuthResourceString;
 55 
 56 /**
 57  * Provides a JAAS login module that prompts for a key store alias and
 58  * populates the subject with the alias&#39;s principal and credentials. Stores
 59  * an {@code X500Principal} for the subject distinguished name of the
 60  * first certificate in the alias&#39;s credentials in the subject&#39;s principals,
 61  * the alias&#39;s certificate path in the subject&#39;s public credentials, and a
 62  * {@code X500PrivateCredential} whose certificate is the first
 63  * certificate in the alias&#39;s certificate path and whose private key is the
 64  * alias&#39;s private key in the subject&#39;s private credentials. &lt;p&gt;
 65  *
 66  * Recognizes the following options in the configuration file:
 67  * &lt;dl&gt;
 68  *
 69  * &lt;dt&gt; {@code keyStoreURL} &lt;/dt&gt;
 70  * &lt;dd&gt; A URL that specifies the location of the key store.  Defaults to
 71  *      a URL pointing to the .keystore file in the directory specified by the
 72  *      {@code user.home} system property.  The input stream from this
 73  *      URL is passed to the {@code KeyStore.load} method.
 74  *      &quot;NONE&quot; may be specified if a {@code null} stream must be
 75  *      passed to the {@code KeyStore.load} method.
 76  *      &quot;NONE&quot; should be specified if the KeyStore resides
 77  *      on a hardware token device, for example.&lt;/dd&gt;
 78  *
 79  * &lt;dt&gt; {@code keyStoreType} &lt;/dt&gt;
 80  * &lt;dd&gt; The key store type.  If not specified, defaults to the result of
 81  *      calling {@code KeyStore.getDefaultType()}.
 82  *      If the type is &quot;PKCS11&quot;, then keyStoreURL must be &quot;NONE&quot;
 83  *      and privateKeyPasswordURL must not be specified.&lt;/dd&gt;
 84  *
 85  * &lt;dt&gt; {@code keyStoreProvider} &lt;/dt&gt;
 86  * &lt;dd&gt; The key store provider.  If not specified, uses the standard search
 87  *      order to find the provider. &lt;/dd&gt;
 88  *
 89  * &lt;dt&gt; {@code keyStoreAlias} &lt;/dt&gt;
 90  * &lt;dd&gt; The alias in the key store to login as.  Required when no callback
 91  *      handler is provided.  No default value. &lt;/dd&gt;
 92  *
 93  * &lt;dt&gt; {@code keyStorePasswordURL} &lt;/dt&gt;
 94  * &lt;dd&gt; A URL that specifies the location of the key store password.  Required
 95  *      when no callback handler is provided and
 96  *      {@code protected} is false.
 97  *      No default value. &lt;/dd&gt;
 98  *
 99  * &lt;dt&gt; {@code privateKeyPasswordURL} &lt;/dt&gt;
100  * &lt;dd&gt; A URL that specifies the location of the specific private key password
101  *      needed to access the private key for this alias.
102  *      The keystore password
103  *      is used if this value is needed and not specified. &lt;/dd&gt;
104  *
105  * &lt;dt&gt; {@code protected} &lt;/dt&gt;
106  * &lt;dd&gt; This value should be set to &quot;true&quot; if the KeyStore
107  *      has a separate, protected authentication path
108  *      (for example, a dedicated PIN-pad attached to a smart card).
109  *      Defaults to &quot;false&quot;. If &quot;true&quot; keyStorePasswordURL and
110  *      privateKeyPasswordURL must not be specified.&lt;/dd&gt;
111  *
112  * &lt;/dl&gt;
113  */
114 public class KeyStoreLoginModule implements LoginModule {
115 
116     /* -- Fields -- */
117 
118     private static final int UNINITIALIZED = 0;
119     private static final int INITIALIZED = 1;
120     private static final int AUTHENTICATED = 2;
121     private static final int LOGGED_IN = 3;
122 
123     private static final int PROTECTED_PATH = 0;
124     private static final int TOKEN = 1;
125     private static final int NORMAL = 2;
126 
127     private static final String NONE = &quot;NONE&quot;;
128     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
129 
130     private static final TextOutputCallback bannerCallback =
131                 new TextOutputCallback
132                         (TextOutputCallback.INFORMATION,
133                         getAuthResourceString(&quot;Please.enter.keystore.information&quot;));
134     private final ConfirmationCallback confirmationCallback =
135                 new ConfirmationCallback
136                         (ConfirmationCallback.INFORMATION,
137                         ConfirmationCallback.OK_CANCEL_OPTION,
138                         ConfirmationCallback.OK);
139 
140     private Subject subject;
141     private CallbackHandler callbackHandler;
142     private Map&lt;String, Object&gt; sharedState;
143     private Map&lt;String, ?&gt; options;
144 
145     private char[] keyStorePassword;
146     private char[] privateKeyPassword;
147     private KeyStore keyStore;
148 
149     private String keyStoreURL;
150     private String keyStoreType;
151     private String keyStoreProvider;
152     private String keyStoreAlias;
153     private String keyStorePasswordURL;
154     private String privateKeyPasswordURL;
155     private boolean debug;
156     private javax.security.auth.x500.X500Principal principal;
157     private Certificate[] fromKeyStore;
158     private java.security.cert.CertPath certP = null;
159     private X500PrivateCredential privateCredential;
160     private int status = UNINITIALIZED;
161     private boolean nullStream = false;
162     private boolean token = false;
163     private boolean protectedPath = false;
164 
165     /**
166      * Creates a {@code KeyStoreLoginModule}.
167      */
168     public KeyStoreLoginModule() {}
169 
170     /* -- Methods -- */
171 
172     /**
173      * Initialize this {@code LoginModule}.
174      *
175      * @param subject the {@code Subject} to be authenticated.
176      *
177      * @param callbackHandler a {@code CallbackHandler} for communicating
178      *                  with the end user (prompting for usernames and
179      *                  passwords, for example),
180      *                  which may be {@code null}.
181      *
182      * @param sharedState shared {@code LoginModule} state.
183      *
184      * @param options options specified in the login
185      *                  {@code Configuration} for this particular
186      *                  {@code LoginModule}.
187      */
188     // Unchecked warning from (Map&lt;String, Object&gt;)sharedState is safe
189     // since javax.security.auth.login.LoginContext passes a raw HashMap.
190     @SuppressWarnings(&quot;unchecked&quot;)
191     public void initialize(Subject subject,
192                            CallbackHandler callbackHandler,
193                            Map&lt;String,?&gt; sharedState,
194                            Map&lt;String,?&gt; options)
195     {
196         this.subject = subject;
197         this.callbackHandler = callbackHandler;
198         this.sharedState = (Map&lt;String, Object&gt;)sharedState;
199         this.options = options;
200 
201         processOptions();
202         status = INITIALIZED;
203     }
204 
205     private void processOptions() {
206         keyStoreURL = (String) options.get(&quot;keyStoreURL&quot;);
207         if (keyStoreURL == null) {
208             keyStoreURL =
209                 &quot;file:&quot; +
210                 System.getProperty(&quot;user.home&quot;).replace(
211                     File.separatorChar, &#39;/&#39;) +
212                 &#39;/&#39; + &quot;.keystore&quot;;
213         } else if (NONE.equals(keyStoreURL)) {
214             nullStream = true;
215         }
216         keyStoreType = (String) options.get(&quot;keyStoreType&quot;);
217         if (keyStoreType == null) {
218             keyStoreType = KeyStore.getDefaultType();
219         }
220         if (P11KEYSTORE.equalsIgnoreCase(keyStoreType)) {
221             token = true;
222         }
223 
224         keyStoreProvider = (String) options.get(&quot;keyStoreProvider&quot;);
225 
226         keyStoreAlias = (String) options.get(&quot;keyStoreAlias&quot;);
227 
228         keyStorePasswordURL = (String) options.get(&quot;keyStorePasswordURL&quot;);
229 
230         privateKeyPasswordURL = (String) options.get(&quot;privateKeyPasswordURL&quot;);
231 
232         protectedPath = &quot;true&quot;.equalsIgnoreCase((String)options.get
233                                         (&quot;protected&quot;));
234 
235         debug = &quot;true&quot;.equalsIgnoreCase((String) options.get(&quot;debug&quot;));
236         if (debug) {
237             debugPrint(null);
238             debugPrint(&quot;keyStoreURL=&quot; + keyStoreURL);
239             debugPrint(&quot;keyStoreType=&quot; + keyStoreType);
240             debugPrint(&quot;keyStoreProvider=&quot; + keyStoreProvider);
241             debugPrint(&quot;keyStoreAlias=&quot; + keyStoreAlias);
242             debugPrint(&quot;keyStorePasswordURL=&quot; + keyStorePasswordURL);
243             debugPrint(&quot;privateKeyPasswordURL=&quot; + privateKeyPasswordURL);
244             debugPrint(&quot;protectedPath=&quot; + protectedPath);
245             debugPrint(null);
246         }
247     }
248 
249     /**
250      * Authenticate the user.
251      *
252      * &lt;p&gt; Get the Keystore alias and relevant passwords.
253      * Retrieve the alias&#39;s principal and credentials from the Keystore.
254      *
255      * @exception FailedLoginException if the authentication fails.
256      *
257      * @return true in all cases (this {@code LoginModule}
258      *          should not be ignored).
259      */
260 
261     public boolean login() throws LoginException {
262         switch (status) {
263         case UNINITIALIZED:
264         default:
265             throw new LoginException(&quot;The login module is not initialized&quot;);
266         case INITIALIZED:
267         case AUTHENTICATED:
268 
269             if (token &amp;&amp; !nullStream) {
270                 throw new LoginException
271                         (&quot;if keyStoreType is &quot; + P11KEYSTORE +
272                         &quot; then keyStoreURL must be &quot; + NONE);
273             }
274 
275             if (token &amp;&amp; privateKeyPasswordURL != null) {
276                 throw new LoginException
277                         (&quot;if keyStoreType is &quot; + P11KEYSTORE +
278                         &quot; then privateKeyPasswordURL must not be specified&quot;);
279             }
280 
281             if (protectedPath &amp;&amp;
282                 (keyStorePasswordURL != null ||
283                         privateKeyPasswordURL != null)) {
284                 throw new LoginException
285                         (&quot;if protected is true then keyStorePasswordURL and &quot; +
286                         &quot;privateKeyPasswordURL must not be specified&quot;);
287             }
288 
289             // get relevant alias and password info
290 
291             if (protectedPath) {
292                 getAliasAndPasswords(PROTECTED_PATH);
293             } else if (token) {
294                 getAliasAndPasswords(TOKEN);
295             } else {
296                 getAliasAndPasswords(NORMAL);
297             }
298 
299             // log into KeyStore to retrieve data,
300             // then clear passwords
301 
302             try {
303                 getKeyStoreInfo();
304             } finally {
305                 if (privateKeyPassword != null &amp;&amp;
306                     privateKeyPassword != keyStorePassword) {
307                     Arrays.fill(privateKeyPassword, &#39;\0&#39;);
308                     privateKeyPassword = null;
309                 }
310                 if (keyStorePassword != null) {
311                     Arrays.fill(keyStorePassword, &#39;\0&#39;);
312                     keyStorePassword = null;
313                 }
314             }
315             status = AUTHENTICATED;
316             return true;
317         case LOGGED_IN:
318             return true;
319         }
320     }
321 
322     /** Get the alias and passwords to use for looking up in the KeyStore. */
323     @SuppressWarnings(&quot;fallthrough&quot;)
324     private void getAliasAndPasswords(int env) throws LoginException {
325         if (callbackHandler == null) {
326 
327             // No callback handler - check for alias and password options
328 
329             switch (env) {
330             case PROTECTED_PATH:
331                 checkAlias();
332                 break;
333             case TOKEN:
334                 checkAlias();
335                 checkStorePass();
336                 break;
337             case NORMAL:
338                 checkAlias();
339                 checkStorePass();
340                 checkKeyPass();
341                 break;
342             }
343 
344         } else {
345 
346             // Callback handler available - prompt for alias and passwords
347 
348             NameCallback aliasCallback;
349             if (keyStoreAlias == null || keyStoreAlias.length() == 0) {
350                 aliasCallback = new NameCallback(getAuthResourceString(&quot;Keystore.alias.&quot;));
351             } else {
352                 aliasCallback =
353                     new NameCallback(getAuthResourceString(&quot;Keystore.alias.&quot;),
354                                      keyStoreAlias);
355             }
356 
357             PasswordCallback storePassCallback = null;
358             PasswordCallback keyPassCallback = null;
359 
360             switch (env) {
361             case PROTECTED_PATH:
362                 break;
363             case NORMAL:
364                 keyPassCallback = new PasswordCallback
365                     (getAuthResourceString(&quot;Private.key.password.optional.&quot;), false);
366                 // fall thru
367             case TOKEN:
368                 storePassCallback = new PasswordCallback
369                     (getAuthResourceString(&quot;Keystore.password.&quot;), false);
370                 break;
371             }
372             prompt(aliasCallback, storePassCallback, keyPassCallback);
373         }
374 
375         if (debug) {
376             debugPrint(&quot;alias=&quot; + keyStoreAlias);
377         }
378     }
379 
380     private void checkAlias() throws LoginException {
381         if (keyStoreAlias == null) {
382             throw new LoginException
383                 (&quot;Need to specify an alias option to use &quot; +
384                 &quot;KeyStoreLoginModule non-interactively.&quot;);
385         }
386     }
387 
388     private void checkStorePass() throws LoginException {
389         if (keyStorePasswordURL == null) {
390             throw new LoginException
391                 (&quot;Need to specify keyStorePasswordURL option to use &quot; +
392                 &quot;KeyStoreLoginModule non-interactively.&quot;);
393         }
394         InputStream in = null;
395         try {
396             in = new URL(keyStorePasswordURL).openStream();
397             keyStorePassword = Password.readPassword(in);
398         } catch (IOException e) {
399             LoginException le = new LoginException
400                 (&quot;Problem accessing keystore password \&quot;&quot; +
401                 keyStorePasswordURL + &quot;\&quot;&quot;);
402             le.initCause(e);
403             throw le;
404         } finally {
405             if (in != null) {
406                 try {
407                     in.close();
408                 } catch (IOException ioe) {
409                     LoginException le = new LoginException(
410                         &quot;Problem closing the keystore password stream&quot;);
411                     le.initCause(ioe);
412                     throw le;
413                 }
414             }
415         }
416     }
417 
418     private void checkKeyPass() throws LoginException {
419         if (privateKeyPasswordURL == null) {
420             privateKeyPassword = keyStorePassword;
421         } else {
422             InputStream in = null;
423             try {
424                 in = new URL(privateKeyPasswordURL).openStream();
425                 privateKeyPassword = Password.readPassword(in);
426             } catch (IOException e) {
427                 LoginException le = new LoginException
428                         (&quot;Problem accessing private key password \&quot;&quot; +
429                         privateKeyPasswordURL + &quot;\&quot;&quot;);
430                 le.initCause(e);
431                 throw le;
432             } finally {
433                 if (in != null) {
434                     try {
435                         in.close();
436                     } catch (IOException ioe) {
437                         LoginException le = new LoginException(
438                             &quot;Problem closing the private key password stream&quot;);
439                         le.initCause(ioe);
440                         throw le;
441                     }
442                 }
443             }
444         }
445     }
446 
447     private void prompt(NameCallback aliasCallback,
448                         PasswordCallback storePassCallback,
449                         PasswordCallback keyPassCallback)
450                 throws LoginException {
451 
452         if (storePassCallback == null) {
453 
454             // only prompt for alias
455 
456             try {
457                 callbackHandler.handle(
458                     new Callback[] {
459                         bannerCallback, aliasCallback, confirmationCallback
460                     });
461             } catch (IOException e) {
462                 LoginException le = new LoginException
463                         (&quot;Problem retrieving keystore alias&quot;);
464                 le.initCause(e);
465                 throw le;
466             } catch (UnsupportedCallbackException e) {
467                 throw new LoginException(
468                     &quot;Error: &quot; + e.getCallback().toString() +
469                     &quot; is not available to retrieve authentication &quot; +
470                     &quot; information from the user&quot;);
471             }
472 
473             int confirmationResult = confirmationCallback.getSelectedIndex();
474 
475             if (confirmationResult == ConfirmationCallback.CANCEL) {
476                 throw new LoginException(&quot;Login cancelled&quot;);
477             }
478 
479             saveAlias(aliasCallback);
480 
481         } else if (keyPassCallback == null) {
482 
483             // prompt for alias and key store password
484 
485             try {
486                 callbackHandler.handle(
487                     new Callback[] {
488                         bannerCallback, aliasCallback,
489                         storePassCallback, confirmationCallback
490                     });
491             } catch (IOException e) {
492                 LoginException le = new LoginException
493                         (&quot;Problem retrieving keystore alias and password&quot;);
494                 le.initCause(e);
495                 throw le;
496             } catch (UnsupportedCallbackException e) {
497                 throw new LoginException(
498                     &quot;Error: &quot; + e.getCallback().toString() +
499                     &quot; is not available to retrieve authentication &quot; +
500                     &quot; information from the user&quot;);
501             }
502 
503             int confirmationResult = confirmationCallback.getSelectedIndex();
504 
505             if (confirmationResult == ConfirmationCallback.CANCEL) {
506                 throw new LoginException(&quot;Login cancelled&quot;);
507             }
508 
509             saveAlias(aliasCallback);
510             saveStorePass(storePassCallback);
511 
512         } else {
513 
514             // prompt for alias, key store password, and key password
515 
516             try {
517                 callbackHandler.handle(
518                     new Callback[] {
519                         bannerCallback, aliasCallback,
520                         storePassCallback, keyPassCallback,
521                         confirmationCallback
522                     });
523             } catch (IOException e) {
524                 LoginException le = new LoginException
525                         (&quot;Problem retrieving keystore alias and passwords&quot;);
526                 le.initCause(e);
527                 throw le;
528             } catch (UnsupportedCallbackException e) {
529                 throw new LoginException(
530                     &quot;Error: &quot; + e.getCallback().toString() +
531                     &quot; is not available to retrieve authentication &quot; +
532                     &quot; information from the user&quot;);
533             }
534 
535             int confirmationResult = confirmationCallback.getSelectedIndex();
536 
537             if (confirmationResult == ConfirmationCallback.CANCEL) {
538                 throw new LoginException(&quot;Login cancelled&quot;);
539             }
540 
541             saveAlias(aliasCallback);
542             saveStorePass(storePassCallback);
543             saveKeyPass(keyPassCallback);
544         }
545     }
546 
547     private void saveAlias(NameCallback cb) {
548         keyStoreAlias = cb.getName();
549     }
550 
551     private void saveStorePass(PasswordCallback c) {
552         keyStorePassword = c.getPassword();
553         if (keyStorePassword == null) {
554             /* Treat a NULL password as an empty password */
555             keyStorePassword = new char[0];
556         }
557         c.clearPassword();
558     }
559 
560     private void saveKeyPass(PasswordCallback c) {
561         privateKeyPassword = c.getPassword();
562         if (privateKeyPassword == null || privateKeyPassword.length == 0) {
563             /*
564              * Use keystore password if no private key password is
565              * specified.
566              */
567             privateKeyPassword = keyStorePassword;
568         }
569         c.clearPassword();
570     }
571 
572     /** Get the credentials from the KeyStore. */
573     private void getKeyStoreInfo() throws LoginException {
574 
575         /* Get KeyStore instance */
576         try {
577             if (keyStoreProvider == null) {
578                 keyStore = KeyStore.getInstance(keyStoreType);
579             } else {
580                 keyStore =
581                     KeyStore.getInstance(keyStoreType, keyStoreProvider);
582             }
583         } catch (KeyStoreException e) {
584             LoginException le = new LoginException
585                 (&quot;The specified keystore type was not available&quot;);
586             le.initCause(e);
587             throw le;
588         } catch (NoSuchProviderException e) {
589             LoginException le = new LoginException
590                 (&quot;The specified keystore provider was not available&quot;);
591             le.initCause(e);
592             throw le;
593         }
594 
595         /* Load KeyStore contents from file */
596         InputStream in = null;
597         try {
598             if (nullStream) {
599                 // if using protected auth path, keyStorePassword will be null
600                 keyStore.load(null, keyStorePassword);
601             } else {
602                 in = new URL(keyStoreURL).openStream();
603                 keyStore.load(in, keyStorePassword);
604             }
605         } catch (MalformedURLException e) {
606             LoginException le = new LoginException
607                                 (&quot;Incorrect keyStoreURL option&quot;);
608             le.initCause(e);
609             throw le;
610         } catch (GeneralSecurityException e) {
611             LoginException le = new LoginException
612                                 (&quot;Error initializing keystore&quot;);
613             le.initCause(e);
614             throw le;
615         } catch (IOException e) {
616             LoginException le = new LoginException
617                                 (&quot;Error initializing keystore&quot;);
618             le.initCause(e);
619             throw le;
620         } finally {
621             if (in != null) {
622                 try {
623                     in.close();
624                 } catch (IOException ioe) {
625                     LoginException le = new LoginException
626                                 (&quot;Error initializing keystore&quot;);
627                     le.initCause(ioe);
628                     throw le;
629                 }
630             }
631         }
632 
633         /* Get certificate chain and create a certificate path */
634         try {
635             fromKeyStore =
636                 keyStore.getCertificateChain(keyStoreAlias);
637             if (fromKeyStore == null
638                 || fromKeyStore.length == 0
639                 || !(fromKeyStore[0] instanceof X509Certificate))
640             {
641                 throw new FailedLoginException(
642                     &quot;Unable to find X.509 certificate chain in keystore&quot;);
643             } else {
644                 LinkedList&lt;Certificate&gt; certList = new LinkedList&lt;&gt;();
645                 for (int i=0; i &lt; fromKeyStore.length; i++) {
646                     certList.add(fromKeyStore[i]);
647                 }
648                 CertificateFactory certF=
649                     CertificateFactory.getInstance(&quot;X.509&quot;);
650                 certP =
651                     certF.generateCertPath(certList);
652             }
653         } catch (KeyStoreException e) {
654             LoginException le = new LoginException(&quot;Error using keystore&quot;);
655             le.initCause(e);
656             throw le;
657         } catch (CertificateException ce) {
658             LoginException le = new LoginException
659                 (&quot;Error: X.509 Certificate type unavailable&quot;);
660             le.initCause(ce);
661             throw le;
662         }
663 
664         /* Get principal and keys */
665         try {
666             X509Certificate certificate = (X509Certificate)fromKeyStore[0];
667             principal = new javax.security.auth.x500.X500Principal
668                 (certificate.getSubjectDN().getName());
669 
670             // if token, privateKeyPassword will be null
671             Key privateKey = keyStore.getKey(keyStoreAlias, privateKeyPassword);
672             if (privateKey == null
673                 || !(privateKey instanceof PrivateKey))
674             {
675                 throw new FailedLoginException(
676                     &quot;Unable to recover key from keystore&quot;);
677             }
678 
679             privateCredential = new X500PrivateCredential(
680                 certificate, (PrivateKey) privateKey, keyStoreAlias);
681         } catch (KeyStoreException e) {
682             LoginException le = new LoginException(&quot;Error using keystore&quot;);
683             le.initCause(e);
684             throw le;
685         } catch (NoSuchAlgorithmException e) {
686             LoginException le = new LoginException(&quot;Error using keystore&quot;);
687             le.initCause(e);
688             throw le;
689         } catch (UnrecoverableKeyException e) {
690             FailedLoginException fle = new FailedLoginException
691                                 (&quot;Unable to recover key from keystore&quot;);
692             fle.initCause(e);
693             throw fle;
694         }
695         if (debug) {
696             debugPrint(&quot;principal=&quot; + principal +
697                        &quot;\n certificate=&quot;
698                        + privateCredential.getCertificate() +
699                        &quot;\n alias =&quot; + privateCredential.getAlias());
700         }
701     }
702 
703     /**
704      * Abstract method to commit the authentication process (phase 2).
705      *
706      * &lt;p&gt; This method is called if the LoginContext&#39;s
707      * overall authentication succeeded
708      * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules
709      * succeeded).
710      *
711      * &lt;p&gt; If this LoginModule&#39;s own authentication attempt
712      * succeeded (checked by retrieving the private state saved by the
713      * {@code login} method), then this method associates a
714      * {@code X500Principal} for the subject distinguished name of the
715      * first certificate in the alias&#39;s credentials in the subject&#39;s
716      * principals,the alias&#39;s certificate path in the subject&#39;s public
717      * credentials, and a {@code X500PrivateCredential} whose certificate
718      * is the first  certificate in the alias&#39;s certificate path and whose
719      * private key is the alias&#39;s private key in the subject&#39;s private
720      * credentials.  If this LoginModule&#39;s own
721      * authentication attempted failed, then this method removes
722      * any state that was originally saved.
723      *
724      * @exception LoginException if the commit fails
725      *
726      * @return true if this LoginModule&#39;s own login and commit
727      *          attempts succeeded, or false otherwise.
728      */
729 
730     public boolean commit() throws LoginException {
731         switch (status) {
732         case UNINITIALIZED:
733         default:
734             throw new LoginException(&quot;The login module is not initialized&quot;);
735         case INITIALIZED:
736             logoutInternal();
737             throw new LoginException(&quot;Authentication failed&quot;);
738         case AUTHENTICATED:
739             if (commitInternal()) {
740                 return true;
741             } else {
742                 logoutInternal();
743                 throw new LoginException(&quot;Unable to retrieve certificates&quot;);
744             }
745         case LOGGED_IN:
746             return true;
747         }
748     }
749 
750     private boolean commitInternal() throws LoginException {
751         /* If the subject is not readonly add to the principal and credentials
752          * set; otherwise just return true
753          */
754         if (subject.isReadOnly()) {
755             throw new LoginException (&quot;Subject is set readonly&quot;);
756         } else {
757             subject.getPrincipals().add(principal);
758             subject.getPublicCredentials().add(certP);
759             subject.getPrivateCredentials().add(privateCredential);
760             status = LOGGED_IN;
761             return true;
762         }
763     }
764 
765     /**
766      * This method is called if the LoginContext&#39;s
767      * overall authentication failed.
768      * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules
769      * did not succeed).
770      *
771      * &lt;p&gt; If this LoginModule&#39;s own authentication attempt
772      * succeeded (checked by retrieving the private state saved by the
773      * {@code login} and {@code commit} methods),
774      * then this method cleans up any state that was originally saved.
775      *
776      * &lt;p&gt; If the loaded KeyStore&#39;s provider extends
777      * {@code java.security.AuthProvider},
778      * then the provider&#39;s {@code logout} method is invoked.
779      *
780      * @exception LoginException if the abort fails.
781      *
782      * @return false if this LoginModule&#39;s own login and/or commit attempts
783      *          failed, and true otherwise.
784      */
785 
786     public boolean abort() throws LoginException {
787         switch (status) {
788         case UNINITIALIZED:
789         default:
790             return false;
791         case INITIALIZED:
792             return false;
793         case AUTHENTICATED:
794             logoutInternal();
795             return true;
796         case LOGGED_IN:
797             logoutInternal();
798             return true;
799         }
800     }
801     /**
802      * Logout a user.
803      *
804      * &lt;p&gt; This method removes the Principals, public credentials and the
805      * private credentials that were added by the {@code commit} method.
806      *
807      * &lt;p&gt; If the loaded KeyStore&#39;s provider extends
808      * {@code java.security.AuthProvider},
809      * then the provider&#39;s {@code logout} method is invoked.
810      *
811      * @exception LoginException if the logout fails.
812      *
813      * @return true in all cases since this {@code LoginModule}
814      *          should not be ignored.
815      */
816 
817     public boolean logout() throws LoginException {
818         if (debug)
819             debugPrint(&quot;Entering logout &quot; + status);
820         switch (status) {
821         case UNINITIALIZED:
822             throw new LoginException
823                 (&quot;The login module is not initialized&quot;);
824         case INITIALIZED:
825         case AUTHENTICATED:
826         default:
827            // impossible for LoginModule to be in AUTHENTICATED
828            // state
829            // assert status != AUTHENTICATED;
830             return false;
831         case LOGGED_IN:
832             logoutInternal();
833             return true;
834         }
835     }
836 
837     private void logoutInternal() throws LoginException {
838         if (debug) {
839             debugPrint(&quot;Entering logoutInternal&quot;);
840         }
841 
842         // assumption is that KeyStore.load did a login -
843         // perform explicit logout if possible
844         LoginException logoutException = null;
845         Provider provider = keyStore.getProvider();
846         if (provider instanceof AuthProvider) {
847             AuthProvider ap = (AuthProvider)provider;
848             try {
849                 ap.logout();
850                 if (debug) {
851                     debugPrint(&quot;logged out of KeyStore AuthProvider&quot;);
852                 }
853             } catch (LoginException le) {
854                 // save but continue below
855                 logoutException = le;
856             }
857         }
858 
859         if (subject.isReadOnly()) {
860             // attempt to destroy the private credential
861             // even if the Subject is read-only
862             principal = null;
863             certP = null;
864             status = INITIALIZED;
865             // destroy the private credential
866             Iterator&lt;Object&gt; it = subject.getPrivateCredentials().iterator();
867             while (it.hasNext()) {
868                 Object obj = it.next();
869                 if (privateCredential.equals(obj)) {
870                     privateCredential = null;
871                     try {
872                         ((Destroyable)obj).destroy();
873                         if (debug)
874                             debugPrint(&quot;Destroyed private credential, &quot; +
875                                        obj.getClass().getName());
876                         break;
877                     } catch (DestroyFailedException dfe) {
878                         LoginException le = new LoginException
879                             (&quot;Unable to destroy private credential, &quot;
880                              + obj.getClass().getName());
881                         le.initCause(dfe);
882                         throw le;
883                     }
884                 }
885             }
886 
887             // throw an exception because we can not remove
888             // the principal and public credential from this
889             // read-only Subject
890             throw new LoginException
891                 (&quot;Unable to remove Principal (&quot;
892                  + &quot;X500Principal &quot;
893                  + &quot;) and public credential (certificatepath) &quot;
894                  + &quot;from read-only Subject&quot;);
895         }
896         if (principal != null) {
897             subject.getPrincipals().remove(principal);
898             principal = null;
899         }
900         if (certP != null) {
901             subject.getPublicCredentials().remove(certP);
902             certP = null;
903         }
904         if (privateCredential != null) {
905             subject.getPrivateCredentials().remove(privateCredential);
906             privateCredential = null;
907         }
908 
909         // throw pending logout exception if there is one
910         if (logoutException != null) {
911             throw logoutException;
912         }
913         status = INITIALIZED;
914     }
915 
916     private void debugPrint(String message) {
917         // we should switch to logging API
918         if (message == null) {
919             System.err.println();
920         } else {
921             System.err.println(&quot;Debug KeyStoreLoginModule: &quot; + message);
922         }
923     }
924 }
    </pre>
  </body>
</html>