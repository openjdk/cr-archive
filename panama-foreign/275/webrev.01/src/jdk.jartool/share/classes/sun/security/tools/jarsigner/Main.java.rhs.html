<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.jarsigner;
  27 
  28 import java.io.*;
  29 import java.net.UnknownHostException;
  30 import java.security.cert.CertPathValidatorException;
  31 import java.security.cert.PKIXBuilderParameters;
  32 import java.util.*;
  33 import java.util.stream.Collectors;
  34 import java.util.zip.*;
  35 import java.util.jar.*;
  36 import java.net.URI;
  37 import java.text.Collator;
  38 import java.text.MessageFormat;
  39 import java.security.cert.Certificate;
  40 import java.security.cert.X509Certificate;
  41 import java.security.cert.CertificateException;
  42 import java.security.*;
  43 
  44 import java.net.SocketTimeoutException;
  45 import java.net.URL;
  46 import java.security.cert.CertPath;
  47 import java.security.cert.CertificateExpiredException;
  48 import java.security.cert.CertificateFactory;
  49 import java.security.cert.CertificateNotYetValidException;
  50 import java.security.cert.TrustAnchor;
  51 import java.util.Map.Entry;
  52 
  53 import jdk.internal.access.JavaUtilZipFileAccess;
  54 import jdk.internal.access.SharedSecrets;
  55 import jdk.security.jarsigner.JarSigner;
  56 import jdk.security.jarsigner.JarSignerException;
  57 import sun.security.pkcs.PKCS7;
  58 import sun.security.pkcs.SignerInfo;
  59 import sun.security.timestamp.TimestampToken;
  60 import sun.security.tools.KeyStoreUtil;
  61 import sun.security.validator.Validator;
  62 import sun.security.validator.ValidatorException;
  63 import sun.security.x509.*;
  64 import sun.security.util.*;
  65 
  66 
  67 /**
  68  * &lt;p&gt;The jarsigner utility.
  69  *
  70  * The exit codes for the main method are:
  71  *
  72  * 0: success
  73  * 1: any error that the jar cannot be signed or verified, including:
  74  *      keystore loading error
  75  *      TSP communication error
  76  *      jarsigner command line error...
  77  * otherwise: error codes from -strict
  78  *
  79  * @author Roland Schemers
  80  * @author Jan Luehe
  81  */
  82 public class Main {
  83 
  84     // for i18n
  85     private static final java.util.ResourceBundle rb =
  86         java.util.ResourceBundle.getBundle
  87         (&quot;sun.security.tools.jarsigner.Resources&quot;);
  88     private static final Collator collator = Collator.getInstance();
  89     static {
  90         // this is for case insensitive string comparisions
  91         collator.setStrength(Collator.PRIMARY);
  92     }
  93 
  94     private static final String NONE = &quot;NONE&quot;;
  95     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
  96 
  97     private static final long SIX_MONTHS = 180*24*60*60*1000L; //milliseconds
  98     private static final long ONE_YEAR = 366*24*60*60*1000L;
  99 
 100     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
 101             new DisabledAlgorithmConstraints(
 102                     DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS);
 103 
 104     private static final DisabledAlgorithmConstraints LEGACY_CHECK =
 105             new DisabledAlgorithmConstraints(
 106                     DisabledAlgorithmConstraints.PROPERTY_SECURITY_LEGACY_ALGS);
 107 
 108     private static final Set&lt;CryptoPrimitive&gt; DIGEST_PRIMITIVE_SET = Collections
 109             .unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));
 110     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 111             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 112 
 113     private static boolean permsDetected;
 114 
 115     static final String VERSION = &quot;1.0&quot;;
 116 
 117     static final int IN_KEYSTORE = 0x01;        // signer is in keystore
 118     static final int NOT_ALIAS = 0x04;          // alias list is NOT empty and
 119     // signer is not in alias list
 120     static final int SIGNED_BY_ALIAS = 0x08;    // signer is in alias list
 121 
 122     static final JavaUtilZipFileAccess JUZFA = SharedSecrets.getJavaUtilZipFileAccess();
 123 
 124     // Attention:
 125     // This is the entry that get launched by the security tool jarsigner.
 126     public static void main(String args[]) throws Exception {
 127         Main js = new Main();
 128         js.run(args);
 129     }
 130 
 131     X509Certificate[] certChain;    // signer&#39;s cert chain (when composing)
 132     PrivateKey privateKey;          // private key
 133     KeyStore store;                 // the keystore specified by -keystore
 134                                     // or the default keystore, never null
 135 
 136     String keystore; // key store file
 137     boolean nullStream = false; // null keystore input stream (NONE)
 138     boolean token = false; // token-based keystore
 139     String jarfile;  // jar files to sign or verify
 140     String alias;    // alias to sign jar with
 141     List&lt;String&gt; ckaliases = new ArrayList&lt;&gt;(); // aliases in -verify
 142     char[] storepass; // keystore password
 143     boolean protectedPath; // protected authentication path
 144     String storetype; // keystore type
 145     String providerName; // provider name
 146     List&lt;String&gt; providers = null; // list of provider names
 147     List&lt;String&gt; providerClasses = null; // list of provider classes
 148     // arguments for provider constructors
 149     HashMap&lt;String,String&gt; providerArgs = new HashMap&lt;&gt;();
 150     char[] keypass; // private key password
 151     String sigfile; // name of .SF file
 152     String sigalg; // name of signature algorithm
 153     String digestalg; // name of digest algorithm
 154     String signedjar; // output filename
 155     String tsaUrl; // location of the Timestamping Authority
 156     String tsaAlias; // alias for the Timestamping Authority&#39;s certificate
 157     String altCertChain; // file to read alternative cert chain from
 158     String tSAPolicyID;
 159     String tSADigestAlg;
 160     boolean verify = false; // verify the jar
 161     String verbose = null; // verbose output when signing/verifying
 162     boolean showcerts = false; // show certs when verifying
 163     boolean debug = false; // debug
 164     boolean signManifest = true; // &quot;sign&quot; the whole manifest
 165     boolean externalSF = true; // leave the .SF out of the PKCS7 block
 166     boolean strict = false;  // treat warnings as error
 167     boolean revocationCheck = false; // Revocation check flag
 168 
 169     // read zip entry raw bytes
 170     private String altSignerClass = null;
 171     private String altSignerClasspath = null;
 172     private ZipFile zipFile = null;
 173 
 174     // Informational warnings
 175     private boolean hasExpiringCert = false;
 176     private boolean hasExpiringTsaCert = false;
 177     private boolean noTimestamp = true;
 178 
 179     // Expiration date. The value could be null if signed by a trusted cert.
 180     private Date expireDate = null;
 181     private Date tsaExpireDate = null;
 182 
 183     // If there is a time stamp block inside the PKCS7 block file
 184     boolean hasTimestampBlock = false;
 185 
 186     private PublicKey weakPublicKey = null;
 187     private boolean disabledAlgFound = false;
 188     private String legacyDigestAlg = null;
 189     private String legacyTsaDigestAlg = null;
 190     private String legacySigAlg = null;
 191 
 192     // Severe warnings.
 193 
 194     // jarsigner used to check signer cert chain validity and key usages
 195     // itself and set various warnings. Later CertPath validation is
 196     // added but chainNotValidated is only flagged when no other existing
 197     // warnings are set. TSA cert chain check is added separately and
 198     // only tsaChainNotValidated is set, i.e. has no affect on hasExpiredCert,
 199     // notYetValidCert, or any badXyzUsage.
 200 
 201     private int legacyAlg = 0; // 1. digestalg, 2. sigalg, 4. tsadigestalg, 8. key
 202     private int disabledAlg = 0; // 1. digestalg, 2. sigalg, 4. tsadigestalg, 8. key
 203     private boolean hasExpiredCert = false;
 204     private boolean hasExpiredTsaCert = false;
 205     private boolean notYetValidCert = false;
 206     private boolean chainNotValidated = false;
 207     private boolean tsaChainNotValidated = false;
 208     private boolean notSignedByAlias = false;
 209     private boolean aliasNotInStore = false;
 210     private boolean hasUnsignedEntry = false;
 211     private boolean badKeyUsage = false;
 212     private boolean badExtendedKeyUsage = false;
 213     private boolean badNetscapeCertType = false;
 214     private boolean signerSelfSigned = false;
 215 
 216     private Throwable chainNotValidatedReason = null;
 217     private Throwable tsaChainNotValidatedReason = null;
 218 
 219     PKIXBuilderParameters pkixParameters;
 220     Set&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
 221 
 222     public void run(String args[]) {
 223         try {
 224             args = parseArgs(args);
 225 
 226             // Try to load and install the specified providers
 227             if (providers != null) {
 228                 for (String provName: providers) {
 229                     try {
 230                         KeyStoreUtil.loadProviderByName(provName,
 231                                 providerArgs.get(provName));
 232                         if (debug) {
 233                             System.out.println(&quot;loadProviderByName: &quot; + provName);
 234                         }
 235                     } catch (IllegalArgumentException e) {
 236                         throw new Exception(String.format(rb.getString(
 237                                 &quot;provider.name.not.found&quot;), provName));
 238                     }
 239                 }
 240             }
 241 
 242             if (providerClasses != null) {
 243                 ClassLoader cl = ClassLoader.getSystemClassLoader();
 244                 for (String provClass: providerClasses) {
 245                     try {
 246                         KeyStoreUtil.loadProviderByClass(provClass,
 247                                 providerArgs.get(provClass), cl);
 248                         if (debug) {
 249                             System.out.println(&quot;loadProviderByClass: &quot; + provClass);
 250                         }
 251                     } catch (ClassCastException cce) {
 252                         throw new Exception(String.format(rb.getString(
 253                                 &quot;provclass.not.a.provider&quot;), provClass));
 254                     } catch (IllegalArgumentException e) {
 255                         throw new Exception(String.format(rb.getString(
 256                                 &quot;provider.class.not.found&quot;), provClass), e.getCause());
 257                     }
 258                 }
 259             }
 260 
 261             if (verify) {
 262                 try {
 263                     loadKeyStore(keystore, false);
 264                 } catch (Exception e) {
 265                     if ((keystore != null) || (storepass != null)) {
 266                         System.out.println(rb.getString(&quot;jarsigner.error.&quot;) +
 267                                         e.getMessage());
 268                         if (debug) {
 269                             e.printStackTrace();
 270                         }
 271                         System.exit(1);
 272                     }
 273                 }
 274                 /*              if (debug) {
 275                     SignatureFileVerifier.setDebug(true);
 276                     ManifestEntryVerifier.setDebug(true);
 277                 }
 278                 */
 279                 verifyJar(jarfile);
 280             } else {
 281                 loadKeyStore(keystore, true);
 282                 getAliasInfo(alias);
 283 
 284                 signJar(jarfile, alias);
 285             }
 286         } catch (Exception e) {
 287             System.out.println(rb.getString(&quot;jarsigner.error.&quot;) + e);
 288             if (debug) {
 289                 e.printStackTrace();
 290             }
 291             System.exit(1);
 292         } finally {
 293             // zero-out private key password
 294             if (keypass != null) {
 295                 Arrays.fill(keypass, &#39; &#39;);
 296                 keypass = null;
 297             }
 298             // zero-out keystore password
 299             if (storepass != null) {
 300                 Arrays.fill(storepass, &#39; &#39;);
 301                 storepass = null;
 302             }
 303             Event.clearReportListener(Event.ReporterCategory.CRLCHECK);
 304         }
 305 
 306         if (strict) {
 307             int exitCode = 0;
 308             if (disabledAlg != 0 || chainNotValidated || hasExpiredCert
 309                     || hasExpiredTsaCert || notYetValidCert || signerSelfSigned) {
 310                 exitCode |= 4;
 311             }
 312             if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType) {
 313                 exitCode |= 8;
 314             }
 315             if (hasUnsignedEntry) {
 316                 exitCode |= 16;
 317             }
 318             if (notSignedByAlias || aliasNotInStore) {
 319                 exitCode |= 32;
 320             }
 321             if (tsaChainNotValidated) {
 322                 exitCode |= 64;
 323             }
 324             if (exitCode != 0) {
 325                 System.exit(exitCode);
 326             }
 327         }
 328     }
 329 
 330     /*
 331      * Parse command line arguments.
 332      */
 333     String[] parseArgs(String args[]) throws Exception {
 334         /* parse flags */
 335         int n = 0;
 336 
 337         if (args.length == 0) fullusage();
 338 
 339         String confFile = null;
 340         String command = &quot;-sign&quot;;
 341         for (n=0; n &lt; args.length; n++) {
 342             if (collator.compare(args[n], &quot;-verify&quot;) == 0) {
 343                 command = &quot;-verify&quot;;
 344             } else if (collator.compare(args[n], &quot;-conf&quot;) == 0) {
 345                 if (n == args.length - 1) {
 346                     usageNoArg();
 347                 }
 348                 confFile = args[++n];
 349             }
 350         }
 351 
 352         if (confFile != null) {
 353             args = KeyStoreUtil.expandArgs(
 354                     &quot;jarsigner&quot;, confFile, command, null, args);
 355         }
 356 
 357         debug = Arrays.stream(args).anyMatch(
 358                 x -&gt; collator.compare(x, &quot;-debug&quot;) == 0);
 359 
 360         if (debug) {
 361             // No need to localize debug output
 362             System.out.println(&quot;Command line args: &quot; +
 363                     Arrays.toString(args));
 364         }
 365 
 366         for (n=0; n &lt; args.length; n++) {
 367 
 368             String flags = args[n];
 369             String modifier = null;
 370 
 371             if (flags.startsWith(&quot;-&quot;)) {
 372                 int pos = flags.indexOf(&#39;:&#39;);
 373                 if (pos &gt; 0) {
 374                     modifier = flags.substring(pos+1);
 375                     flags = flags.substring(0, pos);
 376                 }
 377             }
 378 
 379             if (!flags.startsWith(&quot;-&quot;)) {
 380                 if (jarfile == null) {
 381                     jarfile = flags;
 382                 } else {
 383                     alias = flags;
 384                     ckaliases.add(alias);
 385                 }
 386             } else if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 387                 if (++n == args.length) usageNoArg();
 388             } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
 389                 if (++n == args.length) usageNoArg();
 390                 keystore = args[n];
 391             } else if (collator.compare(flags, &quot;-storepass&quot;) ==0) {
 392                 if (++n == args.length) usageNoArg();
 393                 storepass = getPass(modifier, args[n]);
 394             } else if (collator.compare(flags, &quot;-storetype&quot;) ==0) {
 395                 if (++n == args.length) usageNoArg();
 396                 storetype = args[n];
 397             } else if (collator.compare(flags, &quot;-providerName&quot;) ==0) {
 398                 if (++n == args.length) usageNoArg();
 399                 providerName = args[n];
 400             } else if (collator.compare(flags, &quot;-provider&quot;) == 0 ||
 401                         collator.compare(flags, &quot;-providerClass&quot;) == 0) {
 402                 if (++n == args.length) usageNoArg();
 403                 if (providerClasses == null) {
 404                     providerClasses = new ArrayList&lt;&gt;(3);
 405                 }
 406                 providerClasses.add(args[n]);
 407 
 408                 if (args.length &gt; (n+1)) {
 409                     flags = args[n+1];
 410                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 411                         if (args.length == (n+2)) usageNoArg();
 412                         providerArgs.put(args[n], args[n+2]);
 413                         n += 2;
 414                     }
 415                 }
 416             } else if (collator.compare(flags, &quot;-addprovider&quot;) == 0) {
 417                 if (++n == args.length) usageNoArg();
 418                 if (providers == null) {
 419                     providers = new ArrayList&lt;&gt;(3);
 420                 }
 421                 providers.add(args[n]);
 422 
 423                 if (args.length &gt; (n+1)) {
 424                     flags = args[n+1];
 425                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 426                         if (args.length == (n+2)) usageNoArg();
 427                         providerArgs.put(args[n], args[n+2]);
 428                         n += 2;
 429                     }
 430                 }
 431             } else if (collator.compare(flags, &quot;-protected&quot;) ==0) {
 432                 protectedPath = true;
 433             } else if (collator.compare(flags, &quot;-certchain&quot;) ==0) {
 434                 if (++n == args.length) usageNoArg();
 435                 altCertChain = args[n];
 436             } else if (collator.compare(flags, &quot;-tsapolicyid&quot;) ==0) {
 437                 if (++n == args.length) usageNoArg();
 438                 tSAPolicyID = args[n];
 439             } else if (collator.compare(flags, &quot;-tsadigestalg&quot;) ==0) {
 440                 if (++n == args.length) usageNoArg();
 441                 tSADigestAlg = args[n];
 442             } else if (collator.compare(flags, &quot;-debug&quot;) ==0) {
 443                 // Already processed
 444             } else if (collator.compare(flags, &quot;-keypass&quot;) ==0) {
 445                 if (++n == args.length) usageNoArg();
 446                 keypass = getPass(modifier, args[n]);
 447             } else if (collator.compare(flags, &quot;-sigfile&quot;) ==0) {
 448                 if (++n == args.length) usageNoArg();
 449                 sigfile = args[n];
 450             } else if (collator.compare(flags, &quot;-signedjar&quot;) ==0) {
 451                 if (++n == args.length) usageNoArg();
 452                 signedjar = args[n];
 453             } else if (collator.compare(flags, &quot;-tsa&quot;) ==0) {
 454                 if (++n == args.length) usageNoArg();
 455                 tsaUrl = args[n];
 456             } else if (collator.compare(flags, &quot;-tsacert&quot;) ==0) {
 457                 if (++n == args.length) usageNoArg();
 458                 tsaAlias = args[n];
 459             } else if (collator.compare(flags, &quot;-altsigner&quot;) ==0) {
 460                 if (++n == args.length) usageNoArg();
 461                 altSignerClass = args[n];
 462                 System.err.println(
 463                         rb.getString(&quot;This.option.is.forremoval&quot;) +
 464                                 &quot;-altsigner&quot;);
 465             } else if (collator.compare(flags, &quot;-altsignerpath&quot;) ==0) {
 466                 if (++n == args.length) usageNoArg();
 467                 altSignerClasspath = args[n];
 468                 System.err.println(
 469                         rb.getString(&quot;This.option.is.forremoval&quot;) +
 470                                 &quot;-altsignerpath&quot;);
 471             } else if (collator.compare(flags, &quot;-sectionsonly&quot;) ==0) {
 472                 signManifest = false;
 473             } else if (collator.compare(flags, &quot;-internalsf&quot;) ==0) {
 474                 externalSF = false;
 475             } else if (collator.compare(flags, &quot;-verify&quot;) ==0) {
 476                 verify = true;
 477             } else if (collator.compare(flags, &quot;-verbose&quot;) ==0) {
 478                 verbose = (modifier != null) ? modifier : &quot;all&quot;;
 479             } else if (collator.compare(flags, &quot;-sigalg&quot;) ==0) {
 480                 if (++n == args.length) usageNoArg();
 481                 sigalg = args[n];
 482             } else if (collator.compare(flags, &quot;-digestalg&quot;) ==0) {
 483                 if (++n == args.length) usageNoArg();
 484                 digestalg = args[n];
 485             } else if (collator.compare(flags, &quot;-certs&quot;) ==0) {
 486                 showcerts = true;
 487             } else if (collator.compare(flags, &quot;-strict&quot;) ==0) {
 488                 strict = true;
 489             } else if (collator.compare(flags, &quot;-?&quot;) == 0 ||
 490                        collator.compare(flags, &quot;-h&quot;) == 0 ||
 491                        collator.compare(flags, &quot;--help&quot;) == 0 ||
 492                        // -help: legacy.
 493                        collator.compare(flags, &quot;-help&quot;) == 0) {
 494                 fullusage();
 495             } else if (collator.compare(flags, &quot;-revCheck&quot;) == 0) {
 496                 revocationCheck = true;
 497             } else {
 498                 System.err.println(
 499                         rb.getString(&quot;Illegal.option.&quot;) + flags);
 500                 usage();
 501             }
 502         }
 503 
 504         // -certs must always be specified with -verbose
 505         if (verbose == null) showcerts = false;
 506 
 507         if (jarfile == null) {
 508             System.err.println(rb.getString(&quot;Please.specify.jarfile.name&quot;));
 509             usage();
 510         }
 511         if (!verify &amp;&amp; alias == null) {
 512             System.err.println(rb.getString(&quot;Please.specify.alias.name&quot;));
 513             usage();
 514         }
 515         if (!verify &amp;&amp; ckaliases.size() &gt; 1) {
 516             System.err.println(rb.getString(&quot;Only.one.alias.can.be.specified&quot;));
 517             usage();
 518         }
 519 
 520         if (storetype == null) {
 521             storetype = KeyStore.getDefaultType();
 522         }
 523         storetype = KeyStoreUtil.niceStoreTypeName(storetype);
 524 
 525         try {
 526             if (signedjar != null &amp;&amp; new File(signedjar).getCanonicalPath().equals(
 527                     new File(jarfile).getCanonicalPath())) {
 528                 signedjar = null;
 529             }
 530         } catch (IOException ioe) {
 531             // File system error?
 532             // Just ignore it.
 533         }
 534 
 535         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 536                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 537             token = true;
 538             if (keystore == null) {
 539                 keystore = NONE;
 540             }
 541         }
 542 
 543         if (NONE.equals(keystore)) {
 544             nullStream = true;
 545         }
 546 
 547         if (token &amp;&amp; !nullStream) {
 548             System.err.println(MessageFormat.format(rb.getString
 549                 (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
 550             usage();
 551         }
 552 
 553         if (token &amp;&amp; keypass != null) {
 554             System.err.println(MessageFormat.format(rb.getString
 555                 (&quot;.keypass.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
 556             usage();
 557         }
 558 
 559         if (protectedPath) {
 560             if (storepass != null || keypass != null) {
 561                 System.err.println(rb.getString
 562                         (&quot;If.protected.is.specified.then.storepass.and.keypass.must.not.be.specified&quot;));
 563                 usage();
 564             }
 565         }
 566         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
 567             if (storepass != null || keypass != null) {
 568                 System.err.println(rb.getString
 569                         (&quot;If.keystore.is.not.password.protected.then.storepass.and.keypass.must.not.be.specified&quot;));
 570                 usage();
 571             }
 572         }
 573         return args;
 574     }
 575 
 576     static char[] getPass(String modifier, String arg) {
 577         char[] output =
 578             KeyStoreUtil.getPassWithModifier(modifier, arg, rb, collator);
 579         if (output != null) return output;
 580         usage();
 581         return null;    // Useless, usage() already exit
 582     }
 583 
 584     static void usageNoArg() {
 585         System.out.println(rb.getString(&quot;Option.lacks.argument&quot;));
 586         usage();
 587     }
 588 
 589     static void usage() {
 590         System.out.println();
 591         System.out.println(rb.getString(&quot;Please.type.jarsigner.help.for.usage&quot;));
 592         System.exit(1);
 593     }
 594 
 595     static void fullusage() {
 596         System.out.println(rb.getString
 597                 (&quot;Usage.jarsigner.options.jar.file.alias&quot;));
 598         System.out.println(rb.getString
 599                 (&quot;.jarsigner.verify.options.jar.file.alias.&quot;));
 600         System.out.println();
 601         System.out.println(rb.getString
 602                 (&quot;.keystore.url.keystore.location&quot;));
 603         System.out.println();
 604         System.out.println(rb.getString
 605                 (&quot;.storepass.password.password.for.keystore.integrity&quot;));
 606         System.out.println();
 607         System.out.println(rb.getString
 608                 (&quot;.storetype.type.keystore.type&quot;));
 609         System.out.println();
 610         System.out.println(rb.getString
 611                 (&quot;.keypass.password.password.for.private.key.if.different.&quot;));
 612         System.out.println();
 613         System.out.println(rb.getString
 614                 (&quot;.certchain.file.name.of.alternative.certchain.file&quot;));
 615         System.out.println();
 616         System.out.println(rb.getString
 617                 (&quot;.sigfile.file.name.of.SF.DSA.file&quot;));
 618         System.out.println();
 619         System.out.println(rb.getString
 620                 (&quot;.signedjar.file.name.of.signed.JAR.file&quot;));
 621         System.out.println();
 622         System.out.println(rb.getString
 623                 (&quot;.digestalg.algorithm.name.of.digest.algorithm&quot;));
 624         System.out.println();
 625         System.out.println(rb.getString
 626                 (&quot;.sigalg.algorithm.name.of.signature.algorithm&quot;));
 627         System.out.println();
 628         System.out.println(rb.getString
 629                 (&quot;.verify.verify.a.signed.JAR.file&quot;));
 630         System.out.println();
 631         System.out.println(rb.getString
 632                 (&quot;.verbose.suboptions.verbose.output.when.signing.verifying.&quot;));
 633         System.out.println(rb.getString
 634                 (&quot;.suboptions.can.be.all.grouped.or.summary&quot;));
 635         System.out.println();
 636         System.out.println(rb.getString
 637                 (&quot;.certs.display.certificates.when.verbose.and.verifying&quot;));
 638         System.out.println();
 639         System.out.println(rb.getString
 640                 (&quot;.certs.revocation.check&quot;));
 641         System.out.println();
 642         System.out.println(rb.getString
 643                 (&quot;.tsa.url.location.of.the.Timestamping.Authority&quot;));
 644         System.out.println();
 645         System.out.println(rb.getString
 646                 (&quot;.tsacert.alias.public.key.certificate.for.Timestamping.Authority&quot;));
 647         System.out.println();
 648         System.out.println(rb.getString
 649                 (&quot;.tsapolicyid.tsapolicyid.for.Timestamping.Authority&quot;));
 650         System.out.println();
 651         System.out.println(rb.getString
 652                 (&quot;.tsadigestalg.algorithm.of.digest.data.in.timestamping.request&quot;));
 653         System.out.println();
 654         System.out.println(rb.getString
 655                 (&quot;.altsigner.class.class.name.of.an.alternative.signing.mechanism&quot;));
 656         System.out.println();
 657         System.out.println(rb.getString
 658                 (&quot;.altsignerpath.pathlist.location.of.an.alternative.signing.mechanism&quot;));
 659         System.out.println();
 660         System.out.println(rb.getString
 661                 (&quot;.internalsf.include.the.SF.file.inside.the.signature.block&quot;));
 662         System.out.println();
 663         System.out.println(rb.getString
 664                 (&quot;.sectionsonly.don.t.compute.hash.of.entire.manifest&quot;));
 665         System.out.println();
 666         System.out.println(rb.getString
 667                 (&quot;.protected.keystore.has.protected.authentication.path&quot;));
 668         System.out.println();
 669         System.out.println(rb.getString
 670                 (&quot;.providerName.name.provider.name&quot;));
 671         System.out.println();
 672         System.out.println(rb.getString
 673                 (&quot;.add.provider.option&quot;));
 674         System.out.println(rb.getString
 675                 (&quot;.providerArg.option.1&quot;));
 676         System.out.println();
 677         System.out.println(rb.getString
 678                 (&quot;.providerClass.option&quot;));
 679         System.out.println(rb.getString
 680                 (&quot;.providerArg.option.2&quot;));
 681         System.out.println();
 682         System.out.println(rb.getString
 683                 (&quot;.strict.treat.warnings.as.errors&quot;));
 684         System.out.println();
 685         System.out.println(rb.getString
 686                 (&quot;.conf.url.specify.a.pre.configured.options.file&quot;));
 687         System.out.println();
 688         System.out.println(rb.getString
 689                 (&quot;.print.this.help.message&quot;));
 690         System.out.println();
 691 
 692         System.exit(0);
 693     }
 694 
 695     void verifyJar(String jarName)
 696         throws Exception
 697     {
 698         boolean anySigned = false;  // if there exists entry inside jar signed
 699         JarFile jf = null;
 700         Map&lt;String,String&gt; digestMap = new HashMap&lt;&gt;();
 701         Map&lt;String,PKCS7&gt; sigMap = new HashMap&lt;&gt;();
 702         Map&lt;String,String&gt; sigNameMap = new HashMap&lt;&gt;();
 703         Map&lt;String,String&gt; unparsableSignatures = new HashMap&lt;&gt;();
 704 
 705         try {
 706             jf = new JarFile(jarName, true);
 707             Vector&lt;JarEntry&gt; entriesVec = new Vector&lt;&gt;();
 708             byte[] buffer = new byte[8192];
 709 
 710             String suffix1 = &quot;-Digest-Manifest&quot;;
 711             String suffix2 = &quot;-Digest-&quot; + ManifestDigester.MF_MAIN_ATTRS;
 712 
 713             int suffixLength1 = suffix1.length();
 714             int suffixLength2 = suffix2.length();
 715 
 716             Enumeration&lt;JarEntry&gt; entries = jf.entries();
 717             while (entries.hasMoreElements()) {
 718                 JarEntry je = entries.nextElement();
 719                 entriesVec.addElement(je);
 720                 try (InputStream is = jf.getInputStream(je)) {
 721                     String name = je.getName();
 722                     if (signatureRelated(name)
 723                             &amp;&amp; SignatureFileVerifier.isBlockOrSF(name)) {
 724                         String alias = name.substring(name.lastIndexOf(&#39;/&#39;) + 1,
 725                                 name.lastIndexOf(&#39;.&#39;));
 726                         try {
 727                             if (name.endsWith(&quot;.SF&quot;)) {
 728                                 Manifest sf = new Manifest(is);
 729                                 boolean found = false;
 730                                 for (Object obj : sf.getMainAttributes().keySet()) {
 731                                     String key = obj.toString();
 732                                     if (key.endsWith(suffix1)) {
 733                                         digestMap.put(alias, key.substring(
 734                                                 0, key.length() - suffixLength1));
 735                                         found = true;
 736                                         break;
 737                                     } else if (key.endsWith(suffix2)) {
 738                                         digestMap.put(alias, key.substring(
 739                                                 0, key.length() - suffixLength2));
 740                                         found = true;
 741                                         break;
 742                                     }
 743                                 }
 744                                 if (!found) {
 745                                     unparsableSignatures.putIfAbsent(alias,
 746                                         String.format(
 747                                             rb.getString(&quot;history.unparsable&quot;),
 748                                             name));
 749                                 }
 750                             } else {
 751                                 sigNameMap.put(alias, name);
 752                                 sigMap.put(alias, new PKCS7(is));
 753                             }
 754                         } catch (IOException ioe) {
 755                             unparsableSignatures.putIfAbsent(alias, String.format(
 756                                     rb.getString(&quot;history.unparsable&quot;), name));
 757                         }
 758                     } else {
 759                         while (is.read(buffer, 0, buffer.length) != -1) {
 760                             // we just read. this will throw a SecurityException
 761                             // if  a signature/digest check fails.
 762                         }
 763                     }
 764                 }
 765             }
 766 
 767             Manifest man = jf.getManifest();
 768             boolean hasSignature = false;
 769 
 770             // The map to record display info, only used when -verbose provided
 771             //      key: signer info string
 772             //      value: the list of files with common key
 773             Map&lt;String,List&lt;String&gt;&gt; output = new LinkedHashMap&lt;&gt;();
 774 
 775             if (man != null) {
 776                 if (verbose != null) System.out.println();
 777                 Enumeration&lt;JarEntry&gt; e = entriesVec.elements();
 778 
 779                 String tab = rb.getString(&quot;6SPACE&quot;);
 780 
 781                 while (e.hasMoreElements()) {
 782                     JarEntry je = e.nextElement();
 783                     String name = je.getName();
 784 
 785                     if (!permsDetected &amp;&amp; JUZFA.getPosixPerms(je) != -1) {
 786                         permsDetected = true;
 787                     }
 788                     hasSignature = hasSignature
 789                             || SignatureFileVerifier.isBlockOrSF(name);
 790 
 791                     CodeSigner[] signers = je.getCodeSigners();
 792                     boolean isSigned = (signers != null);
 793                     anySigned |= isSigned;
 794                     hasUnsignedEntry |= !je.isDirectory() &amp;&amp; !isSigned
 795                                         &amp;&amp; !signatureRelated(name);
 796 
 797                     int inStoreWithAlias = inKeyStore(signers);
 798 
 799                     boolean inStore = (inStoreWithAlias &amp; IN_KEYSTORE) != 0;
 800 
 801                     notSignedByAlias |= (inStoreWithAlias &amp; NOT_ALIAS) != 0;
 802                     if (keystore != null) {
 803                         aliasNotInStore |= isSigned &amp;&amp; !inStore;
 804                     }
 805 
 806                     // Only used when -verbose provided
 807                     StringBuffer sb = null;
 808                     if (verbose != null) {
 809                         sb = new StringBuffer();
 810                         boolean inManifest =
 811                             ((man.getAttributes(name) != null) ||
 812                              (man.getAttributes(&quot;./&quot;+name) != null) ||
 813                              (man.getAttributes(&quot;/&quot;+name) != null));
 814                         sb.append(isSigned ? rb.getString(&quot;s&quot;) : rb.getString(&quot;SPACE&quot;))
 815                                 .append(inManifest ? rb.getString(&quot;m&quot;) : rb.getString(&quot;SPACE&quot;))
 816                                 .append(inStore ? rb.getString(&quot;k&quot;) : rb.getString(&quot;SPACE&quot;))
 817                                 .append((inStoreWithAlias &amp; NOT_ALIAS) != 0 ? &#39;X&#39; : &#39; &#39;)
 818                                 .append(rb.getString(&quot;SPACE&quot;));
 819                         sb.append(&#39;|&#39;);
 820                     }
 821 
 822                     // When -certs provided, display info has extra empty
 823                     // lines at the beginning and end.
 824                     if (isSigned) {
 825                         if (showcerts) sb.append(&#39;\n&#39;);
 826                         for (CodeSigner signer: signers) {
 827                             // signerInfo() must be called even if -verbose
 828                             // not provided. The method updates various
 829                             // warning flags.
 830                             String si = signerInfo(signer, tab);
 831                             if (showcerts) {
 832                                 sb.append(si);
 833                                 sb.append(&#39;\n&#39;);
 834                             }
 835                         }
 836                     } else if (showcerts &amp;&amp; !verbose.equals(&quot;all&quot;)) {
 837                         // Print no info for unsigned entries when -verbose:all,
 838                         // to be consistent with old behavior.
 839                         if (signatureRelated(name)) {
 840                             sb.append(&#39;\n&#39;)
 841                                     .append(tab)
 842                                     .append(rb
 843                                             .getString(&quot;.Signature.related.entries.&quot;))
 844                                     .append(&quot;\n\n&quot;);
 845                         } else {
 846                             sb.append(&#39;\n&#39;).append(tab)
 847                                     .append(rb.getString(&quot;.Unsigned.entries.&quot;))
 848                                     .append(&quot;\n\n&quot;);
 849                         }
 850                     }
 851 
 852                     if (verbose != null) {
 853                         String label = sb.toString();
 854                         if (signatureRelated(name)) {
 855                             // Entries inside META-INF and other unsigned
 856                             // entries are grouped separately.
 857                             label = &quot;-&quot; + label;
 858                         }
 859 
 860                         // The label finally contains 2 parts separated by &#39;|&#39;:
 861                         // The legend displayed before the entry names, and
 862                         // the cert info (if -certs specified).
 863 
 864                         if (!output.containsKey(label)) {
 865                             output.put(label, new ArrayList&lt;String&gt;());
 866                         }
 867 
 868                         StringBuilder fb = new StringBuilder();
 869                         String s = Long.toString(je.getSize());
 870                         for (int i = 6 - s.length(); i &gt; 0; --i) {
 871                             fb.append(&#39; &#39;);
 872                         }
 873                         fb.append(s).append(&#39; &#39;).
 874                                 append(new Date(je.getTime()).toString());
 875                         fb.append(&#39; &#39;).append(name);
 876 
 877                         output.get(label).add(fb.toString());
 878                     }
 879                 }
 880             }
 881             if (verbose != null) {
 882                 for (Entry&lt;String,List&lt;String&gt;&gt; s: output.entrySet()) {
 883                     List&lt;String&gt; files = s.getValue();
 884                     String key = s.getKey();
 885                     if (key.charAt(0) == &#39;-&#39;) { // the signature-related group
 886                         key = key.substring(1);
 887                     }
 888                     int pipe = key.indexOf(&#39;|&#39;);
 889                     if (verbose.equals(&quot;all&quot;)) {
 890                         for (String f: files) {
 891                             System.out.println(key.substring(0, pipe) + f);
 892                             System.out.printf(key.substring(pipe+1));
 893                         }
 894                     } else {
 895                         if (verbose.equals(&quot;grouped&quot;)) {
 896                             for (String f: files) {
 897                                 System.out.println(key.substring(0, pipe) + f);
 898                             }
 899                         } else if (verbose.equals(&quot;summary&quot;)) {
 900                             System.out.print(key.substring(0, pipe));
 901                             if (files.size() &gt; 1) {
 902                                 System.out.println(files.get(0) + &quot; &quot; +
 903                                         String.format(rb.getString(
 904                                         &quot;.and.d.more.&quot;), files.size()-1));
 905                             } else {
 906                                 System.out.println(files.get(0));
 907                             }
 908                         }
 909                         System.out.printf(key.substring(pipe+1));
 910                     }
 911                 }
 912                 System.out.println();
 913                 System.out.println(rb.getString(
 914                     &quot;.s.signature.was.verified.&quot;));
 915                 System.out.println(rb.getString(
 916                     &quot;.m.entry.is.listed.in.manifest&quot;));
 917                 System.out.println(rb.getString(
 918                     &quot;.k.at.least.one.certificate.was.found.in.keystore&quot;));
 919                 if (ckaliases.size() &gt; 0) {
 920                     System.out.println(rb.getString(
 921                         &quot;.X.not.signed.by.specified.alias.es.&quot;));
 922                 }
 923             }
 924             if (man == null) {
 925                 System.out.println();
 926                 System.out.println(rb.getString(&quot;no.manifest.&quot;));
 927             }
 928 
 929             // If signer is a trusted cert or private entry in user&#39;s own
 930             // keystore, it can be self-signed. Please note aliasNotInStore
 931             // is always false when ~/.keystore is used.
 932             if (!aliasNotInStore &amp;&amp; keystore != null) {
 933                 signerSelfSigned = false;
 934             }
 935 
 936             // Even if the verbose option is not specified, all out strings
 937             // must be generated so disabledAlgFound can be updated.
 938             if (!digestMap.isEmpty()
 939                     || !sigMap.isEmpty()
 940                     || !unparsableSignatures.isEmpty()) {
 941                 if (verbose != null) {
 942                     System.out.println();
 943                 }
 944                 for (String s : sigMap.keySet()) {
 945                     if (!digestMap.containsKey(s)) {
 946                         unparsableSignatures.putIfAbsent(s, String.format(
 947                                 rb.getString(&quot;history.nosf&quot;), s));
 948                     }
 949                 }
 950                 for (String s : digestMap.keySet()) {
 951                     PKCS7 p7 = sigMap.get(s);
 952                     if (p7 != null) {
 953                         String history;
 954                         try {
 955                             SignerInfo si = p7.getSignerInfos()[0];
 956                             X509Certificate signer = si.getCertificate(p7);
 957                             String digestAlg = digestMap.get(s);
 958                             String sigAlg = AlgorithmId.makeSigAlg(
 959                                     si.getDigestAlgorithmId().getName(),
 960                                     si.getDigestEncryptionAlgorithmId().getName());
 961                             PublicKey key = signer.getPublicKey();
 962                             PKCS7 tsToken = si.getTsToken();
 963                             if (tsToken != null) {
 964                                 hasTimestampBlock = true;
 965                                 SignerInfo tsSi = tsToken.getSignerInfos()[0];
 966                                 X509Certificate tsSigner = tsSi.getCertificate(tsToken);
 967                                 byte[] encTsTokenInfo = tsToken.getContentInfo().getData();
 968                                 TimestampToken tsTokenInfo = new TimestampToken(encTsTokenInfo);
 969                                 PublicKey tsKey = tsSigner.getPublicKey();
 970                                 String tsDigestAlg = tsTokenInfo.getHashAlgorithm().getName();
 971                                 String tsSigAlg = AlgorithmId.makeSigAlg(
 972                                         tsSi.getDigestAlgorithmId().getName(),
 973                                         tsSi.getDigestEncryptionAlgorithmId().getName());
 974                                 Calendar c = Calendar.getInstance(
 975                                         TimeZone.getTimeZone(&quot;UTC&quot;),
 976                                         Locale.getDefault(Locale.Category.FORMAT));
 977                                 c.setTime(tsTokenInfo.getDate());
 978                                 history = String.format(
 979                                         rb.getString(&quot;history.with.ts&quot;),
 980                                         signer.getSubjectX500Principal(),
 981                                         verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false),
 982                                         verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false),
 983                                         verifyWithWeak(key),
 984                                         c,
 985                                         tsSigner.getSubjectX500Principal(),
 986                                         verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true),
 987                                         verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true),
 988                                         verifyWithWeak(tsKey));
 989                             } else {
 990                                 history = String.format(
 991                                         rb.getString(&quot;history.without.ts&quot;),
 992                                         signer.getSubjectX500Principal(),
 993                                         verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false),
 994                                         verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false),
 995                                         verifyWithWeak(key));
 996                             }
 997                         } catch (Exception e) {
 998                             // The only usage of sigNameMap, remember the name
 999                             // of the block file if it&#39;s invalid.
1000                             history = String.format(
1001                                     rb.getString(&quot;history.unparsable&quot;),
1002                                     sigNameMap.get(s));
1003                         }
1004                         if (verbose != null) {
1005                             System.out.println(history);
1006                         }
1007                     } else {
1008                         unparsableSignatures.putIfAbsent(s, String.format(
1009                                 rb.getString(&quot;history.nobk&quot;), s));
1010                     }
1011                 }
1012                 if (verbose != null) {
1013                     for (String s : unparsableSignatures.keySet()) {
1014                         System.out.println(unparsableSignatures.get(s));
1015                     }
1016                 }
1017             }
1018             System.out.println();
1019 
1020             if (!anySigned) {
1021                 if (disabledAlgFound) {
1022                     if (verbose != null) {
1023                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak.verbose&quot;));
1024                         System.out.println(&quot;\n  &quot; +
1025                                 DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS +
1026                                 &quot;=&quot; + Security.getProperty(DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS));
1027                     } else {
1028                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak&quot;));
1029                     }
1030                 } else if (hasSignature) {
1031                     System.out.println(rb.getString(&quot;jar.treated.unsigned&quot;));
1032                 } else {
1033                     System.out.println(rb.getString(&quot;jar.is.unsigned&quot;));
1034                 }
1035             } else {
1036                 displayMessagesAndResult(false);
1037             }
1038             return;
1039         } catch (Exception e) {
1040             System.out.println(rb.getString(&quot;jarsigner.&quot;) + e);
1041             if (debug) {
1042                 e.printStackTrace();
1043             }
1044         } finally { // close the resource
1045             if (jf != null) {
1046                 jf.close();
1047             }
1048         }
1049 
1050         System.exit(1);
1051     }
1052 
1053     private void displayMessagesAndResult(boolean isSigning) {
1054         String result;
1055         List&lt;String&gt; errors = new ArrayList&lt;&gt;();
1056         List&lt;String&gt; warnings = new ArrayList&lt;&gt;();
1057         List&lt;String&gt; info = new ArrayList&lt;&gt;();
1058 
1059         boolean signerNotExpired = expireDate == null
1060                 || expireDate.after(new Date());
1061 
<a name="1" id="anc1"></a><span class="line-modified">1062         if (badKeyUsage) {</span>
<span class="line-modified">1063             errors.add(isSigning</span>
<span class="line-modified">1064                     ? rb.getString(&quot;The.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;)</span>
<span class="line-modified">1065                     : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;));</span>
<span class="line-modified">1066         }</span>











1067 
<a name="2" id="anc2"></a><span class="line-modified">1068         if (badExtendedKeyUsage) {</span>
<span class="line-modified">1069             errors.add(isSigning</span>
<span class="line-modified">1070                     ? rb.getString(&quot;The.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;)</span>
<span class="line-modified">1071                     : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;));</span>
<span class="line-modified">1072         }</span>
1073 
<a name="3" id="anc3"></a><span class="line-modified">1074         if (badNetscapeCertType) {</span>
<span class="line-modified">1075             errors.add(isSigning</span>
<span class="line-modified">1076                     ? rb.getString(&quot;The.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;)</span>
<span class="line-modified">1077                     : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;));</span>
<span class="line-modified">1078         }</span>
1079 
<a name="4" id="anc4"></a><span class="line-modified">1080         // only in verifying</span>
<span class="line-modified">1081         if (hasUnsignedEntry) {</span>
<span class="line-modified">1082             errors.add(rb.getString(</span>
<span class="line-modified">1083                     &quot;This.jar.contains.unsigned.entries.which.have.not.been.integrity.checked.&quot;));</span>
<span class="line-modified">1084         }</span>
1085 
<a name="5" id="anc5"></a><span class="line-modified">1086         if (hasExpiredCert) {</span>
<span class="line-modified">1087             errors.add(isSigning</span>
<span class="line-modified">1088                     ? rb.getString(&quot;The.signer.certificate.has.expired.&quot;)</span>
<span class="line-modified">1089                     : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.has.expired.&quot;));</span>
<span class="line-modified">1090         }</span>










1091 
<a name="6" id="anc6"></a><span class="line-modified">1092         if (notYetValidCert) {</span>
<span class="line-modified">1093             errors.add(isSigning</span>
<span class="line-modified">1094                     ? rb.getString(&quot;The.signer.certificate.is.not.yet.valid.&quot;)</span>
<span class="line-modified">1095                     : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.not.yet.valid.&quot;));</span>
<span class="line-modified">1096         }</span>

1097 
<a name="7" id="anc7"></a><span class="line-modified">1098         if (chainNotValidated) {</span>
<span class="line-modified">1099             errors.add(String.format(isSigning</span>
<span class="line-modified">1100                             ? rb.getString(&quot;The.signer.s.certificate.chain.is.invalid.reason.1&quot;)</span>
<span class="line-modified">1101                             : rb.getString(&quot;This.jar.contains.entries.whose.certificate.chain.is.invalid.reason.1&quot;),</span>
<span class="line-modified">1102                     chainNotValidatedReason.getLocalizedMessage()));</span>
<span class="line-modified">1103         }</span>



1104 
<a name="8" id="anc8"></a><span class="line-modified">1105         if (tsaChainNotValidated) {</span>
<span class="line-modified">1106             errors.add(String.format(isSigning</span>
<span class="line-modified">1107                             ? rb.getString(&quot;The.tsa.certificate.chain.is.invalid.reason.1&quot;)</span>
<span class="line-modified">1108                             : rb.getString(&quot;This.jar.contains.entries.whose.tsa.certificate.chain.is.invalid.reason.1&quot;),</span>
<span class="line-added">1109                     tsaChainNotValidatedReason.getLocalizedMessage()));</span>
<span class="line-added">1110         }</span>
<span class="line-added">1111 </span>
<span class="line-added">1112         // only in verifying</span>
<span class="line-added">1113         if (notSignedByAlias) {</span>
<span class="line-added">1114             errors.add(</span>
<span class="line-added">1115                     rb.getString(&quot;This.jar.contains.signed.entries.which.is.not.signed.by.the.specified.alias.es.&quot;));</span>
<span class="line-added">1116         }</span>
<span class="line-added">1117 </span>
<span class="line-added">1118         // only in verifying</span>
<span class="line-added">1119         if (aliasNotInStore) {</span>
<span class="line-added">1120             errors.add(rb.getString(&quot;This.jar.contains.signed.entries.that.s.not.signed.by.alias.in.this.keystore.&quot;));</span>
<span class="line-added">1121         }</span>
<span class="line-added">1122 </span>
<span class="line-added">1123         if (signerSelfSigned) {</span>
<span class="line-added">1124             errors.add(isSigning</span>
<span class="line-added">1125                     ? rb.getString(&quot;The.signer.s.certificate.is.self.signed.&quot;)</span>
<span class="line-added">1126                     : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.self.signed.&quot;));</span>
<span class="line-added">1127         }</span>
<span class="line-added">1128 </span>
<span class="line-added">1129         if (isSigning) {</span>
<span class="line-added">1130             if ((legacyAlg &amp; 1) == 1) {</span>
<span class="line-added">1131                 warnings.add(String.format(</span>
<span class="line-added">1132                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),</span>
<span class="line-added">1133                         digestalg, &quot;-digestalg&quot;));</span>
1134             }
1135 
<a name="9" id="anc9"></a><span class="line-modified">1136             if ((disabledAlg &amp; 1) == 1) {</span>
<span class="line-modified">1137                 errors.add(String.format(</span>
<span class="line-modified">1138                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled.&quot;),</span>
<span class="line-added">1139                         digestalg, &quot;-digestalg&quot;));</span>
1140             }
1141 
<a name="10" id="anc10"></a><span class="line-modified">1142             if ((legacyAlg &amp; 2) == 2) {</span>
<span class="line-modified">1143                 warnings.add(String.format(</span>
<span class="line-modified">1144                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),</span>
<span class="line-modified">1145                         sigalg, &quot;-sigalg&quot;));</span>
1146             }
1147 
<a name="11" id="anc11"></a><span class="line-modified">1148             if ((disabledAlg &amp; 2) == 2) {</span>
<span class="line-modified">1149                 errors.add(String.format(</span>
<span class="line-modified">1150                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled.&quot;),</span>
<span class="line-modified">1151                         sigalg, &quot;-sigalg&quot;));</span>
<span class="line-modified">1152             }</span>

1153 
<a name="12" id="anc12"></a><span class="line-modified">1154             if ((legacyAlg &amp; 4) == 4) {</span>
<span class="line-modified">1155                 warnings.add(String.format(</span>
<span class="line-modified">1156                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),</span>
<span class="line-modified">1157                         tSADigestAlg, &quot;-tsadigestalg&quot;));</span>
<span class="line-modified">1158             }</span>
1159 
<a name="13" id="anc13"></a><span class="line-modified">1160             if ((disabledAlg &amp; 4) == 4) {</span>
<span class="line-modified">1161                 errors.add(String.format(</span>
<span class="line-modified">1162                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled.&quot;),</span>
<span class="line-modified">1163                         tSADigestAlg, &quot;-tsadigestalg&quot;));</span>
<span class="line-modified">1164             }</span>





1165 
<a name="14" id="anc14"></a><span class="line-modified">1166             if ((legacyAlg &amp; 8) == 8) {</span>
<span class="line-modified">1167                 warnings.add(String.format(</span>
<span class="line-modified">1168                         rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update.&quot;),</span>
<span class="line-modified">1169                         privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));</span>
<span class="line-modified">1170             }</span>





1171 
<a name="15" id="anc15"></a><span class="line-modified">1172             if ((disabledAlg &amp; 8) == 8) {</span>
<span class="line-modified">1173                 errors.add(String.format(</span>
<span class="line-modified">1174                         rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk.and.is.disabled.&quot;),</span>
<span class="line-modified">1175                         privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));</span>
<span class="line-modified">1176             }</span>
<span class="line-modified">1177         } else {</span>
<span class="line-modified">1178             if ((legacyAlg &amp; 1) != 0) {</span>
<span class="line-modified">1179                 warnings.add(String.format(</span>
<span class="line-modified">1180                         rb.getString(&quot;The.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),</span>
<span class="line-modified">1181                         legacyDigestAlg));</span>
<span class="line-modified">1182             }</span>





1183 
<a name="16" id="anc16"></a><span class="line-modified">1184             if ((legacyAlg &amp; 2) == 2) {</span>
<span class="line-modified">1185                 warnings.add(String.format(</span>
<span class="line-modified">1186                         rb.getString(&quot;The.signature.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),</span>
<span class="line-modified">1187                         legacySigAlg));</span>
<span class="line-modified">1188             }</span>
1189 
<a name="17" id="anc17"></a><span class="line-modified">1190             if ((legacyAlg &amp; 4) != 0) {</span>
<span class="line-modified">1191                 warnings.add(String.format(</span>
<span class="line-modified">1192                         rb.getString(&quot;The.timestamp.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),</span>
<span class="line-modified">1193                         legacyTsaDigestAlg));</span>
<span class="line-modified">1194             }</span>
1195 
<a name="18" id="anc18"></a><span class="line-modified">1196             if ((legacyAlg &amp; 8) == 8) {</span>
<span class="line-modified">1197                 warnings.add(String.format(</span>
<span class="line-modified">1198                         rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update.&quot;),</span>
<span class="line-modified">1199                         weakPublicKey.getAlgorithm(), KeyUtil.getKeySize(weakPublicKey)));</span>

1200             }
<a name="19" id="anc19"></a>

1201         }
1202 
<a name="20" id="anc20"></a><span class="line-added">1203         // This check must be placed after all other &quot;errors.add()&quot; calls were done.</span>
1204         if (hasExpiredTsaCert) {
1205             // No need to warn about expiring if already expired
1206             hasExpiringTsaCert = false;
<a name="21" id="anc21"></a><span class="line-modified">1207             // If there are already another errors, we just say it expired.</span>
<span class="line-modified">1208             if (!signerNotExpired || !errors.isEmpty()) {</span>
<span class="line-modified">1209                 errors.add(rb.getString(&quot;The.timestamp.has.expired.&quot;));</span>
<span class="line-modified">1210             } else if (signerNotExpired) {</span>





1211                 if (expireDate != null) {
1212                     warnings.add(String.format(
1213                             rb.getString(&quot;The.timestamp.expired.1.but.usable.2&quot;),
1214                             tsaExpireDate,
1215                             expireDate));
1216                 }
1217                 // Reset the flag so exit code is 0
1218                 hasExpiredTsaCert = false;
1219             }
<a name="22" id="anc22"></a><span class="line-modified">1220         }</span>
<span class="line-modified">1221 </span>
<span class="line-modified">1222         if (hasExpiringCert) {</span>
<span class="line-modified">1223             warnings.add(isSigning</span>
<span class="line-modified">1224                     ? rb.getString(&quot;The.signer.certificate.will.expire.within.six.months.&quot;)</span>
<span class="line-modified">1225                     : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.will.expire.within.six.months.&quot;));</span>
<span class="line-modified">1226         }</span>
<span class="line-modified">1227 </span>
<span class="line-modified">1228         if (hasExpiringTsaCert &amp;&amp; expireDate != null) {</span>
<span class="line-modified">1229             if (expireDate.after(tsaExpireDate)) {</span>
<span class="line-modified">1230                 warnings.add(String.format(rb.getString(</span>
<span class="line-modified">1231                         &quot;The.timestamp.will.expire.within.one.year.on.1.but.2&quot;), tsaExpireDate, expireDate));</span>
<span class="line-modified">1232             } else {</span>
<span class="line-modified">1233                 warnings.add(String.format(rb.getString(</span>
<span class="line-modified">1234                         &quot;The.timestamp.will.expire.within.one.year.on.1&quot;), tsaExpireDate));</span>









1235             }
<a name="23" id="anc23"></a><span class="line-modified">1236         }</span>
<span class="line-modified">1237 </span>
<span class="line-added">1238         if (noTimestamp &amp;&amp; expireDate != null) {</span>
<span class="line-added">1239             if (hasTimestampBlock) {</span>
<span class="line-added">1240                 warnings.add(String.format(isSigning</span>
<span class="line-added">1241                         ? rb.getString(&quot;invalid.timestamp.signing&quot;)</span>
<span class="line-added">1242                         : rb.getString(&quot;bad.timestamp.verifying&quot;), expireDate));</span>
<span class="line-added">1243             } else {</span>
<span class="line-added">1244                 warnings.add(String.format(isSigning</span>
<span class="line-added">1245                         ? rb.getString(&quot;no.timestamp.signing&quot;)</span>
<span class="line-added">1246                         : rb.getString(&quot;no.timestamp.verifying&quot;), expireDate));</span>
1247             }
1248         }
1249 
<a name="24" id="anc24"></a><span class="line-added">1250         if (permsDetected) {</span>
<span class="line-added">1251             warnings.add(rb.getString(&quot;posix.attributes.detected&quot;));</span>
<span class="line-added">1252         }</span>
<span class="line-added">1253 </span>
<span class="line-added">1254         if ((strict) &amp;&amp; (!errors.isEmpty())) {</span>
<span class="line-added">1255             result = isSigning</span>
<span class="line-added">1256                     ? rb.getString(&quot;jar.signed.with.signer.errors.&quot;)</span>
<span class="line-added">1257                     : rb.getString(&quot;jar.verified.with.signer.errors.&quot;);</span>
<span class="line-added">1258         } else {</span>
<span class="line-added">1259             result = isSigning</span>
<span class="line-added">1260                     ? rb.getString(&quot;jar.signed.&quot;)</span>
<span class="line-added">1261                     : rb.getString(&quot;jar.verified.&quot;);</span>
<span class="line-added">1262         }</span>
1263         System.out.println(result);
<a name="25" id="anc25"></a><span class="line-added">1264 </span>
1265         if (strict) {
1266             if (!errors.isEmpty()) {
1267                 System.out.println();
1268                 System.out.println(rb.getString(&quot;Error.&quot;));
1269                 errors.forEach(System.out::println);
1270             }
1271             if (!warnings.isEmpty()) {
1272                 System.out.println();
1273                 System.out.println(rb.getString(&quot;Warning.&quot;));
1274                 warnings.forEach(System.out::println);
1275             }
1276         } else {
1277             if (!errors.isEmpty() || !warnings.isEmpty()) {
1278                 System.out.println();
1279                 System.out.println(rb.getString(&quot;Warning.&quot;));
1280                 errors.forEach(System.out::println);
1281                 warnings.forEach(System.out::println);
1282             }
1283         }
<a name="26" id="anc26"></a><span class="line-added">1284 </span>
1285         if (!isSigning &amp;&amp; (!errors.isEmpty() || !warnings.isEmpty())) {
1286             if (! (verbose != null &amp;&amp; showcerts)) {
1287                 System.out.println();
1288                 System.out.println(rb.getString(
1289                         &quot;Re.run.with.the.verbose.and.certs.options.for.more.details.&quot;));
1290             }
1291         }
1292 
1293         if (isSigning || verbose != null) {
1294             // Always print out expireDate, unless expired or expiring.
1295             if (!hasExpiringCert &amp;&amp; !hasExpiredCert
1296                     &amp;&amp; expireDate != null &amp;&amp; signerNotExpired) {
1297                 info.add(String.format(rb.getString(
1298                         &quot;The.signer.certificate.will.expire.on.1.&quot;), expireDate));
1299             }
1300             if (!noTimestamp) {
1301                 if (!hasExpiringTsaCert &amp;&amp; !hasExpiredTsaCert &amp;&amp; tsaExpireDate != null) {
1302                     if (signerNotExpired) {
1303                         info.add(String.format(rb.getString(
1304                                 &quot;The.timestamp.will.expire.on.1.&quot;), tsaExpireDate));
1305                     } else {
1306                         info.add(String.format(rb.getString(
1307                                 &quot;signer.cert.expired.1.but.timestamp.good.2.&quot;),
1308                                 expireDate,
1309                                 tsaExpireDate));
1310                     }
1311                 }
1312             }
1313         }
1314 
1315         if (!info.isEmpty()) {
1316             System.out.println();
1317             info.forEach(System.out::println);
1318         }
1319     }
1320 
1321     private String verifyWithWeak(String alg, Set&lt;CryptoPrimitive&gt; primitiveSet, boolean tsa) {
1322         if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {
1323             if (LEGACY_CHECK.permits(primitiveSet, alg, null)) {
1324                 return alg;
1325             } else {
1326                 if (primitiveSet == SIG_PRIMITIVE_SET) {
1327                    legacyAlg |= 2;
1328                    legacySigAlg = alg;
1329                 } else {
1330                     if (tsa) {
1331                         legacyAlg |= 4;
1332                         legacyTsaDigestAlg = alg;
1333                     } else {
1334                         legacyAlg |= 1;
1335                         legacyDigestAlg = alg;
1336                     }
1337                 }
1338                 return String.format(rb.getString(&quot;with.weak&quot;), alg);
1339             }
1340         } else {
1341             disabledAlgFound = true;
1342             return String.format(rb.getString(&quot;with.disabled&quot;), alg);
1343         }
1344     }
1345 
1346     private String verifyWithWeak(PublicKey key) {
1347         int kLen = KeyUtil.getKeySize(key);
1348         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1349             if (LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1350                 if (kLen &gt;= 0) {
1351                     return String.format(rb.getString(&quot;key.bit&quot;), kLen);
1352                 } else {
1353                     return rb.getString(&quot;unknown.size&quot;);
1354                 }
1355             } else {
1356                 weakPublicKey = key;
1357                 legacyAlg |= 8;
1358                 return String.format(rb.getString(&quot;key.bit.weak&quot;), kLen);
1359             }
1360         } else {
1361            disabledAlgFound = true;
1362            return String.format(rb.getString(&quot;key.bit.disabled&quot;), kLen);
1363         }
1364     }
1365 
1366     private void checkWeakSign(String alg, Set&lt;CryptoPrimitive&gt; primitiveSet, boolean tsa) {
1367         if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {
1368             if (!LEGACY_CHECK.permits(primitiveSet, alg, null)) {
1369                 if (primitiveSet == SIG_PRIMITIVE_SET) {
1370                    legacyAlg |= 2;
1371                 } else {
1372                     if (tsa) {
1373                         legacyAlg |= 4;
1374                     } else {
1375                         legacyAlg |= 1;
1376                     }
1377                 }
1378             }
1379         } else {
1380            if (primitiveSet == SIG_PRIMITIVE_SET) {
1381                disabledAlg |= 2;
1382            } else {
1383                if (tsa) {
1384                    disabledAlg |= 4;
1385                } else {
1386                    disabledAlg |= 1;
1387                }
1388            }
1389         }
1390     }
1391 
1392     private void checkWeakSign(PrivateKey key) {
1393         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1394             if (!LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1395                 legacyAlg |= 8;
1396             }
1397         } else {
1398             disabledAlg |= 8;
1399         }
1400     }
1401 
1402     private static MessageFormat validityTimeForm = null;
1403     private static MessageFormat notYetTimeForm = null;
1404     private static MessageFormat expiredTimeForm = null;
1405     private static MessageFormat expiringTimeForm = null;
1406 
1407     /**
1408      * Returns a string about a certificate:
1409      *
1410      * [&lt;tab&gt;] &lt;cert-type&gt; [&quot;, &quot; &lt;subject-DN&gt;] [&quot; (&quot; &lt;keystore-entry-alias&gt; &quot;)&quot;]
1411      * [&lt;validity-period&gt; | &lt;expiry-warning&gt;]
1412      * [&lt;key-usage-warning&gt;]
1413      *
1414      * Note: no newline character at the end.
1415      *
1416      * This method sets global flags like hasExpiringCert, hasExpiredCert,
1417      * notYetValidCert, badKeyUsage, badExtendedKeyUsage, badNetscapeCertType,
1418      * hasExpiringTsaCert, hasExpiredTsaCert.
1419      *
1420      * @param isTsCert true if c is in the TSA cert chain, false otherwise.
1421      * @param checkUsage true to check code signer keyUsage
1422      */
1423     String printCert(boolean isTsCert, String tab, Certificate c,
1424         Date timestamp, boolean checkUsage) throws Exception {
1425 
1426         StringBuilder certStr = new StringBuilder();
1427         String space = rb.getString(&quot;SPACE&quot;);
1428         X509Certificate x509Cert = null;
1429 
1430         if (c instanceof X509Certificate) {
1431             x509Cert = (X509Certificate) c;
1432             certStr.append(tab).append(x509Cert.getType())
1433                 .append(rb.getString(&quot;COMMA&quot;))
1434                 .append(x509Cert.getSubjectDN().getName());
1435         } else {
1436             certStr.append(tab).append(c.getType());
1437         }
1438 
1439         String alias = storeHash.get(c);
1440         if (alias != null) {
1441             certStr.append(space).append(&quot;(&quot;).append(alias).append(&quot;)&quot;);
1442         }
1443 
1444         if (x509Cert != null) {
1445 
1446             certStr.append(&quot;\n&quot;).append(tab).append(&quot;[&quot;);
1447 
1448             if (trustedCerts.contains(x509Cert)) {
1449                 certStr.append(rb.getString(&quot;trusted.certificate&quot;));
1450             } else {
1451                 Date notAfter = x509Cert.getNotAfter();
1452                 try {
1453                     boolean printValidity = true;
1454                     if (isTsCert) {
1455                         if (tsaExpireDate == null || tsaExpireDate.after(notAfter)) {
1456                             tsaExpireDate = notAfter;
1457                         }
1458                     } else {
1459                         if (expireDate == null || expireDate.after(notAfter)) {
1460                             expireDate = notAfter;
1461                         }
1462                     }
1463                     if (timestamp == null) {
1464                         x509Cert.checkValidity();
1465                         // test if cert will expire within six months (or one year for tsa)
1466                         long age = isTsCert ? ONE_YEAR : SIX_MONTHS;
1467                         if (notAfter.getTime() &lt; System.currentTimeMillis() + age) {
1468                             if (isTsCert) {
1469                                 hasExpiringTsaCert = true;
1470                             } else {
1471                                 hasExpiringCert = true;
1472                             }
1473                             if (expiringTimeForm == null) {
1474                                 expiringTimeForm = new MessageFormat(
1475                                         rb.getString(&quot;certificate.will.expire.on&quot;));
1476                             }
1477                             Object[] source = {notAfter};
1478                             certStr.append(expiringTimeForm.format(source));
1479                             printValidity = false;
1480                         }
1481                     } else {
1482                         x509Cert.checkValidity(timestamp);
1483                     }
1484                     if (printValidity) {
1485                         if (validityTimeForm == null) {
1486                             validityTimeForm = new MessageFormat(
1487                                     rb.getString(&quot;certificate.is.valid.from&quot;));
1488                         }
1489                         Object[] source = {x509Cert.getNotBefore(), notAfter};
1490                         certStr.append(validityTimeForm.format(source));
1491                     }
1492                 } catch (CertificateExpiredException cee) {
1493                     if (isTsCert) {
1494                         hasExpiredTsaCert = true;
1495                     } else {
1496                         hasExpiredCert = true;
1497                     }
1498 
1499                     if (expiredTimeForm == null) {
1500                         expiredTimeForm = new MessageFormat(
1501                                 rb.getString(&quot;certificate.expired.on&quot;));
1502                     }
1503                     Object[] source = {notAfter};
1504                     certStr.append(expiredTimeForm.format(source));
1505 
1506                 } catch (CertificateNotYetValidException cnyve) {
1507                     if (!isTsCert) notYetValidCert = true;
1508 
1509                     if (notYetTimeForm == null) {
1510                         notYetTimeForm = new MessageFormat(
1511                                 rb.getString(&quot;certificate.is.not.valid.until&quot;));
1512                     }
1513                     Object[] source = {x509Cert.getNotBefore()};
1514                     certStr.append(notYetTimeForm.format(source));
1515                 }
1516             }
1517             certStr.append(&quot;]&quot;);
1518 
1519             if (checkUsage) {
1520                 boolean[] bad = new boolean[3];
1521                 checkCertUsage(x509Cert, bad);
1522                 if (bad[0] || bad[1] || bad[2]) {
1523                     String x = &quot;&quot;;
1524                     if (bad[0]) {
1525                         x =&quot;KeyUsage&quot;;
1526                     }
1527                     if (bad[1]) {
1528                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1529                         x = x + &quot;ExtendedKeyUsage&quot;;
1530                     }
1531                     if (bad[2]) {
1532                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1533                         x = x + &quot;NetscapeCertType&quot;;
1534                     }
1535                     certStr.append(&quot;\n&quot;).append(tab)
1536                         .append(MessageFormat.format(rb.getString(
1537                         &quot;.{0}.extension.does.not.support.code.signing.&quot;), x));
1538                 }
1539             }
1540         }
1541         return certStr.toString();
1542     }
1543 
1544     private static MessageFormat signTimeForm = null;
1545 
1546     private String printTimestamp(String tab, Timestamp timestamp) {
1547 
1548         if (signTimeForm == null) {
1549             signTimeForm =
1550                 new MessageFormat(rb.getString(&quot;entry.was.signed.on&quot;));
1551         }
1552         Object[] source = { timestamp.getTimestamp() };
1553 
1554         return new StringBuilder().append(tab).append(&quot;[&quot;)
1555             .append(signTimeForm.format(source)).append(&quot;]&quot;).toString();
1556     }
1557 
1558     private Map&lt;CodeSigner,Integer&gt; cacheForInKS = new IdentityHashMap&lt;&gt;();
1559 
1560     private int inKeyStoreForOneSigner(CodeSigner signer) {
1561         if (cacheForInKS.containsKey(signer)) {
1562             return cacheForInKS.get(signer);
1563         }
1564 
1565         int result = 0;
1566         if (store != null) {
1567             try {
1568                 List&lt;? extends Certificate&gt; certs =
1569                         signer.getSignerCertPath().getCertificates();
1570                 for (Certificate c : certs) {
1571                     String alias = storeHash.get(c);
1572                     if (alias == null) {
1573                         alias = store.getCertificateAlias(c);
1574                         if (alias != null) {
1575                             storeHash.put(c, alias);
1576                         }
1577                     }
1578                     if (alias != null) {
1579                         result |= IN_KEYSTORE;
1580                     }
1581                     for (String ckalias : ckaliases) {
1582                         if (c.equals(store.getCertificate(ckalias))) {
1583                             result |= SIGNED_BY_ALIAS;
1584                             // must continue with next certificate c and cannot
1585                             // return or break outer loop because has to fill
1586                             // storeHash for printCert
1587                             break;
1588                         }
1589                     }
1590                 }
1591             } catch (KeyStoreException kse) {
1592                 // never happens, because keystore has been loaded
1593             }
1594         }
1595         cacheForInKS.put(signer, result);
1596         return result;
1597     }
1598 
1599     /**
1600      * Maps certificates (as keys) to alias names associated in the keystore
1601      * {@link #store} (as values).
1602      */
1603     Hashtable&lt;Certificate, String&gt; storeHash = new Hashtable&lt;&gt;();
1604 
1605     int inKeyStore(CodeSigner[] signers) {
1606 
1607         if (signers == null)
1608             return 0;
1609 
1610         int output = 0;
1611 
1612         for (CodeSigner signer: signers) {
1613             int result = inKeyStoreForOneSigner(signer);
1614             output |= result;
1615         }
1616         if (ckaliases.size() &gt; 0 &amp;&amp; (output &amp; SIGNED_BY_ALIAS) == 0) {
1617             output |= NOT_ALIAS;
1618         }
1619         return output;
1620     }
1621 
1622     void signJar(String jarName, String alias)
1623             throws Exception {
1624 
1625         if (digestalg == null) {
1626             digestalg = JarSigner.Builder.getDefaultDigestAlgorithm();
1627         }
1628         checkWeakSign(digestalg, DIGEST_PRIMITIVE_SET, false);
1629 
1630         if (tSADigestAlg == null) {
1631             tSADigestAlg = JarSigner.Builder.getDefaultDigestAlgorithm();
1632         }
1633         checkWeakSign(tSADigestAlg, DIGEST_PRIMITIVE_SET, true);
1634 
1635         if (sigalg == null) {
1636             sigalg = JarSigner.Builder.getDefaultSignatureAlgorithm(privateKey);
1637         }
1638         checkWeakSign(sigalg, SIG_PRIMITIVE_SET, false);
1639 
1640         checkWeakSign(privateKey);
1641 
1642         boolean aliasUsed = false;
1643         X509Certificate tsaCert = null;
1644 
1645         if (sigfile == null) {
1646             sigfile = alias;
1647             aliasUsed = true;
1648         }
1649 
1650         if (sigfile.length() &gt; 8) {
1651             sigfile = sigfile.substring(0, 8).toUpperCase(Locale.ENGLISH);
1652         } else {
1653             sigfile = sigfile.toUpperCase(Locale.ENGLISH);
1654         }
1655 
1656         StringBuilder tmpSigFile = new StringBuilder(sigfile.length());
1657         for (int j = 0; j &lt; sigfile.length(); j++) {
1658             char c = sigfile.charAt(j);
1659             if (!
1660                     ((c&gt;= &#39;A&#39; &amp;&amp; c&lt;= &#39;Z&#39;) ||
1661                             (c&gt;= &#39;0&#39; &amp;&amp; c&lt;= &#39;9&#39;) ||
1662                             (c == &#39;-&#39;) ||
1663                             (c == &#39;_&#39;))) {
1664                 if (aliasUsed) {
1665                     // convert illegal characters from the alias to be _&#39;s
1666                     c = &#39;_&#39;;
1667                 } else {
1668                     throw new
1669                             RuntimeException(rb.getString
1670                             (&quot;signature.filename.must.consist.of.the.following.characters.A.Z.0.9.or.&quot;));
1671                 }
1672             }
1673             tmpSigFile.append(c);
1674         }
1675 
1676         sigfile = tmpSigFile.toString();
1677 
1678         String tmpJarName;
1679         if (signedjar == null) tmpJarName = jarName+&quot;.sig&quot;;
1680         else tmpJarName = signedjar;
1681 
1682         File jarFile = new File(jarName);
1683         File signedJarFile = new File(tmpJarName);
1684 
1685         // Open the jar (zip) file
1686         try {
1687             zipFile = new ZipFile(jarName);
1688         } catch (IOException ioe) {
1689             error(rb.getString(&quot;unable.to.open.jar.file.&quot;)+jarName, ioe);
1690         }
1691 
1692         CertPath cp = CertificateFactory.getInstance(&quot;X.509&quot;)
1693                 .generateCertPath(Arrays.asList(certChain));
1694         JarSigner.Builder builder = new JarSigner.Builder(privateKey, cp);
1695 
1696         if (verbose != null) {
1697             builder.eventHandler((action, file) -&gt; {
1698                 switch (action) {
1699                     case &quot;signing&quot;:
1700                         System.out.println(rb.getString(&quot;.signing.&quot;) + file);
1701                         break;
1702                     case &quot;adding&quot;:
1703                         System.out.println(rb.getString(&quot;.adding.&quot;) + file);
1704                         break;
1705                     case &quot;updating&quot;:
1706                         System.out.println(rb.getString(&quot;.updating.&quot;) + file);
1707                         break;
1708                     default:
1709                         throw new IllegalArgumentException(&quot;unknown action: &quot;
1710                                 + action);
1711                 }
1712             });
1713         }
1714 
1715         if (digestalg != null) {
1716             builder.digestAlgorithm(digestalg);
1717         }
1718         if (sigalg != null) {
1719             builder.signatureAlgorithm(sigalg);
1720         }
1721 
1722         URI tsaURI = null;
1723 
1724         if (tsaUrl != null) {
1725             tsaURI = new URI(tsaUrl);
1726         } else if (tsaAlias != null) {
1727             tsaCert = getTsaCert(tsaAlias);
1728             tsaURI = TimestampedSigner.getTimestampingURI(tsaCert);
1729         }
1730 
1731         if (tsaURI != null) {
1732             if (verbose != null) {
1733                 System.out.println(
1734                         rb.getString(&quot;requesting.a.signature.timestamp&quot;));
1735                 if (tsaUrl != null) {
1736                     System.out.println(rb.getString(&quot;TSA.location.&quot;) + tsaUrl);
1737                 } else if (tsaCert != null) {
1738                     System.out.println(rb.getString(&quot;TSA.certificate.&quot;) +
1739                             printCert(true, &quot;&quot;, tsaCert, null, false));
1740                 }
1741             }
1742             builder.tsa(tsaURI);
1743             if (tSADigestAlg != null) {
1744                 builder.setProperty(&quot;tsaDigestAlg&quot;, tSADigestAlg);
1745             }
1746 
1747             if (tSAPolicyID != null) {
1748                 builder.setProperty(&quot;tsaPolicyId&quot;, tSAPolicyID);
1749             }
1750         }
1751 
1752         if (altSignerClass != null) {
1753             builder.setProperty(&quot;altSigner&quot;, altSignerClass);
1754             if (verbose != null) {
1755                 System.out.println(
1756                         rb.getString(&quot;using.an.alternative.signing.mechanism&quot;));
1757             }
1758         }
1759 
1760         if (altSignerClasspath != null) {
1761             builder.setProperty(&quot;altSignerPath&quot;, altSignerClasspath);
1762         }
1763 
1764         builder.signerName(sigfile);
1765 
1766         builder.setProperty(&quot;sectionsOnly&quot;, Boolean.toString(!signManifest));
1767         builder.setProperty(&quot;internalSF&quot;, Boolean.toString(!externalSF));
1768 
1769         FileOutputStream fos = null;
1770         try {
1771             fos = new FileOutputStream(signedJarFile);
1772         } catch (IOException ioe) {
1773             error(rb.getString(&quot;unable.to.create.&quot;)+tmpJarName, ioe);
1774         }
1775 
1776         Throwable failedCause = null;
1777         String failedMessage = null;
1778 
1779         try {
1780             Event.setReportListener(Event.ReporterCategory.POSIXPERMS,
1781                     (t, o) -&gt; permsDetected = true);
1782             builder.build().sign(zipFile, fos);
1783         } catch (JarSignerException e) {
1784             failedCause = e.getCause();
1785             if (failedCause instanceof SocketTimeoutException
1786                     || failedCause instanceof UnknownHostException) {
1787                 // Provide a helpful message when TSA is beyond a firewall
1788                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) +
1789                         rb.getString(&quot;no.response.from.the.Timestamping.Authority.&quot;) +
1790                         &quot;\n  -J-Dhttp.proxyHost=&lt;hostname&gt;&quot; +
1791                         &quot;\n  -J-Dhttp.proxyPort=&lt;portnumber&gt;\n&quot; +
1792                         rb.getString(&quot;or&quot;) +
1793                         &quot;\n  -J-Dhttps.proxyHost=&lt;hostname&gt; &quot; +
1794                         &quot;\n  -J-Dhttps.proxyPort=&lt;portnumber&gt; &quot;;
1795             } else {
1796                 // JarSignerException might have a null cause
1797                 if (failedCause == null) {
1798                     failedCause = e;
1799                 }
1800                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1801             }
1802         } catch (Exception e) {
1803             failedCause = e;
1804             failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1805         } finally {
1806             // close the resources
1807             if (zipFile != null) {
1808                 zipFile.close();
1809                 zipFile = null;
1810             }
1811 
1812             if (fos != null) {
1813                 fos.close();
1814             }
1815 
1816             Event.clearReportListener(Event.ReporterCategory.POSIXPERMS);
1817         }
1818 
1819         if (failedCause != null) {
1820             signedJarFile.delete();
1821             error(failedMessage, failedCause);
1822         }
1823 
1824         if (verbose != null) {
1825             System.out.println();
1826         }
1827 
1828         // The JarSigner API always accepts the timestamp received.
1829         // We need to extract the certs from the signed jar to
1830         // validate it.
1831         try (JarFile check = new JarFile(signedJarFile)) {
1832             PKCS7 p7 = new PKCS7(check.getInputStream(check.getEntry(
1833                     &quot;META-INF/&quot; + sigfile + &quot;.&quot; + privateKey.getAlgorithm())));
1834             Timestamp ts = null;
1835             try {
1836                 SignerInfo si = p7.getSignerInfos()[0];
1837                 if (si.getTsToken() != null) {
1838                     hasTimestampBlock = true;
1839                 }
1840                 ts = si.getTimestamp();
1841             } catch (Exception e) {
1842                 tsaChainNotValidated = true;
1843                 tsaChainNotValidatedReason = e;
1844             }
1845             // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are different
1846             String result = certsAndTSInfo(&quot;&quot;, &quot;    &quot;, Arrays.asList(certChain), ts);
1847             if (verbose != null) {
1848                 System.out.println(result);
1849             }
1850         } catch (Exception e) {
1851             if (debug) {
1852                 e.printStackTrace();
1853             }
1854         }
1855 
1856         if (signedjar == null) {
1857             // attempt an atomic rename. If that fails,
1858             // rename the original jar file, then the signed
1859             // one, then delete the original.
1860             if (!signedJarFile.renameTo(jarFile)) {
1861                 File origJar = new File(jarName+&quot;.orig&quot;);
1862 
1863                 if (jarFile.renameTo(origJar)) {
1864                     if (signedJarFile.renameTo(jarFile)) {
1865                         origJar.delete();
1866                     } else {
1867                         MessageFormat form = new MessageFormat(rb.getString
1868                     (&quot;attempt.to.rename.signedJarFile.to.jarFile.failed&quot;));
1869                         Object[] source = {signedJarFile, jarFile};
1870                         error(form.format(source));
1871                     }
1872                 } else {
1873                     MessageFormat form = new MessageFormat(rb.getString
1874                         (&quot;attempt.to.rename.jarFile.to.origJar.failed&quot;));
1875                     Object[] source = {jarFile, origJar};
1876                     error(form.format(source));
1877                 }
1878             }
1879         }
1880         displayMessagesAndResult(true);
1881     }
1882 
1883     /**
1884      * signature-related files include:
1885      * . META-INF/MANIFEST.MF
1886      * . META-INF/SIG-*
1887      * . META-INF/*.SF
1888      * . META-INF/*.DSA
1889      * . META-INF/*.RSA
1890      * . META-INF/*.EC
1891      */
1892     private boolean signatureRelated(String name) {
1893         return SignatureFileVerifier.isSigningRelated(name);
1894     }
1895 
1896     Map&lt;CodeSigner,String&gt; cacheForSignerInfo = new IdentityHashMap&lt;&gt;();
1897 
1898     /**
1899      * Returns a string of signer info, with a newline at the end.
1900      * Called by verifyJar().
1901      */
1902     private String signerInfo(CodeSigner signer, String tab) throws Exception {
1903         if (cacheForSignerInfo.containsKey(signer)) {
1904             return cacheForSignerInfo.get(signer);
1905         }
1906         List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();
1907         // signing time is only displayed on verification
1908         Timestamp ts = signer.getTimestamp();
1909         String tsLine = &quot;&quot;;
1910         if (ts != null) {
1911             tsLine = printTimestamp(tab, ts) + &quot;\n&quot;;
1912         }
1913         // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are the same.
1914 
1915         String result = certsAndTSInfo(tab, tab, certs, ts);
1916         cacheForSignerInfo.put(signer, tsLine + result);
1917         return result;
1918     }
1919 
1920     /**
1921      * Fills info on certs and timestamp into a StringBuilder, sets
1922      * warning flags (through printCert) and validates cert chains.
1923      *
1924      * @param tab1 spaces before the &quot;&gt;&gt;&gt; Signer&quot; line
1925      * @param tab2 spaces before the other lines
1926      * @param certs the signer cert
1927      * @param ts the timestamp, can be null
1928      * @return the info as a string
1929      */
1930     private String certsAndTSInfo(
1931             String tab1,
1932             String tab2,
1933             List&lt;? extends Certificate&gt; certs, Timestamp ts)
1934             throws Exception {
1935 
1936         Date timestamp;
1937         if (ts != null) {
1938             timestamp = ts.getTimestamp();
1939             noTimestamp = false;
1940         } else {
1941             timestamp = null;
1942         }
1943         // display the certificate(sb). The first one is end-entity cert and
1944         // its KeyUsage should be checked.
1945         boolean first = true;
1946         StringBuilder sb = new StringBuilder();
1947         sb.append(tab1).append(rb.getString(&quot;...Signer&quot;)).append(&#39;\n&#39;);
1948         for (Certificate c : certs) {
1949             sb.append(printCert(false, tab2, c, timestamp, first));
1950             sb.append(&#39;\n&#39;);
1951             first = false;
1952         }
1953         try {
1954             validateCertChain(Validator.VAR_CODE_SIGNING, certs, ts);
1955         } catch (Exception e) {
1956             chainNotValidated = true;
1957             chainNotValidatedReason = e;
1958             sb.append(tab2).append(rb.getString(&quot;.Invalid.certificate.chain.&quot;))
1959                     .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1960         }
1961         if (ts != null) {
1962             sb.append(tab1).append(rb.getString(&quot;...TSA&quot;)).append(&#39;\n&#39;);
1963             for (Certificate c : ts.getSignerCertPath().getCertificates()) {
1964                 sb.append(printCert(true, tab2, c, null, false));
1965                 sb.append(&#39;\n&#39;);
1966             }
1967             try {
1968                 validateCertChain(Validator.VAR_TSA_SERVER,
1969                         ts.getSignerCertPath().getCertificates(), null);
1970             } catch (Exception e) {
1971                 tsaChainNotValidated = true;
1972                 tsaChainNotValidatedReason = e;
1973                 sb.append(tab2).append(rb.getString(&quot;.Invalid.TSA.certificate.chain.&quot;))
1974                         .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1975             }
1976         }
1977         if (certs.size() == 1
1978                 &amp;&amp; KeyStoreUtil.isSelfSigned((X509Certificate)certs.get(0))) {
1979             signerSelfSigned = true;
1980         }
1981 
1982         return sb.toString();
1983     }
1984 
1985     void loadKeyStore(String keyStoreName, boolean prompt) {
1986 
1987         if (!nullStream &amp;&amp; keyStoreName == null) {
1988             keyStoreName = System.getProperty(&quot;user.home&quot;) + File.separator
1989                 + &quot;.keystore&quot;;
1990         }
1991 
1992         try {
1993             try {
1994                 KeyStore caks = KeyStoreUtil.getCacertsKeyStore();
1995                 if (caks != null) {
1996                     Enumeration&lt;String&gt; aliases = caks.aliases();
1997                     while (aliases.hasMoreElements()) {
1998                         String a = aliases.nextElement();
1999                         try {
2000                             trustedCerts.add((X509Certificate)caks.getCertificate(a));
2001                         } catch (Exception e2) {
2002                             // ignore, when a SecretkeyEntry does not include a cert
2003                         }
2004                     }
2005                 }
2006             } catch (Exception e) {
2007                 // Ignore, if cacerts cannot be loaded
2008             }
2009 
2010             if (providerName == null) {
2011                 store = KeyStore.getInstance(storetype);
2012             } else {
2013                 store = KeyStore.getInstance(storetype, providerName);
2014             }
2015 
2016             // Get pass phrase
2017             // XXX need to disable echo; on UNIX, call getpass(char *prompt)Z
2018             // and on NT call ??
2019             if (token &amp;&amp; storepass == null &amp;&amp; !protectedPath
2020                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)) {
2021                 storepass = getPass
2022                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
2023             } else if (!token &amp;&amp; storepass == null &amp;&amp; prompt) {
2024                 storepass = getPass
2025                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
2026             }
2027 
2028             try {
2029                 if (nullStream) {
2030                     store.load(null, storepass);
2031                 } else {
2032                     keyStoreName = keyStoreName.replace(File.separatorChar, &#39;/&#39;);
2033                     URL url = null;
2034                     try {
2035                         url = new URL(keyStoreName);
2036                     } catch (java.net.MalformedURLException e) {
2037                         // try as file
2038                         url = new File(keyStoreName).toURI().toURL();
2039                     }
2040                     InputStream is = null;
2041                     try {
2042                         is = url.openStream();
2043                         store.load(is, storepass);
2044                     } finally {
2045                         if (is != null) {
2046                             is.close();
2047                         }
2048                     }
2049                 }
2050                 Enumeration&lt;String&gt; aliases = store.aliases();
2051                 while (aliases.hasMoreElements()) {
2052                     String a = aliases.nextElement();
2053                     try {
2054                         X509Certificate c = (X509Certificate)store.getCertificate(a);
2055                         // Only add TrustedCertificateEntry and self-signed
2056                         // PrivateKeyEntry
2057                         if (store.isCertificateEntry(a) ||
2058                                 c.getSubjectDN().equals(c.getIssuerDN())) {
2059                             trustedCerts.add(c);
2060                         }
2061                     } catch (Exception e2) {
2062                         // ignore, when a SecretkeyEntry does not include a cert
2063                     }
2064                 }
2065             } finally {
2066                 try {
2067                     pkixParameters = new PKIXBuilderParameters(
2068                             trustedCerts.stream()
2069                                     .map(c -&gt; new TrustAnchor(c, null))
2070                                     .collect(Collectors.toSet()),
2071                             null);
2072 
2073                     if (revocationCheck) {
2074                         Security.setProperty(&quot;ocsp.enable&quot;, &quot;true&quot;);
2075                         System.setProperty(&quot;com.sun.security.enableCRLDP&quot;, &quot;true&quot;);
2076                         Event.setReportListener(Event.ReporterCategory.CRLCHECK,
2077                                 (t, o) -&gt; System.out.println(String.format(rb.getString(t), o)));
2078                     }
2079                     pkixParameters.setRevocationEnabled(revocationCheck);
2080                 } catch (InvalidAlgorithmParameterException ex) {
2081                     // Only if tas is empty
2082                 }
2083             }
2084         } catch (IOException ioe) {
2085             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
2086                                         ioe.getMessage());
2087         } catch (java.security.cert.CertificateException ce) {
2088             throw new RuntimeException(rb.getString(&quot;certificate.exception.&quot;) +
2089                                         ce.getMessage());
2090         } catch (NoSuchProviderException pe) {
2091             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
2092                                         pe.getMessage());
2093         } catch (NoSuchAlgorithmException nsae) {
2094             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
2095                                         nsae.getMessage());
2096         } catch (KeyStoreException kse) {
2097             throw new RuntimeException
2098                 (rb.getString(&quot;unable.to.instantiate.keystore.class.&quot;) +
2099                 kse.getMessage());
2100         }
2101     }
2102 
2103     X509Certificate getTsaCert(String alias) {
2104 
2105         java.security.cert.Certificate cs = null;
2106 
2107         try {
2108             cs = store.getCertificate(alias);
2109         } catch (KeyStoreException kse) {
2110             // this never happens, because keystore has been loaded
2111         }
2112         if (cs == null || (!(cs instanceof X509Certificate))) {
2113             MessageFormat form = new MessageFormat(rb.getString
2114                 (&quot;Certificate.not.found.for.alias.alias.must.reference.a.valid.KeyStore.entry.containing.an.X.509.public.key.certificate.for.the&quot;));
2115             Object[] source = {alias, alias};
2116             error(form.format(source));
2117         }
2118         return (X509Certificate) cs;
2119     }
2120 
2121     /**
2122      * Check if userCert is designed to be a code signer
2123      * @param userCert the certificate to be examined
2124      * @param bad 3 booleans to show if the KeyUsage, ExtendedKeyUsage,
2125      *            NetscapeCertType has codeSigning flag turned on.
2126      *            If null, the class field badKeyUsage, badExtendedKeyUsage,
2127      *            badNetscapeCertType will be set.
2128      */
2129     void checkCertUsage(X509Certificate userCert, boolean[] bad) {
2130 
2131         // Can act as a signer?
2132         // 1. if KeyUsage, then [0:digitalSignature] or
2133         //    [1:nonRepudiation] should be true
2134         // 2. if ExtendedKeyUsage, then should contains ANY or CODE_SIGNING
2135         // 3. if NetscapeCertType, then should contains OBJECT_SIGNING
2136         // 1,2,3 must be true
2137 
2138         if (bad != null) {
2139             bad[0] = bad[1] = bad[2] = false;
2140         }
2141 
2142         boolean[] keyUsage = userCert.getKeyUsage();
2143         if (keyUsage != null) {
2144             keyUsage = Arrays.copyOf(keyUsage, 9);
2145             if (!keyUsage[0] &amp;&amp; !keyUsage[1]) {
2146                 if (bad != null) {
2147                     bad[0] = true;
2148                     badKeyUsage = true;
2149                 }
2150             }
2151         }
2152 
2153         try {
2154             List&lt;String&gt; xKeyUsage = userCert.getExtendedKeyUsage();
2155             if (xKeyUsage != null) {
2156                 if (!xKeyUsage.contains(&quot;2.5.29.37.0&quot;) // anyExtendedKeyUsage
2157                         &amp;&amp; !xKeyUsage.contains(&quot;1.3.6.1.5.5.7.3.3&quot;)) {  // codeSigning
2158                     if (bad != null) {
2159                         bad[1] = true;
2160                         badExtendedKeyUsage = true;
2161                     }
2162                 }
2163             }
2164         } catch (java.security.cert.CertificateParsingException e) {
2165             // shouldn&#39;t happen
2166         }
2167 
2168         try {
2169             // OID_NETSCAPE_CERT_TYPE
2170             byte[] netscapeEx = userCert.getExtensionValue
2171                     (&quot;2.16.840.1.113730.1.1&quot;);
2172             if (netscapeEx != null) {
2173                 DerInputStream in = new DerInputStream(netscapeEx);
2174                 byte[] encoded = in.getOctetString();
2175                 encoded = new DerValue(encoded).getUnalignedBitString()
2176                         .toByteArray();
2177 
2178                 NetscapeCertTypeExtension extn =
2179                         new NetscapeCertTypeExtension(encoded);
2180 
2181                 Boolean val = extn.get(NetscapeCertTypeExtension.OBJECT_SIGNING);
2182                 if (!val) {
2183                     if (bad != null) {
2184                         bad[2] = true;
2185                         badNetscapeCertType = true;
2186                     }
2187                 }
2188             }
2189         } catch (IOException e) {
2190             //
2191         }
2192     }
2193 
2194     // Called by signJar().
2195     void getAliasInfo(String alias) throws Exception {
2196 
2197         Key key = null;
2198 
2199         try {
2200             java.security.cert.Certificate[] cs = null;
2201             if (altCertChain != null) {
2202                 try (FileInputStream fis = new FileInputStream(altCertChain)) {
2203                     cs = CertificateFactory.getInstance(&quot;X.509&quot;).
2204                             generateCertificates(fis).
2205                             toArray(new Certificate[0]);
2206                 } catch (FileNotFoundException ex) {
2207                     error(rb.getString(&quot;File.specified.by.certchain.does.not.exist&quot;));
2208                 } catch (CertificateException | IOException ex) {
2209                     error(rb.getString(&quot;Cannot.restore.certchain.from.file.specified&quot;));
2210                 }
2211             } else {
2212                 try {
2213                     cs = store.getCertificateChain(alias);
2214                 } catch (KeyStoreException kse) {
2215                     // this never happens, because keystore has been loaded
2216                 }
2217             }
2218             if (cs == null || cs.length == 0) {
2219                 if (altCertChain != null) {
2220                     error(rb.getString
2221                             (&quot;Certificate.chain.not.found.in.the.file.specified.&quot;));
2222                 } else {
2223                     MessageFormat form = new MessageFormat(rb.getString
2224                         (&quot;Certificate.chain.not.found.for.alias.alias.must.reference.a.valid.KeyStore.key.entry.containing.a.private.key.and&quot;));
2225                     Object[] source = {alias, alias};
2226                     error(form.format(source));
2227                 }
2228             }
2229 
2230             certChain = new X509Certificate[cs.length];
2231             for (int i=0; i&lt;cs.length; i++) {
2232                 if (!(cs[i] instanceof X509Certificate)) {
2233                     error(rb.getString
2234                         (&quot;found.non.X.509.certificate.in.signer.s.chain&quot;));
2235                 }
2236                 certChain[i] = (X509Certificate)cs[i];
2237             }
2238 
2239             try {
2240                 if (!token &amp;&amp; keypass == null)
2241                     key = store.getKey(alias, storepass);
2242                 else
2243                     key = store.getKey(alias, keypass);
2244             } catch (UnrecoverableKeyException e) {
2245                 if (token) {
2246                     throw e;
2247                 } else if (keypass == null) {
2248                     // Did not work out, so prompt user for key password
2249                     MessageFormat form = new MessageFormat(rb.getString
2250                         (&quot;Enter.key.password.for.alias.&quot;));
2251                     Object[] source = {alias};
2252                     keypass = getPass(form.format(source));
2253                     key = store.getKey(alias, keypass);
2254                 }
2255             }
2256         } catch (NoSuchAlgorithmException e) {
2257             error(e.getMessage());
2258         } catch (UnrecoverableKeyException e) {
2259             error(rb.getString(&quot;unable.to.recover.key.from.keystore&quot;));
2260         } catch (KeyStoreException kse) {
2261             // this never happens, because keystore has been loaded
2262         }
2263 
2264         if (!(key instanceof PrivateKey)) {
2265             MessageFormat form = new MessageFormat(rb.getString
2266                 (&quot;key.associated.with.alias.not.a.private.key&quot;));
2267             Object[] source = {alias};
2268             error(form.format(source));
2269         } else {
2270             privateKey = (PrivateKey)key;
2271         }
2272     }
2273 
2274     void error(String message) {
2275         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2276         System.exit(1);
2277     }
2278 
2279 
2280     void error(String message, Throwable e) {
2281         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2282         if (debug) {
2283             e.printStackTrace();
2284         }
2285         System.exit(1);
2286     }
2287 
2288     /**
2289      * Validates a cert chain.
2290      *
2291      * @param parameter this might be a timestamp
2292      */
2293     void validateCertChain(String variant, List&lt;? extends Certificate&gt; certs,
2294                            Timestamp parameter)
2295             throws Exception {
2296         try {
2297             Validator.getInstance(Validator.TYPE_PKIX,
2298                     variant,
2299                     pkixParameters)
2300                     .validate(certs.toArray(new X509Certificate[certs.size()]),
2301                             null, parameter);
2302         } catch (Exception e) {
2303             if (debug) {
2304                 e.printStackTrace();
2305             }
2306 
2307             // Exception might be dismissed if another warning flag
2308             // is already set by printCert.
2309 
2310             if (variant.equals(Validator.VAR_TSA_SERVER) &amp;&amp;
2311                     e instanceof ValidatorException) {
2312                 // Throw cause if it&#39;s CertPathValidatorException,
2313                 if (e.getCause() != null &amp;&amp;
2314                         e.getCause() instanceof CertPathValidatorException) {
2315                     e = (Exception) e.getCause();
2316                     Throwable t = e.getCause();
2317                     if ((t instanceof CertificateExpiredException &amp;&amp;
2318                             hasExpiredTsaCert)) {
2319                         // we already have hasExpiredTsaCert
2320                         return;
2321                     }
2322                 }
2323             }
2324 
2325             if (variant.equals(Validator.VAR_CODE_SIGNING) &amp;&amp;
2326                     e instanceof ValidatorException) {
2327                 // Throw cause if it&#39;s CertPathValidatorException,
2328                 if (e.getCause() != null &amp;&amp;
2329                         e.getCause() instanceof CertPathValidatorException) {
2330                     e = (Exception) e.getCause();
2331                     Throwable t = e.getCause();
2332                     if ((t instanceof CertificateExpiredException &amp;&amp;
2333                                 hasExpiredCert) ||
2334                             (t instanceof CertificateNotYetValidException &amp;&amp;
2335                                     notYetValidCert)) {
2336                         // we already have hasExpiredCert and notYetValidCert
2337                         return;
2338                     }
2339                 }
2340                 if (e instanceof ValidatorException) {
2341                     ValidatorException ve = (ValidatorException)e;
2342                     if (ve.getErrorType() == ValidatorException.T_EE_EXTENSIONS &amp;&amp;
2343                             (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType)) {
2344                         // We already have badKeyUsage, badExtendedKeyUsage
2345                         // and badNetscapeCertType
2346                         return;
2347                     }
2348                 }
2349             }
2350             throw e;
2351         }
2352     }
2353 
2354     char[] getPass(String prompt) {
2355         System.err.print(prompt);
2356         System.err.flush();
2357         try {
2358             char[] pass = Password.readPassword(System.in);
2359 
2360             if (pass == null) {
2361                 error(rb.getString(&quot;you.must.enter.key.password&quot;));
2362             } else {
2363                 return pass;
2364             }
2365         } catch (IOException ioe) {
2366             error(rb.getString(&quot;unable.to.read.password.&quot;)+ioe.getMessage());
2367         }
2368         // this shouldn&#39;t happen
2369         return null;
2370     }
2371 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>