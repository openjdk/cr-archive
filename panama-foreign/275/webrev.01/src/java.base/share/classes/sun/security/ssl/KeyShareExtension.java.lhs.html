<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.security.GeneralSecurityException;
 31 import java.text.MessageFormat;
 32 import java.util.Arrays;
 33 import java.util.Collections;
<a name="1" id="anc1"></a>
 34 import java.util.LinkedList;
 35 import java.util.List;
<a name="2" id="anc2"></a>
 36 import java.util.Locale;
 37 import java.util.Map;
 38 import javax.net.ssl.SSLProtocolException;
 39 import sun.security.ssl.KeyShareExtension.CHKeyShareSpec;
<a name="3" id="anc3"></a>
 40 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 41 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 42 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 43 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 44 import sun.security.util.HexDumpEncoder;
 45 
 46 /**
 47  * Pack of the &quot;key_share&quot; extensions.
 48  */
 49 final class KeyShareExtension {
 50     static final HandshakeProducer chNetworkProducer =
 51             new CHKeyShareProducer();
 52     static final ExtensionConsumer chOnLoadConsumer =
 53             new CHKeyShareConsumer();
 54     static final HandshakeAbsence chOnTradAbsence =
 55             new CHKeyShareOnTradeAbsence();
 56     static final SSLStringizer chStringizer =
 57             new CHKeyShareStringizer();
 58 
 59     static final HandshakeProducer shNetworkProducer =
 60             new SHKeyShareProducer();
 61     static final ExtensionConsumer shOnLoadConsumer =
 62             new SHKeyShareConsumer();
 63     static final HandshakeAbsence shOnLoadAbsence =
 64             new SHKeyShareAbsence();
 65     static final SSLStringizer shStringizer =
 66             new SHKeyShareStringizer();
 67 
 68     static final HandshakeProducer hrrNetworkProducer =
 69             new HRRKeyShareProducer();
 70     static final ExtensionConsumer hrrOnLoadConsumer =
 71             new HRRKeyShareConsumer();
 72     static final HandshakeProducer hrrNetworkReproducer =
 73             new HRRKeyShareReproducer();
 74     static final SSLStringizer hrrStringizer =
 75             new HRRKeyShareStringizer();
 76 
 77     /**
 78      * The key share entry used in &quot;key_share&quot; extensions.
 79      */
 80     private static final class KeyShareEntry {
 81         final int namedGroupId;
 82         final byte[] keyExchange;
 83 
 84         private KeyShareEntry(int namedGroupId, byte[] keyExchange) {
 85             this.namedGroupId = namedGroupId;
 86             this.keyExchange = keyExchange;
 87         }
 88 
 89         private byte[] getEncoded() {
 90             byte[] buffer = new byte[keyExchange.length + 4];
 91                                             //  2: named group id
 92                                             // +2: key exchange length
 93             ByteBuffer m = ByteBuffer.wrap(buffer);
 94             try {
 95                 Record.putInt16(m, namedGroupId);
 96                 Record.putBytes16(m, keyExchange);
 97             } catch (IOException ioe) {
 98                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 99                     SSLLogger.warning(
100                         &quot;Unlikely IOException&quot;, ioe);
101                 }
102             }
103 
104             return buffer;
105         }
106 
107         private int getEncodedSize() {
108             return keyExchange.length + 4;  //  2: named group id
109                                             // +2: key exchange length
110         }
111 
112         @Override
113         public String toString() {
114             MessageFormat messageFormat = new MessageFormat(
115                 &quot;\n&#39;{&#39;\n&quot; +
116                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
117                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
118                 &quot;{1}\n&quot; +
119                 &quot;  &#39;}&#39;\n&quot; +
120                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
121 
122             HexDumpEncoder hexEncoder = new HexDumpEncoder();
123             Object[] messageFields = {
124                 NamedGroup.nameOf(namedGroupId),
125                 Utilities.indent(hexEncoder.encode(keyExchange), &quot;    &quot;)
126             };
127 
128             return messageFormat.format(messageFields);
129         }
130     }
131 
132     /**
133      * The &quot;key_share&quot; extension in a ClientHello handshake message.
134      */
135     static final class CHKeyShareSpec implements SSLExtensionSpec {
136         final List&lt;KeyShareEntry&gt; clientShares;
137 
138         private CHKeyShareSpec(List&lt;KeyShareEntry&gt; clientShares) {
139             this.clientShares = clientShares;
140         }
141 
142         private CHKeyShareSpec(HandshakeContext handshakeContext,
143                 ByteBuffer buffer) throws IOException {
144             // struct {
145             //      KeyShareEntry client_shares&lt;0..2^16-1&gt;;
146             // } KeyShareClientHello;
147             if (buffer.remaining() &lt; 2) {
148                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
149                         new SSLProtocolException(
150                     &quot;Invalid key_share extension: &quot; +
151                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));
152             }
153 
154             int listLen = Record.getInt16(buffer);
155             if (listLen != buffer.remaining()) {
156                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
157                         new SSLProtocolException(
158                     &quot;Invalid key_share extension: &quot; +
159                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;));
160             }
161 
162             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
163             while (buffer.hasRemaining()) {
164                 int namedGroupId = Record.getInt16(buffer);
165                 byte[] keyExchange = Record.getBytes16(buffer);
166                 if (keyExchange.length == 0) {
167                     throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
168                             new SSLProtocolException(
169                         &quot;Invalid key_share extension: empty key_exchange&quot;));
170                 }
171 
172                 keyShares.add(new KeyShareEntry(namedGroupId, keyExchange));
173             }
174 
175             this.clientShares = Collections.unmodifiableList(keyShares);
176         }
177 
178         @Override
179         public String toString() {
180             MessageFormat messageFormat = new MessageFormat(
181                 &quot;\&quot;client_shares\&quot;: &#39;[&#39;{0}\n&#39;]&#39;&quot;, Locale.ENGLISH);
182 
183             StringBuilder builder = new StringBuilder(512);
184             for (KeyShareEntry entry : clientShares) {
185                 builder.append(entry.toString());
186             }
187 
188             Object[] messageFields = {
189                 Utilities.indent(builder.toString())
190             };
191 
192             return messageFormat.format(messageFields);
193         }
194     }
195 
196     private static final class CHKeyShareStringizer implements SSLStringizer {
197         @Override
198         public String toString(
199                 HandshakeContext handshakeContext, ByteBuffer buffer) {
200             try {
201                 return (new CHKeyShareSpec(handshakeContext, buffer)).toString();
202             } catch (IOException ioe) {
203                 // For debug logging only, so please swallow exceptions.
204                 return ioe.getMessage();
205             }
206         }
207     }
208 
209     /**
210      * Network data producer of the extension in a ClientHello
211      * handshake message.
212      */
213     private static final
214             class CHKeyShareProducer implements HandshakeProducer {
215         // Prevent instantiation of this class.
216         private CHKeyShareProducer() {
217             // blank
218         }
219 
220         @Override
221         public byte[] produce(ConnectionContext context,
222                 HandshakeMessage message) throws IOException {
223             // The producing happens in client side only.
224             ClientHandshakeContext chc = (ClientHandshakeContext)context;
225 
226             // Is it a supported and enabled extension?
227             if (!chc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
228                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
229                     SSLLogger.fine(
230                         &quot;Ignore unavailable key_share extension&quot;);
231                 }
232                 return null;
233             }
234 
235             List&lt;NamedGroup&gt; namedGroups;
236             if (chc.serverSelectedNamedGroup != null) {
237                 // Response to HelloRetryRequest
238                 namedGroups = Arrays.asList(chc.serverSelectedNamedGroup);
239             } else {
240                 namedGroups = chc.clientRequestedNamedGroups;
241                 if (namedGroups == null || namedGroups.isEmpty()) {
242                     // No supported groups.
243                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
244                         SSLLogger.warning(
245                             &quot;Ignore key_share extension, no supported groups&quot;);
246                     }
247                     return null;
248                 }
249             }
250 
<a name="4" id="anc4"></a>


251             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
<a name="5" id="anc5"></a>


252             for (NamedGroup ng : namedGroups) {
<a name="6" id="anc6"></a><span class="line-modified">253                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);</span>
<span class="line-modified">254                 if (ke == null) {</span>
<span class="line-modified">255                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-modified">256                         SSLLogger.warning(</span>
<span class="line-modified">257                             &quot;No key exchange for named group &quot; + ng.name);</span>
<span class="line-modified">258                     }</span>
<span class="line-modified">259                     continue;</span>
<span class="line-modified">260                 }</span>
<span class="line-removed">261 </span>
<span class="line-removed">262                 SSLPossession[] poses = ke.createPossessions(chc);</span>
<span class="line-removed">263                 for (SSLPossession pos : poses) {</span>
<span class="line-removed">264                     // update the context</span>
<span class="line-removed">265                     chc.handshakePossessions.add(pos);</span>
<span class="line-removed">266                     if (!(pos instanceof NamedGroupPossession)) {</span>
<span class="line-removed">267                         // May need more possesion types in the future.</span>
<span class="line-removed">268                         continue;</span>
269                     }
<a name="7" id="anc7"></a><span class="line-removed">270 </span>
<span class="line-removed">271                     keyShares.add(new KeyShareEntry(ng.id, pos.encode()));</span>
<span class="line-removed">272                 }</span>
<span class="line-removed">273 </span>
<span class="line-removed">274                 // One key share entry only.  Too much key share entries makes</span>
<span class="line-removed">275                 // the ClientHello handshake message really big.</span>
<span class="line-removed">276                 if (!keyShares.isEmpty()) {</span>
<span class="line-removed">277                     break;</span>
278                 }
279             }
280 
281             int listLen = 0;
282             for (KeyShareEntry entry : keyShares) {
283                 listLen += entry.getEncodedSize();
284             }
285             byte[] extData = new byte[listLen + 2];     //  2: list length
286             ByteBuffer m = ByteBuffer.wrap(extData);
287             Record.putInt16(m, listLen);
288             for (KeyShareEntry entry : keyShares) {
289                 m.put(entry.getEncoded());
290             }
291 
292             // update the context
293             chc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE,
294                     new CHKeyShareSpec(keyShares));
295 
296             return extData;
297         }
<a name="8" id="anc8"></a>






















298     }
299 
300     /**
301      * Network data consumer of the extension in a ClientHello
302      * handshake message.
303      */
304     private static final class CHKeyShareConsumer implements ExtensionConsumer {
305         // Prevent instantiation of this class.
306         private CHKeyShareConsumer() {
307             // blank
308         }
309 
310         @Override
311         public void consume(ConnectionContext context,
312             HandshakeMessage message, ByteBuffer buffer) throws IOException {
313             // The consuming happens in server side only.
314             ServerHandshakeContext shc = (ServerHandshakeContext)context;
315 
316             if (shc.handshakeExtensions.containsKey(SSLExtension.CH_KEY_SHARE)) {
317                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
318                     SSLLogger.fine(
319                             &quot;The key_share extension has been loaded&quot;);
320                 }
321                 return;
322             }
323 
324             // Is it a supported and enabled extension?
325             if (!shc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
326                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
327                     SSLLogger.fine(
328                             &quot;Ignore unavailable key_share extension&quot;);
329                 }
330                 return;     // ignore the extension
331             }
332 
333             // Parse the extension
334             CHKeyShareSpec spec = new CHKeyShareSpec(shc, buffer);
335             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
336             for (KeyShareEntry entry : spec.clientShares) {
337                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
338                 if (ng == null || !SupportedGroups.isActivatable(
339                         shc.algorithmConstraints, ng)) {
340                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
341                         SSLLogger.fine(
342                                 &quot;Ignore unsupported named group: &quot; +
343                                 NamedGroup.nameOf(entry.namedGroupId));
344                     }
345                     continue;
346                 }
347 
348                 try {
349                     SSLCredentials kaCred =
350                         ng.decodeCredentials(entry.keyExchange,
351                         shc.algorithmConstraints,
352                         s -&gt; SSLLogger.warning(s));
353                     if (kaCred != null) {
354                         credentials.add(kaCred);
355                     }
356                 } catch (GeneralSecurityException ex) {
357                     SSLLogger.warning(
358                         &quot;Cannot decode named group: &quot; +
359                         NamedGroup.nameOf(entry.namedGroupId));
360                 }
361             }
362 
363             if (!credentials.isEmpty()) {
364                 shc.handshakeCredentials.addAll(credentials);
365             } else {
366                 // New handshake credentials are required from the client side.
367                 shc.handshakeProducers.put(
368                         SSLHandshake.HELLO_RETRY_REQUEST.id,
369                         SSLHandshake.HELLO_RETRY_REQUEST);
370             }
371 
372             // update the context
373             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
374         }
375     }
376 
377     /**
378      * The absence processing if the extension is not present in
379      * a ClientHello handshake message.
380      */
381     private static final class CHKeyShareOnTradeAbsence
382             implements HandshakeAbsence {
383         @Override
384         public void absent(ConnectionContext context,
385                 HandshakeMessage message) throws IOException {
386             // The producing happens in server side only.
387             ServerHandshakeContext shc = (ServerHandshakeContext)context;
388 
389             // A client is considered to be attempting to negotiate using this
390             // specification if the ClientHello contains a &quot;supported_versions&quot;
391             // extension with 0x0304 contained in its body.  Such a ClientHello
392             // message MUST meet the following requirements:
393             //    -  If containing a &quot;supported_groups&quot; extension, it MUST also
394             //       contain a &quot;key_share&quot; extension, and vice versa.  An empty
395             //       KeyShare.client_shares vector is permitted.
396             if (shc.negotiatedProtocol.useTLS13PlusSpec() &amp;&amp;
397                     shc.handshakeExtensions.containsKey(
398                             SSLExtension.CH_SUPPORTED_GROUPS)) {
399                 throw shc.conContext.fatal(Alert.MISSING_EXTENSION,
400                         &quot;No key_share extension to work with &quot; +
401                         &quot;the supported_groups extension&quot;);
402             }
403         }
404     }
405 
406 
407     /**
408      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
409      */
410     static final class SHKeyShareSpec implements SSLExtensionSpec {
411         final KeyShareEntry serverShare;
412 
413         SHKeyShareSpec(KeyShareEntry serverShare) {
414             this.serverShare = serverShare;
415         }
416 
417         private SHKeyShareSpec(HandshakeContext handshakeContext,
418                 ByteBuffer buffer) throws IOException {
419             // struct {
420             //      KeyShareEntry server_share;
421             // } KeyShareServerHello;
422             if (buffer.remaining() &lt; 5) {       // 5: minimal server_share
423                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
424                         new SSLProtocolException(
425                     &quot;Invalid key_share extension: &quot; +
426                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));
427             }
428 
429             int namedGroupId = Record.getInt16(buffer);
430             byte[] keyExchange = Record.getBytes16(buffer);
431 
432             if (buffer.hasRemaining()) {
433                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
434                         new SSLProtocolException(
435                     &quot;Invalid key_share extension: unknown extra data&quot;));
436             }
437 
438             this.serverShare = new KeyShareEntry(namedGroupId, keyExchange);
439         }
440 
441         @Override
442         public String toString() {
443             MessageFormat messageFormat = new MessageFormat(
444                 &quot;\&quot;server_share\&quot;: &#39;{&#39;\n&quot; +
445                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
446                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
447                 &quot;{1}\n&quot; +
448                 &quot;  &#39;}&#39;\n&quot; +
449                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
450 
451             HexDumpEncoder hexEncoder = new HexDumpEncoder();
452             Object[] messageFields = {
453                 NamedGroup.nameOf(serverShare.namedGroupId),
454                 Utilities.indent(
455                         hexEncoder.encode(serverShare.keyExchange), &quot;    &quot;)
456             };
457 
458             return messageFormat.format(messageFields);
459         }
460     }
461 
462     private static final class SHKeyShareStringizer implements SSLStringizer {
463         @Override
464         public String toString(HandshakeContext handshakeContext,
465                 ByteBuffer buffer) {
466             try {
467                 return (new SHKeyShareSpec(handshakeContext, buffer)).toString();
468             } catch (IOException ioe) {
469                 // For debug logging only, so please swallow exceptions.
470                 return ioe.getMessage();
471             }
472         }
473     }
474 
475     /**
476      * Network data producer of the extension in a ServerHello
477      * handshake message.
478      */
479     private static final class SHKeyShareProducer implements HandshakeProducer {
480         // Prevent instantiation of this class.
481         private SHKeyShareProducer() {
482             // blank
483         }
484 
485         @Override
486         public byte[] produce(ConnectionContext context,
487                 HandshakeMessage message) throws IOException {
488             // The producing happens in client side only.
489             ServerHandshakeContext shc = (ServerHandshakeContext)context;
490 
491             // In response to key_share request only
492             CHKeyShareSpec kss =
493                     (CHKeyShareSpec)shc.handshakeExtensions.get(
494                             SSLExtension.CH_KEY_SHARE);
495             if (kss == null) {
496                 // Unlikely, no key_share extension requested.
497                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
498                     SSLLogger.warning(
499                             &quot;Ignore, no client key_share extension&quot;);
500                 }
501                 return null;
502             }
503 
504             // Is it a supported and enabled extension?
505             if (!shc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
506                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
507                     SSLLogger.warning(
508                             &quot;Ignore, no available server key_share extension&quot;);
509                 }
510                 return null;
511             }
512 
513             // use requested key share entries
514             if ((shc.handshakeCredentials == null) ||
515                     shc.handshakeCredentials.isEmpty()) {
516                 // Unlikely, HelloRetryRequest should be used ealier.
517                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
518                     SSLLogger.warning(
519                             &quot;No available client key share entries&quot;);
520                 }
521                 return null;
522             }
523 
524             KeyShareEntry keyShare = null;
525             for (SSLCredentials cd : shc.handshakeCredentials) {
526                 NamedGroup ng = null;
527                 if (cd instanceof NamedGroupCredentials) {
528                     NamedGroupCredentials creds = (NamedGroupCredentials)cd;
529                     ng = creds.getNamedGroup();
530                 }
531 
532                 if (ng == null) {
533                     continue;
534                 }
535 
536                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
537                 if (ke == null) {
538                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
539                         SSLLogger.warning(
540                             &quot;No key exchange for named group &quot; + ng.name);
541                     }
542                     continue;
543                 }
544 
545                 SSLPossession[] poses = ke.createPossessions(shc);
546                 for (SSLPossession pos : poses) {
547                     if (!(pos instanceof NamedGroupPossession)) {
548                         // May need more possesion types in the future.
549                         continue;
550                     }
551 
552                     // update the context
553                     shc.handshakeKeyExchange = ke;
554                     shc.handshakePossessions.add(pos);
555                     keyShare = new KeyShareEntry(ng.id, pos.encode());
556                     break;
557                 }
558 
559                 if (keyShare != null) {
560                     for (Map.Entry&lt;Byte, HandshakeProducer&gt; me :
561                             ke.getHandshakeProducers(shc)) {
562                         shc.handshakeProducers.put(
563                                 me.getKey(), me.getValue());
564                     }
565 
566                     // We have got one! Don&#39;t forget to break.
567                     break;
568                 }
569             }
570 
571             if (keyShare == null) {
572                 // Unlikely, HelloRetryRequest should be used instead ealier.
573                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
574                     SSLLogger.warning(
575                             &quot;No available server key_share extension&quot;);
576                 }
577                 return null;
578             }
579 
580             byte[] extData = keyShare.getEncoded();
581 
582             // update the context
583             SHKeyShareSpec spec = new SHKeyShareSpec(keyShare);
584             shc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
585 
586             return extData;
587         }
588     }
589 
590     /**
591      * Network data consumer of the extension in a ServerHello
592      * handshake message.
593      */
594     private static final class SHKeyShareConsumer implements ExtensionConsumer {
595         // Prevent instantiation of this class.
596         private SHKeyShareConsumer() {
597             // blank
598         }
599 
600         @Override
601         public void consume(ConnectionContext context,
602             HandshakeMessage message, ByteBuffer buffer) throws IOException {
603             // Happens in client side only.
604             ClientHandshakeContext chc = (ClientHandshakeContext)context;
605             if (chc.clientRequestedNamedGroups == null ||
606                     chc.clientRequestedNamedGroups.isEmpty()) {
607                 // No supported groups.
608                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
609                         &quot;Unexpected key_share extension in ServerHello&quot;);
610             }
611 
612             // Is it a supported and enabled extension?
613             if (!chc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
614                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
615                         &quot;Unsupported key_share extension in ServerHello&quot;);
616             }
617 
618             // Parse the extension
619             SHKeyShareSpec spec = new SHKeyShareSpec(chc, buffer);
620             KeyShareEntry keyShare = spec.serverShare;
621             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
622             if (ng == null || !SupportedGroups.isActivatable(
623                     chc.algorithmConstraints, ng)) {
624                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
625                         &quot;Unsupported named group: &quot; +
626                         NamedGroup.nameOf(keyShare.namedGroupId));
627             }
628 
629             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
630             if (ke == null) {
631                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
632                         &quot;No key exchange for named group &quot; + ng.name);
633             }
634 
635             SSLCredentials credentials = null;
636             try {
637                 SSLCredentials kaCred = ng.decodeCredentials(
638                     keyShare.keyExchange, chc.algorithmConstraints,
639                     s -&gt; chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, s));
640                 if (kaCred != null) {
641                     credentials = kaCred;
642                 }
643             } catch (GeneralSecurityException ex) {
644                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
645                         &quot;Cannot decode named group: &quot; +
646                         NamedGroup.nameOf(keyShare.namedGroupId));
647             }
648 
649             if (credentials == null) {
650                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
651                         &quot;Unsupported named group: &quot; + ng.name);
652             }
653 
654             // update the context
655             chc.handshakeKeyExchange = ke;
656             chc.handshakeCredentials.add(credentials);
657             chc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
658         }
659     }
660 
661     /**
662      * The absence processing if the extension is not present in
663      * the ServerHello handshake message.
664      */
665     private static final class SHKeyShareAbsence implements HandshakeAbsence {
666         @Override
667         public void absent(ConnectionContext context,
668                 HandshakeMessage message) throws IOException {
669             // The producing happens in client side only.
670             ClientHandshakeContext chc = (ClientHandshakeContext)context;
671 
672             // Cannot use the previous requested key shares any more.
673             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
674                 SSLLogger.fine(
675                         &quot;No key_share extension in ServerHello, &quot; +
676                         &quot;cleanup the key shares if necessary&quot;);
677             }
678             chc.handshakePossessions.clear();
679         }
680     }
681 
682     /**
683      * The key share entry used in HelloRetryRequest &quot;key_share&quot; extensions.
684      */
685     static final class HRRKeyShareSpec implements SSLExtensionSpec {
686         final int selectedGroup;
687 
688         HRRKeyShareSpec(NamedGroup serverGroup) {
689             this.selectedGroup = serverGroup.id;
690         }
691 
692         private HRRKeyShareSpec(HandshakeContext handshakeContext,
693                 ByteBuffer buffer) throws IOException {
694             // struct {
695             //     NamedGroup selected_group;
696             // } KeyShareHelloRetryRequest;
697             if (buffer.remaining() != 2) {
698                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
699                         new SSLProtocolException(
700                     &quot;Invalid key_share extension: &quot; +
701                     &quot;improper data (length=&quot; + buffer.remaining() + &quot;)&quot;));
702             }
703 
704             this.selectedGroup = Record.getInt16(buffer);
705         }
706 
707         @Override
708         public String toString() {
709             MessageFormat messageFormat = new MessageFormat(
710                 &quot;\&quot;selected group\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
711 
712             Object[] messageFields = {
713                     NamedGroup.nameOf(selectedGroup)
714                 };
715             return messageFormat.format(messageFields);
716         }
717     }
718 
719     private static final class HRRKeyShareStringizer implements SSLStringizer {
720         @Override
721         public String toString(HandshakeContext handshakeContext,
722                 ByteBuffer buffer) {
723             try {
724                 return (new HRRKeyShareSpec(handshakeContext, buffer)).toString();
725             } catch (IOException ioe) {
726                 // For debug logging only, so please swallow exceptions.
727                 return ioe.getMessage();
728             }
729         }
730     }
731 
732     /**
733      * Network data producer of the extension in a HelloRetryRequest
734      * handshake message.
735      */
736     private static final
737             class HRRKeyShareProducer implements HandshakeProducer {
738         // Prevent instantiation of this class.
739         private HRRKeyShareProducer() {
740             // blank
741         }
742 
743         @Override
744         public byte[] produce(ConnectionContext context,
745                 HandshakeMessage message) throws IOException {
746             // The producing happens in server side only.
747             ServerHandshakeContext shc = (ServerHandshakeContext) context;
748 
749             // Is it a supported and enabled extension?
750             if (!shc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
751                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
752                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
753             }
754 
755             if (shc.clientRequestedNamedGroups == null ||
756                     shc.clientRequestedNamedGroups.isEmpty()) {
757                 // No supported groups.
758                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
759                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
760             }
761 
762             NamedGroup selectedGroup = null;
763             for (NamedGroup ng : shc.clientRequestedNamedGroups) {
764                 if (SupportedGroups.isActivatable(
765                         shc.algorithmConstraints, ng)) {
766                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
767                         SSLLogger.fine(
768                                 &quot;HelloRetryRequest selected named group: &quot; +
769                                 ng.name);
770                     }
771 
772                     selectedGroup = ng;
773                     break;
774                 }
775             }
776 
777             if (selectedGroup == null) {
778                 throw shc.conContext.fatal(
779                         Alert.UNEXPECTED_MESSAGE, &quot;No common named group&quot;);
780             }
781 
782             byte[] extdata = new byte[] {
783                     (byte)((selectedGroup.id &gt;&gt; 8) &amp; 0xFF),
784                     (byte)(selectedGroup.id &amp; 0xFF)
785                 };
786 
787             // update the context
788             shc.serverSelectedNamedGroup = selectedGroup;
789             shc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE,
790                     new HRRKeyShareSpec(selectedGroup));
791 
792             return extdata;
793         }
794     }
795 
796     /**
797      * Network data producer of the extension for stateless
798      * HelloRetryRequest reconstruction.
799      */
800     private static final
801             class HRRKeyShareReproducer implements HandshakeProducer {
802         // Prevent instantiation of this class.
803         private HRRKeyShareReproducer() {
804             // blank
805         }
806 
807         @Override
808         public byte[] produce(ConnectionContext context,
809                 HandshakeMessage message) throws IOException {
810             // The producing happens in server side only.
811             ServerHandshakeContext shc = (ServerHandshakeContext) context;
812 
813             // Is it a supported and enabled extension?
814             if (!shc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
815                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
816                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
817             }
818 
819             CHKeyShareSpec spec = (CHKeyShareSpec)shc.handshakeExtensions.get(
820                     SSLExtension.CH_KEY_SHARE);
821             if (spec != null &amp;&amp; spec.clientShares != null &amp;&amp;
822                     spec.clientShares.size() == 1) {
823                 int namedGroupId = spec.clientShares.get(0).namedGroupId;
824 
825                 byte[] extdata = new byte[] {
826                         (byte)((namedGroupId &gt;&gt; 8) &amp; 0xFF),
827                         (byte)(namedGroupId &amp; 0xFF)
828                     };
829 
830                 return extdata;
831             }
832 
833             return null;
834         }
835     }
836 
837     /**
838      * Network data consumer of the extension in a HelloRetryRequest
839      * handshake message.
840      */
841     private static final
842             class HRRKeyShareConsumer implements ExtensionConsumer {
843         // Prevent instantiation of this class.
844         private HRRKeyShareConsumer() {
845             // blank
846         }
847 
848         @Override
849         public void consume(ConnectionContext context,
850             HandshakeMessage message, ByteBuffer buffer) throws IOException {
851             // The producing happens in client side only.
852             ClientHandshakeContext chc = (ClientHandshakeContext)context;
853 
854             // Is it a supported and enabled extension?
855             if (!chc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
856                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
857                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
858             }
859 
860             if (chc.clientRequestedNamedGroups == null ||
861                     chc.clientRequestedNamedGroups.isEmpty()) {
862                 // No supported groups.
863                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
864                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
865             }
866 
867             // Parse the extension
868             HRRKeyShareSpec spec = new HRRKeyShareSpec(chc, buffer);
869             NamedGroup serverGroup = NamedGroup.valueOf(spec.selectedGroup);
870             if (serverGroup == null) {
871                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
872                         &quot;Unsupported HelloRetryRequest selected group: &quot; +
873                                 NamedGroup.nameOf(spec.selectedGroup));
874             }
875 
<a name="9" id="anc9"></a>





876             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
877                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
878                         &quot;Unexpected HelloRetryRequest selected group: &quot; +
879                                 serverGroup.name);
880             }
<a name="10" id="anc10"></a>















881 
882             // update the context
883 
884             // When sending the new ClientHello, the client MUST replace the
885             // original &quot;key_share&quot; extension with one containing only a new
886             // KeyShareEntry for the group indicated in the selected_group
887             // field of the triggering HelloRetryRequest.
888             //
889             chc.serverSelectedNamedGroup = serverGroup;
890             chc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE, spec);
891         }
892     }
893 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>