<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.security.GeneralSecurityException;
 31 import java.text.MessageFormat;
 32 import java.util.Arrays;
 33 import java.util.Collections;
<a name="1" id="anc1"></a><span class="line-added"> 34 import java.util.EnumSet;</span>
 35 import java.util.LinkedList;
 36 import java.util.List;
<a name="2" id="anc2"></a><span class="line-added"> 37 import java.util.ListIterator;</span>
 38 import java.util.Locale;
 39 import java.util.Map;
 40 import javax.net.ssl.SSLProtocolException;
 41 import sun.security.ssl.KeyShareExtension.CHKeyShareSpec;
<a name="3" id="anc3"></a><span class="line-added"> 42 import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>
 43 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 44 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 45 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 46 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 47 import sun.security.util.HexDumpEncoder;
 48 
 49 /**
 50  * Pack of the &quot;key_share&quot; extensions.
 51  */
 52 final class KeyShareExtension {
 53     static final HandshakeProducer chNetworkProducer =
 54             new CHKeyShareProducer();
 55     static final ExtensionConsumer chOnLoadConsumer =
 56             new CHKeyShareConsumer();
 57     static final HandshakeAbsence chOnTradAbsence =
 58             new CHKeyShareOnTradeAbsence();
 59     static final SSLStringizer chStringizer =
 60             new CHKeyShareStringizer();
 61 
 62     static final HandshakeProducer shNetworkProducer =
 63             new SHKeyShareProducer();
 64     static final ExtensionConsumer shOnLoadConsumer =
 65             new SHKeyShareConsumer();
 66     static final HandshakeAbsence shOnLoadAbsence =
 67             new SHKeyShareAbsence();
 68     static final SSLStringizer shStringizer =
 69             new SHKeyShareStringizer();
 70 
 71     static final HandshakeProducer hrrNetworkProducer =
 72             new HRRKeyShareProducer();
 73     static final ExtensionConsumer hrrOnLoadConsumer =
 74             new HRRKeyShareConsumer();
 75     static final HandshakeProducer hrrNetworkReproducer =
 76             new HRRKeyShareReproducer();
 77     static final SSLStringizer hrrStringizer =
 78             new HRRKeyShareStringizer();
 79 
 80     /**
 81      * The key share entry used in &quot;key_share&quot; extensions.
 82      */
 83     private static final class KeyShareEntry {
 84         final int namedGroupId;
 85         final byte[] keyExchange;
 86 
 87         private KeyShareEntry(int namedGroupId, byte[] keyExchange) {
 88             this.namedGroupId = namedGroupId;
 89             this.keyExchange = keyExchange;
 90         }
 91 
 92         private byte[] getEncoded() {
 93             byte[] buffer = new byte[keyExchange.length + 4];
 94                                             //  2: named group id
 95                                             // +2: key exchange length
 96             ByteBuffer m = ByteBuffer.wrap(buffer);
 97             try {
 98                 Record.putInt16(m, namedGroupId);
 99                 Record.putBytes16(m, keyExchange);
100             } catch (IOException ioe) {
101                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
102                     SSLLogger.warning(
103                         &quot;Unlikely IOException&quot;, ioe);
104                 }
105             }
106 
107             return buffer;
108         }
109 
110         private int getEncodedSize() {
111             return keyExchange.length + 4;  //  2: named group id
112                                             // +2: key exchange length
113         }
114 
115         @Override
116         public String toString() {
117             MessageFormat messageFormat = new MessageFormat(
118                 &quot;\n&#39;{&#39;\n&quot; +
119                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
120                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
121                 &quot;{1}\n&quot; +
122                 &quot;  &#39;}&#39;\n&quot; +
123                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
124 
125             HexDumpEncoder hexEncoder = new HexDumpEncoder();
126             Object[] messageFields = {
127                 NamedGroup.nameOf(namedGroupId),
128                 Utilities.indent(hexEncoder.encode(keyExchange), &quot;    &quot;)
129             };
130 
131             return messageFormat.format(messageFields);
132         }
133     }
134 
135     /**
136      * The &quot;key_share&quot; extension in a ClientHello handshake message.
137      */
138     static final class CHKeyShareSpec implements SSLExtensionSpec {
139         final List&lt;KeyShareEntry&gt; clientShares;
140 
141         private CHKeyShareSpec(List&lt;KeyShareEntry&gt; clientShares) {
142             this.clientShares = clientShares;
143         }
144 
145         private CHKeyShareSpec(HandshakeContext handshakeContext,
146                 ByteBuffer buffer) throws IOException {
147             // struct {
148             //      KeyShareEntry client_shares&lt;0..2^16-1&gt;;
149             // } KeyShareClientHello;
150             if (buffer.remaining() &lt; 2) {
151                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
152                         new SSLProtocolException(
153                     &quot;Invalid key_share extension: &quot; +
154                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));
155             }
156 
157             int listLen = Record.getInt16(buffer);
158             if (listLen != buffer.remaining()) {
159                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
160                         new SSLProtocolException(
161                     &quot;Invalid key_share extension: &quot; +
162                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;));
163             }
164 
165             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
166             while (buffer.hasRemaining()) {
167                 int namedGroupId = Record.getInt16(buffer);
168                 byte[] keyExchange = Record.getBytes16(buffer);
169                 if (keyExchange.length == 0) {
170                     throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
171                             new SSLProtocolException(
172                         &quot;Invalid key_share extension: empty key_exchange&quot;));
173                 }
174 
175                 keyShares.add(new KeyShareEntry(namedGroupId, keyExchange));
176             }
177 
178             this.clientShares = Collections.unmodifiableList(keyShares);
179         }
180 
181         @Override
182         public String toString() {
183             MessageFormat messageFormat = new MessageFormat(
184                 &quot;\&quot;client_shares\&quot;: &#39;[&#39;{0}\n&#39;]&#39;&quot;, Locale.ENGLISH);
185 
186             StringBuilder builder = new StringBuilder(512);
187             for (KeyShareEntry entry : clientShares) {
188                 builder.append(entry.toString());
189             }
190 
191             Object[] messageFields = {
192                 Utilities.indent(builder.toString())
193             };
194 
195             return messageFormat.format(messageFields);
196         }
197     }
198 
199     private static final class CHKeyShareStringizer implements SSLStringizer {
200         @Override
201         public String toString(
202                 HandshakeContext handshakeContext, ByteBuffer buffer) {
203             try {
204                 return (new CHKeyShareSpec(handshakeContext, buffer)).toString();
205             } catch (IOException ioe) {
206                 // For debug logging only, so please swallow exceptions.
207                 return ioe.getMessage();
208             }
209         }
210     }
211 
212     /**
213      * Network data producer of the extension in a ClientHello
214      * handshake message.
215      */
216     private static final
217             class CHKeyShareProducer implements HandshakeProducer {
218         // Prevent instantiation of this class.
219         private CHKeyShareProducer() {
220             // blank
221         }
222 
223         @Override
224         public byte[] produce(ConnectionContext context,
225                 HandshakeMessage message) throws IOException {
226             // The producing happens in client side only.
227             ClientHandshakeContext chc = (ClientHandshakeContext)context;
228 
229             // Is it a supported and enabled extension?
230             if (!chc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
231                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
232                     SSLLogger.fine(
233                         &quot;Ignore unavailable key_share extension&quot;);
234                 }
235                 return null;
236             }
237 
238             List&lt;NamedGroup&gt; namedGroups;
239             if (chc.serverSelectedNamedGroup != null) {
240                 // Response to HelloRetryRequest
241                 namedGroups = Arrays.asList(chc.serverSelectedNamedGroup);
242             } else {
243                 namedGroups = chc.clientRequestedNamedGroups;
244                 if (namedGroups == null || namedGroups.isEmpty()) {
245                     // No supported groups.
246                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
247                         SSLLogger.warning(
248                             &quot;Ignore key_share extension, no supported groups&quot;);
249                     }
250                     return null;
251                 }
252             }
253 
<a name="4" id="anc4"></a><span class="line-added">254             // Go through the named groups and take the most-preferred</span>
<span class="line-added">255             // group from two categories (i.e. XDH and ECDHE).  Once we have</span>
<span class="line-added">256             // the most preferred group from two types we can exit the loop.</span>
257             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
<a name="5" id="anc5"></a><span class="line-added">258             EnumSet&lt;NamedGroupSpec&gt; ngTypes =</span>
<span class="line-added">259                     EnumSet.noneOf(NamedGroupSpec.class);</span>
<span class="line-added">260             byte[] keyExchangeData;</span>
261             for (NamedGroup ng : namedGroups) {
<a name="6" id="anc6"></a><span class="line-modified">262                 if (!ngTypes.contains(ng.spec)) {</span>
<span class="line-modified">263                     if ((keyExchangeData = getShare(chc, ng)) != null) {</span>
<span class="line-modified">264                         keyShares.add(new KeyShareEntry(ng.id,</span>
<span class="line-modified">265                                 keyExchangeData));</span>
<span class="line-modified">266                         ngTypes.add(ng.spec);</span>
<span class="line-modified">267                         if (ngTypes.size() == 2) {</span>
<span class="line-modified">268                             break;</span>
<span class="line-modified">269                         }</span>








270                     }
<a name="7" id="anc7"></a>







271                 }
272             }
273 
274             int listLen = 0;
275             for (KeyShareEntry entry : keyShares) {
276                 listLen += entry.getEncodedSize();
277             }
278             byte[] extData = new byte[listLen + 2];     //  2: list length
279             ByteBuffer m = ByteBuffer.wrap(extData);
280             Record.putInt16(m, listLen);
281             for (KeyShareEntry entry : keyShares) {
282                 m.put(entry.getEncoded());
283             }
284 
285             // update the context
286             chc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE,
287                     new CHKeyShareSpec(keyShares));
288 
289             return extData;
290         }
<a name="8" id="anc8"></a><span class="line-added">291 </span>
<span class="line-added">292         private static byte[] getShare(ClientHandshakeContext chc,</span>
<span class="line-added">293                 NamedGroup ng) {</span>
<span class="line-added">294             byte[] share = null;</span>
<span class="line-added">295             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);</span>
<span class="line-added">296             if (ke == null) {</span>
<span class="line-added">297                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">298                     SSLLogger.warning(</span>
<span class="line-added">299                         &quot;No key exchange for named group &quot; + ng.name);</span>
<span class="line-added">300                 }</span>
<span class="line-added">301             } else {</span>
<span class="line-added">302                 SSLPossession[] poses = ke.createPossessions(chc);</span>
<span class="line-added">303                 for (SSLPossession pos : poses) {</span>
<span class="line-added">304                     // update the context</span>
<span class="line-added">305                     chc.handshakePossessions.add(pos);</span>
<span class="line-added">306                     // May need more possesion types in the future.</span>
<span class="line-added">307                     if (pos instanceof NamedGroupPossession) {</span>
<span class="line-added">308                         return pos.encode();</span>
<span class="line-added">309                     }</span>
<span class="line-added">310                 }</span>
<span class="line-added">311             }</span>
<span class="line-added">312             return share;</span>
<span class="line-added">313         }</span>
314     }
315 
316     /**
317      * Network data consumer of the extension in a ClientHello
318      * handshake message.
319      */
320     private static final class CHKeyShareConsumer implements ExtensionConsumer {
321         // Prevent instantiation of this class.
322         private CHKeyShareConsumer() {
323             // blank
324         }
325 
326         @Override
327         public void consume(ConnectionContext context,
328             HandshakeMessage message, ByteBuffer buffer) throws IOException {
329             // The consuming happens in server side only.
330             ServerHandshakeContext shc = (ServerHandshakeContext)context;
331 
332             if (shc.handshakeExtensions.containsKey(SSLExtension.CH_KEY_SHARE)) {
333                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
334                     SSLLogger.fine(
335                             &quot;The key_share extension has been loaded&quot;);
336                 }
337                 return;
338             }
339 
340             // Is it a supported and enabled extension?
341             if (!shc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
342                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
343                     SSLLogger.fine(
344                             &quot;Ignore unavailable key_share extension&quot;);
345                 }
346                 return;     // ignore the extension
347             }
348 
349             // Parse the extension
350             CHKeyShareSpec spec = new CHKeyShareSpec(shc, buffer);
351             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
352             for (KeyShareEntry entry : spec.clientShares) {
353                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
354                 if (ng == null || !SupportedGroups.isActivatable(
355                         shc.algorithmConstraints, ng)) {
356                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
357                         SSLLogger.fine(
358                                 &quot;Ignore unsupported named group: &quot; +
359                                 NamedGroup.nameOf(entry.namedGroupId));
360                     }
361                     continue;
362                 }
363 
364                 try {
365                     SSLCredentials kaCred =
366                         ng.decodeCredentials(entry.keyExchange,
367                         shc.algorithmConstraints,
368                         s -&gt; SSLLogger.warning(s));
369                     if (kaCred != null) {
370                         credentials.add(kaCred);
371                     }
372                 } catch (GeneralSecurityException ex) {
373                     SSLLogger.warning(
374                         &quot;Cannot decode named group: &quot; +
375                         NamedGroup.nameOf(entry.namedGroupId));
376                 }
377             }
378 
379             if (!credentials.isEmpty()) {
380                 shc.handshakeCredentials.addAll(credentials);
381             } else {
382                 // New handshake credentials are required from the client side.
383                 shc.handshakeProducers.put(
384                         SSLHandshake.HELLO_RETRY_REQUEST.id,
385                         SSLHandshake.HELLO_RETRY_REQUEST);
386             }
387 
388             // update the context
389             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
390         }
391     }
392 
393     /**
394      * The absence processing if the extension is not present in
395      * a ClientHello handshake message.
396      */
397     private static final class CHKeyShareOnTradeAbsence
398             implements HandshakeAbsence {
399         @Override
400         public void absent(ConnectionContext context,
401                 HandshakeMessage message) throws IOException {
402             // The producing happens in server side only.
403             ServerHandshakeContext shc = (ServerHandshakeContext)context;
404 
405             // A client is considered to be attempting to negotiate using this
406             // specification if the ClientHello contains a &quot;supported_versions&quot;
407             // extension with 0x0304 contained in its body.  Such a ClientHello
408             // message MUST meet the following requirements:
409             //    -  If containing a &quot;supported_groups&quot; extension, it MUST also
410             //       contain a &quot;key_share&quot; extension, and vice versa.  An empty
411             //       KeyShare.client_shares vector is permitted.
412             if (shc.negotiatedProtocol.useTLS13PlusSpec() &amp;&amp;
413                     shc.handshakeExtensions.containsKey(
414                             SSLExtension.CH_SUPPORTED_GROUPS)) {
415                 throw shc.conContext.fatal(Alert.MISSING_EXTENSION,
416                         &quot;No key_share extension to work with &quot; +
417                         &quot;the supported_groups extension&quot;);
418             }
419         }
420     }
421 
422 
423     /**
424      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
425      */
426     static final class SHKeyShareSpec implements SSLExtensionSpec {
427         final KeyShareEntry serverShare;
428 
429         SHKeyShareSpec(KeyShareEntry serverShare) {
430             this.serverShare = serverShare;
431         }
432 
433         private SHKeyShareSpec(HandshakeContext handshakeContext,
434                 ByteBuffer buffer) throws IOException {
435             // struct {
436             //      KeyShareEntry server_share;
437             // } KeyShareServerHello;
438             if (buffer.remaining() &lt; 5) {       // 5: minimal server_share
439                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
440                         new SSLProtocolException(
441                     &quot;Invalid key_share extension: &quot; +
442                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));
443             }
444 
445             int namedGroupId = Record.getInt16(buffer);
446             byte[] keyExchange = Record.getBytes16(buffer);
447 
448             if (buffer.hasRemaining()) {
449                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
450                         new SSLProtocolException(
451                     &quot;Invalid key_share extension: unknown extra data&quot;));
452             }
453 
454             this.serverShare = new KeyShareEntry(namedGroupId, keyExchange);
455         }
456 
457         @Override
458         public String toString() {
459             MessageFormat messageFormat = new MessageFormat(
460                 &quot;\&quot;server_share\&quot;: &#39;{&#39;\n&quot; +
461                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
462                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
463                 &quot;{1}\n&quot; +
464                 &quot;  &#39;}&#39;\n&quot; +
465                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
466 
467             HexDumpEncoder hexEncoder = new HexDumpEncoder();
468             Object[] messageFields = {
469                 NamedGroup.nameOf(serverShare.namedGroupId),
470                 Utilities.indent(
471                         hexEncoder.encode(serverShare.keyExchange), &quot;    &quot;)
472             };
473 
474             return messageFormat.format(messageFields);
475         }
476     }
477 
478     private static final class SHKeyShareStringizer implements SSLStringizer {
479         @Override
480         public String toString(HandshakeContext handshakeContext,
481                 ByteBuffer buffer) {
482             try {
483                 return (new SHKeyShareSpec(handshakeContext, buffer)).toString();
484             } catch (IOException ioe) {
485                 // For debug logging only, so please swallow exceptions.
486                 return ioe.getMessage();
487             }
488         }
489     }
490 
491     /**
492      * Network data producer of the extension in a ServerHello
493      * handshake message.
494      */
495     private static final class SHKeyShareProducer implements HandshakeProducer {
496         // Prevent instantiation of this class.
497         private SHKeyShareProducer() {
498             // blank
499         }
500 
501         @Override
502         public byte[] produce(ConnectionContext context,
503                 HandshakeMessage message) throws IOException {
504             // The producing happens in client side only.
505             ServerHandshakeContext shc = (ServerHandshakeContext)context;
506 
507             // In response to key_share request only
508             CHKeyShareSpec kss =
509                     (CHKeyShareSpec)shc.handshakeExtensions.get(
510                             SSLExtension.CH_KEY_SHARE);
511             if (kss == null) {
512                 // Unlikely, no key_share extension requested.
513                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
514                     SSLLogger.warning(
515                             &quot;Ignore, no client key_share extension&quot;);
516                 }
517                 return null;
518             }
519 
520             // Is it a supported and enabled extension?
521             if (!shc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
522                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
523                     SSLLogger.warning(
524                             &quot;Ignore, no available server key_share extension&quot;);
525                 }
526                 return null;
527             }
528 
529             // use requested key share entries
530             if ((shc.handshakeCredentials == null) ||
531                     shc.handshakeCredentials.isEmpty()) {
532                 // Unlikely, HelloRetryRequest should be used ealier.
533                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
534                     SSLLogger.warning(
535                             &quot;No available client key share entries&quot;);
536                 }
537                 return null;
538             }
539 
540             KeyShareEntry keyShare = null;
541             for (SSLCredentials cd : shc.handshakeCredentials) {
542                 NamedGroup ng = null;
543                 if (cd instanceof NamedGroupCredentials) {
544                     NamedGroupCredentials creds = (NamedGroupCredentials)cd;
545                     ng = creds.getNamedGroup();
546                 }
547 
548                 if (ng == null) {
549                     continue;
550                 }
551 
552                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
553                 if (ke == null) {
554                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
555                         SSLLogger.warning(
556                             &quot;No key exchange for named group &quot; + ng.name);
557                     }
558                     continue;
559                 }
560 
561                 SSLPossession[] poses = ke.createPossessions(shc);
562                 for (SSLPossession pos : poses) {
563                     if (!(pos instanceof NamedGroupPossession)) {
564                         // May need more possesion types in the future.
565                         continue;
566                     }
567 
568                     // update the context
569                     shc.handshakeKeyExchange = ke;
570                     shc.handshakePossessions.add(pos);
571                     keyShare = new KeyShareEntry(ng.id, pos.encode());
572                     break;
573                 }
574 
575                 if (keyShare != null) {
576                     for (Map.Entry&lt;Byte, HandshakeProducer&gt; me :
577                             ke.getHandshakeProducers(shc)) {
578                         shc.handshakeProducers.put(
579                                 me.getKey(), me.getValue());
580                     }
581 
582                     // We have got one! Don&#39;t forget to break.
583                     break;
584                 }
585             }
586 
587             if (keyShare == null) {
588                 // Unlikely, HelloRetryRequest should be used instead ealier.
589                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
590                     SSLLogger.warning(
591                             &quot;No available server key_share extension&quot;);
592                 }
593                 return null;
594             }
595 
596             byte[] extData = keyShare.getEncoded();
597 
598             // update the context
599             SHKeyShareSpec spec = new SHKeyShareSpec(keyShare);
600             shc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
601 
602             return extData;
603         }
604     }
605 
606     /**
607      * Network data consumer of the extension in a ServerHello
608      * handshake message.
609      */
610     private static final class SHKeyShareConsumer implements ExtensionConsumer {
611         // Prevent instantiation of this class.
612         private SHKeyShareConsumer() {
613             // blank
614         }
615 
616         @Override
617         public void consume(ConnectionContext context,
618             HandshakeMessage message, ByteBuffer buffer) throws IOException {
619             // Happens in client side only.
620             ClientHandshakeContext chc = (ClientHandshakeContext)context;
621             if (chc.clientRequestedNamedGroups == null ||
622                     chc.clientRequestedNamedGroups.isEmpty()) {
623                 // No supported groups.
624                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
625                         &quot;Unexpected key_share extension in ServerHello&quot;);
626             }
627 
628             // Is it a supported and enabled extension?
629             if (!chc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
630                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
631                         &quot;Unsupported key_share extension in ServerHello&quot;);
632             }
633 
634             // Parse the extension
635             SHKeyShareSpec spec = new SHKeyShareSpec(chc, buffer);
636             KeyShareEntry keyShare = spec.serverShare;
637             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
638             if (ng == null || !SupportedGroups.isActivatable(
639                     chc.algorithmConstraints, ng)) {
640                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
641                         &quot;Unsupported named group: &quot; +
642                         NamedGroup.nameOf(keyShare.namedGroupId));
643             }
644 
645             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
646             if (ke == null) {
647                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
648                         &quot;No key exchange for named group &quot; + ng.name);
649             }
650 
651             SSLCredentials credentials = null;
652             try {
653                 SSLCredentials kaCred = ng.decodeCredentials(
654                     keyShare.keyExchange, chc.algorithmConstraints,
655                     s -&gt; chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, s));
656                 if (kaCred != null) {
657                     credentials = kaCred;
658                 }
659             } catch (GeneralSecurityException ex) {
660                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
661                         &quot;Cannot decode named group: &quot; +
662                         NamedGroup.nameOf(keyShare.namedGroupId));
663             }
664 
665             if (credentials == null) {
666                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
667                         &quot;Unsupported named group: &quot; + ng.name);
668             }
669 
670             // update the context
671             chc.handshakeKeyExchange = ke;
672             chc.handshakeCredentials.add(credentials);
673             chc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
674         }
675     }
676 
677     /**
678      * The absence processing if the extension is not present in
679      * the ServerHello handshake message.
680      */
681     private static final class SHKeyShareAbsence implements HandshakeAbsence {
682         @Override
683         public void absent(ConnectionContext context,
684                 HandshakeMessage message) throws IOException {
685             // The producing happens in client side only.
686             ClientHandshakeContext chc = (ClientHandshakeContext)context;
687 
688             // Cannot use the previous requested key shares any more.
689             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
690                 SSLLogger.fine(
691                         &quot;No key_share extension in ServerHello, &quot; +
692                         &quot;cleanup the key shares if necessary&quot;);
693             }
694             chc.handshakePossessions.clear();
695         }
696     }
697 
698     /**
699      * The key share entry used in HelloRetryRequest &quot;key_share&quot; extensions.
700      */
701     static final class HRRKeyShareSpec implements SSLExtensionSpec {
702         final int selectedGroup;
703 
704         HRRKeyShareSpec(NamedGroup serverGroup) {
705             this.selectedGroup = serverGroup.id;
706         }
707 
708         private HRRKeyShareSpec(HandshakeContext handshakeContext,
709                 ByteBuffer buffer) throws IOException {
710             // struct {
711             //     NamedGroup selected_group;
712             // } KeyShareHelloRetryRequest;
713             if (buffer.remaining() != 2) {
714                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
715                         new SSLProtocolException(
716                     &quot;Invalid key_share extension: &quot; +
717                     &quot;improper data (length=&quot; + buffer.remaining() + &quot;)&quot;));
718             }
719 
720             this.selectedGroup = Record.getInt16(buffer);
721         }
722 
723         @Override
724         public String toString() {
725             MessageFormat messageFormat = new MessageFormat(
726                 &quot;\&quot;selected group\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
727 
728             Object[] messageFields = {
729                     NamedGroup.nameOf(selectedGroup)
730                 };
731             return messageFormat.format(messageFields);
732         }
733     }
734 
735     private static final class HRRKeyShareStringizer implements SSLStringizer {
736         @Override
737         public String toString(HandshakeContext handshakeContext,
738                 ByteBuffer buffer) {
739             try {
740                 return (new HRRKeyShareSpec(handshakeContext, buffer)).toString();
741             } catch (IOException ioe) {
742                 // For debug logging only, so please swallow exceptions.
743                 return ioe.getMessage();
744             }
745         }
746     }
747 
748     /**
749      * Network data producer of the extension in a HelloRetryRequest
750      * handshake message.
751      */
752     private static final
753             class HRRKeyShareProducer implements HandshakeProducer {
754         // Prevent instantiation of this class.
755         private HRRKeyShareProducer() {
756             // blank
757         }
758 
759         @Override
760         public byte[] produce(ConnectionContext context,
761                 HandshakeMessage message) throws IOException {
762             // The producing happens in server side only.
763             ServerHandshakeContext shc = (ServerHandshakeContext) context;
764 
765             // Is it a supported and enabled extension?
766             if (!shc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
767                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
768                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
769             }
770 
771             if (shc.clientRequestedNamedGroups == null ||
772                     shc.clientRequestedNamedGroups.isEmpty()) {
773                 // No supported groups.
774                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
775                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
776             }
777 
778             NamedGroup selectedGroup = null;
779             for (NamedGroup ng : shc.clientRequestedNamedGroups) {
780                 if (SupportedGroups.isActivatable(
781                         shc.algorithmConstraints, ng)) {
782                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
783                         SSLLogger.fine(
784                                 &quot;HelloRetryRequest selected named group: &quot; +
785                                 ng.name);
786                     }
787 
788                     selectedGroup = ng;
789                     break;
790                 }
791             }
792 
793             if (selectedGroup == null) {
794                 throw shc.conContext.fatal(
795                         Alert.UNEXPECTED_MESSAGE, &quot;No common named group&quot;);
796             }
797 
798             byte[] extdata = new byte[] {
799                     (byte)((selectedGroup.id &gt;&gt; 8) &amp; 0xFF),
800                     (byte)(selectedGroup.id &amp; 0xFF)
801                 };
802 
803             // update the context
804             shc.serverSelectedNamedGroup = selectedGroup;
805             shc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE,
806                     new HRRKeyShareSpec(selectedGroup));
807 
808             return extdata;
809         }
810     }
811 
812     /**
813      * Network data producer of the extension for stateless
814      * HelloRetryRequest reconstruction.
815      */
816     private static final
817             class HRRKeyShareReproducer implements HandshakeProducer {
818         // Prevent instantiation of this class.
819         private HRRKeyShareReproducer() {
820             // blank
821         }
822 
823         @Override
824         public byte[] produce(ConnectionContext context,
825                 HandshakeMessage message) throws IOException {
826             // The producing happens in server side only.
827             ServerHandshakeContext shc = (ServerHandshakeContext) context;
828 
829             // Is it a supported and enabled extension?
830             if (!shc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
831                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
832                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
833             }
834 
835             CHKeyShareSpec spec = (CHKeyShareSpec)shc.handshakeExtensions.get(
836                     SSLExtension.CH_KEY_SHARE);
837             if (spec != null &amp;&amp; spec.clientShares != null &amp;&amp;
838                     spec.clientShares.size() == 1) {
839                 int namedGroupId = spec.clientShares.get(0).namedGroupId;
840 
841                 byte[] extdata = new byte[] {
842                         (byte)((namedGroupId &gt;&gt; 8) &amp; 0xFF),
843                         (byte)(namedGroupId &amp; 0xFF)
844                     };
845 
846                 return extdata;
847             }
848 
849             return null;
850         }
851     }
852 
853     /**
854      * Network data consumer of the extension in a HelloRetryRequest
855      * handshake message.
856      */
857     private static final
858             class HRRKeyShareConsumer implements ExtensionConsumer {
859         // Prevent instantiation of this class.
860         private HRRKeyShareConsumer() {
861             // blank
862         }
863 
864         @Override
865         public void consume(ConnectionContext context,
866             HandshakeMessage message, ByteBuffer buffer) throws IOException {
867             // The producing happens in client side only.
868             ClientHandshakeContext chc = (ClientHandshakeContext)context;
869 
870             // Is it a supported and enabled extension?
871             if (!chc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
872                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
873                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
874             }
875 
876             if (chc.clientRequestedNamedGroups == null ||
877                     chc.clientRequestedNamedGroups.isEmpty()) {
878                 // No supported groups.
879                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
880                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
881             }
882 
883             // Parse the extension
884             HRRKeyShareSpec spec = new HRRKeyShareSpec(chc, buffer);
885             NamedGroup serverGroup = NamedGroup.valueOf(spec.selectedGroup);
886             if (serverGroup == null) {
887                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
888                         &quot;Unsupported HelloRetryRequest selected group: &quot; +
889                                 NamedGroup.nameOf(spec.selectedGroup));
890             }
891 
<a name="9" id="anc9"></a><span class="line-added">892             // The server-selected named group from a HelloRetryRequest must</span>
<span class="line-added">893             // meet the following criteria:</span>
<span class="line-added">894             // 1. It must be one of the named groups in the supported_groups</span>
<span class="line-added">895             //    extension in the client hello.</span>
<span class="line-added">896             // 2. It cannot be one of the groups in the key_share extension</span>
<span class="line-added">897             //    from the client hello.</span>
898             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
899                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
900                         &quot;Unexpected HelloRetryRequest selected group: &quot; +
901                                 serverGroup.name);
902             }
<a name="10" id="anc10"></a><span class="line-added">903             CHKeyShareSpec chKsSpec = (CHKeyShareSpec)</span>
<span class="line-added">904                     chc.handshakeExtensions.get(SSLExtension.CH_KEY_SHARE);</span>
<span class="line-added">905             if (chKsSpec != null) {</span>
<span class="line-added">906                 for (KeyShareEntry kse : chKsSpec.clientShares) {</span>
<span class="line-added">907                     if (serverGroup.id == kse.namedGroupId) {</span>
<span class="line-added">908                         throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added">909                                 &quot;Illegal HelloRetryRequest selected group: &quot; +</span>
<span class="line-added">910                                         serverGroup.name);</span>
<span class="line-added">911                     }</span>
<span class="line-added">912                 }</span>
<span class="line-added">913             } else {</span>
<span class="line-added">914                 // Something has gone very wrong if we&#39;re here.</span>
<span class="line-added">915                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-added">916                         &quot;Unable to retrieve ClientHello key_share extension &quot; +</span>
<span class="line-added">917                                 &quot;during HRR processing&quot;);</span>
<span class="line-added">918             }</span>
919 
920             // update the context
921 
922             // When sending the new ClientHello, the client MUST replace the
923             // original &quot;key_share&quot; extension with one containing only a new
924             // KeyShareEntry for the group indicated in the selected_group
925             // field of the triggering HelloRetryRequest.
926             //
927             chc.serverSelectedNamedGroup = serverGroup;
928             chc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE, spec);
929         }
930     }
931 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>