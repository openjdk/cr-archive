<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/javax/crypto/CipherSpi.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.crypto;
  27 
  28 import java.util.StringTokenizer;
  29 import java.util.NoSuchElementException;
  30 import java.security.AlgorithmParameters;
  31 import java.security.Provider;
  32 import java.security.Key;
  33 import java.security.SecureRandom;
  34 import java.security.NoSuchAlgorithmException;
  35 import java.security.NoSuchProviderException;
  36 import java.security.InvalidKeyException;
  37 import java.security.InvalidAlgorithmParameterException;
  38 import java.security.ProviderException;
  39 import java.security.spec.AlgorithmParameterSpec;
  40 
  41 import java.nio.ByteBuffer;
  42 
  43 /**
  44  * This class defines the &lt;i&gt;Service Provider Interface&lt;/i&gt; (&lt;b&gt;SPI&lt;/b&gt;)
  45  * for the &lt;code&gt;Cipher&lt;/code&gt; class.
  46  * All the abstract methods in this class must be implemented by each
  47  * cryptographic service provider who wishes to supply the implementation
  48  * of a particular cipher algorithm.
  49  *
  50  * &lt;p&gt;In order to create an instance of &lt;code&gt;Cipher&lt;/code&gt;, which
  51  * encapsulates an instance of this &lt;code&gt;CipherSpi&lt;/code&gt; class, an
  52  * application calls one of the
  53  * {@link Cipher#getInstance(java.lang.String) getInstance}
  54  * factory methods of the
  55  * {@link Cipher Cipher} engine class and specifies the requested
  56  * &lt;i&gt;transformation&lt;/i&gt;.
  57  * Optionally, the application may also specify the name of a provider.
  58  *
  59  * &lt;p&gt;A &lt;i&gt;transformation&lt;/i&gt; is a string that describes the operation (or
  60  * set of operations) to be performed on the given input, to produce some
  61  * output. A transformation always includes the name of a cryptographic
  62  * algorithm (e.g., &lt;i&gt;AES&lt;/i&gt;), and may be followed by a feedback mode and
  63  * padding scheme.
  64  *
  65  * &lt;p&gt; A transformation is of the form:
  66  *
  67  * &lt;ul&gt;
  68  * &lt;li&gt;&quot;&lt;i&gt;algorithm/mode/padding&lt;/i&gt;&quot; or
  69  *
  70  * &lt;li&gt;&quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;
  71  * &lt;/ul&gt;
  72  *
  73  * &lt;P&gt; (in the latter case,
  74  * provider-specific default values for the mode and padding scheme are used).
  75  * For example, the following is a valid transformation:
  76  *
  77  * &lt;pre&gt;
  78  *     Cipher c = Cipher.getInstance(&quot;&lt;i&gt;AES/CBC/PKCS5Padding&lt;/i&gt;&quot;);
  79  * &lt;/pre&gt;
  80  *
  81  * &lt;p&gt;A provider may supply a separate class for each combination
  82  * of &lt;i&gt;algorithm/mode/padding&lt;/i&gt;, or may decide to provide more generic
  83  * classes representing sub-transformations corresponding to
  84  * &lt;i&gt;algorithm&lt;/i&gt; or &lt;i&gt;algorithm/mode&lt;/i&gt; or &lt;i&gt;algorithm//padding&lt;/i&gt;
  85  * (note the double slashes),
  86  * in which case the requested mode and/or padding are set automatically by
  87  * the &lt;code&gt;getInstance&lt;/code&gt; methods of &lt;code&gt;Cipher&lt;/code&gt;, which invoke
  88  * the {@link #engineSetMode(java.lang.String) engineSetMode} and
  89  * {@link #engineSetPadding(java.lang.String) engineSetPadding}
  90  * methods of the provider&#39;s subclass of &lt;code&gt;CipherSpi&lt;/code&gt;.
  91  *
  92  * &lt;p&gt;A &lt;code&gt;Cipher&lt;/code&gt; property in a provider master class may have one of
  93  * the following formats:
  94  *
  95  * &lt;ul&gt;
  96  *
  97  * &lt;li&gt;
  98  * &lt;pre&gt;
  99  *     // provider&#39;s subclass of &quot;CipherSpi&quot; implements &quot;algName&quot; with
 100  *     // pluggable mode and padding
 101  *     &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;algName&lt;/i&gt;
 102  * &lt;/pre&gt;
 103  *
 104  * &lt;li&gt;
 105  * &lt;pre&gt;
 106  *     // provider&#39;s subclass of &quot;CipherSpi&quot; implements &quot;algName&quot; in the
 107  *     // specified &quot;mode&quot;, with pluggable padding
 108  *     &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;algName/mode&lt;/i&gt;
 109  * &lt;/pre&gt;
 110  *
 111  * &lt;li&gt;
 112  * &lt;pre&gt;
 113  *     // provider&#39;s subclass of &quot;CipherSpi&quot; implements &quot;algName&quot; with the
 114  *     // specified &quot;padding&quot;, with pluggable mode
 115  *     &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;algName//padding&lt;/i&gt;
 116  * &lt;/pre&gt;
 117  *
 118  * &lt;li&gt;
 119  * &lt;pre&gt;
 120  *     // provider&#39;s subclass of &quot;CipherSpi&quot; implements &quot;algName&quot; with the
 121  *     // specified &quot;mode&quot; and &quot;padding&quot;
 122  *     &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;algName/mode/padding&lt;/i&gt;
 123  * &lt;/pre&gt;
 124  *
 125  * &lt;/ul&gt;
 126  *
 127  * &lt;p&gt;For example, a provider may supply a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
 128  * that implements &lt;i&gt;AES/ECB/PKCS5Padding&lt;/i&gt;, one that implements
 129  * &lt;i&gt;AES/CBC/PKCS5Padding&lt;/i&gt;, one that implements
 130  * &lt;i&gt;AES/CFB/PKCS5Padding&lt;/i&gt;, and yet another one that implements
 131  * &lt;i&gt;AES/OFB/PKCS5Padding&lt;/i&gt;. That provider would have the following
 132  * &lt;code&gt;Cipher&lt;/code&gt; properties in its master class:
 133  *
 134  * &lt;ul&gt;
 135  *
 136  * &lt;li&gt;
 137  * &lt;pre&gt;
 138  *     &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;AES/ECB/PKCS5Padding&lt;/i&gt;
 139  * &lt;/pre&gt;
 140  *
 141  * &lt;li&gt;
 142  * &lt;pre&gt;
 143  *     &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;AES/CBC/PKCS5Padding&lt;/i&gt;
 144  * &lt;/pre&gt;
 145  *
 146  * &lt;li&gt;
 147  * &lt;pre&gt;
 148  *     &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;AES/CFB/PKCS5Padding&lt;/i&gt;
 149  * &lt;/pre&gt;
 150  *
 151  * &lt;li&gt;
 152  * &lt;pre&gt;
 153  *     &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;AES/OFB/PKCS5Padding&lt;/i&gt;
 154  * &lt;/pre&gt;
 155  *
 156  * &lt;/ul&gt;
 157  *
 158  * &lt;p&gt;Another provider may implement a class for each of the above modes
 159  * (i.e., one class for &lt;i&gt;ECB&lt;/i&gt;, one for &lt;i&gt;CBC&lt;/i&gt;, one for &lt;i&gt;CFB&lt;/i&gt;,
 160  * and one for &lt;i&gt;OFB&lt;/i&gt;), one class for &lt;i&gt;PKCS5Padding&lt;/i&gt;,
 161  * and a generic &lt;i&gt;AES&lt;/i&gt; class that subclasses from &lt;code&gt;CipherSpi&lt;/code&gt;.
 162  * That provider would have the following
 163  * &lt;code&gt;Cipher&lt;/code&gt; properties in its master class:
 164  *
 165  * &lt;ul&gt;
 166  *
 167  * &lt;li&gt;
 168  * &lt;pre&gt;
 169  *     &lt;code&gt;Cipher.&lt;/code&gt;&lt;i&gt;AES&lt;/i&gt;
 170  * &lt;/pre&gt;
 171  *
 172  * &lt;/ul&gt;
 173  *
 174  * &lt;p&gt;The &lt;code&gt;getInstance&lt;/code&gt; factory method of the &lt;code&gt;Cipher&lt;/code&gt;
 175  * engine class follows these rules in order to instantiate a provider&#39;s
 176  * implementation of &lt;code&gt;CipherSpi&lt;/code&gt; for a
 177  * transformation of the form &quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;:
 178  *
 179  * &lt;ol&gt;
 180  * &lt;li&gt;
 181  * Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
 182  * for the specified &quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;.
 183  * &lt;p&gt;If the answer is YES, instantiate this
 184  * class, for whose mode and padding scheme default values (as supplied by
 185  * the provider) are used.
 186  * &lt;p&gt;If the answer is NO, throw a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt;
 187  * exception.
 188  * &lt;/ol&gt;
 189  *
 190  * &lt;p&gt;The &lt;code&gt;getInstance&lt;/code&gt; factory method of the &lt;code&gt;Cipher&lt;/code&gt;
 191  * engine class follows these rules in order to instantiate a provider&#39;s
 192  * implementation of &lt;code&gt;CipherSpi&lt;/code&gt; for a
 193  * transformation of the form &quot;&lt;i&gt;algorithm/mode/padding&lt;/i&gt;&quot;:
 194  *
 195  * &lt;ol&gt;
 196  * &lt;li&gt;
 197  * Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
 198  * for the specified &quot;&lt;i&gt;algorithm/mode/padding&lt;/i&gt;&quot; transformation.
 199  * &lt;p&gt;If the answer is YES, instantiate it.
 200  * &lt;p&gt;If the answer is NO, go to the next step.
 201  * &lt;li&gt;
 202  * Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
 203  * for the sub-transformation &quot;&lt;i&gt;algorithm/mode&lt;/i&gt;&quot;.
 204  * &lt;p&gt;If the answer is YES, instantiate it, and call
 205  * &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.
 206  * &lt;p&gt;If the answer is NO, go to the next step.
 207  * &lt;li&gt;
 208  * Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
 209  * for the sub-transformation &quot;&lt;i&gt;algorithm//padding&lt;/i&gt;&quot; (note the double
 210  * slashes).
 211  * &lt;p&gt;If the answer is YES, instantiate it, and call
 212  * &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; on the new instance.
 213  * &lt;p&gt;If the answer is NO, go to the next step.
 214  * &lt;li&gt;
 215  * Check if the provider has registered a subclass of &lt;code&gt;CipherSpi&lt;/code&gt;
 216  * for the sub-transformation &quot;&lt;i&gt;algorithm&lt;/i&gt;&quot;.
 217  * &lt;p&gt;If the answer is YES, instantiate it, and call
 218  * &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; and
 219  * &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.
 220  * &lt;p&gt;If the answer is NO, throw a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt;
 221  * exception.
 222  * &lt;/ol&gt;
 223  *
 224  * @author Jan Luehe
 225  * @see KeyGenerator
 226  * @see SecretKey
 227  * @since 1.4
 228  */
 229 
 230 public abstract class CipherSpi {
 231 
 232     /**
 233      * Sets the mode of this cipher.
 234      *
 235      * @param mode the cipher mode
 236      *
 237      * @exception NoSuchAlgorithmException if the requested cipher mode does
 238      * not exist
 239      */
 240     protected abstract void engineSetMode(String mode)
 241         throws NoSuchAlgorithmException;
 242 
 243     /**
 244      * Sets the padding mechanism of this cipher.
 245      *
 246      * @param padding the padding mechanism
 247      *
 248      * @exception NoSuchPaddingException if the requested padding mechanism
 249      * does not exist
 250      */
 251     protected abstract void engineSetPadding(String padding)
 252         throws NoSuchPaddingException;
 253 
 254     /**
 255      * Returns the block size (in bytes).
 256      *
 257      * @return the block size (in bytes), or 0 if the underlying algorithm is
 258      * not a block cipher
 259      */
 260     protected abstract int engineGetBlockSize();
 261 
 262     /**
 263      * Returns the length in bytes that an output buffer would
 264      * need to be in order to hold the result of the next &lt;code&gt;update&lt;/code&gt;
 265      * or &lt;code&gt;doFinal&lt;/code&gt; operation, given the input length
 266      * &lt;code&gt;inputLen&lt;/code&gt; (in bytes).
 267      *
 268      * &lt;p&gt;This call takes into account any unprocessed (buffered) data from a
 269      * previous &lt;code&gt;update&lt;/code&gt; call, padding, and AEAD tagging.
 270      *
 271      * &lt;p&gt;The actual output length of the next &lt;code&gt;update&lt;/code&gt; or
 272      * &lt;code&gt;doFinal&lt;/code&gt; call may be smaller than the length returned by
 273      * this method.
 274      *
 275      * @param inputLen the input length (in bytes)
 276      *
 277      * @return the required output buffer size (in bytes)
 278      */
 279     protected abstract int engineGetOutputSize(int inputLen);
 280 
 281     /**
 282      * Returns the initialization vector (IV) in a new buffer.
 283      *
 284      * &lt;p&gt; This is useful in the context of password-based encryption or
 285      * decryption, where the IV is derived from a user-provided passphrase.
 286      *
 287      * @return the initialization vector in a new buffer, or null if the
 288      * underlying algorithm does not use an IV, or if the IV has not yet
 289      * been set.
 290      */
 291     protected abstract byte[] engineGetIV();
 292 
 293     /**
 294      * Returns the parameters used with this cipher.
 295      *
 296      * &lt;p&gt;The returned parameters may be the same that were used to initialize
 297      * this cipher, or may contain a combination of default and random
 298      * parameter values used by the underlying cipher implementation if this
 299      * cipher requires algorithm parameters but was not initialized with any.
 300      *
 301      * @return the parameters used with this cipher, or null if this cipher
 302      * does not use any parameters.
 303      */
 304     protected abstract AlgorithmParameters engineGetParameters();
 305 
 306     /**
 307      * Initializes this cipher with a key and a source
 308      * of randomness.
 309      *
 310      * &lt;p&gt;The cipher is initialized for one of the following four operations:
 311      * encryption, decryption, key wrapping or key unwrapping, depending on
 312      * the value of &lt;code&gt;opmode&lt;/code&gt;.
 313      *
 314      * &lt;p&gt;If this cipher requires any algorithm parameters that cannot be
 315      * derived from the given &lt;code&gt;key&lt;/code&gt;, the underlying cipher
 316      * implementation is supposed to generate the required parameters itself
 317      * (using provider-specific default or random values) if it is being
 318      * initialized for encryption or key wrapping, and raise an
 319      * &lt;code&gt;InvalidKeyException&lt;/code&gt; if it is being
 320      * initialized for decryption or key unwrapping.
 321      * The generated parameters can be retrieved using
 322      * {@link #engineGetParameters() engineGetParameters} or
 323      * {@link #engineGetIV() engineGetIV} (if the parameter is an IV).
 324      *
 325      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
 326      * derived from the input parameters, and there are no reasonable
 327      * provider-specific default values, initialization will
 328      * necessarily fail.
 329      *
 330      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
 331      * requires any random bytes (e.g., for parameter generation), it will get
 332      * them from &lt;code&gt;random&lt;/code&gt;.
 333      *
 334      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
 335      * previously-acquired state. In other words, initializing a Cipher is
 336      * equivalent to creating a new instance of that Cipher and initializing
 337      * it.
 338      *
 339      * @param opmode the operation mode of this cipher (this is one of
 340      * the following:
 341      * &lt;code&gt;ENCRYPT_MODE&lt;/code&gt;, &lt;code&gt;DECRYPT_MODE&lt;/code&gt;,
 342      * &lt;code&gt;WRAP_MODE&lt;/code&gt; or &lt;code&gt;UNWRAP_MODE&lt;/code&gt;)
 343      * @param key the encryption key
 344      * @param random the source of randomness
 345      *
 346      * @exception InvalidKeyException if the given key is inappropriate for
 347      * initializing this cipher, or requires
 348      * algorithm parameters that cannot be
 349      * determined from the given key.
 350      * @throws UnsupportedOperationException if {@code opmode} is
 351      * {@code WRAP_MODE} or {@code UNWRAP_MODE} is not implemented
 352      * by the cipher.
 353      */
 354     protected abstract void engineInit(int opmode, Key key,
 355                                        SecureRandom random)
 356         throws InvalidKeyException;
 357 
 358     /**
 359      * Initializes this cipher with a key, a set of
 360      * algorithm parameters, and a source of randomness.
 361      *
 362      * &lt;p&gt;The cipher is initialized for one of the following four operations:
 363      * encryption, decryption, key wrapping or key unwrapping, depending on
 364      * the value of &lt;code&gt;opmode&lt;/code&gt;.
 365      *
 366      * &lt;p&gt;If this cipher requires any algorithm parameters and
 367      * &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is
 368      * supposed to generate the required parameters itself (using
 369      * provider-specific default or random values) if it is being
 370      * initialized for encryption or key wrapping, and raise an
 371      * &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being
 372      * initialized for decryption or key unwrapping.
 373      * The generated parameters can be retrieved using
 374      * {@link #engineGetParameters() engineGetParameters} or
 375      * {@link #engineGetIV() engineGetIV} (if the parameter is an IV).
 376      *
 377      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
 378      * derived from the input parameters, and there are no reasonable
 379      * provider-specific default values, initialization will
 380      * necessarily fail.
 381      *
 382      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
 383      * requires any random bytes (e.g., for parameter generation), it will get
 384      * them from &lt;code&gt;random&lt;/code&gt;.
 385      *
 386      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
 387      * previously-acquired state. In other words, initializing a Cipher is
 388      * equivalent to creating a new instance of that Cipher and initializing
 389      * it.
 390      *
 391      * @param opmode the operation mode of this cipher (this is one of
 392      * the following:
 393      * &lt;code&gt;ENCRYPT_MODE&lt;/code&gt;, &lt;code&gt;DECRYPT_MODE&lt;/code&gt;,
 394      * &lt;code&gt;WRAP_MODE&lt;/code&gt; or &lt;code&gt;UNWRAP_MODE&lt;/code&gt;)
 395      * @param key the encryption key
 396      * @param params the algorithm parameters
 397      * @param random the source of randomness
 398      *
 399      * @exception InvalidKeyException if the given key is inappropriate for
 400      * initializing this cipher
 401      * @exception InvalidAlgorithmParameterException if the given algorithm
 402      * parameters are inappropriate for this cipher,
 403      * or if this cipher requires
 404      * algorithm parameters and &lt;code&gt;params&lt;/code&gt; is null.
 405      * @throws UnsupportedOperationException if {@code opmode} is
 406      * {@code WRAP_MODE} or {@code UNWRAP_MODE} is not implemented
 407      * by the cipher.
 408      */
 409     protected abstract void engineInit(int opmode, Key key,
 410                                        AlgorithmParameterSpec params,
 411                                        SecureRandom random)
 412         throws InvalidKeyException, InvalidAlgorithmParameterException;
 413 
 414     /**
 415      * Initializes this cipher with a key, a set of
 416      * algorithm parameters, and a source of randomness.
 417      *
 418      * &lt;p&gt;The cipher is initialized for one of the following four operations:
 419      * encryption, decryption, key wrapping or key unwrapping, depending on
 420      * the value of &lt;code&gt;opmode&lt;/code&gt;.
 421      *
 422      * &lt;p&gt;If this cipher requires any algorithm parameters and
 423      * &lt;code&gt;params&lt;/code&gt; is null, the underlying cipher implementation is
 424      * supposed to generate the required parameters itself (using
 425      * provider-specific default or random values) if it is being
 426      * initialized for encryption or key wrapping, and raise an
 427      * &lt;code&gt;InvalidAlgorithmParameterException&lt;/code&gt; if it is being
 428      * initialized for decryption or key unwrapping.
 429      * The generated parameters can be retrieved using
 430      * {@link #engineGetParameters() engineGetParameters} or
 431      * {@link #engineGetIV() engineGetIV} (if the parameter is an IV).
 432      *
 433      * &lt;p&gt;If this cipher requires algorithm parameters that cannot be
 434      * derived from the input parameters, and there are no reasonable
 435      * provider-specific default values, initialization will
 436      * necessarily fail.
 437      *
 438      * &lt;p&gt;If this cipher (including its underlying feedback or padding scheme)
 439      * requires any random bytes (e.g., for parameter generation), it will get
 440      * them from &lt;code&gt;random&lt;/code&gt;.
 441      *
 442      * &lt;p&gt;Note that when a Cipher object is initialized, it loses all
 443      * previously-acquired state. In other words, initializing a Cipher is
 444      * equivalent to creating a new instance of that Cipher and initializing
 445      * it.
 446      *
 447      * @param opmode the operation mode of this cipher (this is one of
 448      * the following:
 449      * &lt;code&gt;ENCRYPT_MODE&lt;/code&gt;, &lt;code&gt;DECRYPT_MODE&lt;/code&gt;,
 450      * &lt;code&gt;WRAP_MODE&lt;/code&gt; or &lt;code&gt;UNWRAP_MODE&lt;/code&gt;)
 451      * @param key the encryption key
 452      * @param params the algorithm parameters
 453      * @param random the source of randomness
 454      *
 455      * @exception InvalidKeyException if the given key is inappropriate for
 456      * initializing this cipher
 457      * @exception InvalidAlgorithmParameterException if the given algorithm
 458      * parameters are inappropriate for this cipher,
 459      * or if this cipher requires
 460      * algorithm parameters and &lt;code&gt;params&lt;/code&gt; is null.
 461      * @throws UnsupportedOperationException if {@code opmode} is
 462      * {@code WRAP_MODE} or {@code UNWRAP_MODE} is not implemented
 463      * by the cipher.
 464      */
 465     protected abstract void engineInit(int opmode, Key key,
 466                                        AlgorithmParameters params,
 467                                        SecureRandom random)
 468         throws InvalidKeyException, InvalidAlgorithmParameterException;
 469 
 470     /**
 471      * Continues a multiple-part encryption or decryption operation
 472      * (depending on how this cipher was initialized), processing another data
 473      * part.
 474      *
 475      * &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
 476      * buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed,
 477      * and the result is stored in a new buffer.
 478      *
 479      * @param input the input buffer
 480      * @param inputOffset the offset in &lt;code&gt;input&lt;/code&gt; where the input
 481      * starts
 482      * @param inputLen the input length
 483      *
 484      * @return the new buffer with the result, or null if the underlying
 485      * cipher is a block cipher and the input data is too short to result in a
 486      * new block.
 487      */
 488     protected abstract byte[] engineUpdate(byte[] input, int inputOffset,
 489                                            int inputLen);
 490 
 491     /**
 492      * Continues a multiple-part encryption or decryption operation
 493      * (depending on how this cipher was initialized), processing another data
 494      * part.
 495      *
 496      * &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
 497      * buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, are processed,
 498      * and the result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at
 499      * &lt;code&gt;outputOffset&lt;/code&gt; inclusive.
 500      *
 501      * &lt;p&gt;If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result,
 502      * a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.
 503      *
 504      * @param input the input buffer
 505      * @param inputOffset the offset in &lt;code&gt;input&lt;/code&gt; where the input
 506      * starts
 507      * @param inputLen the input length
 508      * @param output the buffer for the result
 509      * @param outputOffset the offset in &lt;code&gt;output&lt;/code&gt; where the result
 510      * is stored
 511      *
 512      * @return the number of bytes stored in &lt;code&gt;output&lt;/code&gt;
 513      *
 514      * @exception ShortBufferException if the given output buffer is too small
 515      * to hold the result
 516      */
 517     protected abstract int engineUpdate(byte[] input, int inputOffset,
 518                                         int inputLen, byte[] output,
 519                                         int outputOffset)
 520         throws ShortBufferException;
 521 
 522     /**
 523      * Continues a multiple-part encryption or decryption operation
 524      * (depending on how this cipher was initialized), processing another data
 525      * part.
 526      *
 527      * &lt;p&gt;All &lt;code&gt;input.remaining()&lt;/code&gt; bytes starting at
 528      * &lt;code&gt;input.position()&lt;/code&gt; are processed. The result is stored
 529      * in the output buffer.
 530      * Upon return, the input buffer&#39;s position will be equal
 531      * to its limit; its limit will not have changed. The output buffer&#39;s
 532      * position will have advanced by n, where n is the value returned
 533      * by this method; the output buffer&#39;s limit will not have changed.
 534      *
 535      * &lt;p&gt;If &lt;code&gt;output.remaining()&lt;/code&gt; bytes are insufficient to
 536      * hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.
 537      *
 538      * &lt;p&gt;Subclasses should consider overriding this method if they can
 539      * process ByteBuffers more efficiently than byte arrays.
 540      *
 541      * @param input the input ByteBuffer
 542      * @param output the output ByteByffer
 543      *
 544      * @return the number of bytes stored in &lt;code&gt;output&lt;/code&gt;
 545      *
 546      * @exception ShortBufferException if there is insufficient space in the
 547      * output buffer
 548      *
 549      * @throws NullPointerException if either parameter is &lt;CODE&gt;null&lt;/CODE&gt;
 550      * @since 1.5
 551      */
 552     protected int engineUpdate(ByteBuffer input, ByteBuffer output)
 553             throws ShortBufferException {
 554         try {
 555             return bufferCrypt(input, output, true);
 556         } catch (IllegalBlockSizeException e) {
 557             // never thrown for engineUpdate()
 558             throw new ProviderException(&quot;Internal error in update()&quot;);
 559         } catch (BadPaddingException e) {
 560             // never thrown for engineUpdate()
 561             throw new ProviderException(&quot;Internal error in update()&quot;);
 562         }
 563     }
 564 
 565     /**
 566      * Encrypts or decrypts data in a single-part operation,
 567      * or finishes a multiple-part operation.
 568      * The data is encrypted or decrypted, depending on how this cipher was
 569      * initialized.
 570      *
 571      * &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
 572      * buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input
 573      * bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt;
 574      * operation, are processed, with padding (if requested) being applied.
 575      * If an AEAD mode such as GCM/CCM is being used, the authentication
 576      * tag is appended in the case of encryption, or verified in the
 577      * case of decryption.
 578      * The result is stored in a new buffer.
 579      *
 580      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
 581      * it was in when previously initialized via a call to
 582      * &lt;code&gt;engineInit&lt;/code&gt;.
 583      * That is, the object is reset and available to encrypt or decrypt
 584      * (depending on the operation mode that was specified in the call to
 585      * &lt;code&gt;engineInit&lt;/code&gt;) more data.
 586      *
 587      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
 588      * be reset before it can be used again.
 589      *
 590      * @param input the input buffer
 591      * @param inputOffset the offset in &lt;code&gt;input&lt;/code&gt; where the input
 592      * starts
 593      * @param inputLen the input length
 594      *
 595      * @return the new buffer with the result
 596      *
 597      * @exception IllegalBlockSizeException if this cipher is a block cipher,
 598      * no padding has been requested (only in encryption mode), and the total
 599      * input length of the data processed by this cipher is not a multiple of
 600      * block size; or if this encryption algorithm is unable to
 601      * process the input data provided.
 602      * @exception BadPaddingException if this cipher is in decryption mode,
 603      * and (un)padding has been requested, but the decrypted data is not
 604      * bounded by the appropriate padding bytes
 605      * @exception AEADBadTagException if this cipher is decrypting in an
 606      * AEAD mode (such as GCM/CCM), and the received authentication tag
 607      * does not match the calculated value
 608      */
 609     protected abstract byte[] engineDoFinal(byte[] input, int inputOffset,
 610                                             int inputLen)
 611         throws IllegalBlockSizeException, BadPaddingException;
 612 
 613     /**
 614      * Encrypts or decrypts data in a single-part operation,
 615      * or finishes a multiple-part operation.
 616      * The data is encrypted or decrypted, depending on how this cipher was
 617      * initialized.
 618      *
 619      * &lt;p&gt;The first &lt;code&gt;inputLen&lt;/code&gt; bytes in the &lt;code&gt;input&lt;/code&gt;
 620      * buffer, starting at &lt;code&gt;inputOffset&lt;/code&gt; inclusive, and any input
 621      * bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt;
 622      * operation, are processed, with padding (if requested) being applied.
 623      * If an AEAD mode such as GCM/CCM is being used, the authentication
 624      * tag is appended in the case of encryption, or verified in the
 625      * case of decryption.
 626      * The result is stored in the &lt;code&gt;output&lt;/code&gt; buffer, starting at
 627      * &lt;code&gt;outputOffset&lt;/code&gt; inclusive.
 628      *
 629      * &lt;p&gt;If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result,
 630      * a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.
 631      *
 632      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
 633      * it was in when previously initialized via a call to
 634      * &lt;code&gt;engineInit&lt;/code&gt;.
 635      * That is, the object is reset and available to encrypt or decrypt
 636      * (depending on the operation mode that was specified in the call to
 637      * &lt;code&gt;engineInit&lt;/code&gt;) more data.
 638      *
 639      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
 640      * be reset before it can be used again.
 641      *
 642      * @param input the input buffer
 643      * @param inputOffset the offset in &lt;code&gt;input&lt;/code&gt; where the input
 644      * starts
 645      * @param inputLen the input length
 646      * @param output the buffer for the result
 647      * @param outputOffset the offset in &lt;code&gt;output&lt;/code&gt; where the result
 648      * is stored
 649      *
 650      * @return the number of bytes stored in &lt;code&gt;output&lt;/code&gt;
 651      *
 652      * @exception IllegalBlockSizeException if this cipher is a block cipher,
 653      * no padding has been requested (only in encryption mode), and the total
 654      * input length of the data processed by this cipher is not a multiple of
 655      * block size; or if this encryption algorithm is unable to
 656      * process the input data provided.
 657      * @exception ShortBufferException if the given output buffer is too small
 658      * to hold the result
 659      * @exception BadPaddingException if this cipher is in decryption mode,
 660      * and (un)padding has been requested, but the decrypted data is not
 661      * bounded by the appropriate padding bytes
 662      * @exception AEADBadTagException if this cipher is decrypting in an
 663      * AEAD mode (such as GCM/CCM), and the received authentication tag
 664      * does not match the calculated value
 665      */
 666     protected abstract int engineDoFinal(byte[] input, int inputOffset,
 667                                          int inputLen, byte[] output,
 668                                          int outputOffset)
 669         throws ShortBufferException, IllegalBlockSizeException,
 670                BadPaddingException;
 671 
 672     /**
 673      * Encrypts or decrypts data in a single-part operation,
 674      * or finishes a multiple-part operation.
 675      * The data is encrypted or decrypted, depending on how this cipher was
 676      * initialized.
 677      *
 678      * &lt;p&gt;All &lt;code&gt;input.remaining()&lt;/code&gt; bytes starting at
 679      * &lt;code&gt;input.position()&lt;/code&gt; are processed.
 680      * If an AEAD mode such as GCM/CCM is being used, the authentication
 681      * tag is appended in the case of encryption, or verified in the
 682      * case of decryption.
 683      * The result is stored in the output buffer.
 684      * Upon return, the input buffer&#39;s position will be equal
 685      * to its limit; its limit will not have changed. The output buffer&#39;s
 686      * position will have advanced by n, where n is the value returned
 687      * by this method; the output buffer&#39;s limit will not have changed.
 688      *
 689      * &lt;p&gt;If &lt;code&gt;output.remaining()&lt;/code&gt; bytes are insufficient to
 690      * hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.
 691      *
 692      * &lt;p&gt;Upon finishing, this method resets this cipher object to the state
 693      * it was in when previously initialized via a call to
 694      * &lt;code&gt;engineInit&lt;/code&gt;.
 695      * That is, the object is reset and available to encrypt or decrypt
 696      * (depending on the operation mode that was specified in the call to
 697      * &lt;code&gt;engineInit&lt;/code&gt;) more data.
 698      *
 699      * &lt;p&gt;Note: if any exception is thrown, this cipher object may need to
 700      * be reset before it can be used again.
 701      *
 702      * &lt;p&gt;Subclasses should consider overriding this method if they can
 703      * process ByteBuffers more efficiently than byte arrays.
 704      *
 705      * @param input the input ByteBuffer
 706      * @param output the output ByteByffer
 707      *
 708      * @return the number of bytes stored in &lt;code&gt;output&lt;/code&gt;
 709      *
 710      * @exception IllegalBlockSizeException if this cipher is a block cipher,
 711      * no padding has been requested (only in encryption mode), and the total
 712      * input length of the data processed by this cipher is not a multiple of
 713      * block size; or if this encryption algorithm is unable to
 714      * process the input data provided.
 715      * @exception ShortBufferException if there is insufficient space in the
 716      * output buffer
 717      * @exception BadPaddingException if this cipher is in decryption mode,
 718      * and (un)padding has been requested, but the decrypted data is not
 719      * bounded by the appropriate padding bytes
 720      * @exception AEADBadTagException if this cipher is decrypting in an
 721      * AEAD mode (such as GCM/CCM), and the received authentication tag
 722      * does not match the calculated value
 723      *
 724      * @throws NullPointerException if either parameter is &lt;CODE&gt;null&lt;/CODE&gt;
 725      * @since 1.5
 726      */
 727     protected int engineDoFinal(ByteBuffer input, ByteBuffer output)
 728             throws ShortBufferException, IllegalBlockSizeException,
 729             BadPaddingException {
 730         return bufferCrypt(input, output, false);
 731     }
 732 
 733     // copied from sun.security.jca.JCAUtil
 734     // will be changed to reference that method once that code has been
 735     // integrated and promoted
 736     static int getTempArraySize(int totalSize) {
 737         return Math.min(4096, totalSize);
 738     }
 739 
 740     /**
 741      * Implementation for encryption using ByteBuffers. Used for both
 742      * engineUpdate() and engineDoFinal().
 743      */
 744     private int bufferCrypt(ByteBuffer input, ByteBuffer output,
 745             boolean isUpdate) throws ShortBufferException,
 746             IllegalBlockSizeException, BadPaddingException {
 747         if ((input == null) || (output == null)) {
 748             throw new NullPointerException
 749                 (&quot;Input and output buffers must not be null&quot;);
 750         }
 751         int inPos = input.position();
 752         int inLimit = input.limit();
 753         int inLen = inLimit - inPos;
 754         if (isUpdate &amp;&amp; (inLen == 0)) {
 755             return 0;
 756         }
 757         int outLenNeeded = engineGetOutputSize(inLen);
 758 
 759         if (output.remaining() &lt; outLenNeeded) {
 760             throw new ShortBufferException(&quot;Need at least &quot; + outLenNeeded
 761                 + &quot; bytes of space in output buffer&quot;);
 762         }
 763 
 764         // detecting input and output buffer overlap may be tricky
 765         // we can only write directly into output buffer when we
 766         // are 100% sure it&#39;s safe to do so
 767 
 768         boolean a1 = input.hasArray();
 769         boolean a2 = output.hasArray();
 770         int total = 0;
 771 
 772         if (a1) { // input has an accessible byte[]
 773             byte[] inArray = input.array();
 774             int inOfs = input.arrayOffset() + inPos;
 775 
 776             if (a2) { // output has an accessible byte[]
 777                 byte[] outArray = output.array();
 778                 int outPos = output.position();
 779                 int outOfs = output.arrayOffset() + outPos;
 780 
 781                 // check array address and offsets and use temp output buffer
 782                 // if output offset is larger than input offset and
 783                 // falls within the range of input data
 784                 boolean useTempOut = false;
 785                 if (inArray == outArray &amp;&amp;
 786                     ((inOfs &lt; outOfs) &amp;&amp; (outOfs &lt; inOfs + inLen))) {
 787                     useTempOut = true;
 788                     outArray = new byte[outLenNeeded];
 789                     outOfs = 0;
 790                 }
 791                 if (isUpdate) {
 792                     total = engineUpdate(inArray, inOfs, inLen, outArray, outOfs);
 793                 } else {
 794                     total = engineDoFinal(inArray, inOfs, inLen, outArray, outOfs);
 795                 }
 796                 if (useTempOut) {
 797                     output.put(outArray, outOfs, total);
 798                 } else {
 799                     // adjust output position manually
 800                     output.position(outPos + total);
 801                 }
 802                 // adjust input position manually
 803                 input.position(inLimit);
 804             } else { // output does not have an accessible byte[]
 805                 byte[] outArray = null;
 806                 if (isUpdate) {
 807                     outArray = engineUpdate(inArray, inOfs, inLen);
 808                 } else {
 809                     outArray = engineDoFinal(inArray, inOfs, inLen);
 810                 }
 811                 if (outArray != null &amp;&amp; outArray.length != 0) {
 812                     output.put(outArray);
 813                     total = outArray.length;
 814                 }
 815                 // adjust input position manually
 816                 input.position(inLimit);
 817             }
 818         } else { // input does not have an accessible byte[]
 819             // have to assume the worst, since we have no way of determine
 820             // if input and output overlaps or not
 821             byte[] tempOut = new byte[outLenNeeded];
 822             int outOfs = 0;
 823 
 824             byte[] tempIn = new byte[getTempArraySize(inLen)];
 825             do {
 826                 int chunk = Math.min(inLen, tempIn.length);
 827                 if (chunk &gt; 0) {
 828                     input.get(tempIn, 0, chunk);
 829                 }
 830                 int n;
 831                 if (isUpdate || (inLen &gt; chunk)) {
 832                     n = engineUpdate(tempIn, 0, chunk, tempOut, outOfs);
 833                 } else {
 834                     n = engineDoFinal(tempIn, 0, chunk, tempOut, outOfs);
 835                 }
 836                 outOfs += n;
 837                 total += n;
 838                 inLen -= chunk;
 839             } while (inLen &gt; 0);
 840             if (total &gt; 0) {
 841                 output.put(tempOut, 0, total);
 842             }
 843         }
 844 
 845         return total;
 846     }
 847 
 848     /**
 849      * Wrap a key.
 850      *
 851      * &lt;p&gt;This concrete method has been added to this previously-defined
 852      * abstract class. (For backwards compatibility, it cannot be abstract.)
 853      * It may be overridden by a provider to wrap a key.
 854      * Such an override is expected to throw an IllegalBlockSizeException or
 855      * InvalidKeyException (under the specified circumstances),
 856      * if the given key cannot be wrapped.
 857      * If this method is not overridden, it always throws an
 858      * UnsupportedOperationException.
 859      *
 860      * @param key the key to be wrapped.
 861      *
 862      * @return the wrapped key.
 863      *
 864      * @exception IllegalBlockSizeException if this cipher is a block cipher,
 865      * no padding has been requested, and the length of the encoding of the
 866      * key to be wrapped is not a multiple of the block size.
 867      *
 868      * @exception InvalidKeyException if it is impossible or unsafe to
 869      * wrap the key with this cipher (e.g., a hardware protected key is
 870      * being passed to a software-only cipher).
 871      *
 872      * @throws UnsupportedOperationException if this method is not supported.
 873      */
 874     protected byte[] engineWrap(Key key)
 875         throws IllegalBlockSizeException, InvalidKeyException
 876     {
 877         throw new UnsupportedOperationException();
 878     }
 879 
 880     /**
 881      * Unwrap a previously wrapped key.
 882      *
 883      * &lt;p&gt;This concrete method has been added to this previously-defined
 884      * abstract class. (For backwards compatibility, it cannot be abstract.)
 885      * It may be overridden by a provider to unwrap a previously wrapped key.
 886      * Such an override is expected to throw an InvalidKeyException if
 887      * the given wrapped key cannot be unwrapped.
 888      * If this method is not overridden, it always throws an
 889      * UnsupportedOperationException.
 890      *
 891      * @param wrappedKey the key to be unwrapped.
 892      *
 893      * @param wrappedKeyAlgorithm the algorithm associated with the wrapped
 894      * key.
 895      *
 896      * @param wrappedKeyType the type of the wrapped key. This is one of
 897      * &lt;code&gt;SECRET_KEY&lt;/code&gt;, &lt;code&gt;PRIVATE_KEY&lt;/code&gt;, or
 898      * &lt;code&gt;PUBLIC_KEY&lt;/code&gt;.
 899      *
 900      * @return the unwrapped key.
 901      *
 902      * @exception NoSuchAlgorithmException if no installed providers
 903      * can create keys of type &lt;code&gt;wrappedKeyType&lt;/code&gt; for the
 904      * &lt;code&gt;wrappedKeyAlgorithm&lt;/code&gt;.
 905      *
 906      * @exception InvalidKeyException if &lt;code&gt;wrappedKey&lt;/code&gt; does not
 907      * represent a wrapped key of type &lt;code&gt;wrappedKeyType&lt;/code&gt; for
 908      * the &lt;code&gt;wrappedKeyAlgorithm&lt;/code&gt;.
 909      *
 910      * @throws UnsupportedOperationException if this method is not supported.
 911      */
 912     protected Key engineUnwrap(byte[] wrappedKey,
 913                                String wrappedKeyAlgorithm,
 914                                int wrappedKeyType)
 915         throws InvalidKeyException, NoSuchAlgorithmException
 916     {
 917         throw new UnsupportedOperationException();
 918     }
 919 
 920     /**
 921      * Returns the key size of the given key object in bits.
 922      * &lt;p&gt;This concrete method has been added to this previously-defined
 923      * abstract class. It throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;
 924      * if it is not overridden by the provider.
 925      *
 926      * @param key the key object.
 927      *
 928      * @return the key size of the given key object.
 929      *
 930      * @exception InvalidKeyException if &lt;code&gt;key&lt;/code&gt; is invalid.
 931      */
 932     protected int engineGetKeySize(Key key)
 933         throws InvalidKeyException
 934     {
 935         throw new UnsupportedOperationException();
 936     }
 937 
 938     /**
 939      * Continues a multi-part update of the Additional Authentication
 940      * Data (AAD), using a subset of the provided buffer.
 941      * &lt;p&gt;
 942      * Calls to this method provide AAD to the cipher when operating in
 943      * modes such as AEAD (GCM/CCM).  If this cipher is operating in
 944      * either GCM or CCM mode, all AAD must be supplied before beginning
 945      * operations on the ciphertext (via the {@code update} and {@code
 946      * doFinal} methods).
 947      *
 948      * @param src the buffer containing the AAD
 949      * @param offset the offset in {@code src} where the AAD input starts
 950      * @param len the number of AAD bytes
 951      *
 952      * @throws IllegalStateException if this cipher is in a wrong state
 953      * (e.g., has not been initialized), does not accept AAD, or if
 954      * operating in either GCM or CCM mode and one of the {@code update}
 955      * methods has already been called for the active
 956      * encryption/decryption operation
 957      * @throws UnsupportedOperationException if this method
 958      * has not been overridden by an implementation
 959      *
 960      * @since 1.7
 961      */
 962     protected void engineUpdateAAD(byte[] src, int offset, int len) {
 963         throw new UnsupportedOperationException(
 964             &quot;The underlying Cipher implementation &quot;
 965             +  &quot;does not support this method&quot;);
 966     }
 967 
 968     /**
 969      * Continues a multi-part update of the Additional Authentication
 970      * Data (AAD).
 971      * &lt;p&gt;
 972      * Calls to this method provide AAD to the cipher when operating in
 973      * modes such as AEAD (GCM/CCM).  If this cipher is operating in
 974      * either GCM or CCM mode, all AAD must be supplied before beginning
 975      * operations on the ciphertext (via the {@code update} and {@code
 976      * doFinal} methods).
 977      * &lt;p&gt;
 978      * All {@code src.remaining()} bytes starting at
 979      * {@code src.position()} are processed.
 980      * Upon return, the input buffer&#39;s position will be equal
 981      * to its limit; its limit will not have changed.
 982      *
 983      * @param src the buffer containing the AAD
 984      *
 985      * @throws IllegalStateException if this cipher is in a wrong state
 986      * (e.g., has not been initialized), does not accept AAD, or if
 987      * operating in either GCM or CCM mode and one of the {@code update}
 988      * methods has already been called for the active
 989      * encryption/decryption operation
 990      * @throws UnsupportedOperationException if this method
 991      * has not been overridden by an implementation
 992      *
 993      * @since 1.7
 994      */
 995     protected void engineUpdateAAD(ByteBuffer src) {
 996         throw new UnsupportedOperationException(
 997             &quot;The underlying Cipher implementation &quot;
 998             +  &quot;does not support this method&quot;);
 999     }
1000 }
    </pre>
  </body>
</html>