<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/regex/Pattern.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.regex;
  27 
  28 import java.text.Normalizer;
  29 import java.text.Normalizer.Form;
  30 import java.util.Locale;
  31 import java.util.Iterator;
  32 import java.util.Map;
  33 import java.util.ArrayList;
  34 import java.util.HashMap;
  35 import java.util.LinkedHashSet;
  36 import java.util.List;
  37 import java.util.Set;
  38 import java.util.Arrays;
  39 import java.util.NoSuchElementException;
  40 import java.util.Spliterator;
  41 import java.util.Spliterators;
  42 import java.util.function.Predicate;
  43 import java.util.stream.Stream;
  44 import java.util.stream.StreamSupport;
  45 
  46 import jdk.internal.util.ArraysSupport;
  47 
  48 /**
  49  * A compiled representation of a regular expression.
  50  *
  51  * &lt;p&gt; A regular expression, specified as a string, must first be compiled into
  52  * an instance of this class.  The resulting pattern can then be used to create
  53  * a {@link Matcher} object that can match arbitrary {@linkplain
  54  * java.lang.CharSequence character sequences} against the regular
  55  * expression.  All of the state involved in performing a match resides in the
  56  * matcher, so many matchers can share the same pattern.
  57  *
  58  * &lt;p&gt; A typical invocation sequence is thus
  59  *
  60  * &lt;blockquote&gt;&lt;pre&gt;
  61  * Pattern p = Pattern.{@link #compile compile}(&quot;a*b&quot;);
  62  * Matcher m = p.{@link #matcher matcher}(&quot;aaaaab&quot;);
  63  * boolean b = m.{@link Matcher#matches matches}();&lt;/pre&gt;&lt;/blockquote&gt;
  64  *
  65  * &lt;p&gt; A {@link #matches matches} method is defined by this class as a
  66  * convenience for when a regular expression is used just once.  This method
  67  * compiles an expression and matches an input sequence against it in a single
  68  * invocation.  The statement
  69  *
  70  * &lt;blockquote&gt;&lt;pre&gt;
  71  * boolean b = Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;);&lt;/pre&gt;&lt;/blockquote&gt;
  72  *
  73  * is equivalent to the three statements above, though for repeated matches it
  74  * is less efficient since it does not allow the compiled pattern to be reused.
  75  *
  76  * &lt;p&gt; Instances of this class are immutable and are safe for use by multiple
  77  * concurrent threads.  Instances of the {@link Matcher} class are not safe for
  78  * such use.
  79  *
  80  *
  81  * &lt;h2&gt;&lt;a id=&quot;sum&quot;&gt;Summary of regular-expression constructs&lt;/a&gt;&lt;/h2&gt;
  82  *
  83  * &lt;table class=&quot;borderless&quot;&gt;
  84  * &lt;caption style=&quot;display:none&quot;&gt;Regular expression constructs, and what they match&lt;/caption&gt;
  85  * &lt;thead style=&quot;text-align:left&quot;&gt;
  86  * &lt;tr&gt;
  87  * &lt;th id=&quot;construct&quot;&gt;Construct&lt;/th&gt;
  88  * &lt;th id=&quot;matches&quot;&gt;Matches&lt;/th&gt;
  89  * &lt;/tr&gt;
  90  * &lt;/thead&gt;
  91  * &lt;tbody style=&quot;text-align:left&quot;&gt;
  92  *
  93  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;characters&quot;&gt;Characters&lt;/th&gt;&lt;/tr&gt;
  94  *
  95  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;x&quot;&gt;&lt;i&gt;x&lt;/i&gt;&lt;/th&gt;
  96  *     &lt;td headers=&quot;matches characters x&quot;&gt;The character &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
  97  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;backslash&quot;&gt;{@code \\}&lt;/th&gt;
  98  *     &lt;td headers=&quot;matches characters backslash&quot;&gt;The backslash character&lt;/td&gt;&lt;/tr&gt;
  99  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;octal_n&quot;&gt;{@code \0}&lt;i&gt;n&lt;/i&gt;&lt;/th&gt;
 100  *     &lt;td headers=&quot;matches characters octal_n&quot;&gt;The character with octal value {@code 0}&lt;i&gt;n&lt;/i&gt;
 101  *         (0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
 102  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;octal_nn&quot;&gt;{@code \0}&lt;i&gt;nn&lt;/i&gt;&lt;/th&gt;
 103  *     &lt;td headers=&quot;matches characters octal_nn&quot;&gt;The character with octal value {@code 0}&lt;i&gt;nn&lt;/i&gt;
 104  *         (0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
 105  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;octal_nnn&quot;&gt;{@code \0}&lt;i&gt;mnn&lt;/i&gt;&lt;/th&gt;
 106  *     &lt;td headers=&quot;matches characters octal_nnn&quot;&gt;The character with octal value {@code 0}&lt;i&gt;mnn&lt;/i&gt;
 107  *         (0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;m&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;3,
 108  *         0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
 109  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;hex_hh&quot;&gt;{@code \x}&lt;i&gt;hh&lt;/i&gt;&lt;/th&gt;
 110  *     &lt;td headers=&quot;matches characters hex_hh&quot;&gt;The character with hexadecimal value {@code 0x}&lt;i&gt;hh&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 111  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;hex_hhhh&quot;&gt;&lt;code&gt;&amp;#92;u&lt;/code&gt;&lt;i&gt;hhhh&lt;/i&gt;&lt;/th&gt;
 112  *     &lt;td headers=&quot;matches characters hex_hhhh&quot;&gt;The character with hexadecimal&amp;nbsp;value&amp;nbsp;{@code 0x}&lt;i&gt;hhhh&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 113  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;hex_h_h&quot;&gt;&lt;code&gt;&amp;#92;x&lt;/code&gt;&lt;i&gt;{h...h}&lt;/i&gt;&lt;/th&gt;
 114  *     &lt;td headers=&quot;matches characters hex_h_h&quot;&gt;The character with hexadecimal value {@code 0x}&lt;i&gt;h...h&lt;/i&gt;
 115  *         ({@link java.lang.Character#MIN_CODE_POINT Character.MIN_CODE_POINT}
 116  *         &amp;nbsp;&amp;lt;=&amp;nbsp;{@code 0x}&lt;i&gt;h...h&lt;/i&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;
 117  *          {@link java.lang.Character#MAX_CODE_POINT Character.MAX_CODE_POINT})&lt;/td&gt;&lt;/tr&gt;
 118  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;unicode_name&quot;&gt;&lt;code&gt;&amp;#92;N{&lt;/code&gt;&lt;i&gt;name&lt;/i&gt;&lt;code&gt;}&lt;/code&gt;&lt;/th&gt;
 119  *     &lt;td headers=&quot;matches characters unicode_name&quot;&gt;The character with Unicode character name &lt;i&gt;&#39;name&#39;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 120  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;tab&quot;&gt;{@code \t}&lt;/th&gt;
 121  *     &lt;td headers=&quot;matches characters tab&quot;&gt;The tab character (&lt;code&gt;&#39;&amp;#92;u0009&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 122  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;newline&quot;&gt;{@code \n}&lt;/th&gt;
 123  *     &lt;td headers=&quot;matches characters newline&quot;&gt;The newline (line feed) character (&lt;code&gt;&#39;&amp;#92;u000A&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 124  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;return&quot;&gt;{@code \r}&lt;/th&gt;
 125  *     &lt;td headers=&quot;matches characters return&quot;&gt;The carriage-return character (&lt;code&gt;&#39;&amp;#92;u000D&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 126  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;form_feed&quot;&gt;{@code \f}&lt;/th&gt;
 127  *     &lt;td headers=&quot;matches characters form_feed&quot;&gt;The form-feed character (&lt;code&gt;&#39;&amp;#92;u000C&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 128  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;bell&quot;&gt;{@code \a}&lt;/th&gt;
 129  *     &lt;td headers=&quot;matches characters bell&quot;&gt;The alert (bell) character (&lt;code&gt;&#39;&amp;#92;u0007&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 130  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;escape&quot;&gt;{@code \e}&lt;/th&gt;
 131  *     &lt;td headers=&quot;matches characters escape&quot;&gt;The escape character (&lt;code&gt;&#39;&amp;#92;u001B&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 132  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;ctrl_x&quot;&gt;{@code \c}&lt;i&gt;x&lt;/i&gt;&lt;/th&gt;
 133  *     &lt;td headers=&quot;matches characters ctrl_x&quot;&gt;The control character corresponding to &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 134  *
 135  *  &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;classes&quot;&gt;Character classes&lt;/th&gt;&lt;/tr&gt;
 136  *
 137  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;simple&quot;&gt;{@code [abc]}&lt;/th&gt;
 138  *     &lt;td headers=&quot;matches classes simple&quot;&gt;{@code a}, {@code b}, or {@code c} (simple class)&lt;/td&gt;&lt;/tr&gt;
 139  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;negation&quot;&gt;{@code [^abc]}&lt;/th&gt;
 140  *     &lt;td headers=&quot;matches classes negation&quot;&gt;Any character except {@code a}, {@code b}, or {@code c} (negation)&lt;/td&gt;&lt;/tr&gt;
 141  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;range&quot;&gt;{@code [a-zA-Z]}&lt;/th&gt;
 142  *     &lt;td headers=&quot;matches classes range&quot;&gt;{@code a} through {@code z}
 143  *         or {@code A} through {@code Z}, inclusive (range)&lt;/td&gt;&lt;/tr&gt;
 144  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;union&quot;&gt;{@code [a-d[m-p]]}&lt;/th&gt;
 145  *     &lt;td headers=&quot;matches classes union&quot;&gt;{@code a} through {@code d},
 146  *      or {@code m} through {@code p}: {@code [a-dm-p]} (union)&lt;/td&gt;&lt;/tr&gt;
 147  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;intersection&quot;&gt;{@code [a-z&amp;&amp;[def]]}&lt;/th&gt;
 148  *     &lt;td headers=&quot;matches classes intersection&quot;&gt;{@code d}, {@code e}, or {@code f} (intersection)&lt;/tr&gt;
 149  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;subtraction1&quot;&gt;{@code [a-z&amp;&amp;[^bc]]}&lt;/th&gt;
 150  *     &lt;td headers=&quot;matches classes subtraction1&quot;&gt;{@code a} through {@code z},
 151  *         except for {@code b} and {@code c}: {@code [ad-z]} (subtraction)&lt;/td&gt;&lt;/tr&gt;
 152  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;subtraction2&quot;&gt;{@code [a-z&amp;&amp;[^m-p]]}&lt;/th&gt;
 153  *     &lt;td headers=&quot;matches classes subtraction2&quot;&gt;{@code a} through {@code z},
 154  *          and not {@code m} through {@code p}: {@code [a-lq-z]}(subtraction)&lt;/td&gt;&lt;/tr&gt;
 155  *
 156  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;predef&quot;&gt;Predefined character classes&lt;/th&gt;&lt;/tr&gt;
 157  *
 158  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;any&quot;&gt;{@code .}&lt;/th&gt;
 159  *     &lt;td headers=&quot;matches predef any&quot;&gt;Any character (may or may not match &lt;a href=&quot;#lt&quot;&gt;line terminators&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 160  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;digit&quot;&gt;{@code \d}&lt;/th&gt;
 161  *     &lt;td headers=&quot;matches predef digit&quot;&gt;A digit: {@code [0-9]}&lt;/td&gt;&lt;/tr&gt;
 162  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_digit&quot;&gt;{@code \D}&lt;/th&gt;
 163  *     &lt;td headers=&quot;matches predef non_digit&quot;&gt;A non-digit: {@code [^0-9]}&lt;/td&gt;&lt;/tr&gt;
 164  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;horiz_white&quot;&gt;{@code \h}&lt;/th&gt;
 165  *     &lt;td headers=&quot;matches predef horiz_white&quot;&gt;A horizontal whitespace character:
 166  *     &lt;code&gt;[ \t\xA0&amp;#92;u1680&amp;#92;u180e&amp;#92;u2000-&amp;#92;u200a&amp;#92;u202f&amp;#92;u205f&amp;#92;u3000]&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 167  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_horiz_white&quot;&gt;{@code \H}&lt;/th&gt;
 168  *     &lt;td headers=&quot;matches predef non_horiz_white&quot;&gt;A non-horizontal whitespace character: {@code [^\h]}&lt;/td&gt;&lt;/tr&gt;
 169  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;white&quot;&gt;{@code \s}&lt;/th&gt;
 170  *     &lt;td headers=&quot;matches predef white&quot;&gt;A whitespace character: {@code [ \t\n\x0B\f\r]}&lt;/td&gt;&lt;/tr&gt;
 171  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_white&quot;&gt;{@code \S}&lt;/th&gt;
 172  *     &lt;td headers=&quot;matches predef non_white&quot;&gt;A non-whitespace character: {@code [^\s]}&lt;/td&gt;&lt;/tr&gt;
 173  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;vert_white&quot;&gt;{@code \v}&lt;/th&gt;
 174  *     &lt;td headers=&quot;matches predef vert_white&quot;&gt;A vertical whitespace character: &lt;code&gt;[\n\x0B\f\r\x85&amp;#92;u2028&amp;#92;u2029]&lt;/code&gt;
 175  *     &lt;/td&gt;&lt;/tr&gt;
 176  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_vert_white&quot;&gt;{@code \V}&lt;/th&gt;
 177  *     &lt;td headers=&quot;matches predef non_vert_white&quot;&gt;A non-vertical whitespace character: {@code [^\v]}&lt;/td&gt;&lt;/tr&gt;
 178  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;word&quot;&gt;{@code \w}&lt;/th&gt;
 179  *     &lt;td headers=&quot;matches predef word&quot;&gt;A word character: {@code [a-zA-Z_0-9]}&lt;/td&gt;&lt;/tr&gt;
 180  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_word&quot;&gt;{@code \W}&lt;/th&gt;
 181  *     &lt;td headers=&quot;matches predef non_word&quot;&gt;A non-word character: {@code [^\w]}&lt;/td&gt;&lt;/tr&gt;
 182  *
 183  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;posix&quot;&gt;&lt;b&gt;POSIX character classes (US-ASCII only)&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
 184  *
 185  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Lower&quot;&gt;{@code \p{Lower}}&lt;/th&gt;
 186  *     &lt;td headers=&quot;matches posix Lower&quot;&gt;A lower-case alphabetic character: {@code [a-z]}&lt;/td&gt;&lt;/tr&gt;
 187  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Upper&quot;&gt;{@code \p{Upper}}&lt;/th&gt;
 188  *     &lt;td headers=&quot;matches posix Upper&quot;&gt;An upper-case alphabetic character:{@code [A-Z]}&lt;/td&gt;&lt;/tr&gt;
 189  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;ASCII&quot;&gt;{@code \p{ASCII}}&lt;/th&gt;
 190  *     &lt;td headers=&quot;matches posix ASCII&quot;&gt;All ASCII:{@code [\x00-\x7F]}&lt;/td&gt;&lt;/tr&gt;
 191  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Alpha&quot;&gt;{@code \p{Alpha}}&lt;/th&gt;
 192  *     &lt;td headers=&quot;matches posix Alpha&quot;&gt;An alphabetic character:{@code [\p{Lower}\p{Upper}]}&lt;/td&gt;&lt;/tr&gt;
 193  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Digit&quot;&gt;{@code \p{Digit}}&lt;/th&gt;
 194  *     &lt;td headers=&quot;matches posix Digit&quot;&gt;A decimal digit: {@code [0-9]}&lt;/td&gt;&lt;/tr&gt;
 195  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Alnum&quot;&gt;{@code \p{Alnum}}&lt;/th&gt;
 196  *     &lt;td headers=&quot;matches posix Alnum&quot;&gt;An alphanumeric character:{@code [\p{Alpha}\p{Digit}]}&lt;/td&gt;&lt;/tr&gt;
 197  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Punct&quot;&gt;{@code \p{Punct}}&lt;/th&gt;
 198  *     &lt;td headers=&quot;matches posix Punct&quot;&gt;Punctuation: One of {@code !&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~}&lt;/td&gt;&lt;/tr&gt;
 199  *     &lt;!-- {@code [\!&quot;#\$%&amp;&#39;\(\)\*\+,\-\./:;\&lt;=\&gt;\?@\[\\\]\^_`\{\|\}~]}
 200  *          {@code [\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]} --&gt;
 201  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Graph&quot;&gt;{@code \p{Graph}}&lt;/th&gt;
 202  *     &lt;td headers=&quot;matches posix Graph&quot;&gt;A visible character: {@code [\p{Alnum}\p{Punct}]}&lt;/td&gt;&lt;/tr&gt;
 203  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Print&quot;&gt;{@code \p{Print}}&lt;/th&gt;
 204  *     &lt;td headers=&quot;matches posix Print&quot;&gt;A printable character: {@code [\p{Graph}\x20]}&lt;/td&gt;&lt;/tr&gt;
 205  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Blank&quot;&gt;{@code \p{Blank}}&lt;/th&gt;
 206  *     &lt;td headers=&quot;matches posix Blank&quot;&gt;A space or a tab: {@code [ \t]}&lt;/td&gt;&lt;/tr&gt;
 207  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Cntrl&quot;&gt;{@code \p{Cntrl}}&lt;/th&gt;
 208  *     &lt;td headers=&quot;matches posix Cntrl&quot;&gt;A control character: {@code [\x00-\x1F\x7F]}&lt;/td&gt;&lt;/tr&gt;
 209  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;XDigit&quot;&gt;{@code \p{XDigit}}&lt;/th&gt;
 210  *     &lt;td headers=&quot;matches posix XDigit&quot;&gt;A hexadecimal digit: {@code [0-9a-fA-F]}&lt;/td&gt;&lt;/tr&gt;
 211  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Space&quot;&gt;{@code \p{Space}}&lt;/th&gt;
 212  *     &lt;td headers=&quot;matches posix Space&quot;&gt;A whitespace character: {@code [ \t\n\x0B\f\r]}&lt;/td&gt;&lt;/tr&gt;
 213  *
 214  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;java&quot;&gt;java.lang.Character classes (simple &lt;a href=&quot;#jcc&quot;&gt;java character type&lt;/a&gt;)&lt;/th&gt;&lt;/tr&gt;
 215  *
 216  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;javaLowerCase&quot;&gt;{@code \p{javaLowerCase}}&lt;/th&gt;
 217  *     &lt;td headers=&quot;matches java javaLowerCase&quot;&gt;Equivalent to java.lang.Character.isLowerCase()&lt;/td&gt;&lt;/tr&gt;
 218  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;javaUpperCase&quot;&gt;{@code \p{javaUpperCase}}&lt;/th&gt;
 219  *     &lt;td headers=&quot;matches java javaUpperCase&quot;&gt;Equivalent to java.lang.Character.isUpperCase()&lt;/td&gt;&lt;/tr&gt;
 220  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;javaWhitespace&quot;&gt;{@code \p{javaWhitespace}}&lt;/th&gt;
 221  *     &lt;td headers=&quot;matches java javaWhitespace&quot;&gt;Equivalent to java.lang.Character.isWhitespace()&lt;/td&gt;&lt;/tr&gt;
 222  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;javaMirrored&quot;&gt;{@code \p{javaMirrored}}&lt;/th&gt;
 223  *     &lt;td headers=&quot;matches java javaMirrored&quot;&gt;Equivalent to java.lang.Character.isMirrored()&lt;/td&gt;&lt;/tr&gt;
 224  *
 225  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot;  id=&quot;unicode&quot;&gt;Classes for Unicode scripts, blocks, categories and binary properties&lt;/th&gt;&lt;/tr&gt;
 226  *
 227  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;IsLatin&quot;&gt;{@code \p{IsLatin}}&lt;/th&gt;
 228  *     &lt;td headers=&quot;matches unicode IsLatin&quot;&gt;A Latin&amp;nbsp;script character (&lt;a href=&quot;#usc&quot;&gt;script&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 229  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;InGreek&quot;&gt;{@code \p{InGreek}}&lt;/th&gt;
 230  *     &lt;td headers=&quot;matches unicode InGreek&quot;&gt;A character in the Greek&amp;nbsp;block (&lt;a href=&quot;#ubc&quot;&gt;block&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 231  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Lu&quot;&gt;{@code \p{Lu}}&lt;/th&gt;
 232  *     &lt;td headers=&quot;matches unicode Lu&quot;&gt;An uppercase letter (&lt;a href=&quot;#ucc&quot;&gt;category&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 233  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;IsAlphabetic&quot;&gt;{@code \p{IsAlphabetic}}&lt;/th&gt;
 234  *     &lt;td headers=&quot;matches unicode IsAlphabetic&quot;&gt;An alphabetic character (&lt;a href=&quot;#ubpc&quot;&gt;binary property&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 235  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Sc&quot;&gt;{@code \p{Sc}}&lt;/th&gt;
 236  *     &lt;td headers=&quot;matches unicode Sc&quot;&gt;A currency symbol&lt;/td&gt;&lt;/tr&gt;
 237  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;not_InGreek&quot;&gt;{@code \P{InGreek}}&lt;/th&gt;
 238  *     &lt;td headers=&quot;matches unicode not_InGreek&quot;&gt;Any character except one in the Greek block (negation)&lt;/td&gt;&lt;/tr&gt;
 239  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;not_uppercase&quot;&gt;{@code [\p{L}&amp;&amp;[^\p{Lu}]]}&lt;/th&gt;
 240  *     &lt;td headers=&quot;matches unicode not_uppercase&quot;&gt;Any letter except an uppercase letter (subtraction)&lt;/td&gt;&lt;/tr&gt;
 241  *
 242  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;bounds&quot;&gt;Boundary matchers&lt;/th&gt;&lt;/tr&gt;
 243  *
 244  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;begin_line&quot;&gt;{@code ^}&lt;/th&gt;
 245  *     &lt;td headers=&quot;matches bounds begin_line&quot;&gt;The beginning of a line&lt;/td&gt;&lt;/tr&gt;
 246  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;end_line&quot;&gt;{@code $}&lt;/th&gt;
 247  *     &lt;td headers=&quot;matches bounds end_line&quot;&gt;The end of a line&lt;/td&gt;&lt;/tr&gt;
 248  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;word_boundary&quot;&gt;{@code \b}&lt;/th&gt;
 249  *     &lt;td headers=&quot;matches bounds word_boundary&quot;&gt;A word boundary&lt;/td&gt;&lt;/tr&gt;
 250  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;grapheme_cluster_boundary&quot;&gt;{@code \b{g}}&lt;/th&gt;
 251  *     &lt;td headers=&quot;matches bounds grapheme_cluster_boundary&quot;&gt;A Unicode extended grapheme cluster boundary&lt;/td&gt;&lt;/tr&gt;
 252  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_word_boundary&quot;&gt;{@code \B}&lt;/th&gt;
 253  *     &lt;td headers=&quot;matches bounds non_word_boundary&quot;&gt;A non-word boundary&lt;/td&gt;&lt;/tr&gt;
 254  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;begin_input&quot;&gt;{@code \A}&lt;/th&gt;
 255  *     &lt;td headers=&quot;matches bounds begin_input&quot;&gt;The beginning of the input&lt;/td&gt;&lt;/tr&gt;
 256  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;end_prev_match&quot;&gt;{@code \G}&lt;/th&gt;
 257  *     &lt;td headers=&quot;matches bounds end_prev_match&quot;&gt;The end of the previous match&lt;/td&gt;&lt;/tr&gt;
 258  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;end_input_except_term&quot;&gt;{@code \Z}&lt;/th&gt;
 259  *     &lt;td headers=&quot;matches bounds end_input_except_term&quot;&gt;The end of the input but for the final
 260  *         &lt;a href=&quot;#lt&quot;&gt;terminator&lt;/a&gt;, if&amp;nbsp;any&lt;/td&gt;&lt;/tr&gt;
 261  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;end_input&quot;&gt;{@code \z}&lt;/th&gt;
 262  *     &lt;td headers=&quot;matches bounds end_input&quot;&gt;The end of the input&lt;/td&gt;&lt;/tr&gt;
 263  *
 264  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;linebreak&quot;&gt;Linebreak matcher&lt;/th&gt;&lt;/tr&gt;
 265  *
 266  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;any_unicode_linebreak&quot;&gt;{@code \R}&lt;/th&gt;
 267  *     &lt;td headers=&quot;matches linebreak any_unicode_linebreak&quot;&gt;Any Unicode linebreak sequence, is equivalent to
 268  *     &lt;code&gt;&amp;#92;u000D&amp;#92;u000A|[&amp;#92;u000A&amp;#92;u000B&amp;#92;u000C&amp;#92;u000D&amp;#92;u0085&amp;#92;u2028&amp;#92;u2029]
 269  *     &lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 270  *
 271  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;grapheme&quot;&gt;Unicode Extended Grapheme matcher&lt;/th&gt;&lt;/tr&gt;
 272  *
 273  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;grapheme_any&quot;&gt;{@code \X}&lt;/th&gt;
 274  *     &lt;td headers=&quot;matches grapheme grapheme_any&quot;&gt;Any Unicode extended grapheme cluster&lt;/td&gt;&lt;/tr&gt;
 275  *
 276  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;greedy&quot;&gt;Greedy quantifiers&lt;/th&gt;&lt;/tr&gt;
 277  *
 278  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code ?}&lt;/th&gt;
 279  *     &lt;td headers=&quot;matches greedy greedy_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
 280  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code *}&lt;/th&gt;
 281  *     &lt;td headers=&quot;matches greedy greedy_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
 282  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code +}&lt;/th&gt;
 283  *     &lt;td headers=&quot;matches greedy greedy_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
 284  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}&lt;/code&gt;&lt;/th&gt;
 285  *     &lt;td headers=&quot;matches greedy greedy_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 286  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;{@code ,}}&lt;/th&gt;
 287  *     &lt;td headers=&quot;matches greedy greedy_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 288  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;{@code ,}&lt;i&gt;m&lt;/i&gt;&lt;code&gt;}&lt;/code&gt;&lt;/th&gt;
 289  *     &lt;td headers=&quot;matches greedy greedy_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 290  *
 291  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;reluc&quot;&gt;Reluctant quantifiers&lt;/th&gt;&lt;/tr&gt;
 292  *
 293  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code ??}&lt;/th&gt;
 294  *     &lt;td headers=&quot;matches reluc reluc_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
 295  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code *?}&lt;/th&gt;
 296  *     &lt;td headers=&quot;matches reluc reluc_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
 297  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code +?}&lt;/th&gt;
 298  *     &lt;td headers=&quot;matches reluc reluc_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
 299  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}?&lt;/code&gt;&lt;/th&gt;
 300  *     &lt;td headers=&quot;matches reluc reluc_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 301  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;,}?&lt;/code&gt;&lt;/th&gt;
 302  *     &lt;td headers=&quot;matches reluc reluc_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 303  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;{@code ,}&lt;i&gt;m&lt;/i&gt;&lt;code&gt;}?&lt;/code&gt;&lt;/th&gt;
 304  *     &lt;td headers=&quot;matches reluc reluc_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 305  *
 306  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;poss&quot;&gt;Possessive quantifiers&lt;/th&gt;&lt;/tr&gt;
 307  *
 308  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code ?+}&lt;/th&gt;
 309  *     &lt;td headers=&quot;matches poss poss_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
 310  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code *+}&lt;/th&gt;
 311  *     &lt;td headers=&quot;matches poss poss_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
 312  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code ++}&lt;/th&gt;
 313  *     &lt;td headers=&quot;matches poss poss_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
 314  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}+&lt;/code&gt;&lt;/th&gt;
 315  *     &lt;td headers=&quot;matches poss poss_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 316  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;,}+&lt;/code&gt;&lt;/th&gt;
 317  *     &lt;td headers=&quot;matches poss poss_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 318  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;{@code ,}&lt;i&gt;m&lt;/i&gt;&lt;code&gt;}+&lt;/code&gt;&lt;/th&gt;
 319  *     &lt;td headers=&quot;matches poss poss_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 320  *
 321  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;logical&quot;&gt;Logical operators&lt;/th&gt;&lt;/tr&gt;
 322  *
 323  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;concat&quot;&gt;&lt;i&gt;XY&lt;/i&gt;&lt;/th&gt;
 324  *     &lt;td headers=&quot;matches logical concat&quot;&gt;&lt;i&gt;X&lt;/i&gt; followed by &lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 325  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;alternate&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code |}&lt;i&gt;Y&lt;/i&gt;&lt;/th&gt;
 326  *     &lt;td headers=&quot;matches logical alternate&quot;&gt;Either &lt;i&gt;X&lt;/i&gt; or &lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 327  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;group&quot;&gt;{@code (}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 328  *     &lt;td headers=&quot;matches logical group&quot;&gt;X, as a &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
 329  *
 330  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;backref&quot;&gt;Back references&lt;/th&gt;&lt;/tr&gt;
 331  *
 332  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;back_nth&quot;&gt;{@code \}&lt;i&gt;n&lt;/i&gt;&lt;/th&gt;
 333  *     &lt;td headers=&quot;matches backref back_nth&quot;&gt;Whatever the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;
 334  *     &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; matched&lt;/td&gt;&lt;/tr&gt;
 335  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;back_named&quot;&gt;{@code \}&lt;i&gt;k&lt;/i&gt;&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/th&gt;
 336  *     &lt;td headers=&quot;matches backref back_named&quot;&gt;Whatever the
 337  *     &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt; &quot;name&quot; matched&lt;/td&gt;&lt;/tr&gt;
 338  *
 339  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;quote&quot;&gt;Quotation&lt;/th&gt;&lt;/tr&gt;
 340  *
 341  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_follow&quot;&gt;{@code \}&lt;/th&gt;
 342  *     &lt;td headers=&quot;matches quote quote_follow&quot;&gt;Nothing, but quotes the following character&lt;/td&gt;&lt;/tr&gt;
 343  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_begin&quot;&gt;{@code \Q}&lt;/th&gt;
 344  *     &lt;td headers=&quot;matches quote quote_begin&quot;&gt;Nothing, but quotes all characters until {@code \E}&lt;/td&gt;&lt;/tr&gt;
 345  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_end&quot;&gt;{@code \E}&lt;/th&gt;
 346  *     &lt;td headers=&quot;matches quote quote_end&quot;&gt;Nothing, but ends quoting started by {@code \Q}&lt;/td&gt;&lt;/tr&gt;
 347  *     &lt;!-- Metachars: !$()*+.&lt;&gt;?[\]^{|} --&gt;
 348  *
 349  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;special&quot;&gt;Special constructs (named-capturing and non-capturing)&lt;/th&gt;&lt;/tr&gt;
 350  *
 351  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;named_group&quot;&gt;&lt;code&gt;(?&amp;lt;&lt;a href=&quot;#groupname&quot;&gt;name&lt;/a&gt;&amp;gt;&lt;/code&gt;&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 352  *     &lt;td headers=&quot;matches special named_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a named-capturing group&lt;/td&gt;&lt;/tr&gt;
 353  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group&quot;&gt;{@code (?:}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 354  *     &lt;td headers=&quot;matches special non_capture_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a non-capturing group&lt;/td&gt;&lt;/tr&gt;
 355  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;flags&quot;&gt;&lt;code&gt;(?idmsuxU-idmsuxU)&amp;nbsp;&lt;/code&gt;&lt;/th&gt;
 356  *     &lt;td headers=&quot;matches special flags&quot;&gt;Nothing, but turns match flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt;
 357  * &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt; &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt;
 358  * &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a&gt; &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt;
 359  * on - off&lt;/td&gt;&lt;/tr&gt;
 360  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group_flags&quot;&gt;{@code (?idmsuxU-idmsuxU:}&lt;i&gt;X&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 361  *     &lt;td headers=&quot;matches special non_capture_group_flags&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a &lt;a href=&quot;#cg&quot;&gt;non-capturing group&lt;/a&gt; with the
 362  *         given flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt; &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt;
 363  * &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt; &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a &gt;
 364  * &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt; on - off&lt;/td&gt;&lt;/tr&gt;
 365  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookahead&quot;&gt;{@code (?=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 366  *     &lt;td headers=&quot;matches special pos_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookahead&lt;/td&gt;&lt;/tr&gt;
 367  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;neg_lookahead&quot;&gt;{@code (?!}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 368  *     &lt;td headers=&quot;matches special neg_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookahead&lt;/td&gt;&lt;/tr&gt;
 369  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookbehind&quot;&gt;{@code (?&lt;=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 370  *     &lt;td headers=&quot;matches special pos_lookbehind&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookbehind&lt;/td&gt;&lt;/tr&gt;
 371  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;neg_lookbehind&quot;&gt;{@code (?&lt;!}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 372  *     &lt;td headers=&quot;matches special neg_lookbehind&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookbehind&lt;/td&gt;&lt;/tr&gt;
 373  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;indep_non_capture_group&quot;&gt;{@code (?&gt;}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 374  *     &lt;td headers=&quot;matches special indep_non_capture_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as an independent, non-capturing group&lt;/td&gt;&lt;/tr&gt;
 375  *
 376  * &lt;/tbody&gt;
 377  * &lt;/table&gt;
 378  *
 379  * &lt;hr&gt;
 380  *
 381  *
 382  * &lt;h2&gt;&lt;a id=&quot;bs&quot;&gt;Backslashes, escapes, and quoting&lt;/a&gt;&lt;/h2&gt;
 383  *
 384  * &lt;p&gt; The backslash character ({@code &#39;\&#39;}) serves to introduce escaped
 385  * constructs, as defined in the table above, as well as to quote characters
 386  * that otherwise would be interpreted as unescaped constructs.  Thus the
 387  * expression {@code \\} matches a single backslash and &lt;code&gt;\{&lt;/code&gt; matches a
 388  * left brace.
 389  *
 390  * &lt;p&gt; It is an error to use a backslash prior to any alphabetic character that
 391  * does not denote an escaped construct; these are reserved for future
 392  * extensions to the regular-expression language.  A backslash may be used
 393  * prior to a non-alphabetic character regardless of whether that character is
 394  * part of an unescaped construct.
 395  *
 396  * &lt;p&gt; Backslashes within string literals in Java source code are interpreted
 397  * as required by
 398  * &lt;cite&gt;The Java Language Specification&lt;/cite&gt;
 399  * as either Unicode escapes (section {@jls 3.3}) or other character escapes (section {@jls 3.10.6})
 400  * It is therefore necessary to double backslashes in string
 401  * literals that represent regular expressions to protect them from
 402  * interpretation by the Java bytecode compiler.  The string literal
 403  * &lt;code&gt;&quot;&amp;#92;b&quot;&lt;/code&gt;, for example, matches a single backspace character when
 404  * interpreted as a regular expression, while {@code &quot;\\b&quot;} matches a
 405  * word boundary.  The string literal {@code &quot;\(hello\)&quot;} is illegal
 406  * and leads to a compile-time error; in order to match the string
 407  * {@code (hello)} the string literal {@code &quot;\\(hello\\)&quot;}
 408  * must be used.
 409  *
 410  * &lt;h2&gt;&lt;a id=&quot;cc&quot;&gt;Character Classes&lt;/a&gt;&lt;/h2&gt;
 411  *
 412  *    &lt;p&gt; Character classes may appear within other character classes, and
 413  *    may be composed by the union operator (implicit) and the intersection
 414  *    operator ({@code &amp;&amp;}).
 415  *    The union operator denotes a class that contains every character that is
 416  *    in at least one of its operand classes.  The intersection operator
 417  *    denotes a class that contains every character that is in both of its
 418  *    operand classes.
 419  *
 420  *    &lt;p&gt; The precedence of character-class operators is as follows, from
 421  *    highest to lowest:
 422  *
 423  *    &lt;table class=&quot;striped&quot; style=&quot;margin-left: 2em;&quot;&gt;
 424  *      &lt;caption style=&quot;display:none&quot;&gt;Precedence of character class operators.&lt;/caption&gt;
 425  *      &lt;thead&gt;
 426  *      &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Precedence&lt;th scope=&quot;col&quot;&gt;Name&lt;th scope=&quot;col&quot;&gt;Example
 427  *      &lt;/thead&gt;
 428  *      &lt;tbody&gt;
 429  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
 430  *        &lt;td&gt;Literal escape&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
 431  *        &lt;td&gt;{@code \x}&lt;/td&gt;&lt;/tr&gt;
 432  *     &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2&lt;/th&gt;
 433  *        &lt;td&gt;Grouping&lt;/td&gt;
 434  *        &lt;td&gt;{@code [...]}&lt;/td&gt;&lt;/tr&gt;
 435  *     &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
 436  *        &lt;td&gt;Range&lt;/td&gt;
 437  *        &lt;td&gt;{@code a-z}&lt;/td&gt;&lt;/tr&gt;
 438  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;4&lt;/th&gt;
 439  *        &lt;td&gt;Union&lt;/td&gt;
 440  *        &lt;td&gt;{@code [a-e][i-u]}&lt;/td&gt;&lt;/tr&gt;
 441  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;5&lt;/th&gt;
 442  *        &lt;td&gt;Intersection&lt;/td&gt;
 443  *        &lt;td&gt;{@code [a-z&amp;&amp;[aeiou]]}&lt;/td&gt;&lt;/tr&gt;
 444  *      &lt;/tbody&gt;
 445  *    &lt;/table&gt;
 446  *
 447  *    &lt;p&gt; Note that a different set of metacharacters are in effect inside
 448  *    a character class than outside a character class. For instance, the
 449  *    regular expression {@code .} loses its special meaning inside a
 450  *    character class, while the expression {@code -} becomes a range
 451  *    forming metacharacter.
 452  *
 453  * &lt;h2&gt;&lt;a id=&quot;lt&quot;&gt;Line terminators&lt;/a&gt;&lt;/h2&gt;
 454  *
 455  * &lt;p&gt; A &lt;i&gt;line terminator&lt;/i&gt; is a one- or two-character sequence that marks
 456  * the end of a line of the input character sequence.  The following are
 457  * recognized as line terminators:
 458  *
 459  * &lt;ul&gt;
 460  *
 461  *   &lt;li&gt; A newline (line feed) character ({@code &#39;\n&#39;}),
 462  *
 463  *   &lt;li&gt; A carriage-return character followed immediately by a newline
 464  *   character ({@code &quot;\r\n&quot;}),
 465  *
 466  *   &lt;li&gt; A standalone carriage-return character ({@code &#39;\r&#39;}),
 467  *
 468  *   &lt;li&gt; A next-line character (&lt;code&gt;&#39;&amp;#92;u0085&#39;&lt;/code&gt;),
 469  *
 470  *   &lt;li&gt; A line-separator character (&lt;code&gt;&#39;&amp;#92;u2028&#39;&lt;/code&gt;), or
 471  *
 472  *   &lt;li&gt; A paragraph-separator character (&lt;code&gt;&#39;&amp;#92;u2029&#39;&lt;/code&gt;).
 473  *
 474  * &lt;/ul&gt;
 475  * &lt;p&gt;If {@link #UNIX_LINES} mode is activated, then the only line terminators
 476  * recognized are newline characters.
 477  *
 478  * &lt;p&gt; The regular expression {@code .} matches any character except a line
 479  * terminator unless the {@link #DOTALL} flag is specified.
 480  *
 481  * &lt;p&gt; By default, the regular expressions {@code ^} and {@code $} ignore
 482  * line terminators and only match at the beginning and the end, respectively,
 483  * of the entire input sequence. If {@link #MULTILINE} mode is activated then
 484  * {@code ^} matches at the beginning of input and after any line terminator
 485  * except at the end of input. When in {@link #MULTILINE} mode {@code $}
 486  * matches just before a line terminator or the end of the input sequence.
 487  *
 488  * &lt;h2&gt;&lt;a id=&quot;cg&quot;&gt;Groups and capturing&lt;/a&gt;&lt;/h2&gt;
 489  *
 490  * &lt;h3&gt;&lt;a id=&quot;gnumber&quot;&gt;Group number&lt;/a&gt;&lt;/h3&gt;
 491  * &lt;p&gt; Capturing groups are numbered by counting their opening parentheses from
 492  * left to right.  In the expression {@code ((A)(B(C)))}, for example, there
 493  * are four such groups: &lt;/p&gt;
 494  *
 495  * &lt;ol style=&quot;margin-left:2em;&quot;&gt;
 496  *   &lt;li&gt; {@code ((A)(B(C)))}
 497  *   &lt;li&gt; {@code (A)}
 498  *   &lt;li&gt; {@code (B(C))}
 499  *   &lt;li&gt; {@code (C)}
 500  * &lt;/ol&gt;
 501  *
 502  * &lt;p&gt; Group zero always stands for the entire expression.
 503  *
 504  * &lt;p&gt; Capturing groups are so named because, during a match, each subsequence
 505  * of the input sequence that matches such a group is saved.  The captured
 506  * subsequence may be used later in the expression, via a back reference, and
 507  * may also be retrieved from the matcher once the match operation is complete.
 508  *
 509  * &lt;h3&gt;&lt;a id=&quot;groupname&quot;&gt;Group name&lt;/a&gt;&lt;/h3&gt;
 510  * &lt;p&gt;A capturing group can also be assigned a &quot;name&quot;, a {@code named-capturing group},
 511  * and then be back-referenced later by the &quot;name&quot;. Group names are composed of
 512  * the following characters. The first character must be a {@code letter}.
 513  *
 514  * &lt;ul&gt;
 515  *   &lt;li&gt; The uppercase letters {@code &#39;A&#39;} through {@code &#39;Z&#39;}
 516  *        (&lt;code&gt;&#39;&amp;#92;u0041&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u005a&#39;&lt;/code&gt;),
 517  *   &lt;li&gt; The lowercase letters {@code &#39;a&#39;} through {@code &#39;z&#39;}
 518  *        (&lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u007a&#39;&lt;/code&gt;),
 519  *   &lt;li&gt; The digits {@code &#39;0&#39;} through {@code &#39;9&#39;}
 520  *        (&lt;code&gt;&#39;&amp;#92;u0030&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u0039&#39;&lt;/code&gt;),
 521  * &lt;/ul&gt;
 522  *
 523  * &lt;p&gt; A {@code named-capturing group} is still numbered as described in
 524  * &lt;a href=&quot;#gnumber&quot;&gt;Group number&lt;/a&gt;.
 525  *
 526  * &lt;p&gt; The captured input associated with a group is always the subsequence
 527  * that the group most recently matched.  If a group is evaluated a second time
 528  * because of quantification then its previously-captured value, if any, will
 529  * be retained if the second evaluation fails.  Matching the string
 530  * {@code &quot;aba&quot;} against the expression {@code (a(b)?)+}, for example, leaves
 531  * group two set to {@code &quot;b&quot;}.  All captured input is discarded at the
 532  * beginning of each match.
 533  *
 534  * &lt;p&gt; Groups beginning with {@code (?} are either pure, &lt;i&gt;non-capturing&lt;/i&gt; groups
 535  * that do not capture text and do not count towards the group total, or
 536  * &lt;i&gt;named-capturing&lt;/i&gt; group.
 537  *
 538  * &lt;h2&gt; Unicode support &lt;/h2&gt;
 539  *
 540  * &lt;p&gt; This class is in conformance with Level 1 of &lt;a
 541  * href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
 542  * Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;, plus RL2.1
 543  * Canonical Equivalents and RL2.2 Extended Grapheme Clusters.
 544  * &lt;p&gt;
 545  * &lt;b&gt;Unicode escape sequences&lt;/b&gt; such as &lt;code&gt;&amp;#92;u2014&lt;/code&gt; in Java source code
 546  * are processed as described in section {@jls 3.3} of
 547  * &lt;cite&gt;The Java Language Specification&lt;/cite&gt;.
 548  * Such escape sequences are also implemented directly by the regular-expression
 549  * parser so that Unicode escapes can be used in expressions that are read from
 550  * files or from the keyboard.  Thus the strings &lt;code&gt;&quot;&amp;#92;u2014&quot;&lt;/code&gt; and
 551  * {@code &quot;\\u2014&quot;}, while not equal, compile into the same pattern, which
 552  * matches the character with hexadecimal value {@code 0x2014}.
 553  * &lt;p&gt;
 554  * A Unicode character can also be represented by using its &lt;b&gt;Hex notation&lt;/b&gt;
 555  * (hexadecimal code point value) directly as described in construct
 556  * &lt;code&gt;&amp;#92;x{...}&lt;/code&gt;, for example a supplementary character U+2011F can be
 557  * specified as &lt;code&gt;&amp;#92;x{2011F}&lt;/code&gt;, instead of two consecutive Unicode escape
 558  * sequences of the surrogate pair &lt;code&gt;&amp;#92;uD840&lt;/code&gt;&lt;code&gt;&amp;#92;uDD1F&lt;/code&gt;.
 559  * &lt;p&gt;
 560  * &lt;b&gt;Unicode character names&lt;/b&gt; are supported by the named character construct
 561  * &lt;code&gt;\N{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt;, for example, &lt;code&gt;\N{WHITE SMILING FACE}&lt;/code&gt;
 562  * specifies character &lt;code&gt;&amp;#92;u263A&lt;/code&gt;. The character names supported
 563  * by this class are the valid Unicode character names matched by
 564  * {@link java.lang.Character#codePointOf(String) Character.codePointOf(name)}.
 565  * &lt;p&gt;
 566  * &lt;a href=&quot;http://www.unicode.org/reports/tr18/#Default_Grapheme_Clusters&quot;&gt;
 567  * &lt;b&gt;Unicode extended grapheme clusters&lt;/b&gt;&lt;/a&gt; are supported by the grapheme
 568  * cluster matcher {@code \X} and the corresponding boundary matcher {@code \b{g}}.
 569  * &lt;p&gt;
 570  * Unicode scripts, blocks, categories and binary properties are written with
 571  * the {@code \p} and {@code \P} constructs as in Perl.
 572  * &lt;code&gt;\p{&lt;/code&gt;&lt;i&gt;prop&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; matches if
 573  * the input has the property &lt;i&gt;prop&lt;/i&gt;, while &lt;code&gt;\P{&lt;/code&gt;&lt;i&gt;prop&lt;/i&gt;&lt;code&gt;}&lt;/code&gt;
 574  * does not match if the input has that property.
 575  * &lt;p&gt;
 576  * Scripts, blocks, categories and binary properties can be used both inside
 577  * and outside of a character class.
 578  *
 579  * &lt;p&gt;
 580  * &lt;b&gt;&lt;a id=&quot;usc&quot;&gt;Scripts&lt;/a&gt;&lt;/b&gt; are specified either with the prefix {@code Is}, as in
 581  * {@code IsHiragana}, or by using  the {@code script} keyword (or its short
 582  * form {@code sc}) as in {@code script=Hiragana} or {@code sc=Hiragana}.
 583  * &lt;p&gt;
 584  * The script names supported by {@code Pattern} are the valid script names
 585  * accepted and defined by
 586  * {@link java.lang.Character.UnicodeScript#forName(String) UnicodeScript.forName}.
 587  *
 588  * &lt;p&gt;
 589  * &lt;b&gt;&lt;a id=&quot;ubc&quot;&gt;Blocks&lt;/a&gt;&lt;/b&gt; are specified with the prefix {@code In}, as in
 590  * {@code InMongolian}, or by using the keyword {@code block} (or its short
 591  * form {@code blk}) as in {@code block=Mongolian} or {@code blk=Mongolian}.
 592  * &lt;p&gt;
 593  * The block names supported by {@code Pattern} are the valid block names
 594  * accepted and defined by
 595  * {@link java.lang.Character.UnicodeBlock#forName(String) UnicodeBlock.forName}.
 596  * &lt;p&gt;
 597  *
 598  * &lt;b&gt;&lt;a id=&quot;ucc&quot;&gt;Categories&lt;/a&gt;&lt;/b&gt; may be specified with the optional prefix {@code Is}:
 599  * Both {@code \p{L}} and {@code \p{IsL}} denote the category of Unicode
 600  * letters. Same as scripts and blocks, categories can also be specified
 601  * by using the keyword {@code general_category} (or its short form
 602  * {@code gc}) as in {@code general_category=Lu} or {@code gc=Lu}.
 603  * &lt;p&gt;
 604  * The supported categories are those of
 605  * &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;
 606  * &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the
 607  * {@link java.lang.Character Character} class. The category names are those
 608  * defined in the Standard, both normative and informative.
 609  * &lt;p&gt;
 610  *
 611  * &lt;b&gt;&lt;a id=&quot;ubpc&quot;&gt;Binary properties&lt;/a&gt;&lt;/b&gt; are specified with the prefix {@code Is}, as in
 612  * {@code IsAlphabetic}. The supported binary properties by {@code Pattern}
 613  * are
 614  * &lt;ul&gt;
 615  *   &lt;li&gt; Alphabetic
 616  *   &lt;li&gt; Ideographic
 617  *   &lt;li&gt; Letter
 618  *   &lt;li&gt; Lowercase
 619  *   &lt;li&gt; Uppercase
 620  *   &lt;li&gt; Titlecase
 621  *   &lt;li&gt; Punctuation
 622  *   &lt;Li&gt; Control
 623  *   &lt;li&gt; White_Space
 624  *   &lt;li&gt; Digit
 625  *   &lt;li&gt; Hex_Digit
 626  *   &lt;li&gt; Join_Control
 627  *   &lt;li&gt; Noncharacter_Code_Point
 628  *   &lt;li&gt; Assigned
 629  * &lt;/ul&gt;
 630  * &lt;p&gt;
 631  * The following &lt;b&gt;Predefined Character classes&lt;/b&gt; and &lt;b&gt;POSIX character classes&lt;/b&gt;
 632  * are in conformance with the recommendation of &lt;i&gt;Annex C: Compatibility Properties&lt;/i&gt;
 633  * of &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Regular Expression
 634  * &lt;/i&gt;&lt;/a&gt;, when {@link #UNICODE_CHARACTER_CLASS} flag is specified.
 635  *
 636  * &lt;table class=&quot;striped&quot;&gt;
 637  * &lt;caption style=&quot;display:none&quot;&gt;predefined and posix character classes in Unicode mode&lt;/caption&gt;
 638  * &lt;thead&gt;
 639  * &lt;tr&gt;
 640  * &lt;th scope=&quot;col&quot; id=&quot;predef_classes&quot;&gt;Classes&lt;/th&gt;
 641  * &lt;th scope=&quot;col&quot; id=&quot;predef_matches&quot;&gt;Matches&lt;/th&gt;
 642  * &lt;/tr&gt;
 643  * &lt;/thead&gt;
 644  * &lt;tbody&gt;
 645  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Lower}}&lt;/th&gt;
 646  *     &lt;td&gt;A lowercase character:{@code \p{IsLowercase}}&lt;/td&gt;&lt;/tr&gt;
 647  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Upper}}&lt;/th&gt;
 648  *     &lt;td&gt;An uppercase character:{@code \p{IsUppercase}}&lt;/td&gt;&lt;/tr&gt;
 649  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{ASCII}}&lt;/th&gt;
 650  *     &lt;td&gt;All ASCII:{@code [\x00-\x7F]}&lt;/td&gt;&lt;/tr&gt;
 651  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Alpha}}&lt;/th&gt;
 652  *     &lt;td&gt;An alphabetic character:{@code \p{IsAlphabetic}}&lt;/td&gt;&lt;/tr&gt;
 653  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Digit}}&lt;/th&gt;
 654  *     &lt;td&gt;A decimal digit character:{@code \p{IsDigit}}&lt;/td&gt;&lt;/tr&gt;
 655  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Alnum}}&lt;/th&gt;
 656  *     &lt;td&gt;An alphanumeric character:{@code [\p{IsAlphabetic}\p{IsDigit}]}&lt;/td&gt;&lt;/tr&gt;
 657  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Punct}}&lt;/th&gt;
 658  *     &lt;td&gt;A punctuation character:{@code \p{IsPunctuation}}&lt;/td&gt;&lt;/tr&gt;
 659  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Graph}}&lt;/th&gt;
 660  *     &lt;td&gt;A visible character: {@code [^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}]}&lt;/td&gt;&lt;/tr&gt;
 661  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Print}}&lt;/th&gt;
 662  *     &lt;td&gt;A printable character: {@code [\p{Graph}\p{Blank}&amp;&amp;[^\p{Cntrl}]]}&lt;/td&gt;&lt;/tr&gt;
 663  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Blank}}&lt;/th&gt;
 664  *     &lt;td&gt;A space or a tab: {@code [\p{IsWhite_Space}&amp;&amp;[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]]}&lt;/td&gt;&lt;/tr&gt;
 665  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Cntrl}}&lt;/th&gt;
 666  *     &lt;td&gt;A control character: {@code \p{gc=Cc}}&lt;/td&gt;&lt;/tr&gt;
 667  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{XDigit}}&lt;/th&gt;
 668  *     &lt;td&gt;A hexadecimal digit: {@code [\p{gc=Nd}\p{IsHex_Digit}]}&lt;/td&gt;&lt;/tr&gt;
 669  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Space}}&lt;/th&gt;
 670  *     &lt;td&gt;A whitespace character:{@code \p{IsWhite_Space}}&lt;/td&gt;&lt;/tr&gt;
 671  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \d}&lt;/th&gt;
 672  *     &lt;td&gt;A digit: {@code \p{IsDigit}}&lt;/td&gt;&lt;/tr&gt;
 673  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \D}&lt;/th&gt;
 674  *     &lt;td&gt;A non-digit: {@code [^\d]}&lt;/td&gt;&lt;/tr&gt;
 675  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \s}&lt;/th&gt;
 676  *     &lt;td&gt;A whitespace character: {@code \p{IsWhite_Space}}&lt;/td&gt;&lt;/tr&gt;
 677  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \S}&lt;/th&gt;
 678  *     &lt;td&gt;A non-whitespace character: {@code [^\s]}&lt;/td&gt;&lt;/tr&gt;
 679  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \w}&lt;/th&gt;
 680  *     &lt;td&gt;A word character: {@code [\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}]}&lt;/td&gt;&lt;/tr&gt;
 681  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \W}&lt;/th&gt;
 682  *     &lt;td&gt;A non-word character: {@code [^\w]}&lt;/td&gt;&lt;/tr&gt;
 683  * &lt;/tbody&gt;
 684  * &lt;/table&gt;
 685  * &lt;p&gt;
 686  * &lt;a id=&quot;jcc&quot;&gt;
 687  * Categories that behave like the java.lang.Character
 688  * boolean is&lt;i&gt;methodname&lt;/i&gt; methods (except for the deprecated ones) are
 689  * available through the same &lt;code&gt;\p{&lt;/code&gt;&lt;i&gt;prop&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; syntax where
 690  * the specified property has the name &lt;code&gt;java&lt;i&gt;methodname&lt;/i&gt;&lt;/code&gt;&lt;/a&gt;.
 691  *
 692  * &lt;h2&gt; Comparison to Perl 5 &lt;/h2&gt;
 693  *
 694  * &lt;p&gt;The {@code Pattern} engine performs traditional NFA-based matching
 695  * with ordered alternation as occurs in Perl 5.
 696  *
 697  * &lt;p&gt; Perl constructs not supported by this class: &lt;/p&gt;
 698  *
 699  * &lt;ul&gt;
 700  *    &lt;li&gt;&lt;p&gt; The backreference constructs, &lt;code&gt;\g{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; for
 701  *    the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;&lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; and
 702  *    &lt;code&gt;\g{&lt;/code&gt;&lt;i&gt;name&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; for
 703  *    &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt;.
 704  *    &lt;/p&gt;&lt;/li&gt;
 705  *
 706  *    &lt;li&gt;&lt;p&gt; The conditional constructs
 707  *    {@code (?(}&lt;i&gt;condition&lt;/i&gt;{@code )}&lt;i&gt;X&lt;/i&gt;{@code )} and
 708  *    {@code (?(}&lt;i&gt;condition&lt;/i&gt;{@code )}&lt;i&gt;X&lt;/i&gt;{@code |}&lt;i&gt;Y&lt;/i&gt;{@code )},
 709  *    &lt;/p&gt;&lt;/li&gt;
 710  *
 711  *    &lt;li&gt;&lt;p&gt; The embedded code constructs &lt;code&gt;(?{&lt;/code&gt;&lt;i&gt;code&lt;/i&gt;&lt;code&gt;})&lt;/code&gt;
 712  *    and &lt;code&gt;(??{&lt;/code&gt;&lt;i&gt;code&lt;/i&gt;&lt;code&gt;})&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;
 713  *
 714  *    &lt;li&gt;&lt;p&gt; The embedded comment syntax {@code (?#comment)}, and &lt;/p&gt;&lt;/li&gt;
 715  *
 716  *    &lt;li&gt;&lt;p&gt; The preprocessing operations {@code \l} &lt;code&gt;&amp;#92;u&lt;/code&gt;,
 717  *    {@code \L}, and {@code \U}.  &lt;/p&gt;&lt;/li&gt;
 718  *
 719  * &lt;/ul&gt;
 720  *
 721  * &lt;p&gt; Constructs supported by this class but not by Perl: &lt;/p&gt;
 722  *
 723  * &lt;ul&gt;
 724  *
 725  *    &lt;li&gt;&lt;p&gt; Character-class union and intersection as described
 726  *    &lt;a href=&quot;#cc&quot;&gt;above&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
 727  *
 728  * &lt;/ul&gt;
 729  *
 730  * &lt;p&gt; Notable differences from Perl: &lt;/p&gt;
 731  *
 732  * &lt;ul&gt;
 733  *
 734  *    &lt;li&gt;&lt;p&gt; In Perl, {@code \1} through {@code \9} are always interpreted
 735  *    as back references; a backslash-escaped number greater than {@code 9} is
 736  *    treated as a back reference if at least that many subexpressions exist,
 737  *    otherwise it is interpreted, if possible, as an octal escape.  In this
 738  *    class octal escapes must always begin with a zero. In this class,
 739  *    {@code \1} through {@code \9} are always interpreted as back
 740  *    references, and a larger number is accepted as a back reference if at
 741  *    least that many subexpressions exist at that point in the regular
 742  *    expression, otherwise the parser will drop digits until the number is
 743  *    smaller or equal to the existing number of groups or it is one digit.
 744  *    &lt;/p&gt;&lt;/li&gt;
 745  *
 746  *    &lt;li&gt;&lt;p&gt; Perl uses the {@code g} flag to request a match that resumes
 747  *    where the last match left off.  This functionality is provided implicitly
 748  *    by the {@link Matcher} class: Repeated invocations of the {@link
 749  *    Matcher#find find} method will resume where the last match left off,
 750  *    unless the matcher is reset.  &lt;/p&gt;&lt;/li&gt;
 751  *
 752  *    &lt;li&gt;&lt;p&gt; In Perl, embedded flags at the top level of an expression affect
 753  *    the whole expression.  In this class, embedded flags always take effect
 754  *    at the point at which they appear, whether they are at the top level or
 755  *    within a group; in the latter case, flags are restored at the end of the
 756  *    group just as in Perl.  &lt;/p&gt;&lt;/li&gt;
 757  *
 758  * &lt;/ul&gt;
 759  *
 760  *
 761  * &lt;p&gt; For a more precise description of the behavior of regular expression
 762  * constructs, please see &lt;a href=&quot;http://www.oreilly.com/catalog/regex3/&quot;&gt;
 763  * &lt;i&gt;Mastering Regular Expressions, 3rd Edition&lt;/i&gt;, Jeffrey E. F. Friedl,
 764  * O&#39;Reilly and Associates, 2006.&lt;/a&gt;
 765  * &lt;/p&gt;
 766  *
 767  * @see java.lang.String#split(String, int)
 768  * @see java.lang.String#split(String)
 769  *
 770  * @author      Mike McCloskey
 771  * @author      Mark Reinhold
 772  * @author      JSR-51 Expert Group
 773  * @since       1.4
 774  * @spec        JSR-51
 775  */
 776 
 777 public final class Pattern
 778     implements java.io.Serializable
 779 {
 780 
 781     /*
 782      * Regular expression modifier values.  Instead of being passed as
 783      * arguments, they can also be passed as inline modifiers.
 784      * For example, the following statements have the same effect.
 785      *
 786      *   Pattern p1 = Pattern.compile(&quot;abc&quot;, Pattern.CASE_INSENSITIVE|Pattern.MULTILINE);
 787      *   Pattern p2 = Pattern.compile(&quot;(?im)abc&quot;, 0);
 788      */
 789 
 790     /**
 791      * Enables Unix lines mode.
 792      *
 793      * &lt;p&gt; In this mode, only the {@code &#39;\n&#39;} line terminator is recognized
 794      * in the behavior of {@code .}, {@code ^}, and {@code $}.
 795      *
 796      * &lt;p&gt; Unix lines mode can also be enabled via the embedded flag
 797      * expression&amp;nbsp;{@code (?d)}.
 798      */
 799     public static final int UNIX_LINES = 0x01;
 800 
 801     /**
 802      * Enables case-insensitive matching.
 803      *
 804      * &lt;p&gt; By default, case-insensitive matching assumes that only characters
 805      * in the US-ASCII charset are being matched.  Unicode-aware
 806      * case-insensitive matching can be enabled by specifying the {@link
 807      * #UNICODE_CASE} flag in conjunction with this flag.
 808      *
 809      * &lt;p&gt; Case-insensitive matching can also be enabled via the embedded flag
 810      * expression&amp;nbsp;{@code (?i)}.
 811      *
 812      * &lt;p&gt; Specifying this flag may impose a slight performance penalty.  &lt;/p&gt;
 813      */
 814     public static final int CASE_INSENSITIVE = 0x02;
 815 
 816     /**
 817      * Permits whitespace and comments in pattern.
 818      *
 819      * &lt;p&gt; In this mode, whitespace is ignored, and embedded comments starting
 820      * with {@code #} are ignored until the end of a line.
 821      *
 822      * &lt;p&gt; Comments mode can also be enabled via the embedded flag
 823      * expression&amp;nbsp;{@code (?x)}.
 824      */
 825     public static final int COMMENTS = 0x04;
 826 
 827     /**
 828      * Enables multiline mode.
 829      *
 830      * &lt;p&gt; In multiline mode the expressions {@code ^} and {@code $} match
 831      * just after or just before, respectively, a line terminator or the end of
 832      * the input sequence.  By default these expressions only match at the
 833      * beginning and the end of the entire input sequence.
 834      *
 835      * &lt;p&gt; Multiline mode can also be enabled via the embedded flag
 836      * expression&amp;nbsp;{@code (?m)}.  &lt;/p&gt;
 837      */
 838     public static final int MULTILINE = 0x08;
 839 
 840     /**
 841      * Enables literal parsing of the pattern.
 842      *
 843      * &lt;p&gt; When this flag is specified then the input string that specifies
 844      * the pattern is treated as a sequence of literal characters.
 845      * Metacharacters or escape sequences in the input sequence will be
 846      * given no special meaning.
 847      *
 848      * &lt;p&gt;The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on
 849      * matching when used in conjunction with this flag. The other flags
 850      * become superfluous.
 851      *
 852      * &lt;p&gt; There is no embedded flag character for enabling literal parsing.
 853      * @since 1.5
 854      */
 855     public static final int LITERAL = 0x10;
 856 
 857     /**
 858      * Enables dotall mode.
 859      *
 860      * &lt;p&gt; In dotall mode, the expression {@code .} matches any character,
 861      * including a line terminator.  By default this expression does not match
 862      * line terminators.
 863      *
 864      * &lt;p&gt; Dotall mode can also be enabled via the embedded flag
 865      * expression&amp;nbsp;{@code (?s)}.  (The {@code s} is a mnemonic for
 866      * &quot;single-line&quot; mode, which is what this is called in Perl.)  &lt;/p&gt;
 867      */
 868     public static final int DOTALL = 0x20;
 869 
 870     /**
 871      * Enables Unicode-aware case folding.
 872      *
 873      * &lt;p&gt; When this flag is specified then case-insensitive matching, when
 874      * enabled by the {@link #CASE_INSENSITIVE} flag, is done in a manner
 875      * consistent with the Unicode Standard.  By default, case-insensitive
 876      * matching assumes that only characters in the US-ASCII charset are being
 877      * matched.
 878      *
 879      * &lt;p&gt; Unicode-aware case folding can also be enabled via the embedded flag
 880      * expression&amp;nbsp;{@code (?u)}.
 881      *
 882      * &lt;p&gt; Specifying this flag may impose a performance penalty.  &lt;/p&gt;
 883      */
 884     public static final int UNICODE_CASE = 0x40;
 885 
 886     /**
 887      * Enables canonical equivalence.
 888      *
 889      * &lt;p&gt; When this flag is specified then two characters will be considered
 890      * to match if, and only if, their full canonical decompositions match.
 891      * The expression &lt;code&gt;&quot;a&amp;#92;u030A&quot;&lt;/code&gt;, for example, will match the
 892      * string &lt;code&gt;&quot;&amp;#92;u00E5&quot;&lt;/code&gt; when this flag is specified.  By default,
 893      * matching does not take canonical equivalence into account.
 894      *
 895      * &lt;p&gt; There is no embedded flag character for enabling canonical
 896      * equivalence.
 897      *
 898      * &lt;p&gt; Specifying this flag may impose a performance penalty.  &lt;/p&gt;
 899      */
 900     public static final int CANON_EQ = 0x80;
 901 
 902     /**
 903      * Enables the Unicode version of &lt;i&gt;Predefined character classes&lt;/i&gt; and
 904      * &lt;i&gt;POSIX character classes&lt;/i&gt;.
 905      *
 906      * &lt;p&gt; When this flag is specified then the (US-ASCII only)
 907      * &lt;i&gt;Predefined character classes&lt;/i&gt; and &lt;i&gt;POSIX character classes&lt;/i&gt;
 908      * are in conformance with
 909      * &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
 910      * Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;
 911      * &lt;i&gt;Annex C: Compatibility Properties&lt;/i&gt;.
 912      * &lt;p&gt;
 913      * The UNICODE_CHARACTER_CLASS mode can also be enabled via the embedded
 914      * flag expression&amp;nbsp;{@code (?U)}.
 915      * &lt;p&gt;
 916      * The flag implies UNICODE_CASE, that is, it enables Unicode-aware case
 917      * folding.
 918      * &lt;p&gt;
 919      * Specifying this flag may impose a performance penalty.  &lt;/p&gt;
 920      * @since 1.7
 921      */
 922     public static final int UNICODE_CHARACTER_CLASS = 0x100;
 923 
 924     /**
 925      * Contains all possible flags for compile(regex, flags).
 926      */
 927     private static final int ALL_FLAGS = CASE_INSENSITIVE | MULTILINE |
 928             DOTALL | UNICODE_CASE | CANON_EQ | UNIX_LINES | LITERAL |
 929             UNICODE_CHARACTER_CLASS | COMMENTS;
 930 
 931     /* Pattern has only two serialized components: The pattern string
 932      * and the flags, which are all that is needed to recompile the pattern
 933      * when it is deserialized.
 934      */
 935 
 936     /** use serialVersionUID from Merlin b59 for interoperability */
 937     @java.io.Serial
 938     private static final long serialVersionUID = 5073258162644648461L;
 939 
 940     /**
 941      * The original regular-expression pattern string.
 942      *
 943      * @serial
 944      */
 945     private String pattern;
 946 
 947     /**
 948      * The original pattern flags.
 949      *
 950      * @serial
 951      */
 952     private int flags;
 953 
 954     /**
 955      * The temporary pattern flags used during compiling. The flags might be turn
 956      * on and off by embedded flag.
 957      */
 958     private transient int flags0;
 959 
 960     /**
 961      * Boolean indicating this Pattern is compiled; this is necessary in order
 962      * to lazily compile deserialized Patterns.
 963      */
 964     private transient volatile boolean compiled;
 965 
 966     /**
 967      * The normalized pattern string.
 968      */
 969     private transient String normalizedPattern;
 970 
 971     /**
 972      * The starting point of state machine for the find operation.  This allows
 973      * a match to start anywhere in the input.
 974      */
 975     transient Node root;
 976 
 977     /**
 978      * The root of object tree for a match operation.  The pattern is matched
 979      * at the beginning.  This may include a find that uses BnM or a First
 980      * node.
 981      */
 982     transient Node matchRoot;
 983 
 984     /**
 985      * Temporary storage used by parsing pattern slice.
 986      */
 987     transient int[] buffer;
 988 
 989     /**
 990      * A temporary storage used for predicate for double return.
 991      */
 992     transient CharPredicate predicate;
 993 
 994     /**
 995      * Map the &quot;name&quot; of the &quot;named capturing group&quot; to its group id
 996      * node.
 997      */
 998     transient volatile Map&lt;String, Integer&gt; namedGroups;
 999 
1000     /**
1001      * Temporary storage used while parsing group references.
1002      */
1003     transient GroupHead[] groupNodes;
1004 
1005     /**
1006      * Temporary storage used to store the top level closure nodes.
1007      */
1008     transient List&lt;Node&gt; topClosureNodes;
1009 
1010     /**
1011      * The number of top greedy closure nodes in this Pattern. Used by
1012      * matchers to allocate storage needed for a IntHashSet to keep the
1013      * beginning pos {@code i} of all failed match.
1014      */
1015     transient int localTCNCount;
1016 
1017     /*
1018      * Turn off the stop-exponential-backtracking optimization if there
1019      * is a group ref in the pattern.
1020      */
1021     transient boolean hasGroupRef;
1022 
1023     /**
1024      * Temporary null terminated code point array used by pattern compiling.
1025      */
1026     private transient int[] temp;
1027 
1028     /**
1029      * The number of capturing groups in this Pattern. Used by matchers to
1030      * allocate storage needed to perform a match.
1031      */
1032     transient int capturingGroupCount;
1033 
1034     /**
1035      * The local variable count used by parsing tree. Used by matchers to
1036      * allocate storage needed to perform a match.
1037      */
1038     transient int localCount;
1039 
1040     /**
1041      * Index into the pattern string that keeps track of how much has been
1042      * parsed.
1043      */
1044     private transient int cursor;
1045 
1046     /**
1047      * Holds the length of the pattern string.
1048      */
1049     private transient int patternLength;
1050 
1051     /**
<a name="1" id="anc1"></a><span class="line-modified">1052      * If the Start node might possibly match supplementary or surrogate</span>
<span class="line-added">1053      * code points.</span>
1054      * It is set to true during compiling if
<a name="2" id="anc2"></a><span class="line-modified">1055      * (1) There is supplementary or surrogate code point in pattern, or</span>
1056      * (2) There is complement node of a &quot;family&quot; CharProperty
1057      */
1058     private transient boolean hasSupplementary;
1059 
1060     /**
1061      * Compiles the given regular expression into a pattern.
1062      *
1063      * @param  regex
1064      *         The expression to be compiled
1065      * @return the given regular expression compiled into a pattern
1066      * @throws  PatternSyntaxException
1067      *          If the expression&#39;s syntax is invalid
1068      */
1069     public static Pattern compile(String regex) {
1070         return new Pattern(regex, 0);
1071     }
1072 
1073     /**
1074      * Compiles the given regular expression into a pattern with the given
1075      * flags.
1076      *
1077      * @param  regex
1078      *         The expression to be compiled
1079      *
1080      * @param  flags
1081      *         Match flags, a bit mask that may include
1082      *         {@link #CASE_INSENSITIVE}, {@link #MULTILINE}, {@link #DOTALL},
1083      *         {@link #UNICODE_CASE}, {@link #CANON_EQ}, {@link #UNIX_LINES},
1084      *         {@link #LITERAL}, {@link #UNICODE_CHARACTER_CLASS}
1085      *         and {@link #COMMENTS}
1086      *
1087      * @return the given regular expression compiled into a pattern with the given flags
1088      * @throws  IllegalArgumentException
1089      *          If bit values other than those corresponding to the defined
1090      *          match flags are set in {@code flags}
1091      *
1092      * @throws  PatternSyntaxException
1093      *          If the expression&#39;s syntax is invalid
1094      */
1095     public static Pattern compile(String regex, int flags) {
1096         return new Pattern(regex, flags);
1097     }
1098 
1099     /**
1100      * Returns the regular expression from which this pattern was compiled.
1101      *
1102      * @return  The source of this pattern
1103      */
1104     public String pattern() {
1105         return pattern;
1106     }
1107 
1108     /**
1109      * &lt;p&gt;Returns the string representation of this pattern. This
1110      * is the regular expression from which this pattern was
1111      * compiled.&lt;/p&gt;
1112      *
1113      * @return  The string representation of this pattern
1114      * @since 1.5
1115      */
1116     public String toString() {
1117         return pattern;
1118     }
1119 
1120     /**
1121      * Creates a matcher that will match the given input against this pattern.
1122      *
1123      * @param  input
1124      *         The character sequence to be matched
1125      *
1126      * @return  A new matcher for this pattern
1127      */
1128     public Matcher matcher(CharSequence input) {
1129         if (!compiled) {
1130             synchronized(this) {
1131                 if (!compiled)
1132                     compile();
1133             }
1134         }
1135         Matcher m = new Matcher(this, input);
1136         return m;
1137     }
1138 
1139     /**
1140      * Returns this pattern&#39;s match flags.
1141      *
1142      * @return  The match flags specified when this pattern was compiled
1143      */
1144     public int flags() {
1145         return flags0;
1146     }
1147 
1148     /**
1149      * Compiles the given regular expression and attempts to match the given
1150      * input against it.
1151      *
1152      * &lt;p&gt; An invocation of this convenience method of the form
1153      *
1154      * &lt;blockquote&gt;&lt;pre&gt;
1155      * Pattern.matches(regex, input);&lt;/pre&gt;&lt;/blockquote&gt;
1156      *
1157      * behaves in exactly the same way as the expression
1158      *
1159      * &lt;blockquote&gt;&lt;pre&gt;
1160      * Pattern.compile(regex).matcher(input).matches()&lt;/pre&gt;&lt;/blockquote&gt;
1161      *
1162      * &lt;p&gt; If a pattern is to be used multiple times, compiling it once and reusing
1163      * it will be more efficient than invoking this method each time.  &lt;/p&gt;
1164      *
1165      * @param  regex
1166      *         The expression to be compiled
1167      *
1168      * @param  input
1169      *         The character sequence to be matched
1170      * @return whether or not the regular expression matches on the input
1171      * @throws  PatternSyntaxException
1172      *          If the expression&#39;s syntax is invalid
1173      */
1174     public static boolean matches(String regex, CharSequence input) {
1175         Pattern p = Pattern.compile(regex);
1176         Matcher m = p.matcher(input);
1177         return m.matches();
1178     }
1179 
1180     /**
1181      * Splits the given input sequence around matches of this pattern.
1182      *
1183      * &lt;p&gt; The array returned by this method contains each substring of the
1184      * input sequence that is terminated by another subsequence that matches
1185      * this pattern or is terminated by the end of the input sequence.  The
1186      * substrings in the array are in the order in which they occur in the
1187      * input. If this pattern does not match any subsequence of the input then
1188      * the resulting array has just one element, namely the input sequence in
1189      * string form.
1190      *
1191      * &lt;p&gt; When there is a positive-width match at the beginning of the input
1192      * sequence then an empty leading substring is included at the beginning
1193      * of the resulting array. A zero-width match at the beginning however
1194      * never produces such empty leading substring.
1195      *
1196      * &lt;p&gt; The {@code limit} parameter controls the number of times the
1197      * pattern is applied and therefore affects the length of the resulting
1198      * array.
1199      * &lt;ul&gt;
1200      *    &lt;li&gt;&lt;p&gt;
1201      *    If the &lt;i&gt;limit&lt;/i&gt; is positive then the pattern will be applied
1202      *    at most &lt;i&gt;limit&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1 times, the array&#39;s length will be
1203      *    no greater than &lt;i&gt;limit&lt;/i&gt;, and the array&#39;s last entry will contain
1204      *    all input beyond the last matched delimiter.&lt;/p&gt;&lt;/li&gt;
1205      *
1206      *    &lt;li&gt;&lt;p&gt;
1207      *    If the &lt;i&gt;limit&lt;/i&gt; is zero then the pattern will be applied as
1208      *    many times as possible, the array can have any length, and trailing
1209      *    empty strings will be discarded.&lt;/p&gt;&lt;/li&gt;
1210      *
1211      *    &lt;li&gt;&lt;p&gt;
1212      *    If the &lt;i&gt;limit&lt;/i&gt; is negative then the pattern will be applied
1213      *    as many times as possible and the array can have any length.&lt;/p&gt;&lt;/li&gt;
1214      * &lt;/ul&gt;
1215      *
1216      * &lt;p&gt; The input {@code &quot;boo:and:foo&quot;}, for example, yields the following
1217      * results with these parameters:
1218      *
1219      * &lt;table class=&quot;plain&quot; style=&quot;margin-left:2em;&quot;&gt;
1220      * &lt;caption style=&quot;display:none&quot;&gt;Split example showing regex, limit, and result&lt;/caption&gt;
1221      * &lt;thead&gt;
1222      * &lt;tr&gt;
1223      *     &lt;th scope=&quot;col&quot;&gt;Regex&lt;/th&gt;
1224      *     &lt;th scope=&quot;col&quot;&gt;Limit&lt;/th&gt;
1225      *     &lt;th scope=&quot;col&quot;&gt;Result&lt;/th&gt;
1226      * &lt;/tr&gt;
1227      * &lt;/thead&gt;
1228      * &lt;tbody&gt;
1229      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot; style=&quot;font-weight:normal&quot;&gt;:&lt;/th&gt;
1230      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;2&lt;/th&gt;
1231      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and:foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
1232      * &lt;tr&gt;&lt;!-- : --&gt;
1233      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;5&lt;/th&gt;
1234      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
1235      * &lt;tr&gt;&lt;!-- : --&gt;
1236      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;-2&lt;/th&gt;
1237      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
1238      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot; style=&quot;font-weight:normal&quot;&gt;o&lt;/th&gt;
1239      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;5&lt;/th&gt;
1240      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;
1241      * &lt;tr&gt;&lt;!-- o --&gt;
1242      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;-2&lt;/th&gt;
1243      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;
1244      * &lt;tr&gt;&lt;!-- o --&gt;
1245      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;0&lt;/th&gt;
1246      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }}&lt;/td&gt;&lt;/tr&gt;
1247      * &lt;/tbody&gt;
1248      * &lt;/table&gt;
1249      *
1250      * @param  input
1251      *         The character sequence to be split
1252      *
1253      * @param  limit
1254      *         The result threshold, as described above
1255      *
1256      * @return  The array of strings computed by splitting the input
1257      *          around matches of this pattern
1258      */
1259     public String[] split(CharSequence input, int limit) {
1260         int index = 0;
1261         boolean matchLimited = limit &gt; 0;
1262         ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();
1263         Matcher m = matcher(input);
1264 
1265         // Add segments before each match found
1266         while(m.find()) {
1267             if (!matchLimited || matchList.size() &lt; limit - 1) {
1268                 if (index == 0 &amp;&amp; index == m.start() &amp;&amp; m.start() == m.end()) {
1269                     // no empty leading substring included for zero-width match
1270                     // at the beginning of the input char sequence.
1271                     continue;
1272                 }
1273                 String match = input.subSequence(index, m.start()).toString();
1274                 matchList.add(match);
1275                 index = m.end();
1276             } else if (matchList.size() == limit - 1) { // last one
1277                 String match = input.subSequence(index,
1278                                                  input.length()).toString();
1279                 matchList.add(match);
1280                 index = m.end();
1281             }
1282         }
1283 
1284         // If no match was found, return this
1285         if (index == 0)
1286             return new String[] {input.toString()};
1287 
1288         // Add remaining segment
1289         if (!matchLimited || matchList.size() &lt; limit)
1290             matchList.add(input.subSequence(index, input.length()).toString());
1291 
1292         // Construct result
1293         int resultSize = matchList.size();
1294         if (limit == 0)
1295             while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).isEmpty())
1296                 resultSize--;
1297         String[] result = new String[resultSize];
1298         return matchList.subList(0, resultSize).toArray(result);
1299     }
1300 
1301     /**
1302      * Splits the given input sequence around matches of this pattern.
1303      *
1304      * &lt;p&gt; This method works as if by invoking the two-argument {@link
1305      * #split(java.lang.CharSequence, int) split} method with the given input
1306      * sequence and a limit argument of zero.  Trailing empty strings are
1307      * therefore not included in the resulting array. &lt;/p&gt;
1308      *
1309      * &lt;p&gt; The input {@code &quot;boo:and:foo&quot;}, for example, yields the following
1310      * results with these expressions:
1311      *
1312      * &lt;table class=&quot;plain&quot; style=&quot;margin-left:2em&quot;&gt;
1313      * &lt;caption style=&quot;display:none&quot;&gt;Split examples showing regex and result&lt;/caption&gt;
1314      * &lt;thead&gt;
1315      * &lt;tr&gt;
1316      *  &lt;th scope=&quot;col&quot;&gt;Regex&lt;/th&gt;
1317      *  &lt;th scope=&quot;col&quot;&gt;Result&lt;/th&gt;
1318      * &lt;/tr&gt;
1319      * &lt;/thead&gt;
1320      * &lt;tbody&gt;
1321      * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;text-weight:normal&quot;&gt;:&lt;/th&gt;
1322      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
1323      * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;text-weight:normal&quot;&gt;o&lt;/th&gt;
1324      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }}&lt;/td&gt;&lt;/tr&gt;
1325      * &lt;/tbody&gt;
1326      * &lt;/table&gt;
1327      *
1328      *
1329      * @param  input
1330      *         The character sequence to be split
1331      *
1332      * @return  The array of strings computed by splitting the input
1333      *          around matches of this pattern
1334      */
1335     public String[] split(CharSequence input) {
1336         return split(input, 0);
1337     }
1338 
1339     /**
1340      * Returns a literal pattern {@code String} for the specified
1341      * {@code String}.
1342      *
1343      * &lt;p&gt;This method produces a {@code String} that can be used to
1344      * create a {@code Pattern} that would match the string
1345      * {@code s} as if it were a literal pattern.&lt;/p&gt; Metacharacters
1346      * or escape sequences in the input sequence will be given no special
1347      * meaning.
1348      *
1349      * @param  s The string to be literalized
1350      * @return  A literal string replacement
1351      * @since 1.5
1352      */
1353     public static String quote(String s) {
1354         int slashEIndex = s.indexOf(&quot;\\E&quot;);
1355         if (slashEIndex == -1)
1356             return &quot;\\Q&quot; + s + &quot;\\E&quot;;
1357 
1358         int lenHint = s.length();
1359         lenHint = (lenHint &lt; Integer.MAX_VALUE - 8 - lenHint) ?
1360                 (lenHint &lt;&lt; 1) : (Integer.MAX_VALUE - 8);
1361 
1362         StringBuilder sb = new StringBuilder(lenHint);
1363         sb.append(&quot;\\Q&quot;);
1364         int current = 0;
1365         do {
1366             sb.append(s, current, slashEIndex)
1367                     .append(&quot;\\E\\\\E\\Q&quot;);
1368             current = slashEIndex + 2;
1369         } while ((slashEIndex = s.indexOf(&quot;\\E&quot;, current)) != -1);
1370 
1371         return sb.append(s, current, s.length())
1372                 .append(&quot;\\E&quot;)
1373                 .toString();
1374     }
1375 
1376     /**
1377      * Recompile the Pattern instance from a stream.  The original pattern
1378      * string is read in and the object tree is recompiled from it.
1379      */
1380     @java.io.Serial
1381     private void readObject(java.io.ObjectInputStream s)
1382         throws java.io.IOException, ClassNotFoundException {
1383 
1384         // Read in all fields
1385         s.defaultReadObject();
1386 
1387         // reset the flags
1388         flags0 = flags;
1389 
1390         // Initialize counts
1391         capturingGroupCount = 1;
1392         localCount = 0;
1393         localTCNCount = 0;
1394 
1395         // if length &gt; 0, the Pattern is lazily compiled
1396         if (pattern.isEmpty()) {
1397             root = new Start(lastAccept);
1398             matchRoot = lastAccept;
1399             compiled = true;
1400         }
1401     }
1402 
1403     /**
1404      * This private constructor is used to create all Patterns. The pattern
1405      * string and match flags are all that is needed to completely describe
1406      * a Pattern. An empty pattern string results in an object tree with
1407      * only a Start node and a LastNode node.
1408      */
1409     private Pattern(String p, int f) {
1410         if ((f &amp; ~ALL_FLAGS) != 0) {
1411             throw new IllegalArgumentException(&quot;Unknown flag 0x&quot;
1412                                                + Integer.toHexString(f));
1413         }
1414         pattern = p;
1415         flags = f;
1416 
1417         // to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present
1418         if ((flags &amp; UNICODE_CHARACTER_CLASS) != 0)
1419             flags |= UNICODE_CASE;
1420 
1421         // &#39;flags&#39; for compiling
1422         flags0 = flags;
1423 
1424         // Reset group index count
1425         capturingGroupCount = 1;
1426         localCount = 0;
1427         localTCNCount = 0;
1428 
1429         if (!pattern.isEmpty()) {
1430             try {
1431                 compile();
1432             } catch (StackOverflowError soe) {
1433                 throw error(&quot;Stack overflow during pattern compilation&quot;);
1434             }
1435         } else {
1436             root = new Start(lastAccept);
1437             matchRoot = lastAccept;
1438         }
1439     }
1440 
1441     /**
1442      * The pattern is converted to normalized form ({@link
1443      * java.text.Normalizer.Form#NFC NFC}, canonical decomposition,
1444      * followed by canonical composition for the character class
1445      * part, and {@link java.text.Normalizer.Form#NFD NFD},
1446      * canonical decomposition for the rest), and then a pure
1447      * group is constructed to match canonical equivalences of the
1448      * characters.
1449      */
1450     private static String normalize(String pattern) {
1451         int plen = pattern.length();
1452         StringBuilder pbuf = new StringBuilder(plen);
1453         char last = 0;
1454         int lastStart = 0;
1455         char cc = 0;
1456         for (int i = 0; i &lt; plen;) {
1457             char c = pattern.charAt(i);
1458             if (cc == 0 &amp;&amp;    // top level
1459                 c == &#39;\\&#39; &amp;&amp; i + 1 &lt; plen &amp;&amp; pattern.charAt(i + 1) == &#39;\\&#39;) {
1460                 i += 2; last = 0;
1461                 continue;
1462             }
1463             if (c == &#39;[&#39; &amp;&amp; last != &#39;\\&#39;) {
1464                 if (cc == 0) {
1465                     if (lastStart &lt; i)
1466                         normalizeSlice(pattern, lastStart, i, pbuf);
1467                     lastStart = i;
1468                 }
1469                 cc++;
1470             } else if (c == &#39;]&#39; &amp;&amp; last != &#39;\\&#39;) {
1471                 cc--;
1472                 if (cc == 0) {
1473                     normalizeClazz(pattern, lastStart, i + 1, pbuf);
1474                     lastStart = i + 1;
1475                 }
1476             }
1477             last = c;
1478             i++;
1479         }
1480         assert (cc == 0);
1481         if (lastStart &lt; plen)
1482             normalizeSlice(pattern, lastStart, plen, pbuf);
1483         return pbuf.toString();
1484     }
1485 
1486     private static void normalizeSlice(String src, int off, int limit,
1487                                        StringBuilder dst)
1488     {
1489         int len = src.length();
1490         int off0 = off;
1491         while (off &lt; limit &amp;&amp; ASCII.isAscii(src.charAt(off))) {
1492             off++;
1493         }
1494         if (off == limit) {
1495             dst.append(src, off0, limit);
1496             return;
1497         }
1498         off--;
1499         if (off &lt; off0)
1500             off = off0;
1501         else
1502             dst.append(src, off0, off);
1503         while (off &lt; limit) {
1504             int ch0 = src.codePointAt(off);
1505             if (&quot;.$|()[]{}^?*+\\&quot;.indexOf(ch0) != -1) {
1506                 dst.append((char)ch0);
1507                 off++;
1508                 continue;
1509             }
1510             int j = Grapheme.nextBoundary(src, off, limit);
1511             int ch1;
1512             String seq = src.substring(off, j);
1513             String nfd = Normalizer.normalize(seq, Normalizer.Form.NFD);
1514             off = j;
1515             if (nfd.codePointCount(0, nfd.length()) &gt; 1) {
1516                 ch0 = nfd.codePointAt(0);
1517                 ch1 = nfd.codePointAt(Character.charCount(ch0));
1518                 if (Character.getType(ch1) == Character.NON_SPACING_MARK) {
1519                     Set&lt;String&gt; altns = new LinkedHashSet&lt;&gt;();
1520                     altns.add(seq);
1521                     produceEquivalentAlternation(nfd, altns);
1522                     dst.append(&quot;(?:&quot;);
1523                     altns.forEach( s -&gt; dst.append(s).append(&#39;|&#39;));
1524                     dst.delete(dst.length() - 1, dst.length());
1525                     dst.append(&quot;)&quot;);
1526                     continue;
1527                 }
1528             }
1529             String nfc = Normalizer.normalize(seq, Normalizer.Form.NFC);
1530             if (!seq.equals(nfc) &amp;&amp; !nfd.equals(nfc))
1531                 dst.append(&quot;(?:&quot; + seq + &quot;|&quot; + nfd  + &quot;|&quot; + nfc + &quot;)&quot;);
1532             else if (!seq.equals(nfd))
1533                 dst.append(&quot;(?:&quot; + seq + &quot;|&quot; + nfd + &quot;)&quot;);
1534             else
1535                 dst.append(seq);
1536         }
1537     }
1538 
1539     private static void normalizeClazz(String src, int off, int limit,
1540                                        StringBuilder dst)
1541     {
1542         dst.append(Normalizer.normalize(src.substring(off, limit), Form.NFC));
1543     }
1544 
1545     /**
1546      * Given a specific sequence composed of a regular character and
1547      * combining marks that follow it, produce the alternation that will
1548      * match all canonical equivalences of that sequence.
1549      */
1550     private static void produceEquivalentAlternation(String src,
1551                                                      Set&lt;String&gt; dst)
1552     {
1553         int len = countChars(src, 0, 1);
1554         if (src.length() == len) {
1555             dst.add(src);  // source has one character.
1556             return;
1557         }
1558         String base = src.substring(0,len);
1559         String combiningMarks = src.substring(len);
1560         String[] perms = producePermutations(combiningMarks);
1561         // Add combined permutations
1562         for(int x = 0; x &lt; perms.length; x++) {
1563             String next = base + perms[x];
1564             dst.add(next);
1565             next = composeOneStep(next);
1566             if (next != null) {
1567                 produceEquivalentAlternation(next, dst);
1568             }
1569         }
1570     }
1571 
1572     /**
1573      * Returns an array of strings that have all the possible
1574      * permutations of the characters in the input string.
1575      * This is used to get a list of all possible orderings
1576      * of a set of combining marks. Note that some of the permutations
1577      * are invalid because of combining class collisions, and these
1578      * possibilities must be removed because they are not canonically
1579      * equivalent.
1580      */
1581     private static String[] producePermutations(String input) {
1582         if (input.length() == countChars(input, 0, 1))
1583             return new String[] {input};
1584 
1585         if (input.length() == countChars(input, 0, 2)) {
1586             int c0 = Character.codePointAt(input, 0);
1587             int c1 = Character.codePointAt(input, Character.charCount(c0));
1588             if (getClass(c1) == getClass(c0)) {
1589                 return new String[] {input};
1590             }
1591             String[] result = new String[2];
1592             result[0] = input;
1593             StringBuilder sb = new StringBuilder(2);
1594             sb.appendCodePoint(c1);
1595             sb.appendCodePoint(c0);
1596             result[1] = sb.toString();
1597             return result;
1598         }
1599 
1600         int length = 1;
1601         int nCodePoints = countCodePoints(input);
1602         for(int x=1; x&lt;nCodePoints; x++)
1603             length = length * (x+1);
1604 
1605         String[] temp = new String[length];
1606 
1607         int combClass[] = new int[nCodePoints];
1608         for(int x=0, i=0; x&lt;nCodePoints; x++) {
1609             int c = Character.codePointAt(input, i);
1610             combClass[x] = getClass(c);
1611             i +=  Character.charCount(c);
1612         }
1613 
1614         // For each char, take it out and add the permutations
1615         // of the remaining chars
1616         int index = 0;
1617         int len;
1618         // offset maintains the index in code units.
1619 loop:   for(int x=0, offset=0; x&lt;nCodePoints; x++, offset+=len) {
1620             len = countChars(input, offset, 1);
1621             for(int y=x-1; y&gt;=0; y--) {
1622                 if (combClass[y] == combClass[x]) {
1623                     continue loop;
1624                 }
1625             }
1626             StringBuilder sb = new StringBuilder(input);
1627             String otherChars = sb.delete(offset, offset+len).toString();
1628             String[] subResult = producePermutations(otherChars);
1629 
1630             String prefix = input.substring(offset, offset+len);
1631             for (String sre : subResult)
1632                 temp[index++] = prefix + sre;
1633         }
1634         String[] result = new String[index];
1635         System.arraycopy(temp, 0, result, 0, index);
1636         return result;
1637     }
1638 
1639     private static int getClass(int c) {
1640         return sun.text.Normalizer.getCombiningClass(c);
1641     }
1642 
1643     /**
1644      * Attempts to compose input by combining the first character
1645      * with the first combining mark following it. Returns a String
1646      * that is the composition of the leading character with its first
1647      * combining mark followed by the remaining combining marks. Returns
1648      * null if the first two characters cannot be further composed.
1649      */
1650     private static String composeOneStep(String input) {
1651         int len = countChars(input, 0, 2);
1652         String firstTwoCharacters = input.substring(0, len);
1653         String result = Normalizer.normalize(firstTwoCharacters, Normalizer.Form.NFC);
1654         if (result.equals(firstTwoCharacters))
1655             return null;
1656         else {
1657             String remainder = input.substring(len);
1658             return result + remainder;
1659         }
1660     }
1661 
1662     /**
1663      * Preprocess any \Q...\E sequences in `temp&#39;, meta-quoting them.
1664      * See the description of `quotemeta&#39; in perlfunc(1).
1665      */
1666     private void RemoveQEQuoting() {
1667         final int pLen = patternLength;
1668         int i = 0;
1669         while (i &lt; pLen-1) {
1670             if (temp[i] != &#39;\\&#39;)
1671                 i += 1;
1672             else if (temp[i + 1] != &#39;Q&#39;)
1673                 i += 2;
1674             else
1675                 break;
1676         }
1677         if (i &gt;= pLen - 1)    // No \Q sequence found
1678             return;
1679         int j = i;
1680         i += 2;
1681         int newTempLen;
1682         try {
1683             newTempLen = Math.addExact(j + 2, Math.multiplyExact(3, pLen - i));
1684         } catch (ArithmeticException ae) {
1685             throw new OutOfMemoryError(&quot;Required pattern length too large&quot;);
1686         }
1687         int[] newtemp = new int[newTempLen];
1688         System.arraycopy(temp, 0, newtemp, 0, j);
1689 
1690         boolean inQuote = true;
1691         boolean beginQuote = true;
1692         while (i &lt; pLen) {
1693             int c = temp[i++];
1694             if (!ASCII.isAscii(c) || ASCII.isAlpha(c)) {
1695                 newtemp[j++] = c;
1696             } else if (ASCII.isDigit(c)) {
1697                 if (beginQuote) {
1698                     /*
1699                      * A unicode escape \[0xu] could be before this quote,
1700                      * and we don&#39;t want this numeric char to processed as
1701                      * part of the escape.
1702                      */
1703                     newtemp[j++] = &#39;\\&#39;;
1704                     newtemp[j++] = &#39;x&#39;;
1705                     newtemp[j++] = &#39;3&#39;;
1706                 }
1707                 newtemp[j++] = c;
1708             } else if (c != &#39;\\&#39;) {
1709                 if (inQuote) newtemp[j++] = &#39;\\&#39;;
1710                 newtemp[j++] = c;
1711             } else if (inQuote) {
1712                 if (temp[i] == &#39;E&#39;) {
1713                     i++;
1714                     inQuote = false;
1715                 } else {
1716                     newtemp[j++] = &#39;\\&#39;;
1717                     newtemp[j++] = &#39;\\&#39;;
1718                 }
1719             } else {
1720                 if (temp[i] == &#39;Q&#39;) {
1721                     i++;
1722                     inQuote = true;
1723                     beginQuote = true;
1724                     continue;
1725                 } else {
1726                     newtemp[j++] = c;
1727                     if (i != pLen)
1728                         newtemp[j++] = temp[i++];
1729                 }
1730             }
1731 
1732             beginQuote = false;
1733         }
1734 
1735         patternLength = j;
1736         temp = Arrays.copyOf(newtemp, j + 2); // double zero termination
1737     }
1738 
1739     /**
1740      * Copies regular expression to an int array and invokes the parsing
1741      * of the expression which will create the object tree.
1742      */
1743     private void compile() {
1744         // Handle canonical equivalences
1745         if (has(CANON_EQ) &amp;&amp; !has(LITERAL)) {
1746             normalizedPattern = normalize(pattern);
1747         } else {
1748             normalizedPattern = pattern;
1749         }
1750         patternLength = normalizedPattern.length();
1751 
1752         // Copy pattern to int array for convenience
1753         // Use double zero to terminate pattern
1754         temp = new int[patternLength + 2];
1755 
1756         hasSupplementary = false;
1757         int c, count = 0;
1758         // Convert all chars into code points
1759         for (int x = 0; x &lt; patternLength; x += Character.charCount(c)) {
1760             c = normalizedPattern.codePointAt(x);
1761             if (isSupplementary(c)) {
1762                 hasSupplementary = true;
1763             }
1764             temp[count++] = c;
1765         }
1766 
1767         patternLength = count;   // patternLength now in code points
1768 
1769         if (! has(LITERAL))
1770             RemoveQEQuoting();
1771 
1772         // Allocate all temporary objects here.
1773         buffer = new int[32];
1774         groupNodes = new GroupHead[10];
1775         namedGroups = null;
1776         topClosureNodes = new ArrayList&lt;&gt;(10);
1777 
1778         if (has(LITERAL)) {
1779             // Literal pattern handling
1780             matchRoot = newSlice(temp, patternLength, hasSupplementary);
1781             matchRoot.next = lastAccept;
1782         } else {
1783             // Start recursive descent parsing
1784             matchRoot = expr(lastAccept);
1785             // Check extra pattern characters
1786             if (patternLength != cursor) {
1787                 if (peek() == &#39;)&#39;) {
1788                     throw error(&quot;Unmatched closing &#39;)&#39;&quot;);
1789                 } else {
1790                     throw error(&quot;Unexpected internal error&quot;);
1791                 }
1792             }
1793         }
1794 
1795         // Peephole optimization
1796         if (matchRoot instanceof Slice) {
1797             root = BnM.optimize(matchRoot);
1798             if (root == matchRoot) {
1799                 root = hasSupplementary ? new StartS(matchRoot) : new Start(matchRoot);
1800             }
1801         } else if (matchRoot instanceof Begin || matchRoot instanceof First) {
1802             root = matchRoot;
1803         } else {
1804             root = hasSupplementary ? new StartS(matchRoot) : new Start(matchRoot);
1805         }
1806 
1807         // Optimize the greedy Loop to prevent exponential backtracking, IF there
1808         // is no group ref in this pattern. With a non-negative localTCNCount value,
1809         // the greedy type Loop, Curly will skip the backtracking for any starting
1810         // position &quot;i&quot; that failed in the past.
1811         if (!hasGroupRef) {
1812             for (Node node : topClosureNodes) {
1813                 if (node instanceof Loop) {
1814                     // non-deterministic-greedy-group
1815                     ((Loop)node).posIndex = localTCNCount++;
1816                 }
1817             }
1818         }
1819 
1820         // Release temporary storage
1821         temp = null;
1822         buffer = null;
1823         groupNodes = null;
1824         patternLength = 0;
1825         compiled = true;
1826         topClosureNodes = null;
1827     }
1828 
1829     Map&lt;String, Integer&gt; namedGroups() {
1830         Map&lt;String, Integer&gt; groups = namedGroups;
1831         if (groups == null) {
1832             namedGroups = groups = new HashMap&lt;&gt;(2);
1833         }
1834         return groups;
1835     }
1836 
1837     /**
1838      * Used to accumulate information about a subtree of the object graph
1839      * so that optimizations can be applied to the subtree.
1840      */
1841     static final class TreeInfo {
1842         int minLength;
1843         int maxLength;
1844         boolean maxValid;
1845         boolean deterministic;
1846 
1847         TreeInfo() {
1848             reset();
1849         }
1850         void reset() {
1851             minLength = 0;
1852             maxLength = 0;
1853             maxValid = true;
1854             deterministic = true;
1855         }
1856     }
1857 
1858     /*
1859      * The following private methods are mainly used to improve the
1860      * readability of the code. In order to let the Java compiler easily
1861      * inline them, we should not put many assertions or error checks in them.
1862      */
1863 
1864     /**
1865      * Indicates whether a particular flag is set or not.
1866      */
1867     private boolean has(int f) {
1868         return (flags0 &amp; f) != 0;
1869     }
1870 
1871     /**
1872      * Match next character, signal error if failed.
1873      */
1874     private void accept(int ch, String s) {
1875         int testChar = temp[cursor++];
1876         if (has(COMMENTS))
1877             testChar = parsePastWhitespace(testChar);
1878         if (ch != testChar) {
1879             throw error(s);
1880         }
1881     }
1882 
1883     /**
1884      * Mark the end of pattern with a specific character.
1885      */
1886     private void mark(int c) {
1887         temp[patternLength] = c;
1888     }
1889 
1890     /**
1891      * Peek the next character, and do not advance the cursor.
1892      */
1893     private int peek() {
1894         int ch = temp[cursor];
1895         if (has(COMMENTS))
1896             ch = peekPastWhitespace(ch);
1897         return ch;
1898     }
1899 
1900     /**
1901      * Read the next character, and advance the cursor by one.
1902      */
1903     private int read() {
1904         int ch = temp[cursor++];
1905         if (has(COMMENTS))
1906             ch = parsePastWhitespace(ch);
1907         return ch;
1908     }
1909 
1910     /**
1911      * Read the next character, and advance the cursor by one,
1912      * ignoring the COMMENTS setting
1913      */
1914     private int readEscaped() {
1915         int ch = temp[cursor++];
1916         return ch;
1917     }
1918 
1919     /**
1920      * Advance the cursor by one, and peek the next character.
1921      */
1922     private int next() {
1923         int ch = temp[++cursor];
1924         if (has(COMMENTS))
1925             ch = peekPastWhitespace(ch);
1926         return ch;
1927     }
1928 
1929     /**
1930      * Advance the cursor by one, and peek the next character,
1931      * ignoring the COMMENTS setting
1932      */
1933     private int nextEscaped() {
1934         int ch = temp[++cursor];
1935         return ch;
1936     }
1937 
1938     /**
1939      * If in xmode peek past whitespace and comments.
1940      */
1941     private int peekPastWhitespace(int ch) {
1942         while (ASCII.isSpace(ch) || ch == &#39;#&#39;) {
1943             while (ASCII.isSpace(ch))
1944                 ch = temp[++cursor];
1945             if (ch == &#39;#&#39;) {
1946                 ch = peekPastLine();
1947             }
1948         }
1949         return ch;
1950     }
1951 
1952     /**
1953      * If in xmode parse past whitespace and comments.
1954      */
1955     private int parsePastWhitespace(int ch) {
1956         while (ASCII.isSpace(ch) || ch == &#39;#&#39;) {
1957             while (ASCII.isSpace(ch))
1958                 ch = temp[cursor++];
1959             if (ch == &#39;#&#39;)
1960                 ch = parsePastLine();
1961         }
1962         return ch;
1963     }
1964 
1965     /**
1966      * xmode parse past comment to end of line.
1967      */
1968     private int parsePastLine() {
1969         int ch = temp[cursor++];
1970         while (ch != 0 &amp;&amp; !isLineSeparator(ch))
1971             ch = temp[cursor++];
1972         if (ch == 0 &amp;&amp; cursor &gt; patternLength) {
1973             cursor = patternLength;
1974             ch = temp[cursor++];
1975         }
1976         return ch;
1977     }
1978 
1979     /**
1980      * xmode peek past comment to end of line.
1981      */
1982     private int peekPastLine() {
1983         int ch = temp[++cursor];
1984         while (ch != 0 &amp;&amp; !isLineSeparator(ch))
1985             ch = temp[++cursor];
1986         if (ch == 0 &amp;&amp; cursor &gt; patternLength) {
1987             cursor = patternLength;
1988             ch = temp[cursor];
1989         }
1990         return ch;
1991     }
1992 
1993     /**
1994      * Determines if character is a line separator in the current mode
1995      */
1996     private boolean isLineSeparator(int ch) {
1997         if (has(UNIX_LINES)) {
1998             return ch == &#39;\n&#39;;
1999         } else {
2000             return (ch == &#39;\n&#39; ||
2001                     ch == &#39;\r&#39; ||
2002                     (ch|1) == &#39;\u2029&#39; ||
2003                     ch == &#39;\u0085&#39;);
2004         }
2005     }
2006 
2007     /**
2008      * Read the character after the next one, and advance the cursor by two.
2009      */
2010     private int skip() {
2011         int i = cursor;
2012         int ch = temp[i+1];
2013         cursor = i + 2;
2014         return ch;
2015     }
2016 
2017     /**
2018      * Unread one next character, and retreat cursor by one.
2019      */
2020     private void unread() {
2021         cursor--;
2022     }
2023 
2024     /**
2025      * Internal method used for handling all syntax errors. The pattern is
2026      * displayed with a pointer to aid in locating the syntax error.
2027      */
2028     private PatternSyntaxException error(String s) {
2029         return new PatternSyntaxException(s, normalizedPattern,  cursor - 1);
2030     }
2031 
2032     /**
2033      * Determines if there is any supplementary character or unpaired
2034      * surrogate in the specified range.
2035      */
2036     private boolean findSupplementary(int start, int end) {
2037         for (int i = start; i &lt; end; i++) {
2038             if (isSupplementary(temp[i]))
2039                 return true;
2040         }
2041         return false;
2042     }
2043 
2044     /**
2045      * Determines if the specified code point is a supplementary
2046      * character or unpaired surrogate.
2047      */
2048     private static final boolean isSupplementary(int ch) {
2049         return ch &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT ||
2050                Character.isSurrogate((char)ch);
2051     }
2052 
2053     /**
2054      *  The following methods handle the main parsing. They are sorted
2055      *  according to their precedence order, the lowest one first.
2056      */
2057 
2058     /**
2059      * The expression is parsed with branch nodes added for alternations.
2060      * This may be called recursively to parse sub expressions that may
2061      * contain alternations.
2062      */
2063     private Node expr(Node end) {
2064         Node prev = null;
2065         Node firstTail = null;
2066         Branch branch = null;
2067         BranchConn branchConn = null;
2068 
2069         for (;;) {
2070             Node node = sequence(end);
2071             Node nodeTail = root;      //double return
2072             if (prev == null) {
2073                 prev = node;
2074                 firstTail = nodeTail;
2075             } else {
2076                 // Branch
2077                 if (branchConn == null) {
2078                     branchConn = new BranchConn();
2079                     branchConn.next = end;
2080                 }
2081                 if (node == end) {
2082                     // if the node returned from sequence() is &quot;end&quot;
2083                     // we have an empty expr, set a null atom into
2084                     // the branch to indicate to go &quot;next&quot; directly.
2085                     node = null;
2086                 } else {
2087                     // the &quot;tail.next&quot; of each atom goes to branchConn
2088                     nodeTail.next = branchConn;
2089                 }
2090                 if (prev == branch) {
2091                     branch.add(node);
2092                 } else {
2093                     if (prev == end) {
2094                         prev = null;
2095                     } else {
2096                         // replace the &quot;end&quot; with &quot;branchConn&quot; at its tail.next
2097                         // when put the &quot;prev&quot; into the branch as the first atom.
2098                         firstTail.next = branchConn;
2099                     }
2100                     prev = branch = new Branch(prev, node, branchConn);
2101                 }
2102             }
2103             if (peek() != &#39;|&#39;) {
2104                 return prev;
2105             }
2106             next();
2107         }
2108     }
2109 
2110     @SuppressWarnings(&quot;fallthrough&quot;)
2111     /**
2112      * Parsing of sequences between alternations.
2113      */
2114     private Node sequence(Node end) {
2115         Node head = null;
2116         Node tail = null;
2117         Node node;
2118     LOOP:
2119         for (;;) {
2120             int ch = peek();
2121             switch (ch) {
2122             case &#39;(&#39;:
2123                 // Because group handles its own closure,
2124                 // we need to treat it differently
2125                 node = group0();
2126                 // Check for comment or flag group
2127                 if (node == null)
2128                     continue;
2129                 if (head == null)
2130                     head = node;
2131                 else
2132                     tail.next = node;
2133                 // Double return: Tail was returned in root
2134                 tail = root;
2135                 continue;
2136             case &#39;[&#39;:
2137                 if (has(CANON_EQ) &amp;&amp; !has(LITERAL))
2138                     node = new NFCCharProperty(clazz(true));
2139                 else
2140                     node = newCharProperty(clazz(true));
2141                 break;
2142             case &#39;\\&#39;:
2143                 ch = nextEscaped();
2144                 if (ch == &#39;p&#39; || ch == &#39;P&#39;) {
2145                     boolean oneLetter = true;
2146                     boolean comp = (ch == &#39;P&#39;);
2147                     ch = next(); // Consume { if present
2148                     if (ch != &#39;{&#39;) {
2149                         unread();
2150                     } else {
2151                         oneLetter = false;
2152                     }
2153                     // node = newCharProperty(family(oneLetter, comp));
2154                     if (has(CANON_EQ) &amp;&amp; !has(LITERAL))
2155                         node = new NFCCharProperty(family(oneLetter, comp));
2156                     else
2157                         node = newCharProperty(family(oneLetter, comp));
2158                 } else {
2159                     unread();
2160                     node = atom();
2161                 }
2162                 break;
2163             case &#39;^&#39;:
2164                 next();
2165                 if (has(MULTILINE)) {
2166                     if (has(UNIX_LINES))
2167                         node = new UnixCaret();
2168                     else
2169                         node = new Caret();
2170                 } else {
2171                     node = new Begin();
2172                 }
2173                 break;
2174             case &#39;$&#39;:
2175                 next();
2176                 if (has(UNIX_LINES))
2177                     node = new UnixDollar(has(MULTILINE));
2178                 else
2179                     node = new Dollar(has(MULTILINE));
2180                 break;
2181             case &#39;.&#39;:
2182                 next();
2183                 if (has(DOTALL)) {
2184                     node = new CharProperty(ALL());
2185                 } else {
2186                     if (has(UNIX_LINES)) {
2187                         node = new CharProperty(UNIXDOT());
2188                     } else {
2189                         node = new CharProperty(DOT());
2190                     }
2191                 }
2192                 break;
2193             case &#39;|&#39;:
2194             case &#39;)&#39;:
2195                 break LOOP;
2196             case &#39;]&#39;: // Now interpreting dangling ] and } as literals
2197             case &#39;}&#39;:
2198                 node = atom();
2199                 break;
2200             case &#39;?&#39;:
2201             case &#39;*&#39;:
2202             case &#39;+&#39;:
2203                 next();
2204                 throw error(&quot;Dangling meta character &#39;&quot; + ((char)ch) + &quot;&#39;&quot;);
2205             case 0:
2206                 if (cursor &gt;= patternLength) {
2207                     break LOOP;
2208                 }
2209                 // Fall through
2210             default:
2211                 node = atom();
2212                 break;
2213             }
2214 
2215             if (node instanceof LineEnding) {
2216                 LineEnding le = (LineEnding)node;
2217                 node = closureOfLineEnding(le);
2218 
2219                 if (node != le) {
2220                     // LineEnding was replaced with an anonymous group
2221                     if (head == null)
2222                         head = node;
2223                     else
2224                         tail.next = node;
2225                     // Double return: Tail was returned in root
2226                     tail = root;
2227                     continue;
2228                 }
2229             } else {
2230                 node = closure(node);
2231             }
2232 
2233             /* save the top dot-greedy nodes (.*, .+) as well
2234             if (node instanceof GreedyCharProperty &amp;&amp;
2235                 ((GreedyCharProperty)node).cp instanceof Dot) {
2236                 topClosureNodes.add(node);
2237             }
2238             */
2239             if (head == null) {
2240                 head = tail = node;
2241             } else {
2242                 tail.next = node;
2243                 tail = node;
2244             }
2245         }
2246         if (head == null) {
2247             return end;
2248         }
2249         tail.next = end;
2250         root = tail;      //double return
2251         return head;
2252     }
2253 
2254     @SuppressWarnings(&quot;fallthrough&quot;)
2255     /**
2256      * Parse and add a new Single or Slice.
2257      */
2258     private Node atom() {
2259         int first = 0;
2260         int prev = -1;
2261         boolean hasSupplementary = false;
2262         int ch = peek();
2263         for (;;) {
2264             switch (ch) {
2265             case &#39;*&#39;:
2266             case &#39;+&#39;:
2267             case &#39;?&#39;:
2268             case &#39;{&#39;:
2269                 if (first &gt; 1) {
2270                     cursor = prev;    // Unwind one character
2271                     first--;
2272                 }
2273                 break;
2274             case &#39;$&#39;:
2275             case &#39;.&#39;:
2276             case &#39;^&#39;:
2277             case &#39;(&#39;:
2278             case &#39;[&#39;:
2279             case &#39;|&#39;:
2280             case &#39;)&#39;:
2281                 break;
2282             case &#39;\\&#39;:
2283                 ch = nextEscaped();
2284                 if (ch == &#39;p&#39; || ch == &#39;P&#39;) { // Property
2285                     if (first &gt; 0) { // Slice is waiting; handle it first
2286                         unread();
2287                         break;
2288                     } else { // No slice; just return the family node
2289                         boolean comp = (ch == &#39;P&#39;);
2290                         boolean oneLetter = true;
2291                         ch = next(); // Consume { if present
2292                         if (ch != &#39;{&#39;)
2293                             unread();
2294                         else
2295                             oneLetter = false;
2296                         if (has(CANON_EQ) &amp;&amp; !has(LITERAL))
2297                             return new NFCCharProperty(family(oneLetter, comp));
2298                         else
2299                             return newCharProperty(family(oneLetter, comp));
2300                     }
2301                 }
2302                 unread();
2303                 prev = cursor;
2304                 ch = escape(false, first == 0, false);
2305                 if (ch &gt;= 0) {
2306                     append(ch, first);
2307                     first++;
2308                     if (isSupplementary(ch)) {
2309                         hasSupplementary = true;
2310                     }
2311                     ch = peek();
2312                     continue;
2313                 } else if (first == 0) {
2314                     return root;
2315                 }
2316                 // Unwind meta escape sequence
2317                 cursor = prev;
2318                 break;
2319             case 0:
2320                 if (cursor &gt;= patternLength) {
2321                     break;
2322                 }
2323                 // Fall through
2324             default:
2325                 prev = cursor;
2326                 append(ch, first);
2327                 first++;
2328                 if (isSupplementary(ch)) {
2329                     hasSupplementary = true;
2330                 }
2331                 ch = next();
2332                 continue;
2333             }
2334             break;
2335         }
2336         if (first == 1) {
2337             return newCharProperty(single(buffer[0]));
2338         } else {
2339             return newSlice(buffer, first, hasSupplementary);
2340         }
2341     }
2342 
2343     private void append(int ch, int index) {
2344         int len = buffer.length;
2345         if (index - len &gt;= 0) {
2346             len = ArraysSupport.newLength(len,
2347                     1 + index - len, /* minimum growth */
2348                     len              /* preferred growth */);
2349             buffer = Arrays.copyOf(buffer, len);
2350         }
2351         buffer[index] = ch;
2352     }
2353 
2354     /**
2355      * Parses a backref greedily, taking as many numbers as it
2356      * can. The first digit is always treated as a backref, but
2357      * multi digit numbers are only treated as a backref if at
2358      * least that many backrefs exist at this point in the regex.
2359      */
2360     private Node ref(int refNum) {
2361         boolean done = false;
2362         while(!done) {
2363             int ch = peek();
2364             switch(ch) {
2365             case &#39;0&#39;:
2366             case &#39;1&#39;:
2367             case &#39;2&#39;:
2368             case &#39;3&#39;:
2369             case &#39;4&#39;:
2370             case &#39;5&#39;:
2371             case &#39;6&#39;:
2372             case &#39;7&#39;:
2373             case &#39;8&#39;:
2374             case &#39;9&#39;:
2375                 int newRefNum = (refNum * 10) + (ch - &#39;0&#39;);
2376                 // Add another number if it doesn&#39;t make a group
2377                 // that doesn&#39;t exist
2378                 if (capturingGroupCount - 1 &lt; newRefNum) {
2379                     done = true;
2380                     break;
2381                 }
2382                 refNum = newRefNum;
2383                 read();
2384                 break;
2385             default:
2386                 done = true;
2387                 break;
2388             }
2389         }
2390         hasGroupRef = true;
2391         if (has(CASE_INSENSITIVE))
2392             return new CIBackRef(refNum, has(UNICODE_CASE));
2393         else
2394             return new BackRef(refNum);
2395     }
2396 
2397     /**
2398      * Parses an escape sequence to determine the actual value that needs
2399      * to be matched.
2400      * If -1 is returned and create was true a new object was added to the tree
2401      * to handle the escape sequence.
2402      * If the returned value is greater than zero, it is the value that
2403      * matches the escape sequence.
2404      */
2405     private int escape(boolean inclass, boolean create, boolean isrange) {
2406         int ch = skip();
2407         switch (ch) {
2408         case &#39;0&#39;:
2409             return o();
2410         case &#39;1&#39;:
2411         case &#39;2&#39;:
2412         case &#39;3&#39;:
2413         case &#39;4&#39;:
2414         case &#39;5&#39;:
2415         case &#39;6&#39;:
2416         case &#39;7&#39;:
2417         case &#39;8&#39;:
2418         case &#39;9&#39;:
2419             if (inclass) break;
2420             if (create) {
2421                 root = ref((ch - &#39;0&#39;));
2422             }
2423             return -1;
2424         case &#39;A&#39;:
2425             if (inclass) break;
2426             if (create) root = new Begin();
2427             return -1;
2428         case &#39;B&#39;:
2429             if (inclass) break;
2430             if (create) root = new Bound(Bound.NONE, has(UNICODE_CHARACTER_CLASS));
2431             return -1;
2432         case &#39;C&#39;:
2433             break;
2434         case &#39;D&#39;:
2435             if (create) {
2436                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2437                             CharPredicates.DIGIT() : CharPredicates.ASCII_DIGIT();
2438                 predicate = predicate.negate();
2439                 if (!inclass)
2440                     root = newCharProperty(predicate);
2441             }
2442             return -1;
2443         case &#39;E&#39;:
2444         case &#39;F&#39;:
2445             break;
2446         case &#39;G&#39;:
2447             if (inclass) break;
2448             if (create) root = new LastMatch();
2449             return -1;
2450         case &#39;H&#39;:
2451             if (create) {
2452                 predicate = HorizWS().negate();
2453                 if (!inclass)
2454                     root = newCharProperty(predicate);
2455             }
2456             return -1;
2457         case &#39;I&#39;:
2458         case &#39;J&#39;:
2459         case &#39;K&#39;:
2460         case &#39;L&#39;:
2461         case &#39;M&#39;:
2462             break;
2463         case &#39;N&#39;:
2464             return N();
2465         case &#39;O&#39;:
2466         case &#39;P&#39;:
2467         case &#39;Q&#39;:
2468             break;
2469         case &#39;R&#39;:
2470             if (inclass) break;
2471             if (create) root = new LineEnding();
2472             return -1;
2473         case &#39;S&#39;:
2474             if (create) {
2475                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2476                             CharPredicates.WHITE_SPACE() : CharPredicates.ASCII_SPACE();
2477                 predicate = predicate.negate();
2478                 if (!inclass)
2479                     root = newCharProperty(predicate);
2480             }
2481             return -1;
2482         case &#39;T&#39;:
2483         case &#39;U&#39;:
2484             break;
2485         case &#39;V&#39;:
2486             if (create) {
2487                 predicate = VertWS().negate();
2488                 if (!inclass)
2489                     root = newCharProperty(predicate);
2490             }
2491             return -1;
2492         case &#39;W&#39;:
2493             if (create) {
2494                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2495                             CharPredicates.WORD() : CharPredicates.ASCII_WORD();
2496                 predicate = predicate.negate();
2497                 if (!inclass)
2498                     root = newCharProperty(predicate);
2499             }
2500             return -1;
2501         case &#39;X&#39;:
2502             if (inclass) break;
2503             if (create) {
2504                 root = new XGrapheme();
2505             }
2506             return -1;
2507         case &#39;Y&#39;:
2508             break;
2509         case &#39;Z&#39;:
2510             if (inclass) break;
2511             if (create) {
2512                 if (has(UNIX_LINES))
2513                     root = new UnixDollar(false);
2514                 else
2515                     root = new Dollar(false);
2516             }
2517             return -1;
2518         case &#39;a&#39;:
2519             return &#39;\007&#39;;
2520         case &#39;b&#39;:
2521             if (inclass) break;
2522             if (create) {
2523                 if (peek() == &#39;{&#39;) {
2524                     if (skip() == &#39;g&#39;) {
2525                         if (read() == &#39;}&#39;) {
2526                             root = new GraphemeBound();
2527                             return -1;
2528                         }
2529                         break;  // error missing trailing }
2530                     }
2531                     unread(); unread();
2532                 }
2533                 root = new Bound(Bound.BOTH, has(UNICODE_CHARACTER_CLASS));
2534             }
2535             return -1;
2536         case &#39;c&#39;:
2537             return c();
2538         case &#39;d&#39;:
2539             if (create) {
2540                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2541                             CharPredicates.DIGIT() : CharPredicates.ASCII_DIGIT();
2542                 if (!inclass)
2543                     root = newCharProperty(predicate);
2544             }
2545             return -1;
2546         case &#39;e&#39;:
2547             return &#39;\033&#39;;
2548         case &#39;f&#39;:
2549             return &#39;\f&#39;;
2550         case &#39;g&#39;:
2551             break;
2552         case &#39;h&#39;:
2553             if (create) {
2554                 predicate = HorizWS();
2555                 if (!inclass)
2556                     root = newCharProperty(predicate);
2557             }
2558             return -1;
2559         case &#39;i&#39;:
2560         case &#39;j&#39;:
2561             break;
2562         case &#39;k&#39;:
2563             if (inclass)
2564                 break;
2565             if (read() != &#39;&lt;&#39;)
2566                 throw error(&quot;\\k is not followed by &#39;&lt;&#39; for named capturing group&quot;);
2567             String name = groupname(read());
2568             if (!namedGroups().containsKey(name))
2569                 throw error(&quot;named capturing group &lt;&quot; + name + &quot;&gt; does not exist&quot;);
2570             if (create) {
2571                 hasGroupRef = true;
2572                 if (has(CASE_INSENSITIVE))
2573                     root = new CIBackRef(namedGroups().get(name), has(UNICODE_CASE));
2574                 else
2575                     root = new BackRef(namedGroups().get(name));
2576             }
2577             return -1;
2578         case &#39;l&#39;:
2579         case &#39;m&#39;:
2580             break;
2581         case &#39;n&#39;:
2582             return &#39;\n&#39;;
2583         case &#39;o&#39;:
2584         case &#39;p&#39;:
2585         case &#39;q&#39;:
2586             break;
2587         case &#39;r&#39;:
2588             return &#39;\r&#39;;
2589         case &#39;s&#39;:
2590             if (create) {
2591                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2592                             CharPredicates.WHITE_SPACE() : CharPredicates.ASCII_SPACE();
2593                 if (!inclass)
2594                     root = newCharProperty(predicate);
2595             }
2596             return -1;
2597         case &#39;t&#39;:
2598             return &#39;\t&#39;;
2599         case &#39;u&#39;:
2600             return u();
2601         case &#39;v&#39;:
2602             // &#39;\v&#39; was implemented as VT/0x0B in releases &lt; 1.8 (though
2603             // undocumented). In JDK8 &#39;\v&#39; is specified as a predefined
2604             // character class for all vertical whitespace characters.
2605             // So [-1, root=VertWS node] pair is returned (instead of a
2606             // single 0x0B). This breaks the range if &#39;\v&#39; is used as
2607             // the start or end value, such as [\v-...] or [...-\v], in
2608             // which a single definite value (0x0B) is expected. For
2609             // compatibility concern &#39;\013&#39;/0x0B is returned if isrange.
2610             if (isrange)
2611                 return &#39;\013&#39;;
2612             if (create) {
2613                 predicate = VertWS();
2614                 if (!inclass)
2615                     root = newCharProperty(predicate);
2616             }
2617             return -1;
2618         case &#39;w&#39;:
2619             if (create) {
2620                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2621                             CharPredicates.WORD() : CharPredicates.ASCII_WORD();
2622                 if (!inclass)
2623                     root = newCharProperty(predicate);
2624             }
2625             return -1;
2626         case &#39;x&#39;:
2627             return x();
2628         case &#39;y&#39;:
2629             break;
2630         case &#39;z&#39;:
2631             if (inclass) break;
2632             if (create) root = new End();
2633             return -1;
2634         default:
2635             return ch;
2636         }
2637         throw error(&quot;Illegal/unsupported escape sequence&quot;);
2638     }
2639 
2640     /**
2641      * Parse a character class, and return the node that matches it.
2642      *
2643      * Consumes a ] on the way out if consume is true. Usually consume
2644      * is true except for the case of [abc&amp;&amp;def] where def is a separate
2645      * right hand node with &quot;understood&quot; brackets.
2646      */
2647     private CharPredicate clazz(boolean consume) {
2648         CharPredicate prev = null;
2649         CharPredicate curr = null;
2650         BitClass bits = new BitClass();
2651 
2652         boolean isNeg = false;
2653         boolean hasBits = false;
2654         int ch = next();
2655 
2656         // Negates if first char in a class, otherwise literal
2657         if (ch == &#39;^&#39; &amp;&amp; temp[cursor-1] == &#39;[&#39;) {
2658             ch = next();
2659             isNeg = true;
2660         }
2661         for (;;) {
2662             switch (ch) {
2663                 case &#39;[&#39;:
2664                     curr = clazz(true);
2665                     if (prev == null)
2666                         prev = curr;
2667                     else
2668                         prev = prev.union(curr);
2669                     ch = peek();
2670                     continue;
2671                 case &#39;&amp;&#39;:
2672                     ch = next();
2673                     if (ch == &#39;&amp;&#39;) {
2674                         ch = next();
2675                         CharPredicate right = null;
2676                         while (ch != &#39;]&#39; &amp;&amp; ch != &#39;&amp;&#39;) {
2677                             if (ch == &#39;[&#39;) {
2678                                 if (right == null)
2679                                     right = clazz(true);
2680                                 else
2681                                     right = right.union(clazz(true));
2682                             } else { // abc&amp;&amp;def
2683                                 unread();
2684                                 right = clazz(false);
2685                             }
2686                             ch = peek();
2687                         }
2688                         if (hasBits) {
2689                             // bits used, union has high precedence
2690                             if (prev == null) {
2691                                 prev = curr = bits;
2692                             } else {
2693                                 prev = prev.union(bits);
2694                             }
2695                             hasBits = false;
2696                         }
2697                         if (right != null)
2698                             curr = right;
2699                         if (prev == null) {
2700                             if (right == null)
2701                                 throw error(&quot;Bad class syntax&quot;);
2702                             else
2703                                 prev = right;
2704                         } else {
2705                             prev = prev.and(curr);
2706                         }
2707                     } else {
2708                         // treat as a literal &amp;
2709                         unread();
2710                         break;
2711                     }
2712                     continue;
2713                 case 0:
2714                     if (cursor &gt;= patternLength)
2715                         throw error(&quot;Unclosed character class&quot;);
2716                     break;
2717                 case &#39;]&#39;:
2718                     if (prev != null || hasBits) {
2719                         if (consume)
2720                             next();
2721                         if (prev == null)
2722                             prev = bits;
2723                         else if (hasBits)
2724                             prev = prev.union(bits);
2725                         if (isNeg)
2726                             return prev.negate();
2727                         return prev;
2728                     }
2729                     break;
2730                 default:
2731                     break;
2732             }
2733             curr = range(bits);
2734             if (curr == null) {    // the bits used
2735                 hasBits = true;
2736             } else {
2737                 if (prev == null)
2738                     prev = curr;
2739                 else if (prev != curr)
2740                     prev = prev.union(curr);
2741             }
2742             ch = peek();
2743         }
2744     }
2745 
2746     private CharPredicate bitsOrSingle(BitClass bits, int ch) {
2747         /* Bits can only handle codepoints in [u+0000-u+00ff] range.
2748            Use &quot;single&quot; node instead of bits when dealing with unicode
2749            case folding for codepoints listed below.
2750            (1)Uppercase out of range: u+00ff, u+00b5
2751               toUpperCase(u+00ff) -&gt; u+0178
2752               toUpperCase(u+00b5) -&gt; u+039c
2753            (2)LatinSmallLetterLongS u+17f
2754               toUpperCase(u+017f) -&gt; u+0053
2755            (3)LatinSmallLetterDotlessI u+131
2756               toUpperCase(u+0131) -&gt; u+0049
2757            (4)LatinCapitalLetterIWithDotAbove u+0130
2758               toLowerCase(u+0130) -&gt; u+0069
2759            (5)KelvinSign u+212a
2760               toLowerCase(u+212a) ==&gt; u+006B
2761            (6)AngstromSign u+212b
2762               toLowerCase(u+212b) ==&gt; u+00e5
2763         */
2764         if (ch &lt; 256 &amp;&amp;
2765             !(has(CASE_INSENSITIVE) &amp;&amp; has(UNICODE_CASE) &amp;&amp;
2766               (ch == 0xff || ch == 0xb5 ||
2767                ch == 0x49 || ch == 0x69 ||    //I and i
2768                ch == 0x53 || ch == 0x73 ||    //S and s
2769                ch == 0x4b || ch == 0x6b ||    //K and k
2770                ch == 0xc5 || ch == 0xe5))) {  //A+ring
2771             bits.add(ch, flags0);
2772             return null;
2773         }
2774         return single(ch);
2775     }
2776 
2777     /**
2778      *  Returns a suitably optimized, single character predicate
2779      */
2780     private CharPredicate single(final int ch) {
2781         if (has(CASE_INSENSITIVE)) {
2782             int lower, upper;
2783             if (has(UNICODE_CASE)) {
2784                 upper = Character.toUpperCase(ch);
2785                 lower = Character.toLowerCase(upper);
2786                 // Unicode case insensitive matches
2787                 if (upper != lower)
2788                     return SingleU(lower);
2789             } else if (ASCII.isAscii(ch)) {
2790                 lower = ASCII.toLower(ch);
2791                 upper = ASCII.toUpper(ch);
2792                 // Case insensitive matches a given BMP character
2793                 if (lower != upper)
2794                     return SingleI(lower, upper);
2795             }
2796         }
2797         if (isSupplementary(ch))
2798             return SingleS(ch);
2799         return Single(ch);  // Match a given BMP character
2800     }
2801 
2802     /**
2803      * Parse a single character or a character range in a character class
2804      * and return its representative node.
2805      */
2806     private CharPredicate range(BitClass bits) {
2807         int ch = peek();
2808         if (ch == &#39;\\&#39;) {
2809             ch = nextEscaped();
2810             if (ch == &#39;p&#39; || ch == &#39;P&#39;) { // A property
2811                 boolean comp = (ch == &#39;P&#39;);
2812                 boolean oneLetter = true;
2813                 // Consume { if present
2814                 ch = next();
2815                 if (ch != &#39;{&#39;)
2816                     unread();
2817                 else
2818                     oneLetter = false;
2819                 return family(oneLetter, comp);
2820             } else { // ordinary escape
2821                 boolean isrange = temp[cursor+1] == &#39;-&#39;;
2822                 unread();
2823                 ch = escape(true, true, isrange);
2824                 if (ch == -1)
2825                     return predicate;
2826             }
2827         } else {
2828             next();
2829         }
2830         if (ch &gt;= 0) {
2831             if (peek() == &#39;-&#39;) {
2832                 int endRange = temp[cursor+1];
2833                 if (endRange == &#39;[&#39;) {
2834                     return bitsOrSingle(bits, ch);
2835                 }
2836                 if (endRange != &#39;]&#39;) {
2837                     next();
2838                     int m = peek();
2839                     if (m == &#39;\\&#39;) {
2840                         m = escape(true, false, true);
2841                     } else {
2842                         next();
2843                     }
2844                     if (m &lt; ch) {
2845                         throw error(&quot;Illegal character range&quot;);
2846                     }
2847                     if (has(CASE_INSENSITIVE)) {
2848                         if (has(UNICODE_CASE))
2849                             return CIRangeU(ch, m);
2850                         return CIRange(ch, m);
2851                     } else {
2852                         return Range(ch, m);
2853                     }
2854                 }
2855             }
2856             return bitsOrSingle(bits, ch);
2857         }
2858         throw error(&quot;Unexpected character &#39;&quot;+((char)ch)+&quot;&#39;&quot;);
2859     }
2860 
2861     /**
2862      * Parses a Unicode character family and returns its representative node.
2863      */
2864     private CharPredicate family(boolean singleLetter, boolean isComplement) {
2865         next();
2866         String name;
2867         CharPredicate p = null;
2868 
2869         if (singleLetter) {
2870             int c = temp[cursor];
2871             if (!Character.isSupplementaryCodePoint(c)) {
2872                 name = String.valueOf((char)c);
2873             } else {
2874                 name = new String(temp, cursor, 1);
2875             }
2876             read();
2877         } else {
2878             int i = cursor;
2879             mark(&#39;}&#39;);
2880             while(read() != &#39;}&#39;) {
2881             }
2882             mark(&#39;\000&#39;);
2883             int j = cursor;
2884             if (j &gt; patternLength)
2885                 throw error(&quot;Unclosed character family&quot;);
2886             if (i + 1 &gt;= j)
2887                 throw error(&quot;Empty character family&quot;);
2888             name = new String(temp, i, j-i-1);
2889         }
2890 
2891         int i = name.indexOf(&#39;=&#39;);
2892         if (i != -1) {
2893             // property construct \p{name=value}
2894             String value = name.substring(i + 1);
2895             name = name.substring(0, i).toLowerCase(Locale.ENGLISH);
2896             switch (name) {
2897                 case &quot;sc&quot;:
2898                 case &quot;script&quot;:
2899                     p = CharPredicates.forUnicodeScript(value);
2900                     break;
2901                 case &quot;blk&quot;:
2902                 case &quot;block&quot;:
2903                     p = CharPredicates.forUnicodeBlock(value);
2904                     break;
2905                 case &quot;gc&quot;:
2906                 case &quot;general_category&quot;:
2907                     p = CharPredicates.forProperty(value, has(CASE_INSENSITIVE));
2908                     break;
2909                 default:
2910                     break;
2911             }
2912             if (p == null)
2913                 throw error(&quot;Unknown Unicode property {name=&lt;&quot; + name + &quot;&gt;, &quot;
2914                              + &quot;value=&lt;&quot; + value + &quot;&gt;}&quot;);
2915 
2916         } else {
2917             if (name.startsWith(&quot;In&quot;)) {
2918                 // \p{InBlockName}
2919                 p = CharPredicates.forUnicodeBlock(name.substring(2));
2920             } else if (name.startsWith(&quot;Is&quot;)) {
2921                 // \p{IsGeneralCategory} and \p{IsScriptName}
2922                 String shortName = name.substring(2);
2923                 p = CharPredicates.forUnicodeProperty(shortName, has(CASE_INSENSITIVE));
2924                 if (p == null)
2925                     p = CharPredicates.forProperty(shortName, has(CASE_INSENSITIVE));
2926                 if (p == null)
2927                     p = CharPredicates.forUnicodeScript(shortName);
2928             } else {
2929                 if (has(UNICODE_CHARACTER_CLASS))
2930                     p = CharPredicates.forPOSIXName(name, has(CASE_INSENSITIVE));
2931                 if (p == null)
2932                     p = CharPredicates.forProperty(name, has(CASE_INSENSITIVE));
2933             }
2934             if (p == null)
2935                 throw error(&quot;Unknown character property name {&quot; + name + &quot;}&quot;);
2936         }
2937         if (isComplement) {
2938             // it might be too expensive to detect if a complement of
2939             // CharProperty can match &quot;certain&quot; supplementary. So just
2940             // go with StartS.
2941             hasSupplementary = true;
2942             p = p.negate();
2943         }
2944         return p;
2945     }
2946 
2947     private CharProperty newCharProperty(CharPredicate p) {
2948         if (p == null)
2949             return null;
2950         if (p instanceof BmpCharPredicate)
2951             return new BmpCharProperty((BmpCharPredicate)p);
<a name="3" id="anc3"></a><span class="line-modified">2952         else {</span>
<span class="line-added">2953             hasSupplementary = true;</span>
2954             return new CharProperty(p);
<a name="4" id="anc4"></a><span class="line-added">2955         }</span>
2956     }
2957 
2958     /**
2959      * Parses and returns the name of a &quot;named capturing group&quot;, the trailing
2960      * &quot;&gt;&quot; is consumed after parsing.
2961      */
2962     private String groupname(int ch) {
2963         StringBuilder sb = new StringBuilder();
2964         if (!ASCII.isAlpha(ch))
2965             throw error(&quot;capturing group name does not start with a Latin letter&quot;);
2966         do {
2967             sb.append((char) ch);
2968         } while (ASCII.isAlnum(ch=read()));
2969         if (ch != &#39;&gt;&#39;)
2970             throw error(&quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;);
2971         return sb.toString();
2972     }
2973 
2974     /**
2975      * Parses a group and returns the head node of a set of nodes that process
2976      * the group. Sometimes a double return system is used where the tail is
2977      * returned in root.
2978      */
2979     private Node group0() {
2980         boolean capturingGroup = false;
2981         Node head;
2982         Node tail;
2983         int save = flags0;
2984         int saveTCNCount = topClosureNodes.size();
2985         root = null;
2986         int ch = next();
2987         if (ch == &#39;?&#39;) {
2988             ch = skip();
2989             switch (ch) {
2990             case &#39;:&#39;:   //  (?:xxx) pure group
2991                 head = createGroup(true);
2992                 tail = root;
2993                 head.next = expr(tail);
2994                 break;
2995             case &#39;=&#39;:   // (?=xxx) and (?!xxx) lookahead
2996             case &#39;!&#39;:
2997                 head = createGroup(true);
2998                 tail = root;
2999                 head.next = expr(tail);
3000                 if (ch == &#39;=&#39;) {
3001                     head = tail = new Pos(head);
3002                 } else {
3003                     head = tail = new Neg(head);
3004                 }
3005                 break;
3006             case &#39;&gt;&#39;:   // (?&gt;xxx)  independent group
3007                 head = createGroup(true);
3008                 tail = root;
3009                 head.next = expr(tail);
3010                 head = tail = new Ques(head, Qtype.INDEPENDENT);
3011                 break;
3012             case &#39;&lt;&#39;:   // (?&lt;xxx)  look behind
3013                 ch = read();
3014                 if (ch != &#39;=&#39; &amp;&amp; ch != &#39;!&#39;) {
3015                     // named captured group
3016                     String name = groupname(ch);
3017                     if (namedGroups().containsKey(name))
3018                         throw error(&quot;Named capturing group &lt;&quot; + name
3019                                     + &quot;&gt; is already defined&quot;);
3020                     capturingGroup = true;
3021                     head = createGroup(false);
3022                     tail = root;
3023                     namedGroups().put(name, capturingGroupCount-1);
3024                     head.next = expr(tail);
3025                     break;
3026                 }
3027                 int start = cursor;
3028                 head = createGroup(true);
3029                 tail = root;
3030                 head.next = expr(tail);
3031                 tail.next = LookBehindEndNode.INSTANCE;
3032                 TreeInfo info = new TreeInfo();
3033                 head.study(info);
3034                 if (info.maxValid == false) {
3035                     throw error(&quot;Look-behind group does not have &quot;
3036                                 + &quot;an obvious maximum length&quot;);
3037                 }
3038                 boolean hasSupplementary = findSupplementary(start, patternLength);
3039                 if (ch == &#39;=&#39;) {
3040                     head = tail = (hasSupplementary ?
3041                                    new BehindS(head, info.maxLength,
3042                                                info.minLength) :
3043                                    new Behind(head, info.maxLength,
3044                                               info.minLength));
3045                 } else { // if (ch == &#39;!&#39;)
3046                     head = tail = (hasSupplementary ?
3047                                    new NotBehindS(head, info.maxLength,
3048                                                   info.minLength) :
3049                                    new NotBehind(head, info.maxLength,
3050                                                  info.minLength));
3051                 }
3052                 // clear all top-closure-nodes inside lookbehind
3053                 if (saveTCNCount &lt; topClosureNodes.size())
3054                     topClosureNodes.subList(saveTCNCount, topClosureNodes.size()).clear();
3055                 break;
3056             case &#39;$&#39;:
3057             case &#39;@&#39;:
3058                 throw error(&quot;Unknown group type&quot;);
3059             default:    // (?xxx:) inlined match flags
3060                 unread();
3061                 addFlag();
3062                 ch = read();
3063                 if (ch == &#39;)&#39;) {
3064                     return null;    // Inline modifier only
3065                 }
3066                 if (ch != &#39;:&#39;) {
3067                     throw error(&quot;Unknown inline modifier&quot;);
3068                 }
3069                 head = createGroup(true);
3070                 tail = root;
3071                 head.next = expr(tail);
3072                 break;
3073             }
3074         } else { // (xxx) a regular group
3075             capturingGroup = true;
3076             head = createGroup(false);
3077             tail = root;
3078             head.next = expr(tail);
3079         }
3080 
3081         accept(&#39;)&#39;, &quot;Unclosed group&quot;);
3082         flags0 = save;
3083 
3084         // Check for quantifiers
3085         Node node = closure(head);
3086         if (node == head) { // No closure
3087             root = tail;
3088             return node;    // Dual return
3089         }
3090         if (head == tail) { // Zero length assertion
3091             root = node;
3092             return node;    // Dual return
3093         }
3094 
3095         // have group closure, clear all inner closure nodes from the
3096         // top list (no backtracking stopper optimization for inner
3097         if (saveTCNCount &lt; topClosureNodes.size())
3098             topClosureNodes.subList(saveTCNCount, topClosureNodes.size()).clear();
3099 
3100         return groupWithClosure(node, head, tail, capturingGroup);
3101     }
3102 
3103     /**
3104      * Transforms a Group with quantifiers into some special constructs
3105      * (such as Branch or Loop/GroupCurly), if necessary.
3106      *
3107      * This method is applied either to actual groups or to the Unicode
3108      * linebreak (aka \\R) represented as an anonymous group.
3109      */
3110     private Node groupWithClosure(Node node, Node head, Node tail,
3111                                   boolean capturingGroup)
3112     {
3113         if (node instanceof Ques) {
3114             Ques ques = (Ques) node;
3115             if (ques.type == Qtype.POSSESSIVE) {
3116                 root = node;
3117                 return node;
3118             }
3119             BranchConn branchConn = new BranchConn();
3120             tail = tail.next = branchConn;
3121             if (ques.type == Qtype.GREEDY) {
3122                 head = new Branch(head, null, branchConn);
3123             } else { // Reluctant quantifier
3124                 head = new Branch(null, head, branchConn);
3125             }
3126             root = tail;
3127             return head;
3128         } else if (node instanceof Curly) {
3129             Curly curly = (Curly) node;
3130             if (curly.type == Qtype.POSSESSIVE) {
3131                 root = node;
3132                 return node;
3133             }
3134             // Discover if the group is deterministic
3135             TreeInfo info = new TreeInfo();
3136             if (head.study(info)) { // Deterministic
3137                 GroupTail temp = (GroupTail) tail;
3138                 head = root = new GroupCurly(head.next, curly.cmin,
3139                                    curly.cmax, curly.type,
3140                                    ((GroupTail)tail).localIndex,
3141                                    ((GroupTail)tail).groupIndex,
3142                                              capturingGroup);
3143                 return head;
3144             } else { // Non-deterministic
3145                 int temp = ((GroupHead) head).localIndex;
3146                 Loop loop;
3147                 if (curly.type == Qtype.GREEDY) {
3148                     loop = new Loop(this.localCount, temp);
3149                     // add the max_reps greedy to the top-closure-node list
3150                     if (curly.cmax == MAX_REPS)
3151                         topClosureNodes.add(loop);
3152                 } else {  // Reluctant Curly
3153                     loop = new LazyLoop(this.localCount, temp);
3154                 }
3155                 Prolog prolog = new Prolog(loop);
3156                 this.localCount += 1;
3157                 loop.cmin = curly.cmin;
3158                 loop.cmax = curly.cmax;
3159                 loop.body = head;
3160                 tail.next = loop;
3161                 root = loop;
3162                 return prolog; // Dual return
3163             }
3164         }
3165         throw error(&quot;Internal logic error&quot;);
3166     }
3167 
3168     /**
3169      * Create group head and tail nodes using double return. If the group is
3170      * created with anonymous true then it is a pure group and should not
3171      * affect group counting.
3172      */
3173     private Node createGroup(boolean anonymous) {
3174         int localIndex = localCount++;
3175         int groupIndex = 0;
3176         if (!anonymous)
3177             groupIndex = capturingGroupCount++;
3178         GroupHead head = new GroupHead(localIndex);
3179         root = new GroupTail(localIndex, groupIndex);
3180 
3181         // for debug/print only, head.match does NOT need the &quot;tail&quot; info
3182         head.tail = (GroupTail)root;
3183 
3184         if (!anonymous &amp;&amp; groupIndex &lt; 10)
3185             groupNodes[groupIndex] = head;
3186         return head;
3187     }
3188 
3189     @SuppressWarnings(&quot;fallthrough&quot;)
3190     /**
3191      * Parses inlined match flags and set them appropriately.
3192      */
3193     private void addFlag() {
3194         int ch = peek();
3195         for (;;) {
3196             switch (ch) {
3197             case &#39;i&#39;:
3198                 flags0 |= CASE_INSENSITIVE;
3199                 break;
3200             case &#39;m&#39;:
3201                 flags0 |= MULTILINE;
3202                 break;
3203             case &#39;s&#39;:
3204                 flags0 |= DOTALL;
3205                 break;
3206             case &#39;d&#39;:
3207                 flags0 |= UNIX_LINES;
3208                 break;
3209             case &#39;u&#39;:
3210                 flags0 |= UNICODE_CASE;
3211                 break;
3212             case &#39;c&#39;:
3213                 flags0 |= CANON_EQ;
3214                 break;
3215             case &#39;x&#39;:
3216                 flags0 |= COMMENTS;
3217                 break;
3218             case &#39;U&#39;:
3219                 flags0 |= (UNICODE_CHARACTER_CLASS | UNICODE_CASE);
3220                 break;
3221             case &#39;-&#39;: // subFlag then fall through
3222                 ch = next();
3223                 subFlag();
3224             default:
3225                 return;
3226             }
3227             ch = next();
3228         }
3229     }
3230 
3231     @SuppressWarnings(&quot;fallthrough&quot;)
3232     /**
3233      * Parses the second part of inlined match flags and turns off
3234      * flags appropriately.
3235      */
3236     private void subFlag() {
3237         int ch = peek();
3238         for (;;) {
3239             switch (ch) {
3240             case &#39;i&#39;:
3241                 flags0 &amp;= ~CASE_INSENSITIVE;
3242                 break;
3243             case &#39;m&#39;:
3244                 flags0 &amp;= ~MULTILINE;
3245                 break;
3246             case &#39;s&#39;:
3247                 flags0 &amp;= ~DOTALL;
3248                 break;
3249             case &#39;d&#39;:
3250                 flags0 &amp;= ~UNIX_LINES;
3251                 break;
3252             case &#39;u&#39;:
3253                 flags0 &amp;= ~UNICODE_CASE;
3254                 break;
3255             case &#39;c&#39;:
3256                 flags0 &amp;= ~CANON_EQ;
3257                 break;
3258             case &#39;x&#39;:
3259                 flags0 &amp;= ~COMMENTS;
3260                 break;
3261             case &#39;U&#39;:
3262                 flags0 &amp;= ~(UNICODE_CHARACTER_CLASS | UNICODE_CASE);
3263                 break;
3264             default:
3265                 return;
3266             }
3267             ch = next();
3268         }
3269     }
3270 
3271     static final int MAX_REPS   = 0x7FFFFFFF;
3272 
3273     static enum Qtype {
3274         GREEDY, LAZY, POSSESSIVE, INDEPENDENT
3275     }
3276 
3277     private Qtype qtype() {
3278         int ch = next();
3279         if (ch == &#39;?&#39;) {
3280             next();
3281             return Qtype.LAZY;
3282         } else if (ch == &#39;+&#39;) {
3283             next();
3284             return Qtype.POSSESSIVE;
3285         }
3286         return Qtype.GREEDY;
3287     }
3288 
3289     private Node curly(Node prev, int cmin) {
3290         Qtype qtype = qtype();
3291         if (qtype == Qtype.GREEDY) {
3292             if (prev instanceof BmpCharProperty) {
3293                 return new BmpCharPropertyGreedy((BmpCharProperty)prev, cmin);
3294             } else if (prev instanceof CharProperty) {
3295                 return new CharPropertyGreedy((CharProperty)prev, cmin);
3296             }
3297         }
3298         return new Curly(prev, cmin, MAX_REPS, qtype);
3299     }
3300 
3301     /**
3302      * Processing repetition of a Unicode linebreak \\R.
3303      */
3304     private Node closureOfLineEnding(LineEnding le) {
3305         int ch = peek();
3306         if (ch != &#39;?&#39; &amp;&amp; ch != &#39;*&#39; &amp;&amp; ch != &#39;+&#39; &amp;&amp; ch != &#39;{&#39;) {
3307             return le;
3308         }
3309 
3310         // Replace the LineEnding with an anonymous group
3311         // (?:\\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029])
3312         Node grHead = createGroup(true);
3313         Node grTail = root;
3314         BranchConn branchConn = new BranchConn();
3315         branchConn.next = grTail;
3316         Node slice = new Slice(new int[] {0x0D, 0x0A});
3317         slice.next = branchConn;
3318         Node chClass = newCharProperty(x -&gt; x == 0x0A || x == 0x0B ||
3319                 x == 0x0C || x == 0x0D || x == 0x85 || x == 0x2028 ||
3320                 x == 0x2029);
3321         chClass.next = branchConn;
3322         grHead.next = new Branch(slice, chClass, branchConn);
3323         return groupWithClosure(closure(grHead), grHead, grTail, false);
3324     }
3325 
3326     /**
3327      * Processes repetition. If the next character peeked is a quantifier
3328      * then new nodes must be appended to handle the repetition.
3329      * Prev could be a single or a group, so it could be a chain of nodes.
3330      */
3331     private Node closure(Node prev) {
3332         int ch = peek();
3333         switch (ch) {
3334         case &#39;?&#39;:
3335             return new Ques(prev, qtype());
3336         case &#39;*&#39;:
3337             return curly(prev, 0);
3338         case &#39;+&#39;:
3339             return curly(prev, 1);
3340         case &#39;{&#39;:
3341             ch = skip();
3342             if (ASCII.isDigit(ch)) {
3343                 int cmin = 0, cmax;
3344                 try {
3345                     do {
3346                         cmin = Math.addExact(Math.multiplyExact(cmin, 10),
3347                                              ch - &#39;0&#39;);
3348                     } while (ASCII.isDigit(ch = read()));
3349                     if (ch == &#39;,&#39;) {
3350                         ch = read();
3351                         if (ch == &#39;}&#39;) {
3352                             unread();
3353                             return curly(prev, cmin);
3354                         } else {
3355                             cmax = 0;
3356                             while (ASCII.isDigit(ch)) {
3357                                 cmax = Math.addExact(Math.multiplyExact(cmax, 10),
3358                                                      ch - &#39;0&#39;);
3359                                 ch = read();
3360                             }
3361                         }
3362                     } else {
3363                         cmax = cmin;
3364                     }
3365                 } catch (ArithmeticException ae) {
3366                     throw error(&quot;Illegal repetition range&quot;);
3367                 }
3368                 if (ch != &#39;}&#39;)
3369                     throw error(&quot;Unclosed counted closure&quot;);
3370                 if (cmax &lt; cmin)
3371                     throw error(&quot;Illegal repetition range&quot;);
3372                 unread();
3373                 return (cmin == 0 &amp;&amp; cmax == 1)
3374                         ? new Ques(prev, qtype())
3375                         : new Curly(prev, cmin, cmax, qtype());
3376             } else {
3377                 throw error(&quot;Illegal repetition&quot;);
3378             }
3379         default:
3380             return prev;
3381         }
3382     }
3383 
3384     /**
3385      *  Utility method for parsing control escape sequences.
3386      */
3387     private int c() {
3388         if (cursor &lt; patternLength) {
3389             return read() ^ 64;
3390         }
3391         throw error(&quot;Illegal control escape sequence&quot;);
3392     }
3393 
3394     /**
3395      *  Utility method for parsing octal escape sequences.
3396      */
3397     private int o() {
3398         int n = read();
3399         if (((n-&#39;0&#39;)|(&#39;7&#39;-n)) &gt;= 0) {
3400             int m = read();
3401             if (((m-&#39;0&#39;)|(&#39;7&#39;-m)) &gt;= 0) {
3402                 int o = read();
3403                 if ((((o-&#39;0&#39;)|(&#39;7&#39;-o)) &gt;= 0) &amp;&amp; (((n-&#39;0&#39;)|(&#39;3&#39;-n)) &gt;= 0)) {
3404                     return (n - &#39;0&#39;) * 64 + (m - &#39;0&#39;) * 8 + (o - &#39;0&#39;);
3405                 }
3406                 unread();
3407                 return (n - &#39;0&#39;) * 8 + (m - &#39;0&#39;);
3408             }
3409             unread();
3410             return (n - &#39;0&#39;);
3411         }
3412         throw error(&quot;Illegal octal escape sequence&quot;);
3413     }
3414 
3415     /**
3416      *  Utility method for parsing hexadecimal escape sequences.
3417      */
3418     private int x() {
3419         int n = read();
3420         if (ASCII.isHexDigit(n)) {
3421             int m = read();
3422             if (ASCII.isHexDigit(m)) {
3423                 return ASCII.toDigit(n) * 16 + ASCII.toDigit(m);
3424             }
3425         } else if (n == &#39;{&#39; &amp;&amp; ASCII.isHexDigit(peek())) {
3426             int ch = 0;
3427             while (ASCII.isHexDigit(n = read())) {
3428                 ch = (ch &lt;&lt; 4) + ASCII.toDigit(n);
3429                 if (ch &gt; Character.MAX_CODE_POINT)
3430                     throw error(&quot;Hexadecimal codepoint is too big&quot;);
3431             }
3432             if (n != &#39;}&#39;)
3433                 throw error(&quot;Unclosed hexadecimal escape sequence&quot;);
3434             return ch;
3435         }
3436         throw error(&quot;Illegal hexadecimal escape sequence&quot;);
3437     }
3438 
3439     /**
3440      *  Utility method for parsing unicode escape sequences.
3441      */
3442     private int cursor() {
3443         return cursor;
3444     }
3445 
3446     private void setcursor(int pos) {
3447         cursor = pos;
3448     }
3449 
3450     private int uxxxx() {
3451         int n = 0;
3452         for (int i = 0; i &lt; 4; i++) {
3453             int ch = read();
3454             if (!ASCII.isHexDigit(ch)) {
3455                 throw error(&quot;Illegal Unicode escape sequence&quot;);
3456             }
3457             n = n * 16 + ASCII.toDigit(ch);
3458         }
3459         return n;
3460     }
3461 
3462     private int u() {
3463         int n = uxxxx();
3464         if (Character.isHighSurrogate((char)n)) {
3465             int cur = cursor();
3466             if (read() == &#39;\\&#39; &amp;&amp; read() == &#39;u&#39;) {
3467                 int n2 = uxxxx();
3468                 if (Character.isLowSurrogate((char)n2))
3469                     return Character.toCodePoint((char)n, (char)n2);
3470             }
3471             setcursor(cur);
3472         }
3473         return n;
3474     }
3475 
3476     private int N() {
3477         if (read() == &#39;{&#39;) {
3478             int i = cursor;
3479             while (read() != &#39;}&#39;) {
3480                 if (cursor &gt;= patternLength)
3481                     throw error(&quot;Unclosed character name escape sequence&quot;);
3482             }
3483             String name = new String(temp, i, cursor - i - 1);
3484             try {
3485                 return Character.codePointOf(name);
3486             } catch (IllegalArgumentException x) {
3487                 throw error(&quot;Unknown character name [&quot; + name + &quot;]&quot;);
3488             }
3489         }
3490         throw error(&quot;Illegal character name escape sequence&quot;);
3491     }
3492 
3493     //
3494     // Utility methods for code point support
3495     //
3496     private static final int countChars(CharSequence seq, int index,
3497                                         int lengthInCodePoints) {
3498         // optimization
3499         if (lengthInCodePoints == 1 &amp;&amp; !Character.isHighSurrogate(seq.charAt(index))) {
3500             assert (index &gt;= 0 &amp;&amp; index &lt; seq.length());
3501             return 1;
3502         }
3503         int length = seq.length();
3504         int x = index;
3505         if (lengthInCodePoints &gt;= 0) {
3506             assert (index &gt;= 0 &amp;&amp; index &lt; length);
3507             for (int i = 0; x &lt; length &amp;&amp; i &lt; lengthInCodePoints; i++) {
3508                 if (Character.isHighSurrogate(seq.charAt(x++))) {
3509                     if (x &lt; length &amp;&amp; Character.isLowSurrogate(seq.charAt(x))) {
3510                         x++;
3511                     }
3512                 }
3513             }
3514             return x - index;
3515         }
3516 
3517         assert (index &gt;= 0 &amp;&amp; index &lt;= length);
3518         if (index == 0) {
3519             return 0;
3520         }
3521         int len = -lengthInCodePoints;
3522         for (int i = 0; x &gt; 0 &amp;&amp; i &lt; len; i++) {
3523             if (Character.isLowSurrogate(seq.charAt(--x))) {
3524                 if (x &gt; 0 &amp;&amp; Character.isHighSurrogate(seq.charAt(x-1))) {
3525                     x--;
3526                 }
3527             }
3528         }
3529         return index - x;
3530     }
3531 
3532     private static final int countCodePoints(CharSequence seq) {
3533         int length = seq.length();
3534         int n = 0;
3535         for (int i = 0; i &lt; length; ) {
3536             n++;
3537             if (Character.isHighSurrogate(seq.charAt(i++))) {
3538                 if (i &lt; length &amp;&amp; Character.isLowSurrogate(seq.charAt(i))) {
3539                     i++;
3540                 }
3541             }
3542         }
3543         return n;
3544     }
3545 
3546     /**
3547      *  Creates a bit vector for matching Latin-1 values. A normal BitClass
3548      *  never matches values above Latin-1, and a complemented BitClass always
3549      *  matches values above Latin-1.
3550      */
3551     static final class BitClass implements BmpCharPredicate {
3552         final boolean[] bits;
3553         BitClass() {
3554             bits = new boolean[256];
3555         }
3556         BitClass add(int c, int flags) {
3557             assert c &gt;= 0 &amp;&amp; c &lt;= 255;
3558             if ((flags &amp; CASE_INSENSITIVE) != 0) {
3559                 if (ASCII.isAscii(c)) {
3560                     bits[ASCII.toUpper(c)] = true;
3561                     bits[ASCII.toLower(c)] = true;
3562                 } else if ((flags &amp; UNICODE_CASE) != 0) {
3563                     bits[Character.toLowerCase(c)] = true;
3564                     bits[Character.toUpperCase(c)] = true;
3565                 }
3566             }
3567             bits[c] = true;
3568             return this;
3569         }
3570         public boolean is(int ch) {
3571             return ch &lt; 256 &amp;&amp; bits[ch];
3572         }
3573     }
3574 
3575 
3576     /**
3577      *  Utility method for creating a string slice matcher.
3578      */
3579     private Node newSlice(int[] buf, int count, boolean hasSupplementary) {
3580         int[] tmp = new int[count];
3581         if (has(CASE_INSENSITIVE)) {
3582             if (has(UNICODE_CASE)) {
3583                 for (int i = 0; i &lt; count; i++) {
3584                     tmp[i] = Character.toLowerCase(
3585                                  Character.toUpperCase(buf[i]));
3586                 }
3587                 return hasSupplementary? new SliceUS(tmp) : new SliceU(tmp);
3588             }
3589             for (int i = 0; i &lt; count; i++) {
3590                 tmp[i] = ASCII.toLower(buf[i]);
3591             }
3592             return hasSupplementary? new SliceIS(tmp) : new SliceI(tmp);
3593         }
3594         for (int i = 0; i &lt; count; i++) {
3595             tmp[i] = buf[i];
3596         }
3597         return hasSupplementary ? new SliceS(tmp) : new Slice(tmp);
3598     }
3599 
3600     /**
3601      * The following classes are the building components of the object
3602      * tree that represents a compiled regular expression. The object tree
3603      * is made of individual elements that handle constructs in the Pattern.
3604      * Each type of object knows how to match its equivalent construct with
3605      * the match() method.
3606      */
3607 
3608     /**
3609      * Base class for all node classes. Subclasses should override the match()
3610      * method as appropriate. This class is an accepting node, so its match()
3611      * always returns true.
3612      */
3613     static class Node extends Object {
3614         Node next;
3615         Node() {
3616             next = Pattern.accept;
3617         }
3618         /**
3619          * This method implements the classic accept node.
3620          */
3621         boolean match(Matcher matcher, int i, CharSequence seq) {
3622             matcher.last = i;
3623             matcher.groups[0] = matcher.first;
3624             matcher.groups[1] = matcher.last;
3625             return true;
3626         }
3627         /**
3628          * This method is good for all zero length assertions.
3629          */
3630         boolean study(TreeInfo info) {
3631             if (next != null) {
3632                 return next.study(info);
3633             } else {
3634                 return info.deterministic;
3635             }
3636         }
3637     }
3638 
3639     static class LastNode extends Node {
3640         /**
3641          * This method implements the classic accept node with
3642          * the addition of a check to see if the match occurred
3643          * using all of the input.
3644          */
3645         boolean match(Matcher matcher, int i, CharSequence seq) {
3646             if (matcher.acceptMode == Matcher.ENDANCHOR &amp;&amp; i != matcher.to)
3647                 return false;
3648             matcher.last = i;
3649             matcher.groups[0] = matcher.first;
3650             matcher.groups[1] = matcher.last;
3651             return true;
3652         }
3653     }
3654 
3655     /**
3656      * Used for REs that can start anywhere within the input string.
3657      * This basically tries to match repeatedly at each spot in the
3658      * input string, moving forward after each try. An anchored search
3659      * or a BnM will bypass this node completely.
3660      */
3661     static class Start extends Node {
3662         int minLength;
3663         Start(Node node) {
3664             this.next = node;
3665             TreeInfo info = new TreeInfo();
3666             next.study(info);
3667             minLength = info.minLength;
3668         }
3669         boolean match(Matcher matcher, int i, CharSequence seq) {
3670             if (i &gt; matcher.to - minLength) {
3671                 matcher.hitEnd = true;
3672                 return false;
3673             }
3674             int guard = matcher.to - minLength;
3675             for (; i &lt;= guard; i++) {
3676                 if (next.match(matcher, i, seq)) {
3677                     matcher.first = i;
3678                     matcher.groups[0] = matcher.first;
3679                     matcher.groups[1] = matcher.last;
3680                     return true;
3681                 }
3682             }
3683             matcher.hitEnd = true;
3684             return false;
3685         }
3686         boolean study(TreeInfo info) {
3687             next.study(info);
3688             info.maxValid = false;
3689             info.deterministic = false;
3690             return false;
3691         }
3692     }
3693 
3694     /*
3695      * StartS supports supplementary characters, including unpaired surrogates.
3696      */
3697     static final class StartS extends Start {
3698         StartS(Node node) {
3699             super(node);
3700         }
3701         boolean match(Matcher matcher, int i, CharSequence seq) {
3702             if (i &gt; matcher.to - minLength) {
3703                 matcher.hitEnd = true;
3704                 return false;
3705             }
3706             int guard = matcher.to - minLength;
3707             while (i &lt;= guard) {
3708                 //if ((ret = next.match(matcher, i, seq)) || i == guard)
3709                 if (next.match(matcher, i, seq)) {
3710                     matcher.first = i;
3711                     matcher.groups[0] = matcher.first;
3712                     matcher.groups[1] = matcher.last;
3713                     return true;
3714                 }
3715                 if (i == guard)
3716                     break;
3717                 // Optimization to move to the next character. This is
3718                 // faster than countChars(seq, i, 1).
3719                 if (Character.isHighSurrogate(seq.charAt(i++))) {
3720                     if (i &lt; seq.length() &amp;&amp;
3721                         Character.isLowSurrogate(seq.charAt(i))) {
3722                         i++;
3723                     }
3724                 }
3725             }
3726             matcher.hitEnd = true;
3727             return false;
3728         }
3729     }
3730 
3731     /**
3732      * Node to anchor at the beginning of input. This object implements the
3733      * match for a \A sequence, and the caret anchor will use this if not in
3734      * multiline mode.
3735      */
3736     static final class Begin extends Node {
3737         boolean match(Matcher matcher, int i, CharSequence seq) {
3738             int fromIndex = (matcher.anchoringBounds) ?
3739                 matcher.from : 0;
3740             if (i == fromIndex &amp;&amp; next.match(matcher, i, seq)) {
3741                 matcher.first = i;
3742                 matcher.groups[0] = i;
3743                 matcher.groups[1] = matcher.last;
3744                 return true;
3745             } else {
3746                 return false;
3747             }
3748         }
3749     }
3750 
3751     /**
3752      * Node to anchor at the end of input. This is the absolute end, so this
3753      * should not match at the last newline before the end as $ will.
3754      */
3755     static final class End extends Node {
3756         boolean match(Matcher matcher, int i, CharSequence seq) {
3757             int endIndex = (matcher.anchoringBounds) ?
3758                 matcher.to : matcher.getTextLength();
3759             if (i == endIndex) {
3760                 matcher.hitEnd = true;
3761                 return next.match(matcher, i, seq);
3762             }
3763             return false;
3764         }
3765     }
3766 
3767     /**
3768      * Node to anchor at the beginning of a line. This is essentially the
3769      * object to match for the multiline ^.
3770      */
3771     static final class Caret extends Node {
3772         boolean match(Matcher matcher, int i, CharSequence seq) {
3773             int startIndex = matcher.from;
3774             int endIndex = matcher.to;
3775             if (!matcher.anchoringBounds) {
3776                 startIndex = 0;
3777                 endIndex = matcher.getTextLength();
3778             }
3779             // Perl does not match ^ at end of input even after newline
3780             if (i == endIndex) {
3781                 matcher.hitEnd = true;
3782                 return false;
3783             }
3784             if (i &gt; startIndex) {
3785                 char ch = seq.charAt(i-1);
3786                 if (ch != &#39;\n&#39; &amp;&amp; ch != &#39;\r&#39;
3787                     &amp;&amp; (ch|1) != &#39;\u2029&#39;
3788                     &amp;&amp; ch != &#39;\u0085&#39; ) {
3789                     return false;
3790                 }
3791                 // Should treat /r/n as one newline
3792                 if (ch == &#39;\r&#39; &amp;&amp; seq.charAt(i) == &#39;\n&#39;)
3793                     return false;
3794             }
3795             return next.match(matcher, i, seq);
3796         }
3797     }
3798 
3799     /**
3800      * Node to anchor at the beginning of a line when in unixdot mode.
3801      */
3802     static final class UnixCaret extends Node {
3803         boolean match(Matcher matcher, int i, CharSequence seq) {
3804             int startIndex = matcher.from;
3805             int endIndex = matcher.to;
3806             if (!matcher.anchoringBounds) {
3807                 startIndex = 0;
3808                 endIndex = matcher.getTextLength();
3809             }
3810             // Perl does not match ^ at end of input even after newline
3811             if (i == endIndex) {
3812                 matcher.hitEnd = true;
3813                 return false;
3814             }
3815             if (i &gt; startIndex) {
3816                 char ch = seq.charAt(i-1);
3817                 if (ch != &#39;\n&#39;) {
3818                     return false;
3819                 }
3820             }
3821             return next.match(matcher, i, seq);
3822         }
3823     }
3824 
3825     /**
3826      * Node to match the location where the last match ended.
3827      * This is used for the \G construct.
3828      */
3829     static final class LastMatch extends Node {
3830         boolean match(Matcher matcher, int i, CharSequence seq) {
3831             if (i != matcher.oldLast)
3832                 return false;
3833             return next.match(matcher, i, seq);
3834         }
3835     }
3836 
3837     /**
3838      * Node to anchor at the end of a line or the end of input based on the
3839      * multiline mode.
3840      *
3841      * When not in multiline mode, the $ can only match at the very end
3842      * of the input, unless the input ends in a line terminator in which
3843      * it matches right before the last line terminator.
3844      *
3845      * Note that \r\n is considered an atomic line terminator.
3846      *
3847      * Like ^ the $ operator matches at a position, it does not match the
3848      * line terminators themselves.
3849      */
3850     static final class Dollar extends Node {
3851         boolean multiline;
3852         Dollar(boolean mul) {
3853             multiline = mul;
3854         }
3855         boolean match(Matcher matcher, int i, CharSequence seq) {
3856             int endIndex = (matcher.anchoringBounds) ?
3857                 matcher.to : matcher.getTextLength();
3858             if (!multiline) {
3859                 if (i &lt; endIndex - 2)
3860                     return false;
3861                 if (i == endIndex - 2) {
3862                     char ch = seq.charAt(i);
3863                     if (ch != &#39;\r&#39;)
3864                         return false;
3865                     ch = seq.charAt(i + 1);
3866                     if (ch != &#39;\n&#39;)
3867                         return false;
3868                 }
3869             }
3870             // Matches before any line terminator; also matches at the
3871             // end of input
3872             // Before line terminator:
3873             // If multiline, we match here no matter what
3874             // If not multiline, fall through so that the end
3875             // is marked as hit; this must be a /r/n or a /n
3876             // at the very end so the end was hit; more input
3877             // could make this not match here
3878             if (i &lt; endIndex) {
3879                 char ch = seq.charAt(i);
3880                  if (ch == &#39;\n&#39;) {
3881                      // No match between \r\n
3882                      if (i &gt; 0 &amp;&amp; seq.charAt(i-1) == &#39;\r&#39;)
3883                          return false;
3884                      if (multiline)
3885                          return next.match(matcher, i, seq);
3886                  } else if (ch == &#39;\r&#39; || ch == &#39;\u0085&#39; ||
3887                             (ch|1) == &#39;\u2029&#39;) {
3888                      if (multiline)
3889                          return next.match(matcher, i, seq);
3890                  } else { // No line terminator, no match
3891                      return false;
3892                  }
3893             }
3894             // Matched at current end so hit end
3895             matcher.hitEnd = true;
3896             // If a $ matches because of end of input, then more input
3897             // could cause it to fail!
3898             matcher.requireEnd = true;
3899             return next.match(matcher, i, seq);
3900         }
3901         boolean study(TreeInfo info) {
3902             next.study(info);
3903             return info.deterministic;
3904         }
3905     }
3906 
3907     /**
3908      * Node to anchor at the end of a line or the end of input based on the
3909      * multiline mode when in unix lines mode.
3910      */
3911     static final class UnixDollar extends Node {
3912         boolean multiline;
3913         UnixDollar(boolean mul) {
3914             multiline = mul;
3915         }
3916         boolean match(Matcher matcher, int i, CharSequence seq) {
3917             int endIndex = (matcher.anchoringBounds) ?
3918                 matcher.to : matcher.getTextLength();
3919             if (i &lt; endIndex) {
3920                 char ch = seq.charAt(i);
3921                 if (ch == &#39;\n&#39;) {
3922                     // If not multiline, then only possible to
3923                     // match at very end or one before end
3924                     if (multiline == false &amp;&amp; i != endIndex - 1)
3925                         return false;
3926                     // If multiline return next.match without setting
3927                     // matcher.hitEnd
3928                     if (multiline)
3929                         return next.match(matcher, i, seq);
3930                 } else {
3931                     return false;
3932                 }
3933             }
3934             // Matching because at the end or 1 before the end;
3935             // more input could change this so set hitEnd
3936             matcher.hitEnd = true;
3937             // If a $ matches because of end of input, then more input
3938             // could cause it to fail!
3939             matcher.requireEnd = true;
3940             return next.match(matcher, i, seq);
3941         }
3942         boolean study(TreeInfo info) {
3943             next.study(info);
3944             return info.deterministic;
3945         }
3946     }
3947 
3948     /**
3949      * Node class that matches a Unicode line ending &#39;\R&#39;
3950      */
3951     static final class LineEnding extends Node {
3952         boolean match(Matcher matcher, int i, CharSequence seq) {
3953             // (u+000Du+000A|[u+000Au+000Bu+000Cu+000Du+0085u+2028u+2029])
3954             if (i &lt; matcher.to) {
3955                 int ch = seq.charAt(i);
3956                 if (ch == 0x0A || ch == 0x0B || ch == 0x0C ||
3957                     ch == 0x85 || ch == 0x2028 || ch == 0x2029)
3958                     return next.match(matcher, i + 1, seq);
3959                 if (ch == 0x0D) {
3960                     i++;
3961                     if (i &lt; matcher.to) {
3962                         if (seq.charAt(i) == 0x0A &amp;&amp;
3963                             next.match(matcher, i + 1, seq)) {
3964                             return true;
3965                         }
3966                     } else {
3967                         matcher.hitEnd = true;
3968                     }
3969                     return next.match(matcher, i, seq);
3970                 }
3971             } else {
3972                 matcher.hitEnd = true;
3973             }
3974             return false;
3975         }
3976         boolean study(TreeInfo info) {
3977             info.minLength++;
3978             info.maxLength += 2;
3979             return next.study(info);
3980         }
3981     }
3982 
3983     /**
3984      * Abstract node class to match one character satisfying some
3985      * boolean property.
3986      */
3987     static class CharProperty extends Node {
3988         final CharPredicate predicate;
3989 
3990         CharProperty (CharPredicate predicate) {
3991             this.predicate = predicate;
3992         }
3993         boolean match(Matcher matcher, int i, CharSequence seq) {
3994             if (i &lt; matcher.to) {
3995                 int ch = Character.codePointAt(seq, i);
3996                 i += Character.charCount(ch);
3997                 if (i &lt;= matcher.to) {
3998                     return predicate.is(ch) &amp;&amp;
3999                            next.match(matcher, i, seq);
4000                 }
4001             }
4002             matcher.hitEnd = true;
4003             return false;
4004         }
4005         boolean study(TreeInfo info) {
4006             info.minLength++;
4007             info.maxLength++;
4008             return next.study(info);
4009         }
4010     }
4011 
4012     /**
4013      * Optimized version of CharProperty that works only for
4014      * properties never satisfied by Supplementary characters.
4015      */
4016     private static class BmpCharProperty extends CharProperty {
4017         BmpCharProperty (BmpCharPredicate predicate) {
4018             super(predicate);
4019         }
4020         boolean match(Matcher matcher, int i, CharSequence seq) {
4021             if (i &lt; matcher.to) {
4022                 return predicate.is(seq.charAt(i)) &amp;&amp;
4023                        next.match(matcher, i + 1, seq);
4024             } else {
4025                 matcher.hitEnd = true;
4026                 return false;
4027             }
4028         }
4029     }
4030 
4031     private static class NFCCharProperty extends Node {
4032         CharPredicate predicate;
4033         NFCCharProperty (CharPredicate predicate) {
4034             this.predicate = predicate;
4035         }
4036 
4037         boolean match(Matcher matcher, int i, CharSequence seq) {
4038             if (i &lt; matcher.to) {
4039                 int ch0 = Character.codePointAt(seq, i);
4040                 int n = Character.charCount(ch0);
4041                 int j = Grapheme.nextBoundary(seq, i, matcher.to);
4042                 if (i + n == j) { // single cp grapheme, assume nfc
4043                     if (predicate.is(ch0))
4044                         return next.match(matcher, j, seq);
4045                 } else {
4046                     while (i + n &lt; j) {
4047                         String nfc = Normalizer.normalize(
4048                             seq.toString().substring(i, j), Normalizer.Form.NFC);
4049                         if (nfc.codePointCount(0, nfc.length()) == 1) {
4050                             if (predicate.is(nfc.codePointAt(0)) &amp;&amp;
4051                                 next.match(matcher, j, seq)) {
4052                                 return true;
4053                             }
4054                         }
4055 
4056                         ch0 = Character.codePointBefore(seq, j);
4057                         j -= Character.charCount(ch0);
4058                     }
4059                 }
4060                 if (j &lt; matcher.to)
4061                     return false;
4062             }
4063             matcher.hitEnd = true;
4064             return false;
4065         }
4066 
4067         boolean study(TreeInfo info) {
4068             info.minLength++;
4069             info.deterministic = false;
4070             return next.study(info);
4071         }
4072     }
4073 
4074     /**
4075      * Node class that matches an unicode extended grapheme cluster
4076      */
4077     static class XGrapheme extends Node {
4078         boolean match(Matcher matcher, int i, CharSequence seq) {
4079             if (i &lt; matcher.to) {
4080                 i = Grapheme.nextBoundary(seq, i, matcher.to);
4081                 return next.match(matcher, i, seq);
4082             }
4083             matcher.hitEnd = true;
4084             return false;
4085         }
4086 
4087         boolean study(TreeInfo info) {
4088             info.minLength++;
4089             info.deterministic = false;
4090             return next.study(info);
4091         }
4092     }
4093 
4094     /**
4095      * Node class that handles grapheme boundaries
4096      */
4097     static class GraphemeBound extends Node {
4098         boolean match(Matcher matcher, int i, CharSequence seq) {
4099             int startIndex = matcher.from;
4100             int endIndex = matcher.to;
4101             if (matcher.transparentBounds) {
4102                 startIndex = 0;
4103                 endIndex = matcher.getTextLength();
4104             }
4105             if (i == startIndex) {
4106                 // continue with return below
4107             } else if (i &lt; endIndex) {
4108                 if (Character.isSurrogatePair(seq.charAt(i - 1), seq.charAt(i))) {
4109                     return false;
4110                 }
4111                 if (Grapheme.nextBoundary(seq, matcher.last, endIndex) &gt; i) {
4112                     return false;
4113                 }
4114             } else {
4115                 matcher.hitEnd = true;
4116                 matcher.requireEnd = true;
4117             }
4118             return next.match(matcher, i, seq);
4119         }
4120     }
4121 
4122     /**
4123      * Base class for all Slice nodes
4124      */
4125     static class SliceNode extends Node {
4126         int[] buffer;
4127         SliceNode(int[] buf) {
4128             buffer = buf;
4129         }
4130         boolean study(TreeInfo info) {
4131             info.minLength += buffer.length;
4132             info.maxLength += buffer.length;
4133             return next.study(info);
4134         }
4135     }
4136 
4137     /**
4138      * Node class for a case sensitive/BMP-only sequence of literal
4139      * characters.
4140      */
4141     static class Slice extends SliceNode {
4142         Slice(int[] buf) {
4143             super(buf);
4144         }
4145         boolean match(Matcher matcher, int i, CharSequence seq) {
4146             int[] buf = buffer;
4147             int len = buf.length;
4148             for (int j=0; j&lt;len; j++) {
4149                 if ((i+j) &gt;= matcher.to) {
4150                     matcher.hitEnd = true;
4151                     return false;
4152                 }
4153                 if (buf[j] != seq.charAt(i+j))
4154                     return false;
4155             }
4156             return next.match(matcher, i+len, seq);
4157         }
4158     }
4159 
4160     /**
4161      * Node class for a case_insensitive/BMP-only sequence of literal
4162      * characters.
4163      */
4164     static class SliceI extends SliceNode {
4165         SliceI(int[] buf) {
4166             super(buf);
4167         }
4168         boolean match(Matcher matcher, int i, CharSequence seq) {
4169             int[] buf = buffer;
4170             int len = buf.length;
4171             for (int j=0; j&lt;len; j++) {
4172                 if ((i+j) &gt;= matcher.to) {
4173                     matcher.hitEnd = true;
4174                     return false;
4175                 }
4176                 int c = seq.charAt(i+j);
4177                 if (buf[j] != c &amp;&amp;
4178                     buf[j] != ASCII.toLower(c))
4179                     return false;
4180             }
4181             return next.match(matcher, i+len, seq);
4182         }
4183     }
4184 
4185     /**
4186      * Node class for a unicode_case_insensitive/BMP-only sequence of
4187      * literal characters. Uses unicode case folding.
4188      */
4189     static final class SliceU extends SliceNode {
4190         SliceU(int[] buf) {
4191             super(buf);
4192         }
4193         boolean match(Matcher matcher, int i, CharSequence seq) {
4194             int[] buf = buffer;
4195             int len = buf.length;
4196             for (int j=0; j&lt;len; j++) {
4197                 if ((i+j) &gt;= matcher.to) {
4198                     matcher.hitEnd = true;
4199                     return false;
4200                 }
4201                 int c = seq.charAt(i+j);
4202                 if (buf[j] != c &amp;&amp;
4203                     buf[j] != Character.toLowerCase(Character.toUpperCase(c)))
4204                     return false;
4205             }
4206             return next.match(matcher, i+len, seq);
4207         }
4208     }
4209 
4210     /**
4211      * Node class for a case sensitive sequence of literal characters
4212      * including supplementary characters.
4213      */
4214     static final class SliceS extends Slice {
4215         SliceS(int[] buf) {
4216             super(buf);
4217         }
4218         boolean match(Matcher matcher, int i, CharSequence seq) {
4219             int[] buf = buffer;
4220             int x = i;
4221             for (int j = 0; j &lt; buf.length; j++) {
4222                 if (x &gt;= matcher.to) {
4223                     matcher.hitEnd = true;
4224                     return false;
4225                 }
4226                 int c = Character.codePointAt(seq, x);
4227                 if (buf[j] != c)
4228                     return false;
4229                 x += Character.charCount(c);
4230                 if (x &gt; matcher.to) {
4231                     matcher.hitEnd = true;
4232                     return false;
4233                 }
4234             }
4235             return next.match(matcher, x, seq);
4236         }
4237     }
4238 
4239     /**
4240      * Node class for a case insensitive sequence of literal characters
4241      * including supplementary characters.
4242      */
4243     static class SliceIS extends SliceNode {
4244         SliceIS(int[] buf) {
4245             super(buf);
4246         }
4247         int toLower(int c) {
4248             return ASCII.toLower(c);
4249         }
4250         boolean match(Matcher matcher, int i, CharSequence seq) {
4251             int[] buf = buffer;
4252             int x = i;
4253             for (int j = 0; j &lt; buf.length; j++) {
4254                 if (x &gt;= matcher.to) {
4255                     matcher.hitEnd = true;
4256                     return false;
4257                 }
4258                 int c = Character.codePointAt(seq, x);
4259                 if (buf[j] != c &amp;&amp; buf[j] != toLower(c))
4260                     return false;
4261                 x += Character.charCount(c);
4262                 if (x &gt; matcher.to) {
4263                     matcher.hitEnd = true;
4264                     return false;
4265                 }
4266             }
4267             return next.match(matcher, x, seq);
4268         }
4269     }
4270 
4271     /**
4272      * Node class for a case insensitive sequence of literal characters.
4273      * Uses unicode case folding.
4274      */
4275     static final class SliceUS extends SliceIS {
4276         SliceUS(int[] buf) {
4277             super(buf);
4278         }
4279         int toLower(int c) {
4280             return Character.toLowerCase(Character.toUpperCase(c));
4281         }
4282     }
4283 
4284     /**
4285      * The 0 or 1 quantifier. This one class implements all three types.
4286      */
4287     static final class Ques extends Node {
4288         Node atom;
4289         Qtype type;
4290         Ques(Node node, Qtype type) {
4291             this.atom = node;
4292             this.type = type;
4293         }
4294         boolean match(Matcher matcher, int i, CharSequence seq) {
4295             switch (type) {
4296             case GREEDY:
4297                 return (atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq))
4298                     || next.match(matcher, i, seq);
4299             case LAZY:
4300                 return next.match(matcher, i, seq)
4301                     || (atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq));
4302             case POSSESSIVE:
4303                 if (atom.match(matcher, i, seq)) i = matcher.last;
4304                 return next.match(matcher, i, seq);
4305             default:
4306                 return atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq);
4307             }
4308         }
4309         boolean study(TreeInfo info) {
4310             if (type != Qtype.INDEPENDENT) {
4311                 int minL = info.minLength;
4312                 atom.study(info);
4313                 info.minLength = minL;
4314                 info.deterministic = false;
4315                 return next.study(info);
4316             } else {
4317                 atom.study(info);
4318                 return next.study(info);
4319             }
4320         }
4321     }
4322 
4323     /**
4324      * Handles the greedy style repetition with the specified minimum
4325      * and the maximum equal to MAX_REPS, for *, + and {N,} quantifiers.
4326      */
4327     static class CharPropertyGreedy extends Node {
4328         final CharPredicate predicate;
4329         final int cmin;
4330 
4331         CharPropertyGreedy(CharProperty cp, int cmin) {
4332             this.predicate = cp.predicate;
4333             this.cmin = cmin;
4334         }
4335         boolean match(Matcher matcher, int i, CharSequence seq) {
4336             int starti = i;
4337             int n = 0;
4338             int to = matcher.to;
4339             // greedy, all the way down
4340             while (i &lt; to) {
4341                 int ch = Character.codePointAt(seq, i);
4342                 int len = Character.charCount(ch);
4343                 if (i + len &gt; to) {
4344                     // the region cut off the high half of a surrogate pair
4345                     matcher.hitEnd = true;
4346                     ch = seq.charAt(i);
4347                     len = 1;
4348                 }
4349                 if (!predicate.is(ch))
4350                     break;
4351                 i += len;
4352                 n++;
4353             }
4354             if (i &gt;= to) {
4355                 matcher.hitEnd = true;
4356             }
4357             while (n &gt;= cmin) {
4358                 if (next.match(matcher, i, seq))
4359                     return true;
4360                 if (n == cmin)
4361                     return false;
4362                 // backing off if match fails
4363                 int ch = Character.codePointBefore(seq, i);
4364                 // check if the region cut off the low half of a surrogate pair
4365                 i = Math.max(starti, i - Character.charCount(ch));
4366                 n--;
4367             }
4368             return false;
4369         }
4370 
4371         boolean study(TreeInfo info) {
4372             info.minLength += cmin;
4373             if (info.maxValid) {
4374                 info.maxLength += MAX_REPS;
4375             }
4376             info.deterministic = false;
4377             return next.study(info);
4378         }
4379     }
4380 
4381     static final class BmpCharPropertyGreedy extends CharPropertyGreedy {
4382 
4383         BmpCharPropertyGreedy(BmpCharProperty bcp, int cmin) {
4384             super(bcp, cmin);
4385         }
4386 
4387         boolean match(Matcher matcher, int i, CharSequence seq) {
4388             int n = 0;
4389             int to = matcher.to;
4390             while (i &lt; to &amp;&amp; predicate.is(seq.charAt(i))) {
4391                 i++; n++;
4392             }
4393             if (i &gt;= to) {
4394                 matcher.hitEnd = true;
4395             }
4396             while (n &gt;= cmin) {
4397                 if (next.match(matcher, i, seq))
4398                     return true;
4399                 i--; n--;  // backing off if match fails
4400             }
4401             return false;
4402         }
4403     }
4404 
4405     /**
4406      * Handles the curly-brace style repetition with a specified minimum and
4407      * maximum occurrences. The * quantifier is handled as a special case.
4408      * This class handles the three types.
4409      */
4410     static final class Curly extends Node {
4411         Node atom;
4412         Qtype type;
4413         int cmin;
4414         int cmax;
4415 
4416         Curly(Node node, int cmin, int cmax, Qtype type) {
4417             this.atom = node;
4418             this.type = type;
4419             this.cmin = cmin;
4420             this.cmax = cmax;
4421         }
4422         boolean match(Matcher matcher, int i, CharSequence seq) {
4423             int j;
4424             for (j = 0; j &lt; cmin; j++) {
4425                 if (atom.match(matcher, i, seq)) {
4426                     i = matcher.last;
4427                     continue;
4428                 }
4429                 return false;
4430             }
4431             if (type == Qtype.GREEDY)
4432                 return match0(matcher, i, j, seq);
4433             else if (type == Qtype.LAZY)
4434                 return match1(matcher, i, j, seq);
4435             else
4436                 return match2(matcher, i, j, seq);
4437         }
4438         // Greedy match.
4439         // i is the index to start matching at
4440         // j is the number of atoms that have matched
4441         boolean match0(Matcher matcher, int i, int j, CharSequence seq) {
4442             if (j &gt;= cmax) {
4443                 // We have matched the maximum... continue with the rest of
4444                 // the regular expression
4445                 return next.match(matcher, i, seq);
4446             }
4447             int backLimit = j;
4448             while (atom.match(matcher, i, seq)) {
4449                 // k is the length of this match
4450                 int k = matcher.last - i;
4451                 if (k == 0) // Zero length match
4452                     break;
4453                 // Move up index and number matched
4454                 i = matcher.last;
4455                 j++;
4456                 // We are greedy so match as many as we can
4457                 while (j &lt; cmax) {
4458                     if (!atom.match(matcher, i, seq))
4459                         break;
4460                     if (i + k != matcher.last) {
4461                         if (match0(matcher, matcher.last, j+1, seq))
4462                             return true;
4463                         break;
4464                     }
4465                     i += k;
4466                     j++;
4467                 }
4468                 // Handle backing off if match fails
4469                 while (j &gt;= backLimit) {
4470                    if (next.match(matcher, i, seq))
4471                         return true;
4472                     i -= k;
4473                     j--;
4474                 }
4475                 return false;
4476             }
4477             return next.match(matcher, i, seq);
4478         }
4479         // Reluctant match. At this point, the minimum has been satisfied.
4480         // i is the index to start matching at
4481         // j is the number of atoms that have matched
4482         boolean match1(Matcher matcher, int i, int j, CharSequence seq) {
4483             for (;;) {
4484                 // Try finishing match without consuming any more
4485                 if (next.match(matcher, i, seq))
4486                     return true;
4487                 // At the maximum, no match found
4488                 if (j &gt;= cmax)
4489                     return false;
4490                 // Okay, must try one more atom
4491                 if (!atom.match(matcher, i, seq))
4492                     return false;
4493                 // If we haven&#39;t moved forward then must break out
4494                 if (i == matcher.last)
4495                     return false;
4496                 // Move up index and number matched
4497                 i = matcher.last;
4498                 j++;
4499             }
4500         }
4501         boolean match2(Matcher matcher, int i, int j, CharSequence seq) {
4502             for (; j &lt; cmax; j++) {
4503                 if (!atom.match(matcher, i, seq))
4504                     break;
4505                 if (i == matcher.last)
4506                     break;
4507                 i = matcher.last;
4508             }
4509             return next.match(matcher, i, seq);
4510         }
4511         boolean study(TreeInfo info) {
4512             // Save original info
4513             int minL = info.minLength;
4514             int maxL = info.maxLength;
4515             boolean maxV = info.maxValid;
4516             boolean detm = info.deterministic;
4517             info.reset();
4518 
4519             atom.study(info);
4520 
4521             int temp = info.minLength * cmin + minL;
4522             if (temp &lt; minL) {
4523                 temp = 0xFFFFFFF; // arbitrary large number
4524             }
4525             info.minLength = temp;
4526 
4527             if (maxV &amp; info.maxValid) {
4528                 temp = info.maxLength * cmax + maxL;
4529                 info.maxLength = temp;
4530                 if (temp &lt; maxL) {
4531                     info.maxValid = false;
4532                 }
4533             } else {
4534                 info.maxValid = false;
4535             }
4536 
4537             if (info.deterministic &amp;&amp; cmin == cmax)
4538                 info.deterministic = detm;
4539             else
4540                 info.deterministic = false;
4541             return next.study(info);
4542         }
4543     }
4544 
4545     /**
4546      * Handles the curly-brace style repetition with a specified minimum and
4547      * maximum occurrences in deterministic cases. This is an iterative
4548      * optimization over the Prolog and Loop system which would handle this
4549      * in a recursive way. The * quantifier is handled as a special case.
4550      * If capture is true then this class saves group settings and ensures
4551      * that groups are unset when backing off of a group match.
4552      */
4553     static final class GroupCurly extends Node {
4554         Node atom;
4555         Qtype type;
4556         int cmin;
4557         int cmax;
4558         int localIndex;
4559         int groupIndex;
4560         boolean capture;
4561 
4562         GroupCurly(Node node, int cmin, int cmax, Qtype type, int local,
4563                    int group, boolean capture) {
4564             this.atom = node;
4565             this.type = type;
4566             this.cmin = cmin;
4567             this.cmax = cmax;
4568             this.localIndex = local;
4569             this.groupIndex = group;
4570             this.capture = capture;
4571         }
4572         boolean match(Matcher matcher, int i, CharSequence seq) {
4573             int[] groups = matcher.groups;
4574             int[] locals = matcher.locals;
4575             int save0 = locals[localIndex];
4576             int save1 = 0;
4577             int save2 = 0;
4578 
4579             if (capture) {
4580                 save1 = groups[groupIndex];
4581                 save2 = groups[groupIndex+1];
4582             }
4583 
4584             // Notify GroupTail there is no need to setup group info
4585             // because it will be set here
4586             locals[localIndex] = -1;
4587 
4588             boolean ret = true;
4589             for (int j = 0; j &lt; cmin; j++) {
4590                 if (atom.match(matcher, i, seq)) {
4591                     if (capture) {
4592                         groups[groupIndex] = i;
4593                         groups[groupIndex+1] = matcher.last;
4594                     }
4595                     i = matcher.last;
4596                 } else {
4597                     ret = false;
4598                     break;
4599                 }
4600             }
4601             if (ret) {
4602                 if (type == Qtype.GREEDY) {
4603                     ret = match0(matcher, i, cmin, seq);
4604                 } else if (type == Qtype.LAZY) {
4605                     ret = match1(matcher, i, cmin, seq);
4606                 } else {
4607                     ret = match2(matcher, i, cmin, seq);
4608                 }
4609             }
4610             if (!ret) {
4611                 locals[localIndex] = save0;
4612                 if (capture) {
4613                     groups[groupIndex] = save1;
4614                     groups[groupIndex+1] = save2;
4615                 }
4616             }
4617             return ret;
4618         }
4619         // Aggressive group match
4620         boolean match0(Matcher matcher, int i, int j, CharSequence seq) {
4621             // don&#39;t back off passing the starting &quot;j&quot;
4622             int min = j;
4623             int[] groups = matcher.groups;
4624             int save0 = 0;
4625             int save1 = 0;
4626             if (capture) {
4627                 save0 = groups[groupIndex];
4628                 save1 = groups[groupIndex+1];
4629             }
4630             for (;;) {
4631                 if (j &gt;= cmax)
4632                     break;
4633                 if (!atom.match(matcher, i, seq))
4634                     break;
4635                 int k = matcher.last - i;
4636                 if (k &lt;= 0) {
4637                     if (capture) {
4638                         groups[groupIndex] = i;
4639                         groups[groupIndex+1] = i + k;
4640                     }
4641                     i = i + k;
4642                     break;
4643                 }
4644                 for (;;) {
4645                     if (capture) {
4646                         groups[groupIndex] = i;
4647                         groups[groupIndex+1] = i + k;
4648                     }
4649                     i = i + k;
4650                     if (++j &gt;= cmax)
4651                         break;
4652                     if (!atom.match(matcher, i, seq))
4653                         break;
4654                     if (i + k != matcher.last) {
4655                         if (match0(matcher, i, j, seq))
4656                             return true;
4657                         break;
4658                     }
4659                 }
4660                 while (j &gt; min) {
4661                     if (next.match(matcher, i, seq)) {
4662                         if (capture) {
4663                             groups[groupIndex+1] = i;
4664                             groups[groupIndex] = i - k;
4665                         }
4666                         return true;
4667                     }
4668                     // backing off
4669                     i = i - k;
4670                     if (capture) {
4671                         groups[groupIndex+1] = i;
4672                         groups[groupIndex] = i - k;
4673                     }
4674                     j--;
4675 
4676                 }
4677                 break;
4678             }
4679             if (capture) {
4680                 groups[groupIndex] = save0;
4681                 groups[groupIndex+1] = save1;
4682             }
4683             return next.match(matcher, i, seq);
4684         }
4685         // Reluctant matching
4686         boolean match1(Matcher matcher, int i, int j, CharSequence seq) {
4687             for (;;) {
4688                 if (next.match(matcher, i, seq))
4689                     return true;
4690                 if (j &gt;= cmax)
4691                     return false;
4692                 if (!atom.match(matcher, i, seq))
4693                     return false;
4694                 if (i == matcher.last)
4695                     return false;
4696                 if (capture) {
4697                     matcher.groups[groupIndex] = i;
4698                     matcher.groups[groupIndex+1] = matcher.last;
4699                 }
4700                 i = matcher.last;
4701                 j++;
4702             }
4703         }
4704         // Possessive matching
4705         boolean match2(Matcher matcher, int i, int j, CharSequence seq) {
4706             for (; j &lt; cmax; j++) {
4707                 if (!atom.match(matcher, i, seq)) {
4708                     break;
4709                 }
4710                 if (capture) {
4711                     matcher.groups[groupIndex] = i;
4712                     matcher.groups[groupIndex+1] = matcher.last;
4713                 }
4714                 if (i == matcher.last) {
4715                     break;
4716                 }
4717                 i = matcher.last;
4718             }
4719             return next.match(matcher, i, seq);
4720         }
4721         boolean study(TreeInfo info) {
4722             // Save original info
4723             int minL = info.minLength;
4724             int maxL = info.maxLength;
4725             boolean maxV = info.maxValid;
4726             boolean detm = info.deterministic;
4727             info.reset();
4728 
4729             atom.study(info);
4730 
4731             int temp = info.minLength * cmin + minL;
4732             if (temp &lt; minL) {
4733                 temp = 0xFFFFFFF; // Arbitrary large number
4734             }
4735             info.minLength = temp;
4736 
4737             if (maxV &amp; info.maxValid) {
4738                 temp = info.maxLength * cmax + maxL;
4739                 info.maxLength = temp;
4740                 if (temp &lt; maxL) {
4741                     info.maxValid = false;
4742                 }
4743             } else {
4744                 info.maxValid = false;
4745             }
4746 
4747             if (info.deterministic &amp;&amp; cmin == cmax) {
4748                 info.deterministic = detm;
4749             } else {
4750                 info.deterministic = false;
4751             }
4752             return next.study(info);
4753         }
4754     }
4755 
4756     /**
4757      * A Guard node at the end of each atom node in a Branch. It
4758      * serves the purpose of chaining the &quot;match&quot; operation to
4759      * &quot;next&quot; but not the &quot;study&quot;, so we can collect the TreeInfo
4760      * of each atom node without including the TreeInfo of the
4761      * &quot;next&quot;.
4762      */
4763     static final class BranchConn extends Node {
4764         BranchConn() {}
4765         boolean match(Matcher matcher, int i, CharSequence seq) {
4766             return next.match(matcher, i, seq);
4767         }
4768         boolean study(TreeInfo info) {
4769             return info.deterministic;
4770         }
4771     }
4772 
4773     /**
4774      * Handles the branching of alternations. Note this is also used for
4775      * the ? quantifier to branch between the case where it matches once
4776      * and where it does not occur.
4777      */
4778     static final class Branch extends Node {
4779         Node[] atoms = new Node[2];
4780         int size = 2;
4781         BranchConn conn;
4782         Branch(Node first, Node second, BranchConn branchConn) {
4783             conn = branchConn;
4784             atoms[0] = first;
4785             atoms[1] = second;
4786         }
4787 
4788         void add(Node node) {
4789             if (size &gt;= atoms.length) {
4790                 int len = ArraysSupport.newLength(size,
4791                         1,    /* minimum growth */
4792                         size  /* preferred growth */);
4793                 atoms = Arrays.copyOf(atoms, len);
4794             }
4795             atoms[size++] = node;
4796         }
4797 
4798         boolean match(Matcher matcher, int i, CharSequence seq) {
4799             for (int n = 0; n &lt; size; n++) {
4800                 if (atoms[n] == null) {
4801                     if (conn.next.match(matcher, i, seq))
4802                         return true;
4803                 } else if (atoms[n].match(matcher, i, seq)) {
4804                     return true;
4805                 }
4806             }
4807             return false;
4808         }
4809 
4810         boolean study(TreeInfo info) {
4811             int minL = info.minLength;
4812             int maxL = info.maxLength;
4813             boolean maxV = info.maxValid;
4814 
4815             int minL2 = Integer.MAX_VALUE; //arbitrary large enough num
4816             int maxL2 = -1;
4817             for (int n = 0; n &lt; size; n++) {
4818                 info.reset();
4819                 if (atoms[n] != null)
4820                     atoms[n].study(info);
4821                 minL2 = Math.min(minL2, info.minLength);
4822                 maxL2 = Math.max(maxL2, info.maxLength);
4823                 maxV = (maxV &amp; info.maxValid);
4824             }
4825 
4826             minL += minL2;
4827             maxL += maxL2;
4828 
4829             info.reset();
4830             conn.next.study(info);
4831 
4832             info.minLength += minL;
4833             info.maxLength += maxL;
4834             info.maxValid &amp;= maxV;
4835             info.deterministic = false;
4836             return false;
4837         }
4838     }
4839 
4840     /**
4841      * The GroupHead saves the location where the group begins in the locals
4842      * and restores them when the match is done.
4843      *
4844      * The matchRef is used when a reference to this group is accessed later
4845      * in the expression. The locals will have a negative value in them to
4846      * indicate that we do not want to unset the group if the reference
4847      * doesn&#39;t match.
4848      */
4849     static final class GroupHead extends Node {
4850         int localIndex;
4851         GroupTail tail;    // for debug/print only, match does not need to know
4852         GroupHead(int localCount) {
4853             localIndex = localCount;
4854         }
4855         boolean match(Matcher matcher, int i, CharSequence seq) {
4856             int save = matcher.locals[localIndex];
4857             matcher.locals[localIndex] = i;
4858             boolean ret = next.match(matcher, i, seq);
4859             matcher.locals[localIndex] = save;
4860             return ret;
4861         }
4862     }
4863 
4864     /**
4865      * The GroupTail handles the setting of group beginning and ending
4866      * locations when groups are successfully matched. It must also be able to
4867      * unset groups that have to be backed off of.
4868      *
4869      * The GroupTail node is also used when a previous group is referenced,
4870      * and in that case no group information needs to be set.
4871      */
4872     static final class GroupTail extends Node {
4873         int localIndex;
4874         int groupIndex;
4875         GroupTail(int localCount, int groupCount) {
4876             localIndex = localCount;
4877             groupIndex = groupCount + groupCount;
4878         }
4879         boolean match(Matcher matcher, int i, CharSequence seq) {
4880             int tmp = matcher.locals[localIndex];
4881             if (tmp &gt;= 0) { // This is the normal group case.
4882                 // Save the group so we can unset it if it
4883                 // backs off of a match.
4884                 int groupStart = matcher.groups[groupIndex];
4885                 int groupEnd = matcher.groups[groupIndex+1];
4886 
4887                 matcher.groups[groupIndex] = tmp;
4888                 matcher.groups[groupIndex+1] = i;
4889                 if (next.match(matcher, i, seq)) {
4890                     return true;
4891                 }
4892                 matcher.groups[groupIndex] = groupStart;
4893                 matcher.groups[groupIndex+1] = groupEnd;
4894                 return false;
4895             } else {
4896                 // This is a group reference case. We don&#39;t need to save any
4897                 // group info because it isn&#39;t really a group.
4898                 matcher.last = i;
4899                 return true;
4900             }
4901         }
4902     }
4903 
4904     /**
4905      * This sets up a loop to handle a recursive quantifier structure.
4906      */
4907     static final class Prolog extends Node {
4908         Loop loop;
4909         Prolog(Loop loop) {
4910             this.loop = loop;
4911         }
4912         boolean match(Matcher matcher, int i, CharSequence seq) {
4913             return loop.matchInit(matcher, i, seq);
4914         }
4915         boolean study(TreeInfo info) {
4916             return loop.study(info);
4917         }
4918     }
4919 
4920     /**
4921      * Handles the repetition count for a greedy Curly. The matchInit
4922      * is called from the Prolog to save the index of where the group
4923      * beginning is stored. A zero length group check occurs in the
4924      * normal match but is skipped in the matchInit.
4925      */
4926     static class Loop extends Node {
4927         Node body;
4928         int countIndex; // local count index in matcher locals
4929         int beginIndex; // group beginning index
4930         int cmin, cmax;
4931         int posIndex;
4932         Loop(int countIndex, int beginIndex) {
4933             this.countIndex = countIndex;
4934             this.beginIndex = beginIndex;
4935             this.posIndex = -1;
4936         }
4937         boolean match(Matcher matcher, int i, CharSequence seq) {
4938             // Avoid infinite loop in zero-length case.
4939             if (i &gt; matcher.locals[beginIndex]) {
4940                 int count = matcher.locals[countIndex];
4941 
4942                 // This block is for before we reach the minimum
4943                 // iterations required for the loop to match
4944                 if (count &lt; cmin) {
4945                     matcher.locals[countIndex] = count + 1;
4946                     boolean b = body.match(matcher, i, seq);
4947                     // If match failed we must backtrack, so
4948                     // the loop count should NOT be incremented
4949                     if (!b)
4950                         matcher.locals[countIndex] = count;
4951                     // Return success or failure since we are under
4952                     // minimum
4953                     return b;
4954                 }
4955                 // This block is for after we have the minimum
4956                 // iterations required for the loop to match
4957                 if (count &lt; cmax) {
4958                     // Let&#39;s check if we have already tried and failed
4959                     // at this starting position &quot;i&quot; in the past.
4960                     // If yes, then just return false wihtout trying
4961                     // again, to stop the exponential backtracking.
4962                     if (posIndex != -1 &amp;&amp;
4963                         matcher.localsPos[posIndex].contains(i)) {
4964                         return next.match(matcher, i, seq);
4965                     }
4966                     matcher.locals[countIndex] = count + 1;
4967                     boolean b = body.match(matcher, i, seq);
4968                     // If match failed we must backtrack, so
4969                     // the loop count should NOT be incremented
4970                     if (b)
4971                         return true;
4972                     matcher.locals[countIndex] = count;
4973                     // save the failed position
4974                     if (posIndex != -1) {
4975                         matcher.localsPos[posIndex].add(i);
4976                     }
4977                 }
4978             }
4979             return next.match(matcher, i, seq);
4980         }
4981         boolean matchInit(Matcher matcher, int i, CharSequence seq) {
4982             int save = matcher.locals[countIndex];
4983             boolean ret;
4984             if (posIndex != -1 &amp;&amp; matcher.localsPos[posIndex] == null) {
4985                 matcher.localsPos[posIndex] = new IntHashSet();
4986             }
4987             if (0 &lt; cmin) {
4988                 matcher.locals[countIndex] = 1;
4989                 ret = body.match(matcher, i, seq);
4990             } else if (0 &lt; cmax) {
4991                 matcher.locals[countIndex] = 1;
4992                 ret = body.match(matcher, i, seq);
4993                 if (ret == false)
4994                     ret = next.match(matcher, i, seq);
4995             } else {
4996                 ret = next.match(matcher, i, seq);
4997             }
4998             matcher.locals[countIndex] = save;
4999             return ret;
5000         }
5001         boolean study(TreeInfo info) {
5002             info.maxValid = false;
5003             info.deterministic = false;
5004             return false;
5005         }
5006     }
5007 
5008     /**
5009      * Handles the repetition count for a reluctant Curly. The matchInit
5010      * is called from the Prolog to save the index of where the group
5011      * beginning is stored. A zero length group check occurs in the
5012      * normal match but is skipped in the matchInit.
5013      */
5014     static final class LazyLoop extends Loop {
5015         LazyLoop(int countIndex, int beginIndex) {
5016             super(countIndex, beginIndex);
5017         }
5018         boolean match(Matcher matcher, int i, CharSequence seq) {
5019             // Check for zero length group
5020             if (i &gt; matcher.locals[beginIndex]) {
5021                 int count = matcher.locals[countIndex];
5022                 if (count &lt; cmin) {
5023                     matcher.locals[countIndex] = count + 1;
5024                     boolean result = body.match(matcher, i, seq);
5025                     // If match failed we must backtrack, so
5026                     // the loop count should NOT be incremented
5027                     if (!result)
5028                         matcher.locals[countIndex] = count;
5029                     return result;
5030                 }
5031                 if (next.match(matcher, i, seq))
5032                     return true;
5033                 if (count &lt; cmax) {
5034                     matcher.locals[countIndex] = count + 1;
5035                     boolean result = body.match(matcher, i, seq);
5036                     // If match failed we must backtrack, so
5037                     // the loop count should NOT be incremented
5038                     if (!result)
5039                         matcher.locals[countIndex] = count;
5040                     return result;
5041                 }
5042                 return false;
5043             }
5044             return next.match(matcher, i, seq);
5045         }
5046         boolean matchInit(Matcher matcher, int i, CharSequence seq) {
5047             int save = matcher.locals[countIndex];
5048             boolean ret = false;
5049             if (0 &lt; cmin) {
5050                 matcher.locals[countIndex] = 1;
5051                 ret = body.match(matcher, i, seq);
5052             } else if (next.match(matcher, i, seq)) {
5053                 ret = true;
5054             } else if (0 &lt; cmax) {
5055                 matcher.locals[countIndex] = 1;
5056                 ret = body.match(matcher, i, seq);
5057             }
5058             matcher.locals[countIndex] = save;
5059             return ret;
5060         }
5061         boolean study(TreeInfo info) {
5062             info.maxValid = false;
5063             info.deterministic = false;
5064             return false;
5065         }
5066     }
5067 
5068     /**
5069      * Refers to a group in the regular expression. Attempts to match
5070      * whatever the group referred to last matched.
5071      */
5072     static class BackRef extends Node {
5073         int groupIndex;
5074         BackRef(int groupCount) {
5075             super();
5076             groupIndex = groupCount + groupCount;
5077         }
5078         boolean match(Matcher matcher, int i, CharSequence seq) {
5079             int j = matcher.groups[groupIndex];
5080             int k = matcher.groups[groupIndex+1];
5081 
5082             int groupSize = k - j;
5083             // If the referenced group didn&#39;t match, neither can this
5084             if (j &lt; 0)
5085                 return false;
5086 
5087             // If there isn&#39;t enough input left no match
5088             if (i + groupSize &gt; matcher.to) {
5089                 matcher.hitEnd = true;
5090                 return false;
5091             }
5092             // Check each new char to make sure it matches what the group
5093             // referenced matched last time around
5094             for (int index=0; index&lt;groupSize; index++)
5095                 if (seq.charAt(i+index) != seq.charAt(j+index))
5096                     return false;
5097 
5098             return next.match(matcher, i+groupSize, seq);
5099         }
5100         boolean study(TreeInfo info) {
5101             info.maxValid = false;
5102             return next.study(info);
5103         }
5104     }
5105 
5106     static class CIBackRef extends Node {
5107         int groupIndex;
5108         boolean doUnicodeCase;
5109         CIBackRef(int groupCount, boolean doUnicodeCase) {
5110             super();
5111             groupIndex = groupCount + groupCount;
5112             this.doUnicodeCase = doUnicodeCase;
5113         }
5114         boolean match(Matcher matcher, int i, CharSequence seq) {
5115             int j = matcher.groups[groupIndex];
5116             int k = matcher.groups[groupIndex+1];
5117 
5118             int groupSize = k - j;
5119 
5120             // If the referenced group didn&#39;t match, neither can this
5121             if (j &lt; 0)
5122                 return false;
5123 
5124             // If there isn&#39;t enough input left no match
5125             if (i + groupSize &gt; matcher.to) {
5126                 matcher.hitEnd = true;
5127                 return false;
5128             }
5129 
5130             // Check each new char to make sure it matches what the group
5131             // referenced matched last time around
5132             int x = i;
5133             for (int index=0; index&lt;groupSize; index++) {
5134                 int c1 = Character.codePointAt(seq, x);
5135                 int c2 = Character.codePointAt(seq, j);
5136                 if (c1 != c2) {
5137                     if (doUnicodeCase) {
5138                         int cc1 = Character.toUpperCase(c1);
5139                         int cc2 = Character.toUpperCase(c2);
5140                         if (cc1 != cc2 &amp;&amp;
5141                             Character.toLowerCase(cc1) !=
5142                             Character.toLowerCase(cc2))
5143                             return false;
5144                     } else {
5145                         if (ASCII.toLower(c1) != ASCII.toLower(c2))
5146                             return false;
5147                     }
5148                 }
5149                 x += Character.charCount(c1);
5150                 j += Character.charCount(c2);
5151             }
5152 
5153             return next.match(matcher, i+groupSize, seq);
5154         }
5155         boolean study(TreeInfo info) {
5156             info.maxValid = false;
5157             return next.study(info);
5158         }
5159     }
5160 
5161     /**
5162      * Searches until the next instance of its atom. This is useful for
5163      * finding the atom efficiently without passing an instance of it
5164      * (greedy problem) and without a lot of wasted search time (reluctant
5165      * problem).
5166      */
5167     static final class First extends Node {
5168         Node atom;
5169         First(Node node) {
5170             this.atom = BnM.optimize(node);
5171         }
5172         boolean match(Matcher matcher, int i, CharSequence seq) {
5173             if (atom instanceof BnM) {
5174                 return atom.match(matcher, i, seq)
5175                     &amp;&amp; next.match(matcher, matcher.last, seq);
5176             }
5177             for (;;) {
5178                 if (i &gt; matcher.to) {
5179                     matcher.hitEnd = true;
5180                     return false;
5181                 }
5182                 if (atom.match(matcher, i, seq)) {
5183                     return next.match(matcher, matcher.last, seq);
5184                 }
5185                 i += countChars(seq, i, 1);
5186                 matcher.first++;
5187             }
5188         }
5189         boolean study(TreeInfo info) {
5190             atom.study(info);
5191             info.maxValid = false;
5192             info.deterministic = false;
5193             return next.study(info);
5194         }
5195     }
5196 
5197     /**
5198      * Zero width positive lookahead.
5199      */
5200     static final class Pos extends Node {
5201         Node cond;
5202         Pos(Node cond) {
5203             this.cond = cond;
5204         }
5205         boolean match(Matcher matcher, int i, CharSequence seq) {
5206             int savedTo = matcher.to;
5207             boolean conditionMatched;
5208 
5209             // Relax transparent region boundaries for lookahead
5210             if (matcher.transparentBounds)
5211                 matcher.to = matcher.getTextLength();
5212             try {
5213                 conditionMatched = cond.match(matcher, i, seq);
5214             } finally {
5215                 // Reinstate region boundaries
5216                 matcher.to = savedTo;
5217             }
5218             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5219         }
5220     }
5221 
5222     /**
5223      * Zero width negative lookahead.
5224      */
5225     static final class Neg extends Node {
5226         Node cond;
5227         Neg(Node cond) {
5228             this.cond = cond;
5229         }
5230         boolean match(Matcher matcher, int i, CharSequence seq) {
5231             int savedTo = matcher.to;
5232             boolean conditionMatched;
5233 
5234             // Relax transparent region boundaries for lookahead
5235             if (matcher.transparentBounds)
5236                 matcher.to = matcher.getTextLength();
5237             try {
5238                 if (i &lt; matcher.to) {
5239                     conditionMatched = !cond.match(matcher, i, seq);
5240                 } else {
5241                     // If a negative lookahead succeeds then more input
5242                     // could cause it to fail!
5243                     matcher.requireEnd = true;
5244                     conditionMatched = !cond.match(matcher, i, seq);
5245                 }
5246             } finally {
5247                 // Reinstate region boundaries
5248                 matcher.to = savedTo;
5249             }
5250             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5251         }
5252     }
5253 
5254     /**
5255      * For use with lookbehinds; matches the position where the lookbehind
5256      * was encountered.
5257      */
5258     static class LookBehindEndNode extends Node {
5259         private LookBehindEndNode() {} // Singleton
5260 
5261         static LookBehindEndNode INSTANCE = new LookBehindEndNode();
5262 
5263         boolean match(Matcher matcher, int i, CharSequence seq) {
5264             return i == matcher.lookbehindTo;
5265         }
5266     }
5267 
5268     /**
5269      * Zero width positive lookbehind.
5270      */
5271     static class Behind extends Node {
5272         Node cond;
5273         int rmax, rmin;
5274         Behind(Node cond, int rmax, int rmin) {
5275             this.cond = cond;
5276             this.rmax = rmax;
5277             this.rmin = rmin;
5278         }
5279 
5280         boolean match(Matcher matcher, int i, CharSequence seq) {
5281             int savedFrom = matcher.from;
5282             boolean conditionMatched = false;
5283             int startIndex = (!matcher.transparentBounds) ?
5284                              matcher.from : 0;
5285             int from = Math.max(i - rmax, startIndex);
5286             // Set end boundary
5287             int savedLBT = matcher.lookbehindTo;
5288             matcher.lookbehindTo = i;
5289             // Relax transparent region boundaries for lookbehind
5290             if (matcher.transparentBounds)
5291                 matcher.from = 0;
5292             for (int j = i - rmin; !conditionMatched &amp;&amp; j &gt;= from; j--) {
5293                 conditionMatched = cond.match(matcher, j, seq);
5294             }
5295             matcher.from = savedFrom;
5296             matcher.lookbehindTo = savedLBT;
5297             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5298         }
5299     }
5300 
5301     /**
5302      * Zero width positive lookbehind, including supplementary
5303      * characters or unpaired surrogates.
5304      */
5305     static final class BehindS extends Behind {
5306         BehindS(Node cond, int rmax, int rmin) {
5307             super(cond, rmax, rmin);
5308         }
5309         boolean match(Matcher matcher, int i, CharSequence seq) {
5310             int rmaxChars = countChars(seq, i, -rmax);
5311             int rminChars = countChars(seq, i, -rmin);
5312             int savedFrom = matcher.from;
5313             int startIndex = (!matcher.transparentBounds) ?
5314                              matcher.from : 0;
5315             boolean conditionMatched = false;
5316             int from = Math.max(i - rmaxChars, startIndex);
5317             // Set end boundary
5318             int savedLBT = matcher.lookbehindTo;
5319             matcher.lookbehindTo = i;
5320             // Relax transparent region boundaries for lookbehind
5321             if (matcher.transparentBounds)
5322                 matcher.from = 0;
5323 
5324             for (int j = i - rminChars;
5325                  !conditionMatched &amp;&amp; j &gt;= from;
5326                  j -= j&gt;from ? countChars(seq, j, -1) : 1) {
5327                 conditionMatched = cond.match(matcher, j, seq);
5328             }
5329             matcher.from = savedFrom;
5330             matcher.lookbehindTo = savedLBT;
5331             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5332         }
5333     }
5334 
5335     /**
5336      * Zero width negative lookbehind.
5337      */
5338     static class NotBehind extends Node {
5339         Node cond;
5340         int rmax, rmin;
5341         NotBehind(Node cond, int rmax, int rmin) {
5342             this.cond = cond;
5343             this.rmax = rmax;
5344             this.rmin = rmin;
5345         }
5346 
5347         boolean match(Matcher matcher, int i, CharSequence seq) {
5348             int savedLBT = matcher.lookbehindTo;
5349             int savedFrom = matcher.from;
5350             boolean conditionMatched = false;
5351             int startIndex = (!matcher.transparentBounds) ?
5352                              matcher.from : 0;
5353             int from = Math.max(i - rmax, startIndex);
5354             matcher.lookbehindTo = i;
5355             // Relax transparent region boundaries for lookbehind
5356             if (matcher.transparentBounds)
5357                 matcher.from = 0;
5358             for (int j = i - rmin; !conditionMatched &amp;&amp; j &gt;= from; j--) {
5359                 conditionMatched = cond.match(matcher, j, seq);
5360             }
5361             // Reinstate region boundaries
5362             matcher.from = savedFrom;
5363             matcher.lookbehindTo = savedLBT;
5364             return !conditionMatched &amp;&amp; next.match(matcher, i, seq);
5365         }
5366     }
5367 
5368     /**
5369      * Zero width negative lookbehind, including supplementary
5370      * characters or unpaired surrogates.
5371      */
5372     static final class NotBehindS extends NotBehind {
5373         NotBehindS(Node cond, int rmax, int rmin) {
5374             super(cond, rmax, rmin);
5375         }
5376         boolean match(Matcher matcher, int i, CharSequence seq) {
5377             int rmaxChars = countChars(seq, i, -rmax);
5378             int rminChars = countChars(seq, i, -rmin);
5379             int savedFrom = matcher.from;
5380             int savedLBT = matcher.lookbehindTo;
5381             boolean conditionMatched = false;
5382             int startIndex = (!matcher.transparentBounds) ?
5383                              matcher.from : 0;
5384             int from = Math.max(i - rmaxChars, startIndex);
5385             matcher.lookbehindTo = i;
5386             // Relax transparent region boundaries for lookbehind
5387             if (matcher.transparentBounds)
5388                 matcher.from = 0;
5389             for (int j = i - rminChars;
5390                  !conditionMatched &amp;&amp; j &gt;= from;
5391                  j -= j&gt;from ? countChars(seq, j, -1) : 1) {
5392                 conditionMatched = cond.match(matcher, j, seq);
5393             }
5394             //Reinstate region boundaries
5395             matcher.from = savedFrom;
5396             matcher.lookbehindTo = savedLBT;
5397             return !conditionMatched &amp;&amp; next.match(matcher, i, seq);
5398         }
5399     }
5400 
5401     /**
5402      * Handles word boundaries. Includes a field to allow this one class to
5403      * deal with the different types of word boundaries we can match. The word
5404      * characters include underscores, letters, and digits. Non spacing marks
5405      * can are also part of a word if they have a base character, otherwise
5406      * they are ignored for purposes of finding word boundaries.
5407      */
5408     static final class Bound extends Node {
5409         static int LEFT = 0x1;
5410         static int RIGHT= 0x2;
5411         static int BOTH = 0x3;
5412         static int NONE = 0x4;
5413         int type;
5414         boolean useUWORD;
5415         Bound(int n, boolean useUWORD) {
5416             type = n;
5417             this.useUWORD = useUWORD;
5418         }
5419 
5420         boolean isWord(int ch) {
5421             return useUWORD ? CharPredicates.WORD().is(ch)
5422                             : (ch == &#39;_&#39; || Character.isLetterOrDigit(ch));
5423         }
5424 
5425         int check(Matcher matcher, int i, CharSequence seq) {
5426             int ch;
5427             boolean left = false;
5428             int startIndex = matcher.from;
5429             int endIndex = matcher.to;
5430             if (matcher.transparentBounds) {
5431                 startIndex = 0;
5432                 endIndex = matcher.getTextLength();
5433             }
5434             if (i &gt; startIndex) {
5435                 ch = Character.codePointBefore(seq, i);
5436                 left = (isWord(ch) ||
5437                     ((Character.getType(ch) == Character.NON_SPACING_MARK)
5438                      &amp;&amp; hasBaseCharacter(matcher, i-1, seq)));
5439             }
5440             boolean right = false;
5441             if (i &lt; endIndex) {
5442                 ch = Character.codePointAt(seq, i);
5443                 right = (isWord(ch) ||
5444                     ((Character.getType(ch) == Character.NON_SPACING_MARK)
5445                      &amp;&amp; hasBaseCharacter(matcher, i, seq)));
5446             } else {
5447                 // Tried to access char past the end
5448                 matcher.hitEnd = true;
5449                 // The addition of another char could wreck a boundary
5450                 matcher.requireEnd = true;
5451             }
5452             return ((left ^ right) ? (right ? LEFT : RIGHT) : NONE);
5453         }
5454         boolean match(Matcher matcher, int i, CharSequence seq) {
5455             return (check(matcher, i, seq) &amp; type) &gt; 0
5456                 &amp;&amp; next.match(matcher, i, seq);
5457         }
5458     }
5459 
5460     /**
5461      * Non spacing marks only count as word characters in bounds calculations
5462      * if they have a base character.
5463      */
5464     private static boolean hasBaseCharacter(Matcher matcher, int i,
5465                                             CharSequence seq)
5466     {
5467         int start = (!matcher.transparentBounds) ?
5468             matcher.from : 0;
5469         for (int x=i; x &gt;= start; x--) {
5470             int ch = Character.codePointAt(seq, x);
5471             if (Character.isLetterOrDigit(ch))
5472                 return true;
5473             if (Character.getType(ch) == Character.NON_SPACING_MARK)
5474                 continue;
5475             return false;
5476         }
5477         return false;
5478     }
5479 
5480     /**
5481      * Attempts to match a slice in the input using the Boyer-Moore string
5482      * matching algorithm. The algorithm is based on the idea that the
5483      * pattern can be shifted farther ahead in the search text if it is
5484      * matched right to left.
5485      * &lt;p&gt;
5486      * The pattern is compared to the input one character at a time, from
5487      * the rightmost character in the pattern to the left. If the characters
5488      * all match the pattern has been found. If a character does not match,
5489      * the pattern is shifted right a distance that is the maximum of two
5490      * functions, the bad character shift and the good suffix shift. This
5491      * shift moves the attempted match position through the input more
5492      * quickly than a naive one position at a time check.
5493      * &lt;p&gt;
5494      * The bad character shift is based on the character from the text that
5495      * did not match. If the character does not appear in the pattern, the
5496      * pattern can be shifted completely beyond the bad character. If the
5497      * character does occur in the pattern, the pattern can be shifted to
5498      * line the pattern up with the next occurrence of that character.
5499      * &lt;p&gt;
5500      * The good suffix shift is based on the idea that some subset on the right
5501      * side of the pattern has matched. When a bad character is found, the
5502      * pattern can be shifted right by the pattern length if the subset does
5503      * not occur again in pattern, or by the amount of distance to the
5504      * next occurrence of the subset in the pattern.
5505      *
5506      * Boyer-Moore search methods adapted from code by Amy Yu.
5507      */
5508     static class BnM extends Node {
5509         int[] buffer;
5510         int[] lastOcc;
5511         int[] optoSft;
5512 
5513         /**
5514          * Pre calculates arrays needed to generate the bad character
5515          * shift and the good suffix shift. Only the last seven bits
5516          * are used to see if chars match; This keeps the tables small
5517          * and covers the heavily used ASCII range, but occasionally
5518          * results in an aliased match for the bad character shift.
5519          */
5520         static Node optimize(Node node) {
5521             if (!(node instanceof Slice)) {
5522                 return node;
5523             }
5524 
5525             int[] src = ((Slice) node).buffer;
5526             int patternLength = src.length;
5527             // The BM algorithm requires a bit of overhead;
5528             // If the pattern is short don&#39;t use it, since
5529             // a shift larger than the pattern length cannot
5530             // be used anyway.
5531             if (patternLength &lt; 4) {
5532                 return node;
5533             }
5534             int i, j;
5535             int[] lastOcc = new int[128];
5536             int[] optoSft = new int[patternLength];
5537             // Precalculate part of the bad character shift
5538             // It is a table for where in the pattern each
5539             // lower 7-bit value occurs
5540             for (i = 0; i &lt; patternLength; i++) {
5541                 lastOcc[src[i]&amp;0x7F] = i + 1;
5542             }
5543             // Precalculate the good suffix shift
5544             // i is the shift amount being considered
5545 NEXT:       for (i = patternLength; i &gt; 0; i--) {
5546                 // j is the beginning index of suffix being considered
5547                 for (j = patternLength - 1; j &gt;= i; j--) {
5548                     // Testing for good suffix
5549                     if (src[j] == src[j-i]) {
5550                         // src[j..len] is a good suffix
5551                         optoSft[j-1] = i;
5552                     } else {
5553                         // No match. The array has already been
5554                         // filled up with correct values before.
5555                         continue NEXT;
5556                     }
5557                 }
5558                 // This fills up the remaining of optoSft
5559                 // any suffix can not have larger shift amount
5560                 // then its sub-suffix. Why???
5561                 while (j &gt; 0) {
5562                     optoSft[--j] = i;
5563                 }
5564             }
5565             // Set the guard value because of unicode compression
5566             optoSft[patternLength-1] = 1;
5567             if (node instanceof SliceS)
5568                 return new BnMS(src, lastOcc, optoSft, node.next);
5569             return new BnM(src, lastOcc, optoSft, node.next);
5570         }
5571         BnM(int[] src, int[] lastOcc, int[] optoSft, Node next) {
5572             this.buffer = src;
5573             this.lastOcc = lastOcc;
5574             this.optoSft = optoSft;
5575             this.next = next;
5576         }
5577         boolean match(Matcher matcher, int i, CharSequence seq) {
5578             int[] src = buffer;
5579             int patternLength = src.length;
5580             int last = matcher.to - patternLength;
5581 
5582             // Loop over all possible match positions in text
5583 NEXT:       while (i &lt;= last) {
5584                 // Loop over pattern from right to left
5585                 for (int j = patternLength - 1; j &gt;= 0; j--) {
5586                     int ch = seq.charAt(i+j);
5587                     if (ch != src[j]) {
5588                         // Shift search to the right by the maximum of the
5589                         // bad character shift and the good suffix shift
5590                         i += Math.max(j + 1 - lastOcc[ch&amp;0x7F], optoSft[j]);
5591                         continue NEXT;
5592                     }
5593                 }
5594                 // Entire pattern matched starting at i
5595                 matcher.first = i;
5596                 boolean ret = next.match(matcher, i + patternLength, seq);
5597                 if (ret) {
5598                     matcher.first = i;
5599                     matcher.groups[0] = matcher.first;
5600                     matcher.groups[1] = matcher.last;
5601                     return true;
5602                 }
5603                 i++;
5604             }
5605             // BnM is only used as the leading node in the unanchored case,
5606             // and it replaced its Start() which always searches to the end
5607             // if it doesn&#39;t find what it&#39;s looking for, so hitEnd is true.
5608             matcher.hitEnd = true;
5609             return false;
5610         }
5611         boolean study(TreeInfo info) {
5612             info.minLength += buffer.length;
5613             info.maxValid = false;
5614             return next.study(info);
5615         }
5616     }
5617 
5618     /**
5619      * Supplementary support version of BnM(). Unpaired surrogates are
5620      * also handled by this class.
5621      */
5622     static final class BnMS extends BnM {
5623         int lengthInChars;
5624 
5625         BnMS(int[] src, int[] lastOcc, int[] optoSft, Node next) {
5626             super(src, lastOcc, optoSft, next);
5627             for (int cp : buffer) {
5628                 lengthInChars += Character.charCount(cp);
5629             }
5630         }
5631         boolean match(Matcher matcher, int i, CharSequence seq) {
5632             int[] src = buffer;
5633             int patternLength = src.length;
5634             int last = matcher.to - lengthInChars;
5635 
5636             // Loop over all possible match positions in text
5637 NEXT:       while (i &lt;= last) {
5638                 // Loop over pattern from right to left
5639                 int ch;
5640                 for (int j = countChars(seq, i, patternLength), x = patternLength - 1;
5641                      j &gt; 0; j -= Character.charCount(ch), x--) {
5642                     ch = Character.codePointBefore(seq, i+j);
5643                     if (ch != src[x]) {
5644                         // Shift search to the right by the maximum of the
5645                         // bad character shift and the good suffix shift
5646                         int n = Math.max(x + 1 - lastOcc[ch&amp;0x7F], optoSft[x]);
5647                         i += countChars(seq, i, n);
5648                         continue NEXT;
5649                     }
5650                 }
5651                 // Entire pattern matched starting at i
5652                 matcher.first = i;
5653                 boolean ret = next.match(matcher, i + lengthInChars, seq);
5654                 if (ret) {
5655                     matcher.first = i;
5656                     matcher.groups[0] = matcher.first;
5657                     matcher.groups[1] = matcher.last;
5658                     return true;
5659                 }
5660                 i += countChars(seq, i, 1);
5661             }
5662             matcher.hitEnd = true;
5663             return false;
5664         }
5665     }
5666 
5667     @FunctionalInterface
5668     static interface CharPredicate {
5669         boolean is(int ch);
5670 
5671         default CharPredicate and(CharPredicate p) {
5672             return ch -&gt; is(ch) &amp;&amp; p.is(ch);
5673         }
5674         default CharPredicate union(CharPredicate p) {
5675             return ch -&gt; is(ch) || p.is(ch);
5676         }
5677         default CharPredicate union(CharPredicate p1,
5678                                     CharPredicate p2) {
5679             return ch -&gt; is(ch) || p1.is(ch) || p2.is(ch);
5680         }
5681         default CharPredicate negate() {
5682             return ch -&gt; !is(ch);
5683         }
5684     }
5685 
5686     static interface BmpCharPredicate extends CharPredicate {
5687 
5688         default CharPredicate and(CharPredicate p) {
5689             if (p instanceof BmpCharPredicate)
5690                 return (BmpCharPredicate)(ch -&gt; is(ch) &amp;&amp; p.is(ch));
5691             return ch -&gt; is(ch) &amp;&amp; p.is(ch);
5692         }
5693         default CharPredicate union(CharPredicate p) {
5694             if (p instanceof BmpCharPredicate)
5695                 return (BmpCharPredicate)(ch -&gt; is(ch) || p.is(ch));
5696             return ch -&gt; is(ch) || p.is(ch);
5697         }
5698         static CharPredicate union(CharPredicate... predicates) {
5699             CharPredicate cp = ch -&gt; {
5700                 for (CharPredicate p : predicates) {
5701                     if (!p.is(ch))
5702                         return false;
5703                 }
5704                 return true;
5705             };
5706             for (CharPredicate p : predicates) {
5707                 if (! (p instanceof BmpCharPredicate))
5708                     return cp;
5709             }
5710             return (BmpCharPredicate)cp;
5711         }
5712     }
5713 
5714     /**
5715      * matches a Perl vertical whitespace
5716      */
5717     static BmpCharPredicate VertWS() {
5718         return cp -&gt; (cp &gt;= 0x0A &amp;&amp; cp &lt;= 0x0D) ||
5719             cp == 0x85 || cp == 0x2028 || cp == 0x2029;
5720     }
5721 
5722     /**
5723      * matches a Perl horizontal whitespace
5724      */
5725     static BmpCharPredicate HorizWS() {
5726         return cp -&gt;
5727             cp == 0x09 || cp == 0x20 || cp == 0xa0 || cp == 0x1680 ||
5728             cp == 0x180e || cp &gt;= 0x2000 &amp;&amp; cp &lt;= 0x200a ||  cp == 0x202f ||
5729             cp == 0x205f || cp == 0x3000;
5730     }
5731 
5732     /**
5733      *  for the Unicode category ALL and the dot metacharacter when
5734      *  in dotall mode.
5735      */
5736     static CharPredicate ALL() {
5737         return ch -&gt; true;
5738     }
5739 
5740     /**
5741      * for the dot metacharacter when dotall is not enabled.
5742      */
5743     static CharPredicate DOT() {
5744         return ch -&gt;
5745             (ch != &#39;\n&#39; &amp;&amp; ch != &#39;\r&#39;
5746             &amp;&amp; (ch|1) != &#39;\u2029&#39;
5747             &amp;&amp; ch != &#39;\u0085&#39;);
5748     }
5749 
5750     /**
5751      *  the dot metacharacter when dotall is not enabled but UNIX_LINES is enabled.
5752      */
5753     static CharPredicate UNIXDOT() {
5754         return ch -&gt;  ch != &#39;\n&#39;;
5755     }
5756 
5757     /**
5758      * Indicate that matches a Supplementary Unicode character
5759      */
5760     static CharPredicate SingleS(int c) {
5761         return ch -&gt; ch == c;
5762     }
5763 
5764     /**
5765      * A bmp/optimized predicate of single
5766      */
5767     static BmpCharPredicate Single(int c) {
5768         return ch -&gt; ch == c;
5769     }
5770 
5771     /**
5772      * Case insensitive matches a given BMP character
5773      */
5774     static BmpCharPredicate SingleI(int lower, int upper) {
5775         return ch -&gt; ch == lower || ch == upper;
5776     }
5777 
5778     /**
5779      * Unicode case insensitive matches a given Unicode character
5780      */
5781     static CharPredicate SingleU(int lower) {
5782         return ch -&gt; lower == ch ||
5783                      lower == Character.toLowerCase(Character.toUpperCase(ch));
5784     }
5785 
5786     private static boolean inRange(int lower, int ch, int upper) {
5787         return lower &lt;= ch &amp;&amp; ch &lt;= upper;
5788     }
5789 
5790     /**
<a name="5" id="anc5"></a><span class="line-modified">5791      * Characters within a explicit value range</span>
5792      */
5793     static CharPredicate Range(int lower, int upper) {
5794         if (upper &lt; Character.MIN_HIGH_SURROGATE ||
<a name="6" id="anc6"></a><span class="line-modified">5795             lower &gt; Character.MAX_LOW_SURROGATE &amp;&amp;</span>
5796             upper &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT)
5797             return (BmpCharPredicate)(ch -&gt; inRange(lower, ch, upper));
5798         return ch -&gt; inRange(lower, ch, upper);
5799     }
5800 
5801    /**
<a name="7" id="anc7"></a><span class="line-modified">5802     * Characters within a explicit value range in a case insensitive manner.</span>
5803     */
5804     static CharPredicate CIRange(int lower, int upper) {
5805         return ch -&gt; inRange(lower, ch, upper) ||
5806                      ASCII.isAscii(ch) &amp;&amp;
5807                      (inRange(lower, ASCII.toUpper(ch), upper) ||
5808                       inRange(lower, ASCII.toLower(ch), upper));
5809     }
5810 
5811     static CharPredicate CIRangeU(int lower, int upper) {
5812         return ch -&gt; {
5813             if (inRange(lower, ch, upper))
5814                 return true;
5815             int up = Character.toUpperCase(ch);
5816             return inRange(lower, up, upper) ||
5817                    inRange(lower, Character.toLowerCase(up), upper);
5818         };
5819     }
5820 
5821     /**
5822      *  This must be the very first initializer.
5823      */
5824     static final Node accept = new Node();
5825 
5826     static final Node lastAccept = new LastNode();
5827 
5828     /**
5829      * Creates a predicate that tests if this pattern is found in a given input
5830      * string.
5831      *
5832      * @apiNote
5833      * This method creates a predicate that behaves as if it creates a matcher
5834      * from the input sequence and then calls {@code find}, for example a
5835      * predicate of the form:
5836      * &lt;pre&gt;{@code
5837      *   s -&gt; matcher(s).find();
5838      * }&lt;/pre&gt;
5839      *
5840      * @return  The predicate which can be used for finding a match on a
5841      *          subsequence of a string
5842      * @since   1.8
5843      * @see     Matcher#find
5844      */
5845     public Predicate&lt;String&gt; asPredicate() {
5846         return s -&gt; matcher(s).find();
5847     }
5848 
5849     /**
5850      * Creates a predicate that tests if this pattern matches a given input string.
5851      *
5852      * @apiNote
5853      * This method creates a predicate that behaves as if it creates a matcher
5854      * from the input sequence and then calls {@code matches}, for example a
5855      * predicate of the form:
5856      * &lt;pre&gt;{@code
5857      *   s -&gt; matcher(s).matches();
5858      * }&lt;/pre&gt;
5859      *
5860      * @return  The predicate which can be used for matching an input string
5861      *          against this pattern.
5862      * @since   11
5863      * @see     Matcher#matches
5864      */
5865     public Predicate&lt;String&gt; asMatchPredicate() {
5866         return s -&gt; matcher(s).matches();
5867     }
5868 
5869     /**
5870      * Creates a stream from the given input sequence around matches of this
5871      * pattern.
5872      *
5873      * &lt;p&gt; The stream returned by this method contains each substring of the
5874      * input sequence that is terminated by another subsequence that matches
5875      * this pattern or is terminated by the end of the input sequence.  The
5876      * substrings in the stream are in the order in which they occur in the
5877      * input. Trailing empty strings will be discarded and not encountered in
5878      * the stream.
5879      *
5880      * &lt;p&gt; If this pattern does not match any subsequence of the input then
5881      * the resulting stream has just one element, namely the input sequence in
5882      * string form.
5883      *
5884      * &lt;p&gt; When there is a positive-width match at the beginning of the input
5885      * sequence then an empty leading substring is included at the beginning
5886      * of the stream. A zero-width match at the beginning however never produces
5887      * such empty leading substring.
5888      *
5889      * &lt;p&gt; If the input sequence is mutable, it must remain constant during the
5890      * execution of the terminal stream operation.  Otherwise, the result of the
5891      * terminal stream operation is undefined.
5892      *
5893      * @param   input
5894      *          The character sequence to be split
5895      *
5896      * @return  The stream of strings computed by splitting the input
5897      *          around matches of this pattern
5898      * @see     #split(CharSequence)
5899      * @since   1.8
5900      */
5901     public Stream&lt;String&gt; splitAsStream(final CharSequence input) {
5902         class MatcherIterator implements Iterator&lt;String&gt; {
5903             private Matcher matcher;
5904             // The start position of the next sub-sequence of input
5905             // when current == input.length there are no more elements
5906             private int current;
5907             // null if the next element, if any, needs to obtained
5908             private String nextElement;
5909             // &gt; 0 if there are N next empty elements
5910             private int emptyElementCount;
5911 
5912             public String next() {
5913                 if (!hasNext())
5914                     throw new NoSuchElementException();
5915 
5916                 if (emptyElementCount == 0) {
5917                     String n = nextElement;
5918                     nextElement = null;
5919                     return n;
5920                 } else {
5921                     emptyElementCount--;
5922                     return &quot;&quot;;
5923                 }
5924             }
5925 
5926             public boolean hasNext() {
5927                 if (matcher == null) {
5928                     matcher = matcher(input);
5929                     // If the input is an empty string then the result can only be a
5930                     // stream of the input.  Induce that by setting the empty
5931                     // element count to 1
5932                     emptyElementCount = input.length() == 0 ? 1 : 0;
5933                 }
5934                 if (nextElement != null || emptyElementCount &gt; 0)
5935                     return true;
5936 
5937                 if (current == input.length())
5938                     return false;
5939 
5940                 // Consume the next matching element
5941                 // Count sequence of matching empty elements
5942                 while (matcher.find()) {
5943                     nextElement = input.subSequence(current, matcher.start()).toString();
5944                     current = matcher.end();
5945                     if (!nextElement.isEmpty()) {
5946                         return true;
5947                     } else if (current &gt; 0) { // no empty leading substring for zero-width
5948                                               // match at the beginning of the input
5949                         emptyElementCount++;
5950                     }
5951                 }
5952 
5953                 // Consume last matching element
5954                 nextElement = input.subSequence(current, input.length()).toString();
5955                 current = input.length();
5956                 if (!nextElement.isEmpty()) {
5957                     return true;
5958                 } else {
5959                     // Ignore a terminal sequence of matching empty elements
5960                     emptyElementCount = 0;
5961                     nextElement = null;
5962                     return false;
5963                 }
5964             }
5965         }
5966         return StreamSupport.stream(Spliterators.spliteratorUnknownSize(
5967                 new MatcherIterator(), Spliterator.ORDERED | Spliterator.NONNULL), false);
5968     }
5969 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>