<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.management/share/classes/javax/management/monitor/Monitor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.management.monitor;
  27 
  28 import static com.sun.jmx.defaults.JmxProperties.MONITOR_LOGGER;
  29 import com.sun.jmx.mbeanserver.GetPropertyAction;
  30 import com.sun.jmx.mbeanserver.Introspector;
  31 import java.io.IOException;
  32 import java.security.AccessControlContext;
  33 import java.security.AccessController;
  34 import java.security.PrivilegedAction;
  35 import java.security.ProtectionDomain;
  36 import java.util.List;
  37 import java.util.Map;
  38 import java.util.WeakHashMap;
  39 import java.util.concurrent.CopyOnWriteArrayList;
  40 import java.util.concurrent.Executors;
  41 import java.util.concurrent.Future;
  42 import java.util.concurrent.LinkedBlockingQueue;
  43 import java.util.concurrent.ScheduledExecutorService;
  44 import java.util.concurrent.ScheduledFuture;
  45 import java.util.concurrent.ThreadFactory;
  46 import java.util.concurrent.ThreadPoolExecutor;
  47 import java.util.concurrent.TimeUnit;
  48 import java.util.concurrent.atomic.AtomicInteger;
  49 import java.util.concurrent.atomic.AtomicLong;
  50 import java.lang.System.Logger.Level;
  51 import javax.management.AttributeNotFoundException;
  52 import javax.management.InstanceNotFoundException;
  53 import javax.management.IntrospectionException;
  54 import javax.management.MBeanAttributeInfo;
  55 import javax.management.MBeanException;
  56 import javax.management.MBeanInfo;
  57 import javax.management.MBeanRegistration;
  58 import javax.management.MBeanServer;
  59 import javax.management.MBeanServerConnection;
  60 import javax.management.NotificationBroadcasterSupport;
  61 import javax.management.ObjectName;
  62 import javax.management.ReflectionException;
  63 import static javax.management.monitor.MonitorNotification.*;
  64 
  65 /**
  66  * Defines the part common to all monitor MBeans.
  67  * A monitor MBean monitors values of an attribute common to a set of observed
  68  * MBeans. The observed attribute is monitored at intervals specified by the
  69  * granularity period. A gauge value (derived gauge) is derived from the values
  70  * of the observed attribute.
  71  *
  72  *
  73  * @since 1.5
  74  */
  75 public abstract class Monitor
  76     extends NotificationBroadcasterSupport
  77     implements MonitorMBean, MBeanRegistration {
  78 
<a name="2" id="anc2"></a><span class="line-added">  79     /**</span>
<span class="line-added">  80      * Constructor for subclasses to call.</span>
<span class="line-added">  81      */</span>
<span class="line-added">  82     public Monitor() {}</span>
<span class="line-added">  83 </span>
  84     /*
  85      * ------------------------------------------
  86      *  PACKAGE CLASSES
  87      * ------------------------------------------
  88      */
  89 
  90     static class ObservedObject {
  91 
  92         public ObservedObject(ObjectName observedObject) {
  93             this.observedObject = observedObject;
  94         }
  95 
  96         public final ObjectName getObservedObject() {
  97             return observedObject;
  98         }
  99         public final synchronized int getAlreadyNotified() {
 100             return alreadyNotified;
 101         }
 102         public final synchronized void setAlreadyNotified(int alreadyNotified) {
 103             this.alreadyNotified = alreadyNotified;
 104         }
 105         public final synchronized Object getDerivedGauge() {
 106             return derivedGauge;
 107         }
 108         public final synchronized void setDerivedGauge(Object derivedGauge) {
 109             this.derivedGauge = derivedGauge;
 110         }
 111         public final synchronized long getDerivedGaugeTimeStamp() {
 112             return derivedGaugeTimeStamp;
 113         }
 114         public final synchronized void setDerivedGaugeTimeStamp(
 115                                                  long derivedGaugeTimeStamp) {
 116             this.derivedGaugeTimeStamp = derivedGaugeTimeStamp;
 117         }
 118 
 119         private final ObjectName observedObject;
 120         private int alreadyNotified;
 121         private Object derivedGauge;
 122         private long derivedGaugeTimeStamp;
 123     }
 124 
 125     /*
 126      * ------------------------------------------
 127      *  PRIVATE VARIABLES
 128      * ------------------------------------------
 129      */
 130 
 131     /**
 132      * Attribute to observe.
 133      */
 134     private String observedAttribute;
 135 
 136     /**
 137      * Monitor granularity period (in milliseconds).
 138      * The default value is set to 10 seconds.
 139      */
 140     private long granularityPeriod = 10000;
 141 
 142     /**
 143      * Monitor state.
 144      * The default value is set to &lt;CODE&gt;false&lt;/CODE&gt;.
 145      */
 146     private boolean isActive = false;
 147 
 148     /**
 149      * Monitor sequence number.
 150      * The default value is set to 0.
 151      */
 152     private final AtomicLong sequenceNumber = new AtomicLong();
 153 
 154     /**
 155      * Complex type attribute flag.
 156      * The default value is set to &lt;CODE&gt;false&lt;/CODE&gt;.
 157      */
 158     private boolean isComplexTypeAttribute = false;
 159 
 160     /**
 161      * First attribute name extracted from complex type attribute name.
 162      */
 163     private String firstAttribute;
 164 
 165     /**
 166      * Remaining attribute names extracted from complex type attribute name.
 167      */
 168     private final List&lt;String&gt; remainingAttributes =
 169         new CopyOnWriteArrayList&lt;String&gt;();
 170 
 171     /**
 172      * AccessControlContext of the Monitor.start() caller.
 173      */
 174     private static final AccessControlContext noPermissionsACC =
 175             new AccessControlContext(
 176             new ProtectionDomain[] {new ProtectionDomain(null, null)});
 177     private volatile AccessControlContext acc = noPermissionsACC;
 178 
 179     /**
 180      * Scheduler Service.
 181      */
 182     private static final ScheduledExecutorService scheduler =
 183         Executors.newSingleThreadScheduledExecutor(
 184             new DaemonThreadFactory(&quot;Scheduler&quot;));
 185 
 186     /**
 187      * Map containing the thread pool executor per thread group.
 188      */
 189     private static final Map&lt;ThreadPoolExecutor, Void&gt; executors =
 190             new WeakHashMap&lt;ThreadPoolExecutor, Void&gt;();
 191 
 192     /**
 193      * Lock for executors map.
 194      */
 195     private static final Object executorsLock = new Object();
 196 
 197     /**
 198      * Maximum Pool Size
 199      */
 200     private static final int maximumPoolSize;
 201     static {
 202         final String maximumPoolSizeSysProp = &quot;jmx.x.monitor.maximum.pool.size&quot;;
 203         final String maximumPoolSizeStr = AccessController.doPrivileged(
 204             new GetPropertyAction(maximumPoolSizeSysProp));
 205         if (maximumPoolSizeStr == null ||
 206             maximumPoolSizeStr.trim().length() == 0) {
 207             maximumPoolSize = 10;
 208         } else {
 209             int maximumPoolSizeTmp = 10;
 210             try {
 211                 maximumPoolSizeTmp = Integer.parseInt(maximumPoolSizeStr);
 212             } catch (NumberFormatException e) {
 213                 if (MONITOR_LOGGER.isLoggable(Level.TRACE)) {
 214                     MONITOR_LOGGER.log(Level.TRACE,
 215                             &quot;Wrong value for &quot; + maximumPoolSizeSysProp +
 216                             &quot; system property&quot;, e);
 217                     MONITOR_LOGGER.log(Level.TRACE,
 218                             maximumPoolSizeSysProp + &quot; defaults to 10&quot;);
 219                 }
 220                 maximumPoolSizeTmp = 10;
 221             }
 222             if (maximumPoolSizeTmp &lt; 1) {
 223                 maximumPoolSize = 1;
 224             } else {
 225                 maximumPoolSize = maximumPoolSizeTmp;
 226             }
 227         }
 228     }
 229 
 230     /**
 231      * Future associated to the current monitor task.
 232      */
 233     private Future&lt;?&gt; monitorFuture;
 234 
 235     /**
 236      * Scheduler task to be executed by the Scheduler Service.
 237      */
 238     private final SchedulerTask schedulerTask = new SchedulerTask();
 239 
 240     /**
 241      * ScheduledFuture associated to the current scheduler task.
 242      */
 243     private ScheduledFuture&lt;?&gt; schedulerFuture;
 244 
 245     /*
 246      * ------------------------------------------
 247      *  PROTECTED VARIABLES
 248      * ------------------------------------------
 249      */
 250 
 251     /**
 252      * The amount by which the capacity of the monitor arrays are
 253      * automatically incremented when their size becomes greater than
 254      * their capacity.
 255      */
 256     protected final static int capacityIncrement = 16;
 257 
 258     /**
 259      * The number of valid components in the vector of observed objects.
 260      *
 261      */
 262     protected int elementCount = 0;
 263 
 264     /**
 265      * Monitor errors that have already been notified.
 266      * @deprecated equivalent to {@link #alreadyNotifieds}[0].
 267      */
 268     @Deprecated
 269     protected int alreadyNotified = 0;
 270 
 271     /**
 272      * &lt;p&gt;Selected monitor errors that have already been notified.&lt;/p&gt;
 273      *
 274      * &lt;p&gt;Each element in this array corresponds to an observed object
 275      * in the vector.  It contains a bit mask of the flags {@link
 276      * #OBSERVED_OBJECT_ERROR_NOTIFIED} etc, indicating whether the
 277      * corresponding notification has already been sent for the MBean
 278      * being monitored.&lt;/p&gt;
 279      *
 280      */
 281     protected int alreadyNotifieds[] = new int[capacityIncrement];
 282 
 283     /**
 284      * Reference to the MBean server.  This reference is null when the
 285      * monitor MBean is not registered in an MBean server.  This
 286      * reference is initialized before the monitor MBean is registered
 287      * in the MBean server.
 288      * @see #preRegister(MBeanServer server, ObjectName name)
 289      */
 290     protected MBeanServer server;
 291 
 292     // Flags defining possible monitor errors.
 293     //
 294 
 295     /**
 296      * This flag is used to reset the {@link #alreadyNotifieds
 297      * alreadyNotifieds} monitor attribute.
 298      */
 299     protected static final int RESET_FLAGS_ALREADY_NOTIFIED             = 0;
 300 
 301     /**
 302      * Flag denoting that a notification has occurred after changing
 303      * the observed object.  This flag is used to check that the new
 304      * observed object is registered in the MBean server at the time
 305      * of the first notification.
 306      */
 307     protected static final int OBSERVED_OBJECT_ERROR_NOTIFIED           = 1;
 308 
 309     /**
 310      * Flag denoting that a notification has occurred after changing
 311      * the observed attribute.  This flag is used to check that the
 312      * new observed attribute belongs to the observed object at the
 313      * time of the first notification.
 314      */
 315     protected static final int OBSERVED_ATTRIBUTE_ERROR_NOTIFIED        = 2;
 316 
 317     /**
 318      * Flag denoting that a notification has occurred after changing
 319      * the observed object or the observed attribute.  This flag is
 320      * used to check that the observed attribute type is correct
 321      * (depending on the monitor in use) at the time of the first
 322      * notification.
 323      */
 324     protected static final int OBSERVED_ATTRIBUTE_TYPE_ERROR_NOTIFIED   = 4;
 325 
 326     /**
 327      * Flag denoting that a notification has occurred after changing
 328      * the observed object or the observed attribute.  This flag is
 329      * used to notify any exception (except the cases described above)
 330      * when trying to get the value of the observed attribute at the
 331      * time of the first notification.
 332      */
 333     protected static final int RUNTIME_ERROR_NOTIFIED                   = 8;
 334 
 335     /**
 336      * This field is retained for compatibility but should not be referenced.
 337      *
 338      * @deprecated No replacement.
 339      */
 340     @Deprecated
 341     protected String dbgTag = Monitor.class.getName();
 342 
 343     /*
 344      * ------------------------------------------
 345      *  PACKAGE VARIABLES
 346      * ------------------------------------------
 347      */
 348 
 349     /**
 350      * List of ObservedObjects to which the attribute to observe belongs.
 351      */
 352     final List&lt;ObservedObject&gt; observedObjects =
 353         new CopyOnWriteArrayList&lt;ObservedObject&gt;();
 354 
 355     /**
 356      * Flag denoting that a notification has occurred after changing
 357      * the threshold. This flag is used to notify any exception
 358      * related to invalid thresholds settings.
 359      */
 360     static final int THRESHOLD_ERROR_NOTIFIED                           = 16;
 361 
 362     /**
 363      * Enumeration used to keep trace of the derived gauge type
 364      * in counter and gauge monitors.
 365      */
 366     enum NumericalType { BYTE, SHORT, INTEGER, LONG, FLOAT, DOUBLE };
 367 
 368     /**
 369      * Constant used to initialize all the numeric values.
 370      */
 371     static final Integer INTEGER_ZERO = 0;
 372 
 373 
 374     /*
 375      * ------------------------------------------
 376      *  PUBLIC METHODS
 377      * ------------------------------------------
 378      */
 379 
 380     /**
 381      * Allows the monitor MBean to perform any operations it needs
 382      * before being registered in the MBean server.
 383      * &lt;P&gt;
 384      * Initializes the reference to the MBean server.
 385      *
 386      * @param server The MBean server in which the monitor MBean will
 387      * be registered.
 388      * @param name The object name of the monitor MBean.
 389      *
 390      * @return The name of the monitor MBean registered.
 391      *
 392      * @exception Exception if something goes wrong
 393      */
 394     public ObjectName preRegister(MBeanServer server, ObjectName name)
 395         throws Exception {
 396 
 397         MONITOR_LOGGER.log(Level.TRACE,
 398                 &quot;initialize the reference on the MBean server&quot;);
 399 
 400         this.server = server;
 401         return name;
 402     }
 403 
 404     /**
 405      * Allows the monitor MBean to perform any operations needed after
 406      * having been registered in the MBean server or after the
 407      * registration has failed.
 408      * &lt;P&gt;
 409      * Not used in this context.
 410      */
 411     public void postRegister(Boolean registrationDone) {
 412     }
 413 
 414     /**
 415      * Allows the monitor MBean to perform any operations it needs
 416      * before being unregistered by the MBean server.
 417      * &lt;P&gt;
 418      * Stops the monitor.
 419      *
 420      * @exception Exception if something goes wrong
 421      */
 422     public void preDeregister() throws Exception {
 423 
 424         MONITOR_LOGGER.log(Level.TRACE, &quot;stop the monitor&quot;);
 425 
 426         // Stop the Monitor.
 427         //
 428         stop();
 429     }
 430 
 431     /**
 432      * Allows the monitor MBean to perform any operations needed after
 433      * having been unregistered by the MBean server.
 434      * &lt;P&gt;
 435      * Not used in this context.
 436      */
 437     public void postDeregister() {
 438     }
 439 
 440     /**
 441      * Starts the monitor.
 442      */
 443     public abstract void start();
 444 
 445     /**
 446      * Stops the monitor.
 447      */
 448     public abstract void stop();
 449 
 450     // GETTERS AND SETTERS
 451     //--------------------
 452 
 453     /**
 454      * Returns the object name of the first object in the set of observed
 455      * MBeans, or &lt;code&gt;null&lt;/code&gt; if there is no such object.
 456      *
 457      * @return The object being observed.
 458      *
 459      * @see #setObservedObject(ObjectName)
 460      *
 461      * @deprecated As of JMX 1.2, replaced by {@link #getObservedObjects}
 462      */
 463     @Deprecated
 464     public synchronized ObjectName getObservedObject() {
 465         if (observedObjects.isEmpty()) {
 466             return null;
 467         } else {
 468             return observedObjects.get(0).getObservedObject();
 469         }
 470     }
 471 
 472     /**
 473      * Removes all objects from the set of observed objects, and then adds the
 474      * specified object.
 475      *
 476      * @param object The object to observe.
 477      * @exception IllegalArgumentException The specified
 478      * object is null.
 479      *
 480      * @see #getObservedObject()
 481      *
 482      * @deprecated As of JMX 1.2, replaced by {@link #addObservedObject}
 483      */
 484     @Deprecated
 485     public synchronized void setObservedObject(ObjectName object)
 486         throws IllegalArgumentException {
 487         if (object == null)
 488             throw new IllegalArgumentException(&quot;Null observed object&quot;);
 489         if (observedObjects.size() == 1 &amp;&amp; containsObservedObject(object))
 490             return;
 491         observedObjects.clear();
 492         addObservedObject(object);
 493     }
 494 
 495     /**
 496      * Adds the specified object in the set of observed MBeans, if this object
 497      * is not already present.
 498      *
 499      * @param object The object to observe.
 500      * @exception IllegalArgumentException The specified object is null.
 501      *
 502      */
 503     public synchronized void addObservedObject(ObjectName object)
 504         throws IllegalArgumentException {
 505 
 506         if (object == null) {
 507             throw new IllegalArgumentException(&quot;Null observed object&quot;);
 508         }
 509 
 510         // Check that the specified object is not already contained.
 511         //
 512         if (containsObservedObject(object))
 513             return;
 514 
 515         // Add the specified object in the list.
 516         //
 517         ObservedObject o = createObservedObject(object);
 518         o.setAlreadyNotified(RESET_FLAGS_ALREADY_NOTIFIED);
 519         o.setDerivedGauge(INTEGER_ZERO);
 520         o.setDerivedGaugeTimeStamp(System.currentTimeMillis());
 521         observedObjects.add(o);
 522 
 523         // Update legacy protected stuff.
 524         //
 525         createAlreadyNotified();
 526     }
 527 
 528     /**
 529      * Removes the specified object from the set of observed MBeans.
 530      *
 531      * @param object The object to remove.
 532      *
 533      */
 534     public synchronized void removeObservedObject(ObjectName object) {
 535         // Check for null object.
 536         //
 537         if (object == null)
 538             return;
 539 
 540         final ObservedObject o = getObservedObject(object);
 541         if (o != null) {
 542             // Remove the specified object from the list.
 543             //
 544             observedObjects.remove(o);
 545             // Update legacy protected stuff.
 546             //
 547             createAlreadyNotified();
 548         }
 549     }
 550 
 551     /**
 552      * Tests whether the specified object is in the set of observed MBeans.
 553      *
 554      * @param object The object to check.
 555      * @return &lt;CODE&gt;true&lt;/CODE&gt; if the specified object is present,
 556      * &lt;CODE&gt;false&lt;/CODE&gt; otherwise.
 557      *
 558      */
 559     public synchronized boolean containsObservedObject(ObjectName object) {
 560         return getObservedObject(object) != null;
 561     }
 562 
 563     /**
 564      * Returns an array containing the objects being observed.
 565      *
 566      * @return The objects being observed.
 567      *
 568      */
 569     public synchronized ObjectName[] getObservedObjects() {
 570         ObjectName[] names = new ObjectName[observedObjects.size()];
 571         for (int i = 0; i &lt; names.length; i++)
 572             names[i] = observedObjects.get(i).getObservedObject();
 573         return names;
 574     }
 575 
 576     /**
 577      * Gets the attribute being observed.
 578      * &lt;BR&gt;The observed attribute is not initialized by default (set to null).
 579      *
 580      * @return The attribute being observed.
 581      *
 582      * @see #setObservedAttribute
 583      */
 584     public synchronized String getObservedAttribute() {
 585         return observedAttribute;
 586     }
 587 
 588     /**
 589      * Sets the attribute to observe.
 590      * &lt;BR&gt;The observed attribute is not initialized by default (set to null).
 591      *
 592      * @param attribute The attribute to observe.
 593      * @exception IllegalArgumentException The specified
 594      * attribute is null.
 595      *
 596      * @see #getObservedAttribute
 597      */
 598     public void setObservedAttribute(String attribute)
 599         throws IllegalArgumentException {
 600 
 601         if (attribute == null) {
 602             throw new IllegalArgumentException(&quot;Null observed attribute&quot;);
 603         }
 604 
 605         // Update alreadyNotified array.
 606         //
 607         synchronized (this) {
 608             if (observedAttribute != null &amp;&amp;
 609                 observedAttribute.equals(attribute))
 610                 return;
 611             observedAttribute = attribute;
 612 
 613             // Reset the complex type attribute information
 614             // such that it is recalculated again.
 615             //
 616             cleanupIsComplexTypeAttribute();
 617 
 618             int index = 0;
 619             for (ObservedObject o : observedObjects) {
 620                 resetAlreadyNotified(o, index++,
 621                                      OBSERVED_ATTRIBUTE_ERROR_NOTIFIED |
 622                                      OBSERVED_ATTRIBUTE_TYPE_ERROR_NOTIFIED);
 623             }
 624         }
 625     }
 626 
 627     /**
 628      * Gets the granularity period (in milliseconds).
 629      * &lt;BR&gt;The default value of the granularity period is 10 seconds.
 630      *
 631      * @return The granularity period value.
 632      *
 633      * @see #setGranularityPeriod
 634      */
 635     public synchronized long getGranularityPeriod() {
 636         return granularityPeriod;
 637     }
 638 
 639     /**
 640      * Sets the granularity period (in milliseconds).
 641      * &lt;BR&gt;The default value of the granularity period is 10 seconds.
 642      *
 643      * @param period The granularity period value.
 644      * @exception IllegalArgumentException The granularity
 645      * period is less than or equal to zero.
 646      *
 647      * @see #getGranularityPeriod
 648      */
 649     public synchronized void setGranularityPeriod(long period)
 650         throws IllegalArgumentException {
 651 
 652         if (period &lt;= 0) {
 653             throw new IllegalArgumentException(&quot;Nonpositive granularity &quot; +
 654                                                &quot;period&quot;);
 655         }
 656 
 657         if (granularityPeriod == period)
 658             return;
 659         granularityPeriod = period;
 660 
 661         // Reschedule the scheduler task if the monitor is active.
 662         //
 663         if (isActive()) {
 664             cleanupFutures();
 665             schedulerFuture = scheduler.schedule(schedulerTask,
 666                                                  period,
 667                                                  TimeUnit.MILLISECONDS);
 668         }
 669     }
 670 
 671     /**
 672      * Tests whether the monitor MBean is active.  A monitor MBean is
 673      * marked active when the {@link #start start} method is called.
 674      * It becomes inactive when the {@link #stop stop} method is
 675      * called.
 676      *
 677      * @return &lt;CODE&gt;true&lt;/CODE&gt; if the monitor MBean is active,
 678      * &lt;CODE&gt;false&lt;/CODE&gt; otherwise.
 679      */
 680     /* This method must be synchronized so that the monitoring thread will
 681        correctly see modifications to the isActive variable. See the MonitorTask
 682        action executed by the Scheduled Executor Service. */
 683     public synchronized boolean isActive() {
 684         return isActive;
 685     }
 686 
 687     /*
 688      * ------------------------------------------
 689      *  PACKAGE METHODS
 690      * ------------------------------------------
 691      */
 692 
 693     /**
 694      * Starts the monitor.
 695      */
 696     void doStart() {
 697             MONITOR_LOGGER.log(Level.TRACE, &quot;start the monitor&quot;);
 698 
 699         synchronized (this) {
 700             if (isActive()) {
 701                 MONITOR_LOGGER.log(Level.TRACE, &quot;the monitor is already active&quot;);
 702                 return;
 703             }
 704 
 705             isActive = true;
 706 
 707             // Reset the complex type attribute information
 708             // such that it is recalculated again.
 709             //
 710             cleanupIsComplexTypeAttribute();
 711 
 712             // Cache the AccessControlContext of the Monitor.start() caller.
 713             // The monitor tasks will be executed within this context.
 714             //
 715             acc = AccessController.getContext();
 716 
 717             // Start the scheduler.
 718             //
 719             cleanupFutures();
 720             schedulerTask.setMonitorTask(new MonitorTask());
 721             schedulerFuture = scheduler.schedule(schedulerTask,
 722                                                  getGranularityPeriod(),
 723                                                  TimeUnit.MILLISECONDS);
 724         }
 725     }
 726 
 727     /**
 728      * Stops the monitor.
 729      */
 730     void doStop() {
 731         MONITOR_LOGGER.log(Level.TRACE, &quot;stop the monitor&quot;);
 732 
 733         synchronized (this) {
 734             if (!isActive()) {
 735                 MONITOR_LOGGER.log(Level.TRACE, &quot;the monitor is not active&quot;);
 736                 return;
 737             }
 738 
 739             isActive = false;
 740 
 741             // Cancel the scheduler task associated with the
 742             // scheduler and its associated monitor task.
 743             //
 744             cleanupFutures();
 745 
 746             // Reset the AccessControlContext.
 747             //
 748             acc = noPermissionsACC;
 749 
 750             // Reset the complex type attribute information
 751             // such that it is recalculated again.
 752             //
 753             cleanupIsComplexTypeAttribute();
 754         }
 755     }
 756 
 757     /**
 758      * Gets the derived gauge of the specified object, if this object is
 759      * contained in the set of observed MBeans, or &lt;code&gt;null&lt;/code&gt; otherwise.
 760      *
 761      * @param object the name of the object whose derived gauge is to
 762      * be returned.
 763      *
 764      * @return The derived gauge of the specified object.
 765      *
 766      * @since 1.6
 767      */
 768     synchronized Object getDerivedGauge(ObjectName object) {
 769         final ObservedObject o = getObservedObject(object);
 770         return o == null ? null : o.getDerivedGauge();
 771     }
 772 
 773     /**
 774      * Gets the derived gauge timestamp of the specified object, if
 775      * this object is contained in the set of observed MBeans, or
 776      * &lt;code&gt;0&lt;/code&gt; otherwise.
 777      *
 778      * @param object the name of the object whose derived gauge
 779      * timestamp is to be returned.
 780      *
 781      * @return The derived gauge timestamp of the specified object.
 782      *
 783      */
 784     synchronized long getDerivedGaugeTimeStamp(ObjectName object) {
 785         final ObservedObject o = getObservedObject(object);
 786         return o == null ? 0 : o.getDerivedGaugeTimeStamp();
 787     }
 788 
 789     Object getAttribute(MBeanServerConnection mbsc,
 790                         ObjectName object,
 791                         String attribute)
 792         throws AttributeNotFoundException,
 793                InstanceNotFoundException,
 794                MBeanException,
 795                ReflectionException,
 796                IOException {
 797         // Check for &quot;ObservedAttribute&quot; replacement.
 798         // This could happen if a thread A called setObservedAttribute()
 799         // while other thread B was in the middle of the monitor() method
 800         // and received the old observed attribute value.
 801         //
 802         final boolean lookupMBeanInfo;
 803         synchronized (this) {
 804             if (!isActive())
 805                 throw new IllegalArgumentException(
 806                     &quot;The monitor has been stopped&quot;);
 807             if (!attribute.equals(getObservedAttribute()))
 808                 throw new IllegalArgumentException(
 809                     &quot;The observed attribute has been changed&quot;);
 810             lookupMBeanInfo =
 811                 (firstAttribute == null &amp;&amp; attribute.indexOf(&#39;.&#39;) != -1);
 812         }
 813 
 814         // Look up MBeanInfo if needed
 815         //
 816         final MBeanInfo mbi;
 817         if (lookupMBeanInfo) {
 818             try {
 819                 mbi = mbsc.getMBeanInfo(object);
 820             } catch (IntrospectionException e) {
 821                 throw new IllegalArgumentException(e);
 822             }
 823         } else {
 824             mbi = null;
 825         }
 826 
 827         // Check for complex type attribute
 828         //
 829         final String fa;
 830         synchronized (this) {
 831             if (!isActive())
 832                 throw new IllegalArgumentException(
 833                     &quot;The monitor has been stopped&quot;);
 834             if (!attribute.equals(getObservedAttribute()))
 835                 throw new IllegalArgumentException(
 836                     &quot;The observed attribute has been changed&quot;);
 837             if (firstAttribute == null) {
 838                 if (attribute.indexOf(&#39;.&#39;) != -1) {
 839                     MBeanAttributeInfo mbaiArray[] = mbi.getAttributes();
 840                     for (MBeanAttributeInfo mbai : mbaiArray) {
 841                         if (attribute.equals(mbai.getName())) {
 842                             firstAttribute = attribute;
 843                             break;
 844                         }
 845                     }
 846                     if (firstAttribute == null) {
 847                         String tokens[] = attribute.split(&quot;\\.&quot;, -1);
 848                         firstAttribute = tokens[0];
 849                         for (int i = 1; i &lt; tokens.length; i++)
 850                             remainingAttributes.add(tokens[i]);
 851                         isComplexTypeAttribute = true;
 852                     }
 853                 } else {
 854                     firstAttribute = attribute;
 855                 }
 856             }
 857             fa = firstAttribute;
 858         }
 859         return mbsc.getAttribute(object, fa);
 860     }
 861 
 862     Comparable&lt;?&gt; getComparableFromAttribute(ObjectName object,
 863                                              String attribute,
 864                                              Object value)
 865         throws AttributeNotFoundException {
 866         if (isComplexTypeAttribute) {
 867             Object v = value;
 868             for (String attr : remainingAttributes)
 869                 v = Introspector.elementFromComplex(v, attr);
 870             return (Comparable&lt;?&gt;) v;
 871         } else {
 872             return (Comparable&lt;?&gt;) value;
 873         }
 874     }
 875 
 876     boolean isComparableTypeValid(ObjectName object,
 877                                   String attribute,
 878                                   Comparable&lt;?&gt; value) {
 879         return true;
 880     }
 881 
 882     String buildErrorNotification(ObjectName object,
 883                                   String attribute,
 884                                   Comparable&lt;?&gt; value) {
 885         return null;
 886     }
 887 
 888     void onErrorNotification(MonitorNotification notification) {
 889     }
 890 
 891     Comparable&lt;?&gt; getDerivedGaugeFromComparable(ObjectName object,
 892                                                 String attribute,
 893                                                 Comparable&lt;?&gt; value) {
 894         return (Comparable&lt;?&gt;) value;
 895     }
 896 
 897     MonitorNotification buildAlarmNotification(ObjectName object,
 898                                                String attribute,
 899                                                Comparable&lt;?&gt; value){
 900         return null;
 901     }
 902 
 903     boolean isThresholdTypeValid(ObjectName object,
 904                                  String attribute,
 905                                  Comparable&lt;?&gt; value) {
 906         return true;
 907     }
 908 
 909     static Class&lt;? extends Number&gt; classForType(NumericalType type) {
 910         switch (type) {
 911             case BYTE:
 912                 return Byte.class;
 913             case SHORT:
 914                 return Short.class;
 915             case INTEGER:
 916                 return Integer.class;
 917             case LONG:
 918                 return Long.class;
 919             case FLOAT:
 920                 return Float.class;
 921             case DOUBLE:
 922                 return Double.class;
 923             default:
 924                 throw new IllegalArgumentException(
 925                     &quot;Unsupported numerical type&quot;);
 926         }
 927     }
 928 
 929     static boolean isValidForType(Object value, Class&lt;? extends Number&gt; c) {
 930         return ((value == INTEGER_ZERO) || c.isInstance(value));
 931     }
 932 
 933     /**
 934      * Get the specified {@code ObservedObject} if this object is
 935      * contained in the set of observed MBeans, or {@code null}
 936      * otherwise.
 937      *
 938      * @param object the name of the {@code ObservedObject} to retrieve.
 939      *
 940      * @return The {@code ObservedObject} associated to the supplied
 941      * {@code ObjectName}.
 942      *
 943      * @since 1.6
 944      */
 945     synchronized ObservedObject getObservedObject(ObjectName object) {
 946         for (ObservedObject o : observedObjects)
 947             if (o.getObservedObject().equals(object))
 948                 return o;
 949         return null;
 950     }
 951 
 952     /**
 953      * Factory method for ObservedObject creation.
 954      *
 955      * @since 1.6
 956      */
 957     ObservedObject createObservedObject(ObjectName object) {
 958         return new ObservedObject(object);
 959     }
 960 
 961     /**
 962      * Create the {@link #alreadyNotified} array from
 963      * the {@code ObservedObject} array list.
 964      */
 965     synchronized void createAlreadyNotified() {
 966         // Update elementCount.
 967         //
 968         elementCount = observedObjects.size();
 969 
 970         // Update arrays.
 971         //
 972         alreadyNotifieds = new int[elementCount];
 973         for (int i = 0; i &lt; elementCount; i++) {
 974             alreadyNotifieds[i] = observedObjects.get(i).getAlreadyNotified();
 975         }
 976         updateDeprecatedAlreadyNotified();
 977     }
 978 
 979     /**
 980      * Update the deprecated {@link #alreadyNotified} field.
 981      */
 982     synchronized void updateDeprecatedAlreadyNotified() {
 983         if (elementCount &gt; 0)
 984             alreadyNotified = alreadyNotifieds[0];
 985         else
 986             alreadyNotified = 0;
 987     }
 988 
 989     /**
 990      * Update the {@link #alreadyNotifieds} array element at the given index
 991      * with the already notified flag in the given {@code ObservedObject}.
 992      * Ensure the deprecated {@link #alreadyNotified} field is updated
 993      * if appropriate.
 994      */
 995     synchronized void updateAlreadyNotified(ObservedObject o, int index) {
 996         alreadyNotifieds[index] = o.getAlreadyNotified();
 997         if (index == 0)
 998             updateDeprecatedAlreadyNotified();
 999     }
1000 
1001     /**
1002      * Check if the given bits in the given element of {@link #alreadyNotifieds}
1003      * are set.
1004      */
1005     synchronized boolean isAlreadyNotified(ObservedObject o, int mask) {
1006         return ((o.getAlreadyNotified() &amp; mask) != 0);
1007     }
1008 
1009     /**
1010      * Set the given bits in the given element of {@link #alreadyNotifieds}.
1011      * Ensure the deprecated {@link #alreadyNotified} field is updated
1012      * if appropriate.
1013      */
1014     synchronized void setAlreadyNotified(ObservedObject o, int index,
1015                                          int mask, int an[]) {
1016         final int i = computeAlreadyNotifiedIndex(o, index, an);
1017         if (i == -1)
1018             return;
1019         o.setAlreadyNotified(o.getAlreadyNotified() | mask);
1020         updateAlreadyNotified(o, i);
1021     }
1022 
1023     /**
1024      * Reset the given bits in the given element of {@link #alreadyNotifieds}.
1025      * Ensure the deprecated {@link #alreadyNotified} field is updated
1026      * if appropriate.
1027      */
1028     synchronized void resetAlreadyNotified(ObservedObject o,
1029                                            int index, int mask) {
1030         o.setAlreadyNotified(o.getAlreadyNotified() &amp; ~mask);
1031         updateAlreadyNotified(o, index);
1032     }
1033 
1034     /**
1035      * Reset all bits in the given element of {@link #alreadyNotifieds}.
1036      * Ensure the deprecated {@link #alreadyNotified} field is updated
1037      * if appropriate.
1038      */
1039     synchronized void resetAllAlreadyNotified(ObservedObject o,
1040                                               int index, int an[]) {
1041         final int i = computeAlreadyNotifiedIndex(o, index, an);
1042         if (i == -1)
1043             return;
1044         o.setAlreadyNotified(RESET_FLAGS_ALREADY_NOTIFIED);
1045         updateAlreadyNotified(o, index);
1046     }
1047 
1048     /**
1049      * Check if the {@link #alreadyNotifieds} array has been modified.
1050      * If true recompute the index for the given observed object.
1051      */
1052     synchronized int computeAlreadyNotifiedIndex(ObservedObject o,
1053                                                  int index, int an[]) {
1054         if (an == alreadyNotifieds) {
1055             return index;
1056         } else {
1057             return observedObjects.indexOf(o);
1058         }
1059     }
1060 
1061     /*
1062      * ------------------------------------------
1063      *  PRIVATE METHODS
1064      * ------------------------------------------
1065      */
1066 
1067     /**
1068      * This method is used by the monitor MBean to create and send a
1069      * monitor notification to all the listeners registered for this
1070      * kind of notification.
1071      *
1072      * @param type The notification type.
1073      * @param timeStamp The notification emission date.
1074      * @param msg The notification message.
1075      * @param derGauge The derived gauge.
1076      * @param trigger The threshold/string (depending on the monitor
1077      * type) that triggered off the notification.
1078      * @param object The ObjectName of the observed object that triggered
1079      * off the notification.
1080      * @param onError Flag indicating if this monitor notification is
1081      * an error notification or an alarm notification.
1082      */
1083     private void sendNotification(String type, long timeStamp, String msg,
1084                                   Object derGauge, Object trigger,
1085                                   ObjectName object, boolean onError) {
1086         if (!isActive())
1087             return;
1088 
1089         if (MONITOR_LOGGER.isLoggable(Level.TRACE)) {
1090             MONITOR_LOGGER.log(Level.TRACE, &quot;send notification: &quot; +
1091                     &quot;\n\tNotification observed object = &quot; + object +
1092                     &quot;\n\tNotification observed attribute = &quot; + observedAttribute +
1093                     &quot;\n\tNotification derived gauge = &quot; + derGauge);
1094         }
1095 
1096         long seqno = sequenceNumber.getAndIncrement();
1097 
1098         MonitorNotification mn =
1099             new MonitorNotification(type,
1100                                     this,
1101                                     seqno,
1102                                     timeStamp,
1103                                     msg,
1104                                     object,
1105                                     observedAttribute,
1106                                     derGauge,
1107                                     trigger);
1108         if (onError)
1109             onErrorNotification(mn);
1110         sendNotification(mn);
1111     }
1112 
1113     /**
1114      * This method is called by the monitor each time
1115      * the granularity period has been exceeded.
1116      * @param o The observed object.
1117      */
1118     private void monitor(ObservedObject o, int index, int an[]) {
1119 
1120         String attribute;
1121         String notifType = null;
1122         String msg = null;
1123         Object derGauge = null;
1124         Object trigger = null;
1125         ObjectName object;
1126         Comparable&lt;?&gt; value = null;
1127         MonitorNotification alarm = null;
1128 
1129         if (!isActive())
1130             return;
1131 
1132         // Check that neither the observed object nor the
1133         // observed attribute are null.  If the observed
1134         // object or observed attribute is null, this means
1135         // that the monitor started before a complete
1136         // initialization and nothing is done.
1137         //
1138         synchronized (this) {
1139             object = o.getObservedObject();
1140             attribute = getObservedAttribute();
1141             if (object == null || attribute == null) {
1142                 return;
1143             }
1144         }
1145 
1146         // Check that the observed object is registered in the
1147         // MBean server and that the observed attribute
1148         // belongs to the observed object.
1149         //
1150         Object attributeValue = null;
1151         try {
1152             attributeValue = getAttribute(server, object, attribute);
1153             if (attributeValue == null)
1154                 if (isAlreadyNotified(
1155                         o, OBSERVED_ATTRIBUTE_TYPE_ERROR_NOTIFIED))
1156                     return;
1157                 else {
1158                     notifType = OBSERVED_ATTRIBUTE_TYPE_ERROR;
1159                     setAlreadyNotified(
1160                         o, index, OBSERVED_ATTRIBUTE_TYPE_ERROR_NOTIFIED, an);
1161                     msg = &quot;The observed attribute value is null.&quot;;
1162                     MONITOR_LOGGER.log(Level.TRACE, msg);
1163                 }
1164         } catch (NullPointerException np_ex) {
1165             if (isAlreadyNotified(o, RUNTIME_ERROR_NOTIFIED))
1166                 return;
1167             else {
1168                 notifType = RUNTIME_ERROR;
1169                 setAlreadyNotified(o, index, RUNTIME_ERROR_NOTIFIED, an);
1170                 msg =
1171                     &quot;The monitor must be registered in the MBean &quot; +
1172                     &quot;server or an MBeanServerConnection must be &quot; +
1173                     &quot;explicitly supplied.&quot;;
1174                 MONITOR_LOGGER.log(Level.TRACE, msg);
1175                 MONITOR_LOGGER.log(Level.TRACE, np_ex::toString);
1176             }
1177         } catch (InstanceNotFoundException inf_ex) {
1178             if (isAlreadyNotified(o, OBSERVED_OBJECT_ERROR_NOTIFIED))
1179                 return;
1180             else {
1181                 notifType = OBSERVED_OBJECT_ERROR;
1182                 setAlreadyNotified(
1183                     o, index, OBSERVED_OBJECT_ERROR_NOTIFIED, an);
1184                 msg =
1185                     &quot;The observed object must be accessible in &quot; +
1186                     &quot;the MBeanServerConnection.&quot;;
1187                 MONITOR_LOGGER.log(Level.TRACE, msg);
1188                 MONITOR_LOGGER.log(Level.TRACE, inf_ex::toString);
1189             }
1190         } catch (AttributeNotFoundException anf_ex) {
1191             if (isAlreadyNotified(o, OBSERVED_ATTRIBUTE_ERROR_NOTIFIED))
1192                 return;
1193             else {
1194                 notifType = OBSERVED_ATTRIBUTE_ERROR;
1195                 setAlreadyNotified(
1196                     o, index, OBSERVED_ATTRIBUTE_ERROR_NOTIFIED, an);
1197                 msg =
1198                     &quot;The observed attribute must be accessible in &quot; +
1199                     &quot;the observed object.&quot;;
1200                 MONITOR_LOGGER.log(Level.TRACE, msg);
1201                 MONITOR_LOGGER.log(Level.TRACE, anf_ex::toString);
1202             }
1203         } catch (MBeanException mb_ex) {
1204             if (isAlreadyNotified(o, RUNTIME_ERROR_NOTIFIED))
1205                 return;
1206             else {
1207                 notifType = RUNTIME_ERROR;
1208                 setAlreadyNotified(o, index, RUNTIME_ERROR_NOTIFIED, an);
1209                 msg = mb_ex.getMessage() == null ? &quot;&quot; : mb_ex.getMessage();
1210                 MONITOR_LOGGER.log(Level.TRACE, msg);
1211                 MONITOR_LOGGER.log(Level.TRACE, mb_ex::toString);
1212             }
1213         } catch (ReflectionException ref_ex) {
1214             if (isAlreadyNotified(o, RUNTIME_ERROR_NOTIFIED)) {
1215                 return;
1216             } else {
1217                 notifType = RUNTIME_ERROR;
1218                 setAlreadyNotified(o, index, RUNTIME_ERROR_NOTIFIED, an);
1219                 msg = ref_ex.getMessage() == null ? &quot;&quot; : ref_ex.getMessage();
1220                 MONITOR_LOGGER.log(Level.TRACE, msg);
1221                 MONITOR_LOGGER.log(Level.TRACE, ref_ex::toString);
1222             }
1223         } catch (IOException io_ex) {
1224             if (isAlreadyNotified(o, RUNTIME_ERROR_NOTIFIED))
1225                 return;
1226             else {
1227                 notifType = RUNTIME_ERROR;
1228                 setAlreadyNotified(o, index, RUNTIME_ERROR_NOTIFIED, an);
1229                 msg = io_ex.getMessage() == null ? &quot;&quot; : io_ex.getMessage();
1230                 MONITOR_LOGGER.log(Level.TRACE, msg);
1231                 MONITOR_LOGGER.log(Level.TRACE, io_ex::toString);
1232             }
1233         } catch (RuntimeException rt_ex) {
1234             if (isAlreadyNotified(o, RUNTIME_ERROR_NOTIFIED))
1235                 return;
1236             else {
1237                 notifType = RUNTIME_ERROR;
1238                 setAlreadyNotified(o, index, RUNTIME_ERROR_NOTIFIED, an);
1239                 msg = rt_ex.getMessage() == null ? &quot;&quot; : rt_ex.getMessage();
1240                 MONITOR_LOGGER.log(Level.TRACE, msg);
1241                 MONITOR_LOGGER.log(Level.TRACE, rt_ex::toString);
1242             }
1243         }
1244 
1245         synchronized (this) {
1246 
1247             // Check if the monitor has been stopped.
1248             //
1249             if (!isActive())
1250                 return;
1251 
1252             // Check if the observed attribute has been changed.
1253             //
1254             // Avoid race condition where mbs.getAttribute() succeeded but
1255             // another thread replaced the observed attribute meanwhile.
1256             //
1257             // Avoid setting computed derived gauge on erroneous attribute.
1258             //
1259             if (!attribute.equals(getObservedAttribute()))
1260                 return;
1261 
1262             // Derive a Comparable object from the ObservedAttribute value
1263             // if the type of the ObservedAttribute value is a complex type.
1264             //
1265             if (msg == null) {
1266                 try {
1267                     value = getComparableFromAttribute(object,
1268                                                        attribute,
1269                                                        attributeValue);
1270                 } catch (ClassCastException e) {
1271                     if (isAlreadyNotified(
1272                             o, OBSERVED_ATTRIBUTE_TYPE_ERROR_NOTIFIED))
1273                         return;
1274                     else {
1275                         notifType = OBSERVED_ATTRIBUTE_TYPE_ERROR;
1276                         setAlreadyNotified(o, index,
1277                             OBSERVED_ATTRIBUTE_TYPE_ERROR_NOTIFIED, an);
1278                         msg =
1279                             &quot;The observed attribute value does not &quot; +
1280                             &quot;implement the Comparable interface.&quot;;
1281                         MONITOR_LOGGER.log(Level.TRACE, msg);
1282                         MONITOR_LOGGER.log(Level.TRACE, e::toString);
1283                     }
1284                 } catch (AttributeNotFoundException e) {
1285                     if (isAlreadyNotified(o, OBSERVED_ATTRIBUTE_ERROR_NOTIFIED))
1286                         return;
1287                     else {
1288                         notifType = OBSERVED_ATTRIBUTE_ERROR;
1289                         setAlreadyNotified(
1290                             o, index, OBSERVED_ATTRIBUTE_ERROR_NOTIFIED, an);
1291                         msg =
1292                             &quot;The observed attribute must be accessible in &quot; +
1293                             &quot;the observed object.&quot;;
1294                         MONITOR_LOGGER.log(Level.TRACE, msg);
1295                         MONITOR_LOGGER.log(Level.TRACE, e::toString);
1296                     }
1297                 } catch (RuntimeException e) {
1298                     if (isAlreadyNotified(o, RUNTIME_ERROR_NOTIFIED))
1299                         return;
1300                     else {
1301                         notifType = RUNTIME_ERROR;
1302                         setAlreadyNotified(o, index,
1303                             RUNTIME_ERROR_NOTIFIED, an);
1304                         msg = e.getMessage() == null ? &quot;&quot; : e.getMessage();
1305                         MONITOR_LOGGER.log(Level.TRACE, msg);
1306                         MONITOR_LOGGER.log(Level.TRACE, e::toString);
1307                     }
1308                 }
1309             }
1310 
1311             // Check that the observed attribute type is supported by this
1312             // monitor.
1313             //
1314             if (msg == null) {
1315                 if (!isComparableTypeValid(object, attribute, value)) {
1316                     if (isAlreadyNotified(
1317                             o, OBSERVED_ATTRIBUTE_TYPE_ERROR_NOTIFIED))
1318                         return;
1319                     else {
1320                         notifType = OBSERVED_ATTRIBUTE_TYPE_ERROR;
1321                         setAlreadyNotified(o, index,
1322                             OBSERVED_ATTRIBUTE_TYPE_ERROR_NOTIFIED, an);
1323                         msg = &quot;The observed attribute type is not valid.&quot;;
1324                         MONITOR_LOGGER.log(Level.TRACE, msg);
1325                     }
1326                 }
1327             }
1328 
1329             // Check that threshold type is supported by this monitor.
1330             //
1331             if (msg == null) {
1332                 if (!isThresholdTypeValid(object, attribute, value)) {
1333                     if (isAlreadyNotified(o, THRESHOLD_ERROR_NOTIFIED))
1334                         return;
1335                     else {
1336                         notifType = THRESHOLD_ERROR;
1337                         setAlreadyNotified(o, index,
1338                             THRESHOLD_ERROR_NOTIFIED, an);
1339                         msg = &quot;The threshold type is not valid.&quot;;
1340                         MONITOR_LOGGER.log(Level.TRACE, msg);
1341                     }
1342                 }
1343             }
1344 
1345             // Let someone subclassing the monitor to perform additional
1346             // monitor consistency checks and report errors if necessary.
1347             //
1348             if (msg == null) {
1349                 msg = buildErrorNotification(object, attribute, value);
1350                 if (msg != null) {
1351                     if (isAlreadyNotified(o, RUNTIME_ERROR_NOTIFIED))
1352                         return;
1353                     else {
1354                         notifType = RUNTIME_ERROR;
1355                         setAlreadyNotified(o, index,
1356                             RUNTIME_ERROR_NOTIFIED, an);
1357                         MONITOR_LOGGER.log(Level.TRACE, msg);
1358                     }
1359                 }
1360             }
1361 
1362             // If no errors were found then clear all error flags and
1363             // let the monitor decide if a notification must be sent.
1364             //
1365             if (msg == null) {
1366                 // Clear all already notified flags.
1367                 //
1368                 resetAllAlreadyNotified(o, index, an);
1369 
1370                 // Get derived gauge from comparable value.
1371                 //
1372                 derGauge = getDerivedGaugeFromComparable(object,
1373                                                          attribute,
1374                                                          value);
1375 
1376                 o.setDerivedGauge(derGauge);
1377                 o.setDerivedGaugeTimeStamp(System.currentTimeMillis());
1378 
1379                 // Check if an alarm must be fired.
1380                 //
1381                 alarm = buildAlarmNotification(object,
1382                                                attribute,
1383                                                (Comparable&lt;?&gt;) derGauge);
1384             }
1385 
1386         }
1387 
1388         // Notify monitor errors
1389         //
1390         if (msg != null)
1391             sendNotification(notifType,
1392                              System.currentTimeMillis(),
1393                              msg,
1394                              derGauge,
1395                              trigger,
1396                              object,
1397                              true);
1398 
1399         // Notify monitor alarms
1400         //
1401         if (alarm != null &amp;&amp; alarm.getType() != null)
1402             sendNotification(alarm.getType(),
1403                              System.currentTimeMillis(),
1404                              alarm.getMessage(),
1405                              derGauge,
1406                              alarm.getTrigger(),
1407                              object,
1408                              false);
1409     }
1410 
1411     /**
1412      * Cleanup the scheduler and monitor tasks futures.
1413      */
1414     private synchronized void cleanupFutures() {
1415         if (schedulerFuture != null) {
1416             schedulerFuture.cancel(false);
1417             schedulerFuture = null;
1418         }
1419         if (monitorFuture != null) {
1420             monitorFuture.cancel(false);
1421             monitorFuture = null;
1422         }
1423     }
1424 
1425     /**
1426      * Cleanup the &quot;is complex type attribute&quot; info.
1427      */
1428     private synchronized void cleanupIsComplexTypeAttribute() {
1429         firstAttribute = null;
1430         remainingAttributes.clear();
1431         isComplexTypeAttribute = false;
1432     }
1433 
1434     /**
1435      * SchedulerTask nested class: This class implements the Runnable interface.
1436      *
1437      * The SchedulerTask is executed periodically with a given fixed delay by
1438      * the Scheduled Executor Service.
1439      */
1440     private class SchedulerTask implements Runnable {
1441 
1442         private MonitorTask task;
1443 
1444         /*
1445          * ------------------------------------------
1446          *  CONSTRUCTORS
1447          * ------------------------------------------
1448          */
1449 
1450         public SchedulerTask() {
1451         }
1452 
1453         /*
1454          * ------------------------------------------
1455          *  GETTERS/SETTERS
1456          * ------------------------------------------
1457          */
1458 
1459         public void setMonitorTask(MonitorTask task) {
1460             this.task = task;
1461         }
1462 
1463         /*
1464          * ------------------------------------------
1465          *  PUBLIC METHODS
1466          * ------------------------------------------
1467          */
1468 
1469         public void run() {
1470             synchronized (Monitor.this) {
1471                 Monitor.this.monitorFuture = task.submit();
1472             }
1473         }
1474     }
1475 
1476     /**
1477      * MonitorTask nested class: This class implements the Runnable interface.
1478      *
1479      * The MonitorTask is executed periodically with a given fixed delay by the
1480      * Scheduled Executor Service.
1481      */
1482     private class MonitorTask implements Runnable {
1483 
1484         private ThreadPoolExecutor executor;
1485 
1486         /*
1487          * ------------------------------------------
1488          *  CONSTRUCTORS
1489          * ------------------------------------------
1490          */
1491 
1492         public MonitorTask() {
1493             // Find out if there&#39;s already an existing executor for the calling
1494             // thread and reuse it. Otherwise, create a new one and store it in
1495             // the executors map. If there is a SecurityManager, the group of
1496             // System.getSecurityManager() is used, else the group of the thread
1497             // instantiating this MonitorTask, i.e. the group of the thread that
1498             // calls &quot;Monitor.start()&quot;.
1499             SecurityManager s = System.getSecurityManager();
1500             ThreadGroup group = (s != null) ? s.getThreadGroup() :
1501                 Thread.currentThread().getThreadGroup();
1502             synchronized (executorsLock) {
1503                 for (ThreadPoolExecutor e : executors.keySet()) {
1504                     DaemonThreadFactory tf =
1505                             (DaemonThreadFactory) e.getThreadFactory();
1506                     ThreadGroup tg = tf.getThreadGroup();
1507                     if (tg == group) {
1508                         executor = e;
1509                         break;
1510                     }
1511                 }
1512                 if (executor == null) {
1513                     executor = new ThreadPoolExecutor(
1514                             maximumPoolSize,
1515                             maximumPoolSize,
1516                             60L,
1517                             TimeUnit.SECONDS,
1518                             new LinkedBlockingQueue&lt;Runnable&gt;(),
1519                             new DaemonThreadFactory(&quot;ThreadGroup&lt;&quot; +
1520                             group.getName() + &quot;&gt; Executor&quot;, group));
1521                     executor.allowCoreThreadTimeOut(true);
1522                     executors.put(executor, null);
1523                 }
1524             }
1525         }
1526 
1527         /*
1528          * ------------------------------------------
1529          *  PUBLIC METHODS
1530          * ------------------------------------------
1531          */
1532 
1533         public Future&lt;?&gt; submit() {
1534             return executor.submit(this);
1535         }
1536 
1537         public void run() {
1538             final ScheduledFuture&lt;?&gt; sf;
1539             final AccessControlContext ac;
1540             synchronized (Monitor.this) {
1541                 sf = Monitor.this.schedulerFuture;
1542                 ac = Monitor.this.acc;
1543             }
1544             PrivilegedAction&lt;Void&gt; action = new PrivilegedAction&lt;Void&gt;() {
1545                 public Void run() {
1546                     if (Monitor.this.isActive()) {
1547                         final int an[] = alreadyNotifieds;
1548                         int index = 0;
1549                         for (ObservedObject o : Monitor.this.observedObjects) {
1550                             if (Monitor.this.isActive()) {
1551                                 Monitor.this.monitor(o, index++, an);
1552                             }
1553                         }
1554                     }
1555                     return null;
1556                 }
1557             };
1558             if (ac == null) {
1559                 throw new SecurityException(&quot;AccessControlContext cannot be null&quot;);
1560             }
1561             AccessController.doPrivileged(action, ac);
1562             synchronized (Monitor.this) {
1563                 if (Monitor.this.isActive() &amp;&amp;
1564                     Monitor.this.schedulerFuture == sf) {
1565                     Monitor.this.monitorFuture = null;
1566                     Monitor.this.schedulerFuture =
1567                         scheduler.schedule(Monitor.this.schedulerTask,
1568                                            Monitor.this.getGranularityPeriod(),
1569                                            TimeUnit.MILLISECONDS);
1570                 }
1571             }
1572         }
1573     }
1574 
1575     /**
1576      * Daemon thread factory used by the monitor executors.
1577      * &lt;P&gt;
1578      * This factory creates all new threads used by an Executor in
1579      * the same ThreadGroup. If there is a SecurityManager, it uses
1580      * the group of System.getSecurityManager(), else the group of
1581      * the thread instantiating this DaemonThreadFactory. Each new
1582      * thread is created as a daemon thread with priority
1583      * Thread.NORM_PRIORITY. New threads have names accessible via
1584      * Thread.getName() of &quot;{@literal JMX Monitor &lt;pool-name&gt; Pool [Thread-M]}&quot;,
1585      * where M is the sequence number of the thread created by this
1586      * factory.
1587      */
1588     private static class DaemonThreadFactory implements ThreadFactory {
1589         final ThreadGroup group;
1590         final AtomicInteger threadNumber = new AtomicInteger(1);
1591         final String namePrefix;
1592         static final String nameSuffix = &quot;]&quot;;
1593 
1594         public DaemonThreadFactory(String poolName) {
1595             SecurityManager s = System.getSecurityManager();
1596             group = (s != null) ? s.getThreadGroup() :
1597                                   Thread.currentThread().getThreadGroup();
1598             namePrefix = &quot;JMX Monitor &quot; + poolName + &quot; Pool [Thread-&quot;;
1599         }
1600 
1601         public DaemonThreadFactory(String poolName, ThreadGroup threadGroup) {
1602             group = threadGroup;
1603             namePrefix = &quot;JMX Monitor &quot; + poolName + &quot; Pool [Thread-&quot;;
1604         }
1605 
1606         public ThreadGroup getThreadGroup() {
1607             return group;
1608         }
1609 
1610         public Thread newThread(Runnable r) {
1611             Thread t = new Thread(
1612                 group,
1613                 r,
1614                 namePrefix + threadNumber.getAndIncrement() + nameSuffix,
1615                 0,
1616                 false
1617             );
1618 
1619             t.setDaemon(true);
1620             if (t.getPriority() != Thread.NORM_PRIORITY)
1621                 t.setPriority(Thread.NORM_PRIORITY);
1622             return t;
1623         }
1624     }
1625 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>