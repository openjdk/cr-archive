diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTool.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTool.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTool.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTool.java
@@ -112,12 +112,13 @@
 
     public static Declaration.Scoped filter(Declaration.Scoped decl, String... includedNames) {
         return Filter.filter(decl, includedNames);
     }
 
-    public static List<JavaFileObject> generate(Declaration.Scoped decl, String headerName, String targetPkg, List<String> libNames) {
-        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, libNames));
+    public static List<JavaFileObject> generate(Declaration.Scoped decl, String headerName,
+                boolean source, String targetPkg, List<String> libNames) {
+        return List.of(OutputFactory.generateWrapped(decl, headerName, source, targetPkg, libNames));
     }
 
     /**
      * Write resulting {@link JavaFileObject} instances into specified destination path.
      * @param dest the destination path.
@@ -247,11 +248,11 @@
             }
 
             Path output = Path.of(options.outputDir);
 
             List<JavaFileObject> files = generate(
-                toplevel, header.getFileName().toString(),
+                toplevel, header.getFileName().toString(), options.source,
                 options.targetPackage, options.libraryNames);
 
             write(output, !options.source, files);
         } catch (RuntimeException re) {
             err.println(re);
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ClassConstantHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ClassConstantHelper.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ClassConstantHelper.java
@@ -0,0 +1,527 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.org.objectweb.asm.ClassWriter;
+import jdk.internal.org.objectweb.asm.ConstantDynamic;
+import jdk.internal.org.objectweb.asm.Handle;
+import jdk.internal.org.objectweb.asm.MethodVisitor;
+import jdk.internal.org.objectweb.asm.Type;
+
+import javax.tools.JavaFileObject;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.Constable;
+import java.lang.constant.ConstantDesc;
+import java.lang.constant.ConstantDescs;
+import java.lang.constant.DirectMethodHandleDesc;
+import java.lang.constant.DirectMethodHandleDesc.Kind;
+import java.lang.constant.DynamicConstantDesc;
+import java.lang.constant.MethodHandleDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VarHandle;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Consumer;
+
+import static java.lang.constant.ConstantDescs.*;
+import static java.lang.invoke.MethodHandleInfo.*;
+import static java.lang.invoke.MethodType.methodType;
+import static jdk.internal.org.objectweb.asm.Opcodes.*;
+
+// generates ConstantHelper as java .class directly
+class ClassConstantHelper implements ConstantHelper {
+
+    private static final String INTR_OBJECT = Type.getInternalName(Object.class);
+
+    private static final ClassDesc CD_LIBRARIES = desc(LibraryLookup[].class);
+
+    private static final DirectMethodHandleDesc MH_MemoryLayout_varHandle = MethodHandleDesc.ofMethod(
+            Kind.INTERFACE_VIRTUAL,
+            desc(MemoryLayout.class),
+            "varHandle",
+            desc(methodType(
+                    VarHandle.class,
+                    Class.class,
+                    MemoryLayout.PathElement[].class))
+    );
+
+    private static final DirectMethodHandleDesc MH_PathElement_groupElement = MethodHandleDesc.ofMethod(
+            Kind.INTERFACE_STATIC,
+            desc(MemoryLayout.PathElement.class),
+            "groupElement",
+            desc(methodType(MemoryLayout.PathElement.class, String.class))
+    );
+
+    private static final DirectMethodHandleDesc MH_MemoryAddress_ofLong = MethodHandleDesc.ofMethod(
+            Kind.INTERFACE_STATIC,
+            desc(MemoryAddress.class),
+            "ofLong",
+            desc(methodType(MemoryAddress.class, long.class))
+    );
+
+    private static final DirectMethodHandleDesc MH_MemoryHandles_asAddressVarHandle = MethodHandleDesc.ofMethod(
+            Kind.STATIC,
+            desc(MemoryHandles.class),
+            "asAddressVarHandle",
+            desc(methodType(VarHandle.class, VarHandle.class))
+    );
+
+    private static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL = ConstantDescs.ofConstantBootstrap(
+            CD_ConstantBootstraps,
+            "getStaticFinal",
+            CD_Object,
+            CD_Class
+    );
+
+    private static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "TRUE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
+    private static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "FALSE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
+    private static final ClassDesc CD_PathElelemt = desc(MemoryLayout.PathElement.class);
+    private static final ClassDesc CD_MemoryAddress = desc(MemoryAddress.class);
+    private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);
+
+    private final DirectMethodHandleDesc MH_downcallHandle;
+    private final DirectMethodHandleDesc MH_lookupGlobalVariable;
+    private final DirectMethodHandleDesc MH_makeCString;
+
+    private ClassWriter cw;
+    private final String internalClassName;
+    private final ClassDesc CD_constantsHelper;
+    private final ConstantDesc LIBRARIES;
+
+    private final Map<String, DirectMethodHandleDesc> pool = new HashMap<>();
+
+    private static final Map<Class<?>, ClassDesc> CARRIERS = Map.ofEntries(
+            Map.entry(Byte.TYPE,                desc(Byte.TYPE)),
+            Map.entry(Short.TYPE,               desc(Short.TYPE)),
+            Map.entry(Character.TYPE,           desc(Character.TYPE)),
+            Map.entry(Integer.TYPE,             desc(Integer.TYPE)),
+            Map.entry(Long.TYPE,                desc(Long.TYPE)),
+            Map.entry(Float.TYPE,               desc(Float.TYPE)),
+            Map.entry(Double.TYPE,              desc(Double.TYPE)),
+            Map.entry(MemoryAddress.class,      desc(Long.TYPE))
+    );
+
+    ClassConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {
+        this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
+        String className = parentClassName + "$constants";
+        this.CD_constantsHelper = ClassDesc.of(className);
+        this.internalClassName = className.replace('.', '/');
+
+        this.MH_downcallHandle = findRuntimeHelperBootstrap(
+                runtimeHelper,
+                "downcallHandle",
+                methodType(
+                        MethodHandle.class,
+                        LibraryLookup[].class,
+                        String.class,
+                        String.class,
+                        FunctionDescriptor.class,
+                        boolean.class)
+        );
+        this.MH_lookupGlobalVariable = findRuntimeHelperBootstrap(
+                runtimeHelper,
+                "lookupGlobalVariable",
+                methodType(
+                        MemorySegment.class,
+                        LibraryLookup[].class,
+                        String.class,
+                        MemoryLayout.class)
+        );
+        this.MH_makeCString = findRuntimeHelperBootstrap(
+                cString,
+                "toCString",
+                methodType(
+                        MemorySegment.class,
+                        String.class)
+        );
+
+        this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(
+                runtimeHelper,
+                "libraries",
+                methodType(
+                        LibraryLookup[].class,
+                        String[].class)
+        ), libraryNames);
+
+        cw.visit(V15, ACC_PUBLIC, internalClassName, null, INTR_OBJECT, null);
+    }
+
+    private static DirectMethodHandleDesc findRuntimeHelperBootstrap(ClassDesc runtimeHelper, String name, MethodType type) {
+        return MethodHandleDesc.ofMethod(
+                Kind.STATIC,
+                runtimeHelper,
+                name,
+                desc(type)
+        );
+    }
+
+    @Override
+    public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {
+        return emitCondyGetter(javaName + "$LAYOUT", MemoryLayout.class, desc(layout));
+    }
+
+    @Override
+    public DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        return emitCondyGetter(javaName + "$VH", VarHandle.class, varHandleDesc(javaName, nativeName, layout, type, parentLayout));
+    }
+
+    @Override
+    public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
+        return emitCondyGetter(javaName + "$MH", MethodHandle.class, methodHandleDesc(nativeName, mtype, desc, varargs));
+    }
+
+    @Override
+    public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {
+        return emitCondyGetter(javaName + "$SEGMENT", MemorySegment.class, globalVarAddressDesc(nativeName, layout));
+    }
+
+    @Override
+    public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {
+        return emitCondyGetter(javaName + "$DESC", FunctionDescriptor.class, desc(fDesc));
+    }
+
+    @Override
+    public DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value) {
+        if (type == MemoryAddress.class) {
+            if (value instanceof Long) {
+                return emitCondyGetter(name, type, addressDesc((Long) value));
+            } else {
+                throw new IllegalStateException("Unhandled constant value type: " + value.getClass());
+            }
+        } else if (type == MemorySegment.class) {
+            if (value instanceof String) {
+                return emitCondyGetter(name, type, cStringDesc((String) value));
+            } else {
+                throw new IllegalStateException("Unhandled constant value type: " + value.getClass());
+            }
+        } else if (type.isPrimitive()) {
+            if (type == int.class || type == byte.class || type == short.class || type == char.class) {
+                return emitConIntGetter(name, type, ((Long) value).intValue());
+            } else if (type == float.class) {
+                return emitConFloatGetter(name, type, ((Double) value).floatValue());
+            } else if (type == long.class) {
+                return emitConLongGetter(name, type, (Long) value);
+            } else if (type == double.class) {
+                return emitConDoubleGetter(name, type, (Double) value);
+            } else { // boolean and void
+                throw new IllegalStateException("Unhandled primitive target type: " + type);
+            }
+        } else if (type == value.getClass() && value instanceof Constable) {
+            // Constable value that requires no conversion
+            return emitCondyGetter(name, type, desc((Constable) value));
+        } else {
+            System.out.println("Warning: Skipping constant generation for: " + name + " of type: " + type.getSimpleName()
+                + " with value: " + value + " of type: " + value.getClass());
+            return null;
+        }
+    }
+
+    @Override
+    public List<JavaFileObject> getClasses() {
+        cw.visitEnd();
+        byte[] bytes = cw.toByteArray();
+        cw = null;
+        return List.of(jfoFromByteArray(internalClassName, bytes));
+    }
+
+    // Utility
+
+    private static JavaFileObject jfoFromByteArray(String name, byte[] bytes) {
+        return InMemoryJavaCompiler.jfoFromByteArray(URI.create(name + ".class"), bytes);
+    }
+
+    private static String descriptorToInternalName(String s) {
+        return s.substring(1, s.length() - 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    private static <T extends ConstantDesc> T desc(Constable constable) {
+        return (T) constable.describeConstable().orElseThrow();
+    }
+
+    // ASM helpers
+
+    private static void emitConShort(MethodVisitor mv, short value) {
+        if (value >= -1 && value <= 5) {
+            mv.visitInsn(
+                switch (value) {
+                    case -1 -> ICONST_M1;
+                    case 0 -> ICONST_0;
+                    case 1 -> ICONST_1;
+                    case 2 -> ICONST_2;
+                    case 3 -> ICONST_3;
+                    case 4 -> ICONST_4;
+                    case 5 -> ICONST_5;
+                    default -> throw new IllegalStateException("Should not reach here");
+                });
+        } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
+            mv.visitIntInsn(BIPUSH, value);
+        } else {
+            mv.visitIntInsn(SIPUSH, value);
+        }
+    }
+
+    private static void emitConInt(MethodVisitor mv, int value) {
+        if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
+            emitConShort(mv, (short) value);
+        } else {
+            mv.visitLdcInsn(value);
+        }
+    }
+
+    private static void emitConLong(MethodVisitor mv, long value) {
+        if (value == 0) {
+            mv.visitInsn(LCONST_0);
+        } else if (value == 1) {
+            mv.visitInsn(LCONST_1);
+        } else if (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {
+            // saves a constant pool slot
+            emitConInt(mv, (int) value);
+            mv.visitInsn(I2L);
+        } else {
+            mv.visitLdcInsn(value);
+        }
+    }
+
+    private static void emitConFloat(MethodVisitor mv, float value) {
+        if (value == 0.0F) {
+            mv.visitInsn(FCONST_0);
+        } else if (value == 1.0F) {
+            mv.visitInsn(FCONST_1);
+        } else if (value == 2.0F) {
+            mv.visitInsn(FCONST_2);
+        } else if (value == (short) value) {
+            emitConShort(mv, (short) value);
+            mv.visitInsn(I2F);
+        } else {
+            mv.visitLdcInsn(value);
+        }
+    }
+
+    private static void emitConDouble(MethodVisitor mv, double value) {
+        if (value == 0.0D) {
+            mv.visitInsn(DCONST_0);
+        } else if (value == 1.0D) {
+            mv.visitInsn(DCONST_1);
+        } else if (value == (short) value) {
+            emitConShort(mv, (short) value);
+            mv.visitInsn(I2D);
+        } else if (value >= Float.MIN_VALUE && value <= Float.MAX_VALUE) {
+            // saves a constant pool slot
+            mv.visitLdcInsn((float) value);
+            mv.visitInsn(F2D);
+        } else {
+            mv.visitLdcInsn(value);
+        }
+    }
+
+    private DirectMethodHandleDesc emitGetter(String name, Class<?> type, Consumer<MethodVisitor> action) {
+        return pool.computeIfAbsent(name, nameKey -> {
+            MethodType mt = methodType(type);
+            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, nameKey, mt.descriptorString(), null, null);
+            mv.visitCode();
+            action.accept(mv);
+            emitReturn(mv, type);
+            mv.visitMaxs(-1, -1);
+            mv.visitEnd();
+            return MethodHandleDesc.ofMethod(
+                    Kind.STATIC,
+                    CD_constantsHelper,
+                    nameKey,
+                    mt.describeConstable().orElseThrow()
+            );
+        });
+    }
+
+    private DirectMethodHandleDesc emitConDoubleGetter(String name, Class<?> type, double value) {
+        return emitGetter(name, type, mv -> emitConDouble(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitConLongGetter(String name, Class<?> type, long value) {
+        return emitGetter(name, type, mv -> emitConLong(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitConFloatGetter(String name, Class<?> type, float value) {
+        return emitGetter(name, type, mv -> emitConFloat(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitConIntGetter(String name, Class<?> type, int value) {
+        return emitGetter(name, type, mv -> emitConInt(mv, value));
+    }
+
+    private DirectMethodHandleDesc emitCondyGetter(String name, Class<?> type, ConstantDesc desc) {
+        return emitGetter(name, type, mv -> mv.visitLdcInsn(asmConstant(desc)));
+    }
+
+    private static void emitReturn(MethodVisitor mv, Class<?> type) {
+        if (type == int.class
+                || type == short.class
+                || type == byte.class
+                || type == char.class
+                || type == boolean.class) {
+            mv.visitInsn(IRETURN);
+        } else if (type == long.class) {
+            mv.visitInsn(LRETURN);
+        } else if (type == float.class) {
+            mv.visitInsn(FRETURN);
+        } else if (type == double.class) {
+            mv.visitInsn(DRETURN);
+        } else if (type == void.class) {
+            mv.visitInsn(RETURN);
+        } else if (Object.class.isAssignableFrom(type)) {
+            mv.visitInsn(ARETURN);
+        } else {
+            throw new IllegalArgumentException("Type not handled: " + type);
+        }
+    }
+
+    // Condy factories
+
+    private static ConstantDesc librariesDesc(DirectMethodHandleDesc MH_libraries, String[] libraryNames) {
+        ConstantDesc[] args = new ConstantDesc[libraryNames.length + 1];
+        args[0] = MH_libraries;
+        System.arraycopy(libraryNames, 0, args, 1, libraryNames.length);
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "libraries", CD_LIBRARIES, args);
+    }
+
+    private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier, ConstantDesc path) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "VH_" + name, CD_VarHandle, MH_MemoryLayout_varHandle, memoryLayout, carrier, path);
+    }
+
+    private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "VH_" + name, CD_VarHandle, MH_MemoryLayout_varHandle, memoryLayout, carrier);
+    }
+
+    private static ConstantDesc addressVarHandleDesc(String name, ConstantDesc varHandle) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "VH_" + name, CD_VarHandle, MH_MemoryHandles_asAddressVarHandle, varHandle);
+    }
+
+    private static ConstantDesc groupElementDesc(String fieldName) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "groupElement_" + fieldName, CD_PathElelemt, MH_PathElement_groupElement, fieldName);
+    }
+
+    private static ConstantDesc varHandleDesc(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        var carrier = CARRIERS.get(type);
+        if (carrier == null) {
+            carrier = desc(type);
+        }
+
+        var varHandle = parentLayout != null ?
+                varHandleDesc(javaName, desc(parentLayout), carrier, groupElementDesc(nativeName)) :
+                varHandleDesc(javaName, desc(layout), carrier);
+
+        return type == MemoryAddress.class ? addressVarHandleDesc(javaName, varHandle) : varHandle;
+    }
+
+    private ConstantDesc globalVarAddressDesc(String name, MemoryLayout layout) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "ADDR_" + name, CD_MemorySegment, MH_lookupGlobalVariable, LIBRARIES, name, desc(layout));
+    }
+
+    private ConstantDesc addressDesc(long value) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MA_" + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);
+    }
+
+    private ConstantDesc cStringDesc(String value) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "CSTRING", CD_MemorySegment, MH_makeCString, value);
+    }
+
+    private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {
+        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MH_" + name, CD_MethodHandle, MH_downcallHandle,
+            LIBRARIES,
+            name,
+            mtype.descriptorString(),
+            desc(funcDesc),
+            varargs ? TRUE : FALSE);
+    }
+
+    // To ASM constant translation
+
+    private static Handle asmHandle(DirectMethodHandleDesc desc) {
+        int tag = switch(desc.refKind()) {
+            case REF_getField         -> H_GETFIELD;
+            case REF_getStatic        -> H_GETSTATIC;
+            case REF_putField         -> H_PUTFIELD;
+            case REF_putStatic        -> H_PUTSTATIC;
+            case REF_invokeVirtual    -> H_INVOKEVIRTUAL;
+            case REF_invokeStatic     -> H_INVOKESTATIC;
+            case REF_invokeSpecial    -> H_INVOKESPECIAL;
+            case REF_newInvokeSpecial -> H_NEWINVOKESPECIAL;
+            case REF_invokeInterface  -> H_INVOKEINTERFACE;
+            default -> throw new InternalError("Should not reach here");
+        };
+        return new Handle(tag,
+                descriptorToInternalName(desc.owner().descriptorString()),
+                desc.methodName(),
+                desc.lookupDescriptor(),
+                desc.isOwnerInterface());
+    }
+
+    private static ConstantDynamic asmCondy(DynamicConstantDesc<?> condy) {
+        return new ConstantDynamic(
+                condy.constantName(),
+                condy.constantType().descriptorString(),
+                asmHandle(condy.bootstrapMethod()),
+                asmConstantArgs(condy.bootstrapArgs()));
+    }
+
+    private static Object[] asmConstantArgs(ConstantDesc[] descs) {
+        Object[] objects = new Object[descs.length];
+        for (int i = 0; i < objects.length; i++) {
+            objects[i] = asmConstant(descs[i]);
+        }
+        return objects;
+    }
+
+    private static Object asmConstant(ConstantDesc desc) {
+        if (desc instanceof DynamicConstantDesc<?>) {
+            return asmCondy((DynamicConstantDesc<?>) desc);
+        } else if (desc instanceof Integer
+            || desc instanceof Float
+            || desc instanceof Long
+            || desc instanceof Double
+            || desc instanceof String) {
+            return desc;
+        } else if (desc instanceof ClassDesc) {
+            // Primitives should be caught above
+            return Type.getType(((ClassDesc) desc).descriptorString());
+        } else if (desc instanceof MethodTypeDesc) {
+            return Type.getMethodType(((MethodTypeDesc) desc).descriptorString());
+        } else if (desc instanceof DirectMethodHandleDesc) {
+            return asmHandle((DirectMethodHandleDesc) desc);
+        }
+        throw new IllegalArgumentException("ConstantDesc type not handled: " + desc);
+    }
+
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ConstantHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ConstantHelper.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ConstantHelper.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ConstantHelper.java
@@ -23,505 +23,31 @@
  * questions.
  */
 package jdk.internal.jextract.impl;
 
 import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.LibraryLookup;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.internal.org.objectweb.asm.ClassWriter;
-import jdk.internal.org.objectweb.asm.ConstantDynamic;
-import jdk.internal.org.objectweb.asm.Handle;
-import jdk.internal.org.objectweb.asm.MethodVisitor;
-import jdk.internal.org.objectweb.asm.Type;
 
 import javax.tools.JavaFileObject;
-import javax.tools.SimpleJavaFileObject;
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
 import java.lang.constant.ClassDesc;
-import java.lang.constant.Constable;
-import java.lang.constant.ConstantDesc;
-import java.lang.constant.ConstantDescs;
 import java.lang.constant.DirectMethodHandleDesc;
-import java.lang.constant.DirectMethodHandleDesc.Kind;
-import java.lang.constant.DynamicConstantDesc;
-import java.lang.constant.MethodHandleDesc;
-import java.lang.constant.MethodTypeDesc;
-import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
-import java.lang.invoke.VarHandle;
-import java.net.URI;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
-import java.util.function.Consumer;
 
-import static java.lang.constant.ConstantDescs.*;
-import static java.lang.invoke.MethodHandleInfo.*;
-import static java.lang.invoke.MethodType.methodType;
-import static jdk.internal.org.objectweb.asm.Opcodes.*;
-
-public class ConstantHelper {
-
-    private static final String INTR_OBJECT = Type.getInternalName(Object.class);
-
-    private static final ClassDesc CD_LIBRARIES = desc(LibraryLookup[].class);
-
-    private static final DirectMethodHandleDesc MH_MemoryLayout_varHandle = MethodHandleDesc.ofMethod(
-            Kind.INTERFACE_VIRTUAL,
-            desc(MemoryLayout.class),
-            "varHandle",
-            desc(methodType(
-                    VarHandle.class,
-                    Class.class,
-                    MemoryLayout.PathElement[].class))
-    );
-
-    private static final DirectMethodHandleDesc MH_PathElement_groupElement = MethodHandleDesc.ofMethod(
-            Kind.INTERFACE_STATIC,
-            desc(MemoryLayout.PathElement.class),
-            "groupElement",
-            desc(methodType(MemoryLayout.PathElement.class, String.class))
-    );
-
-    private static final DirectMethodHandleDesc MH_MemoryAddress_ofLong = MethodHandleDesc.ofMethod(
-            Kind.INTERFACE_STATIC,
-            desc(MemoryAddress.class),
-            "ofLong",
-            desc(methodType(MemoryAddress.class, long.class))
-    );
-
-    private static final DirectMethodHandleDesc MH_MemoryHandles_asAddressVarHandle = MethodHandleDesc.ofMethod(
-            Kind.STATIC,
-            desc(MemoryHandles.class),
-            "asAddressVarHandle",
-            desc(methodType(VarHandle.class, VarHandle.class))
-    );
-
-    private static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL = ConstantDescs.ofConstantBootstrap(
-            CD_ConstantBootstraps,
-            "getStaticFinal",
-            CD_Object,
-            CD_Class
-    );
-
-    private static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "TRUE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
-    private static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, "FALSE", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);
-    private static final ClassDesc CD_PathElelemt = desc(MemoryLayout.PathElement.class);
-    private static final ClassDesc CD_MemoryAddress = desc(MemoryAddress.class);
-    private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);
-
-    private final DirectMethodHandleDesc MH_downcallHandle;
-    private final DirectMethodHandleDesc MH_lookupGlobalVariable;
-    private final DirectMethodHandleDesc MH_makeCString;
-
-    private ClassWriter cw;
-    private final String internalClassName;
-    private final ClassDesc CD_constantsHelper;
-    private final ConstantDesc LIBRARIES;
-
-    private final Map<String, DirectMethodHandleDesc> pool = new HashMap<>();
-
-    private static final Map<Class<?>, ClassDesc> CARRIERS = Map.ofEntries(
-            Map.entry(Byte.TYPE,                desc(Byte.TYPE)),
-            Map.entry(Short.TYPE,               desc(Short.TYPE)),
-            Map.entry(Character.TYPE,           desc(Character.TYPE)),
-            Map.entry(Integer.TYPE,             desc(Integer.TYPE)),
-            Map.entry(Long.TYPE,                desc(Long.TYPE)),
-            Map.entry(Float.TYPE,               desc(Float.TYPE)),
-            Map.entry(Double.TYPE,              desc(Double.TYPE)),
-            Map.entry(MemoryAddress.class,      desc(Long.TYPE))
-    );
-
-    public ConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {
-        this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
-        String className = parentClassName + "$constants";
-        this.CD_constantsHelper = ClassDesc.of(className);
-        this.internalClassName = className.replace('.', '/');
-
-        this.MH_downcallHandle = findRuntimeHelperBootstrap(
-                runtimeHelper,
-                "downcallHandle",
-                methodType(
-                        MethodHandle.class,
-                        LibraryLookup[].class,
-                        String.class,
-                        String.class,
-                        FunctionDescriptor.class,
-                        boolean.class)
-        );
-        this.MH_lookupGlobalVariable = findRuntimeHelperBootstrap(
-                runtimeHelper,
-                "lookupGlobalVariable",
-                methodType(
-                        MemorySegment.class,
-                        LibraryLookup[].class,
-                        String.class,
-                        MemoryLayout.class)
-        );
-        this.MH_makeCString = findRuntimeHelperBootstrap(
-                cString,
-                "toCString",
-                methodType(
-                        MemorySegment.class,
-                        String.class)
-        );
-
-        this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(
-                runtimeHelper,
-                "libraries",
-                methodType(
-                        LibraryLookup[].class,
-                        String[].class)
-        ), libraryNames);
-
-        cw.visit(V15, ACC_PUBLIC, internalClassName, null, INTR_OBJECT, null);
-    }
-
-    private static DirectMethodHandleDesc findRuntimeHelperBootstrap(ClassDesc runtimeHelper, String name, MethodType type) {
-        return MethodHandleDesc.ofMethod(
-                Kind.STATIC,
-                runtimeHelper,
-                name,
-                desc(type)
-        );
-    }
-
-    public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {
-        return emitCondyGetter(javaName + "$LAYOUT", MemoryLayout.class, desc(layout));
-    }
-
-    public DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        return emitCondyGetter(javaName + "$VH", VarHandle.class, varHandleDesc(javaName, nativeName, layout, type, parentLayout));
-    }
-
-    public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
-        return emitCondyGetter(javaName + "$MH", MethodHandle.class, methodHandleDesc(nativeName, mtype, desc, varargs));
-    }
-
-    public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {
-        return emitCondyGetter(javaName + "$SEGMENT", MemorySegment.class, globalVarAddressDesc(nativeName, layout));
-    }
-
-    public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {
-        return emitCondyGetter(javaName + "$DESC", FunctionDescriptor.class, desc(fDesc));
-    }
-
-    public DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value) {
-        if (type == MemoryAddress.class) {
-            if (value instanceof Long) {
-                return emitCondyGetter(name, type, addressDesc((Long) value));
-            } else {
-                throw new IllegalStateException("Unhandled constant value type: " + value.getClass());
-            }
-        } else if (type == MemorySegment.class) {
-            if (value instanceof String) {
-                return emitCondyGetter(name, type, cStringDesc((String) value));
-            } else {
-                throw new IllegalStateException("Unhandled constant value type: " + value.getClass());
-            }
-        } else if (type.isPrimitive()) {
-            if (type == int.class || type == byte.class || type == short.class || type == char.class) {
-                return emitConIntGetter(name, type, ((Long) value).intValue());
-            } else if (type == float.class) {
-                return emitConFloatGetter(name, type, ((Double) value).floatValue());
-            } else if (type == long.class) {
-                return emitConLongGetter(name, type, (Long) value);
-            } else if (type == double.class) {
-                return emitConDoubleGetter(name, type, (Double) value);
-            } else { // boolean and void
-                throw new IllegalStateException("Unhandled primitive target type: " + type);
-            }
-        } else if (type == value.getClass() && value instanceof Constable) {
-            // Constable value that requires no conversion
-            return emitCondyGetter(name, type, desc((Constable) value));
-        } else {
-            System.out.println("Warning: Skipping constant generation for: " + name + " of type: " + type.getSimpleName()
-                + " with value: " + value + " of type: " + value.getClass());
-            return null;
-        }
-    }
-
-    public List<JavaFileObject> getClasses() {
-        cw.visitEnd();
-        byte[] bytes = cw.toByteArray();
-        cw = null;
-        return List.of(jfoFromByteArray(internalClassName, bytes));
-    }
-
-    // Utility
-
-    private static JavaFileObject jfoFromByteArray(String name, byte[] bytes) {
-        return new SimpleJavaFileObject(URI.create(name + ".class"), JavaFileObject.Kind.CLASS) {
-            @Override
-            public InputStream openInputStream() {
-                return new ByteArrayInputStream(bytes);
-            }
-        };
-    }
-
-    private static String descriptorToInternalName(String s) {
-        return s.substring(1, s.length() - 1);
-    }
-
-    @SuppressWarnings("unchecked")
-    private static <T extends ConstantDesc> T desc(Constable constable) {
-        return (T) constable.describeConstable().orElseThrow();
-    }
-
-    // ASM helpers
-
-    private static void emitConShort(MethodVisitor mv, short value) {
-        if (value >= -1 && value <= 5) {
-            mv.visitInsn(
-                switch (value) {
-                    case -1 -> ICONST_M1;
-                    case 0 -> ICONST_0;
-                    case 1 -> ICONST_1;
-                    case 2 -> ICONST_2;
-                    case 3 -> ICONST_3;
-                    case 4 -> ICONST_4;
-                    case 5 -> ICONST_5;
-                    default -> throw new IllegalStateException("Should not reach here");
-                });
-        } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
-            mv.visitIntInsn(BIPUSH, value);
-        } else {
-            mv.visitIntInsn(SIPUSH, value);
-        }
-    }
-
-    private static void emitConInt(MethodVisitor mv, int value) {
-        if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
-            emitConShort(mv, (short) value);
-        } else {
-            mv.visitLdcInsn(value);
-        }
-    }
-
-    private static void emitConLong(MethodVisitor mv, long value) {
-        if (value == 0) {
-            mv.visitInsn(LCONST_0);
-        } else if (value == 1) {
-            mv.visitInsn(LCONST_1);
-        } else if (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {
-            // saves a constant pool slot
-            emitConInt(mv, (int) value);
-            mv.visitInsn(I2L);
-        } else {
-            mv.visitLdcInsn(value);
-        }
-    }
-
-    private static void emitConFloat(MethodVisitor mv, float value) {
-        if (value == 0.0F) {
-            mv.visitInsn(FCONST_0);
-        } else if (value == 1.0F) {
-            mv.visitInsn(FCONST_1);
-        } else if (value == 2.0F) {
-            mv.visitInsn(FCONST_2);
-        } else if (value == (short) value) {
-            emitConShort(mv, (short) value);
-            mv.visitInsn(I2F);
+interface ConstantHelper {
+    DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout);
+    DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout);
+    DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs);
+    DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout);
+    DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc);
+    DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value);
+    List<JavaFileObject> getClasses();
+
+    static ConstantHelper make(boolean source, String parentClassName, ClassDesc runtimeHelper,
+                               ClassDesc cString, String[] libraryNames) {
+        if (source) {
+            return new SourceConstantHelper(parentClassName, libraryNames);
         } else {
-            mv.visitLdcInsn(value);
+            return new ClassConstantHelper(parentClassName, runtimeHelper, cString, libraryNames);
         }
     }
-
-    private static void emitConDouble(MethodVisitor mv, double value) {
-        if (value == 0.0D) {
-            mv.visitInsn(DCONST_0);
-        } else if (value == 1.0D) {
-            mv.visitInsn(DCONST_1);
-        } else if (value == (short) value) {
-            emitConShort(mv, (short) value);
-            mv.visitInsn(I2D);
-        } else if (value >= Float.MIN_VALUE && value <= Float.MAX_VALUE) {
-            // saves a constant pool slot
-            mv.visitLdcInsn((float) value);
-            mv.visitInsn(F2D);
-        } else {
-            mv.visitLdcInsn(value);
-        }
-    }
-
-    private DirectMethodHandleDesc emitGetter(String name, Class<?> type, Consumer<MethodVisitor> action) {
-        return pool.computeIfAbsent(name, nameKey -> {
-            MethodType mt = methodType(type);
-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, nameKey, mt.descriptorString(), null, null);
-            mv.visitCode();
-            action.accept(mv);
-            emitReturn(mv, type);
-            mv.visitMaxs(-1, -1);
-            mv.visitEnd();
-            return MethodHandleDesc.ofMethod(
-                    Kind.STATIC,
-                    CD_constantsHelper,
-                    nameKey,
-                    mt.describeConstable().orElseThrow()
-            );
-        });
-    }
-
-    private DirectMethodHandleDesc emitConDoubleGetter(String name, Class<?> type, double value) {
-        return emitGetter(name, type, mv -> emitConDouble(mv, value));
-    }
-
-    private DirectMethodHandleDesc emitConLongGetter(String name, Class<?> type, long value) {
-        return emitGetter(name, type, mv -> emitConLong(mv, value));
-    }
-
-    private DirectMethodHandleDesc emitConFloatGetter(String name, Class<?> type, float value) {
-        return emitGetter(name, type, mv -> emitConFloat(mv, value));
-    }
-
-    private DirectMethodHandleDesc emitConIntGetter(String name, Class<?> type, int value) {
-        return emitGetter(name, type, mv -> emitConInt(mv, value));
-    }
-
-    private DirectMethodHandleDesc emitCondyGetter(String name, Class<?> type, ConstantDesc desc) {
-        return emitGetter(name, type, mv -> mv.visitLdcInsn(asmConstant(desc)));
-    }
-
-    private static void emitReturn(MethodVisitor mv, Class<?> type) {
-        if (type == int.class
-                || type == short.class
-                || type == byte.class
-                || type == char.class
-                || type == boolean.class) {
-            mv.visitInsn(IRETURN);
-        } else if (type == long.class) {
-            mv.visitInsn(LRETURN);
-        } else if (type == float.class) {
-            mv.visitInsn(FRETURN);
-        } else if (type == double.class) {
-            mv.visitInsn(DRETURN);
-        } else if (type == void.class) {
-            mv.visitInsn(RETURN);
-        } else if (Object.class.isAssignableFrom(type)) {
-            mv.visitInsn(ARETURN);
-        } else {
-            throw new IllegalArgumentException("Type not handled: " + type);
-        }
-    }
-
-    // Condy factories
-
-    private static ConstantDesc librariesDesc(DirectMethodHandleDesc MH_libraries, String[] libraryNames) {
-        ConstantDesc[] args = new ConstantDesc[libraryNames.length + 1];
-        args[0] = MH_libraries;
-        System.arraycopy(libraryNames, 0, args, 1, libraryNames.length);
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "libraries", CD_LIBRARIES, args);
-    }
-
-    private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier, ConstantDesc path) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "VH_" + name, CD_VarHandle, MH_MemoryLayout_varHandle, memoryLayout, carrier, path);
-    }
-
-    private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "VH_" + name, CD_VarHandle, MH_MemoryLayout_varHandle, memoryLayout, carrier);
-    }
-
-    private static ConstantDesc addressVarHandleDesc(String name, ConstantDesc varHandle) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "VH_" + name, CD_VarHandle, MH_MemoryHandles_asAddressVarHandle, varHandle);
-    }
-
-    private static ConstantDesc groupElementDesc(String fieldName) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "groupElement_" + fieldName, CD_PathElelemt, MH_PathElement_groupElement, fieldName);
-    }
-
-    private static ConstantDesc varHandleDesc(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
-        var carrier = CARRIERS.get(type);
-        if (carrier == null) {
-            carrier = desc(type);
-        }
-
-        var varHandle = parentLayout != null ?
-                varHandleDesc(javaName, desc(parentLayout), carrier, groupElementDesc(nativeName)) :
-                varHandleDesc(javaName, desc(layout), carrier);
-
-        return type == MemoryAddress.class ? addressVarHandleDesc(javaName, varHandle) : varHandle;
-    }
-
-    private ConstantDesc globalVarAddressDesc(String name, MemoryLayout layout) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "ADDR_" + name, CD_MemorySegment, MH_lookupGlobalVariable, LIBRARIES, name, desc(layout));
-    }
-
-    private ConstantDesc addressDesc(long value) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MA_" + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);
-    }
-
-    private ConstantDesc cStringDesc(String value) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "CSTRING", CD_MemorySegment, MH_makeCString, value);
-    }
-
-    private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {
-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, "MH_" + name, CD_MethodHandle, MH_downcallHandle,
-            LIBRARIES,
-            name,
-            mtype.descriptorString(),
-            desc(funcDesc),
-            varargs ? TRUE : FALSE);
-    }
-
-    // To ASM constant translation
-
-    private static Handle asmHandle(DirectMethodHandleDesc desc) {
-        int tag = switch(desc.refKind()) {
-            case REF_getField         -> H_GETFIELD;
-            case REF_getStatic        -> H_GETSTATIC;
-            case REF_putField         -> H_PUTFIELD;
-            case REF_putStatic        -> H_PUTSTATIC;
-            case REF_invokeVirtual    -> H_INVOKEVIRTUAL;
-            case REF_invokeStatic     -> H_INVOKESTATIC;
-            case REF_invokeSpecial    -> H_INVOKESPECIAL;
-            case REF_newInvokeSpecial -> H_NEWINVOKESPECIAL;
-            case REF_invokeInterface  -> H_INVOKEINTERFACE;
-            default -> throw new InternalError("Should not reach here");
-        };
-        return new Handle(tag,
-                descriptorToInternalName(desc.owner().descriptorString()),
-                desc.methodName(),
-                desc.lookupDescriptor(),
-                desc.isOwnerInterface());
-    }
-
-    private static ConstantDynamic asmCondy(DynamicConstantDesc<?> condy) {
-        return new ConstantDynamic(
-                condy.constantName(),
-                condy.constantType().descriptorString(),
-                asmHandle(condy.bootstrapMethod()),
-                asmConstantArgs(condy.bootstrapArgs()));
-    }
-
-    private static Object[] asmConstantArgs(ConstantDesc[] descs) {
-        Object[] objects = new Object[descs.length];
-        for (int i = 0; i < objects.length; i++) {
-            objects[i] = asmConstant(descs[i]);
-        }
-        return objects;
-    }
-
-    private static Object asmConstant(ConstantDesc desc) {
-        if (desc instanceof DynamicConstantDesc<?>) {
-            return asmCondy((DynamicConstantDesc<?>) desc);
-        } else if (desc instanceof Integer
-            || desc instanceof Float
-            || desc instanceof Long
-            || desc instanceof Double
-            || desc instanceof String) {
-            return desc;
-        } else if (desc instanceof ClassDesc) {
-            // Primitives should be caught above
-            return Type.getType(((ClassDesc) desc).descriptorString());
-        } else if (desc instanceof MethodTypeDesc) {
-            return Type.getMethodType(((MethodTypeDesc) desc).descriptorString());
-        } else if (desc instanceof DirectMethodHandleDesc) {
-            return asmHandle((DirectMethodHandleDesc) desc);
-        }
-        throw new IllegalArgumentException("ConstantDesc type not handled: " + desc);
-    }
-
 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/HeaderBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/HeaderBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/HeaderBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/HeaderBuilder.java
@@ -25,19 +25,16 @@
 package jdk.internal.jextract.impl;
 
 import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.Type;
 
 import javax.tools.JavaFileObject;
 import java.lang.invoke.MethodType;
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 
 /**
  * A helper class to generate header interface class in source form.
  * After aggregating various constituents of a .java source, build
  * method is called to get overall generated source string.
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/InMemoryJavaCompiler.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/InMemoryJavaCompiler.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/InMemoryJavaCompiler.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/InMemoryJavaCompiler.java
@@ -30,13 +30,11 @@
 import javax.tools.JavaCompiler;
 import javax.tools.JavaFileManager;
 import javax.tools.JavaFileObject;
 import javax.tools.SimpleJavaFileObject;
 import javax.tools.ToolProvider;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.StringWriter;
+import java.io.*;
 import java.io.Writer;
 import java.net.URI;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -55,22 +53,45 @@
             throw new RuntimeException("In memory compilation failed: " + writer.toString());
         }
         return fileManager.getCompiledFiles();
     }
 
+    static JavaFileObject jfoFromByteArray(URI uri, byte[] bytes) {
+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {
+            @Override
+            public InputStream openInputStream() {
+                return new ByteArrayInputStream(bytes);
+            }
+        };
+    }
+
+    static JavaFileObject jfoFromString(URI uri, String contents) {
+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {
+            @Override
+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+                return contents;
+            }
+        };
+    }
+
     // Wraper for class byte array
     private static class ClassFile extends SimpleJavaFileObject {
         private final ByteArrayOutputStream baos = new ByteArrayOutputStream();
 
         protected ClassFile(String name) {
-            super(URI.create("memo:///" + name.replace('.', '/') + Kind.CLASS.extension), Kind.CLASS);
+            super(URI.create(name.replace('.', '/') + Kind.CLASS.extension), Kind.CLASS);
         }
 
         @Override
-        public ByteArrayOutputStream openOutputStream() { return this.baos; }
+        public ByteArrayOutputStream openOutputStream() {
+            return this.baos;
+        }
 
-        byte[] toByteArray() { return baos.toByteArray(); }
+        @Override
+        public InputStream openInputStream() {
+            return new ByteArrayInputStream(baos.toByteArray());
+        }
     }
 
     // File manager which spawns ClassFile instances on demand
     private static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {
         private final List<JavaFileObject> compiled = new ArrayList<>();
@@ -79,11 +100,11 @@
             super(fileManager);
         }
 
         @Override
         public JavaFileObject getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) throws IOException {
-            JavaFileObject out = super.getJavaFileForOutput(location, name, kind, source);
+            JavaFileObject out = new ClassFile(name);
             compiled.add(out);
             return out;
         }
 
         public List<JavaFileObject> getCompiledFiles() {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JavaSourceBuilder.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JavaSourceBuilder.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JavaSourceBuilder.java
@@ -24,13 +24,11 @@
  */
 package jdk.internal.jextract.impl;
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.jextract.Declaration;
 
-import javax.tools.JavaFileObject;
 import java.lang.constant.ClassDesc;
 import java.lang.constant.DirectMethodHandleDesc;
 import java.lang.invoke.MethodType;
 import java.util.HashSet;
 import java.util.Set;
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/OutputFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/OutputFactory.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/OutputFactory.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/OutputFactory.java
@@ -28,11 +28,10 @@
 import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.Type;
 import jdk.incubator.jextract.Type.Primitive;
 
 import javax.tools.JavaFileObject;
-import javax.tools.SimpleJavaFileObject;
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.lang.constant.ClassDesc;
 import java.lang.invoke.MethodType;
 import java.net.URI;
@@ -87,14 +86,15 @@
     // have we seen this Function earlier?
     protected boolean functionSeen(Declaration.Function tree) {
         return !functions.add(tree);
     }
 
-    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName, String pkgName, List<String> libraryNames) {
+    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName, boolean source,
+                String pkgName, List<String> libraryNames) {
         String clsName = Utils.javaSafeIdentifier(headerName.replace(".h", "_h"), true);
         String qualName = pkgName.isEmpty() ? clsName : pkgName + "." + clsName;
-        ConstantHelper constantHelper = new ConstantHelper(qualName,
+        ConstantHelper constantHelper = ConstantHelper.make(source, qualName,
                 ClassDesc.of(pkgName, "RuntimeHelper"), ClassDesc.of("jdk.incubator.foreign", "CSupport"),
                 libraryNames.toArray(String[]::new));
         return new OutputFactory(pkgName,
                 new HeaderBuilder(clsName, pkgName, constantHelper), constantHelper).generate(decl);
     }
@@ -137,11 +137,11 @@
         toplevelBuilder.classEnd();
         try {
             List<JavaFileObject> files = new ArrayList<>();
             files.add(toplevelBuilder.build());
             files.addAll(constantHelper.getClasses());
-            files.add(fileFromString(pkgName,"RuntimeHelper", getRuntimeHelperSource()));
+            files.add(jfoFromString(pkgName,"RuntimeHelper", getRuntimeHelperSource()));
             return files.toArray(new JavaFileObject[0]);
         } catch (IOException ex) {
             throw new UncheckedIOException(ex);
         } catch (URISyntaxException ex2) {
             throw new RuntimeException(ex2);
@@ -169,18 +169,13 @@
             default-> false;
         };
         return TypeTranslator.layoutToClass(isFloat, layout);
     }
 
-    private JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
+    private JavaFileObject jfoFromString(String pkgName, String clsName, String contents) {
         String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
-        return new SimpleJavaFileObject(URI.create(pkgPrefix + clsName + ".java"), JavaFileObject.Kind.SOURCE) {
-            @Override
-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
-                return contents;
-            }
-        };
+        return InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + clsName + ".java"), contents);
     }
 
     @Override
     public Void visitConstant(Declaration.Constant constant, Declaration parent) {
         if (!constants.add(constant.name())) {
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/SourceConstantHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/SourceConstantHelper.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/SourceConstantHelper.java
@@ -0,0 +1,506 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.*;
+
+import javax.tools.JavaFileObject;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.DirectMethodHandleDesc;
+import java.lang.constant.MethodHandleDesc;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VarHandle;
+import java.net.URI;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+
+import static java.lang.invoke.MethodType.methodType;
+
+// generates ConstantHelper as java source
+class SourceConstantHelper implements ConstantHelper {
+    private static final String PRIVATE_MODS = "private static final ";
+    private static final String ABI_CLASS_ATTR;
+
+    static {
+        String abi = CSupport.getSystemLinker().name();
+        ABI_CLASS_ATTR = switch (abi) {
+            case CSupport.SysV.NAME -> CSupport.SysV.CLASS_ATTRIBUTE_NAME;
+            case CSupport.Win64.NAME -> CSupport.Win64.CLASS_ATTRIBUTE_NAME;
+            case CSupport.AArch64.NAME -> CSupport.AArch64.CLASS_ATTRIBUTE_NAME;
+            default -> throw new UnsupportedOperationException("Unsupported Foreign Linker: " + abi);
+        };
+    }
+
+    // set of names generates already
+    private static final Set<String> namesGenerated = new HashSet<>();
+    // code buffer
+    private final StringBuilder sb = new StringBuilder();
+    // current line alignment (number of 4-spaces)
+    private int align;
+    private final String pkgName;
+    private final String className;
+    private final ClassDesc CD_constantsHelper;
+
+    SourceConstantHelper(String parentClassName, String[] libraryNames) {
+        int idx = parentClassName.lastIndexOf('.');
+        this.pkgName = idx == -1? "" : parentClassName.substring(0, idx);
+        String clsName = parentClassName.substring(idx + 1);
+        this.className =  clsName + "$constants";
+        this.CD_constantsHelper = ClassDesc.of(pkgName.isEmpty()? className : (pkgName +"." + className));
+        classBegin(libraryNames);
+    }
+
+    @Override
+    public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {
+        String layoutName = javaName + "$LAYOUT";
+        if (namesGenerated.add(layoutName)) {
+            emitLayoutField(javaName, layout);
+            return emitGetter(layoutName, MemoryLayout.class, getLayoutFieldName(javaName));
+        } else {
+            return getGetterDesc(layoutName, MethodHandle.class);
+        }
+    }
+
+    @Override
+    public DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, MemoryLayout parentLayout) {
+        String varHandleName = javaName + "$VH";
+        if (namesGenerated.add(varHandleName)) {
+            String fieldName = emitVarHandleField(javaName, type);
+            return emitGetter(varHandleName, VarHandle.class, fieldName);
+        } else {
+            return getGetterDesc(varHandleName, VarHandle.class);
+        }
+    }
+
+    @Override
+    public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {
+        String mhName = javaName + "$MH";
+        if (namesGenerated.add(mhName)) {
+            String fieldName = emitMethodHandleField(javaName, nativeName, mtype, desc, varargs);
+            return emitGetter(mhName, MethodHandle.class, fieldName);
+        } else {
+            return getGetterDesc(mhName, MethodHandle.class);
+        }
+    }
+
+    @Override
+    public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {
+        String segmentName = javaName + "$SEGMENT";
+        if (namesGenerated.add(segmentName)) {
+            String fieldName = emitSegmentField(javaName, nativeName, layout);
+            return emitGetter(segmentName, MemorySegment.class, fieldName);
+        } else {
+            return getGetterDesc(segmentName, MemorySegment.class);
+        }
+    }
+
+    @Override
+    public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor desc) {
+        String funcDescName = javaName + "$FUNC";
+        if (namesGenerated.add(funcDescName)) {
+            String fieldName = emitFunctionDescField(javaName, desc);
+            return emitGetter(funcDescName, FunctionDescriptor.class, fieldName);
+        } else {
+            return getGetterDesc(funcDescName, FunctionDescriptor.class);
+        }
+    }
+
+    @Override
+    public DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value) {
+        if (namesGenerated.add(name)) {
+            String str;
+            if (type == MemorySegment.class) {
+                str = emitConstantStringField(name, value);
+            } else {
+                str = getConstantString(type, value);
+            }
+            return emitGetter(name, type, str);
+        } else {
+            return getGetterDesc(name, type);
+        }
+    }
+
+    @Override
+    public List<JavaFileObject> getClasses() {
+        classEnd();
+        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
+        return List.of(InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + className + ".java"), sb.toString()));
+    }
+
+    // Internals only below this point
+    private void classBegin(String[] libraryNames) {
+        addPackagePrefix(pkgName);
+        addImportSection();
+        append(JavaSourceBuilder.PUB_CLS_MODS);
+        append("class ");
+        append(className);
+        append(" {\n");
+        emitLibraries(libraryNames);
+    }
+
+    private void classEnd() {
+        append("}\n");
+    }
+
+    private DirectMethodHandleDesc getGetterDesc(String name, Class<?> type) {
+        MethodType mt = methodType(type);
+        return MethodHandleDesc.ofMethod(
+                DirectMethodHandleDesc.Kind.STATIC,
+                CD_constantsHelper, name, mt.describeConstable().orElseThrow()
+        );
+    }
+
+    private DirectMethodHandleDesc emitGetter(String name, Class<?> type, String value) {
+        incrAlign();
+        indent();
+        append(JavaSourceBuilder.PUB_MODS);
+        append(type.getName());
+        append(' ');
+        append(name);
+        append("() { return ");
+        append(value);
+        append("; }\n\n");
+        decrAlign();
+        return getGetterDesc(name, type);
+    }
+
+    private void addPackagePrefix(String pkgName) {
+        append("// Generated by jextract\n\n");
+        if (!pkgName.isEmpty()) {
+            append("package ");
+            append(pkgName);
+            append(";\n\n");
+        }
+    }
+
+    private void addImportSection() {
+        append("import java.lang.invoke.MethodHandle;\n");
+        append("import java.lang.invoke.VarHandle;\n");
+        append("import jdk.incubator.foreign.*;\n");
+        append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
+        append("import static ");
+        append(OutputFactory.C_LANG_CONSTANTS_HOLDER);
+        append(".*;\n\n");
+    }
+
+    private void append(String s) {
+        sb.append(s);
+    }
+
+    private void append(char c) {
+        sb.append(c);
+    }
+
+    private void append(boolean b) {
+        sb.append(b);
+    }
+
+    private void indent() {
+        for (int i = 0; i < align; i++) {
+            append("    ");
+        }
+    }
+
+    private void incrAlign() {
+        align++;
+    }
+    private void decrAlign() {
+        align--;
+    }
+
+    private String getMethodHandleFieldName(String javaName) {
+        return javaName + "$MH_";
+    }
+
+    private String emitMethodHandleField(String javaName, String nativeName, MethodType mtype,
+                                         FunctionDescriptor desc, boolean varargs) {
+        addFunctionDesc(javaName, desc);
+        incrAlign();
+        String fieldName = getMethodHandleFieldName(javaName);
+        indent();
+        append(PRIVATE_MODS + "MethodHandle ");
+        append(fieldName + " = RuntimeHelper.downcallHandle(\n");
+        incrAlign();
+        indent();
+        append("LIBRARIES, \"" + nativeName + "\"");
+        append(",\n");
+        indent();
+        append("\"" + mtype.toMethodDescriptorString() + "\",\n");
+        indent();
+        append(getFunctionDescFieldName(javaName));
+        append(", ");
+        // isVariadic
+        append(varargs);
+        append("\n");
+        decrAlign();
+        indent();
+        append(");\n");
+        decrAlign();
+        return fieldName;
+    }
+
+    private String getVarHandleFieldName(String name) {
+        return name + "$VH_";
+    }
+
+    private String emitVarHandleField(String javaName, Class<?> type) {
+        incrAlign();
+        String typeName = type.getName();
+        boolean isAddr = typeName.contains("MemoryAddress");
+        if (isAddr) {
+            typeName = "long";
+        }
+        indent();
+        String fieldName = getVarHandleFieldName(javaName);
+        append(PRIVATE_MODS + "VarHandle " + fieldName + " = ");
+        if (isAddr) {
+            append("MemoryHandles.asAddressVarHandle(");
+        }
+        append(getLayoutFieldName(javaName));
+        append(".varHandle(" + typeName + ".class)");
+        if (isAddr) {
+            append(")");
+        }
+        append(";\n");
+        decrAlign();
+        return fieldName;
+    }
+
+    private String getLayoutFieldName(String javaName) {
+        return javaName + "$LAYOUT_";
+    }
+
+    private void emitLayoutField(String javaName, MemoryLayout layout) {
+        incrAlign();
+        indent();
+        append(PRIVATE_MODS + "MemoryLayout " + getLayoutFieldName(javaName) + " = ");
+        emitLayoutString(layout);
+        append(";\n");
+        decrAlign();
+    }
+
+    private void emitLayoutString(MemoryLayout l) {
+        if (l instanceof ValueLayout) {
+            append(typeToLayoutName((ValueLayout) l));
+        } else if (l instanceof SequenceLayout) {
+            append("MemoryLayout.ofSequence(");
+            if (((SequenceLayout) l).elementCount().isPresent()) {
+                append(((SequenceLayout) l).elementCount().getAsLong() + ", ");
+            }
+            emitLayoutString(((SequenceLayout) l).elementLayout());
+            append(")");
+        } else if (l instanceof GroupLayout) {
+            if (l == CSupport.SysV.C_COMPLEX_LONGDOUBLE) {
+                append("C_COMPLEX_LONGDOUBLE");
+            } else {
+                if (((GroupLayout) l).isStruct()) {
+                    append("MemoryLayout.ofStruct(\n");
+                } else {
+                    append("MemoryLayout.ofUnion(\n");
+                }
+                incrAlign();
+                String delim = "";
+                for (MemoryLayout e : ((GroupLayout) l).memberLayouts()) {
+                    append(delim);
+                    indent();
+                    emitLayoutString(e);
+                    delim = ",\n";
+                }
+                append("\n");
+                decrAlign();
+                indent();
+                append(")");
+            }
+        } else {
+            // padding
+            append("MemoryLayout.ofPaddingBits(" + l.bitSize() + ")");
+        }
+        if (l.name().isPresent()) {
+            append(".withName(\"" +  l.name().get() + "\")");
+        }
+    }
+
+    private String getFunctionDescFieldName(String javaName) {
+        return javaName + "$FUNC_";
+    }
+
+    private String emitFunctionDescField(String javaName, FunctionDescriptor desc) {
+        incrAlign();
+        indent();
+        String fieldName = getFunctionDescFieldName(javaName);
+        final boolean noArgs = desc.argumentLayouts().isEmpty();
+        append(PRIVATE_MODS);
+        append("FunctionDescriptor ");
+        append(fieldName);
+        append(" = ");
+        if (desc.returnLayout().isPresent()) {
+            append("FunctionDescriptor.of(");
+            emitLayoutString(desc.returnLayout().get());
+            if (!noArgs) {
+                append(",");
+            }
+        } else {
+            append("FunctionDescriptor.ofVoid(");
+        }
+        if (!noArgs) {
+            append("\n");
+            incrAlign();
+            String delim = "";
+            for (MemoryLayout e : desc.argumentLayouts()) {
+                append(delim);
+                indent();
+                emitLayoutString(e);
+                delim = ",\n";
+            }
+            append("\n");
+            decrAlign();
+            indent();
+        }
+        append(");\n");
+        decrAlign();
+        return fieldName;
+    }
+
+    private String getConstantStringFieldName(String javaName) {
+        return javaName + "$STR_CONSTANT_";
+    }
+
+    private String emitConstantStringField(String javaName, Object value) {
+        incrAlign();
+        indent();
+        String fieldName = getConstantStringFieldName(javaName);
+        append(PRIVATE_MODS);
+        append("MemorySegment ");
+        append(fieldName);
+        append(" = CSupport.toCString(\"");
+        append(Objects.toString(value));
+        append("\");\n");
+        decrAlign();
+        return fieldName;
+    }
+
+    private String getConstantString(Class<?> type, Object value) {
+        StringBuilder buf = new StringBuilder();
+        if (type == float.class) {
+            buf.append(value);
+            buf.append("f");
+        } else if (type == long.class) {
+            buf.append(value);
+            buf.append("L");
+        } else if (type == double.class) {
+            Double v = (Double) value;
+            if (Double.isFinite(v)) {
+                buf.append(value);
+                buf.append("d");
+            } else {
+                buf.append("Double.valueOf(\"");
+                buf.append(v.toString());
+                buf.append("\")");
+            }
+        } else {
+            buf.append("(" + type.getName() + ")");
+            buf.append(value + "L");
+        }
+        return buf.toString();
+    }
+
+    private static String typeToLayoutName(ValueLayout vl) {
+        if (matchLayout(vl, CSupport.C_BOOL)) {
+            return "C_BOOL";
+        } else if (matchLayout(vl, CSupport.C_CHAR)) {
+            return "C_CHAR";
+        } else if (matchLayout(vl, CSupport.C_SHORT)) {
+            return "C_SHORT";
+        } else if (matchLayout(vl, CSupport.C_INT)) {
+            return "C_INT";
+        } else if (matchLayout(vl, CSupport.C_LONG)) {
+            return "C_LONG";
+        } else if (matchLayout(vl, CSupport.C_LONGLONG)) {
+            return "C_LONGLONG";
+        } else if (matchLayout(vl, CSupport.C_FLOAT)) {
+            return "C_FLOAT";
+        } else if (matchLayout(vl, CSupport.C_DOUBLE)) {
+            return "C_DOUBLE";
+        } else if (matchLayout(vl, CSupport.C_LONGDOUBLE)) {
+            return "C_LONGDOUBLE";
+        } else if (matchLayout(vl, CSupport.C_POINTER)) {
+            return "C_POINTER";
+        } else {
+            throw new RuntimeException("should not reach here, problematic layout: " + vl);
+        }
+    }
+
+    private static boolean matchLayout(ValueLayout a, ValueLayout b) {
+        if (a == b) return true;
+        return (a.bitSize() == b.bitSize() &&
+                a.order() == b.order() &&
+                a.bitAlignment() == b.bitAlignment() &&
+                a.attribute(ABI_CLASS_ATTR).equals(b.attribute(ABI_CLASS_ATTR)));
+    }
+
+    private String getSegmentFieldName(String javaName) {
+        return javaName + "$SEGMENT_";
+    }
+
+    private String emitSegmentField(String javaName, String nativeName, MemoryLayout layout) {
+         addLayout(javaName, layout);
+         incrAlign();
+         indent();
+         String fieldName = getSegmentFieldName(javaName);
+         append(PRIVATE_MODS);
+         append("MemorySegment ");
+         append(fieldName);
+         append(" = ");
+         append("RuntimeHelper.lookupGlobalVariable(LIBRARIES, \"");
+         append(nativeName);
+         append("\", ");
+         append(getLayoutFieldName(javaName));
+         append(");\n");
+         decrAlign();
+         return fieldName;
+    }
+
+    private void emitLibraries(String[] libraryNames) {
+        incrAlign();
+        indent();
+        append(PRIVATE_MODS);
+        append("LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\n");
+        incrAlign();
+        for (String lib : libraryNames) {
+            indent();
+            append('\"');
+            append(lib);
+            append("\",\n");
+        }
+        decrAlign();
+        indent();
+        append("});\n\n");
+        decrAlign();
+    }
+}
