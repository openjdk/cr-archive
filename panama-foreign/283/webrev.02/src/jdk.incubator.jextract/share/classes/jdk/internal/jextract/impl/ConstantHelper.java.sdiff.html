<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ConstantHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../incubator/jextract/JextractTool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeaderBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/ConstantHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.internal.jextract.impl;
 26 
 27 import jdk.incubator.foreign.FunctionDescriptor;
<span class="line-removed"> 28 import jdk.incubator.foreign.LibraryLookup;</span>
<span class="line-removed"> 29 import jdk.incubator.foreign.MemoryAddress;</span>
<span class="line-removed"> 30 import jdk.incubator.foreign.MemoryHandles;</span>
 31 import jdk.incubator.foreign.MemoryLayout;
<span class="line-removed"> 32 import jdk.incubator.foreign.MemorySegment;</span>
<span class="line-removed"> 33 import jdk.internal.org.objectweb.asm.ClassWriter;</span>
<span class="line-removed"> 34 import jdk.internal.org.objectweb.asm.ConstantDynamic;</span>
<span class="line-removed"> 35 import jdk.internal.org.objectweb.asm.Handle;</span>
<span class="line-removed"> 36 import jdk.internal.org.objectweb.asm.MethodVisitor;</span>
<span class="line-removed"> 37 import jdk.internal.org.objectweb.asm.Type;</span>
 38 
 39 import javax.tools.JavaFileObject;
<span class="line-removed"> 40 import javax.tools.SimpleJavaFileObject;</span>
<span class="line-removed"> 41 import java.io.ByteArrayInputStream;</span>
<span class="line-removed"> 42 import java.io.InputStream;</span>
 43 import java.lang.constant.ClassDesc;
<span class="line-removed"> 44 import java.lang.constant.Constable;</span>
<span class="line-removed"> 45 import java.lang.constant.ConstantDesc;</span>
<span class="line-removed"> 46 import java.lang.constant.ConstantDescs;</span>
 47 import java.lang.constant.DirectMethodHandleDesc;
<span class="line-removed"> 48 import java.lang.constant.DirectMethodHandleDesc.Kind;</span>
<span class="line-removed"> 49 import java.lang.constant.DynamicConstantDesc;</span>
<span class="line-removed"> 50 import java.lang.constant.MethodHandleDesc;</span>
<span class="line-removed"> 51 import java.lang.constant.MethodTypeDesc;</span>
<span class="line-removed"> 52 import java.lang.invoke.MethodHandle;</span>
 53 import java.lang.invoke.MethodType;
<span class="line-removed"> 54 import java.lang.invoke.VarHandle;</span>
<span class="line-removed"> 55 import java.net.URI;</span>
<span class="line-removed"> 56 import java.util.HashMap;</span>
 57 import java.util.List;
<span class="line-removed"> 58 import java.util.Map;</span>
<span class="line-removed"> 59 import java.util.function.Consumer;</span>
 60 
<span class="line-modified"> 61 import static java.lang.constant.ConstantDescs.*;</span>
<span class="line-modified"> 62 import static java.lang.invoke.MethodHandleInfo.*;</span>
<span class="line-modified"> 63 import static java.lang.invoke.MethodType.methodType;</span>
<span class="line-modified"> 64 import static jdk.internal.org.objectweb.asm.Opcodes.*;</span>
<span class="line-modified"> 65 </span>
<span class="line-modified"> 66 public class ConstantHelper {</span>
<span class="line-modified"> 67 </span>
<span class="line-modified"> 68     private static final String INTR_OBJECT = Type.getInternalName(Object.class);</span>
<span class="line-modified"> 69 </span>
<span class="line-modified"> 70     private static final ClassDesc CD_LIBRARIES = desc(LibraryLookup[].class);</span>
<span class="line-modified"> 71 </span>
<span class="line-modified"> 72     private static final DirectMethodHandleDesc MH_MemoryLayout_varHandle = MethodHandleDesc.ofMethod(</span>
<span class="line-modified"> 73             Kind.INTERFACE_VIRTUAL,</span>
<span class="line-removed"> 74             desc(MemoryLayout.class),</span>
<span class="line-removed"> 75             &quot;varHandle&quot;,</span>
<span class="line-removed"> 76             desc(methodType(</span>
<span class="line-removed"> 77                     VarHandle.class,</span>
<span class="line-removed"> 78                     Class.class,</span>
<span class="line-removed"> 79                     MemoryLayout.PathElement[].class))</span>
<span class="line-removed"> 80     );</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82     private static final DirectMethodHandleDesc MH_PathElement_groupElement = MethodHandleDesc.ofMethod(</span>
<span class="line-removed"> 83             Kind.INTERFACE_STATIC,</span>
<span class="line-removed"> 84             desc(MemoryLayout.PathElement.class),</span>
<span class="line-removed"> 85             &quot;groupElement&quot;,</span>
<span class="line-removed"> 86             desc(methodType(MemoryLayout.PathElement.class, String.class))</span>
<span class="line-removed"> 87     );</span>
<span class="line-removed"> 88 </span>
<span class="line-removed"> 89     private static final DirectMethodHandleDesc MH_MemoryAddress_ofLong = MethodHandleDesc.ofMethod(</span>
<span class="line-removed"> 90             Kind.INTERFACE_STATIC,</span>
<span class="line-removed"> 91             desc(MemoryAddress.class),</span>
<span class="line-removed"> 92             &quot;ofLong&quot;,</span>
<span class="line-removed"> 93             desc(methodType(MemoryAddress.class, long.class))</span>
<span class="line-removed"> 94     );</span>
<span class="line-removed"> 95 </span>
<span class="line-removed"> 96     private static final DirectMethodHandleDesc MH_MemoryHandles_asAddressVarHandle = MethodHandleDesc.ofMethod(</span>
<span class="line-removed"> 97             Kind.STATIC,</span>
<span class="line-removed"> 98             desc(MemoryHandles.class),</span>
<span class="line-removed"> 99             &quot;asAddressVarHandle&quot;,</span>
<span class="line-removed">100             desc(methodType(VarHandle.class, VarHandle.class))</span>
<span class="line-removed">101     );</span>
<span class="line-removed">102 </span>
<span class="line-removed">103     private static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL = ConstantDescs.ofConstantBootstrap(</span>
<span class="line-removed">104             CD_ConstantBootstraps,</span>
<span class="line-removed">105             &quot;getStaticFinal&quot;,</span>
<span class="line-removed">106             CD_Object,</span>
<span class="line-removed">107             CD_Class</span>
<span class="line-removed">108     );</span>
<span class="line-removed">109 </span>
<span class="line-removed">110     private static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, &quot;TRUE&quot;, ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);</span>
<span class="line-removed">111     private static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, &quot;FALSE&quot;, ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);</span>
<span class="line-removed">112     private static final ClassDesc CD_PathElelemt = desc(MemoryLayout.PathElement.class);</span>
<span class="line-removed">113     private static final ClassDesc CD_MemoryAddress = desc(MemoryAddress.class);</span>
<span class="line-removed">114     private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);</span>
<span class="line-removed">115 </span>
<span class="line-removed">116     private final DirectMethodHandleDesc MH_downcallHandle;</span>
<span class="line-removed">117     private final DirectMethodHandleDesc MH_lookupGlobalVariable;</span>
<span class="line-removed">118     private final DirectMethodHandleDesc MH_makeCString;</span>
<span class="line-removed">119 </span>
<span class="line-removed">120     private ClassWriter cw;</span>
<span class="line-removed">121     private final String internalClassName;</span>
<span class="line-removed">122     private final ClassDesc CD_constantsHelper;</span>
<span class="line-removed">123     private final ConstantDesc LIBRARIES;</span>
<span class="line-removed">124 </span>
<span class="line-removed">125     private final Map&lt;String, DirectMethodHandleDesc&gt; pool = new HashMap&lt;&gt;();</span>
<span class="line-removed">126 </span>
<span class="line-removed">127     private static final Map&lt;Class&lt;?&gt;, ClassDesc&gt; CARRIERS = Map.ofEntries(</span>
<span class="line-removed">128             Map.entry(Byte.TYPE,                desc(Byte.TYPE)),</span>
<span class="line-removed">129             Map.entry(Short.TYPE,               desc(Short.TYPE)),</span>
<span class="line-removed">130             Map.entry(Character.TYPE,           desc(Character.TYPE)),</span>
<span class="line-removed">131             Map.entry(Integer.TYPE,             desc(Integer.TYPE)),</span>
<span class="line-removed">132             Map.entry(Long.TYPE,                desc(Long.TYPE)),</span>
<span class="line-removed">133             Map.entry(Float.TYPE,               desc(Float.TYPE)),</span>
<span class="line-removed">134             Map.entry(Double.TYPE,              desc(Double.TYPE)),</span>
<span class="line-removed">135             Map.entry(MemoryAddress.class,      desc(Long.TYPE))</span>
<span class="line-removed">136     );</span>
<span class="line-removed">137 </span>
<span class="line-removed">138     public ConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {</span>
<span class="line-removed">139         this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);</span>
<span class="line-removed">140         String className = parentClassName + &quot;$constants&quot;;</span>
<span class="line-removed">141         this.CD_constantsHelper = ClassDesc.of(className);</span>
<span class="line-removed">142         this.internalClassName = className.replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-removed">143 </span>
<span class="line-removed">144         this.MH_downcallHandle = findRuntimeHelperBootstrap(</span>
<span class="line-removed">145                 runtimeHelper,</span>
<span class="line-removed">146                 &quot;downcallHandle&quot;,</span>
<span class="line-removed">147                 methodType(</span>
<span class="line-removed">148                         MethodHandle.class,</span>
<span class="line-removed">149                         LibraryLookup[].class,</span>
<span class="line-removed">150                         String.class,</span>
<span class="line-removed">151                         String.class,</span>
<span class="line-removed">152                         FunctionDescriptor.class,</span>
<span class="line-removed">153                         boolean.class)</span>
<span class="line-removed">154         );</span>
<span class="line-removed">155         this.MH_lookupGlobalVariable = findRuntimeHelperBootstrap(</span>
<span class="line-removed">156                 runtimeHelper,</span>
<span class="line-removed">157                 &quot;lookupGlobalVariable&quot;,</span>
<span class="line-removed">158                 methodType(</span>
<span class="line-removed">159                         MemorySegment.class,</span>
<span class="line-removed">160                         LibraryLookup[].class,</span>
<span class="line-removed">161                         String.class,</span>
<span class="line-removed">162                         MemoryLayout.class)</span>
<span class="line-removed">163         );</span>
<span class="line-removed">164         this.MH_makeCString = findRuntimeHelperBootstrap(</span>
<span class="line-removed">165                 cString,</span>
<span class="line-removed">166                 &quot;toCString&quot;,</span>
<span class="line-removed">167                 methodType(</span>
<span class="line-removed">168                         MemorySegment.class,</span>
<span class="line-removed">169                         String.class)</span>
<span class="line-removed">170         );</span>
<span class="line-removed">171 </span>
<span class="line-removed">172         this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(</span>
<span class="line-removed">173                 runtimeHelper,</span>
<span class="line-removed">174                 &quot;libraries&quot;,</span>
<span class="line-removed">175                 methodType(</span>
<span class="line-removed">176                         LibraryLookup[].class,</span>
<span class="line-removed">177                         String[].class)</span>
<span class="line-removed">178         ), libraryNames);</span>
<span class="line-removed">179 </span>
<span class="line-removed">180         cw.visit(V15, ACC_PUBLIC, internalClassName, null, INTR_OBJECT, null);</span>
<span class="line-removed">181     }</span>
<span class="line-removed">182 </span>
<span class="line-removed">183     private static DirectMethodHandleDesc findRuntimeHelperBootstrap(ClassDesc runtimeHelper, String name, MethodType type) {</span>
<span class="line-removed">184         return MethodHandleDesc.ofMethod(</span>
<span class="line-removed">185                 Kind.STATIC,</span>
<span class="line-removed">186                 runtimeHelper,</span>
<span class="line-removed">187                 name,</span>
<span class="line-removed">188                 desc(type)</span>
<span class="line-removed">189         );</span>
<span class="line-removed">190     }</span>
<span class="line-removed">191 </span>
<span class="line-removed">192     public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {</span>
<span class="line-removed">193         return emitCondyGetter(javaName + &quot;$LAYOUT&quot;, MemoryLayout.class, desc(layout));</span>
<span class="line-removed">194     }</span>
<span class="line-removed">195 </span>
<span class="line-removed">196     public DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class&lt;?&gt; type, MemoryLayout parentLayout) {</span>
<span class="line-removed">197         return emitCondyGetter(javaName + &quot;$VH&quot;, VarHandle.class, varHandleDesc(javaName, nativeName, layout, type, parentLayout));</span>
<span class="line-removed">198     }</span>
<span class="line-removed">199 </span>
<span class="line-removed">200     public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {</span>
<span class="line-removed">201         return emitCondyGetter(javaName + &quot;$MH&quot;, MethodHandle.class, methodHandleDesc(nativeName, mtype, desc, varargs));</span>
<span class="line-removed">202     }</span>
<span class="line-removed">203 </span>
<span class="line-removed">204     public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {</span>
<span class="line-removed">205         return emitCondyGetter(javaName + &quot;$SEGMENT&quot;, MemorySegment.class, globalVarAddressDesc(nativeName, layout));</span>
<span class="line-removed">206     }</span>
<span class="line-removed">207 </span>
<span class="line-removed">208     public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {</span>
<span class="line-removed">209         return emitCondyGetter(javaName + &quot;$DESC&quot;, FunctionDescriptor.class, desc(fDesc));</span>
<span class="line-removed">210     }</span>
<span class="line-removed">211 </span>
<span class="line-removed">212     public DirectMethodHandleDesc addConstant(String name, Class&lt;?&gt; type, Object value) {</span>
<span class="line-removed">213         if (type == MemoryAddress.class) {</span>
<span class="line-removed">214             if (value instanceof Long) {</span>
<span class="line-removed">215                 return emitCondyGetter(name, type, addressDesc((Long) value));</span>
<span class="line-removed">216             } else {</span>
<span class="line-removed">217                 throw new IllegalStateException(&quot;Unhandled constant value type: &quot; + value.getClass());</span>
<span class="line-removed">218             }</span>
<span class="line-removed">219         } else if (type == MemorySegment.class) {</span>
<span class="line-removed">220             if (value instanceof String) {</span>
<span class="line-removed">221                 return emitCondyGetter(name, type, cStringDesc((String) value));</span>
<span class="line-removed">222             } else {</span>
<span class="line-removed">223                 throw new IllegalStateException(&quot;Unhandled constant value type: &quot; + value.getClass());</span>
<span class="line-removed">224             }</span>
<span class="line-removed">225         } else if (type.isPrimitive()) {</span>
<span class="line-removed">226             if (type == int.class || type == byte.class || type == short.class || type == char.class) {</span>
<span class="line-removed">227                 return emitConIntGetter(name, type, ((Long) value).intValue());</span>
<span class="line-removed">228             } else if (type == float.class) {</span>
<span class="line-removed">229                 return emitConFloatGetter(name, type, ((Double) value).floatValue());</span>
<span class="line-removed">230             } else if (type == long.class) {</span>
<span class="line-removed">231                 return emitConLongGetter(name, type, (Long) value);</span>
<span class="line-removed">232             } else if (type == double.class) {</span>
<span class="line-removed">233                 return emitConDoubleGetter(name, type, (Double) value);</span>
<span class="line-removed">234             } else { // boolean and void</span>
<span class="line-removed">235                 throw new IllegalStateException(&quot;Unhandled primitive target type: &quot; + type);</span>
<span class="line-removed">236             }</span>
<span class="line-removed">237         } else if (type == value.getClass() &amp;&amp; value instanceof Constable) {</span>
<span class="line-removed">238             // Constable value that requires no conversion</span>
<span class="line-removed">239             return emitCondyGetter(name, type, desc((Constable) value));</span>
<span class="line-removed">240         } else {</span>
<span class="line-removed">241             System.out.println(&quot;Warning: Skipping constant generation for: &quot; + name + &quot; of type: &quot; + type.getSimpleName()</span>
<span class="line-removed">242                 + &quot; with value: &quot; + value + &quot; of type: &quot; + value.getClass());</span>
<span class="line-removed">243             return null;</span>
<span class="line-removed">244         }</span>
<span class="line-removed">245     }</span>
<span class="line-removed">246 </span>
<span class="line-removed">247     public List&lt;JavaFileObject&gt; getClasses() {</span>
<span class="line-removed">248         cw.visitEnd();</span>
<span class="line-removed">249         byte[] bytes = cw.toByteArray();</span>
<span class="line-removed">250         cw = null;</span>
<span class="line-removed">251         return List.of(jfoFromByteArray(internalClassName, bytes));</span>
<span class="line-removed">252     }</span>
<span class="line-removed">253 </span>
<span class="line-removed">254     // Utility</span>
<span class="line-removed">255 </span>
<span class="line-removed">256     private static JavaFileObject jfoFromByteArray(String name, byte[] bytes) {</span>
<span class="line-removed">257         return new SimpleJavaFileObject(URI.create(name + &quot;.class&quot;), JavaFileObject.Kind.CLASS) {</span>
<span class="line-removed">258             @Override</span>
<span class="line-removed">259             public InputStream openInputStream() {</span>
<span class="line-removed">260                 return new ByteArrayInputStream(bytes);</span>
<span class="line-removed">261             }</span>
<span class="line-removed">262         };</span>
<span class="line-removed">263     }</span>
<span class="line-removed">264 </span>
<span class="line-removed">265     private static String descriptorToInternalName(String s) {</span>
<span class="line-removed">266         return s.substring(1, s.length() - 1);</span>
<span class="line-removed">267     }</span>
<span class="line-removed">268 </span>
<span class="line-removed">269     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">270     private static &lt;T extends ConstantDesc&gt; T desc(Constable constable) {</span>
<span class="line-removed">271         return (T) constable.describeConstable().orElseThrow();</span>
<span class="line-removed">272     }</span>
<span class="line-removed">273 </span>
<span class="line-removed">274     // ASM helpers</span>
<span class="line-removed">275 </span>
<span class="line-removed">276     private static void emitConShort(MethodVisitor mv, short value) {</span>
<span class="line-removed">277         if (value &gt;= -1 &amp;&amp; value &lt;= 5) {</span>
<span class="line-removed">278             mv.visitInsn(</span>
<span class="line-removed">279                 switch (value) {</span>
<span class="line-removed">280                     case -1 -&gt; ICONST_M1;</span>
<span class="line-removed">281                     case 0 -&gt; ICONST_0;</span>
<span class="line-removed">282                     case 1 -&gt; ICONST_1;</span>
<span class="line-removed">283                     case 2 -&gt; ICONST_2;</span>
<span class="line-removed">284                     case 3 -&gt; ICONST_3;</span>
<span class="line-removed">285                     case 4 -&gt; ICONST_4;</span>
<span class="line-removed">286                     case 5 -&gt; ICONST_5;</span>
<span class="line-removed">287                     default -&gt; throw new IllegalStateException(&quot;Should not reach here&quot;);</span>
<span class="line-removed">288                 });</span>
<span class="line-removed">289         } else if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE) {</span>
<span class="line-removed">290             mv.visitIntInsn(BIPUSH, value);</span>
<span class="line-removed">291         } else {</span>
<span class="line-removed">292             mv.visitIntInsn(SIPUSH, value);</span>
<span class="line-removed">293         }</span>
<span class="line-removed">294     }</span>
<span class="line-removed">295 </span>
<span class="line-removed">296     private static void emitConInt(MethodVisitor mv, int value) {</span>
<span class="line-removed">297         if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE) {</span>
<span class="line-removed">298             emitConShort(mv, (short) value);</span>
<span class="line-removed">299         } else {</span>
<span class="line-removed">300             mv.visitLdcInsn(value);</span>
<span class="line-removed">301         }</span>
<span class="line-removed">302     }</span>
<span class="line-removed">303 </span>
<span class="line-removed">304     private static void emitConLong(MethodVisitor mv, long value) {</span>
<span class="line-removed">305         if (value == 0) {</span>
<span class="line-removed">306             mv.visitInsn(LCONST_0);</span>
<span class="line-removed">307         } else if (value == 1) {</span>
<span class="line-removed">308             mv.visitInsn(LCONST_1);</span>
<span class="line-removed">309         } else if (value &gt;= Integer.MIN_VALUE &amp;&amp; value &lt;= Integer.MAX_VALUE) {</span>
<span class="line-removed">310             // saves a constant pool slot</span>
<span class="line-removed">311             emitConInt(mv, (int) value);</span>
<span class="line-removed">312             mv.visitInsn(I2L);</span>
<span class="line-removed">313         } else {</span>
<span class="line-removed">314             mv.visitLdcInsn(value);</span>
<span class="line-removed">315         }</span>
<span class="line-removed">316     }</span>
<span class="line-removed">317 </span>
<span class="line-removed">318     private static void emitConFloat(MethodVisitor mv, float value) {</span>
<span class="line-removed">319         if (value == 0.0F) {</span>
<span class="line-removed">320             mv.visitInsn(FCONST_0);</span>
<span class="line-removed">321         } else if (value == 1.0F) {</span>
<span class="line-removed">322             mv.visitInsn(FCONST_1);</span>
<span class="line-removed">323         } else if (value == 2.0F) {</span>
<span class="line-removed">324             mv.visitInsn(FCONST_2);</span>
<span class="line-removed">325         } else if (value == (short) value) {</span>
<span class="line-removed">326             emitConShort(mv, (short) value);</span>
<span class="line-removed">327             mv.visitInsn(I2F);</span>
328         } else {
<span class="line-modified">329             mv.visitLdcInsn(value);</span>
330         }
331     }
<span class="line-removed">332 </span>
<span class="line-removed">333     private static void emitConDouble(MethodVisitor mv, double value) {</span>
<span class="line-removed">334         if (value == 0.0D) {</span>
<span class="line-removed">335             mv.visitInsn(DCONST_0);</span>
<span class="line-removed">336         } else if (value == 1.0D) {</span>
<span class="line-removed">337             mv.visitInsn(DCONST_1);</span>
<span class="line-removed">338         } else if (value == (short) value) {</span>
<span class="line-removed">339             emitConShort(mv, (short) value);</span>
<span class="line-removed">340             mv.visitInsn(I2D);</span>
<span class="line-removed">341         } else if (value &gt;= Float.MIN_VALUE &amp;&amp; value &lt;= Float.MAX_VALUE) {</span>
<span class="line-removed">342             // saves a constant pool slot</span>
<span class="line-removed">343             mv.visitLdcInsn((float) value);</span>
<span class="line-removed">344             mv.visitInsn(F2D);</span>
<span class="line-removed">345         } else {</span>
<span class="line-removed">346             mv.visitLdcInsn(value);</span>
<span class="line-removed">347         }</span>
<span class="line-removed">348     }</span>
<span class="line-removed">349 </span>
<span class="line-removed">350     private DirectMethodHandleDesc emitGetter(String name, Class&lt;?&gt; type, Consumer&lt;MethodVisitor&gt; action) {</span>
<span class="line-removed">351         return pool.computeIfAbsent(name, nameKey -&gt; {</span>
<span class="line-removed">352             MethodType mt = methodType(type);</span>
<span class="line-removed">353             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, nameKey, mt.descriptorString(), null, null);</span>
<span class="line-removed">354             mv.visitCode();</span>
<span class="line-removed">355             action.accept(mv);</span>
<span class="line-removed">356             emitReturn(mv, type);</span>
<span class="line-removed">357             mv.visitMaxs(-1, -1);</span>
<span class="line-removed">358             mv.visitEnd();</span>
<span class="line-removed">359             return MethodHandleDesc.ofMethod(</span>
<span class="line-removed">360                     Kind.STATIC,</span>
<span class="line-removed">361                     CD_constantsHelper,</span>
<span class="line-removed">362                     nameKey,</span>
<span class="line-removed">363                     mt.describeConstable().orElseThrow()</span>
<span class="line-removed">364             );</span>
<span class="line-removed">365         });</span>
<span class="line-removed">366     }</span>
<span class="line-removed">367 </span>
<span class="line-removed">368     private DirectMethodHandleDesc emitConDoubleGetter(String name, Class&lt;?&gt; type, double value) {</span>
<span class="line-removed">369         return emitGetter(name, type, mv -&gt; emitConDouble(mv, value));</span>
<span class="line-removed">370     }</span>
<span class="line-removed">371 </span>
<span class="line-removed">372     private DirectMethodHandleDesc emitConLongGetter(String name, Class&lt;?&gt; type, long value) {</span>
<span class="line-removed">373         return emitGetter(name, type, mv -&gt; emitConLong(mv, value));</span>
<span class="line-removed">374     }</span>
<span class="line-removed">375 </span>
<span class="line-removed">376     private DirectMethodHandleDesc emitConFloatGetter(String name, Class&lt;?&gt; type, float value) {</span>
<span class="line-removed">377         return emitGetter(name, type, mv -&gt; emitConFloat(mv, value));</span>
<span class="line-removed">378     }</span>
<span class="line-removed">379 </span>
<span class="line-removed">380     private DirectMethodHandleDesc emitConIntGetter(String name, Class&lt;?&gt; type, int value) {</span>
<span class="line-removed">381         return emitGetter(name, type, mv -&gt; emitConInt(mv, value));</span>
<span class="line-removed">382     }</span>
<span class="line-removed">383 </span>
<span class="line-removed">384     private DirectMethodHandleDesc emitCondyGetter(String name, Class&lt;?&gt; type, ConstantDesc desc) {</span>
<span class="line-removed">385         return emitGetter(name, type, mv -&gt; mv.visitLdcInsn(asmConstant(desc)));</span>
<span class="line-removed">386     }</span>
<span class="line-removed">387 </span>
<span class="line-removed">388     private static void emitReturn(MethodVisitor mv, Class&lt;?&gt; type) {</span>
<span class="line-removed">389         if (type == int.class</span>
<span class="line-removed">390                 || type == short.class</span>
<span class="line-removed">391                 || type == byte.class</span>
<span class="line-removed">392                 || type == char.class</span>
<span class="line-removed">393                 || type == boolean.class) {</span>
<span class="line-removed">394             mv.visitInsn(IRETURN);</span>
<span class="line-removed">395         } else if (type == long.class) {</span>
<span class="line-removed">396             mv.visitInsn(LRETURN);</span>
<span class="line-removed">397         } else if (type == float.class) {</span>
<span class="line-removed">398             mv.visitInsn(FRETURN);</span>
<span class="line-removed">399         } else if (type == double.class) {</span>
<span class="line-removed">400             mv.visitInsn(DRETURN);</span>
<span class="line-removed">401         } else if (type == void.class) {</span>
<span class="line-removed">402             mv.visitInsn(RETURN);</span>
<span class="line-removed">403         } else if (Object.class.isAssignableFrom(type)) {</span>
<span class="line-removed">404             mv.visitInsn(ARETURN);</span>
<span class="line-removed">405         } else {</span>
<span class="line-removed">406             throw new IllegalArgumentException(&quot;Type not handled: &quot; + type);</span>
<span class="line-removed">407         }</span>
<span class="line-removed">408     }</span>
<span class="line-removed">409 </span>
<span class="line-removed">410     // Condy factories</span>
<span class="line-removed">411 </span>
<span class="line-removed">412     private static ConstantDesc librariesDesc(DirectMethodHandleDesc MH_libraries, String[] libraryNames) {</span>
<span class="line-removed">413         ConstantDesc[] args = new ConstantDesc[libraryNames.length + 1];</span>
<span class="line-removed">414         args[0] = MH_libraries;</span>
<span class="line-removed">415         System.arraycopy(libraryNames, 0, args, 1, libraryNames.length);</span>
<span class="line-removed">416         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;libraries&quot;, CD_LIBRARIES, args);</span>
<span class="line-removed">417     }</span>
<span class="line-removed">418 </span>
<span class="line-removed">419     private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier, ConstantDesc path) {</span>
<span class="line-removed">420         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;VH_&quot; + name, CD_VarHandle, MH_MemoryLayout_varHandle, memoryLayout, carrier, path);</span>
<span class="line-removed">421     }</span>
<span class="line-removed">422 </span>
<span class="line-removed">423     private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier) {</span>
<span class="line-removed">424         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;VH_&quot; + name, CD_VarHandle, MH_MemoryLayout_varHandle, memoryLayout, carrier);</span>
<span class="line-removed">425     }</span>
<span class="line-removed">426 </span>
<span class="line-removed">427     private static ConstantDesc addressVarHandleDesc(String name, ConstantDesc varHandle) {</span>
<span class="line-removed">428         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;VH_&quot; + name, CD_VarHandle, MH_MemoryHandles_asAddressVarHandle, varHandle);</span>
<span class="line-removed">429     }</span>
<span class="line-removed">430 </span>
<span class="line-removed">431     private static ConstantDesc groupElementDesc(String fieldName) {</span>
<span class="line-removed">432         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;groupElement_&quot; + fieldName, CD_PathElelemt, MH_PathElement_groupElement, fieldName);</span>
<span class="line-removed">433     }</span>
<span class="line-removed">434 </span>
<span class="line-removed">435     private static ConstantDesc varHandleDesc(String javaName, String nativeName, MemoryLayout layout, Class&lt;?&gt; type, MemoryLayout parentLayout) {</span>
<span class="line-removed">436         var carrier = CARRIERS.get(type);</span>
<span class="line-removed">437         if (carrier == null) {</span>
<span class="line-removed">438             carrier = desc(type);</span>
<span class="line-removed">439         }</span>
<span class="line-removed">440 </span>
<span class="line-removed">441         var varHandle = parentLayout != null ?</span>
<span class="line-removed">442                 varHandleDesc(javaName, desc(parentLayout), carrier, groupElementDesc(nativeName)) :</span>
<span class="line-removed">443                 varHandleDesc(javaName, desc(layout), carrier);</span>
<span class="line-removed">444 </span>
<span class="line-removed">445         return type == MemoryAddress.class ? addressVarHandleDesc(javaName, varHandle) : varHandle;</span>
<span class="line-removed">446     }</span>
<span class="line-removed">447 </span>
<span class="line-removed">448     private ConstantDesc globalVarAddressDesc(String name, MemoryLayout layout) {</span>
<span class="line-removed">449         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;ADDR_&quot; + name, CD_MemorySegment, MH_lookupGlobalVariable, LIBRARIES, name, desc(layout));</span>
<span class="line-removed">450     }</span>
<span class="line-removed">451 </span>
<span class="line-removed">452     private ConstantDesc addressDesc(long value) {</span>
<span class="line-removed">453         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MA_&quot; + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);</span>
<span class="line-removed">454     }</span>
<span class="line-removed">455 </span>
<span class="line-removed">456     private ConstantDesc cStringDesc(String value) {</span>
<span class="line-removed">457         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;CSTRING&quot;, CD_MemorySegment, MH_makeCString, value);</span>
<span class="line-removed">458     }</span>
<span class="line-removed">459 </span>
<span class="line-removed">460     private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {</span>
<span class="line-removed">461         return DynamicConstantDesc.ofNamed(BSM_INVOKE, &quot;MH_&quot; + name, CD_MethodHandle, MH_downcallHandle,</span>
<span class="line-removed">462             LIBRARIES,</span>
<span class="line-removed">463             name,</span>
<span class="line-removed">464             mtype.descriptorString(),</span>
<span class="line-removed">465             desc(funcDesc),</span>
<span class="line-removed">466             varargs ? TRUE : FALSE);</span>
<span class="line-removed">467     }</span>
<span class="line-removed">468 </span>
<span class="line-removed">469     // To ASM constant translation</span>
<span class="line-removed">470 </span>
<span class="line-removed">471     private static Handle asmHandle(DirectMethodHandleDesc desc) {</span>
<span class="line-removed">472         int tag = switch(desc.refKind()) {</span>
<span class="line-removed">473             case REF_getField         -&gt; H_GETFIELD;</span>
<span class="line-removed">474             case REF_getStatic        -&gt; H_GETSTATIC;</span>
<span class="line-removed">475             case REF_putField         -&gt; H_PUTFIELD;</span>
<span class="line-removed">476             case REF_putStatic        -&gt; H_PUTSTATIC;</span>
<span class="line-removed">477             case REF_invokeVirtual    -&gt; H_INVOKEVIRTUAL;</span>
<span class="line-removed">478             case REF_invokeStatic     -&gt; H_INVOKESTATIC;</span>
<span class="line-removed">479             case REF_invokeSpecial    -&gt; H_INVOKESPECIAL;</span>
<span class="line-removed">480             case REF_newInvokeSpecial -&gt; H_NEWINVOKESPECIAL;</span>
<span class="line-removed">481             case REF_invokeInterface  -&gt; H_INVOKEINTERFACE;</span>
<span class="line-removed">482             default -&gt; throw new InternalError(&quot;Should not reach here&quot;);</span>
<span class="line-removed">483         };</span>
<span class="line-removed">484         return new Handle(tag,</span>
<span class="line-removed">485                 descriptorToInternalName(desc.owner().descriptorString()),</span>
<span class="line-removed">486                 desc.methodName(),</span>
<span class="line-removed">487                 desc.lookupDescriptor(),</span>
<span class="line-removed">488                 desc.isOwnerInterface());</span>
<span class="line-removed">489     }</span>
<span class="line-removed">490 </span>
<span class="line-removed">491     private static ConstantDynamic asmCondy(DynamicConstantDesc&lt;?&gt; condy) {</span>
<span class="line-removed">492         return new ConstantDynamic(</span>
<span class="line-removed">493                 condy.constantName(),</span>
<span class="line-removed">494                 condy.constantType().descriptorString(),</span>
<span class="line-removed">495                 asmHandle(condy.bootstrapMethod()),</span>
<span class="line-removed">496                 asmConstantArgs(condy.bootstrapArgs()));</span>
<span class="line-removed">497     }</span>
<span class="line-removed">498 </span>
<span class="line-removed">499     private static Object[] asmConstantArgs(ConstantDesc[] descs) {</span>
<span class="line-removed">500         Object[] objects = new Object[descs.length];</span>
<span class="line-removed">501         for (int i = 0; i &lt; objects.length; i++) {</span>
<span class="line-removed">502             objects[i] = asmConstant(descs[i]);</span>
<span class="line-removed">503         }</span>
<span class="line-removed">504         return objects;</span>
<span class="line-removed">505     }</span>
<span class="line-removed">506 </span>
<span class="line-removed">507     private static Object asmConstant(ConstantDesc desc) {</span>
<span class="line-removed">508         if (desc instanceof DynamicConstantDesc&lt;?&gt;) {</span>
<span class="line-removed">509             return asmCondy((DynamicConstantDesc&lt;?&gt;) desc);</span>
<span class="line-removed">510         } else if (desc instanceof Integer</span>
<span class="line-removed">511             || desc instanceof Float</span>
<span class="line-removed">512             || desc instanceof Long</span>
<span class="line-removed">513             || desc instanceof Double</span>
<span class="line-removed">514             || desc instanceof String) {</span>
<span class="line-removed">515             return desc;</span>
<span class="line-removed">516         } else if (desc instanceof ClassDesc) {</span>
<span class="line-removed">517             // Primitives should be caught above</span>
<span class="line-removed">518             return Type.getType(((ClassDesc) desc).descriptorString());</span>
<span class="line-removed">519         } else if (desc instanceof MethodTypeDesc) {</span>
<span class="line-removed">520             return Type.getMethodType(((MethodTypeDesc) desc).descriptorString());</span>
<span class="line-removed">521         } else if (desc instanceof DirectMethodHandleDesc) {</span>
<span class="line-removed">522             return asmHandle((DirectMethodHandleDesc) desc);</span>
<span class="line-removed">523         }</span>
<span class="line-removed">524         throw new IllegalArgumentException(&quot;ConstantDesc type not handled: &quot; + desc);</span>
<span class="line-removed">525     }</span>
<span class="line-removed">526 </span>
527 }
</pre>
</td>
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.internal.jextract.impl;
 26 
 27 import jdk.incubator.foreign.FunctionDescriptor;



 28 import jdk.incubator.foreign.MemoryLayout;






 29 
 30 import javax.tools.JavaFileObject;



 31 import java.lang.constant.ClassDesc;



 32 import java.lang.constant.DirectMethodHandleDesc;





 33 import java.lang.invoke.MethodType;



 34 import java.util.List;


 35 
<span class="line-modified"> 36 interface ConstantHelper {</span>
<span class="line-modified"> 37     DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout);</span>
<span class="line-modified"> 38     DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class&lt;?&gt; type, MemoryLayout parentLayout);</span>
<span class="line-modified"> 39     DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs);</span>
<span class="line-modified"> 40     DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout);</span>
<span class="line-modified"> 41     DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc);</span>
<span class="line-modified"> 42     DirectMethodHandleDesc addConstant(String name, Class&lt;?&gt; type, Object value);</span>
<span class="line-modified"> 43     List&lt;JavaFileObject&gt; getClasses();</span>
<span class="line-modified"> 44 </span>
<span class="line-modified"> 45     static ConstantHelper make(boolean source, String parentClassName, ClassDesc runtimeHelper,</span>
<span class="line-modified"> 46                                ClassDesc cString, String[] libraryNames) {</span>
<span class="line-modified"> 47         if (source) {</span>
<span class="line-modified"> 48             return new SourceConstantHelper(parentClassName, libraryNames);</span>






























































































































































































































































 49         } else {
<span class="line-modified"> 50             return new ClassConstantHelper(parentClassName, runtimeHelper, cString, libraryNames);</span>
 51         }
 52     }



































































































































































































 53 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../incubator/jextract/JextractTool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeaderBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>