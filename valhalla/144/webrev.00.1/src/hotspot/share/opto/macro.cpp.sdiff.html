<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;

  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/universe.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/arraycopynode.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/compile.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;

  38 #include &quot;opto/intrinsicnode.hpp&quot;
  39 #include &quot;opto/locknode.hpp&quot;
  40 #include &quot;opto/loopnode.hpp&quot;
  41 #include &quot;opto/macro.hpp&quot;
  42 #include &quot;opto/memnode.hpp&quot;
  43 #include &quot;opto/narrowptrnode.hpp&quot;
  44 #include &quot;opto/node.hpp&quot;
  45 #include &quot;opto/opaquenode.hpp&quot;
  46 #include &quot;opto/phaseX.hpp&quot;
  47 #include &quot;opto/rootnode.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #include &quot;opto/subnode.hpp&quot;
  50 #include &quot;opto/subtypenode.hpp&quot;
  51 #include &quot;opto/type.hpp&quot;
  52 #include &quot;runtime/sharedRuntime.hpp&quot;
  53 #include &quot;utilities/macros.hpp&quot;
  54 #include &quot;utilities/powerOfTwo.hpp&quot;
  55 #if INCLUDE_G1GC
  56 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  57 #endif // INCLUDE_G1GC
</pre>
<hr />
<pre>
  65 // Returns the number of replacements made.
  66 //
  67 int PhaseMacroExpand::replace_input(Node *use, Node *oldref, Node *newref) {
  68   int nreplacements = 0;
  69   uint req = use-&gt;req();
  70   for (uint j = 0; j &lt; use-&gt;len(); j++) {
  71     Node *uin = use-&gt;in(j);
  72     if (uin == oldref) {
  73       if (j &lt; req)
  74         use-&gt;set_req(j, newref);
  75       else
  76         use-&gt;set_prec(j, newref);
  77       nreplacements++;
  78     } else if (j &gt;= req &amp;&amp; uin == NULL) {
  79       break;
  80     }
  81   }
  82   return nreplacements;
  83 }
  84 
<span class="line-removed">  85 void PhaseMacroExpand::migrate_outs(Node *old, Node *target) {</span>
<span class="line-removed">  86   assert(old != NULL, &quot;sanity&quot;);</span>
<span class="line-removed">  87   for (DUIterator_Fast imax, i = old-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">  88     Node* use = old-&gt;fast_out(i);</span>
<span class="line-removed">  89     _igvn.rehash_node_delayed(use);</span>
<span class="line-removed">  90     imax -= replace_input(use, old, target);</span>
<span class="line-removed">  91     // back up iterator</span>
<span class="line-removed">  92     --i;</span>
<span class="line-removed">  93   }</span>
<span class="line-removed">  94   assert(old-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
<span class="line-removed">  95 }</span>
<span class="line-removed">  96 </span>
<span class="line-removed">  97 void PhaseMacroExpand::copy_call_debug_info(CallNode *oldcall, CallNode * newcall) {</span>
<span class="line-removed">  98   // Copy debug information and adjust JVMState information</span>
<span class="line-removed">  99   uint old_dbg_start = oldcall-&gt;tf()-&gt;domain()-&gt;cnt();</span>
<span class="line-removed"> 100   uint new_dbg_start = newcall-&gt;tf()-&gt;domain()-&gt;cnt();</span>
<span class="line-removed"> 101   int jvms_adj  = new_dbg_start - old_dbg_start;</span>
<span class="line-removed"> 102   assert (new_dbg_start == newcall-&gt;req(), &quot;argument count mismatch&quot;);</span>
<span class="line-removed"> 103 </span>
<span class="line-removed"> 104   // SafePointScalarObject node could be referenced several times in debug info.</span>
<span class="line-removed"> 105   // Use Dict to record cloned nodes.</span>
<span class="line-removed"> 106   Dict* sosn_map = new Dict(cmpkey,hashkey);</span>
<span class="line-removed"> 107   for (uint i = old_dbg_start; i &lt; oldcall-&gt;req(); i++) {</span>
<span class="line-removed"> 108     Node* old_in = oldcall-&gt;in(i);</span>
<span class="line-removed"> 109     // Clone old SafePointScalarObjectNodes, adjusting their field contents.</span>
<span class="line-removed"> 110     if (old_in != NULL &amp;&amp; old_in-&gt;is_SafePointScalarObject()) {</span>
<span class="line-removed"> 111       SafePointScalarObjectNode* old_sosn = old_in-&gt;as_SafePointScalarObject();</span>
<span class="line-removed"> 112       uint old_unique = C-&gt;unique();</span>
<span class="line-removed"> 113       Node* new_in = old_sosn-&gt;clone(sosn_map);</span>
<span class="line-removed"> 114       if (old_unique != C-&gt;unique()) { // New node?</span>
<span class="line-removed"> 115         new_in-&gt;set_req(0, C-&gt;root()); // reset control edge</span>
<span class="line-removed"> 116         new_in = transform_later(new_in); // Register new node.</span>
<span class="line-removed"> 117       }</span>
<span class="line-removed"> 118       old_in = new_in;</span>
<span class="line-removed"> 119     }</span>
<span class="line-removed"> 120     newcall-&gt;add_req(old_in);</span>
<span class="line-removed"> 121   }</span>
<span class="line-removed"> 122 </span>
<span class="line-removed"> 123   // JVMS may be shared so clone it before we modify it</span>
<span class="line-removed"> 124   newcall-&gt;set_jvms(oldcall-&gt;jvms() != NULL ? oldcall-&gt;jvms()-&gt;clone_deep(C) : NULL);</span>
<span class="line-removed"> 125   for (JVMState *jvms = newcall-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {</span>
<span class="line-removed"> 126     jvms-&gt;set_map(newcall);</span>
<span class="line-removed"> 127     jvms-&gt;set_locoff(jvms-&gt;locoff()+jvms_adj);</span>
<span class="line-removed"> 128     jvms-&gt;set_stkoff(jvms-&gt;stkoff()+jvms_adj);</span>
<span class="line-removed"> 129     jvms-&gt;set_monoff(jvms-&gt;monoff()+jvms_adj);</span>
<span class="line-removed"> 130     jvms-&gt;set_scloff(jvms-&gt;scloff()+jvms_adj);</span>
<span class="line-removed"> 131     jvms-&gt;set_endoff(jvms-&gt;endoff()+jvms_adj);</span>
<span class="line-removed"> 132   }</span>
<span class="line-removed"> 133 }</span>
<span class="line-removed"> 134 </span>
 135 Node* PhaseMacroExpand::opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path) {
 136   Node* cmp;
 137   if (mask != 0) {
 138     Node* and_node = transform_later(new AndXNode(word, MakeConX(mask)));
 139     cmp = transform_later(new CmpXNode(and_node, MakeConX(bits)));
 140   } else {
 141     cmp = word;
 142   }
 143   Node* bol = transform_later(new BoolNode(cmp, BoolTest::ne));
 144   IfNode* iff = new IfNode( ctrl, bol, PROB_MIN, COUNT_UNKNOWN );
 145   transform_later(iff);
 146 
 147   // Fast path taken.
 148   Node *fast_taken = transform_later(new IfFalseNode(iff));
 149 
 150   // Fast path not-taken, i.e. slow path
 151   Node *slow_taken = transform_later(new IfTrueNode(iff));
 152 
 153   if (return_fast_path) {
 154     region-&gt;init_req(edge, slow_taken); // Capture slow-control
</pre>
<hr />
<pre>
 167   call-&gt;init_req( TypeFunc::Memory , oldcall-&gt;in( TypeFunc::Memory ) ); // ?????
 168   call-&gt;init_req( TypeFunc::ReturnAdr, oldcall-&gt;in( TypeFunc::ReturnAdr ) );
 169   call-&gt;init_req( TypeFunc::FramePtr, oldcall-&gt;in( TypeFunc::FramePtr ) );
 170 }
 171 
 172 //------------------------------make_slow_call---------------------------------
 173 CallNode* PhaseMacroExpand::make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type,
 174                                            address slow_call, const char* leaf_name, Node* slow_path,
 175                                            Node* parm0, Node* parm1, Node* parm2) {
 176 
 177   // Slow-path call
 178  CallNode *call = leaf_name
 179    ? (CallNode*)new CallLeafNode      ( slow_call_type, slow_call, leaf_name, TypeRawPtr::BOTTOM )
 180    : (CallNode*)new CallStaticJavaNode( slow_call_type, slow_call, OptoRuntime::stub_name(slow_call), oldcall-&gt;jvms()-&gt;bci(), TypeRawPtr::BOTTOM );
 181 
 182   // Slow path call has no side-effects, uses few values
 183   copy_predefined_input_for_runtime_call(slow_path, oldcall, call );
 184   if (parm0 != NULL)  call-&gt;init_req(TypeFunc::Parms+0, parm0);
 185   if (parm1 != NULL)  call-&gt;init_req(TypeFunc::Parms+1, parm1);
 186   if (parm2 != NULL)  call-&gt;init_req(TypeFunc::Parms+2, parm2);
<span class="line-modified"> 187   copy_call_debug_info(oldcall, call);</span>
 188   call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
 189   _igvn.replace_node(oldcall, call);
 190   transform_later(call);
 191 
 192   return call;
 193 }
 194 
 195 void PhaseMacroExpand::extract_call_projections(CallNode *call) {
 196   _fallthroughproj = NULL;
 197   _fallthroughcatchproj = NULL;
 198   _ioproj_fallthrough = NULL;
 199   _ioproj_catchall = NULL;
 200   _catchallcatchproj = NULL;
 201   _memproj_fallthrough = NULL;
 202   _memproj_catchall = NULL;
 203   _resproj = NULL;
 204   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
 205     ProjNode *pn = call-&gt;fast_out(i)-&gt;as_Proj();
 206     switch (pn-&gt;_con) {
 207       case TypeFunc::Control:
</pre>
<hr />
<pre>
 275           if (call-&gt;as_ArrayCopy()-&gt;modifies(offset, offset, phase, false)) {
 276             return in;
 277           }
 278         }
 279         mem = in-&gt;in(TypeFunc::Memory);
 280       } else if (in-&gt;is_MemBar()) {
 281         ArrayCopyNode* ac = NULL;
 282         if (ArrayCopyNode::may_modify(tinst, in-&gt;as_MemBar(), phase, ac)) {
 283           assert(ac != NULL &amp;&amp; ac-&gt;is_clonebasic(), &quot;Only basic clone is a non escaping clone&quot;);
 284           return ac;
 285         }
 286         mem = in-&gt;in(TypeFunc::Memory);
 287       } else {
 288         assert(false, &quot;unexpected projection&quot;);
 289       }
 290     } else if (mem-&gt;is_Store()) {
 291       const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 292       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 293       if (adr_idx == alias_idx) {
 294         assert(atype-&gt;isa_oopptr(), &quot;address type must be oopptr&quot;);
<span class="line-modified"> 295         int adr_offset = atype-&gt;offset();</span>
 296         uint adr_iid = atype-&gt;is_oopptr()-&gt;instance_id();
 297         // Array elements references have the same alias_idx
 298         // but different offset and different instance_id.
 299         if (adr_offset == offset &amp;&amp; adr_iid == alloc-&gt;_idx)
 300           return mem;
 301       } else {
 302         assert(adr_idx == Compile::AliasIdxRaw, &quot;address must match or be raw&quot;);
 303       }
 304       mem = mem-&gt;in(MemNode::Memory);
 305     } else if (mem-&gt;is_ClearArray()) {
 306       if (!ClearArrayNode::step_through(&amp;mem, alloc-&gt;_idx, phase)) {
 307         // Can not bypass initialization of the instance
 308         // we are looking.
 309         debug_only(intptr_t offset;)
 310         assert(alloc == AllocateNode::Ideal_allocation(mem-&gt;in(3), phase, offset), &quot;sanity&quot;);
 311         InitializeNode* init = alloc-&gt;as_Allocate()-&gt;initialization();
 312         // We are looking for stored value, return Initialize node
 313         // or memory edge from Allocate node.
 314         if (init != NULL)
 315           return init;
</pre>
<hr />
<pre>
 318       }
 319       // Otherwise skip it (the call updated &#39;mem&#39; value).
 320     } else if (mem-&gt;Opcode() == Op_SCMemProj) {
 321       mem = mem-&gt;in(0);
 322       Node* adr = NULL;
 323       if (mem-&gt;is_LoadStore()) {
 324         adr = mem-&gt;in(MemNode::Address);
 325       } else {
 326         assert(mem-&gt;Opcode() == Op_EncodeISOArray ||
 327                mem-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 328         adr = mem-&gt;in(3); // Destination array
 329       }
 330       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 331       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 332       if (adr_idx == alias_idx) {
 333         DEBUG_ONLY(mem-&gt;dump();)
 334         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 335         return NULL;
 336       }
 337       mem = mem-&gt;in(MemNode::Memory);
<span class="line-modified"> 338    } else if (mem-&gt;Opcode() == Op_StrInflatedCopy) {</span>
 339       Node* adr = mem-&gt;in(3); // Destination array
 340       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 341       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 342       if (adr_idx == alias_idx) {
 343         DEBUG_ONLY(mem-&gt;dump();)
 344         assert(false, &quot;Object is not scalar replaceable if a StrInflatedCopy node accesses its field&quot;);
 345         return NULL;
 346       }
 347       mem = mem-&gt;in(MemNode::Memory);
 348     } else {
 349       return mem;
 350     }
 351     assert(mem != orig_mem, &quot;dead memory loop&quot;);
 352   }
 353 }
 354 
 355 // Generate loads from source of the arraycopy for fields of
 356 // destination needed at a deoptimization point
 357 Node* PhaseMacroExpand::make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {
 358   BasicType bt = ft;
</pre>
<hr />
<pre>
 361     bt = T_OBJECT;
 362     type = ftype-&gt;make_oopptr();
 363   }
 364   Node* res = NULL;
 365   if (ac-&gt;is_clonebasic()) {
 366     assert(ac-&gt;in(ArrayCopyNode::Src) != ac-&gt;in(ArrayCopyNode::Dest), &quot;clone source equals destination&quot;);
 367     Node* base = ac-&gt;in(ArrayCopyNode::Src);
 368     Node* adr = _igvn.transform(new AddPNode(base, base, MakeConX(offset)));
 369     const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(offset);
 370     res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 371   } else {
 372     if (ac-&gt;modifies(offset, offset, &amp;_igvn, true)) {
 373       assert(ac-&gt;in(ArrayCopyNode::Dest) == alloc-&gt;result_cast(), &quot;arraycopy destination should be allocation&#39;s result&quot;);
 374       uint shift = exact_log2(type2aelembytes(bt));
 375       Node* src_pos = ac-&gt;in(ArrayCopyNode::SrcPos);
 376       Node* dest_pos = ac-&gt;in(ArrayCopyNode::DestPos);
 377       const TypeInt* src_pos_t = _igvn.type(src_pos)-&gt;is_int();
 378       const TypeInt* dest_pos_t = _igvn.type(dest_pos)-&gt;is_int();
 379 
 380       Node* adr = NULL;
<span class="line-modified"> 381       const TypePtr* adr_type = NULL;</span>


 382       if (src_pos_t-&gt;is_con() &amp;&amp; dest_pos_t-&gt;is_con()) {
 383         intptr_t off = ((src_pos_t-&gt;get_con() - dest_pos_t-&gt;get_con()) &lt;&lt; shift) + offset;
<span class="line-modified"> 384         Node* base = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-modified"> 385         adr = _igvn.transform(new AddPNode(base, base, MakeConX(off)));</span>
 386         adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(off);
 387         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 388           // Don&#39;t emit a new load from src if src == dst but try to get the value from memory instead
 389           return value_from_mem(ac-&gt;in(TypeFunc::Memory), ctl, ft, ftype, adr_type-&gt;isa_oopptr(), alloc);
 390         }
 391       } else {





 392         Node* diff = _igvn.transform(new SubINode(ac-&gt;in(ArrayCopyNode::SrcPos), ac-&gt;in(ArrayCopyNode::DestPos)));
 393 #ifdef _LP64
 394         diff = _igvn.transform(new ConvI2LNode(diff));
 395 #endif
 396         diff = _igvn.transform(new LShiftXNode(diff, intcon(shift)));
 397 
 398         Node* off = _igvn.transform(new AddXNode(MakeConX(offset), diff));
<span class="line-modified"> 399         Node* base = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-modified"> 400         adr = _igvn.transform(new AddPNode(base, base, off));</span>
<span class="line-modified"> 401         adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(Type::OffsetBot);</span>
<span class="line-modified"> 402         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {</span>
<span class="line-modified"> 403           // Non constant offset in the array: we can&#39;t statically</span>
<span class="line-removed"> 404           // determine the value</span>
<span class="line-removed"> 405           return NULL;</span>
 406         }
 407       }
 408       res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 409     }
 410   }
 411   if (res != NULL) {
 412     res = _igvn.transform(res);
 413     if (ftype-&gt;isa_narrowoop()) {
 414       // PhaseMacroExpand::scalar_replacement adds DecodeN nodes

 415       res = _igvn.transform(new EncodePNode(res, ftype));
 416     }
 417     return res;
 418   }
 419   return NULL;
 420 }
 421 
 422 //
 423 // Given a Memory Phi, compute a value Phi containing the values from stores
 424 // on the input paths.
 425 // Note: this function is recursive, its depth is limited by the &quot;level&quot; argument
 426 // Returns the computed Phi, or NULL if it cannot compute it.
 427 Node *PhaseMacroExpand::value_from_mem_phi(Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {
 428   assert(mem-&gt;is_Phi(), &quot;sanity&quot;);
 429   int alias_idx = C-&gt;get_alias_index(adr_t);
<span class="line-modified"> 430   int offset = adr_t-&gt;offset();</span>
 431   int instance_id = adr_t-&gt;instance_id();
 432 
 433   // Check if an appropriate value phi already exists.
 434   Node* region = mem-&gt;in(0);
 435   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 436     Node* phi = region-&gt;fast_out(k);
 437     if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
 438         phi-&gt;as_Phi()-&gt;is_same_inst_field(phi_type, (int)mem-&gt;_idx, instance_id, alias_idx, offset)) {
 439       return phi;
 440     }
 441   }
 442   // Check if an appropriate new value phi already exists.
 443   Node* new_phi = value_phis-&gt;find(mem-&gt;_idx);
 444   if (new_phi != NULL)
 445     return new_phi;
 446 
 447   if (level &lt;= 0) {
 448     return NULL; // Give up: phi tree too deep
 449   }
 450   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 451   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 452 
 453   uint length = mem-&gt;req();
 454   GrowableArray &lt;Node *&gt; values(length, length, NULL);
 455 
 456   // create a new Phi for the value
 457   PhiNode *phi = new PhiNode(mem-&gt;in(0), phi_type, NULL, mem-&gt;_idx, instance_id, alias_idx, offset);
 458   transform_later(phi);
 459   value_phis-&gt;push(phi, mem-&gt;_idx);
 460 
 461   for (uint j = 1; j &lt; length; j++) {
 462     Node *in = mem-&gt;in(j);
 463     if (in == NULL || in-&gt;is_top()) {
 464       values.at_put(j, in);
 465     } else  {
 466       Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 467       if (val == start_mem || val == alloc_mem) {
 468         // hit a sentinel, return appropriate 0 value
<span class="line-modified"> 469         values.at_put(j, _igvn.zerocon(ft));</span>






 470         continue;
 471       }
 472       if (val-&gt;is_Initialize()) {
 473         val = val-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 474       }
 475       if (val == NULL) {
 476         return NULL;  // can&#39;t find a value on this path
 477       }
 478       if (val == mem) {
 479         values.at_put(j, mem);
 480       } else if (val-&gt;is_Store()) {
 481         Node* n = val-&gt;in(MemNode::ValueIn);
 482         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 483         n = bs-&gt;step_over_gc_barrier(n);
 484         values.at_put(j, n);
 485       } else if(val-&gt;is_Proj() &amp;&amp; val-&gt;in(0) == alloc) {
<span class="line-modified"> 486         values.at_put(j, _igvn.zerocon(ft));</span>






 487       } else if (val-&gt;is_Phi()) {
 488         val = value_from_mem_phi(val, ft, phi_type, adr_t, alloc, value_phis, level-1);
 489         if (val == NULL) {
 490           return NULL;
 491         }
 492         values.at_put(j, val);
 493       } else if (val-&gt;Opcode() == Op_SCMemProj) {
 494         assert(val-&gt;in(0)-&gt;is_LoadStore() ||
 495                val-&gt;in(0)-&gt;Opcode() == Op_EncodeISOArray ||
 496                val-&gt;in(0)-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 497         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 498         return NULL;
 499       } else if (val-&gt;is_ArrayCopy()) {
 500         Node* res = make_arraycopy_load(val-&gt;as_ArrayCopy(), offset, val-&gt;in(0), val-&gt;in(TypeFunc::Memory), ft, phi_type, alloc);
 501         if (res == NULL) {
 502           return NULL;
 503         }
 504         values.at_put(j, res);
 505       } else {
 506 #ifdef ASSERT
</pre>
<hr />
<pre>
 512     }
 513   }
 514   // Set Phi&#39;s inputs
 515   for (uint j = 1; j &lt; length; j++) {
 516     if (values.at(j) == mem) {
 517       phi-&gt;init_req(j, phi);
 518     } else {
 519       phi-&gt;init_req(j, values.at(j));
 520     }
 521   }
 522   return phi;
 523 }
 524 
 525 // Search the last value stored into the object&#39;s field.
 526 Node *PhaseMacroExpand::value_from_mem(Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {
 527   assert(adr_t-&gt;is_known_instance_field(), &quot;instance required&quot;);
 528   int instance_id = adr_t-&gt;instance_id();
 529   assert((uint)instance_id == alloc-&gt;_idx, &quot;wrong allocation&quot;);
 530 
 531   int alias_idx = C-&gt;get_alias_index(adr_t);
<span class="line-modified"> 532   int offset = adr_t-&gt;offset();</span>
 533   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
<span class="line-removed"> 534   Node *alloc_ctrl = alloc-&gt;in(TypeFunc::Control);</span>
 535   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 536   VectorSet visited;
 537 
 538   bool done = sfpt_mem == alloc_mem;
 539   Node *mem = sfpt_mem;
 540   while (!done) {
 541     if (visited.test_set(mem-&gt;_idx)) {
 542       return NULL;  // found a loop, give up
 543     }
 544     mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 545     if (mem == start_mem || mem == alloc_mem) {
 546       done = true;  // hit a sentinel, return appropriate 0 value
 547     } else if (mem-&gt;is_Initialize()) {
 548       mem = mem-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 549       if (mem == NULL) {
<span class="line-modified"> 550         done = true; // Something go wrong.</span>
 551       } else if (mem-&gt;is_Store()) {
 552         const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 553         assert(C-&gt;get_alias_index(atype) == Compile::AliasIdxRaw, &quot;store is correct memory slice&quot;);
 554         done = true;
 555       }
 556     } else if (mem-&gt;is_Store()) {
 557       const TypeOopPtr* atype = mem-&gt;as_Store()-&gt;adr_type()-&gt;isa_oopptr();
 558       assert(atype != NULL, &quot;address type must be oopptr&quot;);
 559       assert(C-&gt;get_alias_index(atype) == alias_idx &amp;&amp;
<span class="line-modified"> 560              atype-&gt;is_known_instance_field() &amp;&amp; atype-&gt;offset() == offset &amp;&amp;</span>
 561              atype-&gt;instance_id() == instance_id, &quot;store is correct memory slice&quot;);
 562       done = true;
 563     } else if (mem-&gt;is_Phi()) {
 564       // try to find a phi&#39;s unique input
 565       Node *unique_input = NULL;
 566       Node *top = C-&gt;top();
 567       for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 568         Node *n = scan_mem_chain(mem-&gt;in(i), alias_idx, offset, start_mem, alloc, &amp;_igvn);
 569         if (n == NULL || n == top || n == mem) {
 570           continue;
 571         } else if (unique_input == NULL) {
 572           unique_input = n;
 573         } else if (unique_input != n) {
 574           unique_input = top;
 575           break;
 576         }
 577       }
 578       if (unique_input != NULL &amp;&amp; unique_input != top) {
 579         mem = unique_input;
 580       } else {
 581         done = true;
 582       }
 583     } else if (mem-&gt;is_ArrayCopy()) {
 584       done = true;
 585     } else {
 586       assert(false, &quot;unexpected node&quot;);
 587     }
 588   }
 589   if (mem != NULL) {
 590     if (mem == start_mem || mem == alloc_mem) {
 591       // hit a sentinel, return appropriate 0 value





 592       return _igvn.zerocon(ft);
 593     } else if (mem-&gt;is_Store()) {
 594       Node* n = mem-&gt;in(MemNode::ValueIn);
 595       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 596       n = bs-&gt;step_over_gc_barrier(n);
 597       return n;
 598     } else if (mem-&gt;is_Phi()) {
 599       // attempt to produce a Phi reflecting the values on the input paths of the Phi
 600       Node_Stack value_phis(8);
 601       Node* phi = value_from_mem_phi(mem, ft, ftype, adr_t, alloc, &amp;value_phis, ValueSearchLimit);
 602       if (phi != NULL) {
 603         return phi;
 604       } else {
 605         // Kill all new Phis
 606         while(value_phis.is_nonempty()) {
 607           Node* n = value_phis.node();
 608           _igvn.replace_node(n, C-&gt;top());
 609           value_phis.pop();
 610         }
 611       }
 612     } else if (mem-&gt;is_ArrayCopy()) {
 613       Node* ctl = mem-&gt;in(0);
 614       Node* m = mem-&gt;in(TypeFunc::Memory);
 615       if (sfpt_ctl-&gt;is_Proj() &amp;&amp; sfpt_ctl-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {
 616         // pin the loads in the uncommon trap path
 617         ctl = sfpt_ctl;
 618         m = sfpt_mem;
 619       }
 620       return make_arraycopy_load(mem-&gt;as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);
 621     }
 622   }
<span class="line-modified"> 623   // Something go wrong.</span>
 624   return NULL;
 625 }
 626 





































 627 // Check the possibility of scalar replacement.
 628 bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 629   //  Scan the uses of the allocation to check for anything that would
 630   //  prevent us from eliminating it.
 631   NOT_PRODUCT( const char* fail_eliminate = NULL; )
 632   DEBUG_ONLY( Node* disq_node = NULL; )
 633   bool  can_eliminate = true;
 634 
 635   Node* res = alloc-&gt;result_cast();
 636   const TypeOopPtr* res_type = NULL;
 637   if (res == NULL) {
 638     // All users were eliminated.
 639   } else if (!res-&gt;is_CheckCastPP()) {
 640     NOT_PRODUCT(fail_eliminate = &quot;Allocation does not have unique CheckCastPP&quot;;)
 641     can_eliminate = false;
 642   } else {
 643     res_type = _igvn.type(res)-&gt;isa_oopptr();
 644     if (res_type == NULL) {
 645       NOT_PRODUCT(fail_eliminate = &quot;Neither instance or array allocation&quot;;)
 646       can_eliminate = false;
</pre>
<hr />
<pre>
 659       Node* use = res-&gt;fast_out(j);
 660 
 661       if (use-&gt;is_AddP()) {
 662         const TypePtr* addp_type = _igvn.type(use)-&gt;is_ptr();
 663         int offset = addp_type-&gt;offset();
 664 
 665         if (offset == Type::OffsetTop || offset == Type::OffsetBot) {
 666           NOT_PRODUCT(fail_eliminate = &quot;Undefined field referrence&quot;;)
 667           can_eliminate = false;
 668           break;
 669         }
 670         for (DUIterator_Fast kmax, k = use-&gt;fast_outs(kmax);
 671                                    k &lt; kmax &amp;&amp; can_eliminate; k++) {
 672           Node* n = use-&gt;fast_out(k);
 673           if (!n-&gt;is_Store() &amp;&amp; n-&gt;Opcode() != Op_CastP2X
 674               SHENANDOAHGC_ONLY(&amp;&amp; (!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n))) ) {
 675             DEBUG_ONLY(disq_node = n;)
 676             if (n-&gt;is_Load() || n-&gt;is_LoadStore()) {
 677               NOT_PRODUCT(fail_eliminate = &quot;Field load&quot;;)
 678             } else {
<span class="line-modified"> 679               NOT_PRODUCT(fail_eliminate = &quot;Not store field referrence&quot;;)</span>
 680             }
 681             can_eliminate = false;
 682           }
 683         }
 684       } else if (use-&gt;is_ArrayCopy() &amp;&amp;
 685                  (use-&gt;as_ArrayCopy()-&gt;is_clonebasic() ||
 686                   use-&gt;as_ArrayCopy()-&gt;is_arraycopy_validated() ||
 687                   use-&gt;as_ArrayCopy()-&gt;is_copyof_validated() ||
 688                   use-&gt;as_ArrayCopy()-&gt;is_copyofrange_validated()) &amp;&amp;
 689                  use-&gt;in(ArrayCopyNode::Dest) == res) {
 690         // ok to eliminate
 691       } else if (use-&gt;is_SafePoint()) {
 692         SafePointNode* sfpt = use-&gt;as_SafePoint();
 693         if (sfpt-&gt;is_Call() &amp;&amp; sfpt-&gt;as_Call()-&gt;has_non_debug_use(res)) {
 694           // Object is passed as argument.
 695           DEBUG_ONLY(disq_node = use;)
 696           NOT_PRODUCT(fail_eliminate = &quot;Object is passed as argument&quot;;)
 697           can_eliminate = false;
 698         }
 699         Node* sfptMem = sfpt-&gt;memory();
 700         if (sfptMem == NULL || sfptMem-&gt;is_top()) {
 701           DEBUG_ONLY(disq_node = use;)
 702           NOT_PRODUCT(fail_eliminate = &quot;NULL or TOP memory&quot;;)
 703           can_eliminate = false;
 704         } else {
 705           safepoints.append_if_missing(sfpt);
 706         }




 707       } else if (use-&gt;Opcode() != Op_CastP2X) { // CastP2X is used by card mark
 708         if (use-&gt;is_Phi()) {
 709           if (use-&gt;outcnt() == 1 &amp;&amp; use-&gt;unique_out()-&gt;Opcode() == Op_Return) {
 710             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 711           } else {
 712             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by Phi&quot;;)
 713           }
 714           DEBUG_ONLY(disq_node = use;)
 715         } else {
 716           if (use-&gt;Opcode() == Op_Return) {
 717             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
<span class="line-modified"> 718           }else {</span>
 719             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by node&quot;;)
 720           }
 721           DEBUG_ONLY(disq_node = use;)
 722         }
 723         can_eliminate = false;



 724       }
 725     }
 726   }
 727 
 728 #ifndef PRODUCT
 729   if (PrintEliminateAllocations) {
 730     if (can_eliminate) {
 731       tty-&gt;print(&quot;Scalar &quot;);
 732       if (res == NULL)
 733         alloc-&gt;dump();
 734       else
 735         res-&gt;dump();
 736     } else if (alloc-&gt;_is_scalar_replaceable) {
 737       tty-&gt;print(&quot;NotScalar (%s)&quot;, fail_eliminate);
 738       if (res == NULL)
 739         alloc-&gt;dump();
 740       else
 741         res-&gt;dump();
 742 #ifdef ASSERT
 743       if (disq_node != NULL) {
</pre>
<hr />
<pre>
 766   Node* res = alloc-&gt;result_cast();
 767   assert(res == NULL || res-&gt;is_CheckCastPP(), &quot;unexpected AllocateNode result&quot;);
 768   const TypeOopPtr* res_type = NULL;
 769   if (res != NULL) { // Could be NULL when there are no users
 770     res_type = _igvn.type(res)-&gt;isa_oopptr();
 771   }
 772 
 773   if (res != NULL) {
 774     klass = res_type-&gt;klass();
 775     if (res_type-&gt;isa_instptr()) {
 776       // find the fields of the class which will be needed for safepoint debug information
 777       assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass.&quot;);
 778       iklass = klass-&gt;as_instance_klass();
 779       nfields = iklass-&gt;nof_nonstatic_fields();
 780     } else {
 781       // find the array&#39;s elements which will be needed for safepoint debug information
 782       nfields = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 783       assert(klass-&gt;is_array_klass() &amp;&amp; nfields &gt;= 0, &quot;must be an array klass.&quot;);
 784       elem_type = klass-&gt;as_array_klass()-&gt;element_type();
 785       basic_elem_type = elem_type-&gt;basic_type();




 786       array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 787       element_size = type2aelembytes(basic_elem_type);




 788     }
 789   }
 790   //
 791   // Process the safepoint uses
 792   //

 793   while (safepoints.length() &gt; 0) {
 794     SafePointNode* sfpt = safepoints.pop();
 795     Node* mem = sfpt-&gt;memory();
 796     Node* ctl = sfpt-&gt;control();
 797     assert(sfpt-&gt;jvms() != NULL, &quot;missed JVMS&quot;);
 798     // Fields of scalar objs are referenced only at the end
 799     // of regular debuginfo at the last (youngest) JVMS.
 800     // Record relative start index.
 801     uint first_ind = (sfpt-&gt;req() - sfpt-&gt;jvms()-&gt;scloff());
 802     SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,
 803 #ifdef ASSERT
 804                                                  alloc,
 805 #endif
 806                                                  first_ind, nfields);
 807     sobj-&gt;init_req(0, C-&gt;root());
 808     transform_later(sobj);
 809 
 810     // Scan object&#39;s fields adding an input to the safepoint for each field.
 811     for (int j = 0; j &lt; nfields; j++) {
 812       intptr_t offset;
 813       ciField* field = NULL;
 814       if (iklass != NULL) {
 815         field = iklass-&gt;nonstatic_field_at(j);
 816         offset = field-&gt;offset();
 817         elem_type = field-&gt;type();
 818         basic_elem_type = field-&gt;layout_type();

 819       } else {
 820         offset = array_base + j * (intptr_t)element_size;
 821       }
 822 
 823       const Type *field_type;
 824       // The next code is taken from Parse::do_get_xxx().
 825       if (is_reference_type(basic_elem_type)) {
 826         if (!elem_type-&gt;is_loaded()) {
 827           field_type = TypeInstPtr::BOTTOM;
 828         } else if (field != NULL &amp;&amp; field-&gt;is_static_constant()) {
 829           // This can happen if the constant oop is non-perm.
 830           ciObject* con = field-&gt;constant_value().as_object();
 831           // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
 832           // and may yield a vacuous result if the field is of interface type.
 833           field_type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
 834           assert(field_type != NULL, &quot;field singleton type must be consistent&quot;);
 835         } else {
 836           field_type = TypeOopPtr::make_from_klass(elem_type-&gt;as_klass());
 837         }
 838         if (UseCompressedOops) {
 839           field_type = field_type-&gt;make_narrowoop();
 840           basic_elem_type = T_NARROWOOP;
 841         }
 842       } else {
 843         field_type = Type::get_const_basic_type(basic_elem_type);
 844       }
 845 
<span class="line-modified"> 846       const TypeOopPtr *field_addr_type = res_type-&gt;add_offset(offset)-&gt;isa_oopptr();</span>
<span class="line-modified"> 847 </span>
<span class="line-modified"> 848       Node *field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);</span>






 849       if (field_val == NULL) {
 850         // We weren&#39;t able to find a value for this field,
 851         // give up on eliminating this allocation.
 852 
 853         // Remove any extra entries we added to the safepoint.
 854         uint last = sfpt-&gt;req() - 1;
 855         for (int k = 0;  k &lt; j; k++) {
 856           sfpt-&gt;del_req(last--);
 857         }
 858         _igvn._worklist.push(sfpt);
 859         // rollback processed safepoints
 860         while (safepoints_done.length() &gt; 0) {
 861           SafePointNode* sfpt_done = safepoints_done.pop();
 862           // remove any extra entries we added to the safepoint
 863           last = sfpt_done-&gt;req() - 1;
 864           for (int k = 0;  k &lt; nfields; k++) {
 865             sfpt_done-&gt;del_req(last--);
 866           }
 867           JVMState *jvms = sfpt_done-&gt;jvms();
 868           jvms-&gt;set_endoff(sfpt_done-&gt;req());
</pre>
<hr />
<pre>
 886         if (PrintEliminateAllocations) {
 887           if (field != NULL) {
 888             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of Field: &quot;,
 889                        sfpt-&gt;_idx);
 890             field-&gt;print();
 891             int field_idx = C-&gt;get_alias_index(field_addr_type);
 892             tty-&gt;print(&quot; (alias_idx=%d)&quot;, field_idx);
 893           } else { // Array&#39;s element
 894             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of array element [%d]&quot;,
 895                        sfpt-&gt;_idx, j);
 896           }
 897           tty-&gt;print(&quot;, which prevents elimination of: &quot;);
 898           if (res == NULL)
 899             alloc-&gt;dump();
 900           else
 901             res-&gt;dump();
 902         }
 903 #endif
 904         return false;
 905       }
<span class="line-modified"> 906       if (UseCompressedOops &amp;&amp; field_type-&gt;isa_narrowoop()) {</span>



 907         // Enable &quot;DecodeN(EncodeP(Allocate)) --&gt; Allocate&quot; transformation
 908         // to be able scalar replace the allocation.
 909         if (field_val-&gt;is_EncodeP()) {
 910           field_val = field_val-&gt;in(1);
 911         } else {
 912           field_val = transform_later(new DecodeNNode(field_val, field_val-&gt;get_ptr_type()));
 913         }
 914       }
 915       sfpt-&gt;add_req(field_val);
 916     }
 917     JVMState *jvms = sfpt-&gt;jvms();
 918     jvms-&gt;set_endoff(sfpt-&gt;req());
 919     // Now make a pass over the debug information replacing any references
 920     // to the allocated object with &quot;sobj&quot;
 921     int start = jvms-&gt;debug_start();
 922     int end   = jvms-&gt;debug_end();
 923     sfpt-&gt;replace_edges_in_range(res, sobj, start, end);
 924     _igvn._worklist.push(sfpt);
 925     safepoints_done.append_if_missing(sfpt); // keep it for rollback
 926   }





 927   return true;
 928 }
 929 
 930 static void disconnect_projections(MultiNode* n, PhaseIterGVN&amp; igvn) {
 931   Node* ctl_proj = n-&gt;proj_out_or_null(TypeFunc::Control);
 932   Node* mem_proj = n-&gt;proj_out_or_null(TypeFunc::Memory);
 933   if (ctl_proj != NULL) {
 934     igvn.replace_node(ctl_proj, n-&gt;in(0));
 935   }
 936   if (mem_proj != NULL) {
 937     igvn.replace_node(mem_proj, n-&gt;in(TypeFunc::Memory));
 938   }
 939 }
 940 
 941 // Process users of eliminated allocation.
<span class="line-modified"> 942 void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc) {</span>
 943   Node* res = alloc-&gt;result_cast();
 944   if (res != NULL) {
 945     for (DUIterator_Last jmin, j = res-&gt;last_outs(jmin); j &gt;= jmin; ) {
 946       Node *use = res-&gt;last_out(j);
 947       uint oc1 = res-&gt;outcnt();
 948 
 949       if (use-&gt;is_AddP()) {
 950         for (DUIterator_Last kmin, k = use-&gt;last_outs(kmin); k &gt;= kmin; ) {
 951           Node *n = use-&gt;last_out(k);
 952           uint oc2 = use-&gt;outcnt();
 953           if (n-&gt;is_Store()) {
<span class="line-modified"> 954 #ifdef ASSERT</span>
<span class="line-modified"> 955             // Verify that there is no dependent MemBarVolatile nodes,</span>
<span class="line-modified"> 956             // they should be removed during IGVN, see MemBarNode::Ideal().</span>
<span class="line-modified"> 957             for (DUIterator_Fast pmax, p = n-&gt;fast_outs(pmax);</span>
<span class="line-modified"> 958                                        p &lt; pmax; p++) {</span>
<span class="line-modified"> 959               Node* mb = n-&gt;fast_out(p);</span>
<span class="line-modified"> 960               assert(mb-&gt;is_Initialize() || !mb-&gt;is_MemBar() ||</span>
<span class="line-removed"> 961                      mb-&gt;req() &lt;= MemBarNode::Precedent ||</span>
<span class="line-removed"> 962                      mb-&gt;in(MemBarNode::Precedent) != n,</span>
<span class="line-removed"> 963                      &quot;MemBarVolatile should be eliminated for non-escaping object&quot;);</span>
 964             }
<span class="line-removed"> 965 #endif</span>
 966             _igvn.replace_node(n, n-&gt;in(MemNode::Memory));
 967           } else {
 968             eliminate_gc_barrier(n);
 969           }
 970           k -= (oc2 - use-&gt;outcnt());
 971         }
 972         _igvn.remove_dead_node(use);
 973       } else if (use-&gt;is_ArrayCopy()) {
 974         // Disconnect ArrayCopy node
 975         ArrayCopyNode* ac = use-&gt;as_ArrayCopy();
 976         if (ac-&gt;is_clonebasic()) {
 977           Node* membar_after = ac-&gt;proj_out(TypeFunc::Control)-&gt;unique_ctrl_out();
 978           disconnect_projections(ac, _igvn);
 979           assert(alloc-&gt;in(TypeFunc::Memory)-&gt;is_Proj() &amp;&amp; alloc-&gt;in(TypeFunc::Memory)-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;mem barrier expected before allocation&quot;);
 980           Node* membar_before = alloc-&gt;in(TypeFunc::Memory)-&gt;in(0);
 981           disconnect_projections(membar_before-&gt;as_MemBar(), _igvn);
 982           if (membar_after-&gt;is_MemBar()) {
 983             disconnect_projections(membar_after-&gt;as_MemBar(), _igvn);
 984           }
 985         } else {
 986           assert(ac-&gt;is_arraycopy_validated() ||
 987                  ac-&gt;is_copyof_validated() ||
 988                  ac-&gt;is_copyofrange_validated(), &quot;unsupported&quot;);
<span class="line-modified"> 989           CallProjections callprojs;</span>
<span class="line-removed"> 990           ac-&gt;extract_projections(&amp;callprojs, true);</span>
 991 
<span class="line-modified"> 992           _igvn.replace_node(callprojs.fallthrough_ioproj, ac-&gt;in(TypeFunc::I_O));</span>
<span class="line-modified"> 993           _igvn.replace_node(callprojs.fallthrough_memproj, ac-&gt;in(TypeFunc::Memory));</span>
<span class="line-modified"> 994           _igvn.replace_node(callprojs.fallthrough_catchproj, ac-&gt;in(TypeFunc::Control));</span>
 995 
 996           // Set control to top. IGVN will remove the remaining projections
 997           ac-&gt;set_req(0, top());
 998           ac-&gt;replace_edge(res, top());
 999 
1000           // Disconnect src right away: it can help find new
1001           // opportunities for allocation elimination
1002           Node* src = ac-&gt;in(ArrayCopyNode::Src);
1003           ac-&gt;replace_edge(src, top());
1004           // src can be top at this point if src and dest of the
1005           // arraycopy were the same
1006           if (src-&gt;outcnt() == 0 &amp;&amp; !src-&gt;is_top()) {
1007             _igvn.remove_dead_node(src);
1008           }
1009         }
1010         _igvn._worklist.push(ac);






1011       } else {
1012         eliminate_gc_barrier(use);
1013       }
1014       j -= (oc1 - res-&gt;outcnt());
1015     }
1016     assert(res-&gt;outcnt() == 0, &quot;all uses of allocated objects must be deleted&quot;);
1017     _igvn.remove_dead_node(res);
1018   }
1019 
1020   //
1021   // Process other users of allocation&#39;s projections
1022   //
1023   if (_resproj != NULL &amp;&amp; _resproj-&gt;outcnt() != 0) {
1024     // First disconnect stores captured by Initialize node.
1025     // If Initialize node is eliminated first in the following code,
1026     // it will kill such stores and DUIterator_Last will assert.
1027     for (DUIterator_Fast jmax, j = _resproj-&gt;fast_outs(jmax);  j &lt; jmax; j++) {
1028       Node *use = _resproj-&gt;fast_out(j);
1029       if (use-&gt;is_AddP()) {
1030         // raw memory addresses used only by the initialization
1031         _igvn.replace_node(use, C-&gt;top());
1032         --j; --jmax;
1033       }
1034     }
1035     for (DUIterator_Last jmin, j = _resproj-&gt;last_outs(jmin); j &gt;= jmin; ) {
1036       Node *use = _resproj-&gt;last_out(j);
1037       uint oc1 = _resproj-&gt;outcnt();
1038       if (use-&gt;is_Initialize()) {
1039         // Eliminate Initialize node.
1040         InitializeNode *init = use-&gt;as_Initialize();
1041         assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
1042         Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
1043         if (ctrl_proj != NULL) {





1044           _igvn.replace_node(ctrl_proj, init-&gt;in(TypeFunc::Control));
1045 #ifdef ASSERT
1046           Node* tmp = init-&gt;in(TypeFunc::Control);
1047           assert(tmp == _fallthroughcatchproj, &quot;allocation control projection&quot;);
1048 #endif
1049         }
1050         Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
1051         if (mem_proj != NULL) {
1052           Node *mem = init-&gt;in(TypeFunc::Memory);
1053 #ifdef ASSERT
1054           if (mem-&gt;is_MergeMem()) {
1055             assert(mem-&gt;in(TypeFunc::Memory) == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1056           } else {
1057             assert(mem == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1058           }
1059 #endif
1060           _igvn.replace_node(mem_proj, mem);
1061         }




1062       } else  {
1063         assert(false, &quot;only Initialize or AddP expected&quot;);
1064       }
1065       j -= (oc1 - _resproj-&gt;outcnt());
1066     }
1067   }
1068   if (_fallthroughcatchproj != NULL) {
1069     _igvn.replace_node(_fallthroughcatchproj, alloc-&gt;in(TypeFunc::Control));
1070   }
1071   if (_memproj_fallthrough != NULL) {
1072     _igvn.replace_node(_memproj_fallthrough, alloc-&gt;in(TypeFunc::Memory));
1073   }
1074   if (_memproj_catchall != NULL) {
1075     _igvn.replace_node(_memproj_catchall, C-&gt;top());
1076   }
1077   if (_ioproj_fallthrough != NULL) {
1078     _igvn.replace_node(_ioproj_fallthrough, alloc-&gt;in(TypeFunc::I_O));
1079   }
1080   if (_ioproj_catchall != NULL) {
1081     _igvn.replace_node(_ioproj_catchall, C-&gt;top());
1082   }
1083   if (_catchallcatchproj != NULL) {
1084     _igvn.replace_node(_catchallcatchproj, C-&gt;top());
1085   }
1086 }
1087 
1088 bool PhaseMacroExpand::eliminate_allocate_node(AllocateNode *alloc) {
1089   // Don&#39;t do scalar replacement if the frame can be popped by JVMTI:
1090   // if reallocation fails during deoptimization we&#39;ll pop all
1091   // interpreter frames for this compiled frame and that won&#39;t play
1092   // nice with JVMTI popframe.
<span class="line-modified">1093   if (!EliminateAllocations || JvmtiExport::can_pop_frame() || !alloc-&gt;_is_non_escaping) {</span>
1094     return false;
1095   }
1096   Node* klass = alloc-&gt;in(AllocateNode::KlassNode);
1097   const TypeKlassPtr* tklass = _igvn.type(klass)-&gt;is_klassptr();
<span class="line-modified">1098   Node* res = alloc-&gt;result_cast();</span>






1099   // Eliminate boxing allocations which are not used
<span class="line-modified">1100   // regardless scalar replacable status.</span>
<span class="line-modified">1101   bool boxing_alloc = C-&gt;eliminate_boxing() &amp;&amp;</span>
<span class="line-modified">1102                       tklass-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;</span>

1103                       tklass-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
<span class="line-modified">1104   if (!alloc-&gt;_is_scalar_replaceable &amp;&amp; (!boxing_alloc || (res != NULL))) {</span>
1105     return false;
1106   }
1107 
1108   extract_call_projections(alloc);
1109 
1110   GrowableArray &lt;SafePointNode *&gt; safepoints;
1111   if (!can_eliminate_allocation(alloc, safepoints)) {
1112     return false;
1113   }
1114 
1115   if (!alloc-&gt;_is_scalar_replaceable) {
<span class="line-modified">1116     assert(res == NULL, &quot;sanity&quot;);</span>
1117     // We can only eliminate allocation if all debug info references
1118     // are already replaced with SafePointScalarObject because
1119     // we can&#39;t search for a fields value without instance_id.
1120     if (safepoints.length() &gt; 0) {

1121       return false;
1122     }
1123   }
1124 
1125   if (!scalar_replacement(alloc, safepoints)) {
1126     return false;
1127   }
1128 
1129   CompileLog* log = C-&gt;log();
1130   if (log != NULL) {
1131     log-&gt;head(&quot;eliminate_allocation type=&#39;%d&#39;&quot;,
1132               log-&gt;identify(tklass-&gt;klass()));
1133     JVMState* p = alloc-&gt;jvms();
1134     while (p != NULL) {
1135       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1136       p = p-&gt;caller();
1137     }
1138     log-&gt;tail(&quot;eliminate_allocation&quot;);
1139   }
1140 
<span class="line-modified">1141   process_users_of_allocation(alloc);</span>
1142 
1143 #ifndef PRODUCT
1144   if (PrintEliminateAllocations) {
1145     if (alloc-&gt;is_AllocateArray())
1146       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1147     else
1148       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1149   }
1150 #endif
1151 
1152   return true;
1153 }
1154 
1155 bool PhaseMacroExpand::eliminate_boxing_node(CallStaticJavaNode *boxing) {
1156   // EA should remove all uses of non-escaping boxing node.
1157   if (!C-&gt;eliminate_boxing() || boxing-&gt;proj_out_or_null(TypeFunc::Parms) != NULL) {
1158     return false;
1159   }
1160 
1161   assert(boxing-&gt;result_cast() == NULL, &quot;unexpected boxing node result&quot;);
1162 
1163   extract_call_projections(boxing);
1164 
<span class="line-modified">1165   const TypeTuple* r = boxing-&gt;tf()-&gt;range();</span>
1166   assert(r-&gt;cnt() &gt; TypeFunc::Parms, &quot;sanity&quot;);
1167   const TypeInstPtr* t = r-&gt;field_at(TypeFunc::Parms)-&gt;isa_instptr();
1168   assert(t != NULL, &quot;sanity&quot;);
1169 
1170   CompileLog* log = C-&gt;log();
1171   if (log != NULL) {
1172     log-&gt;head(&quot;eliminate_boxing type=&#39;%d&#39;&quot;,
1173               log-&gt;identify(t-&gt;klass()));
1174     JVMState* p = boxing-&gt;jvms();
1175     while (p != NULL) {
1176       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1177       p = p-&gt;caller();
1178     }
1179     log-&gt;tail(&quot;eliminate_boxing&quot;);
1180   }
1181 
1182   process_users_of_allocation(boxing);
1183 
1184 #ifndef PRODUCT
1185   if (PrintEliminateAllocations) {
</pre>
<hr />
<pre>
1346         }
1347       }
1348 #endif
1349       yank_alloc_node(alloc);
1350       return;
1351     }
1352   }
1353 
1354   enum { too_big_or_final_path = 1, need_gc_path = 2 };
1355   Node *slow_region = NULL;
1356   Node *toobig_false = ctrl;
1357 
1358   // generate the initial test if necessary
1359   if (initial_slow_test != NULL ) {
1360     assert (expand_fast_path, &quot;Only need test if there is a fast path&quot;);
1361     slow_region = new RegionNode(3);
1362 
1363     // Now make the initial failure test.  Usually a too-big test but
1364     // might be a TRUE for finalizers or a fancy class check for
1365     // newInstance0.
<span class="line-modified">1366     IfNode *toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);</span>
1367     transform_later(toobig_iff);
1368     // Plug the failing-too-big test into the slow-path region
<span class="line-modified">1369     Node *toobig_true = new IfTrueNode( toobig_iff );</span>
1370     transform_later(toobig_true);
1371     slow_region    -&gt;init_req( too_big_or_final_path, toobig_true );
<span class="line-modified">1372     toobig_false = new IfFalseNode( toobig_iff );</span>
1373     transform_later(toobig_false);
1374   } else {
1375     // No initial test, just fall into next case
1376     assert(allocation_has_use || !expand_fast_path, &quot;Should already have been handled&quot;);
1377     toobig_false = ctrl;
1378     debug_only(slow_region = NodeSentinel);
1379   }
1380 
1381   // If we are here there are several possibilities
1382   // - expand_fast_path is false - then only a slow path is expanded. That&#39;s it.
1383   // no_initial_check means a constant allocation.
1384   // - If check always evaluates to false -&gt; expand_fast_path is false (see above)
1385   // - If check always evaluates to true -&gt; directly into fast path (but may bailout to slowpath)
1386   // if !allocation_has_use the fast path is empty
1387   // if !allocation_has_use &amp;&amp; no_initial_check
1388   // - Then there are no fastpath that can fall out to slowpath -&gt; no allocation code at all.
1389   //   removed by yank_alloc_node above.
1390 
1391   Node *slow_mem = mem;  // save the current memory state for slow path
1392   // generate the fast allocation code unless we know that the initial test will always go slow
1393   if (expand_fast_path) {
1394     // Fast path modifies only raw memory.
1395     if (mem-&gt;is_MergeMem()) {
1396       mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
1397     }
1398 
1399     // allocate the Region and Phi nodes for the result
1400     result_region = new RegionNode(3);
1401     result_phi_rawmem = new PhiNode(result_region, Type::MEMORY, TypeRawPtr::BOTTOM);
1402     result_phi_i_o    = new PhiNode(result_region, Type::ABIO); // I/O is used for Prefetch
1403 
1404     // Grab regular I/O before optional prefetch may change it.
1405     // Slow-path does no I/O so just set it to the original I/O.
1406     result_phi_i_o-&gt;init_req(slow_result_path, i_o);
1407 
1408     // Name successful fast-path variables
1409     Node* fast_oop_ctrl;
1410     Node* fast_oop_rawmem;

1411     if (allocation_has_use) {
1412       Node* needgc_ctrl = NULL;
1413       result_phi_rawoop = new PhiNode(result_region, TypeRawPtr::BOTTOM);
1414 
1415       intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;
1416       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1417       Node* fast_oop = bs-&gt;obj_allocate(this, ctrl, mem, toobig_false, size_in_bytes, i_o, needgc_ctrl,
1418                                         fast_oop_ctrl, fast_oop_rawmem,
1419                                         prefetch_lines);
1420 
1421       if (initial_slow_test != NULL) {
1422         // This completes all paths into the slow merge point
1423         slow_region-&gt;init_req(need_gc_path, needgc_ctrl);
1424         transform_later(slow_region);
1425       } else {
1426         // No initial slow path needed!
1427         // Just fall from the need-GC path straight into the VM call.
1428         slow_region = needgc_ctrl;
1429       }
1430 
</pre>
<hr />
<pre>
1449     result_phi_rawmem-&gt;init_req(fast_result_path, fast_oop_rawmem);
1450   } else {
1451     slow_region = ctrl;
1452     result_phi_i_o = i_o; // Rename it to use in the following code.
1453   }
1454 
1455   // Generate slow-path call
1456   CallNode *call = new CallStaticJavaNode(slow_call_type, slow_call_address,
1457                                OptoRuntime::stub_name(slow_call_address),
1458                                alloc-&gt;jvms()-&gt;bci(),
1459                                TypePtr::BOTTOM);
1460   call-&gt;init_req(TypeFunc::Control,   slow_region);
1461   call-&gt;init_req(TypeFunc::I_O,       top());    // does no i/o
1462   call-&gt;init_req(TypeFunc::Memory,    slow_mem); // may gc ptrs
1463   call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1464   call-&gt;init_req(TypeFunc::FramePtr,  alloc-&gt;in(TypeFunc::FramePtr));
1465 
1466   call-&gt;init_req(TypeFunc::Parms+0, klass_node);
1467   if (length != NULL) {
1468     call-&gt;init_req(TypeFunc::Parms+1, length);



1469   }
1470 
1471   // Copy debug information and adjust JVMState information, then replace
1472   // allocate node with the call
<span class="line-modified">1473   copy_call_debug_info((CallNode *) alloc,  call);</span>
1474   if (expand_fast_path) {
1475     call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
1476   } else {
1477     // Hook i_o projection to avoid its elimination during allocation
1478     // replacement (when only a slow call is generated).
1479     call-&gt;set_req(TypeFunc::I_O, result_phi_i_o);
1480   }
1481   _igvn.replace_node(alloc, call);
1482   transform_later(call);
1483 
1484   // Identify the output projections from the allocate node and
1485   // adjust any references to them.
1486   // The control and io projections look like:
1487   //
1488   //        v---Proj(ctrl) &lt;-----+   v---CatchProj(ctrl)
1489   //  Allocate                   Catch
1490   //        ^---Proj(io) &lt;-------+   ^---CatchProj(io)
1491   //
1492   //  We are interested in the CatchProj nodes.
1493   //
1494   extract_call_projections(call);
1495 
1496   // An allocate node has separate memory projections for the uses on
1497   // the control and i_o paths. Replace the control memory projection with
1498   // result_phi_rawmem (unless we are only generating a slow call when
1499   // both memory projections are combined)
1500   if (expand_fast_path &amp;&amp; _memproj_fallthrough != NULL) {
<span class="line-modified">1501     migrate_outs(_memproj_fallthrough, result_phi_rawmem);</span>
1502   }
1503   // Now change uses of _memproj_catchall to use _memproj_fallthrough and delete
1504   // _memproj_catchall so we end up with a call that has only 1 memory projection.
<span class="line-modified">1505   if (_memproj_catchall != NULL ) {</span>
1506     if (_memproj_fallthrough == NULL) {
1507       _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);
1508       transform_later(_memproj_fallthrough);
1509     }
<span class="line-modified">1510     migrate_outs(_memproj_catchall, _memproj_fallthrough);</span>
1511     _igvn.remove_dead_node(_memproj_catchall);
1512   }
1513 
1514   // An allocate node has separate i_o projections for the uses on the control
1515   // and i_o paths. Always replace the control i_o projection with result i_o
1516   // otherwise incoming i_o become dead when only a slow call is generated
1517   // (it is different from memory projections where both projections are
1518   // combined in such case).
1519   if (_ioproj_fallthrough != NULL) {
<span class="line-modified">1520     migrate_outs(_ioproj_fallthrough, result_phi_i_o);</span>
1521   }
1522   // Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete
1523   // _ioproj_catchall so we end up with a call that has only 1 i_o projection.
<span class="line-modified">1524   if (_ioproj_catchall != NULL ) {</span>
1525     if (_ioproj_fallthrough == NULL) {
1526       _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);
1527       transform_later(_ioproj_fallthrough);
1528     }
<span class="line-modified">1529     migrate_outs(_ioproj_catchall, _ioproj_fallthrough);</span>
1530     _igvn.remove_dead_node(_ioproj_catchall);
1531   }
1532 
1533   // if we generated only a slow call, we are done
1534   if (!expand_fast_path) {
1535     // Now we can unhook i_o.
1536     if (result_phi_i_o-&gt;outcnt() &gt; 1) {
1537       call-&gt;set_req(TypeFunc::I_O, top());
1538     } else {
1539       assert(result_phi_i_o-&gt;unique_ctrl_out() == call, &quot;sanity&quot;);
1540       // Case of new array with negative size known during compilation.
1541       // AllocateArrayNode::Ideal() optimization disconnect unreachable
1542       // following code since call to runtime will throw exception.
1543       // As result there will be no users of i_o after the call.
1544       // Leave i_o attached to this call to avoid problems in preceding graph.
1545     }
1546     return;
1547   }
1548 
1549   if (_fallthroughcatchproj != NULL) {
</pre>
<hr />
<pre>
1577 }
1578 
1579 // Remove alloc node that has no uses.
1580 void PhaseMacroExpand::yank_alloc_node(AllocateNode* alloc) {
1581   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1582   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1583   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1584 
1585   extract_call_projections(alloc);
1586   if (_resproj != NULL) {
1587     for (DUIterator_Fast imax, i = _resproj-&gt;fast_outs(imax); i &lt; imax; i++) {
1588       Node* use = _resproj-&gt;fast_out(i);
1589       use-&gt;isa_MemBar()-&gt;remove(&amp;_igvn);
1590       --imax;
1591       --i; // back up iterator
1592     }
1593     assert(_resproj-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);
1594     _igvn.remove_dead_node(_resproj);
1595   }
1596   if (_fallthroughcatchproj != NULL) {
<span class="line-modified">1597     migrate_outs(_fallthroughcatchproj, ctrl);</span>
1598     _igvn.remove_dead_node(_fallthroughcatchproj);
1599   }
1600   if (_catchallcatchproj != NULL) {
1601     _igvn.rehash_node_delayed(_catchallcatchproj);
1602     _catchallcatchproj-&gt;set_req(0, top());
1603   }
1604   if (_fallthroughproj != NULL) {
1605     Node* catchnode = _fallthroughproj-&gt;unique_ctrl_out();
1606     _igvn.remove_dead_node(catchnode);
1607     _igvn.remove_dead_node(_fallthroughproj);
1608   }
1609   if (_memproj_fallthrough != NULL) {
<span class="line-modified">1610     migrate_outs(_memproj_fallthrough, mem);</span>
1611     _igvn.remove_dead_node(_memproj_fallthrough);
1612   }
1613   if (_ioproj_fallthrough != NULL) {
<span class="line-modified">1614     migrate_outs(_ioproj_fallthrough, i_o);</span>
1615     _igvn.remove_dead_node(_ioproj_fallthrough);
1616   }
1617   if (_memproj_catchall != NULL) {
1618     _igvn.rehash_node_delayed(_memproj_catchall);
1619     _memproj_catchall-&gt;set_req(0, top());
1620   }
1621   if (_ioproj_catchall != NULL) {
1622     _igvn.rehash_node_delayed(_ioproj_catchall);
1623     _ioproj_catchall-&gt;set_req(0, top());
1624   }
1625 #ifndef PRODUCT
1626   if (PrintEliminateAllocations) {
1627     if (alloc-&gt;is_AllocateArray()) {
1628       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1629     } else {
1630       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1631     }
1632   }
1633 #endif
1634   _igvn.remove_dead_node(alloc);
</pre>
<hr />
<pre>
1720     Node* thread = new ThreadLocalNode();
1721     transform_later(thread);
1722 
1723     call-&gt;init_req(TypeFunc::Parms + 0, thread);
1724     call-&gt;init_req(TypeFunc::Parms + 1, oop);
1725     call-&gt;init_req(TypeFunc::Control, ctrl);
1726     call-&gt;init_req(TypeFunc::I_O    , top()); // does no i/o
1727     call-&gt;init_req(TypeFunc::Memory , ctrl);
1728     call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1729     call-&gt;init_req(TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr));
1730     transform_later(call);
1731     ctrl = new ProjNode(call, TypeFunc::Control);
1732     transform_later(ctrl);
1733     rawmem = new ProjNode(call, TypeFunc::Memory);
1734     transform_later(rawmem);
1735   }
1736 }
1737 
1738 // Helper for PhaseMacroExpand::expand_allocate_common.
1739 // Initializes the newly-allocated storage.
<span class="line-modified">1740 Node*</span>
<span class="line-modified">1741 PhaseMacroExpand::initialize_object(AllocateNode* alloc,</span>
<span class="line-modified">1742                                     Node* control, Node* rawmem, Node* object,</span>
<span class="line-modified">1743                                     Node* klass_node, Node* length,</span>
<span class="line-removed">1744                                     Node* size_in_bytes) {</span>
1745   InitializeNode* init = alloc-&gt;initialization();
1746   // Store the klass &amp; mark bits
<span class="line-modified">1747   Node* mark_node = alloc-&gt;make_ideal_mark(&amp;_igvn, object, control, rawmem);</span>
1748   if (!mark_node-&gt;is_Con()) {
1749     transform_later(mark_node);
1750   }
1751   rawmem = make_store(control, rawmem, object, oopDesc::mark_offset_in_bytes(), mark_node, TypeX_X-&gt;basic_type());
1752 
1753   rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);
1754   int header_size = alloc-&gt;minimum_header_size();  // conservatively small
1755 
1756   // Array length
1757   if (length != NULL) {         // Arrays need length field
1758     rawmem = make_store(control, rawmem, object, arrayOopDesc::length_offset_in_bytes(), length, T_INT);
1759     // conservatively small header size:
1760     header_size = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1761     ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1762     if (k-&gt;is_array_klass())    // we know the exact header size in most cases:
1763       header_size = Klass::layout_helper_header_size(k-&gt;layout_helper());
1764   }
1765 
1766   // Clear the object body, if necessary.
1767   if (init == NULL) {
1768     // The init has somehow disappeared; be cautious and clear everything.
1769     //
1770     // This can happen if a node is allocated but an uncommon trap occurs
1771     // immediately.  In this case, the Initialize gets associated with the
1772     // trap, and may be placed in a different (outer) loop, if the Allocate
1773     // is in a loop.  If (this is rare) the inner loop gets unrolled, then
1774     // there can be two Allocates to one Initialize.  The answer in all these
1775     // edge cases is safety first.  It is always safe to clear immediately
1776     // within an Allocate, and then (maybe or maybe not) clear some more later.
1777     if (!(UseTLAB &amp;&amp; ZeroTLAB)) {
1778       rawmem = ClearArrayNode::clear_memory(control, rawmem, object,


1779                                             header_size, size_in_bytes,
1780                                             &amp;_igvn);
1781     }
1782   } else {
1783     if (!init-&gt;is_complete()) {
1784       // Try to win by zeroing only what the init does not store.
1785       // We can also try to do some peephole optimizations,
1786       // such as combining some adjacent subword stores.
1787       rawmem = init-&gt;complete_stores(control, rawmem, object,
1788                                      header_size, size_in_bytes, &amp;_igvn);
1789     }
1790     // We have no more use for this link, since the AllocateNode goes away:
1791     init-&gt;set_req(InitializeNode::RawAddress, top());
1792     // (If we keep the link, it just confuses the register allocator,
1793     // who thinks he sees a real use of the address by the membar.)
1794   }
1795 
1796   return rawmem;
1797 }
1798 
</pre>
<hr />
<pre>
2139         // Replace old box node with new eliminated box for all users
2140         // of the same object and mark related locks as eliminated.
2141         mark_eliminated_box(box, obj);
2142       }
2143     }
2144   }
2145 }
2146 
2147 // we have determined that this lock/unlock can be eliminated, we simply
2148 // eliminate the node without expanding it.
2149 //
2150 // Note:  The membar&#39;s associated with the lock/unlock are currently not
2151 //        eliminated.  This should be investigated as a future enhancement.
2152 //
2153 bool PhaseMacroExpand::eliminate_locking_node(AbstractLockNode *alock) {
2154 
2155   if (!alock-&gt;is_eliminated()) {
2156     return false;
2157   }
2158 #ifdef ASSERT


2159   if (!alock-&gt;is_coarsened()) {
2160     // Check that new &quot;eliminated&quot; BoxLock node is created.
2161     BoxLockNode* oldbox = alock-&gt;box_node()-&gt;as_BoxLock();
2162     assert(oldbox-&gt;is_eliminated(), &quot;should be done already&quot;);
2163   }
2164 #endif
2165 
2166   alock-&gt;log_lock_optimization(C, &quot;eliminate_lock&quot;);
2167 
2168 #ifndef PRODUCT
2169   if (PrintEliminateLocks) {
2170     if (alock-&gt;is_Lock()) {
2171       tty-&gt;print_cr(&quot;++++ Eliminated: %d Lock&quot;, alock-&gt;_idx);
2172     } else {
2173       tty-&gt;print_cr(&quot;++++ Eliminated: %d Unlock&quot;, alock-&gt;_idx);
2174     }
2175   }
2176 #endif
2177 
2178   Node* mem  = alock-&gt;in(TypeFunc::Memory);
</pre>
<hr />
<pre>
2420     // region-&gt;in(2) is set to fast path - the object is locked to the current thread.
2421 
2422     slow_path-&gt;init_req(2, ctrl); // Capture slow-control
2423     slow_mem-&gt;init_req(2, fast_lock_mem_phi);
2424 
2425     transform_later(slow_path);
2426     transform_later(slow_mem);
2427     // Reset lock&#39;s memory edge.
2428     lock-&gt;set_req(TypeFunc::Memory, slow_mem);
2429 
2430   } else {
2431     region  = new RegionNode(3);
2432     // create a Phi for the memory state
2433     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2434 
2435     // Optimize test; set region slot 2
2436     slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);
2437     mem_phi-&gt;init_req(2, mem);
2438   }
2439 










































2440   // Make slow path call
2441   CallNode *call = make_slow_call((CallNode *) lock, OptoRuntime::complete_monitor_enter_Type(),
2442                                   OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,
2443                                   obj, box, NULL);
2444 
2445   extract_call_projections(call);
2446 
2447   // Slow path can only throw asynchronous exceptions, which are always
2448   // de-opted.  So the compiler thinks the slow-call can never throw an
2449   // exception.  If it DOES throw an exception we would need the debug
2450   // info removed first (since if it throws there is no monitor).
2451   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2452            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2453 
2454   // Capture slow path
2455   // disconnect fall-through projection from call and create a new one
2456   // hook up users of fall-through projection to region
2457   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2458   transform_later(slow_ctrl);
2459   _igvn.hash_delete(_fallthroughproj);
</pre>
<hr />
<pre>
2521   // No exceptions for unlocking
2522   // Capture slow path
2523   // disconnect fall-through projection from call and create a new one
2524   // hook up users of fall-through projection to region
2525   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2526   transform_later(slow_ctrl);
2527   _igvn.hash_delete(_fallthroughproj);
2528   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2529   region-&gt;init_req(1, slow_ctrl);
2530   // region inputs are now complete
2531   transform_later(region);
2532   _igvn.replace_node(_fallthroughproj, region);
2533 
2534   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory) );
2535   mem_phi-&gt;init_req(1, memproj );
2536   mem_phi-&gt;init_req(2, mem);
2537   transform_later(mem_phi);
2538   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2539 }
2540 













































































































































































































2541 void PhaseMacroExpand::expand_subtypecheck_node(SubTypeCheckNode *check) {
2542   assert(check-&gt;in(SubTypeCheckNode::Control) == NULL, &quot;should be pinned&quot;);
2543   Node* bol = check-&gt;unique_out();
2544   Node* obj_or_subklass = check-&gt;in(SubTypeCheckNode::ObjOrSubKlass);
2545   Node* superklass = check-&gt;in(SubTypeCheckNode::SuperKlass);
2546   assert(bol-&gt;is_Bool() &amp;&amp; bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne, &quot;unexpected bool node&quot;);
2547 
2548   for (DUIterator_Last imin, i = bol-&gt;last_outs(imin); i &gt;= imin; --i) {
2549     Node* iff = bol-&gt;last_out(i);
2550     assert(iff-&gt;is_If(), &quot;where&#39;s the if?&quot;);
2551 
2552     if (iff-&gt;in(0)-&gt;is_top()) {
2553       _igvn.replace_input_of(iff, 1, C-&gt;top());
2554       continue;
2555     }
2556 
2557     Node* iftrue = iff-&gt;as_If()-&gt;proj_out(1);
2558     Node* iffalse = iff-&gt;as_If()-&gt;proj_out(0);
2559     Node* ctrl = iff-&gt;in(0);
2560 
2561     Node* subklass = NULL;
2562     if (_igvn.type(obj_or_subklass)-&gt;isa_klassptr()) {
2563       subklass = obj_or_subklass;
2564     } else {
2565       Node* k_adr = basic_plus_adr(obj_or_subklass, oopDesc::klass_offset_in_bytes());
<span class="line-modified">2566       subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS));</span>
2567     }
2568 
2569     Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, NULL, _igvn);
2570 
2571     _igvn.replace_input_of(iff, 0, C-&gt;top());
2572     _igvn.replace_node(iftrue, not_subtype_ctrl);
2573     _igvn.replace_node(iffalse, ctrl);
2574   }
2575   _igvn.replace_node(check, C-&gt;top());
2576 }
2577 
2578 //---------------------------eliminate_macro_nodes----------------------
2579 // Eliminate scalar replaced allocations and associated locks.
2580 void PhaseMacroExpand::eliminate_macro_nodes() {
2581   if (C-&gt;macro_count() == 0)
2582     return;
2583 
2584   // First, attempt to eliminate locks
2585   int cnt = C-&gt;macro_count();
2586   for (int i=0; i &lt; cnt; i++) {
</pre>
<hr />
<pre>
2602         success = eliminate_locking_node(n-&gt;as_AbstractLock());
2603       }
2604       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2605       progress = progress || success;
2606     }
2607   }
2608   // Next, attempt to eliminate allocations
2609   _has_locks = false;
2610   progress = true;
2611   while (progress) {
2612     progress = false;
2613     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2614       Node * n = C-&gt;macro_node(i-1);
2615       bool success = false;
2616       debug_only(int old_macro_count = C-&gt;macro_count(););
2617       switch (n-&gt;class_id()) {
2618       case Node::Class_Allocate:
2619       case Node::Class_AllocateArray:
2620         success = eliminate_allocate_node(n-&gt;as_Allocate());
2621         break;
<span class="line-modified">2622       case Node::Class_CallStaticJava:</span>
<span class="line-modified">2623         success = eliminate_boxing_node(n-&gt;as_CallStaticJava());</span>



2624         break;

2625       case Node::Class_Lock:
2626       case Node::Class_Unlock:
2627         assert(!n-&gt;as_AbstractLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2628         _has_locks = true;
2629         break;
2630       case Node::Class_ArrayCopy:
2631         break;
2632       case Node::Class_OuterStripMinedLoop:
2633         break;
2634       case Node::Class_SubTypeCheck:
2635         break;
2636       default:
2637         assert(n-&gt;Opcode() == Op_LoopLimit ||
2638                n-&gt;Opcode() == Op_Opaque1   ||
2639                n-&gt;Opcode() == Op_Opaque2   ||
2640                n-&gt;Opcode() == Op_Opaque3   ||
2641                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2642                &quot;unknown node type in macro list&quot;);
2643       }
2644       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
</pre>
<hr />
<pre>
2650 //------------------------------expand_macro_nodes----------------------
2651 //  Returns true if a failure occurred.
2652 bool PhaseMacroExpand::expand_macro_nodes() {
2653   // Last attempt to eliminate macro nodes.
2654   eliminate_macro_nodes();
2655 
2656   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.
2657   bool progress = true;
2658   while (progress) {
2659     progress = false;
2660     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2661       Node* n = C-&gt;macro_node(i-1);
2662       bool success = false;
2663       debug_only(int old_macro_count = C-&gt;macro_count(););
2664       if (n-&gt;Opcode() == Op_LoopLimit) {
2665         // Remove it from macro list and put on IGVN worklist to optimize.
2666         C-&gt;remove_macro_node(n);
2667         _igvn._worklist.push(n);
2668         success = true;
2669       } else if (n-&gt;Opcode() == Op_CallStaticJava) {
<span class="line-modified">2670         // Remove it from macro list and put on IGVN worklist to optimize.</span>
<span class="line-modified">2671         C-&gt;remove_macro_node(n);</span>
<span class="line-modified">2672         _igvn._worklist.push(n);</span>
<span class="line-modified">2673         success = true;</span>



2674       } else if (n-&gt;Opcode() == Op_Opaque1 || n-&gt;Opcode() == Op_Opaque2) {
2675         _igvn.replace_node(n, n-&gt;in(1));
2676         success = true;
2677 #if INCLUDE_RTM_OPT
2678       } else if ((n-&gt;Opcode() == Op_Opaque3) &amp;&amp; ((Opaque3Node*)n)-&gt;rtm_opt()) {
2679         assert(C-&gt;profile_rtm(), &quot;should be used only in rtm deoptimization code&quot;);
2680         assert((n-&gt;outcnt() == 1) &amp;&amp; n-&gt;unique_out()-&gt;is_Cmp(), &quot;&quot;);
2681         Node* cmp = n-&gt;unique_out();
2682 #ifdef ASSERT
2683         // Validate graph.
2684         assert((cmp-&gt;outcnt() == 1) &amp;&amp; cmp-&gt;unique_out()-&gt;is_Bool(), &quot;&quot;);
2685         BoolNode* bol = cmp-&gt;unique_out()-&gt;as_Bool();
2686         assert((bol-&gt;outcnt() == 1) &amp;&amp; bol-&gt;unique_out()-&gt;is_If() &amp;&amp;
2687                (bol-&gt;_test._test == BoolTest::ne), &quot;&quot;);
2688         IfNode* ifn = bol-&gt;unique_out()-&gt;as_If();
2689         assert((ifn-&gt;outcnt() == 2) &amp;&amp;
2690                ifn-&gt;proj_out(1)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, &quot;&quot;);
2691 #endif
2692         Node* repl = n-&gt;in(1);
2693         if (!_has_locks) {
</pre>
<hr />
<pre>
2747     }
2748 
2749     debug_only(int old_macro_count = C-&gt;macro_count(););
2750     switch (n-&gt;class_id()) {
2751     case Node::Class_Lock:
2752       expand_lock_node(n-&gt;as_Lock());
2753       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2754       break;
2755     case Node::Class_Unlock:
2756       expand_unlock_node(n-&gt;as_Unlock());
2757       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2758       break;
2759     case Node::Class_ArrayCopy:
2760       expand_arraycopy_node(n-&gt;as_ArrayCopy());
2761       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2762       break;
2763     case Node::Class_SubTypeCheck:
2764       expand_subtypecheck_node(n-&gt;as_SubTypeCheck());
2765       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2766       break;





2767     default:
2768       assert(false, &quot;unknown node type in macro list&quot;);
2769     }
2770     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
2771     if (C-&gt;failing())  return true;
2772 
2773     // Clean up the graph so we&#39;re less likely to hit the maximum node
2774     // limit
2775     _igvn.set_delay_transform(false);
2776     _igvn.optimize();
2777     if (C-&gt;failing())  return true;
2778     _igvn.set_delay_transform(true);
2779   }
2780 
2781   // All nodes except Allocate nodes are expanded now. There could be
2782   // new optimization opportunities (such as folding newly created
2783   // load from a just allocated object). Run IGVN.
2784 
2785   // expand &quot;macro&quot; nodes
2786   // nodes are removed from the macro list as they are processed
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
<span class="line-added">  26 #include &quot;ci/ciFlatArrayKlass.hpp&quot;</span>
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  29 #include &quot;libadt/vectset.hpp&quot;
  30 #include &quot;memory/universe.hpp&quot;
  31 #include &quot;opto/addnode.hpp&quot;
  32 #include &quot;opto/arraycopynode.hpp&quot;
  33 #include &quot;opto/callnode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/cfgnode.hpp&quot;
  36 #include &quot;opto/compile.hpp&quot;
  37 #include &quot;opto/convertnode.hpp&quot;
  38 #include &quot;opto/graphKit.hpp&quot;
<span class="line-added">  39 #include &quot;opto/inlinetypenode.hpp&quot;</span>
  40 #include &quot;opto/intrinsicnode.hpp&quot;
  41 #include &quot;opto/locknode.hpp&quot;
  42 #include &quot;opto/loopnode.hpp&quot;
  43 #include &quot;opto/macro.hpp&quot;
  44 #include &quot;opto/memnode.hpp&quot;
  45 #include &quot;opto/narrowptrnode.hpp&quot;
  46 #include &quot;opto/node.hpp&quot;
  47 #include &quot;opto/opaquenode.hpp&quot;
  48 #include &quot;opto/phaseX.hpp&quot;
  49 #include &quot;opto/rootnode.hpp&quot;
  50 #include &quot;opto/runtime.hpp&quot;
  51 #include &quot;opto/subnode.hpp&quot;
  52 #include &quot;opto/subtypenode.hpp&quot;
  53 #include &quot;opto/type.hpp&quot;
  54 #include &quot;runtime/sharedRuntime.hpp&quot;
  55 #include &quot;utilities/macros.hpp&quot;
  56 #include &quot;utilities/powerOfTwo.hpp&quot;
  57 #if INCLUDE_G1GC
  58 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  59 #endif // INCLUDE_G1GC
</pre>
<hr />
<pre>
  67 // Returns the number of replacements made.
  68 //
  69 int PhaseMacroExpand::replace_input(Node *use, Node *oldref, Node *newref) {
  70   int nreplacements = 0;
  71   uint req = use-&gt;req();
  72   for (uint j = 0; j &lt; use-&gt;len(); j++) {
  73     Node *uin = use-&gt;in(j);
  74     if (uin == oldref) {
  75       if (j &lt; req)
  76         use-&gt;set_req(j, newref);
  77       else
  78         use-&gt;set_prec(j, newref);
  79       nreplacements++;
  80     } else if (j &gt;= req &amp;&amp; uin == NULL) {
  81       break;
  82     }
  83   }
  84   return nreplacements;
  85 }
  86 


















































  87 Node* PhaseMacroExpand::opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path) {
  88   Node* cmp;
  89   if (mask != 0) {
  90     Node* and_node = transform_later(new AndXNode(word, MakeConX(mask)));
  91     cmp = transform_later(new CmpXNode(and_node, MakeConX(bits)));
  92   } else {
  93     cmp = word;
  94   }
  95   Node* bol = transform_later(new BoolNode(cmp, BoolTest::ne));
  96   IfNode* iff = new IfNode( ctrl, bol, PROB_MIN, COUNT_UNKNOWN );
  97   transform_later(iff);
  98 
  99   // Fast path taken.
 100   Node *fast_taken = transform_later(new IfFalseNode(iff));
 101 
 102   // Fast path not-taken, i.e. slow path
 103   Node *slow_taken = transform_later(new IfTrueNode(iff));
 104 
 105   if (return_fast_path) {
 106     region-&gt;init_req(edge, slow_taken); // Capture slow-control
</pre>
<hr />
<pre>
 119   call-&gt;init_req( TypeFunc::Memory , oldcall-&gt;in( TypeFunc::Memory ) ); // ?????
 120   call-&gt;init_req( TypeFunc::ReturnAdr, oldcall-&gt;in( TypeFunc::ReturnAdr ) );
 121   call-&gt;init_req( TypeFunc::FramePtr, oldcall-&gt;in( TypeFunc::FramePtr ) );
 122 }
 123 
 124 //------------------------------make_slow_call---------------------------------
 125 CallNode* PhaseMacroExpand::make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type,
 126                                            address slow_call, const char* leaf_name, Node* slow_path,
 127                                            Node* parm0, Node* parm1, Node* parm2) {
 128 
 129   // Slow-path call
 130  CallNode *call = leaf_name
 131    ? (CallNode*)new CallLeafNode      ( slow_call_type, slow_call, leaf_name, TypeRawPtr::BOTTOM )
 132    : (CallNode*)new CallStaticJavaNode( slow_call_type, slow_call, OptoRuntime::stub_name(slow_call), oldcall-&gt;jvms()-&gt;bci(), TypeRawPtr::BOTTOM );
 133 
 134   // Slow path call has no side-effects, uses few values
 135   copy_predefined_input_for_runtime_call(slow_path, oldcall, call );
 136   if (parm0 != NULL)  call-&gt;init_req(TypeFunc::Parms+0, parm0);
 137   if (parm1 != NULL)  call-&gt;init_req(TypeFunc::Parms+1, parm1);
 138   if (parm2 != NULL)  call-&gt;init_req(TypeFunc::Parms+2, parm2);
<span class="line-modified"> 139   call-&gt;copy_call_debug_info(&amp;_igvn, oldcall);</span>
 140   call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
 141   _igvn.replace_node(oldcall, call);
 142   transform_later(call);
 143 
 144   return call;
 145 }
 146 
 147 void PhaseMacroExpand::extract_call_projections(CallNode *call) {
 148   _fallthroughproj = NULL;
 149   _fallthroughcatchproj = NULL;
 150   _ioproj_fallthrough = NULL;
 151   _ioproj_catchall = NULL;
 152   _catchallcatchproj = NULL;
 153   _memproj_fallthrough = NULL;
 154   _memproj_catchall = NULL;
 155   _resproj = NULL;
 156   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
 157     ProjNode *pn = call-&gt;fast_out(i)-&gt;as_Proj();
 158     switch (pn-&gt;_con) {
 159       case TypeFunc::Control:
</pre>
<hr />
<pre>
 227           if (call-&gt;as_ArrayCopy()-&gt;modifies(offset, offset, phase, false)) {
 228             return in;
 229           }
 230         }
 231         mem = in-&gt;in(TypeFunc::Memory);
 232       } else if (in-&gt;is_MemBar()) {
 233         ArrayCopyNode* ac = NULL;
 234         if (ArrayCopyNode::may_modify(tinst, in-&gt;as_MemBar(), phase, ac)) {
 235           assert(ac != NULL &amp;&amp; ac-&gt;is_clonebasic(), &quot;Only basic clone is a non escaping clone&quot;);
 236           return ac;
 237         }
 238         mem = in-&gt;in(TypeFunc::Memory);
 239       } else {
 240         assert(false, &quot;unexpected projection&quot;);
 241       }
 242     } else if (mem-&gt;is_Store()) {
 243       const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 244       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 245       if (adr_idx == alias_idx) {
 246         assert(atype-&gt;isa_oopptr(), &quot;address type must be oopptr&quot;);
<span class="line-modified"> 247         int adr_offset = atype-&gt;flattened_offset();</span>
 248         uint adr_iid = atype-&gt;is_oopptr()-&gt;instance_id();
 249         // Array elements references have the same alias_idx
 250         // but different offset and different instance_id.
 251         if (adr_offset == offset &amp;&amp; adr_iid == alloc-&gt;_idx)
 252           return mem;
 253       } else {
 254         assert(adr_idx == Compile::AliasIdxRaw, &quot;address must match or be raw&quot;);
 255       }
 256       mem = mem-&gt;in(MemNode::Memory);
 257     } else if (mem-&gt;is_ClearArray()) {
 258       if (!ClearArrayNode::step_through(&amp;mem, alloc-&gt;_idx, phase)) {
 259         // Can not bypass initialization of the instance
 260         // we are looking.
 261         debug_only(intptr_t offset;)
 262         assert(alloc == AllocateNode::Ideal_allocation(mem-&gt;in(3), phase, offset), &quot;sanity&quot;);
 263         InitializeNode* init = alloc-&gt;as_Allocate()-&gt;initialization();
 264         // We are looking for stored value, return Initialize node
 265         // or memory edge from Allocate node.
 266         if (init != NULL)
 267           return init;
</pre>
<hr />
<pre>
 270       }
 271       // Otherwise skip it (the call updated &#39;mem&#39; value).
 272     } else if (mem-&gt;Opcode() == Op_SCMemProj) {
 273       mem = mem-&gt;in(0);
 274       Node* adr = NULL;
 275       if (mem-&gt;is_LoadStore()) {
 276         adr = mem-&gt;in(MemNode::Address);
 277       } else {
 278         assert(mem-&gt;Opcode() == Op_EncodeISOArray ||
 279                mem-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 280         adr = mem-&gt;in(3); // Destination array
 281       }
 282       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 283       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 284       if (adr_idx == alias_idx) {
 285         DEBUG_ONLY(mem-&gt;dump();)
 286         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 287         return NULL;
 288       }
 289       mem = mem-&gt;in(MemNode::Memory);
<span class="line-modified"> 290     } else if (mem-&gt;Opcode() == Op_StrInflatedCopy) {</span>
 291       Node* adr = mem-&gt;in(3); // Destination array
 292       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 293       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 294       if (adr_idx == alias_idx) {
 295         DEBUG_ONLY(mem-&gt;dump();)
 296         assert(false, &quot;Object is not scalar replaceable if a StrInflatedCopy node accesses its field&quot;);
 297         return NULL;
 298       }
 299       mem = mem-&gt;in(MemNode::Memory);
 300     } else {
 301       return mem;
 302     }
 303     assert(mem != orig_mem, &quot;dead memory loop&quot;);
 304   }
 305 }
 306 
 307 // Generate loads from source of the arraycopy for fields of
 308 // destination needed at a deoptimization point
 309 Node* PhaseMacroExpand::make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {
 310   BasicType bt = ft;
</pre>
<hr />
<pre>
 313     bt = T_OBJECT;
 314     type = ftype-&gt;make_oopptr();
 315   }
 316   Node* res = NULL;
 317   if (ac-&gt;is_clonebasic()) {
 318     assert(ac-&gt;in(ArrayCopyNode::Src) != ac-&gt;in(ArrayCopyNode::Dest), &quot;clone source equals destination&quot;);
 319     Node* base = ac-&gt;in(ArrayCopyNode::Src);
 320     Node* adr = _igvn.transform(new AddPNode(base, base, MakeConX(offset)));
 321     const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(offset);
 322     res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 323   } else {
 324     if (ac-&gt;modifies(offset, offset, &amp;_igvn, true)) {
 325       assert(ac-&gt;in(ArrayCopyNode::Dest) == alloc-&gt;result_cast(), &quot;arraycopy destination should be allocation&#39;s result&quot;);
 326       uint shift = exact_log2(type2aelembytes(bt));
 327       Node* src_pos = ac-&gt;in(ArrayCopyNode::SrcPos);
 328       Node* dest_pos = ac-&gt;in(ArrayCopyNode::DestPos);
 329       const TypeInt* src_pos_t = _igvn.type(src_pos)-&gt;is_int();
 330       const TypeInt* dest_pos_t = _igvn.type(dest_pos)-&gt;is_int();
 331 
 332       Node* adr = NULL;
<span class="line-modified"> 333       Node* base = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-added"> 334       const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr();</span>
<span class="line-added"> 335       assert(adr_type-&gt;isa_aryptr(), &quot;only arrays here&quot;);</span>
 336       if (src_pos_t-&gt;is_con() &amp;&amp; dest_pos_t-&gt;is_con()) {
 337         intptr_t off = ((src_pos_t-&gt;get_con() - dest_pos_t-&gt;get_con()) &lt;&lt; shift) + offset;
<span class="line-modified"> 338         adr = _igvn.transform(new AddPNode(base, base, MakeConX(off)));</span>
<span class="line-modified"> 339         adr_type = _igvn.type(adr)-&gt;is_ptr();</span>
 340         assert(adr_type == _igvn.type(base)-&gt;is_aryptr()-&gt;add_field_offset_and_offset(off), &quot;incorrect address type&quot;);
 341         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 342           // Don&#39;t emit a new load from src if src == dst but try to get the value from memory instead
 343           return value_from_mem(ac-&gt;in(TypeFunc::Memory), ctl, ft, ftype, adr_type-&gt;isa_oopptr(), alloc);
 344         }
 345       } else {
<span class="line-added"> 346         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {</span>
<span class="line-added"> 347           // Non constant offset in the array: we can&#39;t statically</span>
<span class="line-added"> 348           // determine the value</span>
<span class="line-added"> 349           return NULL;</span>
<span class="line-added"> 350         }</span>
 351         Node* diff = _igvn.transform(new SubINode(ac-&gt;in(ArrayCopyNode::SrcPos), ac-&gt;in(ArrayCopyNode::DestPos)));
 352 #ifdef _LP64
 353         diff = _igvn.transform(new ConvI2LNode(diff));
 354 #endif
 355         diff = _igvn.transform(new LShiftXNode(diff, intcon(shift)));
 356 
 357         Node* off = _igvn.transform(new AddXNode(MakeConX(offset), diff));
<span class="line-modified"> 358         adr = _igvn.transform(new AddPNode(base, base, off));</span>
<span class="line-modified"> 359         // In the case of a flattened inline type array, each field has its</span>
<span class="line-modified"> 360         // own slice so we need to extract the field being accessed from</span>
<span class="line-modified"> 361         // the address computation</span>
<span class="line-modified"> 362         adr_type = adr_type-&gt;is_aryptr()-&gt;add_field_offset_and_offset(offset)-&gt;add_offset(Type::OffsetBot);</span>


 363         adr = _igvn.transform(new CastPPNode(adr, adr_type));
 364       }
 365       res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 366     }
 367   }
 368   if (res != NULL) {
 369     res = _igvn.transform(res);
 370     if (ftype-&gt;isa_narrowoop()) {
 371       // PhaseMacroExpand::scalar_replacement adds DecodeN nodes
<span class="line-added"> 372       assert(res-&gt;isa_DecodeN(), &quot;should be narrow oop&quot;);</span>
 373       res = _igvn.transform(new EncodePNode(res, ftype));
 374     }
 375     return res;
 376   }
 377   return NULL;
 378 }
 379 
 380 //
 381 // Given a Memory Phi, compute a value Phi containing the values from stores
 382 // on the input paths.
 383 // Note: this function is recursive, its depth is limited by the &quot;level&quot; argument
 384 // Returns the computed Phi, or NULL if it cannot compute it.
 385 Node *PhaseMacroExpand::value_from_mem_phi(Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {
 386   assert(mem-&gt;is_Phi(), &quot;sanity&quot;);
 387   int alias_idx = C-&gt;get_alias_index(adr_t);
<span class="line-modified"> 388   int offset = adr_t-&gt;flattened_offset();</span>
 389   int instance_id = adr_t-&gt;instance_id();
 390 
 391   // Check if an appropriate value phi already exists.
 392   Node* region = mem-&gt;in(0);
 393   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 394     Node* phi = region-&gt;fast_out(k);
 395     if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
 396         phi-&gt;as_Phi()-&gt;is_same_inst_field(phi_type, (int)mem-&gt;_idx, instance_id, alias_idx, offset)) {
 397       return phi;
 398     }
 399   }
 400   // Check if an appropriate new value phi already exists.
 401   Node* new_phi = value_phis-&gt;find(mem-&gt;_idx);
 402   if (new_phi != NULL)
 403     return new_phi;
 404 
 405   if (level &lt;= 0) {
 406     return NULL; // Give up: phi tree too deep
 407   }
 408   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 409   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 410 
 411   uint length = mem-&gt;req();
 412   GrowableArray &lt;Node *&gt; values(length, length, NULL);
 413 
 414   // create a new Phi for the value
 415   PhiNode *phi = new PhiNode(mem-&gt;in(0), phi_type, NULL, mem-&gt;_idx, instance_id, alias_idx, offset);
 416   transform_later(phi);
 417   value_phis-&gt;push(phi, mem-&gt;_idx);
 418 
 419   for (uint j = 1; j &lt; length; j++) {
 420     Node *in = mem-&gt;in(j);
 421     if (in == NULL || in-&gt;is_top()) {
 422       values.at_put(j, in);
 423     } else  {
 424       Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 425       if (val == start_mem || val == alloc_mem) {
 426         // hit a sentinel, return appropriate 0 value
<span class="line-modified"> 427         Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);</span>
<span class="line-added"> 428         if (default_value != NULL) {</span>
<span class="line-added"> 429           values.at_put(j, default_value);</span>
<span class="line-added"> 430         } else {</span>
<span class="line-added"> 431           assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);</span>
<span class="line-added"> 432           values.at_put(j, _igvn.zerocon(ft));</span>
<span class="line-added"> 433         }</span>
 434         continue;
 435       }
 436       if (val-&gt;is_Initialize()) {
 437         val = val-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 438       }
 439       if (val == NULL) {
 440         return NULL;  // can&#39;t find a value on this path
 441       }
 442       if (val == mem) {
 443         values.at_put(j, mem);
 444       } else if (val-&gt;is_Store()) {
 445         Node* n = val-&gt;in(MemNode::ValueIn);
 446         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 447         n = bs-&gt;step_over_gc_barrier(n);
 448         values.at_put(j, n);
 449       } else if(val-&gt;is_Proj() &amp;&amp; val-&gt;in(0) == alloc) {
<span class="line-modified"> 450         Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);</span>
<span class="line-added"> 451         if (default_value != NULL) {</span>
<span class="line-added"> 452           values.at_put(j, default_value);</span>
<span class="line-added"> 453         } else {</span>
<span class="line-added"> 454           assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);</span>
<span class="line-added"> 455           values.at_put(j, _igvn.zerocon(ft));</span>
<span class="line-added"> 456         }</span>
 457       } else if (val-&gt;is_Phi()) {
 458         val = value_from_mem_phi(val, ft, phi_type, adr_t, alloc, value_phis, level-1);
 459         if (val == NULL) {
 460           return NULL;
 461         }
 462         values.at_put(j, val);
 463       } else if (val-&gt;Opcode() == Op_SCMemProj) {
 464         assert(val-&gt;in(0)-&gt;is_LoadStore() ||
 465                val-&gt;in(0)-&gt;Opcode() == Op_EncodeISOArray ||
 466                val-&gt;in(0)-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 467         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 468         return NULL;
 469       } else if (val-&gt;is_ArrayCopy()) {
 470         Node* res = make_arraycopy_load(val-&gt;as_ArrayCopy(), offset, val-&gt;in(0), val-&gt;in(TypeFunc::Memory), ft, phi_type, alloc);
 471         if (res == NULL) {
 472           return NULL;
 473         }
 474         values.at_put(j, res);
 475       } else {
 476 #ifdef ASSERT
</pre>
<hr />
<pre>
 482     }
 483   }
 484   // Set Phi&#39;s inputs
 485   for (uint j = 1; j &lt; length; j++) {
 486     if (values.at(j) == mem) {
 487       phi-&gt;init_req(j, phi);
 488     } else {
 489       phi-&gt;init_req(j, values.at(j));
 490     }
 491   }
 492   return phi;
 493 }
 494 
 495 // Search the last value stored into the object&#39;s field.
 496 Node *PhaseMacroExpand::value_from_mem(Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {
 497   assert(adr_t-&gt;is_known_instance_field(), &quot;instance required&quot;);
 498   int instance_id = adr_t-&gt;instance_id();
 499   assert((uint)instance_id == alloc-&gt;_idx, &quot;wrong allocation&quot;);
 500 
 501   int alias_idx = C-&gt;get_alias_index(adr_t);
<span class="line-modified"> 502   int offset = adr_t-&gt;flattened_offset();</span>
 503   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);

 504   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 505   VectorSet visited;
 506 
 507   bool done = sfpt_mem == alloc_mem;
 508   Node *mem = sfpt_mem;
 509   while (!done) {
 510     if (visited.test_set(mem-&gt;_idx)) {
 511       return NULL;  // found a loop, give up
 512     }
 513     mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 514     if (mem == start_mem || mem == alloc_mem) {
 515       done = true;  // hit a sentinel, return appropriate 0 value
 516     } else if (mem-&gt;is_Initialize()) {
 517       mem = mem-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 518       if (mem == NULL) {
<span class="line-modified"> 519         done = true; // Something went wrong.</span>
 520       } else if (mem-&gt;is_Store()) {
 521         const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 522         assert(C-&gt;get_alias_index(atype) == Compile::AliasIdxRaw, &quot;store is correct memory slice&quot;);
 523         done = true;
 524       }
 525     } else if (mem-&gt;is_Store()) {
 526       const TypeOopPtr* atype = mem-&gt;as_Store()-&gt;adr_type()-&gt;isa_oopptr();
 527       assert(atype != NULL, &quot;address type must be oopptr&quot;);
 528       assert(C-&gt;get_alias_index(atype) == alias_idx &amp;&amp;
<span class="line-modified"> 529              atype-&gt;is_known_instance_field() &amp;&amp; atype-&gt;flattened_offset() == offset &amp;&amp;</span>
 530              atype-&gt;instance_id() == instance_id, &quot;store is correct memory slice&quot;);
 531       done = true;
 532     } else if (mem-&gt;is_Phi()) {
 533       // try to find a phi&#39;s unique input
 534       Node *unique_input = NULL;
 535       Node *top = C-&gt;top();
 536       for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 537         Node *n = scan_mem_chain(mem-&gt;in(i), alias_idx, offset, start_mem, alloc, &amp;_igvn);
 538         if (n == NULL || n == top || n == mem) {
 539           continue;
 540         } else if (unique_input == NULL) {
 541           unique_input = n;
 542         } else if (unique_input != n) {
 543           unique_input = top;
 544           break;
 545         }
 546       }
 547       if (unique_input != NULL &amp;&amp; unique_input != top) {
 548         mem = unique_input;
 549       } else {
 550         done = true;
 551       }
 552     } else if (mem-&gt;is_ArrayCopy()) {
 553       done = true;
 554     } else {
 555       assert(false, &quot;unexpected node&quot;);
 556     }
 557   }
 558   if (mem != NULL) {
 559     if (mem == start_mem || mem == alloc_mem) {
 560       // hit a sentinel, return appropriate 0 value
<span class="line-added"> 561       Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);</span>
<span class="line-added"> 562       if (default_value != NULL) {</span>
<span class="line-added"> 563         return default_value;</span>
<span class="line-added"> 564       }</span>
<span class="line-added"> 565       assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);</span>
 566       return _igvn.zerocon(ft);
 567     } else if (mem-&gt;is_Store()) {
 568       Node* n = mem-&gt;in(MemNode::ValueIn);
 569       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 570       n = bs-&gt;step_over_gc_barrier(n);
 571       return n;
 572     } else if (mem-&gt;is_Phi()) {
 573       // attempt to produce a Phi reflecting the values on the input paths of the Phi
 574       Node_Stack value_phis(8);
 575       Node* phi = value_from_mem_phi(mem, ft, ftype, adr_t, alloc, &amp;value_phis, ValueSearchLimit);
 576       if (phi != NULL) {
 577         return phi;
 578       } else {
 579         // Kill all new Phis
 580         while(value_phis.is_nonempty()) {
 581           Node* n = value_phis.node();
 582           _igvn.replace_node(n, C-&gt;top());
 583           value_phis.pop();
 584         }
 585       }
 586     } else if (mem-&gt;is_ArrayCopy()) {
 587       Node* ctl = mem-&gt;in(0);
 588       Node* m = mem-&gt;in(TypeFunc::Memory);
 589       if (sfpt_ctl-&gt;is_Proj() &amp;&amp; sfpt_ctl-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {
 590         // pin the loads in the uncommon trap path
 591         ctl = sfpt_ctl;
 592         m = sfpt_mem;
 593       }
 594       return make_arraycopy_load(mem-&gt;as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);
 595     }
 596   }
<span class="line-modified"> 597   // Something went wrong.</span>
 598   return NULL;
 599 }
 600 
<span class="line-added"> 601 // Search the last value stored into the inline type&#39;s fields.</span>
<span class="line-added"> 602 Node* PhaseMacroExpand::inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc) {</span>
<span class="line-added"> 603   // Subtract the offset of the first field to account for the missing oop header</span>
<span class="line-added"> 604   offset -= vk-&gt;first_field_offset();</span>
<span class="line-added"> 605   // Create a new InlineTypeNode and retrieve the field values from memory</span>
<span class="line-added"> 606   InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk)-&gt;as_InlineType();</span>
<span class="line-added"> 607   for (int i = 0; i &lt; vk-&gt;nof_declared_nonstatic_fields(); ++i) {</span>
<span class="line-added"> 608     ciType* field_type = vt-&gt;field_type(i);</span>
<span class="line-added"> 609     int field_offset = offset + vt-&gt;field_offset(i);</span>
<span class="line-added"> 610     // Each inline type field has its own memory slice</span>
<span class="line-added"> 611     adr_type = adr_type-&gt;with_field_offset(field_offset);</span>
<span class="line-added"> 612     Node* value = NULL;</span>
<span class="line-added"> 613     if (vt-&gt;field_is_flattened(i)) {</span>
<span class="line-added"> 614       value = inline_type_from_mem(mem, ctl, field_type-&gt;as_inline_klass(), adr_type, field_offset, alloc);</span>
<span class="line-added"> 615     } else {</span>
<span class="line-added"> 616       const Type* ft = Type::get_const_type(field_type);</span>
<span class="line-added"> 617       BasicType bt = field_type-&gt;basic_type();</span>
<span class="line-added"> 618       if (UseCompressedOops &amp;&amp; !is_java_primitive(bt)) {</span>
<span class="line-added"> 619         ft = ft-&gt;make_narrowoop();</span>
<span class="line-added"> 620         bt = T_NARROWOOP;</span>
<span class="line-added"> 621       }</span>
<span class="line-added"> 622       value = value_from_mem(mem, ctl, bt, ft, adr_type, alloc);</span>
<span class="line-added"> 623       if (value != NULL &amp;&amp; ft-&gt;isa_narrowoop()) {</span>
<span class="line-added"> 624         assert(UseCompressedOops, &quot;unexpected narrow oop&quot;);</span>
<span class="line-added"> 625         value = transform_later(new DecodeNNode(value, value-&gt;get_ptr_type()));</span>
<span class="line-added"> 626       }</span>
<span class="line-added"> 627     }</span>
<span class="line-added"> 628     if (value != NULL) {</span>
<span class="line-added"> 629       vt-&gt;set_field_value(i, value);</span>
<span class="line-added"> 630     } else {</span>
<span class="line-added"> 631       // We might have reached the TrackedInitializationLimit</span>
<span class="line-added"> 632       return NULL;</span>
<span class="line-added"> 633     }</span>
<span class="line-added"> 634   }</span>
<span class="line-added"> 635   return transform_later(vt);</span>
<span class="line-added"> 636 }</span>
<span class="line-added"> 637 </span>
 638 // Check the possibility of scalar replacement.
 639 bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 640   //  Scan the uses of the allocation to check for anything that would
 641   //  prevent us from eliminating it.
 642   NOT_PRODUCT( const char* fail_eliminate = NULL; )
 643   DEBUG_ONLY( Node* disq_node = NULL; )
 644   bool  can_eliminate = true;
 645 
 646   Node* res = alloc-&gt;result_cast();
 647   const TypeOopPtr* res_type = NULL;
 648   if (res == NULL) {
 649     // All users were eliminated.
 650   } else if (!res-&gt;is_CheckCastPP()) {
 651     NOT_PRODUCT(fail_eliminate = &quot;Allocation does not have unique CheckCastPP&quot;;)
 652     can_eliminate = false;
 653   } else {
 654     res_type = _igvn.type(res)-&gt;isa_oopptr();
 655     if (res_type == NULL) {
 656       NOT_PRODUCT(fail_eliminate = &quot;Neither instance or array allocation&quot;;)
 657       can_eliminate = false;
</pre>
<hr />
<pre>
 670       Node* use = res-&gt;fast_out(j);
 671 
 672       if (use-&gt;is_AddP()) {
 673         const TypePtr* addp_type = _igvn.type(use)-&gt;is_ptr();
 674         int offset = addp_type-&gt;offset();
 675 
 676         if (offset == Type::OffsetTop || offset == Type::OffsetBot) {
 677           NOT_PRODUCT(fail_eliminate = &quot;Undefined field referrence&quot;;)
 678           can_eliminate = false;
 679           break;
 680         }
 681         for (DUIterator_Fast kmax, k = use-&gt;fast_outs(kmax);
 682                                    k &lt; kmax &amp;&amp; can_eliminate; k++) {
 683           Node* n = use-&gt;fast_out(k);
 684           if (!n-&gt;is_Store() &amp;&amp; n-&gt;Opcode() != Op_CastP2X
 685               SHENANDOAHGC_ONLY(&amp;&amp; (!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n))) ) {
 686             DEBUG_ONLY(disq_node = n;)
 687             if (n-&gt;is_Load() || n-&gt;is_LoadStore()) {
 688               NOT_PRODUCT(fail_eliminate = &quot;Field load&quot;;)
 689             } else {
<span class="line-modified"> 690               NOT_PRODUCT(fail_eliminate = &quot;Not store field reference&quot;;)</span>
 691             }
 692             can_eliminate = false;
 693           }
 694         }
 695       } else if (use-&gt;is_ArrayCopy() &amp;&amp;
 696                  (use-&gt;as_ArrayCopy()-&gt;is_clonebasic() ||
 697                   use-&gt;as_ArrayCopy()-&gt;is_arraycopy_validated() ||
 698                   use-&gt;as_ArrayCopy()-&gt;is_copyof_validated() ||
 699                   use-&gt;as_ArrayCopy()-&gt;is_copyofrange_validated()) &amp;&amp;
 700                  use-&gt;in(ArrayCopyNode::Dest) == res) {
 701         // ok to eliminate
 702       } else if (use-&gt;is_SafePoint()) {
 703         SafePointNode* sfpt = use-&gt;as_SafePoint();
 704         if (sfpt-&gt;is_Call() &amp;&amp; sfpt-&gt;as_Call()-&gt;has_non_debug_use(res)) {
 705           // Object is passed as argument.
 706           DEBUG_ONLY(disq_node = use;)
 707           NOT_PRODUCT(fail_eliminate = &quot;Object is passed as argument&quot;;)
 708           can_eliminate = false;
 709         }
 710         Node* sfptMem = sfpt-&gt;memory();
 711         if (sfptMem == NULL || sfptMem-&gt;is_top()) {
 712           DEBUG_ONLY(disq_node = use;)
 713           NOT_PRODUCT(fail_eliminate = &quot;NULL or TOP memory&quot;;)
 714           can_eliminate = false;
 715         } else {
 716           safepoints.append_if_missing(sfpt);
 717         }
<span class="line-added"> 718       } else if (use-&gt;is_InlineType() &amp;&amp; use-&gt;isa_InlineType()-&gt;get_oop() == res) {</span>
<span class="line-added"> 719         // ok to eliminate</span>
<span class="line-added"> 720       } else if (use-&gt;Opcode() == Op_StoreX &amp;&amp; use-&gt;in(MemNode::Address) == res) {</span>
<span class="line-added"> 721         // store to mark work</span>
 722       } else if (use-&gt;Opcode() != Op_CastP2X) { // CastP2X is used by card mark
 723         if (use-&gt;is_Phi()) {
 724           if (use-&gt;outcnt() == 1 &amp;&amp; use-&gt;unique_out()-&gt;Opcode() == Op_Return) {
 725             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 726           } else {
 727             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by Phi&quot;;)
 728           }
 729           DEBUG_ONLY(disq_node = use;)
 730         } else {
 731           if (use-&gt;Opcode() == Op_Return) {
 732             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
<span class="line-modified"> 733           } else {</span>
 734             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by node&quot;;)
 735           }
 736           DEBUG_ONLY(disq_node = use;)
 737         }
 738         can_eliminate = false;
<span class="line-added"> 739       } else {</span>
<span class="line-added"> 740         assert(use-&gt;Opcode() == Op_CastP2X, &quot;should be&quot;);</span>
<span class="line-added"> 741         assert(!use-&gt;has_out_with(Op_OrL), &quot;should have been removed because oop is never null&quot;);</span>
 742       }
 743     }
 744   }
 745 
 746 #ifndef PRODUCT
 747   if (PrintEliminateAllocations) {
 748     if (can_eliminate) {
 749       tty-&gt;print(&quot;Scalar &quot;);
 750       if (res == NULL)
 751         alloc-&gt;dump();
 752       else
 753         res-&gt;dump();
 754     } else if (alloc-&gt;_is_scalar_replaceable) {
 755       tty-&gt;print(&quot;NotScalar (%s)&quot;, fail_eliminate);
 756       if (res == NULL)
 757         alloc-&gt;dump();
 758       else
 759         res-&gt;dump();
 760 #ifdef ASSERT
 761       if (disq_node != NULL) {
</pre>
<hr />
<pre>
 784   Node* res = alloc-&gt;result_cast();
 785   assert(res == NULL || res-&gt;is_CheckCastPP(), &quot;unexpected AllocateNode result&quot;);
 786   const TypeOopPtr* res_type = NULL;
 787   if (res != NULL) { // Could be NULL when there are no users
 788     res_type = _igvn.type(res)-&gt;isa_oopptr();
 789   }
 790 
 791   if (res != NULL) {
 792     klass = res_type-&gt;klass();
 793     if (res_type-&gt;isa_instptr()) {
 794       // find the fields of the class which will be needed for safepoint debug information
 795       assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass.&quot;);
 796       iklass = klass-&gt;as_instance_klass();
 797       nfields = iklass-&gt;nof_nonstatic_fields();
 798     } else {
 799       // find the array&#39;s elements which will be needed for safepoint debug information
 800       nfields = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 801       assert(klass-&gt;is_array_klass() &amp;&amp; nfields &gt;= 0, &quot;must be an array klass.&quot;);
 802       elem_type = klass-&gt;as_array_klass()-&gt;element_type();
 803       basic_elem_type = elem_type-&gt;basic_type();
<span class="line-added"> 804       if (elem_type-&gt;is_inlinetype() &amp;&amp; !klass-&gt;is_flat_array_klass()) {</span>
<span class="line-added"> 805         assert(basic_elem_type == T_INLINE_TYPE, &quot;unexpected element basic type&quot;);</span>
<span class="line-added"> 806         basic_elem_type = T_OBJECT;</span>
<span class="line-added"> 807       }</span>
 808       array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 809       element_size = type2aelembytes(basic_elem_type);
<span class="line-added"> 810       if (klass-&gt;is_flat_array_klass()) {</span>
<span class="line-added"> 811         // Flattened inline type array</span>
<span class="line-added"> 812         element_size = klass-&gt;as_flat_array_klass()-&gt;element_byte_size();</span>
<span class="line-added"> 813       }</span>
 814     }
 815   }
 816   //
 817   // Process the safepoint uses
 818   //
<span class="line-added"> 819   Unique_Node_List value_worklist;</span>
 820   while (safepoints.length() &gt; 0) {
 821     SafePointNode* sfpt = safepoints.pop();
 822     Node* mem = sfpt-&gt;memory();
 823     Node* ctl = sfpt-&gt;control();
 824     assert(sfpt-&gt;jvms() != NULL, &quot;missed JVMS&quot;);
 825     // Fields of scalar objs are referenced only at the end
 826     // of regular debuginfo at the last (youngest) JVMS.
 827     // Record relative start index.
 828     uint first_ind = (sfpt-&gt;req() - sfpt-&gt;jvms()-&gt;scloff());
 829     SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,
 830 #ifdef ASSERT
 831                                                  alloc,
 832 #endif
 833                                                  first_ind, nfields);
 834     sobj-&gt;init_req(0, C-&gt;root());
 835     transform_later(sobj);
 836 
 837     // Scan object&#39;s fields adding an input to the safepoint for each field.
 838     for (int j = 0; j &lt; nfields; j++) {
 839       intptr_t offset;
 840       ciField* field = NULL;
 841       if (iklass != NULL) {
 842         field = iklass-&gt;nonstatic_field_at(j);
 843         offset = field-&gt;offset();
 844         elem_type = field-&gt;type();
 845         basic_elem_type = field-&gt;layout_type();
<span class="line-added"> 846         assert(!field-&gt;is_flattened(), &quot;flattened inline type fields should not have safepoint uses&quot;);</span>
 847       } else {
 848         offset = array_base + j * (intptr_t)element_size;
 849       }
 850 
 851       const Type *field_type;
 852       // The next code is taken from Parse::do_get_xxx().
 853       if (is_reference_type(basic_elem_type)) {
 854         if (!elem_type-&gt;is_loaded()) {
 855           field_type = TypeInstPtr::BOTTOM;
 856         } else if (field != NULL &amp;&amp; field-&gt;is_static_constant()) {
 857           // This can happen if the constant oop is non-perm.
 858           ciObject* con = field-&gt;constant_value().as_object();
 859           // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
 860           // and may yield a vacuous result if the field is of interface type.
 861           field_type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
 862           assert(field_type != NULL, &quot;field singleton type must be consistent&quot;);
 863         } else {
 864           field_type = TypeOopPtr::make_from_klass(elem_type-&gt;as_klass());
 865         }
 866         if (UseCompressedOops) {
 867           field_type = field_type-&gt;make_narrowoop();
 868           basic_elem_type = T_NARROWOOP;
 869         }
 870       } else {
 871         field_type = Type::get_const_basic_type(basic_elem_type);
 872       }
 873 
<span class="line-modified"> 874       Node* field_val = NULL;</span>
<span class="line-modified"> 875       const TypeOopPtr* field_addr_type = res_type-&gt;add_offset(offset)-&gt;isa_oopptr();</span>
<span class="line-modified"> 876       if (klass-&gt;is_flat_array_klass()) {</span>
<span class="line-added"> 877         ciInlineKlass* vk = elem_type-&gt;as_inline_klass();</span>
<span class="line-added"> 878         assert(vk-&gt;flatten_array(), &quot;must be flattened&quot;);</span>
<span class="line-added"> 879         field_val = inline_type_from_mem(mem, ctl, vk, field_addr_type-&gt;isa_aryptr(), 0, alloc);</span>
<span class="line-added"> 880       } else {</span>
<span class="line-added"> 881         field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);</span>
<span class="line-added"> 882       }</span>
 883       if (field_val == NULL) {
 884         // We weren&#39;t able to find a value for this field,
 885         // give up on eliminating this allocation.
 886 
 887         // Remove any extra entries we added to the safepoint.
 888         uint last = sfpt-&gt;req() - 1;
 889         for (int k = 0;  k &lt; j; k++) {
 890           sfpt-&gt;del_req(last--);
 891         }
 892         _igvn._worklist.push(sfpt);
 893         // rollback processed safepoints
 894         while (safepoints_done.length() &gt; 0) {
 895           SafePointNode* sfpt_done = safepoints_done.pop();
 896           // remove any extra entries we added to the safepoint
 897           last = sfpt_done-&gt;req() - 1;
 898           for (int k = 0;  k &lt; nfields; k++) {
 899             sfpt_done-&gt;del_req(last--);
 900           }
 901           JVMState *jvms = sfpt_done-&gt;jvms();
 902           jvms-&gt;set_endoff(sfpt_done-&gt;req());
</pre>
<hr />
<pre>
 920         if (PrintEliminateAllocations) {
 921           if (field != NULL) {
 922             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of Field: &quot;,
 923                        sfpt-&gt;_idx);
 924             field-&gt;print();
 925             int field_idx = C-&gt;get_alias_index(field_addr_type);
 926             tty-&gt;print(&quot; (alias_idx=%d)&quot;, field_idx);
 927           } else { // Array&#39;s element
 928             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of array element [%d]&quot;,
 929                        sfpt-&gt;_idx, j);
 930           }
 931           tty-&gt;print(&quot;, which prevents elimination of: &quot;);
 932           if (res == NULL)
 933             alloc-&gt;dump();
 934           else
 935             res-&gt;dump();
 936         }
 937 #endif
 938         return false;
 939       }
<span class="line-modified"> 940       if (field_val-&gt;is_InlineType()) {</span>
<span class="line-added"> 941         // Keep track of inline types to scalarize them later</span>
<span class="line-added"> 942         value_worklist.push(field_val);</span>
<span class="line-added"> 943       } else if (UseCompressedOops &amp;&amp; field_type-&gt;isa_narrowoop()) {</span>
 944         // Enable &quot;DecodeN(EncodeP(Allocate)) --&gt; Allocate&quot; transformation
 945         // to be able scalar replace the allocation.
 946         if (field_val-&gt;is_EncodeP()) {
 947           field_val = field_val-&gt;in(1);
 948         } else {
 949           field_val = transform_later(new DecodeNNode(field_val, field_val-&gt;get_ptr_type()));
 950         }
 951       }
 952       sfpt-&gt;add_req(field_val);
 953     }
 954     JVMState *jvms = sfpt-&gt;jvms();
 955     jvms-&gt;set_endoff(sfpt-&gt;req());
 956     // Now make a pass over the debug information replacing any references
 957     // to the allocated object with &quot;sobj&quot;
 958     int start = jvms-&gt;debug_start();
 959     int end   = jvms-&gt;debug_end();
 960     sfpt-&gt;replace_edges_in_range(res, sobj, start, end);
 961     _igvn._worklist.push(sfpt);
 962     safepoints_done.append_if_missing(sfpt); // keep it for rollback
 963   }
<span class="line-added"> 964   // Scalarize inline types that were added to the safepoint</span>
<span class="line-added"> 965   for (uint i = 0; i &lt; value_worklist.size(); ++i) {</span>
<span class="line-added"> 966     Node* vt = value_worklist.at(i);</span>
<span class="line-added"> 967     vt-&gt;as_InlineType()-&gt;make_scalar_in_safepoints(&amp;_igvn);</span>
<span class="line-added"> 968   }</span>
 969   return true;
 970 }
 971 
 972 static void disconnect_projections(MultiNode* n, PhaseIterGVN&amp; igvn) {
 973   Node* ctl_proj = n-&gt;proj_out_or_null(TypeFunc::Control);
 974   Node* mem_proj = n-&gt;proj_out_or_null(TypeFunc::Memory);
 975   if (ctl_proj != NULL) {
 976     igvn.replace_node(ctl_proj, n-&gt;in(0));
 977   }
 978   if (mem_proj != NULL) {
 979     igvn.replace_node(mem_proj, n-&gt;in(TypeFunc::Memory));
 980   }
 981 }
 982 
 983 // Process users of eliminated allocation.
<span class="line-modified"> 984 void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc, bool inline_alloc) {</span>
 985   Node* res = alloc-&gt;result_cast();
 986   if (res != NULL) {
 987     for (DUIterator_Last jmin, j = res-&gt;last_outs(jmin); j &gt;= jmin; ) {
 988       Node *use = res-&gt;last_out(j);
 989       uint oc1 = res-&gt;outcnt();
 990 
 991       if (use-&gt;is_AddP()) {
 992         for (DUIterator_Last kmin, k = use-&gt;last_outs(kmin); k &gt;= kmin; ) {
 993           Node *n = use-&gt;last_out(k);
 994           uint oc2 = use-&gt;outcnt();
 995           if (n-&gt;is_Store()) {
<span class="line-modified"> 996             for (DUIterator_Fast pmax, p = n-&gt;fast_outs(pmax); p &lt; pmax; p++) {</span>
<span class="line-modified"> 997               MemBarNode* mb = n-&gt;fast_out(p)-&gt;isa_MemBar();</span>
<span class="line-modified"> 998               if (mb != NULL &amp;&amp; mb-&gt;req() &lt;= MemBarNode::Precedent &amp;&amp; mb-&gt;in(MemBarNode::Precedent) == n) {</span>
<span class="line-modified"> 999                 // MemBarVolatiles should have been removed by MemBarNode::Ideal() for non-inline allocations</span>
<span class="line-modified">1000                 assert(inline_alloc, &quot;MemBarVolatile should be eliminated for non-escaping object&quot;);</span>
<span class="line-modified">1001                 mb-&gt;remove(&amp;_igvn);</span>
<span class="line-modified">1002               }</span>



1003             }

1004             _igvn.replace_node(n, n-&gt;in(MemNode::Memory));
1005           } else {
1006             eliminate_gc_barrier(n);
1007           }
1008           k -= (oc2 - use-&gt;outcnt());
1009         }
1010         _igvn.remove_dead_node(use);
1011       } else if (use-&gt;is_ArrayCopy()) {
1012         // Disconnect ArrayCopy node
1013         ArrayCopyNode* ac = use-&gt;as_ArrayCopy();
1014         if (ac-&gt;is_clonebasic()) {
1015           Node* membar_after = ac-&gt;proj_out(TypeFunc::Control)-&gt;unique_ctrl_out();
1016           disconnect_projections(ac, _igvn);
1017           assert(alloc-&gt;in(TypeFunc::Memory)-&gt;is_Proj() &amp;&amp; alloc-&gt;in(TypeFunc::Memory)-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;mem barrier expected before allocation&quot;);
1018           Node* membar_before = alloc-&gt;in(TypeFunc::Memory)-&gt;in(0);
1019           disconnect_projections(membar_before-&gt;as_MemBar(), _igvn);
1020           if (membar_after-&gt;is_MemBar()) {
1021             disconnect_projections(membar_after-&gt;as_MemBar(), _igvn);
1022           }
1023         } else {
1024           assert(ac-&gt;is_arraycopy_validated() ||
1025                  ac-&gt;is_copyof_validated() ||
1026                  ac-&gt;is_copyofrange_validated(), &quot;unsupported&quot;);
<span class="line-modified">1027           CallProjections* callprojs = ac-&gt;extract_projections(true);</span>

1028 
<span class="line-modified">1029           _igvn.replace_node(callprojs-&gt;fallthrough_ioproj, ac-&gt;in(TypeFunc::I_O));</span>
<span class="line-modified">1030           _igvn.replace_node(callprojs-&gt;fallthrough_memproj, ac-&gt;in(TypeFunc::Memory));</span>
<span class="line-modified">1031           _igvn.replace_node(callprojs-&gt;fallthrough_catchproj, ac-&gt;in(TypeFunc::Control));</span>
1032 
1033           // Set control to top. IGVN will remove the remaining projections
1034           ac-&gt;set_req(0, top());
1035           ac-&gt;replace_edge(res, top());
1036 
1037           // Disconnect src right away: it can help find new
1038           // opportunities for allocation elimination
1039           Node* src = ac-&gt;in(ArrayCopyNode::Src);
1040           ac-&gt;replace_edge(src, top());
1041           // src can be top at this point if src and dest of the
1042           // arraycopy were the same
1043           if (src-&gt;outcnt() == 0 &amp;&amp; !src-&gt;is_top()) {
1044             _igvn.remove_dead_node(src);
1045           }
1046         }
1047         _igvn._worklist.push(ac);
<span class="line-added">1048       } else if (use-&gt;is_InlineType()) {</span>
<span class="line-added">1049         assert(use-&gt;isa_InlineType()-&gt;get_oop() == res, &quot;unexpected inline type use&quot;);</span>
<span class="line-added">1050         _igvn.rehash_node_delayed(use);</span>
<span class="line-added">1051         use-&gt;isa_InlineType()-&gt;set_oop(_igvn.zerocon(T_INLINE_TYPE));</span>
<span class="line-added">1052       } else if (use-&gt;is_Store()) {</span>
<span class="line-added">1053         _igvn.replace_node(use, use-&gt;in(MemNode::Memory));</span>
1054       } else {
1055         eliminate_gc_barrier(use);
1056       }
1057       j -= (oc1 - res-&gt;outcnt());
1058     }
1059     assert(res-&gt;outcnt() == 0, &quot;all uses of allocated objects must be deleted&quot;);
1060     _igvn.remove_dead_node(res);
1061   }
1062 
1063   //
1064   // Process other users of allocation&#39;s projections
1065   //
1066   if (_resproj != NULL &amp;&amp; _resproj-&gt;outcnt() != 0) {
1067     // First disconnect stores captured by Initialize node.
1068     // If Initialize node is eliminated first in the following code,
1069     // it will kill such stores and DUIterator_Last will assert.
1070     for (DUIterator_Fast jmax, j = _resproj-&gt;fast_outs(jmax);  j &lt; jmax; j++) {
1071       Node *use = _resproj-&gt;fast_out(j);
1072       if (use-&gt;is_AddP()) {
1073         // raw memory addresses used only by the initialization
1074         _igvn.replace_node(use, C-&gt;top());
1075         --j; --jmax;
1076       }
1077     }
1078     for (DUIterator_Last jmin, j = _resproj-&gt;last_outs(jmin); j &gt;= jmin; ) {
1079       Node *use = _resproj-&gt;last_out(j);
1080       uint oc1 = _resproj-&gt;outcnt();
1081       if (use-&gt;is_Initialize()) {
1082         // Eliminate Initialize node.
1083         InitializeNode *init = use-&gt;as_Initialize();
1084         assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
1085         Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
1086         if (ctrl_proj != NULL) {
<span class="line-added">1087           // Inline type buffer allocations are followed by a membar</span>
<span class="line-added">1088           Node* membar_after = ctrl_proj-&gt;unique_ctrl_out();</span>
<span class="line-added">1089           if (inline_alloc &amp;&amp; membar_after-&gt;Opcode() == Op_MemBarCPUOrder) {</span>
<span class="line-added">1090             membar_after-&gt;as_MemBar()-&gt;remove(&amp;_igvn);</span>
<span class="line-added">1091           }</span>
1092           _igvn.replace_node(ctrl_proj, init-&gt;in(TypeFunc::Control));
1093 #ifdef ASSERT
1094           Node* tmp = init-&gt;in(TypeFunc::Control);
1095           assert(tmp == _fallthroughcatchproj, &quot;allocation control projection&quot;);
1096 #endif
1097         }
1098         Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
1099         if (mem_proj != NULL) {
1100           Node *mem = init-&gt;in(TypeFunc::Memory);
1101 #ifdef ASSERT
1102           if (mem-&gt;is_MergeMem()) {
1103             assert(mem-&gt;in(TypeFunc::Memory) == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1104           } else {
1105             assert(mem == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1106           }
1107 #endif
1108           _igvn.replace_node(mem_proj, mem);
1109         }
<span class="line-added">1110       } else if (use-&gt;Opcode() == Op_MemBarStoreStore) {</span>
<span class="line-added">1111         // Inline type buffer allocations are followed by a membar</span>
<span class="line-added">1112         assert(inline_alloc, &quot;Unexpected MemBarStoreStore&quot;);</span>
<span class="line-added">1113         use-&gt;as_MemBar()-&gt;remove(&amp;_igvn);</span>
1114       } else  {
1115         assert(false, &quot;only Initialize or AddP expected&quot;);
1116       }
1117       j -= (oc1 - _resproj-&gt;outcnt());
1118     }
1119   }
1120   if (_fallthroughcatchproj != NULL) {
1121     _igvn.replace_node(_fallthroughcatchproj, alloc-&gt;in(TypeFunc::Control));
1122   }
1123   if (_memproj_fallthrough != NULL) {
1124     _igvn.replace_node(_memproj_fallthrough, alloc-&gt;in(TypeFunc::Memory));
1125   }
1126   if (_memproj_catchall != NULL) {
1127     _igvn.replace_node(_memproj_catchall, C-&gt;top());
1128   }
1129   if (_ioproj_fallthrough != NULL) {
1130     _igvn.replace_node(_ioproj_fallthrough, alloc-&gt;in(TypeFunc::I_O));
1131   }
1132   if (_ioproj_catchall != NULL) {
1133     _igvn.replace_node(_ioproj_catchall, C-&gt;top());
1134   }
1135   if (_catchallcatchproj != NULL) {
1136     _igvn.replace_node(_catchallcatchproj, C-&gt;top());
1137   }
1138 }
1139 
1140 bool PhaseMacroExpand::eliminate_allocate_node(AllocateNode *alloc) {
1141   // Don&#39;t do scalar replacement if the frame can be popped by JVMTI:
1142   // if reallocation fails during deoptimization we&#39;ll pop all
1143   // interpreter frames for this compiled frame and that won&#39;t play
1144   // nice with JVMTI popframe.
<span class="line-modified">1145   if (!EliminateAllocations || JvmtiExport::can_pop_frame()) {</span>
1146     return false;
1147   }
1148   Node* klass = alloc-&gt;in(AllocateNode::KlassNode);
1149   const TypeKlassPtr* tklass = _igvn.type(klass)-&gt;is_klassptr();
<span class="line-modified">1150 </span>
<span class="line-added">1151   // Attempt to eliminate inline type buffer allocations</span>
<span class="line-added">1152   // regardless of usage and escape/replaceable status.</span>
<span class="line-added">1153   bool inline_alloc = tklass-&gt;klass()-&gt;is_inlinetype();</span>
<span class="line-added">1154   if (!alloc-&gt;_is_non_escaping &amp;&amp; !inline_alloc) {</span>
<span class="line-added">1155     return false;</span>
<span class="line-added">1156   }</span>
1157   // Eliminate boxing allocations which are not used
<span class="line-modified">1158   // regardless of scalar replaceable status.</span>
<span class="line-modified">1159   Node* res = alloc-&gt;result_cast();</span>
<span class="line-modified">1160   bool boxing_alloc = (res == NULL) &amp;&amp; C-&gt;eliminate_boxing() &amp;&amp;</span>
<span class="line-added">1161                       tklass-&gt;klass()-&gt;is_instance_klass() &amp;&amp;</span>
1162                       tklass-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
<span class="line-modified">1163   if (!alloc-&gt;_is_scalar_replaceable &amp;&amp; !boxing_alloc &amp;&amp; !inline_alloc) {</span>
1164     return false;
1165   }
1166 
1167   extract_call_projections(alloc);
1168 
1169   GrowableArray &lt;SafePointNode *&gt; safepoints;
1170   if (!can_eliminate_allocation(alloc, safepoints)) {
1171     return false;
1172   }
1173 
1174   if (!alloc-&gt;_is_scalar_replaceable) {
<span class="line-modified">1175     assert(res == NULL || inline_alloc, &quot;sanity&quot;);</span>
1176     // We can only eliminate allocation if all debug info references
1177     // are already replaced with SafePointScalarObject because
1178     // we can&#39;t search for a fields value without instance_id.
1179     if (safepoints.length() &gt; 0) {
<span class="line-added">1180       assert(!inline_alloc, &quot;Inline type allocations should not have safepoint uses&quot;);</span>
1181       return false;
1182     }
1183   }
1184 
1185   if (!scalar_replacement(alloc, safepoints)) {
1186     return false;
1187   }
1188 
1189   CompileLog* log = C-&gt;log();
1190   if (log != NULL) {
1191     log-&gt;head(&quot;eliminate_allocation type=&#39;%d&#39;&quot;,
1192               log-&gt;identify(tklass-&gt;klass()));
1193     JVMState* p = alloc-&gt;jvms();
1194     while (p != NULL) {
1195       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1196       p = p-&gt;caller();
1197     }
1198     log-&gt;tail(&quot;eliminate_allocation&quot;);
1199   }
1200 
<span class="line-modified">1201   process_users_of_allocation(alloc, inline_alloc);</span>
1202 
1203 #ifndef PRODUCT
1204   if (PrintEliminateAllocations) {
1205     if (alloc-&gt;is_AllocateArray())
1206       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1207     else
1208       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1209   }
1210 #endif
1211 
1212   return true;
1213 }
1214 
1215 bool PhaseMacroExpand::eliminate_boxing_node(CallStaticJavaNode *boxing) {
1216   // EA should remove all uses of non-escaping boxing node.
1217   if (!C-&gt;eliminate_boxing() || boxing-&gt;proj_out_or_null(TypeFunc::Parms) != NULL) {
1218     return false;
1219   }
1220 
1221   assert(boxing-&gt;result_cast() == NULL, &quot;unexpected boxing node result&quot;);
1222 
1223   extract_call_projections(boxing);
1224 
<span class="line-modified">1225   const TypeTuple* r = boxing-&gt;tf()-&gt;range_sig();</span>
1226   assert(r-&gt;cnt() &gt; TypeFunc::Parms, &quot;sanity&quot;);
1227   const TypeInstPtr* t = r-&gt;field_at(TypeFunc::Parms)-&gt;isa_instptr();
1228   assert(t != NULL, &quot;sanity&quot;);
1229 
1230   CompileLog* log = C-&gt;log();
1231   if (log != NULL) {
1232     log-&gt;head(&quot;eliminate_boxing type=&#39;%d&#39;&quot;,
1233               log-&gt;identify(t-&gt;klass()));
1234     JVMState* p = boxing-&gt;jvms();
1235     while (p != NULL) {
1236       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1237       p = p-&gt;caller();
1238     }
1239     log-&gt;tail(&quot;eliminate_boxing&quot;);
1240   }
1241 
1242   process_users_of_allocation(boxing);
1243 
1244 #ifndef PRODUCT
1245   if (PrintEliminateAllocations) {
</pre>
<hr />
<pre>
1406         }
1407       }
1408 #endif
1409       yank_alloc_node(alloc);
1410       return;
1411     }
1412   }
1413 
1414   enum { too_big_or_final_path = 1, need_gc_path = 2 };
1415   Node *slow_region = NULL;
1416   Node *toobig_false = ctrl;
1417 
1418   // generate the initial test if necessary
1419   if (initial_slow_test != NULL ) {
1420     assert (expand_fast_path, &quot;Only need test if there is a fast path&quot;);
1421     slow_region = new RegionNode(3);
1422 
1423     // Now make the initial failure test.  Usually a too-big test but
1424     // might be a TRUE for finalizers or a fancy class check for
1425     // newInstance0.
<span class="line-modified">1426     IfNode* toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);</span>
1427     transform_later(toobig_iff);
1428     // Plug the failing-too-big test into the slow-path region
<span class="line-modified">1429     Node* toobig_true = new IfTrueNode(toobig_iff);</span>
1430     transform_later(toobig_true);
1431     slow_region    -&gt;init_req( too_big_or_final_path, toobig_true );
<span class="line-modified">1432     toobig_false = new IfFalseNode(toobig_iff);</span>
1433     transform_later(toobig_false);
1434   } else {
1435     // No initial test, just fall into next case
1436     assert(allocation_has_use || !expand_fast_path, &quot;Should already have been handled&quot;);
1437     toobig_false = ctrl;
1438     debug_only(slow_region = NodeSentinel);
1439   }
1440 
1441   // If we are here there are several possibilities
1442   // - expand_fast_path is false - then only a slow path is expanded. That&#39;s it.
1443   // no_initial_check means a constant allocation.
1444   // - If check always evaluates to false -&gt; expand_fast_path is false (see above)
1445   // - If check always evaluates to true -&gt; directly into fast path (but may bailout to slowpath)
1446   // if !allocation_has_use the fast path is empty
1447   // if !allocation_has_use &amp;&amp; no_initial_check
1448   // - Then there are no fastpath that can fall out to slowpath -&gt; no allocation code at all.
1449   //   removed by yank_alloc_node above.
1450 
1451   Node *slow_mem = mem;  // save the current memory state for slow path
1452   // generate the fast allocation code unless we know that the initial test will always go slow
1453   if (expand_fast_path) {
1454     // Fast path modifies only raw memory.
1455     if (mem-&gt;is_MergeMem()) {
1456       mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
1457     }
1458 
1459     // allocate the Region and Phi nodes for the result
1460     result_region = new RegionNode(3);
1461     result_phi_rawmem = new PhiNode(result_region, Type::MEMORY, TypeRawPtr::BOTTOM);
1462     result_phi_i_o    = new PhiNode(result_region, Type::ABIO); // I/O is used for Prefetch
1463 
1464     // Grab regular I/O before optional prefetch may change it.
1465     // Slow-path does no I/O so just set it to the original I/O.
1466     result_phi_i_o-&gt;init_req(slow_result_path, i_o);
1467 
1468     // Name successful fast-path variables
1469     Node* fast_oop_ctrl;
1470     Node* fast_oop_rawmem;
<span class="line-added">1471 </span>
1472     if (allocation_has_use) {
1473       Node* needgc_ctrl = NULL;
1474       result_phi_rawoop = new PhiNode(result_region, TypeRawPtr::BOTTOM);
1475 
1476       intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;
1477       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1478       Node* fast_oop = bs-&gt;obj_allocate(this, ctrl, mem, toobig_false, size_in_bytes, i_o, needgc_ctrl,
1479                                         fast_oop_ctrl, fast_oop_rawmem,
1480                                         prefetch_lines);
1481 
1482       if (initial_slow_test != NULL) {
1483         // This completes all paths into the slow merge point
1484         slow_region-&gt;init_req(need_gc_path, needgc_ctrl);
1485         transform_later(slow_region);
1486       } else {
1487         // No initial slow path needed!
1488         // Just fall from the need-GC path straight into the VM call.
1489         slow_region = needgc_ctrl;
1490       }
1491 
</pre>
<hr />
<pre>
1510     result_phi_rawmem-&gt;init_req(fast_result_path, fast_oop_rawmem);
1511   } else {
1512     slow_region = ctrl;
1513     result_phi_i_o = i_o; // Rename it to use in the following code.
1514   }
1515 
1516   // Generate slow-path call
1517   CallNode *call = new CallStaticJavaNode(slow_call_type, slow_call_address,
1518                                OptoRuntime::stub_name(slow_call_address),
1519                                alloc-&gt;jvms()-&gt;bci(),
1520                                TypePtr::BOTTOM);
1521   call-&gt;init_req(TypeFunc::Control,   slow_region);
1522   call-&gt;init_req(TypeFunc::I_O,       top());    // does no i/o
1523   call-&gt;init_req(TypeFunc::Memory,    slow_mem); // may gc ptrs
1524   call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1525   call-&gt;init_req(TypeFunc::FramePtr,  alloc-&gt;in(TypeFunc::FramePtr));
1526 
1527   call-&gt;init_req(TypeFunc::Parms+0, klass_node);
1528   if (length != NULL) {
1529     call-&gt;init_req(TypeFunc::Parms+1, length);
<span class="line-added">1530   } else {</span>
<span class="line-added">1531     // Let the runtime know if this is a larval allocation</span>
<span class="line-added">1532     call-&gt;init_req(TypeFunc::Parms+1, _igvn.intcon(alloc-&gt;_larval));</span>
1533   }
1534 
1535   // Copy debug information and adjust JVMState information, then replace
1536   // allocate node with the call
<span class="line-modified">1537   call-&gt;copy_call_debug_info(&amp;_igvn, alloc);</span>
1538   if (expand_fast_path) {
1539     call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
1540   } else {
1541     // Hook i_o projection to avoid its elimination during allocation
1542     // replacement (when only a slow call is generated).
1543     call-&gt;set_req(TypeFunc::I_O, result_phi_i_o);
1544   }
1545   _igvn.replace_node(alloc, call);
1546   transform_later(call);
1547 
1548   // Identify the output projections from the allocate node and
1549   // adjust any references to them.
1550   // The control and io projections look like:
1551   //
1552   //        v---Proj(ctrl) &lt;-----+   v---CatchProj(ctrl)
1553   //  Allocate                   Catch
1554   //        ^---Proj(io) &lt;-------+   ^---CatchProj(io)
1555   //
1556   //  We are interested in the CatchProj nodes.
1557   //
1558   extract_call_projections(call);
1559 
1560   // An allocate node has separate memory projections for the uses on
1561   // the control and i_o paths. Replace the control memory projection with
1562   // result_phi_rawmem (unless we are only generating a slow call when
1563   // both memory projections are combined)
1564   if (expand_fast_path &amp;&amp; _memproj_fallthrough != NULL) {
<span class="line-modified">1565     _igvn.replace_in_uses(_memproj_fallthrough, result_phi_rawmem);</span>
1566   }
1567   // Now change uses of _memproj_catchall to use _memproj_fallthrough and delete
1568   // _memproj_catchall so we end up with a call that has only 1 memory projection.
<span class="line-modified">1569   if (_memproj_catchall != NULL) {</span>
1570     if (_memproj_fallthrough == NULL) {
1571       _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);
1572       transform_later(_memproj_fallthrough);
1573     }
<span class="line-modified">1574     _igvn.replace_in_uses(_memproj_catchall, _memproj_fallthrough);</span>
1575     _igvn.remove_dead_node(_memproj_catchall);
1576   }
1577 
1578   // An allocate node has separate i_o projections for the uses on the control
1579   // and i_o paths. Always replace the control i_o projection with result i_o
1580   // otherwise incoming i_o become dead when only a slow call is generated
1581   // (it is different from memory projections where both projections are
1582   // combined in such case).
1583   if (_ioproj_fallthrough != NULL) {
<span class="line-modified">1584     _igvn.replace_in_uses(_ioproj_fallthrough, result_phi_i_o);</span>
1585   }
1586   // Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete
1587   // _ioproj_catchall so we end up with a call that has only 1 i_o projection.
<span class="line-modified">1588   if (_ioproj_catchall != NULL) {</span>
1589     if (_ioproj_fallthrough == NULL) {
1590       _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);
1591       transform_later(_ioproj_fallthrough);
1592     }
<span class="line-modified">1593     _igvn.replace_in_uses(_ioproj_catchall, _ioproj_fallthrough);</span>
1594     _igvn.remove_dead_node(_ioproj_catchall);
1595   }
1596 
1597   // if we generated only a slow call, we are done
1598   if (!expand_fast_path) {
1599     // Now we can unhook i_o.
1600     if (result_phi_i_o-&gt;outcnt() &gt; 1) {
1601       call-&gt;set_req(TypeFunc::I_O, top());
1602     } else {
1603       assert(result_phi_i_o-&gt;unique_ctrl_out() == call, &quot;sanity&quot;);
1604       // Case of new array with negative size known during compilation.
1605       // AllocateArrayNode::Ideal() optimization disconnect unreachable
1606       // following code since call to runtime will throw exception.
1607       // As result there will be no users of i_o after the call.
1608       // Leave i_o attached to this call to avoid problems in preceding graph.
1609     }
1610     return;
1611   }
1612 
1613   if (_fallthroughcatchproj != NULL) {
</pre>
<hr />
<pre>
1641 }
1642 
1643 // Remove alloc node that has no uses.
1644 void PhaseMacroExpand::yank_alloc_node(AllocateNode* alloc) {
1645   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1646   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1647   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1648 
1649   extract_call_projections(alloc);
1650   if (_resproj != NULL) {
1651     for (DUIterator_Fast imax, i = _resproj-&gt;fast_outs(imax); i &lt; imax; i++) {
1652       Node* use = _resproj-&gt;fast_out(i);
1653       use-&gt;isa_MemBar()-&gt;remove(&amp;_igvn);
1654       --imax;
1655       --i; // back up iterator
1656     }
1657     assert(_resproj-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);
1658     _igvn.remove_dead_node(_resproj);
1659   }
1660   if (_fallthroughcatchproj != NULL) {
<span class="line-modified">1661     _igvn.replace_in_uses(_fallthroughcatchproj, ctrl);</span>
1662     _igvn.remove_dead_node(_fallthroughcatchproj);
1663   }
1664   if (_catchallcatchproj != NULL) {
1665     _igvn.rehash_node_delayed(_catchallcatchproj);
1666     _catchallcatchproj-&gt;set_req(0, top());
1667   }
1668   if (_fallthroughproj != NULL) {
1669     Node* catchnode = _fallthroughproj-&gt;unique_ctrl_out();
1670     _igvn.remove_dead_node(catchnode);
1671     _igvn.remove_dead_node(_fallthroughproj);
1672   }
1673   if (_memproj_fallthrough != NULL) {
<span class="line-modified">1674     _igvn.replace_in_uses(_memproj_fallthrough, mem);</span>
1675     _igvn.remove_dead_node(_memproj_fallthrough);
1676   }
1677   if (_ioproj_fallthrough != NULL) {
<span class="line-modified">1678     _igvn.replace_in_uses(_ioproj_fallthrough, i_o);</span>
1679     _igvn.remove_dead_node(_ioproj_fallthrough);
1680   }
1681   if (_memproj_catchall != NULL) {
1682     _igvn.rehash_node_delayed(_memproj_catchall);
1683     _memproj_catchall-&gt;set_req(0, top());
1684   }
1685   if (_ioproj_catchall != NULL) {
1686     _igvn.rehash_node_delayed(_ioproj_catchall);
1687     _ioproj_catchall-&gt;set_req(0, top());
1688   }
1689 #ifndef PRODUCT
1690   if (PrintEliminateAllocations) {
1691     if (alloc-&gt;is_AllocateArray()) {
1692       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1693     } else {
1694       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1695     }
1696   }
1697 #endif
1698   _igvn.remove_dead_node(alloc);
</pre>
<hr />
<pre>
1784     Node* thread = new ThreadLocalNode();
1785     transform_later(thread);
1786 
1787     call-&gt;init_req(TypeFunc::Parms + 0, thread);
1788     call-&gt;init_req(TypeFunc::Parms + 1, oop);
1789     call-&gt;init_req(TypeFunc::Control, ctrl);
1790     call-&gt;init_req(TypeFunc::I_O    , top()); // does no i/o
1791     call-&gt;init_req(TypeFunc::Memory , ctrl);
1792     call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1793     call-&gt;init_req(TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr));
1794     transform_later(call);
1795     ctrl = new ProjNode(call, TypeFunc::Control);
1796     transform_later(ctrl);
1797     rawmem = new ProjNode(call, TypeFunc::Memory);
1798     transform_later(rawmem);
1799   }
1800 }
1801 
1802 // Helper for PhaseMacroExpand::expand_allocate_common.
1803 // Initializes the newly-allocated storage.
<span class="line-modified">1804 Node* PhaseMacroExpand::initialize_object(AllocateNode* alloc,</span>
<span class="line-modified">1805                                           Node* control, Node* rawmem, Node* object,</span>
<span class="line-modified">1806                                           Node* klass_node, Node* length,</span>
<span class="line-modified">1807                                           Node* size_in_bytes) {</span>

1808   InitializeNode* init = alloc-&gt;initialization();
1809   // Store the klass &amp; mark bits
<span class="line-modified">1810   Node* mark_node = alloc-&gt;make_ideal_mark(&amp;_igvn, control, rawmem);</span>
1811   if (!mark_node-&gt;is_Con()) {
1812     transform_later(mark_node);
1813   }
1814   rawmem = make_store(control, rawmem, object, oopDesc::mark_offset_in_bytes(), mark_node, TypeX_X-&gt;basic_type());
1815 
1816   rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);
1817   int header_size = alloc-&gt;minimum_header_size();  // conservatively small
1818 
1819   // Array length
1820   if (length != NULL) {         // Arrays need length field
1821     rawmem = make_store(control, rawmem, object, arrayOopDesc::length_offset_in_bytes(), length, T_INT);
1822     // conservatively small header size:
1823     header_size = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1824     ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1825     if (k-&gt;is_array_klass())    // we know the exact header size in most cases:
1826       header_size = Klass::layout_helper_header_size(k-&gt;layout_helper());
1827   }
1828 
1829   // Clear the object body, if necessary.
1830   if (init == NULL) {
1831     // The init has somehow disappeared; be cautious and clear everything.
1832     //
1833     // This can happen if a node is allocated but an uncommon trap occurs
1834     // immediately.  In this case, the Initialize gets associated with the
1835     // trap, and may be placed in a different (outer) loop, if the Allocate
1836     // is in a loop.  If (this is rare) the inner loop gets unrolled, then
1837     // there can be two Allocates to one Initialize.  The answer in all these
1838     // edge cases is safety first.  It is always safe to clear immediately
1839     // within an Allocate, and then (maybe or maybe not) clear some more later.
1840     if (!(UseTLAB &amp;&amp; ZeroTLAB)) {
1841       rawmem = ClearArrayNode::clear_memory(control, rawmem, object,
<span class="line-added">1842                                             alloc-&gt;in(AllocateNode::DefaultValue),</span>
<span class="line-added">1843                                             alloc-&gt;in(AllocateNode::RawDefaultValue),</span>
1844                                             header_size, size_in_bytes,
1845                                             &amp;_igvn);
1846     }
1847   } else {
1848     if (!init-&gt;is_complete()) {
1849       // Try to win by zeroing only what the init does not store.
1850       // We can also try to do some peephole optimizations,
1851       // such as combining some adjacent subword stores.
1852       rawmem = init-&gt;complete_stores(control, rawmem, object,
1853                                      header_size, size_in_bytes, &amp;_igvn);
1854     }
1855     // We have no more use for this link, since the AllocateNode goes away:
1856     init-&gt;set_req(InitializeNode::RawAddress, top());
1857     // (If we keep the link, it just confuses the register allocator,
1858     // who thinks he sees a real use of the address by the membar.)
1859   }
1860 
1861   return rawmem;
1862 }
1863 
</pre>
<hr />
<pre>
2204         // Replace old box node with new eliminated box for all users
2205         // of the same object and mark related locks as eliminated.
2206         mark_eliminated_box(box, obj);
2207       }
2208     }
2209   }
2210 }
2211 
2212 // we have determined that this lock/unlock can be eliminated, we simply
2213 // eliminate the node without expanding it.
2214 //
2215 // Note:  The membar&#39;s associated with the lock/unlock are currently not
2216 //        eliminated.  This should be investigated as a future enhancement.
2217 //
2218 bool PhaseMacroExpand::eliminate_locking_node(AbstractLockNode *alock) {
2219 
2220   if (!alock-&gt;is_eliminated()) {
2221     return false;
2222   }
2223 #ifdef ASSERT
<span class="line-added">2224   const Type* obj_type = _igvn.type(alock-&gt;obj_node());</span>
<span class="line-added">2225   assert(!obj_type-&gt;isa_inlinetype() &amp;&amp; !obj_type-&gt;is_inlinetypeptr(), &quot;Eliminating lock on inline type&quot;);</span>
2226   if (!alock-&gt;is_coarsened()) {
2227     // Check that new &quot;eliminated&quot; BoxLock node is created.
2228     BoxLockNode* oldbox = alock-&gt;box_node()-&gt;as_BoxLock();
2229     assert(oldbox-&gt;is_eliminated(), &quot;should be done already&quot;);
2230   }
2231 #endif
2232 
2233   alock-&gt;log_lock_optimization(C, &quot;eliminate_lock&quot;);
2234 
2235 #ifndef PRODUCT
2236   if (PrintEliminateLocks) {
2237     if (alock-&gt;is_Lock()) {
2238       tty-&gt;print_cr(&quot;++++ Eliminated: %d Lock&quot;, alock-&gt;_idx);
2239     } else {
2240       tty-&gt;print_cr(&quot;++++ Eliminated: %d Unlock&quot;, alock-&gt;_idx);
2241     }
2242   }
2243 #endif
2244 
2245   Node* mem  = alock-&gt;in(TypeFunc::Memory);
</pre>
<hr />
<pre>
2487     // region-&gt;in(2) is set to fast path - the object is locked to the current thread.
2488 
2489     slow_path-&gt;init_req(2, ctrl); // Capture slow-control
2490     slow_mem-&gt;init_req(2, fast_lock_mem_phi);
2491 
2492     transform_later(slow_path);
2493     transform_later(slow_mem);
2494     // Reset lock&#39;s memory edge.
2495     lock-&gt;set_req(TypeFunc::Memory, slow_mem);
2496 
2497   } else {
2498     region  = new RegionNode(3);
2499     // create a Phi for the memory state
2500     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2501 
2502     // Optimize test; set region slot 2
2503     slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);
2504     mem_phi-&gt;init_req(2, mem);
2505   }
2506 
<span class="line-added">2507   const TypeOopPtr* objptr = _igvn.type(obj)-&gt;make_oopptr();</span>
<span class="line-added">2508   if (objptr-&gt;can_be_inline_type()) {</span>
<span class="line-added">2509     // Deoptimize and re-execute if a value</span>
<span class="line-added">2510     assert(EnableValhalla, &quot;should only be used if inline types are enabled&quot;);</span>
<span class="line-added">2511     Node* mark = make_load(slow_path, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());</span>
<span class="line-added">2512     Node* value_mask = _igvn.MakeConX(markWord::always_locked_pattern);</span>
<span class="line-added">2513     Node* is_value = _igvn.transform(new AndXNode(mark, value_mask));</span>
<span class="line-added">2514     Node* cmp = _igvn.transform(new CmpXNode(is_value, value_mask));</span>
<span class="line-added">2515     Node* bol = _igvn.transform(new BoolNode(cmp, BoolTest::eq));</span>
<span class="line-added">2516     Node* unc_ctrl = generate_slow_guard(&amp;slow_path, bol, NULL);</span>
<span class="line-added">2517 </span>
<span class="line-added">2518     int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_class_check, Deoptimization::Action_none);</span>
<span class="line-added">2519     address call_addr = SharedRuntime::uncommon_trap_blob()-&gt;entry_point();</span>
<span class="line-added">2520     const TypePtr* no_memory_effects = NULL;</span>
<span class="line-added">2521     JVMState* jvms = lock-&gt;jvms();</span>
<span class="line-added">2522     CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, &quot;uncommon_trap&quot;,</span>
<span class="line-added">2523                                            jvms-&gt;bci(), no_memory_effects);</span>
<span class="line-added">2524 </span>
<span class="line-added">2525     unc-&gt;init_req(TypeFunc::Control, unc_ctrl);</span>
<span class="line-added">2526     unc-&gt;init_req(TypeFunc::I_O, lock-&gt;i_o());</span>
<span class="line-added">2527     unc-&gt;init_req(TypeFunc::Memory, mem); // may gc ptrs</span>
<span class="line-added">2528     unc-&gt;init_req(TypeFunc::FramePtr,  lock-&gt;in(TypeFunc::FramePtr));</span>
<span class="line-added">2529     unc-&gt;init_req(TypeFunc::ReturnAdr, lock-&gt;in(TypeFunc::ReturnAdr));</span>
<span class="line-added">2530     unc-&gt;init_req(TypeFunc::Parms+0, _igvn.intcon(trap_request));</span>
<span class="line-added">2531     unc-&gt;set_cnt(PROB_UNLIKELY_MAG(4));</span>
<span class="line-added">2532     unc-&gt;copy_call_debug_info(&amp;_igvn, lock);</span>
<span class="line-added">2533 </span>
<span class="line-added">2534     assert(unc-&gt;peek_monitor_box() == box, &quot;wrong monitor&quot;);</span>
<span class="line-added">2535     assert(unc-&gt;peek_monitor_obj() == obj, &quot;wrong monitor&quot;);</span>
<span class="line-added">2536 </span>
<span class="line-added">2537     // pop monitor and push obj back on stack: we trap before the monitorenter</span>
<span class="line-added">2538     unc-&gt;pop_monitor();</span>
<span class="line-added">2539     unc-&gt;grow_stack(unc-&gt;jvms(), 1);</span>
<span class="line-added">2540     unc-&gt;set_stack(unc-&gt;jvms(), unc-&gt;jvms()-&gt;stk_size()-1, obj);</span>
<span class="line-added">2541 </span>
<span class="line-added">2542     _igvn.register_new_node_with_optimizer(unc);</span>
<span class="line-added">2543 </span>
<span class="line-added">2544     Node* ctrl = _igvn.transform(new ProjNode(unc, TypeFunc::Control));</span>
<span class="line-added">2545     Node* halt = _igvn.transform(new HaltNode(ctrl, lock-&gt;in(TypeFunc::FramePtr), &quot;monitor enter on value-type&quot;));</span>
<span class="line-added">2546     C-&gt;root()-&gt;add_req(halt);</span>
<span class="line-added">2547   }</span>
<span class="line-added">2548 </span>
2549   // Make slow path call
2550   CallNode *call = make_slow_call((CallNode *) lock, OptoRuntime::complete_monitor_enter_Type(),
2551                                   OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,
2552                                   obj, box, NULL);
2553 
2554   extract_call_projections(call);
2555 
2556   // Slow path can only throw asynchronous exceptions, which are always
2557   // de-opted.  So the compiler thinks the slow-call can never throw an
2558   // exception.  If it DOES throw an exception we would need the debug
2559   // info removed first (since if it throws there is no monitor).
2560   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2561            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2562 
2563   // Capture slow path
2564   // disconnect fall-through projection from call and create a new one
2565   // hook up users of fall-through projection to region
2566   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2567   transform_later(slow_ctrl);
2568   _igvn.hash_delete(_fallthroughproj);
</pre>
<hr />
<pre>
2630   // No exceptions for unlocking
2631   // Capture slow path
2632   // disconnect fall-through projection from call and create a new one
2633   // hook up users of fall-through projection to region
2634   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2635   transform_later(slow_ctrl);
2636   _igvn.hash_delete(_fallthroughproj);
2637   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2638   region-&gt;init_req(1, slow_ctrl);
2639   // region inputs are now complete
2640   transform_later(region);
2641   _igvn.replace_node(_fallthroughproj, region);
2642 
2643   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory) );
2644   mem_phi-&gt;init_req(1, memproj );
2645   mem_phi-&gt;init_req(2, mem);
2646   transform_later(mem_phi);
2647   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2648 }
2649 
<span class="line-added">2650 // An inline type might be returned from the call but we don&#39;t know its</span>
<span class="line-added">2651 // type. Either we get a buffered inline type (and nothing needs to be done)</span>
<span class="line-added">2652 // or one of the inlines being returned is the klass of the inline type</span>
<span class="line-added">2653 // and we need to allocate an inline type instance of that type and</span>
<span class="line-added">2654 // initialize it with other values being returned. In that case, we</span>
<span class="line-added">2655 // first try a fast path allocation and initialize the value with the</span>
<span class="line-added">2656 // inline klass&#39;s pack handler or we fall back to a runtime call.</span>
<span class="line-added">2657 void PhaseMacroExpand::expand_mh_intrinsic_return(CallStaticJavaNode* call) {</span>
<span class="line-added">2658   assert(call-&gt;method()-&gt;is_method_handle_intrinsic(), &quot;must be a method handle intrinsic call&quot;);</span>
<span class="line-added">2659   Node* ret = call-&gt;proj_out_or_null(TypeFunc::Parms);</span>
<span class="line-added">2660   if (ret == NULL) {</span>
<span class="line-added">2661     return;</span>
<span class="line-added">2662   }</span>
<span class="line-added">2663   const TypeFunc* tf = call-&gt;_tf;</span>
<span class="line-added">2664   const TypeTuple* domain = OptoRuntime::store_inline_type_fields_Type()-&gt;domain_cc();</span>
<span class="line-added">2665   const TypeFunc* new_tf = TypeFunc::make(tf-&gt;domain_sig(), tf-&gt;domain_cc(), tf-&gt;range_sig(), domain);</span>
<span class="line-added">2666   call-&gt;_tf = new_tf;</span>
<span class="line-added">2667   // Make sure the change of type is applied before projections are processed by igvn</span>
<span class="line-added">2668   _igvn.set_type(call, call-&gt;Value(&amp;_igvn));</span>
<span class="line-added">2669   _igvn.set_type(ret, ret-&gt;Value(&amp;_igvn));</span>
<span class="line-added">2670 </span>
<span class="line-added">2671   // Before any new projection is added:</span>
<span class="line-added">2672   CallProjections* projs = call-&gt;extract_projections(true, true);</span>
<span class="line-added">2673 </span>
<span class="line-added">2674   Node* ctl = new Node(1);</span>
<span class="line-added">2675   Node* mem = new Node(1);</span>
<span class="line-added">2676   Node* io = new Node(1);</span>
<span class="line-added">2677   Node* ex_ctl = new Node(1);</span>
<span class="line-added">2678   Node* ex_mem = new Node(1);</span>
<span class="line-added">2679   Node* ex_io = new Node(1);</span>
<span class="line-added">2680   Node* res = new Node(1);</span>
<span class="line-added">2681 </span>
<span class="line-added">2682   Node* cast = transform_later(new CastP2XNode(ctl, res));</span>
<span class="line-added">2683   Node* mask = MakeConX(0x1);</span>
<span class="line-added">2684   Node* masked = transform_later(new AndXNode(cast, mask));</span>
<span class="line-added">2685   Node* cmp = transform_later(new CmpXNode(masked, mask));</span>
<span class="line-added">2686   Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));</span>
<span class="line-added">2687   IfNode* allocation_iff = new IfNode(ctl, bol, PROB_MAX, COUNT_UNKNOWN);</span>
<span class="line-added">2688   transform_later(allocation_iff);</span>
<span class="line-added">2689   Node* allocation_ctl = transform_later(new IfTrueNode(allocation_iff));</span>
<span class="line-added">2690   Node* no_allocation_ctl = transform_later(new IfFalseNode(allocation_iff));</span>
<span class="line-added">2691 </span>
<span class="line-added">2692   Node* no_allocation_res = transform_later(new CheckCastPPNode(no_allocation_ctl, res, TypeInstPtr::BOTTOM));</span>
<span class="line-added">2693 </span>
<span class="line-added">2694   Node* mask2 = MakeConX(-2);</span>
<span class="line-added">2695   Node* masked2 = transform_later(new AndXNode(cast, mask2));</span>
<span class="line-added">2696   Node* rawklassptr = transform_later(new CastX2PNode(masked2));</span>
<span class="line-added">2697   Node* klass_node = transform_later(new CheckCastPPNode(allocation_ctl, rawklassptr, TypeKlassPtr::OBJECT_OR_NULL));</span>
<span class="line-added">2698 </span>
<span class="line-added">2699   Node* slowpath_bol = NULL;</span>
<span class="line-added">2700   Node* top_adr = NULL;</span>
<span class="line-added">2701   Node* old_top = NULL;</span>
<span class="line-added">2702   Node* new_top = NULL;</span>
<span class="line-added">2703   if (UseTLAB) {</span>
<span class="line-added">2704     Node* end_adr = NULL;</span>
<span class="line-added">2705     set_eden_pointers(top_adr, end_adr);</span>
<span class="line-added">2706     Node* end = make_load(ctl, mem, end_adr, 0, TypeRawPtr::BOTTOM, T_ADDRESS);</span>
<span class="line-added">2707     old_top = new LoadPNode(ctl, mem, top_adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM, MemNode::unordered);</span>
<span class="line-added">2708     transform_later(old_top);</span>
<span class="line-added">2709     Node* layout_val = make_load(NULL, mem, klass_node, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);</span>
<span class="line-added">2710     Node* size_in_bytes = ConvI2X(layout_val);</span>
<span class="line-added">2711     new_top = new AddPNode(top(), old_top, size_in_bytes);</span>
<span class="line-added">2712     transform_later(new_top);</span>
<span class="line-added">2713     Node* slowpath_cmp = new CmpPNode(new_top, end);</span>
<span class="line-added">2714     transform_later(slowpath_cmp);</span>
<span class="line-added">2715     slowpath_bol = new BoolNode(slowpath_cmp, BoolTest::ge);</span>
<span class="line-added">2716     transform_later(slowpath_bol);</span>
<span class="line-added">2717   } else {</span>
<span class="line-added">2718     slowpath_bol = intcon(1);</span>
<span class="line-added">2719     top_adr = top();</span>
<span class="line-added">2720     old_top = top();</span>
<span class="line-added">2721     new_top = top();</span>
<span class="line-added">2722   }</span>
<span class="line-added">2723   IfNode* slowpath_iff = new IfNode(allocation_ctl, slowpath_bol, PROB_UNLIKELY_MAG(4), COUNT_UNKNOWN);</span>
<span class="line-added">2724   transform_later(slowpath_iff);</span>
<span class="line-added">2725 </span>
<span class="line-added">2726   Node* slowpath_true = new IfTrueNode(slowpath_iff);</span>
<span class="line-added">2727   transform_later(slowpath_true);</span>
<span class="line-added">2728 </span>
<span class="line-added">2729   CallStaticJavaNode* slow_call = new CallStaticJavaNode(OptoRuntime::store_inline_type_fields_Type(),</span>
<span class="line-added">2730                                                          StubRoutines::store_inline_type_fields_to_buf(),</span>
<span class="line-added">2731                                                          &quot;store_inline_type_fields&quot;,</span>
<span class="line-added">2732                                                          call-&gt;jvms()-&gt;bci(),</span>
<span class="line-added">2733                                                          TypePtr::BOTTOM);</span>
<span class="line-added">2734   slow_call-&gt;init_req(TypeFunc::Control, slowpath_true);</span>
<span class="line-added">2735   slow_call-&gt;init_req(TypeFunc::Memory, mem);</span>
<span class="line-added">2736   slow_call-&gt;init_req(TypeFunc::I_O, io);</span>
<span class="line-added">2737   slow_call-&gt;init_req(TypeFunc::FramePtr, call-&gt;in(TypeFunc::FramePtr));</span>
<span class="line-added">2738   slow_call-&gt;init_req(TypeFunc::ReturnAdr, call-&gt;in(TypeFunc::ReturnAdr));</span>
<span class="line-added">2739   slow_call-&gt;init_req(TypeFunc::Parms, res);</span>
<span class="line-added">2740 </span>
<span class="line-added">2741   Node* slow_ctl = transform_later(new ProjNode(slow_call, TypeFunc::Control));</span>
<span class="line-added">2742   Node* slow_mem = transform_later(new ProjNode(slow_call, TypeFunc::Memory));</span>
<span class="line-added">2743   Node* slow_io = transform_later(new ProjNode(slow_call, TypeFunc::I_O));</span>
<span class="line-added">2744   Node* slow_res = transform_later(new ProjNode(slow_call, TypeFunc::Parms));</span>
<span class="line-added">2745   Node* slow_catc = transform_later(new CatchNode(slow_ctl, slow_io, 2));</span>
<span class="line-added">2746   Node* slow_norm = transform_later(new CatchProjNode(slow_catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci));</span>
<span class="line-added">2747   Node* slow_excp = transform_later(new CatchProjNode(slow_catc, CatchProjNode::catch_all_index,    CatchProjNode::no_handler_bci));</span>
<span class="line-added">2748 </span>
<span class="line-added">2749   Node* ex_r = new RegionNode(3);</span>
<span class="line-added">2750   Node* ex_mem_phi = new PhiNode(ex_r, Type::MEMORY, TypePtr::BOTTOM);</span>
<span class="line-added">2751   Node* ex_io_phi = new PhiNode(ex_r, Type::ABIO);</span>
<span class="line-added">2752   ex_r-&gt;init_req(1, slow_excp);</span>
<span class="line-added">2753   ex_mem_phi-&gt;init_req(1, slow_mem);</span>
<span class="line-added">2754   ex_io_phi-&gt;init_req(1, slow_io);</span>
<span class="line-added">2755   ex_r-&gt;init_req(2, ex_ctl);</span>
<span class="line-added">2756   ex_mem_phi-&gt;init_req(2, ex_mem);</span>
<span class="line-added">2757   ex_io_phi-&gt;init_req(2, ex_io);</span>
<span class="line-added">2758 </span>
<span class="line-added">2759   transform_later(ex_r);</span>
<span class="line-added">2760   transform_later(ex_mem_phi);</span>
<span class="line-added">2761   transform_later(ex_io_phi);</span>
<span class="line-added">2762 </span>
<span class="line-added">2763   Node* slowpath_false = new IfFalseNode(slowpath_iff);</span>
<span class="line-added">2764   transform_later(slowpath_false);</span>
<span class="line-added">2765   Node* rawmem = new StorePNode(slowpath_false, mem, top_adr, TypeRawPtr::BOTTOM, new_top, MemNode::unordered);</span>
<span class="line-added">2766   transform_later(rawmem);</span>
<span class="line-added">2767   Node* mark_node = makecon(TypeRawPtr::make((address)markWord::always_locked_prototype().value()));</span>
<span class="line-added">2768   rawmem = make_store(slowpath_false, rawmem, old_top, oopDesc::mark_offset_in_bytes(), mark_node, T_ADDRESS);</span>
<span class="line-added">2769   rawmem = make_store(slowpath_false, rawmem, old_top, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);</span>
<span class="line-added">2770   if (UseCompressedClassPointers) {</span>
<span class="line-added">2771     rawmem = make_store(slowpath_false, rawmem, old_top, oopDesc::klass_gap_offset_in_bytes(), intcon(0), T_INT);</span>
<span class="line-added">2772   }</span>
<span class="line-added">2773   Node* fixed_block  = make_load(slowpath_false, rawmem, klass_node, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);</span>
<span class="line-added">2774   Node* pack_handler = make_load(slowpath_false, rawmem, fixed_block, in_bytes(InlineKlass::pack_handler_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);</span>
<span class="line-added">2775 </span>
<span class="line-added">2776   CallLeafNoFPNode* handler_call = new CallLeafNoFPNode(OptoRuntime::pack_inline_type_Type(),</span>
<span class="line-added">2777                                                         NULL,</span>
<span class="line-added">2778                                                         &quot;pack handler&quot;,</span>
<span class="line-added">2779                                                         TypeRawPtr::BOTTOM);</span>
<span class="line-added">2780   handler_call-&gt;init_req(TypeFunc::Control, slowpath_false);</span>
<span class="line-added">2781   handler_call-&gt;init_req(TypeFunc::Memory, rawmem);</span>
<span class="line-added">2782   handler_call-&gt;init_req(TypeFunc::I_O, top());</span>
<span class="line-added">2783   handler_call-&gt;init_req(TypeFunc::FramePtr, call-&gt;in(TypeFunc::FramePtr));</span>
<span class="line-added">2784   handler_call-&gt;init_req(TypeFunc::ReturnAdr, top());</span>
<span class="line-added">2785   handler_call-&gt;init_req(TypeFunc::Parms, pack_handler);</span>
<span class="line-added">2786   handler_call-&gt;init_req(TypeFunc::Parms+1, old_top);</span>
<span class="line-added">2787 </span>
<span class="line-added">2788   // We don&#39;t know how many values are returned. This assumes the</span>
<span class="line-added">2789   // worst case, that all available registers are used.</span>
<span class="line-added">2790   for (uint i = TypeFunc::Parms+1; i &lt; domain-&gt;cnt(); i++) {</span>
<span class="line-added">2791     if (domain-&gt;field_at(i) == Type::HALF) {</span>
<span class="line-added">2792       slow_call-&gt;init_req(i, top());</span>
<span class="line-added">2793       handler_call-&gt;init_req(i+1, top());</span>
<span class="line-added">2794       continue;</span>
<span class="line-added">2795     }</span>
<span class="line-added">2796     Node* proj = transform_later(new ProjNode(call, i));</span>
<span class="line-added">2797     slow_call-&gt;init_req(i, proj);</span>
<span class="line-added">2798     handler_call-&gt;init_req(i+1, proj);</span>
<span class="line-added">2799   }</span>
<span class="line-added">2800 </span>
<span class="line-added">2801   // We can safepoint at that new call</span>
<span class="line-added">2802   slow_call-&gt;copy_call_debug_info(&amp;_igvn, call);</span>
<span class="line-added">2803   transform_later(slow_call);</span>
<span class="line-added">2804   transform_later(handler_call);</span>
<span class="line-added">2805 </span>
<span class="line-added">2806   Node* handler_ctl = transform_later(new ProjNode(handler_call, TypeFunc::Control));</span>
<span class="line-added">2807   rawmem = transform_later(new ProjNode(handler_call, TypeFunc::Memory));</span>
<span class="line-added">2808   Node* slowpath_false_res = transform_later(new ProjNode(handler_call, TypeFunc::Parms));</span>
<span class="line-added">2809 </span>
<span class="line-added">2810   MergeMemNode* slowpath_false_mem = MergeMemNode::make(mem);</span>
<span class="line-added">2811   slowpath_false_mem-&gt;set_memory_at(Compile::AliasIdxRaw, rawmem);</span>
<span class="line-added">2812   transform_later(slowpath_false_mem);</span>
<span class="line-added">2813 </span>
<span class="line-added">2814   Node* r = new RegionNode(4);</span>
<span class="line-added">2815   Node* mem_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);</span>
<span class="line-added">2816   Node* io_phi = new PhiNode(r, Type::ABIO);</span>
<span class="line-added">2817   Node* res_phi = new PhiNode(r, TypeInstPtr::BOTTOM);</span>
<span class="line-added">2818 </span>
<span class="line-added">2819   r-&gt;init_req(1, no_allocation_ctl);</span>
<span class="line-added">2820   mem_phi-&gt;init_req(1, mem);</span>
<span class="line-added">2821   io_phi-&gt;init_req(1, io);</span>
<span class="line-added">2822   res_phi-&gt;init_req(1, no_allocation_res);</span>
<span class="line-added">2823   r-&gt;init_req(2, slow_norm);</span>
<span class="line-added">2824   mem_phi-&gt;init_req(2, slow_mem);</span>
<span class="line-added">2825   io_phi-&gt;init_req(2, slow_io);</span>
<span class="line-added">2826   res_phi-&gt;init_req(2, slow_res);</span>
<span class="line-added">2827   r-&gt;init_req(3, handler_ctl);</span>
<span class="line-added">2828   mem_phi-&gt;init_req(3, slowpath_false_mem);</span>
<span class="line-added">2829   io_phi-&gt;init_req(3, io);</span>
<span class="line-added">2830   res_phi-&gt;init_req(3, slowpath_false_res);</span>
<span class="line-added">2831 </span>
<span class="line-added">2832   transform_later(r);</span>
<span class="line-added">2833   transform_later(mem_phi);</span>
<span class="line-added">2834   transform_later(io_phi);</span>
<span class="line-added">2835   transform_later(res_phi);</span>
<span class="line-added">2836 </span>
<span class="line-added">2837   assert(projs-&gt;nb_resproj == 1, &quot;unexpected number of results&quot;);</span>
<span class="line-added">2838   _igvn.replace_in_uses(projs-&gt;fallthrough_catchproj, r);</span>
<span class="line-added">2839   _igvn.replace_in_uses(projs-&gt;fallthrough_memproj, mem_phi);</span>
<span class="line-added">2840   _igvn.replace_in_uses(projs-&gt;fallthrough_ioproj, io_phi);</span>
<span class="line-added">2841   _igvn.replace_in_uses(projs-&gt;resproj[0], res_phi);</span>
<span class="line-added">2842   _igvn.replace_in_uses(projs-&gt;catchall_catchproj, ex_r);</span>
<span class="line-added">2843   _igvn.replace_in_uses(projs-&gt;catchall_memproj, ex_mem_phi);</span>
<span class="line-added">2844   _igvn.replace_in_uses(projs-&gt;catchall_ioproj, ex_io_phi);</span>
<span class="line-added">2845 </span>
<span class="line-added">2846   _igvn.replace_node(ctl, projs-&gt;fallthrough_catchproj);</span>
<span class="line-added">2847   _igvn.replace_node(mem, projs-&gt;fallthrough_memproj);</span>
<span class="line-added">2848   _igvn.replace_node(io, projs-&gt;fallthrough_ioproj);</span>
<span class="line-added">2849   _igvn.replace_node(res, projs-&gt;resproj[0]);</span>
<span class="line-added">2850   _igvn.replace_node(ex_ctl, projs-&gt;catchall_catchproj);</span>
<span class="line-added">2851   _igvn.replace_node(ex_mem, projs-&gt;catchall_memproj);</span>
<span class="line-added">2852   _igvn.replace_node(ex_io, projs-&gt;catchall_ioproj);</span>
<span class="line-added">2853  }</span>
<span class="line-added">2854 </span>
2855 void PhaseMacroExpand::expand_subtypecheck_node(SubTypeCheckNode *check) {
2856   assert(check-&gt;in(SubTypeCheckNode::Control) == NULL, &quot;should be pinned&quot;);
2857   Node* bol = check-&gt;unique_out();
2858   Node* obj_or_subklass = check-&gt;in(SubTypeCheckNode::ObjOrSubKlass);
2859   Node* superklass = check-&gt;in(SubTypeCheckNode::SuperKlass);
2860   assert(bol-&gt;is_Bool() &amp;&amp; bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne, &quot;unexpected bool node&quot;);
2861 
2862   for (DUIterator_Last imin, i = bol-&gt;last_outs(imin); i &gt;= imin; --i) {
2863     Node* iff = bol-&gt;last_out(i);
2864     assert(iff-&gt;is_If(), &quot;where&#39;s the if?&quot;);
2865 
2866     if (iff-&gt;in(0)-&gt;is_top()) {
2867       _igvn.replace_input_of(iff, 1, C-&gt;top());
2868       continue;
2869     }
2870 
2871     Node* iftrue = iff-&gt;as_If()-&gt;proj_out(1);
2872     Node* iffalse = iff-&gt;as_If()-&gt;proj_out(0);
2873     Node* ctrl = iff-&gt;in(0);
2874 
2875     Node* subklass = NULL;
2876     if (_igvn.type(obj_or_subklass)-&gt;isa_klassptr()) {
2877       subklass = obj_or_subklass;
2878     } else {
2879       Node* k_adr = basic_plus_adr(obj_or_subklass, oopDesc::klass_offset_in_bytes());
<span class="line-modified">2880       subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));</span>
2881     }
2882 
2883     Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, NULL, _igvn);
2884 
2885     _igvn.replace_input_of(iff, 0, C-&gt;top());
2886     _igvn.replace_node(iftrue, not_subtype_ctrl);
2887     _igvn.replace_node(iffalse, ctrl);
2888   }
2889   _igvn.replace_node(check, C-&gt;top());
2890 }
2891 
2892 //---------------------------eliminate_macro_nodes----------------------
2893 // Eliminate scalar replaced allocations and associated locks.
2894 void PhaseMacroExpand::eliminate_macro_nodes() {
2895   if (C-&gt;macro_count() == 0)
2896     return;
2897 
2898   // First, attempt to eliminate locks
2899   int cnt = C-&gt;macro_count();
2900   for (int i=0; i &lt; cnt; i++) {
</pre>
<hr />
<pre>
2916         success = eliminate_locking_node(n-&gt;as_AbstractLock());
2917       }
2918       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2919       progress = progress || success;
2920     }
2921   }
2922   // Next, attempt to eliminate allocations
2923   _has_locks = false;
2924   progress = true;
2925   while (progress) {
2926     progress = false;
2927     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2928       Node * n = C-&gt;macro_node(i-1);
2929       bool success = false;
2930       debug_only(int old_macro_count = C-&gt;macro_count(););
2931       switch (n-&gt;class_id()) {
2932       case Node::Class_Allocate:
2933       case Node::Class_AllocateArray:
2934         success = eliminate_allocate_node(n-&gt;as_Allocate());
2935         break;
<span class="line-modified">2936       case Node::Class_CallStaticJava: {</span>
<span class="line-modified">2937         CallStaticJavaNode* call = n-&gt;as_CallStaticJava();</span>
<span class="line-added">2938         if (!call-&gt;method()-&gt;is_method_handle_intrinsic()) {</span>
<span class="line-added">2939           success = eliminate_boxing_node(n-&gt;as_CallStaticJava());</span>
<span class="line-added">2940         }</span>
2941         break;
<span class="line-added">2942       }</span>
2943       case Node::Class_Lock:
2944       case Node::Class_Unlock:
2945         assert(!n-&gt;as_AbstractLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2946         _has_locks = true;
2947         break;
2948       case Node::Class_ArrayCopy:
2949         break;
2950       case Node::Class_OuterStripMinedLoop:
2951         break;
2952       case Node::Class_SubTypeCheck:
2953         break;
2954       default:
2955         assert(n-&gt;Opcode() == Op_LoopLimit ||
2956                n-&gt;Opcode() == Op_Opaque1   ||
2957                n-&gt;Opcode() == Op_Opaque2   ||
2958                n-&gt;Opcode() == Op_Opaque3   ||
2959                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2960                &quot;unknown node type in macro list&quot;);
2961       }
2962       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
</pre>
<hr />
<pre>
2968 //------------------------------expand_macro_nodes----------------------
2969 //  Returns true if a failure occurred.
2970 bool PhaseMacroExpand::expand_macro_nodes() {
2971   // Last attempt to eliminate macro nodes.
2972   eliminate_macro_nodes();
2973 
2974   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.
2975   bool progress = true;
2976   while (progress) {
2977     progress = false;
2978     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2979       Node* n = C-&gt;macro_node(i-1);
2980       bool success = false;
2981       debug_only(int old_macro_count = C-&gt;macro_count(););
2982       if (n-&gt;Opcode() == Op_LoopLimit) {
2983         // Remove it from macro list and put on IGVN worklist to optimize.
2984         C-&gt;remove_macro_node(n);
2985         _igvn._worklist.push(n);
2986         success = true;
2987       } else if (n-&gt;Opcode() == Op_CallStaticJava) {
<span class="line-modified">2988         CallStaticJavaNode* call = n-&gt;as_CallStaticJava();</span>
<span class="line-modified">2989         if (!call-&gt;method()-&gt;is_method_handle_intrinsic()) {</span>
<span class="line-modified">2990           // Remove it from macro list and put on IGVN worklist to optimize.</span>
<span class="line-modified">2991           C-&gt;remove_macro_node(n);</span>
<span class="line-added">2992           _igvn._worklist.push(n);</span>
<span class="line-added">2993           success = true;</span>
<span class="line-added">2994         }</span>
2995       } else if (n-&gt;Opcode() == Op_Opaque1 || n-&gt;Opcode() == Op_Opaque2) {
2996         _igvn.replace_node(n, n-&gt;in(1));
2997         success = true;
2998 #if INCLUDE_RTM_OPT
2999       } else if ((n-&gt;Opcode() == Op_Opaque3) &amp;&amp; ((Opaque3Node*)n)-&gt;rtm_opt()) {
3000         assert(C-&gt;profile_rtm(), &quot;should be used only in rtm deoptimization code&quot;);
3001         assert((n-&gt;outcnt() == 1) &amp;&amp; n-&gt;unique_out()-&gt;is_Cmp(), &quot;&quot;);
3002         Node* cmp = n-&gt;unique_out();
3003 #ifdef ASSERT
3004         // Validate graph.
3005         assert((cmp-&gt;outcnt() == 1) &amp;&amp; cmp-&gt;unique_out()-&gt;is_Bool(), &quot;&quot;);
3006         BoolNode* bol = cmp-&gt;unique_out()-&gt;as_Bool();
3007         assert((bol-&gt;outcnt() == 1) &amp;&amp; bol-&gt;unique_out()-&gt;is_If() &amp;&amp;
3008                (bol-&gt;_test._test == BoolTest::ne), &quot;&quot;);
3009         IfNode* ifn = bol-&gt;unique_out()-&gt;as_If();
3010         assert((ifn-&gt;outcnt() == 2) &amp;&amp;
3011                ifn-&gt;proj_out(1)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, &quot;&quot;);
3012 #endif
3013         Node* repl = n-&gt;in(1);
3014         if (!_has_locks) {
</pre>
<hr />
<pre>
3068     }
3069 
3070     debug_only(int old_macro_count = C-&gt;macro_count(););
3071     switch (n-&gt;class_id()) {
3072     case Node::Class_Lock:
3073       expand_lock_node(n-&gt;as_Lock());
3074       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3075       break;
3076     case Node::Class_Unlock:
3077       expand_unlock_node(n-&gt;as_Unlock());
3078       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3079       break;
3080     case Node::Class_ArrayCopy:
3081       expand_arraycopy_node(n-&gt;as_ArrayCopy());
3082       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3083       break;
3084     case Node::Class_SubTypeCheck:
3085       expand_subtypecheck_node(n-&gt;as_SubTypeCheck());
3086       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3087       break;
<span class="line-added">3088     case Node::Class_CallStaticJava:</span>
<span class="line-added">3089       expand_mh_intrinsic_return(n-&gt;as_CallStaticJava());</span>
<span class="line-added">3090       C-&gt;remove_macro_node(n);</span>
<span class="line-added">3091       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);</span>
<span class="line-added">3092       break;</span>
3093     default:
3094       assert(false, &quot;unknown node type in macro list&quot;);
3095     }
3096     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
3097     if (C-&gt;failing())  return true;
3098 
3099     // Clean up the graph so we&#39;re less likely to hit the maximum node
3100     // limit
3101     _igvn.set_delay_transform(false);
3102     _igvn.optimize();
3103     if (C-&gt;failing())  return true;
3104     _igvn.set_delay_transform(true);
3105   }
3106 
3107   // All nodes except Allocate nodes are expanded now. There could be
3108   // new optimization opportunities (such as folding newly created
3109   // load from a just allocated object). Run IGVN.
3110 
3111   // expand &quot;macro&quot; nodes
3112   // nodes are removed from the macro list as they are processed
</pre>
</td>
</tr>
</table>
<center><a href="loopopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>