<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/node.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;opto/ad.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/connode.hpp&quot;
  35 #include &quot;opto/loopnode.hpp&quot;
  36 #include &quot;opto/machnode.hpp&quot;
  37 #include &quot;opto/matcher.hpp&quot;
  38 #include &quot;opto/node.hpp&quot;
  39 #include &quot;opto/opcodes.hpp&quot;
  40 #include &quot;opto/regmask.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/type.hpp&quot;
  43 #include &quot;utilities/copy.hpp&quot;
  44 #include &quot;utilities/macros.hpp&quot;
  45 #include &quot;utilities/powerOfTwo.hpp&quot;
  46 
  47 class RegMask;
  48 // #include &quot;phase.hpp&quot;
  49 class PhaseTransform;
  50 class PhaseGVN;
  51 
  52 // Arena we are currently building Nodes in
  53 const uint Node::NotAMachineReg = 0xffff0000;
  54 
  55 #ifndef PRODUCT
  56 extern int nodes_created;
  57 #endif
  58 #ifdef __clang__
  59 #pragma clang diagnostic push
  60 #pragma GCC diagnostic ignored &quot;-Wuninitialized&quot;
  61 #endif
  62 
  63 #ifdef ASSERT
  64 
  65 //-------------------------- construct_node------------------------------------
  66 // Set a breakpoint here to identify where a particular node index is built.
  67 void Node::verify_construction() {
  68   _debug_orig = NULL;
  69   int old_debug_idx = Compile::debug_idx();
  70   int new_debug_idx = old_debug_idx + 1;
  71   if (new_debug_idx &gt; 0) {
  72     // Arrange that the lowest five decimal digits of _debug_idx
  73     // will repeat those of _idx. In case this is somehow pathological,
  74     // we continue to assign negative numbers (!) consecutively.
  75     const int mod = 100000;
  76     int bump = (int)(_idx - new_debug_idx) % mod;
  77     if (bump &lt; 0) {
  78       bump += mod;
  79     }
  80     assert(bump &gt;= 0 &amp;&amp; bump &lt; mod, &quot;&quot;);
  81     new_debug_idx += bump;
  82   }
  83   Compile::set_debug_idx(new_debug_idx);
  84   set_debug_idx(new_debug_idx);
  85   Compile* C = Compile::current();
  86   assert(C-&gt;unique() &lt; (INT_MAX - 1), &quot;Node limit exceeded INT_MAX&quot;);
  87   if (!C-&gt;phase_optimize_finished()) {
  88     // Only check assert during parsing and optimization phase. Skip it while generating code.
  89     assert(C-&gt;live_nodes() &lt;= C-&gt;max_node_limit(), &quot;Live Node limit exceeded limit&quot;);
  90   }
  91   if (BreakAtNode != 0 &amp;&amp; (_debug_idx == BreakAtNode || (int)_idx == BreakAtNode)) {
  92     tty-&gt;print_cr(&quot;BreakAtNode: _idx=%d _debug_idx=%d&quot;, _idx, _debug_idx);
  93     BREAKPOINT;
  94   }
  95 #if OPTO_DU_ITERATOR_ASSERT
  96   _last_del = NULL;
  97   _del_tick = 0;
  98 #endif
  99   _hash_lock = 0;
 100 }
 101 
 102 
 103 // #ifdef ASSERT ...
 104 
 105 #if OPTO_DU_ITERATOR_ASSERT
 106 void DUIterator_Common::sample(const Node* node) {
 107   _vdui     = VerifyDUIterators;
 108   _node     = node;
 109   _outcnt   = node-&gt;_outcnt;
 110   _del_tick = node-&gt;_del_tick;
 111   _last     = NULL;
 112 }
 113 
 114 void DUIterator_Common::verify(const Node* node, bool at_end_ok) {
 115   assert(_node     == node, &quot;consistent iterator source&quot;);
 116   assert(_del_tick == node-&gt;_del_tick, &quot;no unexpected deletions allowed&quot;);
 117 }
 118 
 119 void DUIterator_Common::verify_resync() {
 120   // Ensure that the loop body has just deleted the last guy produced.
 121   const Node* node = _node;
 122   // Ensure that at least one copy of the last-seen edge was deleted.
 123   // Note:  It is OK to delete multiple copies of the last-seen edge.
 124   // Unfortunately, we have no way to verify that all the deletions delete
 125   // that same edge.  On this point we must use the Honor System.
 126   assert(node-&gt;_del_tick &gt;= _del_tick+1, &quot;must have deleted an edge&quot;);
 127   assert(node-&gt;_last_del == _last, &quot;must have deleted the edge just produced&quot;);
 128   // We liked this deletion, so accept the resulting outcnt and tick.
 129   _outcnt   = node-&gt;_outcnt;
 130   _del_tick = node-&gt;_del_tick;
 131 }
 132 
 133 void DUIterator_Common::reset(const DUIterator_Common&amp; that) {
 134   if (this == &amp;that)  return;  // ignore assignment to self
 135   if (!_vdui) {
 136     // We need to initialize everything, overwriting garbage values.
 137     _last = that._last;
 138     _vdui = that._vdui;
 139   }
 140   // Note:  It is legal (though odd) for an iterator over some node x
 141   // to be reassigned to iterate over another node y.  Some doubly-nested
 142   // progress loops depend on being able to do this.
 143   const Node* node = that._node;
 144   // Re-initialize everything, except _last.
 145   _node     = node;
 146   _outcnt   = node-&gt;_outcnt;
 147   _del_tick = node-&gt;_del_tick;
 148 }
 149 
 150 void DUIterator::sample(const Node* node) {
 151   DUIterator_Common::sample(node);      // Initialize the assertion data.
 152   _refresh_tick = 0;                    // No refreshes have happened, as yet.
 153 }
 154 
 155 void DUIterator::verify(const Node* node, bool at_end_ok) {
 156   DUIterator_Common::verify(node, at_end_ok);
 157   assert(_idx      &lt;  node-&gt;_outcnt + (uint)at_end_ok, &quot;idx in range&quot;);
 158 }
 159 
 160 void DUIterator::verify_increment() {
 161   if (_refresh_tick &amp; 1) {
 162     // We have refreshed the index during this loop.
 163     // Fix up _idx to meet asserts.
 164     if (_idx &gt; _outcnt)  _idx = _outcnt;
 165   }
 166   verify(_node, true);
 167 }
 168 
 169 void DUIterator::verify_resync() {
 170   // Note:  We do not assert on _outcnt, because insertions are OK here.
 171   DUIterator_Common::verify_resync();
 172   // Make sure we are still in sync, possibly with no more out-edges:
 173   verify(_node, true);
 174 }
 175 
 176 void DUIterator::reset(const DUIterator&amp; that) {
 177   if (this == &amp;that)  return;  // self assignment is always a no-op
 178   assert(that._refresh_tick == 0, &quot;assign only the result of Node::outs()&quot;);
 179   assert(that._idx          == 0, &quot;assign only the result of Node::outs()&quot;);
 180   assert(_idx               == that._idx, &quot;already assigned _idx&quot;);
 181   if (!_vdui) {
 182     // We need to initialize everything, overwriting garbage values.
 183     sample(that._node);
 184   } else {
 185     DUIterator_Common::reset(that);
 186     if (_refresh_tick &amp; 1) {
 187       _refresh_tick++;                  // Clear the &quot;was refreshed&quot; flag.
 188     }
 189     assert(_refresh_tick &lt; 2*100000, &quot;DU iteration must converge quickly&quot;);
 190   }
 191 }
 192 
 193 void DUIterator::refresh() {
 194   DUIterator_Common::sample(_node);     // Re-fetch assertion data.
 195   _refresh_tick |= 1;                   // Set the &quot;was refreshed&quot; flag.
 196 }
 197 
 198 void DUIterator::verify_finish() {
 199   // If the loop has killed the node, do not require it to re-run.
 200   if (_node-&gt;_outcnt == 0)  _refresh_tick &amp;= ~1;
 201   // If this assert triggers, it means that a loop used refresh_out_pos
 202   // to re-synch an iteration index, but the loop did not correctly
 203   // re-run itself, using a &quot;while (progress)&quot; construct.
 204   // This iterator enforces the rule that you must keep trying the loop
 205   // until it &quot;runs clean&quot; without any need for refreshing.
 206   assert(!(_refresh_tick &amp; 1), &quot;the loop must run once with no refreshing&quot;);
 207 }
 208 
 209 
 210 void DUIterator_Fast::verify(const Node* node, bool at_end_ok) {
 211   DUIterator_Common::verify(node, at_end_ok);
 212   Node** out    = node-&gt;_out;
 213   uint   cnt    = node-&gt;_outcnt;
 214   assert(cnt == _outcnt, &quot;no insertions allowed&quot;);
 215   assert(_outp &gt;= out &amp;&amp; _outp &lt;= out + cnt - !at_end_ok, &quot;outp in range&quot;);
 216   // This last check is carefully designed to work for NO_OUT_ARRAY.
 217 }
 218 
 219 void DUIterator_Fast::verify_limit() {
 220   const Node* node = _node;
 221   verify(node, true);
 222   assert(_outp == node-&gt;_out + node-&gt;_outcnt, &quot;limit still correct&quot;);
 223 }
 224 
 225 void DUIterator_Fast::verify_resync() {
 226   const Node* node = _node;
 227   if (_outp == node-&gt;_out + _outcnt) {
 228     // Note that the limit imax, not the pointer i, gets updated with the
 229     // exact count of deletions.  (For the pointer it&#39;s always &quot;--i&quot;.)
 230     assert(node-&gt;_outcnt+node-&gt;_del_tick == _outcnt+_del_tick, &quot;no insertions allowed with deletion(s)&quot;);
 231     // This is a limit pointer, with a name like &quot;imax&quot;.
 232     // Fudge the _last field so that the common assert will be happy.
 233     _last = (Node*) node-&gt;_last_del;
 234     DUIterator_Common::verify_resync();
 235   } else {
 236     assert(node-&gt;_outcnt &lt; _outcnt, &quot;no insertions allowed with deletion(s)&quot;);
 237     // A normal internal pointer.
 238     DUIterator_Common::verify_resync();
 239     // Make sure we are still in sync, possibly with no more out-edges:
 240     verify(node, true);
 241   }
 242 }
 243 
 244 void DUIterator_Fast::verify_relimit(uint n) {
 245   const Node* node = _node;
 246   assert((int)n &gt; 0, &quot;use imax -= n only with a positive count&quot;);
 247   // This must be a limit pointer, with a name like &quot;imax&quot;.
 248   assert(_outp == node-&gt;_out + node-&gt;_outcnt, &quot;apply -= only to a limit (imax)&quot;);
 249   // The reported number of deletions must match what the node saw.
 250   assert(node-&gt;_del_tick == _del_tick + n, &quot;must have deleted n edges&quot;);
 251   // Fudge the _last field so that the common assert will be happy.
 252   _last = (Node*) node-&gt;_last_del;
 253   DUIterator_Common::verify_resync();
 254 }
 255 
 256 void DUIterator_Fast::reset(const DUIterator_Fast&amp; that) {
 257   assert(_outp              == that._outp, &quot;already assigned _outp&quot;);
 258   DUIterator_Common::reset(that);
 259 }
 260 
 261 void DUIterator_Last::verify(const Node* node, bool at_end_ok) {
 262   // at_end_ok means the _outp is allowed to underflow by 1
 263   _outp += at_end_ok;
 264   DUIterator_Fast::verify(node, at_end_ok);  // check _del_tick, etc.
 265   _outp -= at_end_ok;
 266   assert(_outp == (node-&gt;_out + node-&gt;_outcnt) - 1, &quot;pointer must point to end of nodes&quot;);
 267 }
 268 
 269 void DUIterator_Last::verify_limit() {
 270   // Do not require the limit address to be resynched.
 271   //verify(node, true);
 272   assert(_outp == _node-&gt;_out, &quot;limit still correct&quot;);
 273 }
 274 
 275 void DUIterator_Last::verify_step(uint num_edges) {
 276   assert((int)num_edges &gt; 0, &quot;need non-zero edge count for loop progress&quot;);
 277   _outcnt   -= num_edges;
 278   _del_tick += num_edges;
 279   // Make sure we are still in sync, possibly with no more out-edges:
 280   const Node* node = _node;
 281   verify(node, true);
 282   assert(node-&gt;_last_del == _last, &quot;must have deleted the edge just produced&quot;);
 283 }
 284 
 285 #endif //OPTO_DU_ITERATOR_ASSERT
 286 
 287 
 288 #endif //ASSERT
 289 
 290 
 291 // This constant used to initialize _out may be any non-null value.
 292 // The value NULL is reserved for the top node only.
 293 #define NO_OUT_ARRAY ((Node**)-1)
 294 
 295 // Out-of-line code from node constructors.
 296 // Executed only when extra debug info. is being passed around.
 297 static void init_node_notes(Compile* C, int idx, Node_Notes* nn) {
 298   C-&gt;set_node_notes_at(idx, nn);
 299 }
 300 
 301 // Shared initialization code.
 302 inline int Node::Init(int req) {
 303   Compile* C = Compile::current();
 304   int idx = C-&gt;next_unique();
 305 
 306   // Allocate memory for the necessary number of edges.
 307   if (req &gt; 0) {
 308     // Allocate space for _in array to have double alignment.
 309     _in = (Node **) ((char *) (C-&gt;node_arena()-&gt;Amalloc_D(req * sizeof(void*))));
 310   }
 311   // If there are default notes floating around, capture them:
 312   Node_Notes* nn = C-&gt;default_node_notes();
 313   if (nn != NULL)  init_node_notes(C, idx, nn);
 314 
 315   // Note:  At this point, C is dead,
 316   // and we begin to initialize the new Node.
 317 
 318   _cnt = _max = req;
 319   _outcnt = _outmax = 0;
 320   _class_id = Class_Node;
 321   _flags = 0;
 322   _out = NO_OUT_ARRAY;
 323   return idx;
 324 }
 325 
 326 //------------------------------Node-------------------------------------------
 327 // Create a Node, with a given number of required edges.
 328 Node::Node(uint req)
 329   : _idx(Init(req))
 330 #ifdef ASSERT
 331   , _parse_idx(_idx)
 332 #endif
 333 {
 334   assert( req &lt; Compile::current()-&gt;max_node_limit() - NodeLimitFudgeFactor, &quot;Input limit exceeded&quot; );
 335   debug_only( verify_construction() );
 336   NOT_PRODUCT(nodes_created++);
 337   if (req == 0) {
 338     _in = NULL;
 339   } else {
 340     Node** to = _in;
 341     for(uint i = 0; i &lt; req; i++) {
 342       to[i] = NULL;
 343     }
 344   }
 345 }
 346 
 347 //------------------------------Node-------------------------------------------
 348 Node::Node(Node *n0)
 349   : _idx(Init(1))
 350 #ifdef ASSERT
 351   , _parse_idx(_idx)
 352 #endif
 353 {
 354   debug_only( verify_construction() );
 355   NOT_PRODUCT(nodes_created++);
 356   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 357   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 358 }
 359 
 360 //------------------------------Node-------------------------------------------
 361 Node::Node(Node *n0, Node *n1)
 362   : _idx(Init(2))
 363 #ifdef ASSERT
 364   , _parse_idx(_idx)
 365 #endif
 366 {
 367   debug_only( verify_construction() );
 368   NOT_PRODUCT(nodes_created++);
 369   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 370   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 371   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 372   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 373 }
 374 
 375 //------------------------------Node-------------------------------------------
 376 Node::Node(Node *n0, Node *n1, Node *n2)
 377   : _idx(Init(3))
 378 #ifdef ASSERT
 379   , _parse_idx(_idx)
 380 #endif
 381 {
 382   debug_only( verify_construction() );
 383   NOT_PRODUCT(nodes_created++);
 384   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 385   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 386   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 387   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 388   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 389   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 390 }
 391 
 392 //------------------------------Node-------------------------------------------
 393 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3)
 394   : _idx(Init(4))
 395 #ifdef ASSERT
 396   , _parse_idx(_idx)
 397 #endif
 398 {
 399   debug_only( verify_construction() );
 400   NOT_PRODUCT(nodes_created++);
 401   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 402   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 403   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 404   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 405   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 406   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 407   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 408   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 409 }
 410 
 411 //------------------------------Node-------------------------------------------
 412 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3, Node *n4)
 413   : _idx(Init(5))
 414 #ifdef ASSERT
 415   , _parse_idx(_idx)
 416 #endif
 417 {
 418   debug_only( verify_construction() );
 419   NOT_PRODUCT(nodes_created++);
 420   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 421   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 422   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 423   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 424   assert( is_not_dead(n4), &quot;can not use dead node&quot;);
 425   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 426   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 427   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 428   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 429   _in[4] = n4; if (n4 != NULL) n4-&gt;add_out((Node *)this);
 430 }
 431 
 432 //------------------------------Node-------------------------------------------
 433 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3,
 434                      Node *n4, Node *n5)
 435   : _idx(Init(6))
 436 #ifdef ASSERT
 437   , _parse_idx(_idx)
 438 #endif
 439 {
 440   debug_only( verify_construction() );
 441   NOT_PRODUCT(nodes_created++);
 442   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 443   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 444   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 445   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 446   assert( is_not_dead(n4), &quot;can not use dead node&quot;);
 447   assert( is_not_dead(n5), &quot;can not use dead node&quot;);
 448   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 449   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 450   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 451   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 452   _in[4] = n4; if (n4 != NULL) n4-&gt;add_out((Node *)this);
 453   _in[5] = n5; if (n5 != NULL) n5-&gt;add_out((Node *)this);
 454 }
 455 
 456 //------------------------------Node-------------------------------------------
 457 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3,
 458                      Node *n4, Node *n5, Node *n6)
 459   : _idx(Init(7))
 460 #ifdef ASSERT
 461   , _parse_idx(_idx)
 462 #endif
 463 {
 464   debug_only( verify_construction() );
 465   NOT_PRODUCT(nodes_created++);
 466   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 467   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 468   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 469   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 470   assert( is_not_dead(n4), &quot;can not use dead node&quot;);
 471   assert( is_not_dead(n5), &quot;can not use dead node&quot;);
 472   assert( is_not_dead(n6), &quot;can not use dead node&quot;);
 473   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 474   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 475   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 476   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 477   _in[4] = n4; if (n4 != NULL) n4-&gt;add_out((Node *)this);
 478   _in[5] = n5; if (n5 != NULL) n5-&gt;add_out((Node *)this);
 479   _in[6] = n6; if (n6 != NULL) n6-&gt;add_out((Node *)this);
 480 }
 481 
 482 #ifdef __clang__
 483 #pragma clang diagnostic pop
 484 #endif
 485 
 486 
 487 //------------------------------clone------------------------------------------
 488 // Clone a Node.
 489 Node *Node::clone() const {
 490   Compile* C = Compile::current();
 491   uint s = size_of();           // Size of inherited Node
 492   Node *n = (Node*)C-&gt;node_arena()-&gt;Amalloc_D(size_of() + _max*sizeof(Node*));
 493   Copy::conjoint_words_to_lower((HeapWord*)this, (HeapWord*)n, s);
 494   // Set the new input pointer array
 495   n-&gt;_in = (Node**)(((char*)n)+s);
 496   // Cannot share the old output pointer array, so kill it
 497   n-&gt;_out = NO_OUT_ARRAY;
 498   // And reset the counters to 0
 499   n-&gt;_outcnt = 0;
 500   n-&gt;_outmax = 0;
 501   // Unlock this guy, since he is not in any hash table.
 502   debug_only(n-&gt;_hash_lock = 0);
 503   // Walk the old node&#39;s input list to duplicate its edges
 504   uint i;
 505   for( i = 0; i &lt; len(); i++ ) {
 506     Node *x = in(i);
 507     n-&gt;_in[i] = x;
 508     if (x != NULL) x-&gt;add_out(n);
 509   }
 510   if (is_macro())
 511     C-&gt;add_macro_node(n);
 512   if (is_expensive())
 513     C-&gt;add_expensive_node(n);
 514   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 515   bs-&gt;register_potential_barrier_node(n);
 516   // If the cloned node is a range check dependent CastII, add it to the list.
 517   CastIINode* cast = n-&gt;isa_CastII();
 518   if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
 519     C-&gt;add_range_check_cast(cast);
 520   }
 521   if (n-&gt;Opcode() == Op_Opaque4) {
 522     C-&gt;add_opaque4_node(n);
 523   }
 524 
 525   n-&gt;set_idx(C-&gt;next_unique()); // Get new unique index as well
 526   debug_only( n-&gt;verify_construction() );
 527   NOT_PRODUCT(nodes_created++);
 528   // Do not patch over the debug_idx of a clone, because it makes it
 529   // impossible to break on the clone&#39;s moment of creation.
 530   //debug_only( n-&gt;set_debug_idx( debug_idx() ) );
 531 
 532   C-&gt;copy_node_notes_to(n, (Node*) this);
 533 
 534   // MachNode clone
 535   uint nopnds;
 536   if (this-&gt;is_Mach() &amp;&amp; (nopnds = this-&gt;as_Mach()-&gt;num_opnds()) &gt; 0) {
 537     MachNode *mach  = n-&gt;as_Mach();
 538     MachNode *mthis = this-&gt;as_Mach();
 539     // Get address of _opnd_array.
 540     // It should be the same offset since it is the clone of this node.
 541     MachOper **from = mthis-&gt;_opnds;
 542     MachOper **to = (MachOper **)((size_t)(&amp;mach-&gt;_opnds) +
 543                     pointer_delta((const void*)from,
 544                                   (const void*)(&amp;mthis-&gt;_opnds), 1));
 545     mach-&gt;_opnds = to;
 546     for ( uint i = 0; i &lt; nopnds; ++i ) {
 547       to[i] = from[i]-&gt;clone();
 548     }
 549   }
 550   // cloning CallNode may need to clone JVMState
 551   if (n-&gt;is_Call()) {
 552     n-&gt;as_Call()-&gt;clone_jvms(C);
 553   }
 554   if (n-&gt;is_SafePoint()) {
 555     n-&gt;as_SafePoint()-&gt;clone_replaced_nodes();
 556   }
<a name="1" id="anc1"></a><span class="line-added"> 557   if (n-&gt;is_InlineTypeBase()) {</span>
<span class="line-added"> 558     C-&gt;add_inline_type(n);</span>
<span class="line-added"> 559   }</span>
 560   return n;                     // Return the clone
 561 }
 562 
 563 //---------------------------setup_is_top--------------------------------------
 564 // Call this when changing the top node, to reassert the invariants
 565 // required by Node::is_top.  See Compile::set_cached_top_node.
 566 void Node::setup_is_top() {
 567   if (this == (Node*)Compile::current()-&gt;top()) {
 568     // This node has just become top.  Kill its out array.
 569     _outcnt = _outmax = 0;
 570     _out = NULL;                           // marker value for top
 571     assert(is_top(), &quot;must be top&quot;);
 572   } else {
 573     if (_out == NULL)  _out = NO_OUT_ARRAY;
 574     assert(!is_top(), &quot;must not be top&quot;);
 575   }
 576 }
 577 
 578 //------------------------------~Node------------------------------------------
 579 // Fancy destructor; eagerly attempt to reclaim Node numberings and storage
 580 void Node::destruct() {
 581   // Eagerly reclaim unique Node numberings
 582   Compile* compile = Compile::current();
 583   if ((uint)_idx+1 == compile-&gt;unique()) {
 584     compile-&gt;set_unique(compile-&gt;unique()-1);
 585   }
 586   // Clear debug info:
 587   Node_Notes* nn = compile-&gt;node_notes_at(_idx);
 588   if (nn != NULL)  nn-&gt;clear();
 589   // Walk the input array, freeing the corresponding output edges
 590   _cnt = _max;  // forget req/prec distinction
 591   uint i;
 592   for( i = 0; i &lt; _max; i++ ) {
 593     set_req(i, NULL);
 594     //assert(def-&gt;out(def-&gt;outcnt()-1) == (Node *)this,&quot;bad def-use hacking in reclaim&quot;);
 595   }
 596   assert(outcnt() == 0, &quot;deleting a node must not leave a dangling use&quot;);
 597   // See if the input array was allocated just prior to the object
 598   int edge_size = _max*sizeof(void*);
 599   int out_edge_size = _outmax*sizeof(void*);
 600   char *edge_end = ((char*)_in) + edge_size;
 601   char *out_array = (char*)(_out == NO_OUT_ARRAY? NULL: _out);
 602   int node_size = size_of();
 603 
 604   // Free the output edge array
 605   if (out_edge_size &gt; 0) {
 606     compile-&gt;node_arena()-&gt;Afree(out_array, out_edge_size);
 607   }
 608 
 609   // Free the input edge array and the node itself
 610   if( edge_end == (char*)this ) {
 611     // It was; free the input array and object all in one hit
 612 #ifndef ASSERT
 613     compile-&gt;node_arena()-&gt;Afree(_in,edge_size+node_size);
 614 #endif
 615   } else {
 616     // Free just the input array
 617     compile-&gt;node_arena()-&gt;Afree(_in,edge_size);
 618 
 619     // Free just the object
 620 #ifndef ASSERT
 621     compile-&gt;node_arena()-&gt;Afree(this,node_size);
 622 #endif
 623   }
 624   if (is_macro()) {
 625     compile-&gt;remove_macro_node(this);
 626   }
 627   if (is_expensive()) {
 628     compile-&gt;remove_expensive_node(this);
 629   }
 630   CastIINode* cast = isa_CastII();
 631   if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
 632     compile-&gt;remove_range_check_cast(cast);
 633   }
 634   if (Opcode() == Op_Opaque4) {
 635     compile-&gt;remove_opaque4_node(this);
 636   }
<a name="2" id="anc2"></a><span class="line-added"> 637   if (is_InlineTypeBase()) {</span>
<span class="line-added"> 638     compile-&gt;remove_inline_type(this);</span>
<span class="line-added"> 639   }</span>
 640 
 641   if (is_SafePoint()) {
 642     as_SafePoint()-&gt;delete_replaced_nodes();
 643   }
 644   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 645   bs-&gt;unregister_potential_barrier_node(this);
 646 #ifdef ASSERT
 647   // We will not actually delete the storage, but we&#39;ll make the node unusable.
 648   *(address*)this = badAddress;  // smash the C++ vtbl, probably
 649   _in = _out = (Node**) badAddress;
 650   _max = _cnt = _outmax = _outcnt = 0;
 651   compile-&gt;remove_modified_node(this);
 652 #endif
 653 }
 654 
 655 //------------------------------grow-------------------------------------------
 656 // Grow the input array, making space for more edges
 657 void Node::grow( uint len ) {
 658   Arena* arena = Compile::current()-&gt;node_arena();
 659   uint new_max = _max;
 660   if( new_max == 0 ) {
 661     _max = 4;
 662     _in = (Node**)arena-&gt;Amalloc(4*sizeof(Node*));
 663     Node** to = _in;
 664     to[0] = NULL;
 665     to[1] = NULL;
 666     to[2] = NULL;
 667     to[3] = NULL;
 668     return;
 669   }
 670   new_max = next_power_of_2(len);
 671   // Trimming to limit allows a uint8 to handle up to 255 edges.
 672   // Previously I was using only powers-of-2 which peaked at 128 edges.
 673   //if( new_max &gt;= limit ) new_max = limit-1;
 674   _in = (Node**)arena-&gt;Arealloc(_in, _max*sizeof(Node*), new_max*sizeof(Node*));
 675   Copy::zero_to_bytes(&amp;_in[_max], (new_max-_max)*sizeof(Node*)); // NULL all new space
 676   _max = new_max;               // Record new max length
 677   // This assertion makes sure that Node::_max is wide enough to
 678   // represent the numerical value of new_max.
 679   assert(_max == new_max &amp;&amp; _max &gt; len, &quot;int width of _max is too small&quot;);
 680 }
 681 
 682 //-----------------------------out_grow----------------------------------------
 683 // Grow the input array, making space for more edges
 684 void Node::out_grow( uint len ) {
 685   assert(!is_top(), &quot;cannot grow a top node&#39;s out array&quot;);
 686   Arena* arena = Compile::current()-&gt;node_arena();
 687   uint new_max = _outmax;
 688   if( new_max == 0 ) {
 689     _outmax = 4;
 690     _out = (Node **)arena-&gt;Amalloc(4*sizeof(Node*));
 691     return;
 692   }
 693   new_max = next_power_of_2(len);
 694   // Trimming to limit allows a uint8 to handle up to 255 edges.
 695   // Previously I was using only powers-of-2 which peaked at 128 edges.
 696   //if( new_max &gt;= limit ) new_max = limit-1;
 697   assert(_out != NULL &amp;&amp; _out != NO_OUT_ARRAY, &quot;out must have sensible value&quot;);
 698   _out = (Node**)arena-&gt;Arealloc(_out,_outmax*sizeof(Node*),new_max*sizeof(Node*));
 699   //Copy::zero_to_bytes(&amp;_out[_outmax], (new_max-_outmax)*sizeof(Node*)); // NULL all new space
 700   _outmax = new_max;               // Record new max length
 701   // This assertion makes sure that Node::_max is wide enough to
 702   // represent the numerical value of new_max.
 703   assert(_outmax == new_max &amp;&amp; _outmax &gt; len, &quot;int width of _outmax is too small&quot;);
 704 }
 705 
 706 #ifdef ASSERT
 707 //------------------------------is_dead----------------------------------------
 708 bool Node::is_dead() const {
 709   // Mach and pinch point nodes may look like dead.
 710   if( is_top() || is_Mach() || (Opcode() == Op_Node &amp;&amp; _outcnt &gt; 0) )
 711     return false;
 712   for( uint i = 0; i &lt; _max; i++ )
 713     if( _in[i] != NULL )
 714       return false;
 715   dump();
 716   return true;
 717 }
 718 
 719 bool Node::is_reachable_from_root() const {
 720   ResourceMark rm;
 721   Unique_Node_List wq;
 722   wq.push((Node*)this);
 723   RootNode* root = Compile::current()-&gt;root();
 724   for (uint i = 0; i &lt; wq.size(); i++) {
 725     Node* m = wq.at(i);
 726     if (m == root) {
 727       return true;
 728     }
 729     for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 730       Node* u = m-&gt;fast_out(j);
 731       wq.push(u);
 732     }
 733   }
 734   return false;
 735 }
 736 #endif
 737 
 738 //------------------------------is_unreachable---------------------------------
 739 bool Node::is_unreachable(PhaseIterGVN &amp;igvn) const {
 740   assert(!is_Mach(), &quot;doesn&#39;t work with MachNodes&quot;);
 741   return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != NULL &amp;&amp; in(0)-&gt;is_top());
 742 }
 743 
 744 //------------------------------add_req----------------------------------------
 745 // Add a new required input at the end
 746 void Node::add_req( Node *n ) {
 747   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 748 
 749   // Look to see if I can move precedence down one without reallocating
 750   if( (_cnt &gt;= _max) || (in(_max-1) != NULL) )
 751     grow( _max+1 );
 752 
 753   // Find a precedence edge to move
 754   if( in(_cnt) != NULL ) {       // Next precedence edge is busy?
 755     uint i;
 756     for( i=_cnt; i&lt;_max; i++ )
 757       if( in(i) == NULL )       // Find the NULL at end of prec edge list
 758         break;                  // There must be one, since we grew the array
 759     _in[i] = in(_cnt);          // Move prec over, making space for req edge
 760   }
 761   _in[_cnt++] = n;            // Stuff over old prec edge
 762   if (n != NULL) n-&gt;add_out((Node *)this);
 763 }
 764 
 765 //---------------------------add_req_batch-------------------------------------
 766 // Add a new required input at the end
 767 void Node::add_req_batch( Node *n, uint m ) {
 768   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 769   // check various edge cases
 770   if ((int)m &lt;= 1) {
 771     assert((int)m &gt;= 0, &quot;oob&quot;);
 772     if (m != 0)  add_req(n);
 773     return;
 774   }
 775 
 776   // Look to see if I can move precedence down one without reallocating
 777   if( (_cnt+m) &gt; _max || _in[_max-m] )
 778     grow( _max+m );
 779 
 780   // Find a precedence edge to move
 781   if( _in[_cnt] != NULL ) {     // Next precedence edge is busy?
 782     uint i;
 783     for( i=_cnt; i&lt;_max; i++ )
 784       if( _in[i] == NULL )      // Find the NULL at end of prec edge list
 785         break;                  // There must be one, since we grew the array
 786     // Slide all the precs over by m positions (assume #prec &lt;&lt; m).
 787     Copy::conjoint_words_to_higher((HeapWord*)&amp;_in[_cnt], (HeapWord*)&amp;_in[_cnt+m], ((i-_cnt)*sizeof(Node*)));
 788   }
 789 
 790   // Stuff over the old prec edges
 791   for(uint i=0; i&lt;m; i++ ) {
 792     _in[_cnt++] = n;
 793   }
 794 
 795   // Insert multiple out edges on the node.
 796   if (n != NULL &amp;&amp; !n-&gt;is_top()) {
 797     for(uint i=0; i&lt;m; i++ ) {
 798       n-&gt;add_out((Node *)this);
 799     }
 800   }
 801 }
 802 
 803 //------------------------------del_req----------------------------------------
 804 // Delete the required edge and compact the edge array
 805 void Node::del_req( uint idx ) {
 806   assert( idx &lt; _cnt, &quot;oob&quot;);
 807   assert( !VerifyHashTableKeys || _hash_lock == 0,
 808           &quot;remove node from hash table before modifying it&quot;);
 809   // First remove corresponding def-use edge
 810   Node *n = in(idx);
 811   if (n != NULL) n-&gt;del_out((Node *)this);
 812   _in[idx] = in(--_cnt); // Compact the array
 813   // Avoid spec violation: Gap in prec edges.
 814   close_prec_gap_at(_cnt);
 815   Compile::current()-&gt;record_modified_node(this);
 816 }
 817 
 818 //------------------------------del_req_ordered--------------------------------
 819 // Delete the required edge and compact the edge array with preserved order
 820 void Node::del_req_ordered( uint idx ) {
 821   assert( idx &lt; _cnt, &quot;oob&quot;);
 822   assert( !VerifyHashTableKeys || _hash_lock == 0,
 823           &quot;remove node from hash table before modifying it&quot;);
 824   // First remove corresponding def-use edge
 825   Node *n = in(idx);
 826   if (n != NULL) n-&gt;del_out((Node *)this);
 827   if (idx &lt; --_cnt) {    // Not last edge ?
 828     Copy::conjoint_words_to_lower((HeapWord*)&amp;_in[idx+1], (HeapWord*)&amp;_in[idx], ((_cnt-idx)*sizeof(Node*)));
 829   }
 830   // Avoid spec violation: Gap in prec edges.
 831   close_prec_gap_at(_cnt);
 832   Compile::current()-&gt;record_modified_node(this);
 833 }
 834 
 835 //------------------------------ins_req----------------------------------------
 836 // Insert a new required input at the end
 837 void Node::ins_req( uint idx, Node *n ) {
 838   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 839   add_req(NULL);                // Make space
 840   assert( idx &lt; _max, &quot;Must have allocated enough space&quot;);
 841   // Slide over
 842   if(_cnt-idx-1 &gt; 0) {
 843     Copy::conjoint_words_to_higher((HeapWord*)&amp;_in[idx], (HeapWord*)&amp;_in[idx+1], ((_cnt-idx-1)*sizeof(Node*)));
 844   }
 845   _in[idx] = n;                            // Stuff over old required edge
 846   if (n != NULL) n-&gt;add_out((Node *)this); // Add reciprocal def-use edge
 847 }
 848 
 849 //-----------------------------find_edge---------------------------------------
 850 int Node::find_edge(Node* n) {
 851   for (uint i = 0; i &lt; len(); i++) {
 852     if (_in[i] == n)  return i;
 853   }
 854   return -1;
 855 }
 856 
 857 //----------------------------replace_edge-------------------------------------
 858 int Node::replace_edge(Node* old, Node* neww) {
 859   if (old == neww)  return 0;  // nothing to do
 860   uint nrep = 0;
 861   for (uint i = 0; i &lt; len(); i++) {
 862     if (in(i) == old) {
 863       if (i &lt; req()) {
 864         set_req(i, neww);
 865       } else {
 866         assert(find_prec_edge(neww) == -1, &quot;spec violation: duplicated prec edge (node %d -&gt; %d)&quot;, _idx, neww-&gt;_idx);
 867         set_prec(i, neww);
 868       }
 869       nrep++;
 870     }
 871   }
 872   return nrep;
 873 }
 874 
 875 /**
 876  * Replace input edges in the range pointing to &#39;old&#39; node.
 877  */
 878 int Node::replace_edges_in_range(Node* old, Node* neww, int start, int end) {
 879   if (old == neww)  return 0;  // nothing to do
 880   uint nrep = 0;
 881   for (int i = start; i &lt; end; i++) {
 882     if (in(i) == old) {
 883       set_req(i, neww);
 884       nrep++;
 885     }
 886   }
 887   return nrep;
 888 }
 889 
 890 //-------------------------disconnect_inputs-----------------------------------
 891 // NULL out all inputs to eliminate incoming Def-Use edges.
 892 // Return the number of edges between &#39;n&#39; and &#39;this&#39;
 893 int Node::disconnect_inputs(Node *n, Compile* C) {
 894   int edges_to_n = 0;
 895 
 896   uint cnt = req();
 897   for( uint i = 0; i &lt; cnt; ++i ) {
 898     if( in(i) == 0 ) continue;
 899     if( in(i) == n ) ++edges_to_n;
 900     set_req(i, NULL);
 901   }
 902   // Remove precedence edges if any exist
 903   // Note: Safepoints may have precedence edges, even during parsing
 904   if( (req() != len()) &amp;&amp; (in(req()) != NULL) ) {
 905     uint max = len();
 906     for( uint i = 0; i &lt; max; ++i ) {
 907       if( in(i) == 0 ) continue;
 908       if( in(i) == n ) ++edges_to_n;
 909       set_prec(i, NULL);
 910     }
 911   }
 912 
 913   // Node::destruct requires all out edges be deleted first
 914   // debug_only(destruct();)   // no reuse benefit expected
 915   if (edges_to_n == 0) {
 916     C-&gt;record_dead_node(_idx);
 917   }
 918   return edges_to_n;
 919 }
 920 
 921 //-----------------------------uncast---------------------------------------
 922 // %%% Temporary, until we sort out CheckCastPP vs. CastPP.
 923 // Strip away casting.  (It is depth-limited.)
 924 // Optionally, keep casts with dependencies.
 925 Node* Node::uncast(bool keep_deps) const {
 926   // Should be inline:
 927   //return is_ConstraintCast() ? uncast_helper(this) : (Node*) this;
 928   if (is_ConstraintCast()) {
 929     return uncast_helper(this, keep_deps);
 930   } else {
 931     return (Node*) this;
 932   }
 933 }
 934 
 935 // Find out of current node that matches opcode.
 936 Node* Node::find_out_with(int opcode) {
 937   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 938     Node* use = fast_out(i);
 939     if (use-&gt;Opcode() == opcode) {
 940       return use;
 941     }
 942   }
 943   return NULL;
 944 }
 945 
 946 // Return true if the current node has an out that matches opcode.
 947 bool Node::has_out_with(int opcode) {
 948   return (find_out_with(opcode) != NULL);
 949 }
 950 
 951 // Return true if the current node has an out that matches any of the opcodes.
 952 bool Node::has_out_with(int opcode1, int opcode2, int opcode3, int opcode4) {
 953   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 954       int opcode = fast_out(i)-&gt;Opcode();
 955       if (opcode == opcode1 || opcode == opcode2 || opcode == opcode3 || opcode == opcode4) {
 956         return true;
 957       }
 958   }
 959   return false;
 960 }
 961 
 962 
 963 //---------------------------uncast_helper-------------------------------------
 964 Node* Node::uncast_helper(const Node* p, bool keep_deps) {
 965 #ifdef ASSERT
 966   uint depth_count = 0;
 967   const Node* orig_p = p;
 968 #endif
 969 
 970   while (true) {
 971 #ifdef ASSERT
 972     if (depth_count &gt;= K) {
 973       orig_p-&gt;dump(4);
 974       if (p != orig_p)
 975         p-&gt;dump(1);
 976     }
 977     assert(depth_count++ &lt; K, &quot;infinite loop in Node::uncast_helper&quot;);
 978 #endif
 979     if (p == NULL || p-&gt;req() != 2) {
 980       break;
 981     } else if (p-&gt;is_ConstraintCast()) {
 982       if (keep_deps &amp;&amp; p-&gt;as_ConstraintCast()-&gt;carry_dependency()) {
 983         break; // stop at casts with dependencies
 984       }
 985       p = p-&gt;in(1);
 986     } else {
 987       break;
 988     }
 989   }
 990   return (Node*) p;
 991 }
 992 
 993 //------------------------------add_prec---------------------------------------
 994 // Add a new precedence input.  Precedence inputs are unordered, with
 995 // duplicates removed and NULLs packed down at the end.
 996 void Node::add_prec( Node *n ) {
 997   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 998 
 999   // Check for NULL at end
1000   if( _cnt &gt;= _max || in(_max-1) )
1001     grow( _max+1 );
1002 
1003   // Find a precedence edge to move
1004   uint i = _cnt;
1005   while( in(i) != NULL ) {
1006     if (in(i) == n) return; // Avoid spec violation: duplicated prec edge.
1007     i++;
1008   }
1009   _in[i] = n;                                // Stuff prec edge over NULL
1010   if ( n != NULL) n-&gt;add_out((Node *)this);  // Add mirror edge
1011 
1012 #ifdef ASSERT
1013   while ((++i)&lt;_max) { assert(_in[i] == NULL, &quot;spec violation: Gap in prec edges (node %d)&quot;, _idx); }
1014 #endif
1015 }
1016 
1017 //------------------------------rm_prec----------------------------------------
1018 // Remove a precedence input.  Precedence inputs are unordered, with
1019 // duplicates removed and NULLs packed down at the end.
1020 void Node::rm_prec( uint j ) {
1021   assert(j &lt; _max, &quot;oob: i=%d, _max=%d&quot;, j, _max);
1022   assert(j &gt;= _cnt, &quot;not a precedence edge&quot;);
1023   if (_in[j] == NULL) return;   // Avoid spec violation: Gap in prec edges.
1024   _in[j]-&gt;del_out((Node *)this);
1025   close_prec_gap_at(j);
1026 }
1027 
1028 //------------------------------size_of----------------------------------------
1029 uint Node::size_of() const { return sizeof(*this); }
1030 
1031 //------------------------------ideal_reg--------------------------------------
1032 uint Node::ideal_reg() const { return 0; }
1033 
1034 //------------------------------jvms-------------------------------------------
1035 JVMState* Node::jvms() const { return NULL; }
1036 
1037 #ifdef ASSERT
1038 //------------------------------jvms-------------------------------------------
1039 bool Node::verify_jvms(const JVMState* using_jvms) const {
1040   for (JVMState* jvms = this-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {
1041     if (jvms == using_jvms)  return true;
1042   }
1043   return false;
1044 }
1045 
1046 //------------------------------init_NodeProperty------------------------------
1047 void Node::init_NodeProperty() {
1048   assert(_max_classes &lt;= max_jushort, &quot;too many NodeProperty classes&quot;);
1049   assert(max_flags() &lt;= max_jushort, &quot;too many NodeProperty flags&quot;);
1050 }
1051 
1052 //-----------------------------max_flags---------------------------------------
1053 juint Node::max_flags() {
1054   return (PD::_last_flag &lt;&lt; 1) - 1; // allow flags combination
1055 }
1056 #endif
1057 
1058 //------------------------------format-----------------------------------------
1059 // Print as assembly
1060 void Node::format( PhaseRegAlloc *, outputStream *st ) const {}
1061 //------------------------------emit-------------------------------------------
1062 // Emit bytes starting at parameter &#39;ptr&#39;.
1063 void Node::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {}
1064 //------------------------------size-------------------------------------------
1065 // Size of instruction in bytes
1066 uint Node::size(PhaseRegAlloc *ra_) const { return 0; }
1067 
1068 //------------------------------CFG Construction-------------------------------
1069 // Nodes that end basic blocks, e.g. IfTrue/IfFalse, JumpProjNode, Root,
1070 // Goto and Return.
1071 const Node *Node::is_block_proj() const { return 0; }
1072 
1073 // Minimum guaranteed type
1074 const Type *Node::bottom_type() const { return Type::BOTTOM; }
1075 
1076 
1077 //------------------------------raise_bottom_type------------------------------
1078 // Get the worst-case Type output for this Node.
1079 void Node::raise_bottom_type(const Type* new_type) {
1080   if (is_Type()) {
1081     TypeNode *n = this-&gt;as_Type();
1082     if (VerifyAliases) {
1083       assert(new_type-&gt;higher_equal_speculative(n-&gt;type()), &quot;new type must refine old type&quot;);
1084     }
1085     n-&gt;set_type(new_type);
1086   } else if (is_Load()) {
1087     LoadNode *n = this-&gt;as_Load();
1088     if (VerifyAliases) {
1089       assert(new_type-&gt;higher_equal_speculative(n-&gt;type()), &quot;new type must refine old type&quot;);
1090     }
1091     n-&gt;set_type(new_type);
1092   }
1093 }
1094 
1095 //------------------------------Identity---------------------------------------
1096 // Return a node that the given node is equivalent to.
1097 Node* Node::Identity(PhaseGVN* phase) {
1098   return this;                  // Default to no identities
1099 }
1100 
1101 //------------------------------Value------------------------------------------
1102 // Compute a new Type for a node using the Type of the inputs.
1103 const Type* Node::Value(PhaseGVN* phase) const {
1104   return bottom_type();         // Default to worst-case Type
1105 }
1106 
1107 //------------------------------Ideal------------------------------------------
1108 //
1109 // &#39;Idealize&#39; the graph rooted at this Node.
1110 //
1111 // In order to be efficient and flexible there are some subtle invariants
1112 // these Ideal calls need to hold.  Running with &#39;+VerifyIterativeGVN&#39; checks
1113 // these invariants, although its too slow to have on by default.  If you are
1114 // hacking an Ideal call, be sure to test with +VerifyIterativeGVN!
1115 //
1116 // The Ideal call almost arbitrarily reshape the graph rooted at the &#39;this&#39;
1117 // pointer.  If ANY change is made, it must return the root of the reshaped
1118 // graph - even if the root is the same Node.  Example: swapping the inputs
1119 // to an AddINode gives the same answer and same root, but you still have to
1120 // return the &#39;this&#39; pointer instead of NULL.
1121 //
1122 // You cannot return an OLD Node, except for the &#39;this&#39; pointer.  Use the
1123 // Identity call to return an old Node; basically if Identity can find
1124 // another Node have the Ideal call make no change and return NULL.
1125 // Example: AddINode::Ideal must check for add of zero; in this case it
1126 // returns NULL instead of doing any graph reshaping.
1127 //
1128 // You cannot modify any old Nodes except for the &#39;this&#39; pointer.  Due to
1129 // sharing there may be other users of the old Nodes relying on their current
1130 // semantics.  Modifying them will break the other users.
1131 // Example: when reshape &quot;(X+3)+4&quot; into &quot;X+7&quot; you must leave the Node for
1132 // &quot;X+3&quot; unchanged in case it is shared.
1133 //
1134 // If you modify the &#39;this&#39; pointer&#39;s inputs, you should use
1135 // &#39;set_req&#39;.  If you are making a new Node (either as the new root or
1136 // some new internal piece) you may use &#39;init_req&#39; to set the initial
1137 // value.  You can make a new Node with either &#39;new&#39; or &#39;clone&#39;.  In
1138 // either case, def-use info is correctly maintained.
1139 //
1140 // Example: reshape &quot;(X+3)+4&quot; into &quot;X+7&quot;:
1141 //    set_req(1, in(1)-&gt;in(1));
1142 //    set_req(2, phase-&gt;intcon(7));
1143 //    return this;
1144 // Example: reshape &quot;X*4&quot; into &quot;X&lt;&lt;2&quot;
1145 //    return new LShiftINode(in(1), phase-&gt;intcon(2));
1146 //
1147 // You must call &#39;phase-&gt;transform(X)&#39; on any new Nodes X you make, except
1148 // for the returned root node.  Example: reshape &quot;X*31&quot; with &quot;(X&lt;&lt;5)-X&quot;.
1149 //    Node *shift=phase-&gt;transform(new LShiftINode(in(1),phase-&gt;intcon(5)));
1150 //    return new AddINode(shift, in(1));
1151 //
1152 // When making a Node for a constant use &#39;phase-&gt;makecon&#39; or &#39;phase-&gt;intcon&#39;.
1153 // These forms are faster than &#39;phase-&gt;transform(new ConNode())&#39; and Do
1154 // The Right Thing with def-use info.
1155 //
1156 // You cannot bury the &#39;this&#39; Node inside of a graph reshape.  If the reshaped
1157 // graph uses the &#39;this&#39; Node it must be the root.  If you want a Node with
1158 // the same Opcode as the &#39;this&#39; pointer use &#39;clone&#39;.
1159 //
1160 Node *Node::Ideal(PhaseGVN *phase, bool can_reshape) {
1161   return NULL;                  // Default to being Ideal already
1162 }
1163 
1164 // Some nodes have specific Ideal subgraph transformations only if they are
1165 // unique users of specific nodes. Such nodes should be put on IGVN worklist
1166 // for the transformations to happen.
1167 bool Node::has_special_unique_user() const {
1168   assert(outcnt() == 1, &quot;match only for unique out&quot;);
1169   Node* n = unique_out();
1170   int op  = Opcode();
1171   if (this-&gt;is_Store()) {
1172     // Condition for back-to-back stores folding.
1173     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(MemNode::Memory) == this;
1174   } else if (this-&gt;is_Load() || this-&gt;is_DecodeN() || this-&gt;is_Phi()) {
1175     // Condition for removing an unused LoadNode or DecodeNNode from the MemBarAcquire precedence input
1176     return n-&gt;Opcode() == Op_MemBarAcquire;
1177   } else if (op == Op_AddL) {
1178     // Condition for convL2I(addL(x,y)) ==&gt; addI(convL2I(x),convL2I(y))
1179     return n-&gt;Opcode() == Op_ConvL2I &amp;&amp; n-&gt;in(1) == this;
1180   } else if (op == Op_SubI || op == Op_SubL) {
1181     // Condition for subI(x,subI(y,z)) ==&gt; subI(addI(x,z),y)
1182     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(2) == this;
1183   } else if (is_If() &amp;&amp; (n-&gt;is_IfFalse() || n-&gt;is_IfTrue())) {
1184     // See IfProjNode::Identity()
1185     return true;
1186   } else {
1187     return false;
1188   }
1189 };
1190 
1191 //--------------------------find_exact_control---------------------------------
1192 // Skip Proj and CatchProj nodes chains. Check for Null and Top.
1193 Node* Node::find_exact_control(Node* ctrl) {
1194   if (ctrl == NULL &amp;&amp; this-&gt;is_Region())
1195     ctrl = this-&gt;as_Region()-&gt;is_copy();
1196 
1197   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_CatchProj()) {
1198     if (ctrl-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index)
1199       ctrl = ctrl-&gt;in(0);
1200     if (ctrl != NULL &amp;&amp; !ctrl-&gt;is_top())
1201       ctrl = ctrl-&gt;in(0);
1202   }
1203 
1204   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_Proj())
1205     ctrl = ctrl-&gt;in(0);
1206 
1207   return ctrl;
1208 }
1209 
1210 //--------------------------dominates------------------------------------------
1211 // Helper function for MemNode::all_controls_dominate().
1212 // Check if &#39;this&#39; control node dominates or equal to &#39;sub&#39; control node.
1213 // We already know that if any path back to Root or Start reaches &#39;this&#39;,
1214 // then all paths so, so this is a simple search for one example,
1215 // not an exhaustive search for a counterexample.
1216 bool Node::dominates(Node* sub, Node_List &amp;nlist) {
1217   assert(this-&gt;is_CFG(), &quot;expecting control&quot;);
1218   assert(sub != NULL &amp;&amp; sub-&gt;is_CFG(), &quot;expecting control&quot;);
1219 
1220   // detect dead cycle without regions
1221   int iterations_without_region_limit = DominatorSearchLimit;
1222 
1223   Node* orig_sub = sub;
1224   Node* dom      = this;
1225   bool  met_dom  = false;
1226   nlist.clear();
1227 
1228   // Walk &#39;sub&#39; backward up the chain to &#39;dom&#39;, watching for regions.
1229   // After seeing &#39;dom&#39;, continue up to Root or Start.
1230   // If we hit a region (backward split point), it may be a loop head.
1231   // Keep going through one of the region&#39;s inputs.  If we reach the
1232   // same region again, go through a different input.  Eventually we
1233   // will either exit through the loop head, or give up.
1234   // (If we get confused, break out and return a conservative &#39;false&#39;.)
1235   while (sub != NULL) {
1236     if (sub-&gt;is_top())  break; // Conservative answer for dead code.
1237     if (sub == dom) {
1238       if (nlist.size() == 0) {
1239         // No Region nodes except loops were visited before and the EntryControl
1240         // path was taken for loops: it did not walk in a cycle.
1241         return true;
1242       } else if (met_dom) {
1243         break;          // already met before: walk in a cycle
1244       } else {
1245         // Region nodes were visited. Continue walk up to Start or Root
1246         // to make sure that it did not walk in a cycle.
1247         met_dom = true; // first time meet
1248         iterations_without_region_limit = DominatorSearchLimit; // Reset
1249      }
1250     }
1251     if (sub-&gt;is_Start() || sub-&gt;is_Root()) {
1252       // Success if we met &#39;dom&#39; along a path to Start or Root.
1253       // We assume there are no alternative paths that avoid &#39;dom&#39;.
1254       // (This assumption is up to the caller to ensure!)
1255       return met_dom;
1256     }
1257     Node* up = sub-&gt;in(0);
1258     // Normalize simple pass-through regions and projections:
1259     up = sub-&gt;find_exact_control(up);
1260     // If sub == up, we found a self-loop.  Try to push past it.
1261     if (sub == up &amp;&amp; sub-&gt;is_Loop()) {
1262       // Take loop entry path on the way up to &#39;dom&#39;.
1263       up = sub-&gt;in(1); // in(LoopNode::EntryControl);
1264     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() == 2) {
1265       // Take in(1) path on the way up to &#39;dom&#39; for regions with only one input
1266       up = sub-&gt;in(1);
1267     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() == 3) {
1268       // Try both paths for Regions with 2 input paths (it may be a loop head).
1269       // It could give conservative &#39;false&#39; answer without information
1270       // which region&#39;s input is the entry path.
1271       iterations_without_region_limit = DominatorSearchLimit; // Reset
1272 
1273       bool region_was_visited_before = false;
1274       // Was this Region node visited before?
1275       // If so, we have reached it because we accidentally took a
1276       // loop-back edge from &#39;sub&#39; back into the body of the loop,
1277       // and worked our way up again to the loop header &#39;sub&#39;.
1278       // So, take the first unexplored path on the way up to &#39;dom&#39;.
1279       for (int j = nlist.size() - 1; j &gt;= 0; j--) {
1280         intptr_t ni = (intptr_t)nlist.at(j);
1281         Node* visited = (Node*)(ni &amp; ~1);
1282         bool  visited_twice_already = ((ni &amp; 1) != 0);
1283         if (visited == sub) {
1284           if (visited_twice_already) {
1285             // Visited 2 paths, but still stuck in loop body.  Give up.
1286             return false;
1287           }
1288           // The Region node was visited before only once.
1289           // (We will repush with the low bit set, below.)
1290           nlist.remove(j);
1291           // We will find a new edge and re-insert.
1292           region_was_visited_before = true;
1293           break;
1294         }
1295       }
1296 
1297       // Find an incoming edge which has not been seen yet; walk through it.
1298       assert(up == sub, &quot;&quot;);
1299       uint skip = region_was_visited_before ? 1 : 0;
1300       for (uint i = 1; i &lt; sub-&gt;req(); i++) {
1301         Node* in = sub-&gt;in(i);
1302         if (in != NULL &amp;&amp; !in-&gt;is_top() &amp;&amp; in != sub) {
1303           if (skip == 0) {
1304             up = in;
1305             break;
1306           }
1307           --skip;               // skip this nontrivial input
1308         }
1309       }
1310 
1311       // Set 0 bit to indicate that both paths were taken.
1312       nlist.push((Node*)((intptr_t)sub + (region_was_visited_before ? 1 : 0)));
1313     }
1314 
1315     if (up == sub) {
1316       break;    // some kind of tight cycle
1317     }
1318     if (up == orig_sub &amp;&amp; met_dom) {
1319       // returned back after visiting &#39;dom&#39;
1320       break;    // some kind of cycle
1321     }
1322     if (--iterations_without_region_limit &lt; 0) {
1323       break;    // dead cycle
1324     }
1325     sub = up;
1326   }
1327 
1328   // Did not meet Root or Start node in pred. chain.
1329   // Conservative answer for dead code.
1330   return false;
1331 }
1332 
1333 //------------------------------remove_dead_region-----------------------------
1334 // This control node is dead.  Follow the subgraph below it making everything
1335 // using it dead as well.  This will happen normally via the usual IterGVN
1336 // worklist but this call is more efficient.  Do not update use-def info
1337 // inside the dead region, just at the borders.
1338 static void kill_dead_code( Node *dead, PhaseIterGVN *igvn ) {
1339   // Con&#39;s are a popular node to re-hit in the hash table again.
1340   if( dead-&gt;is_Con() ) return;
1341 
1342   ResourceMark rm;
1343   Node_List nstack;
1344 
1345   Node *top = igvn-&gt;C-&gt;top();
1346   nstack.push(dead);
1347   bool has_irreducible_loop = igvn-&gt;C-&gt;has_irreducible_loop();
1348 
1349   while (nstack.size() &gt; 0) {
1350     dead = nstack.pop();
1351     if (dead-&gt;Opcode() == Op_SafePoint) {
1352       dead-&gt;as_SafePoint()-&gt;disconnect_from_root(igvn);
1353     }
1354     if (dead-&gt;outcnt() &gt; 0) {
1355       // Keep dead node on stack until all uses are processed.
1356       nstack.push(dead);
1357       // For all Users of the Dead...    ;-)
1358       for (DUIterator_Last kmin, k = dead-&gt;last_outs(kmin); k &gt;= kmin; ) {
1359         Node* use = dead-&gt;last_out(k);
1360         igvn-&gt;hash_delete(use);       // Yank from hash table prior to mod
1361         if (use-&gt;in(0) == dead) {     // Found another dead node
1362           assert (!use-&gt;is_Con(), &quot;Control for Con node should be Root node.&quot;);
1363           use-&gt;set_req(0, top);       // Cut dead edge to prevent processing
1364           nstack.push(use);           // the dead node again.
1365         } else if (!has_irreducible_loop &amp;&amp; // Backedge could be alive in irreducible loop
1366                    use-&gt;is_Loop() &amp;&amp; !use-&gt;is_Root() &amp;&amp;       // Don&#39;t kill Root (RootNode extends LoopNode)
1367                    use-&gt;in(LoopNode::EntryControl) == dead) { // Dead loop if its entry is dead
1368           use-&gt;set_req(LoopNode::EntryControl, top);          // Cut dead edge to prevent processing
1369           use-&gt;set_req(0, top);       // Cut self edge
1370           nstack.push(use);
1371         } else {                      // Else found a not-dead user
1372           // Dead if all inputs are top or null
1373           bool dead_use = !use-&gt;is_Root(); // Keep empty graph alive
1374           for (uint j = 1; j &lt; use-&gt;req(); j++) {
1375             Node* in = use-&gt;in(j);
1376             if (in == dead) {         // Turn all dead inputs into TOP
1377               use-&gt;set_req(j, top);
1378             } else if (in != NULL &amp;&amp; !in-&gt;is_top()) {
1379               dead_use = false;
1380             }
1381           }
1382           if (dead_use) {
1383             if (use-&gt;is_Region()) {
1384               use-&gt;set_req(0, top);   // Cut self edge
1385             }
1386             nstack.push(use);
1387           } else {
1388             igvn-&gt;_worklist.push(use);
1389           }
1390         }
1391         // Refresh the iterator, since any number of kills might have happened.
1392         k = dead-&gt;last_outs(kmin);
1393       }
1394     } else { // (dead-&gt;outcnt() == 0)
1395       // Done with outputs.
1396       igvn-&gt;hash_delete(dead);
1397       igvn-&gt;_worklist.remove(dead);
1398       igvn-&gt;C-&gt;remove_modified_node(dead);
1399       igvn-&gt;set_type(dead, Type::TOP);
1400       if (dead-&gt;is_macro()) {
1401         igvn-&gt;C-&gt;remove_macro_node(dead);
1402       }
1403       if (dead-&gt;is_expensive()) {
1404         igvn-&gt;C-&gt;remove_expensive_node(dead);
1405       }
1406       CastIINode* cast = dead-&gt;isa_CastII();
1407       if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
1408         igvn-&gt;C-&gt;remove_range_check_cast(cast);
1409       }
1410       if (dead-&gt;Opcode() == Op_Opaque4) {
1411         igvn-&gt;C-&gt;remove_opaque4_node(dead);
1412       }
<a name="3" id="anc3"></a><span class="line-added">1413       if (dead-&gt;is_InlineTypeBase()) {</span>
<span class="line-added">1414         igvn-&gt;C-&gt;remove_inline_type(dead);</span>
<span class="line-added">1415       }</span>
1416       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1417       bs-&gt;unregister_potential_barrier_node(dead);
1418       igvn-&gt;C-&gt;record_dead_node(dead-&gt;_idx);
1419       // Kill all inputs to the dead guy
1420       for (uint i=0; i &lt; dead-&gt;req(); i++) {
1421         Node *n = dead-&gt;in(i);      // Get input to dead guy
1422         if (n != NULL &amp;&amp; !n-&gt;is_top()) { // Input is valid?
1423           dead-&gt;set_req(i, top);    // Smash input away
1424           if (n-&gt;outcnt() == 0) {   // Input also goes dead?
1425             if (!n-&gt;is_Con())
1426               nstack.push(n);       // Clear it out as well
1427           } else if (n-&gt;outcnt() == 1 &amp;&amp;
1428                      n-&gt;has_special_unique_user()) {
1429             igvn-&gt;add_users_to_worklist( n );
1430           } else if (n-&gt;outcnt() &lt;= 2 &amp;&amp; n-&gt;is_Store()) {
1431             // Push store&#39;s uses on worklist to enable folding optimization for
1432             // store/store and store/load to the same address.
1433             // The restriction (outcnt() &lt;= 2) is the same as in set_req_X()
1434             // and remove_globally_dead_node().
1435             igvn-&gt;add_users_to_worklist( n );
1436           } else {
1437             BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;enqueue_useful_gc_barrier(igvn, n);
1438           }
1439         }
1440       }
1441     } // (dead-&gt;outcnt() == 0)
1442   }   // while (nstack.size() &gt; 0) for outputs
1443   return;
1444 }
1445 
1446 //------------------------------remove_dead_region-----------------------------
1447 bool Node::remove_dead_region(PhaseGVN *phase, bool can_reshape) {
1448   Node *n = in(0);
1449   if( !n ) return false;
1450   // Lost control into this guy?  I.e., it became unreachable?
1451   // Aggressively kill all unreachable code.
1452   if (can_reshape &amp;&amp; n-&gt;is_top()) {
1453     kill_dead_code(this, phase-&gt;is_IterGVN());
1454     return false; // Node is dead.
1455   }
1456 
1457   if( n-&gt;is_Region() &amp;&amp; n-&gt;as_Region()-&gt;is_copy() ) {
1458     Node *m = n-&gt;nonnull_req();
1459     set_req(0, m);
1460     return true;
1461   }
1462   return false;
1463 }
1464 
1465 //------------------------------hash-------------------------------------------
1466 // Hash function over Nodes.
1467 uint Node::hash() const {
1468   uint sum = 0;
1469   for( uint i=0; i&lt;_cnt; i++ )  // Add in all inputs
1470     sum = (sum&lt;&lt;1)-(uintptr_t)in(i);        // Ignore embedded NULLs
1471   return (sum&gt;&gt;2) + _cnt + Opcode();
1472 }
1473 
1474 //------------------------------cmp--------------------------------------------
1475 // Compare special parts of simple Nodes
1476 bool Node::cmp( const Node &amp;n ) const {
1477   return true;                  // Must be same
1478 }
1479 
1480 //------------------------------rematerialize-----------------------------------
1481 // Should we clone rather than spill this instruction?
1482 bool Node::rematerialize() const {
1483   if ( is_Mach() )
1484     return this-&gt;as_Mach()-&gt;rematerialize();
1485   else
1486     return (_flags &amp; Flag_rematerialize) != 0;
1487 }
1488 
1489 //------------------------------needs_anti_dependence_check---------------------
1490 // Nodes which use memory without consuming it, hence need antidependences.
1491 bool Node::needs_anti_dependence_check() const {
1492   if (req() &lt; 2 || (_flags &amp; Flag_needs_anti_dependence_check) == 0) {
1493     return false;
1494   }
1495   return in(1)-&gt;bottom_type()-&gt;has_memory();
1496 }
1497 
1498 // Get an integer constant from a ConNode (or CastIINode).
1499 // Return a default value if there is no apparent constant here.
1500 const TypeInt* Node::find_int_type() const {
1501   if (this-&gt;is_Type()) {
1502     return this-&gt;as_Type()-&gt;type()-&gt;isa_int();
1503   } else if (this-&gt;is_Con()) {
1504     assert(is_Mach(), &quot;should be ConNode(TypeNode) or else a MachNode&quot;);
1505     return this-&gt;bottom_type()-&gt;isa_int();
1506   }
1507   return NULL;
1508 }
1509 
1510 // Get a pointer constant from a ConstNode.
1511 // Returns the constant if it is a pointer ConstNode
1512 intptr_t Node::get_ptr() const {
1513   assert( Opcode() == Op_ConP, &quot;&quot; );
1514   return ((ConPNode*)this)-&gt;type()-&gt;is_ptr()-&gt;get_con();
1515 }
1516 
1517 // Get a narrow oop constant from a ConNNode.
1518 intptr_t Node::get_narrowcon() const {
1519   assert( Opcode() == Op_ConN, &quot;&quot; );
1520   return ((ConNNode*)this)-&gt;type()-&gt;is_narrowoop()-&gt;get_con();
1521 }
1522 
1523 // Get a long constant from a ConNode.
1524 // Return a default value if there is no apparent constant here.
1525 const TypeLong* Node::find_long_type() const {
1526   if (this-&gt;is_Type()) {
1527     return this-&gt;as_Type()-&gt;type()-&gt;isa_long();
1528   } else if (this-&gt;is_Con()) {
1529     assert(is_Mach(), &quot;should be ConNode(TypeNode) or else a MachNode&quot;);
1530     return this-&gt;bottom_type()-&gt;isa_long();
1531   }
1532   return NULL;
1533 }
1534 
1535 
1536 /**
1537  * Return a ptr type for nodes which should have it.
1538  */
1539 const TypePtr* Node::get_ptr_type() const {
1540   const TypePtr* tp = this-&gt;bottom_type()-&gt;make_ptr();
1541 #ifdef ASSERT
1542   if (tp == NULL) {
1543     this-&gt;dump(1);
1544     assert((tp != NULL), &quot;unexpected node type&quot;);
1545   }
1546 #endif
1547   return tp;
1548 }
1549 
1550 // Get a double constant from a ConstNode.
1551 // Returns the constant if it is a double ConstNode
1552 jdouble Node::getd() const {
1553   assert( Opcode() == Op_ConD, &quot;&quot; );
1554   return ((ConDNode*)this)-&gt;type()-&gt;is_double_constant()-&gt;getd();
1555 }
1556 
1557 // Get a float constant from a ConstNode.
1558 // Returns the constant if it is a float ConstNode
1559 jfloat Node::getf() const {
1560   assert( Opcode() == Op_ConF, &quot;&quot; );
1561   return ((ConFNode*)this)-&gt;type()-&gt;is_float_constant()-&gt;getf();
1562 }
1563 
1564 #ifndef PRODUCT
1565 
1566 //------------------------------find------------------------------------------
1567 // Find a neighbor of this Node with the given _idx
1568 // If idx is negative, find its absolute value, following both _in and _out.
1569 static void find_recur(Compile* C,  Node* &amp;result, Node *n, int idx, bool only_ctrl,
1570                         VectorSet* old_space, VectorSet* new_space ) {
1571   int node_idx = (idx &gt;= 0) ? idx : -idx;
1572   if (NotANode(n))  return;  // Gracefully handle NULL, -1, 0xabababab, etc.
1573   // Contained in new_space or old_space?   Check old_arena first since it&#39;s mostly empty.
1574   VectorSet *v = C-&gt;old_arena()-&gt;contains(n) ? old_space : new_space;
1575   if( v-&gt;test(n-&gt;_idx) ) return;
1576   if( (int)n-&gt;_idx == node_idx
1577       debug_only(|| n-&gt;debug_idx() == node_idx) ) {
1578     if (result != NULL)
1579       tty-&gt;print(&quot;find: &quot; INTPTR_FORMAT &quot; and &quot; INTPTR_FORMAT &quot; both have idx==%d\n&quot;,
1580                  (uintptr_t)result, (uintptr_t)n, node_idx);
1581     result = n;
1582   }
1583   v-&gt;set(n-&gt;_idx);
1584   for( uint i=0; i&lt;n-&gt;len(); i++ ) {
1585     if( only_ctrl &amp;&amp; !(n-&gt;is_Region()) &amp;&amp; (n-&gt;Opcode() != Op_Root) &amp;&amp; (i != TypeFunc::Control) ) continue;
1586     find_recur(C, result, n-&gt;in(i), idx, only_ctrl, old_space, new_space );
1587   }
1588   // Search along forward edges also:
1589   if (idx &lt; 0 &amp;&amp; !only_ctrl) {
1590     for( uint j=0; j&lt;n-&gt;outcnt(); j++ ) {
1591       find_recur(C, result, n-&gt;raw_out(j), idx, only_ctrl, old_space, new_space );
1592     }
1593   }
1594 #ifdef ASSERT
1595   // Search along debug_orig edges last, checking for cycles
1596   Node* orig = n-&gt;debug_orig();
1597   if (orig != NULL) {
1598     do {
1599       if (NotANode(orig))  break;
1600       find_recur(C, result, orig, idx, only_ctrl, old_space, new_space );
1601       orig = orig-&gt;debug_orig();
1602     } while (orig != NULL &amp;&amp; orig != n-&gt;debug_orig());
1603   }
1604 #endif //ASSERT
1605 }
1606 
1607 // call this from debugger:
1608 Node* find_node(Node* n, int idx) {
1609   return n-&gt;find(idx);
1610 }
1611 
1612 // call this from debugger with root node as default:
1613 Node* find_node(int idx) {
1614   return Compile::current()-&gt;root()-&gt;find(idx);
1615 }
1616 
1617 //------------------------------find-------------------------------------------
1618 Node* Node::find(int idx) const {
1619   VectorSet old_space, new_space;
1620   Node* result = NULL;
1621   find_recur(Compile::current(), result, (Node*) this, idx, false, &amp;old_space, &amp;new_space);
1622   return result;
1623 }
1624 
1625 //------------------------------find_ctrl--------------------------------------
1626 // Find an ancestor to this node in the control history with given _idx
1627 Node* Node::find_ctrl(int idx) const {
1628   VectorSet old_space, new_space;
1629   Node* result = NULL;
1630   find_recur(Compile::current(), result, (Node*)this, idx, true, &amp;old_space, &amp;new_space);
1631   return result;
1632 }
1633 #endif
1634 
1635 
1636 
1637 #ifndef PRODUCT
1638 
1639 // -----------------------------Name-------------------------------------------
1640 extern const char *NodeClassNames[];
1641 const char *Node::Name() const { return NodeClassNames[Opcode()]; }
1642 
1643 static bool is_disconnected(const Node* n) {
1644   for (uint i = 0; i &lt; n-&gt;req(); i++) {
1645     if (n-&gt;in(i) != NULL)  return false;
1646   }
1647   return true;
1648 }
1649 
1650 #ifdef ASSERT
1651 void Node::dump_orig(outputStream *st, bool print_key) const {
1652   Compile* C = Compile::current();
1653   Node* orig = _debug_orig;
1654   if (NotANode(orig)) orig = NULL;
1655   if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1656   if (orig == NULL) return;
1657   if (print_key) {
1658     st-&gt;print(&quot; !orig=&quot;);
1659   }
1660   Node* fast = orig-&gt;debug_orig(); // tortoise &amp; hare algorithm to detect loops
1661   if (NotANode(fast)) fast = NULL;
1662   while (orig != NULL) {
1663     bool discon = is_disconnected(orig);  // if discon, print [123] else 123
1664     if (discon) st-&gt;print(&quot;[&quot;);
1665     if (!Compile::current()-&gt;node_arena()-&gt;contains(orig))
1666       st-&gt;print(&quot;o&quot;);
1667     st-&gt;print(&quot;%d&quot;, orig-&gt;_idx);
1668     if (discon) st-&gt;print(&quot;]&quot;);
1669     orig = orig-&gt;debug_orig();
1670     if (NotANode(orig)) orig = NULL;
1671     if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1672     if (orig != NULL) st-&gt;print(&quot;,&quot;);
1673     if (fast != NULL) {
1674       // Step fast twice for each single step of orig:
1675       fast = fast-&gt;debug_orig();
1676       if (NotANode(fast)) fast = NULL;
1677       if (fast != NULL &amp;&amp; fast != orig) {
1678         fast = fast-&gt;debug_orig();
1679         if (NotANode(fast)) fast = NULL;
1680       }
1681       if (fast == orig) {
1682         st-&gt;print(&quot;...&quot;);
1683         break;
1684       }
1685     }
1686   }
1687 }
1688 
1689 void Node::set_debug_orig(Node* orig) {
1690   _debug_orig = orig;
1691   if (BreakAtNode == 0)  return;
1692   if (NotANode(orig))  orig = NULL;
1693   int trip = 10;
1694   while (orig != NULL) {
1695     if (orig-&gt;debug_idx() == BreakAtNode || (int)orig-&gt;_idx == BreakAtNode) {
1696       tty-&gt;print_cr(&quot;BreakAtNode: _idx=%d _debug_idx=%d orig._idx=%d orig._debug_idx=%d&quot;,
1697                     this-&gt;_idx, this-&gt;debug_idx(), orig-&gt;_idx, orig-&gt;debug_idx());
1698       BREAKPOINT;
1699     }
1700     orig = orig-&gt;debug_orig();
1701     if (NotANode(orig))  orig = NULL;
1702     if (trip-- &lt;= 0)  break;
1703   }
1704 }
1705 #endif //ASSERT
1706 
1707 //------------------------------dump------------------------------------------
1708 // Dump a Node
1709 void Node::dump(const char* suffix, bool mark, outputStream *st) const {
1710   Compile* C = Compile::current();
1711   bool is_new = C-&gt;node_arena()-&gt;contains(this);
1712   C-&gt;_in_dump_cnt++;
1713   st-&gt;print(&quot;%c%d%s\t%s\t=== &quot;, is_new ? &#39; &#39; : &#39;o&#39;, _idx, mark ? &quot; &gt;&quot; : &quot;&quot;, Name());
1714 
1715   // Dump the required and precedence inputs
1716   dump_req(st);
1717   dump_prec(st);
1718   // Dump the outputs
1719   dump_out(st);
1720 
1721   if (is_disconnected(this)) {
1722 #ifdef ASSERT
1723     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1724     dump_orig(st);
1725 #endif
1726     st-&gt;cr();
1727     C-&gt;_in_dump_cnt--;
1728     return;                     // don&#39;t process dead nodes
1729   }
1730 
1731   if (C-&gt;clone_map().value(_idx) != 0) {
1732     C-&gt;clone_map().dump(_idx);
1733   }
1734   // Dump node-specific info
1735   dump_spec(st);
1736 #ifdef ASSERT
1737   // Dump the non-reset _debug_idx
1738   if (Verbose &amp;&amp; WizardMode) {
1739     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1740   }
1741 #endif
1742 
1743   const Type *t = bottom_type();
1744 
1745   if (t != NULL &amp;&amp; (t-&gt;isa_instptr() || t-&gt;isa_klassptr())) {
1746     const TypeInstPtr  *toop = t-&gt;isa_instptr();
1747     const TypeKlassPtr *tkls = t-&gt;isa_klassptr();
1748     ciKlass*           klass = toop ? toop-&gt;klass() : (tkls ? tkls-&gt;klass() : NULL );
1749     if (klass &amp;&amp; klass-&gt;is_loaded() &amp;&amp; klass-&gt;is_interface()) {
1750       st-&gt;print(&quot;  Interface:&quot;);
1751     } else if (toop) {
1752       st-&gt;print(&quot;  Oop:&quot;);
1753     } else if (tkls) {
1754       st-&gt;print(&quot;  Klass:&quot;);
1755     }
1756     t-&gt;dump_on(st);
1757   } else if (t == Type::MEMORY) {
1758     st-&gt;print(&quot;  Memory:&quot;);
1759     MemNode::dump_adr_type(this, adr_type(), st);
1760   } else if (Verbose || WizardMode) {
1761     st-&gt;print(&quot;  Type:&quot;);
1762     if (t) {
1763       t-&gt;dump_on(st);
1764     } else {
1765       st-&gt;print(&quot;no type&quot;);
1766     }
1767   } else if (t-&gt;isa_vect() &amp;&amp; this-&gt;is_MachSpillCopy()) {
1768     // Dump MachSpillcopy vector type.
1769     t-&gt;dump_on(st);
1770   }
1771   if (is_new) {
1772     DEBUG_ONLY(dump_orig(st));
1773     Node_Notes* nn = C-&gt;node_notes_at(_idx);
1774     if (nn != NULL &amp;&amp; !nn-&gt;is_clear()) {
1775       if (nn-&gt;jvms() != NULL) {
1776         st-&gt;print(&quot; !jvms:&quot;);
1777         nn-&gt;jvms()-&gt;dump_spec(st);
1778       }
1779     }
1780   }
1781   if (suffix) st-&gt;print(&quot;%s&quot;, suffix);
1782   C-&gt;_in_dump_cnt--;
1783 }
1784 
1785 //------------------------------dump_req--------------------------------------
1786 void Node::dump_req(outputStream *st) const {
1787   // Dump the required input edges
1788   for (uint i = 0; i &lt; req(); i++) {    // For all required inputs
1789     Node* d = in(i);
1790     if (d == NULL) {
1791       st-&gt;print(&quot;_ &quot;);
1792     } else if (NotANode(d)) {
1793       st-&gt;print(&quot;NotANode &quot;);  // uninitialized, sentinel, garbage, etc.
1794     } else {
1795       st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(d) ? &#39; &#39; : &#39;o&#39;, d-&gt;_idx);
1796     }
1797   }
1798 }
1799 
1800 
1801 //------------------------------dump_prec-------------------------------------
1802 void Node::dump_prec(outputStream *st) const {
1803   // Dump the precedence edges
1804   int any_prec = 0;
1805   for (uint i = req(); i &lt; len(); i++) {       // For all precedence inputs
1806     Node* p = in(i);
1807     if (p != NULL) {
1808       if (!any_prec++) st-&gt;print(&quot; |&quot;);
1809       if (NotANode(p)) { st-&gt;print(&quot;NotANode &quot;); continue; }
1810       st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
1811     }
1812   }
1813 }
1814 
1815 //------------------------------dump_out--------------------------------------
1816 void Node::dump_out(outputStream *st) const {
1817   // Delimit the output edges
1818   st-&gt;print(&quot; [[&quot;);
1819   // Dump the output edges
1820   for (uint i = 0; i &lt; _outcnt; i++) {    // For all outputs
1821     Node* u = _out[i];
1822     if (u == NULL) {
1823       st-&gt;print(&quot;_ &quot;);
1824     } else if (NotANode(u)) {
1825       st-&gt;print(&quot;NotANode &quot;);
1826     } else {
1827       st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(u) ? &#39; &#39; : &#39;o&#39;, u-&gt;_idx);
1828     }
1829   }
1830   st-&gt;print(&quot;]] &quot;);
1831 }
1832 
1833 //----------------------------collect_nodes_i----------------------------------
1834 // Collects nodes from an Ideal graph, starting from a given start node and
1835 // moving in a given direction until a certain depth (distance from the start
1836 // node) is reached. Duplicates are ignored.
1837 // Arguments:
1838 //   nstack:        the nodes are collected into this array.
1839 //   start:         the node at which to start collecting.
1840 //   direction:     if this is a positive number, collect input nodes; if it is
1841 //                  a negative number, collect output nodes.
1842 //   depth:         collect nodes up to this distance from the start node.
1843 //   include_start: whether to include the start node in the result collection.
1844 //   only_ctrl:     whether to regard control edges only during traversal.
1845 //   only_data:     whether to regard data edges only during traversal.
1846 static void collect_nodes_i(GrowableArray&lt;Node*&gt; *nstack, const Node* start, int direction, uint depth, bool include_start, bool only_ctrl, bool only_data) {
1847   Node* s = (Node*) start; // remove const
1848   nstack-&gt;append(s);
1849   int begin = 0;
1850   int end = 0;
1851   for(uint i = 0; i &lt; depth; i++) {
1852     end = nstack-&gt;length();
1853     for(int j = begin; j &lt; end; j++) {
1854       Node* tp  = nstack-&gt;at(j);
1855       uint limit = direction &gt; 0 ? tp-&gt;len() : tp-&gt;outcnt();
1856       for(uint k = 0; k &lt; limit; k++) {
1857         Node* n = direction &gt; 0 ? tp-&gt;in(k) : tp-&gt;raw_out(k);
1858 
1859         if (NotANode(n))  continue;
1860         // do not recurse through top or the root (would reach unrelated stuff)
1861         if (n-&gt;is_Root() || n-&gt;is_top()) continue;
1862         if (only_ctrl &amp;&amp; !n-&gt;is_CFG()) continue;
1863         if (only_data &amp;&amp; n-&gt;is_CFG()) continue;
1864 
1865         bool on_stack = nstack-&gt;contains(n);
1866         if (!on_stack) {
1867           nstack-&gt;append(n);
1868         }
1869       }
1870     }
1871     begin = end;
1872   }
1873   if (!include_start) {
1874     nstack-&gt;remove(s);
1875   }
1876 }
1877 
1878 //------------------------------dump_nodes-------------------------------------
1879 static void dump_nodes(const Node* start, int d, bool only_ctrl) {
1880   if (NotANode(start)) return;
1881 
1882   GrowableArray &lt;Node *&gt; nstack(Compile::current()-&gt;live_nodes());
1883   collect_nodes_i(&amp;nstack, start, d, (uint) ABS(d), true, only_ctrl, false);
1884 
1885   int end = nstack.length();
1886   if (d &gt; 0) {
1887     for(int j = end-1; j &gt;= 0; j--) {
1888       nstack.at(j)-&gt;dump();
1889     }
1890   } else {
1891     for(int j = 0; j &lt; end; j++) {
1892       nstack.at(j)-&gt;dump();
1893     }
1894   }
1895 }
1896 
1897 //------------------------------dump-------------------------------------------
1898 void Node::dump(int d) const {
1899   dump_nodes(this, d, false);
1900 }
1901 
1902 //------------------------------dump_ctrl--------------------------------------
1903 // Dump a Node&#39;s control history to depth
1904 void Node::dump_ctrl(int d) const {
1905   dump_nodes(this, d, true);
1906 }
1907 
1908 //-----------------------------dump_compact------------------------------------
1909 void Node::dump_comp() const {
1910   this-&gt;dump_comp(&quot;\n&quot;);
1911 }
1912 
1913 //-----------------------------dump_compact------------------------------------
1914 // Dump a Node in compact representation, i.e., just print its name and index.
1915 // Nodes can specify additional specifics to print in compact representation by
1916 // implementing dump_compact_spec.
1917 void Node::dump_comp(const char* suffix, outputStream *st) const {
1918   Compile* C = Compile::current();
1919   C-&gt;_in_dump_cnt++;
1920   st-&gt;print(&quot;%s(%d)&quot;, Name(), _idx);
1921   this-&gt;dump_compact_spec(st);
1922   if (suffix) {
1923     st-&gt;print(&quot;%s&quot;, suffix);
1924   }
1925   C-&gt;_in_dump_cnt--;
1926 }
1927 
1928 //----------------------------dump_related-------------------------------------
1929 // Dump a Node&#39;s related nodes - the notion of &quot;related&quot; depends on the Node at
1930 // hand and is determined by the implementation of the virtual method rel.
1931 void Node::dump_related() const {
1932   Compile* C = Compile::current();
1933   GrowableArray &lt;Node *&gt; in_rel(C-&gt;unique());
1934   GrowableArray &lt;Node *&gt; out_rel(C-&gt;unique());
1935   this-&gt;related(&amp;in_rel, &amp;out_rel, false);
1936   for (int i = in_rel.length() - 1; i &gt;= 0; i--) {
1937     in_rel.at(i)-&gt;dump();
1938   }
1939   this-&gt;dump(&quot;\n&quot;, true);
1940   for (int i = 0; i &lt; out_rel.length(); i++) {
1941     out_rel.at(i)-&gt;dump();
1942   }
1943 }
1944 
1945 //----------------------------dump_related-------------------------------------
1946 // Dump a Node&#39;s related nodes up to a given depth (distance from the start
1947 // node).
1948 // Arguments:
1949 //   d_in:  depth for input nodes.
1950 //   d_out: depth for output nodes (note: this also is a positive number).
1951 void Node::dump_related(uint d_in, uint d_out) const {
1952   Compile* C = Compile::current();
1953   GrowableArray &lt;Node *&gt; in_rel(C-&gt;unique());
1954   GrowableArray &lt;Node *&gt; out_rel(C-&gt;unique());
1955 
1956   // call collect_nodes_i directly
1957   collect_nodes_i(&amp;in_rel, this, 1, d_in, false, false, false);
1958   collect_nodes_i(&amp;out_rel, this, -1, d_out, false, false, false);
1959 
1960   for (int i = in_rel.length() - 1; i &gt;= 0; i--) {
1961     in_rel.at(i)-&gt;dump();
1962   }
1963   this-&gt;dump(&quot;\n&quot;, true);
1964   for (int i = 0; i &lt; out_rel.length(); i++) {
1965     out_rel.at(i)-&gt;dump();
1966   }
1967 }
1968 
1969 //------------------------dump_related_compact---------------------------------
1970 // Dump a Node&#39;s related nodes in compact representation. The notion of
1971 // &quot;related&quot; depends on the Node at hand and is determined by the implementation
1972 // of the virtual method rel.
1973 void Node::dump_related_compact() const {
1974   Compile* C = Compile::current();
1975   GrowableArray &lt;Node *&gt; in_rel(C-&gt;unique());
1976   GrowableArray &lt;Node *&gt; out_rel(C-&gt;unique());
1977   this-&gt;related(&amp;in_rel, &amp;out_rel, true);
1978   int n_in = in_rel.length();
1979   int n_out = out_rel.length();
1980 
1981   this-&gt;dump_comp(n_in == 0 ? &quot;\n&quot; : &quot;  &quot;);
1982   for (int i = 0; i &lt; n_in; i++) {
1983     in_rel.at(i)-&gt;dump_comp(i == n_in - 1 ? &quot;\n&quot; : &quot;  &quot;);
1984   }
1985   for (int i = 0; i &lt; n_out; i++) {
1986     out_rel.at(i)-&gt;dump_comp(i == n_out - 1 ? &quot;\n&quot; : &quot;  &quot;);
1987   }
1988 }
1989 
1990 //------------------------------related----------------------------------------
1991 // Collect a Node&#39;s related nodes. The default behaviour just collects the
1992 // inputs and outputs at depth 1, including both control and data flow edges,
1993 // regardless of whether the presentation is compact or not. For data nodes,
1994 // the default is to collect all data inputs (till level 1 if compact), and
1995 // outputs till level 1.
1996 void Node::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1997   if (this-&gt;is_CFG()) {
1998     collect_nodes_i(in_rel, this, 1, 1, false, false, false);
1999     collect_nodes_i(out_rel, this, -1, 1, false, false, false);
2000   } else {
2001     if (compact) {
2002       this-&gt;collect_nodes(in_rel, 1, false, true);
2003     } else {
2004       this-&gt;collect_nodes_in_all_data(in_rel, false);
2005     }
2006     this-&gt;collect_nodes(out_rel, -1, false, false);
2007   }
2008 }
2009 
2010 //---------------------------collect_nodes-------------------------------------
2011 // An entry point to the low-level node collection facility, to start from a
2012 // given node in the graph. The start node is by default not included in the
2013 // result.
2014 // Arguments:
2015 //   ns:   collect the nodes into this data structure.
2016 //   d:    the depth (distance from start node) to which nodes should be
2017 //         collected. A value &gt;0 indicates input nodes, a value &lt;0, output
2018 //         nodes.
2019 //   ctrl: include only control nodes.
2020 //   data: include only data nodes.
2021 void Node::collect_nodes(GrowableArray&lt;Node*&gt; *ns, int d, bool ctrl, bool data) const {
2022   if (ctrl &amp;&amp; data) {
2023     // ignore nonsensical combination
2024     return;
2025   }
2026   collect_nodes_i(ns, this, d, (uint) ABS(d), false, ctrl, data);
2027 }
2028 
2029 //--------------------------collect_nodes_in-----------------------------------
2030 static void collect_nodes_in(Node* start, GrowableArray&lt;Node*&gt; *ns, bool primary_is_data, bool collect_secondary) {
2031   // The maximum depth is determined using a BFS that visits all primary (data
2032   // or control) inputs and increments the depth at each level.
2033   uint d_in = 0;
2034   GrowableArray&lt;Node*&gt; nodes(Compile::current()-&gt;unique());
2035   nodes.push(start);
2036   int nodes_at_current_level = 1;
2037   int n_idx = 0;
2038   while (nodes_at_current_level &gt; 0) {
2039     // Add all primary inputs reachable from the current level to the list, and
2040     // increase the depth if there were any.
2041     int nodes_at_next_level = 0;
2042     bool nodes_added = false;
2043     while (nodes_at_current_level &gt; 0) {
2044       nodes_at_current_level--;
2045       Node* current = nodes.at(n_idx++);
2046       for (uint i = 0; i &lt; current-&gt;len(); i++) {
2047         Node* n = current-&gt;in(i);
2048         if (NotANode(n)) {
2049           continue;
2050         }
2051         if ((primary_is_data &amp;&amp; n-&gt;is_CFG()) || (!primary_is_data &amp;&amp; !n-&gt;is_CFG())) {
2052           continue;
2053         }
2054         if (!nodes.contains(n)) {
2055           nodes.push(n);
2056           nodes_added = true;
2057           nodes_at_next_level++;
2058         }
2059       }
2060     }
2061     if (nodes_added) {
2062       d_in++;
2063     }
2064     nodes_at_current_level = nodes_at_next_level;
2065   }
2066   start-&gt;collect_nodes(ns, d_in, !primary_is_data, primary_is_data);
2067   if (collect_secondary) {
2068     // Now, iterate over the secondary nodes in ns and add the respective
2069     // boundary reachable from them.
2070     GrowableArray&lt;Node*&gt; sns(Compile::current()-&gt;unique());
2071     for (GrowableArrayIterator&lt;Node*&gt; it = ns-&gt;begin(); it != ns-&gt;end(); ++it) {
2072       Node* n = *it;
2073       n-&gt;collect_nodes(&amp;sns, 1, primary_is_data, !primary_is_data);
2074       for (GrowableArrayIterator&lt;Node*&gt; d = sns.begin(); d != sns.end(); ++d) {
2075         ns-&gt;append_if_missing(*d);
2076       }
2077       sns.clear();
2078     }
2079   }
2080 }
2081 
2082 //---------------------collect_nodes_in_all_data-------------------------------
2083 // Collect the entire data input graph. Include the control boundary if
2084 // requested.
2085 // Arguments:
2086 //   ns:   collect the nodes into this data structure.
2087 //   ctrl: if true, include the control boundary.
2088 void Node::collect_nodes_in_all_data(GrowableArray&lt;Node*&gt; *ns, bool ctrl) const {
2089   collect_nodes_in((Node*) this, ns, true, ctrl);
2090 }
2091 
2092 //--------------------------collect_nodes_in_all_ctrl--------------------------
2093 // Collect the entire control input graph. Include the data boundary if
2094 // requested.
2095 //   ns:   collect the nodes into this data structure.
2096 //   data: if true, include the control boundary.
2097 void Node::collect_nodes_in_all_ctrl(GrowableArray&lt;Node*&gt; *ns, bool data) const {
2098   collect_nodes_in((Node*) this, ns, false, data);
2099 }
2100 
2101 //------------------collect_nodes_out_all_ctrl_boundary------------------------
2102 // Collect the entire output graph until hitting control node boundaries, and
2103 // include those.
2104 void Node::collect_nodes_out_all_ctrl_boundary(GrowableArray&lt;Node*&gt; *ns) const {
2105   // Perform a BFS and stop at control nodes.
2106   GrowableArray&lt;Node*&gt; nodes(Compile::current()-&gt;unique());
2107   nodes.push((Node*) this);
2108   while (nodes.length() &gt; 0) {
2109     Node* current = nodes.pop();
2110     if (NotANode(current)) {
2111       continue;
2112     }
2113     ns-&gt;append_if_missing(current);
2114     if (!current-&gt;is_CFG()) {
2115       for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2116         nodes.push(current-&gt;out(i));
2117       }
2118     }
2119   }
2120   ns-&gt;remove((Node*) this);
2121 }
2122 
2123 // VERIFICATION CODE
2124 // For each input edge to a node (ie - for each Use-Def edge), verify that
2125 // there is a corresponding Def-Use edge.
2126 //------------------------------verify_edges-----------------------------------
2127 void Node::verify_edges(Unique_Node_List &amp;visited) {
2128   uint i, j, idx;
2129   int  cnt;
2130   Node *n;
2131 
2132   // Recursive termination test
2133   if (visited.member(this))  return;
2134   visited.push(this);
2135 
2136   // Walk over all input edges, checking for correspondence
2137   for( i = 0; i &lt; len(); i++ ) {
2138     n = in(i);
2139     if (n != NULL &amp;&amp; !n-&gt;is_top()) {
2140       // Count instances of (Node *)this
2141       cnt = 0;
2142       for (idx = 0; idx &lt; n-&gt;_outcnt; idx++ ) {
2143         if (n-&gt;_out[idx] == (Node *)this)  cnt++;
2144       }
2145       assert( cnt &gt; 0,&quot;Failed to find Def-Use edge.&quot; );
2146       // Check for duplicate edges
2147       // walk the input array downcounting the input edges to n
2148       for( j = 0; j &lt; len(); j++ ) {
2149         if( in(j) == n ) cnt--;
2150       }
2151       assert( cnt == 0,&quot;Mismatched edge count.&quot;);
2152     } else if (n == NULL) {
<a name="4" id="anc4"></a><span class="line-modified">2153       assert(i &gt;= req() || i == 0 || is_Region() || is_Phi() || is_ArrayCopy() ||</span>
<span class="line-modified">2154              (is_Allocate() &amp;&amp; i &gt;= AllocateNode::InlineTypeNode) ||</span>
<span class="line-added">2155              (is_Unlock() &amp;&amp; i == req()-1),</span>
<span class="line-added">2156              &quot;only region, phi, arraycopy, allocate or unlock nodes have null data edges&quot;);</span>
2157     } else {
2158       assert(n-&gt;is_top(), &quot;sanity&quot;);
2159       // Nothing to check.
2160     }
2161   }
2162   // Recursive walk over all input edges
2163   for( i = 0; i &lt; len(); i++ ) {
2164     n = in(i);
2165     if( n != NULL )
2166       in(i)-&gt;verify_edges(visited);
2167   }
2168 }
2169 
2170 // Verify all nodes if verify_depth is negative
2171 void Node::verify(Node* n, int verify_depth) {
2172   assert(verify_depth != 0, &quot;depth should not be 0&quot;);
2173   ResourceMark rm;
2174   VectorSet old_space;
2175   VectorSet new_space;
2176   Node_List worklist;
2177   worklist.push(n);
2178   Compile* C = Compile::current();
2179   uint last_index_on_current_depth = 0;
2180   verify_depth--; // Visiting the first node on depth 1
2181   // Only add nodes to worklist if verify_depth is negative (visit all nodes) or greater than 0
2182   bool add_to_worklist = verify_depth != 0;
2183 
2184 
2185   for (uint list_index = 0; list_index &lt; worklist.size(); list_index++) {
2186     n = worklist[list_index];
2187 
2188     if (n-&gt;is_Con() &amp;&amp; n-&gt;bottom_type() == Type::TOP) {
2189       if (C-&gt;cached_top_node() == NULL) {
2190         C-&gt;set_cached_top_node((Node*)n);
2191       }
2192       assert(C-&gt;cached_top_node() == n, &quot;TOP node must be unique&quot;);
2193     }
2194 
2195     for (uint i = 0; i &lt; n-&gt;len(); i++) {
2196       Node* x = n-&gt;in(i);
2197       if (!x || x-&gt;is_top()) {
2198         continue;
2199       }
2200 
2201       // Verify my input has a def-use edge to me
2202       // Count use-def edges from n to x
2203       int cnt = 0;
2204       for (uint j = 0; j &lt; n-&gt;len(); j++) {
2205         if (n-&gt;in(j) == x) {
2206           cnt++;
2207         }
2208       }
2209 
2210       // Count def-use edges from x to n
2211       uint max = x-&gt;_outcnt;
2212       for (uint k = 0; k &lt; max; k++) {
2213         if (x-&gt;_out[k] == n) {
2214           cnt--;
2215         }
2216       }
2217       assert(cnt == 0, &quot;mismatched def-use edge counts&quot;);
2218 
2219       // Contained in new_space or old_space?
2220       VectorSet* v = C-&gt;node_arena()-&gt;contains(x) ? &amp;new_space : &amp;old_space;
2221       // Check for visited in the proper space. Numberings are not unique
2222       // across spaces so we need a separate VectorSet for each space.
2223       if (add_to_worklist &amp;&amp; !v-&gt;test_set(x-&gt;_idx)) {
2224         worklist.push(x);
2225       }
2226     }
2227 
2228     if (verify_depth &gt; 0 &amp;&amp; list_index == last_index_on_current_depth) {
2229       // All nodes on this depth were processed and its inputs are on the worklist. Decrement verify_depth and
2230       // store the current last list index which is the last node in the list with the new depth. All nodes
2231       // added afterwards will have a new depth again. Stop adding new nodes if depth limit is reached (=0).
2232       verify_depth--;
2233       if (verify_depth == 0) {
2234         add_to_worklist = false;
2235       }
2236       last_index_on_current_depth = worklist.size() - 1;
2237     }
2238   }
2239 }
2240 #endif
2241 
2242 //------------------------------walk-------------------------------------------
2243 // Graph walk, with both pre-order and post-order functions
2244 void Node::walk(NFunc pre, NFunc post, void *env) {
2245   VectorSet visited; // Setup for local walk
2246   walk_(pre, post, env, visited);
2247 }
2248 
2249 void Node::walk_(NFunc pre, NFunc post, void *env, VectorSet &amp;visited) {
2250   if( visited.test_set(_idx) ) return;
2251   pre(*this,env);               // Call the pre-order walk function
2252   for( uint i=0; i&lt;_max; i++ )
2253     if( in(i) )                 // Input exists and is not walked?
2254       in(i)-&gt;walk_(pre,post,env,visited); // Walk it with pre &amp; post functions
2255   post(*this,env);              // Call the post-order walk function
2256 }
2257 
2258 void Node::nop(Node &amp;, void*) {}
2259 
2260 //------------------------------Registers--------------------------------------
2261 // Do we Match on this edge index or not?  Generally false for Control
2262 // and true for everything else.  Weird for calls &amp; returns.
2263 uint Node::match_edge(uint idx) const {
2264   return idx;                   // True for other than index 0 (control)
2265 }
2266 
2267 static RegMask _not_used_at_all;
2268 // Register classes are defined for specific machines
2269 const RegMask &amp;Node::out_RegMask() const {
2270   ShouldNotCallThis();
2271   return _not_used_at_all;
2272 }
2273 
2274 const RegMask &amp;Node::in_RegMask(uint) const {
2275   ShouldNotCallThis();
2276   return _not_used_at_all;
2277 }
2278 
2279 //=============================================================================
2280 //-----------------------------------------------------------------------------
2281 void Node_Array::reset( Arena *new_arena ) {
2282   _a-&gt;Afree(_nodes,_max*sizeof(Node*));
2283   _max   = 0;
2284   _nodes = NULL;
2285   _a     = new_arena;
2286 }
2287 
2288 //------------------------------clear------------------------------------------
2289 // Clear all entries in _nodes to NULL but keep storage
2290 void Node_Array::clear() {
2291   Copy::zero_to_bytes( _nodes, _max*sizeof(Node*) );
2292 }
2293 
2294 //-----------------------------------------------------------------------------
2295 void Node_Array::grow( uint i ) {
2296   if( !_max ) {
2297     _max = 1;
2298     _nodes = (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
2299     _nodes[0] = NULL;
2300   }
2301   uint old = _max;
2302   _max = next_power_of_2(i);
2303   _nodes = (Node**)_a-&gt;Arealloc( _nodes, old*sizeof(Node*),_max*sizeof(Node*));
2304   Copy::zero_to_bytes( &amp;_nodes[old], (_max-old)*sizeof(Node*) );
2305 }
2306 
2307 //-----------------------------------------------------------------------------
2308 void Node_Array::insert( uint i, Node *n ) {
2309   if( _nodes[_max-1] ) grow(_max);      // Get more space if full
2310   Copy::conjoint_words_to_higher((HeapWord*)&amp;_nodes[i], (HeapWord*)&amp;_nodes[i+1], ((_max-i-1)*sizeof(Node*)));
2311   _nodes[i] = n;
2312 }
2313 
2314 //-----------------------------------------------------------------------------
2315 void Node_Array::remove( uint i ) {
2316   Copy::conjoint_words_to_lower((HeapWord*)&amp;_nodes[i+1], (HeapWord*)&amp;_nodes[i], ((_max-i-1)*sizeof(Node*)));
2317   _nodes[_max-1] = NULL;
2318 }
2319 
2320 //-----------------------------------------------------------------------------
2321 void Node_Array::sort( C_sort_func_t func) {
2322   qsort( _nodes, _max, sizeof( Node* ), func );
2323 }
2324 
2325 //-----------------------------------------------------------------------------
2326 void Node_Array::dump() const {
2327 #ifndef PRODUCT
2328   for( uint i = 0; i &lt; _max; i++ ) {
2329     Node *nn = _nodes[i];
2330     if( nn != NULL ) {
2331       tty-&gt;print(&quot;%5d--&gt; &quot;,i); nn-&gt;dump();
2332     }
2333   }
2334 #endif
2335 }
2336 
2337 //--------------------------is_iteratively_computed------------------------------
2338 // Operation appears to be iteratively computed (such as an induction variable)
2339 // It is possible for this operation to return false for a loop-varying
2340 // value, if it appears (by local graph inspection) to be computed by a simple conditional.
2341 bool Node::is_iteratively_computed() {
2342   if (ideal_reg()) { // does operation have a result register?
2343     for (uint i = 1; i &lt; req(); i++) {
2344       Node* n = in(i);
2345       if (n != NULL &amp;&amp; n-&gt;is_Phi()) {
2346         for (uint j = 1; j &lt; n-&gt;req(); j++) {
2347           if (n-&gt;in(j) == this) {
2348             return true;
2349           }
2350         }
2351       }
2352     }
2353   }
2354   return false;
2355 }
2356 
2357 //--------------------------find_similar------------------------------
2358 // Return a node with opcode &quot;opc&quot; and same inputs as &quot;this&quot; if one can
2359 // be found; Otherwise return NULL;
2360 Node* Node::find_similar(int opc) {
2361   if (req() &gt;= 2) {
2362     Node* def = in(1);
2363     if (def &amp;&amp; def-&gt;outcnt() &gt;= 2) {
2364       for (DUIterator_Fast dmax, i = def-&gt;fast_outs(dmax); i &lt; dmax; i++) {
2365         Node* use = def-&gt;fast_out(i);
2366         if (use != this &amp;&amp;
2367             use-&gt;Opcode() == opc &amp;&amp;
2368             use-&gt;req() == req()) {
2369           uint j;
2370           for (j = 0; j &lt; use-&gt;req(); j++) {
2371             if (use-&gt;in(j) != in(j)) {
2372               break;
2373             }
2374           }
2375           if (j == use-&gt;req()) {
2376             return use;
2377           }
2378         }
2379       }
2380     }
2381   }
2382   return NULL;
2383 }
2384 
2385 
2386 //--------------------------unique_ctrl_out------------------------------
2387 // Return the unique control out if only one. Null if none or more than one.
2388 Node* Node::unique_ctrl_out() const {
2389   Node* found = NULL;
2390   for (uint i = 0; i &lt; outcnt(); i++) {
2391     Node* use = raw_out(i);
2392     if (use-&gt;is_CFG() &amp;&amp; use != this) {
2393       if (found != NULL) return NULL;
2394       found = use;
2395     }
2396   }
2397   return found;
2398 }
2399 
2400 void Node::ensure_control_or_add_prec(Node* c) {
2401   if (in(0) == NULL) {
2402     set_req(0, c);
2403   } else if (in(0) != c) {
2404     add_prec(c);
2405   }
2406 }
2407 
2408 //=============================================================================
2409 //------------------------------yank-------------------------------------------
2410 // Find and remove
2411 void Node_List::yank( Node *n ) {
2412   uint i;
2413   for( i = 0; i &lt; _cnt; i++ )
2414     if( _nodes[i] == n )
2415       break;
2416 
2417   if( i &lt; _cnt )
2418     _nodes[i] = _nodes[--_cnt];
2419 }
2420 
2421 //------------------------------dump-------------------------------------------
2422 void Node_List::dump() const {
2423 #ifndef PRODUCT
2424   for( uint i = 0; i &lt; _cnt; i++ )
2425     if( _nodes[i] ) {
2426       tty-&gt;print(&quot;%5d--&gt; &quot;,i);
2427       _nodes[i]-&gt;dump();
2428     }
2429 #endif
2430 }
2431 
2432 void Node_List::dump_simple() const {
2433 #ifndef PRODUCT
2434   for( uint i = 0; i &lt; _cnt; i++ )
2435     if( _nodes[i] ) {
2436       tty-&gt;print(&quot; %d&quot;, _nodes[i]-&gt;_idx);
2437     } else {
2438       tty-&gt;print(&quot; NULL&quot;);
2439     }
2440 #endif
2441 }
2442 
2443 //=============================================================================
2444 //------------------------------remove-----------------------------------------
2445 void Unique_Node_List::remove(Node* n) {
2446   if (_in_worklist.test(n-&gt;_idx)) {
2447     for (uint i = 0; i &lt; size(); i++) {
2448       if (_nodes[i] == n) {
2449         map(i, Node_List::pop());
2450         _in_worklist.remove(n-&gt;_idx);
2451         return;
2452       }
2453     }
2454     ShouldNotReachHere();
2455   }
2456 }
2457 
2458 //-----------------------remove_useless_nodes----------------------------------
2459 // Remove useless nodes from worklist
2460 void Unique_Node_List::remove_useless_nodes(VectorSet &amp;useful) {
2461 
2462   for (uint i = 0; i &lt; size(); ++i) {
2463     Node *n = at(i);
2464     assert( n != NULL, &quot;Did not expect null entries in worklist&quot;);
2465     if (!useful.test(n-&gt;_idx)) {
2466       _in_worklist.remove(n-&gt;_idx);
2467       map(i,Node_List::pop());
2468       // Node *replacement = Node_List::pop();
2469       // if( i != size() ) { // Check if removing last entry
2470       //   _nodes[i] = replacement;
2471       // }
2472       --i;  // Visit popped node
2473       // If it was last entry, loop terminates since size() was also reduced
2474     }
2475   }
2476 }
2477 
2478 //=============================================================================
2479 void Node_Stack::grow() {
2480   size_t old_top = pointer_delta(_inode_top,_inodes,sizeof(INode)); // save _top
2481   size_t old_max = pointer_delta(_inode_max,_inodes,sizeof(INode));
2482   size_t max = old_max &lt;&lt; 1;             // max * 2
2483   _inodes = REALLOC_ARENA_ARRAY(_a, INode, _inodes, old_max, max);
2484   _inode_max = _inodes + max;
2485   _inode_top = _inodes + old_top;        // restore _top
2486 }
2487 
2488 // Node_Stack is used to map nodes.
2489 Node* Node_Stack::find(uint idx) const {
2490   uint sz = size();
2491   for (uint i=0; i &lt; sz; i++) {
2492     if (idx == index_at(i) )
2493       return node_at(i);
2494   }
2495   return NULL;
2496 }
2497 
2498 //=============================================================================
2499 uint TypeNode::size_of() const { return sizeof(*this); }
2500 #ifndef PRODUCT
2501 void TypeNode::dump_spec(outputStream *st) const {
2502   if( !Verbose &amp;&amp; !WizardMode ) {
2503     // standard dump does this in Verbose and WizardMode
2504     st-&gt;print(&quot; #&quot;); _type-&gt;dump_on(st);
2505   }
2506 }
2507 
2508 void TypeNode::dump_compact_spec(outputStream *st) const {
2509   st-&gt;print(&quot;#&quot;);
2510   _type-&gt;dump_on(st);
2511 }
2512 #endif
2513 uint TypeNode::hash() const {
2514   return Node::hash() + _type-&gt;hash();
2515 }
2516 bool TypeNode::cmp( const Node &amp;n ) const
2517 { return !Type::cmp( _type, ((TypeNode&amp;)n)._type ); }
2518 const Type *TypeNode::bottom_type() const { return _type; }
2519 const Type* TypeNode::Value(PhaseGVN* phase) const { return _type; }
2520 
2521 //------------------------------ideal_reg--------------------------------------
2522 uint TypeNode::ideal_reg() const {
2523   return _type-&gt;ideal_reg();
2524 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>