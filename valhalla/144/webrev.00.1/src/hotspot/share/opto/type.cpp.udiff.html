<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subnode.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -21,10 +21,13 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-added">+ #include &quot;ci/ciFlatArrayKlass.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;ci/ciField.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;ci/ciInlineKlass.hpp&quot;</span>
  #include &quot;ci/ciMethodData.hpp&quot;
  #include &quot;ci/ciTypeFlow.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;compiler/compileLog.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -45,10 +48,56 @@</span>
  
  // Optimization - Graph Style
  
  // Dictionary of types shared among compilations.
  Dict* Type::_shared_type_dict = NULL;
<span class="udiff-line-added">+ const Type::Offset Type::Offset::top(Type::OffsetTop);</span>
<span class="udiff-line-added">+ const Type::Offset Type::Offset::bottom(Type::OffsetBot);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const Type::Offset Type::Offset::meet(const Type::Offset other) const {</span>
<span class="udiff-line-added">+   // Either is &#39;TOP&#39; offset?  Return the other offset!</span>
<span class="udiff-line-added">+   int offset = other._offset;</span>
<span class="udiff-line-added">+   if (_offset == OffsetTop) return Offset(offset);</span>
<span class="udiff-line-added">+   if (offset == OffsetTop) return Offset(_offset);</span>
<span class="udiff-line-added">+   // If either is different, return &#39;BOTTOM&#39; offset</span>
<span class="udiff-line-added">+   if (_offset != offset) return bottom;</span>
<span class="udiff-line-added">+   return Offset(_offset);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const Type::Offset Type::Offset::dual() const {</span>
<span class="udiff-line-added">+   if (_offset == OffsetTop) return bottom;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;</span>
<span class="udiff-line-added">+   if (_offset == OffsetBot) return top;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;</span>
<span class="udiff-line-added">+   return Offset(_offset);               // Map everything else into self</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const Type::Offset Type::Offset::add(intptr_t offset) const {</span>
<span class="udiff-line-added">+   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!</span>
<span class="udiff-line-added">+   if (_offset == OffsetTop || offset == OffsetTop) return top;</span>
<span class="udiff-line-added">+   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!</span>
<span class="udiff-line-added">+   if (_offset == OffsetBot || offset == OffsetBot) return bottom;</span>
<span class="udiff-line-added">+   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!</span>
<span class="udiff-line-added">+   offset += (intptr_t)_offset;</span>
<span class="udiff-line-added">+   if (offset != (int)offset || offset == OffsetTop) return bottom;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );</span>
<span class="udiff-line-added">+   // It is possible to construct a negative offset during PhaseCCP</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return Offset((int)offset);        // Sum valid offsets</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Type::Offset::dump2(outputStream *st) const {</span>
<span class="udiff-line-added">+   if (_offset == 0) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   } else if (_offset == OffsetTop) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;+top&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   else if (_offset == OffsetBot) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;+bot&quot;);</span>
<span class="udiff-line-added">+   } else if (_offset) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;+%d&quot;, _offset);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  // Array which maps compiler types to Basic Types
  const Type::TypeInfo Type::_type_info[Type::lastype] = {
    { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
    { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -78,10 +127,11 @@</span>
    { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
    { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
    { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
    { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  #endif
<span class="udiff-line-added">+   { Bad,             T_INLINE_TYPE, &quot;inline:&quot;,      false, Node::NotAMachineReg, relocInfo::none          },  // InlineType</span>
    { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
    { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
    { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
    { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
    { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -208,10 +258,19 @@</span>
  
    case T_ADDRESS:
      assert(type-&gt;is_return_address(), &quot;&quot;);
      return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
  
<span class="udiff-line-added">+   case T_INLINE_TYPE: {</span>
<span class="udiff-line-added">+     ciInlineKlass* vk = type-&gt;as_inline_klass();</span>
<span class="udiff-line-added">+     if (vk-&gt;is_scalarizable()) {</span>
<span class="udiff-line-added">+       return TypeInlineType::make(vk);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    default:
      // make sure we did not mix up the cases:
      assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
      assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
      assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -236,10 +295,11 @@</span>
      case T_INT:      return TypeInt::make(constant.as_int());
      case T_LONG:     return TypeLong::make(constant.as_long());
      case T_FLOAT:    return TypeF::make(constant.as_float());
      case T_DOUBLE:   return TypeD::make(constant.as_double());
      case T_ARRAY:
<span class="udiff-line-added">+     case T_INLINE_TYPE:</span>
      case T_OBJECT: {
          const Type* con_type = NULL;
          ciObject* oop_constant = constant.as_object();
          if (oop_constant-&gt;is_null_object()) {
            con_type = Type::get_zero_type(T_OBJECT);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -273,16 +333,18 @@</span>
  static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
    BasicType conbt = con.basic_type();
    switch (conbt) {
      case T_BOOLEAN: conbt = T_BYTE;   break;
      case T_ARRAY:   conbt = T_OBJECT; break;
<span class="udiff-line-added">+     case T_INLINE_TYPE: conbt = T_OBJECT; break;</span>
      default:                          break;
    }
    switch (loadbt) {
      case T_BOOLEAN:   loadbt = T_BYTE;   break;
      case T_NARROWOOP: loadbt = T_OBJECT; break;
      case T_ARRAY:     loadbt = T_OBJECT; break;
<span class="udiff-line-added">+     case T_INLINE_TYPE: loadbt = T_OBJECT; break;</span>
      case T_ADDRESS:   loadbt = T_OBJECT; break;
      default:                             break;
    }
    if (conbt == loadbt) {
      if (is_unsigned &amp;&amp; conbt == T_BYTE) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -506,13 +568,13 @@</span>
    const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
    floop[0] = Type::CONTROL;
    floop[1] = TypeInt::INT;
    TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
  
<span class="udiff-line-modified-removed">-   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, 0);</span>
<span class="udiff-line-modified-removed">-   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, OffsetBot);</span>
<span class="udiff-line-modified-removed">-   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, OffsetBot);</span>
<span class="udiff-line-modified-added">+   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));</span>
<span class="udiff-line-modified-added">+   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);</span>
<span class="udiff-line-modified-added">+   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);</span>
  
    TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
    TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
  
    const Type **fmembar = TypeTuple::fields(0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -525,16 +587,18 @@</span>
  
    TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
    TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
    TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
    TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="udiff-line-modified-removed">-                                            false, 0, oopDesc::mark_offset_in_bytes());</span>
<span class="udiff-line-modified-added">+                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);</span>
    TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="udiff-line-modified-removed">-                                            false, 0, oopDesc::klass_offset_in_bytes());</span>
<span class="udiff-line-modified-removed">-   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, OffsetBot, TypeOopPtr::InstanceBot);</span>
<span class="udiff-line-modified-added">+                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);</span>
<span class="udiff-line-modified-added">+   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);</span>
  
<span class="udiff-line-modified-removed">-   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);</span>
<span class="udiff-line-modified-added">+   TypeInlineType::BOTTOM = TypeInlineType::make(NULL);</span>
  
    TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
    TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
  
    TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -547,47 +611,49 @@</span>
    mreg2type[Op_RegF] = Type::FLOAT;
    mreg2type[Op_RegD] = Type::DOUBLE;
    mreg2type[Op_RegL] = TypeLong::LONG;
    mreg2type[Op_RegFlags] = TypeInt::CC;
  
<span class="udiff-line-modified-removed">-   TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, arrayOopDesc::length_offset_in_bytes());</span>
<span class="udiff-line-modified-added">+   TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, Offset(arrayOopDesc::length_offset_in_bytes()));</span>
  
<span class="udiff-line-modified-removed">-   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);</span>
<span class="udiff-line-modified-added">+   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);</span>
  
  #ifdef _LP64
    if (UseCompressedOops) {
      assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
      TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
    } else
  #endif
    {
      // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
<span class="udiff-line-modified-removed">-     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);</span>
<span class="udiff-line-modified-added">+     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);</span>
    }
<span class="udiff-line-modified-removed">-   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Type::OffsetBot);</span>
<span class="udiff-line-modified-removed">-   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Type::OffsetBot);</span>
<span class="udiff-line-modified-removed">-   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Type::OffsetBot);</span>
<span class="udiff-line-modified-removed">-   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Type::OffsetBot);</span>
<span class="udiff-line-modified-removed">-   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Type::OffsetBot);</span>
<span class="udiff-line-modified-removed">-   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Type::OffsetBot);</span>
<span class="udiff-line-modified-removed">-   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Type::OffsetBot);</span>
<span class="udiff-line-modified-added">+   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);</span>
<span class="udiff-line-modified-added">+   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);</span>
<span class="udiff-line-modified-added">+   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);</span>
<span class="udiff-line-modified-added">+   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);</span>
<span class="udiff-line-modified-added">+   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);</span>
<span class="udiff-line-modified-added">+   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);</span>
<span class="udiff-line-modified-added">+   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);</span>
<span class="udiff-line-added">+   TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInlineType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);</span>
  
    // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
    TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
    TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
<span class="udiff-line-added">+   TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;</span>
    TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
    TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
    TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
    TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
    TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
    TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
    TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
    TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
    TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
  
<span class="udiff-line-modified-removed">-   TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), 0 );</span>
<span class="udiff-line-modified-removed">-   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), 0 );</span>
<span class="udiff-line-modified-added">+   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);</span>
<span class="udiff-line-modified-added">+   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);</span>
  
    const Type **fi2c = TypeTuple::fields(2);
    fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
    fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
    TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -622,10 +688,11 @@</span>
    _const_basic_type[T_LONG]        = TypeLong::LONG;
    _const_basic_type[T_FLOAT]       = Type::FLOAT;
    _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
    _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
    _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
<span class="udiff-line-added">+   _const_basic_type[T_INLINE_TYPE] = TypeInstPtr::BOTTOM;</span>
    _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
    _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
    _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
  
    _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -638,10 +705,11 @@</span>
    _zero_type[T_LONG]        = TypeLong::ZERO;
    _zero_type[T_FLOAT]       = TypeF::ZERO;
    _zero_type[T_DOUBLE]      = TypeD::ZERO;
    _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
    _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
<span class="udiff-line-added">+   _zero_type[T_INLINE_TYPE] = TypePtr::NULL_PTR;</span>
    _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
    _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
  
    // get_zero_type() should not happen for T_CONFLICT
    _zero_type[T_CONFLICT]= NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -813,11 +881,11 @@</span>
  
    // Interface meet Oop is Not Symmetric:
    // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
    // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
  
<span class="udiff-line-modified-removed">-   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual) ) {</span>
<span class="udiff-line-modified-added">+   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual)) {</span>
      tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
      tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
      tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
      tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -917,10 +985,13 @@</span>
      return t-&gt;xmeet(this);
  
    case NarrowKlass:
      return t-&gt;xmeet(this);
  
<span class="udiff-line-added">+   case InlineType:</span>
<span class="udiff-line-added">+     return t-&gt;xmeet(this);</span>
<span class="udiff-line-added">+ </span>
    case Bad:                     // Type check
    default:                      // Bogus type not in lattice
      typerr(t);
      return Type::BOTTOM;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -984,10 +1055,11 @@</span>
    Bad,          // VectorS - handled in v-call
    Bad,          // VectorD - handled in v-call
    Bad,          // VectorX - handled in v-call
    Bad,          // VectorY - handled in v-call
    Bad,          // VectorZ - handled in v-call
<span class="udiff-line-added">+   Bad,          // InlineType - handled in v-call</span>
  
    Bad,          // AnyPtr - handled in v-call
    Bad,          // RawPtr - handled in v-call
    Bad,          // OopPtr - handled in v-call
    Bad,          // InstPtr - handled in v-call
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1879,16 +1951,38 @@</span>
  const TypeTuple *TypeTuple::INT_PAIR;
  const TypeTuple *TypeTuple::LONG_PAIR;
  const TypeTuple *TypeTuple::INT_CC_PAIR;
  const TypeTuple *TypeTuple::LONG_CC_PAIR;
  
<span class="udiff-line-added">+ static void collect_inline_fields(ciInlineKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {</span>
<span class="udiff-line-added">+   for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {</span>
<span class="udiff-line-added">+     ciField* field = vk-&gt;nonstatic_field_at(j);</span>
<span class="udiff-line-added">+     BasicType bt = field-&gt;type()-&gt;basic_type();</span>
<span class="udiff-line-added">+     const Type* ft = Type::get_const_type(field-&gt;type());</span>
<span class="udiff-line-added">+     field_array[pos++] = ft;</span>
<span class="udiff-line-added">+     if (type2size[bt] == 2) {</span>
<span class="udiff-line-added">+       field_array[pos++] = Type::HALF;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // Skip reserved arguments</span>
<span class="udiff-line-added">+     while (SigEntry::next_is_reserved(sig_cc, bt)) {</span>
<span class="udiff-line-added">+       field_array[pos++] = Type::get_const_basic_type(bt);</span>
<span class="udiff-line-added">+       if (type2size[bt] == 2) {</span>
<span class="udiff-line-added">+         field_array[pos++] = Type::HALF;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  //------------------------------make-------------------------------------------
  // Make a TypeTuple from the range of a method signature
<span class="udiff-line-modified-removed">- const TypeTuple *TypeTuple::make_range(ciSignature* sig) {</span>
<span class="udiff-line-modified-added">+ const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {</span>
    ciType* return_type = sig-&gt;return_type();
    uint arg_cnt = return_type-&gt;size();
<span class="udiff-line-added">+   if (ret_vt_fields) {</span>
<span class="udiff-line-added">+     arg_cnt = return_type-&gt;as_inline_klass()-&gt;inline_arg_slots() + 1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    const Type **field_array = fields(arg_cnt);
    switch (return_type-&gt;basic_type()) {
    case T_LONG:
      field_array[TypeFunc::Parms]   = TypeLong::LONG;
      field_array[TypeFunc::Parms+1] = Type::HALF;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1905,38 +1999,63 @@</span>
    case T_BYTE:
    case T_SHORT:
    case T_INT:
      field_array[TypeFunc::Parms] = get_const_type(return_type);
      break;
<span class="udiff-line-added">+   case T_INLINE_TYPE:</span>
<span class="udiff-line-added">+     if (ret_vt_fields) {</span>
<span class="udiff-line-added">+       uint pos = TypeFunc::Parms;</span>
<span class="udiff-line-added">+       field_array[pos] = TypePtr::BOTTOM;</span>
<span class="udiff-line-added">+       pos++;</span>
<span class="udiff-line-added">+       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());</span>
<span class="udiff-line-added">+       collect_inline_fields(return_type-&gt;as_inline_klass(), field_array, pos, sig);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     break;</span>
    case T_VOID:
      break;
    default:
      ShouldNotReachHere();
    }
    return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
  }
  
  // Make a TypeTuple from the domain of a method signature
<span class="udiff-line-modified-removed">- const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {</span>
<span class="udiff-line-modified-removed">-   uint arg_cnt = sig-&gt;size();</span>
<span class="udiff-line-modified-added">+ const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {</span>
<span class="udiff-line-modified-added">+   ciSignature* sig = method-&gt;signature();</span>
<span class="udiff-line-added">+   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);</span>
<span class="udiff-line-added">+   if (vt_fields_as_args) {</span>
<span class="udiff-line-added">+     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {</span>
<span class="udiff-line-added">+       arg_cnt += type2size[(*sig_cc)._bt];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());</span>
<span class="udiff-line-added">+   }</span>
  
    uint pos = TypeFunc::Parms;
<span class="udiff-line-modified-removed">-   const Type **field_array;</span>
<span class="udiff-line-modified-removed">-   if (recv != NULL) {</span>
<span class="udiff-line-modified-removed">-     arg_cnt++;</span>
<span class="udiff-line-modified-removed">-     field_array = fields(arg_cnt);</span>
<span class="udiff-line-modified-removed">-     // Use get_const_type here because it respects UseUniqueSubclasses:</span>
<span class="udiff-line-modified-removed">-     field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     field_array = fields(arg_cnt);</span>
<span class="udiff-line-modified-added">+   const Type** field_array = fields(arg_cnt);</span>
<span class="udiff-line-modified-added">+   if (!method-&gt;is_static()) {</span>
<span class="udiff-line-modified-added">+     ciInstanceKlass* recv = method-&gt;holder();</span>
<span class="udiff-line-modified-added">+     if (vt_fields_as_args &amp;&amp; recv-&gt;is_inlinetype() &amp;&amp; recv-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {</span>
<span class="udiff-line-modified-added">+       collect_inline_fields(recv-&gt;as_inline_klass(), field_array, pos, sig_cc);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="udiff-line-modified-added">+       if (vt_fields_as_args) {</span>
<span class="udiff-line-added">+         ++sig_cc;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
    }
  
    int i = 0;
    while (pos &lt; TypeFunc::Parms + arg_cnt) {
      ciType* type = sig-&gt;type_at(i);
<span class="udiff-line-added">+     BasicType bt = type-&gt;basic_type();</span>
<span class="udiff-line-added">+     bool is_flattened = false;</span>
  
<span class="udiff-line-modified-removed">-     switch (type-&gt;basic_type()) {</span>
<span class="udiff-line-modified-added">+     switch (bt) {</span>
      case T_LONG:
        field_array[pos++] = TypeLong::LONG;
        field_array[pos++] = Type::HALF;
        break;
      case T_DOUBLE:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1953,15 +2072,32 @@</span>
      case T_CHAR:
      case T_BYTE:
      case T_SHORT:
        field_array[pos++] = TypeInt::INT;
        break;
<span class="udiff-line-added">+     case T_INLINE_TYPE: {</span>
<span class="udiff-line-added">+       if (vt_fields_as_args &amp;&amp; type-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {</span>
<span class="udiff-line-added">+         is_flattened = true;</span>
<span class="udiff-line-added">+         collect_inline_fields(type-&gt;as_inline_klass(), field_array, pos, sig_cc);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         field_array[pos++] = get_const_type(type)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
      default:
        ShouldNotReachHere();
      }
<span class="udiff-line-added">+     // Skip reserved arguments</span>
<span class="udiff-line-added">+     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {</span>
<span class="udiff-line-added">+       field_array[pos++] = Type::get_const_basic_type(bt);</span>
<span class="udiff-line-added">+       if (type2size[bt] == 2) {</span>
<span class="udiff-line-added">+         field_array[pos++] = Type::HALF;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
      i++;
    }
<span class="udiff-line-added">+   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);</span>
  
    return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
  }
  
  const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2092,16 +2228,17 @@</span>
    else
      return size;
  }
  
  //------------------------------make-------------------------------------------
<span class="udiff-line-modified-removed">- const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable) {</span>
<span class="udiff-line-modified-added">+ const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable,</span>
<span class="udiff-line-added">+                              bool not_flat, bool not_null_free) {</span>
    if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
      elem = elem-&gt;make_narrowoop();
    }
    size = normalize_array_size(size);
<span class="udiff-line-modified-removed">-   return (TypeAry*)(new TypeAry(elem,size,stable))-&gt;hashcons();</span>
<span class="udiff-line-modified-added">+   return (TypeAry*)(new TypeAry(elem, size, stable, not_flat, not_null_free))-&gt;hashcons();</span>
  }
  
  //------------------------------meet-------------------------------------------
  // Compute the MEET of two types.  It returns a new Type object.
  const Type *TypeAry::xmeet( const Type *t ) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2119,11 +2256,13 @@</span>
  
    case Array: {                 // Meeting 2 arrays?
      const TypeAry *a = t-&gt;is_ary();
      return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
                           _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
<span class="udiff-line-modified-removed">-                          _stable &amp;&amp; a-&gt;_stable);</span>
<span class="udiff-line-modified-added">+                          _stable &amp;&amp; a-&gt;_stable,</span>
<span class="udiff-line-added">+                          _not_flat &amp;&amp; a-&gt;_not_flat,</span>
<span class="udiff-line-added">+                          _not_null_free &amp;&amp; a-&gt;_not_null_free);</span>
    }
    case Top:
      break;
    }
    return this;                  // Return the double constant
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2132,20 +2271,23 @@</span>
  //------------------------------xdual------------------------------------------
  // Dual: compute field-by-field dual
  const Type *TypeAry::xdual() const {
    const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
    size_dual = normalize_array_size(size_dual);
<span class="udiff-line-modified-removed">-   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);</span>
<span class="udiff-line-modified-added">+   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable, !_not_flat, !_not_null_free);</span>
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypeAry::eq( const Type *t ) const {
    const TypeAry *a = (const TypeAry*)t;
    return _elem == a-&gt;_elem &amp;&amp;
      _stable == a-&gt;_stable &amp;&amp;
<span class="udiff-line-modified-removed">-     _size == a-&gt;_size;</span>
<span class="udiff-line-modified-added">+     _size == a-&gt;_size &amp;&amp;</span>
<span class="udiff-line-added">+     _not_flat == a-&gt;_not_flat &amp;&amp;</span>
<span class="udiff-line-added">+     _not_null_free == a-&gt;_not_null_free;</span>
<span class="udiff-line-added">+ </span>
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeAry::hash(void) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2154,18 +2296,18 @@</span>
  
  /**
   * Return same type without a speculative part in the element
   */
  const Type* TypeAry::remove_speculative() const {
<span class="udiff-line-modified-removed">-   return make(_elem-&gt;remove_speculative(), _size, _stable);</span>
<span class="udiff-line-modified-added">+   return make(_elem-&gt;remove_speculative(), _size, _stable, _not_flat, _not_null_free);</span>
  }
  
  /**
   * Return same type with cleaned up speculative part of element
   */
  const Type* TypeAry::cleanup_speculative() const {
<span class="udiff-line-modified-removed">-   return make(_elem-&gt;cleanup_speculative(), _size, _stable);</span>
<span class="udiff-line-modified-added">+   return make(_elem-&gt;cleanup_speculative(), _size, _stable, _not_flat, _not_null_free);</span>
  }
  
  /**
   * Return same type but with a different inline depth (used for speculation)
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2195,10 +2337,14 @@</span>
  
  //------------------------------dump2------------------------------------------
  #ifndef PRODUCT
  void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
    if (_stable)  st-&gt;print(&quot;stable:&quot;);
<span class="udiff-line-added">+   if (Verbose) {</span>
<span class="udiff-line-added">+     if (_not_flat) st-&gt;print(&quot;not flat:&quot;);</span>
<span class="udiff-line-added">+     if (_not_null_free) st-&gt;print(&quot;not null free:&quot;);</span>
<span class="udiff-line-added">+   }</span>
    _elem-&gt;dump2(d, depth, st);
    st-&gt;print(&quot;[&quot;);
    _size-&gt;dump2(d, depth, st);
    st-&gt;print(&quot;]&quot;);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2248,10 +2394,134 @@</span>
    if (tap)
      return tap-&gt;ary()-&gt;ary_must_be_exact();
    return false;
  }
  
<span class="udiff-line-added">+ //==============================TypeInlineType=======================================</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const TypeInlineType* TypeInlineType::BOTTOM;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------make-------------------------------------------</span>
<span class="udiff-line-added">+ const TypeInlineType* TypeInlineType::make(ciInlineKlass* vk, bool larval) {</span>
<span class="udiff-line-added">+   return (TypeInlineType*)(new TypeInlineType(vk, larval))-&gt;hashcons();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------meet-------------------------------------------</span>
<span class="udiff-line-added">+ // Compute the MEET of two types.  It returns a new Type object.</span>
<span class="udiff-line-added">+ const Type* TypeInlineType::xmeet(const Type* t) const {</span>
<span class="udiff-line-added">+   // Perform a fast test for common case; meeting the same types together.</span>
<span class="udiff-line-added">+   if(this == t) return this;  // Meeting same type-rep?</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Current &quot;this-&gt;_base&quot; is InlineType</span>
<span class="udiff-line-added">+   switch (t-&gt;base()) {          // switch on original type</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   case Int:</span>
<span class="udiff-line-added">+   case Long:</span>
<span class="udiff-line-added">+   case FloatTop:</span>
<span class="udiff-line-added">+   case FloatCon:</span>
<span class="udiff-line-added">+   case FloatBot:</span>
<span class="udiff-line-added">+   case DoubleTop:</span>
<span class="udiff-line-added">+   case DoubleCon:</span>
<span class="udiff-line-added">+   case DoubleBot:</span>
<span class="udiff-line-added">+   case NarrowKlass:</span>
<span class="udiff-line-added">+   case Bottom:</span>
<span class="udiff-line-added">+     return Type::BOTTOM;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   case OopPtr:</span>
<span class="udiff-line-added">+   case MetadataPtr:</span>
<span class="udiff-line-added">+   case KlassPtr:</span>
<span class="udiff-line-added">+   case RawPtr:</span>
<span class="udiff-line-added">+     return TypePtr::BOTTOM;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   case Top:</span>
<span class="udiff-line-added">+     return this;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   case NarrowOop: {</span>
<span class="udiff-line-added">+     const Type* res = t-&gt;make_ptr()-&gt;xmeet(this);</span>
<span class="udiff-line-added">+     if (res-&gt;isa_ptr()) {</span>
<span class="udiff-line-added">+       return res-&gt;make_narrowoop();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return res;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   case AryPtr:</span>
<span class="udiff-line-added">+   case InstPtr: {</span>
<span class="udiff-line-added">+     return t-&gt;xmeet(this);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   case InlineType: {</span>
<span class="udiff-line-added">+     // All inline types inherit from Object</span>
<span class="udiff-line-added">+     const TypeInlineType* other = t-&gt;is_inlinetype();</span>
<span class="udiff-line-added">+     if (_vk == NULL) {</span>
<span class="udiff-line-added">+       return this;</span>
<span class="udiff-line-added">+     } else if (other-&gt;_vk == NULL) {</span>
<span class="udiff-line-added">+       return other;</span>
<span class="udiff-line-added">+     } else if (_vk == other-&gt;_vk) {</span>
<span class="udiff-line-added">+       if (_larval == other-&gt;_larval ||</span>
<span class="udiff-line-added">+           !_larval) {</span>
<span class="udiff-line-added">+         return this;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         return t;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return TypeInstPtr::NOTNULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   default:                      // All else is a mistake</span>
<span class="udiff-line-added">+     typerr(t);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return this;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------xdual------------------------------------------</span>
<span class="udiff-line-added">+ const Type* TypeInlineType::xdual() const {</span>
<span class="udiff-line-added">+   return this;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------eq---------------------------------------------</span>
<span class="udiff-line-added">+ // Structural equality check for Type representations</span>
<span class="udiff-line-added">+ bool TypeInlineType::eq(const Type* t) const {</span>
<span class="udiff-line-added">+   const TypeInlineType* vt = t-&gt;is_inlinetype();</span>
<span class="udiff-line-added">+   return (_vk == vt-&gt;inline_klass() &amp;&amp; _larval == vt-&gt;larval());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------hash-------------------------------------------</span>
<span class="udiff-line-added">+ // Type-specific hashing function.</span>
<span class="udiff-line-added">+ int TypeInlineType::hash(void) const {</span>
<span class="udiff-line-added">+   return (intptr_t)_vk;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------singleton--------------------------------------</span>
<span class="udiff-line-added">+ // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.</span>
<span class="udiff-line-added">+ bool TypeInlineType::singleton(void) const {</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------empty------------------------------------------</span>
<span class="udiff-line-added">+ // TRUE if Type is a type with no values, FALSE otherwise.</span>
<span class="udiff-line-added">+ bool TypeInlineType::empty(void) const {</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------dump2------------------------------------------</span>
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
<span class="udiff-line-added">+ void TypeInlineType::dump2(Dict &amp;d, uint depth, outputStream* st) const {</span>
<span class="udiff-line-added">+   if (_vk == NULL) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;BOTTOM inlinetype&quot;);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   int count = _vk-&gt;nof_declared_nonstatic_fields();</span>
<span class="udiff-line-added">+   st-&gt;print(&quot;inlinetype[%d]:{&quot;, count);</span>
<span class="udiff-line-added">+   st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);</span>
<span class="udiff-line-added">+   for (int i = 1; i &lt; count; ++i) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  //==============================TypeVect=======================================
  // Convenience common pre-built types.
  const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
  const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
  const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2389,11 +2659,11 @@</span>
    { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
    { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
  };
  
  //------------------------------make-------------------------------------------
<span class="udiff-line-modified-removed">- const TypePtr *TypePtr::make(TYPES t, enum PTR ptr, int offset, const TypePtr* speculative, int inline_depth) {</span>
<span class="udiff-line-modified-added">+ const TypePtr* TypePtr::make(TYPES t, enum PTR ptr, Offset offset, const TypePtr* speculative, int inline_depth) {</span>
    return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
  }
  
  //------------------------------cast_to_ptr_type-------------------------------
  const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2403,11 +2673,11 @@</span>
  }
  
  //------------------------------get_con----------------------------------------
  intptr_t TypePtr::get_con() const {
    assert( _ptr == Null, &quot;&quot; );
<span class="udiff-line-modified-removed">-   return _offset;</span>
<span class="udiff-line-modified-added">+   return offset();</span>
  }
  
  //------------------------------meet-------------------------------------------
  // Compute the MEET of two types.  It returns a new Type object.
  const Type *TypePtr::xmeet(const Type *t) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2472,24 +2742,17 @@</span>
    }
    return this;
  }
  
  //------------------------------meet_offset------------------------------------
<span class="udiff-line-modified-removed">- int TypePtr::meet_offset( int offset ) const {</span>
<span class="udiff-line-modified-removed">-   // Either is &#39;TOP&#39; offset?  Return the other offset!</span>
<span class="udiff-line-removed">-   if( _offset == OffsetTop ) return offset;</span>
<span class="udiff-line-removed">-   if( offset == OffsetTop ) return _offset;</span>
<span class="udiff-line-removed">-   // If either is different, return &#39;BOTTOM&#39; offset</span>
<span class="udiff-line-removed">-   if( _offset != offset ) return OffsetBot;</span>
<span class="udiff-line-removed">-   return _offset;</span>
<span class="udiff-line-modified-added">+ Type::Offset TypePtr::meet_offset(int offset) const {</span>
<span class="udiff-line-modified-added">+   return _offset.meet(Offset(offset));</span>
  }
  
  //------------------------------dual_offset------------------------------------
<span class="udiff-line-modified-removed">- int TypePtr::dual_offset( ) const {</span>
<span class="udiff-line-modified-removed">-   if( _offset == OffsetTop ) return OffsetBot;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;</span>
<span class="udiff-line-removed">-   if( _offset == OffsetBot ) return OffsetTop;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;</span>
<span class="udiff-line-removed">-   return _offset;               // Map everything else into self</span>
<span class="udiff-line-modified-added">+ Type::Offset TypePtr::dual_offset() const {</span>
<span class="udiff-line-modified-added">+   return _offset.dual();</span>
  }
  
  //------------------------------xdual------------------------------------------
  // Dual: compute field-by-field dual
  const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2498,23 +2761,12 @@</span>
  const Type *TypePtr::xdual() const {
    return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
  }
  
  //------------------------------xadd_offset------------------------------------
<span class="udiff-line-modified-removed">- int TypePtr::xadd_offset( intptr_t offset ) const {</span>
<span class="udiff-line-modified-removed">-   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!</span>
<span class="udiff-line-removed">-   if( _offset == OffsetTop || offset == OffsetTop ) return OffsetTop;</span>
<span class="udiff-line-removed">-   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!</span>
<span class="udiff-line-removed">-   if( _offset == OffsetBot || offset == OffsetBot ) return OffsetBot;</span>
<span class="udiff-line-removed">-   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!</span>
<span class="udiff-line-removed">-   offset += (intptr_t)_offset;</span>
<span class="udiff-line-removed">-   if (offset != (int)offset || offset == OffsetTop) return OffsetBot;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );</span>
<span class="udiff-line-removed">-   // It is possible to construct a negative offset during PhaseCCP</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return (int)offset;        // Sum valid offsets</span>
<span class="udiff-line-modified-added">+ Type::Offset TypePtr::xadd_offset(intptr_t offset) const {</span>
<span class="udiff-line-modified-added">+   return _offset.add(offset);</span>
  }
  
  //------------------------------add_offset-------------------------------------
  const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
    return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2522,17 +2774,17 @@</span>
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypePtr::eq( const Type *t ) const {
    const TypePtr *a = (const TypePtr*)t;
<span class="udiff-line-modified-removed">-   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;offset() &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;</span>
<span class="udiff-line-modified-added">+   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;_offset &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;</span>
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypePtr::hash(void) const {
<span class="udiff-line-modified-removed">-   return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));</span>
<span class="udiff-line-modified-added">+   return java_add(java_add((jint)_ptr, (jint)offset()), java_add((jint)hash_speculative(), (jint)_inline_depth));</span>
  ;
  }
  
  /**
   * Return same type without a speculative part
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2788,13 +3040,11 @@</span>
  
  #ifndef PRODUCT
  void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
    if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
    else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
<span class="udiff-line-modified-removed">-   if( _offset == OffsetTop ) st-&gt;print(&quot;+top&quot;);</span>
<span class="udiff-line-removed">-   else if( _offset == OffsetBot ) st-&gt;print(&quot;+bot&quot;);</span>
<span class="udiff-line-removed">-   else if( _offset ) st-&gt;print(&quot;+%d&quot;, _offset);</span>
<span class="udiff-line-modified-added">+   _offset.dump2(st);</span>
    dump_inline_depth(st);
    dump_speculative(st);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2825,15 +3075,15 @@</span>
  //------------------------------singleton--------------------------------------
  // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
  // constants
  bool TypePtr::singleton(void) const {
    // TopPTR, Null, AnyNull, Constant are all singletons
<span class="udiff-line-modified-removed">-   return (_offset != OffsetBot) &amp;&amp; !below_centerline(_ptr);</span>
<span class="udiff-line-modified-added">+   return (_offset != Offset::bottom) &amp;&amp; !below_centerline(_ptr);</span>
  }
  
  bool TypePtr::empty(void) const {
<span class="udiff-line-modified-removed">-   return (_offset == OffsetTop) || above_centerline(_ptr);</span>
<span class="udiff-line-modified-added">+   return (_offset == Offset::top) || above_centerline(_ptr);</span>
  }
  
  //=============================================================================
  // Convenience common pre-built types.
  const TypeRawPtr *TypeRawPtr::BOTTOM;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2971,63 +3221,76 @@</span>
  //=============================================================================
  // Convenience common pre-built type.
  const TypeOopPtr *TypeOopPtr::BOTTOM;
  
  //------------------------------TypeOopPtr-------------------------------------
<span class="udiff-line-modified-removed">- TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,</span>
<span class="udiff-line-modified-added">+ TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,</span>
                         int instance_id, const TypePtr* speculative, int inline_depth)
    : TypePtr(t, ptr, offset, speculative, inline_depth),
      _const_oop(o), _klass(k),
      _klass_is_exact(xk),
      _is_ptr_to_narrowoop(false),
      _is_ptr_to_narrowklass(false),
      _is_ptr_to_boxed_value(false),
      _instance_id(instance_id) {
    if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
<span class="udiff-line-modified-removed">-       (offset &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="udiff-line-modified-removed">-     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset);</span>
<span class="udiff-line-modified-added">+       (offset.get() &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="udiff-line-modified-added">+     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());</span>
    }
  #ifdef _LP64
<span class="udiff-line-modified-removed">-   if (_offset &gt; 0 || _offset == Type::OffsetTop || _offset == Type::OffsetBot) {</span>
<span class="udiff-line-modified-removed">-     if (_offset == oopDesc::klass_offset_in_bytes()) {</span>
<span class="udiff-line-modified-added">+   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {</span>
<span class="udiff-line-modified-added">+     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {</span>
        _is_ptr_to_narrowklass = UseCompressedClassPointers;
      } else if (klass() == NULL) {
        // Array with unknown body type
        assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
        _is_ptr_to_narrowoop = UseCompressedOops;
<span class="udiff-line-modified-removed">-     } else if (this-&gt;isa_aryptr()) {</span>
<span class="udiff-line-modified-removed">-       _is_ptr_to_narrowoop = (UseCompressedOops &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                              _offset != arrayOopDesc::length_offset_in_bytes());</span>
<span class="udiff-line-modified-added">+     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {</span>
<span class="udiff-line-modified-added">+       if (klass()-&gt;is_obj_array_klass()) {</span>
<span class="udiff-line-modified-added">+         _is_ptr_to_narrowoop = true;</span>
<span class="udiff-line-added">+       } else if (klass()-&gt;is_flat_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {</span>
<span class="udiff-line-added">+         // Check if the field of the inline type array element contains oops</span>
<span class="udiff-line-added">+         ciInlineKlass* vk = klass()-&gt;as_flat_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="udiff-line-added">+         int foffset = field_offset.get() + vk-&gt;first_field_offset();</span>
<span class="udiff-line-added">+         ciField* field = vk-&gt;get_field_by_offset(foffset, false);</span>
<span class="udiff-line-added">+         assert(field != NULL, &quot;missing field&quot;);</span>
<span class="udiff-line-added">+         BasicType bt = field-&gt;layout_type();</span>
<span class="udiff-line-added">+         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);</span>
<span class="udiff-line-added">+       }</span>
      } else if (klass()-&gt;is_instance_klass()) {
<span class="udiff-line-removed">-       ciInstanceKlass* ik = klass()-&gt;as_instance_klass();</span>
<span class="udiff-line-removed">-       ciField* field = NULL;</span>
        if (this-&gt;isa_klassptr()) {
          // Perm objects don&#39;t use compressed references
<span class="udiff-line-modified-removed">-       } else if (_offset == OffsetBot || _offset == OffsetTop) {</span>
<span class="udiff-line-modified-added">+       } else if (_offset == Offset::bottom || _offset == Offset::top) {</span>
          // unsafe access
          _is_ptr_to_narrowoop = UseCompressedOops;
        } else { // exclude unsafe ops
          assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="udiff-line-removed">-             (_offset == java_lang_Class::klass_offset() ||</span>
<span class="udiff-line-modified-added">+         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="udiff-line-modified-added">+             (this-&gt;offset() == java_lang_Class::klass_offset() ||</span>
               this-&gt;offset() == java_lang_Class::array_klass_offset())) {
            // Special hidden fields from the Class.
            assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
            _is_ptr_to_narrowoop = false;
          } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
<span class="udiff-line-modified-removed">-                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {</span>
<span class="udiff-line-modified-added">+                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {</span>
            // Static fields
            assert(o != NULL, &quot;must be constant&quot;);
<span class="udiff-line-modified-removed">-           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="udiff-line-modified-removed">-           ciField* field = k-&gt;get_field_by_offset(_offset, true);</span>
<span class="udiff-line-modified-removed">-           assert(field != NULL, &quot;missing field&quot;);</span>
<span class="udiff-line-modified-removed">-           BasicType basic_elem_type = field-&gt;layout_type();</span>
<span class="udiff-line-modified-added">+           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="udiff-line-modified-added">+           BasicType basic_elem_type;</span>
<span class="udiff-line-modified-added">+           if (ik-&gt;is_inlinetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_inline_klass()-&gt;default_value_offset()) {</span>
<span class="udiff-line-modified-added">+             // Special hidden field that contains the oop of the default inline type</span>
<span class="udiff-line-added">+             basic_elem_type = T_INLINE_TYPE;</span>
<span class="udiff-line-added">+           } else {</span>
<span class="udiff-line-added">+             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);</span>
<span class="udiff-line-added">+             assert(field != NULL, &quot;missing field&quot;);</span>
<span class="udiff-line-added">+             basic_elem_type = field-&gt;layout_type();</span>
<span class="udiff-line-added">+           }</span>
            _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
          } else {
            // Instance fields which contains a compressed oop references.
<span class="udiff-line-modified-removed">-           field = ik-&gt;get_field_by_offset(_offset, false);</span>
<span class="udiff-line-modified-added">+           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();</span>
<span class="udiff-line-added">+           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);</span>
            if (field != NULL) {
              BasicType basic_elem_type = field-&gt;layout_type();
              _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
            } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
              // Compile::find_alias_type() cast exactness on all types to verify
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3043,17 +3306,17 @@</span>
    }
  #endif
  }
  
  //------------------------------make-------------------------------------------
<span class="udiff-line-modified-removed">- const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,</span>
<span class="udiff-line-modified-removed">-                                      const TypePtr* speculative, int inline_depth) {</span>
<span class="udiff-line-modified-added">+ const TypeOopPtr *TypeOopPtr::make(PTR ptr, Offset offset, int instance_id,</span>
<span class="udiff-line-modified-added">+                                    const TypePtr* speculative, int inline_depth) {</span>
    assert(ptr != Constant, &quot;no constant generic pointers&quot;);
    ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
    bool      xk = false;
    ciObject* o = NULL;
<span class="udiff-line-modified-removed">-   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
<span class="udiff-line-modified-added">+   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
  }
  
  
  //------------------------------cast_to_ptr_type-------------------------------
  const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3084,11 +3347,11 @@</span>
    ciKlass* k = klass();
    bool    xk = klass_is_exact();
    if (k == NULL)
      return TypeKlassPtr::OBJECT;
    else
<span class="udiff-line-modified-removed">-     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);</span>
<span class="udiff-line-modified-added">+     return TypeKlassPtr::make(xk? Constant: NotNull, k, Offset(0), isa_instptr() &amp;&amp; is_instptr()-&gt;flat_array());</span>
  }
  
  //------------------------------meet-------------------------------------------
  // Compute the MEET of two types.  It returns a new Type object.
  const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3122,11 +3385,11 @@</span>
      return TypePtr::BOTTOM;     // Oop meet raw is not well defined
  
    case AnyPtr: {
      // Found an AnyPtr type vs self-OopPtr type
      const TypePtr *tp = t-&gt;is_ptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR ptr = meet_ptr(tp-&gt;ptr());
      const TypePtr* speculative = xmeet_speculative(tp);
      int depth = meet_inline_depth(tp-&gt;inline_depth());
      switch (tp-&gt;ptr()) {
      case Null:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3164,17 +3427,17 @@</span>
  //------------------------------xdual------------------------------------------
  // Dual of a pure heap pointer.  No relevant klass or oop information.
  const Type *TypeOopPtr::xdual() const {
    assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
    assert(const_oop() == NULL,             &quot;no constants here&quot;);
<span class="udiff-line-modified-removed">-   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
<span class="udiff-line-modified-added">+   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
  }
  
  //--------------------------make_from_klass_common-----------------------------
  // Computes the element-type given a klass.
  const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
<span class="udiff-line-modified-removed">-   if (klass-&gt;is_instance_klass()) {</span>
<span class="udiff-line-modified-added">+   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {</span>
      Compile* C = Compile::current();
      Dependencies* deps = C-&gt;dependencies();
      assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
      // Element is an instance
      bool klass_is_exact = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3196,28 +3459,46 @@</span>
          // Add a dependence; if concrete subclass added we need to recompile
          deps-&gt;assert_leaf_type(ik);
          klass_is_exact = true;
        }
      }
<span class="udiff-line-modified-removed">-     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);</span>
<span class="udiff-line-modified-added">+     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());</span>
    } else if (klass-&gt;is_obj_array_klass()) {
<span class="udiff-line-modified-removed">-     // Element is an object array. Recursively call ourself.</span>
<span class="udiff-line-modified-removed">-     const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_obj_array_klass()-&gt;element_klass(), false, try_for_exact);</span>
<span class="udiff-line-modified-added">+     // Element is an object or inline type array. Recursively call ourself.</span>
<span class="udiff-line-modified-added">+     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);</span>
<span class="udiff-line-added">+     if (etype-&gt;is_inlinetypeptr()) {</span>
<span class="udiff-line-added">+       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // Determine null-free/flattened properties</span>
<span class="udiff-line-added">+     const TypeOopPtr* exact_etype = etype;</span>
<span class="udiff-line-added">+     if (etype-&gt;can_be_inline_type()) {</span>
<span class="udiff-line-added">+       // Use exact type if element can be an inline type</span>
<span class="udiff-line-added">+       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     bool not_null_free = !exact_etype-&gt;can_be_inline_type();</span>
<span class="udiff-line-added">+     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_inlinetypeptr() &amp;&amp; !exact_etype-&gt;inline_klass()-&gt;flatten_array());</span>
<span class="udiff-line-added">+ </span>
      bool xk = etype-&gt;klass_is_exact();
<span class="udiff-line-modified-removed">-     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);</span>
<span class="udiff-line-modified-added">+     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);</span>
      // We used to pass NotNull in here, asserting that the sub-arrays
      // are all not-null.  This is not true in generally, as code can
      // slam NULLs down in the subarrays.
<span class="udiff-line-modified-removed">-     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);</span>
<span class="udiff-line-modified-added">+     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));</span>
      return arr;
    } else if (klass-&gt;is_type_array_klass()) {
      // Element is an typeArray
      const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
<span class="udiff-line-modified-removed">-     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);</span>
<span class="udiff-line-modified-added">+     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,</span>
<span class="udiff-line-added">+                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);</span>
      // We used to pass NotNull in here, asserting that the array pointer
      // is not-null. That was not true in general.
<span class="udiff-line-modified-removed">-     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, 0);</span>
<span class="udiff-line-modified-added">+     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));</span>
<span class="udiff-line-added">+     return arr;</span>
<span class="udiff-line-added">+   } else if (klass-&gt;is_flat_array_klass()) {</span>
<span class="udiff-line-added">+     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="udiff-line-added">+     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::POS);</span>
<span class="udiff-line-added">+     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));</span>
      return arr;
    } else {
      ShouldNotReachHere();
      return NULL;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3229,54 +3510,70 @@</span>
    assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
  
    const bool make_constant = require_constant || o-&gt;should_be_constant();
  
    ciKlass* klass = o-&gt;klass();
<span class="udiff-line-modified-removed">-   if (klass-&gt;is_instance_klass()) {</span>
<span class="udiff-line-modified-removed">-     // Element is an instance</span>
<span class="udiff-line-modified-added">+   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {</span>
<span class="udiff-line-modified-added">+     // Element is an instance or inline type</span>
      if (make_constant) {
        return TypeInstPtr::make(o);
      } else {
<span class="udiff-line-modified-removed">-       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);</span>
<span class="udiff-line-modified-added">+       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());</span>
      }
    } else if (klass-&gt;is_obj_array_klass()) {
      // Element is an object array. Recursively call ourself.
<span class="udiff-line-modified-removed">-     const TypeOopPtr *etype =</span>
<span class="udiff-line-modified-removed">-       TypeOopPtr::make_from_klass_raw(klass-&gt;as_obj_array_klass()-&gt;element_klass());</span>
<span class="udiff-line-modified-removed">-     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
<span class="udiff-line-modified-added">+     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());</span>
<span class="udiff-line-modified-added">+     bool null_free = false;</span>
<span class="udiff-line-modified-added">+     if (etype-&gt;is_inlinetypeptr()) {</span>
<span class="udiff-line-added">+       null_free = true;</span>
<span class="udiff-line-added">+       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),</span>
<span class="udiff-line-added">+                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);</span>
      // We used to pass NotNull in here, asserting that the sub-arrays
      // are all not-null.  This is not true in generally, as code can
      // slam NULLs down in the subarrays.
      if (make_constant) {
<span class="udiff-line-modified-removed">-       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);</span>
<span class="udiff-line-modified-added">+       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));</span>
      } else {
<span class="udiff-line-modified-removed">-       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);</span>
<span class="udiff-line-modified-added">+       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));</span>
      }
    } else if (klass-&gt;is_type_array_klass()) {
      // Element is an typeArray
<span class="udiff-line-modified-removed">-     const Type* etype =</span>
<span class="udiff-line-modified-removed">-       (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());</span>
<span class="udiff-line-modified-removed">-     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
<span class="udiff-line-modified-added">+     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());</span>
<span class="udiff-line-modified-added">+     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),</span>
<span class="udiff-line-modified-added">+                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);</span>
      // We used to pass NotNull in here, asserting that the array pointer
      // is not-null. That was not true in general.
      if (make_constant) {
<span class="udiff-line-modified-removed">-       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);</span>
<span class="udiff-line-modified-added">+       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else if (klass-&gt;is_flat_array_klass()) {</span>
<span class="udiff-line-added">+     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="udiff-line-added">+     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
<span class="udiff-line-added">+     // We used to pass NotNull in here, asserting that the sub-arrays</span>
<span class="udiff-line-added">+     // are all not-null.  This is not true in generally, as code can</span>
<span class="udiff-line-added">+     // slam NULLs down in the subarrays.</span>
<span class="udiff-line-added">+     if (make_constant) {</span>
<span class="udiff-line-added">+       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));</span>
      } else {
<span class="udiff-line-modified-removed">-       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);</span>
<span class="udiff-line-modified-added">+       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));</span>
      }
    }
  
    fatal(&quot;unhandled object type&quot;);
    return NULL;
  }
  
  //------------------------------get_con----------------------------------------
  intptr_t TypeOopPtr::get_con() const {
    assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="udiff-line-modified-removed">-   assert( _offset &gt;= 0, &quot;&quot; );</span>
<span class="udiff-line-modified-added">+   assert(offset() &gt;= 0, &quot;&quot;);</span>
  
<span class="udiff-line-modified-removed">-   if (_offset != 0) {</span>
<span class="udiff-line-modified-added">+   if (offset() != 0) {</span>
      // After being ported to the compiler interface, the compiler no longer
      // directly manipulates the addresses of oops.  Rather, it only has a pointer
      // to a handle at compile time.  This handle is embedded in the generated
      // code and dereferenced at the time the nmethod is made.  Until that time,
      // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3365,16 +3662,11 @@</span>
  #ifndef PRODUCT
  void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
    st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
    if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
    if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
<span class="udiff-line-modified-removed">-   switch( _offset ) {</span>
<span class="udiff-line-removed">-   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;</span>
<span class="udiff-line-removed">-   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;</span>
<span class="udiff-line-removed">-   case         0: break;</span>
<span class="udiff-line-removed">-   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   _offset.dump2(st);</span>
    if (_instance_id == InstanceTop)
      st-&gt;print(&quot;,iid=top&quot;);
    else if (_instance_id != InstanceBot)
      st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3387,11 +3679,11 @@</span>
  // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
  // constants
  bool TypeOopPtr::singleton(void) const {
    // detune optimizer to not generate constant oop + constant offset as a constant!
    // TopPTR, Null, AnyNull, Constant are all singletons
<span class="udiff-line-modified-removed">-   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);</span>
<span class="udiff-line-modified-added">+   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);</span>
  }
  
  //------------------------------add_offset-------------------------------------
  const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
    return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3479,25 +3771,29 @@</span>
  const TypeInstPtr *TypeInstPtr::MIRROR;
  const TypeInstPtr *TypeInstPtr::MARK;
  const TypeInstPtr *TypeInstPtr::KLASS;
  
  //------------------------------TypeInstPtr-------------------------------------
<span class="udiff-line-modified-removed">- TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,</span>
<span class="udiff-line-modified-removed">-                          int instance_id, const TypePtr* speculative, int inline_depth)</span>
<span class="udiff-line-modified-removed">-   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth),</span>
<span class="udiff-line-modified-removed">-     _name(k-&gt;name()) {</span>
<span class="udiff-line-modified-added">+ TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,</span>
<span class="udiff-line-modified-added">+                          bool flat_array, int instance_id, const TypePtr* speculative,</span>
<span class="udiff-line-modified-added">+                          int inline_depth)</span>
<span class="udiff-line-modified-added">+   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),</span>
<span class="udiff-line-added">+     _name(k-&gt;name()), _flat_array(flat_array) {</span>
     assert(k != NULL &amp;&amp;
            (k-&gt;is_loaded() || o == NULL),
            &quot;cannot have constants with non-loaded klass&quot;);
<span class="udiff-line-added">+    assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="udiff-line-added">+    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
  };
  
  //------------------------------make-------------------------------------------
  const TypeInstPtr *TypeInstPtr::make(PTR ptr,
                                       ciKlass* k,
                                       bool xk,
                                       ciObject* o,
<span class="udiff-line-modified-removed">-                                      int offset,</span>
<span class="udiff-line-modified-added">+                                      Offset offset,</span>
<span class="udiff-line-added">+                                      bool flat_array,</span>
                                       int instance_id,
                                       const TypePtr* speculative,
                                       int inline_depth) {
    assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
    // Either const_oop() is NULL or else ptr is Constant
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3516,11 +3812,11 @@</span>
      if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
    }
  
    // Now hash this baby
    TypeInstPtr *result =
<span class="udiff-line-modified-removed">-     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
<span class="udiff-line-modified-added">+     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, flat_array, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
  
    return result;
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3549,35 +3845,35 @@</span>
  //------------------------------cast_to_ptr_type-------------------------------
  const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
    if( ptr == _ptr ) return this;
    // Reconstruct _sig info here since not a problem with later lazy
    // construction, _sig will show up on demand.
<span class="udiff-line-modified-removed">-   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);</span>
  }
  
  
  //-----------------------------cast_to_exactness-------------------------------
  const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
    if( klass_is_exact == _klass_is_exact ) return this;
    if (!_klass-&gt;is_loaded())  return this;
    ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
    if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
    if( ik-&gt;is_interface() )              return this;  // cannot set xk
<span class="udiff-line-modified-removed">-   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);</span>
  }
  
  //-----------------------------cast_to_instance_id----------------------------
  const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
    if( instance_id == _instance_id ) return this;
<span class="udiff-line-modified-removed">-   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);</span>
  }
  
  //------------------------------xmeet_unloaded---------------------------------
  // Compute the MEET of two InstPtrs when at least one is unloaded.
  // Assume classes are different since called after check for same name/class-loader
  const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
<span class="udiff-line-modified-removed">-     int off = meet_offset(tinst-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset off = meet_offset(tinst-&gt;offset());</span>
      PTR ptr = meet_ptr(tinst-&gt;ptr());
      int instance_id = meet_instance_id(tinst-&gt;instance_id());
      const TypePtr* speculative = xmeet_speculative(tinst);
      int depth = meet_inline_depth(tinst-&gt;inline_depth());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3598,11 +3894,11 @@</span>
        //  BOTTOM  | ........................Object-BOTTOM ..................|
        //
        assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
        //
        if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
<span class="udiff-line-modified-removed">-       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, instance_id, speculative, depth); }</span>
<span class="udiff-line-modified-added">+       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, false, instance_id, speculative, depth); }</span>
        else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
        else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
          if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
          else                                      { return TypeInstPtr::NOTNULL; }
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3651,28 +3947,28 @@</span>
    case KlassPtr:
    case RawPtr: return TypePtr::BOTTOM;
  
    case AryPtr: {                // All arrays inherit from Object class
      const TypeAryPtr *tp = t-&gt;is_aryptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR ptr = meet_ptr(tp-&gt;ptr());
      int instance_id = meet_instance_id(tp-&gt;instance_id());
      const TypePtr* speculative = xmeet_speculative(tp);
      int depth = meet_inline_depth(tp-&gt;inline_depth());
      switch (ptr) {
      case TopPTR:
      case AnyNull:                // Fall &#39;down&#39; to dual of object klass
        // For instances when a subclass meets a superclass we fall
        // below the centerline when the superclass is exact. We need to
        // do the same here.
<span class="udiff-line-modified-removed">-       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {</span>
<span class="udiff-line-modified-removed">-         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
<span class="udiff-line-modified-added">+         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);</span>
        } else {
          // cannot subclass, so the meet has to fall badly below the centerline
          ptr = NotNull;
          instance_id = InstanceBot;
<span class="udiff-line-modified-removed">-         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
        }
      case Constant:
      case NotNull:
      case BotPTR:                // Fall down to object klass
        // LCA is object_klass, but if we subclass from the top we can do better
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3680,39 +3976,39 @@</span>
          // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
          // then we can subclass in the Java class hierarchy.
          // For instances when a subclass meets a superclass we fall
          // below the centerline when the superclass is exact. We need
          // to do the same here.
<span class="udiff-line-modified-removed">-         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {</span>
<span class="udiff-line-modified-added">+         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
            // that is, tp&#39;s array type is a subtype of my klass
            return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
<span class="udiff-line-modified-removed">-                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);</span>
          }
        }
        // The other case cannot happen, since I cannot be a subtype of an array.
        // The meet falls down to Object class below centerline.
        if( ptr == Constant )
           ptr = NotNull;
        instance_id = InstanceBot;
<span class="udiff-line-modified-removed">-       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
      default: typerr(t);
      }
    }
  
    case OopPtr: {                // Meeting to OopPtrs
      // Found a OopPtr type vs self-InstPtr type
      const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR ptr = meet_ptr(tp-&gt;ptr());
      switch (tp-&gt;ptr()) {
      case TopPTR:
      case AnyNull: {
        int instance_id = meet_instance_id(InstanceTop);
        const TypePtr* speculative = xmeet_speculative(tp);
        int depth = meet_inline_depth(tp-&gt;inline_depth());
        return make(ptr, klass(), klass_is_exact(),
<span class="udiff-line-modified-removed">-                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);</span>
      }
      case NotNull:
      case BotPTR: {
        int instance_id = meet_instance_id(tp-&gt;instance_id());
        const TypePtr* speculative = xmeet_speculative(tp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3724,11 +4020,11 @@</span>
    }
  
    case AnyPtr: {                // Meeting to AnyPtrs
      // Found an AnyPtr type vs self-InstPtr type
      const TypePtr *tp = t-&gt;is_ptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR ptr = meet_ptr(tp-&gt;ptr());
      int instance_id = meet_instance_id(InstanceTop);
      const TypePtr* speculative = xmeet_speculative(tp);
      int depth = meet_inline_depth(tp-&gt;inline_depth());
      switch (tp-&gt;ptr()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3736,11 +4032,11 @@</span>
        if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
        // else fall through to AnyNull
      case TopPTR:
      case AnyNull: {
        return make(ptr, klass(), klass_is_exact(),
<span class="udiff-line-modified-removed">-                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);</span>
      }
      case NotNull:
      case BotPTR:
        return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
      default: typerr(t);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3764,29 +4060,32 @@</span>
    */
  
    case InstPtr: {                // Meeting 2 Oops?
      // Found an InstPtr sub-type vs self-InstPtr type
      const TypeInstPtr *tinst = t-&gt;is_instptr();
<span class="udiff-line-modified-removed">-     int off = meet_offset( tinst-&gt;offset() );</span>
<span class="udiff-line-modified-added">+     Offset off = meet_offset( tinst-&gt;offset() );</span>
      PTR ptr = meet_ptr( tinst-&gt;ptr() );
      int instance_id = meet_instance_id(tinst-&gt;instance_id());
      const TypePtr* speculative = xmeet_speculative(tinst);
      int depth = meet_inline_depth(tinst-&gt;inline_depth());
  
      // Check for easy case; klasses are equal (and perhaps not loaded!)
      // If we have constants, then we created oops so classes are loaded
      // and we can handle the constants further down.  This case handles
      // both-not-loaded or both-loaded classes
<span class="udiff-line-modified-removed">-     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact()) {</span>
<span class="udiff-line-modified-removed">-       return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;</span>
<span class="udiff-line-modified-added">+         flat_array() == tinst-&gt;flat_array()) {</span>
<span class="udiff-line-added">+       return make(ptr, klass(), klass_is_exact(), NULL, off, flat_array(), instance_id, speculative, depth);</span>
      }
  
      // Classes require inspection in the Java klass hierarchy.  Must be loaded.
      ciKlass* tinst_klass = tinst-&gt;klass();
      ciKlass* this_klass  = this-&gt;klass();
      bool tinst_xk = tinst-&gt;klass_is_exact();
      bool this_xk  = this-&gt;klass_is_exact();
<span class="udiff-line-added">+     bool tinst_flat_array = tinst-&gt;flat_array();</span>
<span class="udiff-line-added">+     bool this_flat_array  = this-&gt;flat_array();</span>
      if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
        // One of these classes has not been loaded
        const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
  #ifndef PRODUCT
        if( PrintOpto &amp;&amp; Verbose ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3805,10 +4104,13 @@</span>
        tinst_klass = this_klass;
        this_klass = tmp;
        bool tmp2 = tinst_xk;
        tinst_xk = this_xk;
        this_xk = tmp2;
<span class="udiff-line-added">+       tmp2 = tinst_flat_array;</span>
<span class="udiff-line-added">+       tinst_flat_array = this_flat_array;</span>
<span class="udiff-line-added">+       this_flat_array = tmp2;</span>
      }
      if (tinst_klass-&gt;is_interface() &amp;&amp;
          !(this_klass-&gt;is_interface() ||
            // Treat java/lang/Object as an honorary interface,
            // because we need a bottom for the interface hierarchy.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3816,34 +4118,37 @@</span>
        // Oop meets interface!
  
        // See if the oop subtypes (implements) interface.
        ciKlass *k;
        bool xk;
<span class="udiff-line-added">+       bool flat_array;</span>
        if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
          // Oop indeed subtypes.  Now keep oop or interface depending
          // on whether we are both above the centerline or either is
          // below the centerline.  If we are on the centerline
          // (e.g., Constant vs. AnyNull interface), use the constant.
          k  = below_centerline(ptr) ? tinst_klass : this_klass;
          // If we are keeping this_klass, keep its exactness too.
          xk = below_centerline(ptr) ? tinst_xk    : this_xk;
<span class="udiff-line-added">+         flat_array = below_centerline(ptr) ? tinst_flat_array    : this_flat_array;</span>
        } else {                  // Does not implement, fall to Object
          // Oop does not implement interface, so mixing falls to Object
          // just like the verifier does (if both are above the
          // centerline fall to interface)
          k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
          xk = above_centerline(ptr) ? tinst_xk : false;
<span class="udiff-line-added">+         flat_array = above_centerline(ptr) ? tinst_flat_array : false;</span>
          // Watch out for Constant vs. AnyNull interface.
          if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
          instance_id = InstanceBot;
        }
        ciObject* o = NULL;  // the Constant value, if any
        if (ptr == Constant) {
          // Find out which constant.
          o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
        }
<span class="udiff-line-modified-removed">-       return make(ptr, k, xk, o, off, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+       return make(ptr, k, xk, o, off, flat_array, instance_id, speculative, depth);</span>
      }
  
      // Either oop vs oop or interface vs interface or interface vs Object
  
      // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3871,33 +4176,41 @@</span>
      // centerline and or-ed above it.  (N.B. Constants are always exact.)
  
      // Check for subtyping:
      ciKlass *subtype = NULL;
      bool subtype_exact = false;
<span class="udiff-line-modified-removed">-     if( tinst_klass-&gt;equals(this_klass) ) {</span>
<span class="udiff-line-modified-added">+     bool flat_array = false;</span>
<span class="udiff-line-added">+     if (tinst_klass-&gt;equals(this_klass)) {</span>
        subtype = this_klass;
        subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
<span class="udiff-line-modified-removed">-     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {</span>
<span class="udiff-line-modified-added">+       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);</span>
<span class="udiff-line-added">+     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flat_array || this_flat_array)) {</span>
        subtype = this_klass;     // Pick subtyping class
        subtype_exact = this_xk;
<span class="udiff-line-modified-removed">-     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {</span>
<span class="udiff-line-modified-added">+       flat_array = this_flat_array;</span>
<span class="udiff-line-added">+     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flat_array || tinst_flat_array)) {</span>
        subtype = tinst_klass;    // Pick subtyping class
        subtype_exact = tinst_xk;
<span class="udiff-line-added">+       flat_array = tinst_flat_array;</span>
      }
  
<span class="udiff-line-modified-removed">-     if( subtype ) {</span>
<span class="udiff-line-modified-removed">-       if( above_centerline(ptr) ) { // both are up?</span>
<span class="udiff-line-modified-added">+     if (subtype) {</span>
<span class="udiff-line-modified-added">+       if (above_centerline(ptr)) { // both are up?</span>
          this_klass = tinst_klass = subtype;
          this_xk = tinst_xk = subtype_exact;
<span class="udiff-line-modified-removed">-       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {</span>
<span class="udiff-line-modified-added">+         this_flat_array = tinst_flat_array = flat_array;</span>
<span class="udiff-line-added">+       } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {</span>
          this_klass = tinst_klass; // tinst is down; keep down man
          this_xk = tinst_xk;
<span class="udiff-line-modified-removed">-       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {</span>
<span class="udiff-line-modified-added">+         this_flat_array = tinst_flat_array;</span>
<span class="udiff-line-added">+       } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {</span>
          tinst_klass = this_klass; // this is down; keep down man
          tinst_xk = this_xk;
<span class="udiff-line-added">+         tinst_flat_array = this_flat_array;</span>
        } else {
          this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
<span class="udiff-line-added">+         this_flat_array = flat_array;</span>
        }
      }
  
      // Check for classes now being equal
      if (tinst_klass-&gt;equals(this_klass)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3916,11 +4229,11 @@</span>
          else if (above_centerline(tinst -&gt;_ptr))
            o = this_oop;
          else
            ptr = NotNull;
        }
<span class="udiff-line-modified-removed">-       return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);</span>
      } // Else classes are not equal
  
      // Since klasses are different, we require a LCA in the Java
      // class hierarchy - which means we have to fall to at least NotNull.
      if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3928,13 +4241,34 @@</span>
  
      instance_id = InstanceBot;
  
      // Now we find the LCA of Java classes
      ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
<span class="udiff-line-modified-removed">-     return make(ptr, k, false, NULL, off, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);</span>
    } // End of case InstPtr
  
<span class="udiff-line-added">+   case InlineType: {</span>
<span class="udiff-line-added">+     const TypeInlineType* tv = t-&gt;is_inlinetype();</span>
<span class="udiff-line-added">+     if (above_centerline(ptr())) {</span>
<span class="udiff-line-added">+       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {</span>
<span class="udiff-line-added">+         return t;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         return TypeInstPtr::NOTNULL;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       PTR ptr = this-&gt;_ptr;</span>
<span class="udiff-line-added">+       if (ptr == Constant) {</span>
<span class="udiff-line-added">+         ptr = NotNull;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {</span>
<span class="udiff-line-added">+         return TypeInstPtr::make(ptr, _klass);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    } // End of switch
    return this;                  // Return the double constant
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3943,35 +4277,35 @@</span>
    // must be a singleton type
    if( const_oop() == NULL )  return NULL;
  
    // must be of type java.lang.Class
    if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
<span class="udiff-line-removed">- </span>
    return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
  }
  
  
  //------------------------------xdual------------------------------------------
  // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
  // inheritance mechanism.
  const Type *TypeInstPtr::xdual() const {
<span class="udiff-line-modified-removed">-   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
<span class="udiff-line-modified-added">+   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypeInstPtr::eq( const Type *t ) const {
    const TypeInstPtr *p = t-&gt;is_instptr();
    return
      klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
<span class="udiff-line-added">+     flat_array() == p-&gt;flat_array() &amp;&amp;</span>
      TypeOopPtr::eq(p);          // Check sub-type stuff
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeInstPtr::hash(void) const {
<span class="udiff-line-modified-removed">-   int hash = java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash());</span>
<span class="udiff-line-modified-added">+   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flat_array());</span>
    return hash;
  }
  
  //------------------------------dump2------------------------------------------
  // Dump oop Type
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3999,17 +4333,18 @@</span>
      break;
    default:
      break;
    }
  
<span class="udiff-line-modified-removed">-   if( _offset ) {               // Dump offset, if any</span>
<span class="udiff-line-removed">-     if( _offset == OffsetBot )      st-&gt;print(&quot;+any&quot;);</span>
<span class="udiff-line-removed">-     else if( _offset == OffsetTop ) st-&gt;print(&quot;+unknown&quot;);</span>
<span class="udiff-line-removed">-     else st-&gt;print(&quot;+%d&quot;, _offset);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   _offset.dump2(st);</span>
  
    st-&gt;print(&quot; *&quot;);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot; (flatten array)&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    if (_instance_id == InstanceTop)
      st-&gt;print(&quot;,iid=top&quot;);
    else if (_instance_id != InstanceBot)
      st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4018,35 +4353,40 @@</span>
  }
  #endif
  
  //------------------------------add_offset-------------------------------------
  const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
<span class="udiff-line-modified-removed">-   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),</span>
<span class="udiff-line-modified-added">+   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),</span>
                _instance_id, add_offset_speculative(offset), _inline_depth);
  }
  
  const Type *TypeInstPtr::remove_speculative() const {
    if (_speculative == NULL) {
      return this;
    }
    assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="udiff-line-modified-removed">-   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,</span>
<span class="udiff-line-modified-added">+   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(),</span>
                _instance_id, NULL, _inline_depth);
  }
  
  const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
    if (!UseInlineDepthForSpeculativeTypes) {
      return this;
    }
<span class="udiff-line-modified-removed">-   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);</span>
<span class="udiff-line-modified-added">+   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);</span>
  }
  
  const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
    assert(is_known_instance(), &quot;should be known&quot;);
<span class="udiff-line-modified-removed">-   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);</span>
  }
  
<span class="udiff-line-added">+ const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {</span>
<span class="udiff-line-added">+   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  //=============================================================================
  // Convenience common pre-built types.
  const TypeAryPtr *TypeAryPtr::RANGE;
  const TypeAryPtr *TypeAryPtr::OOPS;
  const TypeAryPtr *TypeAryPtr::NARROWOOPS;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4055,51 +4395,58 @@</span>
  const TypeAryPtr *TypeAryPtr::CHARS;
  const TypeAryPtr *TypeAryPtr::INTS;
  const TypeAryPtr *TypeAryPtr::LONGS;
  const TypeAryPtr *TypeAryPtr::FLOATS;
  const TypeAryPtr *TypeAryPtr::DOUBLES;
<span class="udiff-line-added">+ const TypeAryPtr *TypeAryPtr::INLINES;</span>
  
  //------------------------------make-------------------------------------------
<span class="udiff-line-modified-removed">- const TypeAryPtr *TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,</span>
<span class="udiff-line-modified-added">+ const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,</span>
                                     int instance_id, const TypePtr* speculative, int inline_depth) {
    assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
           &quot;integral arrays must be pre-equipped with a class&quot;);
    if (!xk)  xk = ary-&gt;ary_must_be_exact();
    assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
<span class="udiff-line-modified-removed">-   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();</span>
<span class="udiff-line-modified-added">+   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();</span>
  }
  
  //------------------------------make-------------------------------------------
<span class="udiff-line-modified-removed">- const TypeAryPtr *TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,</span>
<span class="udiff-line-modified-added">+ const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,</span>
                                     int instance_id, const TypePtr* speculative, int inline_depth,
                                     bool is_autobox_cache) {
    assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
           &quot;integral arrays must be pre-equipped with a class&quot;);
    assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
    if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
    assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
<span class="udiff-line-modified-removed">-   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();</span>
<span class="udiff-line-modified-added">+   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, field_offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();</span>
  }
  
  //------------------------------cast_to_ptr_type-------------------------------
  const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
    if( ptr == _ptr ) return this;
<span class="udiff-line-modified-removed">-   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
  }
  
  
  //-----------------------------cast_to_exactness-------------------------------
  const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
    if( klass_is_exact == _klass_is_exact ) return this;
<span class="udiff-line-modified-removed">-   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk</span>
<span class="udiff-line-modified-added">+   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const TypeAry* new_ary = _ary;</span>
<span class="udiff-line-added">+   if (klass() != NULL &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp; klass_is_exact) {</span>
<span class="udiff-line-added">+     // An object array can&#39;t be flat or null-free if the klass is exact</span>
<span class="udiff-line-added">+     new_ary = TypeAry::make(elem(), size(), is_stable(), /* not_flat= */ true, /* not_null_free= */ true);</span>
<span class="udiff-line-added">+   }</span>
    return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
  }
  
  //-----------------------------cast_to_instance_id----------------------------
  const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
    if( instance_id == _instance_id ) return this;
<span class="udiff-line-modified-removed">-   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
  }
  
  
  //-----------------------------max_array_length-------------------------------
  // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4151,12 +4498,31 @@</span>
  //-------------------------------cast_to_size----------------------------------
  const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
    assert(new_size != NULL, &quot;&quot;);
    new_size = narrow_size_type(new_size);
    if (new_size == size())  return this;
<span class="udiff-line-modified-removed">-   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable());</span>
<span class="udiff-line-modified-removed">-   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-modified-added">+   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_not_flat(), is_not_null_free());</span>
<span class="udiff-line-modified-added">+   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //-------------------------------cast_to_not_flat------------------------------</span>
<span class="udiff-line-added">+ const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {</span>
<span class="udiff-line-added">+   if (not_flat == is_not_flat()) {</span>
<span class="udiff-line-added">+     return this;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());</span>
<span class="udiff-line-added">+   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //-------------------------------cast_to_not_null_free-------------------------</span>
<span class="udiff-line-added">+ const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {</span>
<span class="udiff-line-added">+   if (not_null_free == is_not_null_free()) {</span>
<span class="udiff-line-added">+     return this;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Not null free implies not flat</span>
<span class="udiff-line-added">+   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);</span>
<span class="udiff-line-added">+   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
  }
  
  //------------------------------cast_to_stable---------------------------------
  const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
    if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4168,13 +4534,13 @@</span>
    if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
      // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
      elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
    }
  
<span class="udiff-line-modified-removed">-   const TypeAry* new_ary = TypeAry::make(elem, size(), stable);</span>
<span class="udiff-line-modified-added">+   const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());</span>
  
<span class="udiff-line-modified-removed">-   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
  }
  
  //-----------------------------stable_dimension--------------------------------
  int TypeAryPtr::stable_dimension() const {
    if (!is_stable())  return 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4191,27 +4557,28 @@</span>
    const TypeOopPtr* etype = elem()-&gt;make_oopptr();
    if (etype == NULL)  return this;
    // The pointers in the autobox arrays are always non-null.
    TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
    etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="udiff-line-modified-removed">-   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable());</span>
<span class="udiff-line-modified-removed">-   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth, cache);</span>
<span class="udiff-line-modified-added">+   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_not_flat(), is_not_null_free());</span>
<span class="udiff-line-modified-added">+   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, cache);</span>
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypeAryPtr::eq( const Type *t ) const {
    const TypeAryPtr *p = t-&gt;is_aryptr();
    return
      _ary == p-&gt;_ary &amp;&amp;  // Check array
<span class="udiff-line-modified-removed">-     TypeOopPtr::eq(p);  // Check sub-parts</span>
<span class="udiff-line-modified-added">+     TypeOopPtr::eq(p) &amp;&amp;// Check sub-parts</span>
<span class="udiff-line-added">+     _field_offset == p-&gt;_field_offset;</span>
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeAryPtr::hash(void) const {
<span class="udiff-line-modified-removed">-   return (intptr_t)_ary + TypeOopPtr::hash();</span>
<span class="udiff-line-modified-added">+   return (intptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();</span>
  }
  
  //------------------------------meet-------------------------------------------
  // Compute the MEET of two types.  It returns a new Type object.
  const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4240,20 +4607,20 @@</span>
      typerr(t);
  
    case OopPtr: {                // Meeting to OopPtrs
      // Found a OopPtr type vs self-AryPtr type
      const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR ptr = meet_ptr(tp-&gt;ptr());
      int depth = meet_inline_depth(tp-&gt;inline_depth());
      const TypePtr* speculative = xmeet_speculative(tp);
      switch (tp-&gt;ptr()) {
      case TopPTR:
      case AnyNull: {
        int instance_id = meet_instance_id(InstanceTop);
        return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="udiff-line-modified-removed">-                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
      }
      case BotPTR:
      case NotNull: {
        int instance_id = meet_instance_id(tp-&gt;instance_id());
        return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4263,11 +4630,11 @@</span>
    }
  
    case AnyPtr: {                // Meeting two AnyPtrs
      // Found an AnyPtr type vs self-AryPtr type
      const TypePtr *tp = t-&gt;is_ptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR ptr = meet_ptr(tp-&gt;ptr());
      const TypePtr* speculative = xmeet_speculative(tp);
      int depth = meet_inline_depth(tp-&gt;inline_depth());
      switch (tp-&gt;ptr()) {
      case TopPTR:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4279,11 +4646,11 @@</span>
        if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
        // else fall through to AnyNull
      case AnyNull: {
        int instance_id = meet_instance_id(InstanceTop);
        return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="udiff-line-modified-removed">-                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
      }
      default: ShouldNotReachHere();
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4291,11 +4658,12 @@</span>
    case KlassPtr:
    case RawPtr: return TypePtr::BOTTOM;
  
    case AryPtr: {                // Meeting 2 references?
      const TypeAryPtr *tap = t-&gt;is_aryptr();
<span class="udiff-line-modified-removed">-     int off = meet_offset(tap-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset off = meet_offset(tap-&gt;offset());</span>
<span class="udiff-line-added">+     Offset field_off = meet_field_offset(tap-&gt;field_offset());</span>
      const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
      PTR ptr = meet_ptr(tap-&gt;ptr());
      int instance_id = meet_instance_id(tap-&gt;instance_id());
      const TypePtr* speculative = xmeet_speculative(tap);
      int depth = meet_inline_depth(tap-&gt;inline_depth());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4309,28 +4677,39 @@</span>
          lazy_klass = _klass;
        } else {
          // Something like byte[int+] meets char[int+].
          // This must fall to bottom, not (int[-128..65535])[int+].
          instance_id = InstanceBot;
<span class="udiff-line-modified-removed">-         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);</span>
<span class="udiff-line-modified-added">+         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);</span>
        }
      } else // Non integral arrays.
        // Must fall to bottom if exact klasses in upper lattice
        // are not equal or super klass is exact.
        if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
            // meet with top[] and bottom[] are processed further down:
<span class="udiff-line-modified-removed">-           tap-&gt;_klass != NULL  &amp;&amp; this-&gt;_klass != NULL   &amp;&amp;</span>
<span class="udiff-line-modified-added">+           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;</span>
            // both are exact and not equal:
            ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
<span class="udiff-line-modified-removed">-            // &#39;tap&#39;  is exact and super or unrelated:</span>
<span class="udiff-line-modified-added">+            // &#39;tap&#39; is exact and super or unrelated:</span>
             (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
             // &#39;this&#39; is exact and super or unrelated:
             (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
        if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
<span class="udiff-line-modified-removed">-         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);</span>
<span class="udiff-line-modified-added">+         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);</span>
<span class="udiff-line-added">+     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_flat_array_klass() != tap-&gt;klass()-&gt;is_flat_array_klass()) {</span>
<span class="udiff-line-added">+       // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.</span>
<span class="udiff-line-added">+       if (tary-&gt;_elem-&gt;isa_inlinetype()) {</span>
<span class="udiff-line-added">+         // Result is flattened</span>
<span class="udiff-line-added">+         off = Offset(elem()-&gt;isa_inlinetype() ? offset() : tap-&gt;offset());</span>
<span class="udiff-line-added">+         field_off = elem()-&gt;isa_inlinetype() ? field_offset() : tap-&gt;field_offset();</span>
<span class="udiff-line-added">+       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {</span>
<span class="udiff-line-added">+         // Result is non-flattened</span>
<span class="udiff-line-added">+         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));</span>
<span class="udiff-line-added">+         field_off = Offset::bottom;</span>
        }
<span class="udiff-line-removed">-       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);</span>
      }
  
      bool xk = false;
      switch (tap-&gt;ptr()) {
      case AnyNull:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4339,11 +4718,11 @@</span>
        if (below_centerline(this-&gt;_ptr)) {
          xk = this-&gt;_klass_is_exact;
        } else {
          xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
        }
<span class="udiff-line-modified-removed">-       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);</span>
      case Constant: {
        ciObject* o = const_oop();
        if( _ptr == Constant ) {
          if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
            xk = (klass() == tap-&gt;klass());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4358,45 +4737,45 @@</span>
          xk = true;
        } else {
          // Only precise for identical arrays
          xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
        }
<span class="udiff-line-modified-removed">-       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);</span>
      }
      case NotNull:
      case BotPTR:
        // Compute new klass on demand, do not use tap-&gt;_klass
        if (above_centerline(this-&gt;_ptr))
              xk = tap-&gt;_klass_is_exact;
        else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
                (klass() == tap-&gt;klass()); // Only precise for identical arrays
<span class="udiff-line-modified-removed">-       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);</span>
      default: ShouldNotReachHere();
      }
    }
  
    // All arrays inherit from Object class
    case InstPtr: {
      const TypeInstPtr *tp = t-&gt;is_instptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR ptr = meet_ptr(tp-&gt;ptr());
      int instance_id = meet_instance_id(tp-&gt;instance_id());
      const TypePtr* speculative = xmeet_speculative(tp);
      int depth = meet_inline_depth(tp-&gt;inline_depth());
      switch (ptr) {
      case TopPTR:
      case AnyNull:                // Fall &#39;down&#39; to dual of object klass
        // For instances when a subclass meets a superclass we fall
        // below the centerline when the superclass is exact. We need to
        // do the same here.
<span class="udiff-line-modified-removed">-       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {</span>
<span class="udiff-line-modified-removed">-         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
<span class="udiff-line-modified-added">+         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
        } else {
          // cannot subclass, so the meet has to fall badly below the centerline
          ptr = NotNull;
          instance_id = InstanceBot;
<span class="udiff-line-modified-removed">-         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
        }
      case Constant:
      case NotNull:
      case BotPTR:                // Fall down to object klass
        // LCA is object_klass, but if we subclass from the top we can do better
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4404,33 +4783,55 @@</span>
          // If &#39;tp&#39;  is above the centerline and it is Object class
          // then we can subclass in the Java class hierarchy.
          // For instances when a subclass meets a superclass we fall
          // below the centerline when the superclass is exact. We need
          // to do the same here.
<span class="udiff-line-modified-removed">-         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {</span>
<span class="udiff-line-modified-added">+         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
            // that is, my array type is a subtype of &#39;tp&#39; klass
            return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="udiff-line-modified-removed">-                       _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
          }
        }
        // The other case cannot happen, since t cannot be a subtype of an array.
        // The meet falls down to Object class below centerline.
        if( ptr == Constant )
           ptr = NotNull;
        instance_id = InstanceBot;
<span class="udiff-line-modified-removed">-       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);</span>
<span class="udiff-line-modified-added">+       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
      default: typerr(t);
      }
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   case InlineType: {</span>
<span class="udiff-line-added">+     const TypeInlineType* tv = t-&gt;is_inlinetype();</span>
<span class="udiff-line-added">+     if (above_centerline(ptr())) {</span>
<span class="udiff-line-added">+       return TypeInstPtr::NOTNULL;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       PTR ptr = this-&gt;_ptr;</span>
<span class="udiff-line-added">+       if (ptr == Constant) {</span>
<span class="udiff-line-added">+         ptr = NotNull;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
    }
    return this;                  // Lint noise
  }
  
  //------------------------------xdual------------------------------------------
  // Dual: compute field-by-field dual
  const Type *TypeAryPtr::xdual() const {
<span class="udiff-line-modified-removed">-   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());</span>
<span class="udiff-line-modified-added">+   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {</span>
<span class="udiff-line-added">+   return _field_offset.meet(offset);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------dual_offset------------------------------------</span>
<span class="udiff-line-added">+ Type::Offset TypeAryPtr::dual_field_offset() const {</span>
<span class="udiff-line-added">+   return _field_offset.dual();</span>
  }
  
  //----------------------interface_vs_oop---------------------------------------
  #ifdef ASSERT
  bool TypeAryPtr::interface_vs_oop(const Type *t) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4463,20 +4864,25 @@</span>
      break;
    default:
      break;
    }
  
<span class="udiff-line-modified-removed">-   if( _offset != 0 ) {</span>
<span class="udiff-line-modified-added">+   if (elem()-&gt;isa_inlinetype()) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;(&quot;);</span>
<span class="udiff-line-added">+     _field_offset.dump2(st);</span>
<span class="udiff-line-added">+     st-&gt;print(&quot;)&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (offset() != 0) {</span>
      int header_size = objArrayOopDesc::header_size() * wordSize;
<span class="udiff-line-modified-removed">-     if( _offset == OffsetTop )       st-&gt;print(&quot;+undefined&quot;);</span>
<span class="udiff-line-modified-removed">-     else if( _offset == OffsetBot )  st-&gt;print(&quot;+any&quot;);</span>
<span class="udiff-line-modified-removed">-     else if( _offset &lt; header_size ) st-&gt;print(&quot;+%d&quot;, _offset);</span>
<span class="udiff-line-modified-added">+     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);</span>
<span class="udiff-line-modified-added">+     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);</span>
<span class="udiff-line-modified-added">+     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());</span>
      else {
        BasicType basic_elem_type = elem()-&gt;basic_type();
        int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
        int elem_size = type2aelembytes(basic_elem_type);
<span class="udiff-line-modified-removed">-       st-&gt;print(&quot;[%d]&quot;, (_offset - array_base)/elem_size);</span>
<span class="udiff-line-modified-added">+       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);</span>
      }
    }
    st-&gt;print(&quot; *&quot;);
    if (_instance_id == InstanceTop)
      st-&gt;print(&quot;,iid=top&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4493,35 +4899,99 @@</span>
    return TypeOopPtr::empty();
  }
  
  //------------------------------add_offset-------------------------------------
  const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
<span class="udiff-line-modified-removed">-   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _field_offset, _instance_id, add_offset_speculative(offset), _inline_depth, _is_autobox_cache);</span>
  }
  
  const Type *TypeAryPtr::remove_speculative() const {
    if (_speculative == NULL) {
      return this;
    }
    assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="udiff-line-modified-removed">-   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, NULL, _inline_depth, _is_autobox_cache);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const Type* TypeAryPtr::cleanup_speculative() const {</span>
<span class="udiff-line-added">+   if (speculative() == NULL) {</span>
<span class="udiff-line-added">+     return this;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Keep speculative part if it contains information about flat-/nullability</span>
<span class="udiff-line-added">+   const TypeAryPtr* spec_aryptr = speculative()-&gt;isa_aryptr();</span>
<span class="udiff-line-added">+   if (spec_aryptr != NULL &amp;&amp; (spec_aryptr-&gt;is_not_flat() || spec_aryptr-&gt;is_not_null_free())) {</span>
<span class="udiff-line-added">+     return this;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return TypeOopPtr::cleanup_speculative();</span>
  }
  
  const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
    if (!UseInlineDepthForSpeculativeTypes) {
      return this;
    }
<span class="udiff-line-modified-removed">-   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, _speculative, depth);</span>
<span class="udiff-line-modified-added">+   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {</span>
<span class="udiff-line-added">+   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {</span>
<span class="udiff-line-added">+   int adj = 0;</span>
<span class="udiff-line-added">+   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {</span>
<span class="udiff-line-added">+     const Type* elemtype = elem();</span>
<span class="udiff-line-added">+     if (elemtype-&gt;isa_inlinetype()) {</span>
<span class="udiff-line-added">+       if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {</span>
<span class="udiff-line-added">+         adj = _offset.get();</span>
<span class="udiff-line-added">+         offset += _offset.get();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);</span>
<span class="udiff-line-added">+       if (_field_offset.get() != OffsetBot &amp;&amp; _field_offset.get() != OffsetTop) {</span>
<span class="udiff-line-added">+         offset += _field_offset.get();</span>
<span class="udiff-line-added">+         if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {</span>
<span class="udiff-line-added">+           offset += header;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (offset &gt;= (intptr_t)header || offset &lt; 0) {</span>
<span class="udiff-line-added">+         // Try to get the field of the inline type array element we are pointing to</span>
<span class="udiff-line-added">+         ciKlass* arytype_klass = klass();</span>
<span class="udiff-line-added">+         ciFlatArrayKlass* vak = arytype_klass-&gt;as_flat_array_klass();</span>
<span class="udiff-line-added">+         ciInlineKlass* vk = vak-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="udiff-line-added">+         int shift = vak-&gt;log2_element_size();</span>
<span class="udiff-line-added">+         int mask = (1 &lt;&lt; shift) - 1;</span>
<span class="udiff-line-added">+         intptr_t field_offset = ((offset - header) &amp; mask);</span>
<span class="udiff-line-added">+         ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);</span>
<span class="udiff-line-added">+         if (field == NULL) {</span>
<span class="udiff-line-added">+           // This may happen with nested AddP(base, AddP(base, base, offset), longcon(16))</span>
<span class="udiff-line-added">+           return add_offset(offset);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           return with_field_offset(field_offset)-&gt;add_offset(offset - field_offset - adj);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return add_offset(offset - adj);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Return offset incremented by field_offset for flattened inline type arrays</span>
<span class="udiff-line-added">+ const int TypeAryPtr::flattened_offset() const {</span>
<span class="udiff-line-added">+   int offset = _offset.get();</span>
<span class="udiff-line-added">+   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;</span>
<span class="udiff-line-added">+       _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {</span>
<span class="udiff-line-added">+     offset += _field_offset.get();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return offset;</span>
  }
  
  const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
    assert(is_known_instance(), &quot;should be known&quot;);
<span class="udiff-line-modified-removed">-   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);</span>
<span class="udiff-line-modified-added">+   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);</span>
  }
  
  //=============================================================================
  
<span class="udiff-line-added">+ </span>
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeNarrowPtr::hash(void) const {
    return _ptrtype-&gt;hash() + 7;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4606,16 +5076,18 @@</span>
    case AryPtr:
    case MetadataPtr:
    case KlassPtr:
    case NarrowOop:
    case NarrowKlass:
<span class="udiff-line-removed">- </span>
    case Bottom:                  // Ye Olde Default
      return Type::BOTTOM;
    case Top:
      return this;
  
<span class="udiff-line-added">+   case InlineType:</span>
<span class="udiff-line-added">+     return t-&gt;xmeet(this);</span>
<span class="udiff-line-added">+ </span>
    default:                      // All else is a mistake
      typerr(t);
  
    } // End of switch
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4690,11 +5162,11 @@</span>
  // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
  // constants
  bool TypeMetadataPtr::singleton(void) const {
    // detune optimizer to not generate constant metadata + constant offset as a constant!
    // TopPTR, Null, AnyNull, Constant are all singletons
<span class="udiff-line-modified-removed">-   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);</span>
<span class="udiff-line-modified-added">+   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);</span>
  }
  
  //------------------------------add_offset-------------------------------------
  const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
    return make( _ptr, _metadata, xadd_offset(offset));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4710,13 +5182,13 @@</span>
  }
  
   //------------------------------get_con----------------------------------------
  intptr_t TypeMetadataPtr::get_con() const {
    assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="udiff-line-modified-removed">-   assert( _offset &gt;= 0, &quot;&quot; );</span>
<span class="udiff-line-modified-added">+   assert(offset() &gt;= 0, &quot;&quot;);</span>
  
<span class="udiff-line-modified-removed">-   if (_offset != 0) {</span>
<span class="udiff-line-modified-added">+   if (offset() != 0) {</span>
      // After being ported to the compiler interface, the compiler no longer
      // directly manipulates the addresses of oops.  Rather, it only has a pointer
      // to a handle at compile time.  This handle is embedded in the generated
      // code and dereferenced at the time the nmethod is made.  Until that time,
      // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4763,11 +5235,11 @@</span>
      typerr(t);
  
    case AnyPtr: {
      // Found an AnyPtr type vs self-OopPtr type
      const TypePtr *tp = t-&gt;is_ptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR ptr = meet_ptr(tp-&gt;ptr());
      switch (tp-&gt;ptr()) {
      case Null:
        if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
        // else fall through:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4789,11 +5261,11 @@</span>
    case AryPtr:
      return TypePtr::BOTTOM;     // Oop meet raw is not well defined
  
    case MetadataPtr: {
      const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR tptr = tp-&gt;ptr();
      PTR ptr = meet_ptr(tptr);
      ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
      if (tptr == TopPTR || _ptr == TopPTR ||
          metadata()-&gt;equals(tp-&gt;metadata())) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4822,38 +5294,38 @@</span>
  //------------------------------dump2------------------------------------------
  #ifndef PRODUCT
  void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
    st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
    if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
<span class="udiff-line-modified-removed">-   switch( _offset ) {</span>
<span class="udiff-line-modified-added">+   switch (offset()) {</span>
    case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
    case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
    case         0: break;
<span class="udiff-line-modified-removed">-   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;</span>
<span class="udiff-line-modified-added">+   default:        st-&gt;print(&quot;+%d&quot;,offset()); break;</span>
    }
  }
  #endif
  
  
  //=============================================================================
  // Convenience common pre-built type.
  const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
  
<span class="udiff-line-modified-removed">- TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset):</span>
<span class="udiff-line-modified-added">+ TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset):</span>
    TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
  }
  
  const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
<span class="udiff-line-modified-removed">-   return make(Constant, m, 0);</span>
<span class="udiff-line-modified-added">+   return make(Constant, m, Offset(0));</span>
  }
  const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
<span class="udiff-line-modified-removed">-   return make(Constant, m, 0);</span>
<span class="udiff-line-modified-added">+   return make(Constant, m, Offset(0));</span>
  }
  
  //------------------------------make-------------------------------------------
  // Create a meta data constant
<span class="udiff-line-modified-removed">- const TypeMetadataPtr *TypeMetadataPtr::make(PTR ptr, ciMetadata* m, int offset) {</span>
<span class="udiff-line-modified-added">+ const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {</span>
    assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
    return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4863,47 +5335,43 @@</span>
  // Not-null object klass or below
  const TypeKlassPtr *TypeKlassPtr::OBJECT;
  const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
  
  //------------------------------TypeKlassPtr-----------------------------------
<span class="udiff-line-modified-removed">- TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )</span>
<span class="udiff-line-modified-removed">-   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {</span>
<span class="udiff-line-modified-added">+ TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)</span>
<span class="udiff-line-modified-added">+   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {</span>
<span class="udiff-line-added">+    assert(!klass-&gt;is_inlinetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="udiff-line-added">+    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
  }
  
  //------------------------------make-------------------------------------------
  // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
<span class="udiff-line-modified-removed">- const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {</span>
<span class="udiff-line-modified-removed">-   assert( k != NULL, &quot;Expect a non-NULL klass&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);</span>
<span class="udiff-line-removed">-   TypeKlassPtr *r =</span>
<span class="udiff-line-removed">-     (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))-&gt;hashcons();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return r;</span>
<span class="udiff-line-modified-added">+ const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {</span>
<span class="udiff-line-modified-added">+   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);</span>
<span class="udiff-line-modified-added">+   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();</span>
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypeKlassPtr::eq( const Type *t ) const {
    const TypeKlassPtr *p = t-&gt;is_klassptr();
<span class="udiff-line-modified-removed">-   return</span>
<span class="udiff-line-removed">-     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;</span>
<span class="udiff-line-removed">-     TypePtr::eq(p);</span>
<span class="udiff-line-modified-added">+   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();</span>
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeKlassPtr::hash(void) const {
<span class="udiff-line-modified-removed">-   return java_add((jint)klass()-&gt;hash(), (jint)TypePtr::hash());</span>
<span class="udiff-line-modified-added">+   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());</span>
  }
  
  //------------------------------singleton--------------------------------------
  // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
  // constants
  bool TypeKlassPtr::singleton(void) const {
    // detune optimizer to not generate constant klass + constant offset as a constant!
    // TopPTR, Null, AnyNull, Constant are all singletons
<span class="udiff-line-modified-removed">-   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);</span>
<span class="udiff-line-modified-added">+   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);</span>
  }
  
  // Do not allow interface-vs.-noninterface joins to collapse to top.
  const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
    // logic here mirrors the one from TypeOopPtr::filter. See comments
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4911,11 +5379,11 @@</span>
    const Type* ft = join_helper(kills, include_speculative);
    const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
    const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
  
    if (ft-&gt;empty()) {
<span class="udiff-line-modified-removed">-     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;klass()-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())</span>
<span class="udiff-line-modified-added">+     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())</span>
        return kills;             // Uplift to interface
  
      return Type::TOP;           // Canonical empty value
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4934,21 +5402,25 @@</span>
  //----------------------compute_klass------------------------------------------
  // Compute the defining klass for this class
  ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
    // Compute _klass based on element type.
    ciKlass* k_ary = NULL;
<span class="udiff-line-removed">-   const TypeInstPtr *tinst;</span>
    const TypeAryPtr *tary;
    const Type* el = elem();
    if (el-&gt;isa_narrowoop()) {
      el = el-&gt;make_ptr();
    }
  
    // Get element klass
<span class="udiff-line-modified-removed">-   if ((tinst = el-&gt;isa_instptr()) != NULL) {</span>
<span class="udiff-line-modified-removed">-     // Compute array klass from element klass</span>
<span class="udiff-line-modified-removed">-     k_ary = ciObjArrayKlass::make(tinst-&gt;klass());</span>
<span class="udiff-line-modified-added">+   if (el-&gt;isa_instptr()) {</span>
<span class="udiff-line-modified-added">+     // Compute object array klass from element klass</span>
<span class="udiff-line-modified-added">+     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());</span>
<span class="udiff-line-added">+   } else if (el-&gt;isa_inlinetype()) {</span>
<span class="udiff-line-added">+     // If element type is TypeInlineType::BOTTOM, inline_klass() will be null.</span>
<span class="udiff-line-added">+     if (el-&gt;inline_klass() != NULL) {</span>
<span class="udiff-line-added">+       k_ary = ciArrayKlass::make(el-&gt;inline_klass());</span>
<span class="udiff-line-added">+     }</span>
    } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
      // Compute array klass from element klass
      ciKlass* k_elem = tary-&gt;klass();
      // If element type is something like bottom[], k_elem will be null.
      if (k_elem != NULL)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5009,49 +5481,53 @@</span>
      // Recomputing the underlying ciKlass for each request is
      // a bit less efficient than caching, but calls to
      // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
      ((TypeAryPtr*)this)-&gt;_klass = k_ary;
      if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
<span class="udiff-line-modified-removed">-         _offset != 0 &amp;&amp; _offset != arrayOopDesc::length_offset_in_bytes()) {</span>
<span class="udiff-line-modified-added">+         offset() != 0 &amp;&amp; offset() != arrayOopDesc::length_offset_in_bytes()) {</span>
        ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
      }
    }
    return k_ary;
  }
  
  
  //------------------------------add_offset-------------------------------------
  // Access internals of klass object
  const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
<span class="udiff-line-modified-removed">-   return make( _ptr, klass(), xadd_offset(offset) );</span>
<span class="udiff-line-modified-added">+   return make(_ptr, klass(), xadd_offset(offset), flat_array());</span>
  }
  
  //------------------------------cast_to_ptr_type-------------------------------
  const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
    assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
    if( ptr == _ptr ) return this;
<span class="udiff-line-modified-removed">-   return make(ptr, _klass, _offset);</span>
<span class="udiff-line-modified-added">+   return make(ptr, _klass, _offset, _flat_array);</span>
  }
  
  
  //-----------------------------cast_to_exactness-------------------------------
  const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
    if( klass_is_exact == _klass_is_exact ) return this;
<span class="udiff-line-modified-removed">-   return make(klass_is_exact ? Constant : NotNull, _klass, _offset);</span>
<span class="udiff-line-modified-added">+   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);</span>
  }
  
  
  //-----------------------------as_instance_type--------------------------------
  // Corresponding type for an instance of the given class.
  // It will be NotNull, and exact if and only if the klass type is exact.
  const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
    ciKlass* k = klass();
<span class="udiff-line-added">+   assert(k != NULL, &quot;klass should not be NULL&quot;);</span>
    bool    xk = klass_is_exact();
    //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
    const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
    guarantee(toop != NULL, &quot;need type for given klass&quot;);
    toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="udiff-line-added">+   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
<span class="udiff-line-added">+     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();</span>
<span class="udiff-line-added">+   }</span>
    return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
  }
  
  
  //------------------------------xmeet------------------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5082,19 +5558,19 @@</span>
      typerr(t);
  
    case AnyPtr: {                // Meeting to AnyPtrs
      // Found an AnyPtr type vs self-KlassPtr type
      const TypePtr *tp = t-&gt;is_ptr();
<span class="udiff-line-modified-removed">-     int offset = meet_offset(tp-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset offset = meet_offset(tp-&gt;offset());</span>
      PTR ptr = meet_ptr(tp-&gt;ptr());
      switch (tp-&gt;ptr()) {
      case TopPTR:
        return this;
      case Null:
        if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
      case AnyNull:
<span class="udiff-line-modified-removed">-       return make( ptr, klass(), offset );</span>
<span class="udiff-line-modified-added">+       return make(ptr, klass(), offset, flat_array());</span>
      case BotPTR:
      case NotNull:
        return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
      default: typerr(t);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5123,26 +5599,37 @@</span>
    //             A-bot         }
    //
  
    case KlassPtr: {  // Meet two KlassPtr types
      const TypeKlassPtr *tkls = t-&gt;is_klassptr();
<span class="udiff-line-modified-removed">-     int  off     = meet_offset(tkls-&gt;offset());</span>
<span class="udiff-line-modified-added">+     Offset  off  = meet_offset(tkls-&gt;offset());</span>
      PTR  ptr     = meet_ptr(tkls-&gt;ptr());
  
<span class="udiff-line-added">+     if (klass() == NULL || tkls-&gt;klass() == NULL) {</span>
<span class="udiff-line-added">+       ciKlass* k = NULL;</span>
<span class="udiff-line-added">+       if (ptr == Constant) {</span>
<span class="udiff-line-added">+         k = (klass() == NULL) ? tkls-&gt;klass() : klass();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       return make(ptr, k, off, false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      // Check for easy case; klasses are equal (and perhaps not loaded!)
      // If we have constants, then we created oops so classes are loaded
      // and we can handle the constants further down.  This case handles
      // not-loaded classes
<span class="udiff-line-modified-removed">-     if( ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) ) {</span>
<span class="udiff-line-modified-removed">-       return make( ptr, klass(), off );</span>
<span class="udiff-line-modified-added">+     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flat_array() == tkls-&gt;flat_array()) {</span>
<span class="udiff-line-modified-added">+       return make(ptr, klass(), off, flat_array());</span>
      }
  
      // Classes require inspection in the Java klass hierarchy.  Must be loaded.
      ciKlass* tkls_klass = tkls-&gt;klass();
      ciKlass* this_klass = this-&gt;klass();
      assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
      assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
<span class="udiff-line-added">+     bool tkls_flat_array = tkls-&gt;flat_array();</span>
<span class="udiff-line-added">+     bool this_flat_array  = this-&gt;flat_array();</span>
<span class="udiff-line-added">+     bool flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tkls_flat_array) : (this_flat_array || tkls_flat_array);</span>
  
      // If &#39;this&#39; type is above the centerline and is a superclass of the
      // other, we can treat &#39;this&#39; as having the same type as the other.
      if ((above_centerline(this-&gt;ptr())) &amp;&amp;
          tkls_klass-&gt;is_subtype_of(this_klass)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5166,38 +5653,38 @@</span>
          else if (above_centerline(this-&gt;ptr()));
          else if (above_centerline(tkls-&gt;ptr()));
          else
            ptr = NotNull;
        }
<span class="udiff-line-modified-removed">-       return make( ptr, this_klass, off );</span>
<span class="udiff-line-modified-added">+       return make(ptr, this_klass, off, flat_array);</span>
      } // Else classes are not equal
  
      // Since klasses are different, we require the LCA in the Java
      // class hierarchy - which means we have to fall to at least NotNull.
      if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
        ptr = NotNull;
      // Now we find the LCA of Java classes
      ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="udiff-line-modified-removed">-     return   make( ptr, k, off );</span>
<span class="udiff-line-modified-added">+     return   make(ptr, k, off, k-&gt;is_inlinetype() &amp;&amp; k-&gt;flatten_array());</span>
    } // End of case KlassPtr
  
    } // End of switch
    return this;                  // Return the double constant
  }
  
  //------------------------------xdual------------------------------------------
  // Dual: compute field-by-field dual
  const Type    *TypeKlassPtr::xdual() const {
<span class="udiff-line-modified-removed">-   return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );</span>
<span class="udiff-line-modified-added">+   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());</span>
  }
  
  //------------------------------get_con----------------------------------------
  intptr_t TypeKlassPtr::get_con() const {
    assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="udiff-line-modified-removed">-   assert( _offset &gt;= 0, &quot;&quot; );</span>
<span class="udiff-line-modified-added">+   assert(offset() &gt;= 0, &quot;&quot;);</span>
  
<span class="udiff-line-modified-removed">-   if (_offset != 0) {</span>
<span class="udiff-line-modified-added">+   if (offset() != 0) {</span>
      // After being ported to the compiler interface, the compiler no longer
      // directly manipulates the addresses of oops.  Rather, it only has a pointer
      // to a handle at compile time.  This handle is embedded in the generated
      // code and dereferenced at the time the nmethod is made.  Until that time,
      // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5216,15 +5703,15 @@</span>
    switch( _ptr ) {
    case Constant:
      st-&gt;print(&quot;precise &quot;);
    case NotNull:
      {
<span class="udiff-line-modified-removed">-       const char *name = klass()-&gt;name()-&gt;as_utf8();</span>
<span class="udiff-line-modified-removed">-       if( name ) {</span>
<span class="udiff-line-modified-added">+       if (klass() != NULL) {</span>
<span class="udiff-line-modified-added">+         const char* name = klass()-&gt;name()-&gt;as_utf8();</span>
          st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
        } else {
<span class="udiff-line-modified-removed">-         ShouldNotReachHere();</span>
<span class="udiff-line-modified-added">+         st-&gt;print(&quot;klass BOTTOM&quot;);</span>
        }
      }
    case BotPTR:
      if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
    case TopPTR:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5234,15 +5721,11 @@</span>
      break;
    default:
      break;
    }
  
<span class="udiff-line-modified-removed">-   if( _offset ) {               // Dump offset, if any</span>
<span class="udiff-line-removed">-     if( _offset == OffsetBot )      { st-&gt;print(&quot;+any&quot;); }</span>
<span class="udiff-line-removed">-     else if( _offset == OffsetTop ) { st-&gt;print(&quot;+unknown&quot;); }</span>
<span class="udiff-line-removed">-     else                            { st-&gt;print(&quot;+%d&quot;, _offset); }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   _offset.dump2(st);</span>
  
    st-&gt;print(&quot; *&quot;);
  }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5250,28 +5733,50 @@</span>
  
  //=============================================================================
  // Convenience common pre-built types.
  
  //------------------------------make-------------------------------------------
<span class="udiff-line-modified-removed">- const TypeFunc *TypeFunc::make( const TypeTuple *domain, const TypeTuple *range ) {</span>
<span class="udiff-line-modified-removed">-   return (TypeFunc*)(new TypeFunc(domain,range))-&gt;hashcons();</span>
<span class="udiff-line-modified-added">+ const TypeFunc *TypeFunc::make(const TypeTuple *domain_sig, const TypeTuple* domain_cc,</span>
<span class="udiff-line-modified-added">+                                const TypeTuple *range_sig, const TypeTuple *range_cc) {</span>
<span class="udiff-line-added">+   return (TypeFunc*)(new TypeFunc(domain_sig, domain_cc, range_sig, range_cc))-&gt;hashcons();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {</span>
<span class="udiff-line-added">+   return make(domain, domain, range, range);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------osr_domain-----------------------------</span>
<span class="udiff-line-added">+ const TypeTuple* osr_domain() {</span>
<span class="udiff-line-added">+   const Type **fields = TypeTuple::fields(2);</span>
<span class="udiff-line-added">+   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer</span>
<span class="udiff-line-added">+   return TypeTuple::make(TypeFunc::Parms+1, fields);</span>
  }
  
  //------------------------------make-------------------------------------------
<span class="udiff-line-modified-removed">- const TypeFunc *TypeFunc::make(ciMethod* method) {</span>
<span class="udiff-line-modified-added">+ const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {</span>
    Compile* C = Compile::current();
<span class="udiff-line-modified-removed">-   const TypeFunc* tf = C-&gt;last_tf(method); // check cache</span>
<span class="udiff-line-modified-removed">-   if (tf != NULL)  return tf;  // The hit rate here is almost 50%.</span>
<span class="udiff-line-modified-removed">-   const TypeTuple *domain;</span>
<span class="udiff-line-modified-removed">-   if (method-&gt;is_static()) {</span>
<span class="udiff-line-modified-removed">-     domain = TypeTuple::make_domain(NULL, method-&gt;signature());</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     domain = TypeTuple::make_domain(method-&gt;holder(), method-&gt;signature());</span>
<span class="udiff-line-modified-added">+   const TypeFunc* tf = NULL;</span>
<span class="udiff-line-modified-added">+   if (!is_osr_compilation) {</span>
<span class="udiff-line-modified-added">+     tf = C-&gt;last_tf(method); // check cache</span>
<span class="udiff-line-modified-added">+     if (tf != NULL)  return tf;  // The hit rate here is almost 50%.</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   // Inline types are not passed/returned by reference, instead each field of</span>
<span class="udiff-line-modified-added">+   // the inline type is passed/returned as an argument. We maintain two views of</span>
<span class="udiff-line-added">+   // the argument/return list here: one based on the signature (with an inline</span>
<span class="udiff-line-added">+   // type argument/return as a single slot), one based on the actual calling</span>
<span class="udiff-line-added">+   // convention (with an inline type argument/return as a list of its fields).</span>
<span class="udiff-line-added">+   bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;</span>
<span class="udiff-line-added">+   const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);</span>
<span class="udiff-line-added">+   const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;</span>
<span class="udiff-line-added">+   ciSignature* sig = method-&gt;signature();</span>
<span class="udiff-line-added">+   bool has_scalar_ret = sig-&gt;return_type()-&gt;is_inlinetype() &amp;&amp; sig-&gt;return_type()-&gt;as_inline_klass()-&gt;can_be_returned_as_fields();</span>
<span class="udiff-line-added">+   const TypeTuple* range_sig = TypeTuple::make_range(sig, false);</span>
<span class="udiff-line-added">+   const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;</span>
<span class="udiff-line-added">+   tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);</span>
<span class="udiff-line-added">+   if (!is_osr_compilation) {</span>
<span class="udiff-line-added">+     C-&gt;set_last_tf(method, tf);  // fill cache</span>
    }
<span class="udiff-line-removed">-   const TypeTuple *range  = TypeTuple::make_range(method-&gt;signature());</span>
<span class="udiff-line-removed">-   tf = TypeFunc::make(domain, range);</span>
<span class="udiff-line-removed">-   C-&gt;set_last_tf(method, tf);  // fill cache</span>
    return tf;
  }
  
  //------------------------------meet-------------------------------------------
  // Compute the MEET of two types.  It returns a new Type object.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5302,46 +5807,48 @@</span>
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypeFunc::eq( const Type *t ) const {
    const TypeFunc *a = (const TypeFunc*)t;
<span class="udiff-line-modified-removed">-   return _domain == a-&gt;_domain &amp;&amp;</span>
<span class="udiff-line-modified-removed">-     _range == a-&gt;_range;</span>
<span class="udiff-line-modified-added">+   return _domain_sig == a-&gt;_domain_sig &amp;&amp;</span>
<span class="udiff-line-modified-added">+     _domain_cc == a-&gt;_domain_cc &amp;&amp;</span>
<span class="udiff-line-added">+     _range_sig == a-&gt;_range_sig &amp;&amp;</span>
<span class="udiff-line-added">+     _range_cc == a-&gt;_range_cc;</span>
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeFunc::hash(void) const {
<span class="udiff-line-modified-removed">-   return (intptr_t)_domain + (intptr_t)_range;</span>
<span class="udiff-line-modified-added">+   return (intptr_t)_domain_sig + (intptr_t)_domain_cc + (intptr_t)_range_sig + (intptr_t)_range_cc;</span>
  }
  
  //------------------------------dump2------------------------------------------
  // Dump Function Type
  #ifndef PRODUCT
  void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
<span class="udiff-line-modified-removed">-   if( _range-&gt;cnt() &lt;= Parms )</span>
<span class="udiff-line-modified-added">+   if( _range_sig-&gt;cnt() &lt;= Parms )</span>
      st-&gt;print(&quot;void&quot;);
    else {
      uint i;
<span class="udiff-line-modified-removed">-     for (i = Parms; i &lt; _range-&gt;cnt()-1; i++) {</span>
<span class="udiff-line-modified-removed">-       _range-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
<span class="udiff-line-modified-added">+     for (i = Parms; i &lt; _range_sig-&gt;cnt()-1; i++) {</span>
<span class="udiff-line-modified-added">+       _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
        st-&gt;print(&quot;/&quot;);
      }
<span class="udiff-line-modified-removed">-     _range-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
<span class="udiff-line-modified-added">+     _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
    }
    st-&gt;print(&quot; &quot;);
    st-&gt;print(&quot;( &quot;);
    if( !depth || d[this] ) {     // Check for recursive dump
      st-&gt;print(&quot;...)&quot;);
      return;
    }
    d.Insert((void*)this,(void*)this);    // Stop recursion
<span class="udiff-line-modified-removed">-   if (Parms &lt; _domain-&gt;cnt())</span>
<span class="udiff-line-modified-removed">-     _domain-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);</span>
<span class="udiff-line-modified-removed">-   for (uint i = Parms+1; i &lt; _domain-&gt;cnt(); i++) {</span>
<span class="udiff-line-modified-added">+   if (Parms &lt; _domain_sig-&gt;cnt())</span>
<span class="udiff-line-modified-added">+     _domain_sig-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);</span>
<span class="udiff-line-modified-added">+   for (uint i = Parms+1; i &lt; _domain_sig-&gt;cnt(); i++) {</span>
      st-&gt;print(&quot;, &quot;);
<span class="udiff-line-modified-removed">-     _domain-&gt;field_at(i)-&gt;dump2(d,depth-1,st);</span>
<span class="udiff-line-modified-added">+     _domain_sig-&gt;field_at(i)-&gt;dump2(d,depth-1,st);</span>
    }
    st-&gt;print(&quot; )&quot;);
  }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5357,10 +5864,10 @@</span>
    return false;                 // Never empty
  }
  
  
  BasicType TypeFunc::return_type() const{
<span class="udiff-line-modified-removed">-   if (range()-&gt;cnt() == TypeFunc::Parms) {</span>
<span class="udiff-line-modified-added">+   if (range_sig()-&gt;cnt() == TypeFunc::Parms) {</span>
      return T_VOID;
    }
<span class="udiff-line-modified-removed">-   return range()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();</span>
<span class="udiff-line-modified-added">+   return range_sig()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();</span>
  }
</pre>
<center><a href="subnode.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>