<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/loopnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_LOOPNODE_HPP
  26 #define SHARE_OPTO_LOOPNODE_HPP
  27 
  28 #include &quot;opto/cfgnode.hpp&quot;
  29 #include &quot;opto/multnode.hpp&quot;
  30 #include &quot;opto/phaseX.hpp&quot;
  31 #include &quot;opto/subnode.hpp&quot;
  32 #include &quot;opto/type.hpp&quot;
  33 
  34 class CmpNode;
  35 class CountedLoopEndNode;
  36 class CountedLoopNode;
  37 class IdealLoopTree;
  38 class LoopNode;
  39 class Node;
  40 class OuterStripMinedLoopEndNode;
  41 class PathFrequency;
  42 class PhaseIdealLoop;
  43 class CountedLoopReserveKit;
  44 class VectorSet;
  45 class Invariance;
  46 struct small_cache;
  47 
  48 //
  49 //                  I D E A L I Z E D   L O O P S
  50 //
  51 // Idealized loops are the set of loops I perform more interesting
  52 // transformations on, beyond simple hoisting.
  53 
  54 //------------------------------LoopNode---------------------------------------
  55 // Simple loop header.  Fall in path on left, loop-back path on right.
  56 class LoopNode : public RegionNode {
  57   // Size is bigger to hold the flags.  However, the flags do not change
  58   // the semantics so it does not appear in the hash &amp; cmp functions.
  59   virtual uint size_of() const { return sizeof(*this); }
  60 protected:
  61   uint _loop_flags;
  62   // Names for flag bitfields
  63   enum { Normal=0, Pre=1, Main=2, Post=3, PreMainPostFlagsMask=3,
  64          MainHasNoPreLoop=4,
  65          HasExactTripCount=8,
  66          InnerLoop=16,
  67          PartialPeelLoop=32,
  68          PartialPeelFailed=64,
  69          HasReductions=128,
  70          WasSlpAnalyzed=256,
  71          PassedSlpAnalysis=512,
  72          DoUnrollOnly=1024,
  73          VectorizedLoop=2048,
  74          HasAtomicPostLoop=4096,
  75          HasRangeChecks=8192,
  76          IsMultiversioned=16384,
  77          StripMined=32768,
  78          SubwordLoop=65536,
<a name="1" id="anc1"></a><span class="line-modified">  79          ProfileTripFailed=131072,</span>
<span class="line-added">  80          FlattenedArrays=262144};</span>
  81   char _unswitch_count;
  82   enum { _unswitch_max=3 };
  83   char _postloop_flags;
  84   enum { LoopNotRCEChecked = 0, LoopRCEChecked = 1, RCEPostLoop = 2 };
  85 
  86   // Expected trip count from profile data
  87   float _profile_trip_cnt;
  88 
  89 public:
  90   // Names for edge indices
  91   enum { Self=0, EntryControl, LoopBackControl };
  92 
  93   bool is_inner_loop() const { return _loop_flags &amp; InnerLoop; }
  94   void set_inner_loop() { _loop_flags |= InnerLoop; }
  95 
  96   bool range_checks_present() const { return _loop_flags &amp; HasRangeChecks; }
  97   bool is_multiversioned() const { return _loop_flags &amp; IsMultiversioned; }
  98   bool is_vectorized_loop() const { return _loop_flags &amp; VectorizedLoop; }
  99   bool is_partial_peel_loop() const { return _loop_flags &amp; PartialPeelLoop; }
 100   void set_partial_peel_loop() { _loop_flags |= PartialPeelLoop; }
 101   bool partial_peel_has_failed() const { return _loop_flags &amp; PartialPeelFailed; }
 102   bool is_strip_mined() const { return _loop_flags &amp; StripMined; }
 103   bool is_profile_trip_failed() const { return _loop_flags &amp; ProfileTripFailed; }
 104   bool is_subword_loop() const { return _loop_flags &amp; SubwordLoop; }
<a name="2" id="anc2"></a><span class="line-added"> 105   bool is_flattened_arrays() const { return _loop_flags &amp; FlattenedArrays; }</span>
 106 
 107   void mark_partial_peel_failed() { _loop_flags |= PartialPeelFailed; }
 108   void mark_has_reductions() { _loop_flags |= HasReductions; }
 109   void mark_was_slp() { _loop_flags |= WasSlpAnalyzed; }
 110   void mark_passed_slp() { _loop_flags |= PassedSlpAnalysis; }
 111   void mark_do_unroll_only() { _loop_flags |= DoUnrollOnly; }
 112   void mark_loop_vectorized() { _loop_flags |= VectorizedLoop; }
 113   void mark_has_atomic_post_loop() { _loop_flags |= HasAtomicPostLoop; }
 114   void mark_has_range_checks() { _loop_flags |=  HasRangeChecks; }
 115   void mark_is_multiversioned() { _loop_flags |= IsMultiversioned; }
 116   void mark_strip_mined() { _loop_flags |= StripMined; }
 117   void clear_strip_mined() { _loop_flags &amp;= ~StripMined; }
 118   void mark_profile_trip_failed() { _loop_flags |= ProfileTripFailed; }
 119   void mark_subword_loop() { _loop_flags |= SubwordLoop; }
<a name="3" id="anc3"></a><span class="line-added"> 120   void mark_flattened_arrays() { _loop_flags |= FlattenedArrays; }</span>
 121 
 122   int unswitch_max() { return _unswitch_max; }
 123   int unswitch_count() { return _unswitch_count; }
 124 
 125   int has_been_range_checked() const { return _postloop_flags &amp; LoopRCEChecked; }
 126   void set_has_been_range_checked() { _postloop_flags |= LoopRCEChecked; }
 127   int is_rce_post_loop() const { return _postloop_flags &amp; RCEPostLoop; }
 128   void set_is_rce_post_loop() { _postloop_flags |= RCEPostLoop; }
 129 
 130   void set_unswitch_count(int val) {
 131     assert (val &lt;= unswitch_max(), &quot;too many unswitches&quot;);
 132     _unswitch_count = val;
 133   }
 134 
 135   void set_profile_trip_cnt(float ptc) { _profile_trip_cnt = ptc; }
 136   float profile_trip_cnt()             { return _profile_trip_cnt; }
 137 
 138   LoopNode(Node *entry, Node *backedge)
 139     : RegionNode(3), _loop_flags(0), _unswitch_count(0),
 140       _postloop_flags(0), _profile_trip_cnt(COUNT_UNKNOWN)  {
 141     init_class_id(Class_Loop);
 142     init_req(EntryControl, entry);
 143     init_req(LoopBackControl, backedge);
 144   }
 145 
 146   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 147   virtual int Opcode() const;
 148   bool can_be_counted_loop(PhaseTransform* phase) const {
 149     return req() == 3 &amp;&amp; in(0) != NULL &amp;&amp;
 150       in(1) != NULL &amp;&amp; phase-&gt;type(in(1)) != Type::TOP &amp;&amp;
 151       in(2) != NULL &amp;&amp; phase-&gt;type(in(2)) != Type::TOP;
 152   }
 153   bool is_valid_counted_loop() const;
 154 #ifndef PRODUCT
 155   virtual void dump_spec(outputStream *st) const;
 156 #endif
 157 
 158   void verify_strip_mined(int expect_skeleton) const NOT_DEBUG_RETURN;
 159   virtual LoopNode* skip_strip_mined(int expect_skeleton = 1) { return this; }
 160   virtual IfTrueNode* outer_loop_tail() const { ShouldNotReachHere(); return NULL; }
 161   virtual OuterStripMinedLoopEndNode* outer_loop_end() const { ShouldNotReachHere(); return NULL; }
 162   virtual IfFalseNode* outer_loop_exit() const { ShouldNotReachHere(); return NULL; }
 163   virtual SafePointNode* outer_safepoint() const { ShouldNotReachHere(); return NULL; }
 164 };
 165 
 166 //------------------------------Counted Loops----------------------------------
 167 // Counted loops are all trip-counted loops, with exactly 1 trip-counter exit
 168 // path (and maybe some other exit paths).  The trip-counter exit is always
 169 // last in the loop.  The trip-counter have to stride by a constant;
 170 // the exit value is also loop invariant.
 171 
 172 // CountedLoopNodes and CountedLoopEndNodes come in matched pairs.  The
 173 // CountedLoopNode has the incoming loop control and the loop-back-control
 174 // which is always the IfTrue before the matching CountedLoopEndNode.  The
 175 // CountedLoopEndNode has an incoming control (possibly not the
 176 // CountedLoopNode if there is control flow in the loop), the post-increment
 177 // trip-counter value, and the limit.  The trip-counter value is always of
 178 // the form (Op old-trip-counter stride).  The old-trip-counter is produced
 179 // by a Phi connected to the CountedLoopNode.  The stride is constant.
 180 // The Op is any commutable opcode, including Add, Mul, Xor.  The
 181 // CountedLoopEndNode also takes in the loop-invariant limit value.
 182 
 183 // From a CountedLoopNode I can reach the matching CountedLoopEndNode via the
 184 // loop-back control.  From CountedLoopEndNodes I can reach CountedLoopNodes
 185 // via the old-trip-counter from the Op node.
 186 
 187 //------------------------------CountedLoopNode--------------------------------
 188 // CountedLoopNodes head simple counted loops.  CountedLoopNodes have as
 189 // inputs the incoming loop-start control and the loop-back control, so they
 190 // act like RegionNodes.  They also take in the initial trip counter, the
 191 // loop-invariant stride and the loop-invariant limit value.  CountedLoopNodes
 192 // produce a loop-body control and the trip counter value.  Since
 193 // CountedLoopNodes behave like RegionNodes I still have a standard CFG model.
 194 
 195 class CountedLoopNode : public LoopNode {
 196   // Size is bigger to hold _main_idx.  However, _main_idx does not change
 197   // the semantics so it does not appear in the hash &amp; cmp functions.
 198   virtual uint size_of() const { return sizeof(*this); }
 199 
 200   // For Pre- and Post-loops during debugging ONLY, this holds the index of
 201   // the Main CountedLoop.  Used to assert that we understand the graph shape.
 202   node_idx_t _main_idx;
 203 
 204   // Known trip count calculated by compute_exact_trip_count()
 205   uint  _trip_count;
 206 
 207   // Log2 of original loop bodies in unrolled loop
 208   int _unrolled_count_log2;
 209 
 210   // Node count prior to last unrolling - used to decide if
 211   // unroll,optimize,unroll,optimize,... is making progress
 212   int _node_count_before_unroll;
 213 
 214   // If slp analysis is performed we record the maximum
 215   // vector mapped unroll factor here
 216   int _slp_maximum_unroll_factor;
 217 
 218 public:
 219   CountedLoopNode( Node *entry, Node *backedge )
 220     : LoopNode(entry, backedge), _main_idx(0), _trip_count(max_juint),
 221       _unrolled_count_log2(0), _node_count_before_unroll(0),
 222       _slp_maximum_unroll_factor(0) {
 223     init_class_id(Class_CountedLoop);
 224     // Initialize _trip_count to the largest possible value.
 225     // Will be reset (lower) if the loop&#39;s trip count is known.
 226   }
 227 
 228   virtual int Opcode() const;
 229   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 230 
 231   Node *init_control() const { return in(EntryControl); }
 232   Node *back_control() const { return in(LoopBackControl); }
 233   CountedLoopEndNode *loopexit_or_null() const;
 234   CountedLoopEndNode *loopexit() const;
 235   Node *init_trip() const;
 236   Node *stride() const;
 237   int   stride_con() const;
 238   bool  stride_is_con() const;
 239   Node *limit() const;
 240   Node *incr() const;
 241   Node *phi() const;
 242 
 243   // Match increment with optional truncation
 244   static Node* match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2, const TypeInt** trunc_type);
 245 
 246   // A &#39;main&#39; loop has a pre-loop and a post-loop.  The &#39;main&#39; loop
 247   // can run short a few iterations and may start a few iterations in.
 248   // It will be RCE&#39;d and unrolled and aligned.
 249 
 250   // A following &#39;post&#39; loop will run any remaining iterations.  Used
 251   // during Range Check Elimination, the &#39;post&#39; loop will do any final
 252   // iterations with full checks.  Also used by Loop Unrolling, where
 253   // the &#39;post&#39; loop will do any epilog iterations needed.  Basically,
 254   // a &#39;post&#39; loop can not profitably be further unrolled or RCE&#39;d.
 255 
 256   // A preceding &#39;pre&#39; loop will run at least 1 iteration (to do peeling),
 257   // it may do under-flow checks for RCE and may do alignment iterations
 258   // so the following main loop &#39;knows&#39; that it is striding down cache
 259   // lines.
 260 
 261   // A &#39;main&#39; loop that is ONLY unrolled or peeled, never RCE&#39;d or
 262   // Aligned, may be missing it&#39;s pre-loop.
 263   bool is_normal_loop   () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Normal; }
 264   bool is_pre_loop      () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Pre;    }
 265   bool is_main_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Main;   }
 266   bool is_post_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Post;   }
 267   bool is_reduction_loop() const { return (_loop_flags&amp;HasReductions) == HasReductions; }
 268   bool was_slp_analyzed () const { return (_loop_flags&amp;WasSlpAnalyzed) == WasSlpAnalyzed; }
 269   bool has_passed_slp   () const { return (_loop_flags&amp;PassedSlpAnalysis) == PassedSlpAnalysis; }
 270   bool is_unroll_only   () const { return (_loop_flags&amp;DoUnrollOnly) == DoUnrollOnly; }
 271   bool is_main_no_pre_loop() const { return _loop_flags &amp; MainHasNoPreLoop; }
 272   bool has_atomic_post_loop  () const { return (_loop_flags &amp; HasAtomicPostLoop) == HasAtomicPostLoop; }
 273   void set_main_no_pre_loop() { _loop_flags |= MainHasNoPreLoop; }
 274 
 275   int main_idx() const { return _main_idx; }
 276 
 277 
 278   void set_pre_loop  (CountedLoopNode *main) { assert(is_normal_loop(),&quot;&quot;); _loop_flags |= Pre ; _main_idx = main-&gt;_idx; }
 279   void set_main_loop (                     ) { assert(is_normal_loop(),&quot;&quot;); _loop_flags |= Main;                         }
 280   void set_post_loop (CountedLoopNode *main) { assert(is_normal_loop(),&quot;&quot;); _loop_flags |= Post; _main_idx = main-&gt;_idx; }
 281   void set_normal_loop(                    ) { _loop_flags &amp;= ~PreMainPostFlagsMask; }
 282 
 283   void set_trip_count(uint tc) { _trip_count = tc; }
 284   uint trip_count()            { return _trip_count; }
 285 
 286   bool has_exact_trip_count() const { return (_loop_flags &amp; HasExactTripCount) != 0; }
 287   void set_exact_trip_count(uint tc) {
 288     _trip_count = tc;
 289     _loop_flags |= HasExactTripCount;
 290   }
 291   void set_nonexact_trip_count() {
 292     _loop_flags &amp;= ~HasExactTripCount;
 293   }
 294   void set_notpassed_slp() {
 295     _loop_flags &amp;= ~PassedSlpAnalysis;
 296   }
 297 
 298   void double_unrolled_count() { _unrolled_count_log2++; }
 299   int  unrolled_count()        { return 1 &lt;&lt; MIN2(_unrolled_count_log2, BitsPerInt-3); }
 300 
 301   void set_node_count_before_unroll(int ct)  { _node_count_before_unroll = ct; }
 302   int  node_count_before_unroll()            { return _node_count_before_unroll; }
 303   void set_slp_max_unroll(int unroll_factor) { _slp_maximum_unroll_factor = unroll_factor; }
 304   int  slp_max_unroll() const                { return _slp_maximum_unroll_factor; }
 305 
 306   virtual LoopNode* skip_strip_mined(int expect_skeleton = 1);
 307   OuterStripMinedLoopNode* outer_loop() const;
 308   virtual IfTrueNode* outer_loop_tail() const;
 309   virtual OuterStripMinedLoopEndNode* outer_loop_end() const;
 310   virtual IfFalseNode* outer_loop_exit() const;
 311   virtual SafePointNode* outer_safepoint() const;
 312 
 313   // If this is a main loop in a pre/main/post loop nest, walk over
 314   // the predicates that were inserted by
 315   // duplicate_predicates()/add_range_check_predicate()
 316   static Node* skip_predicates_from_entry(Node* ctrl);
 317   Node* skip_predicates();
 318 
 319 #ifndef PRODUCT
 320   virtual void dump_spec(outputStream *st) const;
 321 #endif
 322 };
 323 
 324 //------------------------------CountedLoopEndNode-----------------------------
 325 // CountedLoopEndNodes end simple trip counted loops.  They act much like
 326 // IfNodes.
 327 class CountedLoopEndNode : public IfNode {
 328 public:
 329   enum { TestControl, TestValue };
 330 
 331   CountedLoopEndNode( Node *control, Node *test, float prob, float cnt )
 332     : IfNode( control, test, prob, cnt) {
 333     init_class_id(Class_CountedLoopEnd);
 334   }
 335   virtual int Opcode() const;
 336 
 337   Node *cmp_node() const            { return (in(TestValue)-&gt;req() &gt;=2) ? in(TestValue)-&gt;in(1) : NULL; }
 338   Node *incr() const                { Node *tmp = cmp_node(); return (tmp &amp;&amp; tmp-&gt;req()==3) ? tmp-&gt;in(1) : NULL; }
 339   Node *limit() const               { Node *tmp = cmp_node(); return (tmp &amp;&amp; tmp-&gt;req()==3) ? tmp-&gt;in(2) : NULL; }
 340   Node *stride() const              { Node *tmp = incr    (); return (tmp &amp;&amp; tmp-&gt;req()==3) ? tmp-&gt;in(2) : NULL; }
 341   Node *init_trip() const           { Node *tmp = phi     (); return (tmp &amp;&amp; tmp-&gt;req()==3) ? tmp-&gt;in(1) : NULL; }
 342   int stride_con() const;
 343   bool stride_is_con() const        { Node *tmp = stride  (); return (tmp != NULL &amp;&amp; tmp-&gt;is_Con()); }
 344   BoolTest::mask test_trip() const  { return in(TestValue)-&gt;as_Bool()-&gt;_test._test; }
 345   PhiNode *phi() const {
 346     Node *tmp = incr();
 347     if (tmp &amp;&amp; tmp-&gt;req() == 3) {
 348       Node* phi = tmp-&gt;in(1);
 349       if (phi-&gt;is_Phi()) {
 350         return phi-&gt;as_Phi();
 351       }
 352     }
 353     return NULL;
 354   }
 355   CountedLoopNode *loopnode() const {
 356     // The CountedLoopNode that goes with this CountedLoopEndNode may
 357     // have been optimized out by the IGVN so be cautious with the
 358     // pattern matching on the graph
 359     PhiNode* iv_phi = phi();
 360     if (iv_phi == NULL) {
 361       return NULL;
 362     }
 363     Node *ln = iv_phi-&gt;in(0);
 364     if (ln-&gt;is_CountedLoop() &amp;&amp; ln-&gt;as_CountedLoop()-&gt;loopexit_or_null() == this) {
 365       return (CountedLoopNode*)ln;
 366     }
 367     return NULL;
 368   }
 369 
 370 #ifndef PRODUCT
 371   virtual void dump_spec(outputStream *st) const;
 372 #endif
 373 };
 374 
 375 
 376 inline CountedLoopEndNode* CountedLoopNode::loopexit_or_null() const {
 377   Node* bctrl = back_control();
 378   if (bctrl == NULL) return NULL;
 379 
 380   Node* lexit = bctrl-&gt;in(0);
 381   return (CountedLoopEndNode*)
 382       (lexit-&gt;Opcode() == Op_CountedLoopEnd ? lexit : NULL);
 383 }
 384 
 385 inline CountedLoopEndNode* CountedLoopNode::loopexit() const {
 386   CountedLoopEndNode* cle = loopexit_or_null();
 387   assert(cle != NULL, &quot;loopexit is NULL&quot;);
 388   return cle;
 389 }
 390 
 391 inline Node* CountedLoopNode::init_trip() const {
 392   CountedLoopEndNode* cle = loopexit_or_null();
 393   return cle != NULL ? cle-&gt;init_trip() : NULL;
 394 }
 395 inline Node* CountedLoopNode::stride() const {
 396   CountedLoopEndNode* cle = loopexit_or_null();
 397   return cle != NULL ? cle-&gt;stride() : NULL;
 398 }
 399 inline int CountedLoopNode::stride_con() const {
 400   CountedLoopEndNode* cle = loopexit_or_null();
 401   return cle != NULL ? cle-&gt;stride_con() : 0;
 402 }
 403 inline bool CountedLoopNode::stride_is_con() const {
 404   CountedLoopEndNode* cle = loopexit_or_null();
 405   return cle != NULL &amp;&amp; cle-&gt;stride_is_con();
 406 }
 407 inline Node* CountedLoopNode::limit() const {
 408   CountedLoopEndNode* cle = loopexit_or_null();
 409   return cle != NULL ? cle-&gt;limit() : NULL;
 410 }
 411 inline Node* CountedLoopNode::incr() const {
 412   CountedLoopEndNode* cle = loopexit_or_null();
 413   return cle != NULL ? cle-&gt;incr() : NULL;
 414 }
 415 inline Node* CountedLoopNode::phi() const {
 416   CountedLoopEndNode* cle = loopexit_or_null();
 417   return cle != NULL ? cle-&gt;phi() : NULL;
 418 }
 419 
 420 //------------------------------LoopLimitNode-----------------------------
 421 // Counted Loop limit node which represents exact final iterator value:
 422 // trip_count = (limit - init_trip + stride - 1)/stride
 423 // final_value= trip_count * stride + init_trip.
 424 // Use HW instructions to calculate it when it can overflow in integer.
 425 // Note, final_value should fit into integer since counted loop has
 426 // limit check: limit &lt;= max_int-stride.
 427 class LoopLimitNode : public Node {
 428   enum { Init=1, Limit=2, Stride=3 };
 429  public:
 430   LoopLimitNode( Compile* C, Node *init, Node *limit, Node *stride ) : Node(0,init,limit,stride) {
 431     // Put it on the Macro nodes list to optimize during macro nodes expansion.
 432     init_flags(Flag_is_macro);
 433     C-&gt;add_macro_node(this);
 434   }
 435   virtual int Opcode() const;
 436   virtual const Type *bottom_type() const { return TypeInt::INT; }
 437   virtual uint ideal_reg() const { return Op_RegI; }
 438   virtual const Type* Value(PhaseGVN* phase) const;
 439   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 440   virtual Node* Identity(PhaseGVN* phase);
 441 };
 442 
 443 // Support for strip mining
 444 class OuterStripMinedLoopNode : public LoopNode {
 445 private:
 446   CountedLoopNode* inner_loop() const;
 447 public:
 448   OuterStripMinedLoopNode(Compile* C, Node *entry, Node *backedge)
 449     : LoopNode(entry, backedge) {
 450     init_class_id(Class_OuterStripMinedLoop);
 451     init_flags(Flag_is_macro);
 452     C-&gt;add_macro_node(this);
 453   }
 454 
 455   virtual int Opcode() const;
 456 
 457   virtual IfTrueNode* outer_loop_tail() const;
 458   virtual OuterStripMinedLoopEndNode* outer_loop_end() const;
 459   virtual IfFalseNode* outer_loop_exit() const;
 460   virtual SafePointNode* outer_safepoint() const;
 461   void adjust_strip_mined_loop(PhaseIterGVN* igvn);
 462 };
 463 
 464 class OuterStripMinedLoopEndNode : public IfNode {
 465 public:
 466   OuterStripMinedLoopEndNode(Node *control, Node *test, float prob, float cnt)
 467     : IfNode(control, test, prob, cnt) {
 468     init_class_id(Class_OuterStripMinedLoopEnd);
 469   }
 470 
 471   virtual int Opcode() const;
 472 
 473   virtual const Type* Value(PhaseGVN* phase) const;
 474   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 475 };
 476 
 477 // -----------------------------IdealLoopTree----------------------------------
 478 class IdealLoopTree : public ResourceObj {
 479 public:
 480   IdealLoopTree *_parent;       // Parent in loop tree
 481   IdealLoopTree *_next;         // Next sibling in loop tree
 482   IdealLoopTree *_child;        // First child in loop tree
 483 
 484   // The head-tail backedge defines the loop.
 485   // If a loop has multiple backedges, this is addressed during cleanup where
 486   // we peel off the multiple backedges,  merging all edges at the bottom and
 487   // ensuring that one proper backedge flow into the loop.
 488   Node *_head;                  // Head of loop
 489   Node *_tail;                  // Tail of loop
 490   inline Node *tail();          // Handle lazy update of _tail field
 491   inline Node *head();          // Handle lazy update of _head field
 492   PhaseIdealLoop* _phase;
 493   int _local_loop_unroll_limit;
 494   int _local_loop_unroll_factor;
 495 
 496   Node_List _body;              // Loop body for inner loops
 497 
 498   uint8_t _nest;                // Nesting depth
 499   uint8_t _irreducible:1,       // True if irreducible
 500           _has_call:1,          // True if has call safepoint
 501           _has_sfpt:1,          // True if has non-call safepoint
 502           _rce_candidate:1;     // True if candidate for range check elimination
 503 
 504   Node_List* _safepts;          // List of safepoints in this loop
 505   Node_List* _required_safept;  // A inner loop cannot delete these safepts;
 506   bool  _allow_optimizations;   // Allow loop optimizations
 507 
 508   IdealLoopTree( PhaseIdealLoop* phase, Node *head, Node *tail )
 509     : _parent(0), _next(0), _child(0),
 510       _head(head), _tail(tail),
 511       _phase(phase),
 512       _local_loop_unroll_limit(0), _local_loop_unroll_factor(0),
 513       _nest(0), _irreducible(0), _has_call(0), _has_sfpt(0), _rce_candidate(0),
 514       _safepts(NULL),
 515       _required_safept(NULL),
 516       _allow_optimizations(true)
 517   {
 518     precond(_head != NULL);
 519     precond(_tail != NULL);
 520   }
 521 
 522   // Is &#39;l&#39; a member of &#39;this&#39;?
 523   bool is_member(const IdealLoopTree *l) const; // Test for nested membership
 524 
 525   // Set loop nesting depth.  Accumulate has_call bits.
 526   int set_nest( uint depth );
 527 
 528   // Split out multiple fall-in edges from the loop header.  Move them to a
 529   // private RegionNode before the loop.  This becomes the loop landing pad.
 530   void split_fall_in( PhaseIdealLoop *phase, int fall_in_cnt );
 531 
 532   // Split out the outermost loop from this shared header.
 533   void split_outer_loop( PhaseIdealLoop *phase );
 534 
 535   // Merge all the backedges from the shared header into a private Region.
 536   // Feed that region as the one backedge to this loop.
 537   void merge_many_backedges( PhaseIdealLoop *phase );
 538 
 539   // Split shared headers and insert loop landing pads.
 540   // Insert a LoopNode to replace the RegionNode.
 541   // Returns TRUE if loop tree is structurally changed.
 542   bool beautify_loops( PhaseIdealLoop *phase );
 543 
 544   // Perform optimization to use the loop predicates for null checks and range checks.
 545   // Applies to any loop level (not just the innermost one)
 546   bool loop_predication( PhaseIdealLoop *phase);
 547 
 548   // Perform iteration-splitting on inner loops.  Split iterations to
 549   // avoid range checks or one-shot null checks.  Returns false if the
 550   // current round of loop opts should stop.
 551   bool iteration_split( PhaseIdealLoop *phase, Node_List &amp;old_new );
 552 
 553   // Driver for various flavors of iteration splitting.  Returns false
 554   // if the current round of loop opts should stop.
 555   bool iteration_split_impl( PhaseIdealLoop *phase, Node_List &amp;old_new );
 556 
 557   // Given dominators, try to find loops with calls that must always be
 558   // executed (call dominates loop tail).  These loops do not need non-call
 559   // safepoints (ncsfpt).
 560   void check_safepts(VectorSet &amp;visited, Node_List &amp;stack);
 561 
 562   // Allpaths backwards scan from loop tail, terminating each path at first safepoint
 563   // encountered.
 564   void allpaths_check_safepts(VectorSet &amp;visited, Node_List &amp;stack);
 565 
 566   // Remove safepoints from loop. Optionally keeping one.
 567   void remove_safepoints(PhaseIdealLoop* phase, bool keep_one);
 568 
 569   // Convert to counted loops where possible
 570   void counted_loop( PhaseIdealLoop *phase );
 571 
 572   // Check for Node being a loop-breaking test
 573   Node *is_loop_exit(Node *iff) const;
 574 
 575   // Remove simplistic dead code from loop body
 576   void DCE_loop_body();
 577 
 578   // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
 579   // Replace with a 1-in-10 exit guess.
 580   void adjust_loop_exit_prob( PhaseIdealLoop *phase );
 581 
 582   // Return TRUE or FALSE if the loop should never be RCE&#39;d or aligned.
 583   // Useful for unrolling loops with NO array accesses.
 584   bool policy_peel_only( PhaseIdealLoop *phase ) const;
 585 
 586   // Return TRUE or FALSE if the loop should be unswitched -- clone
 587   // loop with an invariant test
 588   bool policy_unswitching( PhaseIdealLoop *phase ) const;
 589 
 590   // Micro-benchmark spamming.  Remove empty loops.
 591   bool do_remove_empty_loop( PhaseIdealLoop *phase );
 592 
 593   // Convert one iteration loop into normal code.
 594   bool do_one_iteration_loop( PhaseIdealLoop *phase );
 595 
 596   // Return TRUE or FALSE if the loop should be peeled or not. Peel if we can
 597   // move some loop-invariant test (usually a null-check) before the loop.
 598   bool policy_peeling(PhaseIdealLoop *phase);
 599 
 600   uint estimate_peeling(PhaseIdealLoop *phase);
 601 
 602   // Return TRUE or FALSE if the loop should be maximally unrolled. Stash any
 603   // known trip count in the counted loop node.
 604   bool policy_maximally_unroll(PhaseIdealLoop *phase) const;
 605 
 606   // Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll
 607   // if the loop is a counted loop and the loop body is small enough.
 608   bool policy_unroll(PhaseIdealLoop *phase);
 609 
 610   // Loop analyses to map to a maximal superword unrolling for vectorization.
 611   void policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_ct);
 612 
 613   // Return TRUE or FALSE if the loop should be range-check-eliminated.
 614   // Gather a list of IF tests that are dominated by iteration splitting;
 615   // also gather the end of the first split and the start of the 2nd split.
 616   bool policy_range_check( PhaseIdealLoop *phase ) const;
 617 
 618   // Return TRUE or FALSE if the loop should be cache-line aligned.
 619   // Gather the expression that does the alignment.  Note that only
 620   // one array base can be aligned in a loop (unless the VM guarantees
 621   // mutual alignment).  Note that if we vectorize short memory ops
 622   // into longer memory ops, we may want to increase alignment.
 623   bool policy_align( PhaseIdealLoop *phase ) const;
 624 
 625   // Return TRUE if &quot;iff&quot; is a range check.
 626   bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance&amp; invar) const;
 627 
 628   // Estimate the number of nodes required when cloning a loop (body).
 629   uint est_loop_clone_sz(uint factor) const;
 630   // Estimate the number of nodes required when unrolling a loop (body).
 631   uint est_loop_unroll_sz(uint factor) const;
 632 
 633   // Compute loop trip count if possible
 634   void compute_trip_count(PhaseIdealLoop* phase);
 635 
 636   // Compute loop trip count from profile data
 637   float compute_profile_trip_cnt_helper(Node* n);
 638   void compute_profile_trip_cnt( PhaseIdealLoop *phase );
 639 
 640   // Reassociate invariant expressions.
 641   void reassociate_invariants(PhaseIdealLoop *phase);
 642   // Reassociate invariant add and subtract expressions.
 643   Node* reassociate_add_sub(Node* n1, PhaseIdealLoop *phase);
 644   // Return nonzero index of invariant operand if invariant and variant
 645   // are combined with an Add or Sub. Helper for reassociate_invariants.
 646   int is_invariant_addition(Node* n, PhaseIdealLoop *phase);
 647 
 648   // Return true if n is invariant
 649   bool is_invariant(Node* n) const;
 650 
 651   // Put loop body on igvn work list
 652   void record_for_igvn();
 653 
 654   bool is_root() { return _parent == NULL; }
 655   // A proper/reducible loop w/o any (occasional) dead back-edge.
 656   bool is_loop() { return !_irreducible &amp;&amp; !tail()-&gt;is_top(); }
 657   bool is_counted()   { return is_loop() &amp;&amp; _head-&gt;is_CountedLoop(); }
 658   bool is_innermost() { return is_loop() &amp;&amp; _child == NULL; }
 659 
 660   void remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase);
 661 
 662 #ifndef PRODUCT
 663   void dump_head() const;       // Dump loop head only
 664   void dump() const;            // Dump this loop recursively
 665   void verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const;
 666 #endif
 667 
 668  private:
 669   enum { EMPTY_LOOP_SIZE = 7 }; // Number of nodes in an empty loop.
 670 
 671   // Estimate the number of nodes resulting from control and data flow merge.
 672   uint est_loop_flow_merge_sz() const;
 673 };
 674 
 675 // -----------------------------PhaseIdealLoop---------------------------------
 676 // Computes the mapping from Nodes to IdealLoopTrees. Organizes IdealLoopTrees
 677 // into a loop tree. Drives the loop-based transformations on the ideal graph.
 678 class PhaseIdealLoop : public PhaseTransform {
 679   friend class IdealLoopTree;
 680   friend class SuperWord;
 681   friend class CountedLoopReserveKit;
 682   friend class ShenandoahBarrierC2Support;
 683   friend class AutoNodeBudget;
 684 
 685   // Pre-computed def-use info
 686   PhaseIterGVN &amp;_igvn;
 687 
 688   // Head of loop tree
 689   IdealLoopTree* _ltree_root;
 690 
 691   // Array of pre-order numbers, plus post-visited bit.
 692   // ZERO for not pre-visited.  EVEN for pre-visited but not post-visited.
 693   // ODD for post-visited.  Other bits are the pre-order number.
 694   uint *_preorders;
 695   uint _max_preorder;
 696 
 697   const PhaseIdealLoop* _verify_me;
 698   bool _verify_only;
 699 
 700   // Allocate _preorders[] array
 701   void allocate_preorders() {
 702     _max_preorder = C-&gt;unique()+8;
 703     _preorders = NEW_RESOURCE_ARRAY(uint, _max_preorder);
 704     memset(_preorders, 0, sizeof(uint) * _max_preorder);
 705   }
 706 
 707   // Allocate _preorders[] array
 708   void reallocate_preorders() {
 709     if ( _max_preorder &lt; C-&gt;unique() ) {
 710       _preorders = REALLOC_RESOURCE_ARRAY(uint, _preorders, _max_preorder, C-&gt;unique());
 711       _max_preorder = C-&gt;unique();
 712     }
 713     memset(_preorders, 0, sizeof(uint) * _max_preorder);
 714   }
 715 
 716   // Check to grow _preorders[] array for the case when build_loop_tree_impl()
 717   // adds new nodes.
 718   void check_grow_preorders( ) {
 719     if ( _max_preorder &lt; C-&gt;unique() ) {
 720       uint newsize = _max_preorder&lt;&lt;1;  // double size of array
 721       _preorders = REALLOC_RESOURCE_ARRAY(uint, _preorders, _max_preorder, newsize);
 722       memset(&amp;_preorders[_max_preorder],0,sizeof(uint)*(newsize-_max_preorder));
 723       _max_preorder = newsize;
 724     }
 725   }
 726   // Check for pre-visited.  Zero for NOT visited; non-zero for visited.
 727   int is_visited( Node *n ) const { return _preorders[n-&gt;_idx]; }
 728   // Pre-order numbers are written to the Nodes array as low-bit-set values.
 729   void set_preorder_visited( Node *n, int pre_order ) {
 730     assert( !is_visited( n ), &quot;already set&quot; );
 731     _preorders[n-&gt;_idx] = (pre_order&lt;&lt;1);
 732   };
 733   // Return pre-order number.
 734   int get_preorder( Node *n ) const { assert( is_visited(n), &quot;&quot; ); return _preorders[n-&gt;_idx]&gt;&gt;1; }
 735 
 736   // Check for being post-visited.
 737   // Should be previsited already (checked with assert(is_visited(n))).
 738   int is_postvisited( Node *n ) const { assert( is_visited(n), &quot;&quot; ); return _preorders[n-&gt;_idx]&amp;1; }
 739 
 740   // Mark as post visited
 741   void set_postvisited( Node *n ) { assert( !is_postvisited( n ), &quot;&quot; ); _preorders[n-&gt;_idx] |= 1; }
 742 
 743 public:
 744   // Set/get control node out.  Set lower bit to distinguish from IdealLoopTree
 745   // Returns true if &quot;n&quot; is a data node, false if it&#39;s a control node.
 746   bool has_ctrl( Node *n ) const { return ((intptr_t)_nodes[n-&gt;_idx]) &amp; 1; }
 747 
 748 private:
 749   // clear out dead code after build_loop_late
 750   Node_List _deadlist;
 751 
 752   // Support for faster execution of get_late_ctrl()/dom_lca()
 753   // when a node has many uses and dominator depth is deep.
 754   Node_Array _dom_lca_tags;
 755   void   init_dom_lca_tags();
 756   void   clear_dom_lca_tags();
 757 
 758   // Helper for debugging bad dominance relationships
 759   bool verify_dominance(Node* n, Node* use, Node* LCA, Node* early);
 760 
 761   Node* compute_lca_of_uses(Node* n, Node* early, bool verify = false);
 762 
 763   // Inline wrapper for frequent cases:
 764   // 1) only one use
 765   // 2) a use is the same as the current LCA passed as &#39;n1&#39;
 766   Node *dom_lca_for_get_late_ctrl( Node *lca, Node *n, Node *tag ) {
 767     assert( n-&gt;is_CFG(), &quot;&quot; );
 768     // Fast-path NULL lca
 769     if( lca != NULL &amp;&amp; lca != n ) {
 770       assert( lca-&gt;is_CFG(), &quot;&quot; );
 771       // find LCA of all uses
 772       n = dom_lca_for_get_late_ctrl_internal( lca, n, tag );
 773     }
 774     return find_non_split_ctrl(n);
 775   }
 776   Node *dom_lca_for_get_late_ctrl_internal( Node *lca, Node *n, Node *tag );
 777 
 778   // Helper function for directing control inputs away from CFG split points.
 779   Node *find_non_split_ctrl( Node *ctrl ) const {
 780     if (ctrl != NULL) {
 781       if (ctrl-&gt;is_MultiBranch()) {
 782         ctrl = ctrl-&gt;in(0);
 783       }
 784       assert(ctrl-&gt;is_CFG(), &quot;CFG&quot;);
 785     }
 786     return ctrl;
 787   }
 788 
 789   Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);
 790 
 791 #ifdef ASSERT
 792   void ensure_zero_trip_guard_proj(Node* node, bool is_main_loop);
 793 #endif
 794   void copy_skeleton_predicates_to_main_loop_helper(Node* predicate, Node* start, Node* end, IdealLoopTree* outer_loop, LoopNode* outer_main_head,
 795                                                     uint dd_main_head, const uint idx_before_pre_post, const uint idx_after_post_before_pre,
 796                                                     Node* zero_trip_guard_proj_main, Node* zero_trip_guard_proj_post, const Node_List &amp;old_new);
 797   void copy_skeleton_predicates_to_main_loop(CountedLoopNode* pre_head, Node* start, Node* end, IdealLoopTree* outer_loop, LoopNode* outer_main_head,
 798                                              uint dd_main_head, const uint idx_before_pre_post, const uint idx_after_post_before_pre,
 799                                              Node* zero_trip_guard_proj_main, Node* zero_trip_guard_proj_post, const Node_List &amp;old_new);
 800   Node* clone_skeleton_predicate(Node* iff, Node* value, Node* predicate, Node* uncommon_proj,
 801                                  Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj);
 802   bool skeleton_predicate_has_opaque(IfNode* iff);
 803   void update_main_loop_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);
 804   void insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol);
 805 
 806 public:
 807 
 808   PhaseIterGVN &amp;igvn() const { return _igvn; }
 809 
 810   static bool is_canonical_loop_entry(CountedLoopNode* cl);
 811 
 812   bool has_node( Node* n ) const {
 813     guarantee(n != NULL, &quot;No Node.&quot;);
 814     return _nodes[n-&gt;_idx] != NULL;
 815   }
 816   // check if transform created new nodes that need _ctrl recorded
 817   Node *get_late_ctrl( Node *n, Node *early );
 818   Node *get_early_ctrl( Node *n );
 819   Node *get_early_ctrl_for_expensive(Node *n, Node* earliest);
 820   void set_early_ctrl( Node *n );
 821   void set_subtree_ctrl( Node *root );
 822   void set_ctrl( Node *n, Node *ctrl ) {
 823     assert( !has_node(n) || has_ctrl(n), &quot;&quot; );
 824     assert( ctrl-&gt;in(0), &quot;cannot set dead control node&quot; );
 825     assert( ctrl == find_non_split_ctrl(ctrl), &quot;must set legal crtl&quot; );
 826     _nodes.map( n-&gt;_idx, (Node*)((intptr_t)ctrl + 1) );
 827   }
 828   // Set control and update loop membership
 829   void set_ctrl_and_loop(Node* n, Node* ctrl) {
 830     IdealLoopTree* old_loop = get_loop(get_ctrl(n));
 831     IdealLoopTree* new_loop = get_loop(ctrl);
 832     if (old_loop != new_loop) {
 833       if (old_loop-&gt;_child == NULL) old_loop-&gt;_body.yank(n);
 834       if (new_loop-&gt;_child == NULL) new_loop-&gt;_body.push(n);
 835     }
 836     set_ctrl(n, ctrl);
 837   }
 838   // Control nodes can be replaced or subsumed.  During this pass they
 839   // get their replacement Node in slot 1.  Instead of updating the block
 840   // location of all Nodes in the subsumed block, we lazily do it.  As we
 841   // pull such a subsumed block out of the array, we write back the final
 842   // correct block.
 843   Node *get_ctrl( Node *i ) {
 844 
 845     assert(has_node(i), &quot;&quot;);
 846     Node *n = get_ctrl_no_update(i);
 847     _nodes.map( i-&gt;_idx, (Node*)((intptr_t)n + 1) );
 848     assert(has_node(i) &amp;&amp; has_ctrl(i), &quot;&quot;);
 849     assert(n == find_non_split_ctrl(n), &quot;must return legal ctrl&quot; );
 850     return n;
 851   }
 852   // true if CFG node d dominates CFG node n
 853   bool is_dominator(Node *d, Node *n);
 854   // return get_ctrl for a data node and self(n) for a CFG node
 855   Node* ctrl_or_self(Node* n) {
 856     if (has_ctrl(n))
 857       return get_ctrl(n);
 858     else {
 859       assert (n-&gt;is_CFG(), &quot;must be a CFG node&quot;);
 860       return n;
 861     }
 862   }
 863 
 864   Node *get_ctrl_no_update_helper(Node *i) const {
 865     assert(has_ctrl(i), &quot;should be control, not loop&quot;);
 866     return (Node*)(((intptr_t)_nodes[i-&gt;_idx]) &amp; ~1);
 867   }
 868 
 869   Node *get_ctrl_no_update(Node *i) const {
 870     assert( has_ctrl(i), &quot;&quot; );
 871     Node *n = get_ctrl_no_update_helper(i);
 872     if (!n-&gt;in(0)) {
 873       // Skip dead CFG nodes
 874       do {
 875         n = get_ctrl_no_update_helper(n);
 876       } while (!n-&gt;in(0));
 877       n = find_non_split_ctrl(n);
 878     }
 879     return n;
 880   }
 881 
 882   // Check for loop being set
 883   // &quot;n&quot; must be a control node. Returns true if &quot;n&quot; is known to be in a loop.
 884   bool has_loop( Node *n ) const {
 885     assert(!has_node(n) || !has_ctrl(n), &quot;&quot;);
 886     return has_node(n);
 887   }
 888   // Set loop
 889   void set_loop( Node *n, IdealLoopTree *loop ) {
 890     _nodes.map(n-&gt;_idx, (Node*)loop);
 891   }
 892   // Lazy-dazy update of &#39;get_ctrl&#39; and &#39;idom_at&#39; mechanisms.  Replace
 893   // the &#39;old_node&#39; with &#39;new_node&#39;.  Kill old-node.  Add a reference
 894   // from old_node to new_node to support the lazy update.  Reference
 895   // replaces loop reference, since that is not needed for dead node.
 896   void lazy_update(Node *old_node, Node *new_node) {
 897     assert(old_node != new_node, &quot;no cycles please&quot;);
 898     // Re-use the side array slot for this node to provide the
 899     // forwarding pointer.
 900     _nodes.map(old_node-&gt;_idx, (Node*)((intptr_t)new_node + 1));
 901   }
 902   void lazy_replace(Node *old_node, Node *new_node) {
 903     _igvn.replace_node(old_node, new_node);
 904     lazy_update(old_node, new_node);
 905   }
 906 
 907 private:
 908 
 909   // Place &#39;n&#39; in some loop nest, where &#39;n&#39; is a CFG node
 910   void build_loop_tree();
 911   int build_loop_tree_impl( Node *n, int pre_order );
 912   // Insert loop into the existing loop tree.  &#39;innermost&#39; is a leaf of the
 913   // loop tree, not the root.
 914   IdealLoopTree *sort( IdealLoopTree *loop, IdealLoopTree *innermost );
 915 
 916   // Place Data nodes in some loop nest
 917   void build_loop_early( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack );
 918   void build_loop_late ( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack );
 919   void build_loop_late_post_work(Node* n, bool pinned);
 920   void build_loop_late_post(Node* n);
 921   void verify_strip_mined_scheduling(Node *n, Node* least);
 922 
 923   // Array of immediate dominance info for each CFG node indexed by node idx
 924 private:
 925   uint _idom_size;
 926   Node **_idom;                  // Array of immediate dominators
 927   uint *_dom_depth;              // Used for fast LCA test
 928   GrowableArray&lt;uint&gt;* _dom_stk; // For recomputation of dom depth
 929 
 930   // Perform verification that the graph is valid.
 931   PhaseIdealLoop( PhaseIterGVN &amp;igvn) :
 932     PhaseTransform(Ideal_Loop),
 933     _igvn(igvn),
 934     _verify_me(NULL),
 935     _verify_only(true),
 936     _dom_lca_tags(arena()),  // Thread::resource_area
 937     _nodes_required(UINT_MAX) {
 938     build_and_optimize(LoopOptsVerify);
 939   }
 940 
 941   // build the loop tree and perform any requested optimizations
 942   void build_and_optimize(LoopOptsMode mode);
 943 
 944   // Dominators for the sea of nodes
 945   void Dominators();
 946 
 947   // Compute the Ideal Node to Loop mapping
 948   PhaseIdealLoop(PhaseIterGVN &amp;igvn, LoopOptsMode mode) :
 949     PhaseTransform(Ideal_Loop),
 950     _igvn(igvn),
 951     _verify_me(NULL),
 952     _verify_only(false),
 953     _dom_lca_tags(arena()),  // Thread::resource_area
 954     _nodes_required(UINT_MAX) {
 955     build_and_optimize(mode);
 956   }
 957 
 958   // Verify that verify_me made the same decisions as a fresh run.
 959   PhaseIdealLoop(PhaseIterGVN &amp;igvn, const PhaseIdealLoop *verify_me) :
 960     PhaseTransform(Ideal_Loop),
 961     _igvn(igvn),
 962     _verify_me(verify_me),
 963     _verify_only(false),
 964     _dom_lca_tags(arena()),  // Thread::resource_area
 965     _nodes_required(UINT_MAX) {
 966     build_and_optimize(LoopOptsVerify);
 967   }
 968 
 969 public:
 970   Node* idom_no_update(Node* d) const {
 971     return idom_no_update(d-&gt;_idx);
 972   }
 973 
 974   Node* idom_no_update(uint didx) const {
 975     assert(didx &lt; _idom_size, &quot;oob&quot;);
 976     Node* n = _idom[didx];
 977     assert(n != NULL,&quot;Bad immediate dominator info.&quot;);
 978     while (n-&gt;in(0) == NULL) { // Skip dead CFG nodes
 979       n = (Node*)(((intptr_t)_nodes[n-&gt;_idx]) &amp; ~1);
 980       assert(n != NULL,&quot;Bad immediate dominator info.&quot;);
 981     }
 982     return n;
 983   }
 984 
 985   Node *idom(Node* d) const {
 986     return idom(d-&gt;_idx);
 987   }
 988 
 989   Node *idom(uint didx) const {
 990     Node *n = idom_no_update(didx);
 991     _idom[didx] = n; // Lazily remove dead CFG nodes from table.
 992     return n;
 993   }
 994 
 995   uint dom_depth(Node* d) const {
 996     guarantee(d != NULL, &quot;Null dominator info.&quot;);
 997     guarantee(d-&gt;_idx &lt; _idom_size, &quot;&quot;);
 998     return _dom_depth[d-&gt;_idx];
 999   }
1000   void set_idom(Node* d, Node* n, uint dom_depth);
1001   // Locally compute IDOM using dom_lca call
1002   Node *compute_idom( Node *region ) const;
1003   // Recompute dom_depth
1004   void recompute_dom_depth();
1005 
1006   // Is safept not required by an outer loop?
1007   bool is_deleteable_safept(Node* sfpt);
1008 
1009   // Replace parallel induction variable (parallel to trip counter)
1010   void replace_parallel_iv(IdealLoopTree *loop);
1011 
1012   Node *dom_lca( Node *n1, Node *n2 ) const {
1013     return find_non_split_ctrl(dom_lca_internal(n1, n2));
1014   }
1015   Node *dom_lca_internal( Node *n1, Node *n2 ) const;
1016 
1017   // Build and verify the loop tree without modifying the graph.  This
1018   // is useful to verify that all inputs properly dominate their uses.
1019   static void verify(PhaseIterGVN&amp; igvn) {
1020 #ifdef ASSERT
1021     ResourceMark rm;
1022     PhaseIdealLoop v(igvn);
1023 #endif
1024   }
1025 
1026   // Recommended way to use PhaseIdealLoop.
1027   // Run PhaseIdealLoop in some mode and allocates a local scope for memory allocations.
1028   static void optimize(PhaseIterGVN &amp;igvn, LoopOptsMode mode) {
1029     ResourceMark rm;
1030     PhaseIdealLoop v(igvn, mode);
1031   }
1032 
1033   // True if the method has at least 1 irreducible loop
1034   bool _has_irreducible_loops;
1035 
1036   // Per-Node transform
1037   virtual Node* transform(Node* n) { return NULL; }
1038 
1039   Node* loop_exit_control(Node* x, IdealLoopTree* loop);
1040   Node* loop_exit_test(Node* back_control, IdealLoopTree* loop, Node*&amp; incr, Node*&amp; limit, BoolTest::mask&amp; bt, float&amp; cl_prob);
1041   Node* loop_iv_incr(Node* incr, Node* x, IdealLoopTree* loop, Node*&amp; phi_incr);
1042   Node* loop_iv_stride(Node* incr, IdealLoopTree* loop, Node*&amp; xphi);
1043   PhiNode* loop_iv_phi(Node* xphi, Node* phi_incr, Node* x, IdealLoopTree* loop);
1044 
1045   bool is_counted_loop(Node* n, IdealLoopTree* &amp;loop);
1046   IdealLoopTree* insert_outer_loop(IdealLoopTree* loop, LoopNode* outer_l, Node* outer_ift);
1047   IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
1048                                                IdealLoopTree* loop, float cl_prob, float le_fcnt,
1049                                                Node*&amp; entry_control, Node*&amp; iffalse);
1050 
1051   Node* exact_limit( IdealLoopTree *loop );
1052 
1053   // Return a post-walked LoopNode
1054   IdealLoopTree *get_loop( Node *n ) const {
1055     // Dead nodes have no loop, so return the top level loop instead
1056     if (!has_node(n))  return _ltree_root;
1057     assert(!has_ctrl(n), &quot;&quot;);
1058     return (IdealLoopTree*)_nodes[n-&gt;_idx];
1059   }
1060 
1061   IdealLoopTree* ltree_root() const { return _ltree_root; }
1062 
1063   // Is &#39;n&#39; a (nested) member of &#39;loop&#39;?
1064   int is_member( const IdealLoopTree *loop, Node *n ) const {
1065     return loop-&gt;is_member(get_loop(n)); }
1066 
1067   // This is the basic building block of the loop optimizations.  It clones an
1068   // entire loop body.  It makes an old_new loop body mapping; with this
1069   // mapping you can find the new-loop equivalent to an old-loop node.  All
1070   // new-loop nodes are exactly equal to their old-loop counterparts, all
1071   // edges are the same.  All exits from the old-loop now have a RegionNode
1072   // that merges the equivalent new-loop path.  This is true even for the
1073   // normal &quot;loop-exit&quot; condition.  All uses of loop-invariant old-loop values
1074   // now come from (one or more) Phis that merge their new-loop equivalents.
1075   // Parameter side_by_side_idom:
1076   //   When side_by_size_idom is NULL, the dominator tree is constructed for
1077   //      the clone loop to dominate the original.  Used in construction of
1078   //      pre-main-post loop sequence.
1079   //   When nonnull, the clone and original are side-by-side, both are
1080   //      dominated by the passed in side_by_side_idom node.  Used in
1081   //      construction of unswitched loops.
1082   enum CloneLoopMode {
1083     IgnoreStripMined = 0,        // Only clone inner strip mined loop
1084     CloneIncludesStripMined = 1, // clone both inner and outer strip mined loops
1085     ControlAroundStripMined = 2  // Only clone inner strip mined loop,
1086                                  // result control flow branches
1087                                  // either to inner clone or outer
1088                                  // strip mined loop.
1089   };
1090   void clone_loop( IdealLoopTree *loop, Node_List &amp;old_new, int dom_depth,
1091                   CloneLoopMode mode, Node* side_by_side_idom = NULL);
1092   void clone_loop_handle_data_uses(Node* old, Node_List &amp;old_new,
1093                                    IdealLoopTree* loop, IdealLoopTree* companion_loop,
1094                                    Node_List*&amp; split_if_set, Node_List*&amp; split_bool_set,
1095                                    Node_List*&amp; split_cex_set, Node_List&amp; worklist,
1096                                    uint new_counter, CloneLoopMode mode);
1097   void clone_outer_loop(LoopNode* head, CloneLoopMode mode, IdealLoopTree *loop,
1098                         IdealLoopTree* outer_loop, int dd, Node_List &amp;old_new,
1099                         Node_List&amp; extra_data_nodes);
1100 
1101   // If we got the effect of peeling, either by actually peeling or by
1102   // making a pre-loop which must execute at least once, we can remove
1103   // all loop-invariant dominated tests in the main body.
1104   void peeled_dom_test_elim( IdealLoopTree *loop, Node_List &amp;old_new );
1105 
1106   // Generate code to do a loop peel for the given loop (and body).
1107   // old_new is a temp array.
1108   void do_peeling( IdealLoopTree *loop, Node_List &amp;old_new );
1109 
1110   // Add pre and post loops around the given loop.  These loops are used
1111   // during RCE, unrolling and aligning loops.
1112   void insert_pre_post_loops( IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only );
1113 
1114   // Add post loop after the given loop.
1115   Node *insert_post_loop(IdealLoopTree *loop, Node_List &amp;old_new,
1116                          CountedLoopNode *main_head, CountedLoopEndNode *main_end,
1117                          Node *incr, Node *limit, CountedLoopNode *&amp;post_head);
1118 
1119   // Add an RCE&#39;d post loop which we will multi-version adapt for run time test path usage
1120   void insert_scalar_rced_post_loop( IdealLoopTree *loop, Node_List &amp;old_new );
1121 
1122   // Add a vector post loop between a vector main loop and the current post loop
1123   void insert_vector_post_loop(IdealLoopTree *loop, Node_List &amp;old_new);
1124   // If Node n lives in the back_ctrl block, we clone a private version of n
1125   // in preheader_ctrl block and return that, otherwise return n.
1126   Node *clone_up_backedge_goo( Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &amp;visited, Node_Stack &amp;clones );
1127 
1128   // Take steps to maximally unroll the loop.  Peel any odd iterations, then
1129   // unroll to do double iterations.  The next round of major loop transforms
1130   // will repeat till the doubled loop body does all remaining iterations in 1
1131   // pass.
1132   void do_maximally_unroll( IdealLoopTree *loop, Node_List &amp;old_new );
1133 
1134   // Unroll the loop body one step - make each trip do 2 iterations.
1135   void do_unroll( IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip );
1136 
1137   // Mark vector reduction candidates before loop unrolling
1138   void mark_reductions( IdealLoopTree *loop );
1139 
1140   // Return true if exp is a constant times an induction var
1141   bool is_scaled_iv(Node* exp, Node* iv, int* p_scale);
1142 
1143   // Return true if exp is a scaled induction var plus (or minus) constant
1144   bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth = 0);
1145 
1146   // Create a new if above the uncommon_trap_if_pattern for the predicate to be promoted
1147   ProjNode* create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry, Deoptimization::DeoptReason reason,
1148                                         int opcode, bool if_cont_is_true_proj = true);
1149 
1150   void register_control(Node* n, IdealLoopTree *loop, Node* pred, bool update_body = true);
1151 
1152   static Node* skip_all_loop_predicates(Node* entry);
1153   static Node* skip_loop_predicates(Node* entry);
1154 
1155   // Find a good location to insert a predicate
1156   static ProjNode* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);
1157   // Find a predicate
1158   static Node* find_predicate(Node* entry);
1159   // Construct a range check for a predicate if
1160   BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,
1161                          int scale, Node* offset,
1162                          Node* init, Node* limit, jint stride,
1163                          Node* range, bool upper, bool &amp;overflow);
1164 
1165   // Implementation of the loop predication to promote checks outside the loop
1166   bool loop_predication_impl(IdealLoopTree *loop);
1167   bool loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,
1168                                     CountedLoopNode *cl, ConNode* zero, Invariance&amp; invar,
1169                                     Deoptimization::DeoptReason reason);
1170   bool loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt);
1171   void loop_predication_follow_branches(Node *c, IdealLoopTree *loop, float loop_trip_cnt,
1172                                         PathFrequency&amp; pf, Node_Stack&amp; stack, VectorSet&amp; seen,
1173                                         Node_List&amp; if_proj_list);
1174   ProjNode* insert_initial_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,
1175                                               ProjNode* proj, ProjNode *predicate_proj,
1176                                               ProjNode* upper_bound_proj,
1177                                               int scale, Node* offset,
1178                                               Node* init, Node* limit, jint stride,
1179                                               Node* rng, bool&amp; overflow,
1180                                               Deoptimization::DeoptReason reason);
1181   Node* add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,
1182                                   Node* predicate_proj, int scale_con, Node* offset,
1183                                   Node* limit, jint stride_con, Node* value);
1184 
1185   // Helper function to collect predicate for eliminating the useless ones
1186   void collect_potentially_useful_predicates(IdealLoopTree *loop, Unique_Node_List &amp;predicate_opaque1);
1187   void eliminate_useless_predicates();
1188 
1189   // Change the control input of expensive nodes to allow commoning by
1190   // IGVN when it is guaranteed to not result in a more frequent
1191   // execution of the expensive node. Return true if progress.
1192   bool process_expensive_nodes();
1193 
1194   // Check whether node has become unreachable
1195   bool is_node_unreachable(Node *n) const {
1196     return !has_node(n) || n-&gt;is_unreachable(_igvn);
1197   }
1198 
1199   // Eliminate range-checks and other trip-counter vs loop-invariant tests.
1200   int do_range_check( IdealLoopTree *loop, Node_List &amp;old_new );
1201 
1202   // Check to see if do_range_check(...) cleaned the main loop of range-checks
1203   void has_range_checks(IdealLoopTree *loop);
1204 
1205   // Process post loops which have range checks and try to build a multi-version
1206   // guard to safely determine if we can execute the post loop which was RCE&#39;d.
1207   bool multi_version_post_loops(IdealLoopTree *rce_loop, IdealLoopTree *legacy_loop);
1208 
1209   // Cause the rce&#39;d post loop to optimized away, this happens if we cannot complete multiverioning
1210   void poison_rce_post_loop(IdealLoopTree *rce_loop);
1211 
1212   // Create a slow version of the loop by cloning the loop
1213   // and inserting an if to select fast-slow versions.
1214   ProjNode* create_slow_version_of_loop(IdealLoopTree *loop,
1215                                         Node_List &amp;old_new,
1216                                         int opcode,
1217                                         CloneLoopMode mode);
1218 
1219   // Clone a loop and return the clone head (clone_loop_head).
1220   // Added nodes include int(1), int(0) - disconnected, If, IfTrue, IfFalse,
1221   // This routine was created for usage in CountedLoopReserveKit.
1222   //
1223   //    int(1) -&gt; If -&gt; IfTrue -&gt; original_loop_head
1224   //              |
1225   //              V
1226   //           IfFalse -&gt; clone_loop_head (returned by function pointer)
1227   //
1228   LoopNode* create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk);
1229   // Clone loop with an invariant test (that does not exit) and
1230   // insert a clone of the test that selects which version to
1231   // execute.
1232   void do_unswitching (IdealLoopTree *loop, Node_List &amp;old_new);
1233 
1234   // Find candidate &quot;if&quot; for unswitching
<a name="4" id="anc4"></a><span class="line-modified">1235   IfNode* find_unswitching_candidate(const IdealLoopTree *loop, Node_List&amp; unswitch_iffs) const;</span>
1236 
1237   // Range Check Elimination uses this function!
1238   // Constrain the main loop iterations so the affine function:
1239   //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
1240   // always holds true.  That is, either increase the number of iterations in
1241   // the pre-loop or the post-loop until the condition holds true in the main
1242   // loop.  Scale_con, offset and limit are all loop invariant.
1243   void add_constraint( int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit );
1244   // Helper function for add_constraint().
1245   Node* adjust_limit(int stride_con, Node * scale, Node *offset, Node *rc_limit, Node *loop_limit, Node *pre_ctrl, bool round_up);
1246 
1247   // Partially peel loop up through last_peel node.
1248   bool partial_peel( IdealLoopTree *loop, Node_List &amp;old_new );
1249 
1250   // Create a scheduled list of nodes control dependent on ctrl set.
1251   void scheduled_nodelist( IdealLoopTree *loop, VectorSet&amp; ctrl, Node_List &amp;sched );
1252   // Has a use in the vector set
1253   bool has_use_in_set( Node* n, VectorSet&amp; vset );
1254   // Has use internal to the vector set (ie. not in a phi at the loop head)
1255   bool has_use_internal_to_set( Node* n, VectorSet&amp; vset, IdealLoopTree *loop );
1256   // clone &quot;n&quot; for uses that are outside of loop
1257   int  clone_for_use_outside_loop( IdealLoopTree *loop, Node* n, Node_List&amp; worklist );
1258   // clone &quot;n&quot; for special uses that are in the not_peeled region
1259   void clone_for_special_use_inside_loop( IdealLoopTree *loop, Node* n,
1260                                           VectorSet&amp; not_peel, Node_List&amp; sink_list, Node_List&amp; worklist );
1261   // Insert phi(lp_entry_val, back_edge_val) at use-&gt;in(idx) for loop lp if phi does not already exist
1262   void insert_phi_for_loop( Node* use, uint idx, Node* lp_entry_val, Node* back_edge_val, LoopNode* lp );
1263 #ifdef ASSERT
1264   // Validate the loop partition sets: peel and not_peel
1265   bool is_valid_loop_partition( IdealLoopTree *loop, VectorSet&amp; peel, Node_List&amp; peel_list, VectorSet&amp; not_peel );
1266   // Ensure that uses outside of loop are of the right form
1267   bool is_valid_clone_loop_form( IdealLoopTree *loop, Node_List&amp; peel_list,
1268                                  uint orig_exit_idx, uint clone_exit_idx);
1269   bool is_valid_clone_loop_exit_use( IdealLoopTree *loop, Node* use, uint exit_idx);
1270 #endif
1271 
1272   // Returns nonzero constant stride if-node is a possible iv test (otherwise returns zero.)
1273   int stride_of_possible_iv( Node* iff );
1274   bool is_possible_iv_test( Node* iff ) { return stride_of_possible_iv(iff) != 0; }
1275   // Return the (unique) control output node that&#39;s in the loop (if it exists.)
1276   Node* stay_in_loop( Node* n, IdealLoopTree *loop);
1277   // Insert a signed compare loop exit cloned from an unsigned compare.
1278   IfNode* insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree *loop);
1279   void remove_cmpi_loop_exit(IfNode* if_cmp, IdealLoopTree *loop);
1280   // Utility to register node &quot;n&quot; with PhaseIdealLoop
1281   void register_node(Node* n, IdealLoopTree *loop, Node* pred, int ddepth);
1282   // Utility to create an if-projection
1283   ProjNode* proj_clone(ProjNode* p, IfNode* iff);
1284   // Force the iff control output to be the live_proj
1285   Node* short_circuit_if(IfNode* iff, ProjNode* live_proj);
1286   // Insert a region before an if projection
1287   RegionNode* insert_region_before_proj(ProjNode* proj);
1288   // Insert a new if before an if projection
1289   ProjNode* insert_if_before_proj(Node* left, bool Signed, BoolTest::mask relop, Node* right, ProjNode* proj);
1290 
1291   // Passed in a Phi merging (recursively) some nearly equivalent Bool/Cmps.
1292   // &quot;Nearly&quot; because all Nodes have been cloned from the original in the loop,
1293   // but the fall-in edges to the Cmp are different.  Clone bool/Cmp pairs
1294   // through the Phi recursively, and return a Bool.
1295   Node *clone_iff( PhiNode *phi, IdealLoopTree *loop );
1296   CmpNode *clone_bool( PhiNode *phi, IdealLoopTree *loop );
1297 
1298 
1299   // Rework addressing expressions to get the most loop-invariant stuff
1300   // moved out.  We&#39;d like to do all associative operators, but it&#39;s especially
1301   // important (common) to do address expressions.
1302   Node *remix_address_expressions( Node *n );
1303 
1304   // Convert add to muladd to generate MuladdS2I under certain criteria
1305   Node * convert_add_to_muladd(Node * n);
1306 
1307   // Attempt to use a conditional move instead of a phi/branch
1308   Node *conditional_move( Node *n );
1309 
1310   // Reorganize offset computations to lower register pressure.
1311   // Mostly prevent loop-fallout uses of the pre-incremented trip counter
1312   // (which are then alive with the post-incremented trip counter
1313   // forcing an extra register move)
1314   void reorg_offsets( IdealLoopTree *loop );
1315 
1316   // Check for aggressive application of &#39;split-if&#39; optimization,
1317   // using basic block level info.
1318   void  split_if_with_blocks     ( VectorSet &amp;visited, Node_Stack &amp;nstack);
1319   Node *split_if_with_blocks_pre ( Node *n );
1320   void  split_if_with_blocks_post( Node *n );
1321   Node *has_local_phi_input( Node *n );
1322   // Mark an IfNode as being dominated by a prior test,
1323   // without actually altering the CFG (and hence IDOM info).
1324   void dominated_by( Node *prevdom, Node *iff, bool flip = false, bool exclude_loop_predicate = false );
1325 
1326   // Split Node &#39;n&#39; through merge point
1327   Node *split_thru_region( Node *n, Node *region );
1328   // Split Node &#39;n&#39; through merge point if there is enough win.
1329   Node *split_thru_phi( Node *n, Node *region, int policy );
1330   // Found an If getting its condition-code input from a Phi in the
1331   // same block.  Split thru the Region.
1332   void do_split_if( Node *iff );
1333 
1334   // Conversion of fill/copy patterns into intrinsic versions
1335   bool do_intrinsify_fill();
1336   bool intrinsify_fill(IdealLoopTree* lpt);
1337   bool match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
1338                        Node*&amp; shift, Node*&amp; offset);
1339 
1340 private:
1341   // Return a type based on condition control flow
1342   const TypeInt* filtered_type( Node *n, Node* n_ctrl);
1343   const TypeInt* filtered_type( Node *n ) { return filtered_type(n, NULL); }
1344  // Helpers for filtered type
1345   const TypeInt* filtered_type_from_dominators( Node* val, Node *val_ctrl);
1346 
1347   // Helper functions
1348   Node *spinup( Node *iff, Node *new_false, Node *new_true, Node *region, Node *phi, small_cache *cache );
1349   Node *find_use_block( Node *use, Node *def, Node *old_false, Node *new_false, Node *old_true, Node *new_true );
1350   void handle_use( Node *use, Node *def, small_cache *cache, Node *region_dom, Node *new_false, Node *new_true, Node *old_false, Node *old_true );
1351   bool split_up( Node *n, Node *blk1, Node *blk2 );
1352   void sink_use( Node *use, Node *post_loop );
1353   Node *place_near_use( Node *useblock ) const;
1354   Node* try_move_store_before_loop(Node* n, Node *n_ctrl);
1355   void try_move_store_after_loop(Node* n);
1356   bool identical_backtoback_ifs(Node *n);
<a name="5" id="anc5"></a><span class="line-added">1357   bool flatten_array_element_type_check(Node *n);</span>
1358   bool can_split_if(Node *n_ctrl);
1359 
1360   // Determine if a method is too big for a/another round of split-if, based on
1361   // a magic (approximate) ratio derived from the equally magic constant 35000,
1362   // previously used for this purpose (but without relating to the node limit).
1363   bool must_throttle_split_if() {
1364     uint threshold = C-&gt;max_node_limit() * 2 / 5;
1365     return C-&gt;live_nodes() &gt; threshold;
1366   }
1367 
1368   // A simplistic node request tracking mechanism, where
1369   //   = UINT_MAX   Request not valid or made final.
1370   //   &lt; UINT_MAX   Nodes currently requested (estimate).
1371   uint _nodes_required;
1372 
1373   enum { REQUIRE_MIN = 70 };
1374 
1375   uint nodes_required() const { return _nodes_required; }
1376 
1377   // Given the _currently_  available number of nodes, check  whether there is
1378   // &quot;room&quot; for an additional request or not, considering the already required
1379   // number of  nodes.  Return TRUE if  the new request is  exceeding the node
1380   // budget limit, otherwise return FALSE.  Note that this interpretation will
1381   // act pessimistic on  additional requests when new nodes  have already been
1382   // generated since the &#39;begin&#39;.  This behaviour fits with the intention that
1383   // node estimates/requests should be made upfront.
1384   bool exceeding_node_budget(uint required = 0) {
1385     assert(C-&gt;live_nodes() &lt; C-&gt;max_node_limit(), &quot;sanity&quot;);
1386     uint available = C-&gt;max_node_limit() - C-&gt;live_nodes();
1387     return available &lt; required + _nodes_required + REQUIRE_MIN;
1388   }
1389 
1390   uint require_nodes(uint require, uint minreq = REQUIRE_MIN) {
1391     precond(require &gt; 0);
1392     _nodes_required += MAX2(require, minreq);
1393     return _nodes_required;
1394   }
1395 
1396   bool may_require_nodes(uint require, uint minreq = REQUIRE_MIN) {
1397     return !exceeding_node_budget(require) &amp;&amp; require_nodes(require, minreq) &gt; 0;
1398   }
1399 
1400   uint require_nodes_begin() {
1401     assert(_nodes_required == UINT_MAX, &quot;Bad state (begin).&quot;);
1402     _nodes_required = 0;
1403     return C-&gt;live_nodes();
1404   }
1405 
1406   // When a node request is final,  optionally check that the requested number
1407   // of nodes was  reasonably correct with respect to the  number of new nodes
1408   // introduced since the last &#39;begin&#39;. Always check that we have not exceeded
1409   // the maximum node limit.
1410   void require_nodes_final(uint live_at_begin, bool check_estimate) {
1411     assert(_nodes_required &lt; UINT_MAX, &quot;Bad state (final).&quot;);
1412 
1413 #ifdef ASSERT
1414     if (check_estimate) {
1415       // Check that the node budget request was not off by too much (x2).
1416       // Should this be the case we _surely_ need to improve the estimates
1417       // used in our budget calculations.
1418       if (C-&gt;live_nodes() - live_at_begin &gt; 2 * _nodes_required) {
1419         log_info(compilation)(&quot;Bad node estimate: actual = %d &gt;&gt; request = %d&quot;,
1420                               C-&gt;live_nodes() - live_at_begin, _nodes_required);
1421       }
1422     }
1423 #endif
1424     // Assert that we have stayed within the node budget limit.
1425     assert(C-&gt;live_nodes() &lt; C-&gt;max_node_limit(),
1426            &quot;Exceeding node budget limit: %d + %d &gt; %d (request = %d)&quot;,
1427            C-&gt;live_nodes() - live_at_begin, live_at_begin,
1428            C-&gt;max_node_limit(), _nodes_required);
1429 
1430     _nodes_required = UINT_MAX;
1431   }
1432 
1433   // Clone loop predicates to slow and fast loop when unswitching a loop
1434   Node* clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check, bool is_slow_loop,
1435                               uint idx_before_clone, Node_List &amp;old_new);
1436   ProjNode* clone_loop_predicate(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,
1437                                  bool is_slow_loop, uint idx_before_clone, Node_List &amp;old_new);
1438   void clone_concrete_loop_predicates(Deoptimization::DeoptReason reason, ProjNode* old_predicate_proj,
1439                                       ProjNode* new_predicate_proj, bool is_slow_loop,
1440                                       uint idx_before_clone, Node_List &amp;old_new);
1441 
1442   bool _created_loop_node;
1443 
1444 public:
1445   void set_created_loop_node() { _created_loop_node = true; }
1446   bool created_loop_node()     { return _created_loop_node; }
1447   void register_new_node(Node* n, Node* blk);
1448 
1449 #ifdef ASSERT
1450   void dump_bad_graph(const char* msg, Node* n, Node* early, Node* LCA);
1451 #endif
1452 
1453 #ifndef PRODUCT
1454   void dump() const;
1455   void dump(IdealLoopTree* loop, uint rpo_idx, Node_List &amp;rpo_list) const;
1456   void verify() const;          // Major slow  :-)
1457   void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &amp;visited) const;
1458   IdealLoopTree* get_loop_idx(Node* n) const {
1459     // Dead nodes have no loop, so return the top level loop instead
1460     return _nodes[n-&gt;_idx] ? (IdealLoopTree*)_nodes[n-&gt;_idx] : _ltree_root;
1461   }
1462   // Print some stats
1463   static void print_statistics();
1464   static int _loop_invokes;     // Count of PhaseIdealLoop invokes
1465   static int _loop_work;        // Sum of PhaseIdealLoop x _unique
1466 #endif
1467 
1468   void rpo(Node* start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list) const;
1469 };
1470 
1471 
1472 class AutoNodeBudget : public StackObj
1473 {
1474 public:
1475   enum budget_check_t { BUDGET_CHECK, NO_BUDGET_CHECK };
1476 
1477   AutoNodeBudget(PhaseIdealLoop* phase, budget_check_t chk = BUDGET_CHECK)
1478     : _phase(phase),
1479       _check_at_final(chk == BUDGET_CHECK),
1480       _nodes_at_begin(0)
1481   {
1482     precond(_phase != NULL);
1483 
1484     _nodes_at_begin = _phase-&gt;require_nodes_begin();
1485   }
1486 
1487   ~AutoNodeBudget() {
1488 #ifndef PRODUCT
1489     if (TraceLoopOpts) {
1490       uint request = _phase-&gt;nodes_required();
1491       uint delta   = _phase-&gt;C-&gt;live_nodes() - _nodes_at_begin;
1492 
1493       if (request &lt; delta) {
1494         tty-&gt;print_cr(&quot;Exceeding node budget: %d &lt; %d&quot;, request, delta);
1495       } else {
1496         uint const REQUIRE_MIN = PhaseIdealLoop::REQUIRE_MIN;
1497         // Identify the worst estimates as &quot;poor&quot; ones.
1498         if (request &gt; REQUIRE_MIN &amp;&amp; delta &gt; 0) {
1499           if ((delta &gt;  REQUIRE_MIN &amp;&amp; request &gt;  3 * delta) ||
1500               (delta &lt;= REQUIRE_MIN &amp;&amp; request &gt; 10 * delta)) {
1501             tty-&gt;print_cr(&quot;Poor node estimate: %d &gt;&gt; %d&quot;, request, delta);
1502           }
1503         }
1504       }
1505     }
1506 #endif // PRODUCT
1507     _phase-&gt;require_nodes_final(_nodes_at_begin, _check_at_final);
1508   }
1509 
1510 private:
1511   PhaseIdealLoop* _phase;
1512   bool _check_at_final;
1513   uint _nodes_at_begin;
1514 };
1515 
1516 
1517 // This kit may be used for making of a reserved copy of a loop before this loop
1518 //  goes under non-reversible changes.
1519 //
1520 // Function create_reserve() creates a reserved copy (clone) of the loop.
1521 // The reserved copy is created by calling
1522 // PhaseIdealLoop::create_reserve_version_of_loop - see there how
1523 // the original and reserved loops are connected in the outer graph.
1524 // If create_reserve succeeded, it returns &#39;true&#39; and _has_reserved is set to &#39;true&#39;.
1525 //
1526 // By default the reserved copy (clone) of the loop is created as dead code - it is
1527 // dominated in the outer loop by this node chain:
1528 //   intcon(1)-&gt;If-&gt;IfFalse-&gt;reserved_copy.
1529 // The original loop is dominated by the the same node chain but IfTrue projection:
1530 //   intcon(0)-&gt;If-&gt;IfTrue-&gt;original_loop.
1531 //
1532 // In this implementation of CountedLoopReserveKit the ctor includes create_reserve()
1533 // and the dtor, checks _use_new value.
1534 // If _use_new == false, it &quot;switches&quot; control to reserved copy of the loop
1535 // by simple replacing of node intcon(1) with node intcon(0).
1536 //
1537 // Here is a proposed example of usage (see also SuperWord::output in superword.cpp).
1538 //
1539 // void CountedLoopReserveKit_example()
1540 // {
1541 //    CountedLoopReserveKit lrk((phase, lpt, DoReserveCopy = true); // create local object
1542 //    if (DoReserveCopy &amp;&amp; !lrk.has_reserved()) {
1543 //      return; //failed to create reserved loop copy
1544 //    }
1545 //    ...
1546 //    //something is wrong, switch to original loop
1547 ///   if(something_is_wrong) return; // ~CountedLoopReserveKit makes the switch
1548 //    ...
1549 //    //everything worked ok, return with the newly modified loop
1550 //    lrk.use_new();
1551 //    return; // ~CountedLoopReserveKit does nothing once use_new() was called
1552 //  }
1553 //
1554 // Keep in mind, that by default if create_reserve() is not followed by use_new()
1555 // the dtor will &quot;switch to the original&quot; loop.
1556 // NOTE. You you modify outside of the original loop this class is no help.
1557 //
1558 class CountedLoopReserveKit {
1559   private:
1560     PhaseIdealLoop* _phase;
1561     IdealLoopTree*  _lpt;
1562     LoopNode*       _lp;
1563     IfNode*         _iff;
1564     LoopNode*       _lp_reserved;
1565     bool            _has_reserved;
1566     bool            _use_new;
1567     const bool      _active; //may be set to false in ctor, then the object is dummy
1568 
1569   public:
1570     CountedLoopReserveKit(PhaseIdealLoop* phase, IdealLoopTree *loop, bool active);
1571     ~CountedLoopReserveKit();
1572     void use_new()                {_use_new = true;}
1573     void set_iff(IfNode* x)       {_iff = x;}
1574     bool has_reserved()     const { return _active &amp;&amp; _has_reserved;}
1575   private:
1576     bool create_reserve();
1577 };// class CountedLoopReserveKit
1578 
1579 inline Node* IdealLoopTree::tail() {
1580   // Handle lazy update of _tail field.
1581   if (_tail-&gt;in(0) == NULL) {
1582     _tail = _phase-&gt;get_ctrl(_tail);
1583   }
1584   return _tail;
1585 }
1586 
1587 inline Node* IdealLoopTree::head() {
1588   // Handle lazy update of _head field.
1589   if (_head-&gt;in(0) == NULL) {
1590     _head = _phase-&gt;get_ctrl(_head);
1591   }
1592   return _head;
1593 }
1594 
1595 // Iterate over the loop tree using a preorder, left-to-right traversal.
1596 //
1597 // Example that visits all counted loops from within PhaseIdealLoop
1598 //
1599 //  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
1600 //   IdealLoopTree* lpt = iter.current();
1601 //   if (!lpt-&gt;is_counted()) continue;
1602 //   ...
1603 class LoopTreeIterator : public StackObj {
1604 private:
1605   IdealLoopTree* _root;
1606   IdealLoopTree* _curnt;
1607 
1608 public:
1609   LoopTreeIterator(IdealLoopTree* root) : _root(root), _curnt(root) {}
1610 
1611   bool done() { return _curnt == NULL; }       // Finished iterating?
1612 
1613   void next();                                 // Advance to next loop tree
1614 
1615   IdealLoopTree* current() { return _curnt; }  // Return current value of iterator.
1616 };
1617 
1618 #endif // SHARE_OPTO_LOOPNODE_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>