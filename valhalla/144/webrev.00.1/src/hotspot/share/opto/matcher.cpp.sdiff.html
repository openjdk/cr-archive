<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/matcher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/matcher.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 155   Unique_Node_List worklist;
 156   VectorSet visited;
 157   worklist.push(xroot);
 158   while (worklist.size() &gt; 0) {
 159     Node* n = worklist.pop();
 160     visited.set(n-&gt;_idx);
 161     assert(C-&gt;node_arena()-&gt;contains(n), &quot;dead node&quot;);
 162     for (uint j = 0; j &lt; n-&gt;req(); j++) {
 163       Node* in = n-&gt;in(j);
 164       if (in != NULL) {
 165         assert(C-&gt;node_arena()-&gt;contains(in), &quot;dead node&quot;);
 166         if (!visited.test(in-&gt;_idx)) {
 167           worklist.push(in);
 168         }
 169       }
 170     }
 171   }
 172 }
 173 #endif
 174 














































 175 
 176 //---------------------------match---------------------------------------------
 177 void Matcher::match( ) {
 178   if( MaxLabelRootDepth &lt; 100 ) { // Too small?
 179     assert(false, &quot;invalid MaxLabelRootDepth, increase it to 100 minimum&quot;);
 180     MaxLabelRootDepth = 100;
 181   }
 182   // One-time initialization of some register masks.
 183   init_spill_mask( C-&gt;root()-&gt;in(1) );
 184   _return_addr_mask = return_addr();
 185 #ifdef _LP64
 186   // Pointers take 2 slots in 64-bit land
 187   _return_addr_mask.Insert(OptoReg::add(return_addr(),1));
 188 #endif
 189 
<span class="line-modified"> 190   // Map a Java-signature return type into return register-value</span>
<span class="line-modified"> 191   // machine registers for 0, 1 and 2 returned values.</span>
<span class="line-modified"> 192   const TypeTuple *range = C-&gt;tf()-&gt;range();</span>
<span class="line-modified"> 193   if( range-&gt;cnt() &gt; TypeFunc::Parms ) { // If not a void function</span>
<span class="line-removed"> 194     // Get ideal-register return type</span>
<span class="line-removed"> 195     uint ireg = range-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();</span>
<span class="line-removed"> 196     // Get machine return register</span>
<span class="line-removed"> 197     uint sop = C-&gt;start()-&gt;Opcode();</span>
<span class="line-removed"> 198     OptoRegPair regs = return_value(ireg, false);</span>
<span class="line-removed"> 199 </span>
<span class="line-removed"> 200     // And mask for same</span>
<span class="line-removed"> 201     _return_value_mask = RegMask(regs.first());</span>
<span class="line-removed"> 202     if( OptoReg::is_valid(regs.second()) )</span>
<span class="line-removed"> 203       _return_value_mask.Insert(regs.second());</span>
<span class="line-removed"> 204   }</span>
 205 
 206   // ---------------
 207   // Frame Layout
 208 
 209   // Need the method signature to determine the incoming argument types,
 210   // because the types determine which registers the incoming arguments are
 211   // in, and this affects the matched code.
<span class="line-modified"> 212   const TypeTuple *domain = C-&gt;tf()-&gt;domain();</span>
 213   uint             argcnt = domain-&gt;cnt() - TypeFunc::Parms;
 214   BasicType *sig_bt        = NEW_RESOURCE_ARRAY( BasicType, argcnt );
 215   VMRegPair *vm_parm_regs  = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
 216   _parm_regs               = NEW_RESOURCE_ARRAY( OptoRegPair, argcnt );
 217   _calling_convention_mask = NEW_RESOURCE_ARRAY( RegMask, argcnt );
 218   uint i;
 219   for( i = 0; i&lt;argcnt; i++ ) {
 220     sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();
 221   }
 222 
 223   // Pass array of ideal registers and length to USER code (from the AD file)
 224   // that will convert this to an array of register numbers.
 225   const StartNode *start = C-&gt;start();
 226   start-&gt;calling_convention( sig_bt, vm_parm_regs, argcnt );
 227 #ifdef ASSERT
 228   // Sanity check users&#39; calling convention.  Real handy while trying to
 229   // get the initial port correct.
 230   { for (uint i = 0; i&lt;argcnt; i++) {
 231       if( !vm_parm_regs[i].first()-&gt;is_valid() &amp;&amp; !vm_parm_regs[i].second()-&gt;is_valid() ) {
 232         assert(domain-&gt;field_at(i+TypeFunc::Parms)==Type::HALF, &quot;only allowed on halve&quot; );
</pre>
<hr />
<pre>
 458   idealreg2mhdebugmask[Op_RegF] = &amp;rms[15];
 459   idealreg2mhdebugmask[Op_RegD] = &amp;rms[16];
 460   idealreg2mhdebugmask[Op_RegP] = &amp;rms[17];
 461 
 462   idealreg2spillmask  [Op_VecS] = &amp;rms[18];
 463   idealreg2spillmask  [Op_VecD] = &amp;rms[19];
 464   idealreg2spillmask  [Op_VecX] = &amp;rms[20];
 465   idealreg2spillmask  [Op_VecY] = &amp;rms[21];
 466   idealreg2spillmask  [Op_VecZ] = &amp;rms[22];
 467 
 468   OptoReg::Name i;
 469 
 470   // At first, start with the empty mask
 471   C-&gt;FIRST_STACK_mask().Clear();
 472 
 473   // Add in the incoming argument area
 474   OptoReg::Name init_in = OptoReg::add(_old_SP, C-&gt;out_preserve_stack_slots());
 475   for (i = init_in; i &lt; _in_arg_limit; i = OptoReg::add(i,1)) {
 476     C-&gt;FIRST_STACK_mask().Insert(i);
 477   }



















 478   // Add in all bits past the outgoing argument area
 479   guarantee(RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1)),
 480             &quot;must be able to represent all call arguments in reg mask&quot;);
 481   OptoReg::Name init = _out_arg_limit;
 482   for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1)) {
 483     C-&gt;FIRST_STACK_mask().Insert(i);
 484   }
 485   // Finally, set the &quot;infinite stack&quot; bit.
 486   C-&gt;FIRST_STACK_mask().set_AllStack();
 487 
 488   // Make spill masks.  Registers for their class, plus FIRST_STACK_mask.
 489   RegMask aligned_stack_mask = C-&gt;FIRST_STACK_mask();
 490   // Keep spill masks aligned.
 491   aligned_stack_mask.clear_to_pairs();
 492   assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 493 
 494   *idealreg2spillmask[Op_RegP] = *idealreg2regmask[Op_RegP];
 495 #ifdef _LP64
 496   *idealreg2spillmask[Op_RegN] = *idealreg2regmask[Op_RegN];
 497    idealreg2spillmask[Op_RegN]-&gt;OR(C-&gt;FIRST_STACK_mask());
</pre>
<hr />
<pre>
 650   init_first_stack_mask();
 651 
 652   Node *root = C-&gt;root();       // Short name for root
 653   // Count number of save-on-entry registers.
 654   uint soe_cnt = number_of_saved_registers();
 655   uint i;
 656 
 657   // Find the procedure Start Node
 658   StartNode *start = C-&gt;start();
 659   assert( start, &quot;Expect a start node&quot; );
 660 
 661   // Save argument registers in the trampolining stubs
 662   if( C-&gt;save_argument_registers() )
 663     for( i = 0; i &lt; _last_Mach_Reg; i++ )
 664       if( is_spillable_arg(i) )
 665         soe_cnt++;
 666 
 667   // Input RegMask array shared by all Returns.
 668   // The type for doubles and longs has a count of 2, but
 669   // there is only 1 returned value
<span class="line-modified"> 670   uint ret_edge_cnt = TypeFunc::Parms + ((C-&gt;tf()-&gt;range()-&gt;cnt() == TypeFunc::Parms) ? 0 : 1);</span>
 671   RegMask *ret_rms  = init_input_masks( ret_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
<span class="line-modified"> 672   // Returns have 0 or 1 returned values depending on call signature.</span>
<span class="line-modified"> 673   // Return register is specified by return_value in the AD file.</span>
<span class="line-modified"> 674   if (ret_edge_cnt &gt; TypeFunc::Parms)</span>
<span class="line-removed"> 675     ret_rms[TypeFunc::Parms+0] = _return_value_mask;</span>
 676 
 677   // Input RegMask array shared by all Rethrows.
 678   uint reth_edge_cnt = TypeFunc::Parms+1;
 679   RegMask *reth_rms  = init_input_masks( reth_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 680   // Rethrow takes exception oop only, but in the argument 0 slot.
 681   OptoReg::Name reg = find_receiver(false);
 682   if (reg &gt;= 0) {
 683     reth_rms[TypeFunc::Parms] = mreg2regmask[reg];
 684 #ifdef _LP64
 685     // Need two slots for ptrs in 64-bit land
 686     reth_rms[TypeFunc::Parms].Insert(OptoReg::add(OptoReg::Name(reg), 1));
 687 #endif
 688   }
 689 
 690   // Input RegMask array shared by all TailCalls
 691   uint tail_call_edge_cnt = TypeFunc::Parms+2;
 692   RegMask *tail_call_rms = init_input_masks( tail_call_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 693 
 694   // Input RegMask array shared by all TailJumps
 695   uint tail_jump_edge_cnt = TypeFunc::Parms+2;
</pre>
<hr />
<pre>
 722   }
 723 
 724   // Input RegMask array shared by all Halts
 725   uint halt_edge_cnt = TypeFunc::Parms;
 726   RegMask *halt_rms = init_input_masks( halt_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 727 
 728   // Capture the return input masks into each exit flavor
 729   for( i=1; i &lt; root-&gt;req(); i++ ) {
 730     MachReturnNode *exit = root-&gt;in(i)-&gt;as_MachReturn();
 731     switch( exit-&gt;ideal_Opcode() ) {
 732       case Op_Return   : exit-&gt;_in_rms = ret_rms;  break;
 733       case Op_Rethrow  : exit-&gt;_in_rms = reth_rms; break;
 734       case Op_TailCall : exit-&gt;_in_rms = tail_call_rms; break;
 735       case Op_TailJump : exit-&gt;_in_rms = tail_jump_rms; break;
 736       case Op_Halt     : exit-&gt;_in_rms = halt_rms; break;
 737       default          : ShouldNotReachHere();
 738     }
 739   }
 740 
 741   // Next unused projection number from Start.
<span class="line-modified"> 742   int proj_cnt = C-&gt;tf()-&gt;domain()-&gt;cnt();</span>
 743 
 744   // Do all the save-on-entry registers.  Make projections from Start for
 745   // them, and give them a use at the exit points.  To the allocator, they
 746   // look like incoming register arguments.
 747   for( i = 0; i &lt; _last_Mach_Reg; i++ ) {
 748     if( is_save_on_entry(i) ) {
 749 
 750       // Add the save-on-entry to the mask array
 751       ret_rms      [      ret_edge_cnt] = mreg2regmask[i];
 752       reth_rms     [     reth_edge_cnt] = mreg2regmask[i];
 753       tail_call_rms[tail_call_edge_cnt] = mreg2regmask[i];
 754       tail_jump_rms[tail_jump_edge_cnt] = mreg2regmask[i];
 755       // Halts need the SOE registers, but only in the stack as debug info.
 756       // A just-prior uncommon-trap or deoptimization will use the SOE regs.
 757       halt_rms     [     halt_edge_cnt] = *idealreg2spillmask[_register_save_type[i]];
 758 
 759       Node *mproj;
 760 
 761       // Is this a RegF low half of a RegD?  Double up 2 adjacent RegF&#39;s
 762       // into a single RegD.
</pre>
<hr />
<pre>
 972       Node *oldn = n;
 973       // Old-space or new-space check
 974       if (!C-&gt;node_arena()-&gt;contains(n)) {
 975         // Old space!
 976         Node* m;
 977         if (has_new_node(n)) {  // Not yet Label/Reduced
 978           m = new_node(n);
 979         } else {
 980           if (!is_dontcare(n)) { // Matcher can match this guy
 981             // Calls match special.  They match alone with no children.
 982             // Their children, the incoming arguments, match normally.
 983             m = n-&gt;is_SafePoint() ? match_sfpt(n-&gt;as_SafePoint()):match_tree(n);
 984             if (C-&gt;failing())  return NULL;
 985             if (m == NULL) { Matcher::soft_match_failure(); return NULL; }
 986             if (n-&gt;is_MemBar()) {
 987               m-&gt;as_MachMemBar()-&gt;set_adr_type(n-&gt;adr_type());
 988             }
 989           } else {                  // Nothing the matcher cares about
 990             if (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_Multi()) {       // Projections?
 991               // Convert to machine-dependent projection
<span class="line-modified"> 992               m = n-&gt;in(0)-&gt;as_Multi()-&gt;match( n-&gt;as_Proj(), this );</span>




 993 #ifdef ASSERT
 994               _new2old_map.map(m-&gt;_idx, n);
 995 #endif
 996               if (m-&gt;in(0) != NULL) // m might be top
 997                 collect_null_checks(m, n);
 998             } else {                // Else just a regular &#39;ol guy
 999               m = n-&gt;clone();       // So just clone into new-space
1000 #ifdef ASSERT
1001               _new2old_map.map(m-&gt;_idx, n);
1002 #endif
1003               // Def-Use edges will be added incrementally as Uses
1004               // of this node are matched.
1005               assert(m-&gt;outcnt() == 0, &quot;no Uses of this clone yet&quot;);
1006             }
1007           }
1008 
1009           set_new_node(n, m);       // Map old to new
1010           if (_old_node_note_array != NULL) {
1011             Node_Notes* nn = C-&gt;locate_node_notes(_old_node_note_array,
1012                                                   n-&gt;_idx);
</pre>
<hr />
<pre>
1117   }
1118   return OptoReg::as_OptoReg(reg);
1119 }
1120 
1121 
1122 //------------------------------match_sfpt-------------------------------------
1123 // Helper function to match call instructions.  Calls match special.
1124 // They match alone with no children.  Their children, the incoming
1125 // arguments, match normally.
1126 MachNode *Matcher::match_sfpt( SafePointNode *sfpt ) {
1127   MachSafePointNode *msfpt = NULL;
1128   MachCallNode      *mcall = NULL;
1129   uint               cnt;
1130   // Split out case for SafePoint vs Call
1131   CallNode *call;
1132   const TypeTuple *domain;
1133   ciMethod*        method = NULL;
1134   bool             is_method_handle_invoke = false;  // for special kill effects
1135   if( sfpt-&gt;is_Call() ) {
1136     call = sfpt-&gt;as_Call();
<span class="line-modified">1137     domain = call-&gt;tf()-&gt;domain();</span>
1138     cnt = domain-&gt;cnt();
1139 
1140     // Match just the call, nothing else
1141     MachNode *m = match_tree(call);
1142     if (C-&gt;failing())  return NULL;
1143     if( m == NULL ) { Matcher::soft_match_failure(); return NULL; }
1144 
1145     // Copy data from the Ideal SafePoint to the machine version
1146     mcall = m-&gt;as_MachCall();
1147 
1148     mcall-&gt;set_tf(         call-&gt;tf());
1149     mcall-&gt;set_entry_point(call-&gt;entry_point());
1150     mcall-&gt;set_cnt(        call-&gt;cnt());
1151 
1152     if( mcall-&gt;is_MachCallJava() ) {
1153       MachCallJavaNode *mcall_java  = mcall-&gt;as_MachCallJava();
1154       const CallJavaNode *call_java =  call-&gt;as_CallJava();
1155       assert(call_java-&gt;validate_symbolic_info(), &quot;inconsistent info&quot;);
1156       method = call_java-&gt;method();
1157       mcall_java-&gt;_method = method;
</pre>
<hr />
<pre>
1192   msfpt-&gt;_in_rms = NEW_RESOURCE_ARRAY( RegMask, cnt );
1193   // Empty them all.
1194   for (uint i = 0; i &lt; cnt; i++) ::new (&amp;(msfpt-&gt;_in_rms[i])) RegMask();
1195 
1196   // Do all the pre-defined non-Empty register masks
1197   msfpt-&gt;_in_rms[TypeFunc::ReturnAdr] = _return_addr_mask;
1198   msfpt-&gt;_in_rms[TypeFunc::FramePtr ] = c_frame_ptr_mask;
1199 
1200   // Place first outgoing argument can possibly be put.
1201   OptoReg::Name begin_out_arg_area = OptoReg::add(_new_SP, C-&gt;out_preserve_stack_slots());
1202   assert( is_even(begin_out_arg_area), &quot;&quot; );
1203   // Compute max outgoing register number per call site.
1204   OptoReg::Name out_arg_limit_per_call = begin_out_arg_area;
1205   // Calls to C may hammer extra stack slots above and beyond any arguments.
1206   // These are usually backing store for register arguments for varargs.
1207   if( call != NULL &amp;&amp; call-&gt;is_CallRuntime() )
1208     out_arg_limit_per_call = OptoReg::add(out_arg_limit_per_call,C-&gt;varargs_C_out_slots_killed());
1209 
1210 
1211   // Do the normal argument list (parameters) register masks
<span class="line-modified">1212   int argcnt = cnt - TypeFunc::Parms;</span>



1213   if( argcnt &gt; 0 ) {          // Skip it all if we have no args
1214     BasicType *sig_bt  = NEW_RESOURCE_ARRAY( BasicType, argcnt );
1215     VMRegPair *parm_regs = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
1216     int i;
1217     for( i = 0; i &lt; argcnt; i++ ) {
<span class="line-modified">1218       sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();</span>
1219     }
1220     // V-call to pick proper calling convention
1221     call-&gt;calling_convention( sig_bt, parm_regs, argcnt );
1222 
1223 #ifdef ASSERT
1224     // Sanity check users&#39; calling convention.  Really handy during
1225     // the initial porting effort.  Fairly expensive otherwise.
1226     { for (int i = 0; i&lt;argcnt; i++) {
1227       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1228           !parm_regs[i].second()-&gt;is_valid() ) continue;
1229       VMReg reg1 = parm_regs[i].first();
1230       VMReg reg2 = parm_regs[i].second();
1231       for (int j = 0; j &lt; i; j++) {
1232         if( !parm_regs[j].first()-&gt;is_valid() &amp;&amp;
1233             !parm_regs[j].second()-&gt;is_valid() ) continue;
1234         VMReg reg3 = parm_regs[j].first();
1235         VMReg reg4 = parm_regs[j].second();
1236         if( !reg1-&gt;is_valid() ) {
1237           assert( !reg2-&gt;is_valid(), &quot;valid halvsies&quot; );
1238         } else if( !reg3-&gt;is_valid() ) {
1239           assert( !reg4-&gt;is_valid(), &quot;valid halvsies&quot; );
1240         } else {
1241           assert( reg1 != reg2, &quot;calling conv. must produce distinct regs&quot;);
1242           assert( reg1 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1243           assert( reg1 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1244           assert( reg2 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1245           assert( reg2 != reg4 || !reg2-&gt;is_valid(), &quot;calling conv. must produce distinct regs&quot;);
1246           assert( reg3 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1247         }
1248       }
1249     }
1250     }
1251 #endif
1252 
1253     // Visit each argument.  Compute its outgoing register mask.
1254     // Return results now can have 2 bits returned.
1255     // Compute max over all outgoing arguments both per call-site
1256     // and over the entire method.
1257     for( i = 0; i &lt; argcnt; i++ ) {
1258       // Address of incoming argument mask to fill in
<span class="line-modified">1259       RegMask *rm = &amp;mcall-&gt;_in_rms[i+TypeFunc::Parms];</span>
1260       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1261           !parm_regs[i].second()-&gt;is_valid() ) {
1262         continue;               // Avoid Halves
1263       }
1264       // Grab first register, adjust stack slots and insert in mask.
1265       OptoReg::Name reg1 = warp_outgoing_stk_arg(parm_regs[i].first(), begin_out_arg_area, out_arg_limit_per_call );
<span class="line-modified">1266       if (OptoReg::is_valid(reg1))</span>
1267         rm-&gt;Insert( reg1 );

1268       // Grab second register (if any), adjust stack slots and insert in mask.
1269       OptoReg::Name reg2 = warp_outgoing_stk_arg(parm_regs[i].second(), begin_out_arg_area, out_arg_limit_per_call );
<span class="line-modified">1270       if (OptoReg::is_valid(reg2))</span>
1271         rm-&gt;Insert( reg2 );

1272     } // End of for all arguments
1273 
1274     // Compute number of stack slots needed to restore stack in case of
1275     // Pascal-style argument popping.
1276     mcall-&gt;_argsize = out_arg_limit_per_call - begin_out_arg_area;
1277   }
1278 
1279   // Compute the max stack slot killed by any call.  These will not be
1280   // available for debug info, and will be used to adjust FIRST_STACK_mask
1281   // after all call sites have been visited.
1282   if( _out_arg_limit &lt; out_arg_limit_per_call)
1283     _out_arg_limit = out_arg_limit_per_call;
1284 
1285   if (mcall) {
1286     // Kill the outgoing argument area, including any non-argument holes and
1287     // any legacy C-killed slots.  Use Fat-Projections to do the killing.
1288     // Since the max-per-method covers the max-per-call-site and debug info
1289     // is excluded on the max-per-method basis, debug info cannot land in
1290     // this killed area.
<span class="line-modified">1291     uint r_cnt = mcall-&gt;tf()-&gt;range()-&gt;cnt();</span>
1292     MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::Empty, MachProjNode::fat_proj );
1293     if (!RegMask::can_represent_arg(OptoReg::Name(out_arg_limit_per_call-1))) {
1294       C-&gt;record_method_not_compilable(&quot;unsupported outgoing calling sequence&quot;);
1295     } else {
1296       for (int i = begin_out_arg_area; i &lt; out_arg_limit_per_call; i++)
1297         proj-&gt;_rout.Insert(OptoReg::Name(i));
1298     }
1299     if (proj-&gt;_rout.is_NotEmpty()) {
1300       push_projection(proj);
1301     }
1302   }
1303   // Transfer the safepoint information from the call to the mcall
1304   // Move the JVMState list
1305   msfpt-&gt;set_jvms(sfpt-&gt;jvms());
1306   for (JVMState* jvms = msfpt-&gt;jvms(); jvms; jvms = jvms-&gt;caller()) {
1307     jvms-&gt;set_map(sfpt);
1308   }
1309 
1310   // Debug inputs begin just after the last incoming parameter
1311   assert((mcall == NULL) || (mcall-&gt;jvms() == NULL) ||
<span class="line-modified">1312          (mcall-&gt;jvms()-&gt;debug_start() + mcall-&gt;_jvmadj == mcall-&gt;tf()-&gt;domain()-&gt;cnt()), &quot;&quot;);</span>
1313 
1314   // Move the OopMap
1315   msfpt-&gt;_oop_map = sfpt-&gt;_oop_map;
1316 
1317   // Add additional edges.
1318   if (msfpt-&gt;mach_constant_base_node_input() != (uint)-1 &amp;&amp; !msfpt-&gt;is_MachCallLeaf()) {
1319     // For these calls we can not add MachConstantBase in expand(), as the
1320     // ins are not complete then.
1321     msfpt-&gt;ins_req(msfpt-&gt;mach_constant_base_node_input(), C-&gt;mach_constant_base_node());
1322     if (msfpt-&gt;jvms() &amp;&amp;
1323         msfpt-&gt;mach_constant_base_node_input() &lt;= msfpt-&gt;jvms()-&gt;debug_start() + msfpt-&gt;_jvmadj) {
1324       // We added an edge before jvms, so we must adapt the position of the ins.
1325       msfpt-&gt;jvms()-&gt;adapt_position(+1);
1326     }
1327   }
1328 
1329   // Registers killed by the call are set in the local scheduling pass
1330   // of Global Code Motion.
1331   return msfpt;
1332 }
</pre>
<hr />
<pre>
2256     case Op_FmaD:
2257     case Op_FmaF:
2258     case Op_FmaVD:
2259     case Op_FmaVF: {
2260       // Restructure into a binary tree for Matching.
2261       Node* pair = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2262       n-&gt;set_req(2, pair);
2263       n-&gt;set_req(1, n-&gt;in(3));
2264       n-&gt;del_req(3);
2265       break;
2266     }
2267     case Op_MulAddS2I: {
2268       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2269       Node* pair2 = new BinaryNode(n-&gt;in(3), n-&gt;in(4));
2270       n-&gt;set_req(1, pair1);
2271       n-&gt;set_req(2, pair2);
2272       n-&gt;del_req(4);
2273       n-&gt;del_req(3);
2274       break;
2275     }







2276     default:
2277       break;
2278   }
2279 }
2280 
2281 #ifdef ASSERT
2282 // machine-independent root to machine-dependent root
2283 void Matcher::dump_old2new_map() {
2284   _old2new_map.dump();
2285 }
2286 #endif
2287 
2288 //---------------------------collect_null_checks-------------------------------
2289 // Find null checks in the ideal graph; write a machine-specific node for
2290 // it.  Used by later implicit-null-check handling.  Actually collects
2291 // either an IfTrue or IfFalse for the common NOT-null path, AND the ideal
2292 // value being tested.
2293 void Matcher::collect_null_checks( Node *proj, Node *orig_proj ) {
2294   Node *iff = proj-&gt;in(0);
2295   if( iff-&gt;Opcode() == Op_If ) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 155   Unique_Node_List worklist;
 156   VectorSet visited;
 157   worklist.push(xroot);
 158   while (worklist.size() &gt; 0) {
 159     Node* n = worklist.pop();
 160     visited.set(n-&gt;_idx);
 161     assert(C-&gt;node_arena()-&gt;contains(n), &quot;dead node&quot;);
 162     for (uint j = 0; j &lt; n-&gt;req(); j++) {
 163       Node* in = n-&gt;in(j);
 164       if (in != NULL) {
 165         assert(C-&gt;node_arena()-&gt;contains(in), &quot;dead node&quot;);
 166         if (!visited.test(in-&gt;_idx)) {
 167           worklist.push(in);
 168         }
 169       }
 170     }
 171   }
 172 }
 173 #endif
 174 
<span class="line-added"> 175 // Array of RegMask, one per returned values (inline type instances can</span>
<span class="line-added"> 176 // be returned as multiple return values, one per field)</span>
<span class="line-added"> 177 RegMask* Matcher::return_values_mask(const TypeTuple *range) {</span>
<span class="line-added"> 178   uint cnt = range-&gt;cnt() - TypeFunc::Parms;</span>
<span class="line-added"> 179   if (cnt == 0) {</span>
<span class="line-added"> 180     return NULL;</span>
<span class="line-added"> 181   }</span>
<span class="line-added"> 182   RegMask* mask = NEW_RESOURCE_ARRAY(RegMask, cnt);</span>
<span class="line-added"> 183 </span>
<span class="line-added"> 184   if (!InlineTypeReturnedAsFields) {</span>
<span class="line-added"> 185     // Get ideal-register return type</span>
<span class="line-added"> 186     uint ireg = range-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();</span>
<span class="line-added"> 187     // Get machine return register</span>
<span class="line-added"> 188     OptoRegPair regs = return_value(ireg, false);</span>
<span class="line-added"> 189 </span>
<span class="line-added"> 190     // And mask for same</span>
<span class="line-added"> 191     mask[0].Clear();</span>
<span class="line-added"> 192     mask[0].Insert(regs.first());</span>
<span class="line-added"> 193     if (OptoReg::is_valid(regs.second())) {</span>
<span class="line-added"> 194       mask[0].Insert(regs.second());</span>
<span class="line-added"> 195     }</span>
<span class="line-added"> 196   } else {</span>
<span class="line-added"> 197     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, cnt);</span>
<span class="line-added"> 198     VMRegPair* vm_parm_regs = NEW_RESOURCE_ARRAY(VMRegPair, cnt);</span>
<span class="line-added"> 199 </span>
<span class="line-added"> 200     for (uint i = 0; i &lt; cnt; i++) {</span>
<span class="line-added"> 201       sig_bt[i] = range-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();</span>
<span class="line-added"> 202     }</span>
<span class="line-added"> 203 </span>
<span class="line-added"> 204     int regs = SharedRuntime::java_return_convention(sig_bt, vm_parm_regs, cnt);</span>
<span class="line-added"> 205     assert(regs &gt; 0, &quot;should have been tested during graph construction&quot;);</span>
<span class="line-added"> 206     for (uint i = 0; i &lt; cnt; i++) {</span>
<span class="line-added"> 207       mask[i].Clear();</span>
<span class="line-added"> 208 </span>
<span class="line-added"> 209       OptoReg::Name reg1 = OptoReg::as_OptoReg(vm_parm_regs[i].first());</span>
<span class="line-added"> 210       if (OptoReg::is_valid(reg1)) {</span>
<span class="line-added"> 211         mask[i].Insert(reg1);</span>
<span class="line-added"> 212       }</span>
<span class="line-added"> 213       OptoReg::Name reg2 = OptoReg::as_OptoReg(vm_parm_regs[i].second());</span>
<span class="line-added"> 214       if (OptoReg::is_valid(reg2)) {</span>
<span class="line-added"> 215         mask[i].Insert(reg2);</span>
<span class="line-added"> 216       }</span>
<span class="line-added"> 217     }</span>
<span class="line-added"> 218   }</span>
<span class="line-added"> 219   return mask;</span>
<span class="line-added"> 220 }</span>
 221 
 222 //---------------------------match---------------------------------------------
 223 void Matcher::match( ) {
 224   if( MaxLabelRootDepth &lt; 100 ) { // Too small?
 225     assert(false, &quot;invalid MaxLabelRootDepth, increase it to 100 minimum&quot;);
 226     MaxLabelRootDepth = 100;
 227   }
 228   // One-time initialization of some register masks.
 229   init_spill_mask( C-&gt;root()-&gt;in(1) );
 230   _return_addr_mask = return_addr();
 231 #ifdef _LP64
 232   // Pointers take 2 slots in 64-bit land
 233   _return_addr_mask.Insert(OptoReg::add(return_addr(),1));
 234 #endif
 235 
<span class="line-modified"> 236   // Map Java-signature return types into return register-value</span>
<span class="line-modified"> 237   // machine registers.</span>
<span class="line-modified"> 238   const TypeTuple *range = C-&gt;tf()-&gt;range_cc();</span>
<span class="line-modified"> 239   _return_values_mask = return_values_mask(range);</span>











 240 
 241   // ---------------
 242   // Frame Layout
 243 
 244   // Need the method signature to determine the incoming argument types,
 245   // because the types determine which registers the incoming arguments are
 246   // in, and this affects the matched code.
<span class="line-modified"> 247   const TypeTuple *domain = C-&gt;tf()-&gt;domain_cc();</span>
 248   uint             argcnt = domain-&gt;cnt() - TypeFunc::Parms;
 249   BasicType *sig_bt        = NEW_RESOURCE_ARRAY( BasicType, argcnt );
 250   VMRegPair *vm_parm_regs  = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
 251   _parm_regs               = NEW_RESOURCE_ARRAY( OptoRegPair, argcnt );
 252   _calling_convention_mask = NEW_RESOURCE_ARRAY( RegMask, argcnt );
 253   uint i;
 254   for( i = 0; i&lt;argcnt; i++ ) {
 255     sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();
 256   }
 257 
 258   // Pass array of ideal registers and length to USER code (from the AD file)
 259   // that will convert this to an array of register numbers.
 260   const StartNode *start = C-&gt;start();
 261   start-&gt;calling_convention( sig_bt, vm_parm_regs, argcnt );
 262 #ifdef ASSERT
 263   // Sanity check users&#39; calling convention.  Real handy while trying to
 264   // get the initial port correct.
 265   { for (uint i = 0; i&lt;argcnt; i++) {
 266       if( !vm_parm_regs[i].first()-&gt;is_valid() &amp;&amp; !vm_parm_regs[i].second()-&gt;is_valid() ) {
 267         assert(domain-&gt;field_at(i+TypeFunc::Parms)==Type::HALF, &quot;only allowed on halve&quot; );
</pre>
<hr />
<pre>
 493   idealreg2mhdebugmask[Op_RegF] = &amp;rms[15];
 494   idealreg2mhdebugmask[Op_RegD] = &amp;rms[16];
 495   idealreg2mhdebugmask[Op_RegP] = &amp;rms[17];
 496 
 497   idealreg2spillmask  [Op_VecS] = &amp;rms[18];
 498   idealreg2spillmask  [Op_VecD] = &amp;rms[19];
 499   idealreg2spillmask  [Op_VecX] = &amp;rms[20];
 500   idealreg2spillmask  [Op_VecY] = &amp;rms[21];
 501   idealreg2spillmask  [Op_VecZ] = &amp;rms[22];
 502 
 503   OptoReg::Name i;
 504 
 505   // At first, start with the empty mask
 506   C-&gt;FIRST_STACK_mask().Clear();
 507 
 508   // Add in the incoming argument area
 509   OptoReg::Name init_in = OptoReg::add(_old_SP, C-&gt;out_preserve_stack_slots());
 510   for (i = init_in; i &lt; _in_arg_limit; i = OptoReg::add(i,1)) {
 511     C-&gt;FIRST_STACK_mask().Insert(i);
 512   }
<span class="line-added"> 513 </span>
<span class="line-added"> 514   // Check if the method has a reserved entry in the argument stack area that</span>
<span class="line-added"> 515   // should not be used for spilling because it may hold the return address.</span>
<span class="line-added"> 516   if (!C-&gt;is_osr_compilation() &amp;&amp; C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;has_scalarized_args()) {</span>
<span class="line-added"> 517     ExtendedSignature sig_cc = ExtendedSignature(C-&gt;method()-&gt;get_sig_cc(), SigEntryFilter());</span>
<span class="line-added"> 518     for (int off = 0; !sig_cc.at_end(); ) {</span>
<span class="line-added"> 519       BasicType bt = (*sig_cc)._bt;</span>
<span class="line-added"> 520       off += type2size[bt];</span>
<span class="line-added"> 521       while (SigEntry::next_is_reserved(sig_cc, bt)) {</span>
<span class="line-added"> 522         // Remove reserved stack slot from mask to avoid spilling</span>
<span class="line-added"> 523         OptoRegPair reg = _parm_regs[off];</span>
<span class="line-added"> 524         assert(OptoReg::is_valid(reg.first()), &quot;invalid reserved register&quot;);</span>
<span class="line-added"> 525         C-&gt;FIRST_STACK_mask().Remove(reg.first());</span>
<span class="line-added"> 526         C-&gt;FIRST_STACK_mask().Remove(reg.first()+1); // Always occupies two stack slots</span>
<span class="line-added"> 527         off += type2size[bt];</span>
<span class="line-added"> 528       }</span>
<span class="line-added"> 529     }</span>
<span class="line-added"> 530   }</span>
<span class="line-added"> 531 </span>
 532   // Add in all bits past the outgoing argument area
 533   guarantee(RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1)),
 534             &quot;must be able to represent all call arguments in reg mask&quot;);
 535   OptoReg::Name init = _out_arg_limit;
 536   for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1)) {
 537     C-&gt;FIRST_STACK_mask().Insert(i);
 538   }
 539   // Finally, set the &quot;infinite stack&quot; bit.
 540   C-&gt;FIRST_STACK_mask().set_AllStack();
 541 
 542   // Make spill masks.  Registers for their class, plus FIRST_STACK_mask.
 543   RegMask aligned_stack_mask = C-&gt;FIRST_STACK_mask();
 544   // Keep spill masks aligned.
 545   aligned_stack_mask.clear_to_pairs();
 546   assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 547 
 548   *idealreg2spillmask[Op_RegP] = *idealreg2regmask[Op_RegP];
 549 #ifdef _LP64
 550   *idealreg2spillmask[Op_RegN] = *idealreg2regmask[Op_RegN];
 551    idealreg2spillmask[Op_RegN]-&gt;OR(C-&gt;FIRST_STACK_mask());
</pre>
<hr />
<pre>
 704   init_first_stack_mask();
 705 
 706   Node *root = C-&gt;root();       // Short name for root
 707   // Count number of save-on-entry registers.
 708   uint soe_cnt = number_of_saved_registers();
 709   uint i;
 710 
 711   // Find the procedure Start Node
 712   StartNode *start = C-&gt;start();
 713   assert( start, &quot;Expect a start node&quot; );
 714 
 715   // Save argument registers in the trampolining stubs
 716   if( C-&gt;save_argument_registers() )
 717     for( i = 0; i &lt; _last_Mach_Reg; i++ )
 718       if( is_spillable_arg(i) )
 719         soe_cnt++;
 720 
 721   // Input RegMask array shared by all Returns.
 722   // The type for doubles and longs has a count of 2, but
 723   // there is only 1 returned value
<span class="line-modified"> 724   uint ret_edge_cnt = C-&gt;tf()-&gt;range_cc()-&gt;cnt();</span>
 725   RegMask *ret_rms  = init_input_masks( ret_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
<span class="line-modified"> 726   for (i = TypeFunc::Parms; i &lt; ret_edge_cnt; i++) {</span>
<span class="line-modified"> 727     ret_rms[i] = _return_values_mask[i-TypeFunc::Parms];</span>
<span class="line-modified"> 728   }</span>

 729 
 730   // Input RegMask array shared by all Rethrows.
 731   uint reth_edge_cnt = TypeFunc::Parms+1;
 732   RegMask *reth_rms  = init_input_masks( reth_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 733   // Rethrow takes exception oop only, but in the argument 0 slot.
 734   OptoReg::Name reg = find_receiver(false);
 735   if (reg &gt;= 0) {
 736     reth_rms[TypeFunc::Parms] = mreg2regmask[reg];
 737 #ifdef _LP64
 738     // Need two slots for ptrs in 64-bit land
 739     reth_rms[TypeFunc::Parms].Insert(OptoReg::add(OptoReg::Name(reg), 1));
 740 #endif
 741   }
 742 
 743   // Input RegMask array shared by all TailCalls
 744   uint tail_call_edge_cnt = TypeFunc::Parms+2;
 745   RegMask *tail_call_rms = init_input_masks( tail_call_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 746 
 747   // Input RegMask array shared by all TailJumps
 748   uint tail_jump_edge_cnt = TypeFunc::Parms+2;
</pre>
<hr />
<pre>
 775   }
 776 
 777   // Input RegMask array shared by all Halts
 778   uint halt_edge_cnt = TypeFunc::Parms;
 779   RegMask *halt_rms = init_input_masks( halt_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 780 
 781   // Capture the return input masks into each exit flavor
 782   for( i=1; i &lt; root-&gt;req(); i++ ) {
 783     MachReturnNode *exit = root-&gt;in(i)-&gt;as_MachReturn();
 784     switch( exit-&gt;ideal_Opcode() ) {
 785       case Op_Return   : exit-&gt;_in_rms = ret_rms;  break;
 786       case Op_Rethrow  : exit-&gt;_in_rms = reth_rms; break;
 787       case Op_TailCall : exit-&gt;_in_rms = tail_call_rms; break;
 788       case Op_TailJump : exit-&gt;_in_rms = tail_jump_rms; break;
 789       case Op_Halt     : exit-&gt;_in_rms = halt_rms; break;
 790       default          : ShouldNotReachHere();
 791     }
 792   }
 793 
 794   // Next unused projection number from Start.
<span class="line-modified"> 795   int proj_cnt = C-&gt;tf()-&gt;domain_cc()-&gt;cnt();</span>
 796 
 797   // Do all the save-on-entry registers.  Make projections from Start for
 798   // them, and give them a use at the exit points.  To the allocator, they
 799   // look like incoming register arguments.
 800   for( i = 0; i &lt; _last_Mach_Reg; i++ ) {
 801     if( is_save_on_entry(i) ) {
 802 
 803       // Add the save-on-entry to the mask array
 804       ret_rms      [      ret_edge_cnt] = mreg2regmask[i];
 805       reth_rms     [     reth_edge_cnt] = mreg2regmask[i];
 806       tail_call_rms[tail_call_edge_cnt] = mreg2regmask[i];
 807       tail_jump_rms[tail_jump_edge_cnt] = mreg2regmask[i];
 808       // Halts need the SOE registers, but only in the stack as debug info.
 809       // A just-prior uncommon-trap or deoptimization will use the SOE regs.
 810       halt_rms     [     halt_edge_cnt] = *idealreg2spillmask[_register_save_type[i]];
 811 
 812       Node *mproj;
 813 
 814       // Is this a RegF low half of a RegD?  Double up 2 adjacent RegF&#39;s
 815       // into a single RegD.
</pre>
<hr />
<pre>
1025       Node *oldn = n;
1026       // Old-space or new-space check
1027       if (!C-&gt;node_arena()-&gt;contains(n)) {
1028         // Old space!
1029         Node* m;
1030         if (has_new_node(n)) {  // Not yet Label/Reduced
1031           m = new_node(n);
1032         } else {
1033           if (!is_dontcare(n)) { // Matcher can match this guy
1034             // Calls match special.  They match alone with no children.
1035             // Their children, the incoming arguments, match normally.
1036             m = n-&gt;is_SafePoint() ? match_sfpt(n-&gt;as_SafePoint()):match_tree(n);
1037             if (C-&gt;failing())  return NULL;
1038             if (m == NULL) { Matcher::soft_match_failure(); return NULL; }
1039             if (n-&gt;is_MemBar()) {
1040               m-&gt;as_MachMemBar()-&gt;set_adr_type(n-&gt;adr_type());
1041             }
1042           } else {                  // Nothing the matcher cares about
1043             if (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_Multi()) {       // Projections?
1044               // Convert to machine-dependent projection
<span class="line-modified">1045               RegMask* mask = NULL;</span>
<span class="line-added">1046               if (n-&gt;in(0)-&gt;is_Call()) {</span>
<span class="line-added">1047                 mask = return_values_mask(n-&gt;in(0)-&gt;as_Call()-&gt;tf()-&gt;range_cc());</span>
<span class="line-added">1048               }</span>
<span class="line-added">1049               m = n-&gt;in(0)-&gt;as_Multi()-&gt;match(n-&gt;as_Proj(), this, mask);</span>
1050 #ifdef ASSERT
1051               _new2old_map.map(m-&gt;_idx, n);
1052 #endif
1053               if (m-&gt;in(0) != NULL) // m might be top
1054                 collect_null_checks(m, n);
1055             } else {                // Else just a regular &#39;ol guy
1056               m = n-&gt;clone();       // So just clone into new-space
1057 #ifdef ASSERT
1058               _new2old_map.map(m-&gt;_idx, n);
1059 #endif
1060               // Def-Use edges will be added incrementally as Uses
1061               // of this node are matched.
1062               assert(m-&gt;outcnt() == 0, &quot;no Uses of this clone yet&quot;);
1063             }
1064           }
1065 
1066           set_new_node(n, m);       // Map old to new
1067           if (_old_node_note_array != NULL) {
1068             Node_Notes* nn = C-&gt;locate_node_notes(_old_node_note_array,
1069                                                   n-&gt;_idx);
</pre>
<hr />
<pre>
1174   }
1175   return OptoReg::as_OptoReg(reg);
1176 }
1177 
1178 
1179 //------------------------------match_sfpt-------------------------------------
1180 // Helper function to match call instructions.  Calls match special.
1181 // They match alone with no children.  Their children, the incoming
1182 // arguments, match normally.
1183 MachNode *Matcher::match_sfpt( SafePointNode *sfpt ) {
1184   MachSafePointNode *msfpt = NULL;
1185   MachCallNode      *mcall = NULL;
1186   uint               cnt;
1187   // Split out case for SafePoint vs Call
1188   CallNode *call;
1189   const TypeTuple *domain;
1190   ciMethod*        method = NULL;
1191   bool             is_method_handle_invoke = false;  // for special kill effects
1192   if( sfpt-&gt;is_Call() ) {
1193     call = sfpt-&gt;as_Call();
<span class="line-modified">1194     domain = call-&gt;tf()-&gt;domain_cc();</span>
1195     cnt = domain-&gt;cnt();
1196 
1197     // Match just the call, nothing else
1198     MachNode *m = match_tree(call);
1199     if (C-&gt;failing())  return NULL;
1200     if( m == NULL ) { Matcher::soft_match_failure(); return NULL; }
1201 
1202     // Copy data from the Ideal SafePoint to the machine version
1203     mcall = m-&gt;as_MachCall();
1204 
1205     mcall-&gt;set_tf(         call-&gt;tf());
1206     mcall-&gt;set_entry_point(call-&gt;entry_point());
1207     mcall-&gt;set_cnt(        call-&gt;cnt());
1208 
1209     if( mcall-&gt;is_MachCallJava() ) {
1210       MachCallJavaNode *mcall_java  = mcall-&gt;as_MachCallJava();
1211       const CallJavaNode *call_java =  call-&gt;as_CallJava();
1212       assert(call_java-&gt;validate_symbolic_info(), &quot;inconsistent info&quot;);
1213       method = call_java-&gt;method();
1214       mcall_java-&gt;_method = method;
</pre>
<hr />
<pre>
1249   msfpt-&gt;_in_rms = NEW_RESOURCE_ARRAY( RegMask, cnt );
1250   // Empty them all.
1251   for (uint i = 0; i &lt; cnt; i++) ::new (&amp;(msfpt-&gt;_in_rms[i])) RegMask();
1252 
1253   // Do all the pre-defined non-Empty register masks
1254   msfpt-&gt;_in_rms[TypeFunc::ReturnAdr] = _return_addr_mask;
1255   msfpt-&gt;_in_rms[TypeFunc::FramePtr ] = c_frame_ptr_mask;
1256 
1257   // Place first outgoing argument can possibly be put.
1258   OptoReg::Name begin_out_arg_area = OptoReg::add(_new_SP, C-&gt;out_preserve_stack_slots());
1259   assert( is_even(begin_out_arg_area), &quot;&quot; );
1260   // Compute max outgoing register number per call site.
1261   OptoReg::Name out_arg_limit_per_call = begin_out_arg_area;
1262   // Calls to C may hammer extra stack slots above and beyond any arguments.
1263   // These are usually backing store for register arguments for varargs.
1264   if( call != NULL &amp;&amp; call-&gt;is_CallRuntime() )
1265     out_arg_limit_per_call = OptoReg::add(out_arg_limit_per_call,C-&gt;varargs_C_out_slots_killed());
1266 
1267 
1268   // Do the normal argument list (parameters) register masks
<span class="line-modified">1269   // Null entry point is a special cast where the target of the call</span>
<span class="line-added">1270   // is in a register.</span>
<span class="line-added">1271   int adj = (call != NULL &amp;&amp; call-&gt;entry_point() == NULL) ? 1 : 0;</span>
<span class="line-added">1272   int argcnt = cnt - TypeFunc::Parms - adj;</span>
1273   if( argcnt &gt; 0 ) {          // Skip it all if we have no args
1274     BasicType *sig_bt  = NEW_RESOURCE_ARRAY( BasicType, argcnt );
1275     VMRegPair *parm_regs = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
1276     int i;
1277     for( i = 0; i &lt; argcnt; i++ ) {
<span class="line-modified">1278       sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms+adj)-&gt;basic_type();</span>
1279     }
1280     // V-call to pick proper calling convention
1281     call-&gt;calling_convention( sig_bt, parm_regs, argcnt );
1282 
1283 #ifdef ASSERT
1284     // Sanity check users&#39; calling convention.  Really handy during
1285     // the initial porting effort.  Fairly expensive otherwise.
1286     { for (int i = 0; i&lt;argcnt; i++) {
1287       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1288           !parm_regs[i].second()-&gt;is_valid() ) continue;
1289       VMReg reg1 = parm_regs[i].first();
1290       VMReg reg2 = parm_regs[i].second();
1291       for (int j = 0; j &lt; i; j++) {
1292         if( !parm_regs[j].first()-&gt;is_valid() &amp;&amp;
1293             !parm_regs[j].second()-&gt;is_valid() ) continue;
1294         VMReg reg3 = parm_regs[j].first();
1295         VMReg reg4 = parm_regs[j].second();
1296         if( !reg1-&gt;is_valid() ) {
1297           assert( !reg2-&gt;is_valid(), &quot;valid halvsies&quot; );
1298         } else if( !reg3-&gt;is_valid() ) {
1299           assert( !reg4-&gt;is_valid(), &quot;valid halvsies&quot; );
1300         } else {
1301           assert( reg1 != reg2, &quot;calling conv. must produce distinct regs&quot;);
1302           assert( reg1 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1303           assert( reg1 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1304           assert( reg2 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1305           assert( reg2 != reg4 || !reg2-&gt;is_valid(), &quot;calling conv. must produce distinct regs&quot;);
1306           assert( reg3 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1307         }
1308       }
1309     }
1310     }
1311 #endif
1312 
1313     // Visit each argument.  Compute its outgoing register mask.
1314     // Return results now can have 2 bits returned.
1315     // Compute max over all outgoing arguments both per call-site
1316     // and over the entire method.
1317     for( i = 0; i &lt; argcnt; i++ ) {
1318       // Address of incoming argument mask to fill in
<span class="line-modified">1319       RegMask *rm = &amp;mcall-&gt;_in_rms[i+TypeFunc::Parms+adj];</span>
1320       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1321           !parm_regs[i].second()-&gt;is_valid() ) {
1322         continue;               // Avoid Halves
1323       }
1324       // Grab first register, adjust stack slots and insert in mask.
1325       OptoReg::Name reg1 = warp_outgoing_stk_arg(parm_regs[i].first(), begin_out_arg_area, out_arg_limit_per_call );
<span class="line-modified">1326       if (OptoReg::is_valid(reg1)) {</span>
1327         rm-&gt;Insert( reg1 );
<span class="line-added">1328       }</span>
1329       // Grab second register (if any), adjust stack slots and insert in mask.
1330       OptoReg::Name reg2 = warp_outgoing_stk_arg(parm_regs[i].second(), begin_out_arg_area, out_arg_limit_per_call );
<span class="line-modified">1331       if (OptoReg::is_valid(reg2)) {</span>
1332         rm-&gt;Insert( reg2 );
<span class="line-added">1333       }</span>
1334     } // End of for all arguments
1335 
1336     // Compute number of stack slots needed to restore stack in case of
1337     // Pascal-style argument popping.
1338     mcall-&gt;_argsize = out_arg_limit_per_call - begin_out_arg_area;
1339   }
1340 
1341   // Compute the max stack slot killed by any call.  These will not be
1342   // available for debug info, and will be used to adjust FIRST_STACK_mask
1343   // after all call sites have been visited.
1344   if( _out_arg_limit &lt; out_arg_limit_per_call)
1345     _out_arg_limit = out_arg_limit_per_call;
1346 
1347   if (mcall) {
1348     // Kill the outgoing argument area, including any non-argument holes and
1349     // any legacy C-killed slots.  Use Fat-Projections to do the killing.
1350     // Since the max-per-method covers the max-per-call-site and debug info
1351     // is excluded on the max-per-method basis, debug info cannot land in
1352     // this killed area.
<span class="line-modified">1353     uint r_cnt = mcall-&gt;tf()-&gt;range_sig()-&gt;cnt();</span>
1354     MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::Empty, MachProjNode::fat_proj );
1355     if (!RegMask::can_represent_arg(OptoReg::Name(out_arg_limit_per_call-1))) {
1356       C-&gt;record_method_not_compilable(&quot;unsupported outgoing calling sequence&quot;);
1357     } else {
1358       for (int i = begin_out_arg_area; i &lt; out_arg_limit_per_call; i++)
1359         proj-&gt;_rout.Insert(OptoReg::Name(i));
1360     }
1361     if (proj-&gt;_rout.is_NotEmpty()) {
1362       push_projection(proj);
1363     }
1364   }
1365   // Transfer the safepoint information from the call to the mcall
1366   // Move the JVMState list
1367   msfpt-&gt;set_jvms(sfpt-&gt;jvms());
1368   for (JVMState* jvms = msfpt-&gt;jvms(); jvms; jvms = jvms-&gt;caller()) {
1369     jvms-&gt;set_map(sfpt);
1370   }
1371 
1372   // Debug inputs begin just after the last incoming parameter
1373   assert((mcall == NULL) || (mcall-&gt;jvms() == NULL) ||
<span class="line-modified">1374          (mcall-&gt;jvms()-&gt;debug_start() + mcall-&gt;_jvmadj == mcall-&gt;tf()-&gt;domain_cc()-&gt;cnt()), &quot;&quot;);</span>
1375 
1376   // Move the OopMap
1377   msfpt-&gt;_oop_map = sfpt-&gt;_oop_map;
1378 
1379   // Add additional edges.
1380   if (msfpt-&gt;mach_constant_base_node_input() != (uint)-1 &amp;&amp; !msfpt-&gt;is_MachCallLeaf()) {
1381     // For these calls we can not add MachConstantBase in expand(), as the
1382     // ins are not complete then.
1383     msfpt-&gt;ins_req(msfpt-&gt;mach_constant_base_node_input(), C-&gt;mach_constant_base_node());
1384     if (msfpt-&gt;jvms() &amp;&amp;
1385         msfpt-&gt;mach_constant_base_node_input() &lt;= msfpt-&gt;jvms()-&gt;debug_start() + msfpt-&gt;_jvmadj) {
1386       // We added an edge before jvms, so we must adapt the position of the ins.
1387       msfpt-&gt;jvms()-&gt;adapt_position(+1);
1388     }
1389   }
1390 
1391   // Registers killed by the call are set in the local scheduling pass
1392   // of Global Code Motion.
1393   return msfpt;
1394 }
</pre>
<hr />
<pre>
2318     case Op_FmaD:
2319     case Op_FmaF:
2320     case Op_FmaVD:
2321     case Op_FmaVF: {
2322       // Restructure into a binary tree for Matching.
2323       Node* pair = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2324       n-&gt;set_req(2, pair);
2325       n-&gt;set_req(1, n-&gt;in(3));
2326       n-&gt;del_req(3);
2327       break;
2328     }
2329     case Op_MulAddS2I: {
2330       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2331       Node* pair2 = new BinaryNode(n-&gt;in(3), n-&gt;in(4));
2332       n-&gt;set_req(1, pair1);
2333       n-&gt;set_req(2, pair2);
2334       n-&gt;del_req(4);
2335       n-&gt;del_req(3);
2336       break;
2337     }
<span class="line-added">2338     case Op_ClearArray: {</span>
<span class="line-added">2339       Node* pair = new BinaryNode(n-&gt;in(2), n-&gt;in(3));</span>
<span class="line-added">2340       n-&gt;set_req(2, pair);</span>
<span class="line-added">2341       n-&gt;set_req(3, n-&gt;in(4));</span>
<span class="line-added">2342       n-&gt;del_req(4);</span>
<span class="line-added">2343       break;</span>
<span class="line-added">2344     }</span>
2345     default:
2346       break;
2347   }
2348 }
2349 
2350 #ifdef ASSERT
2351 // machine-independent root to machine-dependent root
2352 void Matcher::dump_old2new_map() {
2353   _old2new_map.dump();
2354 }
2355 #endif
2356 
2357 //---------------------------collect_null_checks-------------------------------
2358 // Find null checks in the ideal graph; write a machine-specific node for
2359 // it.  Used by later implicit-null-check handling.  Actually collects
2360 // either an IfTrue or IfFalse for the common NOT-null path, AND the ideal
2361 // value being tested.
2362 void Matcher::collect_null_checks( Node *proj, Node *orig_proj ) {
2363   Node *iff = proj-&gt;in(0);
2364   if( iff-&gt;Opcode() == Op_If ) {
</pre>
</td>
</tr>
</table>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>