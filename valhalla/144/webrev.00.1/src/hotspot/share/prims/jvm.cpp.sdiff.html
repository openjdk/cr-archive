<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/stringTable.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;

  54 #include &quot;oops/instanceKlass.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/recordComponent.hpp&quot;
  57 #include &quot;oops/objArrayKlass.hpp&quot;
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;prims/jvm_misc.hpp&quot;
  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;prims/nativeLookup.hpp&quot;
  64 #include &quot;prims/stackwalk.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/init.hpp&quot;
  69 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  70 #include &quot;runtime/deoptimization.hpp&quot;
  71 #include &quot;runtime/handshake.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
 635   // be null.
 636   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 637   objArrayHandle frames_array_h(THREAD, fa);
 638 
 639   int limit = start_index+frame_count;
 640   if (frames_array_h-&gt;length() &lt; limit) {
 641     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 642   }
 643 
 644   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 645   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 646                                    start_index, frames_array_h, THREAD);
 647 JVM_END
 648 
 649 // java.lang.Object ///////////////////////////////////////////////
 650 
 651 
 652 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 653   JVMWrapper(&quot;JVM_IHashCode&quot;);
 654   // as implemented in the classic virtual machine; return 0 if object is NULL
<span class="line-modified"> 655   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;</span>





















 656 JVM_END
 657 
 658 
 659 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 660   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 661   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 662   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 663   if (JvmtiExport::should_post_monitor_wait()) {
 664     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 665 
 666     // The current thread already owns the monitor and it has not yet
 667     // been added to the wait queue so the current thread cannot be
 668     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 669     // event handler cannot accidentally consume an unpark() meant for
 670     // the ParkEvent associated with this ObjectMonitor.
 671   }
 672   ObjectSynchronizer::wait(obj, ms, CHECK);
 673 JVM_END
 674 
 675 
</pre>
<hr />
<pre>
 691   JVMWrapper(&quot;JVM_Clone&quot;);
 692   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 693   Klass* klass = obj-&gt;klass();
 694   JvmtiVMObjectAllocEventCollector oam;
 695 
 696 #ifdef ASSERT
 697   // Just checking that the cloneable flag is set correct
 698   if (obj-&gt;is_array()) {
 699     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 700   } else {
 701     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 702     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 703     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 704   }
 705 #endif
 706 
 707   // Check if class of obj supports the Cloneable interface.
 708   // All arrays are considered to be cloneable (See JLS 20.1.5).
 709   // All j.l.r.Reference classes are considered non-cloneable.
 710   if (!klass-&gt;is_cloneable() ||

 711       (klass-&gt;is_instance_klass() &amp;&amp;
 712        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 713     ResourceMark rm(THREAD);
 714     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 715   }
 716 
 717   // Make shallow object copy
 718   const int size = obj-&gt;size();
 719   oop new_obj_oop = NULL;
 720   if (obj-&gt;is_array()) {
 721     const int length = ((arrayOop)obj())-&gt;length();
 722     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 723                                                    /* do_zero */ true, CHECK_NULL);
 724   } else {
 725     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 726   }
 727 
 728   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 729 
 730   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1234   return (jstring) JNIHandles::make_local(env, result);
1235 JVM_END
1236 
1237 
1238 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1239   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1240   JvmtiVMObjectAllocEventCollector oam;
1241   oop mirror = JNIHandles::resolve_non_null(cls);
1242 
1243   // Special handling for primitive objects
1244   if (java_lang_Class::is_primitive(mirror)) {
1245     // Primitive objects does not have any interfaces
1246     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1247     return (jobjectArray) JNIHandles::make_local(env, r);
1248   }
1249 
1250   Klass* klass = java_lang_Class::as_Klass(mirror);
1251   // Figure size of result array
1252   int size;
1253   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1254     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();</span>




1255   } else {
1256     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1257     size = 2;</span>
1258   }
1259 
1260   // Allocate result array
1261   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1262   objArrayHandle result (THREAD, r);
1263   // Fill in result
1264   if (klass-&gt;is_instance_klass()) {
1265     // Regular instance klass, fill in all local interfaces

1266     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1267       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-modified">1268       result-&gt;obj_at_put(index, k-&gt;java_mirror());</span>



1269     }
1270   } else {
<span class="line-modified">1271     // All arrays implement java.lang.Cloneable and java.io.Serializable</span>
1272     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1273     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());

1274   }
1275   return (jobjectArray) JNIHandles::make_local(env, result());
1276 JVM_END
1277 
1278 
1279 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1280   JVMWrapper(&quot;JVM_IsInterface&quot;);
1281   oop mirror = JNIHandles::resolve_non_null(cls);
1282   if (java_lang_Class::is_primitive(mirror)) {
1283     return JNI_FALSE;
1284   }
1285   Klass* k = java_lang_Class::as_Klass(mirror);
1286   jboolean result = k-&gt;is_interface();
1287   assert(!result || k-&gt;is_instance_klass(),
1288          &quot;all interfaces are instance types&quot;);
1289   // The compiler intrinsic for isInterface tests the
1290   // Klass::_access_flags bits in the same way.
1291   return result;
1292 JVM_END
1293 
</pre>
<hr />
<pre>
1873         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1874       objArrayHandle components_h (THREAD, record_components);
1875 
1876       for (int x = 0; x &lt; length; x++) {
1877         RecordComponent* component = components-&gt;at(x);
1878         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1879         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1880         components_h-&gt;obj_at_put(x, component_oop);
1881       }
1882       return (jobjectArray)JNIHandles::make_local(components_h());
1883     }
1884   }
1885 
1886   // Return empty array if ofClass is not a record.
1887   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1888   return (jobjectArray)JNIHandles::make_local(env, result);
1889 }
1890 JVM_END
1891 
1892 static bool select_method(const methodHandle&amp; method, bool want_constructor) {


1893   if (want_constructor) {
<span class="line-modified">1894     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());</span>
1895   } else {
<span class="line-modified">1896     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());</span>


1897   }
1898 }
1899 
1900 static jobjectArray get_class_declared_methods_helper(
1901                                   JNIEnv *env,
1902                                   jclass ofClass, jboolean publicOnly,
1903                                   bool want_constructor,
1904                                   Klass* klass, TRAPS) {
1905 
1906   JvmtiVMObjectAllocEventCollector oam;
1907 
1908   // Exclude primitive types and array types
1909   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1910       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1911     // Return empty array
1912     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1913     return (jobjectArray) JNIHandles::make_local(env, res);
1914   }
1915 
1916   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1938     }
1939   }
1940 
1941   // Allocate result
1942   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1943   objArrayHandle result (THREAD, r);
1944 
1945   // Now just put the methods that we selected above, but go by their idnum
1946   // in case of redefinition.  The methods can be redefined at any safepoint,
1947   // so above when allocating the oop array and below when creating reflect
1948   // objects.
1949   for (int i = 0; i &lt; num_methods; i++) {
1950     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1951     if (method.is_null()) {
1952       // Method may have been deleted and seems this API can handle null
1953       // Otherwise should probably put a method that throws NSME
1954       result-&gt;obj_at_put(i, NULL);
1955     } else {
1956       oop m;
1957       if (want_constructor) {


1958         m = Reflection::new_constructor(method, CHECK_NULL);
1959       } else {
1960         m = Reflection::new_method(method, false, CHECK_NULL);
1961       }
1962       result-&gt;obj_at_put(i, m);
1963     }
1964   }
1965 
1966   return (jobjectArray) JNIHandles::make_local(env, result());
1967 }
1968 
1969 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1970 {
1971   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1972   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1973                                            /*want_constructor*/ false,
1974                                            SystemDictionary::reflect_Method_klass(), THREAD);
1975 }
1976 JVM_END
1977 
</pre>
<hr />
<pre>
2195   constantTag tag = cp-&gt;tag_at(index);
2196   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2197     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2198   }
2199   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2200   Klass* k_o;
2201   if (force_resolution) {
2202     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2203   } else {
2204     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2205     if (k_o == NULL) return NULL;
2206   }
2207   InstanceKlass* k = InstanceKlass::cast(k_o);
2208   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2209   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2210   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2211   if (m.is_null()) {
2212     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2213   }
2214   oop method;
<span class="line-modified">2215   if (!m-&gt;is_initializer() || m-&gt;is_static()) {</span>
<span class="line-removed">2216     method = Reflection::new_method(m, true, CHECK_NULL);</span>
<span class="line-removed">2217   } else {</span>
2218     method = Reflection::new_constructor(m, CHECK_NULL);


2219   }
2220   return JNIHandles::make_local(method);
2221 }
2222 
2223 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2224 {
2225   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2226   JvmtiVMObjectAllocEventCollector oam;
2227   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2228   bounds_check(cp, index, CHECK_NULL);
2229   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2230   return res;
2231 }
2232 JVM_END
2233 
2234 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2235 {
2236   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2237   JvmtiVMObjectAllocEventCollector oam;
2238   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2486   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2487   if (!k-&gt;is_instance_klass()) return false;
2488 
2489   ResourceMark rm(THREAD);
2490   const char* name = k-&gt;name()-&gt;as_C_string();
2491   bool system_class = k-&gt;class_loader() == NULL;
2492   return JavaAssertions::enabled(name, system_class);
2493 
2494 JVM_END
2495 
2496 
2497 // Return a new AssertionStatusDirectives object with the fields filled in with
2498 // command-line assertion arguments (i.e., -ea, -da).
2499 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2500   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2501   JvmtiVMObjectAllocEventCollector oam;
2502   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2503   return JNIHandles::make_local(env, asd);
2504 JVM_END
2505 







































2506 // Verification ////////////////////////////////////////////////////////////////////////////////
2507 
2508 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2509 
2510 // RedefineClasses support: bug 6214132 caused verification to fail.
2511 // All functions from this section should call the jvmtiThreadSate function:
2512 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2513 // The function returns a Klass* of the _scratch_class if the verifier
2514 // was invoked in the middle of the class redefinition.
2515 // Otherwise it returns its argument value which is the _the_class Klass*.
2516 // Please, refer to the description in the jvmtiThreadSate.hpp.
2517 
2518 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2519   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2520   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2521   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2522   return k-&gt;name()-&gt;as_utf8();
2523 JVM_END
2524 
2525 
</pre>
<hr />
<pre>
2665   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2666   return method-&gt;size_of_parameters();
2667 JVM_END
2668 
2669 
2670 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2671   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2672   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2673   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2674   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2675   return method-&gt;verifier_max_stack();
2676 JVM_END
2677 
2678 
2679 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2680   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2681   ResourceMark rm(THREAD);
2682   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2683   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2684   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2685   return method-&gt;name() == vmSymbols::object_initializer_name();</span>
2686 JVM_END
2687 
2688 
2689 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2690   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2691   ResourceMark rm(THREAD);
2692   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2693   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2694   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2695   return method-&gt;is_overpass();
2696 JVM_END
2697 
2698 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2699   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2700   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2701   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2702   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2703   return method-&gt;name()-&gt;as_utf8();
2704 JVM_END
2705 
</pre>
<hr />
<pre>
3660   //   protection_domain. The protection_domain is passed as NULL by the java code
3661   //   if there is no security manager in 3-arg Class.forName().
3662   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3663 
3664   // Check if we should initialize the class
3665   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3666     klass-&gt;initialize(CHECK_NULL);
3667   }
3668   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3669 }
3670 
3671 
3672 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3673 
3674 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3675   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3676   Handle method_handle;
3677   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3678     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3679     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3680     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3681     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3682     jobject res = JNIHandles::make_local(env, result);
3683     if (JvmtiExport::should_post_vm_object_alloc()) {
3684       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3685       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3686       if (java_lang_Class::is_primitive(ret_type)) {
3687         // Only for primitive type vm allocates memory for java object.
3688         // See box() method.
3689         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3690       }
3691     }
3692     return res;
3693   } else {
3694     THROW_0(vmSymbols::java_lang_StackOverflowError());
3695   }
3696 JVM_END
3697 
3698 
3699 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3700   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);

3701   oop constructor_mirror = JNIHandles::resolve(c);
<span class="line-removed">3702   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3703   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3704   jobject res = JNIHandles::make_local(env, result);
3705   if (JvmtiExport::should_post_vm_object_alloc()) {
3706     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3707   }
3708   return res;
3709 JVM_END
3710 
3711 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3712 
3713 JVM_LEAF(jboolean, JVM_SupportsCX8())
3714   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3715   return VM_Version::supports_cx8();
3716 JVM_END
3717 
3718 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3719   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3720   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3721   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3722   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
<td>
<hr />
<pre>
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/stringTable.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;
<span class="line-added">  54 #include &quot;oops/flatArrayKlass.hpp&quot;</span>
  55 #include &quot;oops/instanceKlass.hpp&quot;
  56 #include &quot;oops/method.hpp&quot;
  57 #include &quot;oops/recordComponent.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.inline.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;prims/jvm_misc.hpp&quot;
  62 #include &quot;prims/jvmtiExport.hpp&quot;
  63 #include &quot;prims/jvmtiThreadState.hpp&quot;
  64 #include &quot;prims/nativeLookup.hpp&quot;
  65 #include &quot;prims/stackwalk.hpp&quot;
  66 #include &quot;runtime/arguments.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/init.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/deoptimization.hpp&quot;
  72 #include &quot;runtime/handshake.hpp&quot;
  73 #include &quot;runtime/java.hpp&quot;
  74 #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
 636   // be null.
 637   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 638   objArrayHandle frames_array_h(THREAD, fa);
 639 
 640   int limit = start_index+frame_count;
 641   if (frames_array_h-&gt;length() &lt; limit) {
 642     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 643   }
 644 
 645   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 646   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 647                                    start_index, frames_array_h, THREAD);
 648 JVM_END
 649 
 650 // java.lang.Object ///////////////////////////////////////////////
 651 
 652 
 653 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 654   JVMWrapper(&quot;JVM_IHashCode&quot;);
 655   // as implemented in the classic virtual machine; return 0 if object is NULL
<span class="line-modified"> 656   if (handle == NULL) {</span>
<span class="line-added"> 657     return 0;</span>
<span class="line-added"> 658   }</span>
<span class="line-added"> 659   oop obj = JNIHandles::resolve_non_null(handle);</span>
<span class="line-added"> 660   if (EnableValhalla &amp;&amp; obj-&gt;klass()-&gt;is_inline_klass()) {</span>
<span class="line-added"> 661       JavaValue result(T_INT);</span>
<span class="line-added"> 662       JavaCallArguments args;</span>
<span class="line-added"> 663       Handle ho(THREAD, obj);</span>
<span class="line-added"> 664       args.push_oop(ho);</span>
<span class="line-added"> 665       methodHandle method(THREAD, Universe::inline_type_hash_code_method());</span>
<span class="line-added"> 666       JavaCalls::call(&amp;result, method, &amp;args, THREAD);</span>
<span class="line-added"> 667       if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added"> 668         if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::Error_klass())) {</span>
<span class="line-added"> 669           Handle e(THREAD, PENDING_EXCEPTION);</span>
<span class="line-added"> 670           CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added"> 671           THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), &quot;Internal error in hashCode&quot;, e, false);</span>
<span class="line-added"> 672         }</span>
<span class="line-added"> 673       }</span>
<span class="line-added"> 674       return result.get_jint();</span>
<span class="line-added"> 675   } else {</span>
<span class="line-added"> 676     return ObjectSynchronizer::FastHashCode(THREAD, obj);</span>
<span class="line-added"> 677   }</span>
 678 JVM_END
 679 
 680 
 681 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 682   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 683   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 684   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 685   if (JvmtiExport::should_post_monitor_wait()) {
 686     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 687 
 688     // The current thread already owns the monitor and it has not yet
 689     // been added to the wait queue so the current thread cannot be
 690     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 691     // event handler cannot accidentally consume an unpark() meant for
 692     // the ParkEvent associated with this ObjectMonitor.
 693   }
 694   ObjectSynchronizer::wait(obj, ms, CHECK);
 695 JVM_END
 696 
 697 
</pre>
<hr />
<pre>
 713   JVMWrapper(&quot;JVM_Clone&quot;);
 714   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 715   Klass* klass = obj-&gt;klass();
 716   JvmtiVMObjectAllocEventCollector oam;
 717 
 718 #ifdef ASSERT
 719   // Just checking that the cloneable flag is set correct
 720   if (obj-&gt;is_array()) {
 721     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 722   } else {
 723     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 724     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 725     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 726   }
 727 #endif
 728 
 729   // Check if class of obj supports the Cloneable interface.
 730   // All arrays are considered to be cloneable (See JLS 20.1.5).
 731   // All j.l.r.Reference classes are considered non-cloneable.
 732   if (!klass-&gt;is_cloneable() ||
<span class="line-added"> 733        klass-&gt;is_inline_klass() ||</span>
 734       (klass-&gt;is_instance_klass() &amp;&amp;
 735        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 736     ResourceMark rm(THREAD);
 737     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 738   }
 739 
 740   // Make shallow object copy
 741   const int size = obj-&gt;size();
 742   oop new_obj_oop = NULL;
 743   if (obj-&gt;is_array()) {
 744     const int length = ((arrayOop)obj())-&gt;length();
 745     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 746                                                    /* do_zero */ true, CHECK_NULL);
 747   } else {
 748     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 749   }
 750 
 751   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 752 
 753   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1257   return (jstring) JNIHandles::make_local(env, result);
1258 JVM_END
1259 
1260 
1261 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1262   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1263   JvmtiVMObjectAllocEventCollector oam;
1264   oop mirror = JNIHandles::resolve_non_null(cls);
1265 
1266   // Special handling for primitive objects
1267   if (java_lang_Class::is_primitive(mirror)) {
1268     // Primitive objects does not have any interfaces
1269     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1270     return (jobjectArray) JNIHandles::make_local(env, r);
1271   }
1272 
1273   Klass* klass = java_lang_Class::as_Klass(mirror);
1274   // Figure size of result array
1275   int size;
1276   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1277     InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-added">1278     size = ik-&gt;local_interfaces()-&gt;length();</span>
<span class="line-added">1279     if (ik-&gt;has_injected_identityObject()) {</span>
<span class="line-added">1280       size--;</span>
<span class="line-added">1281     }</span>
1282   } else {
1283     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1284     size = 3;</span>
1285   }
1286 
1287   // Allocate result array
1288   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1289   objArrayHandle result (THREAD, r);
1290   // Fill in result
1291   if (klass-&gt;is_instance_klass()) {
1292     // Regular instance klass, fill in all local interfaces
<span class="line-added">1293     int cursor = 0;</span>
1294     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1295       InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-modified">1296       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-added">1297       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">1298         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());</span>
<span class="line-added">1299       }</span>
1300     }
1301   } else {
<span class="line-modified">1302     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject</span>
1303     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1304     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
<span class="line-added">1305     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());</span>
1306   }
1307   return (jobjectArray) JNIHandles::make_local(env, result());
1308 JVM_END
1309 
1310 
1311 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1312   JVMWrapper(&quot;JVM_IsInterface&quot;);
1313   oop mirror = JNIHandles::resolve_non_null(cls);
1314   if (java_lang_Class::is_primitive(mirror)) {
1315     return JNI_FALSE;
1316   }
1317   Klass* k = java_lang_Class::as_Klass(mirror);
1318   jboolean result = k-&gt;is_interface();
1319   assert(!result || k-&gt;is_instance_klass(),
1320          &quot;all interfaces are instance types&quot;);
1321   // The compiler intrinsic for isInterface tests the
1322   // Klass::_access_flags bits in the same way.
1323   return result;
1324 JVM_END
1325 
</pre>
<hr />
<pre>
1905         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1906       objArrayHandle components_h (THREAD, record_components);
1907 
1908       for (int x = 0; x &lt; length; x++) {
1909         RecordComponent* component = components-&gt;at(x);
1910         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1911         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1912         components_h-&gt;obj_at_put(x, component_oop);
1913       }
1914       return (jobjectArray)JNIHandles::make_local(components_h());
1915     }
1916   }
1917 
1918   // Return empty array if ofClass is not a record.
1919   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1920   return (jobjectArray)JNIHandles::make_local(env, result);
1921 }
1922 JVM_END
1923 
1924 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
<span class="line-added">1925   bool is_ctor = (method-&gt;is_object_constructor() ||</span>
<span class="line-added">1926                   method-&gt;is_static_init_factory());</span>
1927   if (want_constructor) {
<span class="line-modified">1928     return is_ctor;</span>
1929   } else {
<span class="line-modified">1930     return (!is_ctor &amp;&amp;</span>
<span class="line-added">1931             !method-&gt;is_class_initializer() &amp;&amp;</span>
<span class="line-added">1932             !method-&gt;is_overpass());</span>
1933   }
1934 }
1935 
1936 static jobjectArray get_class_declared_methods_helper(
1937                                   JNIEnv *env,
1938                                   jclass ofClass, jboolean publicOnly,
1939                                   bool want_constructor,
1940                                   Klass* klass, TRAPS) {
1941 
1942   JvmtiVMObjectAllocEventCollector oam;
1943 
1944   // Exclude primitive types and array types
1945   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1946       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1947     // Return empty array
1948     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1949     return (jobjectArray) JNIHandles::make_local(env, res);
1950   }
1951 
1952   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1974     }
1975   }
1976 
1977   // Allocate result
1978   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1979   objArrayHandle result (THREAD, r);
1980 
1981   // Now just put the methods that we selected above, but go by their idnum
1982   // in case of redefinition.  The methods can be redefined at any safepoint,
1983   // so above when allocating the oop array and below when creating reflect
1984   // objects.
1985   for (int i = 0; i &lt; num_methods; i++) {
1986     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1987     if (method.is_null()) {
1988       // Method may have been deleted and seems this API can handle null
1989       // Otherwise should probably put a method that throws NSME
1990       result-&gt;obj_at_put(i, NULL);
1991     } else {
1992       oop m;
1993       if (want_constructor) {
<span class="line-added">1994         assert(method-&gt;is_object_constructor() ||</span>
<span class="line-added">1995                method-&gt;is_static_init_factory(), &quot;must be&quot;);</span>
1996         m = Reflection::new_constructor(method, CHECK_NULL);
1997       } else {
1998         m = Reflection::new_method(method, false, CHECK_NULL);
1999       }
2000       result-&gt;obj_at_put(i, m);
2001     }
2002   }
2003 
2004   return (jobjectArray) JNIHandles::make_local(env, result());
2005 }
2006 
2007 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2008 {
2009   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
2010   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2011                                            /*want_constructor*/ false,
2012                                            SystemDictionary::reflect_Method_klass(), THREAD);
2013 }
2014 JVM_END
2015 
</pre>
<hr />
<pre>
2233   constantTag tag = cp-&gt;tag_at(index);
2234   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2235     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2236   }
2237   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2238   Klass* k_o;
2239   if (force_resolution) {
2240     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2241   } else {
2242     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2243     if (k_o == NULL) return NULL;
2244   }
2245   InstanceKlass* k = InstanceKlass::cast(k_o);
2246   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2247   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2248   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2249   if (m.is_null()) {
2250     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2251   }
2252   oop method;
<span class="line-modified">2253   if (m-&gt;is_object_constructor() || m-&gt;is_static_init_factory()) {</span>


2254     method = Reflection::new_constructor(m, CHECK_NULL);
<span class="line-added">2255   } else {</span>
<span class="line-added">2256     method = Reflection::new_method(m, true, CHECK_NULL);</span>
2257   }
2258   return JNIHandles::make_local(method);
2259 }
2260 
2261 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2262 {
2263   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2264   JvmtiVMObjectAllocEventCollector oam;
2265   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2266   bounds_check(cp, index, CHECK_NULL);
2267   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2268   return res;
2269 }
2270 JVM_END
2271 
2272 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2273 {
2274   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2275   JvmtiVMObjectAllocEventCollector oam;
2276   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2524   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2525   if (!k-&gt;is_instance_klass()) return false;
2526 
2527   ResourceMark rm(THREAD);
2528   const char* name = k-&gt;name()-&gt;as_C_string();
2529   bool system_class = k-&gt;class_loader() == NULL;
2530   return JavaAssertions::enabled(name, system_class);
2531 
2532 JVM_END
2533 
2534 
2535 // Return a new AssertionStatusDirectives object with the fields filled in with
2536 // command-line assertion arguments (i.e., -ea, -da).
2537 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2538   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2539   JvmtiVMObjectAllocEventCollector oam;
2540   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2541   return JNIHandles::make_local(env, asd);
2542 JVM_END
2543 
<span class="line-added">2544 // Arrays support /////////////////////////////////////////////////////////////</span>
<span class="line-added">2545 </span>
<span class="line-added">2546 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2547   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);</span>
<span class="line-added">2548   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2549   Klass* k = o-&gt;klass();</span>
<span class="line-added">2550   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2551     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2552   }</span>
<span class="line-added">2553   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();</span>
<span class="line-added">2554 JVM_END</span>
<span class="line-added">2555 </span>
<span class="line-added">2556 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2557   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);</span>
<span class="line-added">2558   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2559   Klass* k = o-&gt;klass();</span>
<span class="line-added">2560   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2561     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2562   }</span>
<span class="line-added">2563   if (k-&gt;is_flatArray_klass()) {</span>
<span class="line-added">2564     FlatArrayKlass* vk = FlatArrayKlass::cast(k);</span>
<span class="line-added">2565     if (!vk-&gt;element_access_is_atomic()) {</span>
<span class="line-added">2566       /**</span>
<span class="line-added">2567        * Need to decide how to implement:</span>
<span class="line-added">2568        *</span>
<span class="line-added">2569        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so</span>
<span class="line-added">2570        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through</span>
<span class="line-added">2571        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;</span>
<span class="line-added">2572        *</span>
<span class="line-added">2573        * 2) Use extra header in the flatArrayOop to flag atomicity required and</span>
<span class="line-added">2574        * possibly per instance lock structure. Said info, could be placed in</span>
<span class="line-added">2575        * &quot;trailer&quot; rather than disturb the current arrayOop</span>
<span class="line-added">2576        */</span>
<span class="line-added">2577       Unimplemented();</span>
<span class="line-added">2578     }</span>
<span class="line-added">2579   }</span>
<span class="line-added">2580   return array;</span>
<span class="line-added">2581 JVM_END</span>
<span class="line-added">2582 </span>
2583 // Verification ////////////////////////////////////////////////////////////////////////////////
2584 
2585 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2586 
2587 // RedefineClasses support: bug 6214132 caused verification to fail.
2588 // All functions from this section should call the jvmtiThreadSate function:
2589 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2590 // The function returns a Klass* of the _scratch_class if the verifier
2591 // was invoked in the middle of the class redefinition.
2592 // Otherwise it returns its argument value which is the _the_class Klass*.
2593 // Please, refer to the description in the jvmtiThreadSate.hpp.
2594 
2595 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2596   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2597   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2598   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2599   return k-&gt;name()-&gt;as_utf8();
2600 JVM_END
2601 
2602 
</pre>
<hr />
<pre>
2742   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2743   return method-&gt;size_of_parameters();
2744 JVM_END
2745 
2746 
2747 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2748   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2749   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2750   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2751   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2752   return method-&gt;verifier_max_stack();
2753 JVM_END
2754 
2755 
2756 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2757   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2758   ResourceMark rm(THREAD);
2759   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2760   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2761   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2762   return method-&gt;is_object_constructor();</span>
2763 JVM_END
2764 
2765 
2766 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2767   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2768   ResourceMark rm(THREAD);
2769   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2770   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2771   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2772   return method-&gt;is_overpass();
2773 JVM_END
2774 
2775 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2776   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2777   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2778   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2779   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2780   return method-&gt;name()-&gt;as_utf8();
2781 JVM_END
2782 
</pre>
<hr />
<pre>
3737   //   protection_domain. The protection_domain is passed as NULL by the java code
3738   //   if there is no security manager in 3-arg Class.forName().
3739   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3740 
3741   // Check if we should initialize the class
3742   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3743     klass-&gt;initialize(CHECK_NULL);
3744   }
3745   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3746 }
3747 
3748 
3749 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3750 
3751 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3752   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3753   Handle method_handle;
3754   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3755     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3756     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3757     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3758     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3759     jobject res = JNIHandles::make_local(env, result);
3760     if (JvmtiExport::should_post_vm_object_alloc()) {
3761       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3762       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3763       if (java_lang_Class::is_primitive(ret_type)) {
3764         // Only for primitive type vm allocates memory for java object.
3765         // See box() method.
3766         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3767       }
3768     }
3769     return res;
3770   } else {
3771     THROW_0(vmSymbols::java_lang_StackOverflowError());
3772   }
3773 JVM_END
3774 
3775 
3776 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3777   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
<span class="line-added">3778   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3779   oop constructor_mirror = JNIHandles::resolve(c);

3780   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3781   jobject res = JNIHandles::make_local(env, result);
3782   if (JvmtiExport::should_post_vm_object_alloc()) {
3783     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3784   }
3785   return res;
3786 JVM_END
3787 
3788 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3789 
3790 JVM_LEAF(jboolean, JVM_SupportsCX8())
3791   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3792   return VM_Version::supports_cx8();
3793 JVM_END
3794 
3795 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3796   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3797   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3798   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3799   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
</tr>
</table>
<center><a href="../opto/type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>