<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/javaClasses.inline.hpp&quot;
  31 #include &quot;classfile/modules.hpp&quot;
  32 #include &quot;classfile/protectionDomainCache.hpp&quot;
  33 #include &quot;classfile/stringTable.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;code/codeCache.hpp&quot;
  36 #include &quot;compiler/compilationPolicy.hpp&quot;
  37 #include &quot;compiler/methodMatcher.hpp&quot;
  38 #include &quot;compiler/directivesParser.hpp&quot;
  39 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  40 #include &quot;gc/shared/gcConfig.hpp&quot;
  41 #include &quot;gc/shared/genArguments.hpp&quot;
  42 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  43 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/filemap.hpp&quot;
  46 #include &quot;memory/heapShared.inline.hpp&quot;
  47 #include &quot;memory/metaspaceShared.hpp&quot;
  48 #include &quot;memory/metadataFactory.hpp&quot;
  49 #include &quot;memory/iterator.inline.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;memory/universe.hpp&quot;
  52 #include &quot;memory/oopFactory.hpp&quot;
  53 #include &quot;oops/array.hpp&quot;
  54 #include &quot;oops/compressedOops.hpp&quot;
  55 #include &quot;oops/compressedOops.inline.hpp&quot;
  56 #include &quot;oops/constantPool.inline.hpp&quot;
  57 #include &quot;oops/method.inline.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.inline.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/objArrayOop.inline.hpp&quot;
  62 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  63 #include &quot;prims/resolvedMethodTable.hpp&quot;
  64 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  65 #include &quot;prims/whitebox.inline.hpp&quot;
  66 #include &quot;runtime/arguments.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/deoptimization.hpp&quot;
  69 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  70 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  71 #include &quot;runtime/frame.inline.hpp&quot;
  72 #include &quot;runtime/handles.inline.hpp&quot;
  73 #include &quot;runtime/handshake.hpp&quot;
  74 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/jniHandles.inline.hpp&quot;
  77 #include &quot;runtime/os.hpp&quot;
  78 #include &quot;runtime/sweeper.hpp&quot;
  79 #include &quot;runtime/synchronizer.hpp&quot;
  80 #include &quot;runtime/thread.hpp&quot;
  81 #include &quot;runtime/threadSMR.hpp&quot;
  82 #include &quot;runtime/vm_version.hpp&quot;
  83 #include &quot;services/memoryService.hpp&quot;
  84 #include &quot;utilities/align.hpp&quot;
  85 #include &quot;utilities/debug.hpp&quot;
  86 #include &quot;utilities/elfFile.hpp&quot;
  87 #include &quot;utilities/exceptions.hpp&quot;
  88 #include &quot;utilities/macros.hpp&quot;
  89 #if INCLUDE_CDS
  90 #include &quot;prims/cdsoffsets.hpp&quot;
  91 #endif // INCLUDE_CDS
  92 #if INCLUDE_G1GC
  93 #include &quot;gc/g1/g1Arguments.hpp&quot;
  94 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  95 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  96 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  97 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  98 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  99 #endif // INCLUDE_G1GC
 100 #if INCLUDE_PARALLELGC
 101 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
 102 #endif // INCLUDE_PARALLELGC
 103 #if INCLUDE_NMT
 104 #include &quot;services/mallocSiteTable.hpp&quot;
 105 #include &quot;services/memTracker.hpp&quot;
 106 #include &quot;utilities/nativeCallStack.hpp&quot;
 107 #endif // INCLUDE_NMT
 108 #if INCLUDE_AOT
 109 #include &quot;aot/aotLoader.hpp&quot;
 110 #endif // INCLUDE_AOT
 111 
 112 #ifdef LINUX
 113 #include &quot;osContainer_linux.hpp&quot;
 114 #include &quot;cgroupSubsystem_linux.hpp&quot;
 115 #endif
 116 
 117 #define SIZE_T_MAX_VALUE ((size_t) -1)
 118 
 119 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 120   do {                                                                 \
 121     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 122     THREAD-&gt;clear_pending_jni_exception_check();                       \
 123     if (HAS_PENDING_EXCEPTION) {                                       \
 124       return(value);                                                   \
 125     }                                                                  \
 126   } while (0)
 127 
 128 #define CHECK_JNI_EXCEPTION(env)                                       \
 129   do {                                                                 \
 130     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 131     THREAD-&gt;clear_pending_jni_exception_check();                       \
 132     if (HAS_PENDING_EXCEPTION) {                                       \
 133       return;                                                          \
 134     }                                                                  \
 135   } while (0)
 136 
 137 bool WhiteBox::_used = false;
 138 volatile bool WhiteBox::compilation_locked = false;
 139 
 140 class VM_WhiteBoxOperation : public VM_Operation {
 141  public:
 142   VM_WhiteBoxOperation()                         { }
 143   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 144   bool allow_nested_vm_operations() const        { return true; }
 145 };
 146 
 147 
 148 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 149   return (jlong)(void*)JNIHandles::resolve(obj);
 150 WB_END
 151 
 152 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 153   return heapOopSize;
 154 WB_END
 155 
 156 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 157   return os::vm_page_size();
 158 WB_END
 159 
 160 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 161   return os::vm_allocation_granularity();
 162 WB_END
 163 
 164 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 165   return os::large_page_size();
 166 WB_END
 167 
 168 class WBIsKlassAliveClosure : public LockedClassesDo {
 169     Symbol* _name;
 170     int _count;
 171 public:
 172     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}
 173 
 174     void do_klass(Klass* k) {
 175       Symbol* ksym = k-&gt;name();
 176       if (ksym-&gt;fast_compare(_name) == 0) {
 177         _count++;
 178       }
 179     }
 180 
 181     int count() const {
 182         return _count;
 183     }
 184 };
 185 
 186 WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))
 187   oop h_name = JNIHandles::resolve(name);
 188   if (h_name == NULL) return false;
 189   Symbol* sym = java_lang_String::as_symbol(h_name);
 190   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 191 
 192   WBIsKlassAliveClosure closure(sym);
 193   ClassLoaderDataGraph::classes_do(&amp;closure);
 194 
 195   // Return the count of alive classes with this name.
 196   return closure.count();
 197 WB_END
 198 
 199 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 200   oop h_name = JNIHandles::resolve(name);
 201   if (h_name == NULL) return false;
 202   Symbol* sym = java_lang_String::as_symbol(h_name);
 203   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 204   return (jint)sym-&gt;refcount();
 205 WB_END
 206 
 207 
 208 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 209 #if INCLUDE_JVMTI
 210   ResourceMark rm;
 211   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 212   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 213   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 214   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 215 #endif
 216 }
 217 WB_END
 218 
 219 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 220 #if INCLUDE_JVMTI
 221   ResourceMark rm;
 222   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 223   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 224   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 225   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 226 #endif
 227 }
 228 WB_END
 229 
 230 
 231 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 232   return (jlong)Arguments::max_heap_for_compressed_oops();
 233 }
 234 WB_END
 235 
 236 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
 237   tty-&gt;print_cr(&quot;Minimum heap &quot; SIZE_FORMAT &quot; Initial heap &quot; SIZE_FORMAT &quot; &quot;
 238                 &quot;Maximum heap &quot; SIZE_FORMAT &quot; Space alignment &quot; SIZE_FORMAT &quot; Heap alignment &quot; SIZE_FORMAT,
 239                 MinHeapSize,
 240                 InitialHeapSize,
 241                 MaxHeapSize,
 242                 SpaceAlignment,
 243                 HeapAlignment);
 244 }
 245 WB_END
 246 
 247 #ifndef PRODUCT
 248 // Forward declaration
 249 void TestReservedSpace_test();
 250 void TestReserveMemorySpecial_test();
 251 void TestVirtualSpace_test();
 252 #endif
 253 
 254 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 255 #ifndef PRODUCT
 256   TestReservedSpace_test();
 257   TestReserveMemorySpecial_test();
 258   TestVirtualSpace_test();
 259 #endif
 260 WB_END
 261 
 262 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 263   size_t granularity = os::vm_allocation_granularity();
 264   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 265   VirtualSpace vs;
 266   vs.initialize(rhs, 50 * granularity);
 267 
 268   // Check if constraints are complied
 269   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
 270          CompressedOops::base() != NULL &amp;&amp;
 271          CompressedOops::use_implicit_null_checks() )) {
 272     tty-&gt;print_cr(&quot;WB_ReadFromNoaccessArea method is useless:\n &quot;
 273                   &quot;\tUseCompressedOops is %d\n&quot;
 274                   &quot;\trhs.base() is &quot; PTR_FORMAT &quot;\n&quot;
 275                   &quot;\tCompressedOops::base() is &quot; PTR_FORMAT &quot;\n&quot;
 276                   &quot;\tCompressedOops::use_implicit_null_checks() is %d&quot;,
 277                   UseCompressedOops,
 278                   p2i(rhs.base()),
 279                   p2i(CompressedOops::base()),
 280                   CompressedOops::use_implicit_null_checks());
 281     return;
 282   }
 283   tty-&gt;print_cr(&quot;Reading from no access area... &quot;);
 284   tty-&gt;print_cr(&quot;*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c&quot;,
 285                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 286 WB_END
 287 
 288 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 289                                            size_t magnitude, size_t iterations) {
 290   size_t granularity = os::vm_allocation_granularity();
 291   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 292   VirtualSpace vs;
 293   if (!vs.initialize(rhs, 0)) {
 294     tty-&gt;print_cr(&quot;Failed to initialize VirtualSpace. Can&#39;t proceed.&quot;);
 295     return 3;
 296   }
 297 
 298   int seed = os::random();
 299   tty-&gt;print_cr(&quot;Random seed is %d&quot;, seed);
 300   os::init_random(seed);
 301 
 302   for (size_t i = 0; i &lt; iterations; i++) {
 303 
 304     // Whether we will shrink or grow
 305     bool shrink = os::random() % 2L == 0;
 306 
 307     // Get random delta to resize virtual space
 308     size_t delta = (size_t)os::random() % magnitude;
 309 
 310     // If we are about to shrink virtual space below zero, then expand instead
 311     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 312       shrink = false;
 313     }
 314 
 315     // Resizing by delta
 316     if (shrink) {
 317       vs.shrink_by(delta);
 318     } else {
 319       // If expanding fails expand_by will silently return false
 320       vs.expand_by(delta, true);
 321     }
 322   }
 323   return 0;
 324 }
 325 
 326 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 327         jlong reserved_space_size, jlong magnitude, jlong iterations))
 328   tty-&gt;print_cr(&quot;reservedSpaceSize=&quot; JLONG_FORMAT &quot;, magnitude=&quot; JLONG_FORMAT &quot;, &quot;
 329                 &quot;iterations=&quot; JLONG_FORMAT &quot;\n&quot;, reserved_space_size, magnitude,
 330                 iterations);
 331   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 332     tty-&gt;print_cr(&quot;One of variables printed above is negative. Can&#39;t proceed.\n&quot;);
 333     return 1;
 334   }
 335 
 336   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 337   // always 8 byte. That&#39;s why we should avoid overflow in case of 32bit platform.
 338   if (sizeof(size_t) &lt; sizeof(jlong)) {
 339     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 340     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 341         || iterations &gt; size_t_max_value) {
 342       tty-&gt;print_cr(&quot;One of variables printed above overflows size_t. Can&#39;t proceed.\n&quot;);
 343       return 2;
 344     }
 345   }
 346 
 347   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 348                                         (size_t) magnitude, (size_t) iterations);
 349 WB_END
 350 
 351 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 352   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 353 WB_END
 354 
 355 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 356   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 357 WB_END
 358 
 359 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 360   return GCConfig::is_gc_selected_ergonomically();
 361 WB_END
 362 
 363 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 364   oop p = JNIHandles::resolve(obj);
 365 #if INCLUDE_G1GC
 366   if (UseG1GC) {
 367     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 368     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 369     if (hr == NULL) {
 370       return false;
 371     }
 372     return !(hr-&gt;is_young());
 373   }
 374 #endif
 375 #if INCLUDE_PARALLELGC
 376   if (UseParallelGC) {
 377     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 378     return !psh-&gt;is_in_young(p);
 379   }
 380 #endif
 381 #if INCLUDE_ZGC
 382   if (UseZGC) {
 383     return Universe::heap()-&gt;is_in(p);
 384   }
 385 #endif
 386   GenCollectedHeap* gch = GenCollectedHeap::heap();
 387   return !gch-&gt;is_in_young(p);
 388 WB_END
 389 
 390 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 391   oop p = JNIHandles::resolve(obj);
 392   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 393 WB_END
 394 
 395 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 396   return (jlong)SpaceAlignment;
 397 WB_END
 398 
 399 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 400   return (jlong)HeapAlignment;
 401 WB_END
 402 
 403 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))
 404   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();
 405 WB_END
 406 
 407 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))
 408   ConcurrentGCBreakpoints::acquire_control();
 409 WB_END
 410 
 411 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))
 412   ConcurrentGCBreakpoints::release_control();
 413 WB_END
 414 
 415 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))
 416   ConcurrentGCBreakpoints::run_to_idle();
 417 WB_END
 418 
 419 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))
 420   Handle h_name(THREAD, JNIHandles::resolve(at));
 421   ResourceMark rm;
 422   const char* c_name = java_lang_String::as_utf8_string(h_name());
 423   return ConcurrentGCBreakpoints::run_to(c_name);
 424 WB_END
 425 
 426 #if INCLUDE_G1GC
 427 
 428 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 429   if (UseG1GC) {
 430     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 431     oop result = JNIHandles::resolve(obj);
 432     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 433     return hr-&gt;is_humongous();
 434   }
 435   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 436 WB_END
 437 
 438 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 439   if (UseG1GC) {
 440     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 441     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 442     return hr-&gt;is_humongous();
 443   }
 444   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToHumongousRegion: G1 GC is not enabled&quot;);
 445 WB_END
 446 
 447 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 448   if (UseG1GC) {
 449     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 450     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 451     return hr-&gt;is_free();
 452   }
 453   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToFreeRegion: G1 GC is not enabled&quot;);
 454 WB_END
 455 
 456 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 457   if (UseG1GC) {
 458     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 459     size_t nr = g1h-&gt;max_regions();
 460     return (jlong)nr;
 461   }
 462   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumMaxRegions: G1 GC is not enabled&quot;);
 463 WB_END
 464 
 465 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 466   if (UseG1GC) {
 467     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 468     size_t nr = g1h-&gt;num_free_regions();
 469     return (jlong)nr;
 470   }
 471   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 472 WB_END
 473 
 474 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 475   if (UseG1GC) {
 476     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 477     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 478   }
 479   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 480 WB_END
 481 
 482 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 483   if (UseG1GC) {
 484     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 485     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 486       g1h-&gt;collect(GCCause::_wb_conc_mark);
 487       return true;
 488     }
 489     return false;
 490   }
 491   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 492 WB_END
 493 
 494 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 495   if (UseG1GC) {
 496     return (jint)HeapRegion::GrainBytes;
 497   }
 498   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 499 WB_END
 500 
 501 #endif // INCLUDE_G1GC
 502 
 503 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 504 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 505 #if INCLUDE_G1GC
 506   if (UseG1GC) {
 507     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 508     if (g1h-&gt;is_heterogeneous_heap()) {
 509       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 510       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 511     } else {
 512       return (jlong)g1h-&gt;base();
 513     }
 514   }
 515 #endif // INCLUDE_G1GC
 516 #if INCLUDE_PARALLELGC
 517   if (UseParallelGC) {
 518     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 519     if (AllocateOldGenAt != NULL) {
 520       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 521       return (jlong)reserved.start();
 522     } else {
 523       return (jlong)ps_heap-&gt;base();
 524     }
 525   }
 526 #endif // INCLUDE_PARALLELGC
 527   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedStart: enabled only for G1 and Parallel GC&quot;);
 528 WB_END
 529 
 530 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 531 #if INCLUDE_G1GC
 532   if (UseG1GC) {
 533     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 534     if (g1h-&gt;is_heterogeneous_heap()) {
 535       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 536       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 537     } else {
 538       return (jlong)g1h-&gt;base() + G1Arguments::heap_max_size_bytes();
 539     }
 540   }
 541 #endif // INCLUDE_G1GC
 542 #if INCLUDE_PARALLELGC
 543   if (UseParallelGC) {
 544     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 545     if (AllocateOldGenAt != NULL) {
 546       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 547       return (jlong)reserved.end();
 548     } else {
 549       return (jlong)ps_heap-&gt;reserved_region().end();
 550     }
 551   }
 552 #endif // INCLUDE_PARALLELGC
 553   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedEnd: enabled only for G1 and Parallel GC&quot;);
 554 WB_END
 555 
 556 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 557 #if INCLUDE_G1GC
 558   if (UseG1GC) {
 559     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 560     if (g1h-&gt;is_heterogeneous_heap()) {
 561       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 562       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 563     } else {
 564       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 565     }
 566   }
 567 #endif // INCLUDE_G1GC
 568 #if INCLUDE_PARALLELGC
 569   if (UseParallelGC) {
 570     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 571     if (AllocateOldGenAt != NULL) {
 572       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 573       return (jlong)reserved.start();
 574     } else {
 575       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 576     }
 577   }
 578 #endif // INCLUDE_PARALLELGC
 579   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: enabled only for G1 and Parallel GC&quot;);
 580 WB_END
 581 
 582 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 583 #if INCLUDE_G1GC
 584   if (UseG1GC) {
 585     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 586     if (g1h-&gt;is_heterogeneous_heap()) {
 587       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 588       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 589     } else {
 590       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 591     }
 592   }
 593 #endif // INCLUDE_G1GC
 594 #if INCLUDE_PARALLELGC
 595   if (UseParallelGC) {
 596     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 597     if (AllocateOldGenAt != NULL) {
 598       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 599       return (jlong)reserved.end();
 600       } else {
 601       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 602     }
 603   }
 604 #endif // INCLUDE_PARALLELGC
 605   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC&quot;);
 606 WB_END
 607 
 608 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 609 
 610 #if INCLUDE_PARALLELGC
 611 
 612 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 613   if (UseParallelGC) {
 614     return GenAlignment;
 615   }
 616   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSVirtualSpaceAlignment: Parallel GC is not enabled&quot;);
 617 WB_END
 618 
 619 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 620   if (UseParallelGC) {
 621     return GenAlignment;
 622   }
 623   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSHeapGenerationAlignment: Parallel GC is not enabled&quot;);
 624 WB_END
 625 
 626 #endif // INCLUDE_PARALLELGC
 627 
 628 #if INCLUDE_G1GC
 629 
 630 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 631   if (UseG1GC) {
 632     ResourceMark rm(THREAD);
 633     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 634     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 635     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 636     return JNIHandles::make_local(env, h());
 637   }
 638   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled&quot;);
 639 WB_END
 640 
 641 WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))
 642   if (UseG1GC) {
 643     G1NUMA* numa = G1NUMA::numa();
 644     return (jint)numa-&gt;num_active_nodes();
 645   }
 646   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1ActiveMemoryNodeCount: G1 GC is not enabled&quot;);
 647 WB_END
 648 
 649 WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))
 650   if (UseG1GC) {
 651     G1NUMA* numa = G1NUMA::numa();
 652     int num_node_ids = (int)numa-&gt;num_active_nodes();
 653     const int* node_ids = numa-&gt;node_ids();
 654 
 655     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);
 656     for (int i = 0; i &lt; num_node_ids; i++) {
 657       result-&gt;int_at_put(i, (jint)node_ids[i]);
 658     }
 659     return (jintArray) JNIHandles::make_local(env, result);
 660   }
 661   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1MemoryNodeIds: G1 GC is not enabled&quot;);
 662 WB_END
 663 
 664 class OldRegionsLivenessClosure: public HeapRegionClosure {
 665 
 666  private:
 667   const int _liveness;
 668   size_t _total_count;
 669   size_t _total_memory;
 670   size_t _total_memory_to_free;
 671 
 672  public:
 673   OldRegionsLivenessClosure(int liveness) :
 674     _liveness(liveness),
 675     _total_count(0),
 676     _total_memory(0),
 677     _total_memory_to_free(0) { }
 678 
 679     size_t total_count() { return _total_count; }
 680     size_t total_memory() { return _total_memory; }
 681     size_t total_memory_to_free() { return _total_memory_to_free; }
 682 
 683   bool do_heap_region(HeapRegion* r) {
 684     if (r-&gt;is_old()) {
 685       size_t prev_live = r-&gt;marked_bytes();
 686       size_t live = r-&gt;live_bytes();
 687       size_t size = r-&gt;used();
 688       size_t reg_size = HeapRegion::GrainBytes;
 689       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 690         _total_memory += size;
 691         ++_total_count;
 692         if (size == reg_size) {
 693         // we don&#39;t include non-full regions since they are unlikely included in mixed gc
 694         // for testing purposes it&#39;s enough to have lowest estimation of total memory that is expected to be freed
 695           _total_memory_to_free += size - prev_live;
 696         }
 697       }
 698     }
 699     return false;
 700   }
 701 };
 702 
 703 
 704 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 705   if (!UseG1GC) {
 706     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1GetMixedGCInfo: G1 GC is not enabled&quot;);
 707   }
 708   if (liveness &lt; 0) {
 709     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;liveness value should be non-negative&quot;);
 710   }
 711 
 712   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 713   OldRegionsLivenessClosure rli(liveness);
 714   g1h-&gt;heap_region_iterate(&amp;rli);
 715 
 716   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 717   result-&gt;long_at_put(0, rli.total_count());
 718   result-&gt;long_at_put(1, rli.total_memory());
 719   result-&gt;long_at_put(2, rli.total_memory_to_free());
 720   return (jlongArray) JNIHandles::make_local(env, result);
 721 WB_END
 722 
 723 #endif // INCLUDE_G1GC
 724 
 725 #if INCLUDE_NMT
 726 // Alloc memory using the test memory type so that we can use that to see if
 727 // NMT picks it up correctly
 728 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 729   jlong addr = 0;
 730   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 731   return addr;
 732 WB_END
 733 
 734 // Alloc memory with pseudo call stack. The test can create psudo malloc
 735 // allocation site to stress the malloc tracking.
 736 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 737   address pc = (address)(size_t)pseudo_stack;
 738   NativeCallStack stack(&amp;pc, 1);
 739   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 740 WB_END
 741 
 742 // Alloc memory with pseudo call stack and specific memory type.
 743 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 744   address pc = (address)(size_t)pseudo_stack;
 745   NativeCallStack stack(&amp;pc, 1);
 746   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 747 WB_END
 748 
 749 // Free the memory allocated by NMTAllocTest
 750 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 751   os::free((void*)(uintptr_t)mem);
 752 WB_END
 753 
 754 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 755   jlong addr = 0;
 756 
 757   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 758   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 759 
 760   return addr;
 761 WB_END
 762 
 763 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 764   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 765   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 766 
 767   return addr;
 768 WB_END
 769 
 770 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 771   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 772   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 773 WB_END
 774 
 775 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 776   os::uncommit_memory((char *)(uintptr_t)addr, size);
 777 WB_END
 778 
 779 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 780   os::release_memory((char *)(uintptr_t)addr, size);
 781 WB_END
 782 
 783 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 784   // Test that we can downgrade NMT levels but not upgrade them.
 785   if (MemTracker::tracking_level() == NMT_off) {
 786     MemTracker::transition_to(NMT_off);
 787     return MemTracker::tracking_level() == NMT_off;
 788   } else {
 789     assert(MemTracker::tracking_level() == NMT_detail, &quot;Should start out as detail tracking&quot;);
 790     MemTracker::transition_to(NMT_summary);
 791     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should be summary now&quot;);
 792 
 793     // Can&#39;t go to detail once NMT is set to summary.
 794     MemTracker::transition_to(NMT_detail);
 795     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should still be summary now&quot;);
 796 
 797     // Shutdown sets tracking level to minimal.
 798     MemTracker::shutdown();
 799     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should be minimal now&quot;);
 800 
 801     // Once the tracking level is minimal, we cannot increase to summary.
 802     // The code ignores this request instead of asserting because if the malloc site
 803     // table overflows in another thread, it tries to change the code to summary.
 804     MemTracker::transition_to(NMT_summary);
 805     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 806 
 807     // Really can never go up to detail, verify that the code would never do this.
 808     MemTracker::transition_to(NMT_detail);
 809     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 810     return MemTracker::tracking_level() == NMT_minimal;
 811   }
 812 WB_END
 813 
 814 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 815   int hash_size = MallocSiteTable::hash_buckets();
 816   assert(hash_size &gt; 0, &quot;NMT hash_size should be &gt; 0&quot;);
 817   return (jint)hash_size;
 818 WB_END
 819 
 820 WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))
 821   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));
 822   return (jlong)arena;
 823 WB_END
 824 
 825 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 826   Arena* a = (Arena*)arena;
 827   delete a;
 828 WB_END
 829 
 830 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 831   Arena* a = (Arena*)arena;
 832   a-&gt;Amalloc(size_t(size));
 833 WB_END
 834 #endif // INCLUDE_NMT
 835 
 836 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 837   assert(method != NULL, &quot;method should not be null&quot;);
 838   ThreadToNativeFromVM ttn(thread);
 839   return env-&gt;FromReflectedMethod(method);
 840 }
 841 
 842 static CompLevel highestCompLevel() {
 843   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
 844 }
 845 
 846 // Deoptimizes all compiled frames and makes nmethods not entrant if it&#39;s requested
 847 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 848  private:
 849   int _result;
 850   const bool _make_not_entrant;
 851  public:
 852   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 853         _result(0), _make_not_entrant(make_not_entrant) { }
 854   int  result() const { return _result; }
 855 
 856   void doit() {
 857     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 858       if (t-&gt;has_last_Java_frame()) {
 859         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {
 860           frame* f = fst.current();
 861           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
 862             Deoptimization::deoptimize(t, *f);
 863             if (_make_not_entrant) {
 864                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 865                 assert(cm != NULL, &quot;sanity check&quot;);
 866                 cm-&gt;make_not_entrant();
 867             }
 868             ++_result;
 869           }
 870         }
 871       }
 872     }
 873   }
 874 };
 875 
 876 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 877   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 878   VMThread::execute(&amp;op);
 879   return op.result();
 880 WB_END
 881 
 882 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
 883   CodeCache::mark_all_nmethods_for_deoptimization();
 884   Deoptimization::deoptimize_all_marked();
 885 WB_END
 886 
 887 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 888   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 889   int result = 0;
 890   CHECK_JNI_EXCEPTION_(env, result);
 891   MutexLocker mu(Compile_lock);
 892   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 893   if (is_osr) {
 894     result += mh-&gt;mark_osr_nmethods();
 895   } else if (mh-&gt;code() != NULL) {
 896     mh-&gt;code()-&gt;mark_for_deoptimization();
 897     ++result;
 898   }
 899   result += CodeCache::mark_for_deoptimization(mh());
 900   if (result &gt; 0) {
 901     Deoptimization::deoptimize_all_marked();
 902   }
 903   return result;
 904 WB_END
 905 
 906 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 907   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 908   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 909   MutexLocker mu(Compile_lock);
 910   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 911   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 912   if (code == NULL) {
 913     return JNI_FALSE;
 914   }
 915   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 916 WB_END
 917 
 918 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 919   if (method == NULL || comp_level &gt; highestCompLevel()) {
 920     return false;
 921   }
 922   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 923   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 924   MutexLocker mu(Compile_lock);
 925   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 926   if (is_osr) {
 927     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 928   } else {
 929     return CompilationPolicy::can_be_compiled(mh, comp_level);
 930   }
 931 WB_END
 932 
 933 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 934   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 935   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 936   MutexLocker mu(Compile_lock);
 937   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 938   return mh-&gt;queued_for_compilation();
 939 WB_END
 940 
 941 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 942   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {
 943     return false; // Intrinsic is not available on a non-existent compilation level.
 944   }
 945   jmethodID method_id, compilation_context_id;
 946   method_id = reflected_method_to_jmid(thread, env, method);
 947   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 948   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 949 
 950   DirectiveSet* directive;
 951   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 952   assert(comp != NULL, &quot;compiler not available&quot;);
 953   if (compilation_context != NULL) {
 954     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 955     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 956     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 957     directive = DirectivesStack::getMatchingDirective(cch, comp);
 958   } else {
 959     // Calling with NULL matches default directive
 960     directive = DirectivesStack::getDefaultDirective(comp);
 961   }
 962   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 963   DirectivesStack::release(directive);
 964   return result;
 965 WB_END
 966 
 967 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 968   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 969   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 970   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 971   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 972   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 973 WB_END
 974 
 975 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 976   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 977   CHECK_JNI_EXCEPTION(env);
 978   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 979   if (is_osr) {
 980     mh-&gt;set_not_osr_compilable(&quot;WhiteBox&quot;, comp_level);
 981   } else {
 982     mh-&gt;set_not_compilable(&quot;WhiteBox&quot;, comp_level);
 983   }
 984 WB_END
 985 
 986 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 987   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 988   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 989   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 990   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 991   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 992 WB_END
 993 
 994 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 995   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 996   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 997   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 998   bool result = mh-&gt;dont_inline();
 999   mh-&gt;set_dont_inline(value == JNI_TRUE);
1000   return result;
1001 WB_END
1002 
1003 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1004   if (comp_level == CompLevel_any) {
1005     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1006         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1007   } else {
1008     return CompileBroker::queue_size(comp_level);
1009   }
1010 WB_END
1011 
1012 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1013   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1014   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1015   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1016   bool result = mh-&gt;force_inline();
1017   mh-&gt;set_force_inline(value == JNI_TRUE);
1018   return result;
1019 WB_END
1020 
1021 #ifdef LINUX
1022 bool WhiteBox::validate_cgroup(const char* proc_cgroups,
1023                                const char* proc_self_cgroup,
1024                                const char* proc_self_mountinfo,
1025                                u1* cg_flags) {
1026   CgroupInfo cg_infos[4];
1027   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,
1028                                                     proc_self_cgroup,
1029                                                     proc_self_mountinfo, cg_flags);
1030 }
1031 #endif
1032 
1033 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1034   // Screen for unavailable/bad comp level or null method
1035   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1036   if (method == NULL) {
1037     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1038     return false;
1039   }
1040   if (comp_level &gt; highestCompLevel()) {
1041     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1042     return false;
1043   }
1044   if (comp == NULL) {
1045     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1046     return false;
1047   }
1048 
1049   // Check if compilation is blocking
1050   methodHandle mh(THREAD, method);
1051   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1052   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1053   DirectivesStack::release(directive);
1054 
1055   // Compile method and check result
1056   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1057   MutexLocker mu(THREAD, Compile_lock);
1058   bool is_queued = mh-&gt;queued_for_compilation();
1059   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1060     return true;
1061   }
1062   tty-&gt;print(&quot;WB error: failed to %s compile at level %d method &quot;, is_blocking ? &quot;blocking&quot; : &quot;&quot;, comp_level);
1063   mh-&gt;print_short_name(tty);
1064   tty-&gt;cr();
1065   if (is_blocking &amp;&amp; is_queued) {
1066     tty-&gt;print_cr(&quot;WB error: blocking compilation is still in queue!&quot;);
1067   }
1068   return false;
1069 }
1070 
1071 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1072   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1073   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1074   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1075 WB_END
1076 
1077 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1078   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1079   Method* clinit = ik-&gt;class_initializer();
1080   if (clinit == NULL) {
1081     return false;
1082   }
1083   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1084 WB_END
1085 
1086 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1087   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1088   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1089 
1090   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1091   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1092   bool result = directive-&gt;PrintAssemblyOption;
1093   DirectivesStack::release(directive);
1094 
1095   return result;
1096 WB_END
1097 
1098 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1099   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1100   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1101 
1102   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1103 
1104   ResourceMark rm(THREAD);
1105   const char* error_msg = NULL;
1106   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1107   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1108 
1109   if (m == NULL) {
1110     assert(error_msg != NULL, &quot;Always have an error message&quot;);
1111     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1112     return -1; // Pattern failed
1113   }
1114 
1115   // Pattern works - now check if it matches
1116   int result;
1117   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1118     result = 2; // Force inline match
1119   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1120     result = 1; // Dont inline match
1121   } else {
1122     result = 0; // No match
1123   }
1124   delete m;
1125   return result;
1126 WB_END
1127 
1128 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1129   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1130   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1131 
1132   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1133 
1134   ResourceMark rm;
1135   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1136 
1137   const char* error_msg = NULL;
1138 
1139   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1140   if (m == NULL) {
1141     assert(error_msg != NULL, &quot;Must have error_msg&quot;);
1142     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1143     return -1;
1144   }
1145 
1146   // Pattern works - now check if it matches
1147   int result = m-&gt;matches(mh);
1148   delete m;
1149   assert(result == 0 || result == 1, &quot;Result out of range&quot;);
1150   return result;
1151 WB_END
1152 
1153 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1154   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1155   CHECK_JNI_EXCEPTION(env);
1156   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1157 
1158   MethodData* mdo = mh-&gt;method_data();
1159   if (mdo == NULL) {
1160     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1161     mdo = mh-&gt;method_data();
1162   }
1163   mdo-&gt;init();
1164   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1165   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1166   // set i-counter according to TieredThresholdPolicy::is_method_profiled
1167   icnt-&gt;set(Tier4MinInvocationThreshold);
1168   bcnt-&gt;set(Tier4CompileThreshold);
1169 WB_END
1170 
1171 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1172   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1173   CHECK_JNI_EXCEPTION(env);
1174   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1175   MutexLocker mu(THREAD, Compile_lock);
1176   MethodData* mdo = mh-&gt;method_data();
1177   MethodCounters* mcs = mh-&gt;method_counters();
1178 
1179   if (mdo != NULL) {
1180     mdo-&gt;init();
1181     ResourceMark rm(THREAD);
1182     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1183     for (int i = 0; i &lt; arg_count; i++) {
1184       mdo-&gt;set_arg_modified(i, 0);
1185     }
1186     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1187     mdo-&gt;clean_method_data(/*always_clean*/true);
1188   }
1189 
1190   mh-&gt;clear_not_c1_compilable();
1191   mh-&gt;clear_not_c2_compilable();
1192   mh-&gt;clear_not_c2_osr_compilable();
1193   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1194   if (mcs != NULL) {
1195     mcs-&gt;backedge_counter()-&gt;init();
1196     mcs-&gt;invocation_counter()-&gt;init();
1197     mcs-&gt;set_interpreter_invocation_count(0);
1198     mcs-&gt;set_interpreter_throwout_count(0);
1199 
1200 #ifdef TIERED
1201     mcs-&gt;set_rate(0.0F);
1202     mh-&gt;set_prev_event_count(0);
1203     mh-&gt;set_prev_time(0);
1204 #endif
1205   }
1206 WB_END
1207 
1208 template &lt;typename T&gt;
1209 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {
1210   if (name == NULL) {
1211     return false;
1212   }
1213   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1214   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1215   CHECK_JNI_EXCEPTION_(env, false);
1216   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
1217   JVMFlag::Error result = (*TAt)(flag, value);
1218   env-&gt;ReleaseStringUTFChars(name, flag_name);
1219   return (result == JVMFlag::SUCCESS);
1220 }
1221 
1222 template &lt;typename T&gt;
1223 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {
1224   if (name == NULL) {
1225     return false;
1226   }
1227   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1228   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1229   CHECK_JNI_EXCEPTION_(env, false);
1230   JVMFlag* flag = JVMFlag::find_flag(flag_name);
1231   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);
1232   env-&gt;ReleaseStringUTFChars(name, flag_name);
1233   return (result == JVMFlag::SUCCESS);
1234 }
1235 
1236 template &lt;typename T&gt;
1237 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1238   ResourceMark rm(thread);
1239   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1240   CHECK_JNI_EXCEPTION_(env, NULL);
1241   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1242         vmSymbols::valueOf_name()-&gt;as_C_string(),
1243         sig-&gt;as_C_string());
1244   CHECK_JNI_EXCEPTION_(env, NULL);
1245   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1246   CHECK_JNI_EXCEPTION_(env, NULL);
1247   return result;
1248 }
1249 
1250 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1251   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1252 }
1253 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1254   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1255 }
1256 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1257   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1258 }
1259 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1260   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1261 }*/
1262 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1263   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1264 }
1265 
1266 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
1267   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1268   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1269   CHECK_JNI_EXCEPTION_(env, NULL);
1270   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
1271   env-&gt;ReleaseStringUTFChars(name, flag_name);
1272   return result;
1273 }
1274 
1275 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
1276   const JVMFlag* flag = getVMFlag(thread, env, name);
1277   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1278 WB_END
1279 
1280 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
1281   const JVMFlag* flag = getVMFlag(thread, env, name);
1282   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1283 WB_END
1284 
1285 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1286   bool result;
1287   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1288     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1289     return booleanBox(thread, env, result);
1290   }
1291   return NULL;
1292 WB_END
1293 
1294 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1295   int result;
1296   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1297     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1298     return longBox(thread, env, result);
1299   }
1300   return NULL;
1301 WB_END
1302 
1303 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1304   uint result;
1305   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1306     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1307     return longBox(thread, env, result);
1308   }
1309   return NULL;
1310 WB_END
1311 
1312 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1313   intx result;
1314   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1315     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1316     return longBox(thread, env, result);
1317   }
1318   return NULL;
1319 WB_END
1320 
1321 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1322   uintx result;
1323   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1324     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1325     return longBox(thread, env, result);
1326   }
1327   return NULL;
1328 WB_END
1329 
1330 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1331   uint64_t result;
1332   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1333     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1334     return longBox(thread, env, result);
1335   }
1336   return NULL;
1337 WB_END
1338 
1339 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1340   size_t result;
1341   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1342     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1343     return longBox(thread, env, result);
1344   }
1345   return NULL;
1346 WB_END
1347 
1348 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1349   double result;
1350   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1351     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1352     return doubleBox(thread, env, result);
1353   }
1354   return NULL;
1355 WB_END
1356 
1357 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1358   ccstr ccstrResult;
1359   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1360     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1361     jstring result = env-&gt;NewStringUTF(ccstrResult);
1362     CHECK_JNI_EXCEPTION_(env, NULL);
1363     return result;
1364   }
1365   return NULL;
1366 WB_END
1367 
1368 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1369   bool result = value == JNI_TRUE ? true : false;
1370   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1371 WB_END
1372 
1373 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1374   int result = value;
1375   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1376 WB_END
1377 
1378 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1379   uint result = value;
1380   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1381 WB_END
1382 
1383 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1384   intx result = value;
1385   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1386 WB_END
1387 
1388 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1389   uintx result = value;
1390   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1391 WB_END
1392 
1393 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1394   uint64_t result = value;
1395   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1396 WB_END
1397 
1398 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1399   size_t result = value;
1400   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1401 WB_END
1402 
1403 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1404   double result = value;
1405   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1406 WB_END
1407 
1408 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1409   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1410   const char* ccstrValue;
1411   if (value == NULL) {
1412     ccstrValue = NULL;
1413   }
1414   else {
1415     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1416     CHECK_JNI_EXCEPTION(env);
1417   }
1418   ccstr ccstrResult = ccstrValue;
1419   bool needFree;
1420   {
1421     ThreadInVMfromNative ttvfn(thread); // back to VM
1422     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1423   }
1424   if (value != NULL) {
1425     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1426   }
1427   if (needFree) {
1428     FREE_C_HEAP_ARRAY(char, ccstrResult);
1429   }
1430 WB_END
1431 
1432 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1433   WhiteBox::compilation_locked = true;
1434 WB_END
1435 
1436 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1437   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1438   WhiteBox::compilation_locked = false;
1439   mo.notify_all();
1440 WB_END
1441 
1442 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1443   // Force a code cache sweep and block until it finished
1444   NMethodSweeper::force_sweep();
1445 WB_END
1446 
1447 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1448   ResourceMark rm(THREAD);
1449   int len;
1450   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1451   return (StringTable::lookup(name, len) != NULL);
1452 WB_END
1453 
1454 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1455   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1456   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1457 #if INCLUDE_G1GC
1458   if (UseG1GC) {
1459     // Needs to be cleared explicitly for G1
1460     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1461   }
1462 #endif // INCLUDE_G1GC
1463 WB_END
1464 
1465 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1466   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1467 WB_END
1468 
1469 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1470   // static+volatile in order to force the read to happen
1471   // (not be eliminated by the compiler)
1472   static char c;
1473   static volatile char* p;
1474 
1475   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1476   if (p == NULL) {
1477     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), &quot;Failed to reserve memory&quot;);
1478   }
1479 
1480   c = *p;
1481 WB_END
1482 
1483 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1484   const char* features = VM_Version::features_string();
1485   ThreadToNativeFromVM ttn(thread);
1486   jstring features_string = env-&gt;NewStringUTF(features);
1487 
1488   CHECK_JNI_EXCEPTION_(env, NULL);
1489 
1490   return features_string;
1491 WB_END
1492 
1493 int WhiteBox::get_blob_type(const CodeBlob* code) {
1494   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1495   if (code-&gt;is_aot()) {
1496     return -1;
1497   }
1498   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1499 }
1500 
1501 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1502   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1503   return CodeCache::get_code_heap(blob_type);
1504 }
1505 
1506 struct CodeBlobStub {
1507   CodeBlobStub(const CodeBlob* blob) :
1508       name(os::strdup(blob-&gt;name())),
1509       size(blob-&gt;size()),
1510       blob_type(WhiteBox::get_blob_type(blob)),
1511       address((jlong) blob) { }
1512   ~CodeBlobStub() { os::free((void*) name); }
1513   const char* const name;
1514   const jint        size;
1515   const jint        blob_type;
1516   const jlong       address;
1517 };
1518 
1519 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
1520   ResourceMark rm;
1521   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1522   CHECK_JNI_EXCEPTION_(env, NULL);
1523   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1524 
1525   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1526   CHECK_JNI_EXCEPTION_(env, NULL);
1527   env-&gt;SetObjectArrayElement(result, 0, name);
1528 
1529   jobject obj = integerBox(thread, env, cb-&gt;size);
1530   CHECK_JNI_EXCEPTION_(env, NULL);
1531   env-&gt;SetObjectArrayElement(result, 1, obj);
1532 
1533   obj = integerBox(thread, env, cb-&gt;blob_type);
1534   CHECK_JNI_EXCEPTION_(env, NULL);
1535   env-&gt;SetObjectArrayElement(result, 2, obj);
1536 
1537   obj = longBox(thread, env, cb-&gt;address);
1538   CHECK_JNI_EXCEPTION_(env, NULL);
1539   env-&gt;SetObjectArrayElement(result, 3, obj);
1540 
1541   return result;
1542 }
1543 
1544 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1545   ResourceMark rm(THREAD);
1546   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1547   CHECK_JNI_EXCEPTION_(env, NULL);
1548   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1549   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1550   jobjectArray result = NULL;
1551   if (code == NULL) {
1552     return result;
1553   }
1554   int comp_level = code-&gt;comp_level();
1555   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1556 
1557   ThreadToNativeFromVM ttn(thread);
1558   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1559   CHECK_JNI_EXCEPTION_(env, NULL);
1560   result = env-&gt;NewObjectArray(5, clazz, NULL);
1561   if (result == NULL) {
1562     return result;
1563   }
1564 
1565   CodeBlobStub stub(code);
1566   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1567   CHECK_JNI_EXCEPTION_(env, NULL);
1568   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1569 
1570   jobject level = integerBox(thread, env, comp_level);
1571   CHECK_JNI_EXCEPTION_(env, NULL);
1572   env-&gt;SetObjectArrayElement(result, 1, level);
1573 
1574   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1575   CHECK_JNI_EXCEPTION_(env, NULL);
1576   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1577   env-&gt;SetObjectArrayElement(result, 2, insts);
1578 
1579   jobject id = integerBox(thread, env, code-&gt;compile_id());
1580   CHECK_JNI_EXCEPTION_(env, NULL);
1581   env-&gt;SetObjectArrayElement(result, 3, id);
1582 
1583   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1584   CHECK_JNI_EXCEPTION_(env, NULL);
1585   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1586 
1587   return result;
1588 WB_END
1589 
1590 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1591   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1592   BufferBlob* blob;
1593   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1594   if (full_size &lt; size) {
1595     full_size += align_up(size - full_size, oopSize);
1596   }
1597   {
1598     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1599     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1600     if (blob != NULL) {
1601       ::new (blob) BufferBlob(&quot;WB::DummyBlob&quot;, full_size);
1602     }
1603   }
1604   // Track memory usage statistic after releasing CodeCache_lock
1605   MemoryService::track_code_cache_memory_usage();
1606   return blob;
1607 }
1608 
1609 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1610   if (size &lt; 0) {
1611     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1612       err_msg(&quot;WB_AllocateCodeBlob: size is negative: &quot; INT32_FORMAT, size));
1613   }
1614   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1615 WB_END
1616 
1617 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1618   if (addr == 0) {
1619     return;
1620   }
1621   BufferBlob::free((BufferBlob*) addr);
1622 WB_END
1623 
1624 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1625   ResourceMark rm;
1626   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1627   {
1628     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1629     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1630     if (heap == NULL) {
1631       return NULL;
1632     }
1633     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1634          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1635       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1636       new (stub) CodeBlobStub(cb);
1637       blobs.append(stub);
1638     }
1639   }
1640   ThreadToNativeFromVM ttn(thread);
1641   jobjectArray result = NULL;
1642   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1643   CHECK_JNI_EXCEPTION_(env, NULL);
1644   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1645   CHECK_JNI_EXCEPTION_(env, NULL);
1646   if (result == NULL) {
1647     return result;
1648   }
1649   int i = 0;
1650   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1651        it != blobs.end(); ++it) {
1652     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1653     CHECK_JNI_EXCEPTION_(env, NULL);
1654     env-&gt;SetObjectArrayElement(result, i, obj);
1655     CHECK_JNI_EXCEPTION_(env, NULL);
1656     ++i;
1657   }
1658   return result;
1659 WB_END
1660 
1661 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1662   return CompileBroker::get_compilation_activity_mode();
1663 WB_END
1664 
1665 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1666   if (addr == 0) {
1667     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1668       &quot;WB_GetCodeBlob: addr is null&quot;);
1669   }
1670   ThreadToNativeFromVM ttn(thread);
1671   CodeBlobStub stub((CodeBlob*) addr);
1672   return codeBlob2objectArray(thread, env, &amp;stub);
1673 WB_END
1674 
1675 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1676   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1677   CHECK_JNI_EXCEPTION_(env, 0);
1678   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1679   return (jlong) mh-&gt;method_data();
1680 WB_END
1681 
1682 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1683   return (jlong) Thread::current()-&gt;stack_size();
1684 WB_END
1685 
1686 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1687   JavaThread* t = JavaThread::current();
1688   return (jlong) t-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1689 WB_END
1690 
1691 
1692 int WhiteBox::array_bytes_to_length(size_t bytes) {
1693   return Array&lt;u1&gt;::bytes_to_length(bytes);
1694 }
1695 
1696 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1697   if (size &lt; 0) {
1698     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1699         err_msg(&quot;WB_AllocateMetaspace: size is negative: &quot; JLONG_FORMAT, size));
1700   }
1701 
1702   oop class_loader_oop = JNIHandles::resolve(class_loader);
1703   ClassLoaderData* cld = class_loader_oop != NULL
1704       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1705       : ClassLoaderData::the_null_class_loader_data();
1706 
1707   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1708 
1709   return (jlong)(uintptr_t)metadata;
1710 WB_END
1711 
1712 WB_ENTRY(void, WB_FreeMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong addr, jlong size))
1713   oop class_loader_oop = JNIHandles::resolve(class_loader);
1714   ClassLoaderData* cld = class_loader_oop != NULL
1715       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1716       : ClassLoaderData::the_null_class_loader_data();
1717 
1718   MetadataFactory::free_array(cld, (Array&lt;u1&gt;*)(uintptr_t)addr);
1719 WB_END
1720 
1721 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1722                                 jstring version, jstring location, jobjectArray packages))
1723   Modules::define_module(module, is_open, version, location, packages, CHECK);
1724 WB_END
1725 
1726 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1727   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1728 WB_END
1729 
1730 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1731   Modules::add_module_exports_to_all_unnamed(module, package, CHECK);
1732 WB_END
1733 
1734 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1735   Modules::add_module_exports(module, package, NULL, CHECK);
1736 WB_END
1737 
1738 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1739   Modules::add_reads_module(from_module, source_module, CHECK);
1740 WB_END
1741 
1742 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1743   if (inc &lt; 0) {
1744     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1745         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc is negative: &quot; JLONG_FORMAT, inc));
1746   }
1747 
1748   jlong max_size_t = (jlong) ((size_t) -1);
1749   if (inc &gt; max_size_t) {
1750     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1751         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: &quot; JLONG_FORMAT, inc));
1752   }
1753 
1754   size_t new_cap_until_GC = 0;
1755   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1756   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1757   if (!success) {
1758     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1759                 &quot;WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC &quot;
1760                 &quot;due to contention with another thread&quot;);
1761   }
1762   return (jlong) new_cap_until_GC;
1763 WB_END
1764 
1765 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1766   return (jlong) MetaspaceGC::capacity_until_GC();
1767 WB_END
1768 
1769 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1770   return (jlong)Metaspace::reserve_alignment();
1771 WB_END
1772 
1773 WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))
1774   Mutex::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?
1775                                            Mutex::_safepoint_check_always :
1776                                            Mutex::_safepoint_check_never;
1777   Mutex::SafepointCheckFlag sfpt_check_attempted = attemptedNoSafepointValue ?
1778                                            Mutex::_no_safepoint_check_flag :
1779                                            Mutex::_safepoint_check_flag;
1780   MutexLocker ml(new Mutex(Mutex::leaf, &quot;SFPT_Test_lock&quot;, true, sfpt_check_required),
1781                  sfpt_check_attempted);
1782 WB_END
1783 
1784 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1785   // Create a special lock violating condition in value
1786   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1787                                            Mutex::_safepoint_check_always :
1788                                            Mutex::_safepoint_check_never;
1789   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1790                                            Monitor::_safepoint_check_flag :
1791                                            Monitor::_no_safepoint_check_flag;
1792 
1793   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1794   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1795   ThreadBlockInVM tbivm(JavaThread::current());
1796 WB_END
1797 
1798 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1799   oop obj_oop = JNIHandles::resolve(obj);
1800   return (jboolean) obj_oop-&gt;mark().has_monitor();
1801 WB_END
1802 
1803 WB_ENTRY(jboolean, WB_DeflateIdleMonitors(JNIEnv* env, jobject wb))
1804   log_info(monitorinflation)(&quot;WhiteBox initiated DeflateIdleMonitors&quot;);
1805   return ObjectSynchronizer::request_deflate_idle_monitors();
1806 WB_END
1807 
1808 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1809   VM_ForceSafepoint force_safepoint_op;
1810   VMThread::execute(&amp;force_safepoint_op);
1811 WB_END
1812 
1813 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1814   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1815   return (jlong) ik-&gt;constants();
1816 WB_END
1817 
1818 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1819   return ConstantPool::CPCACHE_INDEX_TAG;
1820 WB_END
1821 
1822 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1823   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1824   ConstantPool* cp = ik-&gt;constants();
1825   if (cp-&gt;cache() == NULL) {
1826       return -1;
1827   }
1828   return cp-&gt;cache()-&gt;length();
1829 WB_END
1830 
1831 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1832   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1833   ConstantPool* cp = ik-&gt;constants();
1834   if (cp-&gt;cache() == NULL) {
1835     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), &quot;Constant pool does not have a cache&quot;);
1836   }
1837   jint cpci = index;
1838   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1839   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1840     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool cache index is out of range&quot;);
1841   }
1842   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1843   return cpi;
1844 WB_END
1845 
1846 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1847   return ConstantPool::encode_invokedynamic_index(index);
1848 WB_END
1849 
1850 WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))
1851   oop aoop = JNIHandles::resolve(thing);
1852   if (!aoop-&gt;is_instance()) {
1853     return NULL;
1854   }
1855   instanceHandle ih(THREAD, (instanceOop) aoop);
1856   InstanceKlass* klass = InstanceKlass::cast(aoop-&gt;klass());
1857   if (klass-&gt;nonstatic_oop_map_count() == 0) {
1858     return NULL;
1859   }
1860   const OopMapBlock* map = klass-&gt;start_of_nonstatic_oop_maps();
1861   const OopMapBlock* const end = map + klass-&gt;nonstatic_oop_map_count();
1862   int oop_count = 0;
1863   while (map &lt; end) {
1864     oop_count += map-&gt;count();
1865     map++;
1866   }
1867 
1868   objArrayOop result_array =
1869       oopFactory::new_objArray(SystemDictionary::Object_klass(), oop_count, CHECK_NULL);
1870   map = klass-&gt;start_of_nonstatic_oop_maps();
1871   instanceOop ioop = ih();
1872   int index = 0;
1873   while (map &lt; end) {
1874     int offset = map-&gt;offset();
1875     for (unsigned int j = 0; j &lt; map-&gt;count(); j++) {
1876       result_array-&gt;obj_at_put(index++, ioop-&gt;obj_field(offset));
1877       offset += heapOopSize;
1878     }
1879     map++;
1880   }
1881   return (jobjectArray)JNIHandles::make_local(env, result_array);
1882 WB_END
1883 
1884 class CollectOops : public BasicOopIterateClosure {
1885  public:
1886   GrowableArray&lt;Handle&gt;* array;
1887 
1888   objArrayOop create_results(TRAPS) {
1889     objArrayOop result_array =
1890         oopFactory::new_objArray(SystemDictionary::Object_klass(), array-&gt;length(), CHECK_NULL);
1891     for (int i = 0 ; i &lt; array-&gt;length(); i++) {
1892       result_array-&gt;obj_at_put(i, array-&gt;at(i)());
1893     }
1894     return result_array;
1895   }
1896 
1897   jobjectArray create_jni_result(JNIEnv* env, TRAPS) {
1898     return (jobjectArray)JNIHandles::make_local(env, create_results(THREAD));
1899   }
1900 
1901   void add_oop(oop o) {
1902     // Value might be oop, but JLS can&#39;t see as Object, just iterate through it...
1903     if (o != NULL &amp;&amp; o-&gt;is_inline_type()) {
1904       o-&gt;oop_iterate(this);
1905     } else {
1906       array-&gt;append(Handle(Thread::current(), o));
1907     }
1908   }
1909 
1910   void do_oop(oop* o) { add_oop(*o); }
1911   void do_oop(narrowOop* v) { add_oop(CompressedOops::decode(*v)); }
1912 };
1913 
1914 
1915 WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))
1916   ResourceMark rm(THREAD);
1917   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);
1918   CollectOops collectOops;
1919   collectOops.array = array;
1920 
1921   JNIHandles::resolve(thing)-&gt;oop_iterate(&amp;collectOops);
1922 
1923   return collectOops.create_jni_result(env, THREAD);
1924 WB_END
1925 
1926 WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))
1927   ResourceMark rm(THREAD);
1928   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);
1929   CollectOops collectOops;
1930   collectOops.array = array;
1931   StackFrameStream sfs(thread);
1932   while (depth &gt; 0) { // Skip the native WB API frame
1933     sfs.next();
1934     frame* f = sfs.current();
1935     f-&gt;oops_do(&amp;collectOops, NULL, sfs.register_map());
1936     depth--;
1937   }
1938   return collectOops.create_jni_result(env, THREAD);
1939 WB_END
1940 
1941 
1942 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1943   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1944   VMThread::execute(&amp;clear_ics);
1945 WB_END
1946 
1947 template &lt;typename T&gt;
1948 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1949   assert(value != NULL, &quot;sanity&quot;);
1950   if (method == NULL || name == NULL) {
1951     return false;
1952   }
1953   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1954   CHECK_JNI_EXCEPTION_(env, false);
1955   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1956   // can&#39;t be in VM when we call JNI
1957   ThreadToNativeFromVM ttnfv(thread);
1958   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1959   CHECK_JNI_EXCEPTION_(env, false);
1960   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1961   env-&gt;ReleaseStringUTFChars(name, flag_name);
1962   return result;
1963 }
1964 
1965 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1966   bool result;
1967   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1968     // can&#39;t be in VM when we call JNI
1969     ThreadToNativeFromVM ttnfv(thread);
1970     return booleanBox(thread, env, result);
1971   }
1972   return NULL;
1973 WB_END
1974 
1975 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1976   intx result;
1977   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
1978     // can&#39;t be in VM when we call JNI
1979     ThreadToNativeFromVM ttnfv(thread);
1980     return longBox(thread, env, result);
1981   }
1982   return NULL;
1983 WB_END
1984 
1985 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1986   uintx result;
1987   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
1988     // can&#39;t be in VM when we call JNI
1989     ThreadToNativeFromVM ttnfv(thread);
1990     return longBox(thread, env, result);
1991   }
1992   return NULL;
1993 WB_END
1994 
1995 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1996   double result;
1997   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
1998     // can&#39;t be in VM when we call JNI
1999     ThreadToNativeFromVM ttnfv(thread);
2000     return doubleBox(thread, env, result);
2001   }
2002   return NULL;
2003 WB_END
2004 
2005 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
2006   ccstr ccstrResult;
2007   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
2008     // can&#39;t be in VM when we call JNI
2009     ThreadToNativeFromVM ttnfv(thread);
2010     jstring result = env-&gt;NewStringUTF(ccstrResult);
2011     CHECK_JNI_EXCEPTION_(env, NULL);
2012     return result;
2013   }
2014   return NULL;
2015 WB_END
2016 
2017 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
2018   const char* p = Arguments::get_default_shared_archive_path();
2019   ThreadToNativeFromVM ttn(thread);
2020   jstring path_string = env-&gt;NewStringUTF(p);
2021 
2022   CHECK_JNI_EXCEPTION_(env, NULL);
2023 
2024   return path_string;
2025 WB_END
2026 
2027 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
2028   return UseSharedSpaces;
2029 WB_END
2030 
2031 WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))
2032   return FileMapInfo::memory_mapping_failed();
2033 WB_END
2034 
2035 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
2036   oop obj_oop = JNIHandles::resolve(obj);
2037   return HeapShared::is_archived_object(obj_oop);
2038 WB_END
2039 
2040 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
2041   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
2042 WB_END
2043 
2044 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
2045   return !HeapShared::closed_archive_heap_region_mapped();
2046 WB_END
2047 
2048 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
2049   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2050   if (k-&gt;is_instance_klass()) {
2051     InstanceKlass *ik = InstanceKlass::cast(k);
2052     ConstantPool *cp = ik-&gt;constants();
2053     objArrayOop refs =  cp-&gt;resolved_references();
2054     return (jobject)JNIHandles::make_local(env, refs);
2055   } else {
2056     return NULL;
2057   }
2058 WB_END
2059 
2060 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
2061   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2062   if (!k-&gt;is_instance_klass()) {
2063     return;
2064   }
2065   InstanceKlass *ik = InstanceKlass::cast(k);
2066   ik-&gt;link_class(THREAD); // may throw verification error
2067 WB_END
2068 
2069 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2070   return HeapShared::open_archive_heap_region_mapped();
2071 WB_END
2072 
2073 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2074 #if INCLUDE_CDS
2075   return true;
2076 #else
2077   return false;
2078 #endif // INCLUDE_CDS
2079 WB_END
2080 
2081 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2082 #if COMPILER2_OR_JVMCI
2083   return true;
2084 #else
2085   return false;
2086 #endif
2087 WB_END
2088 
2089 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2090   return HeapShared::is_heap_object_archiving_allowed();
2091 WB_END
2092 
2093 
2094 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
2095 #if INCLUDE_JFR
2096   return true;
2097 #else
2098   return false;
2099 #endif // INCLUDE_JFR
2100 WB_END
2101 
2102 #if INCLUDE_CDS
2103 
2104 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
2105   ResourceMark rm;
2106   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
2107   int result = CDSOffsets::find_offset(c_name);
2108   return (jint)result;
2109 WB_END
2110 
2111 #endif // INCLUDE_CDS
2112 
2113 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
2114   class TraceSelfClosure : public HandshakeClosure {
2115     jint _num_threads_completed;
2116 
2117     void do_thread(Thread* th) {
2118       assert(th-&gt;is_Java_thread(), &quot;sanity&quot;);
2119       JavaThread* jt = (JavaThread*)th;
2120       ResourceMark rm;
2121 
2122       jt-&gt;print_on(tty);
2123       jt-&gt;print_stack_on(tty);
2124       tty-&gt;cr();
2125       Atomic::inc(&amp;_num_threads_completed);
2126     }
2127 
2128   public:
2129     TraceSelfClosure() : HandshakeClosure(&quot;WB_TraceSelf&quot;), _num_threads_completed(0) {}
2130 
2131     jint num_threads_completed() const { return _num_threads_completed; }
2132   };
2133   TraceSelfClosure tsc;
2134 
2135   if (all_threads) {
2136     Handshake::execute(&amp;tsc);
2137   } else {
2138     oop thread_oop = JNIHandles::resolve(thread_handle);
2139     if (thread_oop != NULL) {
2140       JavaThread* target = java_lang_Thread::thread(thread_oop);
2141       Handshake::execute(&amp;tsc, target);
2142     }
2143   }
2144   return tsc.num_threads_completed();
2145 WB_END
2146 
2147 //Some convenience methods to deal with objects from java
2148 int WhiteBox::offset_for_field(const char* field_name, oop object,
2149     Symbol* signature_symbol) {
2150   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, &quot;Field name not valid&quot;);
2151   Thread* THREAD = Thread::current();
2152 
2153   //Get the class of our object
2154   Klass* arg_klass = object-&gt;klass();
2155   //Turn it into an instance-klass
2156   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
2157 
2158   //Create symbols to look for in the class
2159   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);
2160 
2161   //To be filled in with an offset of the field we&#39;re looking for
2162   fieldDescriptor fd;
2163 
2164   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
2165   if (res == NULL) {
2166     tty-&gt;print_cr(&quot;Invalid layout of %s at %s&quot;, ik-&gt;external_name(),
2167         name_symbol-&gt;as_C_string());
2168     vm_exit_during_initialization(&quot;Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
2169   }
2170 
2171   //fetch the field at the offset we&#39;ve found
2172   int dest_offset = fd.offset();
2173 
2174   return dest_offset;
2175 }
2176 
2177 
2178 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
2179   int offset = offset_for_field(field_name, object,
2180       vmSymbols::string_signature());
2181   oop string = object-&gt;obj_field(offset);
2182   if (string == NULL) {
2183     return NULL;
2184   }
2185   const char* ret = java_lang_String::as_utf8_string(string);
2186   return ret;
2187 }
2188 
2189 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2190   int offset =
2191       offset_for_field(field_name, object, vmSymbols::bool_signature());
2192   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2193   return ret;
2194 }
2195 
2196 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2197   ResourceMark rm;
2198   ThreadToNativeFromVM ttnfv(thread); // can&#39;t be in VM when we call JNI
2199 
2200   //  one by one registration natives for exception catching
2201   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2202   CHECK_JNI_EXCEPTION(env);
2203   for (int i = 0, n = method_count; i &lt; n; ++i) {
2204     // Skip dummy entries
2205     if (method_array[i].fnPtr == NULL) continue;
2206     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2207       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2208       if (throwable_obj != NULL) {
2209         env-&gt;ExceptionClear();
2210         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2211           // NoSuchMethodError is thrown when a method can&#39;t be found or a method is not native.
2212           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2213           tty-&gt;print_cr(&quot;Warning: &#39;NoSuchMethodError&#39; on register of sun.hotspot.WhiteBox::%s%s&quot;,
2214               method_array[i].name, method_array[i].signature);
2215         }
2216       } else {
2217         // Registration failed unexpectedly.
2218         tty-&gt;print_cr(&quot;Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered&quot;,
2219             method_array[i].name, method_array[i].signature);
2220         env-&gt;UnregisterNatives(wbclass);
2221         break;
2222       }
2223     }
2224   }
2225 }
2226 
2227 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2228   // can&#39;t be in VM when we call JNI
2229   ThreadToNativeFromVM ttnfv(thread);
2230   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2231   CHECK_JNI_EXCEPTION_(env, 0);
2232   int ret;
2233   {
2234     ThreadInVMfromNative ttvfn(thread); // back to VM
2235     ret = DirectivesParser::parse_string(dir, tty);
2236   }
2237   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2238   // -1 for error parsing directive. Return 0 as number of directives added.
2239   if (ret == -1) {
2240     ret = 0;
2241   }
2242   return (jint) ret;
2243 WB_END
2244 
2245 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2246   DirectivesStack::pop(count);
2247 WB_END
2248 
2249 // Checks that the library libfile has the noexecstack bit set.
2250 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2251   jboolean ret = false;
2252 #ifdef LINUX
2253   // Can&#39;t be in VM when we call JNI.
2254   ThreadToNativeFromVM ttnfv(thread);
2255   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2256   CHECK_JNI_EXCEPTION_(env, 0);
2257   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2258   env-&gt;ReleaseStringUTFChars(libfile, lf);
2259 #endif
2260   return ret;
2261 WB_END
2262 
2263 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2264   LINUX_ONLY(return OSContainer::is_containerized();)
2265   return false;
2266 WB_END
2267 
2268 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,
2269                                     jobject o,
2270                                     jstring proc_cgroups,
2271                                     jstring proc_self_cgroup,
2272                                     jstring proc_self_mountinfo))
2273   jint ret = 0;
2274 #ifdef LINUX
2275   ThreadToNativeFromVM ttnfv(thread);
2276   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);
2277   CHECK_JNI_EXCEPTION_(env, 0);
2278   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);
2279   CHECK_JNI_EXCEPTION_(env, 0);
2280   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);
2281   CHECK_JNI_EXCEPTION_(env, 0);
2282   u1 cg_type_flags = 0;
2283   // This sets cg_type_flags
2284   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);
2285   ret = (jint)cg_type_flags;
2286   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);
2287   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);
2288   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);
2289 #endif
2290   return ret;
2291 WB_END
2292 
2293 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2294   os::print_os_info(tty);
2295 WB_END
2296 
2297 // Elf decoder
2298 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2299 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2300   ElfFile::_do_not_cache_elf_section = true;
2301 #endif
2302 WB_END
2303 
2304 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2305   return (jlong) ResolvedMethodTable::items_count();
2306 WB_END
2307 
2308 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2309   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2310 WB_END
2311 
2312 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2313   jint result = 0;
2314 #if INCLUDE_AOT
2315   result = (jint) AOTLoader::heaps_count();
2316 #endif
2317   return result;
2318 WB_END
2319 
2320 WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))
2321   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2322   // Return size in bytes.
2323   return k-&gt;size() * wordSize;
2324 WB_END
2325 
2326 // See test/hotspot/jtreg/runtime/Thread/ThreadObjAccessAtExit.java.
2327 // It explains how the thread&#39;s priority field is used for test state coordination.
2328 //
2329 WB_ENTRY(void, WB_CheckThreadObjOfTerminatingThread(JNIEnv* env, jobject wb, jobject target_handle))
2330   oop target_oop = JNIHandles::resolve_non_null(target_handle);
2331   jlong tid = java_lang_Thread::thread_id(target_oop);
2332   JavaThread* target = java_lang_Thread::thread(target_oop);
2333 
2334   // Grab a ThreadsListHandle to protect the target thread whilst terminating
2335   ThreadsListHandle tlh;
2336 
2337   // Look up the target thread by tid to ensure it is present
2338   JavaThread* t = tlh.list()-&gt;find_JavaThread_from_java_tid(tid);
2339   if (t == NULL) {
2340     THROW_MSG(vmSymbols::java_lang_RuntimeException(), &quot;Target thread not found in ThreadsList!&quot;);
2341   }
2342 
2343   tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: target thread is protected&quot;);
2344   // Allow target to terminate by boosting priority
2345   java_lang_Thread::set_priority(t-&gt;threadObj(), ThreadPriority(NormPriority + 1));
2346 
2347   // Now wait for the target to terminate
2348   while (!target-&gt;is_terminated()) {
2349     ThreadBlockInVM tbivm(thread);  // just in case target is involved in a safepoint
2350     os::naked_short_sleep(0);
2351   }
2352 
2353   tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: target thread is terminated&quot;);
2354 
2355   // Now release the GC inducing thread - we have to re-resolve the external oop that
2356   // was passed in as GC may have occurred and we don&#39;t know if we can trust t-&gt;threadObj() now.
2357   oop original = JNIHandles::resolve_non_null(target_handle);
2358   java_lang_Thread::set_priority(original, ThreadPriority(NormPriority + 2));
2359 
2360   tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: GC has been initiated - checking threadObj:&quot;);
2361 
2362   // The Java code should be creating garbage and triggering GC, which would potentially move
2363   // the threadObj oop. If the exiting thread is properly protected then its threadObj should
2364   // remain valid and equal to our initial target_handle. Loop a few times to give GC a chance to
2365   // kick in.
2366   for (int i = 0; i &lt; 5; i++) {
2367     oop original = JNIHandles::resolve_non_null(target_handle);
2368     oop current = t-&gt;threadObj();
2369     if (original != current) {
2370       tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: failed comparison on iteration %d&quot;, i);
2371       THROW_MSG(vmSymbols::java_lang_RuntimeException(), &quot;Target thread oop has changed!&quot;);
2372     } else {
2373       tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: successful comparison on iteration %d&quot;, i);
2374       ThreadBlockInVM tbivm(thread);
2375       os::naked_short_sleep(50);
2376     }
2377   }
2378 WB_END
2379 
2380 #define CC (char*)
2381 
2382 static JNINativeMethod methods[] = {
2383   {CC&quot;getObjectAddress0&quot;,                CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectAddress  },
2384   {CC&quot;getObjectSize0&quot;,                   CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectSize     },
2385   {CC&quot;isObjectInOldGen0&quot;,                CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_isObjectInOldGen  },
2386   {CC&quot;getHeapOopSize&quot;,                   CC&quot;()I&quot;,                   (void*)&amp;WB_GetHeapOopSize    },
2387   {CC&quot;getVMPageSize&quot;,                    CC&quot;()I&quot;,                   (void*)&amp;WB_GetVMPageSize     },
2388   {CC&quot;getVMAllocationGranularity&quot;,       CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMAllocationGranularity },
2389   {CC&quot;getVMLargePageSize&quot;,               CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMLargePageSize},
2390   {CC&quot;getHeapSpaceAlignment&quot;,            CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapSpaceAlignment},
2391   {CC&quot;getHeapAlignment&quot;,                 CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapAlignment},
2392   {CC&quot;countAliveClasses0&quot;,               CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_CountAliveClasses },
2393   {CC&quot;getSymbolRefcount&quot;,                CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_GetSymbolRefcount },
2394   {CC&quot;parseCommandLine0&quot;,
2395       CC&quot;(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;&quot;,
2396       (void*) &amp;WB_ParseCommandLine
2397   },
2398   {CC&quot;addToBootstrapClassLoaderSearch0&quot;, CC&quot;(Ljava/lang/String;)V&quot;,
2399                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2400   {CC&quot;addToSystemClassLoaderSearch0&quot;,    CC&quot;(Ljava/lang/String;)V&quot;,
2401                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2402   {CC&quot;getCompressedOopsMaxHeapSize&quot;, CC&quot;()J&quot;,
2403       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2404   {CC&quot;printHeapSizes&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_PrintHeapSizes    },
2405   {CC&quot;runMemoryUnitTests&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_RunMemoryUnitTests},
2406   {CC&quot;readFromNoaccessArea&quot;,CC&quot;()V&quot;,                  (void*)&amp;WB_ReadFromNoaccessArea},
2407   {CC&quot;stressVirtualSpaceResize&quot;,CC&quot;(JJJ)I&quot;,           (void*)&amp;WB_StressVirtualSpaceResize},
2408 #if INCLUDE_CDS
2409   {CC&quot;getOffsetForName0&quot;, CC&quot;(Ljava/lang/String;)I&quot;,  (void*)&amp;WB_GetOffsetForName},
2410 #endif
2411 #if INCLUDE_G1GC
2412   {CC&quot;g1InConcurrentMark&quot;, CC&quot;()Z&quot;,                   (void*)&amp;WB_G1InConcurrentMark},
2413   {CC&quot;g1IsHumongous0&quot;,      CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_G1IsHumongous     },
2414   {CC&quot;g1BelongsToHumongousRegion0&quot;, CC&quot;(J)Z&quot;,         (void*)&amp;WB_G1BelongsToHumongousRegion},
2415   {CC&quot;g1BelongsToFreeRegion0&quot;, CC&quot;(J)Z&quot;,              (void*)&amp;WB_G1BelongsToFreeRegion},
2416   {CC&quot;g1NumMaxRegions&quot;,    CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumMaxRegions  },
2417   {CC&quot;g1NumFreeRegions&quot;,   CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumFreeRegions  },
2418   {CC&quot;g1RegionSize&quot;,       CC&quot;()I&quot;,                   (void*)&amp;WB_G1RegionSize      },
2419   {CC&quot;g1StartConcMarkCycle&quot;,       CC&quot;()Z&quot;,           (void*)&amp;WB_G1StartMarkCycle  },
2420   {CC&quot;g1AuxiliaryMemoryUsage&quot;, CC&quot;()Ljava/lang/management/MemoryUsage;&quot;,
2421                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
2422   {CC&quot;g1ActiveMemoryNodeCount&quot;, CC&quot;()I&quot;,              (void*)&amp;WB_G1ActiveMemoryNodeCount },
2423   {CC&quot;g1MemoryNodeIds&quot;,    CC&quot;()[I&quot;,                  (void*)&amp;WB_G1MemoryNodeIds },
2424   {CC&quot;g1GetMixedGCInfo&quot;,   CC&quot;(I)[J&quot;,                 (void*)&amp;WB_G1GetMixedGCInfo },
2425 #endif // INCLUDE_G1GC
2426 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2427   {CC&quot;dramReservedStart&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedStart },
2428   {CC&quot;dramReservedEnd&quot;,     CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedEnd },
2429   {CC&quot;nvdimmReservedStart&quot;, CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedStart },
2430   {CC&quot;nvdimmReservedEnd&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedEnd },
2431 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2432 #if INCLUDE_PARALLELGC
2433   {CC&quot;psVirtualSpaceAlignment&quot;,CC&quot;()J&quot;,               (void*)&amp;WB_PSVirtualSpaceAlignment},
2434   {CC&quot;psHeapGenerationAlignment&quot;,CC&quot;()J&quot;,             (void*)&amp;WB_PSHeapGenerationAlignment},
2435 #endif
2436 #if INCLUDE_NMT
2437   {CC&quot;NMTMalloc&quot;,           CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTMalloc          },
2438   {CC&quot;NMTMallocWithPseudoStack&quot;, CC&quot;(JI)J&quot;,           (void*)&amp;WB_NMTMallocWithPseudoStack},
2439   {CC&quot;NMTMallocWithPseudoStackAndType&quot;, CC&quot;(JII)J&quot;,   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2440   {CC&quot;NMTFree&quot;,             CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFree            },
2441   {CC&quot;NMTReserveMemory&quot;,    CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTReserveMemory   },
2442   {CC&quot;NMTAttemptReserveMemoryAt&quot;,    CC&quot;(JJ)J&quot;,       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2443   {CC&quot;NMTCommitMemory&quot;,     CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTCommitMemory    },
2444   {CC&quot;NMTUncommitMemory&quot;,   CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTUncommitMemory  },
2445   {CC&quot;NMTReleaseMemory&quot;,    CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTReleaseMemory   },
2446   {CC&quot;NMTChangeTrackingLevel&quot;, CC&quot;()Z&quot;,               (void*)&amp;WB_NMTChangeTrackingLevel},
2447   {CC&quot;NMTGetHashSize&quot;,      CC&quot;()I&quot;,                  (void*)&amp;WB_NMTGetHashSize     },
2448   {CC&quot;NMTNewArena&quot;,         CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTNewArena        },
2449   {CC&quot;NMTFreeArena&quot;,        CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFreeArena       },
2450   {CC&quot;NMTArenaMalloc&quot;,      CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTArenaMalloc     },
2451 #endif // INCLUDE_NMT
2452   {CC&quot;deoptimizeFrames&quot;,   CC&quot;(Z)I&quot;,                  (void*)&amp;WB_DeoptimizeFrames  },
2453   {CC&quot;deoptimizeAll&quot;,      CC&quot;()V&quot;,                   (void*)&amp;WB_DeoptimizeAll     },
2454   {CC&quot;deoptimizeMethod0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,
2455                                                       (void*)&amp;WB_DeoptimizeMethod  },
2456   {CC&quot;isMethodCompiled0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,
2457                                                       (void*)&amp;WB_IsMethodCompiled  },
2458   {CC&quot;isMethodCompilable0&quot;, CC&quot;(Ljava/lang/reflect/Executable;IZ)Z&quot;,
2459                                                       (void*)&amp;WB_IsMethodCompilable},
2460   {CC&quot;isMethodQueuedForCompilation0&quot;,
2461       CC&quot;(Ljava/lang/reflect/Executable;)Z&quot;,          (void*)&amp;WB_IsMethodQueuedForCompilation},
2462   {CC&quot;isIntrinsicAvailable0&quot;,
2463       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z&quot;,
2464                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2465   {CC&quot;makeMethodNotCompilable0&quot;,
2466       CC&quot;(Ljava/lang/reflect/Executable;IZ)V&quot;,        (void*)&amp;WB_MakeMethodNotCompilable},
2467   {CC&quot;testSetDontInlineMethod0&quot;,
2468       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetDontInlineMethod},
2469   {CC&quot;getMethodCompilationLevel0&quot;,
2470       CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,         (void*)&amp;WB_GetMethodCompilationLevel},
2471   {CC&quot;getMethodEntryBci0&quot;,
2472       CC&quot;(Ljava/lang/reflect/Executable;)I&quot;,          (void*)&amp;WB_GetMethodEntryBci},
2473   {CC&quot;getCompileQueueSize&quot;,
2474       CC&quot;(I)I&quot;,                                       (void*)&amp;WB_GetCompileQueueSize},
2475   {CC&quot;testSetForceInlineMethod0&quot;,
2476       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetForceInlineMethod},
2477   {CC&quot;enqueueMethodForCompilation0&quot;,
2478       CC&quot;(Ljava/lang/reflect/Executable;II)Z&quot;,        (void*)&amp;WB_EnqueueMethodForCompilation},
2479   {CC&quot;enqueueInitializerForCompilation0&quot;,
2480       CC&quot;(Ljava/lang/Class;I)Z&quot;,                      (void*)&amp;WB_EnqueueInitializerForCompilation},
2481   {CC&quot;markMethodProfiled&quot;,
2482       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_MarkMethodProfiled},
2483   {CC&quot;clearMethodState0&quot;,
2484       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_ClearMethodState},
2485   {CC&quot;lockCompilation&quot;,    CC&quot;()V&quot;,                   (void*)&amp;WB_LockCompilation},
2486   {CC&quot;unlockCompilation&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_UnlockCompilation},
2487   {CC&quot;matchesMethod&quot;,
2488       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2489                                                       (void*)&amp;WB_MatchesMethod},
2490   {CC&quot;matchesInline&quot;,
2491       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2492                                                       (void*)&amp;WB_MatchesInline},
2493   {CC&quot;shouldPrintAssembly&quot;,
2494         CC&quot;(Ljava/lang/reflect/Executable;I)Z&quot;,
2495                                                         (void*)&amp;WB_ShouldPrintAssembly},
2496 
2497   {CC&quot;isConstantVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsConstantVMFlag},
2498   {CC&quot;isLockedVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsLockedVMFlag},
2499   {CC&quot;setBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;Z)V&quot;,(void*)&amp;WB_SetBooleanVMFlag},
2500   {CC&quot;setIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntVMFlag},
2501   {CC&quot;setUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintVMFlag},
2502   {CC&quot;setIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntxVMFlag},
2503   {CC&quot;setUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintxVMFlag},
2504   {CC&quot;setUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUint64VMFlag},
2505   {CC&quot;setSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetSizeTVMFlag},
2506   {CC&quot;setDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;D)V&quot;,(void*)&amp;WB_SetDoubleVMFlag},
2507   {CC&quot;setStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;,
2508                                                       (void*)&amp;WB_SetStringVMFlag},
2509   {CC&quot;getBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2510                                                       (void*)&amp;WB_GetBooleanVMFlag},
2511   {CC&quot;getIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2512                                                       (void*)&amp;WB_GetIntVMFlag},
2513   {CC&quot;getUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2514                                                       (void*)&amp;WB_GetUintVMFlag},
2515   {CC&quot;getIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2516                                                       (void*)&amp;WB_GetIntxVMFlag},
2517   {CC&quot;getUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2518                                                       (void*)&amp;WB_GetUintxVMFlag},
2519   {CC&quot;getUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2520                                                       (void*)&amp;WB_GetUint64VMFlag},
2521   {CC&quot;getSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2522                                                       (void*)&amp;WB_GetSizeTVMFlag},
2523   {CC&quot;getDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Double;&quot;,
2524                                                       (void*)&amp;WB_GetDoubleVMFlag},
2525   {CC&quot;getStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;,
2526                                                       (void*)&amp;WB_GetStringVMFlag},
2527   {CC&quot;isInStringTable&quot;,    CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsInStringTable  },
2528   {CC&quot;fullGC&quot;,   CC&quot;()V&quot;,                             (void*)&amp;WB_FullGC },
2529   {CC&quot;youngGC&quot;,  CC&quot;()V&quot;,                             (void*)&amp;WB_YoungGC },
2530   {CC&quot;readReservedMemory&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_ReadReservedMemory },
2531   {CC&quot;allocateMetaspace&quot;,
2532      CC&quot;(Ljava/lang/ClassLoader;J)J&quot;,                 (void*)&amp;WB_AllocateMetaspace },
2533   {CC&quot;freeMetaspace&quot;,
2534      CC&quot;(Ljava/lang/ClassLoader;JJ)V&quot;,                (void*)&amp;WB_FreeMetaspace },
2535   {CC&quot;incMetaspaceCapacityUntilGC&quot;, CC&quot;(J)J&quot;,         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2536   {CC&quot;metaspaceCapacityUntilGC&quot;, CC&quot;()J&quot;,             (void*)&amp;WB_MetaspaceCapacityUntilGC },
2537   {CC&quot;metaspaceReserveAlignment&quot;, CC&quot;()J&quot;,            (void*)&amp;WB_MetaspaceReserveAlignment },
2538   {CC&quot;getCPUFeatures&quot;,     CC&quot;()Ljava/lang/String;&quot;,  (void*)&amp;WB_GetCPUFeatures     },
2539   {CC&quot;getNMethod0&quot;,         CC&quot;(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;&quot;,
2540                                                       (void*)&amp;WB_GetNMethod         },
2541   {CC&quot;forceNMethodSweep&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_ForceNMethodSweep  },
2542   {CC&quot;allocateCodeBlob&quot;,   CC&quot;(II)J&quot;,                 (void*)&amp;WB_AllocateCodeBlob   },
2543   {CC&quot;freeCodeBlob&quot;,       CC&quot;(J)V&quot;,                  (void*)&amp;WB_FreeCodeBlob       },
2544   {CC&quot;getCodeHeapEntries&quot;, CC&quot;(I)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeHeapEntries },
2545   {CC&quot;getCompilationActivityMode&quot;,
2546                            CC&quot;()I&quot;,                   (void*)&amp;WB_GetCompilationActivityMode},
2547   {CC&quot;getMethodData0&quot;,     CC&quot;(Ljava/lang/reflect/Executable;)J&quot;,
2548                                                       (void*)&amp;WB_GetMethodData      },
2549   {CC&quot;getCodeBlob&quot;,        CC&quot;(J)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeBlob        },
2550   {CC&quot;getThreadStackSize&quot;, CC&quot;()J&quot;,                   (void*)&amp;WB_GetThreadStackSize },
2551   {CC&quot;getThreadRemainingStackSize&quot;, CC&quot;()J&quot;,          (void*)&amp;WB_GetThreadRemainingStackSize },
2552   {CC&quot;DefineModule&quot;,       CC&quot;(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V&quot;,
2553                                                       (void*)&amp;WB_DefineModule },
2554   {CC&quot;AddModuleExports&quot;,   CC&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,
2555                                                       (void*)&amp;WB_AddModuleExports },
2556   {CC&quot;AddReadsModule&quot;,     CC&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;,
2557                                                       (void*)&amp;WB_AddReadsModule },
2558   {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2559                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2560   {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2561                                                       (void*)&amp;WB_AddModuleExportsToAll },
2562   {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
2563   {CC&quot;assertSpecialLock&quot;,  CC&quot;(ZZ)V&quot;,                 (void*)&amp;WB_AssertSpecialLock },
2564   {CC&quot;deflateIdleMonitors&quot;, CC&quot;()Z&quot;,                  (void*)&amp;WB_DeflateIdleMonitors },
2565   {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
2566   {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
2567   {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
2568   {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2569   {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
2570   {CC&quot;remapInstructionOperandFromCPCache0&quot;,
2571       CC&quot;(Ljava/lang/Class;I)I&quot;,                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2572   {CC&quot;encodeConstantPoolIndyIndex0&quot;,
2573       CC&quot;(I)I&quot;,                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
2574   {CC&quot;getObjectsViaKlassOopMaps0&quot;,
2575       CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,    (void*)&amp;WB_getObjectsViaKlassOopMaps},
2576   {CC&quot;getObjectsViaOopIterator0&quot;,
2577           CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,(void*)&amp;WB_getObjectsViaOopIterator},
2578   {CC&quot;getObjectsViaFrameOopIterator&quot;,
2579       CC&quot;(I)[Ljava/lang/Object;&quot;,                     (void*)&amp;WB_getObjectsViaFrameOopIterator},
2580   {CC&quot;getMethodBooleanOption&quot;,
2581       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2582                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2583   {CC&quot;getMethodIntxOption&quot;,
2584       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2585                                                       (void*)&amp;WB_GetMethodIntxOption},
2586   {CC&quot;getMethodUintxOption&quot;,
2587       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2588                                                       (void*)&amp;WB_GetMethodUintxOption},
2589   {CC&quot;getMethodDoubleOption&quot;,
2590       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;&quot;,
2591                                                       (void*)&amp;WB_GetMethodDoubleOption},
2592   {CC&quot;getMethodStringOption&quot;,
2593       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;&quot;,
2594                                                       (void*)&amp;WB_GetMethodStringOption},
2595   {CC&quot;getDefaultArchivePath&quot;,             CC&quot;()Ljava/lang/String;&quot;,
2596                                                       (void*)&amp;WB_GetDefaultArchivePath},
2597   {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
2598   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2599   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2600   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2601   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2602   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2603   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2604   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2605   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2606   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2607   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2608   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2609 
2610   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2611   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2612   {CC&quot;checkThreadObjOfTerminatingThread&quot;, CC&quot;(Ljava/lang/Thread;)V&quot;, (void*)&amp;WB_CheckThreadObjOfTerminatingThread },
2613   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2614                                                       (void*)&amp;WB_AddCompilerDirective },
2615   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2616   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2617   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2618   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
2619   {CC&quot;supportsConcurrentGCBreakpoints&quot;, CC&quot;()Z&quot;,      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},
2620   {CC&quot;concurrentGCAcquireControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCAcquireControl},
2621   {CC&quot;concurrentGCReleaseControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCReleaseControl},
2622   {CC&quot;concurrentGCRunToIdle0&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_ConcurrentGCRunToIdle},
2623   {CC&quot;concurrentGCRunTo0&quot;,        CC&quot;(Ljava/lang/String;)Z&quot;,
2624                                                       (void*)&amp;WB_ConcurrentGCRunTo},
2625   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2626                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2627   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
2628   {CC&quot;validateCgroup&quot;,
2629       CC&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I&quot;,
2630                                                       (void*)&amp;WB_ValidateCgroup },
2631   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2632   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2633   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2634   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2635   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2636   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2637 };
2638 
2639 
2640 #undef CC
2641 
2642 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2643   {
2644     if (WhiteBoxAPI) {
2645       // Make sure that wbclass is loaded by the null classloader
2646       InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(wbclass)));
2647       Handle loader(THREAD, ik-&gt;class_loader());
2648       if (loader.is_null()) {
2649         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2650         WhiteBox::set_used();
2651       }
2652     }
2653   }
2654 JVM_END
    </pre>
  </body>
</html>