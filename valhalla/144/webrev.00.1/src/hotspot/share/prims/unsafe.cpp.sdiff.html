<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/unsafe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/unsafe.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/javaClasses.inline.hpp&quot;
  31 #include &quot;classfile/vmSymbols.hpp&quot;
  32 #include &quot;jfr/jfrEvents.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;


  35 #include &quot;oops/access.inline.hpp&quot;
  36 #include &quot;oops/fieldStreams.inline.hpp&quot;



  37 #include &quot;oops/instanceKlass.inline.hpp&quot;
  38 #include &quot;oops/objArrayOop.inline.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  41 #include &quot;prims/unsafe.hpp&quot;

  42 #include &quot;runtime/globals.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  45 #include &quot;runtime/jniHandles.inline.hpp&quot;
  46 #include &quot;runtime/orderAccess.hpp&quot;
  47 #include &quot;runtime/reflection.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;runtime/threadSMR.hpp&quot;
  51 #include &quot;runtime/vm_version.hpp&quot;
  52 #include &quot;services/threadService.hpp&quot;
  53 #include &quot;utilities/align.hpp&quot;
  54 #include &quot;utilities/copy.hpp&quot;
  55 #include &quot;utilities/dtrace.hpp&quot;
  56 #include &quot;utilities/macros.hpp&quot;
  57 
  58 /**
  59  * Implementation of the jdk.internal.misc.Unsafe class
  60  */
  61 
</pre>
<hr />
<pre>
 130   if (p != NULL) {
 131     p = Access&lt;&gt;::resolve(p);
 132   }
 133 
 134   if (sizeof(char*) == sizeof(jint)) {   // (this constant folds!)
 135     return cast_from_oop&lt;address&gt;(p) + (jint) byte_offset;
 136   } else {
 137     return cast_from_oop&lt;address&gt;(p) +        byte_offset;
 138   }
 139 }
 140 
 141 // Externally callable versions:
 142 // (Use these in compiler intrinsics which emulate unsafe primitives.)
 143 jlong Unsafe_field_offset_to_byte_offset(jlong field_offset) {
 144   return field_offset;
 145 }
 146 jlong Unsafe_field_offset_from_byte_offset(jlong byte_offset) {
 147   return byte_offset;
 148 }
 149 
<span class="line-removed"> 150 </span>
 151 ///// Data read/writes on the Java heap and in native (off-heap) memory
 152 
 153 /**
 154  * Helper class to wrap memory accesses in JavaThread::doing_unsafe_access()
 155  */
 156 class GuardUnsafeAccess {
 157   JavaThread* _thread;
 158 
 159 public:
 160   GuardUnsafeAccess(JavaThread* thread) : _thread(thread) {
 161     // native/off-heap access which may raise SIGBUS if accessing
 162     // memory mapped file data in a region of the file which has
 163     // been truncated and is now invalid.
 164     _thread-&gt;set_doing_unsafe_access(true);
 165   }
 166 
 167   ~GuardUnsafeAccess() {
 168     _thread-&gt;set_doing_unsafe_access(false);
 169   }
 170 };
</pre>
<hr />
<pre>
 215     : _thread(thread), _obj(JNIHandles::resolve(obj)), _offset((ptrdiff_t)offset) {
 216     assert_field_offset_sane(_obj, offset);
 217   }
 218 
 219   T get() {
 220     if (_obj == NULL) {
 221       GuardUnsafeAccess guard(_thread);
 222       T ret = RawAccess&lt;&gt;::load(addr());
 223       return normalize_for_read(ret);
 224     } else {
 225       T ret = HeapAccess&lt;&gt;::load_at(_obj, _offset);
 226       return normalize_for_read(ret);
 227     }
 228   }
 229 
 230   void put(T x) {
 231     if (_obj == NULL) {
 232       GuardUnsafeAccess guard(_thread);
 233       RawAccess&lt;&gt;::store(addr(), normalize_for_write(x));
 234     } else {

 235       HeapAccess&lt;&gt;::store_at(_obj, _offset, normalize_for_write(x));
 236     }
 237   }
 238 
<span class="line-removed"> 239 </span>
 240   T get_volatile() {
 241     if (_obj == NULL) {
 242       GuardUnsafeAccess guard(_thread);
 243       volatile T ret = RawAccess&lt;MO_SEQ_CST&gt;::load(addr());
 244       return normalize_for_read(ret);
 245     } else {
 246       T ret = HeapAccess&lt;MO_SEQ_CST&gt;::load_at(_obj, _offset);
 247       return normalize_for_read(ret);
 248     }
 249   }
 250 
 251   void put_volatile(T x) {
 252     if (_obj == NULL) {
 253       GuardUnsafeAccess guard(_thread);
 254       RawAccess&lt;MO_SEQ_CST&gt;::store(addr(), normalize_for_write(x));
 255     } else {
 256       HeapAccess&lt;MO_SEQ_CST&gt;::store_at(_obj, _offset, normalize_for_write(x));
 257     }
 258   }
 259 };
 260 






























































 261 // These functions allow a null base pointer with an arbitrary address.
 262 // But if the base pointer is non-null, the offset should make some sense.
 263 // That is, it should be in the range [0, MAX_OBJECT_SIZE].
 264 UNSAFE_ENTRY(jobject, Unsafe_GetReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 265   oop p = JNIHandles::resolve(obj);
 266   assert_field_offset_sane(p, offset);
 267   oop v = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 268   return JNIHandles::make_local(env, v);
 269 } UNSAFE_END
 270 
 271 UNSAFE_ENTRY(void, Unsafe_PutReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 272   oop x = JNIHandles::resolve(x_h);
 273   oop p = JNIHandles::resolve(obj);
 274   assert_field_offset_sane(p, offset);

 275   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 276 } UNSAFE_END
 277 


























































 278 UNSAFE_ENTRY(jobject, Unsafe_GetReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 279   oop p = JNIHandles::resolve(obj);
 280   assert_field_offset_sane(p, offset);
 281   oop v = HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 282   return JNIHandles::make_local(env, v);
 283 } UNSAFE_END
 284 
 285 UNSAFE_ENTRY(void, Unsafe_PutReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 286   oop x = JNIHandles::resolve(x_h);
 287   oop p = JNIHandles::resolve(obj);
 288   assert_field_offset_sane(p, offset);
 289   HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 290 } UNSAFE_END
 291 
 292 UNSAFE_ENTRY(jobject, Unsafe_GetUncompressedObject(JNIEnv *env, jobject unsafe, jlong addr)) {
 293   oop v = *(oop*) (address) addr;
 294   return JNIHandles::make_local(env, v);
 295 } UNSAFE_END
 296 
 297 #define DEFINE_GETSETOOP(java_type, Type) \
</pre>
<hr />
<pre>
 594   return false;
 595 }
 596 UNSAFE_END
 597 
 598 static void getBaseAndScale(int&amp; base, int&amp; scale, jclass clazz, TRAPS) {
 599   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 600 
 601   oop mirror = JNIHandles::resolve_non_null(clazz);
 602   Klass* k = java_lang_Class::as_Klass(mirror);
 603 
 604   if (k == NULL || !k-&gt;is_array_klass()) {
 605     THROW(vmSymbols::java_lang_InvalidClassException());
 606   } else if (k-&gt;is_objArray_klass()) {
 607     base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
 608     scale = heapOopSize;
 609   } else if (k-&gt;is_typeArray_klass()) {
 610     TypeArrayKlass* tak = TypeArrayKlass::cast(k);
 611     base  = tak-&gt;array_header_in_bytes();
 612     assert(base == arrayOopDesc::base_offset_in_bytes(tak-&gt;element_type()), &quot;array_header_size semantics ok&quot;);
 613     scale = (1 &lt;&lt; tak-&gt;log2_element_size());





 614   } else {
 615     ShouldNotReachHere();
 616   }
 617 }
 618 
 619 UNSAFE_ENTRY(jint, Unsafe_ArrayBaseOffset0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 620   int base = 0, scale = 0;
 621   getBaseAndScale(base, scale, clazz, CHECK_0);
 622 
 623   return field_offset_from_byte_offset(base);
 624 } UNSAFE_END
 625 
 626 
 627 UNSAFE_ENTRY(jint, Unsafe_ArrayIndexScale0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 628   int base = 0, scale = 0;
 629   getBaseAndScale(base, scale, clazz, CHECK_0);
 630 
 631   // This VM packs both fields and array elements down to the byte.
 632   // But watch out:  If this changes, so that array references for
 633   // a given primitive type (say, T_BOOLEAN) use different memory units
 634   // than fields, this method MUST return zero for such arrays.
 635   // For example, the VM used to store sub-word sized fields in full
 636   // words in the object layout, so that accessors like getByte(Object,int)
 637   // did not really do what one might expect for arrays.  Therefore,
 638   // this function used to report a zero scale factor, so that the user
 639   // would know not to attempt to access sub-word array elements.
 640   // // Code for unpacked fields:
 641   // if (scale &lt; wordSize)  return 0;
 642 
 643   // The following allows for a pretty general fieldOffset cookie scheme,
 644   // but requires it to be linear in byte offset.
 645   return field_offset_from_byte_offset(scale) - field_offset_from_byte_offset(0);
 646 } UNSAFE_END
 647 
 648 






 649 static inline void throw_new(JNIEnv *env, const char *ename) {
 650   jclass cls = env-&gt;FindClass(ename);
 651   if (env-&gt;ExceptionCheck()) {
 652     env-&gt;ExceptionClear();
 653     tty-&gt;print_cr(&quot;Unsafe: cannot throw %s because FindClass has failed&quot;, ename);
 654     return;
 655   }
 656 
 657   env-&gt;ThrowNew(cls, NULL);
 658 }
 659 
 660 static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd) {
 661   // Code lifted from JDK 1.3 ClassLoader.c
 662 
 663   jbyte *body;
 664   char *utfName = NULL;
 665   jclass result = 0;
 666   char buf[128];
 667 
 668   assert(data != NULL, &quot;Class bytes must not be NULL&quot;);
</pre>
<hr />
<pre>
 758 // By using the CP patching array, you can have a new anonymous class U2 refer to an older one U1.
 759 // The bytecodes for U2 should refer to U1 by a symbolic name (doesn&#39;t matter what the name is).
 760 // The CONSTANT_Class entry for that name can be patched to refer directly to U1.
 761 
 762 // This allows, for example, U2 to use U1 as a superclass or super-interface, or as
 763 // an outer class (so that U2 is an anonymous inner class of anonymous U1).
 764 // It is not possible for a named class, or an older anonymous class, to refer by
 765 // name (via its CP) to a newer anonymous class.
 766 
 767 // CP patching may also be used to modify (i.e., hack) the names of methods, classes,
 768 // or type descriptors used in the loaded anonymous class.
 769 
 770 // Finally, CP patching may be used to introduce &quot;live&quot; objects into the constant pool,
 771 // instead of &quot;dead&quot; strings.  A compiled statement like println((Object)&quot;hello&quot;) can
 772 // be changed to println(greeting), where greeting is an arbitrary object created before
 773 // the anonymous class is loaded.  This is useful in dynamic languages, in which
 774 // various kinds of metaobjects must be introduced as constants into bytecode.
 775 // Note the cast (Object), which tells the verifier to expect an arbitrary object,
 776 // not just a literal string.  For such ldc instructions, the verifier uses the
 777 // type Object instead of String, if the loaded constant is not in fact a String.


 778 
 779 static InstanceKlass*
 780 Unsafe_DefineAnonymousClass_impl(JNIEnv *env,
 781                                  jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,
 782                                  u1** temp_alloc,
 783                                  TRAPS) {
 784   assert(host_class != NULL, &quot;host_class must not be NULL&quot;);
 785   assert(data != NULL, &quot;data must not be NULL&quot;);
 786 
 787   if (UsePerfData) {
 788     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 789   }
 790 
 791   jint length = typeArrayOop(JNIHandles::resolve_non_null(data))-&gt;length();
 792   assert(length &gt;= 0, &quot;class_bytes_length must not be negative: %d&quot;, length);
 793 
 794   int class_bytes_length = (int) length;
 795 
 796   u1* class_bytes = NEW_C_HEAP_ARRAY_RETURN_NULL(u1, length, mtInternal);
 797   if (class_bytes == NULL) {
</pre>
<hr />
<pre>
 853 
 854   Symbol* no_class_name = NULL;
 855   ClassLoadInfo cl_info(host_domain,
 856                         InstanceKlass::cast(host_klass),
 857                         cp_patches,
 858                         NULL,     // dynamic_nest_host
 859                         Handle(), // classData
 860                         false,    // is_hidden
 861                         false,    // is_strong_hidden
 862                         true);    // can_access_vm_annotations
 863 
 864   Klass* anonk = SystemDictionary::parse_stream(no_class_name,
 865                                                 host_loader,
 866                                                 &amp;st,
 867                                                 cl_info,
 868                                                 CHECK_NULL);
 869   if (anonk == NULL) {
 870     return NULL;
 871   }
 872 


 873   return InstanceKlass::cast(anonk);
 874 }
 875 
 876 UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {
 877   ResourceMark rm(THREAD);
 878 
 879   jobject res_jh = NULL;
 880   u1* temp_alloc = NULL;
 881 
 882   InstanceKlass* anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &amp;temp_alloc, THREAD);
 883   if (anon_klass != NULL) {
 884     res_jh = JNIHandles::make_local(env, anon_klass-&gt;java_mirror());
 885   }
 886 
 887   // try/finally clause:
 888   FREE_C_HEAP_ARRAY(u1, temp_alloc);
 889 
 890   // The anonymous class loader data has been artificially been kept alive to
 891   // this point.   The mirror and any instances of this class have to keep
 892   // it alive afterwards.
</pre>
<hr />
<pre>
1055 
1056 
1057 /// JVM_RegisterUnsafeMethods
1058 
1059 #define ADR &quot;J&quot;
1060 
1061 #define LANG &quot;Ljava/lang/&quot;
1062 
1063 #define OBJ LANG &quot;Object;&quot;
1064 #define CLS LANG &quot;Class;&quot;
1065 #define FLD LANG &quot;reflect/Field;&quot;
1066 #define THR LANG &quot;Throwable;&quot;
1067 
1068 #define DC_Args  LANG &quot;String;[BII&quot; LANG &quot;ClassLoader;&quot; &quot;Ljava/security/ProtectionDomain;&quot;
1069 #define DAC_Args CLS &quot;[B[&quot; OBJ
1070 
1071 #define CC (char*)  /*cast a literal from (const char*)*/
1072 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1073 
1074 #define DECLARE_GETPUTOOP(Type, Desc) \
<span class="line-modified">1075     {CC &quot;get&quot; #Type,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,       FN_PTR(Unsafe_Get##Type)}, \</span>
<span class="line-modified">1076     {CC &quot;put&quot; #Type,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,   FN_PTR(Unsafe_Put##Type)}, \</span>
<span class="line-modified">1077     {CC &quot;get&quot; #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,       FN_PTR(Unsafe_Get##Type##Volatile)}, \</span>
<span class="line-modified">1078     {CC &quot;put&quot; #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,   FN_PTR(Unsafe_Put##Type##Volatile)}</span>
1079 
1080 
1081 static JNINativeMethod jdk_internal_misc_Unsafe_methods[] = {
1082     {CC &quot;getReference&quot;,         CC &quot;(&quot; OBJ &quot;J)&quot; OBJ &quot;&quot;,   FN_PTR(Unsafe_GetReference)},
1083     {CC &quot;putReference&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReference)},
1084     {CC &quot;getReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J)&quot; OBJ,      FN_PTR(Unsafe_GetReferenceVolatile)},
1085     {CC &quot;putReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReferenceVolatile)},
1086 








1087     {CC &quot;getUncompressedObject&quot;, CC &quot;(&quot; ADR &quot;)&quot; OBJ,  FN_PTR(Unsafe_GetUncompressedObject)},
1088 
1089     DECLARE_GETPUTOOP(Boolean, Z),
1090     DECLARE_GETPUTOOP(Byte, B),
1091     DECLARE_GETPUTOOP(Short, S),
1092     DECLARE_GETPUTOOP(Char, C),
1093     DECLARE_GETPUTOOP(Int, I),
1094     DECLARE_GETPUTOOP(Long, J),
1095     DECLARE_GETPUTOOP(Float, F),
1096     DECLARE_GETPUTOOP(Double, D),
1097 
1098     {CC &quot;allocateMemory0&quot;,    CC &quot;(J)&quot; ADR,              FN_PTR(Unsafe_AllocateMemory0)},
1099     {CC &quot;reallocateMemory0&quot;,  CC &quot;(&quot; ADR &quot;J)&quot; ADR,       FN_PTR(Unsafe_ReallocateMemory0)},
1100     {CC &quot;freeMemory0&quot;,        CC &quot;(&quot; ADR &quot;)V&quot;,           FN_PTR(Unsafe_FreeMemory0)},
1101 
1102     {CC &quot;objectFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_ObjectFieldOffset0)},
1103     {CC &quot;objectFieldOffset1&quot;, CC &quot;(&quot; CLS LANG &quot;String;)J&quot;, FN_PTR(Unsafe_ObjectFieldOffset1)},
1104     {CC &quot;staticFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_StaticFieldOffset0)},
1105     {CC &quot;staticFieldBase0&quot;,   CC &quot;(&quot; FLD &quot;)&quot; OBJ,        FN_PTR(Unsafe_StaticFieldBase0)},
1106     {CC &quot;ensureClassInitialized0&quot;, CC &quot;(&quot; CLS &quot;)V&quot;,      FN_PTR(Unsafe_EnsureClassInitialized0)},
1107     {CC &quot;arrayBaseOffset0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayBaseOffset0)},
1108     {CC &quot;arrayIndexScale0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayIndexScale0)},

1109 
1110     {CC &quot;defineClass0&quot;,       CC &quot;(&quot; DC_Args &quot;)&quot; CLS,    FN_PTR(Unsafe_DefineClass0)},
1111     {CC &quot;allocateInstance&quot;,   CC &quot;(&quot; CLS &quot;)&quot; OBJ,        FN_PTR(Unsafe_AllocateInstance)},
1112     {CC &quot;throwException&quot;,     CC &quot;(&quot; THR &quot;)V&quot;,           FN_PTR(Unsafe_ThrowException)},
1113     {CC &quot;compareAndSetReference&quot;,CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSetReference)},
1114     {CC &quot;compareAndSetInt&quot;,   CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetInt)},
1115     {CC &quot;compareAndSetLong&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetLong)},
1116     {CC &quot;compareAndExchangeReference&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)&quot; OBJ, FN_PTR(Unsafe_CompareAndExchangeReference)},
1117     {CC &quot;compareAndExchangeInt&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)I&quot;, FN_PTR(Unsafe_CompareAndExchangeInt)},
1118     {CC &quot;compareAndExchangeLong&quot;, CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)J&quot;, FN_PTR(Unsafe_CompareAndExchangeLong)},
1119 
1120     {CC &quot;park&quot;,               CC &quot;(ZJ)V&quot;,                FN_PTR(Unsafe_Park)},
1121     {CC &quot;unpark&quot;,             CC &quot;(&quot; OBJ &quot;)V&quot;,           FN_PTR(Unsafe_Unpark)},
1122 
1123     {CC &quot;getLoadAverage0&quot;,    CC &quot;([DI)I&quot;,               FN_PTR(Unsafe_GetLoadAverage0)},
1124 
1125     {CC &quot;copyMemory0&quot;,        CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJ)V&quot;, FN_PTR(Unsafe_CopyMemory0)},
1126     {CC &quot;copySwapMemory0&quot;,    CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJJ)V&quot;, FN_PTR(Unsafe_CopySwapMemory0)},
1127     {CC &quot;writeback0&quot;,         CC &quot;(&quot; &quot;J&quot; &quot;)V&quot;,           FN_PTR(Unsafe_WriteBack0)},
1128     {CC &quot;writebackPreSync0&quot;,  CC &quot;()V&quot;,                  FN_PTR(Unsafe_WriteBackPreSync0)},
</pre>
</td>
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/javaClasses.inline.hpp&quot;
  31 #include &quot;classfile/vmSymbols.hpp&quot;
  32 #include &quot;jfr/jfrEvents.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  35 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">  36 #include &quot;logging/logStream.hpp&quot;</span>
  37 #include &quot;oops/access.inline.hpp&quot;
  38 #include &quot;oops/fieldStreams.inline.hpp&quot;
<span class="line-added">  39 #include &quot;oops/flatArrayKlass.hpp&quot;</span>
<span class="line-added">  40 #include &quot;oops/flatArrayOop.inline.hpp&quot;</span>
<span class="line-added">  41 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  42 #include &quot;oops/instanceKlass.inline.hpp&quot;
  43 #include &quot;oops/objArrayOop.inline.hpp&quot;
  44 #include &quot;oops/oop.inline.hpp&quot;
  45 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  46 #include &quot;prims/unsafe.hpp&quot;
<span class="line-added">  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
  48 #include &quot;runtime/globals.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/jniHandles.inline.hpp&quot;
  52 #include &quot;runtime/orderAccess.hpp&quot;
  53 #include &quot;runtime/reflection.hpp&quot;
  54 #include &quot;runtime/sharedRuntime.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;runtime/threadSMR.hpp&quot;
  57 #include &quot;runtime/vm_version.hpp&quot;
  58 #include &quot;services/threadService.hpp&quot;
  59 #include &quot;utilities/align.hpp&quot;
  60 #include &quot;utilities/copy.hpp&quot;
  61 #include &quot;utilities/dtrace.hpp&quot;
  62 #include &quot;utilities/macros.hpp&quot;
  63 
  64 /**
  65  * Implementation of the jdk.internal.misc.Unsafe class
  66  */
  67 
</pre>
<hr />
<pre>
 136   if (p != NULL) {
 137     p = Access&lt;&gt;::resolve(p);
 138   }
 139 
 140   if (sizeof(char*) == sizeof(jint)) {   // (this constant folds!)
 141     return cast_from_oop&lt;address&gt;(p) + (jint) byte_offset;
 142   } else {
 143     return cast_from_oop&lt;address&gt;(p) +        byte_offset;
 144   }
 145 }
 146 
 147 // Externally callable versions:
 148 // (Use these in compiler intrinsics which emulate unsafe primitives.)
 149 jlong Unsafe_field_offset_to_byte_offset(jlong field_offset) {
 150   return field_offset;
 151 }
 152 jlong Unsafe_field_offset_from_byte_offset(jlong byte_offset) {
 153   return byte_offset;
 154 }
 155 

 156 ///// Data read/writes on the Java heap and in native (off-heap) memory
 157 
 158 /**
 159  * Helper class to wrap memory accesses in JavaThread::doing_unsafe_access()
 160  */
 161 class GuardUnsafeAccess {
 162   JavaThread* _thread;
 163 
 164 public:
 165   GuardUnsafeAccess(JavaThread* thread) : _thread(thread) {
 166     // native/off-heap access which may raise SIGBUS if accessing
 167     // memory mapped file data in a region of the file which has
 168     // been truncated and is now invalid.
 169     _thread-&gt;set_doing_unsafe_access(true);
 170   }
 171 
 172   ~GuardUnsafeAccess() {
 173     _thread-&gt;set_doing_unsafe_access(false);
 174   }
 175 };
</pre>
<hr />
<pre>
 220     : _thread(thread), _obj(JNIHandles::resolve(obj)), _offset((ptrdiff_t)offset) {
 221     assert_field_offset_sane(_obj, offset);
 222   }
 223 
 224   T get() {
 225     if (_obj == NULL) {
 226       GuardUnsafeAccess guard(_thread);
 227       T ret = RawAccess&lt;&gt;::load(addr());
 228       return normalize_for_read(ret);
 229     } else {
 230       T ret = HeapAccess&lt;&gt;::load_at(_obj, _offset);
 231       return normalize_for_read(ret);
 232     }
 233   }
 234 
 235   void put(T x) {
 236     if (_obj == NULL) {
 237       GuardUnsafeAccess guard(_thread);
 238       RawAccess&lt;&gt;::store(addr(), normalize_for_write(x));
 239     } else {
<span class="line-added"> 240       assert(!_obj-&gt;is_inline_type() || _obj-&gt;mark().is_larval_state(), &quot;must be an object instance or a larval inline type&quot;);</span>
 241       HeapAccess&lt;&gt;::store_at(_obj, _offset, normalize_for_write(x));
 242     }
 243   }
 244 

 245   T get_volatile() {
 246     if (_obj == NULL) {
 247       GuardUnsafeAccess guard(_thread);
 248       volatile T ret = RawAccess&lt;MO_SEQ_CST&gt;::load(addr());
 249       return normalize_for_read(ret);
 250     } else {
 251       T ret = HeapAccess&lt;MO_SEQ_CST&gt;::load_at(_obj, _offset);
 252       return normalize_for_read(ret);
 253     }
 254   }
 255 
 256   void put_volatile(T x) {
 257     if (_obj == NULL) {
 258       GuardUnsafeAccess guard(_thread);
 259       RawAccess&lt;MO_SEQ_CST&gt;::store(addr(), normalize_for_write(x));
 260     } else {
 261       HeapAccess&lt;MO_SEQ_CST&gt;::store_at(_obj, _offset, normalize_for_write(x));
 262     }
 263   }
 264 };
 265 
<span class="line-added"> 266 #ifdef ASSERT</span>
<span class="line-added"> 267 /*</span>
<span class="line-added"> 268  * Get the field descriptor of the field of the given object at the given offset.</span>
<span class="line-added"> 269  */</span>
<span class="line-added"> 270 static bool get_field_descriptor(oop p, jlong offset, fieldDescriptor* fd) {</span>
<span class="line-added"> 271   bool found = false;</span>
<span class="line-added"> 272   Klass* k = p-&gt;klass();</span>
<span class="line-added"> 273   if (k-&gt;is_instance_klass()) {</span>
<span class="line-added"> 274     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added"> 275     found = ik-&gt;find_field_from_offset((int)offset, false, fd);</span>
<span class="line-added"> 276     if (!found &amp;&amp; ik-&gt;is_mirror_instance_klass()) {</span>
<span class="line-added"> 277       Klass* k2 = java_lang_Class::as_Klass(p);</span>
<span class="line-added"> 278       if (k2-&gt;is_instance_klass()) {</span>
<span class="line-added"> 279         ik = InstanceKlass::cast(k2);</span>
<span class="line-added"> 280         found = ik-&gt;find_field_from_offset((int)offset, true, fd);</span>
<span class="line-added"> 281       }</span>
<span class="line-added"> 282     }</span>
<span class="line-added"> 283   }</span>
<span class="line-added"> 284   return found;</span>
<span class="line-added"> 285 }</span>
<span class="line-added"> 286 #endif // ASSERT</span>
<span class="line-added"> 287 </span>
<span class="line-added"> 288 static void assert_and_log_unsafe_value_access(oop p, jlong offset, InlineKlass* vk) {</span>
<span class="line-added"> 289   Klass* k = p-&gt;klass();</span>
<span class="line-added"> 290 #ifdef ASSERT</span>
<span class="line-added"> 291   if (k-&gt;is_instance_klass()) {</span>
<span class="line-added"> 292     assert_field_offset_sane(p, offset);</span>
<span class="line-added"> 293     fieldDescriptor fd;</span>
<span class="line-added"> 294     bool found = get_field_descriptor(p, offset, &amp;fd);</span>
<span class="line-added"> 295     if (found) {</span>
<span class="line-added"> 296       assert(found, &quot;value field not found&quot;);</span>
<span class="line-added"> 297       assert(fd.is_inlined(), &quot;field not flat&quot;);</span>
<span class="line-added"> 298     } else {</span>
<span class="line-added"> 299       if (log_is_enabled(Trace, valuetypes)) {</span>
<span class="line-added"> 300         log_trace(valuetypes)(&quot;not a field in %s at offset &quot; SIZE_FORMAT_HEX,</span>
<span class="line-added"> 301                               p-&gt;klass()-&gt;external_name(), offset);</span>
<span class="line-added"> 302       }</span>
<span class="line-added"> 303     }</span>
<span class="line-added"> 304   } else if (k-&gt;is_flatArray_klass()) {</span>
<span class="line-added"> 305     FlatArrayKlass* vak = FlatArrayKlass::cast(k);</span>
<span class="line-added"> 306     int index = (offset - vak-&gt;array_header_in_bytes()) / vak-&gt;element_byte_size();</span>
<span class="line-added"> 307     address dest = (address)((flatArrayOop)p)-&gt;value_at_addr(index, vak-&gt;layout_helper());</span>
<span class="line-added"> 308     assert(dest == (cast_from_oop&lt;address&gt;(p) + offset), &quot;invalid offset&quot;);</span>
<span class="line-added"> 309   } else {</span>
<span class="line-added"> 310     ShouldNotReachHere();</span>
<span class="line-added"> 311   }</span>
<span class="line-added"> 312 #endif // ASSERT</span>
<span class="line-added"> 313   if (log_is_enabled(Trace, valuetypes)) {</span>
<span class="line-added"> 314     if (k-&gt;is_flatArray_klass()) {</span>
<span class="line-added"> 315       FlatArrayKlass* vak = FlatArrayKlass::cast(k);</span>
<span class="line-added"> 316       int index = (offset - vak-&gt;array_header_in_bytes()) / vak-&gt;element_byte_size();</span>
<span class="line-added"> 317       address dest = (address)((flatArrayOop)p)-&gt;value_at_addr(index, vak-&gt;layout_helper());</span>
<span class="line-added"> 318       log_trace(valuetypes)(&quot;%s array type %s index %d element size %d offset &quot; SIZE_FORMAT_HEX &quot; at &quot; INTPTR_FORMAT,</span>
<span class="line-added"> 319                             p-&gt;klass()-&gt;external_name(), vak-&gt;external_name(),</span>
<span class="line-added"> 320                             index, vak-&gt;element_byte_size(), offset, p2i(dest));</span>
<span class="line-added"> 321     } else {</span>
<span class="line-added"> 322       log_trace(valuetypes)(&quot;%s field type %s at offset &quot; SIZE_FORMAT_HEX,</span>
<span class="line-added"> 323                             p-&gt;klass()-&gt;external_name(), vk-&gt;external_name(), offset);</span>
<span class="line-added"> 324     }</span>
<span class="line-added"> 325   }</span>
<span class="line-added"> 326 }</span>
<span class="line-added"> 327 </span>
 328 // These functions allow a null base pointer with an arbitrary address.
 329 // But if the base pointer is non-null, the offset should make some sense.
 330 // That is, it should be in the range [0, MAX_OBJECT_SIZE].
 331 UNSAFE_ENTRY(jobject, Unsafe_GetReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 332   oop p = JNIHandles::resolve(obj);
 333   assert_field_offset_sane(p, offset);
 334   oop v = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 335   return JNIHandles::make_local(env, v);
 336 } UNSAFE_END
 337 
 338 UNSAFE_ENTRY(void, Unsafe_PutReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 339   oop x = JNIHandles::resolve(x_h);
 340   oop p = JNIHandles::resolve(obj);
 341   assert_field_offset_sane(p, offset);
<span class="line-added"> 342   assert(!p-&gt;is_inline_type() || p-&gt;mark().is_larval_state(), &quot;must be an object instance or a larval inline type&quot;);</span>
 343   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 344 } UNSAFE_END
 345 
<span class="line-added"> 346 UNSAFE_ENTRY(jlong, Unsafe_ValueHeaderSize(JNIEnv *env, jobject unsafe, jclass c)) {</span>
<span class="line-added"> 347   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));</span>
<span class="line-added"> 348   InlineKlass* vk = InlineKlass::cast(k);</span>
<span class="line-added"> 349   return vk-&gt;first_field_offset();</span>
<span class="line-added"> 350 } UNSAFE_END</span>
<span class="line-added"> 351 </span>
<span class="line-added"> 352 UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedArray(JNIEnv *env, jobject unsafe, jclass c)) {</span>
<span class="line-added"> 353   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));</span>
<span class="line-added"> 354   return k-&gt;is_flatArray_klass();</span>
<span class="line-added"> 355 } UNSAFE_END</span>
<span class="line-added"> 356 </span>
<span class="line-added"> 357 UNSAFE_ENTRY(jobject, Unsafe_UninitializedDefaultValue(JNIEnv *env, jobject unsafe, jclass vc)) {</span>
<span class="line-added"> 358   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));</span>
<span class="line-added"> 359   InlineKlass* vk = InlineKlass::cast(k);</span>
<span class="line-added"> 360   oop v = vk-&gt;default_value();</span>
<span class="line-added"> 361   return JNIHandles::make_local(env, v);</span>
<span class="line-added"> 362 } UNSAFE_END</span>
<span class="line-added"> 363 </span>
<span class="line-added"> 364 UNSAFE_ENTRY(jobject, Unsafe_GetValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc)) {</span>
<span class="line-added"> 365   oop base = JNIHandles::resolve(obj);</span>
<span class="line-added"> 366   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));</span>
<span class="line-added"> 367   InlineKlass* vk = InlineKlass::cast(k);</span>
<span class="line-added"> 368   assert_and_log_unsafe_value_access(base, offset, vk);</span>
<span class="line-added"> 369   Handle base_h(THREAD, base);</span>
<span class="line-added"> 370   oop v = vk-&gt;read_inlined_field(base_h(), offset, CHECK_NULL);</span>
<span class="line-added"> 371   return JNIHandles::make_local(env, v);</span>
<span class="line-added"> 372 } UNSAFE_END</span>
<span class="line-added"> 373 </span>
<span class="line-added"> 374 UNSAFE_ENTRY(void, Unsafe_PutValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc, jobject value)) {</span>
<span class="line-added"> 375   oop base = JNIHandles::resolve(obj);</span>
<span class="line-added"> 376   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));</span>
<span class="line-added"> 377   InlineKlass* vk = InlineKlass::cast(k);</span>
<span class="line-added"> 378   assert(!base-&gt;is_inline_type() || base-&gt;mark().is_larval_state(), &quot;must be an object instance or a larval inline type&quot;);</span>
<span class="line-added"> 379   assert_and_log_unsafe_value_access(base, offset, vk);</span>
<span class="line-added"> 380   oop v = JNIHandles::resolve(value);</span>
<span class="line-added"> 381   vk-&gt;write_inlined_field(base, offset, v, CHECK);</span>
<span class="line-added"> 382 } UNSAFE_END</span>
<span class="line-added"> 383 </span>
<span class="line-added"> 384 UNSAFE_ENTRY(jobject, Unsafe_MakePrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {</span>
<span class="line-added"> 385   oop v = JNIHandles::resolve_non_null(value);</span>
<span class="line-added"> 386   assert(v-&gt;is_inline_type(), &quot;must be an inline type instance&quot;);</span>
<span class="line-added"> 387   Handle vh(THREAD, v);</span>
<span class="line-added"> 388   InlineKlass* vk = InlineKlass::cast(v-&gt;klass());</span>
<span class="line-added"> 389   instanceOop new_value = vk-&gt;allocate_instance_buffer(CHECK_NULL);</span>
<span class="line-added"> 390   vk-&gt;inline_copy_oop_to_new_oop(vh(),  new_value);</span>
<span class="line-added"> 391   markWord mark = new_value-&gt;mark();</span>
<span class="line-added"> 392   new_value-&gt;set_mark(mark.enter_larval_state());</span>
<span class="line-added"> 393   return JNIHandles::make_local(env, new_value);</span>
<span class="line-added"> 394 } UNSAFE_END</span>
<span class="line-added"> 395 </span>
<span class="line-added"> 396 UNSAFE_ENTRY(jobject, Unsafe_FinishPrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {</span>
<span class="line-added"> 397   oop v = JNIHandles::resolve(value);</span>
<span class="line-added"> 398   assert(v-&gt;mark().is_larval_state(), &quot;must be a larval value&quot;);</span>
<span class="line-added"> 399   markWord mark = v-&gt;mark();</span>
<span class="line-added"> 400   v-&gt;set_mark(mark.exit_larval_state());</span>
<span class="line-added"> 401   return JNIHandles::make_local(env, v);</span>
<span class="line-added"> 402 } UNSAFE_END</span>
<span class="line-added"> 403 </span>
 404 UNSAFE_ENTRY(jobject, Unsafe_GetReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 405   oop p = JNIHandles::resolve(obj);
 406   assert_field_offset_sane(p, offset);
 407   oop v = HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 408   return JNIHandles::make_local(env, v);
 409 } UNSAFE_END
 410 
 411 UNSAFE_ENTRY(void, Unsafe_PutReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 412   oop x = JNIHandles::resolve(x_h);
 413   oop p = JNIHandles::resolve(obj);
 414   assert_field_offset_sane(p, offset);
 415   HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 416 } UNSAFE_END
 417 
 418 UNSAFE_ENTRY(jobject, Unsafe_GetUncompressedObject(JNIEnv *env, jobject unsafe, jlong addr)) {
 419   oop v = *(oop*) (address) addr;
 420   return JNIHandles::make_local(env, v);
 421 } UNSAFE_END
 422 
 423 #define DEFINE_GETSETOOP(java_type, Type) \
</pre>
<hr />
<pre>
 720   return false;
 721 }
 722 UNSAFE_END
 723 
 724 static void getBaseAndScale(int&amp; base, int&amp; scale, jclass clazz, TRAPS) {
 725   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 726 
 727   oop mirror = JNIHandles::resolve_non_null(clazz);
 728   Klass* k = java_lang_Class::as_Klass(mirror);
 729 
 730   if (k == NULL || !k-&gt;is_array_klass()) {
 731     THROW(vmSymbols::java_lang_InvalidClassException());
 732   } else if (k-&gt;is_objArray_klass()) {
 733     base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
 734     scale = heapOopSize;
 735   } else if (k-&gt;is_typeArray_klass()) {
 736     TypeArrayKlass* tak = TypeArrayKlass::cast(k);
 737     base  = tak-&gt;array_header_in_bytes();
 738     assert(base == arrayOopDesc::base_offset_in_bytes(tak-&gt;element_type()), &quot;array_header_size semantics ok&quot;);
 739     scale = (1 &lt;&lt; tak-&gt;log2_element_size());
<span class="line-added"> 740   } else if (k-&gt;is_flatArray_klass()) {</span>
<span class="line-added"> 741     FlatArrayKlass* vak = FlatArrayKlass::cast(k);</span>
<span class="line-added"> 742     InlineKlass* vklass = vak-&gt;element_klass();</span>
<span class="line-added"> 743     base = vak-&gt;array_header_in_bytes();</span>
<span class="line-added"> 744     scale = vak-&gt;element_byte_size();</span>
 745   } else {
 746     ShouldNotReachHere();
 747   }
 748 }
 749 
 750 UNSAFE_ENTRY(jint, Unsafe_ArrayBaseOffset0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 751   int base = 0, scale = 0;
 752   getBaseAndScale(base, scale, clazz, CHECK_0);
 753 
 754   return field_offset_from_byte_offset(base);
 755 } UNSAFE_END
 756 
 757 
 758 UNSAFE_ENTRY(jint, Unsafe_ArrayIndexScale0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 759   int base = 0, scale = 0;
 760   getBaseAndScale(base, scale, clazz, CHECK_0);
 761 
 762   // This VM packs both fields and array elements down to the byte.
 763   // But watch out:  If this changes, so that array references for
 764   // a given primitive type (say, T_BOOLEAN) use different memory units
 765   // than fields, this method MUST return zero for such arrays.
 766   // For example, the VM used to store sub-word sized fields in full
 767   // words in the object layout, so that accessors like getByte(Object,int)
 768   // did not really do what one might expect for arrays.  Therefore,
 769   // this function used to report a zero scale factor, so that the user
 770   // would know not to attempt to access sub-word array elements.
 771   // // Code for unpacked fields:
 772   // if (scale &lt; wordSize)  return 0;
 773 
 774   // The following allows for a pretty general fieldOffset cookie scheme,
 775   // but requires it to be linear in byte offset.
 776   return field_offset_from_byte_offset(scale) - field_offset_from_byte_offset(0);
 777 } UNSAFE_END
 778 
 779 
<span class="line-added"> 780 UNSAFE_ENTRY(jlong, Unsafe_GetObjectSize0(JNIEnv* env, jobject o, jobject obj))</span>
<span class="line-added"> 781   oop p = JNIHandles::resolve(obj);</span>
<span class="line-added"> 782   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;</span>
<span class="line-added"> 783 UNSAFE_END</span>
<span class="line-added"> 784 </span>
<span class="line-added"> 785 </span>
 786 static inline void throw_new(JNIEnv *env, const char *ename) {
 787   jclass cls = env-&gt;FindClass(ename);
 788   if (env-&gt;ExceptionCheck()) {
 789     env-&gt;ExceptionClear();
 790     tty-&gt;print_cr(&quot;Unsafe: cannot throw %s because FindClass has failed&quot;, ename);
 791     return;
 792   }
 793 
 794   env-&gt;ThrowNew(cls, NULL);
 795 }
 796 
 797 static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd) {
 798   // Code lifted from JDK 1.3 ClassLoader.c
 799 
 800   jbyte *body;
 801   char *utfName = NULL;
 802   jclass result = 0;
 803   char buf[128];
 804 
 805   assert(data != NULL, &quot;Class bytes must not be NULL&quot;);
</pre>
<hr />
<pre>
 895 // By using the CP patching array, you can have a new anonymous class U2 refer to an older one U1.
 896 // The bytecodes for U2 should refer to U1 by a symbolic name (doesn&#39;t matter what the name is).
 897 // The CONSTANT_Class entry for that name can be patched to refer directly to U1.
 898 
 899 // This allows, for example, U2 to use U1 as a superclass or super-interface, or as
 900 // an outer class (so that U2 is an anonymous inner class of anonymous U1).
 901 // It is not possible for a named class, or an older anonymous class, to refer by
 902 // name (via its CP) to a newer anonymous class.
 903 
 904 // CP patching may also be used to modify (i.e., hack) the names of methods, classes,
 905 // or type descriptors used in the loaded anonymous class.
 906 
 907 // Finally, CP patching may be used to introduce &quot;live&quot; objects into the constant pool,
 908 // instead of &quot;dead&quot; strings.  A compiled statement like println((Object)&quot;hello&quot;) can
 909 // be changed to println(greeting), where greeting is an arbitrary object created before
 910 // the anonymous class is loaded.  This is useful in dynamic languages, in which
 911 // various kinds of metaobjects must be introduced as constants into bytecode.
 912 // Note the cast (Object), which tells the verifier to expect an arbitrary object,
 913 // not just a literal string.  For such ldc instructions, the verifier uses the
 914 // type Object instead of String, if the loaded constant is not in fact a String.
<span class="line-added"> 915 //</span>
<span class="line-added"> 916 // An anonymous class cannot be an inline type.</span>
 917 
 918 static InstanceKlass*
 919 Unsafe_DefineAnonymousClass_impl(JNIEnv *env,
 920                                  jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,
 921                                  u1** temp_alloc,
 922                                  TRAPS) {
 923   assert(host_class != NULL, &quot;host_class must not be NULL&quot;);
 924   assert(data != NULL, &quot;data must not be NULL&quot;);
 925 
 926   if (UsePerfData) {
 927     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 928   }
 929 
 930   jint length = typeArrayOop(JNIHandles::resolve_non_null(data))-&gt;length();
 931   assert(length &gt;= 0, &quot;class_bytes_length must not be negative: %d&quot;, length);
 932 
 933   int class_bytes_length = (int) length;
 934 
 935   u1* class_bytes = NEW_C_HEAP_ARRAY_RETURN_NULL(u1, length, mtInternal);
 936   if (class_bytes == NULL) {
</pre>
<hr />
<pre>
 992 
 993   Symbol* no_class_name = NULL;
 994   ClassLoadInfo cl_info(host_domain,
 995                         InstanceKlass::cast(host_klass),
 996                         cp_patches,
 997                         NULL,     // dynamic_nest_host
 998                         Handle(), // classData
 999                         false,    // is_hidden
1000                         false,    // is_strong_hidden
1001                         true);    // can_access_vm_annotations
1002 
1003   Klass* anonk = SystemDictionary::parse_stream(no_class_name,
1004                                                 host_loader,
1005                                                 &amp;st,
1006                                                 cl_info,
1007                                                 CHECK_NULL);
1008   if (anonk == NULL) {
1009     return NULL;
1010   }
1011 
<span class="line-added">1012   assert(!anonk-&gt;is_inline_klass(), &quot;unsafe anonymous class cannot be inline class&quot;);</span>
<span class="line-added">1013 </span>
1014   return InstanceKlass::cast(anonk);
1015 }
1016 
1017 UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {
1018   ResourceMark rm(THREAD);
1019 
1020   jobject res_jh = NULL;
1021   u1* temp_alloc = NULL;
1022 
1023   InstanceKlass* anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &amp;temp_alloc, THREAD);
1024   if (anon_klass != NULL) {
1025     res_jh = JNIHandles::make_local(env, anon_klass-&gt;java_mirror());
1026   }
1027 
1028   // try/finally clause:
1029   FREE_C_HEAP_ARRAY(u1, temp_alloc);
1030 
1031   // The anonymous class loader data has been artificially been kept alive to
1032   // this point.   The mirror and any instances of this class have to keep
1033   // it alive afterwards.
</pre>
<hr />
<pre>
1196 
1197 
1198 /// JVM_RegisterUnsafeMethods
1199 
1200 #define ADR &quot;J&quot;
1201 
1202 #define LANG &quot;Ljava/lang/&quot;
1203 
1204 #define OBJ LANG &quot;Object;&quot;
1205 #define CLS LANG &quot;Class;&quot;
1206 #define FLD LANG &quot;reflect/Field;&quot;
1207 #define THR LANG &quot;Throwable;&quot;
1208 
1209 #define DC_Args  LANG &quot;String;[BII&quot; LANG &quot;ClassLoader;&quot; &quot;Ljava/security/ProtectionDomain;&quot;
1210 #define DAC_Args CLS &quot;[B[&quot; OBJ
1211 
1212 #define CC (char*)  /*cast a literal from (const char*)*/
1213 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1214 
1215 #define DECLARE_GETPUTOOP(Type, Desc) \
<span class="line-modified">1216     {CC &quot;get&quot;  #Type,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,                 FN_PTR(Unsafe_Get##Type)}, \</span>
<span class="line-modified">1217     {CC &quot;put&quot;  #Type,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,             FN_PTR(Unsafe_Put##Type)}, \</span>
<span class="line-modified">1218     {CC &quot;get&quot;  #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,      FN_PTR(Unsafe_Get##Type##Volatile)}, \</span>
<span class="line-modified">1219     {CC &quot;put&quot;  #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,  FN_PTR(Unsafe_Put##Type##Volatile)}</span>
1220 
1221 
1222 static JNINativeMethod jdk_internal_misc_Unsafe_methods[] = {
1223     {CC &quot;getReference&quot;,         CC &quot;(&quot; OBJ &quot;J)&quot; OBJ &quot;&quot;,   FN_PTR(Unsafe_GetReference)},
1224     {CC &quot;putReference&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReference)},
1225     {CC &quot;getReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J)&quot; OBJ,      FN_PTR(Unsafe_GetReferenceVolatile)},
1226     {CC &quot;putReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReferenceVolatile)},
1227 
<span class="line-added">1228     {CC &quot;isFlattenedArray&quot;, CC &quot;(&quot; CLS &quot;)Z&quot;,                     FN_PTR(Unsafe_IsFlattenedArray)},</span>
<span class="line-added">1229     {CC &quot;getValue&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; CLS &quot;)&quot; OBJ,          FN_PTR(Unsafe_GetValue)},</span>
<span class="line-added">1230     {CC &quot;putValue&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; CLS OBJ &quot;)V&quot;,         FN_PTR(Unsafe_PutValue)},</span>
<span class="line-added">1231     {CC &quot;uninitializedDefaultValue&quot;, CC &quot;(&quot; CLS &quot;)&quot; OBJ,         FN_PTR(Unsafe_UninitializedDefaultValue)},</span>
<span class="line-added">1232     {CC &quot;makePrivateBuffer&quot;,     CC &quot;(&quot; OBJ &quot;)&quot; OBJ,             FN_PTR(Unsafe_MakePrivateBuffer)},</span>
<span class="line-added">1233     {CC &quot;finishPrivateBuffer&quot;,   CC &quot;(&quot; OBJ &quot;)&quot; OBJ,             FN_PTR(Unsafe_FinishPrivateBuffer)},</span>
<span class="line-added">1234     {CC &quot;valueHeaderSize&quot;,       CC &quot;(&quot; CLS &quot;)J&quot;,                FN_PTR(Unsafe_ValueHeaderSize)},</span>
<span class="line-added">1235 </span>
1236     {CC &quot;getUncompressedObject&quot;, CC &quot;(&quot; ADR &quot;)&quot; OBJ,  FN_PTR(Unsafe_GetUncompressedObject)},
1237 
1238     DECLARE_GETPUTOOP(Boolean, Z),
1239     DECLARE_GETPUTOOP(Byte, B),
1240     DECLARE_GETPUTOOP(Short, S),
1241     DECLARE_GETPUTOOP(Char, C),
1242     DECLARE_GETPUTOOP(Int, I),
1243     DECLARE_GETPUTOOP(Long, J),
1244     DECLARE_GETPUTOOP(Float, F),
1245     DECLARE_GETPUTOOP(Double, D),
1246 
1247     {CC &quot;allocateMemory0&quot;,    CC &quot;(J)&quot; ADR,              FN_PTR(Unsafe_AllocateMemory0)},
1248     {CC &quot;reallocateMemory0&quot;,  CC &quot;(&quot; ADR &quot;J)&quot; ADR,       FN_PTR(Unsafe_ReallocateMemory0)},
1249     {CC &quot;freeMemory0&quot;,        CC &quot;(&quot; ADR &quot;)V&quot;,           FN_PTR(Unsafe_FreeMemory0)},
1250 
1251     {CC &quot;objectFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_ObjectFieldOffset0)},
1252     {CC &quot;objectFieldOffset1&quot;, CC &quot;(&quot; CLS LANG &quot;String;)J&quot;, FN_PTR(Unsafe_ObjectFieldOffset1)},
1253     {CC &quot;staticFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_StaticFieldOffset0)},
1254     {CC &quot;staticFieldBase0&quot;,   CC &quot;(&quot; FLD &quot;)&quot; OBJ,        FN_PTR(Unsafe_StaticFieldBase0)},
1255     {CC &quot;ensureClassInitialized0&quot;, CC &quot;(&quot; CLS &quot;)V&quot;,      FN_PTR(Unsafe_EnsureClassInitialized0)},
1256     {CC &quot;arrayBaseOffset0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayBaseOffset0)},
1257     {CC &quot;arrayIndexScale0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayIndexScale0)},
<span class="line-added">1258     {CC &quot;getObjectSize0&quot;,     CC &quot;(Ljava/lang/Object;)J&quot;, FN_PTR(Unsafe_GetObjectSize0)},</span>
1259 
1260     {CC &quot;defineClass0&quot;,       CC &quot;(&quot; DC_Args &quot;)&quot; CLS,    FN_PTR(Unsafe_DefineClass0)},
1261     {CC &quot;allocateInstance&quot;,   CC &quot;(&quot; CLS &quot;)&quot; OBJ,        FN_PTR(Unsafe_AllocateInstance)},
1262     {CC &quot;throwException&quot;,     CC &quot;(&quot; THR &quot;)V&quot;,           FN_PTR(Unsafe_ThrowException)},
1263     {CC &quot;compareAndSetReference&quot;,CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSetReference)},
1264     {CC &quot;compareAndSetInt&quot;,   CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetInt)},
1265     {CC &quot;compareAndSetLong&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetLong)},
1266     {CC &quot;compareAndExchangeReference&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)&quot; OBJ, FN_PTR(Unsafe_CompareAndExchangeReference)},
1267     {CC &quot;compareAndExchangeInt&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)I&quot;, FN_PTR(Unsafe_CompareAndExchangeInt)},
1268     {CC &quot;compareAndExchangeLong&quot;, CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)J&quot;, FN_PTR(Unsafe_CompareAndExchangeLong)},
1269 
1270     {CC &quot;park&quot;,               CC &quot;(ZJ)V&quot;,                FN_PTR(Unsafe_Park)},
1271     {CC &quot;unpark&quot;,             CC &quot;(&quot; OBJ &quot;)V&quot;,           FN_PTR(Unsafe_Unpark)},
1272 
1273     {CC &quot;getLoadAverage0&quot;,    CC &quot;([DI)I&quot;,               FN_PTR(Unsafe_GetLoadAverage0)},
1274 
1275     {CC &quot;copyMemory0&quot;,        CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJ)V&quot;, FN_PTR(Unsafe_CopyMemory0)},
1276     {CC &quot;copySwapMemory0&quot;,    CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJJ)V&quot;, FN_PTR(Unsafe_CopySwapMemory0)},
1277     {CC &quot;writeback0&quot;,         CC &quot;(&quot; &quot;J&quot; &quot;)V&quot;,           FN_PTR(Unsafe_WriteBack0)},
1278     {CC &quot;writebackPreSync0&quot;,  CC &quot;()V&quot;,                  FN_PTR(Unsafe_WriteBackPreSync0)},
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>