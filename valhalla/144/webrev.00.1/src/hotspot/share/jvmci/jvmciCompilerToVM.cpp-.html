<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/scopeDesc.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/compilerEvent.hpp&quot;
  32 #include &quot;compiler/disassembler.hpp&quot;
  33 #include &quot;interpreter/linkResolver.hpp&quot;
  34 #include &quot;interpreter/bytecodeStream.hpp&quot;
  35 #include &quot;jfr/jfrEvents.hpp&quot;
  36 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  37 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  38 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;logging/logTag.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/constantPool.inline.hpp&quot;
  44 #include &quot;oops/method.inline.hpp&quot;
  45 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  46 #include &quot;prims/nativeLookup.hpp&quot;
  47 #include &quot;runtime/atomic.hpp&quot;
  48 #include &quot;runtime/deoptimization.hpp&quot;
  49 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  50 #include &quot;runtime/frame.inline.hpp&quot;
  51 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/timerTrace.hpp&quot;
  54 #include &quot;runtime/vframe_hp.hpp&quot;
  55 
  56 JVMCIKlassHandle::JVMCIKlassHandle(Thread* thread, Klass* klass) {
  57   _thread = thread;
  58   _klass = klass;
  59   if (klass != NULL) {
  60     _holder = Handle(_thread, klass-&gt;klass_holder());
  61   }
  62 }
  63 
  64 JVMCIKlassHandle&amp; JVMCIKlassHandle::operator=(Klass* klass) {
  65   _klass = klass;
  66   if (klass != NULL) {
  67     _holder = Handle(_thread, klass-&gt;klass_holder());
  68   }
  69   return *this;
  70 }
  71 
  72 static void requireInHotSpot(const char* caller, JVMCI_TRAPS) {
  73   if (!JVMCIENV-&gt;is_hotspot()) {
  74     JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot call %s from JVMCI shared library&quot;, caller));
  75   }
  76 }
  77 
  78 void JNIHandleMark::push_jni_handle_block(JavaThread* thread) {
  79   if (thread != NULL) {
  80     // Allocate a new block for JNI handles.
  81     // Inlined code from jni_PushLocalFrame()
  82     JNIHandleBlock* java_handles = thread-&gt;active_handles();
  83     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  84     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, &quot;should not be NULL&quot;);
  85     compile_handles-&gt;set_pop_frame_link(java_handles);
  86     thread-&gt;set_active_handles(compile_handles);
  87   }
  88 }
  89 
  90 void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {
  91   if (thread != NULL) {
  92     // Release our JNI handle block
  93     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  94     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  95     thread-&gt;set_active_handles(java_handles);
  96     compile_handles-&gt;set_pop_frame_link(NULL);
  97     JNIHandleBlock::release_block(compile_handles, thread); // may block
  98   }
  99 }
 100 
 101 class JVMCITraceMark : public StackObj {
 102   const char* _msg;
 103  public:
 104   JVMCITraceMark(const char* msg) {
 105     _msg = msg;
 106     if (JVMCITraceLevel &gt;= 1) {
 107       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Enter %s&quot;, p2i(JavaThread::current()), _msg);
 108     }
 109   }
 110   ~JVMCITraceMark() {
 111     if (JVMCITraceLevel &gt;= 1) {
 112       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Exit %s&quot;, p2i(JavaThread::current()), _msg);
 113     }
 114   }
 115 };
 116 
 117 
 118 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 119   assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
 120   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 121   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
 122   return Handle(Thread::current(), arg);
 123 }
 124 
 125 // Bring the JVMCI compiler thread into the VM state.
 126 #define JVMCI_VM_ENTRY_MARK                   \
 127   ThreadInVMfromNative __tiv(thread);         \
 128   ResetNoHandleMark rnhm;                     \
 129   HandleMarkCleaner __hm(thread);             \
 130   Thread* THREAD = thread;                    \
 131   debug_only(VMNativeEntryWrapper __vew;)
 132 
 133 // Native method block that transitions current thread to &#39;_thread_in_vm&#39;.
 134 #define C2V_BLOCK(result_type, name, signature)      \
 135   TRACE_CALL(result_type, jvmci_ ## name signature)  \
 136   JVMCI_VM_ENTRY_MARK;                               \
 137   ResourceMark rm;                                   \
 138   JNI_JVMCIENV(thread, env);
 139 
 140 static Thread* get_current_thread() {
 141   return Thread::current_or_null_safe();
 142 }
 143 
 144 // Entry to native method implementation that transitions
 145 // current thread to &#39;_thread_in_vm&#39;.
 146 #define C2V_VMENTRY(result_type, name, signature)        \
 147   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 148   Thread* base_thread = get_current_thread();            \
 149   if (base_thread == NULL) {                             \
 150     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 151         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 152     return;                                              \
 153   }                                                      \
 154   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
 155   JavaThread* thread = (JavaThread*) base_thread;        \
 156   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 157   C2V_BLOCK(result_type, name, signature)
 158 
 159 #define C2V_VMENTRY_(result_type, name, signature, result) \
 160   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 161   Thread* base_thread = get_current_thread();            \
 162   if (base_thread == NULL) {                             \
 163     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 164         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 165     return result;                                       \
 166   }                                                      \
 167   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
 168   JavaThread* thread = (JavaThread*) base_thread;        \
 169   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 170   C2V_BLOCK(result_type, name, signature)
 171 
 172 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)
 173 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)
 174 
 175 // Entry to native method implementation that does not transition
 176 // current thread to &#39;_thread_in_vm&#39;.
 177 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \
 178   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 179   Thread* base_thread = get_current_thread();
 180 
 181 #define C2V_END }
 182 
 183 #define JNI_THROW(caller, name, msg) do {                                         \
 184     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 185     if (__throw_res != JNI_OK) {                                                  \
 186       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 187     }                                                                             \
 188     return;                                                                       \
 189   } while (0);
 190 
 191 #define JNI_THROW_(caller, name, msg, result) do {                                \
 192     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 193     if (__throw_res != JNI_OK) {                                                  \
 194       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 195     }                                                                             \
 196     return result;                                                                \
 197   } while (0)
 198 
 199 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);
 200 
 201 C2V_VMENTRY_NULL(jobjectArray, readConfiguration, (JNIEnv* env))
 202   jobjectArray config = readConfiguration0(env, JVMCI_CHECK_NULL);
 203   return config;
 204 }
 205 
 206 C2V_VMENTRY_NULL(jobject, getFlagValue, (JNIEnv* env, jobject c2vm, jobject name_handle))
 207 #define RETURN_BOXED_LONG(value) jvalue p; p.j = (jlong) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_LONG, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();
 208 #define RETURN_BOXED_DOUBLE(value) jvalue p; p.d = (jdouble) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_DOUBLE, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();
 209   JVMCIObject name = JVMCIENV-&gt;wrap(name_handle);
 210   if (name.is_null()) {
 211     JVMCI_THROW_NULL(NullPointerException);
 212   }
 213   const char* cstring = JVMCIENV-&gt;as_utf8_string(name);
 214   const JVMFlag* flag = JVMFlag::find_declared_flag(cstring);
 215   if (flag == NULL) {
 216     return c2vm;
 217   }
 218   if (flag-&gt;is_bool()) {
 219     jvalue prim;
 220     prim.z = flag-&gt;get_bool();
 221     JVMCIObject box = JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);
 222     return JVMCIENV-&gt;get_jobject(box);
 223   } else if (flag-&gt;is_ccstr()) {
 224     JVMCIObject value = JVMCIENV-&gt;create_string(flag-&gt;get_ccstr(), JVMCI_CHECK_NULL);
 225     return JVMCIENV-&gt;get_jobject(value);
 226   } else if (flag-&gt;is_intx()) {
 227     RETURN_BOXED_LONG(flag-&gt;get_intx());
 228   } else if (flag-&gt;is_int()) {
 229     RETURN_BOXED_LONG(flag-&gt;get_int());
 230   } else if (flag-&gt;is_uint()) {
 231     RETURN_BOXED_LONG(flag-&gt;get_uint());
 232   } else if (flag-&gt;is_uint64_t()) {
 233     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 234   } else if (flag-&gt;is_size_t()) {
 235     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 236   } else if (flag-&gt;is_uintx()) {
 237     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 238   } else if (flag-&gt;is_double()) {
 239     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 240   } else {
 241     JVMCI_ERROR_NULL(&quot;VM flag %s has unsupported type %s&quot;, flag-&gt;_name, flag-&gt;_type);
 242   }
 243 #undef RETURN_BOXED_LONG
 244 #undef RETURN_BOXED_DOUBLE
 245 C2V_END
 246 
 247 C2V_VMENTRY_NULL(jobject, getObjectAtAddress, (JNIEnv* env, jobject c2vm, jlong oop_address))
 248   requireInHotSpot(&quot;getObjectAtAddress&quot;, JVMCI_CHECK_NULL);
 249   if (oop_address == 0) {
 250     JVMCI_THROW_MSG_NULL(InternalError, &quot;Handle must be non-zero&quot;);
 251   }
 252   oop obj = *((oopDesc**) oop_address);
 253   if (obj != NULL) {
 254     oopDesc::verify(obj);
 255   }
 256   return JNIHandles::make_local(obj);
 257 C2V_END
 258 
 259 C2V_VMENTRY_NULL(jbyteArray, getBytecode, (JNIEnv* env, jobject, jobject jvmci_method))
 260   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 261 
 262   int code_size = method-&gt;code_size();
 263   jbyte* reconstituted_code = NEW_RESOURCE_ARRAY(jbyte, code_size);
 264 
 265   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), &quot;Method&#39;s holder should be rewritten&quot;);
 266   // iterate over all bytecodes and replace non-Java bytecodes
 267 
 268   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 269     Bytecodes::Code code = s.code();
 270     Bytecodes::Code raw_code = s.raw_code();
 271     int bci = s.bci();
 272     int len = s.instruction_size();
 273 
 274     // Restore original byte code.
 275     reconstituted_code[bci] =  (jbyte) (s.is_wide()? Bytecodes::_wide : code);
 276     if (len &gt; 1) {
 277       memcpy(reconstituted_code + (bci + 1), s.bcp()+1, len-1);
 278     }
 279 
 280     if (len &gt; 1) {
 281       // Restore the big-endian constant pool indexes.
 282       // Cf. Rewriter::scan_method
 283       switch (code) {
 284         case Bytecodes::_getstatic:
 285         case Bytecodes::_putstatic:
 286         case Bytecodes::_getfield:
 287         case Bytecodes::_putfield:
 288         case Bytecodes::_invokevirtual:
 289         case Bytecodes::_invokespecial:
 290         case Bytecodes::_invokestatic:
 291         case Bytecodes::_invokeinterface:
 292         case Bytecodes::_invokehandle: {
 293           int cp_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));
 294           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);
 295           break;
 296         }
 297 
 298         case Bytecodes::_invokedynamic: {
 299           int cp_index = Bytes::get_native_u4((address) reconstituted_code + (bci + 1));
 300           Bytes::put_Java_u4((address) reconstituted_code + (bci + 1), (u4) cp_index);
 301           break;
 302         }
 303 
 304         default:
 305           break;
 306       }
 307 
 308       // Not all ldc byte code are rewritten.
 309       switch (raw_code) {
 310         case Bytecodes::_fast_aldc: {
 311           int cpc_index = reconstituted_code[bci + 1] &amp; 0xff;
 312           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 313           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
 314           reconstituted_code[bci + 1] = (jbyte) cp_index;
 315           break;
 316         }
 317 
 318         case Bytecodes::_fast_aldc_w: {
 319           int cpc_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));
 320           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 321           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
 322           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);
 323           break;
 324         }
 325 
 326         default:
 327           break;
 328       }
 329     }
 330   }
 331 
 332   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
 333   JVMCIENV-&gt;copy_bytes_from(reconstituted_code, result, 0, code_size);
 334   return JVMCIENV-&gt;get_jbyteArray(result);
 335 C2V_END
 336 
 337 C2V_VMENTRY_0(jint, getExceptionTableLength, (JNIEnv* env, jobject, jobject jvmci_method))
 338   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 339   return method-&gt;exception_table_length();
 340 C2V_END
 341 
 342 C2V_VMENTRY_0(jlong, getExceptionTableStart, (JNIEnv* env, jobject, jobject jvmci_method))
 343   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 344   if (method-&gt;exception_table_length() == 0) {
 345     return 0L;
 346   }
 347   return (jlong) (address) method-&gt;exception_table_start();
 348 C2V_END
 349 
 350 C2V_VMENTRY_NULL(jobject, asResolvedJavaMethod, (JNIEnv* env, jobject, jobject executable_handle))
 351   requireInHotSpot(&quot;asResolvedJavaMethod&quot;, JVMCI_CHECK_NULL);
 352   oop executable = JNIHandles::resolve(executable_handle);
 353   oop mirror = NULL;
 354   int slot = 0;
 355 
 356   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 357     mirror = java_lang_reflect_Constructor::clazz(executable);
 358     slot = java_lang_reflect_Constructor::slot(executable);
 359   } else {
 360     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 361     mirror = java_lang_reflect_Method::clazz(executable);
 362     slot = java_lang_reflect_Method::slot(executable);
 363   }
 364   Klass* holder = java_lang_Class::as_Klass(mirror);
 365   methodHandle method (THREAD, InstanceKlass::cast(holder)-&gt;method_with_idnum(slot));
 366   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 367   return JVMCIENV-&gt;get_jobject(result);
 368 }
 369 
 370 C2V_VMENTRY_NULL(jobject, getResolvedJavaMethod, (JNIEnv* env, jobject, jobject base, jlong offset))
 371   Method* method;
 372   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);
 373   if (base_object.is_null()) {
 374     method = *((Method**)(offset));
 375   } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 376     Handle obj = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 377     if (obj-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {
 378       method = (Method*) (intptr_t) obj-&gt;long_field(offset);
 379     } else {
 380       JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, obj-&gt;klass()-&gt;external_name()));
 381     }
 382   } else if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {
 383     method = JVMCIENV-&gt;asMethod(base_object);
 384   }
 385   if (method == NULL) {
 386     JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));
 387   }
 388   assert (method-&gt;is_method(), &quot;invalid read&quot;);
 389   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, method), JVMCI_CHECK_NULL);
 390   return JVMCIENV-&gt;get_jobject(result);
 391 }
 392 
 393 C2V_VMENTRY_NULL(jobject, getConstantPool, (JNIEnv* env, jobject, jobject object_handle))
 394   ConstantPool* cp = NULL;
 395   JVMCIObject object = JVMCIENV-&gt;wrap(object_handle);
 396   if (object.is_null()) {
 397     JVMCI_THROW_NULL(NullPointerException);
 398   }
 399   if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(object)) {
 400     cp = JVMCIENV-&gt;asMethod(object)-&gt;constMethod()-&gt;constants();
 401   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(object)) {
 402     cp = InstanceKlass::cast(JVMCIENV-&gt;asKlass(object))-&gt;constants();
 403   } else {
 404     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 405                 err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(object)));
 406   }
 407   assert(cp != NULL, &quot;npe&quot;);
 408 
 409   JVMCIObject result = JVMCIENV-&gt;get_jvmci_constant_pool(constantPoolHandle(THREAD, cp), JVMCI_CHECK_NULL);
 410   return JVMCIENV-&gt;get_jobject(result);
 411 }
 412 
 413 C2V_VMENTRY_NULL(jobject, getResolvedJavaType0, (JNIEnv* env, jobject, jobject base, jlong offset, jboolean compressed))
 414   JVMCIKlassHandle klass(THREAD);
 415   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);
 416   jlong base_address = 0;
 417   if (base_object.is_non_null() &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 418     // klass = JVMCIENV-&gt;unhandle(base_object)-&gt;klass();
 419     if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 420       Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 421       klass = base_oop-&gt;klass();
 422     } else {
 423       assert(false, &quot;What types are we actually expecting here?&quot;);
 424     }
 425   } else if (!compressed) {
 426     if (base_object.is_non_null()) {
 427       if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {
 428         base_address = (intptr_t) JVMCIENV-&gt;asMethod(base_object);
 429       } else if (JVMCIENV-&gt;isa_HotSpotConstantPool(base_object)) {
 430         base_address = (intptr_t) JVMCIENV-&gt;asConstantPool(base_object);
 431       } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {
 432         base_address = (intptr_t) JVMCIENV-&gt;asKlass(base_object);
 433       } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 434         Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 435         if (base_oop-&gt;is_a(SystemDictionary::Class_klass())) {
 436           base_address = cast_from_oop&lt;jlong&gt;(base_oop());
 437         }
 438       }
 439       if (base_address == 0) {
 440         JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 441                     err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;, JVMCIENV-&gt;klass_name(base_object), offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 442       }
 443     }
 444     klass = *((Klass**) (intptr_t) (base_address + offset));
 445   } else {
 446     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 447                 err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;,
 448                         base_object.is_non_null() ? JVMCIENV-&gt;klass_name(base_object) : &quot;null&quot;,
 449                         offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 450   }
 451   assert (klass == NULL || klass-&gt;is_klass(), &quot;invalid read&quot;);
 452   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 453   return JVMCIENV-&gt;get_jobject(result);
 454 }
 455 
 456 C2V_VMENTRY_NULL(jobject, findUniqueConcreteMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 457   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 458   Klass* holder = JVMCIENV-&gt;asKlass(jvmci_type);
 459   if (holder-&gt;is_interface()) {
 460     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, holder-&gt;external_name()));
 461   }
 462   if (method-&gt;can_be_statically_bound()) {
 463     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Effectively static method %s.%s should be handled in Java code&quot;, method-&gt;method_holder()-&gt;external_name(), method-&gt;external_name()));
 464   }
 465 
 466   methodHandle ucm;
 467   {
 468     MutexLocker locker(Compile_lock);
 469     ucm = methodHandle(THREAD, Dependencies::find_unique_concrete_method(holder, method()));
 470   }
 471   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(ucm, JVMCI_CHECK_NULL);
 472   return JVMCIENV-&gt;get_jobject(result);
 473 C2V_END
 474 
 475 C2V_VMENTRY_NULL(jobject, getImplementor, (JNIEnv* env, jobject, jobject jvmci_type))
 476   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 477   if (!klass-&gt;is_interface()) {
 478     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 479         err_msg(&quot;Expected interface type, got %s&quot;, klass-&gt;external_name()));
 480   }
 481   InstanceKlass* iklass = InstanceKlass::cast(klass);
 482   JVMCIKlassHandle handle(THREAD);
 483   {
 484     // Need Compile_lock around implementor()
 485     MutexLocker locker(Compile_lock);
 486     handle = iklass-&gt;implementor();
 487   }
 488   JVMCIObject implementor = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 489   return JVMCIENV-&gt;get_jobject(implementor);
 490 C2V_END
 491 
 492 C2V_VMENTRY_0(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv* env, jobject, jobject jvmci_method))
 493   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 494   return method-&gt;is_ignored_by_security_stack_walk();
 495 C2V_END
 496 
 497 C2V_VMENTRY_0(jboolean, isCompilable,(JNIEnv* env, jobject, jobject jvmci_method))
 498   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 499   ConstantPool* cp = method-&gt;constMethod()-&gt;constants();
 500   assert(cp != NULL, &quot;npe&quot;);
 501   // don&#39;t inline method when constant pool contains a CONSTANT_Dynamic
 502   return !method-&gt;is_not_compilable(CompLevel_full_optimization) &amp;&amp; !cp-&gt;has_dynamic_constant();
 503 C2V_END
 504 
 505 C2V_VMENTRY_0(jboolean, hasNeverInlineDirective,(JNIEnv* env, jobject, jobject jvmci_method))
 506   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 507   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 508 C2V_END
 509 
 510 C2V_VMENTRY_0(jboolean, shouldInlineMethod,(JNIEnv* env, jobject, jobject jvmci_method))
 511   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 512   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 513 C2V_END
 514 
 515 C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 516   JVMCIObject name = JVMCIENV-&gt;wrap(jname);
 517   const char* str = JVMCIENV-&gt;as_utf8_string(name);
 518   TempNewSymbol class_name = SymbolTable::new_symbol(str);
 519 
 520   if (class_name-&gt;utf8_length() &lt;= 1) {
 521     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));
 522   }
 523 
 524   JVMCIKlassHandle resolved_klass(THREAD);
 525   Klass* accessing_klass = NULL;
 526   Handle class_loader;
 527   Handle protection_domain;
 528   if (accessing_class != NULL) {
 529     accessing_klass = JVMCIENV-&gt;asKlass(accessing_class);
 530     class_loader = Handle(THREAD, accessing_klass-&gt;class_loader());
 531     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
 532   } else {
 533     // Use the System class loader
 534     class_loader = Handle(THREAD, SystemDictionary::java_system_loader());
 535     JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 536   }
 537 
 538   if (resolve) {
 539     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_NULL);
 540     if (resolved_klass == NULL) {
 541       JVMCI_THROW_MSG_NULL(ClassNotFoundException, str);
 542     }
 543   } else {
 544     if (Signature::has_envelope(class_name)) {
 545       // This is a name from a signature.  Strip off the trimmings.
 546       // Call recursive to keep scope of strippedsym.
 547       TempNewSymbol strippedsym = Signature::strip_envelope(class_name);
 548       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_NULL);
 549     } else if (Signature::is_array(class_name)) {
 550       SignatureStream ss(class_name, false);
 551       int ndim = ss.skip_array_prefix();
 552       if (ss.type() == T_OBJECT) {
 553         Symbol* strippedsym = ss.as_symbol();
 554         resolved_klass = SystemDictionary::find(strippedsym,
 555                                                 class_loader,
 556                                                 protection_domain,
 557                                                 CHECK_NULL);
 558         if (!resolved_klass.is_null()) {
 559           resolved_klass = resolved_klass-&gt;array_klass(ndim, CHECK_NULL);
 560         }
 561       } else {
 562         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(ss.type()))-&gt;array_klass(ndim, CHECK_NULL);
 563       }
 564     } else {
 565       resolved_klass = SystemDictionary::find(class_name, class_loader, protection_domain, CHECK_NULL);
 566     }
 567   }
 568   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 569   return JVMCIENV-&gt;get_jobject(result);
 570 C2V_END
 571 
 572 C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jobject jvmci_type))
 573   if (jvmci_type == NULL) {
 574     JVMCI_THROW_0(NullPointerException);
 575   }
 576 
 577   JVMCIObject jvmci_type_object = JVMCIENV-&gt;wrap(jvmci_type);
 578   JVMCIKlassHandle array_klass(THREAD);
 579   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(jvmci_type_object)) {
 580     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(jvmci_type_object), JVMCI_CHECK_0);
 581     if (type == T_VOID) {
 582       return NULL;
 583     }
 584     array_klass = Universe::typeArrayKlassObj(type);
 585     if (array_klass == NULL) {
 586       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;No array klass for primitive type %s&quot;, type2name(type)));
 587     }
 588   } else {
 589     Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 590     if (klass == NULL) {
 591       JVMCI_THROW_0(NullPointerException);
 592     }
 593     array_klass = klass-&gt;array_klass(CHECK_NULL);
 594   }
 595   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(array_klass, JVMCI_CHECK_NULL);
 596   return JVMCIENV-&gt;get_jobject(result);
 597 C2V_END
 598 
 599 C2V_VMENTRY_NULL(jobject, lookupClass, (JNIEnv* env, jobject, jclass mirror))
 600   requireInHotSpot(&quot;lookupClass&quot;, JVMCI_CHECK_NULL);
 601   if (mirror == NULL) {
 602     return NULL;
 603   }
 604   JVMCIKlassHandle klass(THREAD);
 605   klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
 606   if (klass == NULL) {
 607     JVMCI_THROW_MSG_NULL(IllegalArgumentException, &quot;Primitive classes are unsupported&quot;);
 608   }
 609   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 610   return JVMCIENV-&gt;get_jobject(result);
 611 }
 612 
 613 C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 614   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 615   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 616   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(result));
 617 C2V_END
 618 
 619 C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 620   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 621   return cp-&gt;name_and_type_ref_index_at(index);
 622 C2V_END
 623 
 624 C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))
 625   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 626   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;name_ref_at(which), JVMCI_CHECK_NULL);
 627   return JVMCIENV-&gt;get_jobject(sym);
 628 C2V_END
 629 
 630 C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))
 631   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 632   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;signature_ref_at(which), JVMCI_CHECK_NULL);
 633   return JVMCIENV-&gt;get_jobject(sym);
 634 C2V_END
 635 
 636 C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 637   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 638   return cp-&gt;klass_ref_index_at(index);
 639 C2V_END
 640 
 641 C2V_VMENTRY_NULL(jobject, resolveTypeInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 642   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 643   Klass* klass = cp-&gt;klass_at(index, CHECK_NULL);
 644   JVMCIKlassHandle resolved_klass(THREAD, klass);
 645   if (resolved_klass-&gt;is_instance_klass()) {
 646     InstanceKlass::cast(resolved_klass())-&gt;link_class(CHECK_NULL);
 647     if (!InstanceKlass::cast(resolved_klass())-&gt;is_linked()) {
 648       // link_class() should not return here if there is an issue.
 649       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Class %s must be linked&quot;, resolved_klass()-&gt;external_name()));
 650     }
 651   }
 652   JVMCIObject klassObject = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 653   return JVMCIENV-&gt;get_jobject(klassObject);
 654 C2V_END
 655 
 656 C2V_VMENTRY_NULL(jobject, lookupKlassInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 657   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 658   Klass* loading_klass = cp-&gt;pool_holder();
 659   bool is_accessible = false;
 660   JVMCIKlassHandle klass(THREAD, JVMCIRuntime::get_klass_by_index(cp, index, is_accessible, loading_klass));
 661   Symbol* symbol = NULL;
 662   if (klass.is_null()) {
 663     constantTag tag = cp-&gt;tag_at(index);
 664     if (tag.is_klass()) {
 665       // The klass has been inserted into the constant pool
 666       // very recently.
 667       klass = cp-&gt;resolved_klass_at(index);
 668     } else if (tag.is_symbol()) {
 669       symbol = cp-&gt;symbol_at(index);
 670     } else {
 671       assert(cp-&gt;tag_at(index).is_unresolved_klass(), &quot;wrong tag&quot;);
 672       symbol = cp-&gt;klass_name_at(index);
 673     }
 674   }
 675   JVMCIObject result;
 676   if (!klass.is_null()) {
 677     result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 678   } else {
 679     result = JVMCIENV-&gt;create_string(symbol, JVMCI_CHECK_NULL);
 680   }
 681   return JVMCIENV-&gt;get_jobject(result);
 682 C2V_END
 683 
 684 C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 685   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 686   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 687   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(appendix_oop));
 688 C2V_END
 689 
 690 C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 691   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 692   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 693   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 694   methodHandle method(THREAD, JVMCIRuntime::get_method_by_index(cp, index, bc, pool_holder));
 695   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 696   return JVMCIENV-&gt;get_jobject(result);
 697 C2V_END
 698 
 699 C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 700   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 701   return cp-&gt;remap_instruction_operand_from_cache(index);
 702 C2V_END
 703 
 704 C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 705   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 706   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 707   fieldDescriptor fd;
 708   methodHandle mh(THREAD, (jvmci_method != NULL) ? JVMCIENV-&gt;asMethod(jvmci_method) : NULL);
 709   LinkInfo link_info(cp, index, mh, CHECK_NULL);
 710   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_NULL);
 711   JVMCIPrimitiveArray info = JVMCIENV-&gt;wrap(info_handle);
 712   if (info.is_null() || JVMCIENV-&gt;get_length(info) != 3) {
 713     JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
 714   }
 715   JVMCIENV-&gt;put_int_at(info, 0, fd.access_flags().as_int());
 716   JVMCIENV-&gt;put_int_at(info, 1, fd.offset());
 717   JVMCIENV-&gt;put_int_at(info, 2, fd.index());
 718   JVMCIKlassHandle handle(THREAD, fd.field_holder());
 719   JVMCIObject field_holder = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 720   return JVMCIENV-&gt;get_jobject(field_holder);
 721 C2V_END
 722 
 723 C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 724   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 725   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 726   if (klass-&gt;is_interface()) {
 727     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));
 728   }
 729   if (!method-&gt;method_holder()-&gt;is_interface()) {
 730     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));
 731   }
 732   if (!klass-&gt;is_instance_klass()) {
 733     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));
 734   }
 735   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 736     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be linked&quot;, klass-&gt;external_name()));
 737   }
 738   return LinkResolver::vtable_index_of_interface_method(klass, method);
 739 C2V_END
 740 
 741 C2V_VMENTRY_NULL(jobject, resolveMethod, (JNIEnv* env, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 742   Klass* recv_klass = JVMCIENV-&gt;asKlass(receiver_jvmci_type);
 743   Klass* caller_klass = JVMCIENV-&gt;asKlass(caller_jvmci_type);
 744   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 745 
 746   Klass* resolved     = method-&gt;method_holder();
 747   Symbol* h_name      = method-&gt;name();
 748   Symbol* h_signature = method-&gt;signature();
 749 
 750   if (MethodHandles::is_signature_polymorphic_method(method())) {
 751       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 752       return NULL;
 753   }
 754 
 755   if (method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 756       resolved == SystemDictionary::Object_klass() &amp;&amp;
 757       recv_klass-&gt;is_array_klass()) {
 758     // Resolution of the clone method on arrays always returns Object.clone even though that method
 759     // has protected access.  There&#39;s some trickery in the access checking to make this all work out
 760     // so it&#39;s necessary to pass in the array class as the resolved class to properly trigger this.
 761     // Otherwise it&#39;s impossible to resolve the array clone methods through JVMCI.  See
 762     // LinkResolver::check_method_accessability for the matching logic.
 763     resolved = recv_klass;
 764   }
 765 
 766   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
 767   Method* m = NULL;
 768   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 769   // the vtable has not been setup, and the LinkResolver will fail.
 770   if (recv_klass-&gt;is_array_klass() ||
 771       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 772     if (resolved-&gt;is_interface()) {
 773       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 774     } else {
 775       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 776     }
 777   }
 778 
 779   if (m == NULL) {
 780     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 781     return NULL;
 782   }
 783 
 784   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, m), JVMCI_CHECK_NULL);
 785   return JVMCIENV-&gt;get_jobject(result);
 786 C2V_END
 787 
 788 C2V_VMENTRY_0(jboolean, hasFinalizableSubclass,(JNIEnv* env, jobject, jobject jvmci_type))
 789   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 790   assert(klass != NULL, &quot;method must not be called for primitive types&quot;);
 791   return Dependencies::find_finalizable_subclass(klass) != NULL;
 792 C2V_END
 793 
 794 C2V_VMENTRY_NULL(jobject, getClassInitializer, (JNIEnv* env, jobject, jobject jvmci_type))
 795   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 796   if (!klass-&gt;is_instance_klass()) {
 797     return NULL;
 798   }
 799   InstanceKlass* iklass = InstanceKlass::cast(klass);
 800   methodHandle clinit(THREAD, iklass-&gt;class_initializer());
 801   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(clinit, JVMCI_CHECK_NULL);
 802   return JVMCIENV-&gt;get_jobject(result);
 803 C2V_END
 804 
 805 C2V_VMENTRY_0(jlong, getMaxCallTargetOffset, (JNIEnv* env, jobject, jlong addr))
 806   address target_addr = (address) addr;
 807   if (target_addr != 0x0) {
 808     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 809     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 810     return MAX2(ABS(off_low), ABS(off_high));
 811   }
 812   return -1;
 813 C2V_END
 814 
 815 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject,  jobject jvmci_method))
 816   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 817   method-&gt;set_not_c1_compilable();
 818   method-&gt;set_not_c2_compilable();
 819   method-&gt;set_dont_inline(true);
 820 C2V_END
 821 
 822 C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,
 823             jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))
 824   HandleMark hm;
 825   JNIHandleMark jni_hm(thread);
 826 
 827   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 828   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 829   CodeBlob* cb = NULL;
 830   JVMCIObject installed_code_handle = JVMCIENV-&gt;wrap(installed_code);
 831   JVMCIPrimitiveArray speculations_handle = JVMCIENV-&gt;wrap(speculations_obj);
 832 
 833   int speculations_len = JVMCIENV-&gt;get_length(speculations_handle);
 834   char* speculations = NEW_RESOURCE_ARRAY(char, speculations_len);
 835   JVMCIENV-&gt;copy_bytes_to(speculations_handle, (jbyte*) speculations, 0, speculations_len);
 836 
 837   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
 838 
 839   TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
 840   bool is_immutable_PIC = JVMCIENV-&gt;get_HotSpotCompiledCode_isImmutablePIC(compiled_code_handle) &gt; 0;
 841 
 842   CodeInstaller installer(JVMCIENV, is_immutable_PIC);
 843   JVMCI::CodeInstallResult result = installer.install(compiler,
 844       target_handle,
 845       compiled_code_handle,
 846       cb,
 847       installed_code_handle,
 848       (FailedSpeculation**)(address) failed_speculations_address,
 849       speculations,
 850       speculations_len,
 851       JVMCI_CHECK_0);
 852 
 853   if (PrintCodeCacheOnCompilation) {
 854     stringStream s;
 855     // Dump code cache into a buffer before locking the tty,
 856     {
 857       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 858       CodeCache::print_summary(&amp;s, false);
 859     }
 860     ttyLocker ttyl;
 861     tty-&gt;print_raw_cr(s.as_string());
 862   }
 863 
 864   if (result != JVMCI::ok) {
 865     assert(cb == NULL, &quot;should be&quot;);
 866   } else {
 867     if (installed_code_handle.is_non_null()) {
 868       if (cb-&gt;is_nmethod()) {
 869         assert(JVMCIENV-&gt;isa_HotSpotNmethod(installed_code_handle), &quot;wrong type&quot;);
 870         // Clear the link to an old nmethod first
 871         JVMCIObject nmethod_mirror = installed_code_handle;
 872         JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK_0);
 873       } else {
 874         assert(JVMCIENV-&gt;isa_InstalledCode(installed_code_handle), &quot;wrong type&quot;);
 875       }
 876       // Initialize the link to the new code blob
 877       JVMCIENV-&gt;initialize_installed_code(installed_code_handle, cb, JVMCI_CHECK_0);
 878     }
 879   }
 880   return result;
 881 C2V_END
 882 
 883 C2V_VMENTRY_0(jint, getMetadata, (JNIEnv *env, jobject, jobject target, jobject compiled_code, jobject metadata))
 884 #if INCLUDE_AOT
 885   HandleMark hm;
 886   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);
 887 
 888   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 889   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 890   JVMCIObject metadata_handle = JVMCIENV-&gt;wrap(metadata);
 891 
 892   CodeMetadata code_metadata;
 893 
 894   CodeInstaller installer(JVMCIENV, true /* immutable PIC compilation */);
 895   JVMCI::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, JVMCI_CHECK_0);
 896   if (result != JVMCI::ok) {
 897     return result;
 898   }
 899 
 900   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 901     int size = sizeof(PcDesc) * code_metadata.get_nr_pc_desc();
 902     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 903     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_pc_desc(), array, 0, size);
 904     HotSpotJVMCI::HotSpotMetaData::set_pcDescBytes(JVMCIENV, metadata_handle, array);
 905   }
 906 
 907   if (code_metadata.get_scopes_size() &gt; 0) {
 908     int size = code_metadata.get_scopes_size();
 909     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 910     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_scopes_desc(), array, 0, size);
 911     HotSpotJVMCI::HotSpotMetaData::set_scopesDescBytes(JVMCIENV, metadata_handle, array);
 912   }
 913 
 914   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 915   int size = (int) reloc_buffer-&gt;size();
 916   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 917   JVMCIENV-&gt;copy_bytes_from((jbyte*) reloc_buffer-&gt;begin(), array, 0, size);
 918   HotSpotJVMCI::HotSpotMetaData::set_relocBytes(JVMCIENV, metadata_handle, array);
 919 
 920   const OopMapSet* oopMapSet = installer.oopMapSet();
 921   {
 922     ResourceMark mark;
 923     ImmutableOopMapBuilder builder(oopMapSet);
 924     int size = builder.heap_size();
 925     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 926     builder.generate_into((address) HotSpotJVMCI::resolve(array)-&gt;byte_at_addr(0));
 927     HotSpotJVMCI::HotSpotMetaData::set_oopMaps(JVMCIENV, metadata_handle, array);
 928   }
 929 
 930   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
 931 
 932   int nr_meta_refs = recorder-&gt;nr_meta_refs();
 933   JVMCIObjectArray metadataArray = JVMCIENV-&gt;new_Object_array(nr_meta_refs, JVMCI_CHECK_(JVMCI::cache_full));
 934   for (int i = 0; i &lt; nr_meta_refs; ++i) {
 935     jobject element = recorder-&gt;meta_element(i);
 936     if (element == NULL) {
 937       return JVMCI::cache_full;
 938     }
 939     JVMCIENV-&gt;put_object_at(metadataArray, i, JVMCIENV-&gt;wrap(element));
 940   }
 941   HotSpotJVMCI::HotSpotMetaData::set_metadata(JVMCIENV, metadata_handle, metadataArray);
 942 
 943   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 944   int table_size = handler-&gt;size_in_bytes();
 945   JVMCIPrimitiveArray exceptionArray = JVMCIENV-&gt;new_byteArray(table_size, JVMCI_CHECK_(JVMCI::cache_full));
 946   if (table_size &gt; 0) {
 947     handler-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(exceptionArray)-&gt;byte_at_addr(0));
 948   }
 949   HotSpotJVMCI::HotSpotMetaData::set_exceptionBytes(JVMCIENV, metadata_handle, exceptionArray);
 950 
 951   ImplicitExceptionTable* implicit = code_metadata.get_implicit_exception_table();
 952   int implicit_table_size = implicit-&gt;size_in_bytes();
 953   JVMCIPrimitiveArray implicitExceptionArray = JVMCIENV-&gt;new_byteArray(implicit_table_size, JVMCI_CHECK_(JVMCI::cache_full));
 954   if (implicit_table_size &gt; 0) {
 955     implicit-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(implicitExceptionArray)-&gt;byte_at_addr(0), implicit_table_size);
 956   }
 957   HotSpotJVMCI::HotSpotMetaData::set_implicitExceptionBytes(JVMCIENV, metadata_handle, implicitExceptionArray);
 958 
 959   return result;
 960 #else
 961   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);
 962 #endif
 963 C2V_END
 964 
 965 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv* env, jobject))
 966   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
 967   CompilerStatistics* stats = compiler-&gt;stats();
 968   stats-&gt;_standard.reset();
 969   stats-&gt;_osr.reset();
 970 C2V_END
 971 
 972 C2V_VMENTRY_NULL(jobject, disassembleCodeBlob, (JNIEnv* env, jobject, jobject installedCode))
 973   HandleMark hm;
 974 
 975   if (installedCode == NULL) {
 976     JVMCI_THROW_MSG_NULL(NullPointerException, &quot;installedCode is null&quot;);
 977   }
 978 
 979   JVMCIObject installedCodeObject = JVMCIENV-&gt;wrap(installedCode);
 980   nmethodLocker locker;
 981   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(installedCodeObject, locker);
 982   if (cb == NULL) {
 983     return NULL;
 984   }
 985 
 986   // We don&#39;t want the stringStream buffer to resize during disassembly as it
 987   // uses scoped resource memory. If a nested function called during disassembly uses
 988   // a ResourceMark and the buffer expands within the scope of the mark,
 989   // the buffer becomes garbage when that scope is exited. Experience shows that
 990   // the disassembled code is typically about 10x the code size so a fixed buffer
 991   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 992   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 993   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 994   stringStream st(buffer, bufferSize);
 995   if (cb-&gt;is_nmethod()) {
 996     nmethod* nm = (nmethod*) cb;
 997     if (!nm-&gt;is_alive()) {
 998       return NULL;
 999     }
1000   }
1001   Disassembler::decode(cb, &amp;st);
1002   if (st.size() &lt;= 0) {
1003     return NULL;
1004   }
1005 
1006   JVMCIObject result = JVMCIENV-&gt;create_string(st.as_string(), JVMCI_CHECK_NULL);
1007   return JVMCIENV-&gt;get_jobject(result);
1008 C2V_END
1009 
1010 C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))
1011   HandleMark hm;
1012 
1013   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1014   JVMCIObject element = JVMCIENV-&gt;new_StackTraceElement(method, bci, JVMCI_CHECK_NULL);
1015   return JVMCIENV-&gt;get_jobject(element);
1016 C2V_END
1017 
1018 C2V_VMENTRY_NULL(jobject, executeHotSpotNmethod, (JNIEnv* env, jobject, jobject args, jobject hs_nmethod))
1019   // The incoming arguments array would have to contain JavaConstants instead of regular objects
1020   // and the return value would have to be wrapped as a JavaConstant.
1021   requireInHotSpot(&quot;executeHotSpotNmethod&quot;, JVMCI_CHECK_NULL);
1022 
1023   HandleMark hm;
1024 
1025   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1026   nmethodLocker locker;
1027   nmethod* nm = JVMCIENV-&gt;get_nmethod(nmethod_mirror, locker);
1028   if (nm == NULL || !nm-&gt;is_in_use()) {
1029     JVMCI_THROW_NULL(InvalidInstalledCodeException);
1030   }
1031   methodHandle mh(THREAD, nm-&gt;method());
1032   Symbol* signature = mh-&gt;signature();
1033   JavaCallArguments jca(mh-&gt;size_of_parameters());
1034 
1035   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1036   JavaValue result(jap.return_type());
1037   jca.set_alternative_target(Handle(THREAD, JNIHandles::resolve(nmethod_mirror.as_jobject())));
1038   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1039 
1040   if (jap.return_type() == T_VOID) {
1041     return NULL;
1042   } else if (is_reference_type(jap.return_type())) {
1043     return JNIHandles::make_local((oop) result.get_jobject());
1044   } else {
1045     jvalue *value = (jvalue *) result.get_value_addr();
1046     // Narrow the value down if required (Important on big endian machines)
1047     switch (jap.return_type()) {
1048       case T_BOOLEAN:
1049        value-&gt;z = (jboolean) value-&gt;i;
1050        break;
1051       case T_BYTE:
1052        value-&gt;b = (jbyte) value-&gt;i;
1053        break;
1054       case T_CHAR:
1055        value-&gt;c = (jchar) value-&gt;i;
1056        break;
1057       case T_SHORT:
1058        value-&gt;s = (jshort) value-&gt;i;
1059        break;
1060       default:
1061         break;
1062     }
1063     JVMCIObject o = JVMCIENV-&gt;create_box(jap.return_type(), value, JVMCI_CHECK_NULL);
1064     return JVMCIENV-&gt;get_jobject(o);
1065   }
1066 C2V_END
1067 
1068 C2V_VMENTRY_NULL(jlongArray, getLineNumberTable, (JNIEnv* env, jobject, jobject jvmci_method))
1069   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1070   if (!method-&gt;has_linenumber_table()) {
1071     return NULL;
1072   }
1073   u2 num_entries = 0;
1074   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1075   while (streamForSize.read_pair()) {
1076     num_entries++;
1077   }
1078 
1079   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1080   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(2 * num_entries, JVMCI_CHECK_NULL);
1081 
1082   int i = 0;
1083   jlong value;
1084   while (stream.read_pair()) {
1085     value = ((long) stream.bci());
1086     JVMCIENV-&gt;put_long_at(result, i, value);
1087     value = ((long) stream.line());
1088     JVMCIENV-&gt;put_long_at(result, i + 1, value);
1089     i += 2;
1090   }
1091 
1092   return (jlongArray) JVMCIENV-&gt;get_jobject(result);
1093 C2V_END
1094 
1095 C2V_VMENTRY_0(jlong, getLocalVariableTableStart, (JNIEnv* env, jobject, jobject jvmci_method))
1096   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1097   if (!method-&gt;has_localvariable_table()) {
1098     return 0;
1099   }
1100   return (jlong) (address) method-&gt;localvariable_table_start();
1101 C2V_END
1102 
1103 C2V_VMENTRY_0(jint, getLocalVariableTableLength, (JNIEnv* env, jobject, jobject jvmci_method))
1104   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1105   return method-&gt;localvariable_table_length();
1106 C2V_END
1107 
1108 C2V_VMENTRY(void, reprofile, (JNIEnv* env, jobject, jobject jvmci_method))
1109   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1110   MethodCounters* mcs = method-&gt;method_counters();
1111   if (mcs != NULL) {
1112     mcs-&gt;clear_counters();
1113   }
1114   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1115 
1116   CompiledMethod* code = method-&gt;code();
1117   if (code != NULL) {
1118     code-&gt;make_not_entrant();
1119   }
1120 
1121   MethodData* method_data = method-&gt;method_data();
1122   if (method_data == NULL) {
1123     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1124     method_data = MethodData::allocate(loader_data, method, CHECK);
1125     method-&gt;set_method_data(method_data);
1126   } else {
1127     method_data-&gt;initialize();
1128   }
1129 C2V_END
1130 
1131 
1132 C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod))
1133   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1134   JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK);
1135 C2V_END
1136 
1137 C2V_VMENTRY_NULL(jobject, readUncompressedOop, (JNIEnv* env, jobject, jlong addr))
1138   oop ret = RawAccess&lt;&gt;::oop_load((oop*)(address)addr);
1139   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(ret));
1140  C2V_END
1141 
1142 C2V_VMENTRY_NULL(jlongArray, collectCounters, (JNIEnv* env, jobject))
1143   // Returns a zero length array if counters aren&#39;t enabled
1144   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_longArray(JVMCICounterSize, JVMCI_CHECK_NULL);
1145   if (JVMCICounterSize &gt; 0) {
1146     jlong* temp_array = NEW_RESOURCE_ARRAY(jlong, JVMCICounterSize);
1147     JavaThread::collect_counters(temp_array, JVMCICounterSize);
1148     JVMCIENV-&gt;copy_longs_from(temp_array, array, 0, JVMCICounterSize);
1149   }
1150   return (jlongArray) JVMCIENV-&gt;get_jobject(array);
1151 C2V_END
1152 
1153 C2V_VMENTRY_0(jint, getCountersSize, (JNIEnv* env, jobject))
1154   return (jint) JVMCICounterSize;
1155 C2V_END
1156 
1157 C2V_VMENTRY(void, setCountersSize, (JNIEnv* env, jobject, jint new_size))
1158   JavaThread::resize_all_jvmci_counters(new_size);
1159 C2V_END
1160 
1161 C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))
1162   HandleMark hm;
1163   if (jvmci_method == NULL) {
1164     JVMCI_THROW_0(NullPointerException);
1165   }
1166   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1167   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1168     JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Unexpected bci %d&quot;, entry_bci));
1169   }
1170   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1171 C2V_END
1172 
1173 
1174 C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong metaspace_method_data))
1175   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1176   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1177 C2V_END
1178 
1179 C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1180   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1181   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1182 C2V_END
1183 
1184 C2V_VMENTRY_NULL(jobject, getSymbol, (JNIEnv* env, jobject, jlong symbol))
1185   JVMCIObject sym = JVMCIENV-&gt;create_string((Symbol*)(address)symbol, JVMCI_CHECK_NULL);
1186   return JVMCIENV-&gt;get_jobject(sym);
1187 C2V_END
1188 
1189 bool matches(jobjectArray methods, Method* method, JVMCIEnv* JVMCIENV) {
1190   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1191 
1192   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1193     oop resolved = methods_oop-&gt;obj_at(i);
1194     if ((resolved-&gt;klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; HotSpotJVMCI::asMethod(JVMCIENV, resolved) == method) {
1195       return true;
1196     }
1197   }
1198   return false;
1199 }
1200 
1201 void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
1202   CallInfo callinfo;
1203   Handle receiver = args-&gt;receiver();
1204   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
1205   LinkInfo link_info(spec_klass, name, signature);
1206   LinkResolver::resolve_interface_call(
1207           callinfo, receiver, recvrKlass, link_info, true, CHECK);
1208   methodHandle method(THREAD, callinfo.selected_method());
1209   assert(method.not_null(), &quot;should have thrown exception&quot;);
1210 
1211   // Invoke the method
1212   JavaCalls::call(result, method, args, CHECK);
1213 }
1214 
1215 C2V_VMENTRY_NULL(jobject, iterateFrames, (JNIEnv* env, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jobject visitor_handle))
1216 
1217   if (!thread-&gt;has_last_Java_frame()) {
1218     return NULL;
1219   }
1220   Handle visitor(THREAD, JNIHandles::resolve_non_null(visitor_handle));
1221 
1222   requireInHotSpot(&quot;iterateFrames&quot;, JVMCI_CHECK_NULL);
1223 
1224   HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1225   Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1226 
1227   StackFrameStream fst(thread);
1228   jobjectArray methods = initial_methods;
1229 
1230   int frame_number = 0;
1231   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1232 
1233   while (true) {
1234     // look for the given method
1235     bool realloc_called = false;
1236     while (true) {
1237       StackValueCollection* locals = NULL;
1238       if (vf-&gt;is_compiled_frame()) {
1239         // compiled method frame
1240         compiledVFrame* cvf = compiledVFrame::cast(vf);
1241         if (methods == NULL || matches(methods, cvf-&gt;method(), JVMCIENV)) {
1242           if (initialSkip &gt; 0) {
1243             initialSkip--;
1244           } else {
1245             ScopeDesc* scope = cvf-&gt;scope();
1246             // native wrappers do not have a scope
1247             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1248               GrowableArray&lt;ScopeValue*&gt;* objects;
1249               if (!realloc_called) {
1250                 objects = scope-&gt;objects();
1251               } else {
1252                 // some object might already have been re-allocated, only reallocate the non-allocated ones
1253                 objects = new GrowableArray&lt;ScopeValue*&gt;(scope-&gt;objects()-&gt;length());
1254                 for (int i = 0; i &lt; scope-&gt;objects()-&gt;length(); i++) {
1255                   ObjectValue* sv = (ObjectValue*) scope-&gt;objects()-&gt;at(i);
1256                   if (sv-&gt;value().is_null()) {
1257                     objects-&gt;append(sv);
1258                   }
1259                 }
1260               }
1261               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);
1262               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
1263               realloc_called = true;
1264 
1265               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1266               assert(local_values != NULL, &quot;NULL locals&quot;);
1267               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1268               typeArrayHandle array(THREAD, array_oop);
1269               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1270                 ScopeValue* value = local_values-&gt;at(i);
1271                 if (value-&gt;is_object()) {
1272                   array-&gt;bool_at_put(i, true);
1273                 }
1274               }
1275               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());
1276             } else {
1277               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1278             }
1279 
1280             locals = cvf-&gt;locals();
1281             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf-&gt;bci());
1282             methodHandle mh(THREAD, cvf-&gt;method());
1283             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1284             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));
1285           }
1286         }
1287       } else if (vf-&gt;is_interpreted_frame()) {
1288         // interpreted method frame
1289         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1290         if (methods == NULL || matches(methods, ivf-&gt;method(), JVMCIENV)) {
1291           if (initialSkip &gt; 0) {
1292             initialSkip--;
1293           } else {
1294             locals = ivf-&gt;locals();
1295             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf-&gt;bci());
1296             methodHandle mh(THREAD, ivf-&gt;method());
1297             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1298             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));
1299             HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1300           }
1301         }
1302       }
1303 
1304       // locals != NULL means that we found a matching frame and result is already partially initialized
1305       if (locals != NULL) {
1306         methods = match_methods;
1307         HotSpotJVMCI::HotSpotStackFrameReference::set_compilerToVM(JVMCIENV, frame_reference(), JNIHandles::resolve(compilerToVM));
1308         HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()-&gt;sp());
1309         HotSpotJVMCI::HotSpotStackFrameReference::set_frameNumber(JVMCIENV, frame_reference(), frame_number);
1310 
1311         // initialize the locals array
1312         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1313         objArrayHandle array(THREAD, array_oop);
1314         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1315           StackValue* var = locals-&gt;at(i);
1316           if (var-&gt;type() == T_OBJECT) {
1317             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1318           }
1319         }
1320         HotSpotJVMCI::HotSpotStackFrameReference::set_locals(JVMCIENV, frame_reference(), array());
1321         HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);
1322 
1323         JavaValue result(T_OBJECT);
1324         JavaCallArguments args(visitor);
1325         args.push_oop(frame_reference);
1326         call_interface(&amp;result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &amp;args, CHECK_NULL);
1327         if (result.get_jobject() != NULL) {
1328           return JNIHandles::make_local(thread, (oop) result.get_jobject());
1329         }
1330         assert(initialSkip == 0, &quot;There should be no match before initialSkip == 0&quot;);
1331         if (HotSpotJVMCI::HotSpotStackFrameReference::objectsMaterialized(JVMCIENV, frame_reference()) == JNI_TRUE) {
1332           // the frame has been deoptimized, we need to re-synchronize the frame and vframe
1333           intptr_t* stack_pointer = (intptr_t*) HotSpotJVMCI::HotSpotStackFrameReference::stackPointer(JVMCIENV, frame_reference());
1334           fst = StackFrameStream(thread);
1335           while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1336             fst.next();
1337           }
1338           if (fst.current()-&gt;sp() != stack_pointer) {
1339             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found after deopt&quot;)
1340           }
1341           vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1342           if (!vf-&gt;is_compiled_frame()) {
1343             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)
1344           }
1345           for (int i = 0; i &lt; frame_number; i++) {
1346             if (vf-&gt;is_top()) {
1347               THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;vframe not found after deopt&quot;)
1348             }
1349             vf = vf-&gt;sender();
1350             assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1351           }
1352         }
1353         frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1354         HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1355       }
1356 
1357       if (vf-&gt;is_top()) {
1358         break;
1359       }
1360       frame_number++;
1361       vf = vf-&gt;sender();
1362     } // end of vframe loop
1363 
1364     if (fst.is_done()) {
1365       break;
1366     }
1367     fst.next();
1368     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1369     frame_number = 0;
1370   } // end of frame loop
1371 
1372   // the end was reached without finding a matching method
1373   return NULL;
1374 C2V_END
1375 
1376 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1377   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
1378   CallInfo callInfo;
1379   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1380   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1381   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1382 C2V_END
1383 
1384 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1385   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
1386   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1387   Symbol* name = cp-&gt;name_ref_at(index);
1388   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1389     CallInfo callInfo;
1390     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1391     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1392     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1393   }
1394 C2V_END
1395 
1396 C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1397   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
1398   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1399   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1400     // MethodHandle.invoke* --&gt; LambdaForm?
1401     ResourceMark rm;
1402 
1403     LinkInfo link_info(cp, index, CATCH);
1404 
1405     Klass* resolved_klass = link_info.resolved_klass();
1406 
1407     Symbol* name_sym = cp-&gt;name_ref_at(index);
1408 
1409     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), &quot;!&quot;);
1410     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), &quot;!&quot;);
1411 
1412     methodHandle adapter_method(THREAD, cp_cache_entry-&gt;f1_as_method());
1413 
1414     methodHandle resolved_method(adapter_method);
1415 
1416     // Can we treat it as a regular invokevirtual?
1417     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1418       vmassert(!resolved_method-&gt;is_static(),&quot;!&quot;);
1419       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),&quot;!&quot;);
1420       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), &quot;!&quot;);
1421       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, &quot;!&quot;);
1422 
1423       methodHandle m(THREAD, LinkResolver::linktime_resolve_virtual_method_or_null(link_info));
1424       vmassert(m == resolved_method, &quot;!!&quot;);
1425       return -1;
1426     }
1427 
1428     return Bytecodes::_invokevirtual;
1429   }
1430   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1431     return Bytecodes::_invokedynamic;
1432   }
1433   return -1;
1434 C2V_END
1435 
1436 
1437 C2V_VMENTRY_NULL(jobject, getSignaturePolymorphicHolders, (JNIEnv* env, jobject))
1438   JVMCIObjectArray holders = JVMCIENV-&gt;new_String_array(2, JVMCI_CHECK_NULL);
1439   JVMCIObject mh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/MethodHandle;&quot;, JVMCI_CHECK_NULL);
1440   JVMCIObject vh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/VarHandle;&quot;, JVMCI_CHECK_NULL);
1441   JVMCIENV-&gt;put_object_at(holders, 0, mh);
1442   JVMCIENV-&gt;put_object_at(holders, 1, vh);
1443   return JVMCIENV-&gt;get_jobject(holders);
1444 C2V_END
1445 
1446 C2V_VMENTRY_0(jboolean, shouldDebugNonSafepoints, (JNIEnv* env, jobject))
1447   //see compute_recording_non_safepoints in debugInfroRec.cpp
1448   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1449     return true;
1450   }
1451   return DebugNonSafepoints;
1452 C2V_END
1453 
1454 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1455 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv* env, jobject, jobject _hs_frame, bool invalidate))
1456   JVMCIObject hs_frame = JVMCIENV-&gt;wrap(_hs_frame);
1457   if (hs_frame.is_null()) {
1458     JVMCI_THROW_MSG(NullPointerException, &quot;stack frame is null&quot;);
1459   }
1460 
1461   requireInHotSpot(&quot;materializeVirtualObjects&quot;, JVMCI_CHECK);
1462 
1463   JVMCIENV-&gt;HotSpotStackFrameReference_initialize(JVMCI_CHECK);
1464 
1465   // look for the given stack frame
1466   StackFrameStream fst(thread, false);
1467   intptr_t* stack_pointer = (intptr_t*) JVMCIENV-&gt;get_HotSpotStackFrameReference_stackPointer(hs_frame);
1468   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1469     fst.next();
1470   }
1471   if (fst.current()-&gt;sp() != stack_pointer) {
1472     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found&quot;);
1473   }
1474 
1475   if (invalidate) {
1476     if (!fst.current()-&gt;is_compiled_frame()) {
1477       JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);
1478     }
1479     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), &quot;nmethod expected&quot;);
1480     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1481   }
1482   Deoptimization::deoptimize(thread, *fst.current(), Deoptimization::Reason_none);
1483   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1484   StackFrameStream fstAfterDeopt(thread);
1485   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1486     fstAfterDeopt.next();
1487   }
1488   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1489     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found after deopt&quot;);
1490   }
1491 
1492   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1493   if (!vf-&gt;is_compiled_frame()) {
1494     JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);
1495   }
1496 
1497   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1498   while (true) {
1499     assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1500     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1501     if (vf-&gt;is_top()) {
1502       break;
1503     }
1504     vf = vf-&gt;sender();
1505   }
1506 
1507   int last_frame_number = JVMCIENV-&gt;get_HotSpotStackFrameReference_frameNumber(hs_frame);
1508   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1509     JVMCI_THROW_MSG(IllegalStateException, &quot;invalid frame number&quot;);
1510   }
1511 
1512   // Reallocate the non-escaping objects and restore their fields.
1513   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
1514   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1515 
1516   if (objects == NULL) {
1517     // no objects to materialize
1518     return;
1519   }
1520 
1521   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, CHECK);
1522   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1523 
1524   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1525     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1526 
1527     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1528     StackValueCollection* locals = cvf-&gt;locals();
1529     if (locals != NULL) {
1530       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1531         StackValue* var = locals-&gt;at(i2);
1532         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1533           jvalue val;
1534           val.l = cast_from_oop&lt;jobject&gt;(locals-&gt;at(i2)-&gt;get_obj()());
1535           cvf-&gt;update_local(T_OBJECT, i2, val);
1536         }
1537       }
1538     }
1539 
1540     GrowableArray&lt;ScopeValue*&gt;* scopeExpressions = cvf-&gt;scope()-&gt;expressions();
1541     StackValueCollection* expressions = cvf-&gt;expressions();
1542     if (expressions != NULL) {
1543       for (int i2 = 0; i2 &lt; expressions-&gt;size(); i2++) {
1544         StackValue* var = expressions-&gt;at(i2);
1545         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeExpressions-&gt;at(i2)-&gt;is_object()) {
1546           jvalue val;
1547           val.l = cast_from_oop&lt;jobject&gt;(expressions-&gt;at(i2)-&gt;get_obj()());
1548           cvf-&gt;update_stack(T_OBJECT, i2, val);
1549         }
1550       }
1551     }
1552 
1553     GrowableArray&lt;MonitorValue*&gt;* scopeMonitors = cvf-&gt;scope()-&gt;monitors();
1554     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1555     if (monitors != NULL) {
1556       for (int i2 = 0; i2 &lt; monitors-&gt;length(); i2++) {
1557         cvf-&gt;update_monitor(i2, monitors-&gt;at(i2));
1558       }
1559     }
1560   }
1561 
1562   // all locals are materialized by now
1563   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1564   // update the locals array
1565   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1566   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1567   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1568     StackValue* var = locals-&gt;at(i);
1569     if (var-&gt;type() == T_OBJECT) {
1570       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1571     }
1572   }
1573   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1574 C2V_END
1575 
1576 // Creates a scope where the current thread is attached and detached
1577 // from HotSpot if it wasn&#39;t already attached when entering the scope.
1578 extern &quot;C&quot; void jio_printf(const char *fmt, ...);
1579 class AttachDetach : public StackObj {
1580  public:
1581   bool _attached;
1582   AttachDetach(JNIEnv* env, Thread* current_thread) {
1583     if (current_thread == NULL) {
1584       extern struct JavaVM_ main_vm;
1585       JNIEnv* hotspotEnv;
1586       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1587       _attached = res == JNI_OK;
1588       static volatile int report_attach_error = 0;
1589       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {
1590         // Only report an attach error once
1591         jio_printf(&quot;Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1592       }
1593     } else {
1594       _attached = false;
1595     }
1596   }
1597   ~AttachDetach() {
1598     if (_attached &amp;&amp; get_current_thread() != NULL) {
1599       extern struct JavaVM_ main_vm;
1600       jint res = main_vm.DetachCurrentThread();
1601       static volatile int report_detach_error = 0;
1602       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_detach_error, 0, 1) == 0) {
1603         // Only report an attach error once
1604         jio_printf(&quot;Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1605       }
1606     }
1607   }
1608 };
1609 
1610 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))
1611   AttachDetach ad(env, base_thread);
1612   bool use_tty = true;
1613   if (base_thread == NULL) {
1614     if (!ad._attached) {
1615       // Can only use tty if the current thread is attached
1616       return 0;
1617     }
1618     base_thread = get_current_thread();
1619   }
1620   JVMCITraceMark jtm(&quot;writeDebugOutput&quot;);
1621   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);
1622   JavaThread* thread = (JavaThread*) base_thread;
1623   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))
1624   if (bytes == NULL) {
1625     if (can_throw) {
1626       JVMCI_THROW_0(NullPointerException);
1627     }
1628     return -1;
1629   }
1630   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);
1631 
1632   // Check if offset and length are non negative.
1633   if (offset &lt; 0 || length &lt; 0) {
1634     if (can_throw) {
1635       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1636     }
1637     return -2;
1638   }
1639   // Check if the range is valid.
1640   int array_length = JVMCIENV-&gt;get_length(array);
1641   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {
1642     if (can_throw) {
1643       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1644     }
1645     return -2;
1646   }
1647   jbyte buffer[O_BUFLEN];
1648   while (length &gt; 0) {
1649     int copy_len = MIN2(length, (jint)O_BUFLEN);
1650     JVMCIENV-&gt;copy_bytes_to(array, buffer, offset, copy_len);
1651     tty-&gt;write((char*) buffer, copy_len);
1652     length -= O_BUFLEN;
1653     offset += O_BUFLEN;
1654   }
1655   if (flush) {
1656     tty-&gt;flush();
1657   }
1658   return 0;
1659 C2V_END
1660 
1661 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv* env, jobject))
1662   tty-&gt;flush();
1663 C2V_END
1664 
1665 C2V_VMENTRY_0(jint, methodDataProfileDataSize, (JNIEnv* env, jobject, jlong metaspace_method_data, jint position))
1666   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1667   ProfileData* profile_data = mdo-&gt;data_at(position);
1668   if (mdo-&gt;is_valid(profile_data)) {
1669     return profile_data-&gt;size_in_bytes();
1670   }
1671   DataLayout* data    = mdo-&gt;extra_data_base();
1672   DataLayout* end   = mdo-&gt;extra_data_limit();
1673   for (;; data = mdo-&gt;next_extra(data)) {
1674     assert(data &lt; end, &quot;moved past end of extra data&quot;);
1675     profile_data = data-&gt;data_in();
1676     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1677       return profile_data-&gt;size_in_bytes();
1678     }
1679   }
1680   JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Invalid profile data position %d&quot;, position));
1681 C2V_END
1682 
1683 C2V_VMENTRY_0(jlong, getFingerprint, (JNIEnv* env, jobject, jlong metaspace_klass))
1684 #if INCLUDE_AOT
1685   Klass *k = (Klass*) (address) metaspace_klass;
1686   if (k-&gt;is_instance_klass()) {
1687     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1688   } else {
1689     return 0;
1690   }
1691 #else
1692   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);
1693 #endif
1694 C2V_END
1695 
1696 C2V_VMENTRY_NULL(jobject, getHostClass, (JNIEnv* env, jobject, jobject jvmci_type))
1697   InstanceKlass* k = InstanceKlass::cast(JVMCIENV-&gt;asKlass(jvmci_type));
1698   InstanceKlass* host = k-&gt;unsafe_anonymous_host();
1699   JVMCIKlassHandle handle(THREAD, host);
1700   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
1701   return JVMCIENV-&gt;get_jobject(result);
1702 C2V_END
1703 
1704 C2V_VMENTRY_NULL(jobject, getInterfaces, (JNIEnv* env, jobject, jobject jvmci_type))
1705   if (jvmci_type == NULL) {
1706     JVMCI_THROW_0(NullPointerException);
1707   }
1708 
1709   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1710   if (klass == NULL) {
1711     JVMCI_THROW_0(NullPointerException);
1712   }
1713   if (!klass-&gt;is_instance_klass()) {
1714     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));
1715   }
1716   InstanceKlass* iklass = InstanceKlass::cast(klass);
1717 
1718   // Regular instance klass, fill in all local interfaces
1719   int size = iklass-&gt;local_interfaces()-&gt;length();
1720   JVMCIObjectArray interfaces = JVMCIENV-&gt;new_HotSpotResolvedObjectTypeImpl_array(size, JVMCI_CHECK_NULL);
1721   for (int index = 0; index &lt; size; index++) {
1722     JVMCIKlassHandle klass(THREAD);
1723     Klass* k = iklass-&gt;local_interfaces()-&gt;at(index);
1724     klass = k;
1725     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
1726     JVMCIENV-&gt;put_object_at(interfaces, index, type);
1727   }
1728   return JVMCIENV-&gt;get_jobject(interfaces);
1729 C2V_END
1730 
1731 C2V_VMENTRY_NULL(jobject, getComponentType, (JNIEnv* env, jobject, jobject jvmci_type))
1732   if (jvmci_type == NULL) {
1733     JVMCI_THROW_0(NullPointerException);
1734   }
1735 
1736   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1737   oop mirror = klass-&gt;java_mirror();
1738   if (java_lang_Class::is_primitive(mirror) ||
1739       !java_lang_Class::as_Klass(mirror)-&gt;is_array_klass()) {
1740     return NULL;
1741   }
1742 
1743   oop component_mirror = java_lang_Class::component_mirror(mirror);
1744   if (component_mirror == NULL) {
1745     return NULL;
1746   }
1747   Klass* component_klass = java_lang_Class::as_Klass(component_mirror);
1748   if (component_klass != NULL) {
1749     JVMCIKlassHandle klass_handle(THREAD);
1750     klass_handle = component_klass;
1751     JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);
1752     return JVMCIENV-&gt;get_jobject(result);
1753   }
1754   BasicType type = java_lang_Class::primitive_type(component_mirror);
1755   JVMCIObject result = JVMCIENV-&gt;get_jvmci_primitive_type(type);
1756   return JVMCIENV-&gt;get_jobject(result);
1757 C2V_END
1758 
1759 C2V_VMENTRY(void, ensureInitialized, (JNIEnv* env, jobject, jobject jvmci_type))
1760   if (jvmci_type == NULL) {
1761     JVMCI_THROW(NullPointerException);
1762   }
1763 
1764   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1765   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {
1766     InstanceKlass* k = InstanceKlass::cast(klass);
1767     k-&gt;initialize(CHECK);
1768   }
1769 C2V_END
1770 
1771 C2V_VMENTRY(void, ensureLinked, (JNIEnv* env, jobject, jobject jvmci_type))
1772   if (jvmci_type == NULL) {
1773     JVMCI_THROW(NullPointerException);
1774   }
1775 
1776   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1777   if (klass != NULL &amp;&amp; klass-&gt;is_instance_klass()) {
1778     InstanceKlass* k = InstanceKlass::cast(klass);
1779     k-&gt;link_class(CHECK);
1780   }
1781 C2V_END
1782 
1783 C2V_VMENTRY_0(jint, interpreterFrameSize, (JNIEnv* env, jobject, jobject bytecode_frame_handle))
1784   if (bytecode_frame_handle == NULL) {
1785     JVMCI_THROW_0(NullPointerException);
1786   }
1787 
1788   JVMCIObject top_bytecode_frame = JVMCIENV-&gt;wrap(bytecode_frame_handle);
1789   JVMCIObject bytecode_frame = top_bytecode_frame;
1790   int size = 0;
1791   int callee_parameters = 0;
1792   int callee_locals = 0;
1793   Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));
1794   int extra_args = method-&gt;max_stack() - JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);
1795 
1796   while (bytecode_frame.is_non_null()) {
1797     int locks = JVMCIENV-&gt;get_BytecodeFrame_numLocks(bytecode_frame);
1798     int temps = JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);
1799     bool is_top_frame = (JVMCIENV-&gt;equals(bytecode_frame, top_bytecode_frame));
1800     Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));
1801 
1802     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1803                                                                  temps + callee_parameters,
1804                                                                  extra_args,
1805                                                                  locks,
1806                                                                  callee_parameters,
1807                                                                  callee_locals,
1808                                                                  is_top_frame);
1809     size += frame_size;
1810 
1811     callee_parameters = method-&gt;size_of_parameters();
1812     callee_locals = method-&gt;max_locals();
1813     extra_args = 0;
1814     bytecode_frame = JVMCIENV-&gt;get_BytecodePosition_caller(bytecode_frame);
1815   }
1816   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1817 C2V_END
1818 
1819 C2V_VMENTRY(void, compileToBytecode, (JNIEnv* env, jobject, jobject lambda_form_handle))
1820   Handle lambda_form = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(lambda_form_handle), JVMCI_CHECK);
1821   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1822     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;);
1823     JavaValue result(T_VOID);
1824     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1825   } else {
1826     JVMCI_THROW_MSG(IllegalArgumentException,
1827                     err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()))
1828   }
1829 C2V_END
1830 
1831 C2V_VMENTRY_0(jint, getIdentityHashCode, (JNIEnv* env, jobject, jobject object))
1832   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1833   return obj-&gt;identity_hash();
1834 C2V_END
1835 
1836 C2V_VMENTRY_0(jboolean, isInternedString, (JNIEnv* env, jobject, jobject object))
1837   Handle str = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1838   if (!java_lang_String::is_instance(str())) {
1839     return false;
1840   }
1841   int len;
1842   jchar* name = java_lang_String::as_unicode_string(str(), len, CHECK_false);
1843   return (StringTable::lookup(name, len) != NULL);
1844 C2V_END
1845 
1846 
1847 C2V_VMENTRY_NULL(jobject, unboxPrimitive, (JNIEnv* env, jobject, jobject object))
1848   if (object == NULL) {
1849     JVMCI_THROW_0(NullPointerException);
1850   }
1851   Handle box = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
1852   BasicType type = java_lang_boxing_object::basic_type(box());
1853   jvalue result;
1854   if (java_lang_boxing_object::get_value(box(), &amp;result) == T_ILLEGAL) {
1855     return NULL;
1856   }
1857   JVMCIObject boxResult = JVMCIENV-&gt;create_box(type, &amp;result, JVMCI_CHECK_NULL);
1858   return JVMCIENV-&gt;get_jobject(boxResult);
1859 C2V_END
1860 
1861 C2V_VMENTRY_NULL(jobject, boxPrimitive, (JNIEnv* env, jobject, jobject object))
1862   if (object == NULL) {
1863     JVMCI_THROW_0(NullPointerException);
1864   }
1865   JVMCIObject box = JVMCIENV-&gt;wrap(object);
1866   BasicType type = JVMCIENV-&gt;get_box_type(box);
1867   if (type == T_ILLEGAL) {
1868     return NULL;
1869   }
1870   jvalue value = JVMCIENV-&gt;get_boxed_value(type, box);
1871   JavaValue box_result(T_OBJECT);
1872   JavaCallArguments jargs;
1873   Klass* box_klass = NULL;
1874   Symbol* box_signature = NULL;
1875 #define BOX_CASE(bt, v, argtype, name)           \
1876   case bt: \
1877     jargs.push_##argtype(value.v); \
1878     box_klass = SystemDictionary::name##_klass(); \
1879     box_signature = vmSymbols::name##_valueOf_signature(); \
1880     break
1881 
1882   switch (type) {
1883     BOX_CASE(T_BOOLEAN, z, int, Boolean);
1884     BOX_CASE(T_BYTE, b, int, Byte);
1885     BOX_CASE(T_CHAR, c, int, Character);
1886     BOX_CASE(T_SHORT, s, int, Short);
1887     BOX_CASE(T_INT, i, int, Integer);
1888     BOX_CASE(T_LONG, j, long, Long);
1889     BOX_CASE(T_FLOAT, f, float, Float);
1890     BOX_CASE(T_DOUBLE, d, double, Double);
1891     default:
1892       ShouldNotReachHere();
1893   }
1894 #undef BOX_CASE
1895 
1896   JavaCalls::call_static(&amp;box_result,
1897                          box_klass,
1898                          vmSymbols::valueOf_name(),
1899                          box_signature, &amp;jargs, CHECK_NULL);
1900   oop hotspot_box = (oop) box_result.get_jobject();
1901   JVMCIObject result = JVMCIENV-&gt;get_object_constant(hotspot_box, false);
1902   return JVMCIENV-&gt;get_jobject(result);
1903 C2V_END
1904 
1905 C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, jobject holder))
1906   if (holder == NULL) {
1907     JVMCI_THROW_0(NullPointerException);
1908   }
1909   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1910   if (!klass-&gt;is_instance_klass()) {
1911     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1912     return JVMCIENV-&gt;get_jobjectArray(methods);
1913   }
1914 
1915   InstanceKlass* iklass = InstanceKlass::cast(klass);
1916   // Ensure class is linked
1917   iklass-&gt;link_class(CHECK_NULL);
1918 
1919   GrowableArray&lt;Method*&gt; constructors_array;
1920   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1921     Method* m = iklass-&gt;methods()-&gt;at(i);
1922     if (m-&gt;is_initializer() &amp;&amp; !m-&gt;is_static()) {
1923       constructors_array.append(m);
1924     }
1925   }
1926   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(constructors_array.length(), JVMCI_CHECK_NULL);
1927   for (int i = 0; i &lt; constructors_array.length(); i++) {
1928     methodHandle ctor(THREAD, constructors_array.at(i));
1929     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(ctor, JVMCI_CHECK_NULL);
1930     JVMCIENV-&gt;put_object_at(methods, i, method);
1931   }
1932   return JVMCIENV-&gt;get_jobjectArray(methods);
1933 C2V_END
1934 
1935 C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, jobject holder))
1936   if (holder == NULL) {
1937     JVMCI_THROW_0(NullPointerException);
1938   }
1939   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1940   if (!klass-&gt;is_instance_klass()) {
1941     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1942     return JVMCIENV-&gt;get_jobjectArray(methods);
1943   }
1944 
1945   InstanceKlass* iklass = InstanceKlass::cast(klass);
1946   // Ensure class is linked
1947   iklass-&gt;link_class(CHECK_NULL);
1948 
1949   GrowableArray&lt;Method*&gt; methods_array;
1950   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1951     Method* m = iklass-&gt;methods()-&gt;at(i);
1952     if (!m-&gt;is_initializer() &amp;&amp; !m-&gt;is_overpass()) {
1953       methods_array.append(m);
1954     }
1955   }
1956   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(methods_array.length(), JVMCI_CHECK_NULL);
1957   for (int i = 0; i &lt; methods_array.length(); i++) {
1958     methodHandle mh(THREAD, methods_array.at(i));
1959     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1960     JVMCIENV-&gt;put_object_at(methods, i, method);
1961   }
1962   return JVMCIENV-&gt;get_jobjectArray(methods);
1963 C2V_END
1964 
1965 C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject field, jboolean is_volatile))
1966   if (object == NULL || field == NULL) {
1967     JVMCI_THROW_0(NullPointerException);
1968   }
1969   JVMCIObject field_object = JVMCIENV-&gt;wrap(field);
1970   JVMCIObject java_type = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_type(field_object);
1971   int modifiers = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_modifiers(field_object);
1972   Klass* holder = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_holder(field_object));
1973   if (!holder-&gt;is_instance_klass()) {
1974     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Holder %s must be instance klass&quot;, holder-&gt;external_name()));
1975   }
1976   InstanceKlass* ik = InstanceKlass::cast(holder);
1977   BasicType constant_type;
1978   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(java_type)) {
1979     constant_type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(java_type), JVMCI_CHECK_NULL);
1980   } else {
1981     constant_type = T_OBJECT;
1982   }
1983   int displacement = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_offset(field_object);
1984   fieldDescriptor fd;
1985   if (!ik-&gt;find_local_field_from_offset(displacement, (modifiers &amp; JVM_ACC_STATIC) != 0, &amp;fd)) {
1986     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Can&#39;t find field with displacement %d&quot;, displacement));
1987   }
1988   JVMCIObject base = JVMCIENV-&gt;wrap(object);
1989   Handle obj;
1990   if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base)) {
1991     obj = JVMCIENV-&gt;asConstant(base, JVMCI_CHECK_NULL);
1992   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base)) {
1993     Klass* klass = JVMCIENV-&gt;asKlass(base);
1994     obj = Handle(THREAD, klass-&gt;java_mirror());
1995   } else {
1996     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
1997                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base)));
1998   }
1999   jlong value = 0;
2000   JVMCIObject kind;
2001   switch (constant_type) {
2002     case T_OBJECT: {
2003       oop object = is_volatile ? obj-&gt;obj_field_acquire(displacement) : obj-&gt;obj_field(displacement);
2004       JVMCIObject result = JVMCIENV-&gt;get_object_constant(object);
2005       if (result.is_null()) {
2006         return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_JavaConstant_NULL_POINTER());
2007       }
2008       return JVMCIENV-&gt;get_jobject(result);
2009     }
2010     case T_FLOAT: {
2011       float f = is_volatile ? obj-&gt;float_field_acquire(displacement) : obj-&gt;float_field(displacement);
2012       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forFloat(f, JVMCI_CHECK_NULL);
2013       return JVMCIENV-&gt;get_jobject(result);
2014     }
2015     case T_DOUBLE: {
2016       double f = is_volatile ? obj-&gt;double_field_acquire(displacement) : obj-&gt;double_field(displacement);
2017       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forDouble(f, JVMCI_CHECK_NULL);
2018       return JVMCIENV-&gt;get_jobject(result);
2019     }
2020     case T_BOOLEAN: value = is_volatile ? obj-&gt;bool_field_acquire(displacement) : obj-&gt;bool_field(displacement); break;
2021     case T_BYTE: value = is_volatile ? obj-&gt;byte_field_acquire(displacement) : obj-&gt;byte_field(displacement); break;
2022     case T_SHORT: value = is_volatile ? obj-&gt;short_field_acquire(displacement) : obj-&gt;short_field(displacement); break;
2023     case T_CHAR: value = is_volatile ? obj-&gt;char_field_acquire(displacement) : obj-&gt;char_field(displacement); break;
2024     case T_INT: value = is_volatile ? obj-&gt;int_field_acquire(displacement) : obj-&gt;int_field(displacement); break;
2025     case T_LONG: value = is_volatile ? obj-&gt;long_field_acquire(displacement) : obj-&gt;long_field(displacement); break;
2026     default:
2027       ShouldNotReachHere();
2028   }
2029   JVMCIObject result = JVMCIENV-&gt;call_PrimitiveConstant_forTypeChar(type2char(constant_type), value, JVMCI_CHECK_NULL);
2030   return JVMCIENV-&gt;get_jobject(result);
2031 C2V_END
2032 
2033 C2V_VMENTRY_0(jboolean, isInstance, (JNIEnv* env, jobject, jobject holder, jobject object))
2034   if (object == NULL || holder == NULL) {
2035     JVMCI_THROW_0(NullPointerException);
2036   }
2037   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
2038   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));
2039   return obj-&gt;is_a(klass);
2040 C2V_END
2041 
2042 C2V_VMENTRY_0(jboolean, isAssignableFrom, (JNIEnv* env, jobject, jobject holder, jobject otherHolder))
2043   if (holder == NULL || otherHolder == NULL) {
2044     JVMCI_THROW_0(NullPointerException);
2045   }
2046   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));
2047   Klass* otherKlass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(otherHolder));
2048   return otherKlass-&gt;is_subtype_of(klass);
2049 C2V_END
2050 
2051 C2V_VMENTRY_0(jboolean, isTrustedForIntrinsics, (JNIEnv* env, jobject, jobject holder))
2052   if (holder == NULL) {
2053     JVMCI_THROW_0(NullPointerException);
2054   }
2055   InstanceKlass* ik = InstanceKlass::cast(JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder)));
2056   if (ik-&gt;class_loader_data()-&gt;is_boot_class_loader_data() || ik-&gt;class_loader_data()-&gt;is_platform_class_loader_data()) {
2057     return true;
2058   }
2059   return false;
2060 C2V_END
2061 
2062 C2V_VMENTRY_NULL(jobject, asJavaType, (JNIEnv* env, jobject, jobject object))
2063   if (object == NULL) {
2064     JVMCI_THROW_0(NullPointerException);
2065   }
2066   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
2067   if (java_lang_Class::is_instance(obj())) {
2068     if (java_lang_Class::is_primitive(obj())) {
2069       JVMCIObject type = JVMCIENV-&gt;get_jvmci_primitive_type(java_lang_Class::primitive_type(obj()));
2070       return JVMCIENV-&gt;get_jobject(type);
2071     }
2072     Klass* klass = java_lang_Class::as_Klass(obj());
2073     JVMCIKlassHandle klass_handle(THREAD);
2074     klass_handle = klass;
2075     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);
2076     return JVMCIENV-&gt;get_jobject(type);
2077   }
2078   return NULL;
2079 C2V_END
2080 
2081 
2082 C2V_VMENTRY_NULL(jobject, asString, (JNIEnv* env, jobject, jobject object))
2083   if (object == NULL) {
2084     JVMCI_THROW_0(NullPointerException);
2085   }
2086   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
2087   const char* str = java_lang_String::as_utf8_string(obj());
2088   JVMCIObject result = JVMCIENV-&gt;create_string(str, JVMCI_CHECK_NULL);
2089   return JVMCIENV-&gt;get_jobject(result);
2090 C2V_END
2091 
2092 
2093 C2V_VMENTRY_0(jboolean, equals, (JNIEnv* env, jobject, jobject x, jlong xHandle, jobject y, jlong yHandle))
2094   if (x == NULL || y == NULL) {
2095     JVMCI_THROW_0(NullPointerException);
2096   }
2097   return JVMCIENV-&gt;resolve_handle(xHandle) == JVMCIENV-&gt;resolve_handle(yHandle);
2098 C2V_END
2099 
2100 C2V_VMENTRY_NULL(jobject, getJavaMirror, (JNIEnv* env, jobject, jobject object))
2101   if (object == NULL) {
2102     JVMCI_THROW_0(NullPointerException);
2103   }
2104   JVMCIObject base_object = JVMCIENV-&gt;wrap(object);
2105   Handle mirror;
2106   if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {
2107     mirror = Handle(THREAD, JVMCIENV-&gt;asKlass(base_object)-&gt;java_mirror());
2108   } else if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(base_object)) {
2109     mirror = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_mirror(base_object), JVMCI_CHECK_NULL);
2110   } else {
2111     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2112                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));
2113  }
2114   JVMCIObject result = JVMCIENV-&gt;get_object_constant(mirror());
2115   return JVMCIENV-&gt;get_jobject(result);
2116 C2V_END
2117 
2118 
2119 C2V_VMENTRY_0(jint, getArrayLength, (JNIEnv* env, jobject, jobject x))
2120   if (x == NULL) {
2121     JVMCI_THROW_0(NullPointerException);
2122   }
2123   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2124   if (xobj-&gt;klass()-&gt;is_array_klass()) {
2125     return arrayOop(xobj())-&gt;length();
2126   }
2127   return -1;
2128  C2V_END
2129 
2130 
2131 C2V_VMENTRY_NULL(jobject, readArrayElement, (JNIEnv* env, jobject, jobject x, int index))
2132   if (x == NULL) {
2133     JVMCI_THROW_0(NullPointerException);
2134   }
2135   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_NULL);
2136   if (xobj-&gt;klass()-&gt;is_array_klass()) {
2137     arrayOop array = arrayOop(xobj());
2138     BasicType element_type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
2139     if (index &lt; 0 || index &gt;= array-&gt;length()) {
2140       return NULL;
2141     }
2142     JVMCIObject result;
2143 
2144     if (element_type == T_OBJECT) {
2145       result = JVMCIENV-&gt;get_object_constant(objArrayOop(xobj())-&gt;obj_at(index));
2146       if (result.is_null()) {
2147         result = JVMCIENV-&gt;get_JavaConstant_NULL_POINTER();
2148       }
2149     } else {
2150       jvalue value;
2151       switch (element_type) {
2152         case T_DOUBLE:        value.d = typeArrayOop(xobj())-&gt;double_at(index);        break;
2153         case T_FLOAT:         value.f = typeArrayOop(xobj())-&gt;float_at(index);         break;
2154         case T_LONG:          value.j = typeArrayOop(xobj())-&gt;long_at(index);          break;
2155         case T_INT:           value.i = typeArrayOop(xobj())-&gt;int_at(index);            break;
2156         case T_SHORT:         value.s = typeArrayOop(xobj())-&gt;short_at(index);          break;
2157         case T_CHAR:          value.c = typeArrayOop(xobj())-&gt;char_at(index);           break;
2158         case T_BYTE:          value.b = typeArrayOop(xobj())-&gt;byte_at(index);           break;
2159         case T_BOOLEAN:       value.z = typeArrayOop(xobj())-&gt;byte_at(index) &amp; 1;       break;
2160         default:              ShouldNotReachHere();
2161       }
2162       result = JVMCIENV-&gt;create_box(element_type, &amp;value, JVMCI_CHECK_NULL);
2163     }
2164     assert(!result.is_null(), &quot;must have a value&quot;);
2165     return JVMCIENV-&gt;get_jobject(result);
2166   }
2167   return NULL;;
2168 C2V_END
2169 
2170 
2171 C2V_VMENTRY_0(jint, arrayBaseOffset, (JNIEnv* env, jobject, jobject kind))
2172   if (kind == NULL) {
2173     JVMCI_THROW_0(NullPointerException);
2174   }
2175   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);
2176   return arrayOopDesc::header_size(type) * HeapWordSize;
2177 C2V_END
2178 
2179 C2V_VMENTRY_0(jint, arrayIndexScale, (JNIEnv* env, jobject, jobject kind))
2180   if (kind == NULL) {
2181     JVMCI_THROW_0(NullPointerException);
2182   }
2183   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);
2184   return type2aelembytes(type);
2185 C2V_END
2186 
2187 C2V_VMENTRY_0(jbyte, getByte, (JNIEnv* env, jobject, jobject x, long displacement))
2188   if (x == NULL) {
2189     JVMCI_THROW_0(NullPointerException);
2190   }
2191   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2192   return xobj-&gt;byte_field(displacement);
2193 }
2194 
2195 C2V_VMENTRY_0(jshort, getShort, (JNIEnv* env, jobject, jobject x, long displacement))
2196   if (x == NULL) {
2197     JVMCI_THROW_0(NullPointerException);
2198   }
2199   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2200   return xobj-&gt;short_field(displacement);
2201 }
2202 
2203 C2V_VMENTRY_0(jint, getInt, (JNIEnv* env, jobject, jobject x, long displacement))
2204   if (x == NULL) {
2205     JVMCI_THROW_0(NullPointerException);
2206   }
2207   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2208   return xobj-&gt;int_field(displacement);
2209 }
2210 
2211 C2V_VMENTRY_0(jlong, getLong, (JNIEnv* env, jobject, jobject x, long displacement))
2212   if (x == NULL) {
2213     JVMCI_THROW_0(NullPointerException);
2214   }
2215   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2216   return xobj-&gt;long_field(displacement);
2217 }
2218 
2219 C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))
2220   if (x == NULL) {
2221     JVMCI_THROW_0(NullPointerException);
2222   }
2223   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2224   oop res = xobj-&gt;obj_field(displacement);
2225   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);
2226   return JVMCIENV-&gt;get_jobject(result);
2227 }
2228 
2229 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))
2230   jobject handle = (jobject)(address)h;
2231   if (handle != NULL) {
2232     JVMCI::destroy_global(handle);
2233   }
2234 }
2235 
2236 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2237   if (!UseJVMCINativeLibrary) {
2238     JVMCI_THROW_MSG(UnsupportedOperationException, &quot;JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)&quot;);
2239   }
2240 }
2241 
2242 static JavaVM* requireNativeLibraryJavaVM(const char* caller, JVMCI_TRAPS) {
2243   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
2244   if (javaVM == NULL) {
2245     JVMCI_THROW_MSG_NULL(IllegalStateException, err_msg(&quot;Require JVMCI shared library to be initialized in %s&quot;, caller));
2246   }
2247   return javaVM;
2248 }
2249 
2250 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2251   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2252   requireInHotSpot(&quot;registerNativeMethods&quot;, JVMCI_CHECK_NULL);
2253   void* shared_library = JVMCIEnv::get_shared_library_handle();
2254   if (shared_library == NULL) {
2255     // Ensure the JVMCI shared library runtime is initialized.
2256     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2257     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2258     HandleMark hm;
2259     JVMCIRuntime* runtime = JVMCI::compiler_runtime();
2260     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2261     if (peerEnv-&gt;has_pending_exception()) {
2262       peerEnv-&gt;describe_pending_exception(true);
2263     }
2264     shared_library = JVMCIEnv::get_shared_library_handle();
2265     if (shared_library == NULL) {
2266       JVMCI_THROW_MSG_0(InternalError, &quot;Error initializing JVMCI runtime&quot;);
2267     }
2268   }
2269 
2270   if (mirror == NULL) {
2271     JVMCI_THROW_0(NullPointerException);
2272   }
2273   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2274   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2275     JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;clazz is for primitive type&quot;);
2276   }
2277 
2278   InstanceKlass* iklass = InstanceKlass::cast(klass);
2279   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
2280     methodHandle method(THREAD, iklass-&gt;methods()-&gt;at(i));
2281     if (method-&gt;is_native()) {
2282 
2283       // Compute argument size
2284       int args_size = 1                             // JNIEnv
2285                     + (method-&gt;is_static() ? 1 : 0) // class for static methods
2286                     + method-&gt;size_of_parameters(); // actual parameters
2287 
2288       // 1) Try JNI short style
2289       stringStream st;
2290       char* pure_name = NativeLookup::pure_jni_name(method);
2291       os::print_jni_name_prefix_on(&amp;st, args_size);
2292       st.print_raw(pure_name);
2293       os::print_jni_name_suffix_on(&amp;st, args_size);
2294       char* jni_name = st.as_string();
2295 
2296       address entry = (address) os::dll_lookup(shared_library, jni_name);
2297       if (entry == NULL) {
2298         // 2) Try JNI long style
2299         st.reset();
2300         char* long_name = NativeLookup::long_jni_name(method);
2301         os::print_jni_name_prefix_on(&amp;st, args_size);
2302         st.print_raw(pure_name);
2303         st.print_raw(long_name);
2304         os::print_jni_name_suffix_on(&amp;st, args_size);
2305         char* jni_long_name = st.as_string();
2306         entry = (address) os::dll_lookup(shared_library, jni_long_name);
2307         if (entry == NULL) {
2308           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [neither %s nor %s exist in %s]&quot;,
2309               method-&gt;name_and_sig_as_C_string(),
2310               jni_name, jni_long_name, JVMCIEnv::get_shared_library_path()));
2311         }
2312       }
2313 
2314       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {
2315         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [cannot re-link from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot;]&quot;,
2316             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));
2317       }
2318       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);
2319       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,
2320                               method-&gt;method_holder()-&gt;external_name(),
2321                               method-&gt;name()-&gt;as_C_string());
2322     }
2323   }
2324 
2325   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
2326   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(4, JVMCI_CHECK_NULL);
2327   JVMCIENV-&gt;put_long_at(result, 0, (jlong) (address) javaVM);
2328   JVMCIENV-&gt;put_long_at(result, 1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);
2329   JVMCIENV-&gt;put_long_at(result, 2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);
2330   JVMCIENV-&gt;put_long_at(result, 3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);
2331   return (jlongArray) JVMCIENV-&gt;get_jobject(result);
2332 }
2333 
2334 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))
2335   if (base_thread == NULL) {
2336     // Called from unattached JVMCI shared library thread
2337     return false;
2338   }
2339   JVMCITraceMark jtm(&quot;isCurrentThreadAttached&quot;);
2340   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);
2341   JavaThread* thread = (JavaThread*) base_thread;
2342   if (thread-&gt;jni_environment() == env) {
2343     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))
2344     requireJVMCINativeLibrary(JVMCI_CHECK_0);
2345     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;isCurrentThreadAttached&quot;, JVMCI_CHECK_0);
2346     JNIEnv* peerEnv;
2347     return javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;
2348   }
2349   return true;
2350 C2V_END
2351 
2352 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))
2353   if (base_thread == NULL) {
2354     // Called from unattached JVMCI shared library thread
2355     return 0L;
2356   }
2357   JVMCITraceMark jtm(&quot;getCurrentJavaThread&quot;);
2358   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);
2359   return (jlong) p2i(base_thread);
2360 C2V_END
2361 
2362 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))
2363   if (base_thread == NULL) {
2364     // Called from unattached JVMCI shared library thread
2365     extern struct JavaVM_ main_vm;
2366     JNIEnv* hotspotEnv;
2367     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&amp;hotspotEnv, NULL) :
2368                            main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
2369     if (res != JNI_OK) {
2370       JNI_THROW_(&quot;attachCurrentThread&quot;, InternalError, err_msg(&quot;Trying to attach thread returned %d&quot;, res), false);
2371     }
2372     return true;
2373   }
2374   JVMCITraceMark jtm(&quot;attachCurrentThread&quot;);
2375   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
2376   JavaThread* thread = (JavaThread*) base_thread;
2377   if (thread-&gt;jni_environment() == env) {
2378     // Called from HotSpot
2379     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))
2380     requireJVMCINativeLibrary(JVMCI_CHECK_0);
2381     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;attachCurrentThread&quot;, JVMCI_CHECK_0);
2382     JavaVMAttachArgs attach_args;
2383     attach_args.version = JNI_VERSION_1_2;
2384     attach_args.name = thread-&gt;name();
2385     attach_args.group = NULL;
2386     JNIEnv* peerEnv;
2387     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK) {
2388       return false;
2389     }
2390     jint res = as_daemon ? javaVM-&gt;AttachCurrentThreadAsDaemon((void**)&amp;peerEnv, &amp;attach_args) :
2391                            javaVM-&gt;AttachCurrentThread((void**)&amp;peerEnv, &amp;attach_args);
2392     if (res == JNI_OK) {
2393       guarantee(peerEnv != NULL, &quot;must be&quot;);
2394       return true;
2395     }
2396     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, attach_args.name));
2397   }
2398   // Called from JVMCI shared library
2399   return false;
2400 C2V_END
2401 
2402 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))
2403   if (base_thread == NULL) {
2404     // Called from unattached JVMCI shared library thread
2405     JNI_THROW(&quot;detachCurrentThread&quot;, IllegalStateException, err_msg(&quot;Cannot detach non-attached thread&quot;));
2406   }
2407   JVMCITraceMark jtm(&quot;detachCurrentThread&quot;);
2408   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
2409   JavaThread* thread = (JavaThread*) base_thread;
2410   if (thread-&gt;jni_environment() == env) {
2411     // Called from HotSpot
2412     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))
2413     requireJVMCINativeLibrary(JVMCI_CHECK);
2414     requireInHotSpot(&quot;detachCurrentThread&quot;, JVMCI_CHECK);
2415     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;detachCurrentThread&quot;, JVMCI_CHECK);
2416     JNIEnv* peerEnv;
2417     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) != JNI_OK) {
2418       JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot detach non-attached thread: %s&quot;, thread-&gt;name()));
2419     }
2420     jint res = javaVM-&gt;DetachCurrentThread();
2421     if (res != JNI_OK) {
2422       JVMCI_THROW_MSG(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, thread-&gt;name()));
2423     }
2424   } else {
2425     // Called from attached JVMCI shared library thread
2426     extern struct JavaVM_ main_vm;
2427     jint res = main_vm.DetachCurrentThread();
2428     if (res != JNI_OK) {
2429       JNI_THROW(&quot;detachCurrentThread&quot;, InternalError, err_msg(&quot;Cannot detach non-attached thread&quot;));
2430     }
2431   }
2432 C2V_END
2433 
2434 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))
2435   requireJVMCINativeLibrary(JVMCI_CHECK_0);
2436   if (obj_handle == NULL) {
2437     return 0L;
2438   }
2439   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);
2440   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2441   JVMCIEnv* thisEnv = JVMCIENV;
2442 
2443   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);
2444   JVMCIObject result;
2445   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {
2446     methodHandle method(THREAD, thisEnv-&gt;asMethod(obj));
2447     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);
2448   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
2449     Klass* klass = thisEnv-&gt;asKlass(obj);
2450     JVMCIKlassHandle klass_handle(THREAD);
2451     klass_handle = klass;
2452     result = peerEnv-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_0);
2453   } else if (thisEnv-&gt;isa_HotSpotResolvedPrimitiveType(obj)) {
2454     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(obj), JVMCI_CHECK_0);
2455     result = peerEnv-&gt;get_jvmci_primitive_type(type);
2456   } else if (thisEnv-&gt;isa_IndirectHotSpotObjectConstantImpl(obj) ||
2457              thisEnv-&gt;isa_DirectHotSpotObjectConstantImpl(obj)) {
2458     Handle constant = thisEnv-&gt;asConstant(obj, JVMCI_CHECK_0);
2459     result = peerEnv-&gt;get_object_constant(constant());
2460   } else if (thisEnv-&gt;isa_HotSpotNmethod(obj)) {
2461     nmethodLocker locker;
2462     nmethod* nm = JVMCIENV-&gt;get_nmethod(obj, locker);
2463     if (nm != NULL) {
2464       JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
2465       if (data != NULL) {
2466         if (peerEnv-&gt;is_hotspot()) {
2467           // Only the mirror in the HotSpot heap is accessible
2468           // through JVMCINMethodData
2469           oop nmethod_mirror = data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ true);
2470           if (nmethod_mirror != NULL) {
2471             result = HotSpotJVMCI::wrap(nmethod_mirror);
2472           }
2473         }
2474       }
2475     }
2476     if (result.is_null()) {
2477       JVMCIObject methodObject = thisEnv-&gt;get_HotSpotNmethod_method(obj);
2478       methodHandle mh(THREAD, thisEnv-&gt;asMethod(methodObject));
2479       jboolean isDefault = thisEnv-&gt;get_HotSpotNmethod_isDefault(obj);
2480       jlong compileIdSnapshot = thisEnv-&gt;get_HotSpotNmethod_compileIdSnapshot(obj);
2481       JVMCIObject name_string = thisEnv-&gt;get_InstalledCode_name(obj);
2482       const char* cstring = name_string.is_null() ? NULL : thisEnv-&gt;as_utf8_string(name_string);
2483       // Create a new HotSpotNmethod instance in the peer runtime
2484       result = peerEnv-&gt;new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);
2485       if (nm == NULL) {
2486         // nmethod must have been unloaded
2487       } else {
2488         // Link the new HotSpotNmethod to the nmethod
2489         peerEnv-&gt;initialize_installed_code(result, nm, JVMCI_CHECK_0);
2490         // Only HotSpotNmethod instances in the HotSpot heap are tracked directly by the runtime.
2491         if (peerEnv-&gt;is_hotspot()) {
2492           JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
2493           if (data == NULL) {
2494             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot set HotSpotNmethod mirror for default nmethod&quot;);
2495           }
2496           if (data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) != NULL) {
2497             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot overwrite existing HotSpotNmethod mirror for nmethod&quot;);
2498           }
2499           oop nmethod_mirror = HotSpotJVMCI::resolve(result);
2500           data-&gt;set_nmethod_mirror(nm, nmethod_mirror);
2501         }
2502       }
2503     }
2504   } else {
2505     JVMCI_THROW_MSG_0(IllegalArgumentException,
2506                 err_msg(&quot;Cannot translate object of type: %s&quot;, thisEnv-&gt;klass_name(obj)));
2507   }
2508   return (jlong) peerEnv-&gt;make_global(result).as_jobject();
2509 }
2510 
2511 C2V_VMENTRY_NULL(jobject, unhand, (JNIEnv* env, jobject, jlong obj_handle))
2512   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2513   if (obj_handle == 0L) {
2514     return NULL;
2515   }
2516   jobject global_handle = (jobject) obj_handle;
2517   JVMCIObject global_handle_obj = JVMCIENV-&gt;wrap((jobject) obj_handle);
2518   jobject result = JVMCIENV-&gt;make_local(global_handle_obj).as_jobject();
2519 
2520   JVMCIENV-&gt;destroy_global(global_handle_obj);
2521   return result;
2522 }
2523 
2524 C2V_VMENTRY(void, updateHotSpotNmethod, (JNIEnv* env, jobject, jobject code_handle))
2525   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2526   // Execute this operation for the side effect of updating the InstalledCode state
2527   nmethodLocker locker;
2528   JVMCIENV-&gt;get_nmethod(code, locker);
2529 }
2530 
2531 C2V_VMENTRY_NULL(jbyteArray, getCode, (JNIEnv* env, jobject, jobject code_handle))
2532   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2533   nmethodLocker locker;
2534   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(code, locker);
2535   if (cb == NULL) {
2536     return NULL;
2537   }
2538   int code_size = cb-&gt;code_size();
2539   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
2540   JVMCIENV-&gt;copy_bytes_from((jbyte*) cb-&gt;code_begin(), result, 0, code_size);
2541   return JVMCIENV-&gt;get_jbyteArray(result);
2542 }
2543 
2544 C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))
2545   requireInHotSpot(&quot;asReflectionExecutable&quot;, JVMCI_CHECK_NULL);
2546   methodHandle m(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
2547   oop executable;
2548   if (m-&gt;is_initializer()) {
2549     if (m-&gt;is_static_initializer()) {
2550       JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2551           &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);
2552     }
2553     executable = Reflection::new_constructor(m, CHECK_NULL);
2554   } else {
2555     executable = Reflection::new_method(m, false, CHECK_NULL);
2556   }
2557   return JNIHandles::make_local(THREAD, executable);
2558 }
2559 
2560 C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))
2561   requireInHotSpot(&quot;asReflectionField&quot;, JVMCI_CHECK_NULL);
2562   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
2563   if (!klass-&gt;is_instance_klass()) {
2564     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2565         err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
2566   }
2567   InstanceKlass* iklass = InstanceKlass::cast(klass);
2568   Array&lt;u2&gt;* fields = iklass-&gt;fields();
2569   if (index &lt; 0 ||index &gt; fields-&gt;length()) {
2570     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2571         err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
2572   }
2573   fieldDescriptor fd(iklass, index);
2574   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2575   return JNIHandles::make_local(env, reflected);
2576 }
2577 
2578 C2V_VMENTRY_NULL(jobjectArray, getFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address, jobjectArray current))
2579   FailedSpeculation* head = *((FailedSpeculation**)(address) failed_speculations_address);
2580   int result_length = 0;
2581   for (FailedSpeculation* fs = head; fs != NULL; fs = fs-&gt;next()) {
2582     result_length++;
2583   }
2584   int current_length = 0;
2585   JVMCIObjectArray current_array = NULL;
2586   if (current != NULL) {
2587     current_array = JVMCIENV-&gt;wrap(current);
2588     current_length = JVMCIENV-&gt;get_length(current_array);
2589     if (current_length == result_length) {
2590       // No new failures
2591       return current;
2592     }
2593   }
2594   JVMCIObjectArray result = JVMCIENV-&gt;new_byte_array_array(result_length, JVMCI_CHECK_NULL);
2595   int result_index = 0;
2596   for (FailedSpeculation* fs = head; result_index &lt; result_length; fs = fs-&gt;next()) {
2597     assert(fs != NULL, &quot;npe&quot;);
2598     JVMCIPrimitiveArray entry;
2599     if (result_index &lt; current_length) {
2600       entry = (JVMCIPrimitiveArray) JVMCIENV-&gt;get_object_at(current_array, result_index);
2601     } else {
2602       entry = JVMCIENV-&gt;new_byteArray(fs-&gt;data_len(), JVMCI_CHECK_NULL);
2603       JVMCIENV-&gt;copy_bytes_from((jbyte*) fs-&gt;data(), entry, 0, fs-&gt;data_len());
2604     }
2605     JVMCIENV-&gt;put_object_at(result, result_index++, entry);
2606   }
2607   return JVMCIENV-&gt;get_jobjectArray(result);
2608 }
2609 
2610 C2V_VMENTRY_0(jlong, getFailedSpeculationsAddress, (JNIEnv* env, jobject, jobject jvmci_method))
2611   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
2612   MethodData* method_data = method-&gt;method_data();
2613   if (method_data == NULL) {
2614     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
2615     method_data = MethodData::allocate(loader_data, method, CHECK_0);
2616     method-&gt;set_method_data(method_data);
2617   }
2618   return (jlong) method_data-&gt;get_failed_speculations_address();
2619 }
2620 
2621 C2V_VMENTRY(void, releaseFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address))
2622   FailedSpeculation::free_failed_speculations((FailedSpeculation**)(address) failed_speculations_address);
2623 }
2624 
2625 C2V_VMENTRY_0(jboolean, addFailedSpeculation, (JNIEnv* env, jobject, jlong failed_speculations_address, jbyteArray speculation_obj))
2626   JVMCIPrimitiveArray speculation_handle = JVMCIENV-&gt;wrap(speculation_obj);
2627   int speculation_len = JVMCIENV-&gt;get_length(speculation_handle);
2628   char* speculation = NEW_RESOURCE_ARRAY(char, speculation_len);
2629   JVMCIENV-&gt;copy_bytes_to(speculation_handle, (jbyte*) speculation, 0, speculation_len);
2630   return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);
2631 }
2632 
2633 C2V_VMENTRY(void, callSystemExit, (JNIEnv* env, jobject, jint status))
2634   JavaValue result(T_VOID);
2635   JavaCallArguments jargs(1);
2636   jargs.push_int(status);
2637   JavaCalls::call_static(&amp;result,
2638                        SystemDictionary::System_klass(),
2639                        vmSymbols::exit_method_name(),
2640                        vmSymbols::int_void_signature(),
2641                        &amp;jargs,
2642                        CHECK);
2643 }
2644 
2645 C2V_VMENTRY_0(jlong, ticksNow, (JNIEnv* env, jobject))
2646   return CompilerEvent::ticksNow();
2647 }
2648 
2649 C2V_VMENTRY_0(jint, registerCompilerPhases, (JNIEnv* env, jobject, jobjectArray jphases))
2650 #if INCLUDE_JFR
2651   if (jphases == NULL) {
2652     return -1;
2653   }
2654   JVMCIObjectArray phases = JVMCIENV-&gt;wrap(jphases);
2655   int len = JVMCIENV-&gt;get_length(phases);
2656   GrowableArray&lt;const char*&gt;* jvmci_phase_names = new GrowableArray&lt;const char*&gt;(len);
2657   for (int i = 0; i &lt; len; i++) {
2658     JVMCIObject phase = JVMCIENV-&gt;get_object_at(phases, i);
2659     jvmci_phase_names-&gt;append(strdup(JVMCIENV-&gt;as_utf8_string(phase)));
2660   }
2661   return CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);
2662 #else
2663   return -1;
2664 #endif // !INCLUDE_JFR
2665 }
2666 
2667 C2V_VMENTRY(void, notifyCompilerPhaseEvent, (JNIEnv* env, jobject, jlong startTime, jint phase, jint compileId, jint level))
2668   EventCompilerPhase event;
2669   if (event.should_commit()) {
2670     CompilerEvent::PhaseEvent::post(event, startTime, phase, compileId, level);
2671   }
2672 }
2673 
2674 C2V_VMENTRY(void, notifyCompilerInliningEvent, (JNIEnv* env, jobject, jint compileId, jobject caller, jobject callee, jboolean succeeded, jstring jmessage, jint bci))
2675   EventCompilerInlining event;
2676   if (event.should_commit()) {
2677     Method* caller_method = JVMCIENV-&gt;asMethod(caller);
2678     Method* callee_method = JVMCIENV-&gt;asMethod(callee);
2679     JVMCIObject message = JVMCIENV-&gt;wrap(jmessage);
2680     CompilerEvent::InlineEvent::post(event, compileId, caller_method, callee_method, succeeded, JVMCIENV-&gt;as_utf8_string(message), bci);
2681   }
2682 }
2683 
2684 #define CC (char*)  /*cast a literal from (const char*)*/
2685 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
2686 
2687 #define STRING                  &quot;Ljava/lang/String;&quot;
2688 #define OBJECT                  &quot;Ljava/lang/Object;&quot;
2689 #define CLASS                   &quot;Ljava/lang/Class;&quot;
2690 #define OBJECTCONSTANT          &quot;Ljdk/vm/ci/hotspot/HotSpotObjectConstantImpl;&quot;
2691 #define HANDLECONSTANT          &quot;Ljdk/vm/ci/hotspot/IndirectHotSpotObjectConstantImpl;&quot;
2692 #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
2693 #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
2694 #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
2695 #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
2696 #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;
2697 #define JAVACONSTANT            &quot;Ljdk/vm/ci/meta/JavaConstant;&quot;
2698 #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
2699 #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
2700 #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
2701 #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;
2702 #define HS_RESOLVED_TYPE        &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaType;&quot;
2703 #define HS_RESOLVED_FIELD       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaField;&quot;
2704 #define HS_INSTALLED_CODE       &quot;Ljdk/vm/ci/hotspot/HotSpotInstalledCode;&quot;
2705 #define HS_NMETHOD              &quot;Ljdk/vm/ci/hotspot/HotSpotNmethod;&quot;
2706 #define HS_CONSTANT_POOL        &quot;Ljdk/vm/ci/hotspot/HotSpotConstantPool;&quot;
2707 #define HS_COMPILED_CODE        &quot;Ljdk/vm/ci/hotspot/HotSpotCompiledCode;&quot;
2708 #define HS_CONFIG               &quot;Ljdk/vm/ci/hotspot/HotSpotVMConfig;&quot;
2709 #define HS_METADATA             &quot;Ljdk/vm/ci/hotspot/HotSpotMetaData;&quot;
2710 #define HS_STACK_FRAME_REF      &quot;Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;&quot;
2711 #define HS_SPECULATION_LOG      &quot;Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;&quot;
2712 #define METASPACE_OBJECT        &quot;Ljdk/vm/ci/hotspot/MetaspaceObject;&quot;
2713 #define REFLECTION_EXECUTABLE   &quot;Ljava/lang/reflect/Executable;&quot;
2714 #define REFLECTION_FIELD        &quot;Ljava/lang/reflect/Field;&quot;
2715 #define METASPACE_METHOD_DATA   &quot;J&quot;
2716 
2717 JNINativeMethod CompilerToVM::methods[] = {
2718   {CC &quot;getBytecode&quot;,                                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[B&quot;,                                                      FN_PTR(getBytecode)},
2719   {CC &quot;getExceptionTableStart&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getExceptionTableStart)},
2720   {CC &quot;getExceptionTableLength&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getExceptionTableLength)},
2721   {CC &quot;findUniqueConcreteMethod&quot;,                     CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)&quot; HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
2722   {CC &quot;getImplementor&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
2723   {CC &quot;getStackTraceElement&quot;,                         CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)&quot; STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
2724   {CC &quot;methodIsIgnoredBySecurityStackWalk&quot;,           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
2725   {CC &quot;setNotInlinableOrCompilable&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(setNotInlinableOrCompilable)},
2726   {CC &quot;isCompilable&quot;,                                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(isCompilable)},
2727   {CC &quot;hasNeverInlineDirective&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(hasNeverInlineDirective)},
2728   {CC &quot;shouldInlineMethod&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(shouldInlineMethod)},
2729   {CC &quot;lookupType&quot;,                                   CC &quot;(&quot; STRING HS_RESOLVED_KLASS &quot;Z)&quot; HS_RESOLVED_TYPE,                                FN_PTR(lookupType)},
2730   {CC &quot;getArrayType&quot;,                                 CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getArrayType)},
2731   {CC &quot;lookupClass&quot;,                                  CC &quot;(&quot; CLASS &quot;)&quot; HS_RESOLVED_TYPE,                                                    FN_PTR(lookupClass)},
2732   {CC &quot;lookupNameInPool&quot;,                             CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupNameInPool)},
2733   {CC &quot;lookupNameAndTypeRefIndexInPool&quot;,              CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
2734   {CC &quot;lookupSignatureInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupSignatureInPool)},
2735   {CC &quot;lookupKlassRefIndexInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupKlassRefIndexInPool)},
2736   {CC &quot;lookupKlassInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)Ljava/lang/Object;&quot;,                                       FN_PTR(lookupKlassInPool)},
2737   {CC &quot;lookupAppendixInPool&quot;,                         CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(lookupAppendixInPool)},
2738   {CC &quot;lookupMethodInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;IB)&quot; HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
2739   {CC &quot;constantPoolRemapInstructionOperandFromCache&quot;, CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
2740   {CC &quot;resolvePossiblyCachedConstantInPool&quot;,          CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(resolvePossiblyCachedConstantInPool)},
2741   {CC &quot;resolveTypeInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
2742   {CC &quot;resolveFieldInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;I&quot; HS_RESOLVED_METHOD &quot;B[I)&quot; HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
2743   {CC &quot;resolveInvokeDynamicInPool&quot;,                   CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeDynamicInPool)},
2744   {CC &quot;resolveInvokeHandleInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeHandleInPool)},
2745   {CC &quot;isResolvedInvokeHandleInPool&quot;,                 CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(isResolvedInvokeHandleInPool)},
2746   {CC &quot;resolveMethod&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
2747   {CC &quot;getSignaturePolymorphicHolders&quot;,               CC &quot;()[&quot; STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
2748   {CC &quot;getVtableIndexForInterfaceMethod&quot;,             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)I&quot;,                                     FN_PTR(getVtableIndexForInterfaceMethod)},
2749   {CC &quot;getClassInitializer&quot;,                          CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
2750   {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
2751   {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
2752   {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
2753   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
2754   {CC &quot;getConstantPool&quot;,                              CC &quot;(&quot; METASPACE_OBJECT &quot;)&quot; HS_CONSTANT_POOL,                                         FN_PTR(getConstantPool)},
2755   {CC &quot;getResolvedJavaType0&quot;,                         CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType0)},
2756   {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
2757   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE &quot;J[B)I&quot;,                    FN_PTR(installCode)},
2758   {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
2759   {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
2760   {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
2761   {CC &quot;executeHotSpotNmethod&quot;,                        CC &quot;([&quot; OBJECT HS_NMETHOD &quot;)&quot; OBJECT,                                                 FN_PTR(executeHotSpotNmethod)},
2762   {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
2763   {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
2764   {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
2765   {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
2766   {CC &quot;invalidateHotSpotNmethod&quot;,                     CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(invalidateHotSpotNmethod)},
2767   {CC &quot;readUncompressedOop&quot;,                          CC &quot;(J)&quot; OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},
2768   {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},
2769   {CC &quot;getCountersSize&quot;,                              CC &quot;()I&quot;,                                                                             FN_PTR(getCountersSize)},
2770   {CC &quot;setCountersSize&quot;,                              CC &quot;(I)V&quot;,                                                                            FN_PTR(setCountersSize)},
2771   {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
2772   {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
2773   {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
2774   {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
2775   {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
2776   {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
2777   {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
2778   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BIIZZ)I&quot;,                                                                       FN_PTR(writeDebugOutput)},
2779   {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
2780   {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
2781   {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
2782   {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
2783   {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
2784   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECTCONSTANT &quot;)V&quot;,                                                           FN_PTR(compileToBytecode)},
2785   {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},
2786   {CC &quot;getObjectAtAddress&quot;,                           CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(getObjectAtAddress)},
2787   {CC &quot;getInterfaces&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; HS_RESOLVED_KLASS,                                      FN_PTR(getInterfaces)},
2788   {CC &quot;getComponentType&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_TYPE,                                        FN_PTR(getComponentType)},
2789   {CC &quot;ensureInitialized&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureInitialized)},
2790   {CC &quot;ensureLinked&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureLinked)},
2791   {CC &quot;getIdentityHashCode&quot;,                          CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getIdentityHashCode)},
2792   {CC &quot;isInternedString&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;)Z&quot;,                                                           FN_PTR(isInternedString)},
2793   {CC &quot;unboxPrimitive&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; OBJECT,                                                     FN_PTR(unboxPrimitive)},
2794   {CC &quot;boxPrimitive&quot;,                                 CC &quot;(&quot; OBJECT &quot;)&quot; OBJECTCONSTANT,                                                     FN_PTR(boxPrimitive)},
2795   {CC &quot;getDeclaredConstructors&quot;,                      CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredConstructors)},
2796   {CC &quot;getDeclaredMethods&quot;,                           CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredMethods)},
2797   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                         FN_PTR(readFieldValue)},
2798   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; OBJECTCONSTANT HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                            FN_PTR(readFieldValue)},
2799   {CC &quot;isInstance&quot;,                                   CC &quot;(&quot; HS_RESOLVED_KLASS OBJECTCONSTANT &quot;)Z&quot;,                                         FN_PTR(isInstance)},
2800   {CC &quot;isAssignableFrom&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_KLASS &quot;)Z&quot;,                                      FN_PTR(isAssignableFrom)},
2801   {CC &quot;isTrustedForIntrinsics&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(isTrustedForIntrinsics)},
2802   {CC &quot;asJavaType&quot;,                                   CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; HS_RESOLVED_TYPE,                                           FN_PTR(asJavaType)},
2803   {CC &quot;asString&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; STRING,                                                     FN_PTR(asString)},
2804   {CC &quot;equals&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J&quot; OBJECTCONSTANT &quot;J)Z&quot;,                                       FN_PTR(equals)},
2805   {CC &quot;getJavaMirror&quot;,                                CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; OBJECTCONSTANT,                                           FN_PTR(getJavaMirror)},
2806   {CC &quot;getArrayLength&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getArrayLength)},
2807   {CC &quot;readArrayElement&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;I)Ljava/lang/Object;&quot;,                                         FN_PTR(readArrayElement)},
2808   {CC &quot;arrayBaseOffset&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayBaseOffset)},
2809   {CC &quot;arrayIndexScale&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayIndexScale)},
2810   {CC &quot;getByte&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)B&quot;,                                                          FN_PTR(getByte)},
2811   {CC &quot;getShort&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;J)S&quot;,                                                          FN_PTR(getShort)},
2812   {CC &quot;getInt&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J)I&quot;,                                                          FN_PTR(getInt)},
2813   {CC &quot;getLong&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)J&quot;,                                                          FN_PTR(getLong)},
2814   {CC &quot;getObject&quot;,                                    CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; OBJECTCONSTANT,                                            FN_PTR(getObject)},
2815   {CC &quot;deleteGlobalHandle&quot;,                           CC &quot;(J)V&quot;,                                                                            FN_PTR(deleteGlobalHandle)},
2816   {CC &quot;registerNativeMethods&quot;,                        CC &quot;(&quot; CLASS &quot;)[J&quot;,                                                                   FN_PTR(registerNativeMethods)},
2817   {CC &quot;isCurrentThreadAttached&quot;,                      CC &quot;()Z&quot;,                                                                             FN_PTR(isCurrentThreadAttached)},
2818   {CC &quot;getCurrentJavaThread&quot;,                         CC &quot;()J&quot;,                                                                             FN_PTR(getCurrentJavaThread)},
2819   {CC &quot;attachCurrentThread&quot;,                          CC &quot;(Z)Z&quot;,                                                                            FN_PTR(attachCurrentThread)},
2820   {CC &quot;detachCurrentThread&quot;,                          CC &quot;()V&quot;,                                                                             FN_PTR(detachCurrentThread)},
2821   {CC &quot;translate&quot;,                                    CC &quot;(&quot; OBJECT &quot;)J&quot;,                                                                   FN_PTR(translate)},
2822   {CC &quot;unhand&quot;,                                       CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(unhand)},
2823   {CC &quot;updateHotSpotNmethod&quot;,                         CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(updateHotSpotNmethod)},
2824   {CC &quot;getCode&quot;,                                      CC &quot;(&quot; HS_INSTALLED_CODE &quot;)[B&quot;,                                                       FN_PTR(getCode)},
2825   {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
2826   {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
2827   {CC &quot;getFailedSpeculations&quot;,                        CC &quot;(J[[B)[[B&quot;,                                                                       FN_PTR(getFailedSpeculations)},
2828   {CC &quot;getFailedSpeculationsAddress&quot;,                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getFailedSpeculationsAddress)},
2829   {CC &quot;releaseFailedSpeculations&quot;,                    CC &quot;(J)V&quot;,                                                                            FN_PTR(releaseFailedSpeculations)},
2830   {CC &quot;addFailedSpeculation&quot;,                         CC &quot;(J[B)Z&quot;,                                                                          FN_PTR(addFailedSpeculation)},
2831   {CC &quot;callSystemExit&quot;,                               CC &quot;(I)V&quot;,                                                                            FN_PTR(callSystemExit)},
2832   {CC &quot;ticksNow&quot;,                                     CC &quot;()J&quot;,                                                                             FN_PTR(ticksNow)},
2833   {CC &quot;registerCompilerPhases&quot;,                       CC &quot;([&quot; STRING &quot;)I&quot;,                                                                  FN_PTR(registerCompilerPhases)},
2834   {CC &quot;notifyCompilerPhaseEvent&quot;,                     CC &quot;(JIII)V&quot;,                                                                         FN_PTR(notifyCompilerPhaseEvent)},
2835   {CC &quot;notifyCompilerInliningEvent&quot;,                  CC &quot;(I&quot; HS_RESOLVED_METHOD HS_RESOLVED_METHOD &quot;ZLjava/lang/String;I)V&quot;,               FN_PTR(notifyCompilerInliningEvent)},
2836 };
2837 
2838 int CompilerToVM::methods_count() {
2839   return sizeof(methods) / sizeof(JNINativeMethod);
2840 }
    </pre>
  </body>
</html>