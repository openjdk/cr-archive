<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classListParser.hpp&quot;
  29 #include &quot;classfile/classLoaderExt.hpp&quot;
  30 #include &quot;classfile/dictionary.hpp&quot;
  31 #include &quot;classfile/loaderConstraints.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/placeholders.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  38 #include &quot;code/codeCache.hpp&quot;
  39 #include &quot;gc/shared/softRefPolicy.hpp&quot;
  40 #include &quot;interpreter/bytecodeStream.hpp&quot;
  41 #include &quot;interpreter/bytecodes.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  54 #include &quot;oops/flatArrayKlass.hpp&quot;</span>
<span class="line-added">  55 #include &quot;oops/inlineKlass.hpp&quot;</span>
  56 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  57 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  58 #include &quot;oops/instanceRefKlass.hpp&quot;
  59 #include &quot;oops/methodData.hpp&quot;
  60 #include &quot;oops/objArrayKlass.hpp&quot;
  61 #include &quot;oops/objArrayOop.hpp&quot;
  62 #include &quot;oops/oop.inline.hpp&quot;
  63 #include &quot;oops/typeArrayKlass.hpp&quot;
  64 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/os.hpp&quot;
  67 #include &quot;runtime/safepointVerifiers.hpp&quot;
  68 #include &quot;runtime/signature.hpp&quot;
  69 #include &quot;runtime/timerTrace.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;runtime/vmOperations.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/bitMap.inline.hpp&quot;
  74 #include &quot;utilities/ostream.hpp&quot;
  75 #include &quot;utilities/defaultStream.hpp&quot;
  76 #include &quot;utilities/hashtable.inline.hpp&quot;
  77 #if INCLUDE_G1GC
  78 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  79 #endif
  80 
  81 ReservedSpace MetaspaceShared::_shared_rs;
  82 VirtualSpace MetaspaceShared::_shared_vs;
  83 ReservedSpace MetaspaceShared::_symbol_rs;
  84 VirtualSpace MetaspaceShared::_symbol_vs;
  85 MetaspaceSharedStats MetaspaceShared::_stats;
  86 bool MetaspaceShared::_has_error_classes;
  87 bool MetaspaceShared::_archive_loading_failed = false;
  88 bool MetaspaceShared::_remapped_readwrite = false;
  89 address MetaspaceShared::_i2i_entry_code_buffers = NULL;
  90 size_t MetaspaceShared::_i2i_entry_code_buffers_size = 0;
  91 void* MetaspaceShared::_shared_metaspace_static_top = NULL;
  92 intx MetaspaceShared::_relocation_delta;
  93 char* MetaspaceShared::_requested_base_address;
  94 bool MetaspaceShared::_use_optimized_module_handling = true;
  95 
  96 // The CDS archive is divided into the following regions:
  97 //     mc  - misc code (the method entry trampolines, c++ vtables)
  98 //     rw  - read-write metadata
  99 //     ro  - read-only metadata and read-only tables
 100 //
 101 //     ca0 - closed archive heap space #0
 102 //     ca1 - closed archive heap space #1 (may be empty)
 103 //     oa0 - open archive heap space #0
 104 //     oa1 - open archive heap space #1 (may be empty)
 105 //
 106 // The mc, rw, and ro regions are linearly allocated, starting from
 107 // SharedBaseAddress, in the order of mc-&gt;rw-&gt;ro. The size of these 3 regions
 108 // are page-aligned, and there&#39;s no gap between any consecutive regions.
 109 //
 110 // These 3 regions are populated in the following steps:
 111 // [1] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are
 112 //     temporarily allocated outside of the shared regions. Only the method entry
 113 //     trampolines are written into the mc region.
 114 // [2] C++ vtables are copied into the mc region.
 115 // [3] ArchiveCompactor copies RW metadata into the rw region.
 116 // [4] ArchiveCompactor copies RO metadata into the ro region.
 117 // [5] SymbolTable, StringTable, SystemDictionary, and a few other read-only data
 118 //     are copied into the ro region as read-only tables.
 119 //
 120 // The s0/s1 and oa0/oa1 regions are populated inside HeapShared::archive_java_heap_objects.
 121 // Their layout is independent of the other 4 regions.
 122 
 123 char* DumpRegion::expand_top_to(char* newtop) {
 124   assert(is_allocatable(), &quot;must be initialized and not packed&quot;);
 125   assert(newtop &gt;= _top, &quot;must not grow backwards&quot;);
 126   if (newtop &gt; _end) {
 127     MetaspaceShared::report_out_of_space(_name, newtop - _top);
 128     ShouldNotReachHere();
 129   }
 130 
 131   if (_rs == MetaspaceShared::shared_rs()) {
 132     uintx delta;
 133     if (DynamicDumpSharedSpaces) {
 134       delta = DynamicArchive::object_delta_uintx(newtop);
 135     } else {
 136       delta = MetaspaceShared::object_delta_uintx(newtop);
 137     }
 138     if (delta &gt; MAX_SHARED_DELTA) {
 139       // This is just a sanity check and should not appear in any real world usage. This
 140       // happens only if you allocate more than 2GB of shared objects and would require
 141       // millions of shared classes.
 142       vm_exit_during_initialization(&quot;Out of memory in the CDS archive&quot;,
 143                                     &quot;Please reduce the number of shared classes.&quot;);
 144     }
 145   }
 146 
 147   MetaspaceShared::commit_to(_rs, _vs, newtop);
 148   _top = newtop;
 149   return _top;
 150 }
 151 
 152 char* DumpRegion::allocate(size_t num_bytes, size_t alignment) {
 153   char* p = (char*)align_up(_top, alignment);
 154   char* newtop = p + align_up(num_bytes, alignment);
 155   expand_top_to(newtop);
 156   memset(p, 0, newtop - p);
 157   return p;
 158 }
 159 
 160 void DumpRegion::append_intptr_t(intptr_t n, bool need_to_mark) {
 161   assert(is_aligned(_top, sizeof(intptr_t)), &quot;bad alignment&quot;);
 162   intptr_t *p = (intptr_t*)_top;
 163   char* newtop = _top + sizeof(intptr_t);
 164   expand_top_to(newtop);
 165   *p = n;
 166   if (need_to_mark) {
 167     ArchivePtrMarker::mark_pointer(p);
 168   }
 169 }
 170 
 171 void DumpRegion::print(size_t total_bytes) const {
 172   log_debug(cds)(&quot;%-3s space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used] at &quot; INTPTR_FORMAT,
 173                  _name, used(), percent_of(used(), total_bytes), reserved(), percent_of(used(), reserved()),
 174                  p2i(_base + MetaspaceShared::final_delta()));
 175 }
 176 
 177 void DumpRegion::print_out_of_space_msg(const char* failing_region, size_t needed_bytes) {
 178   log_error(cds)(&quot;[%-8s] &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; capacity =%9d, allocated =%9d&quot;,
 179                  _name, p2i(_base), p2i(_top), int(_end - _base), int(_top - _base));
 180   if (strcmp(_name, failing_region) == 0) {
 181     log_error(cds)(&quot; required = %d&quot;, int(needed_bytes));
 182   }
 183 }
 184 
 185 void DumpRegion::init(ReservedSpace* rs, VirtualSpace* vs) {
 186   _rs = rs;
 187   _vs = vs;
 188   // Start with 0 committed bytes. The memory will be committed as needed by
 189   // MetaspaceShared::commit_to().
 190   if (!_vs-&gt;initialize(*_rs, 0)) {
 191     fatal(&quot;Unable to allocate memory for shared space&quot;);
 192   }
 193   _base = _top = _rs-&gt;base();
 194   _end = _rs-&gt;end();
 195 }
 196 
 197 void DumpRegion::pack(DumpRegion* next) {
 198   assert(!is_packed(), &quot;sanity&quot;);
 199   _end = (char*)align_up(_top, MetaspaceShared::reserved_space_alignment());
 200   _is_packed = true;
 201   if (next != NULL) {
 202     next-&gt;_rs = _rs;
 203     next-&gt;_vs = _vs;
 204     next-&gt;_base = next-&gt;_top = this-&gt;_end;
 205     next-&gt;_end = _rs-&gt;end();
 206   }
 207 }
 208 
 209 static DumpRegion _mc_region(&quot;mc&quot;), _ro_region(&quot;ro&quot;), _rw_region(&quot;rw&quot;), _symbol_region(&quot;symbols&quot;);
 210 static size_t _total_closed_archive_region_size = 0, _total_open_archive_region_size = 0;
 211 
 212 void MetaspaceShared::init_shared_dump_space(DumpRegion* first_space) {
 213   first_space-&gt;init(&amp;_shared_rs, &amp;_shared_vs);
 214 }
 215 
 216 DumpRegion* MetaspaceShared::misc_code_dump_space() {
 217   return &amp;_mc_region;
 218 }
 219 
 220 DumpRegion* MetaspaceShared::read_write_dump_space() {
 221   return &amp;_rw_region;
 222 }
 223 
 224 DumpRegion* MetaspaceShared::read_only_dump_space() {
 225   return &amp;_ro_region;
 226 }
 227 
 228 void MetaspaceShared::pack_dump_space(DumpRegion* current, DumpRegion* next,
 229                                       ReservedSpace* rs) {
 230   current-&gt;pack(next);
 231 }
 232 
 233 char* MetaspaceShared::symbol_space_alloc(size_t num_bytes) {
 234   return _symbol_region.allocate(num_bytes);
 235 }
 236 
 237 char* MetaspaceShared::misc_code_space_alloc(size_t num_bytes) {
 238   return _mc_region.allocate(num_bytes);
 239 }
 240 
 241 char* MetaspaceShared::read_only_space_alloc(size_t num_bytes) {
 242   return _ro_region.allocate(num_bytes);
 243 }
 244 
 245 size_t MetaspaceShared::reserved_space_alignment() { return os::vm_allocation_granularity(); }
 246 
 247 static bool shared_base_valid(char* shared_base) {
 248 #ifdef _LP64
 249   return CompressedKlassPointers::is_valid_base((address)shared_base);
 250 #else
 251   return true;
 252 #endif
 253 }
 254 
 255 static bool shared_base_too_high(char* shared_base, size_t cds_total) {
 256   if (SharedBaseAddress != 0 &amp;&amp; shared_base &lt; (char*)SharedBaseAddress) {
 257     // SharedBaseAddress is very high (e.g., 0xffffffffffffff00) so
 258     // align_up(SharedBaseAddress, MetaspaceShared::reserved_space_alignment()) has wrapped around.
 259     return true;
 260   }
 261   if (max_uintx - uintx(shared_base) &lt; uintx(cds_total)) {
 262     // The end of the archive will wrap around
 263     return true;
 264   }
 265 
 266   return false;
 267 }
 268 
 269 static char* compute_shared_base(size_t cds_total) {
 270   char* shared_base = (char*)align_up((char*)SharedBaseAddress, MetaspaceShared::reserved_space_alignment());
 271   const char* err = NULL;
 272   if (shared_base_too_high(shared_base, cds_total)) {
 273     err = &quot;too high&quot;;
 274   } else if (!shared_base_valid(shared_base)) {
 275     err = &quot;invalid for this platform&quot;;
 276   }
 277   if (err) {
 278     log_warning(cds)(&quot;SharedBaseAddress (&quot; INTPTR_FORMAT &quot;) is %s. Reverted to &quot; INTPTR_FORMAT,
 279                      p2i((void*)SharedBaseAddress), err,
 280                      p2i((void*)Arguments::default_SharedBaseAddress()));
 281     SharedBaseAddress = Arguments::default_SharedBaseAddress();
 282     shared_base = (char*)align_up((char*)SharedBaseAddress, MetaspaceShared::reserved_space_alignment());
 283   }
 284   assert(!shared_base_too_high(shared_base, cds_total) &amp;&amp; shared_base_valid(shared_base), &quot;Sanity&quot;);
 285   return shared_base;
 286 }
 287 
 288 void MetaspaceShared::initialize_dumptime_shared_and_meta_spaces() {
 289   assert(DumpSharedSpaces, &quot;should be called for dump time only&quot;);
 290 
 291   const size_t reserve_alignment = MetaspaceShared::reserved_space_alignment();
 292 
 293 #ifdef _LP64
 294   // On 64-bit VM we reserve a 4G range and, if UseCompressedClassPointers=1,
 295   //  will use that to house both the archives and the ccs. See below for
 296   //  details.
 297   const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
 298   const size_t cds_total = align_down(UnscaledClassSpaceMax, reserve_alignment);
 299 #else
 300   // We don&#39;t support archives larger than 256MB on 32-bit due to limited
 301   //  virtual address space.
 302   size_t cds_total = align_down(256*M, reserve_alignment);
 303 #endif
 304 
 305   char* shared_base = compute_shared_base(cds_total);
 306   _requested_base_address = shared_base;
 307 
 308   // Whether to use SharedBaseAddress as attach address.
 309   bool use_requested_base = true;
 310 
 311   if (shared_base == NULL) {
 312     use_requested_base = false;
 313   }
 314 
 315   if (ArchiveRelocationMode == 1) {
 316     log_info(cds)(&quot;ArchiveRelocationMode == 1: always allocate class space at an alternative address&quot;);
 317     use_requested_base = false;
 318   }
 319 
 320   // First try to reserve the space at the specified SharedBaseAddress.
 321   assert(!_shared_rs.is_reserved(), &quot;must be&quot;);
 322   if (use_requested_base) {
 323     _shared_rs = ReservedSpace(cds_total, reserve_alignment,
 324                                false /* large */, (char*)shared_base);
 325     if (_shared_rs.is_reserved()) {
 326       assert(_shared_rs.base() == shared_base, &quot;should match&quot;);
 327     } else {
 328       log_info(cds)(&quot;dumptime space reservation: failed to map at &quot;
 329                     &quot;SharedBaseAddress &quot; PTR_FORMAT, p2i(shared_base));
 330     }
 331   }
 332   if (!_shared_rs.is_reserved()) {
 333     // Get a reserved space anywhere if attaching at the SharedBaseAddress
 334     //  fails:
 335     if (UseCompressedClassPointers) {
 336       // If we need to reserve class space as well, let the platform handle
 337       //  the reservation.
 338       LP64_ONLY(_shared_rs =
 339                 Metaspace::reserve_address_space_for_compressed_classes(cds_total);)
 340       NOT_LP64(ShouldNotReachHere();)
 341     } else {
 342       // anywhere is fine.
 343       _shared_rs = ReservedSpace(cds_total, reserve_alignment,
 344                                  false /* large */, (char*)NULL);
 345     }
 346   }
 347 
 348   if (!_shared_rs.is_reserved()) {
 349     vm_exit_during_initialization(&quot;Unable to reserve memory for shared space&quot;,
 350                                   err_msg(SIZE_FORMAT &quot; bytes.&quot;, cds_total));
 351   }
 352 
 353 #ifdef _LP64
 354 
 355   if (UseCompressedClassPointers) {
 356 
 357     assert(CompressedKlassPointers::is_valid_base((address)_shared_rs.base()), &quot;Sanity&quot;);
 358 
 359     // On 64-bit VM, if UseCompressedClassPointers=1, the compressed class space
 360     //  must be allocated near the cds such as that the compressed Klass pointer
 361     //  encoding can be used to en/decode pointers from both cds and ccs. Since
 362     //  Metaspace cannot do this (it knows nothing about cds), we do it for
 363     //  Metaspace here and pass it the space to use for ccs.
 364     //
 365     // We do this by reserving space for the ccs behind the archives. Note
 366     //  however that ccs follows a different alignment
 367     //  (Metaspace::reserve_alignment), so there may be a gap between ccs and
 368     //  cds.
 369     // We use a similar layout at runtime, see reserve_address_space_for_archives().
 370     //
 371     //                              +-- SharedBaseAddress (default = 0x800000000)
 372     //                              v
 373     // +-..---------+---------+ ... +----+----+----+--------+-----------------+
 374     // |    Heap    | Archive |     | MC | RW | RO | [gap]  |    class space  |
 375     // +-..---------+---------+ ... +----+----+----+--------+-----------------+
 376     // |&lt;--   MaxHeapSize  --&gt;|     |&lt;-- UnscaledClassSpaceMax = 4GB --&gt;|
 377     //
 378     // Note: ccs must follow the archives, and the archives must start at the
 379     //  encoding base. However, the exact placement of ccs does not matter as
 380     //  long as it it resides in the encoding range of CompressedKlassPointers
 381     //  and comes after the archive.
 382     //
 383     // We do this by splitting up the allocated 4G into 3G of archive space,
 384     //  followed by 1G for the ccs:
 385     // + The upper 1 GB is used as the &quot;temporary compressed class space&quot;
 386     //   -- preload_classes() will store Klasses into this space.
 387     // + The lower 3 GB is used for the archive -- when preload_classes()
 388     //   is done, ArchiveCompactor will copy the class metadata into this
 389     //   space, first the RW parts, then the RO parts.
 390 
 391     // Starting address of ccs must be aligned to Metaspace::reserve_alignment()...
 392     size_t class_space_size = align_down(_shared_rs.size() / 4, Metaspace::reserve_alignment());
 393     address class_space_start = (address)align_down(_shared_rs.end() - class_space_size, Metaspace::reserve_alignment());
 394     size_t archive_size = class_space_start - (address)_shared_rs.base();
 395 
 396     ReservedSpace tmp_class_space = _shared_rs.last_part(archive_size);
 397     _shared_rs = _shared_rs.first_part(archive_size);
 398 
 399     // ... as does the size of ccs.
 400     tmp_class_space = tmp_class_space.first_part(class_space_size);
 401     CompressedClassSpaceSize = class_space_size;
 402 
 403     // Let Metaspace initialize ccs
 404     Metaspace::initialize_class_space(tmp_class_space);
 405 
 406     // and set up CompressedKlassPointers encoding.
 407     CompressedKlassPointers::initialize((address)_shared_rs.base(), cds_total);
 408 
 409     log_info(cds)(&quot;narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
 410                   p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());
 411 
 412     log_info(cds)(&quot;Allocated temporary class space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,
 413                   CompressedClassSpaceSize, p2i(tmp_class_space.base()));
 414 
 415     assert(_shared_rs.end() == tmp_class_space.base() &amp;&amp;
 416            is_aligned(_shared_rs.base(), MetaspaceShared::reserved_space_alignment()) &amp;&amp;
 417            is_aligned(tmp_class_space.base(), Metaspace::reserve_alignment()) &amp;&amp;
 418            is_aligned(tmp_class_space.size(), Metaspace::reserve_alignment()), &quot;Sanity&quot;);
 419   }
 420 
 421 #endif
 422 
 423   init_shared_dump_space(&amp;_mc_region);
 424   SharedBaseAddress = (size_t)_shared_rs.base();
 425   log_info(cds)(&quot;Allocated shared space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,
 426                 _shared_rs.size(), p2i(_shared_rs.base()));
 427 
 428   // We don&#39;t want any valid object to be at the very bottom of the archive.
 429   // See ArchivePtrMarker::mark_pointer().
 430   MetaspaceShared::misc_code_space_alloc(16);
 431 
 432   size_t symbol_rs_size = LP64_ONLY(3 * G) NOT_LP64(128 * M);
 433   _symbol_rs = ReservedSpace(symbol_rs_size);
 434   if (!_symbol_rs.is_reserved()) {
 435     vm_exit_during_initialization(&quot;Unable to reserve memory for symbols&quot;,
 436                                   err_msg(SIZE_FORMAT &quot; bytes.&quot;, symbol_rs_size));
 437   }
 438   _symbol_region.init(&amp;_symbol_rs, &amp;_symbol_vs);
 439 }
 440 
 441 // Called by universe_post_init()
 442 void MetaspaceShared::post_initialize(TRAPS) {
 443   if (UseSharedSpaces) {
 444     int size = FileMapInfo::get_number_of_shared_paths();
 445     if (size &gt; 0) {
 446       SystemDictionaryShared::allocate_shared_data_arrays(size, THREAD);
 447       if (!DynamicDumpSharedSpaces) {
 448         FileMapInfo* info;
 449         if (FileMapInfo::dynamic_info() == NULL) {
 450           info = FileMapInfo::current_info();
 451         } else {
 452           info = FileMapInfo::dynamic_info();
 453         }
 454         ClassLoaderExt::init_paths_start_index(info-&gt;app_class_paths_start_index());
 455         ClassLoaderExt::init_app_module_paths_start_index(info-&gt;app_module_paths_start_index());
 456       }
 457     }
 458   }
 459 }
 460 
 461 static GrowableArrayCHeap&lt;Handle, mtClassShared&gt;* _extra_interned_strings = NULL;
 462 
 463 void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {
 464   _extra_interned_strings = new GrowableArrayCHeap&lt;Handle, mtClassShared&gt;(10000);
 465 
 466   HashtableTextDump reader(filename);
 467   reader.check_version(&quot;VERSION: 1.0&quot;);
 468 
 469   while (reader.remain() &gt; 0) {
 470     int utf8_length;
 471     int prefix_type = reader.scan_prefix(&amp;utf8_length);
 472     ResourceMark rm(THREAD);
 473     if (utf8_length == 0x7fffffff) {
 474       // buf_len will overflown 32-bit value.
 475       vm_exit_during_initialization(err_msg(&quot;string length too large: %d&quot;, utf8_length));
 476     }
 477     int buf_len = utf8_length+1;
 478     char* utf8_buffer = NEW_RESOURCE_ARRAY(char, buf_len);
 479     reader.get_utf8(utf8_buffer, utf8_length);
 480     utf8_buffer[utf8_length] = &#39;\0&#39;;
 481 
 482     if (prefix_type == HashtableTextDump::SymbolPrefix) {
 483       SymbolTable::new_permanent_symbol(utf8_buffer);
 484     } else{
 485       assert(prefix_type == HashtableTextDump::StringPrefix, &quot;Sanity&quot;);
 486       oop s = StringTable::intern(utf8_buffer, THREAD);
 487 
 488       if (HAS_PENDING_EXCEPTION) {
 489         log_warning(cds, heap)(&quot;[line %d] extra interned string allocation failed; size too large: %d&quot;,
 490                                reader.last_line_no(), utf8_length);
 491         CLEAR_PENDING_EXCEPTION;
 492       } else {
 493 #if INCLUDE_G1GC
 494         if (UseG1GC) {
 495           typeArrayOop body = java_lang_String::value(s);
 496           const HeapRegion* hr = G1CollectedHeap::heap()-&gt;heap_region_containing(body);
 497           if (hr-&gt;is_humongous()) {
 498             // Don&#39;t keep it alive, so it will be GC&#39;ed before we dump the strings, in order
 499             // to maximize free heap space and minimize fragmentation.
 500             log_warning(cds, heap)(&quot;[line %d] extra interned string ignored; size too large: %d&quot;,
 501                                 reader.last_line_no(), utf8_length);
 502             continue;
 503           }
 504         }
 505 #endif
 506         // Interned strings are GC&#39;ed if there are no references to it, so let&#39;s
 507         // add a reference to keep this string alive.
 508         assert(s != NULL, &quot;must succeed&quot;);
 509         Handle h(THREAD, s);
 510         _extra_interned_strings-&gt;append(h);
 511       }
 512     }
 513   }
 514 }
 515 
 516 void MetaspaceShared::commit_to(ReservedSpace* rs, VirtualSpace* vs, char* newtop) {
 517   Arguments::assert_is_dumping_archive();
 518   char* base = rs-&gt;base();
 519   size_t need_committed_size = newtop - base;
 520   size_t has_committed_size = vs-&gt;committed_size();
 521   if (need_committed_size &lt; has_committed_size) {
 522     return;
 523   }
 524 
 525   size_t min_bytes = need_committed_size - has_committed_size;
 526   size_t preferred_bytes = 1 * M;
 527   size_t uncommitted = vs-&gt;reserved_size() - has_committed_size;
 528 
 529   size_t commit =MAX2(min_bytes, preferred_bytes);
 530   commit = MIN2(commit, uncommitted);
 531   assert(commit &lt;= uncommitted, &quot;sanity&quot;);
 532 
 533   bool result = vs-&gt;expand_by(commit, false);
 534   if (rs == &amp;_shared_rs) {
 535     ArchivePtrMarker::expand_ptr_end((address*)vs-&gt;high());
 536   }
 537 
 538   if (!result) {
 539     vm_exit_during_initialization(err_msg(&quot;Failed to expand shared space to &quot; SIZE_FORMAT &quot; bytes&quot;,
 540                                           need_committed_size));
 541   }
 542 
 543   assert(rs == &amp;_shared_rs || rs == &amp;_symbol_rs, &quot;must be&quot;);
 544   const char* which = (rs == &amp;_shared_rs) ? &quot;shared&quot; : &quot;symbol&quot;;
 545   log_debug(cds)(&quot;Expanding %s spaces by &quot; SIZE_FORMAT_W(7) &quot; bytes [total &quot; SIZE_FORMAT_W(9)  &quot; bytes ending at %p]&quot;,
 546                  which, commit, vs-&gt;actual_committed_size(), vs-&gt;high());
 547 }
 548 
 549 void MetaspaceShared::initialize_ptr_marker(CHeapBitMap* ptrmap) {
 550   ArchivePtrMarker::initialize(ptrmap, (address*)_shared_vs.low(), (address*)_shared_vs.high());
 551 }
 552 
 553 // Read/write a data stream for restoring/preserving metadata pointers and
 554 // miscellaneous data from/to the shared archive file.
 555 
 556 void MetaspaceShared::serialize(SerializeClosure* soc) {
 557   int tag = 0;
 558   soc-&gt;do_tag(--tag);
 559 
 560   // Verify the sizes of various metadata in the system.
 561   soc-&gt;do_tag(sizeof(Method));
 562   soc-&gt;do_tag(sizeof(ConstMethod));
 563   soc-&gt;do_tag(arrayOopDesc::base_offset_in_bytes(T_BYTE));
 564   soc-&gt;do_tag(sizeof(ConstantPool));
 565   soc-&gt;do_tag(sizeof(ConstantPoolCache));
 566   soc-&gt;do_tag(objArrayOopDesc::base_offset_in_bytes());
 567   soc-&gt;do_tag(typeArrayOopDesc::base_offset_in_bytes(T_BYTE));
 568   soc-&gt;do_tag(sizeof(Symbol));
 569 
 570   // Dump/restore miscellaneous metadata.
 571   JavaClasses::serialize_offsets(soc);
 572   Universe::serialize(soc);
 573   soc-&gt;do_tag(--tag);
 574 
 575   // Dump/restore references to commonly used names and signatures.
 576   vmSymbols::serialize(soc);
 577   soc-&gt;do_tag(--tag);
 578 
 579   // Dump/restore the symbol/string/subgraph_info tables
 580   SymbolTable::serialize_shared_table_header(soc);
 581   StringTable::serialize_shared_table_header(soc);
 582   HeapShared::serialize_subgraph_info_table_header(soc);
 583   SystemDictionaryShared::serialize_dictionary_headers(soc);
 584 
 585   InstanceMirrorKlass::serialize_offsets(soc);
 586 
 587   // Dump/restore well known classes (pointers)
 588   SystemDictionaryShared::serialize_well_known_klasses(soc);
 589   soc-&gt;do_tag(--tag);
 590 
 591   serialize_cloned_cpp_vtptrs(soc);
 592   soc-&gt;do_tag(--tag);
 593 
 594   soc-&gt;do_tag(666);
 595 }
 596 
 597 address MetaspaceShared::i2i_entry_code_buffers(size_t total_size) {
 598   if (DumpSharedSpaces) {
 599     if (_i2i_entry_code_buffers == NULL) {
 600       _i2i_entry_code_buffers = (address)misc_code_space_alloc(total_size);
 601       _i2i_entry_code_buffers_size = total_size;
 602     }
 603   } else if (UseSharedSpaces) {
 604     assert(_i2i_entry_code_buffers != NULL, &quot;must already been initialized&quot;);
 605   } else {
 606     return NULL;
 607   }
 608 
 609   assert(_i2i_entry_code_buffers_size == total_size, &quot;must not change&quot;);
 610   return _i2i_entry_code_buffers;
 611 }
 612 
 613 uintx MetaspaceShared::object_delta_uintx(void* obj) {
 614   Arguments::assert_is_dumping_archive();
 615   if (DumpSharedSpaces) {
 616     assert(shared_rs()-&gt;contains(obj), &quot;must be&quot;);
 617   } else {
 618     assert(is_in_shared_metaspace(obj) || DynamicArchive::is_in_target_space(obj), &quot;must be&quot;);
 619   }
 620   address base_address = address(SharedBaseAddress);
 621   uintx deltax = address(obj) - base_address;
 622   return deltax;
 623 }
 624 
 625 // Global object for holding classes that have been loaded.  Since this
 626 // is run at a safepoint just before exit, this is the entire set of classes.
 627 static GrowableArray&lt;Klass*&gt;* _global_klass_objects;
 628 
 629 static int global_klass_compare(Klass** a, Klass **b) {
 630   return a[0]-&gt;name()-&gt;fast_compare(b[0]-&gt;name());
 631 }
 632 
 633 GrowableArray&lt;Klass*&gt;* MetaspaceShared::collected_klasses() {
 634   return _global_klass_objects;
 635 }
 636 
 637 static void collect_array_classes(Klass* k) {
 638   _global_klass_objects-&gt;append_if_missing(k);
 639   if (k-&gt;is_array_klass()) {
 640     // Add in the array classes too
 641     ArrayKlass* ak = ArrayKlass::cast(k);
 642     Klass* h = ak-&gt;higher_dimension();
 643     if (h != NULL) {
 644       h-&gt;array_klasses_do(collect_array_classes);
 645     }
 646   }
 647 }
 648 
 649 class CollectClassesClosure : public KlassClosure {
 650   void do_klass(Klass* k) {
 651     if (k-&gt;is_instance_klass() &amp;&amp;
 652         SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k))) {
 653       // Don&#39;t add to the _global_klass_objects
 654     } else {
 655       _global_klass_objects-&gt;append_if_missing(k);
 656     }
 657     if (k-&gt;is_array_klass()) {
 658       // Add in the array classes too
 659       ArrayKlass* ak = ArrayKlass::cast(k);
 660       Klass* h = ak-&gt;higher_dimension();
 661       if (h != NULL) {
 662         h-&gt;array_klasses_do(collect_array_classes);
 663       }
 664     }
 665   }
 666 };
 667 
 668 // Global object for holding symbols that created during class loading. See SymbolTable::new_symbol
 669 static GrowableArray&lt;Symbol*&gt;* _global_symbol_objects = NULL;
 670 
 671 static int compare_symbols_by_address(Symbol** a, Symbol** b) {
 672   if (a[0] &lt; b[0]) {
 673     return -1;
 674   } else if (a[0] == b[0]) {
 675     ResourceMark rm;
 676     log_warning(cds)(&quot;Duplicated symbol %s unexpected&quot;, (*a)-&gt;as_C_string());
 677     return 0;
 678   } else {
 679     return 1;
 680   }
 681 }
 682 
 683 void MetaspaceShared::add_symbol(Symbol* sym) {
 684   MutexLocker ml(CDSAddSymbol_lock, Mutex::_no_safepoint_check_flag);
 685   if (_global_symbol_objects == NULL) {
 686     _global_symbol_objects = new (ResourceObj::C_HEAP, mtSymbol) GrowableArray&lt;Symbol*&gt;(2048, mtSymbol);
 687   }
 688   _global_symbol_objects-&gt;append(sym);
 689 }
 690 
 691 GrowableArray&lt;Symbol*&gt;* MetaspaceShared::collected_symbols() {
 692   return _global_symbol_objects;
 693 }
 694 
 695 static void remove_unshareable_in_classes() {
 696   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 697     Klass* k = _global_klass_objects-&gt;at(i);
 698     if (!k-&gt;is_objArray_klass()) {
 699       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 700       // on their array classes.
 701       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 702       k-&gt;remove_unshareable_info();
 703     }
 704   }
 705 }
 706 
 707 static void remove_java_mirror_in_classes() {
 708   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 709     Klass* k = _global_klass_objects-&gt;at(i);
 710     if (!k-&gt;is_objArray_klass()) {
 711       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 712       // on their array classes.
 713       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 714       k-&gt;remove_java_mirror();
 715     }
 716   }
 717 }
 718 
 719 static void clear_basic_type_mirrors() {
 720   assert(!HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
 721   Universe::set_int_mirror(NULL);
 722   Universe::set_float_mirror(NULL);
 723   Universe::set_double_mirror(NULL);
 724   Universe::set_byte_mirror(NULL);
 725   Universe::set_bool_mirror(NULL);
 726   Universe::set_char_mirror(NULL);
 727   Universe::set_long_mirror(NULL);
 728   Universe::set_short_mirror(NULL);
 729   Universe::set_void_mirror(NULL);
 730 }
 731 
 732 static void rewrite_nofast_bytecode(const methodHandle&amp; method) {
 733   BytecodeStream bcs(method);
 734   while (!bcs.is_last_bytecode()) {
 735     Bytecodes::Code opcode = bcs.next();
 736     switch (opcode) {
 737     case Bytecodes::_getfield:      *bcs.bcp() = Bytecodes::_nofast_getfield;      break;
 738     case Bytecodes::_putfield:      *bcs.bcp() = Bytecodes::_nofast_putfield;      break;
 739     case Bytecodes::_aload_0:       *bcs.bcp() = Bytecodes::_nofast_aload_0;       break;
 740     case Bytecodes::_iload: {
 741       if (!bcs.is_wide()) {
 742         *bcs.bcp() = Bytecodes::_nofast_iload;
 743       }
 744       break;
 745     }
 746     default: break;
 747     }
 748   }
 749 }
 750 
 751 // Walk all methods in the class list to ensure that they won&#39;t be modified at
 752 // run time. This includes:
 753 // [1] Rewrite all bytecodes as needed, so that the ConstMethod* will not be modified
 754 //     at run time by RewriteBytecodes/RewriteFrequentPairs
 755 // [2] Assign a fingerprint, so one doesn&#39;t need to be assigned at run-time.
 756 static void rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread) {
 757   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 758     Klass* k = _global_klass_objects-&gt;at(i);
 759     if (k-&gt;is_instance_klass()) {
 760       InstanceKlass* ik = InstanceKlass::cast(k);
 761       MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(thread, ik);
 762     }
 763   }
 764 }
 765 
 766 void MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {
 767   for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
 768     methodHandle m(thread, ik-&gt;methods()-&gt;at(i));
 769     rewrite_nofast_bytecode(m);
 770     Fingerprinter fp(m);
 771     // The side effect of this call sets method&#39;s fingerprint field.
 772     fp.fingerprint();
 773   }
 774 }
 775 
 776 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 777 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 778 //
 779 // Addresses of the vtables and the methods may be different across JVM runs,
 780 // if libjvm.so is dynamically loaded at a different base address.
 781 //
 782 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 783 //
 784 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 785 //                  the CDS image
 786 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 787 //                  into our own tables.
 788 
 789 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 790 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 791   f(ConstantPool) \
<a name="2" id="anc2"></a><span class="line-modified"> 792   f(InstanceClassLoaderKlass) \</span>
 793   f(InstanceKlass) \
 794   f(InstanceMirrorKlass) \
 795   f(InstanceRefKlass) \
 796   f(Method) \
 797   f(ObjArrayKlass) \
<a name="3" id="anc3"></a><span class="line-modified"> 798   f(TypeArrayKlass) \</span>
<span class="line-added"> 799   f(FlatArrayKlass) \</span>
<span class="line-added"> 800   f(InlineKlass)</span>
 801 
 802 class CppVtableInfo {
 803   intptr_t _vtable_size;
 804   intptr_t _cloned_vtable[1];
 805 public:
 806   static int num_slots(int vtable_size) {
 807     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 808   }
 809   int vtable_size()           { return int(uintx(_vtable_size)); }
 810   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 811   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 812   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 813   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 814   static size_t byte_size(int vtable_size) {
 815     CppVtableInfo i;
 816     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 817   }
 818 };
 819 
 820 template &lt;class T&gt; class CppVtableCloner : public T {
 821   static intptr_t* vtable_of(Metadata&amp; m) {
 822     return *((intptr_t**)&amp;m);
 823   }
 824   static CppVtableInfo* _info;
 825 
 826   static int get_vtable_length(const char* name);
 827 
 828 public:
 829   // Allocate and initialize the C++ vtable, starting from top, but do not go past end.
 830   static intptr_t* allocate(const char* name);
 831 
 832   // Clone the vtable to ...
 833   static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);
 834 
 835   static void zero_vtable_clone() {
 836     assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 837     _info-&gt;zero();
 838   }
 839 
 840   static bool is_valid_shared_object(const T* obj) {
 841     intptr_t* vptr = *(intptr_t**)obj;
 842     return vptr == _info-&gt;cloned_vtable();
 843   }
 844 };
 845 
 846 template &lt;class T&gt; CppVtableInfo* CppVtableCloner&lt;T&gt;::_info = NULL;
 847 
 848 template &lt;class T&gt;
 849 intptr_t* CppVtableCloner&lt;T&gt;::allocate(const char* name) {
 850   assert(is_aligned(_mc_region.top(), sizeof(intptr_t)), &quot;bad alignment&quot;);
 851   int n = get_vtable_length(name);
 852   _info = (CppVtableInfo*)_mc_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));
 853   _info-&gt;set_vtable_size(n);
 854 
 855   intptr_t* p = clone_vtable(name, _info);
 856   assert((char*)p == _mc_region.top(), &quot;must be&quot;);
 857 
 858   return _info-&gt;cloned_vtable();
 859 }
 860 
 861 template &lt;class T&gt;
 862 intptr_t* CppVtableCloner&lt;T&gt;::clone_vtable(const char* name, CppVtableInfo* info) {
 863   if (!DumpSharedSpaces) {
 864     assert(_info == 0, &quot;_info is initialized only at dump time&quot;);
 865     _info = info; // Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()
 866   }
 867   T tmp; // Allocate temporary dummy metadata object to get to the original vtable.
 868   int n = info-&gt;vtable_size();
 869   intptr_t* srcvtable = vtable_of(tmp);
 870   intptr_t* dstvtable = info-&gt;cloned_vtable();
 871 
 872   // We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are
 873   // safe to do memcpy.
 874   log_debug(cds, vtables)(&quot;Copying %3d vtable entries for %s&quot;, n, name);
 875   memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);
 876   return dstvtable + n;
 877 }
 878 
 879 // To determine the size of the vtable for each type, we use the following
 880 // trick by declaring 2 subclasses:
 881 //
 882 //   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };
 883 //   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };
 884 //
 885 // CppVtableTesterA and CppVtableTesterB&#39;s vtables have the following properties:
 886 // - Their size (N+1) is exactly one more than the size of InstanceKlass&#39;s vtable (N)
 887 // - The first N entries have are exactly the same as in InstanceKlass&#39;s vtable.
 888 // - Their last entry is different.
 889 //
 890 // So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB&#39;s tables
 891 // and find the first entry that&#39;s different.
 892 //
 893 // This works on all C++ compilers supported by Oracle, but you may need to tweak it for more
 894 // esoteric compilers.
 895 
 896 template &lt;class T&gt; class CppVtableTesterB: public T {
 897 public:
 898   virtual int last_virtual_method() {return 1;}
 899 };
 900 
 901 template &lt;class T&gt; class CppVtableTesterA : public T {
 902 public:
 903   virtual void* last_virtual_method() {
 904     // Make this different than CppVtableTesterB::last_virtual_method so the C++
 905     // compiler/linker won&#39;t alias the two functions.
 906     return NULL;
 907   }
 908 };
 909 
 910 template &lt;class T&gt;
 911 int CppVtableCloner&lt;T&gt;::get_vtable_length(const char* name) {
 912   CppVtableTesterA&lt;T&gt; a;
 913   CppVtableTesterB&lt;T&gt; b;
 914 
 915   intptr_t* avtable = vtable_of(a);
 916   intptr_t* bvtable = vtable_of(b);
 917 
 918   // Start at slot 1, because slot 0 may be RTTI (on Solaris/Sparc)
 919   int vtable_len = 1;
 920   for (; ; vtable_len++) {
 921     if (avtable[vtable_len] != bvtable[vtable_len]) {
 922       break;
 923     }
 924   }
 925   log_debug(cds, vtables)(&quot;Found   %3d vtable entries for %s&quot;, vtable_len, name);
 926 
 927   return vtable_len;
 928 }
 929 
 930 #define ALLOC_CPP_VTABLE_CLONE(c) \
 931   _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner&lt;c&gt;::allocate(#c); \
 932   ArchivePtrMarker::mark_pointer(&amp;_cloned_cpp_vtptrs[c##_Kind]);
 933 
 934 #define CLONE_CPP_VTABLE(c) \
 935   p = CppVtableCloner&lt;c&gt;::clone_vtable(#c, (CppVtableInfo*)p);
 936 
 937 #define ZERO_CPP_VTABLE(c) \
 938  CppVtableCloner&lt;c&gt;::zero_vtable_clone();
 939 
 940 //------------------------------ for DynamicDumpSharedSpaces - start
 941 #define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,
 942 
 943 enum {
 944   // E.g., ConstantPool_Kind == 0, InstanceKlass == 1, etc.
 945   CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)
 946   _num_cloned_vtable_kinds
 947 };
 948 
 949 // This is the index of all the cloned vtables. E.g., for
 950 //     ConstantPool* cp = ....; // an archived constant pool
 951 //     InstanceKlass* ik = ....;// an archived class
 952 // the following holds true:
 953 //     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]
 954 //     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]
 955 static intptr_t** _cloned_cpp_vtptrs = NULL;
 956 
 957 void MetaspaceShared::allocate_cloned_cpp_vtptrs() {
 958   assert(DumpSharedSpaces, &quot;must&quot;);
 959   size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);
 960   _cloned_cpp_vtptrs = (intptr_t**)_mc_region.allocate(vtptrs_bytes, sizeof(intptr_t*));
 961 }
 962 
 963 void MetaspaceShared::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {
 964   soc-&gt;do_ptr((void**)&amp;_cloned_cpp_vtptrs);
 965 }
 966 
 967 intptr_t* MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(MetaspaceObj::Type msotype, address obj) {
 968   Arguments::assert_is_dumping_archive();
 969   int kind = -1;
 970   switch (msotype) {
 971   case MetaspaceObj::SymbolType:
 972   case MetaspaceObj::TypeArrayU1Type:
 973   case MetaspaceObj::TypeArrayU2Type:
 974   case MetaspaceObj::TypeArrayU4Type:
 975   case MetaspaceObj::TypeArrayU8Type:
 976   case MetaspaceObj::TypeArrayOtherType:
 977   case MetaspaceObj::ConstMethodType:
 978   case MetaspaceObj::ConstantPoolCacheType:
 979   case MetaspaceObj::AnnotationsType:
 980   case MetaspaceObj::MethodCountersType:
 981   case MetaspaceObj::RecordComponentType:
 982     // These have no vtables.
 983     break;
 984   case MetaspaceObj::ClassType:
 985     {
 986       Klass* k = (Klass*)obj;
 987       assert(k-&gt;is_klass(), &quot;must be&quot;);
<a name="4" id="anc4"></a><span class="line-modified"> 988       if (k-&gt;is_inline_klass()) {</span>
<span class="line-added"> 989         kind = InlineKlass_Kind;</span>
<span class="line-added"> 990       } else if (k-&gt;is_instance_klass()) {</span>
 991         InstanceKlass* ik = InstanceKlass::cast(k);
 992         if (ik-&gt;is_class_loader_instance_klass()) {
 993           kind = InstanceClassLoaderKlass_Kind;
 994         } else if (ik-&gt;is_reference_instance_klass()) {
 995           kind = InstanceRefKlass_Kind;
 996         } else if (ik-&gt;is_mirror_instance_klass()) {
 997           kind = InstanceMirrorKlass_Kind;
 998         } else {
 999           kind = InstanceKlass_Kind;
1000         }
1001       } else if (k-&gt;is_typeArray_klass()) {
1002         kind = TypeArrayKlass_Kind;
1003       } else {
1004         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
1005         kind = ObjArrayKlass_Kind;
1006       }
1007     }
1008     break;
1009 
1010   case MetaspaceObj::MethodType:
1011     {
1012       Method* m = (Method*)obj;
1013       assert(m-&gt;is_method(), &quot;must be&quot;);
1014       kind = Method_Kind;
1015     }
1016     break;
1017 
1018   case MetaspaceObj::MethodDataType:
1019     // We don&#39;t archive MethodData &lt;-- should have been removed in removed_unsharable_info
1020     ShouldNotReachHere();
1021     break;
1022 
1023   case MetaspaceObj::ConstantPoolType:
1024     {
1025       ConstantPool *cp = (ConstantPool*)obj;
1026       assert(cp-&gt;is_constantPool(), &quot;must be&quot;);
1027       kind = ConstantPool_Kind;
1028     }
1029     break;
1030 
1031   default:
1032     ShouldNotReachHere();
1033   }
1034 
1035   if (kind &gt;= 0) {
1036     assert(kind &lt; _num_cloned_vtable_kinds, &quot;must be&quot;);
1037     return _cloned_cpp_vtptrs[kind];
1038   } else {
1039     return NULL;
1040   }
1041 }
1042 
1043 //------------------------------ for DynamicDumpSharedSpaces - end
1044 
1045 // This can be called at both dump time and run time:
1046 // - clone the contents of the c++ vtables into the space
1047 //   allocated by allocate_cpp_vtable_clones()
1048 void MetaspaceShared::clone_cpp_vtables(intptr_t* p) {
1049   assert(DumpSharedSpaces || UseSharedSpaces, &quot;sanity&quot;);
1050   CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);
1051 }
1052 
1053 void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {
1054   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
1055   CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);
1056 }
1057 
1058 // Allocate and initialize the C++ vtables, starting from top, but do not go past end.
1059 char* MetaspaceShared::allocate_cpp_vtable_clones() {
1060   char* cloned_vtables = _mc_region.top(); // This is the beginning of all the cloned vtables
1061 
1062   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
1063   // Layout (each slot is a intptr_t):
1064   //   [number of slots in the first vtable = n1]
1065   //   [ &lt;n1&gt; slots for the first vtable]
1066   //   [number of slots in the first second = n2]
1067   //   [ &lt;n2&gt; slots for the second vtable]
1068   //   ...
1069   // The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.
1070   CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);
1071 
1072   return cloned_vtables;
1073 }
1074 
1075 bool MetaspaceShared::is_valid_shared_method(const Method* m) {
1076   assert(is_in_shared_metaspace(m), &quot;must be&quot;);
1077   return CppVtableCloner&lt;Method&gt;::is_valid_shared_object(m);
1078 }
1079 
1080 void WriteClosure::do_oop(oop* o) {
1081   if (*o == NULL) {
1082     _dump_region-&gt;append_intptr_t(0);
1083   } else {
1084     assert(HeapShared::is_heap_object_archiving_allowed(),
1085            &quot;Archiving heap object is not allowed&quot;);
1086     _dump_region-&gt;append_intptr_t(
1087       (intptr_t)CompressedOops::encode_not_null(*o));
1088   }
1089 }
1090 
1091 void WriteClosure::do_region(u_char* start, size_t size) {
1092   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);
1093   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);
1094   do_tag((int)size);
1095   while (size &gt; 0) {
1096     _dump_region-&gt;append_intptr_t(*(intptr_t*)start, true);
1097     start += sizeof(intptr_t);
1098     size -= sizeof(intptr_t);
1099   }
1100 }
1101 
1102 // This is for dumping detailed statistics for the allocations
1103 // in the shared spaces.
1104 class DumpAllocStats : public ResourceObj {
1105 public:
1106 
1107   // Here&#39;s poor man&#39;s enum inheritance
1108 #define SHAREDSPACE_OBJ_TYPES_DO(f) \
1109   METASPACE_OBJ_TYPES_DO(f) \
1110   f(SymbolHashentry) \
1111   f(SymbolBucket) \
1112   f(StringHashentry) \
1113   f(StringBucket) \
1114   f(Other)
1115 
1116   enum Type {
1117     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
1118     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
1119     _number_of_types
1120   };
1121 
1122   static const char * type_name(Type type) {
1123     switch(type) {
1124     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
1125     default:
1126       ShouldNotReachHere();
1127       return NULL;
1128     }
1129   }
1130 
1131 public:
1132   enum { RO = 0, RW = 1 };
1133 
1134   int _counts[2][_number_of_types];
1135   int _bytes [2][_number_of_types];
1136 
1137   DumpAllocStats() {
1138     memset(_counts, 0, sizeof(_counts));
1139     memset(_bytes,  0, sizeof(_bytes));
1140   };
1141 
1142   void record(MetaspaceObj::Type type, int byte_size, bool read_only) {
1143     assert(int(type) &gt;= 0 &amp;&amp; type &lt; MetaspaceObj::_number_of_types, &quot;sanity&quot;);
1144     int which = (read_only) ? RO : RW;
1145     _counts[which][type] ++;
1146     _bytes [which][type] += byte_size;
1147   }
1148 
1149   void record_other_type(int byte_size, bool read_only) {
1150     int which = (read_only) ? RO : RW;
1151     _bytes [which][OtherType] += byte_size;
1152   }
1153   void print_stats(int ro_all, int rw_all, int mc_all);
1154 };
1155 
1156 void DumpAllocStats::print_stats(int ro_all, int rw_all, int mc_all) {
1157   // Calculate size of data that was not allocated by Metaspace::allocate()
1158   MetaspaceSharedStats *stats = MetaspaceShared::stats();
1159 
1160   // symbols
1161   _counts[RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_count;
1162   _bytes [RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_bytes;
1163 
1164   _counts[RO][SymbolBucketType] = stats-&gt;symbol.bucket_count;
1165   _bytes [RO][SymbolBucketType] = stats-&gt;symbol.bucket_bytes;
1166 
1167   // strings
1168   _counts[RO][StringHashentryType] = stats-&gt;string.hashentry_count;
1169   _bytes [RO][StringHashentryType] = stats-&gt;string.hashentry_bytes;
1170 
1171   _counts[RO][StringBucketType] = stats-&gt;string.bucket_count;
1172   _bytes [RO][StringBucketType] = stats-&gt;string.bucket_bytes;
1173 
1174   // TODO: count things like dictionary, vtable, etc
1175   _bytes[RW][OtherType] += mc_all;
1176   rw_all += mc_all; // mc is mapped Read/Write
1177 
1178   // prevent divide-by-zero
1179   if (ro_all &lt; 1) {
1180     ro_all = 1;
1181   }
1182   if (rw_all &lt; 1) {
1183     rw_all = 1;
1184   }
1185 
1186   int all_ro_count = 0;
1187   int all_ro_bytes = 0;
1188   int all_rw_count = 0;
1189   int all_rw_bytes = 0;
1190 
1191 // To make fmt_stats be a syntactic constant (for format warnings), use #define.
1192 #define fmt_stats &quot;%-20s: %8d %10d %5.1f | %8d %10d %5.1f | %8d %10d %5.1f&quot;
1193   const char *sep = &quot;--------------------+---------------------------+---------------------------+--------------------------&quot;;
1194   const char *hdr = &quot;                        ro_cnt   ro_bytes     % |   rw_cnt   rw_bytes     % |  all_cnt  all_bytes     %&quot;;
1195 
1196   LogMessage(cds) msg;
1197 
1198   msg.debug(&quot;Detailed metadata info (excluding st regions; rw stats include mc regions):&quot;);
1199   msg.debug(&quot;%s&quot;, hdr);
1200   msg.debug(&quot;%s&quot;, sep);
1201   for (int type = 0; type &lt; int(_number_of_types); type ++) {
1202     const char *name = type_name((Type)type);
1203     int ro_count = _counts[RO][type];
1204     int ro_bytes = _bytes [RO][type];
1205     int rw_count = _counts[RW][type];
1206     int rw_bytes = _bytes [RW][type];
1207     int count = ro_count + rw_count;
1208     int bytes = ro_bytes + rw_bytes;
1209 
1210     double ro_perc = percent_of(ro_bytes, ro_all);
1211     double rw_perc = percent_of(rw_bytes, rw_all);
1212     double perc    = percent_of(bytes, ro_all + rw_all);
1213 
1214     msg.debug(fmt_stats, name,
1215                          ro_count, ro_bytes, ro_perc,
1216                          rw_count, rw_bytes, rw_perc,
1217                          count, bytes, perc);
1218 
1219     all_ro_count += ro_count;
1220     all_ro_bytes += ro_bytes;
1221     all_rw_count += rw_count;
1222     all_rw_bytes += rw_bytes;
1223   }
1224 
1225   int all_count = all_ro_count + all_rw_count;
1226   int all_bytes = all_ro_bytes + all_rw_bytes;
1227 
1228   double all_ro_perc = percent_of(all_ro_bytes, ro_all);
1229   double all_rw_perc = percent_of(all_rw_bytes, rw_all);
1230   double all_perc    = percent_of(all_bytes, ro_all + rw_all);
1231 
1232   msg.debug(&quot;%s&quot;, sep);
1233   msg.debug(fmt_stats, &quot;Total&quot;,
1234                        all_ro_count, all_ro_bytes, all_ro_perc,
1235                        all_rw_count, all_rw_bytes, all_rw_perc,
1236                        all_count, all_bytes, all_perc);
1237 
1238   assert(all_ro_bytes == ro_all, &quot;everything should have been counted&quot;);
1239   assert(all_rw_bytes == rw_all, &quot;everything should have been counted&quot;);
1240 
1241 #undef fmt_stats
1242 }
1243 
1244 // Populate the shared space.
1245 
1246 class VM_PopulateDumpSharedSpace: public VM_Operation {
1247 private:
1248   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1249   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1250 
1251   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1252   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1253 
1254   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1255   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1256   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1257                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1258   void dump_symbols();
1259   char* dump_read_only_tables();
1260   void print_class_stats();
1261   void print_region_stats(FileMapInfo* map_info);
1262   void print_bitmap_region_stats(size_t size, size_t total_size);
1263   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1264                                const char *name, size_t total_size);
1265   void relocate_to_requested_base_address(CHeapBitMap* ptrmap);
1266 
1267 public:
1268 
1269   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1270   void doit();   // outline because gdb sucks
1271   bool allow_nested_vm_operations() const { return true; }
1272 }; // class VM_PopulateDumpSharedSpace
1273 
1274 // ArchiveCompactor --
1275 //
1276 // This class is the central piece of shared archive compaction -- all metaspace data are
1277 // initially allocated outside of the shared regions. ArchiveCompactor copies the
1278 // metaspace data into their final location in the shared regions.
1279 
1280 class ArchiveCompactor : AllStatic {
1281   static const int INITIAL_TABLE_SIZE = 8087;
1282   static const int MAX_TABLE_SIZE     = 1000000;
1283 
1284   static DumpAllocStats* _alloc_stats;
1285 
1286   typedef KVHashtable&lt;address, address, mtInternal&gt; RelocationTable;
1287   static RelocationTable* _new_loc_table;
1288 
1289 public:
1290   static void initialize() {
1291     _alloc_stats = new(ResourceObj::C_HEAP, mtInternal)DumpAllocStats;
1292     _new_loc_table = new RelocationTable(INITIAL_TABLE_SIZE);
1293   }
1294   static DumpAllocStats* alloc_stats() {
1295     return _alloc_stats;
1296   }
1297 
1298   // Use this when you allocate space with MetaspaceShare::read_only_space_alloc()
1299   // outside of ArchiveCompactor::allocate(). These are usually for misc tables
1300   // that are allocated in the RO space.
1301   class OtherROAllocMark {
1302     char* _oldtop;
1303   public:
1304     OtherROAllocMark() {
1305       _oldtop = _ro_region.top();
1306     }
1307     ~OtherROAllocMark() {
1308       char* newtop = _ro_region.top();
1309       ArchiveCompactor::alloc_stats()-&gt;record_other_type(int(newtop - _oldtop), true);
1310     }
1311   };
1312 
1313   static void allocate(MetaspaceClosure::Ref* ref, bool read_only) {
1314     address obj = ref-&gt;obj();
1315     int bytes = ref-&gt;size() * BytesPerWord;
1316     char* p;
1317     size_t alignment = BytesPerWord;
1318     char* oldtop;
1319     char* newtop;
1320 
1321     if (read_only) {
1322       oldtop = _ro_region.top();
1323       p = _ro_region.allocate(bytes, alignment);
1324       newtop = _ro_region.top();
1325     } else {
1326       oldtop = _rw_region.top();
1327       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
1328         // Save a pointer immediate in front of an InstanceKlass, so
1329         // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
1330         // without building another hashtable. See RunTimeSharedClassInfo::get_for()
1331         // in systemDictionaryShared.cpp.
1332         Klass* klass = (Klass*)obj;
1333         if (klass-&gt;is_instance_klass()) {
1334           SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
1335           _rw_region.allocate(sizeof(address), BytesPerWord);
1336         }
1337       }
1338       p = _rw_region.allocate(bytes, alignment);
1339       newtop = _rw_region.top();
1340     }
1341     memcpy(p, obj, bytes);
1342 
1343     intptr_t* cloned_vtable = MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(ref-&gt;msotype(), (address)p);
1344     if (cloned_vtable != NULL) {
1345       *(address*)p = (address)cloned_vtable;
1346       ArchivePtrMarker::mark_pointer((address*)p);
1347     }
1348 
1349     assert(_new_loc_table-&gt;lookup(obj) == NULL, &quot;each object can be relocated at most once&quot;);
1350     _new_loc_table-&gt;add(obj, (address)p);
1351     log_trace(cds)(&quot;Copy: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %d&quot;, p2i(obj), p2i(p), bytes);
1352     if (_new_loc_table-&gt;maybe_grow(MAX_TABLE_SIZE)) {
1353       log_info(cds, hashtables)(&quot;Expanded _new_loc_table to %d&quot;, _new_loc_table-&gt;table_size());
1354     }
1355     _alloc_stats-&gt;record(ref-&gt;msotype(), int(newtop - oldtop), read_only);
1356   }
1357 
1358   static address get_new_loc(MetaspaceClosure::Ref* ref) {
1359     address* pp = _new_loc_table-&gt;lookup(ref-&gt;obj());
1360     assert(pp != NULL, &quot;must be&quot;);
1361     return *pp;
1362   }
1363 
1364 private:
1365   // Makes a shallow copy of visited MetaspaceObj&#39;s
1366   class ShallowCopier: public UniqueMetaspaceClosure {
1367     bool _read_only;
1368   public:
1369     ShallowCopier(bool read_only) : _read_only(read_only) {}
1370 
1371     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1372       if (read_only == _read_only) {
1373         allocate(ref, read_only);
1374       }
1375       return true; // recurse into ref.obj()
1376     }
1377   };
1378 
1379   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1380   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1381   public:
1382     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1383       address new_loc = get_new_loc(ref);
1384       RefRelocator refer;
1385       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1386       return true; // recurse into ref.obj()
1387     }
1388     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
<a name="5" id="anc5"></a><span class="line-modified">1389       assert_valid(type);</span>
<span class="line-added">1390 </span>
1391       address obj = ref-&gt;obj();
1392       address new_obj = get_new_loc(ref);
1393       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1394       intptr_t* new_p = (intptr_t*)(new_obj + offset);
<a name="6" id="anc6"></a><span class="line-modified">1395       switch (type) {</span>
<span class="line-added">1396       case _method_entry_ref:</span>
<span class="line-added">1397         assert(*p == *new_p, &quot;must be a copy&quot;);</span>
<span class="line-added">1398         break;</span>
<span class="line-added">1399       case _internal_pointer_ref:</span>
<span class="line-added">1400         {</span>
<span class="line-added">1401           size_t off = pointer_delta(*((address*)p), obj, sizeof(u1));</span>
<span class="line-added">1402           assert(0 &lt;= intx(off) &amp;&amp; intx(off) &lt; ref-&gt;size() * BytesPerWord, &quot;must point to internal address&quot;);</span>
<span class="line-added">1403           *((address*)new_p) = new_obj + off;</span>
<span class="line-added">1404         }</span>
<span class="line-added">1405         break;</span>
<span class="line-added">1406       default:</span>
<span class="line-added">1407         ShouldNotReachHere();</span>
<span class="line-added">1408       }</span>
1409       ArchivePtrMarker::mark_pointer((address*)new_p);
1410     }
1411   };
1412 
1413   // Relocate a reference to point to its shallow copy
1414   class RefRelocator: public MetaspaceClosure {
1415   public:
1416     virtual bool do_ref(Ref* ref, bool read_only) {
1417       if (ref-&gt;not_null()) {
1418         ref-&gt;update(get_new_loc(ref));
1419         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1420       }
1421       return false; // Do not recurse.
1422     }
1423   };
1424 
1425 #ifdef ASSERT
1426   class IsRefInArchiveChecker: public MetaspaceClosure {
1427   public:
1428     virtual bool do_ref(Ref* ref, bool read_only) {
1429       if (ref-&gt;not_null()) {
1430         char* obj = (char*)ref-&gt;obj();
1431         assert(_ro_region.contains(obj) || _rw_region.contains(obj),
1432                &quot;must be relocated to point to CDS archive&quot;);
1433       }
1434       return false; // Do not recurse.
1435     }
1436   };
1437 #endif
1438 
1439 public:
1440   static void copy_and_compact() {
1441     ResourceMark rm;
1442 
1443     log_info(cds)(&quot;Scanning all metaspace objects ... &quot;);
1444     {
1445       // allocate and shallow-copy RW objects, immediately following the MC region
1446       log_info(cds)(&quot;Allocating RW objects ... &quot;);
1447       _mc_region.pack(&amp;_rw_region);
1448 
1449       ResourceMark rm;
1450       ShallowCopier rw_copier(false);
1451       iterate_roots(&amp;rw_copier);
1452     }
1453     {
1454       // allocate and shallow-copy of RO object, immediately following the RW region
1455       log_info(cds)(&quot;Allocating RO objects ... &quot;);
1456       _rw_region.pack(&amp;_ro_region);
1457 
1458       ResourceMark rm;
1459       ShallowCopier ro_copier(true);
1460       iterate_roots(&amp;ro_copier);
1461     }
1462     {
1463       log_info(cds)(&quot;Relocating embedded pointers ... &quot;);
1464       ResourceMark rm;
1465       ShallowCopyEmbeddedRefRelocator emb_reloc;
1466       iterate_roots(&amp;emb_reloc);
1467     }
1468     {
1469       log_info(cds)(&quot;Relocating external roots ... &quot;);
1470       ResourceMark rm;
1471       RefRelocator ext_reloc;
1472       iterate_roots(&amp;ext_reloc);
1473     }
1474     {
1475       log_info(cds)(&quot;Fixing symbol identity hash ... &quot;);
1476       os::init_random(0x12345678);
1477       GrowableArray&lt;Symbol*&gt;* all_symbols = MetaspaceShared::collected_symbols();
1478       all_symbols-&gt;sort(compare_symbols_by_address);
1479       for (int i = 0; i &lt; all_symbols-&gt;length(); i++) {
1480         assert(all_symbols-&gt;at(i)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1481         all_symbols-&gt;at(i)-&gt;update_identity_hash();
1482       }
1483     }
1484 #ifdef ASSERT
1485     {
1486       log_info(cds)(&quot;Verifying external roots ... &quot;);
1487       ResourceMark rm;
1488       IsRefInArchiveChecker checker;
1489       iterate_roots(&amp;checker);
1490     }
1491 #endif
1492   }
1493 
1494   // We must relocate the System::_well_known_klasses only after we have copied the
1495   // java objects in during dump_java_heap_objects(): during the object copy, we operate on
1496   // old objects which assert that their klass is the original klass.
1497   static void relocate_well_known_klasses() {
1498     {
1499       log_info(cds)(&quot;Relocating SystemDictionary::_well_known_klasses[] ... &quot;);
1500       ResourceMark rm;
1501       RefRelocator ext_reloc;
1502       SystemDictionary::well_known_klasses_do(&amp;ext_reloc);
1503     }
1504     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1505     // objects.
1506 
1507     // We cannot use any of the objects in the heap anymore (except for the
1508     // shared strings) because their headers no longer point to valid Klasses.
1509   }
1510 
1511   static void iterate_roots(MetaspaceClosure* it) {
1512     // To ensure deterministic contents in the archive, we just need to ensure that
1513     // we iterate the MetsapceObjs in a deterministic order. It doesn&#39;t matter where
1514     // the MetsapceObjs are located originally, as they are copied sequentially into
1515     // the archive during the iteration.
1516     //
1517     // The only issue here is that the symbol table and the system directories may be
1518     // randomly ordered, so we copy the symbols and klasses into two arrays and sort
1519     // them deterministically.
1520     //
1521     // During -Xshare:dump, the order of Symbol creation is strictly determined by
1522     // the SharedClassListFile (class loading is done in a single thread and the JIT
1523     // is disabled). Also, Symbols are allocated in monotonically increasing addresses
1524     // (see Symbol::operator new(size_t, int)). So if we iterate the Symbols by
1525     // ascending address order, we ensure that all Symbols are copied into deterministic
1526     // locations in the archive.
1527     GrowableArray&lt;Symbol*&gt;* symbols = _global_symbol_objects;
1528     for (int i = 0; i &lt; symbols-&gt;length(); i++) {
1529       it-&gt;push(symbols-&gt;adr_at(i));
1530     }
1531     if (_global_klass_objects != NULL) {
1532       // Need to fix up the pointers
1533       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1534         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1535         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1536       }
1537     }
1538     FileMapInfo::metaspace_pointers_do(it, false);
1539     SystemDictionaryShared::dumptime_classes_do(it);
1540     Universe::metaspace_pointers_do(it);
1541     SymbolTable::metaspace_pointers_do(it);
1542     vmSymbols::metaspace_pointers_do(it);
1543 
1544     it-&gt;finish();
1545   }
1546 
1547   static Klass* get_relocated_klass(Klass* orig_klass) {
1548     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1549     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1550     assert(pp != NULL, &quot;must be&quot;);
1551     Klass* klass = (Klass*)(*pp);
1552     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1553     return klass;
1554   }
1555 };
1556 
1557 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1558 ArchiveCompactor::RelocationTable* ArchiveCompactor::_new_loc_table;
1559 
1560 void VM_PopulateDumpSharedSpace::dump_symbols() {
1561   log_info(cds)(&quot;Dumping symbol table ...&quot;);
1562 
1563   NOT_PRODUCT(SymbolTable::verify());
1564   SymbolTable::write_to_archive();
1565 }
1566 
1567 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1568   ArchiveCompactor::OtherROAllocMark mark;
1569 
1570   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1571   if (!HeapShared::is_heap_object_archiving_allowed()) {
1572     clear_basic_type_mirrors();
1573   }
1574   remove_java_mirror_in_classes();
1575   log_info(cds)(&quot;done. &quot;);
1576 
1577   SystemDictionaryShared::write_to_archive();
1578 
1579   // Write the other data to the output array.
1580   char* start = _ro_region.top();
1581   WriteClosure wc(&amp;_ro_region);
1582   MetaspaceShared::serialize(&amp;wc);
1583 
1584   // Write the bitmaps for patching the archive heap regions
1585   _closed_archive_heap_oopmaps = NULL;
1586   _open_archive_heap_oopmaps = NULL;
1587   dump_archive_heap_oopmaps();
1588 
1589   return start;
1590 }
1591 
1592 void VM_PopulateDumpSharedSpace::print_class_stats() {
1593   log_info(cds)(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());
1594   {
1595     int num_type_array = 0, num_obj_array = 0, num_inst = 0;
1596     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1597       Klass* k = _global_klass_objects-&gt;at(i);
1598       if (k-&gt;is_instance_klass()) {
1599         num_inst ++;
1600       } else if (k-&gt;is_objArray_klass()) {
1601         num_obj_array ++;
1602       } else {
1603         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);
1604         num_type_array ++;
1605       }
1606     }
1607     log_info(cds)(&quot;    instance classes   = %5d&quot;, num_inst);
1608     log_info(cds)(&quot;    obj array classes  = %5d&quot;, num_obj_array);
1609     log_info(cds)(&quot;    type array classes = %5d&quot;, num_type_array);
1610   }
1611 }
1612 
1613 void VM_PopulateDumpSharedSpace::relocate_to_requested_base_address(CHeapBitMap* ptrmap) {
1614   intx addr_delta = MetaspaceShared::final_delta();
1615   if (addr_delta == 0) {
1616     ArchivePtrMarker::compact((address)SharedBaseAddress, (address)_ro_region.top());
1617   } else {
1618     // We are not able to reserve space at MetaspaceShared::requested_base_address() (due to ASLR).
1619     // This means that the current content of the archive is based on a random
1620     // address. Let&#39;s relocate all the pointers, so that it can be mapped to
1621     // MetaspaceShared::requested_base_address() without runtime relocation.
1622     //
1623     // Note: both the base and dynamic archive are written with
1624     // FileMapHeader::_requested_base_address == MetaspaceShared::requested_base_address()
1625 
1626     // Patch all pointers that are marked by ptrmap within this region,
1627     // where we have just dumped all the metaspace data.
1628     address patch_base = (address)SharedBaseAddress;
1629     address patch_end  = (address)_ro_region.top();
1630     size_t size = patch_end - patch_base;
1631 
1632     // the current value of the pointers to be patched must be within this
1633     // range (i.e., must point to valid metaspace objects)
1634     address valid_old_base = patch_base;
1635     address valid_old_end  = patch_end;
1636 
1637     // after patching, the pointers must point inside this range
1638     // (the requested location of the archive, as mapped at runtime).
1639     address valid_new_base = (address)MetaspaceShared::requested_base_address();
1640     address valid_new_end  = valid_new_base + size;
1641 
1642     log_debug(cds)(&quot;Relocating archive from [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ] to &quot;
1643                    &quot;[&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ]&quot;, p2i(patch_base), p2i(patch_end),
1644                    p2i(valid_new_base), p2i(valid_new_end));
1645 
1646     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1647                                       valid_new_base, valid_new_end, addr_delta, ptrmap);
1648     ptrmap-&gt;iterate(&amp;patcher);
1649     ArchivePtrMarker::compact(patcher.max_non_null_offset());
1650   }
1651 }
1652 
1653 void VM_PopulateDumpSharedSpace::doit() {
1654   HeapShared::run_full_gc_in_vm_thread();
1655   CHeapBitMap ptrmap;
1656   MetaspaceShared::initialize_ptr_marker(&amp;ptrmap);
1657 
1658   // We should no longer allocate anything from the metaspace, so that:
1659   //
1660   // (1) Metaspace::allocate might trigger GC if we have run out of
1661   //     committed metaspace, but we can&#39;t GC because we&#39;re running
1662   //     in the VM thread.
1663   // (2) ArchiveCompactor needs to work with a stable set of MetaspaceObjs.
1664   Metaspace::freeze();
1665   DEBUG_ONLY(SystemDictionaryShared::NoClassLoadingMark nclm);
1666 
1667   Thread* THREAD = VMThread::vm_thread();
1668 
1669   FileMapInfo::check_nonempty_dir_in_shared_path_table();
1670 
1671   NOT_PRODUCT(SystemDictionary::verify();)
1672   // The following guarantee is meant to ensure that no loader constraints
1673   // exist yet, since the constraints table is not shared.  This becomes
1674   // more important now that we don&#39;t re-initialize vtables/itables for
1675   // shared classes at runtime, where constraints were previously created.
1676   guarantee(SystemDictionary::constraints()-&gt;number_of_entries() == 0,
1677             &quot;loader constraints are not saved&quot;);
1678   guarantee(SystemDictionary::placeholders()-&gt;number_of_entries() == 0,
1679           &quot;placeholders are not saved&quot;);
1680 
1681   // At this point, many classes have been loaded.
1682   // Gather systemDictionary classes in a global array and do everything to
1683   // that so we don&#39;t have to walk the SystemDictionary again.
1684   SystemDictionaryShared::check_excluded_classes();
1685   _global_klass_objects = new GrowableArray&lt;Klass*&gt;(1000);
1686   CollectClassesClosure collect_classes;
1687   ClassLoaderDataGraph::loaded_classes_do(&amp;collect_classes);
1688   _global_klass_objects-&gt;sort(global_klass_compare);
1689 
1690   print_class_stats();
1691 
1692   // Ensure the ConstMethods won&#39;t be modified at run-time
1693   log_info(cds)(&quot;Updating ConstMethods ... &quot;);
1694   rewrite_nofast_bytecodes_and_calculate_fingerprints(THREAD);
1695   log_info(cds)(&quot;done. &quot;);
1696 
1697   // Remove all references outside the metadata
1698   log_info(cds)(&quot;Removing unshareable information ... &quot;);
1699   remove_unshareable_in_classes();
1700   log_info(cds)(&quot;done. &quot;);
1701 
1702   MetaspaceShared::allocate_cloned_cpp_vtptrs();
1703   char* cloned_vtables = _mc_region.top();
1704   MetaspaceShared::allocate_cpp_vtable_clones();
1705 
1706   ArchiveCompactor::initialize();
1707   ArchiveCompactor::copy_and_compact();
1708 
1709   dump_symbols();
1710 
1711   // Dump supported java heap objects
1712   _closed_archive_heap_regions = NULL;
1713   _open_archive_heap_regions = NULL;
1714   dump_java_heap_objects();
1715 
1716   ArchiveCompactor::relocate_well_known_klasses();
1717 
1718   char* serialized_data = dump_read_only_tables();
1719   _ro_region.pack();
1720 
1721   // The vtable clones contain addresses of the current process.
1722   // We don&#39;t want to write these addresses into the archive. Same for i2i buffer.
1723   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1724   memset(MetaspaceShared::i2i_entry_code_buffers(), 0,
1725          MetaspaceShared::i2i_entry_code_buffers_size());
1726 
1727   // relocate the data so that it can be mapped to MetaspaceShared::requested_base_address()
1728   // without runtime relocation.
1729   relocate_to_requested_base_address(&amp;ptrmap);
1730 
1731   // Create and write the archive file that maps the shared spaces.
1732 
1733   FileMapInfo* mapinfo = new FileMapInfo(true);
1734   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
1735   mapinfo-&gt;set_serialized_data(serialized_data);
1736   mapinfo-&gt;set_cloned_vtables(cloned_vtables);
1737   mapinfo-&gt;set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers(),
1738                                       MetaspaceShared::i2i_entry_code_buffers_size());
1739   mapinfo-&gt;open_for_write();
1740   MetaspaceShared::write_core_archive_regions(mapinfo, _closed_archive_heap_oopmaps, _open_archive_heap_oopmaps);
1741   _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1742                                         _closed_archive_heap_regions,
1743                                         _closed_archive_heap_oopmaps,
1744                                         MetaspaceShared::first_closed_archive_heap_region,
1745                                         MetaspaceShared::max_closed_archive_heap_region);
1746   _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1747                                         _open_archive_heap_regions,
1748                                         _open_archive_heap_oopmaps,
1749                                         MetaspaceShared::first_open_archive_heap_region,
1750                                         MetaspaceShared::max_open_archive_heap_region);
1751 
1752   mapinfo-&gt;set_final_requested_base((char*)MetaspaceShared::requested_base_address());
1753   mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());
1754   mapinfo-&gt;write_header();
1755   print_region_stats(mapinfo);
1756   mapinfo-&gt;close();
1757 
1758   if (log_is_enabled(Info, cds)) {
1759     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
1760                                                  int(_mc_region.used()));
1761   }
1762 
1763   if (PrintSystemDictionaryAtExit) {
1764     SystemDictionary::print();
1765   }
1766 
1767   if (AllowArchivingWithJavaAgent) {
1768     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1769             &quot;for testing purposes only and should not be used in a production environment&quot;);
1770   }
1771 
1772   // There may be other pending VM operations that operate on the InstanceKlasses,
1773   // which will fail because InstanceKlasses::remove_unshareable_info()
1774   // has been called. Forget these operations and exit the VM directly.
1775   vm_direct_exit(0);
1776 }
1777 
1778 void VM_PopulateDumpSharedSpace::print_region_stats(FileMapInfo *map_info) {
1779   // Print statistics of all the regions
1780   const size_t bitmap_used = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used();
1781   const size_t bitmap_reserved = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used_aligned();
1782   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
1783                                 _mc_region.reserved()  +
1784                                 bitmap_reserved +
1785                                 _total_closed_archive_region_size +
1786                                 _total_open_archive_region_size;
1787   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
1788                              _mc_region.used()  +
1789                              bitmap_used +
1790                              _total_closed_archive_region_size +
1791                              _total_open_archive_region_size;
1792   const double total_u_perc = percent_of(total_bytes, total_reserved);
1793 
1794   _mc_region.print(total_reserved);
1795   _rw_region.print(total_reserved);
1796   _ro_region.print(total_reserved);
1797   print_bitmap_region_stats(bitmap_used, total_reserved);
1798   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1799   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1800 
1801   log_debug(cds)(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,
1802                  total_bytes, total_reserved, total_u_perc);
1803 }
1804 
1805 void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {
1806   log_debug(cds)(&quot;bm  space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used]&quot;,
1807                  size, size/double(total_size)*100.0, size);
1808 }
1809 
1810 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1811                                                          const char *name, size_t total_size) {
1812   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1813   for (int i = 0; i &lt; arr_len; i++) {
1814       char* start = (char*)heap_mem-&gt;at(i).start();
1815       size_t size = heap_mem-&gt;at(i).byte_size();
1816       char* top = start + size;
1817       log_debug(cds)(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1818                      name, i, size, size/double(total_size)*100.0, size, p2i(start));
1819 
1820   }
1821 }
1822 
1823 void MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo,
1824                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,
1825                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps) {
1826   // Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with
1827   // MetaspaceShared::n_regions (internal to hotspot).
1828   assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, &quot;sanity&quot;);
1829 
1830   // mc contains the trampoline code for method entries, which are patched at run time,
1831   // so it needs to be read/write.
1832   write_region(mapinfo, mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);
1833   write_region(mapinfo, rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);
1834   write_region(mapinfo, ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);
1835   mapinfo-&gt;write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_oopmaps, open_oopmaps);
1836 }
1837 
1838 void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {
1839   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);
1840 }
1841 
1842 // Update a Java object to point its Klass* to the new location after
1843 // shared archive has been compacted.
1844 void MetaspaceShared::relocate_klass_ptr(oop o) {
1845   assert(DumpSharedSpaces, &quot;sanity&quot;);
1846   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1847   o-&gt;set_klass(k);
1848 }
1849 
1850 Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {
1851   assert(DumpSharedSpaces, &quot;sanity&quot;);
1852   k = ArchiveCompactor::get_relocated_klass(k);
1853   if (is_final) {
1854     k = (Klass*)(address(k) + final_delta());
1855   }
1856   return k;
1857 }
1858 
1859 class LinkSharedClassesClosure : public KlassClosure {
1860   Thread* THREAD;
1861   bool    _made_progress;
1862  public:
1863   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1864 
1865   void reset()               { _made_progress = false; }
1866   bool made_progress() const { return _made_progress; }
1867 
1868   void do_klass(Klass* k) {
1869     if (k-&gt;is_instance_klass()) {
1870       InstanceKlass* ik = InstanceKlass::cast(k);
1871       // For dynamic CDS dump, only link classes loaded by the builtin class loaders.
1872       bool do_linking = DumpSharedSpaces ? true : !ik-&gt;is_shared_unregistered_class();
1873       if (do_linking) {
1874         // Link the class to cause the bytecodes to be rewritten and the
1875         // cpcache to be created. Class verification is done according
1876         // to -Xverify setting.
1877         _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);
1878         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1879 
1880         if (DumpSharedSpaces) {
1881           // The following function is used to resolve all Strings in the statically
1882           // dumped classes to archive all the Strings. The archive heap is not supported
1883           // for the dynamic archive.
1884           ik-&gt;constants()-&gt;resolve_class_constants(THREAD);
1885         }
1886       }
1887     }
1888   }
1889 };
1890 
1891 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1892   // We need to iterate because verification may cause additional classes
1893   // to be loaded.
1894   LinkSharedClassesClosure link_closure(THREAD);
1895   do {
1896     link_closure.reset();
1897     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1898     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1899   } while (link_closure.made_progress());
1900 }
1901 
1902 void MetaspaceShared::prepare_for_dumping() {
1903   Arguments::check_unsupported_dumping_properties();
1904   ClassLoader::initialize_shared_path();
1905 }
1906 
1907 // Preload classes from a list, populate the shared spaces and dump to a
1908 // file.
1909 void MetaspaceShared::preload_and_dump(TRAPS) {
1910   { TraceTime timer(&quot;Dump Shared Spaces&quot;, TRACETIME_LOG(Info, startuptime));
1911     ResourceMark rm(THREAD);
1912     char class_list_path_str[JVM_MAXPATHLEN];
1913     // Preload classes to be shared.
1914     const char* class_list_path;
1915     if (SharedClassListFile == NULL) {
1916       // Construct the path to the class list (in jre/lib)
1917       // Walk up two directories from the location of the VM and
1918       // optionally tack on &quot;lib&quot; (depending on platform)
1919       os::jvm_path(class_list_path_str, sizeof(class_list_path_str));
1920       for (int i = 0; i &lt; 3; i++) {
1921         char *end = strrchr(class_list_path_str, *os::file_separator());
1922         if (end != NULL) *end = &#39;\0&#39;;
1923       }
1924       int class_list_path_len = (int)strlen(class_list_path_str);
1925       if (class_list_path_len &gt;= 3) {
1926         if (strcmp(class_list_path_str + class_list_path_len - 3, &quot;lib&quot;) != 0) {
1927           if (class_list_path_len &lt; JVM_MAXPATHLEN - 4) {
1928             jio_snprintf(class_list_path_str + class_list_path_len,
1929                          sizeof(class_list_path_str) - class_list_path_len,
1930                          &quot;%slib&quot;, os::file_separator());
1931             class_list_path_len += 4;
1932           }
1933         }
1934       }
1935       if (class_list_path_len &lt; JVM_MAXPATHLEN - 10) {
1936         jio_snprintf(class_list_path_str + class_list_path_len,
1937                      sizeof(class_list_path_str) - class_list_path_len,
1938                      &quot;%sclasslist&quot;, os::file_separator());
1939       }
1940       class_list_path = class_list_path_str;
1941     } else {
1942       class_list_path = SharedClassListFile;
1943     }
1944 
1945     log_info(cds)(&quot;Loading classes to share ...&quot;);
1946     _has_error_classes = false;
1947     int class_count = preload_classes(class_list_path, THREAD);
1948     if (ExtraSharedClassListFile) {
1949       class_count += preload_classes(ExtraSharedClassListFile, THREAD);
1950     }
1951     log_info(cds)(&quot;Loading classes to share: done.&quot;);
1952 
1953     log_info(cds)(&quot;Shared spaces: preloaded %d classes&quot;, class_count);
1954 
1955     if (SharedArchiveConfigFile) {
1956       log_info(cds)(&quot;Reading extra data from %s ...&quot;, SharedArchiveConfigFile);
1957       read_extra_data(SharedArchiveConfigFile, THREAD);
1958     }
1959     log_info(cds)(&quot;Reading extra data: done.&quot;);
1960 
1961     HeapShared::init_subgraph_entry_fields(THREAD);
1962 
1963     // Rewrite and link classes
1964     log_info(cds)(&quot;Rewriting and linking classes ...&quot;);
1965 
1966     // Link any classes which got missed. This would happen if we have loaded classes that
1967     // were not explicitly specified in the classlist. E.g., if an interface implemented by class K
1968     // fails verification, all other interfaces that were not specified in the classlist but
1969     // are implemented by K are not verified.
1970     link_and_cleanup_shared_classes(CATCH);
1971     log_info(cds)(&quot;Rewriting and linking classes: done&quot;);
1972 
1973     VM_PopulateDumpSharedSpace op;
1974     MutexLocker ml(THREAD, HeapShared::is_heap_object_archiving_allowed() ?
1975                    Heap_lock : NULL);     // needed by HeapShared::run_gc()
1976     VMThread::execute(&amp;op);
1977   }
1978 }
1979 
1980 
1981 int MetaspaceShared::preload_classes(const char* class_list_path, TRAPS) {
1982   ClassListParser parser(class_list_path);
1983   int class_count = 0;
1984 
1985   while (parser.parse_one_line()) {
1986     Klass* klass = parser.load_current_class(THREAD);
1987     if (HAS_PENDING_EXCEPTION) {
1988       if (klass == NULL &amp;&amp;
1989           (PENDING_EXCEPTION-&gt;klass()-&gt;name() == vmSymbols::java_lang_ClassNotFoundException())) {
1990         // print a warning only when the pending exception is class not found
1991         log_warning(cds)(&quot;Preload Warning: Cannot find %s&quot;, parser.current_class_name());
1992       }
1993       CLEAR_PENDING_EXCEPTION;
1994     }
1995     if (klass != NULL) {
1996       if (log_is_enabled(Trace, cds)) {
1997         ResourceMark rm(THREAD);
1998         log_trace(cds)(&quot;Shared spaces preloaded: %s&quot;, klass-&gt;external_name());
1999       }
2000 
2001       if (klass-&gt;is_instance_klass()) {
2002         InstanceKlass* ik = InstanceKlass::cast(klass);
2003 
2004         // Link the class to cause the bytecodes to be rewritten and the
2005         // cpcache to be created. The linking is done as soon as classes
2006         // are loaded in order that the related data structures (klass and
2007         // cpCache) are located together.
2008         try_link_class(ik, THREAD);
2009         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
2010       }
2011 
2012       class_count++;
2013     }
2014   }
2015 
2016   return class_count;
2017 }
2018 
2019 // Returns true if the class&#39;s status has changed
2020 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
2021   Arguments::assert_is_dumping_archive();
2022   if (ik-&gt;init_state() &lt; InstanceKlass::linked &amp;&amp;
2023       !SystemDictionaryShared::has_class_failed_verification(ik)) {
2024     bool saved = BytecodeVerificationLocal;
2025     if (ik-&gt;is_shared_unregistered_class() &amp;&amp; ik-&gt;class_loader() == NULL) {
2026       // The verification decision is based on BytecodeVerificationRemote
2027       // for non-system classes. Since we are using the NULL classloader
2028       // to load non-system classes for customized class loaders during dumping,
2029       // we need to temporarily change BytecodeVerificationLocal to be the same as
2030       // BytecodeVerificationRemote. Note this can cause the parent system
2031       // classes also being verified. The extra overhead is acceptable during
2032       // dumping.
2033       BytecodeVerificationLocal = BytecodeVerificationRemote;
2034     }
2035     ik-&gt;link_class(THREAD);
2036     if (HAS_PENDING_EXCEPTION) {
2037       ResourceMark rm(THREAD);
2038       log_warning(cds)(&quot;Preload Warning: Verification failed for %s&quot;,
2039                     ik-&gt;external_name());
2040       CLEAR_PENDING_EXCEPTION;
2041       SystemDictionaryShared::set_class_has_failed_verification(ik);
2042       _has_error_classes = true;
2043     }
2044     BytecodeVerificationLocal = saved;
2045     return true;
2046   } else {
2047     return false;
2048   }
2049 }
2050 
2051 #if INCLUDE_CDS_JAVA_HEAP
2052 void VM_PopulateDumpSharedSpace::dump_java_heap_objects() {
2053   // The closed and open archive heap space has maximum two regions.
2054   // See FileMapInfo::write_archive_heap_regions() for details.
2055   _closed_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
2056   _open_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
2057   HeapShared::archive_java_heap_objects(_closed_archive_heap_regions,
2058                                         _open_archive_heap_regions);
2059   ArchiveCompactor::OtherROAllocMark mark;
2060   HeapShared::write_subgraph_info_table();
2061 }
2062 
2063 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
2064   if (HeapShared::is_heap_object_archiving_allowed()) {
2065     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
2066     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
2067 
2068     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
2069     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
2070   }
2071 }
2072 
2073 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
2074                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
2075   for (int i=0; i&lt;regions-&gt;length(); i++) {
2076     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
2077     size_t size_in_bits = oopmap.size();
2078     size_t size_in_bytes = oopmap.size_in_bytes();
2079     uintptr_t* buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);
2080     oopmap.write_to(buffer, size_in_bytes);
2081     log_info(cds, heap)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;
2082                         INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,
2083                         p2i(buffer), size_in_bytes,
2084                         p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());
2085 
2086     ArchiveHeapOopmapInfo info;
2087     info._oopmap = (address)buffer;
2088     info._oopmap_size_in_bits = size_in_bits;
2089     info._oopmap_size_in_bytes = size_in_bytes;
2090     oopmaps-&gt;append(info);
2091   }
2092 }
2093 #endif // INCLUDE_CDS_JAVA_HEAP
2094 
2095 void ReadClosure::do_ptr(void** p) {
2096   assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);
2097   intptr_t obj = nextPtr();
2098   assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,
2099          &quot;hit tag while initializing ptrs.&quot;);
2100   *p = (void*)obj;
2101 }
2102 
2103 void ReadClosure::do_u4(u4* p) {
2104   intptr_t obj = nextPtr();
2105   *p = (u4)(uintx(obj));
2106 }
2107 
2108 void ReadClosure::do_bool(bool* p) {
2109   intptr_t obj = nextPtr();
2110   *p = (bool)(uintx(obj));
2111 }
2112 
2113 void ReadClosure::do_tag(int tag) {
2114   int old_tag;
2115   old_tag = (int)(intptr_t)nextPtr();
2116   // do_int(&amp;old_tag);
2117   assert(tag == old_tag, &quot;old tag doesn&#39;t match&quot;);
2118   FileMapInfo::assert_mark(tag == old_tag);
2119 }
2120 
2121 void ReadClosure::do_oop(oop *p) {
2122   narrowOop o = (narrowOop)nextPtr();
2123   if (o == 0 || !HeapShared::open_archive_heap_region_mapped()) {
2124     p = NULL;
2125   } else {
2126     assert(HeapShared::is_heap_object_archiving_allowed(),
2127            &quot;Archived heap object is not allowed&quot;);
2128     assert(HeapShared::open_archive_heap_region_mapped(),
2129            &quot;Open archive heap region is not mapped&quot;);
2130     *p = HeapShared::decode_from_archive(o);
2131   }
2132 }
2133 
2134 void ReadClosure::do_region(u_char* start, size_t size) {
2135   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);
2136   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);
2137   do_tag((int)size);
2138   while (size &gt; 0) {
2139     *(intptr_t*)start = nextPtr();
2140     start += sizeof(intptr_t);
2141     size -= sizeof(intptr_t);
2142   }
2143 }
2144 
2145 void MetaspaceShared::set_shared_metaspace_range(void* base, void *static_top, void* top) {
2146   assert(base &lt;= static_top &amp;&amp; static_top &lt;= top, &quot;must be&quot;);
2147   _shared_metaspace_static_top = static_top;
2148   MetaspaceObj::set_shared_metaspace_range(base, top);
2149 }
2150 
2151 // Return true if given address is in the misc data region
2152 bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {
2153   return UseSharedSpaces &amp;&amp; FileMapInfo::current_info()-&gt;is_in_shared_region(p, idx);
2154 }
2155 
2156 bool MetaspaceShared::is_in_trampoline_frame(address addr) {
2157   if (UseSharedSpaces &amp;&amp; is_in_shared_region(addr, MetaspaceShared::mc)) {
2158     return true;
2159   }
2160   return false;
2161 }
2162 
2163 bool MetaspaceShared::is_shared_dynamic(void* p) {
2164   if ((p &lt; MetaspaceObj::shared_metaspace_top()) &amp;&amp;
2165       (p &gt;= _shared_metaspace_static_top)) {
2166     return true;
2167   } else {
2168     return false;
2169   }
2170 }
2171 
2172 void MetaspaceShared::initialize_runtime_shared_and_meta_spaces() {
2173   assert(UseSharedSpaces, &quot;Must be called when UseSharedSpaces is enabled&quot;);
2174   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;
2175 
2176   FileMapInfo* static_mapinfo = open_static_archive();
2177   FileMapInfo* dynamic_mapinfo = NULL;
2178 
2179   if (static_mapinfo != NULL) {
2180     dynamic_mapinfo = open_dynamic_archive();
2181 
2182     // First try to map at the requested address
2183     result = map_archives(static_mapinfo, dynamic_mapinfo, true);
2184     if (result == MAP_ARCHIVE_MMAP_FAILURE) {
2185       // Mapping has failed (probably due to ASLR). Let&#39;s map at an address chosen
2186       // by the OS.
2187       log_info(cds)(&quot;Try to map archive(s) at an alternative address&quot;);
2188       result = map_archives(static_mapinfo, dynamic_mapinfo, false);
2189     }
2190   }
2191 
2192   if (result == MAP_ARCHIVE_SUCCESS) {
2193     bool dynamic_mapped = (dynamic_mapinfo != NULL &amp;&amp; dynamic_mapinfo-&gt;is_mapped());
2194     char* cds_base = static_mapinfo-&gt;mapped_base();
2195     char* cds_end =  dynamic_mapped ? dynamic_mapinfo-&gt;mapped_end() : static_mapinfo-&gt;mapped_end();
2196     set_shared_metaspace_range(cds_base, static_mapinfo-&gt;mapped_end(), cds_end);
2197     _relocation_delta = static_mapinfo-&gt;relocation_delta();
2198     if (dynamic_mapped) {
2199       FileMapInfo::set_shared_path_table(dynamic_mapinfo);
2200     } else {
2201       FileMapInfo::set_shared_path_table(static_mapinfo);
2202     }
2203     _requested_base_address = static_mapinfo-&gt;requested_base_address();
2204   } else {
2205     set_shared_metaspace_range(NULL, NULL, NULL);
2206     UseSharedSpaces = false;
2207     FileMapInfo::fail_continue(&quot;Unable to map shared spaces&quot;);
2208     if (PrintSharedArchiveAndExit) {
2209       vm_exit_during_initialization(&quot;Unable to use shared archive.&quot;);
2210     }
2211   }
2212 
2213   if (static_mapinfo != NULL &amp;&amp; !static_mapinfo-&gt;is_mapped()) {
2214     delete static_mapinfo;
2215   }
2216   if (dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped()) {
2217     delete dynamic_mapinfo;
2218   }
2219 }
2220 
2221 FileMapInfo* MetaspaceShared::open_static_archive() {
2222   FileMapInfo* mapinfo = new FileMapInfo(true);
2223   if (!mapinfo-&gt;initialize()) {
2224     delete(mapinfo);
2225     return NULL;
2226   }
2227   return mapinfo;
2228 }
2229 
2230 FileMapInfo* MetaspaceShared::open_dynamic_archive() {
2231   if (DynamicDumpSharedSpaces) {
2232     return NULL;
2233   }
2234   if (Arguments::GetSharedDynamicArchivePath() == NULL) {
2235     return NULL;
2236   }
2237 
2238   FileMapInfo* mapinfo = new FileMapInfo(false);
2239   if (!mapinfo-&gt;initialize()) {
2240     delete(mapinfo);
2241     return NULL;
2242   }
2243   return mapinfo;
2244 }
2245 
2246 // use_requested_addr:
2247 //  true  = map at FileMapHeader::_requested_base_address
2248 //  false = map at an alternative address picked by OS.
2249 MapArchiveResult MetaspaceShared::map_archives(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo,
2250                                                bool use_requested_addr) {
2251   if (use_requested_addr &amp;&amp; static_mapinfo-&gt;requested_base_address() == NULL) {
2252     log_info(cds)(&quot;Archive(s) were created with -XX:SharedBaseAddress=0. Always map at os-selected address.&quot;);
2253     return MAP_ARCHIVE_MMAP_FAILURE;
2254   }
2255 
2256   PRODUCT_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {
2257       // For product build only -- this is for benchmarking the cost of doing relocation.
2258       // For debug builds, the check is done below, after reserving the space, for better test coverage
2259       // (see comment below).
2260       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);
2261       return MAP_ARCHIVE_MMAP_FAILURE;
2262     });
2263 
2264   if (ArchiveRelocationMode == 2 &amp;&amp; !use_requested_addr) {
2265     log_info(cds)(&quot;ArchiveRelocationMode == 2: never map archive(s) at an alternative address&quot;);
2266     return MAP_ARCHIVE_MMAP_FAILURE;
2267   };
2268 
2269   if (dynamic_mapinfo != NULL) {
2270     // Ensure that the OS won&#39;t be able to allocate new memory spaces between the two
2271     // archives, or else it would mess up the simple comparision in MetaspaceObj::is_shared().
2272     assert(static_mapinfo-&gt;mapping_end_offset() == dynamic_mapinfo-&gt;mapping_base_offset(), &quot;no gap&quot;);
2273   }
2274 
2275   ReservedSpace archive_space_rs, class_space_rs;
2276   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;
2277   char* mapped_base_address = reserve_address_space_for_archives(static_mapinfo, dynamic_mapinfo,
2278                                                                  use_requested_addr, archive_space_rs,
2279                                                                  class_space_rs);
2280   if (mapped_base_address == NULL) {
2281     result = MAP_ARCHIVE_MMAP_FAILURE;
2282     log_debug(cds)(&quot;Failed to reserve spaces (use_requested_addr=%u)&quot;, (unsigned)use_requested_addr);
2283   } else {
2284 
2285 #ifdef ASSERT
2286     // Some sanity checks after reserving address spaces for archives
2287     //  and class space.
2288     assert(archive_space_rs.is_reserved(), &quot;Sanity&quot;);
2289     if (Metaspace::using_class_space()) {
2290       // Class space must closely follow the archive space. Both spaces
2291       //  must be aligned correctly.
2292       assert(class_space_rs.is_reserved(),
2293              &quot;A class space should have been reserved&quot;);
2294       assert(class_space_rs.base() &gt;= archive_space_rs.end(),
2295              &quot;class space should follow the cds archive space&quot;);
2296       assert(is_aligned(archive_space_rs.base(),
2297                         MetaspaceShared::reserved_space_alignment()),
2298              &quot;Archive space misaligned&quot;);
2299       assert(is_aligned(class_space_rs.base(),
2300                         Metaspace::reserve_alignment()),
2301              &quot;class space misaligned&quot;);
2302     }
2303 #endif // ASSERT
2304 
2305     log_debug(cds)(&quot;Reserved archive_space_rs     [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,
2306                    p2i(archive_space_rs.base()), p2i(archive_space_rs.end()), archive_space_rs.size());
2307     log_debug(cds)(&quot;Reserved class_space_rs [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,
2308                    p2i(class_space_rs.base()), p2i(class_space_rs.end()), class_space_rs.size());
2309 
2310     if (MetaspaceShared::use_windows_memory_mapping()) {
2311       // We have now reserved address space for the archives, and will map in
2312       //  the archive files into this space.
2313       //
2314       // Special handling for Windows: on Windows we cannot map a file view
2315       //  into an existing memory mapping. So, we unmap the address range we
2316       //  just reserved again, which will make it available for mapping the
2317       //  archives.
2318       // Reserving this range has not been for naught however since it makes
2319       //  us reasonably sure the address range is available.
2320       //
2321       // But still it may fail, since between unmapping the range and mapping
2322       //  in the archive someone else may grab the address space. Therefore
2323       //  there is a fallback in FileMap::map_region() where we just read in
2324       //  the archive files sequentially instead of mapping it in. We couple
2325       //  this with use_requested_addr, since we&#39;re going to patch all the
2326       //  pointers anyway so there&#39;s no benefit to mmap.
2327       if (use_requested_addr) {
2328         log_info(cds)(&quot;Windows mmap workaround: releasing archive space.&quot;);
2329         archive_space_rs.release();
2330       }
2331     }
2332     MapArchiveResult static_result = map_archive(static_mapinfo, mapped_base_address, archive_space_rs);
2333     MapArchiveResult dynamic_result = (static_result == MAP_ARCHIVE_SUCCESS) ?
2334                                      map_archive(dynamic_mapinfo, mapped_base_address, archive_space_rs) : MAP_ARCHIVE_OTHER_FAILURE;
2335 
2336     DEBUG_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {
2337       // This is for simulating mmap failures at the requested address. In
2338       //  debug builds, we do it here (after all archives have possibly been
2339       //  mapped), so we can thoroughly test the code for failure handling
2340       //  (releasing all allocated resource, etc).
2341       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);
2342       if (static_result == MAP_ARCHIVE_SUCCESS) {
2343         static_result = MAP_ARCHIVE_MMAP_FAILURE;
2344       }
2345       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {
2346         dynamic_result = MAP_ARCHIVE_MMAP_FAILURE;
2347       }
2348     });
2349 
2350     if (static_result == MAP_ARCHIVE_SUCCESS) {
2351       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {
2352         result = MAP_ARCHIVE_SUCCESS;
2353       } else if (dynamic_result == MAP_ARCHIVE_OTHER_FAILURE) {
2354         assert(dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped(), &quot;must have failed&quot;);
2355         // No need to retry mapping the dynamic archive again, as it will never succeed
2356         // (bad file, etc) -- just keep the base archive.
2357         log_warning(cds, dynamic)(&quot;Unable to use shared archive. The top archive failed to load: %s&quot;,
2358                                   dynamic_mapinfo-&gt;full_path());
2359         result = MAP_ARCHIVE_SUCCESS;
2360         // TODO, we can give the unused space for the dynamic archive to class_space_rs, but there&#39;s no
2361         // easy API to do that right now.
2362       } else {
2363         result = MAP_ARCHIVE_MMAP_FAILURE;
2364       }
2365     } else if (static_result == MAP_ARCHIVE_OTHER_FAILURE) {
2366       result = MAP_ARCHIVE_OTHER_FAILURE;
2367     } else {
2368       result = MAP_ARCHIVE_MMAP_FAILURE;
2369     }
2370   }
2371 
2372   if (result == MAP_ARCHIVE_SUCCESS) {
2373     SharedBaseAddress = (size_t)mapped_base_address;
2374     LP64_ONLY({
2375         if (Metaspace::using_class_space()) {
2376           // Set up ccs in metaspace.
2377           Metaspace::initialize_class_space(class_space_rs);
2378 
2379           // Set up compressed Klass pointer encoding: the encoding range must
2380           //  cover both archive and class space.
2381           address cds_base = (address)static_mapinfo-&gt;mapped_base();
2382           address ccs_end = (address)class_space_rs.end();
2383           CompressedKlassPointers::initialize(cds_base, ccs_end - cds_base);
2384 
2385           // map_heap_regions() compares the current narrow oop and klass encodings
2386           // with the archived ones, so it must be done after all encodings are determined.
2387           static_mapinfo-&gt;map_heap_regions();
2388         }
2389       });
2390     log_info(cds)(&quot;Using optimized module handling %s&quot;, MetaspaceShared::use_optimized_module_handling() ? &quot;enabled&quot; : &quot;disabled&quot;);
2391   } else {
2392     unmap_archive(static_mapinfo);
2393     unmap_archive(dynamic_mapinfo);
2394     release_reserved_spaces(archive_space_rs, class_space_rs);
2395   }
2396 
2397   return result;
2398 }
2399 
2400 
2401 // This will reserve two address spaces suitable to house Klass structures, one
2402 //  for the cds archives (static archive and optionally dynamic archive) and
2403 //  optionally one move for ccs.
2404 //
2405 // Since both spaces must fall within the compressed class pointer encoding
2406 //  range, they are allocated close to each other.
2407 //
2408 // Space for archives will be reserved first, followed by a potential gap,
2409 //  followed by the space for ccs:
2410 //
2411 // +-- Base address             A        B                     End
2412 // |                            |        |                      |
2413 // v                            v        v                      v
2414 // +-------------+--------------+        +----------------------+
2415 // | static arc  | [dyn. arch]  | [gap]  | compr. class space   |
2416 // +-------------+--------------+        +----------------------+
2417 //
2418 // (The gap may result from different alignment requirements between metaspace
2419 //  and CDS)
2420 //
2421 // If UseCompressedClassPointers is disabled, only one address space will be
2422 //  reserved:
2423 //
2424 // +-- Base address             End
2425 // |                            |
2426 // v                            v
2427 // +-------------+--------------+
2428 // | static arc  | [dyn. arch]  |
2429 // +-------------+--------------+
2430 //
2431 // Base address: If use_archive_base_addr address is true, the Base address is
2432 //  determined by the address stored in the static archive. If
2433 //  use_archive_base_addr address is false, this base address is determined
2434 //  by the platform.
2435 //
2436 // If UseCompressedClassPointers=1, the range encompassing both spaces will be
2437 //  suitable to en/decode narrow Klass pointers: the base will be valid for
2438 //  encoding, the range [Base, End) not surpass KlassEncodingMetaspaceMax.
2439 //
2440 // Return:
2441 //
2442 // - On success:
2443 //    - archive_space_rs will be reserved and large enough to host static and
2444 //      if needed dynamic archive: [Base, A).
2445 //      archive_space_rs.base and size will be aligned to CDS reserve
2446 //      granularity.
2447 //    - class_space_rs: If UseCompressedClassPointers=1, class_space_rs will
2448 //      be reserved. Its start address will be aligned to metaspace reserve
2449 //      alignment, which may differ from CDS alignment. It will follow the cds
2450 //      archive space, close enough such that narrow class pointer encoding
2451 //      covers both spaces.
2452 //      If UseCompressedClassPointers=0, class_space_rs remains unreserved.
2453 // - On error: NULL is returned and the spaces remain unreserved.
2454 char* MetaspaceShared::reserve_address_space_for_archives(FileMapInfo* static_mapinfo,
2455                                                           FileMapInfo* dynamic_mapinfo,
2456                                                           bool use_archive_base_addr,
2457                                                           ReservedSpace&amp; archive_space_rs,
2458                                                           ReservedSpace&amp; class_space_rs) {
2459 
2460   address const base_address = (address) (use_archive_base_addr ? static_mapinfo-&gt;requested_base_address() : NULL);
2461   const size_t archive_space_alignment = MetaspaceShared::reserved_space_alignment();
2462 
2463   // Size and requested location of the archive_space_rs (for both static and dynamic archives)
2464   assert(static_mapinfo-&gt;mapping_base_offset() == 0, &quot;Must be&quot;);
2465   size_t archive_end_offset  = (dynamic_mapinfo == NULL) ? static_mapinfo-&gt;mapping_end_offset() : dynamic_mapinfo-&gt;mapping_end_offset();
2466   size_t archive_space_size = align_up(archive_end_offset, archive_space_alignment);
2467 
2468   // If a base address is given, it must have valid alignment and be suitable as encoding base.
2469   if (base_address != NULL) {
2470     assert(is_aligned(base_address, archive_space_alignment),
2471            &quot;Archive base address invalid: &quot; PTR_FORMAT &quot;.&quot;, p2i(base_address));
2472     if (Metaspace::using_class_space()) {
2473       assert(CompressedKlassPointers::is_valid_base(base_address),
2474              &quot;Archive base address invalid: &quot; PTR_FORMAT &quot;.&quot;, p2i(base_address));
2475     }
2476   }
2477 
2478   if (!Metaspace::using_class_space()) {
2479     // Get the simple case out of the way first:
2480     // no compressed class space, simple allocation.
2481     archive_space_rs = ReservedSpace(archive_space_size, archive_space_alignment,
2482                                      false /* bool large */, (char*)base_address);
2483     if (archive_space_rs.is_reserved()) {
2484       assert(base_address == NULL ||
2485              (address)archive_space_rs.base() == base_address, &quot;Sanity&quot;);
2486       // Register archive space with NMT.
2487       MemTracker::record_virtual_memory_type(archive_space_rs.base(), mtClassShared);
2488       return archive_space_rs.base();
2489     }
2490     return NULL;
2491   }
2492 
2493 #ifdef _LP64
2494 
2495   // Complex case: two spaces adjacent to each other, both to be addressable
2496   //  with narrow class pointers.
2497   // We reserve the whole range spanning both spaces, then split that range up.
2498 
2499   const size_t class_space_alignment = Metaspace::reserve_alignment();
2500 
2501   // To simplify matters, lets assume that metaspace alignment will always be
2502   //  equal or a multiple of archive alignment.
2503   assert(is_power_of_2(class_space_alignment) &amp;&amp;
2504                        is_power_of_2(archive_space_alignment) &amp;&amp;
2505                        class_space_alignment &gt;= archive_space_alignment,
2506                        &quot;Sanity&quot;);
2507 
2508   const size_t class_space_size = CompressedClassSpaceSize;
2509   assert(CompressedClassSpaceSize &gt; 0 &amp;&amp;
2510          is_aligned(CompressedClassSpaceSize, class_space_alignment),
2511          &quot;CompressedClassSpaceSize malformed: &quot;
2512          SIZE_FORMAT, CompressedClassSpaceSize);
2513 
2514   const size_t ccs_begin_offset = align_up(base_address + archive_space_size,
2515                                            class_space_alignment) - base_address;
2516   const size_t gap_size = ccs_begin_offset - archive_space_size;
2517 
2518   const size_t total_range_size =
2519       align_up(archive_space_size + gap_size + class_space_size,
2520                os::vm_allocation_granularity());
2521 
2522   ReservedSpace total_rs;
2523   if (base_address != NULL) {
2524     // Reserve at the given archive base address, or not at all.
2525     total_rs = ReservedSpace(total_range_size, archive_space_alignment,
2526                              false /* bool large */, (char*) base_address);
2527   } else {
2528     // Reserve at any address, but leave it up to the platform to choose a good one.
2529     total_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size);
2530   }
2531 
2532   if (!total_rs.is_reserved()) {
2533     return NULL;
2534   }
2535 
2536   // Paranoid checks:
2537   assert(base_address == NULL || (address)total_rs.base() == base_address,
2538          &quot;Sanity (&quot; PTR_FORMAT &quot; vs &quot; PTR_FORMAT &quot;)&quot;, p2i(base_address), p2i(total_rs.base()));
2539   assert(is_aligned(total_rs.base(), archive_space_alignment), &quot;Sanity&quot;);
2540   assert(total_rs.size() == total_range_size, &quot;Sanity&quot;);
2541   assert(CompressedKlassPointers::is_valid_base((address)total_rs.base()), &quot;Sanity&quot;);
2542 
2543   // Now split up the space into ccs and cds archive. For simplicity, just leave
2544   //  the gap reserved at the end of the archive space.
2545   archive_space_rs = total_rs.first_part(ccs_begin_offset,
2546                                          (size_t)os::vm_allocation_granularity(),
2547                                          /*split=*/true);
2548   class_space_rs = total_rs.last_part(ccs_begin_offset);
2549 
2550   assert(is_aligned(archive_space_rs.base(), archive_space_alignment), &quot;Sanity&quot;);
2551   assert(is_aligned(archive_space_rs.size(), archive_space_alignment), &quot;Sanity&quot;);
2552   assert(is_aligned(class_space_rs.base(), class_space_alignment), &quot;Sanity&quot;);
2553   assert(is_aligned(class_space_rs.size(), class_space_alignment), &quot;Sanity&quot;);
2554 
2555   // NMT: fix up the space tags
2556   MemTracker::record_virtual_memory_type(archive_space_rs.base(), mtClassShared);
2557   MemTracker::record_virtual_memory_type(class_space_rs.base(), mtClass);
2558 
2559   return archive_space_rs.base();
2560 
2561 #else
2562   ShouldNotReachHere();
2563   return NULL;
2564 #endif
2565 
2566 }
2567 
2568 void MetaspaceShared::release_reserved_spaces(ReservedSpace&amp; archive_space_rs,
2569                                               ReservedSpace&amp; class_space_rs) {
2570   if (archive_space_rs.is_reserved()) {
2571     log_debug(cds)(&quot;Released shared space (archive) &quot; INTPTR_FORMAT, p2i(archive_space_rs.base()));
2572     archive_space_rs.release();
2573   }
2574   if (class_space_rs.is_reserved()) {
2575     log_debug(cds)(&quot;Released shared space (classes) &quot; INTPTR_FORMAT, p2i(class_space_rs.base()));
2576     class_space_rs.release();
2577   }
2578 }
2579 
2580 static int archive_regions[]  = {MetaspaceShared::mc,
2581                                  MetaspaceShared::rw,
2582                                  MetaspaceShared::ro};
2583 static int archive_regions_count  = 3;
2584 
2585 MapArchiveResult MetaspaceShared::map_archive(FileMapInfo* mapinfo, char* mapped_base_address, ReservedSpace rs) {
2586   assert(UseSharedSpaces, &quot;must be runtime&quot;);
2587   if (mapinfo == NULL) {
2588     return MAP_ARCHIVE_SUCCESS; // The dynamic archive has not been specified. No error has happened -- trivially succeeded.
2589   }
2590 
2591   mapinfo-&gt;set_is_mapped(false);
2592 
2593   if (mapinfo-&gt;alignment() != (size_t)os::vm_allocation_granularity()) {
2594     log_error(cds)(&quot;Unable to map CDS archive -- os::vm_allocation_granularity() expected: &quot; SIZE_FORMAT
2595                    &quot; actual: %d&quot;, mapinfo-&gt;alignment(), os::vm_allocation_granularity());
2596     return MAP_ARCHIVE_OTHER_FAILURE;
2597   }
2598 
2599   MapArchiveResult result =
2600     mapinfo-&gt;map_regions(archive_regions, archive_regions_count, mapped_base_address, rs);
2601 
2602   if (result != MAP_ARCHIVE_SUCCESS) {
2603     unmap_archive(mapinfo);
2604     return result;
2605   }
2606 
2607   if (!mapinfo-&gt;validate_shared_path_table()) {
2608     unmap_archive(mapinfo);
2609     return MAP_ARCHIVE_OTHER_FAILURE;
2610   }
2611 
2612   mapinfo-&gt;set_is_mapped(true);
2613   return MAP_ARCHIVE_SUCCESS;
2614 }
2615 
2616 void MetaspaceShared::unmap_archive(FileMapInfo* mapinfo) {
2617   assert(UseSharedSpaces, &quot;must be runtime&quot;);
2618   if (mapinfo != NULL) {
2619     mapinfo-&gt;unmap_regions(archive_regions, archive_regions_count);
2620     mapinfo-&gt;set_is_mapped(false);
2621   }
2622 }
2623 
2624 // Read the miscellaneous data from the shared file, and
2625 // serialize it out to its various destinations.
2626 
2627 void MetaspaceShared::initialize_shared_spaces() {
2628   FileMapInfo *static_mapinfo = FileMapInfo::current_info();
2629   _i2i_entry_code_buffers = static_mapinfo-&gt;i2i_entry_code_buffers();
2630   _i2i_entry_code_buffers_size = static_mapinfo-&gt;i2i_entry_code_buffers_size();
2631   char* buffer = static_mapinfo-&gt;cloned_vtables();
2632   clone_cpp_vtables((intptr_t*)buffer);
2633 
2634   // Verify various attributes of the archive, plus initialize the
2635   // shared string/symbol tables
2636   buffer = static_mapinfo-&gt;serialized_data();
2637   intptr_t* array = (intptr_t*)buffer;
2638   ReadClosure rc(&amp;array);
2639   serialize(&amp;rc);
2640 
2641   // Initialize the run-time symbol table.
2642   SymbolTable::create_table();
2643 
2644   static_mapinfo-&gt;patch_archived_heap_embedded_pointers();
2645 
2646   // Close the mapinfo file
2647   static_mapinfo-&gt;close();
2648 
2649   static_mapinfo-&gt;unmap_region(MetaspaceShared::bm);
2650 
2651   FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();
2652   if (dynamic_mapinfo != NULL) {
2653     intptr_t* buffer = (intptr_t*)dynamic_mapinfo-&gt;serialized_data();
2654     ReadClosure rc(&amp;buffer);
2655     SymbolTable::serialize_shared_table_header(&amp;rc, false);
2656     SystemDictionaryShared::serialize_dictionary_headers(&amp;rc, false);
2657     dynamic_mapinfo-&gt;close();
2658   }
2659 
2660   if (PrintSharedArchiveAndExit) {
2661     if (PrintSharedDictionary) {
2662       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
2663       SystemDictionaryShared::print_on(tty);
2664     }
2665     if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {
2666       tty-&gt;print_cr(&quot;archive is invalid&quot;);
2667       vm_exit(1);
2668     } else {
2669       tty-&gt;print_cr(&quot;archive is valid&quot;);
2670       vm_exit(0);
2671     }
2672   }
2673 }
2674 
2675 // JVM/TI RedefineClasses() support:
2676 bool MetaspaceShared::remap_shared_readonly_as_readwrite() {
2677   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
2678 
2679   if (UseSharedSpaces) {
2680     // remap the shared readonly space to shared readwrite, private
2681     FileMapInfo* mapinfo = FileMapInfo::current_info();
2682     if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2683       return false;
2684     }
2685     if (FileMapInfo::dynamic_info() != NULL) {
2686       mapinfo = FileMapInfo::dynamic_info();
2687       if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2688         return false;
2689       }
2690     }
2691     _remapped_readwrite = true;
2692   }
2693   return true;
2694 }
2695 
2696 void MetaspaceShared::report_out_of_space(const char* name, size_t needed_bytes) {
2697   // This is highly unlikely to happen on 64-bits because we have reserved a 4GB space.
2698   // On 32-bit we reserve only 256MB so you could run out of space with 100,000 classes
2699   // or so.
2700   _mc_region.print_out_of_space_msg(name, needed_bytes);
2701   _rw_region.print_out_of_space_msg(name, needed_bytes);
2702   _ro_region.print_out_of_space_msg(name, needed_bytes);
2703 
2704   vm_exit_during_initialization(err_msg(&quot;Unable to allocate from &#39;%s&#39; region&quot;, name),
2705                                 &quot;Please reduce the number of shared classes.&quot;);
2706 }
2707 
2708 // This is used to relocate the pointers so that the base archive can be mapped at
2709 // MetaspaceShared::requested_base_address() without runtime relocation.
2710 intx MetaspaceShared::final_delta() {
2711   return intx(MetaspaceShared::requested_base_address())  // We want the base archive to be mapped to here at runtime
2712        - intx(SharedBaseAddress);                         // .. but the base archive is mapped at here at dump time
2713 }
2714 
2715 void MetaspaceShared::print_on(outputStream* st) {
2716   if (UseSharedSpaces || DumpSharedSpaces) {
2717     st-&gt;print(&quot;CDS archive(s) mapped at: &quot;);
2718     address base;
2719     address top;
2720     if (UseSharedSpaces) { // Runtime
2721       base = (address)MetaspaceObj::shared_metaspace_base();
2722       address static_top = (address)_shared_metaspace_static_top;
2723       top = (address)MetaspaceObj::shared_metaspace_top();
2724       st-&gt;print(&quot;[&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;), &quot;, p2i(base), p2i(static_top), p2i(top));
2725     } else if (DumpSharedSpaces) { // Dump Time
2726       base = (address)_shared_rs.base();
2727       top = (address)_shared_rs.end();
2728       st-&gt;print(&quot;[&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;), &quot;, p2i(base), p2i(top));
2729     }
2730     st-&gt;print(&quot;size &quot; SIZE_FORMAT &quot;, &quot;, top - base);
2731     st-&gt;print(&quot;SharedBaseAddress: &quot; PTR_FORMAT &quot;, ArchiveRelocationMode: %d.&quot;, SharedBaseAddress, (int)ArchiveRelocationMode);
2732   } else {
2733     st-&gt;print(&quot;CDS disabled.&quot;);
2734   }
2735   st-&gt;cr();
2736 }
2737 
2738 
2739 
2740 
2741 
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>