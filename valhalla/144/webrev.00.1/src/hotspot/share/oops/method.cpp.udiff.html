<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/method.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/metaspaceShared.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2_globals.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -52,10 +52,11 @@</span>
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -111,11 +112,10 @@</span>
  
    if (access_flags.is_native()) {
      clear_native_function();
      set_signature_handler(NULL);
    }
<span class="udiff-line-removed">- </span>
    NOT_PRODUCT(set_compiled_invocation_count(0);)
  }
  
  // Release Method*.  The nmethod will be gone when we get here because
  // we&#39;ve walked the code cache.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,15 +148,25 @@</span>
  address Method::get_c2i_entry() {
    assert(adapter() != NULL, &quot;must have&quot;);
    return adapter()-&gt;get_c2i_entry();
  }
  
<span class="udiff-line-added">+ address Method::get_c2i_inline_entry() {</span>
<span class="udiff-line-added">+   assert(adapter() != NULL, &quot;must have&quot;);</span>
<span class="udiff-line-added">+   return adapter()-&gt;get_c2i_inline_entry();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  address Method::get_c2i_unverified_entry() {
    assert(adapter() != NULL, &quot;must have&quot;);
    return adapter()-&gt;get_c2i_unverified_entry();
  }
  
<span class="udiff-line-added">+ address Method::get_c2i_unverified_inline_entry() {</span>
<span class="udiff-line-added">+   assert(adapter() != NULL, &quot;must have&quot;);</span>
<span class="udiff-line-added">+   return adapter()-&gt;get_c2i_unverified_inline_entry();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  address Method::get_c2i_no_clinit_check_entry() {
    assert(VM_Version::supports_fast_class_init_checks(), &quot;&quot;);
    assert(adapter() != NULL, &quot;must have&quot;);
    return adapter()-&gt;get_c2i_no_clinit_check_entry();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -345,10 +355,12 @@</span>
    it-&gt;push(&amp;_method_counters);
  
    Method* this_ptr = this;
    it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_i2i_entry);
    it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_entry);
<span class="udiff-line-added">+   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_inline_ro_entry);</span>
<span class="udiff-line-added">+   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_inline_entry);</span>
    it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_interpreted_entry);
  }
  
  // Attempt to return method oop to original state.  Clear any pointers
  // (to objects outside the shared spaces).  We won&#39;t be able to predict
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -589,21 +601,39 @@</span>
    set_size_of_parameters(fp.size_of_parameters());
    constMethod()-&gt;set_result_type(fp.return_type());
    constMethod()-&gt;set_fingerprint(fp.fingerprint());
  }
  
<span class="udiff-line-added">+ // InlineKlass the method is declared to return. This must not</span>
<span class="udiff-line-added">+ // safepoint as it is called with references live on the stack at</span>
<span class="udiff-line-added">+ // locations the GC is unaware of.</span>
<span class="udiff-line-added">+ InlineKlass* Method::returned_inline_type(Thread* thread) const {</span>
<span class="udiff-line-added">+   SignatureStream ss(signature());</span>
<span class="udiff-line-added">+   while (!ss.at_return_type()) {</span>
<span class="udiff-line-added">+     ss.next();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Handle class_loader(thread, method_holder()-&gt;class_loader());</span>
<span class="udiff-line-added">+   Handle protection_domain(thread, method_holder()-&gt;protection_domain());</span>
<span class="udiff-line-added">+   Klass* k = NULL;</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     NoSafepointVerifier nsv;</span>
<span class="udiff-line-added">+     k = ss.as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, thread);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(k != NULL &amp;&amp; !thread-&gt;has_pending_exception(), &quot;can&#39;t resolve klass&quot;);</span>
<span class="udiff-line-added">+   return InlineKlass::cast(k);</span>
<span class="udiff-line-added">+ }</span>
  bool Method::is_empty_method() const {
    return  code_size() == 1
        &amp;&amp; *code_base() == Bytecodes::_return;
  }
  
  bool Method::is_vanilla_constructor() const {
    // Returns true if this method is a vanilla constructor, i.e. an &quot;&lt;init&gt;&quot; &quot;()V&quot; method
    // which only calls the superclass vanilla constructor and possibly does stores of
    // zero constants to local fields:
    //
<span class="udiff-line-modified-removed">-   //   aload_0</span>
<span class="udiff-line-modified-added">+   //   aload_0, _fast_aload_0, or _nofast_aload_0</span>
    //   invokespecial
    //   indexbyte1
    //   indexbyte2
    //
    // followed by an (optional) sequence of:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -623,11 +653,12 @@</span>
    int size = code_size();
    // Check if size match
    if (size == 0 || size % 5 != 0) return false;
    address cb = code_base();
    int last = size - 1;
<span class="udiff-line-modified-removed">-   if (cb[0] != Bytecodes::_aload_0 || cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {</span>
<span class="udiff-line-modified-added">+   if ((cb[0] != Bytecodes::_aload_0 &amp;&amp; cb[0] != Bytecodes::_fast_aload_0 &amp;&amp; cb[0] != Bytecodes::_nofast_aload_0) ||</span>
<span class="udiff-line-added">+        cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {</span>
      // Does not call superclass default constructor
      return false;
    }
    // Check optional sequence
    for (int i = 4; i &lt; last; i += 5) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -775,29 +806,31 @@</span>
            Bytecodes::is_const(java_code_at(0)) &amp;&amp;
            Bytecodes::length_for(java_code_at(0)) == last_index &amp;&amp;
            Bytecodes::is_return(java_code_at(last_index)));
  }
  
<span class="udiff-line-modified-removed">- bool Method::is_initializer() const {</span>
<span class="udiff-line-modified-removed">-   return is_object_initializer() || is_static_initializer();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool Method::has_valid_initializer_flags() const {</span>
<span class="udiff-line-removed">-   return (is_static() ||</span>
<span class="udiff-line-removed">-           method_holder()-&gt;major_version() &lt; 51);</span>
<span class="udiff-line-modified-added">+ bool Method::is_object_constructor_or_class_initializer() const {</span>
<span class="udiff-line-modified-added">+   return (is_object_constructor() || is_class_initializer());</span>
  }
  
<span class="udiff-line-modified-removed">- bool Method::is_static_initializer() const {</span>
<span class="udiff-line-modified-added">+ bool Method::is_class_initializer() const {</span>
    // For classfiles version 51 or greater, ensure that the clinit method is
    // static.  Non-static methods with the name &quot;&lt;clinit&gt;&quot; are not static
    // initializers. (older classfiles exempted for backward compatibility)
<span class="udiff-line-modified-removed">-   return name() == vmSymbols::class_initializer_name() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-          has_valid_initializer_flags();</span>
<span class="udiff-line-modified-added">+   return (name() == vmSymbols::class_initializer_name() &amp;&amp;</span>
<span class="udiff-line-modified-added">+           (is_static() ||</span>
<span class="udiff-line-added">+            method_holder()-&gt;major_version() &lt; 51));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // A method named &lt;init&gt;, if non-static, is a classic object constructor.</span>
<span class="udiff-line-added">+ bool Method::is_object_constructor() const {</span>
<span class="udiff-line-added">+    return name() == vmSymbols::object_initializer_name() &amp;&amp; !is_static();</span>
  }
  
<span class="udiff-line-modified-removed">- bool Method::is_object_initializer() const {</span>
<span class="udiff-line-modified-removed">-    return name() == vmSymbols::object_initializer_name();</span>
<span class="udiff-line-modified-added">+ // A static method named &lt;init&gt; is a factory for an inline class.</span>
<span class="udiff-line-modified-added">+ bool Method::is_static_init_factory() const {</span>
<span class="udiff-line-added">+    return name() == vmSymbols::object_initializer_name() &amp;&amp; is_static();</span>
  }
  
  bool Method::needs_clinit_barrier() const {
    return is_static() &amp;&amp; !method_holder()-&gt;is_initialized();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -851,11 +884,11 @@</span>
    return best_line;
  }
  
  
  bool Method::is_klass_loaded_by_klass_index(int klass_index) const {
<span class="udiff-line-modified-removed">-   if( constants()-&gt;tag_at(klass_index).is_unresolved_klass() ) {</span>
<span class="udiff-line-modified-added">+   if( constants()-&gt;tag_at(klass_index).is_unresolved_klass()) {</span>
      Thread *thread = Thread::current();
      Symbol* klass_name = constants()-&gt;klass_name_at(klass_index);
      Handle loader(thread, method_holder()-&gt;class_loader());
      Handle prot  (thread, method_holder()-&gt;protection_domain());
      return SystemDictionary::find(klass_name, loader, prot, thread) != NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -867,11 +900,13 @@</span>
  
  bool Method::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
    int klass_index = constants()-&gt;klass_ref_index_at(refinfo_index);
    if (must_be_resolved) {
      // Make sure klass is resolved in constantpool.
<span class="udiff-line-modified-removed">-     if (constants()-&gt;tag_at(klass_index).is_unresolved_klass()) return false;</span>
<span class="udiff-line-modified-added">+     if (constants()-&gt;tag_at(klass_index).is_unresolved_klass()) {</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
    }
    return is_klass_loaded_by_klass_index(klass_index);
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1036,12 +1071,16 @@</span>
  void Method::clear_code() {
    // this may be NULL if c2i adapters have not been made yet
    // Only should happen at allocate time.
    if (adapter() == NULL) {
      _from_compiled_entry    = NULL;
<span class="udiff-line-added">+     _from_compiled_inline_entry = NULL;</span>
<span class="udiff-line-added">+     _from_compiled_inline_ro_entry = NULL;</span>
    } else {
      _from_compiled_entry    = adapter()-&gt;get_c2i_entry();
<span class="udiff-line-added">+     _from_compiled_inline_entry = adapter()-&gt;get_c2i_inline_entry();</span>
<span class="udiff-line-added">+     _from_compiled_inline_ro_entry = adapter()-&gt;get_c2i_inline_ro_entry();</span>
    }
    OrderAccess::storestore();
    _from_interpreted_entry = _i2i_entry;
    OrderAccess::storestore();
    _code = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1082,13 +1121,22 @@</span>
    } else {
      // TODO: Simplify the adapter trampoline allocation for static archiving.
      //       Remove the use of CDSAdapterHandlerEntry.
      CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();
      constMethod()-&gt;set_adapter_trampoline(cds_adapter-&gt;get_adapter_trampoline());
<span class="udiff-line-added">+ </span>
      _from_compiled_entry = cds_adapter-&gt;get_c2i_entry_trampoline();
      assert(*((int*)_from_compiled_entry) == 0,
<span class="udiff-line-modified-removed">-            &quot;must be NULL during dump time, to be initialized at run time&quot;);</span>
<span class="udiff-line-modified-added">+            &quot;instructions must be zeros during dump time, to be initialized at run time&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _from_compiled_inline_ro_entry = cds_adapter-&gt;get_c2i_inline_ro_entry_trampoline();</span>
<span class="udiff-line-added">+     assert(*((int*)_from_compiled_inline_ro_entry) == 0,</span>
<span class="udiff-line-added">+            &quot;instructions must be zeros during dump time, to be initialized at run time&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _from_compiled_inline_entry = cds_adapter-&gt;get_c2i_inline_entry_trampoline();</span>
<span class="udiff-line-added">+     assert(*((int*)_from_compiled_inline_entry) == 0,</span>
<span class="udiff-line-added">+            &quot;instructions must be zeros during dump time, to be initialized at run time&quot;);</span>
    }
  
    if (is_native()) {
      *native_function_addr() = NULL;
      set_signature_handler(NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1237,34 +1285,61 @@</span>
    }
  
    if (mh-&gt;is_shared()) {
      assert(mh-&gt;adapter() == adapter, &quot;must be&quot;);
      assert(mh-&gt;_from_compiled_entry != NULL, &quot;must be&quot;);
<span class="udiff-line-added">+     assert(mh-&gt;_from_compiled_inline_entry != NULL, &quot;must be&quot;);</span>
<span class="udiff-line-added">+     assert(mh-&gt;_from_compiled_inline_ro_entry != NULL, &quot;must be&quot;);</span>
    } else {
      mh-&gt;set_adapter_entry(adapter);
      mh-&gt;_from_compiled_entry = adapter-&gt;get_c2i_entry();
<span class="udiff-line-added">+     mh-&gt;_from_compiled_inline_entry = adapter-&gt;get_c2i_inline_entry();</span>
<span class="udiff-line-added">+     mh-&gt;_from_compiled_inline_ro_entry = adapter-&gt;get_c2i_inline_ro_entry();</span>
    }
    return adapter-&gt;get_c2i_entry();
  }
  
  void Method::restore_unshareable_info(TRAPS) {
    assert(is_method() &amp;&amp; is_valid_method(this), &quot;ensure C++ vtable is restored&quot;);
  
<span class="udiff-line-added">+ #if 0</span>
<span class="udiff-line-added">+   /*</span>
<span class="udiff-line-added">+    * CDS:TODO --</span>
<span class="udiff-line-added">+    * &quot;Q&quot; classes in the method signature must be resolved during link_method.</span>
<span class="udiff-line-added">+    * However, at this point we are still inside method_holder()-&gt;restore_unshareable_info.</span>
<span class="udiff-line-added">+    * If we try to resolve method_holder(), or multually dependent classes, it will</span>
<span class="udiff-line-added">+    * cause deadlock and other ill effects.</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * For now, lets do method linking inside InstanceKlass::link_class(). Optimization</span>
<span class="udiff-line-added">+    * may be possible if we know that resolution will never happen.</span>
<span class="udiff-line-added">+    */</span>
<span class="udiff-line-added">+ </span>
    // Since restore_unshareable_info can be called more than once for a method, don&#39;t
    // redo any work.
    if (adapter() == NULL) {
      methodHandle mh(THREAD, this);
      link_method(mh, CHECK);
    }
<span class="udiff-line-added">+ #endif</span>
  }
  
<span class="udiff-line-modified-removed">- address Method::from_compiled_entry_no_trampoline() const {</span>
<span class="udiff-line-modified-added">+ address Method::from_compiled_entry_no_trampoline(bool caller_is_c1) const {</span>
    CompiledMethod *code = Atomic::load_acquire(&amp;_code);
<span class="udiff-line-modified-removed">-   if (code) {</span>
<span class="udiff-line-modified-removed">-     return code-&gt;verified_entry_point();</span>
<span class="udiff-line-modified-added">+   if (caller_is_c1) {</span>
<span class="udiff-line-modified-added">+     // C1 - inline type arguments are passed as objects</span>
<span class="udiff-line-added">+     if (code) {</span>
<span class="udiff-line-added">+       return code-&gt;verified_inline_entry_point();</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return adapter()-&gt;get_c2i_inline_entry();</span>
<span class="udiff-line-added">+     }</span>
    } else {
<span class="udiff-line-modified-removed">-     return adapter()-&gt;get_c2i_entry();</span>
<span class="udiff-line-modified-added">+     // C2 - inline type arguments may be passed as fields</span>
<span class="udiff-line-added">+     if (code) {</span>
<span class="udiff-line-added">+       return code-&gt;verified_entry_point();</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return adapter()-&gt;get_c2i_entry();</span>
<span class="udiff-line-added">+     }</span>
    }
  }
  
  // The verified_code_entry() must be called when a invoke is resolved
  // on this method.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1277,10 +1352,22 @@</span>
    debug_only(NoSafepointVerifier nsv;)
    assert(_from_compiled_entry != NULL, &quot;must be set&quot;);
    return _from_compiled_entry;
  }
  
<span class="udiff-line-added">+ address Method::verified_inline_code_entry() {</span>
<span class="udiff-line-added">+   debug_only(NoSafepointVerifier nsv;)</span>
<span class="udiff-line-added">+   assert(_from_compiled_inline_entry != NULL, &quot;must be set&quot;);</span>
<span class="udiff-line-added">+   return _from_compiled_inline_entry;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ address Method::verified_inline_ro_code_entry() {</span>
<span class="udiff-line-added">+   debug_only(NoSafepointVerifier nsv;)</span>
<span class="udiff-line-added">+   assert(_from_compiled_inline_ro_entry != NULL, &quot;must be set&quot;);</span>
<span class="udiff-line-added">+   return _from_compiled_inline_ro_entry;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Check that if an nmethod ref exists, it has a backlink to this or no backlink at all
  // (could be racing a deopt).
  // Not inline to avoid circular ref.
  bool Method::check_code() const {
    // cached in a register or local.  There&#39;s a race on the value of the field.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1308,10 +1395,12 @@</span>
      mh-&gt;set_highest_comp_level(comp_level);
    }
  
    OrderAccess::storestore();
    mh-&gt;_from_compiled_entry = code-&gt;verified_entry_point();
<span class="udiff-line-added">+   mh-&gt;_from_compiled_inline_entry = code-&gt;verified_inline_entry_point();</span>
<span class="udiff-line-added">+   mh-&gt;_from_compiled_inline_ro_entry = code-&gt;verified_inline_ro_entry_point();</span>
    OrderAccess::storestore();
    // Instantly compiled code can execute.
    if (!mh-&gt;is_method_handle_intrinsic())
      mh-&gt;_from_interpreted_entry = mh-&gt;get_i2c_entry();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2339,10 +2428,12 @@</span>
    if (intrinsic_id() != vmIntrinsics::_none)
      st-&gt;print_cr(&quot; - intrinsic id:      %d %s&quot;, intrinsic_id(), vmIntrinsics::name_at(intrinsic_id()));
    if (highest_comp_level() != CompLevel_none)
      st-&gt;print_cr(&quot; - highest level:     %d&quot;, highest_comp_level());
    st-&gt;print_cr(&quot; - vtable index:      %d&quot;,   _vtable_index);
<span class="udiff-line-added">+   if (valid_itable_index())</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot; - itable index:      %d&quot;,   itable_index());</span>
    st-&gt;print_cr(&quot; - i2i entry:         &quot; INTPTR_FORMAT, p2i(interpreter_entry()));
    st-&gt;print(   &quot; - adapters:          &quot;);
    AdapterHandlerEntry* a = ((Method*)this)-&gt;adapter();
    if (a == NULL)
      st-&gt;print_cr(INTPTR_FORMAT, p2i(a));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2416,10 +2507,11 @@</span>
  void Method::print_value_on(outputStream* st) const {
    assert(is_method(), &quot;must be method&quot;);
    st-&gt;print(&quot;%s&quot;, internal_name());
    print_address_on(st);
    st-&gt;print(&quot; &quot;);
<span class="udiff-line-added">+   if (WizardMode) access_flags().print_on(st);</span>
    name()-&gt;print_value_on(st);
    st-&gt;print(&quot; &quot;);
    signature()-&gt;print_value_on(st);
    st-&gt;print(&quot; in &quot;);
    method_holder()-&gt;print_value_on(st);
</pre>
<center><a href="../memory/metaspaceShared.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2_globals.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>