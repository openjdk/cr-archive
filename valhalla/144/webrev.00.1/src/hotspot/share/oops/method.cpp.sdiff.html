<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/method.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;interpreter/oopMapCache.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;logging/logTag.hpp&quot;
  41 #include &quot;logging/logStream.hpp&quot;
  42 #include &quot;memory/allocation.inline.hpp&quot;
  43 #include &quot;memory/metadataFactory.hpp&quot;
  44 #include &quot;memory/metaspaceClosure.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/constMethod.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/method.inline.hpp&quot;
  52 #include &quot;oops/methodData.hpp&quot;
  53 #include &quot;oops/objArrayKlass.hpp&quot;
  54 #include &quot;oops/objArrayOop.inline.hpp&quot;
  55 #include &quot;oops/oop.inline.hpp&quot;
  56 #include &quot;oops/symbol.hpp&quot;

  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/methodHandles.hpp&quot;
  59 #include &quot;prims/nativeLookup.hpp&quot;
  60 #include &quot;runtime/arguments.hpp&quot;
  61 #include &quot;runtime/atomic.hpp&quot;
  62 #include &quot;runtime/frame.inline.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/init.hpp&quot;
  65 #include &quot;runtime/orderAccess.hpp&quot;
  66 #include &quot;runtime/relocator.hpp&quot;
  67 #include &quot;runtime/safepointVerifiers.hpp&quot;
  68 #include &quot;runtime/sharedRuntime.hpp&quot;
  69 #include &quot;runtime/signature.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/quickSort.hpp&quot;
  72 #include &quot;utilities/vmError.hpp&quot;
  73 #include &quot;utilities/xmlstream.hpp&quot;
  74 
  75 // Implementation of Method
  76 
</pre>
<hr />
<pre>
  96   set_constMethod(xconst);
  97   set_access_flags(access_flags);
  98   set_intrinsic_id(vmIntrinsics::_none);
  99   set_force_inline(false);
 100   set_hidden(false);
 101   set_dont_inline(false);
 102   set_has_injected_profile(false);
 103   set_method_data(NULL);
 104   clear_method_counters();
 105   set_vtable_index(Method::garbage_vtable_index);
 106 
 107   // Fix and bury in Method*
 108   set_interpreter_entry(NULL); // sets i2i entry and from_int
 109   set_adapter_entry(NULL);
 110   Method::clear_code(); // from_c/from_i get set to c2i/i2i
 111 
 112   if (access_flags.is_native()) {
 113     clear_native_function();
 114     set_signature_handler(NULL);
 115   }
<span class="line-removed"> 116 </span>
 117   NOT_PRODUCT(set_compiled_invocation_count(0);)
 118 }
 119 
 120 // Release Method*.  The nmethod will be gone when we get here because
 121 // we&#39;ve walked the code cache.
 122 void Method::deallocate_contents(ClassLoaderData* loader_data) {
 123   MetadataFactory::free_metadata(loader_data, constMethod());
 124   set_constMethod(NULL);
 125   MetadataFactory::free_metadata(loader_data, method_data());
 126   set_method_data(NULL);
 127   MetadataFactory::free_metadata(loader_data, method_counters());
 128   clear_method_counters();
 129   // The nmethod will be gone when we get here.
 130   if (code() != NULL) _code = NULL;
 131 }
 132 
 133 void Method::release_C_heap_structures() {
 134   if (method_data()) {
 135 #if INCLUDE_JVMCI
 136     FailedSpeculation::free_failed_speculations(method_data()-&gt;get_failed_speculations_address());
 137 #endif
 138     // Destroy MethodData
 139     method_data()-&gt;~MethodData();
 140   }
 141 }
 142 
 143 address Method::get_i2c_entry() {
 144   assert(adapter() != NULL, &quot;must have&quot;);
 145   return adapter()-&gt;get_i2c_entry();
 146 }
 147 
 148 address Method::get_c2i_entry() {
 149   assert(adapter() != NULL, &quot;must have&quot;);
 150   return adapter()-&gt;get_c2i_entry();
 151 }
 152 





 153 address Method::get_c2i_unverified_entry() {
 154   assert(adapter() != NULL, &quot;must have&quot;);
 155   return adapter()-&gt;get_c2i_unverified_entry();
 156 }
 157 





 158 address Method::get_c2i_no_clinit_check_entry() {
 159   assert(VM_Version::supports_fast_class_init_checks(), &quot;&quot;);
 160   assert(adapter() != NULL, &quot;must have&quot;);
 161   return adapter()-&gt;get_c2i_no_clinit_check_entry();
 162 }
 163 
 164 char* Method::name_and_sig_as_C_string() const {
 165   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature());
 166 }
 167 
 168 char* Method::name_and_sig_as_C_string(char* buf, int size) const {
 169   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature(), buf, size);
 170 }
 171 
 172 char* Method::name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature) {
 173   const char* klass_name = klass-&gt;external_name();
 174   int klass_name_len  = (int)strlen(klass_name);
 175   int method_name_len = method_name-&gt;utf8_length();
 176   int len             = klass_name_len + 1 + method_name_len + signature-&gt;utf8_length();
 177   char* dest          = NEW_RESOURCE_ARRAY(char, len + 1);
</pre>
<hr />
<pre>
 330   // If native, then include pointers for native_function and signature_handler
 331   int extra_bytes = (is_native) ? 2*sizeof(address*) : 0;
 332   int extra_words = align_up(extra_bytes, BytesPerWord) / BytesPerWord;
 333   return align_metadata_size(header_size() + extra_words);
 334 }
 335 
 336 Symbol* Method::klass_name() const {
 337   return method_holder()-&gt;name();
 338 }
 339 
 340 void Method::metaspace_pointers_do(MetaspaceClosure* it) {
 341   log_trace(cds)(&quot;Iter(Method): %p&quot;, this);
 342 
 343   it-&gt;push(&amp;_constMethod);
 344   it-&gt;push(&amp;_method_data);
 345   it-&gt;push(&amp;_method_counters);
 346 
 347   Method* this_ptr = this;
 348   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_i2i_entry);
 349   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_entry);


 350   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_interpreted_entry);
 351 }
 352 
 353 // Attempt to return method oop to original state.  Clear any pointers
 354 // (to objects outside the shared spaces).  We won&#39;t be able to predict
 355 // where they should point in a new JVM.  Further initialize some
 356 // entries now in order allow them to be write protected later.
 357 
 358 void Method::remove_unshareable_info() {
 359   unlink_method();
 360   JFR_ONLY(REMOVE_METHOD_ID(this);)
 361 }
 362 
 363 void Method::set_vtable_index(int index) {
 364   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 365     // At runtime initialize_vtable is rerun as part of link_class_impl()
 366     // for a shared class loaded by the non-boot loader to obtain the loader
 367     // constraints based on the runtime classloaders&#39; context.
 368     return; // don&#39;t write into the shared class
 369   } else {
</pre>
<hr />
<pre>
 574   return Atomic::replace_if_null(&amp;_method_counters, counters);
 575 }
 576 
 577 int Method::extra_stack_words() {
 578   // not an inline function, to avoid a header dependency on Interpreter
 579   return extra_stack_entries() * Interpreter::stackElementSize;
 580 }
 581 
 582 // Derive size of parameters, return type, and fingerprint,
 583 // all in one pass, which is run at load time.
 584 // We need the first two, and might as well grab the third.
 585 void Method::compute_from_signature(Symbol* sig) {
 586   // At this point, since we are scanning the signature,
 587   // we might as well compute the whole fingerprint.
 588   Fingerprinter fp(sig, is_static());
 589   set_size_of_parameters(fp.size_of_parameters());
 590   constMethod()-&gt;set_result_type(fp.return_type());
 591   constMethod()-&gt;set_fingerprint(fp.fingerprint());
 592 }
 593 


















 594 bool Method::is_empty_method() const {
 595   return  code_size() == 1
 596       &amp;&amp; *code_base() == Bytecodes::_return;
 597 }
 598 
 599 bool Method::is_vanilla_constructor() const {
 600   // Returns true if this method is a vanilla constructor, i.e. an &quot;&lt;init&gt;&quot; &quot;()V&quot; method
 601   // which only calls the superclass vanilla constructor and possibly does stores of
 602   // zero constants to local fields:
 603   //
<span class="line-modified"> 604   //   aload_0</span>
 605   //   invokespecial
 606   //   indexbyte1
 607   //   indexbyte2
 608   //
 609   // followed by an (optional) sequence of:
 610   //
 611   //   aload_0
 612   //   aconst_null / iconst_0 / fconst_0 / dconst_0
 613   //   putfield
 614   //   indexbyte1
 615   //   indexbyte2
 616   //
 617   // followed by:
 618   //
 619   //   return
 620 
 621   assert(name() == vmSymbols::object_initializer_name(),    &quot;Should only be called for default constructors&quot;);
 622   assert(signature() == vmSymbols::void_method_signature(), &quot;Should only be called for default constructors&quot;);
 623   int size = code_size();
 624   // Check if size match
 625   if (size == 0 || size % 5 != 0) return false;
 626   address cb = code_base();
 627   int last = size - 1;
<span class="line-modified"> 628   if (cb[0] != Bytecodes::_aload_0 || cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {</span>

 629     // Does not call superclass default constructor
 630     return false;
 631   }
 632   // Check optional sequence
 633   for (int i = 4; i &lt; last; i += 5) {
 634     if (cb[i] != Bytecodes::_aload_0) return false;
 635     if (!Bytecodes::is_zero_const(Bytecodes::cast(cb[i+1]))) return false;
 636     if (cb[i+2] != Bytecodes::_putfield) return false;
 637   }
 638   return true;
 639 }
 640 
 641 
 642 bool Method::compute_has_loops_flag() {
 643   BytecodeStream bcs(methodHandle(Thread::current(), this));
 644   Bytecodes::Code bc;
 645 
 646   while ((bc = bcs.next()) &gt;= 0) {
 647     switch( bc ) {
 648       case Bytecodes::_ifeq:
</pre>
<hr />
<pre>
 760       if (size_of_parameters() != 3) return false;
 761       break;
 762     default:
 763       return false;
 764   }
 765   if (java_code_at(2) != Bytecodes::_putfield) return false;
 766   if (java_code_at(5) != Bytecodes::_return)   return false;
 767   return true;
 768 }
 769 
 770 bool Method::is_constant_getter() const {
 771   int last_index = code_size() - 1;
 772   // Check if the first 1-3 bytecodes are a constant push
 773   // and the last bytecode is a return.
 774   return (2 &lt;= code_size() &amp;&amp; code_size() &lt;= 4 &amp;&amp;
 775           Bytecodes::is_const(java_code_at(0)) &amp;&amp;
 776           Bytecodes::length_for(java_code_at(0)) == last_index &amp;&amp;
 777           Bytecodes::is_return(java_code_at(last_index)));
 778 }
 779 
<span class="line-modified"> 780 bool Method::is_initializer() const {</span>
<span class="line-modified"> 781   return is_object_initializer() || is_static_initializer();</span>
<span class="line-removed"> 782 }</span>
<span class="line-removed"> 783 </span>
<span class="line-removed"> 784 bool Method::has_valid_initializer_flags() const {</span>
<span class="line-removed"> 785   return (is_static() ||</span>
<span class="line-removed"> 786           method_holder()-&gt;major_version() &lt; 51);</span>
 787 }
 788 
<span class="line-modified"> 789 bool Method::is_static_initializer() const {</span>
 790   // For classfiles version 51 or greater, ensure that the clinit method is
 791   // static.  Non-static methods with the name &quot;&lt;clinit&gt;&quot; are not static
 792   // initializers. (older classfiles exempted for backward compatibility)
<span class="line-modified"> 793   return name() == vmSymbols::class_initializer_name() &amp;&amp;</span>
<span class="line-modified"> 794          has_valid_initializer_flags();</span>






 795 }
 796 
<span class="line-modified"> 797 bool Method::is_object_initializer() const {</span>
<span class="line-modified"> 798    return name() == vmSymbols::object_initializer_name();</span>

 799 }
 800 
 801 bool Method::needs_clinit_barrier() const {
 802   return is_static() &amp;&amp; !method_holder()-&gt;is_initialized();
 803 }
 804 
 805 objArrayHandle Method::resolved_checked_exceptions_impl(Method* method, TRAPS) {
 806   int length = method-&gt;checked_exceptions_length();
 807   if (length == 0) {  // common case
 808     return objArrayHandle(THREAD, Universe::the_empty_class_klass_array());
 809   } else {
 810     methodHandle h_this(THREAD, method);
 811     objArrayOop m_oop = oopFactory::new_objArray(SystemDictionary::Class_klass(), length, CHECK_(objArrayHandle()));
 812     objArrayHandle mirrors (THREAD, m_oop);
 813     for (int i = 0; i &lt; length; i++) {
 814       CheckedExceptionElement* table = h_this-&gt;checked_exceptions_start(); // recompute on each iteration, not gc safe
 815       Klass* k = h_this-&gt;constants()-&gt;klass_at(table[i].class_cp_index, CHECK_(objArrayHandle()));
 816       if (log_is_enabled(Warning, exceptions) &amp;&amp;
 817           !k-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {
 818         ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
 836     // Not necessarily sorted and not necessarily one-to-one.
 837     CompressedLineNumberReadStream stream(compressed_linenumber_table());
 838     while (stream.read_pair()) {
 839       if (stream.bci() == bci) {
 840         // perfect match
 841         return stream.line();
 842       } else {
 843         // update best_bci/line
 844         if (stream.bci() &lt; bci &amp;&amp; stream.bci() &gt;= best_bci) {
 845           best_bci  = stream.bci();
 846           best_line = stream.line();
 847         }
 848       }
 849     }
 850   }
 851   return best_line;
 852 }
 853 
 854 
 855 bool Method::is_klass_loaded_by_klass_index(int klass_index) const {
<span class="line-modified"> 856   if( constants()-&gt;tag_at(klass_index).is_unresolved_klass() ) {</span>
 857     Thread *thread = Thread::current();
 858     Symbol* klass_name = constants()-&gt;klass_name_at(klass_index);
 859     Handle loader(thread, method_holder()-&gt;class_loader());
 860     Handle prot  (thread, method_holder()-&gt;protection_domain());
 861     return SystemDictionary::find(klass_name, loader, prot, thread) != NULL;
 862   } else {
 863     return true;
 864   }
 865 }
 866 
 867 
 868 bool Method::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
 869   int klass_index = constants()-&gt;klass_ref_index_at(refinfo_index);
 870   if (must_be_resolved) {
 871     // Make sure klass is resolved in constantpool.
<span class="line-modified"> 872     if (constants()-&gt;tag_at(klass_index).is_unresolved_klass()) return false;</span>


 873   }
 874   return is_klass_loaded_by_klass_index(klass_index);
 875 }
 876 
 877 
 878 void Method::set_native_function(address function, bool post_event_flag) {
 879   assert(function != NULL, &quot;use clear_native_function to unregister natives&quot;);
 880   assert(!is_method_handle_intrinsic() || function == SharedRuntime::native_method_throw_unsatisfied_link_error_entry(), &quot;&quot;);
 881   address* native_function = native_function_addr();
 882 
 883   // We can see racers trying to place the same native function into place. Once
 884   // is plenty.
 885   address current = *native_function;
 886   if (current == function) return;
 887   if (post_event_flag &amp;&amp; JvmtiExport::should_post_native_method_bind() &amp;&amp;
 888       function != NULL) {
 889     // native_method_throw_unsatisfied_link_error_entry() should only
 890     // be passed when post_event_flag is false.
 891     assert(function !=
 892       SharedRuntime::native_method_throw_unsatisfied_link_error_entry(),
</pre>
<hr />
<pre>
1021 void Method::set_not_osr_compilable(const char* reason, int comp_level, bool report) {
1022   print_made_not_compilable(comp_level, /*is_osr*/ true, report, reason);
1023   if (comp_level == CompLevel_all) {
1024     set_not_c1_osr_compilable();
1025     set_not_c2_osr_compilable();
1026   } else {
1027     if (is_c1_compile(comp_level))
1028       set_not_c1_osr_compilable();
1029     if (is_c2_compile(comp_level))
1030       set_not_c2_osr_compilable();
1031   }
1032   assert(!CompilationPolicy::can_be_osr_compiled(methodHandle(Thread::current(), this), comp_level), &quot;sanity check&quot;);
1033 }
1034 
1035 // Revert to using the interpreter and clear out the nmethod
1036 void Method::clear_code() {
1037   // this may be NULL if c2i adapters have not been made yet
1038   // Only should happen at allocate time.
1039   if (adapter() == NULL) {
1040     _from_compiled_entry    = NULL;


1041   } else {
1042     _from_compiled_entry    = adapter()-&gt;get_c2i_entry();


1043   }
1044   OrderAccess::storestore();
1045   _from_interpreted_entry = _i2i_entry;
1046   OrderAccess::storestore();
1047   _code = NULL;
1048 }
1049 
1050 void Method::unlink_code(CompiledMethod *compare) {
1051   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1052   // We need to check if either the _code or _from_compiled_code_entry_point
1053   // refer to this nmethod because there is a race in setting these two fields
1054   // in Method* as seen in bugid 4947125.
1055   // If the vep() points to the zombie nmethod, the memory for the nmethod
1056   // could be flushed and the compiler and vtable stubs could still call
1057   // through it.
1058   if (code() == compare ||
1059       from_compiled_entry() == compare-&gt;verified_entry_point()) {
1060     clear_code();
1061   }
1062 }
</pre>
<hr />
<pre>
1067 }
1068 
1069 #if INCLUDE_CDS
1070 // Called by class data sharing to remove any entry points (which are not shared)
1071 void Method::unlink_method() {
1072   _code = NULL;
1073 
1074   Arguments::assert_is_dumping_archive();
1075   // Set the values to what they should be at run time. Note that
1076   // this Method can no longer be executed during dump time.
1077   _i2i_entry = Interpreter::entry_for_cds_method(methodHandle(Thread::current(), this));
1078   _from_interpreted_entry = _i2i_entry;
1079 
1080   if (DynamicDumpSharedSpaces) {
1081     assert(_from_compiled_entry != NULL, &quot;sanity&quot;);
1082   } else {
1083     // TODO: Simplify the adapter trampoline allocation for static archiving.
1084     //       Remove the use of CDSAdapterHandlerEntry.
1085     CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();
1086     constMethod()-&gt;set_adapter_trampoline(cds_adapter-&gt;get_adapter_trampoline());

1087     _from_compiled_entry = cds_adapter-&gt;get_c2i_entry_trampoline();
1088     assert(*((int*)_from_compiled_entry) == 0,
<span class="line-modified">1089            &quot;must be NULL during dump time, to be initialized at run time&quot;);</span>








1090   }
1091 
1092   if (is_native()) {
1093     *native_function_addr() = NULL;
1094     set_signature_handler(NULL);
1095   }
1096   NOT_PRODUCT(set_compiled_invocation_count(0);)
1097 
1098   set_method_data(NULL);
1099   clear_method_counters();
1100 }
1101 #endif
1102 
1103 /****************************************************************************
1104 // The following illustrates how the entries work for CDS shared Methods:
1105 //
1106 // Our goal is to delay writing into a shared Method until it&#39;s compiled.
1107 // Hence, we want to determine the initial values for _i2i_entry,
1108 // _from_interpreted_entry and _from_compiled_entry during CDS dump time.
1109 //
</pre>
<hr />
<pre>
1222 
1223 address Method::make_adapters(const methodHandle&amp; mh, TRAPS) {
1224   // Adapters for compiled code are made eagerly here.  They are fairly
1225   // small (generally &lt; 100 bytes) and quick to make (and cached and shared)
1226   // so making them eagerly shouldn&#39;t be too expensive.
1227   AdapterHandlerEntry* adapter = AdapterHandlerLibrary::get_adapter(mh);
1228   if (adapter == NULL ) {
1229     if (!is_init_completed()) {
1230       // Don&#39;t throw exceptions during VM initialization because java.lang.* classes
1231       // might not have been initialized, causing problems when constructing the
1232       // Java exception object.
1233       vm_exit_during_initialization(&quot;Out of space in CodeCache for adapters&quot;);
1234     } else {
1235       THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(), &quot;Out of space in CodeCache for adapters&quot;);
1236     }
1237   }
1238 
1239   if (mh-&gt;is_shared()) {
1240     assert(mh-&gt;adapter() == adapter, &quot;must be&quot;);
1241     assert(mh-&gt;_from_compiled_entry != NULL, &quot;must be&quot;);


1242   } else {
1243     mh-&gt;set_adapter_entry(adapter);
1244     mh-&gt;_from_compiled_entry = adapter-&gt;get_c2i_entry();


1245   }
1246   return adapter-&gt;get_c2i_entry();
1247 }
1248 
1249 void Method::restore_unshareable_info(TRAPS) {
1250   assert(is_method() &amp;&amp; is_valid_method(this), &quot;ensure C++ vtable is restored&quot;);
1251 












1252   // Since restore_unshareable_info can be called more than once for a method, don&#39;t
1253   // redo any work.
1254   if (adapter() == NULL) {
1255     methodHandle mh(THREAD, this);
1256     link_method(mh, CHECK);
1257   }

1258 }
1259 
<span class="line-modified">1260 address Method::from_compiled_entry_no_trampoline() const {</span>
1261   CompiledMethod *code = Atomic::load_acquire(&amp;_code);
<span class="line-modified">1262   if (code) {</span>
<span class="line-modified">1263     return code-&gt;verified_entry_point();</span>





1264   } else {
<span class="line-modified">1265     return adapter()-&gt;get_c2i_entry();</span>





1266   }
1267 }
1268 
1269 // The verified_code_entry() must be called when a invoke is resolved
1270 // on this method.
1271 
1272 // It returns the compiled code entry point, after asserting not null.
1273 // This function is called after potential safepoints so that nmethod
1274 // or adapter that it points to is still live and valid.
1275 // This function must not hit a safepoint!
1276 address Method::verified_code_entry() {
1277   debug_only(NoSafepointVerifier nsv;)
1278   assert(_from_compiled_entry != NULL, &quot;must be set&quot;);
1279   return _from_compiled_entry;
1280 }
1281 












1282 // Check that if an nmethod ref exists, it has a backlink to this or no backlink at all
1283 // (could be racing a deopt).
1284 // Not inline to avoid circular ref.
1285 bool Method::check_code() const {
1286   // cached in a register or local.  There&#39;s a race on the value of the field.
1287   CompiledMethod *code = Atomic::load_acquire(&amp;_code);
1288   return code == NULL || (code-&gt;method() == NULL) || (code-&gt;method() == (Method*)this &amp;&amp; !code-&gt;is_osr_method());
1289 }
1290 
1291 // Install compiled code.  Instantly it can execute.
1292 void Method::set_code(const methodHandle&amp; mh, CompiledMethod *code) {
1293   assert_lock_strong(CompiledMethod_lock);
1294   assert( code, &quot;use clear_code to remove code&quot; );
1295   assert( mh-&gt;check_code(), &quot;&quot; );
1296 
1297   guarantee(mh-&gt;adapter() != NULL, &quot;Adapter blob must already exist!&quot;);
1298 
1299   // These writes must happen in this order, because the interpreter will
1300   // directly jump to from_interpreted_entry which jumps to an i2c adapter
1301   // which jumps to _from_compiled_entry.
1302   mh-&gt;_code = code;             // Assign before allowing compiled code to exec
1303 
1304   int comp_level = code-&gt;comp_level();
1305   // In theory there could be a race here. In practice it is unlikely
1306   // and not worth worrying about.
1307   if (comp_level &gt; mh-&gt;highest_comp_level()) {
1308     mh-&gt;set_highest_comp_level(comp_level);
1309   }
1310 
1311   OrderAccess::storestore();
1312   mh-&gt;_from_compiled_entry = code-&gt;verified_entry_point();


1313   OrderAccess::storestore();
1314   // Instantly compiled code can execute.
1315   if (!mh-&gt;is_method_handle_intrinsic())
1316     mh-&gt;_from_interpreted_entry = mh-&gt;get_i2c_entry();
1317 }
1318 
1319 
1320 bool Method::is_overridden_in(Klass* k) const {
1321   InstanceKlass* ik = InstanceKlass::cast(k);
1322 
1323   if (ik-&gt;is_interface()) return false;
1324 
1325   // If method is an interface, we skip it - except if it
1326   // is a miranda method
1327   if (method_holder()-&gt;is_interface()) {
1328     // Check that method is not a miranda method
1329     if (ik-&gt;lookup_method(name(), signature()) == NULL) {
1330       // No implementation exist - so miranda method
1331       return false;
1332     }
</pre>
<hr />
<pre>
2324 void Method::print_on(outputStream* st) const {
2325   ResourceMark rm;
2326   assert(is_method(), &quot;must be method&quot;);
2327   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2328   st-&gt;print_cr(&quot; - this oop:          &quot; INTPTR_FORMAT, p2i(this));
2329   st-&gt;print   (&quot; - method holder:     &quot;); method_holder()-&gt;print_value_on(st); st-&gt;cr();
2330   st-&gt;print   (&quot; - constants:         &quot; INTPTR_FORMAT &quot; &quot;, p2i(constants()));
2331   constants()-&gt;print_value_on(st); st-&gt;cr();
2332   st-&gt;print   (&quot; - access:            0x%x  &quot;, access_flags().as_int()); access_flags().print_on(st); st-&gt;cr();
2333   st-&gt;print   (&quot; - name:              &quot;);    name()-&gt;print_value_on(st); st-&gt;cr();
2334   st-&gt;print   (&quot; - signature:         &quot;);    signature()-&gt;print_value_on(st); st-&gt;cr();
2335   st-&gt;print_cr(&quot; - max stack:         %d&quot;,   max_stack());
2336   st-&gt;print_cr(&quot; - max locals:        %d&quot;,   max_locals());
2337   st-&gt;print_cr(&quot; - size of params:    %d&quot;,   size_of_parameters());
2338   st-&gt;print_cr(&quot; - method size:       %d&quot;,   method_size());
2339   if (intrinsic_id() != vmIntrinsics::_none)
2340     st-&gt;print_cr(&quot; - intrinsic id:      %d %s&quot;, intrinsic_id(), vmIntrinsics::name_at(intrinsic_id()));
2341   if (highest_comp_level() != CompLevel_none)
2342     st-&gt;print_cr(&quot; - highest level:     %d&quot;, highest_comp_level());
2343   st-&gt;print_cr(&quot; - vtable index:      %d&quot;,   _vtable_index);


2344   st-&gt;print_cr(&quot; - i2i entry:         &quot; INTPTR_FORMAT, p2i(interpreter_entry()));
2345   st-&gt;print(   &quot; - adapters:          &quot;);
2346   AdapterHandlerEntry* a = ((Method*)this)-&gt;adapter();
2347   if (a == NULL)
2348     st-&gt;print_cr(INTPTR_FORMAT, p2i(a));
2349   else
2350     a-&gt;print_adapter_on(st);
2351   st-&gt;print_cr(&quot; - compiled entry     &quot; INTPTR_FORMAT, p2i(from_compiled_entry()));
2352   st-&gt;print_cr(&quot; - code size:         %d&quot;,   code_size());
2353   if (code_size() != 0) {
2354     st-&gt;print_cr(&quot; - code start:        &quot; INTPTR_FORMAT, p2i(code_base()));
2355     st-&gt;print_cr(&quot; - code end (excl):   &quot; INTPTR_FORMAT, p2i(code_base() + code_size()));
2356   }
2357   if (method_data() != NULL) {
2358     st-&gt;print_cr(&quot; - method data:       &quot; INTPTR_FORMAT, p2i(method_data()));
2359   }
2360   st-&gt;print_cr(&quot; - checked ex length: %d&quot;,   checked_exceptions_length());
2361   if (checked_exceptions_length() &gt; 0) {
2362     CheckedExceptionElement* table = checked_exceptions_start();
2363     st-&gt;print_cr(&quot; - checked ex start:  &quot; INTPTR_FORMAT, p2i(table));
</pre>
<hr />
<pre>
2401     st-&gt;print_cr(&quot; - signature handler: &quot; INTPTR_FORMAT, p2i(signature_handler()));
2402   }
2403 }
2404 
2405 void Method::print_linkage_flags(outputStream* st) {
2406   access_flags().print_on(st);
2407   if (is_default_method()) {
2408     st-&gt;print(&quot;default &quot;);
2409   }
2410   if (is_overpass()) {
2411     st-&gt;print(&quot;overpass &quot;);
2412   }
2413 }
2414 #endif //PRODUCT
2415 
2416 void Method::print_value_on(outputStream* st) const {
2417   assert(is_method(), &quot;must be method&quot;);
2418   st-&gt;print(&quot;%s&quot;, internal_name());
2419   print_address_on(st);
2420   st-&gt;print(&quot; &quot;);

2421   name()-&gt;print_value_on(st);
2422   st-&gt;print(&quot; &quot;);
2423   signature()-&gt;print_value_on(st);
2424   st-&gt;print(&quot; in &quot;);
2425   method_holder()-&gt;print_value_on(st);
2426   if (WizardMode) st-&gt;print(&quot;#%d&quot;, _vtable_index);
2427   if (WizardMode) st-&gt;print(&quot;[%d,%d]&quot;, size_of_parameters(), max_locals());
2428   if (WizardMode &amp;&amp; code() != NULL) st-&gt;print(&quot; ((nmethod*)%p)&quot;, code());
2429 }
2430 
2431 // LogTouchedMethods and PrintTouchedMethods
2432 
2433 // TouchedMethodRecord -- we can&#39;t use a HashtableEntry&lt;Method*&gt; because
2434 // the Method may be garbage collected. Let&#39;s roll our own hash table.
2435 class TouchedMethodRecord : CHeapObj&lt;mtTracing&gt; {
2436 public:
2437   // It&#39;s OK to store Symbols here because they will NOT be GC&#39;ed if
2438   // LogTouchedMethods is enabled.
2439   TouchedMethodRecord* _next;
2440   Symbol* _class_name;
</pre>
</td>
<td>
<hr />
<pre>
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;interpreter/oopMapCache.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;logging/logTag.hpp&quot;
  41 #include &quot;logging/logStream.hpp&quot;
  42 #include &quot;memory/allocation.inline.hpp&quot;
  43 #include &quot;memory/metadataFactory.hpp&quot;
  44 #include &quot;memory/metaspaceClosure.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/constMethod.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/method.inline.hpp&quot;
  52 #include &quot;oops/methodData.hpp&quot;
  53 #include &quot;oops/objArrayKlass.hpp&quot;
  54 #include &quot;oops/objArrayOop.inline.hpp&quot;
  55 #include &quot;oops/oop.inline.hpp&quot;
  56 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  57 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  58 #include &quot;prims/jvmtiExport.hpp&quot;
  59 #include &quot;prims/methodHandles.hpp&quot;
  60 #include &quot;prims/nativeLookup.hpp&quot;
  61 #include &quot;runtime/arguments.hpp&quot;
  62 #include &quot;runtime/atomic.hpp&quot;
  63 #include &quot;runtime/frame.inline.hpp&quot;
  64 #include &quot;runtime/handles.inline.hpp&quot;
  65 #include &quot;runtime/init.hpp&quot;
  66 #include &quot;runtime/orderAccess.hpp&quot;
  67 #include &quot;runtime/relocator.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/sharedRuntime.hpp&quot;
  70 #include &quot;runtime/signature.hpp&quot;
  71 #include &quot;utilities/align.hpp&quot;
  72 #include &quot;utilities/quickSort.hpp&quot;
  73 #include &quot;utilities/vmError.hpp&quot;
  74 #include &quot;utilities/xmlstream.hpp&quot;
  75 
  76 // Implementation of Method
  77 
</pre>
<hr />
<pre>
  97   set_constMethod(xconst);
  98   set_access_flags(access_flags);
  99   set_intrinsic_id(vmIntrinsics::_none);
 100   set_force_inline(false);
 101   set_hidden(false);
 102   set_dont_inline(false);
 103   set_has_injected_profile(false);
 104   set_method_data(NULL);
 105   clear_method_counters();
 106   set_vtable_index(Method::garbage_vtable_index);
 107 
 108   // Fix and bury in Method*
 109   set_interpreter_entry(NULL); // sets i2i entry and from_int
 110   set_adapter_entry(NULL);
 111   Method::clear_code(); // from_c/from_i get set to c2i/i2i
 112 
 113   if (access_flags.is_native()) {
 114     clear_native_function();
 115     set_signature_handler(NULL);
 116   }

 117   NOT_PRODUCT(set_compiled_invocation_count(0);)
 118 }
 119 
 120 // Release Method*.  The nmethod will be gone when we get here because
 121 // we&#39;ve walked the code cache.
 122 void Method::deallocate_contents(ClassLoaderData* loader_data) {
 123   MetadataFactory::free_metadata(loader_data, constMethod());
 124   set_constMethod(NULL);
 125   MetadataFactory::free_metadata(loader_data, method_data());
 126   set_method_data(NULL);
 127   MetadataFactory::free_metadata(loader_data, method_counters());
 128   clear_method_counters();
 129   // The nmethod will be gone when we get here.
 130   if (code() != NULL) _code = NULL;
 131 }
 132 
 133 void Method::release_C_heap_structures() {
 134   if (method_data()) {
 135 #if INCLUDE_JVMCI
 136     FailedSpeculation::free_failed_speculations(method_data()-&gt;get_failed_speculations_address());
 137 #endif
 138     // Destroy MethodData
 139     method_data()-&gt;~MethodData();
 140   }
 141 }
 142 
 143 address Method::get_i2c_entry() {
 144   assert(adapter() != NULL, &quot;must have&quot;);
 145   return adapter()-&gt;get_i2c_entry();
 146 }
 147 
 148 address Method::get_c2i_entry() {
 149   assert(adapter() != NULL, &quot;must have&quot;);
 150   return adapter()-&gt;get_c2i_entry();
 151 }
 152 
<span class="line-added"> 153 address Method::get_c2i_inline_entry() {</span>
<span class="line-added"> 154   assert(adapter() != NULL, &quot;must have&quot;);</span>
<span class="line-added"> 155   return adapter()-&gt;get_c2i_inline_entry();</span>
<span class="line-added"> 156 }</span>
<span class="line-added"> 157 </span>
 158 address Method::get_c2i_unverified_entry() {
 159   assert(adapter() != NULL, &quot;must have&quot;);
 160   return adapter()-&gt;get_c2i_unverified_entry();
 161 }
 162 
<span class="line-added"> 163 address Method::get_c2i_unverified_inline_entry() {</span>
<span class="line-added"> 164   assert(adapter() != NULL, &quot;must have&quot;);</span>
<span class="line-added"> 165   return adapter()-&gt;get_c2i_unverified_inline_entry();</span>
<span class="line-added"> 166 }</span>
<span class="line-added"> 167 </span>
 168 address Method::get_c2i_no_clinit_check_entry() {
 169   assert(VM_Version::supports_fast_class_init_checks(), &quot;&quot;);
 170   assert(adapter() != NULL, &quot;must have&quot;);
 171   return adapter()-&gt;get_c2i_no_clinit_check_entry();
 172 }
 173 
 174 char* Method::name_and_sig_as_C_string() const {
 175   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature());
 176 }
 177 
 178 char* Method::name_and_sig_as_C_string(char* buf, int size) const {
 179   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature(), buf, size);
 180 }
 181 
 182 char* Method::name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature) {
 183   const char* klass_name = klass-&gt;external_name();
 184   int klass_name_len  = (int)strlen(klass_name);
 185   int method_name_len = method_name-&gt;utf8_length();
 186   int len             = klass_name_len + 1 + method_name_len + signature-&gt;utf8_length();
 187   char* dest          = NEW_RESOURCE_ARRAY(char, len + 1);
</pre>
<hr />
<pre>
 340   // If native, then include pointers for native_function and signature_handler
 341   int extra_bytes = (is_native) ? 2*sizeof(address*) : 0;
 342   int extra_words = align_up(extra_bytes, BytesPerWord) / BytesPerWord;
 343   return align_metadata_size(header_size() + extra_words);
 344 }
 345 
 346 Symbol* Method::klass_name() const {
 347   return method_holder()-&gt;name();
 348 }
 349 
 350 void Method::metaspace_pointers_do(MetaspaceClosure* it) {
 351   log_trace(cds)(&quot;Iter(Method): %p&quot;, this);
 352 
 353   it-&gt;push(&amp;_constMethod);
 354   it-&gt;push(&amp;_method_data);
 355   it-&gt;push(&amp;_method_counters);
 356 
 357   Method* this_ptr = this;
 358   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_i2i_entry);
 359   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_entry);
<span class="line-added"> 360   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_inline_ro_entry);</span>
<span class="line-added"> 361   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_inline_entry);</span>
 362   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_interpreted_entry);
 363 }
 364 
 365 // Attempt to return method oop to original state.  Clear any pointers
 366 // (to objects outside the shared spaces).  We won&#39;t be able to predict
 367 // where they should point in a new JVM.  Further initialize some
 368 // entries now in order allow them to be write protected later.
 369 
 370 void Method::remove_unshareable_info() {
 371   unlink_method();
 372   JFR_ONLY(REMOVE_METHOD_ID(this);)
 373 }
 374 
 375 void Method::set_vtable_index(int index) {
 376   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 377     // At runtime initialize_vtable is rerun as part of link_class_impl()
 378     // for a shared class loaded by the non-boot loader to obtain the loader
 379     // constraints based on the runtime classloaders&#39; context.
 380     return; // don&#39;t write into the shared class
 381   } else {
</pre>
<hr />
<pre>
 586   return Atomic::replace_if_null(&amp;_method_counters, counters);
 587 }
 588 
 589 int Method::extra_stack_words() {
 590   // not an inline function, to avoid a header dependency on Interpreter
 591   return extra_stack_entries() * Interpreter::stackElementSize;
 592 }
 593 
 594 // Derive size of parameters, return type, and fingerprint,
 595 // all in one pass, which is run at load time.
 596 // We need the first two, and might as well grab the third.
 597 void Method::compute_from_signature(Symbol* sig) {
 598   // At this point, since we are scanning the signature,
 599   // we might as well compute the whole fingerprint.
 600   Fingerprinter fp(sig, is_static());
 601   set_size_of_parameters(fp.size_of_parameters());
 602   constMethod()-&gt;set_result_type(fp.return_type());
 603   constMethod()-&gt;set_fingerprint(fp.fingerprint());
 604 }
 605 
<span class="line-added"> 606 // InlineKlass the method is declared to return. This must not</span>
<span class="line-added"> 607 // safepoint as it is called with references live on the stack at</span>
<span class="line-added"> 608 // locations the GC is unaware of.</span>
<span class="line-added"> 609 InlineKlass* Method::returned_inline_type(Thread* thread) const {</span>
<span class="line-added"> 610   SignatureStream ss(signature());</span>
<span class="line-added"> 611   while (!ss.at_return_type()) {</span>
<span class="line-added"> 612     ss.next();</span>
<span class="line-added"> 613   }</span>
<span class="line-added"> 614   Handle class_loader(thread, method_holder()-&gt;class_loader());</span>
<span class="line-added"> 615   Handle protection_domain(thread, method_holder()-&gt;protection_domain());</span>
<span class="line-added"> 616   Klass* k = NULL;</span>
<span class="line-added"> 617   {</span>
<span class="line-added"> 618     NoSafepointVerifier nsv;</span>
<span class="line-added"> 619     k = ss.as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, thread);</span>
<span class="line-added"> 620   }</span>
<span class="line-added"> 621   assert(k != NULL &amp;&amp; !thread-&gt;has_pending_exception(), &quot;can&#39;t resolve klass&quot;);</span>
<span class="line-added"> 622   return InlineKlass::cast(k);</span>
<span class="line-added"> 623 }</span>
 624 bool Method::is_empty_method() const {
 625   return  code_size() == 1
 626       &amp;&amp; *code_base() == Bytecodes::_return;
 627 }
 628 
 629 bool Method::is_vanilla_constructor() const {
 630   // Returns true if this method is a vanilla constructor, i.e. an &quot;&lt;init&gt;&quot; &quot;()V&quot; method
 631   // which only calls the superclass vanilla constructor and possibly does stores of
 632   // zero constants to local fields:
 633   //
<span class="line-modified"> 634   //   aload_0, _fast_aload_0, or _nofast_aload_0</span>
 635   //   invokespecial
 636   //   indexbyte1
 637   //   indexbyte2
 638   //
 639   // followed by an (optional) sequence of:
 640   //
 641   //   aload_0
 642   //   aconst_null / iconst_0 / fconst_0 / dconst_0
 643   //   putfield
 644   //   indexbyte1
 645   //   indexbyte2
 646   //
 647   // followed by:
 648   //
 649   //   return
 650 
 651   assert(name() == vmSymbols::object_initializer_name(),    &quot;Should only be called for default constructors&quot;);
 652   assert(signature() == vmSymbols::void_method_signature(), &quot;Should only be called for default constructors&quot;);
 653   int size = code_size();
 654   // Check if size match
 655   if (size == 0 || size % 5 != 0) return false;
 656   address cb = code_base();
 657   int last = size - 1;
<span class="line-modified"> 658   if ((cb[0] != Bytecodes::_aload_0 &amp;&amp; cb[0] != Bytecodes::_fast_aload_0 &amp;&amp; cb[0] != Bytecodes::_nofast_aload_0) ||</span>
<span class="line-added"> 659        cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {</span>
 660     // Does not call superclass default constructor
 661     return false;
 662   }
 663   // Check optional sequence
 664   for (int i = 4; i &lt; last; i += 5) {
 665     if (cb[i] != Bytecodes::_aload_0) return false;
 666     if (!Bytecodes::is_zero_const(Bytecodes::cast(cb[i+1]))) return false;
 667     if (cb[i+2] != Bytecodes::_putfield) return false;
 668   }
 669   return true;
 670 }
 671 
 672 
 673 bool Method::compute_has_loops_flag() {
 674   BytecodeStream bcs(methodHandle(Thread::current(), this));
 675   Bytecodes::Code bc;
 676 
 677   while ((bc = bcs.next()) &gt;= 0) {
 678     switch( bc ) {
 679       case Bytecodes::_ifeq:
</pre>
<hr />
<pre>
 791       if (size_of_parameters() != 3) return false;
 792       break;
 793     default:
 794       return false;
 795   }
 796   if (java_code_at(2) != Bytecodes::_putfield) return false;
 797   if (java_code_at(5) != Bytecodes::_return)   return false;
 798   return true;
 799 }
 800 
 801 bool Method::is_constant_getter() const {
 802   int last_index = code_size() - 1;
 803   // Check if the first 1-3 bytecodes are a constant push
 804   // and the last bytecode is a return.
 805   return (2 &lt;= code_size() &amp;&amp; code_size() &lt;= 4 &amp;&amp;
 806           Bytecodes::is_const(java_code_at(0)) &amp;&amp;
 807           Bytecodes::length_for(java_code_at(0)) == last_index &amp;&amp;
 808           Bytecodes::is_return(java_code_at(last_index)));
 809 }
 810 
<span class="line-modified"> 811 bool Method::is_object_constructor_or_class_initializer() const {</span>
<span class="line-modified"> 812   return (is_object_constructor() || is_class_initializer());</span>





 813 }
 814 
<span class="line-modified"> 815 bool Method::is_class_initializer() const {</span>
 816   // For classfiles version 51 or greater, ensure that the clinit method is
 817   // static.  Non-static methods with the name &quot;&lt;clinit&gt;&quot; are not static
 818   // initializers. (older classfiles exempted for backward compatibility)
<span class="line-modified"> 819   return (name() == vmSymbols::class_initializer_name() &amp;&amp;</span>
<span class="line-modified"> 820           (is_static() ||</span>
<span class="line-added"> 821            method_holder()-&gt;major_version() &lt; 51));</span>
<span class="line-added"> 822 }</span>
<span class="line-added"> 823 </span>
<span class="line-added"> 824 // A method named &lt;init&gt;, if non-static, is a classic object constructor.</span>
<span class="line-added"> 825 bool Method::is_object_constructor() const {</span>
<span class="line-added"> 826    return name() == vmSymbols::object_initializer_name() &amp;&amp; !is_static();</span>
 827 }
 828 
<span class="line-modified"> 829 // A static method named &lt;init&gt; is a factory for an inline class.</span>
<span class="line-modified"> 830 bool Method::is_static_init_factory() const {</span>
<span class="line-added"> 831    return name() == vmSymbols::object_initializer_name() &amp;&amp; is_static();</span>
 832 }
 833 
 834 bool Method::needs_clinit_barrier() const {
 835   return is_static() &amp;&amp; !method_holder()-&gt;is_initialized();
 836 }
 837 
 838 objArrayHandle Method::resolved_checked_exceptions_impl(Method* method, TRAPS) {
 839   int length = method-&gt;checked_exceptions_length();
 840   if (length == 0) {  // common case
 841     return objArrayHandle(THREAD, Universe::the_empty_class_klass_array());
 842   } else {
 843     methodHandle h_this(THREAD, method);
 844     objArrayOop m_oop = oopFactory::new_objArray(SystemDictionary::Class_klass(), length, CHECK_(objArrayHandle()));
 845     objArrayHandle mirrors (THREAD, m_oop);
 846     for (int i = 0; i &lt; length; i++) {
 847       CheckedExceptionElement* table = h_this-&gt;checked_exceptions_start(); // recompute on each iteration, not gc safe
 848       Klass* k = h_this-&gt;constants()-&gt;klass_at(table[i].class_cp_index, CHECK_(objArrayHandle()));
 849       if (log_is_enabled(Warning, exceptions) &amp;&amp;
 850           !k-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {
 851         ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
 869     // Not necessarily sorted and not necessarily one-to-one.
 870     CompressedLineNumberReadStream stream(compressed_linenumber_table());
 871     while (stream.read_pair()) {
 872       if (stream.bci() == bci) {
 873         // perfect match
 874         return stream.line();
 875       } else {
 876         // update best_bci/line
 877         if (stream.bci() &lt; bci &amp;&amp; stream.bci() &gt;= best_bci) {
 878           best_bci  = stream.bci();
 879           best_line = stream.line();
 880         }
 881       }
 882     }
 883   }
 884   return best_line;
 885 }
 886 
 887 
 888 bool Method::is_klass_loaded_by_klass_index(int klass_index) const {
<span class="line-modified"> 889   if( constants()-&gt;tag_at(klass_index).is_unresolved_klass()) {</span>
 890     Thread *thread = Thread::current();
 891     Symbol* klass_name = constants()-&gt;klass_name_at(klass_index);
 892     Handle loader(thread, method_holder()-&gt;class_loader());
 893     Handle prot  (thread, method_holder()-&gt;protection_domain());
 894     return SystemDictionary::find(klass_name, loader, prot, thread) != NULL;
 895   } else {
 896     return true;
 897   }
 898 }
 899 
 900 
 901 bool Method::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
 902   int klass_index = constants()-&gt;klass_ref_index_at(refinfo_index);
 903   if (must_be_resolved) {
 904     // Make sure klass is resolved in constantpool.
<span class="line-modified"> 905     if (constants()-&gt;tag_at(klass_index).is_unresolved_klass()) {</span>
<span class="line-added"> 906       return false;</span>
<span class="line-added"> 907     }</span>
 908   }
 909   return is_klass_loaded_by_klass_index(klass_index);
 910 }
 911 
 912 
 913 void Method::set_native_function(address function, bool post_event_flag) {
 914   assert(function != NULL, &quot;use clear_native_function to unregister natives&quot;);
 915   assert(!is_method_handle_intrinsic() || function == SharedRuntime::native_method_throw_unsatisfied_link_error_entry(), &quot;&quot;);
 916   address* native_function = native_function_addr();
 917 
 918   // We can see racers trying to place the same native function into place. Once
 919   // is plenty.
 920   address current = *native_function;
 921   if (current == function) return;
 922   if (post_event_flag &amp;&amp; JvmtiExport::should_post_native_method_bind() &amp;&amp;
 923       function != NULL) {
 924     // native_method_throw_unsatisfied_link_error_entry() should only
 925     // be passed when post_event_flag is false.
 926     assert(function !=
 927       SharedRuntime::native_method_throw_unsatisfied_link_error_entry(),
</pre>
<hr />
<pre>
1056 void Method::set_not_osr_compilable(const char* reason, int comp_level, bool report) {
1057   print_made_not_compilable(comp_level, /*is_osr*/ true, report, reason);
1058   if (comp_level == CompLevel_all) {
1059     set_not_c1_osr_compilable();
1060     set_not_c2_osr_compilable();
1061   } else {
1062     if (is_c1_compile(comp_level))
1063       set_not_c1_osr_compilable();
1064     if (is_c2_compile(comp_level))
1065       set_not_c2_osr_compilable();
1066   }
1067   assert(!CompilationPolicy::can_be_osr_compiled(methodHandle(Thread::current(), this), comp_level), &quot;sanity check&quot;);
1068 }
1069 
1070 // Revert to using the interpreter and clear out the nmethod
1071 void Method::clear_code() {
1072   // this may be NULL if c2i adapters have not been made yet
1073   // Only should happen at allocate time.
1074   if (adapter() == NULL) {
1075     _from_compiled_entry    = NULL;
<span class="line-added">1076     _from_compiled_inline_entry = NULL;</span>
<span class="line-added">1077     _from_compiled_inline_ro_entry = NULL;</span>
1078   } else {
1079     _from_compiled_entry    = adapter()-&gt;get_c2i_entry();
<span class="line-added">1080     _from_compiled_inline_entry = adapter()-&gt;get_c2i_inline_entry();</span>
<span class="line-added">1081     _from_compiled_inline_ro_entry = adapter()-&gt;get_c2i_inline_ro_entry();</span>
1082   }
1083   OrderAccess::storestore();
1084   _from_interpreted_entry = _i2i_entry;
1085   OrderAccess::storestore();
1086   _code = NULL;
1087 }
1088 
1089 void Method::unlink_code(CompiledMethod *compare) {
1090   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1091   // We need to check if either the _code or _from_compiled_code_entry_point
1092   // refer to this nmethod because there is a race in setting these two fields
1093   // in Method* as seen in bugid 4947125.
1094   // If the vep() points to the zombie nmethod, the memory for the nmethod
1095   // could be flushed and the compiler and vtable stubs could still call
1096   // through it.
1097   if (code() == compare ||
1098       from_compiled_entry() == compare-&gt;verified_entry_point()) {
1099     clear_code();
1100   }
1101 }
</pre>
<hr />
<pre>
1106 }
1107 
1108 #if INCLUDE_CDS
1109 // Called by class data sharing to remove any entry points (which are not shared)
1110 void Method::unlink_method() {
1111   _code = NULL;
1112 
1113   Arguments::assert_is_dumping_archive();
1114   // Set the values to what they should be at run time. Note that
1115   // this Method can no longer be executed during dump time.
1116   _i2i_entry = Interpreter::entry_for_cds_method(methodHandle(Thread::current(), this));
1117   _from_interpreted_entry = _i2i_entry;
1118 
1119   if (DynamicDumpSharedSpaces) {
1120     assert(_from_compiled_entry != NULL, &quot;sanity&quot;);
1121   } else {
1122     // TODO: Simplify the adapter trampoline allocation for static archiving.
1123     //       Remove the use of CDSAdapterHandlerEntry.
1124     CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();
1125     constMethod()-&gt;set_adapter_trampoline(cds_adapter-&gt;get_adapter_trampoline());
<span class="line-added">1126 </span>
1127     _from_compiled_entry = cds_adapter-&gt;get_c2i_entry_trampoline();
1128     assert(*((int*)_from_compiled_entry) == 0,
<span class="line-modified">1129            &quot;instructions must be zeros during dump time, to be initialized at run time&quot;);</span>
<span class="line-added">1130 </span>
<span class="line-added">1131     _from_compiled_inline_ro_entry = cds_adapter-&gt;get_c2i_inline_ro_entry_trampoline();</span>
<span class="line-added">1132     assert(*((int*)_from_compiled_inline_ro_entry) == 0,</span>
<span class="line-added">1133            &quot;instructions must be zeros during dump time, to be initialized at run time&quot;);</span>
<span class="line-added">1134 </span>
<span class="line-added">1135     _from_compiled_inline_entry = cds_adapter-&gt;get_c2i_inline_entry_trampoline();</span>
<span class="line-added">1136     assert(*((int*)_from_compiled_inline_entry) == 0,</span>
<span class="line-added">1137            &quot;instructions must be zeros during dump time, to be initialized at run time&quot;);</span>
1138   }
1139 
1140   if (is_native()) {
1141     *native_function_addr() = NULL;
1142     set_signature_handler(NULL);
1143   }
1144   NOT_PRODUCT(set_compiled_invocation_count(0);)
1145 
1146   set_method_data(NULL);
1147   clear_method_counters();
1148 }
1149 #endif
1150 
1151 /****************************************************************************
1152 // The following illustrates how the entries work for CDS shared Methods:
1153 //
1154 // Our goal is to delay writing into a shared Method until it&#39;s compiled.
1155 // Hence, we want to determine the initial values for _i2i_entry,
1156 // _from_interpreted_entry and _from_compiled_entry during CDS dump time.
1157 //
</pre>
<hr />
<pre>
1270 
1271 address Method::make_adapters(const methodHandle&amp; mh, TRAPS) {
1272   // Adapters for compiled code are made eagerly here.  They are fairly
1273   // small (generally &lt; 100 bytes) and quick to make (and cached and shared)
1274   // so making them eagerly shouldn&#39;t be too expensive.
1275   AdapterHandlerEntry* adapter = AdapterHandlerLibrary::get_adapter(mh);
1276   if (adapter == NULL ) {
1277     if (!is_init_completed()) {
1278       // Don&#39;t throw exceptions during VM initialization because java.lang.* classes
1279       // might not have been initialized, causing problems when constructing the
1280       // Java exception object.
1281       vm_exit_during_initialization(&quot;Out of space in CodeCache for adapters&quot;);
1282     } else {
1283       THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(), &quot;Out of space in CodeCache for adapters&quot;);
1284     }
1285   }
1286 
1287   if (mh-&gt;is_shared()) {
1288     assert(mh-&gt;adapter() == adapter, &quot;must be&quot;);
1289     assert(mh-&gt;_from_compiled_entry != NULL, &quot;must be&quot;);
<span class="line-added">1290     assert(mh-&gt;_from_compiled_inline_entry != NULL, &quot;must be&quot;);</span>
<span class="line-added">1291     assert(mh-&gt;_from_compiled_inline_ro_entry != NULL, &quot;must be&quot;);</span>
1292   } else {
1293     mh-&gt;set_adapter_entry(adapter);
1294     mh-&gt;_from_compiled_entry = adapter-&gt;get_c2i_entry();
<span class="line-added">1295     mh-&gt;_from_compiled_inline_entry = adapter-&gt;get_c2i_inline_entry();</span>
<span class="line-added">1296     mh-&gt;_from_compiled_inline_ro_entry = adapter-&gt;get_c2i_inline_ro_entry();</span>
1297   }
1298   return adapter-&gt;get_c2i_entry();
1299 }
1300 
1301 void Method::restore_unshareable_info(TRAPS) {
1302   assert(is_method() &amp;&amp; is_valid_method(this), &quot;ensure C++ vtable is restored&quot;);
1303 
<span class="line-added">1304 #if 0</span>
<span class="line-added">1305   /*</span>
<span class="line-added">1306    * CDS:TODO --</span>
<span class="line-added">1307    * &quot;Q&quot; classes in the method signature must be resolved during link_method.</span>
<span class="line-added">1308    * However, at this point we are still inside method_holder()-&gt;restore_unshareable_info.</span>
<span class="line-added">1309    * If we try to resolve method_holder(), or multually dependent classes, it will</span>
<span class="line-added">1310    * cause deadlock and other ill effects.</span>
<span class="line-added">1311    *</span>
<span class="line-added">1312    * For now, lets do method linking inside InstanceKlass::link_class(). Optimization</span>
<span class="line-added">1313    * may be possible if we know that resolution will never happen.</span>
<span class="line-added">1314    */</span>
<span class="line-added">1315 </span>
1316   // Since restore_unshareable_info can be called more than once for a method, don&#39;t
1317   // redo any work.
1318   if (adapter() == NULL) {
1319     methodHandle mh(THREAD, this);
1320     link_method(mh, CHECK);
1321   }
<span class="line-added">1322 #endif</span>
1323 }
1324 
<span class="line-modified">1325 address Method::from_compiled_entry_no_trampoline(bool caller_is_c1) const {</span>
1326   CompiledMethod *code = Atomic::load_acquire(&amp;_code);
<span class="line-modified">1327   if (caller_is_c1) {</span>
<span class="line-modified">1328     // C1 - inline type arguments are passed as objects</span>
<span class="line-added">1329     if (code) {</span>
<span class="line-added">1330       return code-&gt;verified_inline_entry_point();</span>
<span class="line-added">1331     } else {</span>
<span class="line-added">1332       return adapter()-&gt;get_c2i_inline_entry();</span>
<span class="line-added">1333     }</span>
1334   } else {
<span class="line-modified">1335     // C2 - inline type arguments may be passed as fields</span>
<span class="line-added">1336     if (code) {</span>
<span class="line-added">1337       return code-&gt;verified_entry_point();</span>
<span class="line-added">1338     } else {</span>
<span class="line-added">1339       return adapter()-&gt;get_c2i_entry();</span>
<span class="line-added">1340     }</span>
1341   }
1342 }
1343 
1344 // The verified_code_entry() must be called when a invoke is resolved
1345 // on this method.
1346 
1347 // It returns the compiled code entry point, after asserting not null.
1348 // This function is called after potential safepoints so that nmethod
1349 // or adapter that it points to is still live and valid.
1350 // This function must not hit a safepoint!
1351 address Method::verified_code_entry() {
1352   debug_only(NoSafepointVerifier nsv;)
1353   assert(_from_compiled_entry != NULL, &quot;must be set&quot;);
1354   return _from_compiled_entry;
1355 }
1356 
<span class="line-added">1357 address Method::verified_inline_code_entry() {</span>
<span class="line-added">1358   debug_only(NoSafepointVerifier nsv;)</span>
<span class="line-added">1359   assert(_from_compiled_inline_entry != NULL, &quot;must be set&quot;);</span>
<span class="line-added">1360   return _from_compiled_inline_entry;</span>
<span class="line-added">1361 }</span>
<span class="line-added">1362 </span>
<span class="line-added">1363 address Method::verified_inline_ro_code_entry() {</span>
<span class="line-added">1364   debug_only(NoSafepointVerifier nsv;)</span>
<span class="line-added">1365   assert(_from_compiled_inline_ro_entry != NULL, &quot;must be set&quot;);</span>
<span class="line-added">1366   return _from_compiled_inline_ro_entry;</span>
<span class="line-added">1367 }</span>
<span class="line-added">1368 </span>
1369 // Check that if an nmethod ref exists, it has a backlink to this or no backlink at all
1370 // (could be racing a deopt).
1371 // Not inline to avoid circular ref.
1372 bool Method::check_code() const {
1373   // cached in a register or local.  There&#39;s a race on the value of the field.
1374   CompiledMethod *code = Atomic::load_acquire(&amp;_code);
1375   return code == NULL || (code-&gt;method() == NULL) || (code-&gt;method() == (Method*)this &amp;&amp; !code-&gt;is_osr_method());
1376 }
1377 
1378 // Install compiled code.  Instantly it can execute.
1379 void Method::set_code(const methodHandle&amp; mh, CompiledMethod *code) {
1380   assert_lock_strong(CompiledMethod_lock);
1381   assert( code, &quot;use clear_code to remove code&quot; );
1382   assert( mh-&gt;check_code(), &quot;&quot; );
1383 
1384   guarantee(mh-&gt;adapter() != NULL, &quot;Adapter blob must already exist!&quot;);
1385 
1386   // These writes must happen in this order, because the interpreter will
1387   // directly jump to from_interpreted_entry which jumps to an i2c adapter
1388   // which jumps to _from_compiled_entry.
1389   mh-&gt;_code = code;             // Assign before allowing compiled code to exec
1390 
1391   int comp_level = code-&gt;comp_level();
1392   // In theory there could be a race here. In practice it is unlikely
1393   // and not worth worrying about.
1394   if (comp_level &gt; mh-&gt;highest_comp_level()) {
1395     mh-&gt;set_highest_comp_level(comp_level);
1396   }
1397 
1398   OrderAccess::storestore();
1399   mh-&gt;_from_compiled_entry = code-&gt;verified_entry_point();
<span class="line-added">1400   mh-&gt;_from_compiled_inline_entry = code-&gt;verified_inline_entry_point();</span>
<span class="line-added">1401   mh-&gt;_from_compiled_inline_ro_entry = code-&gt;verified_inline_ro_entry_point();</span>
1402   OrderAccess::storestore();
1403   // Instantly compiled code can execute.
1404   if (!mh-&gt;is_method_handle_intrinsic())
1405     mh-&gt;_from_interpreted_entry = mh-&gt;get_i2c_entry();
1406 }
1407 
1408 
1409 bool Method::is_overridden_in(Klass* k) const {
1410   InstanceKlass* ik = InstanceKlass::cast(k);
1411 
1412   if (ik-&gt;is_interface()) return false;
1413 
1414   // If method is an interface, we skip it - except if it
1415   // is a miranda method
1416   if (method_holder()-&gt;is_interface()) {
1417     // Check that method is not a miranda method
1418     if (ik-&gt;lookup_method(name(), signature()) == NULL) {
1419       // No implementation exist - so miranda method
1420       return false;
1421     }
</pre>
<hr />
<pre>
2413 void Method::print_on(outputStream* st) const {
2414   ResourceMark rm;
2415   assert(is_method(), &quot;must be method&quot;);
2416   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2417   st-&gt;print_cr(&quot; - this oop:          &quot; INTPTR_FORMAT, p2i(this));
2418   st-&gt;print   (&quot; - method holder:     &quot;); method_holder()-&gt;print_value_on(st); st-&gt;cr();
2419   st-&gt;print   (&quot; - constants:         &quot; INTPTR_FORMAT &quot; &quot;, p2i(constants()));
2420   constants()-&gt;print_value_on(st); st-&gt;cr();
2421   st-&gt;print   (&quot; - access:            0x%x  &quot;, access_flags().as_int()); access_flags().print_on(st); st-&gt;cr();
2422   st-&gt;print   (&quot; - name:              &quot;);    name()-&gt;print_value_on(st); st-&gt;cr();
2423   st-&gt;print   (&quot; - signature:         &quot;);    signature()-&gt;print_value_on(st); st-&gt;cr();
2424   st-&gt;print_cr(&quot; - max stack:         %d&quot;,   max_stack());
2425   st-&gt;print_cr(&quot; - max locals:        %d&quot;,   max_locals());
2426   st-&gt;print_cr(&quot; - size of params:    %d&quot;,   size_of_parameters());
2427   st-&gt;print_cr(&quot; - method size:       %d&quot;,   method_size());
2428   if (intrinsic_id() != vmIntrinsics::_none)
2429     st-&gt;print_cr(&quot; - intrinsic id:      %d %s&quot;, intrinsic_id(), vmIntrinsics::name_at(intrinsic_id()));
2430   if (highest_comp_level() != CompLevel_none)
2431     st-&gt;print_cr(&quot; - highest level:     %d&quot;, highest_comp_level());
2432   st-&gt;print_cr(&quot; - vtable index:      %d&quot;,   _vtable_index);
<span class="line-added">2433   if (valid_itable_index())</span>
<span class="line-added">2434     st-&gt;print_cr(&quot; - itable index:      %d&quot;,   itable_index());</span>
2435   st-&gt;print_cr(&quot; - i2i entry:         &quot; INTPTR_FORMAT, p2i(interpreter_entry()));
2436   st-&gt;print(   &quot; - adapters:          &quot;);
2437   AdapterHandlerEntry* a = ((Method*)this)-&gt;adapter();
2438   if (a == NULL)
2439     st-&gt;print_cr(INTPTR_FORMAT, p2i(a));
2440   else
2441     a-&gt;print_adapter_on(st);
2442   st-&gt;print_cr(&quot; - compiled entry     &quot; INTPTR_FORMAT, p2i(from_compiled_entry()));
2443   st-&gt;print_cr(&quot; - code size:         %d&quot;,   code_size());
2444   if (code_size() != 0) {
2445     st-&gt;print_cr(&quot; - code start:        &quot; INTPTR_FORMAT, p2i(code_base()));
2446     st-&gt;print_cr(&quot; - code end (excl):   &quot; INTPTR_FORMAT, p2i(code_base() + code_size()));
2447   }
2448   if (method_data() != NULL) {
2449     st-&gt;print_cr(&quot; - method data:       &quot; INTPTR_FORMAT, p2i(method_data()));
2450   }
2451   st-&gt;print_cr(&quot; - checked ex length: %d&quot;,   checked_exceptions_length());
2452   if (checked_exceptions_length() &gt; 0) {
2453     CheckedExceptionElement* table = checked_exceptions_start();
2454     st-&gt;print_cr(&quot; - checked ex start:  &quot; INTPTR_FORMAT, p2i(table));
</pre>
<hr />
<pre>
2492     st-&gt;print_cr(&quot; - signature handler: &quot; INTPTR_FORMAT, p2i(signature_handler()));
2493   }
2494 }
2495 
2496 void Method::print_linkage_flags(outputStream* st) {
2497   access_flags().print_on(st);
2498   if (is_default_method()) {
2499     st-&gt;print(&quot;default &quot;);
2500   }
2501   if (is_overpass()) {
2502     st-&gt;print(&quot;overpass &quot;);
2503   }
2504 }
2505 #endif //PRODUCT
2506 
2507 void Method::print_value_on(outputStream* st) const {
2508   assert(is_method(), &quot;must be method&quot;);
2509   st-&gt;print(&quot;%s&quot;, internal_name());
2510   print_address_on(st);
2511   st-&gt;print(&quot; &quot;);
<span class="line-added">2512   if (WizardMode) access_flags().print_on(st);</span>
2513   name()-&gt;print_value_on(st);
2514   st-&gt;print(&quot; &quot;);
2515   signature()-&gt;print_value_on(st);
2516   st-&gt;print(&quot; in &quot;);
2517   method_holder()-&gt;print_value_on(st);
2518   if (WizardMode) st-&gt;print(&quot;#%d&quot;, _vtable_index);
2519   if (WizardMode) st-&gt;print(&quot;[%d,%d]&quot;, size_of_parameters(), max_locals());
2520   if (WizardMode &amp;&amp; code() != NULL) st-&gt;print(&quot; ((nmethod*)%p)&quot;, code());
2521 }
2522 
2523 // LogTouchedMethods and PrintTouchedMethods
2524 
2525 // TouchedMethodRecord -- we can&#39;t use a HashtableEntry&lt;Method*&gt; because
2526 // the Method may be garbage collected. Let&#39;s roll our own hash table.
2527 class TouchedMethodRecord : CHeapObj&lt;mtTracing&gt; {
2528 public:
2529   // It&#39;s OK to store Symbols here because they will NOT be GC&#39;ed if
2530   // LogTouchedMethods is enabled.
2531   TouchedMethodRecord* _next;
2532   Symbol* _class_name;
</pre>
</td>
</tr>
</table>
<center><a href="../memory/metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>