<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &lt;sys/types.h&gt;
  27 
  28 #include &quot;precompiled.hpp&quot;
  29 #include &quot;jvm.h&quot;
  30 #include &quot;asm/assembler.hpp&quot;
  31 #include &quot;asm/assembler.inline.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;gc/shared/cardTable.hpp&quot;
  34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  35 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;compiler/disassembler.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/accessDecorators.hpp&quot;
  42 #include &quot;oops/compressedOops.inline.hpp&quot;
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #ifdef COMPILER1
  52 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  53 #endif
  54 #ifdef COMPILER2
  55 #include &quot;oops/oop.hpp&quot;
  56 #include &quot;opto/compile.hpp&quot;
  57 #include &quot;opto/node.hpp&quot;
  58 #include &quot;opto/output.hpp&quot;
  59 #endif
  60 
  61 #ifdef PRODUCT
  62 #define BLOCK_COMMENT(str) /* nothing */
  63 #else
  64 #define BLOCK_COMMENT(str) block_comment(str)
  65 #endif
  66 #define STOP(str) stop(str);
  67 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  68 
  69 // Patch any kind of instruction; there may be several instructions.
  70 // Return the total length (in bytes) of the instructions.
  71 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  72   int instructions = 1;
  73   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  74   long offset = (target - branch) &gt;&gt; 2;
  75   unsigned insn = *(unsigned*)branch;
  76   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
  77     // Load register (literal)
  78     Instruction_aarch64::spatch(branch, 23, 5, offset);
  79   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
  80     // Unconditional branch (immediate)
  81     Instruction_aarch64::spatch(branch, 25, 0, offset);
  82   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
  83     // Conditional branch (immediate)
  84     Instruction_aarch64::spatch(branch, 23, 5, offset);
  85   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
  86     // Compare &amp; branch (immediate)
  87     Instruction_aarch64::spatch(branch, 23, 5, offset);
  88   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
  89     // Test &amp; branch (immediate)
  90     Instruction_aarch64::spatch(branch, 18, 5, offset);
  91   } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
  92     // PC-rel. addressing
  93     offset = target-branch;
  94     int shift = Instruction_aarch64::extract(insn, 31, 31);
  95     if (shift) {
  96       u_int64_t dest = (u_int64_t)target;
  97       uint64_t pc_page = (uint64_t)branch &gt;&gt; 12;
  98       uint64_t adr_page = (uint64_t)target &gt;&gt; 12;
  99       unsigned offset_lo = dest &amp; 0xfff;
 100       offset = adr_page - pc_page;
 101 
 102       // We handle 4 types of PC relative addressing
 103       //   1 - adrp    Rx, target_page
 104       //       ldr/str Ry, [Rx, #offset_in_page]
 105       //   2 - adrp    Rx, target_page
 106       //       add     Ry, Rx, #offset_in_page
 107       //   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 108       //       movk    Rx, #imm16&lt;&lt;32
 109       //   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 110       // In the first 3 cases we must check that Rx is the same in the adrp and the
 111       // subsequent ldr/str, add or movk instruction. Otherwise we could accidentally end
 112       // up treating a type 4 relocation as a type 1, 2 or 3 just because it happened
 113       // to be followed by a random unrelated ldr/str, add or movk instruction.
 114       //
 115       unsigned insn2 = ((unsigned*)branch)[1];
 116       if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &amp;&amp;
 117                 Instruction_aarch64::extract(insn, 4, 0) ==
 118                         Instruction_aarch64::extract(insn2, 9, 5)) {
 119         // Load/store register (unsigned immediate)
 120         unsigned size = Instruction_aarch64::extract(insn2, 31, 30);
 121         Instruction_aarch64::patch(branch + sizeof (unsigned),
 122                                     21, 10, offset_lo &gt;&gt; size);
 123         guarantee(((dest &gt;&gt; size) &lt;&lt; size) == dest, &quot;misaligned target&quot;);
 124         instructions = 2;
 125       } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &amp;&amp;
 126                 Instruction_aarch64::extract(insn, 4, 0) ==
 127                         Instruction_aarch64::extract(insn2, 4, 0)) {
 128         // add (immediate)
 129         Instruction_aarch64::patch(branch + sizeof (unsigned),
 130                                    21, 10, offset_lo);
 131         instructions = 2;
 132       } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &amp;&amp;
 133                    Instruction_aarch64::extract(insn, 4, 0) ==
 134                      Instruction_aarch64::extract(insn2, 4, 0)) {
 135         // movk #imm16&lt;&lt;32
 136         Instruction_aarch64::patch(branch + 4, 20, 5, (uint64_t)target &gt;&gt; 32);
 137         long dest = ((long)target &amp; 0xffffffffL) | ((long)branch &amp; 0xffff00000000L);
 138         long pc_page = (long)branch &gt;&gt; 12;
 139         long adr_page = (long)dest &gt;&gt; 12;
 140         offset = adr_page - pc_page;
 141         instructions = 2;
 142       }
 143     }
 144     int offset_lo = offset &amp; 3;
 145     offset &gt;&gt;= 2;
 146     Instruction_aarch64::spatch(branch, 23, 5, offset);
 147     Instruction_aarch64::patch(branch, 30, 29, offset_lo);
 148   } else if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100) {
 149     u_int64_t dest = (u_int64_t)target;
 150     // Move wide constant
 151     assert(nativeInstruction_at(branch+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 152     assert(nativeInstruction_at(branch+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 153     Instruction_aarch64::patch(branch, 20, 5, dest &amp; 0xffff);
 154     Instruction_aarch64::patch(branch+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 155     Instruction_aarch64::patch(branch+8, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 156     assert(target_addr_for_insn(branch) == target, &quot;should be&quot;);
 157     instructions = 3;
 158   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 159              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 160     // nothing to do
 161     assert(target == 0, &quot;did not expect to relocate target for polling page load&quot;);
 162   } else {
 163     ShouldNotReachHere();
 164   }
 165   return instructions * NativeInstruction::instruction_size;
 166 }
 167 
 168 int MacroAssembler::patch_oop(address insn_addr, address o) {
 169   int instructions;
 170   unsigned insn = *(unsigned*)insn_addr;
 171   assert(nativeInstruction_at(insn_addr+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 172 
 173   // OOPs are either narrow (32 bits) or wide (48 bits).  We encode
 174   // narrow OOPs by setting the upper 16 bits in the first
 175   // instruction.
 176   if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010101) {
 177     // Move narrow OOP
 178     narrowOop n = CompressedOops::encode((oop)o);
 179     Instruction_aarch64::patch(insn_addr, 20, 5, n &gt;&gt; 16);
 180     Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
 181     instructions = 2;
 182   } else {
 183     // Move wide OOP
 184     assert(nativeInstruction_at(insn_addr+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 185     uintptr_t dest = (uintptr_t)o;
 186     Instruction_aarch64::patch(insn_addr, 20, 5, dest &amp; 0xffff);
 187     Instruction_aarch64::patch(insn_addr+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 188     Instruction_aarch64::patch(insn_addr+8, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 189     instructions = 3;
 190   }
 191   return instructions * NativeInstruction::instruction_size;
 192 }
 193 
 194 int MacroAssembler::patch_narrow_klass(address insn_addr, narrowKlass n) {
 195   // Metatdata pointers are either narrow (32 bits) or wide (48 bits).
 196   // We encode narrow ones by setting the upper 16 bits in the first
 197   // instruction.
 198   NativeInstruction *insn = nativeInstruction_at(insn_addr);
 199   assert(Instruction_aarch64::extract(insn-&gt;encoding(), 31, 21) == 0b11010010101 &amp;&amp;
 200          nativeInstruction_at(insn_addr+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 201 
 202   Instruction_aarch64::patch(insn_addr, 20, 5, n &gt;&gt; 16);
 203   Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
 204   return 2 * NativeInstruction::instruction_size;
 205 }
 206 
 207 address MacroAssembler::target_addr_for_insn(address insn_addr, unsigned insn) {
 208   long offset = 0;
 209   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b011011) == 0b00011000) {
 210     // Load register (literal)
 211     offset = Instruction_aarch64::sextract(insn, 23, 5);
 212     return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 213   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
 214     // Unconditional branch (immediate)
 215     offset = Instruction_aarch64::sextract(insn, 25, 0);
 216   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
 217     // Conditional branch (immediate)
 218     offset = Instruction_aarch64::sextract(insn, 23, 5);
 219   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
 220     // Compare &amp; branch (immediate)
 221     offset = Instruction_aarch64::sextract(insn, 23, 5);
 222    } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
 223     // Test &amp; branch (immediate)
 224     offset = Instruction_aarch64::sextract(insn, 18, 5);
 225   } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
 226     // PC-rel. addressing
 227     offset = Instruction_aarch64::extract(insn, 30, 29);
 228     offset |= Instruction_aarch64::sextract(insn, 23, 5) &lt;&lt; 2;
 229     int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;
 230     if (shift) {
 231       offset &lt;&lt;= shift;
 232       uint64_t target_page = ((uint64_t)insn_addr) + offset;
 233       target_page &amp;= ((uint64_t)-1) &lt;&lt; shift;
 234       // Return the target address for the following sequences
 235       //   1 - adrp    Rx, target_page
 236       //       ldr/str Ry, [Rx, #offset_in_page]
 237       //   2 - adrp    Rx, target_page
 238       //       add     Ry, Rx, #offset_in_page
 239       //   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 240       //       movk    Rx, #imm12&lt;&lt;32
 241       //   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 242       //
 243       // In the first two cases  we check that the register is the same and
 244       // return the target_page + the offset within the page.
 245       // Otherwise we assume it is a page aligned relocation and return
 246       // the target page only.
 247       //
 248       unsigned insn2 = ((unsigned*)insn_addr)[1];
 249       if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &amp;&amp;
 250                 Instruction_aarch64::extract(insn, 4, 0) ==
 251                         Instruction_aarch64::extract(insn2, 9, 5)) {
 252         // Load/store register (unsigned immediate)
 253         unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);
 254         unsigned int size = Instruction_aarch64::extract(insn2, 31, 30);
 255         return address(target_page + (byte_offset &lt;&lt; size));
 256       } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &amp;&amp;
 257                 Instruction_aarch64::extract(insn, 4, 0) ==
 258                         Instruction_aarch64::extract(insn2, 4, 0)) {
 259         // add (immediate)
 260         unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);
 261         return address(target_page + byte_offset);
 262       } else {
 263         if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110  &amp;&amp;
 264                Instruction_aarch64::extract(insn, 4, 0) ==
 265                  Instruction_aarch64::extract(insn2, 4, 0)) {
 266           target_page = (target_page &amp; 0xffffffff) |
 267                          ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) &lt;&lt; 32);
 268         }
 269         return (address)target_page;
 270       }
 271     } else {
 272       ShouldNotReachHere();
 273     }
 274   } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
 275     u_int32_t *insns = (u_int32_t *)insn_addr;
 276     // Move wide constant: movz, movk, movk.  See movptr().
 277     assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 278     assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 279     return address(u_int64_t(Instruction_aarch64::extract(insns[0], 20, 5))
 280                    + (u_int64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)
 281                    + (u_int64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));
 282   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 283              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 284     return 0;
 285   } else {
 286     ShouldNotReachHere();
 287   }
 288   return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 289 }
 290 
 291 void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
 292   ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));
 293   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
 294 }
 295 
 296 // Just like safepoint_poll, but use an acquiring load for thread-
 297 // local polling.
 298 //
 299 // We need an acquire here to ensure that any subsequent load of the
 300 // global SafepointSynchronize::_state flag is ordered after this load
 301 // of the local Thread::_polling page.  We don&#39;t want this poll to
 302 // return false (i.e. not safepointing) and a later poll of the global
 303 // SafepointSynchronize::_state spuriously to return true.
 304 //
 305 // This is to avoid a race when we&#39;re in a native-&gt;Java transition
 306 // racing the code which wakes up from a safepoint.
 307 //
 308 void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
 309   lea(rscratch1, Address(rthread, Thread::polling_page_offset()));
 310   ldar(rscratch1, rscratch1);
 311   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
 312 }
 313 
 314 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 315   // we must set sp to zero to clear frame
 316   str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
 317 
 318   // must clear fp, so that compiled frames are not confused; it is
 319   // possible that we need it only for debugging
 320   if (clear_fp) {
 321     str(zr, Address(rthread, JavaThread::last_Java_fp_offset()));
 322   }
 323 
 324   // Always clear the pc because it could have been set by make_walkable()
 325   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 326 }
 327 
 328 // Calls to C land
 329 //
 330 // When entering C land, the rfp, &amp; resp of the last Java frame have to be recorded
 331 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
 332 // has to be reset to 0. This is required to allow proper stack traversal.
 333 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 334                                          Register last_java_fp,
 335                                          Register last_java_pc,
 336                                          Register scratch) {
 337 
 338   if (last_java_pc-&gt;is_valid()) {
 339       str(last_java_pc, Address(rthread,
 340                                 JavaThread::frame_anchor_offset()
 341                                 + JavaFrameAnchor::last_Java_pc_offset()));
 342     }
 343 
 344   // determine last_java_sp register
 345   if (last_java_sp == sp) {
 346     mov(scratch, sp);
 347     last_java_sp = scratch;
 348   } else if (!last_java_sp-&gt;is_valid()) {
 349     last_java_sp = esp;
 350   }
 351 
 352   str(last_java_sp, Address(rthread, JavaThread::last_Java_sp_offset()));
 353 
 354   // last_java_fp is optional
 355   if (last_java_fp-&gt;is_valid()) {
 356     str(last_java_fp, Address(rthread, JavaThread::last_Java_fp_offset()));
 357   }
 358 }
 359 
 360 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 361                                          Register last_java_fp,
 362                                          address  last_java_pc,
 363                                          Register scratch) {
 364   assert(last_java_pc != NULL, &quot;must provide a valid PC&quot;);
 365 
 366   adr(scratch, last_java_pc);
 367   str(scratch, Address(rthread,
 368                        JavaThread::frame_anchor_offset()
 369                        + JavaFrameAnchor::last_Java_pc_offset()));
 370 
 371   set_last_Java_frame(last_java_sp, last_java_fp, noreg, scratch);
 372 }
 373 
 374 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 375                                          Register last_java_fp,
 376                                          Label &amp;L,
 377                                          Register scratch) {
 378   if (L.is_bound()) {
 379     set_last_Java_frame(last_java_sp, last_java_fp, target(L), scratch);
 380   } else {
 381     InstructionMark im(this);
 382     L.add_patch_at(code(), locator());
 383     set_last_Java_frame(last_java_sp, last_java_fp, pc() /* Patched later */, scratch);
 384   }
 385 }
 386 
 387 void MacroAssembler::far_call(Address entry, CodeBuffer *cbuf, Register tmp) {
 388   assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
 389   assert(CodeCache::find_blob(entry.target()) != NULL,
 390          &quot;destination of far call not found in code cache&quot;);
 391   if (far_branches()) {
 392     unsigned long offset;
 393     // We can use ADRP here because we know that the total size of
 394     // the code cache cannot exceed 2Gb.
 395     adrp(tmp, entry, offset);
 396     add(tmp, tmp, offset);
 397     if (cbuf) cbuf-&gt;set_insts_mark();
 398     blr(tmp);
 399   } else {
 400     if (cbuf) cbuf-&gt;set_insts_mark();
 401     bl(entry);
 402   }
 403 }
 404 
 405 void MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {
 406   assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
 407   assert(CodeCache::find_blob(entry.target()) != NULL,
 408          &quot;destination of far call not found in code cache&quot;);
 409   if (far_branches()) {
 410     unsigned long offset;
 411     // We can use ADRP here because we know that the total size of
 412     // the code cache cannot exceed 2Gb.
 413     adrp(tmp, entry, offset);
 414     add(tmp, tmp, offset);
 415     if (cbuf) cbuf-&gt;set_insts_mark();
 416     br(tmp);
 417   } else {
 418     if (cbuf) cbuf-&gt;set_insts_mark();
 419     b(entry);
 420   }
 421 }
 422 
 423 void MacroAssembler::reserved_stack_check() {
 424     // testing if reserved zone needs to be enabled
 425     Label no_reserved_zone_enabling;
 426 
 427     ldr(rscratch1, Address(rthread, JavaThread::reserved_stack_activation_offset()));
 428     cmp(sp, rscratch1);
 429     br(Assembler::LO, no_reserved_zone_enabling);
 430 
 431     enter();   // LR and FP are live.
 432     lea(rscratch1, CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone));
 433     mov(c_rarg0, rthread);
 434     blr(rscratch1);
 435     leave();
 436 
 437     // We have already removed our own frame.
 438     // throw_delayed_StackOverflowError will think that it&#39;s been
 439     // called by our caller.
 440     lea(rscratch1, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
 441     br(rscratch1);
 442     should_not_reach_here();
 443 
 444     bind(no_reserved_zone_enabling);
 445 }
 446 
 447 int MacroAssembler::biased_locking_enter(Register lock_reg,
 448                                          Register obj_reg,
 449                                          Register swap_reg,
 450                                          Register tmp_reg,
 451                                          bool swap_reg_contains_mark,
 452                                          Label&amp; done,
 453                                          Label* slow_case,
 454                                          BiasedLockingCounters* counters) {
 455   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 456   assert_different_registers(lock_reg, obj_reg, swap_reg);
 457 
 458   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL)
 459     counters = BiasedLocking::counters();
 460 
 461   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);
 462   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
 463   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
 464   Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());
 465   Address saved_mark_addr(lock_reg, 0);
 466 
 467   // Biased locking
 468   // See whether the lock is currently biased toward our thread and
 469   // whether the epoch is still valid
 470   // Note that the runtime guarantees sufficient alignment of JavaThread
 471   // pointers to allow age to be placed into low bits
 472   // First check to see whether biasing is even enabled for this object
 473   Label cas_label;
 474   int null_check_offset = -1;
 475   if (!swap_reg_contains_mark) {
 476     null_check_offset = offset();
 477     ldr(swap_reg, mark_addr);
 478   }
 479   andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);
 480   cmp(tmp_reg, (u1)markWord::biased_lock_pattern);
 481   br(Assembler::NE, cas_label);
 482   // The bias pattern is present in the object&#39;s header. Need to check
 483   // whether the bias owner and the epoch are both still current.
 484   load_prototype_header(tmp_reg, obj_reg);
 485   orr(tmp_reg, tmp_reg, rthread);
 486   eor(tmp_reg, swap_reg, tmp_reg);
 487   andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));
 488   if (counters != NULL) {
 489     Label around;
 490     cbnz(tmp_reg, around);
 491     atomic_incw(Address((address)counters-&gt;biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);
 492     b(done);
 493     bind(around);
 494   } else {
 495     cbz(tmp_reg, done);
 496   }
 497 
 498   Label try_revoke_bias;
 499   Label try_rebias;
 500 
 501   // At this point we know that the header has the bias pattern and
 502   // that we are not the bias owner in the current epoch. We need to
 503   // figure out more details about the state of the header in order to
 504   // know what operations can be legally performed on the object&#39;s
 505   // header.
 506 
 507   // If the low three bits in the xor result aren&#39;t clear, that means
 508   // the prototype header is no longer biased and we have to revoke
 509   // the bias on this object.
 510   andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);
 511   cbnz(rscratch1, try_revoke_bias);
 512 
 513   // Biasing is still enabled for this data type. See whether the
 514   // epoch of the current bias is still valid, meaning that the epoch
 515   // bits of the mark word are equal to the epoch bits of the
 516   // prototype header. (Note that the prototype header&#39;s epoch bits
 517   // only change at a safepoint.) If not, attempt to rebias the object
 518   // toward the current thread. Note that we must be absolutely sure
 519   // that the current epoch is invalid in order to do this because
 520   // otherwise the manipulations it performs on the mark word are
 521   // illegal.
 522   andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);
 523   cbnz(rscratch1, try_rebias);
 524 
 525   // The epoch of the current bias is still valid but we know nothing
 526   // about the owner; it might be set or it might be clear. Try to
 527   // acquire the bias of the object using an atomic operation. If this
 528   // fails we will go in to the runtime to revoke the object&#39;s bias.
 529   // Note that we first construct the presumed unbiased header so we
 530   // don&#39;t accidentally blow away another thread&#39;s valid bias.
 531   {
 532     Label here;
 533     mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
 534     andr(swap_reg, swap_reg, rscratch1);
 535     orr(tmp_reg, swap_reg, rthread);
 536     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);
 537     // If the biasing toward our thread failed, this means that
 538     // another thread succeeded in biasing it toward itself and we
 539     // need to revoke that bias. The revocation will occur in the
 540     // interpreter runtime in the slow case.
 541     bind(here);
 542     if (counters != NULL) {
 543       atomic_incw(Address((address)counters-&gt;anonymously_biased_lock_entry_count_addr()),
 544                   tmp_reg, rscratch1, rscratch2);
 545     }
 546   }
 547   b(done);
 548 
 549   bind(try_rebias);
 550   // At this point we know the epoch has expired, meaning that the
 551   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
 552   // circumstances _only_, we are allowed to use the current header&#39;s
 553   // value as the comparison value when doing the cas to acquire the
 554   // bias in the current epoch. In other words, we allow transfer of
 555   // the bias from one thread to another directly in this situation.
 556   //
 557   // FIXME: due to a lack of registers we currently blow away the age
 558   // bits in this situation. Should attempt to preserve them.
 559   {
 560     Label here;
 561     load_prototype_header(tmp_reg, obj_reg);
 562     orr(tmp_reg, rthread, tmp_reg);
 563     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);
 564     // If the biasing toward our thread failed, then another thread
 565     // succeeded in biasing it toward itself and we need to revoke that
 566     // bias. The revocation will occur in the runtime in the slow case.
 567     bind(here);
 568     if (counters != NULL) {
 569       atomic_incw(Address((address)counters-&gt;rebiased_lock_entry_count_addr()),
 570                   tmp_reg, rscratch1, rscratch2);
 571     }
 572   }
 573   b(done);
 574 
 575   bind(try_revoke_bias);
 576   // The prototype mark in the klass doesn&#39;t have the bias bit set any
 577   // more, indicating that objects of this data type are not supposed
 578   // to be biased any more. We are going to try to reset the mark of
 579   // this object to the prototype value and fall through to the
 580   // CAS-based locking scheme. Note that if our CAS fails, it means
 581   // that another thread raced us for the privilege of revoking the
 582   // bias of this particular object, so it&#39;s okay to continue in the
 583   // normal locking code.
 584   //
 585   // FIXME: due to a lack of registers we currently blow away the age
 586   // bits in this situation. Should attempt to preserve them.
 587   {
 588     Label here, nope;
 589     load_prototype_header(tmp_reg, obj_reg);
 590     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &amp;nope);
 591     bind(here);
 592 
 593     // Fall through to the normal CAS-based lock, because no matter what
 594     // the result of the above CAS, some thread must have succeeded in
 595     // removing the bias bit from the object&#39;s header.
 596     if (counters != NULL) {
 597       atomic_incw(Address((address)counters-&gt;revoked_lock_entry_count_addr()), tmp_reg,
 598                   rscratch1, rscratch2);
 599     }
 600     bind(nope);
 601   }
 602 
 603   bind(cas_label);
 604 
 605   return null_check_offset;
 606 }
 607 
 608 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 609   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 610 
 611   // Check for biased locking unlock case, which is a no-op
 612   // Note: we do not have to check the thread ID for two reasons.
 613   // First, the interpreter checks for IllegalMonitorStateException at
 614   // a higher level. Second, if the bias was revoked while we held the
 615   // lock, the object could not be rebiased toward another thread, so
 616   // the bias bit would be clear.
 617   ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 618   andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);
 619   cmp(temp_reg, (u1)markWord::biased_lock_pattern);
 620   br(Assembler::EQ, done);
 621 }
 622 
 623 static void pass_arg0(MacroAssembler* masm, Register arg) {
 624   if (c_rarg0 != arg ) {
 625     masm-&gt;mov(c_rarg0, arg);
 626   }
 627 }
 628 
 629 static void pass_arg1(MacroAssembler* masm, Register arg) {
 630   if (c_rarg1 != arg ) {
 631     masm-&gt;mov(c_rarg1, arg);
 632   }
 633 }
 634 
 635 static void pass_arg2(MacroAssembler* masm, Register arg) {
 636   if (c_rarg2 != arg ) {
 637     masm-&gt;mov(c_rarg2, arg);
 638   }
 639 }
 640 
 641 static void pass_arg3(MacroAssembler* masm, Register arg) {
 642   if (c_rarg3 != arg ) {
 643     masm-&gt;mov(c_rarg3, arg);
 644   }
 645 }
 646 
 647 void MacroAssembler::call_VM_base(Register oop_result,
 648                                   Register java_thread,
 649                                   Register last_java_sp,
 650                                   address  entry_point,
 651                                   int      number_of_arguments,
 652                                   bool     check_exceptions) {
 653    // determine java_thread register
 654   if (!java_thread-&gt;is_valid()) {
 655     java_thread = rthread;
 656   }
 657 
 658   // determine last_java_sp register
 659   if (!last_java_sp-&gt;is_valid()) {
 660     last_java_sp = esp;
 661   }
 662 
 663   // debugging support
 664   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 665   assert(java_thread == rthread, &quot;unexpected register&quot;);
 666 #ifdef ASSERT
 667   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
 668   // if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);
 669 #endif // ASSERT
 670 
 671   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
 672   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
 673 
 674   // push java thread (becomes first argument of C function)
 675 
 676   mov(c_rarg0, java_thread);
 677 
 678   // set last Java frame before call
 679   assert(last_java_sp != rfp, &quot;can&#39;t use rfp&quot;);
 680 
 681   Label l;
 682   set_last_Java_frame(last_java_sp, rfp, l, rscratch1);
 683 
 684   // do the call, remove parameters
 685   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments, &amp;l);
 686 
 687   // reset last Java frame
 688   // Only interpreter should have to clear fp
 689   reset_last_Java_frame(true);
 690 
 691    // C++ interp handles this in the interpreter
 692   check_and_handle_popframe(java_thread);
 693   check_and_handle_earlyret(java_thread);
 694 
 695   if (check_exceptions) {
 696     // check for pending exceptions (java_thread is set upon return)
 697     ldr(rscratch1, Address(java_thread, in_bytes(Thread::pending_exception_offset())));
 698     Label ok;
 699     cbz(rscratch1, ok);
 700     lea(rscratch1, RuntimeAddress(StubRoutines::forward_exception_entry()));
 701     br(rscratch1);
 702     bind(ok);
 703   }
 704 
 705   // get oop result if there is one and reset the value in the thread
 706   if (oop_result-&gt;is_valid()) {
 707     get_vm_result(oop_result, java_thread);
 708   }
 709 }
 710 
 711 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 712   call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);
 713 }
 714 
 715 // Maybe emit a call via a trampoline.  If the code cache is small
 716 // trampolines won&#39;t be emitted.
 717 
 718 address MacroAssembler::trampoline_call(Address entry, CodeBuffer *cbuf) {
 719   assert(JavaThread::current()-&gt;is_Compiler_thread(), &quot;just checking&quot;);
 720   assert(entry.rspec().type() == relocInfo::runtime_call_type
 721          || entry.rspec().type() == relocInfo::opt_virtual_call_type
 722          || entry.rspec().type() == relocInfo::static_call_type
 723          || entry.rspec().type() == relocInfo::virtual_call_type, &quot;wrong reloc type&quot;);
 724 
 725   // We need a trampoline if branches are far.
 726   if (far_branches()) {
 727     bool in_scratch_emit_size = false;
 728 #ifdef COMPILER2
 729     // We don&#39;t want to emit a trampoline if C2 is generating dummy
 730     // code during its branch shortening phase.
 731     CompileTask* task = ciEnv::current()-&gt;task();
 732     in_scratch_emit_size =
 733       (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
 734        Compile::current()-&gt;output()-&gt;in_scratch_emit_size());
 735 #endif
 736     if (!in_scratch_emit_size) {
 737       address stub = emit_trampoline_stub(offset(), entry.target());
 738       if (stub == NULL) {
 739         return NULL; // CodeCache is full
 740       }
 741     }
 742   }
 743 
 744   if (cbuf) cbuf-&gt;set_insts_mark();
 745   relocate(entry.rspec());
 746   if (!far_branches()) {
 747     bl(entry.target());
 748   } else {
 749     bl(pc());
 750   }
 751   // just need to return a non-null address
 752   return pc();
 753 }
 754 
 755 
 756 // Emit a trampoline stub for a call to a target which is too far away.
 757 //
 758 // code sequences:
 759 //
 760 // call-site:
 761 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 762 //
 763 // Related trampoline stub for this call site in the stub section:
 764 //   load the call target from the constant pool
 765 //   branch (LR still points to the call site above)
 766 
 767 address MacroAssembler::emit_trampoline_stub(int insts_call_instruction_offset,
 768                                              address dest) {
 769   // Max stub size: alignment nop, TrampolineStub.
 770   address stub = start_a_stub(NativeInstruction::instruction_size
 771                    + NativeCallTrampolineStub::instruction_size);
 772   if (stub == NULL) {
 773     return NULL;  // CodeBuffer::expand failed
 774   }
 775 
 776   // Create a trampoline stub relocation which relates this trampoline stub
 777   // with the call instruction at insts_call_instruction_offset in the
 778   // instructions code-section.
 779   align(wordSize);
 780   relocate(trampoline_stub_Relocation::spec(code()-&gt;insts()-&gt;start()
 781                                             + insts_call_instruction_offset));
 782   const int stub_start_offset = offset();
 783 
 784   // Now, create the trampoline stub&#39;s code:
 785   // - load the call
 786   // - call
 787   Label target;
 788   ldr(rscratch1, target);
 789   br(rscratch1);
 790   bind(target);
 791   assert(offset() - stub_start_offset == NativeCallTrampolineStub::data_offset,
 792          &quot;should be&quot;);
 793   emit_int64((int64_t)dest);
 794 
 795   const address stub_start_addr = addr_at(stub_start_offset);
 796 
 797   assert(is_NativeCallTrampolineStub_at(stub_start_addr), &quot;doesn&#39;t look like a trampoline&quot;);
 798 
 799   end_a_stub();
 800   return stub_start_addr;
 801 }
 802 
 803 void MacroAssembler::emit_static_call_stub() {
 804   // CompiledDirectStaticCall::set_to_interpreted knows the
 805   // exact layout of this stub.
 806 
 807   isb();
 808   mov_metadata(rmethod, (Metadata*)NULL);
 809 
 810   // Jump to the entry point of the i2c stub.
 811   movptr(rscratch1, 0);
 812   br(rscratch1);
 813 }
 814 
 815 void MacroAssembler::c2bool(Register x) {
 816   // implements x == 0 ? 0 : 1
 817   // note: must only look at least-significant byte of x
 818   //       since C-style booleans are stored in one byte
 819   //       only! (was bug)
 820   tst(x, 0xff);
 821   cset(x, Assembler::NE);
 822 }
 823 
 824 address MacroAssembler::ic_call(address entry, jint method_index) {
 825   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
 826   // address const_ptr = long_constant((jlong)Universe::non_oop_word());
 827   // unsigned long offset;
 828   // ldr_constant(rscratch2, const_ptr);
 829   movptr(rscratch2, (uintptr_t)Universe::non_oop_word());
 830   return trampoline_call(Address(entry, rh));
 831 }
 832 
 833 // Implementation of call_VM versions
 834 
 835 void MacroAssembler::call_VM(Register oop_result,
 836                              address entry_point,
 837                              bool check_exceptions) {
 838   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
 839 }
 840 
 841 void MacroAssembler::call_VM(Register oop_result,
 842                              address entry_point,
 843                              Register arg_1,
 844                              bool check_exceptions) {
 845   pass_arg1(this, arg_1);
 846   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
 847 }
 848 
 849 void MacroAssembler::call_VM(Register oop_result,
 850                              address entry_point,
 851                              Register arg_1,
 852                              Register arg_2,
 853                              bool check_exceptions) {
 854   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 855   pass_arg2(this, arg_2);
 856   pass_arg1(this, arg_1);
 857   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
 858 }
 859 
 860 void MacroAssembler::call_VM(Register oop_result,
 861                              address entry_point,
 862                              Register arg_1,
 863                              Register arg_2,
 864                              Register arg_3,
 865                              bool check_exceptions) {
 866   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
 867   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
 868   pass_arg3(this, arg_3);
 869 
 870   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 871   pass_arg2(this, arg_2);
 872 
 873   pass_arg1(this, arg_1);
 874   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
 875 }
 876 
 877 void MacroAssembler::call_VM(Register oop_result,
 878                              Register last_java_sp,
 879                              address entry_point,
 880                              int number_of_arguments,
 881                              bool check_exceptions) {
 882   call_VM_base(oop_result, rthread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 883 }
 884 
 885 void MacroAssembler::call_VM(Register oop_result,
 886                              Register last_java_sp,
 887                              address entry_point,
 888                              Register arg_1,
 889                              bool check_exceptions) {
 890   pass_arg1(this, arg_1);
 891   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 892 }
 893 
 894 void MacroAssembler::call_VM(Register oop_result,
 895                              Register last_java_sp,
 896                              address entry_point,
 897                              Register arg_1,
 898                              Register arg_2,
 899                              bool check_exceptions) {
 900 
 901   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 902   pass_arg2(this, arg_2);
 903   pass_arg1(this, arg_1);
 904   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 905 }
 906 
 907 void MacroAssembler::call_VM(Register oop_result,
 908                              Register last_java_sp,
 909                              address entry_point,
 910                              Register arg_1,
 911                              Register arg_2,
 912                              Register arg_3,
 913                              bool check_exceptions) {
 914   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
 915   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
 916   pass_arg3(this, arg_3);
 917   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 918   pass_arg2(this, arg_2);
 919   pass_arg1(this, arg_1);
 920   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 921 }
 922 
 923 
 924 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
 925   ldr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
 926   str(zr, Address(java_thread, JavaThread::vm_result_offset()));
 927   verify_oop(oop_result, &quot;broken oop in call_VM_base&quot;);
 928 }
 929 
 930 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
 931   ldr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
 932   str(zr, Address(java_thread, JavaThread::vm_result_2_offset()));
 933 }
 934 
 935 void MacroAssembler::align(int modulus) {
 936   while (offset() % modulus != 0) nop();
 937 }
 938 
 939 // these are no-ops overridden by InterpreterMacroAssembler
 940 
 941 void MacroAssembler::check_and_handle_earlyret(Register java_thread) { }
 942 
 943 void MacroAssembler::check_and_handle_popframe(Register java_thread) { }
 944 
 945 
 946 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
 947                                                       Register tmp,
 948                                                       int offset) {
 949   intptr_t value = *delayed_value_addr;
 950   if (value != 0)
 951     return RegisterOrConstant(value + offset);
 952 
 953   // load indirectly to solve generation ordering problem
 954   ldr(tmp, ExternalAddress((address) delayed_value_addr));
 955 
 956   if (offset != 0)
 957     add(tmp, tmp, offset);
 958 
 959   return RegisterOrConstant(tmp);
 960 }
 961 
 962 // Look up the method for a megamorphic invokeinterface call.
 963 // The target method is determined by &lt;intf_klass, itable_index&gt;.
 964 // The receiver klass is in recv_klass.
 965 // On success, the result will be in method_result, and execution falls through.
 966 // On failure, execution transfers to the given label.
 967 void MacroAssembler::lookup_interface_method(Register recv_klass,
 968                                              Register intf_klass,
 969                                              RegisterOrConstant itable_index,
 970                                              Register method_result,
 971                                              Register scan_temp,
 972                                              Label&amp; L_no_such_interface,
 973                          bool return_method) {
 974   assert_different_registers(recv_klass, intf_klass, scan_temp);
 975   assert_different_registers(method_result, intf_klass, scan_temp);
 976   assert(recv_klass != method_result || !return_method,
 977      &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
 978   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
 979          &quot;caller must use same register for non-constant itable index as for method&quot;);
 980 
 981   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
 982   int vtable_base = in_bytes(Klass::vtable_start_offset());
 983   int itentry_off = itableMethodEntry::method_offset_in_bytes();
 984   int scan_step   = itableOffsetEntry::size() * wordSize;
 985   int vte_size    = vtableEntry::size_in_bytes();
 986   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
 987 
 988   ldrw(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
 989 
 990   // %%% Could store the aligned, prescaled offset in the klassoop.
 991   // lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
 992   lea(scan_temp, Address(recv_klass, scan_temp, Address::lsl(3)));
 993   add(scan_temp, scan_temp, vtable_base);
 994 
 995   if (return_method) {
 996     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
 997     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
 998     // lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
 999     lea(recv_klass, Address(recv_klass, itable_index, Address::lsl(3)));
1000     if (itentry_off)
1001       add(recv_klass, recv_klass, itentry_off);
1002   }
1003 
1004   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
1005   //   if (scan-&gt;interface() == intf) {
1006   //     result = (klass + scan-&gt;offset() + itable_index);
1007   //   }
1008   // }
1009   Label search, found_method;
1010 
1011   for (int peel = 1; peel &gt;= 0; peel--) {
1012     ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
1013     cmp(intf_klass, method_result);
1014 
1015     if (peel) {
1016       br(Assembler::EQ, found_method);
1017     } else {
1018       br(Assembler::NE, search);
1019       // (invert the test to fall through to found_method...)
1020     }
1021 
1022     if (!peel)  break;
1023 
1024     bind(search);
1025 
1026     // Check that the previous entry is non-null.  A null entry means that
1027     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
1028     // same as when the caller was compiled.
1029     cbz(method_result, L_no_such_interface);
1030     add(scan_temp, scan_temp, scan_step);
1031   }
1032 
1033   bind(found_method);
1034 
1035   // Got a hit.
1036   if (return_method) {
1037     ldrw(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
1038     ldr(method_result, Address(recv_klass, scan_temp, Address::uxtw(0)));
1039   }
1040 }
1041 
1042 // virtual method calling
1043 void MacroAssembler::lookup_virtual_method(Register recv_klass,
1044                                            RegisterOrConstant vtable_index,
1045                                            Register method_result) {
1046   const int base = in_bytes(Klass::vtable_start_offset());
1047   assert(vtableEntry::size() * wordSize == 8,
1048          &quot;adjust the scaling in the code below&quot;);
1049   int vtable_offset_in_bytes = base + vtableEntry::method_offset_in_bytes();
1050 
1051   if (vtable_index.is_register()) {
1052     lea(method_result, Address(recv_klass,
1053                                vtable_index.as_register(),
1054                                Address::lsl(LogBytesPerWord)));
1055     ldr(method_result, Address(method_result, vtable_offset_in_bytes));
1056   } else {
1057     vtable_offset_in_bytes += vtable_index.as_constant() * wordSize;
1058     ldr(method_result,
1059         form_address(rscratch1, recv_klass, vtable_offset_in_bytes, 0));
1060   }
1061 }
1062 
1063 void MacroAssembler::check_klass_subtype(Register sub_klass,
1064                            Register super_klass,
1065                            Register temp_reg,
1066                            Label&amp; L_success) {
1067   Label L_failure;
1068   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
1069   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
1070   bind(L_failure);
1071 }
1072 
1073 
1074 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
1075                                                    Register super_klass,
1076                                                    Register temp_reg,
1077                                                    Label* L_success,
1078                                                    Label* L_failure,
1079                                                    Label* L_slow_path,
1080                                         RegisterOrConstant super_check_offset) {
1081   assert_different_registers(sub_klass, super_klass, temp_reg);
1082   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
1083   if (super_check_offset.is_register()) {
1084     assert_different_registers(sub_klass, super_klass,
1085                                super_check_offset.as_register());
1086   } else if (must_load_sco) {
1087     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
1088   }
1089 
1090   Label L_fallthrough;
1091   int label_nulls = 0;
1092   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
1093   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
1094   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
1095   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
1096 
1097   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
1098   int sco_offset = in_bytes(Klass::super_check_offset_offset());
1099   Address super_check_offset_addr(super_klass, sco_offset);
1100 
1101   // Hacked jmp, which may only be used just before L_fallthrough.
1102 #define final_jmp(label)                                                \
1103   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
1104   else                            b(label)                /*omit semi*/
1105 
1106   // If the pointers are equal, we are done (e.g., String[] elements).
1107   // This self-check enables sharing of secondary supertype arrays among
1108   // non-primary types such as array-of-interface.  Otherwise, each such
1109   // type would need its own customized SSA.
1110   // We move this check to the front of the fast path because many
1111   // type checks are in fact trivially successful in this manner,
1112   // so we get a nicely predicted branch right at the start of the check.
1113   cmp(sub_klass, super_klass);
1114   br(Assembler::EQ, *L_success);
1115 
1116   // Check the supertype display:
1117   if (must_load_sco) {
1118     ldrw(temp_reg, super_check_offset_addr);
1119     super_check_offset = RegisterOrConstant(temp_reg);
1120   }
1121   Address super_check_addr(sub_klass, super_check_offset);
1122   ldr(rscratch1, super_check_addr);
1123   cmp(super_klass, rscratch1); // load displayed supertype
1124 
1125   // This check has worked decisively for primary supers.
1126   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
1127   // (Secondary supers are interfaces and very deeply nested subtypes.)
1128   // This works in the same check above because of a tricky aliasing
1129   // between the super_cache and the primary super display elements.
1130   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
1131   // Note that the cache is updated below if it does not help us find
1132   // what we need immediately.
1133   // So if it was a primary super, we can just fail immediately.
1134   // Otherwise, it&#39;s the slow path for us (no success at this point).
1135 
1136   if (super_check_offset.is_register()) {
1137     br(Assembler::EQ, *L_success);
1138     subs(zr, super_check_offset.as_register(), sc_offset);
1139     if (L_failure == &amp;L_fallthrough) {
1140       br(Assembler::EQ, *L_slow_path);
1141     } else {
1142       br(Assembler::NE, *L_failure);
1143       final_jmp(*L_slow_path);
1144     }
1145   } else if (super_check_offset.as_constant() == sc_offset) {
1146     // Need a slow path; fast failure is impossible.
1147     if (L_slow_path == &amp;L_fallthrough) {
1148       br(Assembler::EQ, *L_success);
1149     } else {
1150       br(Assembler::NE, *L_slow_path);
1151       final_jmp(*L_success);
1152     }
1153   } else {
1154     // No slow path; it&#39;s a fast decision.
1155     if (L_failure == &amp;L_fallthrough) {
1156       br(Assembler::EQ, *L_success);
1157     } else {
1158       br(Assembler::NE, *L_failure);
1159       final_jmp(*L_success);
1160     }
1161   }
1162 
1163   bind(L_fallthrough);
1164 
1165 #undef final_jmp
1166 }
1167 
1168 // These two are taken from x86, but they look generally useful
1169 
1170 // scans count pointer sized words at [addr] for occurence of value,
1171 // generic
1172 void MacroAssembler::repne_scan(Register addr, Register value, Register count,
1173                                 Register scratch) {
1174   Label Lloop, Lexit;
1175   cbz(count, Lexit);
1176   bind(Lloop);
1177   ldr(scratch, post(addr, wordSize));
1178   cmp(value, scratch);
1179   br(EQ, Lexit);
1180   sub(count, count, 1);
1181   cbnz(count, Lloop);
1182   bind(Lexit);
1183 }
1184 
1185 // scans count 4 byte words at [addr] for occurence of value,
1186 // generic
1187 void MacroAssembler::repne_scanw(Register addr, Register value, Register count,
1188                                 Register scratch) {
1189   Label Lloop, Lexit;
1190   cbz(count, Lexit);
1191   bind(Lloop);
1192   ldrw(scratch, post(addr, wordSize));
1193   cmpw(value, scratch);
1194   br(EQ, Lexit);
1195   sub(count, count, 1);
1196   cbnz(count, Lloop);
1197   bind(Lexit);
1198 }
1199 
1200 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
1201                                                    Register super_klass,
1202                                                    Register temp_reg,
1203                                                    Register temp2_reg,
1204                                                    Label* L_success,
1205                                                    Label* L_failure,
1206                                                    bool set_cond_codes) {
1207   assert_different_registers(sub_klass, super_klass, temp_reg);
1208   if (temp2_reg != noreg)
1209     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, rscratch1);
1210 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
1211 
1212   Label L_fallthrough;
1213   int label_nulls = 0;
1214   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
1215   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
1216   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
1217 
1218   // a couple of useful fields in sub_klass:
1219   int ss_offset = in_bytes(Klass::secondary_supers_offset());
1220   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
1221   Address secondary_supers_addr(sub_klass, ss_offset);
1222   Address super_cache_addr(     sub_klass, sc_offset);
1223 
1224   BLOCK_COMMENT(&quot;check_klass_subtype_slow_path&quot;);
1225 
1226   // Do a linear scan of the secondary super-klass chain.
1227   // This code is rarely used, so simplicity is a virtue here.
1228   // The repne_scan instruction uses fixed registers, which we must spill.
1229   // Don&#39;t worry too much about pre-existing connections with the input regs.
1230 
1231   assert(sub_klass != r0, &quot;killed reg&quot;); // killed by mov(r0, super)
1232   assert(sub_klass != r2, &quot;killed reg&quot;); // killed by lea(r2, &amp;pst_counter)
1233 
1234   RegSet pushed_registers;
1235   if (!IS_A_TEMP(r2))    pushed_registers += r2;
1236   if (!IS_A_TEMP(r5))    pushed_registers += r5;
1237 
1238   if (super_klass != r0 || UseCompressedOops) {
1239     if (!IS_A_TEMP(r0))   pushed_registers += r0;
1240   }
1241 
1242   push(pushed_registers, sp);
1243 
1244   // Get super_klass value into r0 (even if it was in r5 or r2).
1245   if (super_klass != r0) {
1246     mov(r0, super_klass);
1247   }
1248 
1249 #ifndef PRODUCT
1250   mov(rscratch2, (address)&amp;SharedRuntime::_partial_subtype_ctr);
1251   Address pst_counter_addr(rscratch2);
1252   ldr(rscratch1, pst_counter_addr);
1253   add(rscratch1, rscratch1, 1);
1254   str(rscratch1, pst_counter_addr);
1255 #endif //PRODUCT
1256 
1257   // We will consult the secondary-super array.
1258   ldr(r5, secondary_supers_addr);
1259   // Load the array length.
1260   ldrw(r2, Address(r5, Array&lt;Klass*&gt;::length_offset_in_bytes()));
1261   // Skip to start of data.
1262   add(r5, r5, Array&lt;Klass*&gt;::base_offset_in_bytes());
1263 
1264   cmp(sp, zr); // Clear Z flag; SP is never zero
1265   // Scan R2 words at [R5] for an occurrence of R0.
1266   // Set NZ/Z based on last compare.
1267   repne_scan(r5, r0, r2, rscratch1);
1268 
1269   // Unspill the temp. registers:
1270   pop(pushed_registers, sp);
1271 
1272   br(Assembler::NE, *L_failure);
1273 
1274   // Success.  Cache the super we found and proceed in triumph.
1275   str(super_klass, super_cache_addr);
1276 
1277   if (L_success != &amp;L_fallthrough) {
1278     b(*L_success);
1279   }
1280 
1281 #undef IS_A_TEMP
1282 
1283   bind(L_fallthrough);
1284 }
1285 
1286 void MacroAssembler::clinit_barrier(Register klass, Register scratch, Label* L_fast_path, Label* L_slow_path) {
1287   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
1288   assert_different_registers(klass, rthread, scratch);
1289 
1290   Label L_fallthrough, L_tmp;
1291   if (L_fast_path == NULL) {
1292     L_fast_path = &amp;L_fallthrough;
1293   } else if (L_slow_path == NULL) {
1294     L_slow_path = &amp;L_fallthrough;
1295   }
1296   // Fast path check: class is fully initialized
1297   ldrb(scratch, Address(klass, InstanceKlass::init_state_offset()));
1298   subs(zr, scratch, InstanceKlass::fully_initialized);
1299   br(Assembler::EQ, *L_fast_path);
1300 
1301   // Fast path check: current thread is initializer thread
1302   ldr(scratch, Address(klass, InstanceKlass::init_thread_offset()));
1303   cmp(rthread, scratch);
1304 
1305   if (L_slow_path == &amp;L_fallthrough) {
1306     br(Assembler::EQ, *L_fast_path);
1307     bind(*L_slow_path);
1308   } else if (L_fast_path == &amp;L_fallthrough) {
1309     br(Assembler::NE, *L_slow_path);
1310     bind(*L_fast_path);
1311   } else {
1312     Unimplemented();
1313   }
1314 }
1315 
1316 void MacroAssembler::verify_oop(Register reg, const char* s) {
1317   if (!VerifyOops) return;
1318 
1319   // Pass register number to verify_oop_subroutine
1320   const char* b = NULL;
1321   {
1322     ResourceMark rm;
1323     stringStream ss;
1324     ss.print(&quot;verify_oop: %s: %s&quot;, reg-&gt;name(), s);
1325     b = code_string(ss.as_string());
1326   }
1327   BLOCK_COMMENT(&quot;verify_oop {&quot;);
1328 
1329   stp(r0, rscratch1, Address(pre(sp, -2 * wordSize)));
1330   stp(rscratch2, lr, Address(pre(sp, -2 * wordSize)));
1331 
1332   mov(r0, reg);
1333   movptr(rscratch1, (uintptr_t)(address)b);
1334 
1335   // call indirectly to solve generation ordering problem
1336   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
1337   ldr(rscratch2, Address(rscratch2));
1338   blr(rscratch2);
1339 
1340   ldp(rscratch2, lr, Address(post(sp, 2 * wordSize)));
1341   ldp(r0, rscratch1, Address(post(sp, 2 * wordSize)));
1342 
1343   BLOCK_COMMENT(&quot;} verify_oop&quot;);
1344 }
1345 
1346 void MacroAssembler::verify_oop_addr(Address addr, const char* s) {
1347   if (!VerifyOops) return;
1348 
1349   const char* b = NULL;
1350   {
1351     ResourceMark rm;
1352     stringStream ss;
1353     ss.print(&quot;verify_oop_addr: %s&quot;, s);
1354     b = code_string(ss.as_string());
1355   }
1356   BLOCK_COMMENT(&quot;verify_oop_addr {&quot;);
1357 
1358   stp(r0, rscratch1, Address(pre(sp, -2 * wordSize)));
1359   stp(rscratch2, lr, Address(pre(sp, -2 * wordSize)));
1360 
1361   // addr may contain sp so we will have to adjust it based on the
1362   // pushes that we just did.
1363   if (addr.uses(sp)) {
1364     lea(r0, addr);
1365     ldr(r0, Address(r0, 4 * wordSize));
1366   } else {
1367     ldr(r0, addr);
1368   }
1369   movptr(rscratch1, (uintptr_t)(address)b);
1370 
1371   // call indirectly to solve generation ordering problem
1372   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
1373   ldr(rscratch2, Address(rscratch2));
1374   blr(rscratch2);
1375 
1376   ldp(rscratch2, lr, Address(post(sp, 2 * wordSize)));
1377   ldp(r0, rscratch1, Address(post(sp, 2 * wordSize)));
1378 
1379   BLOCK_COMMENT(&quot;} verify_oop_addr&quot;);
1380 }
1381 
1382 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
1383                                          int extra_slot_offset) {
1384   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
1385   int stackElementSize = Interpreter::stackElementSize;
1386   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
1387 #ifdef ASSERT
1388   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
1389   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
1390 #endif
1391   if (arg_slot.is_constant()) {
1392     return Address(esp, arg_slot.as_constant() * stackElementSize
1393                    + offset);
1394   } else {
1395     add(rscratch1, esp, arg_slot.as_register(),
1396         ext::uxtx, exact_log2(stackElementSize));
1397     return Address(rscratch1, offset);
1398   }
1399 }
1400 
1401 void MacroAssembler::call_VM_leaf_base(address entry_point,
1402                                        int number_of_arguments,
1403                                        Label *retaddr) {
1404   Label E, L;
1405 
1406   stp(rscratch1, rmethod, Address(pre(sp, -2 * wordSize)));
1407 
1408   mov(rscratch1, entry_point);
1409   blr(rscratch1);
1410   if (retaddr)
1411     bind(*retaddr);
1412 
1413   ldp(rscratch1, rmethod, Address(post(sp, 2 * wordSize)));
1414   maybe_isb();
1415 }
1416 
1417 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1418   call_VM_leaf_base(entry_point, number_of_arguments);
1419 }
1420 
1421 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1422   pass_arg0(this, arg_0);
1423   call_VM_leaf_base(entry_point, 1);
1424 }
1425 
1426 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1427   pass_arg0(this, arg_0);
1428   pass_arg1(this, arg_1);
1429   call_VM_leaf_base(entry_point, 2);
1430 }
1431 
1432 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0,
1433                                   Register arg_1, Register arg_2) {
1434   pass_arg0(this, arg_0);
1435   pass_arg1(this, arg_1);
1436   pass_arg2(this, arg_2);
1437   call_VM_leaf_base(entry_point, 3);
1438 }
1439 
1440 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1441   pass_arg0(this, arg_0);
1442   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1443 }
1444 
1445 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1446 
1447   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1448   pass_arg1(this, arg_1);
1449   pass_arg0(this, arg_0);
1450   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1451 }
1452 
1453 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1454   assert(arg_0 != c_rarg2, &quot;smashed arg&quot;);
1455   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
1456   pass_arg2(this, arg_2);
1457   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1458   pass_arg1(this, arg_1);
1459   pass_arg0(this, arg_0);
1460   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1461 }
1462 
1463 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1464   assert(arg_0 != c_rarg3, &quot;smashed arg&quot;);
1465   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
1466   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
1467   pass_arg3(this, arg_3);
1468   assert(arg_0 != c_rarg2, &quot;smashed arg&quot;);
1469   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
1470   pass_arg2(this, arg_2);
1471   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1472   pass_arg1(this, arg_1);
1473   pass_arg0(this, arg_0);
1474   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1475 }
1476 
1477 void MacroAssembler::null_check(Register reg, int offset) {
1478   if (needs_explicit_null_check(offset)) {
1479     // provoke OS NULL exception if reg = NULL by
1480     // accessing M[reg] w/o changing any registers
1481     // NOTE: this is plenty to provoke a segv
1482     ldr(zr, Address(reg));
1483   } else {
1484     // nothing to do, (later) access of M[reg + offset]
1485     // will provoke OS NULL exception if reg = NULL
1486   }
1487 }
1488 
1489 // MacroAssembler protected routines needed to implement
1490 // public methods
1491 
1492 void MacroAssembler::mov(Register r, Address dest) {
1493   code_section()-&gt;relocate(pc(), dest.rspec());
1494   u_int64_t imm64 = (u_int64_t)dest.target();
1495   movptr(r, imm64);
1496 }
1497 
1498 // Move a constant pointer into r.  In AArch64 mode the virtual
1499 // address space is 48 bits in size, so we only need three
1500 // instructions to create a patchable instruction sequence that can
1501 // reach anywhere.
1502 void MacroAssembler::movptr(Register r, uintptr_t imm64) {
1503 #ifndef PRODUCT
1504   {
1505     char buffer[64];
1506     snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
1507     block_comment(buffer);
1508   }
1509 #endif
1510   assert(imm64 &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
1511   movz(r, imm64 &amp; 0xffff);
1512   imm64 &gt;&gt;= 16;
1513   movk(r, imm64 &amp; 0xffff, 16);
1514   imm64 &gt;&gt;= 16;
1515   movk(r, imm64 &amp; 0xffff, 32);
1516 }
1517 
1518 // Macro to mov replicated immediate to vector register.
1519 //  Vd will get the following values for different arrangements in T
1520 //   imm32 == hex 000000gh  T8B:  Vd = ghghghghghghghgh
1521 //   imm32 == hex 000000gh  T16B: Vd = ghghghghghghghghghghghghghghghgh
1522 //   imm32 == hex 0000efgh  T4H:  Vd = efghefghefghefgh
1523 //   imm32 == hex 0000efgh  T8H:  Vd = efghefghefghefghefghefghefghefgh
1524 //   imm32 == hex abcdefgh  T2S:  Vd = abcdefghabcdefgh
1525 //   imm32 == hex abcdefgh  T4S:  Vd = abcdefghabcdefghabcdefghabcdefgh
1526 //   T1D/T2D: invalid
1527 void MacroAssembler::mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32) {
1528   assert(T != T1D &amp;&amp; T != T2D, &quot;invalid arrangement&quot;);
1529   if (T == T8B || T == T16B) {
1530     assert((imm32 &amp; ~0xff) == 0, &quot;extraneous bits in unsigned imm32 (T8B/T16B)&quot;);
1531     movi(Vd, T, imm32 &amp; 0xff, 0);
1532     return;
1533   }
1534   u_int32_t nimm32 = ~imm32;
1535   if (T == T4H || T == T8H) {
1536     assert((imm32  &amp; ~0xffff) == 0, &quot;extraneous bits in unsigned imm32 (T4H/T8H)&quot;);
1537     imm32 &amp;= 0xffff;
1538     nimm32 &amp;= 0xffff;
1539   }
1540   u_int32_t x = imm32;
1541   int movi_cnt = 0;
1542   int movn_cnt = 0;
1543   while (x) { if (x &amp; 0xff) movi_cnt++; x &gt;&gt;= 8; }
1544   x = nimm32;
1545   while (x) { if (x &amp; 0xff) movn_cnt++; x &gt;&gt;= 8; }
1546   if (movn_cnt &lt; movi_cnt) imm32 = nimm32;
1547   unsigned lsl = 0;
1548   while (imm32 &amp;&amp; (imm32 &amp; 0xff) == 0) { lsl += 8; imm32 &gt;&gt;= 8; }
1549   if (movn_cnt &lt; movi_cnt)
1550     mvni(Vd, T, imm32 &amp; 0xff, lsl);
1551   else
1552     movi(Vd, T, imm32 &amp; 0xff, lsl);
1553   imm32 &gt;&gt;= 8; lsl += 8;
1554   while (imm32) {
1555     while ((imm32 &amp; 0xff) == 0) { lsl += 8; imm32 &gt;&gt;= 8; }
1556     if (movn_cnt &lt; movi_cnt)
1557       bici(Vd, T, imm32 &amp; 0xff, lsl);
1558     else
1559       orri(Vd, T, imm32 &amp; 0xff, lsl);
1560     lsl += 8; imm32 &gt;&gt;= 8;
1561   }
1562 }
1563 
1564 void MacroAssembler::mov_immediate64(Register dst, u_int64_t imm64)
1565 {
1566 #ifndef PRODUCT
1567   {
1568     char buffer[64];
1569     snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
1570     block_comment(buffer);
1571   }
1572 #endif
1573   if (operand_valid_for_logical_immediate(false, imm64)) {
1574     orr(dst, zr, imm64);
1575   } else {
1576     // we can use a combination of MOVZ or MOVN with
1577     // MOVK to build up the constant
1578     u_int64_t imm_h[4];
1579     int zero_count = 0;
1580     int neg_count = 0;
1581     int i;
1582     for (i = 0; i &lt; 4; i++) {
1583       imm_h[i] = ((imm64 &gt;&gt; (i * 16)) &amp; 0xffffL);
1584       if (imm_h[i] == 0) {
1585         zero_count++;
1586       } else if (imm_h[i] == 0xffffL) {
1587         neg_count++;
1588       }
1589     }
1590     if (zero_count == 4) {
1591       // one MOVZ will do
1592       movz(dst, 0);
1593     } else if (neg_count == 4) {
1594       // one MOVN will do
1595       movn(dst, 0);
1596     } else if (zero_count == 3) {
1597       for (i = 0; i &lt; 4; i++) {
1598         if (imm_h[i] != 0L) {
1599           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1600           break;
1601         }
1602       }
1603     } else if (neg_count == 3) {
1604       // one MOVN will do
1605       for (int i = 0; i &lt; 4; i++) {
1606         if (imm_h[i] != 0xffffL) {
1607           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1608           break;
1609         }
1610       }
1611     } else if (zero_count == 2) {
1612       // one MOVZ and one MOVK will do
1613       for (i = 0; i &lt; 3; i++) {
1614         if (imm_h[i] != 0L) {
1615           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1616           i++;
1617           break;
1618         }
1619       }
1620       for (;i &lt; 4; i++) {
1621         if (imm_h[i] != 0L) {
1622           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1623         }
1624       }
1625     } else if (neg_count == 2) {
1626       // one MOVN and one MOVK will do
1627       for (i = 0; i &lt; 4; i++) {
1628         if (imm_h[i] != 0xffffL) {
1629           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1630           i++;
1631           break;
1632         }
1633       }
1634       for (;i &lt; 4; i++) {
1635         if (imm_h[i] != 0xffffL) {
1636           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1637         }
1638       }
1639     } else if (zero_count == 1) {
1640       // one MOVZ and two MOVKs will do
1641       for (i = 0; i &lt; 4; i++) {
1642         if (imm_h[i] != 0L) {
1643           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1644           i++;
1645           break;
1646         }
1647       }
1648       for (;i &lt; 4; i++) {
1649         if (imm_h[i] != 0x0L) {
1650           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1651         }
1652       }
1653     } else if (neg_count == 1) {
1654       // one MOVN and two MOVKs will do
1655       for (i = 0; i &lt; 4; i++) {
1656         if (imm_h[i] != 0xffffL) {
1657           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1658           i++;
1659           break;
1660         }
1661       }
1662       for (;i &lt; 4; i++) {
1663         if (imm_h[i] != 0xffffL) {
1664           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1665         }
1666       }
1667     } else {
1668       // use a MOVZ and 3 MOVKs (makes it easier to debug)
1669       movz(dst, (u_int32_t)imm_h[0], 0);
1670       for (i = 1; i &lt; 4; i++) {
1671         movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1672       }
1673     }
1674   }
1675 }
1676 
1677 void MacroAssembler::mov_immediate32(Register dst, u_int32_t imm32)
1678 {
1679 #ifndef PRODUCT
1680     {
1681       char buffer[64];
1682       snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX32, imm32);
1683       block_comment(buffer);
1684     }
1685 #endif
1686   if (operand_valid_for_logical_immediate(true, imm32)) {
1687     orrw(dst, zr, imm32);
1688   } else {
1689     // we can use MOVZ, MOVN or two calls to MOVK to build up the
1690     // constant
1691     u_int32_t imm_h[2];
1692     imm_h[0] = imm32 &amp; 0xffff;
1693     imm_h[1] = ((imm32 &gt;&gt; 16) &amp; 0xffff);
1694     if (imm_h[0] == 0) {
1695       movzw(dst, imm_h[1], 16);
1696     } else if (imm_h[0] == 0xffff) {
1697       movnw(dst, imm_h[1] ^ 0xffff, 16);
1698     } else if (imm_h[1] == 0) {
1699       movzw(dst, imm_h[0], 0);
1700     } else if (imm_h[1] == 0xffff) {
1701       movnw(dst, imm_h[0] ^ 0xffff, 0);
1702     } else {
1703       // use a MOVZ and MOVK (makes it easier to debug)
1704       movzw(dst, imm_h[0], 0);
1705       movkw(dst, imm_h[1], 16);
1706     }
1707   }
1708 }
1709 
1710 // Form an address from base + offset in Rd.  Rd may or may
1711 // not actually be used: you must use the Address that is returned.
1712 // It is up to you to ensure that the shift provided matches the size
1713 // of your data.
1714 Address MacroAssembler::form_address(Register Rd, Register base, long byte_offset, int shift) {
1715   if (Address::offset_ok_for_immed(byte_offset, shift))
1716     // It fits; no need for any heroics
1717     return Address(base, byte_offset);
1718 
1719   // Don&#39;t do anything clever with negative or misaligned offsets
1720   unsigned mask = (1 &lt;&lt; shift) - 1;
1721   if (byte_offset &lt; 0 || byte_offset &amp; mask) {
1722     mov(Rd, byte_offset);
1723     add(Rd, base, Rd);
1724     return Address(Rd);
1725   }
1726 
1727   // See if we can do this with two 12-bit offsets
1728   {
1729     unsigned long word_offset = byte_offset &gt;&gt; shift;
1730     unsigned long masked_offset = word_offset &amp; 0xfff000;
1731     if (Address::offset_ok_for_immed(word_offset - masked_offset, 0)
1732         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(masked_offset &lt;&lt; shift)) {
1733       add(Rd, base, masked_offset &lt;&lt; shift);
1734       word_offset -= masked_offset;
1735       return Address(Rd, word_offset &lt;&lt; shift);
1736     }
1737   }
1738 
1739   // Do it the hard way
1740   mov(Rd, byte_offset);
1741   add(Rd, base, Rd);
1742   return Address(Rd);
1743 }
1744 
1745 void MacroAssembler::atomic_incw(Register counter_addr, Register tmp, Register tmp2) {
1746   if (UseLSE) {
1747     mov(tmp, 1);
1748     ldadd(Assembler::word, tmp, zr, counter_addr);
1749     return;
1750   }
1751   Label retry_load;
1752   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
1753     prfm(Address(counter_addr), PSTL1STRM);
1754   bind(retry_load);
1755   // flush and load exclusive from the memory location
1756   ldxrw(tmp, counter_addr);
1757   addw(tmp, tmp, 1);
1758   // if we store+flush with no intervening write tmp wil be zero
1759   stxrw(tmp2, tmp, counter_addr);
1760   cbnzw(tmp2, retry_load);
1761 }
1762 
1763 
1764 int MacroAssembler::corrected_idivl(Register result, Register ra, Register rb,
1765                                     bool want_remainder, Register scratch)
1766 {
1767   // Full implementation of Java idiv and irem.  The function
1768   // returns the (pc) offset of the div instruction - may be needed
1769   // for implicit exceptions.
1770   //
1771   // constraint : ra/rb =/= scratch
1772   //         normal case
1773   //
1774   // input : ra: dividend
1775   //         rb: divisor
1776   //
1777   // result: either
1778   //         quotient  (= ra idiv rb)
1779   //         remainder (= ra irem rb)
1780 
1781   assert(ra != scratch &amp;&amp; rb != scratch, &quot;reg cannot be scratch&quot;);
1782 
1783   int idivl_offset = offset();
1784   if (! want_remainder) {
1785     sdivw(result, ra, rb);
1786   } else {
1787     sdivw(scratch, ra, rb);
1788     Assembler::msubw(result, scratch, rb, ra);
1789   }
1790 
1791   return idivl_offset;
1792 }
1793 
1794 int MacroAssembler::corrected_idivq(Register result, Register ra, Register rb,
1795                                     bool want_remainder, Register scratch)
1796 {
1797   // Full implementation of Java ldiv and lrem.  The function
1798   // returns the (pc) offset of the div instruction - may be needed
1799   // for implicit exceptions.
1800   //
1801   // constraint : ra/rb =/= scratch
1802   //         normal case
1803   //
1804   // input : ra: dividend
1805   //         rb: divisor
1806   //
1807   // result: either
1808   //         quotient  (= ra idiv rb)
1809   //         remainder (= ra irem rb)
1810 
1811   assert(ra != scratch &amp;&amp; rb != scratch, &quot;reg cannot be scratch&quot;);
1812 
1813   int idivq_offset = offset();
1814   if (! want_remainder) {
1815     sdiv(result, ra, rb);
1816   } else {
1817     sdiv(scratch, ra, rb);
1818     Assembler::msub(result, scratch, rb, ra);
1819   }
1820 
1821   return idivq_offset;
1822 }
1823 
1824 void MacroAssembler::membar(Membar_mask_bits order_constraint) {
1825   address prev = pc() - NativeMembar::instruction_size;
1826   address last = code()-&gt;last_insn();
1827   if (last != NULL &amp;&amp; nativeInstruction_at(last)-&gt;is_Membar() &amp;&amp; prev == last) {
1828     NativeMembar *bar = NativeMembar_at(prev);
1829     // We are merging two memory barrier instructions.  On AArch64 we
1830     // can do this simply by ORing them together.
1831     bar-&gt;set_kind(bar-&gt;get_kind() | order_constraint);
1832     BLOCK_COMMENT(&quot;merged membar&quot;);
1833   } else {
1834     code()-&gt;set_last_insn(pc());
1835     dmb(Assembler::barrier(order_constraint));
1836   }
1837 }
1838 
1839 bool MacroAssembler::try_merge_ldst(Register rt, const Address &amp;adr, size_t size_in_bytes, bool is_store) {
1840   if (ldst_can_merge(rt, adr, size_in_bytes, is_store)) {
1841     merge_ldst(rt, adr, size_in_bytes, is_store);
1842     code()-&gt;clear_last_insn();
1843     return true;
1844   } else {
1845     assert(size_in_bytes == 8 || size_in_bytes == 4, &quot;only 8 bytes or 4 bytes load/store is supported.&quot;);
1846     const unsigned mask = size_in_bytes - 1;
1847     if (adr.getMode() == Address::base_plus_offset &amp;&amp;
1848         (adr.offset() &amp; mask) == 0) { // only supports base_plus_offset.
1849       code()-&gt;set_last_insn(pc());
1850     }
1851     return false;
1852   }
1853 }
1854 
1855 void MacroAssembler::ldr(Register Rx, const Address &amp;adr) {
1856   // We always try to merge two adjacent loads into one ldp.
1857   if (!try_merge_ldst(Rx, adr, 8, false)) {
1858     Assembler::ldr(Rx, adr);
1859   }
1860 }
1861 
1862 void MacroAssembler::ldrw(Register Rw, const Address &amp;adr) {
1863   // We always try to merge two adjacent loads into one ldp.
1864   if (!try_merge_ldst(Rw, adr, 4, false)) {
1865     Assembler::ldrw(Rw, adr);
1866   }
1867 }
1868 
1869 void MacroAssembler::str(Register Rx, const Address &amp;adr) {
1870   // We always try to merge two adjacent stores into one stp.
1871   if (!try_merge_ldst(Rx, adr, 8, true)) {
1872     Assembler::str(Rx, adr);
1873   }
1874 }
1875 
1876 void MacroAssembler::strw(Register Rw, const Address &amp;adr) {
1877   // We always try to merge two adjacent stores into one stp.
1878   if (!try_merge_ldst(Rw, adr, 4, true)) {
1879     Assembler::strw(Rw, adr);
1880   }
1881 }
1882 
1883 // MacroAssembler routines found actually to be needed
1884 
1885 void MacroAssembler::push(Register src)
1886 {
1887   str(src, Address(pre(esp, -1 * wordSize)));
1888 }
1889 
1890 void MacroAssembler::pop(Register dst)
1891 {
1892   ldr(dst, Address(post(esp, 1 * wordSize)));
1893 }
1894 
1895 // Note: load_unsigned_short used to be called load_unsigned_word.
1896 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
1897   int off = offset();
1898   ldrh(dst, src);
1899   return off;
1900 }
1901 
1902 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
1903   int off = offset();
1904   ldrb(dst, src);
1905   return off;
1906 }
1907 
1908 int MacroAssembler::load_signed_short(Register dst, Address src) {
1909   int off = offset();
1910   ldrsh(dst, src);
1911   return off;
1912 }
1913 
1914 int MacroAssembler::load_signed_byte(Register dst, Address src) {
1915   int off = offset();
1916   ldrsb(dst, src);
1917   return off;
1918 }
1919 
1920 int MacroAssembler::load_signed_short32(Register dst, Address src) {
1921   int off = offset();
1922   ldrshw(dst, src);
1923   return off;
1924 }
1925 
1926 int MacroAssembler::load_signed_byte32(Register dst, Address src) {
1927   int off = offset();
1928   ldrsbw(dst, src);
1929   return off;
1930 }
1931 
1932 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
1933   switch (size_in_bytes) {
1934   case  8:  ldr(dst, src); break;
1935   case  4:  ldrw(dst, src); break;
1936   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
1937   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
1938   default:  ShouldNotReachHere();
1939   }
1940 }
1941 
1942 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
1943   switch (size_in_bytes) {
1944   case  8:  str(src, dst); break;
1945   case  4:  strw(src, dst); break;
1946   case  2:  strh(src, dst); break;
1947   case  1:  strb(src, dst); break;
1948   default:  ShouldNotReachHere();
1949   }
1950 }
1951 
1952 void MacroAssembler::decrementw(Register reg, int value)
1953 {
1954   if (value &lt; 0)  { incrementw(reg, -value);      return; }
1955   if (value == 0) {                               return; }
1956   if (value &lt; (1 &lt;&lt; 12)) { subw(reg, reg, value); return; }
1957   /* else */ {
1958     guarantee(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
1959     movw(rscratch2, (unsigned)value);
1960     subw(reg, reg, rscratch2);
1961   }
1962 }
1963 
1964 void MacroAssembler::decrement(Register reg, int value)
1965 {
1966   if (value &lt; 0)  { increment(reg, -value);      return; }
1967   if (value == 0) {                              return; }
1968   if (value &lt; (1 &lt;&lt; 12)) { sub(reg, reg, value); return; }
1969   /* else */ {
1970     assert(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
1971     mov(rscratch2, (unsigned long)value);
1972     sub(reg, reg, rscratch2);
1973   }
1974 }
1975 
1976 void MacroAssembler::decrementw(Address dst, int value)
1977 {
1978   assert(!dst.uses(rscratch1), &quot;invalid dst for address decrement&quot;);
1979   if (dst.getMode() == Address::literal) {
1980     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
1981     lea(rscratch2, dst);
1982     dst = Address(rscratch2);
1983   }
1984   ldrw(rscratch1, dst);
1985   decrementw(rscratch1, value);
1986   strw(rscratch1, dst);
1987 }
1988 
1989 void MacroAssembler::decrement(Address dst, int value)
1990 {
1991   assert(!dst.uses(rscratch1), &quot;invalid address for decrement&quot;);
1992   if (dst.getMode() == Address::literal) {
1993     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
1994     lea(rscratch2, dst);
1995     dst = Address(rscratch2);
1996   }
1997   ldr(rscratch1, dst);
1998   decrement(rscratch1, value);
1999   str(rscratch1, dst);
2000 }
2001 
2002 void MacroAssembler::incrementw(Register reg, int value)
2003 {
2004   if (value &lt; 0)  { decrementw(reg, -value);      return; }
2005   if (value == 0) {                               return; }
2006   if (value &lt; (1 &lt;&lt; 12)) { addw(reg, reg, value); return; }
2007   /* else */ {
2008     assert(reg != rscratch2, &quot;invalid dst for register increment&quot;);
2009     movw(rscratch2, (unsigned)value);
2010     addw(reg, reg, rscratch2);
2011   }
2012 }
2013 
2014 void MacroAssembler::increment(Register reg, int value)
2015 {
2016   if (value &lt; 0)  { decrement(reg, -value);      return; }
2017   if (value == 0) {                              return; }
2018   if (value &lt; (1 &lt;&lt; 12)) { add(reg, reg, value); return; }
2019   /* else */ {
2020     assert(reg != rscratch2, &quot;invalid dst for register increment&quot;);
2021     movw(rscratch2, (unsigned)value);
2022     add(reg, reg, rscratch2);
2023   }
2024 }
2025 
2026 void MacroAssembler::incrementw(Address dst, int value)
2027 {
2028   assert(!dst.uses(rscratch1), &quot;invalid dst for address increment&quot;);
2029   if (dst.getMode() == Address::literal) {
2030     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2031     lea(rscratch2, dst);
2032     dst = Address(rscratch2);
2033   }
2034   ldrw(rscratch1, dst);
2035   incrementw(rscratch1, value);
2036   strw(rscratch1, dst);
2037 }
2038 
2039 void MacroAssembler::increment(Address dst, int value)
2040 {
2041   assert(!dst.uses(rscratch1), &quot;invalid dst for address increment&quot;);
2042   if (dst.getMode() == Address::literal) {
2043     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2044     lea(rscratch2, dst);
2045     dst = Address(rscratch2);
2046   }
2047   ldr(rscratch1, dst);
2048   increment(rscratch1, value);
2049   str(rscratch1, dst);
2050 }
2051 
2052 
2053 void MacroAssembler::pusha() {
2054   push(0x7fffffff, sp);
2055 }
2056 
2057 void MacroAssembler::popa() {
2058   pop(0x7fffffff, sp);
2059 }
2060 
2061 // Push lots of registers in the bit set supplied.  Don&#39;t push sp.
2062 // Return the number of words pushed
2063 int MacroAssembler::push(unsigned int bitset, Register stack) {
2064   int words_pushed = 0;
2065 
2066   // Scan bitset to accumulate register pairs
2067   unsigned char regs[32];
2068   int count = 0;
2069   for (int reg = 0; reg &lt;= 30; reg++) {
2070     if (1 &amp; bitset)
2071       regs[count++] = reg;
2072     bitset &gt;&gt;= 1;
2073   }
2074   regs[count++] = zr-&gt;encoding_nocheck();
2075   count &amp;= ~1;  // Only push an even nuber of regs
2076 
2077   if (count) {
2078     stp(as_Register(regs[0]), as_Register(regs[1]),
2079        Address(pre(stack, -count * wordSize)));
2080     words_pushed += 2;
2081   }
2082   for (int i = 2; i &lt; count; i += 2) {
2083     stp(as_Register(regs[i]), as_Register(regs[i+1]),
2084        Address(stack, i * wordSize));
2085     words_pushed += 2;
2086   }
2087 
2088   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2089 
2090   return count;
2091 }
2092 
2093 int MacroAssembler::pop(unsigned int bitset, Register stack) {
2094   int words_pushed = 0;
2095 
2096   // Scan bitset to accumulate register pairs
2097   unsigned char regs[32];
2098   int count = 0;
2099   for (int reg = 0; reg &lt;= 30; reg++) {
2100     if (1 &amp; bitset)
2101       regs[count++] = reg;
2102     bitset &gt;&gt;= 1;
2103   }
2104   regs[count++] = zr-&gt;encoding_nocheck();
2105   count &amp;= ~1;
2106 
2107   for (int i = 2; i &lt; count; i += 2) {
2108     ldp(as_Register(regs[i]), as_Register(regs[i+1]),
2109        Address(stack, i * wordSize));
2110     words_pushed += 2;
2111   }
2112   if (count) {
2113     ldp(as_Register(regs[0]), as_Register(regs[1]),
2114        Address(post(stack, count * wordSize)));
2115     words_pushed += 2;
2116   }
2117 
2118   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2119 
2120   return count;
2121 }
2122 
2123 // Push lots of registers in the bit set supplied.  Don&#39;t push sp.
2124 // Return the number of words pushed
2125 int MacroAssembler::push_fp(unsigned int bitset, Register stack) {
2126   int words_pushed = 0;
2127 
2128   // Scan bitset to accumulate register pairs
2129   unsigned char regs[32];
2130   int count = 0;
2131   for (int reg = 0; reg &lt;= 31; reg++) {
2132     if (1 &amp; bitset)
2133       regs[count++] = reg;
2134     bitset &gt;&gt;= 1;
2135   }
2136 
2137   if (count == 0) {
2138     return 0;
2139   }
2140 
2141   if (count == 1) {
2142     strq(as_FloatRegister(regs[0]), Address(pre(stack, -wordSize * 2)));
2143     return 1;
2144   }
2145 
2146   bool odd = (count &amp; 1) == 1;
2147   int push_slots = count + (odd ? 1 : 0);
2148 
2149   // Always pushing full 128 bit registers.
2150   stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize * 2)));
2151   words_pushed += 2;
2152 
2153   for (int i = 2; i + 1 &lt; count; i += 2) {
2154     stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
2155     words_pushed += 2;
2156   }
2157 
2158   if (odd) {
2159     strq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));
2160     words_pushed++;
2161   }
2162 
2163   assert(words_pushed == count, &quot;oops, pushed(%d) != count(%d)&quot;, words_pushed, count);
2164   return count;
2165 }
2166 
2167 int MacroAssembler::pop_fp(unsigned int bitset, Register stack) {
2168   int words_pushed = 0;
2169 
2170   // Scan bitset to accumulate register pairs
2171   unsigned char regs[32];
2172   int count = 0;
2173   for (int reg = 0; reg &lt;= 31; reg++) {
2174     if (1 &amp; bitset)
2175       regs[count++] = reg;
2176     bitset &gt;&gt;= 1;
2177   }
2178 
2179   if (count == 0) {
2180     return 0;
2181   }
2182 
2183   if (count == 1) {
2184     ldrq(as_FloatRegister(regs[0]), Address(post(stack, wordSize * 2)));
2185     return 1;
2186   }
2187 
2188   bool odd = (count &amp; 1) == 1;
2189   int push_slots = count + (odd ? 1 : 0);
2190 
2191   if (odd) {
2192     ldrq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));
2193     words_pushed++;
2194   }
2195 
2196   for (int i = 2; i + 1 &lt; count; i += 2) {
2197     ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
2198     words_pushed += 2;
2199   }
2200 
2201   ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize * 2)));
2202   words_pushed += 2;
2203 
2204   assert(words_pushed == count, &quot;oops, pushed(%d) != count(%d)&quot;, words_pushed, count);
2205 
2206   return count;
2207 }
2208 
2209 #ifdef ASSERT
2210 void MacroAssembler::verify_heapbase(const char* msg) {
2211 #if 0
2212   assert (UseCompressedOops || UseCompressedClassPointers, &quot;should be compressed&quot;);
2213   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
2214   if (!UseCompressedOops || Universe::ptr_base() == NULL) {
2215     // rheapbase is allocated as general register
2216     return;
2217   }
2218   if (CheckCompressedOops) {
2219     Label ok;
2220     push(1 &lt;&lt; rscratch1-&gt;encoding(), sp); // cmpptr trashes rscratch1
2221     cmpptr(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
2222     br(Assembler::EQ, ok);
2223     stop(msg);
2224     bind(ok);
2225     pop(1 &lt;&lt; rscratch1-&gt;encoding(), sp);
2226   }
2227 #endif
2228 }
2229 #endif
2230 
2231 void MacroAssembler::resolve_jobject(Register value, Register thread, Register tmp) {
2232   Label done, not_weak;
2233   cbz(value, done);           // Use NULL as-is.
2234 
2235   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
2236   tbz(r0, 0, not_weak);    // Test for jweak tag.
2237 
2238   // Resolve jweak.
2239   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,
2240                  Address(value, -JNIHandles::weak_tag_value), tmp, thread);
2241   verify_oop(value);
2242   b(done);
2243 
2244   bind(not_weak);
2245   // Resolve (untagged) jobject.
2246   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
2247   verify_oop(value);
2248   bind(done);
2249 }
2250 
2251 void MacroAssembler::stop(const char* msg) {
2252   BLOCK_COMMENT(msg);
2253   dcps1(0xdeae);
2254   emit_int64((uintptr_t)msg);
2255 }
2256 
2257 void MacroAssembler::unimplemented(const char* what) {
2258   const char* buf = NULL;
2259   {
2260     ResourceMark rm;
2261     stringStream ss;
2262     ss.print(&quot;unimplemented: %s&quot;, what);
2263     buf = code_string(ss.as_string());
2264   }
2265   stop(buf);
2266 }
2267 
2268 // If a constant does not fit in an immediate field, generate some
2269 // number of MOV instructions and then perform the operation.
2270 void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
2271                                            add_sub_imm_insn insn1,
2272                                            add_sub_reg_insn insn2) {
2273   assert(Rd != zr, &quot;Rd = zr and not setting flags?&quot;);
2274   if (operand_valid_for_add_sub_immediate((int)imm)) {
2275     (this-&gt;*insn1)(Rd, Rn, imm);
2276   } else {
2277     if (uabs(imm) &lt; (1 &lt;&lt; 24)) {
2278        (this-&gt;*insn1)(Rd, Rn, imm &amp; -(1 &lt;&lt; 12));
2279        (this-&gt;*insn1)(Rd, Rd, imm &amp; ((1 &lt;&lt; 12)-1));
2280     } else {
2281        assert_different_registers(Rd, Rn);
2282        mov(Rd, (uint64_t)imm);
2283        (this-&gt;*insn2)(Rd, Rn, Rd, LSL, 0);
2284     }
2285   }
2286 }
2287 
2288 // Seperate vsn which sets the flags. Optimisations are more restricted
2289 // because we must set the flags correctly.
2290 void MacroAssembler::wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
2291                                            add_sub_imm_insn insn1,
2292                                            add_sub_reg_insn insn2) {
2293   if (operand_valid_for_add_sub_immediate((int)imm)) {
2294     (this-&gt;*insn1)(Rd, Rn, imm);
2295   } else {
2296     assert_different_registers(Rd, Rn);
2297     assert(Rd != zr, &quot;overflow in immediate operand&quot;);
2298     mov(Rd, (uint64_t)imm);
2299     (this-&gt;*insn2)(Rd, Rn, Rd, LSL, 0);
2300   }
2301 }
2302 
2303 
2304 void MacroAssembler::add(Register Rd, Register Rn, RegisterOrConstant increment) {
2305   if (increment.is_register()) {
2306     add(Rd, Rn, increment.as_register());
2307   } else {
2308     add(Rd, Rn, increment.as_constant());
2309   }
2310 }
2311 
2312 void MacroAssembler::addw(Register Rd, Register Rn, RegisterOrConstant increment) {
2313   if (increment.is_register()) {
2314     addw(Rd, Rn, increment.as_register());
2315   } else {
2316     addw(Rd, Rn, increment.as_constant());
2317   }
2318 }
2319 
2320 void MacroAssembler::sub(Register Rd, Register Rn, RegisterOrConstant decrement) {
2321   if (decrement.is_register()) {
2322     sub(Rd, Rn, decrement.as_register());
2323   } else {
2324     sub(Rd, Rn, decrement.as_constant());
2325   }
2326 }
2327 
2328 void MacroAssembler::subw(Register Rd, Register Rn, RegisterOrConstant decrement) {
2329   if (decrement.is_register()) {
2330     subw(Rd, Rn, decrement.as_register());
2331   } else {
2332     subw(Rd, Rn, decrement.as_constant());
2333   }
2334 }
2335 
2336 void MacroAssembler::reinit_heapbase()
2337 {
2338   if (UseCompressedOops) {
2339     if (Universe::is_fully_initialized()) {
2340       mov(rheapbase, CompressedOops::ptrs_base());
2341     } else {
2342       lea(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
2343       ldr(rheapbase, Address(rheapbase));
2344     }
2345   }
2346 }
2347 
2348 // this simulates the behaviour of the x86 cmpxchg instruction using a
2349 // load linked/store conditional pair. we use the acquire/release
2350 // versions of these instructions so that we flush pending writes as
2351 // per Java semantics.
2352 
2353 // n.b the x86 version assumes the old value to be compared against is
2354 // in rax and updates rax with the value located in memory if the
2355 // cmpxchg fails. we supply a register for the old value explicitly
2356 
2357 // the aarch64 load linked/store conditional instructions do not
2358 // accept an offset. so, unlike x86, we must provide a plain register
2359 // to identify the memory word to be compared/exchanged rather than a
2360 // register+offset Address.
2361 
2362 void MacroAssembler::cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
2363                                 Label &amp;succeed, Label *fail) {
2364   // oldv holds comparison value
2365   // newv holds value to write in exchange
2366   // addr identifies memory word to compare against/update
2367   if (UseLSE) {
2368     mov(tmp, oldv);
2369     casal(Assembler::xword, oldv, newv, addr);
2370     cmp(tmp, oldv);
2371     br(Assembler::EQ, succeed);
2372     membar(AnyAny);
2373   } else {
2374     Label retry_load, nope;
2375     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2376       prfm(Address(addr), PSTL1STRM);
2377     bind(retry_load);
2378     // flush and load exclusive from the memory location
2379     // and fail if it is not what we expect
2380     ldaxr(tmp, addr);
2381     cmp(tmp, oldv);
2382     br(Assembler::NE, nope);
2383     // if we store+flush with no intervening write tmp wil be zero
2384     stlxr(tmp, newv, addr);
2385     cbzw(tmp, succeed);
2386     // retry so we only ever return after a load fails to compare
2387     // ensures we don&#39;t return a stale value after a failed write.
2388     b(retry_load);
2389     // if the memory word differs we return it in oldv and signal a fail
2390     bind(nope);
2391     membar(AnyAny);
2392     mov(oldv, tmp);
2393   }
2394   if (fail)
2395     b(*fail);
2396 }
2397 
2398 void MacroAssembler::cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
2399                                         Label &amp;succeed, Label *fail) {
2400   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;assumption&quot;);
2401   cmpxchgptr(oldv, newv, obj, tmp, succeed, fail);
2402 }
2403 
2404 void MacroAssembler::cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
2405                                 Label &amp;succeed, Label *fail) {
2406   // oldv holds comparison value
2407   // newv holds value to write in exchange
2408   // addr identifies memory word to compare against/update
2409   // tmp returns 0/1 for success/failure
2410   if (UseLSE) {
2411     mov(tmp, oldv);
2412     casal(Assembler::word, oldv, newv, addr);
2413     cmp(tmp, oldv);
2414     br(Assembler::EQ, succeed);
2415     membar(AnyAny);
2416   } else {
2417     Label retry_load, nope;
2418     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2419       prfm(Address(addr), PSTL1STRM);
2420     bind(retry_load);
2421     // flush and load exclusive from the memory location
2422     // and fail if it is not what we expect
2423     ldaxrw(tmp, addr);
2424     cmp(tmp, oldv);
2425     br(Assembler::NE, nope);
2426     // if we store+flush with no intervening write tmp wil be zero
2427     stlxrw(tmp, newv, addr);
2428     cbzw(tmp, succeed);
2429     // retry so we only ever return after a load fails to compare
2430     // ensures we don&#39;t return a stale value after a failed write.
2431     b(retry_load);
2432     // if the memory word differs we return it in oldv and signal a fail
2433     bind(nope);
2434     membar(AnyAny);
2435     mov(oldv, tmp);
2436   }
2437   if (fail)
2438     b(*fail);
2439 }
2440 
2441 // A generic CAS; success or failure is in the EQ flag.  A weak CAS
2442 // doesn&#39;t retry and may fail spuriously.  If the oldval is wanted,
2443 // Pass a register for the result, otherwise pass noreg.
2444 
2445 // Clobbers rscratch1
2446 void MacroAssembler::cmpxchg(Register addr, Register expected,
2447                              Register new_val,
2448                              enum operand_size size,
2449                              bool acquire, bool release,
2450                              bool weak,
2451                              Register result) {
2452   if (result == noreg)  result = rscratch1;
2453   BLOCK_COMMENT(&quot;cmpxchg {&quot;);
2454   if (UseLSE) {
2455     mov(result, expected);
2456     lse_cas(result, new_val, addr, size, acquire, release, /*not_pair*/ true);
2457     compare_eq(result, expected, size);
2458   } else {
2459     Label retry_load, done;
2460     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2461       prfm(Address(addr), PSTL1STRM);
2462     bind(retry_load);
2463     load_exclusive(result, addr, size, acquire);
2464     compare_eq(result, expected, size);
2465     br(Assembler::NE, done);
2466     store_exclusive(rscratch1, new_val, addr, size, release);
2467     if (weak) {
2468       cmpw(rscratch1, 0u);  // If the store fails, return NE to our caller.
2469     } else {
2470       cbnzw(rscratch1, retry_load);
2471     }
2472     bind(done);
2473   }
2474   BLOCK_COMMENT(&quot;} cmpxchg&quot;);
2475 }
2476 
2477 // A generic comparison. Only compares for equality, clobbers rscratch1.
2478 void MacroAssembler::compare_eq(Register rm, Register rn, enum operand_size size) {
2479   if (size == xword) {
2480     cmp(rm, rn);
2481   } else if (size == word) {
2482     cmpw(rm, rn);
2483   } else if (size == halfword) {
2484     eorw(rscratch1, rm, rn);
2485     ands(zr, rscratch1, 0xffff);
2486   } else if (size == byte) {
2487     eorw(rscratch1, rm, rn);
2488     ands(zr, rscratch1, 0xff);
2489   } else {
2490     ShouldNotReachHere();
2491   }
2492 }
2493 
2494 
2495 static bool different(Register a, RegisterOrConstant b, Register c) {
2496   if (b.is_constant())
2497     return a != c;
2498   else
2499     return a != b.as_register() &amp;&amp; a != c &amp;&amp; b.as_register() != c;
2500 }
2501 
2502 #define ATOMIC_OP(NAME, LDXR, OP, IOP, AOP, STXR, sz)                   \
2503 void MacroAssembler::atomic_##NAME(Register prev, RegisterOrConstant incr, Register addr) { \
2504   if (UseLSE) {                                                         \
2505     prev = prev-&gt;is_valid() ? prev : zr;                                \
2506     if (incr.is_register()) {                                           \
2507       AOP(sz, incr.as_register(), prev, addr);                          \
2508     } else {                                                            \
2509       mov(rscratch2, incr.as_constant());                               \
2510       AOP(sz, rscratch2, prev, addr);                                   \
2511     }                                                                   \
2512     return;                                                             \
2513   }                                                                     \
2514   Register result = rscratch2;                                          \
2515   if (prev-&gt;is_valid())                                                 \
2516     result = different(prev, incr, addr) ? prev : rscratch2;            \
2517                                                                         \
2518   Label retry_load;                                                     \
2519   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))         \
2520     prfm(Address(addr), PSTL1STRM);                                     \
2521   bind(retry_load);                                                     \
2522   LDXR(result, addr);                                                   \
2523   OP(rscratch1, result, incr);                                          \
2524   STXR(rscratch2, rscratch1, addr);                                     \
2525   cbnzw(rscratch2, retry_load);                                         \
2526   if (prev-&gt;is_valid() &amp;&amp; prev != result) {                             \
2527     IOP(prev, rscratch1, incr);                                         \
2528   }                                                                     \
2529 }
2530 
2531 ATOMIC_OP(add, ldxr, add, sub, ldadd, stxr, Assembler::xword)
2532 ATOMIC_OP(addw, ldxrw, addw, subw, ldadd, stxrw, Assembler::word)
2533 ATOMIC_OP(addal, ldaxr, add, sub, ldaddal, stlxr, Assembler::xword)
2534 ATOMIC_OP(addalw, ldaxrw, addw, subw, ldaddal, stlxrw, Assembler::word)
2535 
2536 #undef ATOMIC_OP
2537 
2538 #define ATOMIC_XCHG(OP, AOP, LDXR, STXR, sz)                            \
2539 void MacroAssembler::atomic_##OP(Register prev, Register newv, Register addr) { \
2540   if (UseLSE) {                                                         \
2541     prev = prev-&gt;is_valid() ? prev : zr;                                \
2542     AOP(sz, newv, prev, addr);                                          \
2543     return;                                                             \
2544   }                                                                     \
2545   Register result = rscratch2;                                          \
2546   if (prev-&gt;is_valid())                                                 \
2547     result = different(prev, newv, addr) ? prev : rscratch2;            \
2548                                                                         \
2549   Label retry_load;                                                     \
2550   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))         \
2551     prfm(Address(addr), PSTL1STRM);                                     \
2552   bind(retry_load);                                                     \
2553   LDXR(result, addr);                                                   \
2554   STXR(rscratch1, newv, addr);                                          \
2555   cbnzw(rscratch1, retry_load);                                         \
2556   if (prev-&gt;is_valid() &amp;&amp; prev != result)                               \
2557     mov(prev, result);                                                  \
2558 }
2559 
2560 ATOMIC_XCHG(xchg, swp, ldxr, stxr, Assembler::xword)
2561 ATOMIC_XCHG(xchgw, swp, ldxrw, stxrw, Assembler::word)
2562 ATOMIC_XCHG(xchgal, swpal, ldaxr, stlxr, Assembler::xword)
2563 ATOMIC_XCHG(xchgalw, swpal, ldaxrw, stlxrw, Assembler::word)
2564 
2565 #undef ATOMIC_XCHG
2566 
2567 #ifndef PRODUCT
2568 extern &quot;C&quot; void findpc(intptr_t x);
2569 #endif
2570 
2571 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[])
2572 {
2573   // In order to get locks to work, we need to fake a in_VM state
2574   if (ShowMessageBoxOnError ) {
2575     JavaThread* thread = JavaThread::current();
2576     JavaThreadState saved_state = thread-&gt;thread_state();
2577     thread-&gt;set_thread_state(_thread_in_vm);
2578 #ifndef PRODUCT
2579     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
2580       ttyLocker ttyl;
2581       BytecodeCounter::print();
2582     }
2583 #endif
2584     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
2585       ttyLocker ttyl;
2586       tty-&gt;print_cr(&quot; pc = 0x%016lx&quot;, pc);
2587 #ifndef PRODUCT
2588       tty-&gt;cr();
2589       findpc(pc);
2590       tty-&gt;cr();
2591 #endif
2592       tty-&gt;print_cr(&quot; r0 = 0x%016lx&quot;, regs[0]);
2593       tty-&gt;print_cr(&quot; r1 = 0x%016lx&quot;, regs[1]);
2594       tty-&gt;print_cr(&quot; r2 = 0x%016lx&quot;, regs[2]);
2595       tty-&gt;print_cr(&quot; r3 = 0x%016lx&quot;, regs[3]);
2596       tty-&gt;print_cr(&quot; r4 = 0x%016lx&quot;, regs[4]);
2597       tty-&gt;print_cr(&quot; r5 = 0x%016lx&quot;, regs[5]);
2598       tty-&gt;print_cr(&quot; r6 = 0x%016lx&quot;, regs[6]);
2599       tty-&gt;print_cr(&quot; r7 = 0x%016lx&quot;, regs[7]);
2600       tty-&gt;print_cr(&quot; r8 = 0x%016lx&quot;, regs[8]);
2601       tty-&gt;print_cr(&quot; r9 = 0x%016lx&quot;, regs[9]);
2602       tty-&gt;print_cr(&quot;r10 = 0x%016lx&quot;, regs[10]);
2603       tty-&gt;print_cr(&quot;r11 = 0x%016lx&quot;, regs[11]);
2604       tty-&gt;print_cr(&quot;r12 = 0x%016lx&quot;, regs[12]);
2605       tty-&gt;print_cr(&quot;r13 = 0x%016lx&quot;, regs[13]);
2606       tty-&gt;print_cr(&quot;r14 = 0x%016lx&quot;, regs[14]);
2607       tty-&gt;print_cr(&quot;r15 = 0x%016lx&quot;, regs[15]);
2608       tty-&gt;print_cr(&quot;r16 = 0x%016lx&quot;, regs[16]);
2609       tty-&gt;print_cr(&quot;r17 = 0x%016lx&quot;, regs[17]);
2610       tty-&gt;print_cr(&quot;r18 = 0x%016lx&quot;, regs[18]);
2611       tty-&gt;print_cr(&quot;r19 = 0x%016lx&quot;, regs[19]);
2612       tty-&gt;print_cr(&quot;r20 = 0x%016lx&quot;, regs[20]);
2613       tty-&gt;print_cr(&quot;r21 = 0x%016lx&quot;, regs[21]);
2614       tty-&gt;print_cr(&quot;r22 = 0x%016lx&quot;, regs[22]);
2615       tty-&gt;print_cr(&quot;r23 = 0x%016lx&quot;, regs[23]);
2616       tty-&gt;print_cr(&quot;r24 = 0x%016lx&quot;, regs[24]);
2617       tty-&gt;print_cr(&quot;r25 = 0x%016lx&quot;, regs[25]);
2618       tty-&gt;print_cr(&quot;r26 = 0x%016lx&quot;, regs[26]);
2619       tty-&gt;print_cr(&quot;r27 = 0x%016lx&quot;, regs[27]);
2620       tty-&gt;print_cr(&quot;r28 = 0x%016lx&quot;, regs[28]);
2621       tty-&gt;print_cr(&quot;r30 = 0x%016lx&quot;, regs[30]);
2622       tty-&gt;print_cr(&quot;r31 = 0x%016lx&quot;, regs[31]);
2623       BREAKPOINT;
2624     }
2625   }
2626   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
2627 }
2628 
2629 void MacroAssembler::push_call_clobbered_registers() {
2630   int step = 4 * wordSize;
2631   push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
2632   sub(sp, sp, step);
2633   mov(rscratch1, -step);
2634   // Push v0-v7, v16-v31.
2635   for (int i = 31; i&gt;= 4; i -= 4) {
2636     if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
2637       st1(as_FloatRegister(i-3), as_FloatRegister(i-2), as_FloatRegister(i-1),
2638           as_FloatRegister(i), T1D, Address(post(sp, rscratch1)));
2639   }
2640   st1(as_FloatRegister(0), as_FloatRegister(1), as_FloatRegister(2),
2641       as_FloatRegister(3), T1D, Address(sp));
2642 }
2643 
2644 void MacroAssembler::pop_call_clobbered_registers() {
2645   for (int i = 0; i &lt; 32; i += 4) {
2646     if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
2647       ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2648           as_FloatRegister(i+3), T1D, Address(post(sp, 4 * wordSize)));
2649   }
2650 
2651   pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
2652 }
2653 
2654 void MacroAssembler::push_CPU_state(bool save_vectors) {
2655   int step = (save_vectors ? 8 : 4) * wordSize;
2656   push(0x3fffffff, sp);         // integer registers except lr &amp; sp
2657   mov(rscratch1, -step);
2658   sub(sp, sp, step);
2659   for (int i = 28; i &gt;= 4; i -= 4) {
2660     st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2661         as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));
2662   }
2663   st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);
2664 }
2665 
2666 void MacroAssembler::pop_CPU_state(bool restore_vectors) {
2667   int step = (restore_vectors ? 8 : 4) * wordSize;
2668   for (int i = 0; i &lt;= 28; i += 4)
2669     ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2670         as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));
2671   pop(0x3fffffff, sp);         // integer registers except lr &amp; sp
2672 }
2673 
2674 /**
2675  * Helpers for multiply_to_len().
2676  */
2677 void MacroAssembler::add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
2678                                      Register src1, Register src2) {
2679   adds(dest_lo, dest_lo, src1);
2680   adc(dest_hi, dest_hi, zr);
2681   adds(dest_lo, dest_lo, src2);
2682   adc(final_dest_hi, dest_hi, zr);
2683 }
2684 
2685 // Generate an address from (r + r1 extend offset).  &quot;size&quot; is the
2686 // size of the operand.  The result may be in rscratch2.
2687 Address MacroAssembler::offsetted_address(Register r, Register r1,
2688                                           Address::extend ext, int offset, int size) {
2689   if (offset || (ext.shift() % size != 0)) {
2690     lea(rscratch2, Address(r, r1, ext));
2691     return Address(rscratch2, offset);
2692   } else {
2693     return Address(r, r1, ext);
2694   }
2695 }
2696 
2697 Address MacroAssembler::spill_address(int size, int offset, Register tmp)
2698 {
2699   assert(offset &gt;= 0, &quot;spill to negative address?&quot;);
2700   // Offset reachable ?
2701   //   Not aligned - 9 bits signed offset
2702   //   Aligned - 12 bits unsigned offset shifted
2703   Register base = sp;
2704   if ((offset &amp; (size-1)) &amp;&amp; offset &gt;= (1&lt;&lt;8)) {
2705     add(tmp, base, offset &amp; ((1&lt;&lt;12)-1));
2706     base = tmp;
2707     offset &amp;= -1u&lt;&lt;12;
2708   }
2709 
2710   if (offset &gt;= (1&lt;&lt;12) * size) {
2711     add(tmp, base, offset &amp; (((1&lt;&lt;12)-1)&lt;&lt;12));
2712     base = tmp;
2713     offset &amp;= ~(((1&lt;&lt;12)-1)&lt;&lt;12);
2714   }
2715 
2716   return Address(base, offset);
2717 }
2718 
2719 // Checks whether offset is aligned.
2720 // Returns true if it is, else false.
2721 bool MacroAssembler::merge_alignment_check(Register base,
2722                                            size_t size,
2723                                            long cur_offset,
2724                                            long prev_offset) const {
2725   if (AvoidUnalignedAccesses) {
2726     if (base == sp) {
2727       // Checks whether low offset if aligned to pair of registers.
2728       long pair_mask = size * 2 - 1;
2729       long offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;
2730       return (offset &amp; pair_mask) == 0;
2731     } else { // If base is not sp, we can&#39;t guarantee the access is aligned.
2732       return false;
2733     }
2734   } else {
2735     long mask = size - 1;
2736     // Load/store pair instruction only supports element size aligned offset.
2737     return (cur_offset &amp; mask) == 0 &amp;&amp; (prev_offset &amp; mask) == 0;
2738   }
2739 }
2740 
2741 // Checks whether current and previous loads/stores can be merged.
2742 // Returns true if it can be merged, else false.
2743 bool MacroAssembler::ldst_can_merge(Register rt,
2744                                     const Address &amp;adr,
2745                                     size_t cur_size_in_bytes,
2746                                     bool is_store) const {
2747   address prev = pc() - NativeInstruction::instruction_size;
2748   address last = code()-&gt;last_insn();
2749 
2750   if (last == NULL || !nativeInstruction_at(last)-&gt;is_Imm_LdSt()) {
2751     return false;
2752   }
2753 
2754   if (adr.getMode() != Address::base_plus_offset || prev != last) {
2755     return false;
2756   }
2757 
2758   NativeLdSt* prev_ldst = NativeLdSt_at(prev);
2759   size_t prev_size_in_bytes = prev_ldst-&gt;size_in_bytes();
2760 
2761   assert(prev_size_in_bytes == 4 || prev_size_in_bytes == 8, &quot;only supports 64/32bit merging.&quot;);
2762   assert(cur_size_in_bytes == 4 || cur_size_in_bytes == 8, &quot;only supports 64/32bit merging.&quot;);
2763 
2764   if (cur_size_in_bytes != prev_size_in_bytes || is_store != prev_ldst-&gt;is_store()) {
2765     return false;
2766   }
2767 
2768   long max_offset = 63 * prev_size_in_bytes;
2769   long min_offset = -64 * prev_size_in_bytes;
2770 
2771   assert(prev_ldst-&gt;is_not_pre_post_index(), &quot;pre-index or post-index is not supported to be merged.&quot;);
2772 
2773   // Only same base can be merged.
2774   if (adr.base() != prev_ldst-&gt;base()) {
2775     return false;
2776   }
2777 
2778   long cur_offset = adr.offset();
2779   long prev_offset = prev_ldst-&gt;offset();
2780   size_t diff = abs(cur_offset - prev_offset);
2781   if (diff != prev_size_in_bytes) {
2782     return false;
2783   }
2784 
2785   // Following cases can not be merged:
2786   // ldr x2, [x2, #8]
2787   // ldr x3, [x2, #16]
2788   // or:
2789   // ldr x2, [x3, #8]
2790   // ldr x2, [x3, #16]
2791   // If t1 and t2 is the same in &quot;ldp t1, t2, [xn, #imm]&quot;, we&#39;ll get SIGILL.
2792   if (!is_store &amp;&amp; (adr.base() == prev_ldst-&gt;target() || rt == prev_ldst-&gt;target())) {
2793     return false;
2794   }
2795 
2796   long low_offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;
2797   // Offset range must be in ldp/stp instruction&#39;s range.
2798   if (low_offset &gt; max_offset || low_offset &lt; min_offset) {
2799     return false;
2800   }
2801 
2802   if (merge_alignment_check(adr.base(), prev_size_in_bytes, cur_offset, prev_offset)) {
2803     return true;
2804   }
2805 
2806   return false;
2807 }
2808 
2809 // Merge current load/store with previous load/store into ldp/stp.
2810 void MacroAssembler::merge_ldst(Register rt,
2811                                 const Address &amp;adr,
2812                                 size_t cur_size_in_bytes,
2813                                 bool is_store) {
2814 
2815   assert(ldst_can_merge(rt, adr, cur_size_in_bytes, is_store) == true, &quot;cur and prev must be able to be merged.&quot;);
2816 
2817   Register rt_low, rt_high;
2818   address prev = pc() - NativeInstruction::instruction_size;
2819   NativeLdSt* prev_ldst = NativeLdSt_at(prev);
2820 
2821   long offset;
2822 
2823   if (adr.offset() &lt; prev_ldst-&gt;offset()) {
2824     offset = adr.offset();
2825     rt_low = rt;
2826     rt_high = prev_ldst-&gt;target();
2827   } else {
2828     offset = prev_ldst-&gt;offset();
2829     rt_low = prev_ldst-&gt;target();
2830     rt_high = rt;
2831   }
2832 
2833   Address adr_p = Address(prev_ldst-&gt;base(), offset);
2834   // Overwrite previous generated binary.
2835   code_section()-&gt;set_end(prev);
2836 
2837   const int sz = prev_ldst-&gt;size_in_bytes();
2838   assert(sz == 8 || sz == 4, &quot;only supports 64/32bit merging.&quot;);
2839   if (!is_store) {
2840     BLOCK_COMMENT(&quot;merged ldr pair&quot;);
2841     if (sz == 8) {
2842       ldp(rt_low, rt_high, adr_p);
2843     } else {
2844       ldpw(rt_low, rt_high, adr_p);
2845     }
2846   } else {
2847     BLOCK_COMMENT(&quot;merged str pair&quot;);
2848     if (sz == 8) {
2849       stp(rt_low, rt_high, adr_p);
2850     } else {
2851       stpw(rt_low, rt_high, adr_p);
2852     }
2853   }
2854 }
2855 
2856 /**
2857  * Multiply 64 bit by 64 bit first loop.
2858  */
2859 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
2860                                            Register y, Register y_idx, Register z,
2861                                            Register carry, Register product,
2862                                            Register idx, Register kdx) {
2863   //
2864   //  jlong carry, x[], y[], z[];
2865   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
2866   //    huge_128 product = y[idx] * x[xstart] + carry;
2867   //    z[kdx] = (jlong)product;
2868   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
2869   //  }
2870   //  z[xstart] = carry;
2871   //
2872 
2873   Label L_first_loop, L_first_loop_exit;
2874   Label L_one_x, L_one_y, L_multiply;
2875 
2876   subsw(xstart, xstart, 1);
2877   br(Assembler::MI, L_one_x);
2878 
2879   lea(rscratch1, Address(x, xstart, Address::lsl(LogBytesPerInt)));
2880   ldr(x_xstart, Address(rscratch1));
2881   ror(x_xstart, x_xstart, 32); // convert big-endian to little-endian
2882 
2883   bind(L_first_loop);
2884   subsw(idx, idx, 1);
2885   br(Assembler::MI, L_first_loop_exit);
2886   subsw(idx, idx, 1);
2887   br(Assembler::MI, L_one_y);
2888   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2889   ldr(y_idx, Address(rscratch1));
2890   ror(y_idx, y_idx, 32); // convert big-endian to little-endian
2891   bind(L_multiply);
2892 
2893   // AArch64 has a multiply-accumulate instruction that we can&#39;t use
2894   // here because it has no way to process carries, so we have to use
2895   // separate add and adc instructions.  Bah.
2896   umulh(rscratch1, x_xstart, y_idx); // x_xstart * y_idx -&gt; rscratch1:product
2897   mul(product, x_xstart, y_idx);
2898   adds(product, product, carry);
2899   adc(carry, rscratch1, zr);   // x_xstart * y_idx + carry -&gt; carry:product
2900 
2901   subw(kdx, kdx, 2);
2902   ror(product, product, 32); // back to big-endian
2903   str(product, offsetted_address(z, kdx, Address::uxtw(LogBytesPerInt), 0, BytesPerLong));
2904 
2905   b(L_first_loop);
2906 
2907   bind(L_one_y);
2908   ldrw(y_idx, Address(y,  0));
2909   b(L_multiply);
2910 
2911   bind(L_one_x);
2912   ldrw(x_xstart, Address(x,  0));
2913   b(L_first_loop);
2914 
2915   bind(L_first_loop_exit);
2916 }
2917 
2918 /**
2919  * Multiply 128 bit by 128. Unrolled inner loop.
2920  *
2921  */
2922 void MacroAssembler::multiply_128_x_128_loop(Register y, Register z,
2923                                              Register carry, Register carry2,
2924                                              Register idx, Register jdx,
2925                                              Register yz_idx1, Register yz_idx2,
2926                                              Register tmp, Register tmp3, Register tmp4,
2927                                              Register tmp6, Register product_hi) {
2928 
2929   //   jlong carry, x[], y[], z[];
2930   //   int kdx = ystart+1;
2931   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
2932   //     huge_128 tmp3 = (y[idx+1] * product_hi) + z[kdx+idx+1] + carry;
2933   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
2934   //     huge_128 tmp4 = (y[idx]   * product_hi) + z[kdx+idx] + carry2;
2935   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
2936   //     z[kdx+idx+1] = (jlong)tmp3;
2937   //     z[kdx+idx] = (jlong)tmp4;
2938   //   }
2939   //   idx += 2;
2940   //   if (idx &gt; 0) {
2941   //     yz_idx1 = (y[idx] * product_hi) + z[kdx+idx] + carry;
2942   //     z[kdx+idx] = (jlong)yz_idx1;
2943   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
2944   //   }
2945   //
2946 
2947   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
2948 
2949   lsrw(jdx, idx, 2);
2950 
2951   bind(L_third_loop);
2952 
2953   subsw(jdx, jdx, 1);
2954   br(Assembler::MI, L_third_loop_exit);
2955   subw(idx, idx, 4);
2956 
2957   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2958 
2959   ldp(yz_idx2, yz_idx1, Address(rscratch1, 0));
2960 
2961   lea(tmp6, Address(z, idx, Address::uxtw(LogBytesPerInt)));
2962 
2963   ror(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
2964   ror(yz_idx2, yz_idx2, 32);
2965 
2966   ldp(rscratch2, rscratch1, Address(tmp6, 0));
2967 
2968   mul(tmp3, product_hi, yz_idx1);  //  yz_idx1 * product_hi -&gt; tmp4:tmp3
2969   umulh(tmp4, product_hi, yz_idx1);
2970 
2971   ror(rscratch1, rscratch1, 32); // convert big-endian to little-endian
2972   ror(rscratch2, rscratch2, 32);
2973 
2974   mul(tmp, product_hi, yz_idx2);   //  yz_idx2 * product_hi -&gt; carry2:tmp
2975   umulh(carry2, product_hi, yz_idx2);
2976 
2977   // propagate sum of both multiplications into carry:tmp4:tmp3
2978   adds(tmp3, tmp3, carry);
2979   adc(tmp4, tmp4, zr);
2980   adds(tmp3, tmp3, rscratch1);
2981   adcs(tmp4, tmp4, tmp);
2982   adc(carry, carry2, zr);
2983   adds(tmp4, tmp4, rscratch2);
2984   adc(carry, carry, zr);
2985 
2986   ror(tmp3, tmp3, 32); // convert little-endian to big-endian
2987   ror(tmp4, tmp4, 32);
2988   stp(tmp4, tmp3, Address(tmp6, 0));
2989 
2990   b(L_third_loop);
2991   bind (L_third_loop_exit);
2992 
2993   andw (idx, idx, 0x3);
2994   cbz(idx, L_post_third_loop_done);
2995 
2996   Label L_check_1;
2997   subsw(idx, idx, 2);
2998   br(Assembler::MI, L_check_1);
2999 
3000   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
3001   ldr(yz_idx1, Address(rscratch1, 0));
3002   ror(yz_idx1, yz_idx1, 32);
3003   mul(tmp3, product_hi, yz_idx1);  //  yz_idx1 * product_hi -&gt; tmp4:tmp3
3004   umulh(tmp4, product_hi, yz_idx1);
3005   lea(rscratch1, Address(z, idx, Address::uxtw(LogBytesPerInt)));
3006   ldr(yz_idx2, Address(rscratch1, 0));
3007   ror(yz_idx2, yz_idx2, 32);
3008 
3009   add2_with_carry(carry, tmp4, tmp3, carry, yz_idx2);
3010 
3011   ror(tmp3, tmp3, 32);
3012   str(tmp3, Address(rscratch1, 0));
3013 
3014   bind (L_check_1);
3015 
3016   andw (idx, idx, 0x1);
3017   subsw(idx, idx, 1);
3018   br(Assembler::MI, L_post_third_loop_done);
3019   ldrw(tmp4, Address(y, idx, Address::uxtw(LogBytesPerInt)));
3020   mul(tmp3, tmp4, product_hi);  //  tmp4 * product_hi -&gt; carry2:tmp3
3021   umulh(carry2, tmp4, product_hi);
3022   ldrw(tmp4, Address(z, idx, Address::uxtw(LogBytesPerInt)));
3023 
3024   add2_with_carry(carry2, tmp3, tmp4, carry);
3025 
3026   strw(tmp3, Address(z, idx, Address::uxtw(LogBytesPerInt)));
3027   extr(carry, carry2, tmp3, 32);
3028 
3029   bind(L_post_third_loop_done);
3030 }
3031 
3032 /**
3033  * Code for BigInteger::multiplyToLen() instrinsic.
3034  *
3035  * r0: x
3036  * r1: xlen
3037  * r2: y
3038  * r3: ylen
3039  * r4:  z
3040  * r5: zlen
3041  * r10: tmp1
3042  * r11: tmp2
3043  * r12: tmp3
3044  * r13: tmp4
3045  * r14: tmp5
3046  * r15: tmp6
3047  * r16: tmp7
3048  *
3049  */
3050 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen,
3051                                      Register z, Register zlen,
3052                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4,
3053                                      Register tmp5, Register tmp6, Register product_hi) {
3054 
3055   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);
3056 
3057   const Register idx = tmp1;
3058   const Register kdx = tmp2;
3059   const Register xstart = tmp3;
3060 
3061   const Register y_idx = tmp4;
3062   const Register carry = tmp5;
3063   const Register product  = xlen;
3064   const Register x_xstart = zlen;  // reuse register
3065 
3066   // First Loop.
3067   //
3068   //  final static long LONG_MASK = 0xffffffffL;
3069   //  int xstart = xlen - 1;
3070   //  int ystart = ylen - 1;
3071   //  long carry = 0;
3072   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
3073   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
3074   //    z[kdx] = (int)product;
3075   //    carry = product &gt;&gt;&gt; 32;
3076   //  }
3077   //  z[xstart] = (int)carry;
3078   //
3079 
3080   movw(idx, ylen);      // idx = ylen;
3081   movw(kdx, zlen);      // kdx = xlen+ylen;
3082   mov(carry, zr);       // carry = 0;
3083 
3084   Label L_done;
3085 
3086   movw(xstart, xlen);
3087   subsw(xstart, xstart, 1);
3088   br(Assembler::MI, L_done);
3089 
3090   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
3091 
3092   Label L_second_loop;
3093   cbzw(kdx, L_second_loop);
3094 
3095   Label L_carry;
3096   subw(kdx, kdx, 1);
3097   cbzw(kdx, L_carry);
3098 
3099   strw(carry, Address(z, kdx, Address::uxtw(LogBytesPerInt)));
3100   lsr(carry, carry, 32);
3101   subw(kdx, kdx, 1);
3102 
3103   bind(L_carry);
3104   strw(carry, Address(z, kdx, Address::uxtw(LogBytesPerInt)));
3105 
3106   // Second and third (nested) loops.
3107   //
3108   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
3109   //   carry = 0;
3110   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
3111   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
3112   //                    (z[k] &amp; LONG_MASK) + carry;
3113   //     z[k] = (int)product;
3114   //     carry = product &gt;&gt;&gt; 32;
3115   //   }
3116   //   z[i] = (int)carry;
3117   // }
3118   //
3119   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = product_hi
3120 
3121   const Register jdx = tmp1;
3122 
3123   bind(L_second_loop);
3124   mov(carry, zr);                // carry = 0;
3125   movw(jdx, ylen);               // j = ystart+1
3126 
3127   subsw(xstart, xstart, 1);      // i = xstart-1;
3128   br(Assembler::MI, L_done);
3129 
3130   str(z, Address(pre(sp, -4 * wordSize)));
3131 
3132   Label L_last_x;
3133   lea(z, offsetted_address(z, xstart, Address::uxtw(LogBytesPerInt), 4, BytesPerInt)); // z = z + k - j
3134   subsw(xstart, xstart, 1);       // i = xstart-1;
3135   br(Assembler::MI, L_last_x);
3136 
3137   lea(rscratch1, Address(x, xstart, Address::uxtw(LogBytesPerInt)));
3138   ldr(product_hi, Address(rscratch1));
3139   ror(product_hi, product_hi, 32);  // convert big-endian to little-endian
3140 
3141   Label L_third_loop_prologue;
3142   bind(L_third_loop_prologue);
3143 
3144   str(ylen, Address(sp, wordSize));
3145   stp(x, xstart, Address(sp, 2 * wordSize));
3146   multiply_128_x_128_loop(y, z, carry, x, jdx, ylen, product,
3147                           tmp2, x_xstart, tmp3, tmp4, tmp6, product_hi);
3148   ldp(z, ylen, Address(post(sp, 2 * wordSize)));
3149   ldp(x, xlen, Address(post(sp, 2 * wordSize)));   // copy old xstart -&gt; xlen
3150 
3151   addw(tmp3, xlen, 1);
3152   strw(carry, Address(z, tmp3, Address::uxtw(LogBytesPerInt)));
3153   subsw(tmp3, tmp3, 1);
3154   br(Assembler::MI, L_done);
3155 
3156   lsr(carry, carry, 32);
3157   strw(carry, Address(z, tmp3, Address::uxtw(LogBytesPerInt)));
3158   b(L_second_loop);
3159 
3160   // Next infrequent code is moved outside loops.
3161   bind(L_last_x);
3162   ldrw(product_hi, Address(x,  0));
3163   b(L_third_loop_prologue);
3164 
3165   bind(L_done);
3166 }
3167 
3168 // Code for BigInteger::mulAdd instrinsic
3169 // out     = r0
3170 // in      = r1
3171 // offset  = r2  (already out.length-offset)
3172 // len     = r3
3173 // k       = r4
3174 //
3175 // pseudo code from java implementation:
3176 // carry = 0;
3177 // offset = out.length-offset - 1;
3178 // for (int j=len-1; j &gt;= 0; j--) {
3179 //     product = (in[j] &amp; LONG_MASK) * kLong + (out[offset] &amp; LONG_MASK) + carry;
3180 //     out[offset--] = (int)product;
3181 //     carry = product &gt;&gt;&gt; 32;
3182 // }
3183 // return (int)carry;
3184 void MacroAssembler::mul_add(Register out, Register in, Register offset,
3185       Register len, Register k) {
3186     Label LOOP, END;
3187     // pre-loop
3188     cmp(len, zr); // cmp, not cbz/cbnz: to use condition twice =&gt; less branches
3189     csel(out, zr, out, Assembler::EQ);
3190     br(Assembler::EQ, END);
3191     add(in, in, len, LSL, 2); // in[j+1] address
3192     add(offset, out, offset, LSL, 2); // out[offset + 1] address
3193     mov(out, zr); // used to keep carry now
3194     BIND(LOOP);
3195     ldrw(rscratch1, Address(pre(in, -4)));
3196     madd(rscratch1, rscratch1, k, out);
3197     ldrw(rscratch2, Address(pre(offset, -4)));
3198     add(rscratch1, rscratch1, rscratch2);
3199     strw(rscratch1, Address(offset));
3200     lsr(out, rscratch1, 32);
3201     subs(len, len, 1);
3202     br(Assembler::NE, LOOP);
3203     BIND(END);
3204 }
3205 
3206 /**
3207  * Emits code to update CRC-32 with a byte value according to constants in table
3208  *
3209  * @param [in,out]crc   Register containing the crc.
3210  * @param [in]val       Register containing the byte to fold into the CRC.
3211  * @param [in]table     Register containing the table of crc constants.
3212  *
3213  * uint32_t crc;
3214  * val = crc_table[(val ^ crc) &amp; 0xFF];
3215  * crc = val ^ (crc &gt;&gt; 8);
3216  *
3217  */
3218 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
3219   eor(val, val, crc);
3220   andr(val, val, 0xff);
3221   ldrw(val, Address(table, val, Address::lsl(2)));
3222   eor(crc, val, crc, Assembler::LSR, 8);
3223 }
3224 
3225 /**
3226  * Emits code to update CRC-32 with a 32-bit value according to tables 0 to 3
3227  *
3228  * @param [in,out]crc   Register containing the crc.
3229  * @param [in]v         Register containing the 32-bit to fold into the CRC.
3230  * @param [in]table0    Register containing table 0 of crc constants.
3231  * @param [in]table1    Register containing table 1 of crc constants.
3232  * @param [in]table2    Register containing table 2 of crc constants.
3233  * @param [in]table3    Register containing table 3 of crc constants.
3234  *
3235  * uint32_t crc;
3236  *   v = crc ^ v
3237  *   crc = table3[v&amp;0xff]^table2[(v&gt;&gt;8)&amp;0xff]^table1[(v&gt;&gt;16)&amp;0xff]^table0[v&gt;&gt;24]
3238  *
3239  */
3240 void MacroAssembler::update_word_crc32(Register crc, Register v, Register tmp,
3241         Register table0, Register table1, Register table2, Register table3,
3242         bool upper) {
3243   eor(v, crc, v, upper ? LSR:LSL, upper ? 32:0);
3244   uxtb(tmp, v);
3245   ldrw(crc, Address(table3, tmp, Address::lsl(2)));
3246   ubfx(tmp, v, 8, 8);
3247   ldrw(tmp, Address(table2, tmp, Address::lsl(2)));
3248   eor(crc, crc, tmp);
3249   ubfx(tmp, v, 16, 8);
3250   ldrw(tmp, Address(table1, tmp, Address::lsl(2)));
3251   eor(crc, crc, tmp);
3252   ubfx(tmp, v, 24, 8);
3253   ldrw(tmp, Address(table0, tmp, Address::lsl(2)));
3254   eor(crc, crc, tmp);
3255 }
3256 
3257 void MacroAssembler::kernel_crc32_using_crc32(Register crc, Register buf,
3258         Register len, Register tmp0, Register tmp1, Register tmp2,
3259         Register tmp3) {
3260     Label CRC_by64_loop, CRC_by4_loop, CRC_by1_loop, CRC_less64, CRC_by64_pre, CRC_by32_loop, CRC_less32, L_exit;
3261     assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2, tmp3);
3262 
3263     mvnw(crc, crc);
3264 
3265     subs(len, len, 128);
3266     br(Assembler::GE, CRC_by64_pre);
3267   BIND(CRC_less64);
3268     adds(len, len, 128-32);
3269     br(Assembler::GE, CRC_by32_loop);
3270   BIND(CRC_less32);
3271     adds(len, len, 32-4);
3272     br(Assembler::GE, CRC_by4_loop);
3273     adds(len, len, 4);
3274     br(Assembler::GT, CRC_by1_loop);
3275     b(L_exit);
3276 
3277   BIND(CRC_by32_loop);
3278     ldp(tmp0, tmp1, Address(post(buf, 16)));
3279     subs(len, len, 32);
3280     crc32x(crc, crc, tmp0);
3281     ldr(tmp2, Address(post(buf, 8)));
3282     crc32x(crc, crc, tmp1);
3283     ldr(tmp3, Address(post(buf, 8)));
3284     crc32x(crc, crc, tmp2);
3285     crc32x(crc, crc, tmp3);
3286     br(Assembler::GE, CRC_by32_loop);
3287     cmn(len, 32);
3288     br(Assembler::NE, CRC_less32);
3289     b(L_exit);
3290 
3291   BIND(CRC_by4_loop);
3292     ldrw(tmp0, Address(post(buf, 4)));
3293     subs(len, len, 4);
3294     crc32w(crc, crc, tmp0);
3295     br(Assembler::GE, CRC_by4_loop);
3296     adds(len, len, 4);
3297     br(Assembler::LE, L_exit);
3298   BIND(CRC_by1_loop);
3299     ldrb(tmp0, Address(post(buf, 1)));
3300     subs(len, len, 1);
3301     crc32b(crc, crc, tmp0);
3302     br(Assembler::GT, CRC_by1_loop);
3303     b(L_exit);
3304 
3305   BIND(CRC_by64_pre);
3306     sub(buf, buf, 8);
3307     ldp(tmp0, tmp1, Address(buf, 8));
3308     crc32x(crc, crc, tmp0);
3309     ldr(tmp2, Address(buf, 24));
3310     crc32x(crc, crc, tmp1);
3311     ldr(tmp3, Address(buf, 32));
3312     crc32x(crc, crc, tmp2);
3313     ldr(tmp0, Address(buf, 40));
3314     crc32x(crc, crc, tmp3);
3315     ldr(tmp1, Address(buf, 48));
3316     crc32x(crc, crc, tmp0);
3317     ldr(tmp2, Address(buf, 56));
3318     crc32x(crc, crc, tmp1);
3319     ldr(tmp3, Address(pre(buf, 64)));
3320 
3321     b(CRC_by64_loop);
3322 
3323     align(CodeEntryAlignment);
3324   BIND(CRC_by64_loop);
3325     subs(len, len, 64);
3326     crc32x(crc, crc, tmp2);
3327     ldr(tmp0, Address(buf, 8));
3328     crc32x(crc, crc, tmp3);
3329     ldr(tmp1, Address(buf, 16));
3330     crc32x(crc, crc, tmp0);
3331     ldr(tmp2, Address(buf, 24));
3332     crc32x(crc, crc, tmp1);
3333     ldr(tmp3, Address(buf, 32));
3334     crc32x(crc, crc, tmp2);
3335     ldr(tmp0, Address(buf, 40));
3336     crc32x(crc, crc, tmp3);
3337     ldr(tmp1, Address(buf, 48));
3338     crc32x(crc, crc, tmp0);
3339     ldr(tmp2, Address(buf, 56));
3340     crc32x(crc, crc, tmp1);
3341     ldr(tmp3, Address(pre(buf, 64)));
3342     br(Assembler::GE, CRC_by64_loop);
3343 
3344     // post-loop
3345     crc32x(crc, crc, tmp2);
3346     crc32x(crc, crc, tmp3);
3347 
3348     sub(len, len, 64);
3349     add(buf, buf, 8);
3350     cmn(len, 128);
3351     br(Assembler::NE, CRC_less64);
3352   BIND(L_exit);
3353     mvnw(crc, crc);
3354 }
3355 
3356 /**
3357  * @param crc   register containing existing CRC (32-bit)
3358  * @param buf   register pointing to input byte buffer (byte*)
3359  * @param len   register containing number of bytes
3360  * @param table register that will contain address of CRC table
3361  * @param tmp   scratch register
3362  */
3363 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,
3364         Register table0, Register table1, Register table2, Register table3,
3365         Register tmp, Register tmp2, Register tmp3) {
3366   Label L_by16, L_by16_loop, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;
3367   unsigned long offset;
3368 
3369   if (UseCRC32) {
3370       kernel_crc32_using_crc32(crc, buf, len, table0, table1, table2, table3);
3371       return;
3372   }
3373 
3374     mvnw(crc, crc);
3375 
3376     adrp(table0, ExternalAddress(StubRoutines::crc_table_addr()), offset);
3377     if (offset) add(table0, table0, offset);
3378     add(table1, table0, 1*256*sizeof(juint));
3379     add(table2, table0, 2*256*sizeof(juint));
3380     add(table3, table0, 3*256*sizeof(juint));
3381 
3382   if (UseNeon) {
3383       cmp(len, (u1)64);
3384       br(Assembler::LT, L_by16);
3385       eor(v16, T16B, v16, v16);
3386 
3387     Label L_fold;
3388 
3389       add(tmp, table0, 4*256*sizeof(juint)); // Point at the Neon constants
3390 
3391       ld1(v0, v1, T2D, post(buf, 32));
3392       ld1r(v4, T2D, post(tmp, 8));
3393       ld1r(v5, T2D, post(tmp, 8));
3394       ld1r(v6, T2D, post(tmp, 8));
3395       ld1r(v7, T2D, post(tmp, 8));
3396       mov(v16, T4S, 0, crc);
3397 
3398       eor(v0, T16B, v0, v16);
3399       sub(len, len, 64);
3400 
3401     BIND(L_fold);
3402       pmull(v22, T8H, v0, v5, T8B);
3403       pmull(v20, T8H, v0, v7, T8B);
3404       pmull(v23, T8H, v0, v4, T8B);
3405       pmull(v21, T8H, v0, v6, T8B);
3406 
3407       pmull2(v18, T8H, v0, v5, T16B);
3408       pmull2(v16, T8H, v0, v7, T16B);
3409       pmull2(v19, T8H, v0, v4, T16B);
3410       pmull2(v17, T8H, v0, v6, T16B);
3411 
3412       uzp1(v24, T8H, v20, v22);
3413       uzp2(v25, T8H, v20, v22);
3414       eor(v20, T16B, v24, v25);
3415 
3416       uzp1(v26, T8H, v16, v18);
3417       uzp2(v27, T8H, v16, v18);
3418       eor(v16, T16B, v26, v27);
3419 
3420       ushll2(v22, T4S, v20, T8H, 8);
3421       ushll(v20, T4S, v20, T4H, 8);
3422 
3423       ushll2(v18, T4S, v16, T8H, 8);
3424       ushll(v16, T4S, v16, T4H, 8);
3425 
3426       eor(v22, T16B, v23, v22);
3427       eor(v18, T16B, v19, v18);
3428       eor(v20, T16B, v21, v20);
3429       eor(v16, T16B, v17, v16);
3430 
3431       uzp1(v17, T2D, v16, v20);
3432       uzp2(v21, T2D, v16, v20);
3433       eor(v17, T16B, v17, v21);
3434 
3435       ushll2(v20, T2D, v17, T4S, 16);
3436       ushll(v16, T2D, v17, T2S, 16);
3437 
3438       eor(v20, T16B, v20, v22);
3439       eor(v16, T16B, v16, v18);
3440 
3441       uzp1(v17, T2D, v20, v16);
3442       uzp2(v21, T2D, v20, v16);
3443       eor(v28, T16B, v17, v21);
3444 
3445       pmull(v22, T8H, v1, v5, T8B);
3446       pmull(v20, T8H, v1, v7, T8B);
3447       pmull(v23, T8H, v1, v4, T8B);
3448       pmull(v21, T8H, v1, v6, T8B);
3449 
3450       pmull2(v18, T8H, v1, v5, T16B);
3451       pmull2(v16, T8H, v1, v7, T16B);
3452       pmull2(v19, T8H, v1, v4, T16B);
3453       pmull2(v17, T8H, v1, v6, T16B);
3454 
3455       ld1(v0, v1, T2D, post(buf, 32));
3456 
3457       uzp1(v24, T8H, v20, v22);
3458       uzp2(v25, T8H, v20, v22);
3459       eor(v20, T16B, v24, v25);
3460 
3461       uzp1(v26, T8H, v16, v18);
3462       uzp2(v27, T8H, v16, v18);
3463       eor(v16, T16B, v26, v27);
3464 
3465       ushll2(v22, T4S, v20, T8H, 8);
3466       ushll(v20, T4S, v20, T4H, 8);
3467 
3468       ushll2(v18, T4S, v16, T8H, 8);
3469       ushll(v16, T4S, v16, T4H, 8);
3470 
3471       eor(v22, T16B, v23, v22);
3472       eor(v18, T16B, v19, v18);
3473       eor(v20, T16B, v21, v20);
3474       eor(v16, T16B, v17, v16);
3475 
3476       uzp1(v17, T2D, v16, v20);
3477       uzp2(v21, T2D, v16, v20);
3478       eor(v16, T16B, v17, v21);
3479 
3480       ushll2(v20, T2D, v16, T4S, 16);
3481       ushll(v16, T2D, v16, T2S, 16);
3482 
3483       eor(v20, T16B, v22, v20);
3484       eor(v16, T16B, v16, v18);
3485 
3486       uzp1(v17, T2D, v20, v16);
3487       uzp2(v21, T2D, v20, v16);
3488       eor(v20, T16B, v17, v21);
3489 
3490       shl(v16, T2D, v28, 1);
3491       shl(v17, T2D, v20, 1);
3492 
3493       eor(v0, T16B, v0, v16);
3494       eor(v1, T16B, v1, v17);
3495 
3496       subs(len, len, 32);
3497       br(Assembler::GE, L_fold);
3498 
3499       mov(crc, 0);
3500       mov(tmp, v0, T1D, 0);
3501       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3502       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3503       mov(tmp, v0, T1D, 1);
3504       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3505       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3506       mov(tmp, v1, T1D, 0);
3507       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3508       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3509       mov(tmp, v1, T1D, 1);
3510       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3511       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3512 
3513       add(len, len, 32);
3514   }
3515 
3516   BIND(L_by16);
3517     subs(len, len, 16);
3518     br(Assembler::GE, L_by16_loop);
3519     adds(len, len, 16-4);
3520     br(Assembler::GE, L_by4_loop);
3521     adds(len, len, 4);
3522     br(Assembler::GT, L_by1_loop);
3523     b(L_exit);
3524 
3525   BIND(L_by4_loop);
3526     ldrw(tmp, Address(post(buf, 4)));
3527     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3);
3528     subs(len, len, 4);
3529     br(Assembler::GE, L_by4_loop);
3530     adds(len, len, 4);
3531     br(Assembler::LE, L_exit);
3532   BIND(L_by1_loop);
3533     subs(len, len, 1);
3534     ldrb(tmp, Address(post(buf, 1)));
3535     update_byte_crc32(crc, tmp, table0);
3536     br(Assembler::GT, L_by1_loop);
3537     b(L_exit);
3538 
3539     align(CodeEntryAlignment);
3540   BIND(L_by16_loop);
3541     subs(len, len, 16);
3542     ldp(tmp, tmp3, Address(post(buf, 16)));
3543     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3544     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3545     update_word_crc32(crc, tmp3, tmp2, table0, table1, table2, table3, false);
3546     update_word_crc32(crc, tmp3, tmp2, table0, table1, table2, table3, true);
3547     br(Assembler::GE, L_by16_loop);
3548     adds(len, len, 16-4);
3549     br(Assembler::GE, L_by4_loop);
3550     adds(len, len, 4);
3551     br(Assembler::GT, L_by1_loop);
3552   BIND(L_exit);
3553     mvnw(crc, crc);
3554 }
3555 
3556 void MacroAssembler::kernel_crc32c_using_crc32c(Register crc, Register buf,
3557         Register len, Register tmp0, Register tmp1, Register tmp2,
3558         Register tmp3) {
3559     Label CRC_by64_loop, CRC_by4_loop, CRC_by1_loop, CRC_less64, CRC_by64_pre, CRC_by32_loop, CRC_less32, L_exit;
3560     assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2, tmp3);
3561 
3562     subs(len, len, 128);
3563     br(Assembler::GE, CRC_by64_pre);
3564   BIND(CRC_less64);
3565     adds(len, len, 128-32);
3566     br(Assembler::GE, CRC_by32_loop);
3567   BIND(CRC_less32);
3568     adds(len, len, 32-4);
3569     br(Assembler::GE, CRC_by4_loop);
3570     adds(len, len, 4);
3571     br(Assembler::GT, CRC_by1_loop);
3572     b(L_exit);
3573 
3574   BIND(CRC_by32_loop);
3575     ldp(tmp0, tmp1, Address(post(buf, 16)));
3576     subs(len, len, 32);
3577     crc32cx(crc, crc, tmp0);
3578     ldr(tmp2, Address(post(buf, 8)));
3579     crc32cx(crc, crc, tmp1);
3580     ldr(tmp3, Address(post(buf, 8)));
3581     crc32cx(crc, crc, tmp2);
3582     crc32cx(crc, crc, tmp3);
3583     br(Assembler::GE, CRC_by32_loop);
3584     cmn(len, 32);
3585     br(Assembler::NE, CRC_less32);
3586     b(L_exit);
3587 
3588   BIND(CRC_by4_loop);
3589     ldrw(tmp0, Address(post(buf, 4)));
3590     subs(len, len, 4);
3591     crc32cw(crc, crc, tmp0);
3592     br(Assembler::GE, CRC_by4_loop);
3593     adds(len, len, 4);
3594     br(Assembler::LE, L_exit);
3595   BIND(CRC_by1_loop);
3596     ldrb(tmp0, Address(post(buf, 1)));
3597     subs(len, len, 1);
3598     crc32cb(crc, crc, tmp0);
3599     br(Assembler::GT, CRC_by1_loop);
3600     b(L_exit);
3601 
3602   BIND(CRC_by64_pre);
3603     sub(buf, buf, 8);
3604     ldp(tmp0, tmp1, Address(buf, 8));
3605     crc32cx(crc, crc, tmp0);
3606     ldr(tmp2, Address(buf, 24));
3607     crc32cx(crc, crc, tmp1);
3608     ldr(tmp3, Address(buf, 32));
3609     crc32cx(crc, crc, tmp2);
3610     ldr(tmp0, Address(buf, 40));
3611     crc32cx(crc, crc, tmp3);
3612     ldr(tmp1, Address(buf, 48));
3613     crc32cx(crc, crc, tmp0);
3614     ldr(tmp2, Address(buf, 56));
3615     crc32cx(crc, crc, tmp1);
3616     ldr(tmp3, Address(pre(buf, 64)));
3617 
3618     b(CRC_by64_loop);
3619 
3620     align(CodeEntryAlignment);
3621   BIND(CRC_by64_loop);
3622     subs(len, len, 64);
3623     crc32cx(crc, crc, tmp2);
3624     ldr(tmp0, Address(buf, 8));
3625     crc32cx(crc, crc, tmp3);
3626     ldr(tmp1, Address(buf, 16));
3627     crc32cx(crc, crc, tmp0);
3628     ldr(tmp2, Address(buf, 24));
3629     crc32cx(crc, crc, tmp1);
3630     ldr(tmp3, Address(buf, 32));
3631     crc32cx(crc, crc, tmp2);
3632     ldr(tmp0, Address(buf, 40));
3633     crc32cx(crc, crc, tmp3);
3634     ldr(tmp1, Address(buf, 48));
3635     crc32cx(crc, crc, tmp0);
3636     ldr(tmp2, Address(buf, 56));
3637     crc32cx(crc, crc, tmp1);
3638     ldr(tmp3, Address(pre(buf, 64)));
3639     br(Assembler::GE, CRC_by64_loop);
3640 
3641     // post-loop
3642     crc32cx(crc, crc, tmp2);
3643     crc32cx(crc, crc, tmp3);
3644 
3645     sub(len, len, 64);
3646     add(buf, buf, 8);
3647     cmn(len, 128);
3648     br(Assembler::NE, CRC_less64);
3649   BIND(L_exit);
3650 }
3651 
3652 /**
3653  * @param crc   register containing existing CRC (32-bit)
3654  * @param buf   register pointing to input byte buffer (byte*)
3655  * @param len   register containing number of bytes
3656  * @param table register that will contain address of CRC table
3657  * @param tmp   scratch register
3658  */
3659 void MacroAssembler::kernel_crc32c(Register crc, Register buf, Register len,
3660         Register table0, Register table1, Register table2, Register table3,
3661         Register tmp, Register tmp2, Register tmp3) {
3662   kernel_crc32c_using_crc32c(crc, buf, len, table0, table1, table2, table3);
3663 }
3664 
3665 
3666 SkipIfEqual::SkipIfEqual(
3667     MacroAssembler* masm, const bool* flag_addr, bool value) {
3668   _masm = masm;
3669   unsigned long offset;
3670   _masm-&gt;adrp(rscratch1, ExternalAddress((address)flag_addr), offset);
3671   _masm-&gt;ldrb(rscratch1, Address(rscratch1, offset));
3672   _masm-&gt;cbzw(rscratch1, _label);
3673 }
3674 
3675 SkipIfEqual::~SkipIfEqual() {
3676   _masm-&gt;bind(_label);
3677 }
3678 
3679 void MacroAssembler::addptr(const Address &amp;dst, int32_t src) {
3680   Address adr;
3681   switch(dst.getMode()) {
3682   case Address::base_plus_offset:
3683     // This is the expected mode, although we allow all the other
3684     // forms below.
3685     adr = form_address(rscratch2, dst.base(), dst.offset(), LogBytesPerWord);
3686     break;
3687   default:
3688     lea(rscratch2, dst);
3689     adr = Address(rscratch2);
3690     break;
3691   }
3692   ldr(rscratch1, adr);
3693   add(rscratch1, rscratch1, src);
3694   str(rscratch1, adr);
3695 }
3696 
3697 void MacroAssembler::cmpptr(Register src1, Address src2) {
3698   unsigned long offset;
3699   adrp(rscratch1, src2, offset);
3700   ldr(rscratch1, Address(rscratch1, offset));
3701   cmp(src1, rscratch1);
3702 }
3703 
3704 void MacroAssembler::cmpoop(Register obj1, Register obj2) {
3705   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3706   bs-&gt;obj_equals(this, obj1, obj2);
3707 }
3708 
3709 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
3710   load_method_holder(rresult, rmethod);
3711   ldr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
3712 }
3713 
3714 void MacroAssembler::load_method_holder(Register holder, Register method) {
3715   ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
3716   ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
3717   ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
3718 }
3719 
3720 void MacroAssembler::load_klass(Register dst, Register src) {
3721   if (UseCompressedClassPointers) {
3722     ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3723     decode_klass_not_null(dst);
3724   } else {
3725     ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3726   }
3727 }
3728 
3729 // ((OopHandle)result).resolve();
3730 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3731   // OopHandle::resolve is an indirection.
3732   access_load_at(T_OBJECT, IN_NATIVE, result, Address(result, 0), tmp, noreg);
3733 }
3734 
3735 // ((WeakHandle)result).resolve();
3736 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
3737   assert_different_registers(rresult, rtmp);
3738   Label resolved;
3739 
3740   // A null weak handle resolves to null.
3741   cbz(rresult, resolved);
3742 
3743   // Only 64 bit platforms support GCs that require a tmp register
3744   // Only IN_HEAP loads require a thread_tmp register
3745   // WeakHandle::resolve is an indirection like jweak.
3746   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3747                  rresult, Address(rresult), rtmp, /*tmp_thread*/noreg);
3748   bind(resolved);
3749 }
3750 
3751 void MacroAssembler::load_mirror(Register dst, Register method, Register tmp) {
3752   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3753   ldr(dst, Address(rmethod, Method::const_offset()));
3754   ldr(dst, Address(dst, ConstMethod::constants_offset()));
3755   ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));
3756   ldr(dst, Address(dst, mirror_offset));
3757   resolve_oop_handle(dst, tmp);
3758 }
3759 
3760 void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
3761   if (UseCompressedClassPointers) {
3762     ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3763     if (CompressedKlassPointers::base() == NULL) {
3764       cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());
3765       return;
3766     } else if (((uint64_t)CompressedKlassPointers::base() &amp; 0xffffffff) == 0
3767                &amp;&amp; CompressedKlassPointers::shift() == 0) {
3768       // Only the bottom 32 bits matter
3769       cmpw(trial_klass, tmp);
3770       return;
3771     }
3772     decode_klass_not_null(tmp);
3773   } else {
3774     ldr(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3775   }
3776   cmp(trial_klass, tmp);
3777 }
3778 
3779 void MacroAssembler::load_prototype_header(Register dst, Register src) {
3780   load_klass(dst, src);
3781   ldr(dst, Address(dst, Klass::prototype_header_offset()));
3782 }
3783 
3784 void MacroAssembler::store_klass(Register dst, Register src) {
3785   // FIXME: Should this be a store release?  concurrent gcs assumes
3786   // klass length is valid if klass field is not null.
3787   if (UseCompressedClassPointers) {
3788     encode_klass_not_null(src);
3789     strw(src, Address(dst, oopDesc::klass_offset_in_bytes()));
3790   } else {
3791     str(src, Address(dst, oopDesc::klass_offset_in_bytes()));
3792   }
3793 }
3794 
3795 void MacroAssembler::store_klass_gap(Register dst, Register src) {
3796   if (UseCompressedClassPointers) {
3797     // Store to klass gap in destination
3798     strw(src, Address(dst, oopDesc::klass_gap_offset_in_bytes()));
3799   }
3800 }
3801 
3802 // Algorithm must match CompressedOops::encode.
3803 void MacroAssembler::encode_heap_oop(Register d, Register s) {
3804 #ifdef ASSERT
3805   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
3806 #endif
3807   verify_oop(s, &quot;broken oop in encode_heap_oop&quot;);
3808   if (CompressedOops::base() == NULL) {
3809     if (CompressedOops::shift() != 0) {
3810       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3811       lsr(d, s, LogMinObjAlignmentInBytes);
3812     } else {
3813       mov(d, s);
3814     }
3815   } else {
3816     subs(d, s, rheapbase);
3817     csel(d, d, zr, Assembler::HS);
3818     lsr(d, d, LogMinObjAlignmentInBytes);
3819 
3820     /*  Old algorithm: is this any worse?
3821     Label nonnull;
3822     cbnz(r, nonnull);
3823     sub(r, r, rheapbase);
3824     bind(nonnull);
3825     lsr(r, r, LogMinObjAlignmentInBytes);
3826     */
3827   }
3828 }
3829 
3830 void MacroAssembler::encode_heap_oop_not_null(Register r) {
3831 #ifdef ASSERT
3832   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
3833   if (CheckCompressedOops) {
3834     Label ok;
3835     cbnz(r, ok);
3836     stop(&quot;null oop passed to encode_heap_oop_not_null&quot;);
3837     bind(ok);
3838   }
3839 #endif
3840   verify_oop(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
3841   if (CompressedOops::base() != NULL) {
3842     sub(r, r, rheapbase);
3843   }
3844   if (CompressedOops::shift() != 0) {
3845     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3846     lsr(r, r, LogMinObjAlignmentInBytes);
3847   }
3848 }
3849 
3850 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
3851 #ifdef ASSERT
3852   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
3853   if (CheckCompressedOops) {
3854     Label ok;
3855     cbnz(src, ok);
3856     stop(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
3857     bind(ok);
3858   }
3859 #endif
3860   verify_oop(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
3861 
3862   Register data = src;
3863   if (CompressedOops::base() != NULL) {
3864     sub(dst, src, rheapbase);
3865     data = dst;
3866   }
3867   if (CompressedOops::shift() != 0) {
3868     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3869     lsr(dst, data, LogMinObjAlignmentInBytes);
3870     data = dst;
3871   }
3872   if (data == src)
3873     mov(dst, src);
3874 }
3875 
3876 void  MacroAssembler::decode_heap_oop(Register d, Register s) {
3877 #ifdef ASSERT
3878   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
3879 #endif
3880   if (CompressedOops::base() == NULL) {
3881     if (CompressedOops::shift() != 0 || d != s) {
3882       lsl(d, s, CompressedOops::shift());
3883     }
3884   } else {
3885     Label done;
3886     if (d != s)
3887       mov(d, s);
3888     cbz(s, done);
3889     add(d, rheapbase, s, Assembler::LSL, LogMinObjAlignmentInBytes);
3890     bind(done);
3891   }
3892   verify_oop(d, &quot;broken oop in decode_heap_oop&quot;);
3893 }
3894 
3895 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
3896   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
3897   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3898   // Cannot assert, unverified entry point counts instructions (see .ad file)
3899   // vtableStubs also counts instructions in pd_code_size_limit.
3900   // Also do not verify_oop as this is called by verify_oop.
3901   if (CompressedOops::shift() != 0) {
3902     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3903     if (CompressedOops::base() != NULL) {
3904       add(r, rheapbase, r, Assembler::LSL, LogMinObjAlignmentInBytes);
3905     } else {
3906       add(r, zr, r, Assembler::LSL, LogMinObjAlignmentInBytes);
3907     }
3908   } else {
3909     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
3910   }
3911 }
3912 
3913 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
3914   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
3915   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3916   // Cannot assert, unverified entry point counts instructions (see .ad file)
3917   // vtableStubs also counts instructions in pd_code_size_limit.
3918   // Also do not verify_oop as this is called by verify_oop.
3919   if (CompressedOops::shift() != 0) {
3920     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3921     if (CompressedOops::base() != NULL) {
3922       add(dst, rheapbase, src, Assembler::LSL, LogMinObjAlignmentInBytes);
3923     } else {
3924       add(dst, zr, src, Assembler::LSL, LogMinObjAlignmentInBytes);
3925     }
3926   } else {
3927     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
3928     if (dst != src) {
3929       mov(dst, src);
3930     }
3931   }
3932 }
3933 
3934 MacroAssembler::KlassDecodeMode MacroAssembler::_klass_decode_mode(KlassDecodeNone);
3935 
3936 MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode() {
3937   assert(UseCompressedClassPointers, &quot;not using compressed class pointers&quot;);
3938   assert(Metaspace::initialized(), &quot;metaspace not initialized yet&quot;);
3939 
3940   if (_klass_decode_mode != KlassDecodeNone) {
3941     return _klass_decode_mode;
3942   }
3943 
3944   assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift()
3945          || 0 == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
3946 
3947   if (CompressedKlassPointers::base() == NULL) {
3948     return (_klass_decode_mode = KlassDecodeZero);
3949   }
3950 
3951   if (operand_valid_for_logical_immediate(
3952         /*is32*/false, (uint64_t)CompressedKlassPointers::base())) {
3953     const uint64_t range_mask =
3954       (1UL &lt;&lt; log2_intptr(CompressedKlassPointers::range())) - 1;
3955     if (((uint64_t)CompressedKlassPointers::base() &amp; range_mask) == 0) {
3956       return (_klass_decode_mode = KlassDecodeXor);
3957     }
3958   }
3959 
3960   const uint64_t shifted_base =
3961     (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();
3962   guarantee((shifted_base &amp; 0xffff0000ffffffff) == 0,
3963             &quot;compressed class base bad alignment&quot;);
3964 
3965   return (_klass_decode_mode = KlassDecodeMovk);
3966 }
3967 
3968 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
3969   switch (klass_decode_mode()) {
3970   case KlassDecodeZero:
3971     if (CompressedKlassPointers::shift() != 0) {
3972       lsr(dst, src, LogKlassAlignmentInBytes);
3973     } else {
3974       if (dst != src) mov(dst, src);
3975     }
3976     break;
3977 
3978   case KlassDecodeXor:
3979     if (CompressedKlassPointers::shift() != 0) {
3980       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
3981       lsr(dst, dst, LogKlassAlignmentInBytes);
3982     } else {
3983       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
3984     }
3985     break;
3986 
3987   case KlassDecodeMovk:
3988     if (CompressedKlassPointers::shift() != 0) {
3989       ubfx(dst, src, LogKlassAlignmentInBytes, 32);
3990     } else {
3991       movw(dst, src);
3992     }
3993     break;
3994 
3995   case KlassDecodeNone:
3996     ShouldNotReachHere();
3997     break;
3998   }
3999 }
4000 
4001 void MacroAssembler::encode_klass_not_null(Register r) {
4002   encode_klass_not_null(r, r);
4003 }
4004 
4005 void  MacroAssembler::decode_klass_not_null(Register dst, Register src) {
4006   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4007 
4008   switch (klass_decode_mode()) {
4009   case KlassDecodeZero:
4010     if (CompressedKlassPointers::shift() != 0) {
4011       lsl(dst, src, LogKlassAlignmentInBytes);
4012     } else {
4013       if (dst != src) mov(dst, src);
4014     }
4015     break;
4016 
4017   case KlassDecodeXor:
4018     if (CompressedKlassPointers::shift() != 0) {
4019       lsl(dst, src, LogKlassAlignmentInBytes);
4020       eor(dst, dst, (uint64_t)CompressedKlassPointers::base());
4021     } else {
4022       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
4023     }
4024     break;
4025 
4026   case KlassDecodeMovk: {
4027     const uint64_t shifted_base =
4028       (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();
4029 
4030     if (dst != src) movw(dst, src);
4031     movk(dst, shifted_base &gt;&gt; 32, 32);
4032 
4033     if (CompressedKlassPointers::shift() != 0) {
4034       lsl(dst, dst, LogKlassAlignmentInBytes);
4035     }
4036 
4037     break;
4038   }
4039 
4040   case KlassDecodeNone:
4041     ShouldNotReachHere();
4042     break;
4043   }
4044 }
4045 
4046 void  MacroAssembler::decode_klass_not_null(Register r) {
4047   decode_klass_not_null(r, r);
4048 }
4049 
4050 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4051 #ifdef ASSERT
4052   {
4053     ThreadInVMfromUnknown tiv;
4054     assert (UseCompressedOops, &quot;should only be used for compressed oops&quot;);
4055     assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4056     assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4057     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4058   }
4059 #endif
4060   int oop_index = oop_recorder()-&gt;find_index(obj);
4061   InstructionMark im(this);
4062   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4063   code_section()-&gt;relocate(inst_mark(), rspec);
4064   movz(dst, 0xDEAD, 16);
4065   movk(dst, 0xBEEF);
4066 }
4067 
4068 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4069   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4070   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4071   int index = oop_recorder()-&gt;find_index(k);
4072   assert(! Universe::heap()-&gt;is_in(k), &quot;should not be an oop&quot;);
4073 
4074   InstructionMark im(this);
4075   RelocationHolder rspec = metadata_Relocation::spec(index);
4076   code_section()-&gt;relocate(inst_mark(), rspec);
4077   narrowKlass nk = CompressedKlassPointers::encode(k);
4078   movz(dst, (nk &gt;&gt; 16), 16);
4079   movk(dst, nk &amp; 0xffff);
4080 }
4081 
4082 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
4083                                     Register dst, Address src,
4084                                     Register tmp1, Register thread_tmp) {
4085   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4086   decorators = AccessInternal::decorator_fixup(decorators);
4087   bool as_raw = (decorators &amp; AS_RAW) != 0;
4088   if (as_raw) {
4089     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4090   } else {
4091     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4092   }
4093 }
4094 
4095 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
4096                                      Address dst, Register src,
4097                                      Register tmp1, Register thread_tmp) {
4098   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4099   decorators = AccessInternal::decorator_fixup(decorators);
4100   bool as_raw = (decorators &amp; AS_RAW) != 0;
4101   if (as_raw) {
4102     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4103   } else {
4104     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4105   }
4106 }
4107 
4108 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4109   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4110   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4111     decorators |= ACCESS_READ | ACCESS_WRITE;
4112   }
4113   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4114   return bs-&gt;resolve(this, decorators, obj);
4115 }
4116 
4117 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4118                                    Register thread_tmp, DecoratorSet decorators) {
4119   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4120 }
4121 
4122 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4123                                             Register thread_tmp, DecoratorSet decorators) {
4124   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4125 }
4126 
4127 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4128                                     Register thread_tmp, DecoratorSet decorators) {
4129   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4130 }
4131 
4132 // Used for storing NULLs.
4133 void MacroAssembler::store_heap_oop_null(Address dst) {
4134   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
4135 }
4136 
4137 Address MacroAssembler::allocate_metadata_address(Metadata* obj) {
4138   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
4139   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
4140   RelocationHolder rspec = metadata_Relocation::spec(index);
4141   return Address((address)obj, rspec);
4142 }
4143 
4144 // Move an oop into a register.  immediate is true if we want
4145 // immediate instructions and nmethod entry barriers are not enabled.
4146 // i.e. we are not going to patch this instruction while the code is being
4147 // executed by another thread.
4148 void MacroAssembler::movoop(Register dst, jobject obj, bool immediate) {
4149   int oop_index;
4150   if (obj == NULL) {
4151     oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
4152   } else {
4153 #ifdef ASSERT
4154     {
4155       ThreadInVMfromUnknown tiv;
4156       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4157     }
4158 #endif
4159     oop_index = oop_recorder()-&gt;find_index(obj);
4160   }
4161   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4162 
4163   // nmethod entry barrier necessitate using the constant pool. They have to be
4164   // ordered with respected to oop accesses.
4165   // Using immediate literals would necessitate ISBs.
4166   if (BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL || !immediate) {
4167     address dummy = address(uintptr_t(pc()) &amp; -wordSize); // A nearby aligned address
4168     ldr_constant(dst, Address(dummy, rspec));
4169   } else
4170     mov(dst, Address((address)obj, rspec));
4171 
4172 }
4173 
4174 // Move a metadata address into a register.
4175 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
4176   int oop_index;
4177   if (obj == NULL) {
4178     oop_index = oop_recorder()-&gt;allocate_metadata_index(obj);
4179   } else {
4180     oop_index = oop_recorder()-&gt;find_index(obj);
4181   }
4182   RelocationHolder rspec = metadata_Relocation::spec(oop_index);
4183   mov(dst, Address((address)obj, rspec));
4184 }
4185 
4186 Address MacroAssembler::constant_oop_address(jobject obj) {
4187 #ifdef ASSERT
4188   {
4189     ThreadInVMfromUnknown tiv;
4190     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4191     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
4192   }
4193 #endif
4194   int oop_index = oop_recorder()-&gt;find_index(obj);
4195   return Address((address)obj, oop_Relocation::spec(oop_index));
4196 }
4197 
4198 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
4199 void MacroAssembler::tlab_allocate(Register obj,
4200                                    Register var_size_in_bytes,
4201                                    int con_size_in_bytes,
4202                                    Register t1,
4203                                    Register t2,
4204                                    Label&amp; slow_case) {
4205   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4206   bs-&gt;tlab_allocate(this, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
4207 }
4208 
4209 // Defines obj, preserves var_size_in_bytes
4210 void MacroAssembler::eden_allocate(Register obj,
4211                                    Register var_size_in_bytes,
4212                                    int con_size_in_bytes,
4213                                    Register t1,
4214                                    Label&amp; slow_case) {
4215   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4216   bs-&gt;eden_allocate(this, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
4217 }
4218 
4219 // Zero words; len is in bytes
4220 // Destroys all registers except addr
4221 // len must be a nonzero multiple of wordSize
4222 void MacroAssembler::zero_memory(Register addr, Register len, Register t1) {
4223   assert_different_registers(addr, len, t1, rscratch1, rscratch2);
4224 
4225 #ifdef ASSERT
4226   { Label L;
4227     tst(len, BytesPerWord - 1);
4228     br(Assembler::EQ, L);
4229     stop(&quot;len is not a multiple of BytesPerWord&quot;);
4230     bind(L);
4231   }
4232 #endif
4233 
4234 #ifndef PRODUCT
4235   block_comment(&quot;zero memory&quot;);
4236 #endif
4237 
4238   Label loop;
4239   Label entry;
4240 
4241 //  Algorithm:
4242 //
4243 //    scratch1 = cnt &amp; 7;
4244 //    cnt -= scratch1;
4245 //    p += scratch1;
4246 //    switch (scratch1) {
4247 //      do {
4248 //        cnt -= 8;
4249 //          p[-8] = 0;
4250 //        case 7:
4251 //          p[-7] = 0;
4252 //        case 6:
4253 //          p[-6] = 0;
4254 //          // ...
4255 //        case 1:
4256 //          p[-1] = 0;
4257 //        case 0:
4258 //          p += 8;
4259 //      } while (cnt);
4260 //    }
4261 
4262   const int unroll = 8; // Number of str(zr) instructions we&#39;ll unroll
4263 
4264   lsr(len, len, LogBytesPerWord);
4265   andr(rscratch1, len, unroll - 1);  // tmp1 = cnt % unroll
4266   sub(len, len, rscratch1);      // cnt -= unroll
4267   // t1 always points to the end of the region we&#39;re about to zero
4268   add(t1, addr, rscratch1, Assembler::LSL, LogBytesPerWord);
4269   adr(rscratch2, entry);
4270   sub(rscratch2, rscratch2, rscratch1, Assembler::LSL, 2);
4271   br(rscratch2);
4272   bind(loop);
4273   sub(len, len, unroll);
4274   for (int i = -unroll; i &lt; 0; i++)
4275     Assembler::str(zr, Address(t1, i * wordSize));
4276   bind(entry);
4277   add(t1, t1, unroll * wordSize);
4278   cbnz(len, loop);
4279 }
4280 
4281 void MacroAssembler::verify_tlab() {
4282 #ifdef ASSERT
4283   if (UseTLAB &amp;&amp; VerifyOops) {
4284     Label next, ok;
4285 
4286     stp(rscratch2, rscratch1, Address(pre(sp, -16)));
4287 
4288     ldr(rscratch2, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
4289     ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_start_offset())));
4290     cmp(rscratch2, rscratch1);
4291     br(Assembler::HS, next);
4292     STOP(&quot;assert(top &gt;= start)&quot;);
4293     should_not_reach_here();
4294 
4295     bind(next);
4296     ldr(rscratch2, Address(rthread, in_bytes(JavaThread::tlab_end_offset())));
4297     ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
4298     cmp(rscratch2, rscratch1);
4299     br(Assembler::HS, ok);
4300     STOP(&quot;assert(top &lt;= end)&quot;);
4301     should_not_reach_here();
4302 
4303     bind(ok);
4304     ldp(rscratch2, rscratch1, Address(post(sp, 16)));
4305   }
4306 #endif
4307 }
4308 
4309 // Writes to stack successive pages until offset reached to check for
4310 // stack overflow + shadow pages.  This clobbers tmp.
4311 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
4312   assert_different_registers(tmp, size, rscratch1);
4313   mov(tmp, sp);
4314   // Bang stack for total size given plus shadow page size.
4315   // Bang one page at a time because large size can bang beyond yellow and
4316   // red zones.
4317   Label loop;
4318   mov(rscratch1, os::vm_page_size());
4319   bind(loop);
4320   lea(tmp, Address(tmp, -os::vm_page_size()));
4321   subsw(size, size, rscratch1);
4322   str(size, Address(tmp));
4323   br(Assembler::GT, loop);
4324 
4325   // Bang down shadow pages too.
4326   // At this point, (tmp-0) is the last address touched, so don&#39;t
4327   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
4328   // was post-decremented.)  Skip this address by starting at i=1, and
4329   // touch a few more pages below.  N.B.  It is important to touch all
4330   // the way down to and including i=StackShadowPages.
4331   for (int i = 0; i &lt; (int)(JavaThread::stack_shadow_zone_size() / os::vm_page_size()) - 1; i++) {
4332     // this could be any sized move but this is can be a debugging crumb
4333     // so the bigger the better.
4334     lea(tmp, Address(tmp, -os::vm_page_size()));
4335     str(size, Address(tmp));
4336   }
4337 }
4338 
4339 // Move the address of the polling page into dest.
4340 void MacroAssembler::get_polling_page(Register dest, relocInfo::relocType rtype) {
4341   ldr(dest, Address(rthread, Thread::polling_page_offset()));
4342 }
4343 
4344 // Move the address of the polling page into r, then read the polling
4345 // page.
4346 address MacroAssembler::fetch_and_read_polling_page(Register r, relocInfo::relocType rtype) {
4347   get_polling_page(r, rtype);
4348   return read_polling_page(r, rtype);
4349 }
4350 
4351 // Read the polling page.  The address of the polling page must
4352 // already be in r.
4353 address MacroAssembler::read_polling_page(Register r, relocInfo::relocType rtype) {
4354   InstructionMark im(this);
4355   code_section()-&gt;relocate(inst_mark(), rtype);
4356   ldrw(zr, Address(r, 0));
4357   return inst_mark();
4358 }
4359 
4360 void MacroAssembler::adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset) {
4361   relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
4362   unsigned long low_page = (unsigned long)CodeCache::low_bound() &gt;&gt; 12;
4363   unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) &gt;&gt; 12;
4364   unsigned long dest_page = (unsigned long)dest.target() &gt;&gt; 12;
4365   long offset_low = dest_page - low_page;
4366   long offset_high = dest_page - high_page;
4367 
4368   assert(is_valid_AArch64_address(dest.target()), &quot;bad address&quot;);
4369   assert(dest.getMode() == Address::literal, &quot;ADRP must be applied to a literal address&quot;);
4370 
4371   InstructionMark im(this);
4372   code_section()-&gt;relocate(inst_mark(), dest.rspec());
4373   // 8143067: Ensure that the adrp can reach the dest from anywhere within
4374   // the code cache so that if it is relocated we know it will still reach
4375   if (offset_high &gt;= -(1&lt;&lt;20) &amp;&amp; offset_low &lt; (1&lt;&lt;20)) {
4376     _adrp(reg1, dest.target());
4377   } else {
4378     unsigned long target = (unsigned long)dest.target();
4379     unsigned long adrp_target
4380       = (target &amp; 0xffffffffUL) | ((unsigned long)pc() &amp; 0xffff00000000UL);
4381 
4382     _adrp(reg1, (address)adrp_target);
4383     movk(reg1, target &gt;&gt; 32, 32);
4384   }
4385   byte_offset = (unsigned long)dest.target() &amp; 0xfff;
4386 }
4387 
4388 void MacroAssembler::load_byte_map_base(Register reg) {
4389   CardTable::CardValue* byte_map_base =
4390     ((CardTableBarrierSet*)(BarrierSet::barrier_set()))-&gt;card_table()-&gt;byte_map_base();
4391 
4392   if (is_valid_AArch64_address((address)byte_map_base)) {
4393     // Strictly speaking the byte_map_base isn&#39;t an address at all,
4394     // and it might even be negative.
4395     unsigned long offset;
4396     adrp(reg, ExternalAddress((address)byte_map_base), offset);
4397     // We expect offset to be zero with most collectors.
4398     if (offset != 0) {
4399       add(reg, reg, offset);
4400     }
4401   } else {
4402     mov(reg, (uint64_t)byte_map_base);
4403   }
4404 }
4405 
4406 void MacroAssembler::build_frame(int framesize) {
4407   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4408   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4409     sub(sp, sp, framesize);
4410     stp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4411     if (PreserveFramePointer) add(rfp, sp, framesize - 2 * wordSize);
4412   } else {
4413     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
4414     if (PreserveFramePointer) mov(rfp, sp);
4415     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4416       sub(sp, sp, framesize - 2 * wordSize);
4417     else {
4418       mov(rscratch1, framesize - 2 * wordSize);
4419       sub(sp, sp, rscratch1);
4420     }
4421   }
4422 }
4423 
4424 void MacroAssembler::remove_frame(int framesize) {
4425   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4426   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4427     ldp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4428     add(sp, sp, framesize);
4429   } else {
4430     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4431       add(sp, sp, framesize - 2 * wordSize);
4432     else {
4433       mov(rscratch1, framesize - 2 * wordSize);
4434       add(sp, sp, rscratch1);
4435     }
4436     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
4437   }
4438 }
4439 
4440 
4441 // This method checks if provided byte array contains byte with highest bit set.
4442 void MacroAssembler::has_negatives(Register ary1, Register len, Register result) {
4443     // Simple and most common case of aligned small array which is not at the
4444     // end of memory page is placed here. All other cases are in stub.
4445     Label LOOP, END, STUB, STUB_LONG, SET_RESULT, DONE;
4446     const uint64_t UPPER_BIT_MASK=0x8080808080808080;
4447     assert_different_registers(ary1, len, result);
4448 
4449     cmpw(len, 0);
4450     br(LE, SET_RESULT);
4451     cmpw(len, 4 * wordSize);
4452     br(GE, STUB_LONG); // size &gt; 32 then go to stub
4453 
4454     int shift = 64 - exact_log2(os::vm_page_size());
4455     lsl(rscratch1, ary1, shift);
4456     mov(rscratch2, (size_t)(4 * wordSize) &lt;&lt; shift);
4457     adds(rscratch2, rscratch1, rscratch2);  // At end of page?
4458     br(CS, STUB); // at the end of page then go to stub
4459     subs(len, len, wordSize);
4460     br(LT, END);
4461 
4462   BIND(LOOP);
4463     ldr(rscratch1, Address(post(ary1, wordSize)));
4464     tst(rscratch1, UPPER_BIT_MASK);
4465     br(NE, SET_RESULT);
4466     subs(len, len, wordSize);
4467     br(GE, LOOP);
4468     cmpw(len, -wordSize);
4469     br(EQ, SET_RESULT);
4470 
4471   BIND(END);
4472     ldr(result, Address(ary1));
4473     sub(len, zr, len, LSL, 3); // LSL 3 is to get bits from bytes
4474     lslv(result, result, len);
4475     tst(result, UPPER_BIT_MASK);
4476     b(SET_RESULT);
4477 
4478   BIND(STUB);
4479     RuntimeAddress has_neg =  RuntimeAddress(StubRoutines::aarch64::has_negatives());
4480     assert(has_neg.target() != NULL, &quot;has_negatives stub has not been generated&quot;);
4481     trampoline_call(has_neg);
4482     b(DONE);
4483 
4484   BIND(STUB_LONG);
4485     RuntimeAddress has_neg_long =  RuntimeAddress(
4486             StubRoutines::aarch64::has_negatives_long());
4487     assert(has_neg_long.target() != NULL, &quot;has_negatives stub has not been generated&quot;);
4488     trampoline_call(has_neg_long);
4489     b(DONE);
4490 
4491   BIND(SET_RESULT);
4492     cset(result, NE); // set true or false
4493 
4494   BIND(DONE);
4495 }
4496 
4497 void MacroAssembler::arrays_equals(Register a1, Register a2, Register tmp3,
4498                                    Register tmp4, Register tmp5, Register result,
4499                                    Register cnt1, int elem_size) {
4500   Label DONE, SAME;
4501   Register tmp1 = rscratch1;
4502   Register tmp2 = rscratch2;
4503   Register cnt2 = tmp2;  // cnt2 only used in array length compare
4504   int elem_per_word = wordSize/elem_size;
4505   int log_elem_size = exact_log2(elem_size);
4506   int length_offset = arrayOopDesc::length_offset_in_bytes();
4507   int base_offset
4508     = arrayOopDesc::base_offset_in_bytes(elem_size == 2 ? T_CHAR : T_BYTE);
4509   int stubBytesThreshold = 3 * 64 + (UseSIMDForArrayEquals ? 0 : 16);
4510 
4511   assert(elem_size == 1 || elem_size == 2, &quot;must be char or byte&quot;);
4512   assert_different_registers(a1, a2, result, cnt1, rscratch1, rscratch2);
4513 
4514 #ifndef PRODUCT
4515   {
4516     const char kind = (elem_size == 2) ? &#39;U&#39; : &#39;L&#39;;
4517     char comment[64];
4518     snprintf(comment, sizeof comment, &quot;array_equals%c{&quot;, kind);
4519     BLOCK_COMMENT(comment);
4520   }
4521 #endif
4522 
4523   // if (a1 == a2)
4524   //     return true;
4525   cmpoop(a1, a2); // May have read barriers for a1 and a2.
4526   br(EQ, SAME);
4527 
4528   if (UseSimpleArrayEquals) {
4529     Label NEXT_WORD, SHORT, TAIL03, TAIL01, A_MIGHT_BE_NULL, A_IS_NOT_NULL;
4530     // if (a1 == null || a2 == null)
4531     //     return false;
4532     // a1 &amp; a2 == 0 means (some-pointer is null) or
4533     // (very-rare-or-even-probably-impossible-pointer-values)
4534     // so, we can save one branch in most cases
4535     tst(a1, a2);
4536     mov(result, false);
4537     br(EQ, A_MIGHT_BE_NULL);
4538     // if (a1.length != a2.length)
4539     //      return false;
4540     bind(A_IS_NOT_NULL);
4541     ldrw(cnt1, Address(a1, length_offset));
4542     ldrw(cnt2, Address(a2, length_offset));
4543     eorw(tmp5, cnt1, cnt2);
4544     cbnzw(tmp5, DONE);
4545     lea(a1, Address(a1, base_offset));
4546     lea(a2, Address(a2, base_offset));
4547     // Check for short strings, i.e. smaller than wordSize.
4548     subs(cnt1, cnt1, elem_per_word);
4549     br(Assembler::LT, SHORT);
4550     // Main 8 byte comparison loop.
4551     bind(NEXT_WORD); {
4552       ldr(tmp1, Address(post(a1, wordSize)));
4553       ldr(tmp2, Address(post(a2, wordSize)));
4554       subs(cnt1, cnt1, elem_per_word);
4555       eor(tmp5, tmp1, tmp2);
4556       cbnz(tmp5, DONE);
4557     } br(GT, NEXT_WORD);
4558     // Last longword.  In the case where length == 4 we compare the
4559     // same longword twice, but that&#39;s still faster than another
4560     // conditional branch.
4561     // cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when
4562     // length == 4.
4563     if (log_elem_size &gt; 0)
4564       lsl(cnt1, cnt1, log_elem_size);
4565     ldr(tmp3, Address(a1, cnt1));
4566     ldr(tmp4, Address(a2, cnt1));
4567     eor(tmp5, tmp3, tmp4);
4568     cbnz(tmp5, DONE);
4569     b(SAME);
4570     bind(A_MIGHT_BE_NULL);
4571     // in case both a1 and a2 are not-null, proceed with loads
4572     cbz(a1, DONE);
4573     cbz(a2, DONE);
4574     b(A_IS_NOT_NULL);
4575     bind(SHORT);
4576 
4577     tbz(cnt1, 2 - log_elem_size, TAIL03); // 0-7 bytes left.
4578     {
4579       ldrw(tmp1, Address(post(a1, 4)));
4580       ldrw(tmp2, Address(post(a2, 4)));
4581       eorw(tmp5, tmp1, tmp2);
4582       cbnzw(tmp5, DONE);
4583     }
4584     bind(TAIL03);
4585     tbz(cnt1, 1 - log_elem_size, TAIL01); // 0-3 bytes left.
4586     {
4587       ldrh(tmp3, Address(post(a1, 2)));
4588       ldrh(tmp4, Address(post(a2, 2)));
4589       eorw(tmp5, tmp3, tmp4);
4590       cbnzw(tmp5, DONE);
4591     }
4592     bind(TAIL01);
4593     if (elem_size == 1) { // Only needed when comparing byte arrays.
4594       tbz(cnt1, 0, SAME); // 0-1 bytes left.
4595       {
4596         ldrb(tmp1, a1);
4597         ldrb(tmp2, a2);
4598         eorw(tmp5, tmp1, tmp2);
4599         cbnzw(tmp5, DONE);
4600       }
4601     }
4602   } else {
4603     Label NEXT_DWORD, SHORT, TAIL, TAIL2, STUB, EARLY_OUT,
4604         CSET_EQ, LAST_CHECK;
4605     mov(result, false);
4606     cbz(a1, DONE);
4607     ldrw(cnt1, Address(a1, length_offset));
4608     cbz(a2, DONE);
4609     ldrw(cnt2, Address(a2, length_offset));
4610     // on most CPUs a2 is still &quot;locked&quot;(surprisingly) in ldrw and it&#39;s
4611     // faster to perform another branch before comparing a1 and a2
4612     cmp(cnt1, (u1)elem_per_word);
4613     br(LE, SHORT); // short or same
4614     ldr(tmp3, Address(pre(a1, base_offset)));
4615     subs(zr, cnt1, stubBytesThreshold);
4616     br(GE, STUB);
4617     ldr(tmp4, Address(pre(a2, base_offset)));
4618     sub(tmp5, zr, cnt1, LSL, 3 + log_elem_size);
4619     cmp(cnt2, cnt1);
4620     br(NE, DONE);
4621 
4622     // Main 16 byte comparison loop with 2 exits
4623     bind(NEXT_DWORD); {
4624       ldr(tmp1, Address(pre(a1, wordSize)));
4625       ldr(tmp2, Address(pre(a2, wordSize)));
4626       subs(cnt1, cnt1, 2 * elem_per_word);
4627       br(LE, TAIL);
4628       eor(tmp4, tmp3, tmp4);
4629       cbnz(tmp4, DONE);
4630       ldr(tmp3, Address(pre(a1, wordSize)));
4631       ldr(tmp4, Address(pre(a2, wordSize)));
4632       cmp(cnt1, (u1)elem_per_word);
4633       br(LE, TAIL2);
4634       cmp(tmp1, tmp2);
4635     } br(EQ, NEXT_DWORD);
4636     b(DONE);
4637 
4638     bind(TAIL);
4639     eor(tmp4, tmp3, tmp4);
4640     eor(tmp2, tmp1, tmp2);
4641     lslv(tmp2, tmp2, tmp5);
4642     orr(tmp5, tmp4, tmp2);
4643     cmp(tmp5, zr);
4644     b(CSET_EQ);
4645 
4646     bind(TAIL2);
4647     eor(tmp2, tmp1, tmp2);
4648     cbnz(tmp2, DONE);
4649     b(LAST_CHECK);
4650 
4651     bind(STUB);
4652     ldr(tmp4, Address(pre(a2, base_offset)));
4653     cmp(cnt2, cnt1);
4654     br(NE, DONE);
4655     if (elem_size == 2) { // convert to byte counter
4656       lsl(cnt1, cnt1, 1);
4657     }
4658     eor(tmp5, tmp3, tmp4);
4659     cbnz(tmp5, DONE);
4660     RuntimeAddress stub = RuntimeAddress(StubRoutines::aarch64::large_array_equals());
4661     assert(stub.target() != NULL, &quot;array_equals_long stub has not been generated&quot;);
4662     trampoline_call(stub);
4663     b(DONE);
4664 
4665     bind(EARLY_OUT);
4666     // (a1 != null &amp;&amp; a2 == null) || (a1 != null &amp;&amp; a2 != null &amp;&amp; a1 == a2)
4667     // so, if a2 == null =&gt; return false(0), else return true, so we can return a2
4668     mov(result, a2);
4669     b(DONE);
4670     bind(SHORT);
4671     cmp(cnt2, cnt1);
4672     br(NE, DONE);
4673     cbz(cnt1, SAME);
4674     sub(tmp5, zr, cnt1, LSL, 3 + log_elem_size);
4675     ldr(tmp3, Address(a1, base_offset));
4676     ldr(tmp4, Address(a2, base_offset));
4677     bind(LAST_CHECK);
4678     eor(tmp4, tmp3, tmp4);
4679     lslv(tmp5, tmp4, tmp5);
4680     cmp(tmp5, zr);
4681     bind(CSET_EQ);
4682     cset(result, EQ);
4683     b(DONE);
4684   }
4685 
4686   bind(SAME);
4687   mov(result, true);
4688   // That&#39;s it.
4689   bind(DONE);
4690 
4691   BLOCK_COMMENT(&quot;} array_equals&quot;);
4692 }
4693 
4694 // Compare Strings
4695 
4696 // For Strings we&#39;re passed the address of the first characters in a1
4697 // and a2 and the length in cnt1.
4698 // elem_size is the element size in bytes: either 1 or 2.
4699 // There are two implementations.  For arrays &gt;= 8 bytes, all
4700 // comparisons (including the final one, which may overlap) are
4701 // performed 8 bytes at a time.  For strings &lt; 8 bytes, we compare a
4702 // halfword, then a short, and then a byte.
4703 
4704 void MacroAssembler::string_equals(Register a1, Register a2,
4705                                    Register result, Register cnt1, int elem_size)
4706 {
4707   Label SAME, DONE, SHORT, NEXT_WORD;
4708   Register tmp1 = rscratch1;
4709   Register tmp2 = rscratch2;
4710   Register cnt2 = tmp2;  // cnt2 only used in array length compare
4711 
4712   assert(elem_size == 1 || elem_size == 2, &quot;must be 2 or 1 byte&quot;);
4713   assert_different_registers(a1, a2, result, cnt1, rscratch1, rscratch2);
4714 
4715 #ifndef PRODUCT
4716   {
4717     const char kind = (elem_size == 2) ? &#39;U&#39; : &#39;L&#39;;
4718     char comment[64];
4719     snprintf(comment, sizeof comment, &quot;{string_equals%c&quot;, kind);
4720     BLOCK_COMMENT(comment);
4721   }
4722 #endif
4723 
4724   mov(result, false);
4725 
4726   // Check for short strings, i.e. smaller than wordSize.
4727   subs(cnt1, cnt1, wordSize);
4728   br(Assembler::LT, SHORT);
4729   // Main 8 byte comparison loop.
4730   bind(NEXT_WORD); {
4731     ldr(tmp1, Address(post(a1, wordSize)));
4732     ldr(tmp2, Address(post(a2, wordSize)));
4733     subs(cnt1, cnt1, wordSize);
4734     eor(tmp1, tmp1, tmp2);
4735     cbnz(tmp1, DONE);
4736   } br(GT, NEXT_WORD);
4737   // Last longword.  In the case where length == 4 we compare the
4738   // same longword twice, but that&#39;s still faster than another
4739   // conditional branch.
4740   // cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when
4741   // length == 4.
4742   ldr(tmp1, Address(a1, cnt1));
4743   ldr(tmp2, Address(a2, cnt1));
4744   eor(tmp2, tmp1, tmp2);
4745   cbnz(tmp2, DONE);
4746   b(SAME);
4747 
4748   bind(SHORT);
4749   Label TAIL03, TAIL01;
4750 
4751   tbz(cnt1, 2, TAIL03); // 0-7 bytes left.
4752   {
4753     ldrw(tmp1, Address(post(a1, 4)));
4754     ldrw(tmp2, Address(post(a2, 4)));
4755     eorw(tmp1, tmp1, tmp2);
4756     cbnzw(tmp1, DONE);
4757   }
4758   bind(TAIL03);
4759   tbz(cnt1, 1, TAIL01); // 0-3 bytes left.
4760   {
4761     ldrh(tmp1, Address(post(a1, 2)));
4762     ldrh(tmp2, Address(post(a2, 2)));
4763     eorw(tmp1, tmp1, tmp2);
4764     cbnzw(tmp1, DONE);
4765   }
4766   bind(TAIL01);
4767   if (elem_size == 1) { // Only needed when comparing 1-byte elements
4768     tbz(cnt1, 0, SAME); // 0-1 bytes left.
4769     {
4770       ldrb(tmp1, a1);
4771       ldrb(tmp2, a2);
4772       eorw(tmp1, tmp1, tmp2);
4773       cbnzw(tmp1, DONE);
4774     }
4775   }
4776   // Arrays are equal.
4777   bind(SAME);
4778   mov(result, true);
4779 
4780   // That&#39;s it.
4781   bind(DONE);
4782   BLOCK_COMMENT(&quot;} string_equals&quot;);
4783 }
4784 
4785 
4786 // The size of the blocks erased by the zero_blocks stub.  We must
4787 // handle anything smaller than this ourselves in zero_words().
4788 const int MacroAssembler::zero_words_block_size = 8;
4789 
4790 // zero_words() is used by C2 ClearArray patterns.  It is as small as
4791 // possible, handling small word counts locally and delegating
4792 // anything larger to the zero_blocks stub.  It is expanded many times
4793 // in compiled code, so it is important to keep it short.
4794 
4795 // ptr:   Address of a buffer to be zeroed.
4796 // cnt:   Count in HeapWords.
4797 //
4798 // ptr, cnt, rscratch1, and rscratch2 are clobbered.
4799 void MacroAssembler::zero_words(Register ptr, Register cnt)
4800 {
4801   assert(is_power_of_2(zero_words_block_size), &quot;adjust this&quot;);
4802   assert(ptr == r10 &amp;&amp; cnt == r11, &quot;mismatch in register usage&quot;);
4803 
4804   BLOCK_COMMENT(&quot;zero_words {&quot;);
4805   cmp(cnt, (u1)zero_words_block_size);
4806   Label around;
4807   br(LO, around);
4808   {
4809     RuntimeAddress zero_blocks =  RuntimeAddress(StubRoutines::aarch64::zero_blocks());
4810     assert(zero_blocks.target() != NULL, &quot;zero_blocks stub has not been generated&quot;);
4811     if (StubRoutines::aarch64::complete()) {
4812       trampoline_call(zero_blocks);
4813     } else {
4814       bl(zero_blocks);
4815     }
4816   }
4817   bind(around);
4818   for (int i = zero_words_block_size &gt;&gt; 1; i &gt; 1; i &gt;&gt;= 1) {
4819     Label l;
4820     tbz(cnt, exact_log2(i), l);
4821     for (int j = 0; j &lt; i; j += 2) {
4822       stp(zr, zr, post(ptr, 16));
4823     }
4824     bind(l);
4825   }
4826   {
4827     Label l;
4828     tbz(cnt, 0, l);
4829     str(zr, Address(ptr));
4830     bind(l);
4831   }
4832   BLOCK_COMMENT(&quot;} zero_words&quot;);
4833 }
4834 
4835 // base:         Address of a buffer to be zeroed, 8 bytes aligned.
4836 // cnt:          Immediate count in HeapWords.
4837 #define SmallArraySize (18 * BytesPerLong)
4838 void MacroAssembler::zero_words(Register base, u_int64_t cnt)
4839 {
4840   BLOCK_COMMENT(&quot;zero_words {&quot;);
4841   int i = cnt &amp; 1;  // store any odd word to start
4842   if (i) str(zr, Address(base));
4843 
4844   if (cnt &lt;= SmallArraySize / BytesPerLong) {
4845     for (; i &lt; (int)cnt; i += 2)
4846       stp(zr, zr, Address(base, i * wordSize));
4847   } else {
4848     const int unroll = 4; // Number of stp(zr, zr) instructions we&#39;ll unroll
4849     int remainder = cnt % (2 * unroll);
4850     for (; i &lt; remainder; i += 2)
4851       stp(zr, zr, Address(base, i * wordSize));
4852 
4853     Label loop;
4854     Register cnt_reg = rscratch1;
4855     Register loop_base = rscratch2;
4856     cnt = cnt - remainder;
4857     mov(cnt_reg, cnt);
4858     // adjust base and prebias by -2 * wordSize so we can pre-increment
4859     add(loop_base, base, (remainder - 2) * wordSize);
4860     bind(loop);
4861     sub(cnt_reg, cnt_reg, 2 * unroll);
4862     for (i = 1; i &lt; unroll; i++)
4863       stp(zr, zr, Address(loop_base, 2 * i * wordSize));
4864     stp(zr, zr, Address(pre(loop_base, 2 * unroll * wordSize)));
4865     cbnz(cnt_reg, loop);
4866   }
4867   BLOCK_COMMENT(&quot;} zero_words&quot;);
4868 }
4869 
4870 // Zero blocks of memory by using DC ZVA.
4871 //
4872 // Aligns the base address first sufficently for DC ZVA, then uses
4873 // DC ZVA repeatedly for every full block.  cnt is the size to be
4874 // zeroed in HeapWords.  Returns the count of words left to be zeroed
4875 // in cnt.
4876 //
4877 // NOTE: This is intended to be used in the zero_blocks() stub.  If
4878 // you want to use it elsewhere, note that cnt must be &gt;= 2*zva_length.
4879 void MacroAssembler::zero_dcache_blocks(Register base, Register cnt) {
4880   Register tmp = rscratch1;
4881   Register tmp2 = rscratch2;
4882   int zva_length = VM_Version::zva_length();
4883   Label initial_table_end, loop_zva;
4884   Label fini;
4885 
4886   // Base must be 16 byte aligned. If not just return and let caller handle it
4887   tst(base, 0x0f);
4888   br(Assembler::NE, fini);
4889   // Align base with ZVA length.
4890   neg(tmp, base);
4891   andr(tmp, tmp, zva_length - 1);
4892 
4893   // tmp: the number of bytes to be filled to align the base with ZVA length.
4894   add(base, base, tmp);
4895   sub(cnt, cnt, tmp, Assembler::ASR, 3);
4896   adr(tmp2, initial_table_end);
4897   sub(tmp2, tmp2, tmp, Assembler::LSR, 2);
4898   br(tmp2);
4899 
4900   for (int i = -zva_length + 16; i &lt; 0; i += 16)
4901     stp(zr, zr, Address(base, i));
4902   bind(initial_table_end);
4903 
4904   sub(cnt, cnt, zva_length &gt;&gt; 3);
4905   bind(loop_zva);
4906   dc(Assembler::ZVA, base);
4907   subs(cnt, cnt, zva_length &gt;&gt; 3);
4908   add(base, base, zva_length);
4909   br(Assembler::GE, loop_zva);
4910   add(cnt, cnt, zva_length &gt;&gt; 3); // count not zeroed by DC ZVA
4911   bind(fini);
4912 }
4913 
4914 // base:   Address of a buffer to be filled, 8 bytes aligned.
4915 // cnt:    Count in 8-byte unit.
4916 // value:  Value to be filled with.
4917 // base will point to the end of the buffer after filling.
4918 void MacroAssembler::fill_words(Register base, Register cnt, Register value)
4919 {
4920 //  Algorithm:
4921 //
4922 //    scratch1 = cnt &amp; 7;
4923 //    cnt -= scratch1;
4924 //    p += scratch1;
4925 //    switch (scratch1) {
4926 //      do {
4927 //        cnt -= 8;
4928 //          p[-8] = v;
4929 //        case 7:
4930 //          p[-7] = v;
4931 //        case 6:
4932 //          p[-6] = v;
4933 //          // ...
4934 //        case 1:
4935 //          p[-1] = v;
4936 //        case 0:
4937 //          p += 8;
4938 //      } while (cnt);
4939 //    }
4940 
4941   assert_different_registers(base, cnt, value, rscratch1, rscratch2);
4942 
4943   Label fini, skip, entry, loop;
4944   const int unroll = 8; // Number of stp instructions we&#39;ll unroll
4945 
4946   cbz(cnt, fini);
4947   tbz(base, 3, skip);
4948   str(value, Address(post(base, 8)));
4949   sub(cnt, cnt, 1);
4950   bind(skip);
4951 
4952   andr(rscratch1, cnt, (unroll-1) * 2);
4953   sub(cnt, cnt, rscratch1);
4954   add(base, base, rscratch1, Assembler::LSL, 3);
4955   adr(rscratch2, entry);
4956   sub(rscratch2, rscratch2, rscratch1, Assembler::LSL, 1);
4957   br(rscratch2);
4958 
4959   bind(loop);
4960   add(base, base, unroll * 16);
4961   for (int i = -unroll; i &lt; 0; i++)
4962     stp(value, value, Address(base, i * 16));
4963   bind(entry);
4964   subs(cnt, cnt, unroll * 2);
4965   br(Assembler::GE, loop);
4966 
4967   tbz(cnt, 0, fini);
4968   str(value, Address(post(base, 8)));
4969   bind(fini);
4970 }
4971 
4972 // Intrinsic for sun/nio/cs/ISO_8859_1$Encoder.implEncodeISOArray and
4973 // java/lang/StringUTF16.compress.
4974 void MacroAssembler::encode_iso_array(Register src, Register dst,
4975                       Register len, Register result,
4976                       FloatRegister Vtmp1, FloatRegister Vtmp2,
4977                       FloatRegister Vtmp3, FloatRegister Vtmp4)
4978 {
4979     Label DONE, SET_RESULT, NEXT_32, NEXT_32_PRFM, LOOP_8, NEXT_8, LOOP_1, NEXT_1,
4980         NEXT_32_START, NEXT_32_PRFM_START;
4981     Register tmp1 = rscratch1, tmp2 = rscratch2;
4982 
4983       mov(result, len); // Save initial len
4984 
4985       cmp(len, (u1)8); // handle shortest strings first
4986       br(LT, LOOP_1);
4987       cmp(len, (u1)32);
4988       br(LT, NEXT_8);
4989       // The following code uses the SIMD &#39;uzp1&#39; and &#39;uzp2&#39; instructions
4990       // to convert chars to bytes
4991       if (SoftwarePrefetchHintDistance &gt;= 0) {
4992         ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
4993         subs(tmp2, len, SoftwarePrefetchHintDistance/2 + 16);
4994         br(LE, NEXT_32_START);
4995         b(NEXT_32_PRFM_START);
4996         BIND(NEXT_32_PRFM);
4997           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
4998         BIND(NEXT_32_PRFM_START);
4999           prfm(Address(src, SoftwarePrefetchHintDistance));
5000           orr(v4, T16B, Vtmp1, Vtmp2);
5001           orr(v5, T16B, Vtmp3, Vtmp4);
5002           uzp1(Vtmp1, T16B, Vtmp1, Vtmp2);
5003           uzp1(Vtmp3, T16B, Vtmp3, Vtmp4);
5004           uzp2(v5, T16B, v4, v5); // high bytes
5005           umov(tmp2, v5, D, 1);
5006           fmovd(tmp1, v5);
5007           orr(tmp1, tmp1, tmp2);
5008           cbnz(tmp1, LOOP_8);
5009           stpq(Vtmp1, Vtmp3, dst);
5010           sub(len, len, 32);
5011           add(dst, dst, 32);
5012           add(src, src, 64);
5013           subs(tmp2, len, SoftwarePrefetchHintDistance/2 + 16);
5014           br(GE, NEXT_32_PRFM);
5015           cmp(len, (u1)32);
5016           br(LT, LOOP_8);
5017         BIND(NEXT_32);
5018           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5019         BIND(NEXT_32_START);
5020       } else {
5021         BIND(NEXT_32);
5022           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5023       }
5024       prfm(Address(src, SoftwarePrefetchHintDistance));
5025       uzp1(v4, T16B, Vtmp1, Vtmp2);
5026       uzp1(v5, T16B, Vtmp3, Vtmp4);
5027       orr(Vtmp1, T16B, Vtmp1, Vtmp2);
5028       orr(Vtmp3, T16B, Vtmp3, Vtmp4);
5029       uzp2(Vtmp1, T16B, Vtmp1, Vtmp3); // high bytes
5030       umov(tmp2, Vtmp1, D, 1);
5031       fmovd(tmp1, Vtmp1);
5032       orr(tmp1, tmp1, tmp2);
5033       cbnz(tmp1, LOOP_8);
5034       stpq(v4, v5, dst);
5035       sub(len, len, 32);
5036       add(dst, dst, 32);
5037       add(src, src, 64);
5038       cmp(len, (u1)32);
5039       br(GE, NEXT_32);
5040       cbz(len, DONE);
5041 
5042     BIND(LOOP_8);
5043       cmp(len, (u1)8);
5044       br(LT, LOOP_1);
5045     BIND(NEXT_8);
5046       ld1(Vtmp1, T8H, src);
5047       uzp1(Vtmp2, T16B, Vtmp1, Vtmp1); // low bytes
5048       uzp2(Vtmp3, T16B, Vtmp1, Vtmp1); // high bytes
5049       fmovd(tmp1, Vtmp3);
5050       cbnz(tmp1, NEXT_1);
5051       strd(Vtmp2, dst);
5052 
5053       sub(len, len, 8);
5054       add(dst, dst, 8);
5055       add(src, src, 16);
5056       cmp(len, (u1)8);
5057       br(GE, NEXT_8);
5058 
5059     BIND(LOOP_1);
5060 
5061     cbz(len, DONE);
5062     BIND(NEXT_1);
5063       ldrh(tmp1, Address(post(src, 2)));
5064       tst(tmp1, 0xff00);
5065       br(NE, SET_RESULT);
5066       strb(tmp1, Address(post(dst, 1)));
5067       subs(len, len, 1);
5068       br(GT, NEXT_1);
5069 
5070     BIND(SET_RESULT);
5071       sub(result, result, len); // Return index where we stopped
5072                                 // Return len == 0 if we processed all
5073                                 // characters
5074     BIND(DONE);
5075 }
5076 
5077 
5078 // Inflate byte[] array to char[].
5079 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
5080                                         FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,
5081                                         Register tmp4) {
5082   Label big, done, after_init, to_stub;
5083 
5084   assert_different_registers(src, dst, len, tmp4, rscratch1);
5085 
5086   fmovd(vtmp1, zr);
5087   lsrw(tmp4, len, 3);
5088   bind(after_init);
5089   cbnzw(tmp4, big);
5090   // Short string: less than 8 bytes.
5091   {
5092     Label loop, tiny;
5093 
5094     cmpw(len, 4);
5095     br(LT, tiny);
5096     // Use SIMD to do 4 bytes.
5097     ldrs(vtmp2, post(src, 4));
5098     zip1(vtmp3, T8B, vtmp2, vtmp1);
5099     subw(len, len, 4);
5100     strd(vtmp3, post(dst, 8));
5101 
5102     cbzw(len, done);
5103 
5104     // Do the remaining bytes by steam.
5105     bind(loop);
5106     ldrb(tmp4, post(src, 1));
5107     strh(tmp4, post(dst, 2));
5108     subw(len, len, 1);
5109 
5110     bind(tiny);
5111     cbnz(len, loop);
5112 
5113     b(done);
5114   }
5115 
5116   if (SoftwarePrefetchHintDistance &gt;= 0) {
5117     bind(to_stub);
5118       RuntimeAddress stub =  RuntimeAddress(StubRoutines::aarch64::large_byte_array_inflate());
5119       assert(stub.target() != NULL, &quot;large_byte_array_inflate stub has not been generated&quot;);
5120       trampoline_call(stub);
5121       b(after_init);
5122   }
5123 
5124   // Unpack the bytes 8 at a time.
5125   bind(big);
5126   {
5127     Label loop, around, loop_last, loop_start;
5128 
5129     if (SoftwarePrefetchHintDistance &gt;= 0) {
5130       const int large_loop_threshold = (64 + 16)/8;
5131       ldrd(vtmp2, post(src, 8));
5132       andw(len, len, 7);
5133       cmp(tmp4, (u1)large_loop_threshold);
5134       br(GE, to_stub);
5135       b(loop_start);
5136 
5137       bind(loop);
5138       ldrd(vtmp2, post(src, 8));
5139       bind(loop_start);
5140       subs(tmp4, tmp4, 1);
5141       br(EQ, loop_last);
5142       zip1(vtmp2, T16B, vtmp2, vtmp1);
5143       ldrd(vtmp3, post(src, 8));
5144       st1(vtmp2, T8H, post(dst, 16));
5145       subs(tmp4, tmp4, 1);
5146       zip1(vtmp3, T16B, vtmp3, vtmp1);
5147       st1(vtmp3, T8H, post(dst, 16));
5148       br(NE, loop);
5149       b(around);
5150       bind(loop_last);
5151       zip1(vtmp2, T16B, vtmp2, vtmp1);
5152       st1(vtmp2, T8H, post(dst, 16));
5153       bind(around);
5154       cbz(len, done);
5155     } else {
5156       andw(len, len, 7);
5157       bind(loop);
5158       ldrd(vtmp2, post(src, 8));
5159       sub(tmp4, tmp4, 1);
5160       zip1(vtmp3, T16B, vtmp2, vtmp1);
5161       st1(vtmp3, T8H, post(dst, 16));
5162       cbnz(tmp4, loop);
5163     }
5164   }
5165 
5166   // Do the tail of up to 8 bytes.
5167   add(src, src, len);
5168   ldrd(vtmp3, Address(src, -8));
5169   add(dst, dst, len, ext::uxtw, 1);
5170   zip1(vtmp3, T16B, vtmp3, vtmp1);
5171   strq(vtmp3, Address(dst, -16));
5172 
5173   bind(done);
5174 }
5175 
5176 // Compress char[] array to byte[].
5177 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
5178                                          FloatRegister tmp1Reg, FloatRegister tmp2Reg,
5179                                          FloatRegister tmp3Reg, FloatRegister tmp4Reg,
5180                                          Register result) {
5181   encode_iso_array(src, dst, len, result,
5182                    tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg);
5183   cmp(len, zr);
5184   csel(result, result, zr, EQ);
5185 }
5186 
5187 // get_thread() can be called anywhere inside generated code so we
5188 // need to save whatever non-callee save context might get clobbered
5189 // by the call to JavaThread::aarch64_get_thread_helper() or, indeed,
5190 // the call setup code.
5191 //
5192 // aarch64_get_thread_helper() clobbers only r0, r1, and flags.
5193 //
5194 void MacroAssembler::get_thread(Register dst) {
5195   RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;
5196   push(saved_regs, sp);
5197 
5198   mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));
5199   blr(lr);
5200   if (dst != c_rarg0) {
5201     mov(dst, c_rarg0);
5202   }
5203 
5204   pop(saved_regs, sp);
5205 }
5206 
5207 void MacroAssembler::cache_wb(Address line) {
5208   assert(line.getMode() == Address::base_plus_offset, &quot;mode should be base_plus_offset&quot;);
5209   assert(line.index() == noreg, &quot;index should be noreg&quot;);
5210   assert(line.offset() == 0, &quot;offset should be 0&quot;);
5211   // would like to assert this
5212   // assert(line._ext.shift == 0, &quot;shift should be zero&quot;);
5213   if (VM_Version::supports_dcpop()) {
5214     // writeback using clear virtual address to point of persistence
5215     dc(Assembler::CVAP, line.base());
5216   } else {
5217     // no need to generate anything as Unsafe.writebackMemory should
5218     // never invoke this stub
5219   }
5220 }
5221 
5222 void MacroAssembler::cache_wbsync(bool is_pre) {
5223   // we only need a barrier post sync
5224   if (!is_pre) {
5225     membar(Assembler::AnyAny);
5226   }
5227 }
    </pre>
  </body>
</html>