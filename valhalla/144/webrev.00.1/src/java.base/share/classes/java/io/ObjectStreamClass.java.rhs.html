<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/ObjectStreamClass.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.lang.invoke.MethodHandle;
  29 import java.lang.invoke.MethodHandles;
  30 import java.lang.invoke.MethodType;
  31 import java.lang.ref.Reference;
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.ref.SoftReference;
  34 import java.lang.ref.WeakReference;
  35 import java.lang.reflect.Constructor;
  36 import java.lang.reflect.Field;
<a name="1" id="anc1"></a><span class="line-added">  37 import java.lang.reflect.InaccessibleObjectException;</span>
  38 import java.lang.reflect.InvocationTargetException;
  39 import java.lang.reflect.RecordComponent;
  40 import java.lang.reflect.UndeclaredThrowableException;
  41 import java.lang.reflect.Member;
  42 import java.lang.reflect.Method;
  43 import java.lang.reflect.Modifier;
  44 import java.lang.reflect.Proxy;
  45 import java.security.AccessControlContext;
  46 import java.security.AccessController;
  47 import java.security.MessageDigest;
  48 import java.security.NoSuchAlgorithmException;
  49 import java.security.PermissionCollection;
  50 import java.security.Permissions;
  51 import java.security.PrivilegedAction;
  52 import java.security.PrivilegedActionException;
  53 import java.security.PrivilegedExceptionAction;
  54 import java.security.ProtectionDomain;
  55 import java.util.ArrayList;
  56 import java.util.Arrays;
  57 import java.util.Collections;
  58 import java.util.Comparator;
  59 import java.util.HashSet;
  60 import java.util.Map;
  61 import java.util.Set;
  62 import java.util.concurrent.ConcurrentHashMap;
  63 import java.util.concurrent.ConcurrentMap;
  64 import jdk.internal.misc.Unsafe;
  65 import jdk.internal.reflect.CallerSensitive;
  66 import jdk.internal.reflect.Reflection;
  67 import jdk.internal.reflect.ReflectionFactory;
  68 import jdk.internal.access.SharedSecrets;
  69 import jdk.internal.access.JavaSecurityAccess;
  70 import sun.reflect.misc.ReflectUtil;
  71 import static java.io.ObjectStreamField.*;
  72 
  73 /**
  74  * Serialization&#39;s descriptor for classes.  It contains the name and
  75  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  76  * loaded in this Java VM can be found/created using the lookup method.
  77  *
  78  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  79  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  80  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
  81  *
  82  * @author      Mike Warres
  83  * @author      Roger Riggs
  84  * @see ObjectStreamField
  85  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html&quot;&gt;
  86  *     Object Serialization Specification, Section 4, Class Descriptors&lt;/a&gt;
  87  * @since   1.1
  88  */
  89 public class ObjectStreamClass implements Serializable {
  90 
  91     /** serialPersistentFields value indicating no serializable fields */
  92     public static final ObjectStreamField[] NO_FIELDS =
  93         new ObjectStreamField[0];
  94 
  95     @java.io.Serial
  96     private static final long serialVersionUID = -6120832682080437368L;
  97     @java.io.Serial
  98     private static final ObjectStreamField[] serialPersistentFields =
  99         NO_FIELDS;
 100 
 101     /** reflection factory for obtaining serialization constructors */
 102     private static final ReflectionFactory reflFactory =
 103         AccessController.doPrivileged(
 104             new ReflectionFactory.GetReflectionFactoryAction());
 105 
 106     private static class Caches {
 107         /** cache mapping local classes -&gt; descriptors */
 108         static final ConcurrentMap&lt;WeakClassKey,Reference&lt;?&gt;&gt; localDescs =
 109             new ConcurrentHashMap&lt;&gt;();
 110 
 111         /** cache mapping field group/local desc pairs -&gt; field reflectors */
 112         static final ConcurrentMap&lt;FieldReflectorKey,Reference&lt;?&gt;&gt; reflectors =
 113             new ConcurrentHashMap&lt;&gt;();
 114 
 115         /** queue for WeakReferences to local classes */
 116         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; localDescsQueue =
 117             new ReferenceQueue&lt;&gt;();
 118         /** queue for WeakReferences to field reflectors keys */
 119         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; reflectorsQueue =
 120             new ReferenceQueue&lt;&gt;();
 121     }
 122 
 123     /** class associated with this descriptor (if any) */
 124     private Class&lt;?&gt; cl;
 125     /** name of class represented by this descriptor */
 126     private String name;
 127     /** serialVersionUID of represented class (null if not computed yet) */
 128     private volatile Long suid;
 129 
 130     /** true if represents dynamic proxy class */
 131     private boolean isProxy;
 132     /** true if represents enum type */
 133     private boolean isEnum;
 134     /** true if represents record type */
 135     private boolean isRecord;
 136     /** true if represented class implements Serializable */
 137     private boolean serializable;
 138     /** true if represented class implements Externalizable */
 139     private boolean externalizable;
 140     /** true if desc has data written by class-defined writeObject method */
 141     private boolean hasWriteObjectData;
 142     /**
 143      * true if desc has externalizable data written in block data format; this
 144      * must be true by default to accommodate ObjectInputStream subclasses which
 145      * override readClassDescriptor() to return class descriptors obtained from
 146      * ObjectStreamClass.lookup() (see 4461737)
 147      */
 148     private boolean hasBlockExternalData = true;
 149 
 150     /**
 151      * Contains information about InvalidClassException instances to be thrown
 152      * when attempting operations on an invalid class. Note that instances of
 153      * this class are immutable and are potentially shared among
 154      * ObjectStreamClass instances.
 155      */
 156     private static class ExceptionInfo {
 157         private final String className;
 158         private final String message;
 159 
 160         ExceptionInfo(String cn, String msg) {
 161             className = cn;
 162             message = msg;
 163         }
 164 
 165         /**
 166          * Returns (does not throw) an InvalidClassException instance created
 167          * from the information in this object, suitable for being thrown by
 168          * the caller.
 169          */
 170         InvalidClassException newInvalidClassException() {
 171             return new InvalidClassException(className, message);
 172         }
 173     }
 174 
 175     /** exception (if any) thrown while attempting to resolve class */
 176     private ClassNotFoundException resolveEx;
 177     /** exception (if any) to throw if non-enum deserialization attempted */
 178     private ExceptionInfo deserializeEx;
 179     /** exception (if any) to throw if non-enum serialization attempted */
 180     private ExceptionInfo serializeEx;
 181     /** exception (if any) to throw if default serialization attempted */
 182     private ExceptionInfo defaultSerializeEx;
 183 
 184     /** serializable fields */
 185     private ObjectStreamField[] fields;
 186     /** aggregate marshalled size of primitive fields */
 187     private int primDataSize;
 188     /** number of non-primitive fields */
 189     private int numObjFields;
 190     /** reflector for setting/getting serializable field values */
 191     private FieldReflector fieldRefl;
 192     /** data layout of serialized objects described by this class desc */
 193     private volatile ClassDataSlot[] dataLayout;
 194 
 195     /** serialization-appropriate constructor, or null if none */
 196     private Constructor&lt;?&gt; cons;
 197     /** record canonical constructor (shared among OSCs for same class), or null */
 198     private MethodHandle canonicalCtr;
 199     /** cache of record deserialization constructors per unique set of stream fields
 200      * (shared among OSCs for same class), or null */
 201     private DeserializationConstructorsCache deserializationCtrs;
 202     /** session-cache of record deserialization constructor
 203      * (in de-serialized OSC only), or null */
 204     private MethodHandle deserializationCtr;
 205     /** protection domains that need to be checked when calling the constructor */
 206     private ProtectionDomain[] domains;
 207 
 208     /** class-defined writeObject method, or null if none */
 209     private Method writeObjectMethod;
 210     /** class-defined readObject method, or null if none */
 211     private Method readObjectMethod;
 212     /** class-defined readObjectNoData method, or null if none */
 213     private Method readObjectNoDataMethod;
 214     /** class-defined writeReplace method, or null if none */
 215     private Method writeReplaceMethod;
 216     /** class-defined readResolve method, or null if none */
 217     private Method readResolveMethod;
 218 
 219     /** local class descriptor for represented class (may point to self) */
 220     private ObjectStreamClass localDesc;
 221     /** superclass descriptor appearing in stream */
 222     private ObjectStreamClass superDesc;
 223 
 224     /** true if, and only if, the object has been correctly initialized */
 225     private boolean initialized;
 226 
 227     /**
 228      * Initializes native code.
 229      */
 230     private static native void initNative();
 231     static {
 232         initNative();
 233     }
 234 
 235     /**
 236      * Find the descriptor for a class that can be serialized.  Creates an
 237      * ObjectStreamClass instance if one does not exist yet for class. Null is
 238      * returned if the specified class does not implement java.io.Serializable
 239      * or java.io.Externalizable.
 240      *
 241      * @param   cl class for which to get the descriptor
 242      * @return  the class descriptor for the specified class
 243      */
 244     public static ObjectStreamClass lookup(Class&lt;?&gt; cl) {
 245         return lookup(cl, false);
 246     }
 247 
 248     /**
 249      * Returns the descriptor for any class, regardless of whether it
 250      * implements {@link Serializable}.
 251      *
 252      * @param        cl class for which to get the descriptor
 253      * @return       the class descriptor for the specified class
 254      * @since 1.6
 255      */
 256     public static ObjectStreamClass lookupAny(Class&lt;?&gt; cl) {
 257         return lookup(cl, true);
 258     }
 259 
 260     /**
 261      * Returns the name of the class described by this descriptor.
 262      * This method returns the name of the class in the format that
 263      * is used by the {@link Class#getName} method.
 264      *
 265      * @return a string representing the name of the class
 266      */
 267     public String getName() {
 268         return name;
 269     }
 270 
 271     /**
 272      * Return the serialVersionUID for this class.  The serialVersionUID
 273      * defines a set of classes all with the same name that have evolved from a
 274      * common root class and agree to be serialized and deserialized using a
 275      * common format.  NonSerializable classes have a serialVersionUID of 0L.
 276      *
 277      * @return  the SUID of the class described by this descriptor
 278      */
 279     public long getSerialVersionUID() {
 280         // REMIND: synchronize instead of relying on volatile?
 281         if (suid == null) {
 282             if (isRecord)
 283                 return 0L;
 284 
 285             suid = AccessController.doPrivileged(
 286                 new PrivilegedAction&lt;Long&gt;() {
 287                     public Long run() {
 288                         return computeDefaultSUID(cl);
 289                     }
 290                 }
 291             );
 292         }
 293         return suid.longValue();
 294     }
 295 
 296     /**
 297      * Return the class in the local VM that this version is mapped to.  Null
 298      * is returned if there is no corresponding local class.
 299      *
 300      * @return  the {@code Class} instance that this descriptor represents
 301      */
 302     @CallerSensitive
 303     public Class&lt;?&gt; forClass() {
 304         if (cl == null) {
 305             return null;
 306         }
 307         requireInitialized();
 308         if (System.getSecurityManager() != null) {
 309             Class&lt;?&gt; caller = Reflection.getCallerClass();
 310             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), cl.getClassLoader())) {
 311                 ReflectUtil.checkPackageAccess(cl);
 312             }
 313         }
 314         return cl;
 315     }
 316 
 317     /**
 318      * Return an array of the fields of this serializable class.
 319      *
 320      * @return  an array containing an element for each persistent field of
 321      *          this class. Returns an array of length zero if there are no
 322      *          fields.
 323      * @since 1.2
 324      */
 325     public ObjectStreamField[] getFields() {
 326         return getFields(true);
 327     }
 328 
 329     /**
 330      * Get the field of this class by name.
 331      *
 332      * @param   name the name of the data field to look for
 333      * @return  The ObjectStreamField object of the named field or null if
 334      *          there is no such named field.
 335      */
 336     public ObjectStreamField getField(String name) {
 337         return getField(name, null);
 338     }
 339 
 340     /**
 341      * Return a string describing this ObjectStreamClass.
 342      */
 343     public String toString() {
 344         return name + &quot;: static final long serialVersionUID = &quot; +
 345             getSerialVersionUID() + &quot;L;&quot;;
 346     }
 347 
 348     /**
 349      * Looks up and returns class descriptor for given class, or null if class
 350      * is non-serializable and &quot;all&quot; is set to false.
 351      *
 352      * @param   cl class to look up
 353      * @param   all if true, return descriptors for all classes; if false, only
 354      *          return descriptors for serializable classes
 355      */
 356     static ObjectStreamClass lookup(Class&lt;?&gt; cl, boolean all) {
 357         if (!(all || Serializable.class.isAssignableFrom(cl))) {
 358             return null;
 359         }
 360         processQueue(Caches.localDescsQueue, Caches.localDescs);
 361         WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);
 362         Reference&lt;?&gt; ref = Caches.localDescs.get(key);
 363         Object entry = null;
 364         if (ref != null) {
 365             entry = ref.get();
 366         }
 367         EntryFuture future = null;
 368         if (entry == null) {
 369             EntryFuture newEntry = new EntryFuture();
 370             Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);
 371             do {
 372                 if (ref != null) {
 373                     Caches.localDescs.remove(key, ref);
 374                 }
 375                 ref = Caches.localDescs.putIfAbsent(key, newRef);
 376                 if (ref != null) {
 377                     entry = ref.get();
 378                 }
 379             } while (ref != null &amp;&amp; entry == null);
 380             if (entry == null) {
 381                 future = newEntry;
 382             }
 383         }
 384 
 385         if (entry instanceof ObjectStreamClass) {  // check common case first
 386             return (ObjectStreamClass) entry;
 387         }
 388         if (entry instanceof EntryFuture) {
 389             future = (EntryFuture) entry;
 390             if (future.getOwner() == Thread.currentThread()) {
 391                 /*
 392                  * Handle nested call situation described by 4803747: waiting
 393                  * for future value to be set by a lookup() call further up the
 394                  * stack will result in deadlock, so calculate and set the
 395                  * future value here instead.
 396                  */
 397                 entry = null;
 398             } else {
 399                 entry = future.get();
 400             }
 401         }
 402         if (entry == null) {
 403             try {
 404                 entry = new ObjectStreamClass(cl);
 405             } catch (Throwable th) {
 406                 entry = th;
 407             }
 408             if (future.set(entry)) {
 409                 Caches.localDescs.put(key, new SoftReference&lt;&gt;(entry));
 410             } else {
 411                 // nested lookup call already set future
 412                 entry = future.get();
 413             }
 414         }
 415 
 416         if (entry instanceof ObjectStreamClass) {
 417             return (ObjectStreamClass) entry;
 418         } else if (entry instanceof RuntimeException) {
 419             throw (RuntimeException) entry;
 420         } else if (entry instanceof Error) {
 421             throw (Error) entry;
 422         } else {
 423             throw new InternalError(&quot;unexpected entry: &quot; + entry);
 424         }
 425     }
 426 
 427     /**
 428      * Placeholder used in class descriptor and field reflector lookup tables
 429      * for an entry in the process of being initialized.  (Internal) callers
 430      * which receive an EntryFuture belonging to another thread as the result
 431      * of a lookup should call the get() method of the EntryFuture; this will
 432      * return the actual entry once it is ready for use and has been set().  To
 433      * conserve objects, EntryFutures synchronize on themselves.
 434      */
 435     private static class EntryFuture {
 436 
 437         private static final Object unset = new Object();
 438         private final Thread owner = Thread.currentThread();
 439         private Object entry = unset;
 440 
 441         /**
 442          * Attempts to set the value contained by this EntryFuture.  If the
 443          * EntryFuture&#39;s value has not been set already, then the value is
 444          * saved, any callers blocked in the get() method are notified, and
 445          * true is returned.  If the value has already been set, then no saving
 446          * or notification occurs, and false is returned.
 447          */
 448         synchronized boolean set(Object entry) {
 449             if (this.entry != unset) {
 450                 return false;
 451             }
 452             this.entry = entry;
 453             notifyAll();
 454             return true;
 455         }
 456 
 457         /**
 458          * Returns the value contained by this EntryFuture, blocking if
 459          * necessary until a value is set.
 460          */
 461         synchronized Object get() {
 462             boolean interrupted = false;
 463             while (entry == unset) {
 464                 try {
 465                     wait();
 466                 } catch (InterruptedException ex) {
 467                     interrupted = true;
 468                 }
 469             }
 470             if (interrupted) {
 471                 AccessController.doPrivileged(
 472                     new PrivilegedAction&lt;&gt;() {
 473                         public Void run() {
 474                             Thread.currentThread().interrupt();
 475                             return null;
 476                         }
 477                     }
 478                 );
 479             }
 480             return entry;
 481         }
 482 
 483         /**
 484          * Returns the thread that created this EntryFuture.
 485          */
 486         Thread getOwner() {
 487             return owner;
 488         }
 489     }
 490 
 491     @SuppressWarnings(&quot;preview&quot;)
 492     private static boolean isRecord(Class&lt;?&gt; cls) {
 493         return cls.isRecord();
 494     }
 495 
 496     /**
 497      * Creates local class descriptor representing given class.
 498      */
 499     private ObjectStreamClass(final Class&lt;?&gt; cl) {
 500         this.cl = cl;
 501         name = cl.getName();
 502         isProxy = Proxy.isProxyClass(cl);
 503         isEnum = Enum.class.isAssignableFrom(cl);
<a name="2" id="anc2"></a><span class="line-added"> 504         boolean isInlineClass = cl.isInlineClass();</span>
 505         isRecord = isRecord(cl);
 506         serializable = Serializable.class.isAssignableFrom(cl);
 507         externalizable = Externalizable.class.isAssignableFrom(cl);
 508 
 509         Class&lt;?&gt; superCl = cl.getSuperclass();
 510         superDesc = (superCl != null) ? lookup(superCl, false) : null;
 511         localDesc = this;
 512 
 513         if (serializable) {
 514             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 515                 public Void run() {
 516                     if (isEnum) {
 517                         suid = Long.valueOf(0);
 518                         fields = NO_FIELDS;
 519                         return null;
 520                     }
 521                     if (cl.isArray()) {
 522                         fields = NO_FIELDS;
 523                         return null;
 524                     }
 525 
 526                     suid = getDeclaredSUID(cl);
 527                     try {
 528                         fields = getSerialFields(cl);
 529                         computeFieldOffsets();
 530                     } catch (InvalidClassException e) {
 531                         serializeEx = deserializeEx =
 532                             new ExceptionInfo(e.classname, e.getMessage());
 533                         fields = NO_FIELDS;
 534                     }
 535 
 536                     if (isRecord) {
 537                         canonicalCtr = canonicalRecordCtr(cl);
 538                         deserializationCtrs = new DeserializationConstructorsCache();
 539                     } else if (externalizable) {
 540                         cons = getExternalizableConstructor(cl);
 541                     } else {
 542                         cons = getSerializableConstructor(cl);
 543                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 544                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 545                             Void.TYPE);
 546                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 547                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 548                             Void.TYPE);
 549                         readObjectNoDataMethod = getPrivateMethod(
 550                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 551                         hasWriteObjectData = (writeObjectMethod != null);
 552                     }
 553                     domains = getProtectionDomains(cons, cl);
 554                     writeReplaceMethod = getInheritableMethod(
 555                         cl, &quot;writeReplace&quot;, null, Object.class);
 556                     readResolveMethod = getInheritableMethod(
 557                         cl, &quot;readResolve&quot;, null, Object.class);
 558                     return null;
 559                 }
 560             });
 561         } else {
 562             suid = Long.valueOf(0);
 563             fields = NO_FIELDS;
 564         }
 565 
 566         try {
 567             fieldRefl = getReflector(fields, this);
 568         } catch (InvalidClassException ex) {
 569             // field mismatches impossible when matching local fields vs. self
 570             throw new InternalError(ex);
 571         }
 572 
 573         if (deserializeEx == null) {
 574             if (isEnum) {
 575                 deserializeEx = new ExceptionInfo(name, &quot;enum type&quot;);
<a name="3" id="anc3"></a><span class="line-added"> 576             } else if (isInlineClass &amp;&amp; writeReplaceMethod == null) {</span>
<span class="line-added"> 577                 deserializeEx = new ExceptionInfo(name, &quot;inline class&quot;);</span>
 578             } else if (cons == null &amp;&amp; !isRecord) {
 579                 deserializeEx = new ExceptionInfo(name, &quot;no valid constructor&quot;);
 580             }
 581         }
 582         if (isRecord &amp;&amp; canonicalCtr == null) {
 583             deserializeEx = new ExceptionInfo(name, &quot;record canonical constructor not found&quot;);
 584         } else {
 585             for (int i = 0; i &lt; fields.length; i++) {
 586                 if (fields[i].getField() == null) {
 587                     defaultSerializeEx = new ExceptionInfo(
 588                         name, &quot;unmatched serializable field(s) declared&quot;);
 589                 }
 590             }
 591         }
 592         initialized = true;
 593     }
 594 
 595     /**
 596      * Creates blank class descriptor which should be initialized via a
 597      * subsequent call to initProxy(), initNonProxy() or readNonProxy().
 598      */
 599     ObjectStreamClass() {
 600     }
 601 
 602     /**
 603      * Creates a PermissionDomain that grants no permission.
 604      */
 605     private ProtectionDomain noPermissionsDomain() {
 606         PermissionCollection perms = new Permissions();
 607         perms.setReadOnly();
 608         return new ProtectionDomain(null, perms);
 609     }
 610 
 611     /**
 612      * Aggregate the ProtectionDomains of all the classes that separate
 613      * a concrete class {@code cl} from its ancestor&#39;s class declaring
 614      * a constructor {@code cons}.
 615      *
 616      * If {@code cl} is defined by the boot loader, or the constructor
 617      * {@code cons} is declared by {@code cl}, or if there is no security
 618      * manager, then this method does nothing and {@code null} is returned.
 619      *
 620      * @param cons A constructor declared by {@code cl} or one of its
 621      *             ancestors.
 622      * @param cl A concrete class, which is either the class declaring
 623      *           the constructor {@code cons}, or a serializable subclass
 624      *           of that class.
 625      * @return An array of ProtectionDomain representing the set of
 626      *         ProtectionDomain that separate the concrete class {@code cl}
 627      *         from its ancestor&#39;s declaring {@code cons}, or {@code null}.
 628      */
 629     private ProtectionDomain[] getProtectionDomains(Constructor&lt;?&gt; cons,
 630                                                     Class&lt;?&gt; cl) {
 631         ProtectionDomain[] domains = null;
 632         if (cons != null &amp;&amp; cl.getClassLoader() != null
 633                 &amp;&amp; System.getSecurityManager() != null) {
 634             Class&lt;?&gt; cls = cl;
 635             Class&lt;?&gt; fnscl = cons.getDeclaringClass();
 636             Set&lt;ProtectionDomain&gt; pds = null;
 637             while (cls != fnscl) {
 638                 ProtectionDomain pd = cls.getProtectionDomain();
 639                 if (pd != null) {
 640                     if (pds == null) pds = new HashSet&lt;&gt;();
 641                     pds.add(pd);
 642                 }
 643                 cls = cls.getSuperclass();
 644                 if (cls == null) {
 645                     // that&#39;s not supposed to happen
 646                     // make a ProtectionDomain with no permission.
 647                     // should we throw instead?
 648                     if (pds == null) pds = new HashSet&lt;&gt;();
 649                     else pds.clear();
 650                     pds.add(noPermissionsDomain());
 651                     break;
 652                 }
 653             }
 654             if (pds != null) {
 655                 domains = pds.toArray(new ProtectionDomain[0]);
 656             }
 657         }
 658         return domains;
 659     }
 660 
 661     /**
 662      * Initializes class descriptor representing a proxy class.
 663      */
 664     void initProxy(Class&lt;?&gt; cl,
 665                    ClassNotFoundException resolveEx,
 666                    ObjectStreamClass superDesc)
 667         throws InvalidClassException
 668     {
 669         ObjectStreamClass osc = null;
 670         if (cl != null) {
 671             osc = lookup(cl, true);
 672             if (!osc.isProxy) {
 673                 throw new InvalidClassException(
 674                     &quot;cannot bind proxy descriptor to a non-proxy class&quot;);
 675             }
 676         }
 677         this.cl = cl;
 678         this.resolveEx = resolveEx;
 679         this.superDesc = superDesc;
 680         isProxy = true;
 681         serializable = true;
 682         suid = Long.valueOf(0);
 683         fields = NO_FIELDS;
 684         if (osc != null) {
 685             localDesc = osc;
 686             name = localDesc.name;
 687             externalizable = localDesc.externalizable;
 688             writeReplaceMethod = localDesc.writeReplaceMethod;
 689             readResolveMethod = localDesc.readResolveMethod;
 690             deserializeEx = localDesc.deserializeEx;
 691             domains = localDesc.domains;
 692             cons = localDesc.cons;
 693         }
 694         fieldRefl = getReflector(fields, localDesc);
 695         initialized = true;
 696     }
 697 
 698     /**
 699      * Initializes class descriptor representing a non-proxy class.
 700      */
 701     void initNonProxy(ObjectStreamClass model,
 702                       Class&lt;?&gt; cl,
 703                       ClassNotFoundException resolveEx,
 704                       ObjectStreamClass superDesc)
 705         throws InvalidClassException
 706     {
 707         long suid = Long.valueOf(model.getSerialVersionUID());
 708         ObjectStreamClass osc = null;
 709         if (cl != null) {
 710             osc = lookup(cl, true);
 711             if (osc.isProxy) {
 712                 throw new InvalidClassException(
 713                         &quot;cannot bind non-proxy descriptor to a proxy class&quot;);
 714             }
 715             if (model.isEnum != osc.isEnum) {
 716                 throw new InvalidClassException(model.isEnum ?
 717                         &quot;cannot bind enum descriptor to a non-enum class&quot; :
 718                         &quot;cannot bind non-enum descriptor to an enum class&quot;);
 719             }
 720 
 721             if (model.serializable == osc.serializable &amp;&amp;
 722                     !cl.isArray() &amp;&amp; !isRecord(cl) &amp;&amp;
 723                     suid != osc.getSerialVersionUID()) {
 724                 throw new InvalidClassException(osc.name,
 725                         &quot;local class incompatible: &quot; +
 726                                 &quot;stream classdesc serialVersionUID = &quot; + suid +
 727                                 &quot;, local class serialVersionUID = &quot; +
 728                                 osc.getSerialVersionUID());
 729             }
 730 
 731             if (!classNamesEqual(model.name, osc.name)) {
 732                 throw new InvalidClassException(osc.name,
 733                         &quot;local class name incompatible with stream class &quot; +
 734                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 735             }
 736 
 737             if (!model.isEnum) {
 738                 if ((model.serializable == osc.serializable) &amp;&amp;
 739                         (model.externalizable != osc.externalizable)) {
 740                     throw new InvalidClassException(osc.name,
 741                             &quot;Serializable incompatible with Externalizable&quot;);
 742                 }
 743 
 744                 if ((model.serializable != osc.serializable) ||
 745                         (model.externalizable != osc.externalizable) ||
 746                         !(model.serializable || model.externalizable)) {
 747                     deserializeEx = new ExceptionInfo(
 748                             osc.name, &quot;class invalid for deserialization&quot;);
 749                 }
 750             }
 751         }
 752 
 753         this.cl = cl;
 754         this.resolveEx = resolveEx;
 755         this.superDesc = superDesc;
 756         name = model.name;
 757         this.suid = suid;
 758         isProxy = false;
 759         isEnum = model.isEnum;
 760         serializable = model.serializable;
 761         externalizable = model.externalizable;
 762         hasBlockExternalData = model.hasBlockExternalData;
 763         hasWriteObjectData = model.hasWriteObjectData;
 764         fields = model.fields;
 765         primDataSize = model.primDataSize;
 766         numObjFields = model.numObjFields;
 767 
 768         if (osc != null) {
 769             localDesc = osc;
 770             isRecord = localDesc.isRecord;
 771             // canonical record constructor is shared
 772             canonicalCtr = localDesc.canonicalCtr;
 773             // cache of deserialization constructors is shared
 774             deserializationCtrs = localDesc.deserializationCtrs;
 775             writeObjectMethod = localDesc.writeObjectMethod;
 776             readObjectMethod = localDesc.readObjectMethod;
 777             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 778             writeReplaceMethod = localDesc.writeReplaceMethod;
 779             readResolveMethod = localDesc.readResolveMethod;
 780             if (deserializeEx == null) {
 781                 deserializeEx = localDesc.deserializeEx;
 782             }
 783             domains = localDesc.domains;
 784             assert isRecord(cl) ? localDesc.cons == null : true;
 785             cons = localDesc.cons;
 786         }
 787 
 788         fieldRefl = getReflector(fields, localDesc);
 789         // reassign to matched fields so as to reflect local unshared settings
 790         fields = fieldRefl.getFields();
 791 
 792         initialized = true;
 793     }
 794 
 795     /**
 796      * Reads non-proxy class descriptor information from given input stream.
 797      * The resulting class descriptor is not fully functional; it can only be
 798      * used as input to the ObjectInputStream.resolveClass() and
 799      * ObjectStreamClass.initNonProxy() methods.
 800      */
 801     void readNonProxy(ObjectInputStream in)
 802         throws IOException, ClassNotFoundException
 803     {
 804         name = in.readUTF();
 805         suid = Long.valueOf(in.readLong());
 806         isProxy = false;
 807 
 808         byte flags = in.readByte();
 809         hasWriteObjectData =
 810             ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0);
 811         hasBlockExternalData =
 812             ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != 0);
 813         externalizable =
 814             ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0);
 815         boolean sflag =
 816             ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0);
 817         if (externalizable &amp;&amp; sflag) {
 818             throw new InvalidClassException(
 819                 name, &quot;serializable and externalizable flags conflict&quot;);
 820         }
 821         serializable = externalizable || sflag;
 822         isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != 0);
 823         if (isEnum &amp;&amp; suid.longValue() != 0L) {
 824             throw new InvalidClassException(name,
 825                 &quot;enum descriptor has non-zero serialVersionUID: &quot; + suid);
 826         }
 827 
 828         int numFields = in.readShort();
 829         if (isEnum &amp;&amp; numFields != 0) {
 830             throw new InvalidClassException(name,
 831                 &quot;enum descriptor has non-zero field count: &quot; + numFields);
 832         }
 833         fields = (numFields &gt; 0) ?
 834             new ObjectStreamField[numFields] : NO_FIELDS;
 835         for (int i = 0; i &lt; numFields; i++) {
 836             char tcode = (char) in.readByte();
 837             String fname = in.readUTF();
 838             String signature = ((tcode == &#39;L&#39;) || (tcode == &#39;[&#39;)) ?
 839                 in.readTypeString() : new String(new char[] { tcode });
 840             try {
 841                 fields[i] = new ObjectStreamField(fname, signature, false);
 842             } catch (RuntimeException e) {
 843                 throw (IOException) new InvalidClassException(name,
 844                     &quot;invalid descriptor for field &quot; + fname).initCause(e);
 845             }
 846         }
 847         computeFieldOffsets();
 848     }
 849 
 850     /**
 851      * Writes non-proxy class descriptor information to given output stream.
 852      */
 853     void writeNonProxy(ObjectOutputStream out) throws IOException {
 854         out.writeUTF(name);
 855         out.writeLong(getSerialVersionUID());
 856 
 857         byte flags = 0;
 858         if (externalizable) {
 859             flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;
 860             int protocol = out.getProtocolVersion();
 861             if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) {
 862                 flags |= ObjectStreamConstants.SC_BLOCK_DATA;
 863             }
 864         } else if (serializable) {
 865             flags |= ObjectStreamConstants.SC_SERIALIZABLE;
 866         }
 867         if (hasWriteObjectData) {
 868             flags |= ObjectStreamConstants.SC_WRITE_METHOD;
 869         }
 870         if (isEnum) {
 871             flags |= ObjectStreamConstants.SC_ENUM;
 872         }
 873         out.writeByte(flags);
 874 
 875         out.writeShort(fields.length);
 876         for (int i = 0; i &lt; fields.length; i++) {
 877             ObjectStreamField f = fields[i];
 878             out.writeByte(f.getTypeCode());
 879             out.writeUTF(f.getName());
 880             if (!f.isPrimitive()) {
 881                 out.writeTypeString(f.getTypeString());
 882             }
 883         }
 884     }
 885 
 886     /**
 887      * Returns ClassNotFoundException (if any) thrown while attempting to
 888      * resolve local class corresponding to this class descriptor.
 889      */
 890     ClassNotFoundException getResolveException() {
 891         return resolveEx;
 892     }
 893 
 894     /**
 895      * Throws InternalError if not initialized.
 896      */
 897     private final void requireInitialized() {
 898         if (!initialized)
 899             throw new InternalError(&quot;Unexpected call when not initialized&quot;);
 900     }
 901 
 902     /**
 903      * Throws InvalidClassException if not initialized.
 904      * To be called in cases where an uninitialized class descriptor indicates
 905      * a problem in the serialization stream.
 906      */
 907     final void checkInitialized() throws InvalidClassException {
 908         if (!initialized) {
 909             throw new InvalidClassException(&quot;Class descriptor should be initialized&quot;);
 910         }
 911     }
 912 
 913     /**
 914      * Throws an InvalidClassException if object instances referencing this
 915      * class descriptor should not be allowed to deserialize.  This method does
 916      * not apply to deserialization of enum constants.
 917      */
 918     void checkDeserialize() throws InvalidClassException {
 919         requireInitialized();
 920         if (deserializeEx != null) {
 921             throw deserializeEx.newInvalidClassException();
 922         }
 923     }
 924 
 925     /**
 926      * Throws an InvalidClassException if objects whose class is represented by
 927      * this descriptor should not be allowed to serialize.  This method does
 928      * not apply to serialization of enum constants.
 929      */
 930     void checkSerialize() throws InvalidClassException {
 931         requireInitialized();
 932         if (serializeEx != null) {
 933             throw serializeEx.newInvalidClassException();
 934         }
 935     }
 936 
 937     /**
 938      * Throws an InvalidClassException if objects whose class is represented by
 939      * this descriptor should not be permitted to use default serialization
 940      * (e.g., if the class declares serializable fields that do not correspond
 941      * to actual fields, and hence must use the GetField API).  This method
 942      * does not apply to deserialization of enum constants.
 943      */
 944     void checkDefaultSerialize() throws InvalidClassException {
 945         requireInitialized();
 946         if (defaultSerializeEx != null) {
 947             throw defaultSerializeEx.newInvalidClassException();
 948         }
 949     }
 950 
 951     /**
 952      * Returns superclass descriptor.  Note that on the receiving side, the
 953      * superclass descriptor may be bound to a class that is not a superclass
 954      * of the subclass descriptor&#39;s bound class.
 955      */
 956     ObjectStreamClass getSuperDesc() {
 957         requireInitialized();
 958         return superDesc;
 959     }
 960 
 961     /**
 962      * Returns the &quot;local&quot; class descriptor for the class associated with this
 963      * class descriptor (i.e., the result of
 964      * ObjectStreamClass.lookup(this.forClass())) or null if there is no class
 965      * associated with this descriptor.
 966      */
 967     ObjectStreamClass getLocalDesc() {
 968         requireInitialized();
 969         return localDesc;
 970     }
 971 
 972     /**
 973      * Returns arrays of ObjectStreamFields representing the serializable
 974      * fields of the represented class.  If copy is true, a clone of this class
 975      * descriptor&#39;s field array is returned, otherwise the array itself is
 976      * returned.
 977      */
 978     ObjectStreamField[] getFields(boolean copy) {
 979         return copy ? fields.clone() : fields;
 980     }
 981 
 982     /**
 983      * Looks up a serializable field of the represented class by name and type.
 984      * A specified type of null matches all types, Object.class matches all
 985      * non-primitive types, and any other non-null type matches assignable
 986      * types only.  Returns matching field, or null if no match found.
 987      */
 988     ObjectStreamField getField(String name, Class&lt;?&gt; type) {
 989         for (int i = 0; i &lt; fields.length; i++) {
 990             ObjectStreamField f = fields[i];
 991             if (f.getName().equals(name)) {
 992                 if (type == null ||
 993                     (type == Object.class &amp;&amp; !f.isPrimitive()))
 994                 {
 995                     return f;
 996                 }
 997                 Class&lt;?&gt; ftype = f.getType();
 998                 if (ftype != null &amp;&amp; type.isAssignableFrom(ftype)) {
 999                     return f;
1000                 }
1001             }
1002         }
1003         return null;
1004     }
1005 
1006     /**
1007      * Returns true if class descriptor represents a dynamic proxy class, false
1008      * otherwise.
1009      */
1010     boolean isProxy() {
1011         requireInitialized();
1012         return isProxy;
1013     }
1014 
1015     /**
1016      * Returns true if class descriptor represents an enum type, false
1017      * otherwise.
1018      */
1019     boolean isEnum() {
1020         requireInitialized();
1021         return isEnum;
1022     }
1023 
1024     /**
1025      * Returns true if class descriptor represents a record type, false
1026      * otherwise.
1027      */
1028     boolean isRecord() {
1029         requireInitialized();
1030         return isRecord;
1031     }
1032 
1033     /**
1034      * Returns true if represented class implements Externalizable, false
1035      * otherwise.
1036      */
1037     boolean isExternalizable() {
1038         requireInitialized();
1039         return externalizable;
1040     }
1041 
1042     /**
1043      * Returns true if represented class implements Serializable, false
1044      * otherwise.
1045      */
1046     boolean isSerializable() {
1047         requireInitialized();
1048         return serializable;
1049     }
1050 
1051     /**
1052      * Returns true if class descriptor represents externalizable class that
1053      * has written its data in 1.2 (block data) format, false otherwise.
1054      */
1055     boolean hasBlockExternalData() {
1056         requireInitialized();
1057         return hasBlockExternalData;
1058     }
1059 
1060     /**
1061      * Returns true if class descriptor represents serializable (but not
1062      * externalizable) class which has written its data via a custom
1063      * writeObject() method, false otherwise.
1064      */
1065     boolean hasWriteObjectData() {
1066         requireInitialized();
1067         return hasWriteObjectData;
1068     }
1069 
1070     /**
1071      * Returns true if represented class is serializable/externalizable and can
1072      * be instantiated by the serialization runtime--i.e., if it is
1073      * externalizable and defines a public no-arg constructor, or if it is
1074      * non-externalizable and its first non-serializable superclass defines an
1075      * accessible no-arg constructor.  Otherwise, returns false.
1076      */
1077     boolean isInstantiable() {
1078         requireInitialized();
1079         return (cons != null);
1080     }
1081 
1082     /**
1083      * Returns true if represented class is serializable (but not
1084      * externalizable) and defines a conformant writeObject method.  Otherwise,
1085      * returns false.
1086      */
1087     boolean hasWriteObjectMethod() {
1088         requireInitialized();
1089         return (writeObjectMethod != null);
1090     }
1091 
1092     /**
1093      * Returns true if represented class is serializable (but not
1094      * externalizable) and defines a conformant readObject method.  Otherwise,
1095      * returns false.
1096      */
1097     boolean hasReadObjectMethod() {
1098         requireInitialized();
1099         return (readObjectMethod != null);
1100     }
1101 
1102     /**
1103      * Returns true if represented class is serializable (but not
1104      * externalizable) and defines a conformant readObjectNoData method.
1105      * Otherwise, returns false.
1106      */
1107     boolean hasReadObjectNoDataMethod() {
1108         requireInitialized();
1109         return (readObjectNoDataMethod != null);
1110     }
1111 
1112     /**
1113      * Returns true if represented class is serializable or externalizable and
1114      * defines a conformant writeReplace method.  Otherwise, returns false.
1115      */
1116     boolean hasWriteReplaceMethod() {
1117         requireInitialized();
1118         return (writeReplaceMethod != null);
1119     }
1120 
1121     /**
1122      * Returns true if represented class is serializable or externalizable and
1123      * defines a conformant readResolve method.  Otherwise, returns false.
1124      */
1125     boolean hasReadResolveMethod() {
1126         requireInitialized();
1127         return (readResolveMethod != null);
1128     }
1129 
1130     /**
1131      * Creates a new instance of the represented class.  If the class is
1132      * externalizable, invokes its public no-arg constructor; otherwise, if the
1133      * class is serializable, invokes the no-arg constructor of the first
1134      * non-serializable superclass.  Throws UnsupportedOperationException if
1135      * this class descriptor is not associated with a class, if the associated
1136      * class is non-serializable or if the appropriate no-arg constructor is
1137      * inaccessible/unavailable.
1138      */
1139     Object newInstance()
1140         throws InstantiationException, InvocationTargetException,
1141                UnsupportedOperationException
1142     {
1143         requireInitialized();
1144         if (cons != null) {
1145             try {
1146                 if (domains == null || domains.length == 0) {
1147                     return cons.newInstance();
1148                 } else {
1149                     JavaSecurityAccess jsa = SharedSecrets.getJavaSecurityAccess();
1150                     PrivilegedAction&lt;?&gt; pea = () -&gt; {
1151                         try {
1152                             return cons.newInstance();
1153                         } catch (InstantiationException
1154                                  | InvocationTargetException
1155                                  | IllegalAccessException x) {
1156                             throw new UndeclaredThrowableException(x);
1157                         }
1158                     }; // Can&#39;t use PrivilegedExceptionAction with jsa
1159                     try {
1160                         return jsa.doIntersectionPrivilege(pea,
1161                                    AccessController.getContext(),
1162                                    new AccessControlContext(domains));
1163                     } catch (UndeclaredThrowableException x) {
1164                         Throwable cause = x.getCause();
1165                         if (cause instanceof InstantiationException)
1166                             throw (InstantiationException) cause;
1167                         if (cause instanceof InvocationTargetException)
1168                             throw (InvocationTargetException) cause;
1169                         if (cause instanceof IllegalAccessException)
1170                             throw (IllegalAccessException) cause;
1171                         // not supposed to happen
1172                         throw x;
1173                     }
1174                 }
1175             } catch (IllegalAccessException ex) {
1176                 // should not occur, as access checks have been suppressed
1177                 throw new InternalError(ex);
1178             } catch (InstantiationError err) {
1179                 var ex = new InstantiationException();
1180                 ex.initCause(err);
1181                 throw ex;
1182             }
1183         } else {
1184             throw new UnsupportedOperationException();
1185         }
1186     }
1187 
1188     /**
1189      * Invokes the writeObject method of the represented serializable class.
1190      * Throws UnsupportedOperationException if this class descriptor is not
1191      * associated with a class, or if the class is externalizable,
1192      * non-serializable or does not define writeObject.
1193      */
1194     void invokeWriteObject(Object obj, ObjectOutputStream out)
1195         throws IOException, UnsupportedOperationException
1196     {
1197         requireInitialized();
1198         if (writeObjectMethod != null) {
1199             try {
1200                 writeObjectMethod.invoke(obj, new Object[]{ out });
1201             } catch (InvocationTargetException ex) {
1202                 Throwable th = ex.getTargetException();
1203                 if (th instanceof IOException) {
1204                     throw (IOException) th;
1205                 } else {
1206                     throwMiscException(th);
1207                 }
1208             } catch (IllegalAccessException ex) {
1209                 // should not occur, as access checks have been suppressed
1210                 throw new InternalError(ex);
1211             }
1212         } else {
1213             throw new UnsupportedOperationException();
1214         }
1215     }
1216 
1217     /**
1218      * Invokes the readObject method of the represented serializable class.
1219      * Throws UnsupportedOperationException if this class descriptor is not
1220      * associated with a class, or if the class is externalizable,
1221      * non-serializable or does not define readObject.
1222      */
1223     void invokeReadObject(Object obj, ObjectInputStream in)
1224         throws ClassNotFoundException, IOException,
1225                UnsupportedOperationException
1226     {
1227         requireInitialized();
1228         if (readObjectMethod != null) {
1229             try {
1230                 readObjectMethod.invoke(obj, new Object[]{ in });
1231             } catch (InvocationTargetException ex) {
1232                 Throwable th = ex.getTargetException();
1233                 if (th instanceof ClassNotFoundException) {
1234                     throw (ClassNotFoundException) th;
1235                 } else if (th instanceof IOException) {
1236                     throw (IOException) th;
1237                 } else {
1238                     throwMiscException(th);
1239                 }
1240             } catch (IllegalAccessException ex) {
1241                 // should not occur, as access checks have been suppressed
1242                 throw new InternalError(ex);
1243             }
1244         } else {
1245             throw new UnsupportedOperationException();
1246         }
1247     }
1248 
1249     /**
1250      * Invokes the readObjectNoData method of the represented serializable
1251      * class.  Throws UnsupportedOperationException if this class descriptor is
1252      * not associated with a class, or if the class is externalizable,
1253      * non-serializable or does not define readObjectNoData.
1254      */
1255     void invokeReadObjectNoData(Object obj)
1256         throws IOException, UnsupportedOperationException
1257     {
1258         requireInitialized();
1259         if (readObjectNoDataMethod != null) {
1260             try {
1261                 readObjectNoDataMethod.invoke(obj, (Object[]) null);
1262             } catch (InvocationTargetException ex) {
1263                 Throwable th = ex.getTargetException();
1264                 if (th instanceof ObjectStreamException) {
1265                     throw (ObjectStreamException) th;
1266                 } else {
1267                     throwMiscException(th);
1268                 }
1269             } catch (IllegalAccessException ex) {
1270                 // should not occur, as access checks have been suppressed
1271                 throw new InternalError(ex);
1272             }
1273         } else {
1274             throw new UnsupportedOperationException();
1275         }
1276     }
1277 
1278     /**
1279      * Invokes the writeReplace method of the represented serializable class and
1280      * returns the result.  Throws UnsupportedOperationException if this class
1281      * descriptor is not associated with a class, or if the class is
1282      * non-serializable or does not define writeReplace.
1283      */
1284     Object invokeWriteReplace(Object obj)
1285         throws IOException, UnsupportedOperationException
1286     {
1287         requireInitialized();
1288         if (writeReplaceMethod != null) {
1289             try {
1290                 return writeReplaceMethod.invoke(obj, (Object[]) null);
1291             } catch (InvocationTargetException ex) {
1292                 Throwable th = ex.getTargetException();
1293                 if (th instanceof ObjectStreamException) {
1294                     throw (ObjectStreamException) th;
1295                 } else {
1296                     throwMiscException(th);
1297                     throw new InternalError(th);  // never reached
1298                 }
1299             } catch (IllegalAccessException ex) {
1300                 // should not occur, as access checks have been suppressed
1301                 throw new InternalError(ex);
1302             }
1303         } else {
1304             throw new UnsupportedOperationException();
1305         }
1306     }
1307 
1308     /**
1309      * Invokes the readResolve method of the represented serializable class and
1310      * returns the result.  Throws UnsupportedOperationException if this class
1311      * descriptor is not associated with a class, or if the class is
1312      * non-serializable or does not define readResolve.
1313      */
1314     Object invokeReadResolve(Object obj)
1315         throws IOException, UnsupportedOperationException
1316     {
1317         requireInitialized();
1318         if (readResolveMethod != null) {
1319             try {
1320                 return readResolveMethod.invoke(obj, (Object[]) null);
1321             } catch (InvocationTargetException ex) {
1322                 Throwable th = ex.getTargetException();
1323                 if (th instanceof ObjectStreamException) {
1324                     throw (ObjectStreamException) th;
1325                 } else {
1326                     throwMiscException(th);
1327                     throw new InternalError(th);  // never reached
1328                 }
1329             } catch (IllegalAccessException ex) {
1330                 // should not occur, as access checks have been suppressed
1331                 throw new InternalError(ex);
1332             }
1333         } else {
1334             throw new UnsupportedOperationException();
1335         }
1336     }
1337 
1338     /**
1339      * Class representing the portion of an object&#39;s serialized form allotted
1340      * to data described by a given class descriptor.  If &quot;hasData&quot; is false,
1341      * the object&#39;s serialized form does not contain data associated with the
1342      * class descriptor.
1343      */
1344     static class ClassDataSlot {
1345 
1346         /** class descriptor &quot;occupying&quot; this slot */
1347         final ObjectStreamClass desc;
1348         /** true if serialized form includes data for this slot&#39;s descriptor */
1349         final boolean hasData;
1350 
1351         ClassDataSlot(ObjectStreamClass desc, boolean hasData) {
1352             this.desc = desc;
1353             this.hasData = hasData;
1354         }
1355     }
1356 
1357     /**
1358      * Returns array of ClassDataSlot instances representing the data layout
1359      * (including superclass data) for serialized objects described by this
1360      * class descriptor.  ClassDataSlots are ordered by inheritance with those
1361      * containing &quot;higher&quot; superclasses appearing first.  The final
1362      * ClassDataSlot contains a reference to this descriptor.
1363      */
1364     ClassDataSlot[] getClassDataLayout() throws InvalidClassException {
1365         // REMIND: synchronize instead of relying on volatile?
1366         if (dataLayout == null) {
1367             dataLayout = getClassDataLayout0();
1368         }
1369         return dataLayout;
1370     }
1371 
1372     private ClassDataSlot[] getClassDataLayout0()
1373         throws InvalidClassException
1374     {
1375         ArrayList&lt;ClassDataSlot&gt; slots = new ArrayList&lt;&gt;();
1376         Class&lt;?&gt; start = cl, end = cl;
1377 
1378         // locate closest non-serializable superclass
1379         while (end != null &amp;&amp; Serializable.class.isAssignableFrom(end)) {
1380             end = end.getSuperclass();
1381         }
1382 
1383         HashSet&lt;String&gt; oscNames = new HashSet&lt;&gt;(3);
1384 
1385         for (ObjectStreamClass d = this; d != null; d = d.superDesc) {
1386             if (oscNames.contains(d.name)) {
1387                 throw new InvalidClassException(&quot;Circular reference.&quot;);
1388             } else {
1389                 oscNames.add(d.name);
1390             }
1391 
1392             // search up inheritance hierarchy for class with matching name
1393             String searchName = (d.cl != null) ? d.cl.getName() : d.name;
1394             Class&lt;?&gt; match = null;
1395             for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) {
1396                 if (searchName.equals(c.getName())) {
1397                     match = c;
1398                     break;
1399                 }
1400             }
1401 
1402             // add &quot;no data&quot; slot for each unmatched class below match
1403             if (match != null) {
1404                 for (Class&lt;?&gt; c = start; c != match; c = c.getSuperclass()) {
1405                     slots.add(new ClassDataSlot(
1406                         ObjectStreamClass.lookup(c, true), false));
1407                 }
1408                 start = match.getSuperclass();
1409             }
1410 
1411             // record descriptor/class pairing
1412             slots.add(new ClassDataSlot(d.getVariantFor(match), true));
1413         }
1414 
1415         // add &quot;no data&quot; slot for any leftover unmatched classes
1416         for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) {
1417             slots.add(new ClassDataSlot(
1418                 ObjectStreamClass.lookup(c, true), false));
1419         }
1420 
1421         // order slots from superclass -&gt; subclass
1422         Collections.reverse(slots);
1423         return slots.toArray(new ClassDataSlot[slots.size()]);
1424     }
1425 
1426     /**
1427      * Returns aggregate size (in bytes) of marshalled primitive field values
1428      * for represented class.
1429      */
1430     int getPrimDataSize() {
1431         return primDataSize;
1432     }
1433 
1434     /**
1435      * Returns number of non-primitive serializable fields of represented
1436      * class.
1437      */
1438     int getNumObjFields() {
1439         return numObjFields;
1440     }
1441 
1442     /**
1443      * Fetches the serializable primitive field values of object obj and
1444      * marshals them into byte array buf starting at offset 0.  It is the
1445      * responsibility of the caller to ensure that obj is of the proper type if
1446      * non-null.
1447      */
1448     void getPrimFieldValues(Object obj, byte[] buf) {
1449         fieldRefl.getPrimFieldValues(obj, buf);
1450     }
1451 
1452     /**
1453      * Sets the serializable primitive fields of object obj using values
1454      * unmarshalled from byte array buf starting at offset 0.  It is the
1455      * responsibility of the caller to ensure that obj is of the proper type if
1456      * non-null.
1457      */
1458     void setPrimFieldValues(Object obj, byte[] buf) {
1459         fieldRefl.setPrimFieldValues(obj, buf);
1460     }
1461 
1462     /**
1463      * Fetches the serializable object field values of object obj and stores
1464      * them in array vals starting at offset 0.  It is the responsibility of
1465      * the caller to ensure that obj is of the proper type if non-null.
1466      */
1467     void getObjFieldValues(Object obj, Object[] vals) {
1468         fieldRefl.getObjFieldValues(obj, vals);
1469     }
1470 
1471     /**
1472      * Checks that the given values, from array vals starting at offset 0,
1473      * are assignable to the given serializable object fields.
1474      * @throws ClassCastException if any value is not assignable
1475      */
1476     void checkObjFieldValueTypes(Object obj, Object[] vals) {
1477         fieldRefl.checkObjectFieldValueTypes(obj, vals);
1478     }
1479 
1480     /**
1481      * Sets the serializable object fields of object obj using values from
1482      * array vals starting at offset 0.  It is the responsibility of the caller
1483      * to ensure that obj is of the proper type if non-null.
1484      */
1485     void setObjFieldValues(Object obj, Object[] vals) {
1486         fieldRefl.setObjFieldValues(obj, vals);
1487     }
1488 
1489     /**
1490      * Calculates and sets serializable field offsets, as well as primitive
1491      * data size and object field count totals.  Throws InvalidClassException
1492      * if fields are illegally ordered.
1493      */
1494     private void computeFieldOffsets() throws InvalidClassException {
1495         primDataSize = 0;
1496         numObjFields = 0;
1497         int firstObjIndex = -1;
1498 
1499         for (int i = 0; i &lt; fields.length; i++) {
1500             ObjectStreamField f = fields[i];
1501             switch (f.getTypeCode()) {
1502                 case &#39;Z&#39;:
1503                 case &#39;B&#39;:
1504                     f.setOffset(primDataSize++);
1505                     break;
1506 
1507                 case &#39;C&#39;:
1508                 case &#39;S&#39;:
1509                     f.setOffset(primDataSize);
1510                     primDataSize += 2;
1511                     break;
1512 
1513                 case &#39;I&#39;:
1514                 case &#39;F&#39;:
1515                     f.setOffset(primDataSize);
1516                     primDataSize += 4;
1517                     break;
1518 
1519                 case &#39;J&#39;:
1520                 case &#39;D&#39;:
1521                     f.setOffset(primDataSize);
1522                     primDataSize += 8;
1523                     break;
1524 
1525                 case &#39;[&#39;:
1526                 case &#39;L&#39;:
1527                     f.setOffset(numObjFields++);
1528                     if (firstObjIndex == -1) {
1529                         firstObjIndex = i;
1530                     }
1531                     break;
1532 
1533                 default:
1534                     throw new InternalError();
1535             }
1536         }
1537         if (firstObjIndex != -1 &amp;&amp;
1538             firstObjIndex + numObjFields != fields.length)
1539         {
1540             throw new InvalidClassException(name, &quot;illegal field order&quot;);
1541         }
1542     }
1543 
1544     /**
1545      * If given class is the same as the class associated with this class
1546      * descriptor, returns reference to this class descriptor.  Otherwise,
1547      * returns variant of this class descriptor bound to given class.
1548      */
1549     private ObjectStreamClass getVariantFor(Class&lt;?&gt; cl)
1550         throws InvalidClassException
1551     {
1552         if (this.cl == cl) {
1553             return this;
1554         }
1555         ObjectStreamClass desc = new ObjectStreamClass();
1556         if (isProxy) {
1557             desc.initProxy(cl, null, superDesc);
1558         } else {
1559             desc.initNonProxy(this, cl, null, superDesc);
1560         }
1561         return desc;
1562     }
1563 
1564     /**
1565      * Returns public no-arg constructor of given class, or null if none found.
1566      * Access checks are disabled on the returned constructor (if any), since
1567      * the defining class may still be non-public.
1568      */
1569     private static Constructor&lt;?&gt; getExternalizableConstructor(Class&lt;?&gt; cl) {
1570         try {
1571             Constructor&lt;?&gt; cons = cl.getDeclaredConstructor((Class&lt;?&gt;[]) null);
1572             cons.setAccessible(true);
1573             return ((cons.getModifiers() &amp; Modifier.PUBLIC) != 0) ?
1574                 cons : null;
<a name="4" id="anc4"></a><span class="line-modified">1575         } catch (NoSuchMethodException | InaccessibleObjectException ex) {</span>
1576             return null;
1577         }
1578     }
1579 
1580     /**
1581      * Returns subclass-accessible no-arg constructor of first non-serializable
1582      * superclass, or null if none found.  Access checks are disabled on the
1583      * returned constructor (if any).
1584      */
1585     private static Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) {
1586         return reflFactory.newConstructorForSerialization(cl);
1587     }
1588 
1589     /**
1590      * Returns the canonical constructor for the given record class, or null if
1591      * the not found ( which should never happen for correctly generated record
1592      * classes ).
1593      */
1594     @SuppressWarnings(&quot;preview&quot;)
1595     private static MethodHandle canonicalRecordCtr(Class&lt;?&gt; cls) {
1596         assert isRecord(cls) : &quot;Expected record, got: &quot; + cls;
1597         PrivilegedAction&lt;MethodHandle&gt; pa = () -&gt; {
1598             Class&lt;?&gt;[] paramTypes = Arrays.stream(cls.getRecordComponents())
1599                                           .map(RecordComponent::getType)
1600                                           .toArray(Class&lt;?&gt;[]::new);
1601             try {
1602                 Constructor&lt;?&gt; ctr = cls.getDeclaredConstructor(paramTypes);
1603                 ctr.setAccessible(true);
1604                 return MethodHandles.lookup().unreflectConstructor(ctr);
1605             } catch (IllegalAccessException | NoSuchMethodException e) {
1606                 return null;
1607             }
1608         };
1609         return AccessController.doPrivileged(pa);
1610     }
1611 
1612     /**
1613      * Returns the canonical constructor, if the local class equivalent of this
1614      * stream class descriptor is a record class, otherwise null.
1615      */
1616     MethodHandle getRecordConstructor() {
1617         return canonicalCtr;
1618     }
1619 
1620     /**
1621      * Returns non-static, non-abstract method with given signature provided it
1622      * is defined by or accessible (via inheritance) by the given class, or
1623      * null if no match found.  Access checks are disabled on the returned
1624      * method (if any).
1625      */
1626     private static Method getInheritableMethod(Class&lt;?&gt; cl, String name,
1627                                                Class&lt;?&gt;[] argTypes,
1628                                                Class&lt;?&gt; returnType)
1629     {
1630         Method meth = null;
1631         Class&lt;?&gt; defCl = cl;
1632         while (defCl != null) {
1633             try {
1634                 meth = defCl.getDeclaredMethod(name, argTypes);
1635                 break;
1636             } catch (NoSuchMethodException ex) {
1637                 defCl = defCl.getSuperclass();
1638             }
1639         }
1640 
1641         if ((meth == null) || (meth.getReturnType() != returnType)) {
1642             return null;
1643         }
1644         meth.setAccessible(true);
1645         int mods = meth.getModifiers();
1646         if ((mods &amp; (Modifier.STATIC | Modifier.ABSTRACT)) != 0) {
1647             return null;
1648         } else if ((mods &amp; (Modifier.PUBLIC | Modifier.PROTECTED)) != 0) {
1649             return meth;
1650         } else if ((mods &amp; Modifier.PRIVATE) != 0) {
1651             return (cl == defCl) ? meth : null;
1652         } else {
1653             return packageEquals(cl, defCl) ? meth : null;
1654         }
1655     }
1656 
1657     /**
1658      * Returns non-static private method with given signature defined by given
1659      * class, or null if none found.  Access checks are disabled on the
1660      * returned method (if any).
1661      */
1662     private static Method getPrivateMethod(Class&lt;?&gt; cl, String name,
1663                                            Class&lt;?&gt;[] argTypes,
1664                                            Class&lt;?&gt; returnType)
1665     {
1666         try {
1667             Method meth = cl.getDeclaredMethod(name, argTypes);
1668             meth.setAccessible(true);
1669             int mods = meth.getModifiers();
1670             return ((meth.getReturnType() == returnType) &amp;&amp;
1671                     ((mods &amp; Modifier.STATIC) == 0) &amp;&amp;
1672                     ((mods &amp; Modifier.PRIVATE) != 0)) ? meth : null;
1673         } catch (NoSuchMethodException ex) {
1674             return null;
1675         }
1676     }
1677 
1678     /**
1679      * Returns true if classes are defined in the same runtime package, false
1680      * otherwise.
1681      */
1682     private static boolean packageEquals(Class&lt;?&gt; cl1, Class&lt;?&gt; cl2) {
1683         return (cl1.getClassLoader() == cl2.getClassLoader() &amp;&amp;
1684                 cl1.getPackageName().equals(cl2.getPackageName()));
1685     }
1686 
1687     /**
1688      * Compares class names for equality, ignoring package names.  Returns true
1689      * if class names equal, false otherwise.
1690      */
1691     private static boolean classNamesEqual(String name1, String name2) {
1692         int idx1 = name1.lastIndexOf(&#39;.&#39;) + 1;
1693         int idx2 = name2.lastIndexOf(&#39;.&#39;) + 1;
1694         int len1 = name1.length() - idx1;
1695         int len2 = name2.length() - idx2;
1696         return len1 == len2 &amp;&amp;
1697                 name1.regionMatches(idx1, name2, idx2, len1);
1698     }
1699 
1700     /**
1701      * Returns JVM type signature for given list of parameters and return type.
1702      */
1703     private static String getMethodSignature(Class&lt;?&gt;[] paramTypes,
1704                                              Class&lt;?&gt; retType)
1705     {
1706         StringBuilder sb = new StringBuilder();
1707         sb.append(&#39;(&#39;);
1708         for (int i = 0; i &lt; paramTypes.length; i++) {
1709             appendClassSignature(sb, paramTypes[i]);
1710         }
1711         sb.append(&#39;)&#39;);
1712         appendClassSignature(sb, retType);
1713         return sb.toString();
1714     }
1715 
1716     /**
1717      * Convenience method for throwing an exception that is either a
1718      * RuntimeException, Error, or of some unexpected type (in which case it is
1719      * wrapped inside an IOException).
1720      */
1721     private static void throwMiscException(Throwable th) throws IOException {
1722         if (th instanceof RuntimeException) {
1723             throw (RuntimeException) th;
1724         } else if (th instanceof Error) {
1725             throw (Error) th;
1726         } else {
1727             IOException ex = new IOException(&quot;unexpected exception type&quot;);
1728             ex.initCause(th);
1729             throw ex;
1730         }
1731     }
1732 
1733     /**
1734      * Returns ObjectStreamField array describing the serializable fields of
1735      * the given class.  Serializable fields backed by an actual field of the
1736      * class are represented by ObjectStreamFields with corresponding non-null
1737      * Field objects.  Throws InvalidClassException if the (explicitly
1738      * declared) serializable fields are invalid.
1739      */
1740     private static ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl)
1741         throws InvalidClassException
1742     {
1743         if (!Serializable.class.isAssignableFrom(cl))
1744             return NO_FIELDS;
1745 
1746         ObjectStreamField[] fields;
1747         if (isRecord(cl)) {
1748             fields = getDefaultSerialFields(cl);
1749             Arrays.sort(fields);
1750         } else if (!Externalizable.class.isAssignableFrom(cl) &amp;&amp;
1751             !Proxy.isProxyClass(cl) &amp;&amp;
1752                    !cl.isInterface()) {
1753             if ((fields = getDeclaredSerialFields(cl)) == null) {
1754                 fields = getDefaultSerialFields(cl);
1755             }
1756             Arrays.sort(fields);
1757         } else {
1758             fields = NO_FIELDS;
1759         }
1760         return fields;
1761     }
1762 
1763     /**
1764      * Returns serializable fields of given class as defined explicitly by a
1765      * &quot;serialPersistentFields&quot; field, or null if no appropriate
1766      * &quot;serialPersistentFields&quot; field is defined.  Serializable fields backed
1767      * by an actual field of the class are represented by ObjectStreamFields
1768      * with corresponding non-null Field objects.  For compatibility with past
1769      * releases, a &quot;serialPersistentFields&quot; field with a null value is
1770      * considered equivalent to not declaring &quot;serialPersistentFields&quot;.  Throws
1771      * InvalidClassException if the declared serializable fields are
1772      * invalid--e.g., if multiple fields share the same name.
1773      */
1774     private static ObjectStreamField[] getDeclaredSerialFields(Class&lt;?&gt; cl)
1775         throws InvalidClassException
1776     {
1777         ObjectStreamField[] serialPersistentFields = null;
1778         try {
1779             Field f = cl.getDeclaredField(&quot;serialPersistentFields&quot;);
1780             int mask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;
1781             if ((f.getModifiers() &amp; mask) == mask) {
1782                 f.setAccessible(true);
1783                 serialPersistentFields = (ObjectStreamField[]) f.get(null);
1784             }
1785         } catch (Exception ex) {
1786         }
1787         if (serialPersistentFields == null) {
1788             return null;
1789         } else if (serialPersistentFields.length == 0) {
1790             return NO_FIELDS;
1791         }
1792 
1793         ObjectStreamField[] boundFields =
1794             new ObjectStreamField[serialPersistentFields.length];
1795         Set&lt;String&gt; fieldNames = new HashSet&lt;&gt;(serialPersistentFields.length);
1796 
1797         for (int i = 0; i &lt; serialPersistentFields.length; i++) {
1798             ObjectStreamField spf = serialPersistentFields[i];
1799 
1800             String fname = spf.getName();
1801             if (fieldNames.contains(fname)) {
1802                 throw new InvalidClassException(
1803                     &quot;multiple serializable fields named &quot; + fname);
1804             }
1805             fieldNames.add(fname);
1806 
1807             try {
1808                 Field f = cl.getDeclaredField(fname);
1809                 if ((f.getType() == spf.getType()) &amp;&amp;
1810                     ((f.getModifiers() &amp; Modifier.STATIC) == 0))
1811                 {
1812                     boundFields[i] =
1813                         new ObjectStreamField(f, spf.isUnshared(), true);
1814                 }
1815             } catch (NoSuchFieldException ex) {
1816             }
1817             if (boundFields[i] == null) {
1818                 boundFields[i] = new ObjectStreamField(
1819                     fname, spf.getType(), spf.isUnshared());
1820             }
1821         }
1822         return boundFields;
1823     }
1824 
1825     /**
1826      * Returns array of ObjectStreamFields corresponding to all non-static
1827      * non-transient fields declared by given class.  Each ObjectStreamField
1828      * contains a Field object for the field it represents.  If no default
1829      * serializable fields exist, NO_FIELDS is returned.
1830      */
1831     private static ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) {
1832         Field[] clFields = cl.getDeclaredFields();
1833         ArrayList&lt;ObjectStreamField&gt; list = new ArrayList&lt;&gt;();
1834         int mask = Modifier.STATIC | Modifier.TRANSIENT;
1835 
1836         for (int i = 0; i &lt; clFields.length; i++) {
1837             if ((clFields[i].getModifiers() &amp; mask) == 0) {
1838                 list.add(new ObjectStreamField(clFields[i], false, true));
1839             }
1840         }
1841         int size = list.size();
1842         return (size == 0) ? NO_FIELDS :
1843             list.toArray(new ObjectStreamField[size]);
1844     }
1845 
1846     /**
1847      * Returns explicit serial version UID value declared by given class, or
1848      * null if none.
1849      */
1850     private static Long getDeclaredSUID(Class&lt;?&gt; cl) {
1851         try {
1852             Field f = cl.getDeclaredField(&quot;serialVersionUID&quot;);
1853             int mask = Modifier.STATIC | Modifier.FINAL;
1854             if ((f.getModifiers() &amp; mask) == mask) {
1855                 f.setAccessible(true);
1856                 return Long.valueOf(f.getLong(null));
1857             }
1858         } catch (Exception ex) {
1859         }
1860         return null;
1861     }
1862 
1863     /**
1864      * Computes the default serial version UID value for the given class.
1865      */
1866     private static long computeDefaultSUID(Class&lt;?&gt; cl) {
1867         if (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl))
1868         {
1869             return 0L;
1870         }
1871 
1872         try {
1873             ByteArrayOutputStream bout = new ByteArrayOutputStream();
1874             DataOutputStream dout = new DataOutputStream(bout);
1875 
1876             dout.writeUTF(cl.getName());
1877 
1878             int classMods = cl.getModifiers() &amp;
1879                 (Modifier.PUBLIC | Modifier.FINAL |
1880                  Modifier.INTERFACE | Modifier.ABSTRACT);
1881 
1882             /*
1883              * compensate for javac bug in which ABSTRACT bit was set for an
1884              * interface only if the interface declared methods
1885              */
1886             Method[] methods = cl.getDeclaredMethods();
1887             if ((classMods &amp; Modifier.INTERFACE) != 0) {
1888                 classMods = (methods.length &gt; 0) ?
1889                     (classMods | Modifier.ABSTRACT) :
1890                     (classMods &amp; ~Modifier.ABSTRACT);
1891             }
1892             dout.writeInt(classMods);
1893 
1894             if (!cl.isArray()) {
1895                 /*
1896                  * compensate for change in 1.2FCS in which
1897                  * Class.getInterfaces() was modified to return Cloneable and
1898                  * Serializable for array classes.
1899                  */
1900                 Class&lt;?&gt;[] interfaces = cl.getInterfaces();
1901                 String[] ifaceNames = new String[interfaces.length];
1902                 for (int i = 0; i &lt; interfaces.length; i++) {
1903                     ifaceNames[i] = interfaces[i].getName();
1904                 }
1905                 Arrays.sort(ifaceNames);
<a name="5" id="anc5"></a><span class="line-added">1906                 // Skip IdentityObject to keep the computed SVUID the same.</span>
1907                 for (int i = 0; i &lt; ifaceNames.length; i++) {
<a name="6" id="anc6"></a><span class="line-modified">1908                     if (!&quot;java.lang.IdentityObject&quot;.equals(ifaceNames[i]))</span>
<span class="line-added">1909                         dout.writeUTF(ifaceNames[i]);</span>
1910                 }
1911             }
1912 
1913             Field[] fields = cl.getDeclaredFields();
1914             MemberSignature[] fieldSigs = new MemberSignature[fields.length];
1915             for (int i = 0; i &lt; fields.length; i++) {
1916                 fieldSigs[i] = new MemberSignature(fields[i]);
1917             }
1918             Arrays.sort(fieldSigs, new Comparator&lt;&gt;() {
1919                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1920                     return ms1.name.compareTo(ms2.name);
1921                 }
1922             });
1923             for (int i = 0; i &lt; fieldSigs.length; i++) {
1924                 MemberSignature sig = fieldSigs[i];
1925                 int mods = sig.member.getModifiers() &amp;
1926                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1927                      Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE |
1928                      Modifier.TRANSIENT);
1929                 if (((mods &amp; Modifier.PRIVATE) == 0) ||
1930                     ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == 0))
1931                 {
1932                     dout.writeUTF(sig.name);
1933                     dout.writeInt(mods);
1934                     dout.writeUTF(sig.signature);
1935                 }
1936             }
1937 
1938             if (hasStaticInitializer(cl)) {
1939                 dout.writeUTF(&quot;&lt;clinit&gt;&quot;);
1940                 dout.writeInt(Modifier.STATIC);
1941                 dout.writeUTF(&quot;()V&quot;);
1942             }
1943 
1944             Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors();
1945             MemberSignature[] consSigs = new MemberSignature[cons.length];
1946             for (int i = 0; i &lt; cons.length; i++) {
1947                 consSigs[i] = new MemberSignature(cons[i]);
1948             }
1949             Arrays.sort(consSigs, new Comparator&lt;&gt;() {
1950                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1951                     return ms1.signature.compareTo(ms2.signature);
1952                 }
1953             });
1954             for (int i = 0; i &lt; consSigs.length; i++) {
1955                 MemberSignature sig = consSigs[i];
1956                 int mods = sig.member.getModifiers() &amp;
1957                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1958                      Modifier.STATIC | Modifier.FINAL |
1959                      Modifier.SYNCHRONIZED | Modifier.NATIVE |
1960                      Modifier.ABSTRACT | Modifier.STRICT);
1961                 if ((mods &amp; Modifier.PRIVATE) == 0) {
1962                     dout.writeUTF(&quot;&lt;init&gt;&quot;);
1963                     dout.writeInt(mods);
1964                     dout.writeUTF(sig.signature.replace(&#39;/&#39;, &#39;.&#39;));
1965                 }
1966             }
1967 
1968             MemberSignature[] methSigs = new MemberSignature[methods.length];
1969             for (int i = 0; i &lt; methods.length; i++) {
1970                 methSigs[i] = new MemberSignature(methods[i]);
1971             }
1972             Arrays.sort(methSigs, new Comparator&lt;&gt;() {
1973                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1974                     int comp = ms1.name.compareTo(ms2.name);
1975                     if (comp == 0) {
1976                         comp = ms1.signature.compareTo(ms2.signature);
1977                     }
1978                     return comp;
1979                 }
1980             });
1981             for (int i = 0; i &lt; methSigs.length; i++) {
1982                 MemberSignature sig = methSigs[i];
1983                 int mods = sig.member.getModifiers() &amp;
1984                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1985                      Modifier.STATIC | Modifier.FINAL |
1986                      Modifier.SYNCHRONIZED | Modifier.NATIVE |
1987                      Modifier.ABSTRACT | Modifier.STRICT);
1988                 if ((mods &amp; Modifier.PRIVATE) == 0) {
1989                     dout.writeUTF(sig.name);
1990                     dout.writeInt(mods);
1991                     dout.writeUTF(sig.signature.replace(&#39;/&#39;, &#39;.&#39;));
1992                 }
1993             }
1994 
1995             dout.flush();
1996 
1997             MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
1998             byte[] hashBytes = md.digest(bout.toByteArray());
1999             long hash = 0;
2000             for (int i = Math.min(hashBytes.length, 8) - 1; i &gt;= 0; i--) {
2001                 hash = (hash &lt;&lt; 8) | (hashBytes[i] &amp; 0xFF);
2002             }
2003             return hash;
2004         } catch (IOException ex) {
2005             throw new InternalError(ex);
2006         } catch (NoSuchAlgorithmException ex) {
2007             throw new SecurityException(ex.getMessage());
2008         }
2009     }
2010 
2011     /**
2012      * Returns true if the given class defines a static initializer method,
2013      * false otherwise.
2014      */
2015     private static native boolean hasStaticInitializer(Class&lt;?&gt; cl);
2016 
2017     /**
2018      * Class for computing and caching field/constructor/method signatures
2019      * during serialVersionUID calculation.
2020      */
2021     private static class MemberSignature {
2022 
2023         public final Member member;
2024         public final String name;
2025         public final String signature;
2026 
2027         public MemberSignature(Field field) {
2028             member = field;
2029             name = field.getName();
2030             signature = getClassSignature(field.getType());
2031         }
2032 
2033         public MemberSignature(Constructor&lt;?&gt; cons) {
2034             member = cons;
2035             name = cons.getName();
2036             signature = getMethodSignature(
2037                 cons.getParameterTypes(), Void.TYPE);
2038         }
2039 
2040         public MemberSignature(Method meth) {
2041             member = meth;
2042             name = meth.getName();
2043             signature = getMethodSignature(
2044                 meth.getParameterTypes(), meth.getReturnType());
2045         }
2046     }
2047 
2048     /**
2049      * Class for setting and retrieving serializable field values in batch.
2050      */
2051     // REMIND: dynamically generate these?
2052     private static class FieldReflector {
2053 
2054         /** handle for performing unsafe operations */
2055         private static final Unsafe unsafe = Unsafe.getUnsafe();
2056 
2057         /** fields to operate on */
2058         private final ObjectStreamField[] fields;
2059         /** number of primitive fields */
2060         private final int numPrimFields;
2061         /** unsafe field keys for reading fields - may contain dupes */
2062         private final long[] readKeys;
2063         /** unsafe fields keys for writing fields - no dupes */
2064         private final long[] writeKeys;
2065         /** field data offsets */
2066         private final int[] offsets;
2067         /** field type codes */
2068         private final char[] typeCodes;
2069         /** field types */
2070         private final Class&lt;?&gt;[] types;
2071 
2072         /**
2073          * Constructs FieldReflector capable of setting/getting values from the
2074          * subset of fields whose ObjectStreamFields contain non-null
2075          * reflective Field objects.  ObjectStreamFields with null Fields are
2076          * treated as filler, for which get operations return default values
2077          * and set operations discard given values.
2078          */
2079         FieldReflector(ObjectStreamField[] fields) {
2080             this.fields = fields;
2081             int nfields = fields.length;
2082             readKeys = new long[nfields];
2083             writeKeys = new long[nfields];
2084             offsets = new int[nfields];
2085             typeCodes = new char[nfields];
2086             ArrayList&lt;Class&lt;?&gt;&gt; typeList = new ArrayList&lt;&gt;();
2087             Set&lt;Long&gt; usedKeys = new HashSet&lt;&gt;();
2088 
2089 
2090             for (int i = 0; i &lt; nfields; i++) {
2091                 ObjectStreamField f = fields[i];
2092                 Field rf = f.getField();
2093                 long key = (rf != null) ?
2094                     unsafe.objectFieldOffset(rf) : Unsafe.INVALID_FIELD_OFFSET;
2095                 readKeys[i] = key;
2096                 writeKeys[i] = usedKeys.add(key) ?
2097                     key : Unsafe.INVALID_FIELD_OFFSET;
2098                 offsets[i] = f.getOffset();
2099                 typeCodes[i] = f.getTypeCode();
2100                 if (!f.isPrimitive()) {
2101                     typeList.add((rf != null) ? rf.getType() : null);
2102                 }
2103             }
2104 
2105             types = typeList.toArray(new Class&lt;?&gt;[typeList.size()]);
2106             numPrimFields = nfields - types.length;
2107         }
2108 
2109         /**
2110          * Returns list of ObjectStreamFields representing fields operated on
2111          * by this reflector.  The shared/unshared values and Field objects
2112          * contained by ObjectStreamFields in the list reflect their bindings
2113          * to locally defined serializable fields.
2114          */
2115         ObjectStreamField[] getFields() {
2116             return fields;
2117         }
2118 
2119         /**
2120          * Fetches the serializable primitive field values of object obj and
2121          * marshals them into byte array buf starting at offset 0.  The caller
2122          * is responsible for ensuring that obj is of the proper type.
2123          */
2124         void getPrimFieldValues(Object obj, byte[] buf) {
2125             if (obj == null) {
2126                 throw new NullPointerException();
2127             }
2128             /* assuming checkDefaultSerialize() has been called on the class
2129              * descriptor this FieldReflector was obtained from, no field keys
2130              * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.
2131              */
2132             for (int i = 0; i &lt; numPrimFields; i++) {
2133                 long key = readKeys[i];
2134                 int off = offsets[i];
2135                 switch (typeCodes[i]) {
2136                     case &#39;Z&#39;:
2137                         Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));
2138                         break;
2139 
2140                     case &#39;B&#39;:
2141                         buf[off] = unsafe.getByte(obj, key);
2142                         break;
2143 
2144                     case &#39;C&#39;:
2145                         Bits.putChar(buf, off, unsafe.getChar(obj, key));
2146                         break;
2147 
2148                     case &#39;S&#39;:
2149                         Bits.putShort(buf, off, unsafe.getShort(obj, key));
2150                         break;
2151 
2152                     case &#39;I&#39;:
2153                         Bits.putInt(buf, off, unsafe.getInt(obj, key));
2154                         break;
2155 
2156                     case &#39;F&#39;:
2157                         Bits.putFloat(buf, off, unsafe.getFloat(obj, key));
2158                         break;
2159 
2160                     case &#39;J&#39;:
2161                         Bits.putLong(buf, off, unsafe.getLong(obj, key));
2162                         break;
2163 
2164                     case &#39;D&#39;:
2165                         Bits.putDouble(buf, off, unsafe.getDouble(obj, key));
2166                         break;
2167 
2168                     default:
2169                         throw new InternalError();
2170                 }
2171             }
2172         }
2173 
2174         /**
2175          * Sets the serializable primitive fields of object obj using values
2176          * unmarshalled from byte array buf starting at offset 0.  The caller
2177          * is responsible for ensuring that obj is of the proper type.
2178          */
2179         void setPrimFieldValues(Object obj, byte[] buf) {
2180             if (obj == null) {
2181                 throw new NullPointerException();
2182             }
2183             for (int i = 0; i &lt; numPrimFields; i++) {
2184                 long key = writeKeys[i];
2185                 if (key == Unsafe.INVALID_FIELD_OFFSET) {
2186                     continue;           // discard value
2187                 }
2188                 int off = offsets[i];
2189                 switch (typeCodes[i]) {
2190                     case &#39;Z&#39;:
2191                         unsafe.putBoolean(obj, key, Bits.getBoolean(buf, off));
2192                         break;
2193 
2194                     case &#39;B&#39;:
2195                         unsafe.putByte(obj, key, buf[off]);
2196                         break;
2197 
2198                     case &#39;C&#39;:
2199                         unsafe.putChar(obj, key, Bits.getChar(buf, off));
2200                         break;
2201 
2202                     case &#39;S&#39;:
2203                         unsafe.putShort(obj, key, Bits.getShort(buf, off));
2204                         break;
2205 
2206                     case &#39;I&#39;:
2207                         unsafe.putInt(obj, key, Bits.getInt(buf, off));
2208                         break;
2209 
2210                     case &#39;F&#39;:
2211                         unsafe.putFloat(obj, key, Bits.getFloat(buf, off));
2212                         break;
2213 
2214                     case &#39;J&#39;:
2215                         unsafe.putLong(obj, key, Bits.getLong(buf, off));
2216                         break;
2217 
2218                     case &#39;D&#39;:
2219                         unsafe.putDouble(obj, key, Bits.getDouble(buf, off));
2220                         break;
2221 
2222                     default:
2223                         throw new InternalError();
2224                 }
2225             }
2226         }
2227 
2228         /**
2229          * Fetches the serializable object field values of object obj and
2230          * stores them in array vals starting at offset 0.  The caller is
2231          * responsible for ensuring that obj is of the proper type.
2232          */
2233         void getObjFieldValues(Object obj, Object[] vals) {
2234             if (obj == null) {
2235                 throw new NullPointerException();
2236             }
2237             /* assuming checkDefaultSerialize() has been called on the class
2238              * descriptor this FieldReflector was obtained from, no field keys
2239              * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.
2240              */
2241             for (int i = numPrimFields; i &lt; fields.length; i++) {
2242                 switch (typeCodes[i]) {
2243                     case &#39;L&#39;:
2244                     case &#39;[&#39;:
2245                         vals[offsets[i]] = unsafe.getReference(obj, readKeys[i]);
2246                         break;
2247 
2248                     default:
2249                         throw new InternalError();
2250                 }
2251             }
2252         }
2253 
2254         /**
2255          * Checks that the given values, from array vals starting at offset 0,
2256          * are assignable to the given serializable object fields.
2257          * @throws ClassCastException if any value is not assignable
2258          */
2259         void checkObjectFieldValueTypes(Object obj, Object[] vals) {
2260             setObjFieldValues(obj, vals, true);
2261         }
2262 
2263         /**
2264          * Sets the serializable object fields of object obj using values from
2265          * array vals starting at offset 0.  The caller is responsible for
2266          * ensuring that obj is of the proper type; however, attempts to set a
2267          * field with a value of the wrong type will trigger an appropriate
2268          * ClassCastException.
2269          */
2270         void setObjFieldValues(Object obj, Object[] vals) {
2271             setObjFieldValues(obj, vals, false);
2272         }
2273 
2274         private void setObjFieldValues(Object obj, Object[] vals, boolean dryRun) {
2275             if (obj == null) {
2276                 throw new NullPointerException();
2277             }
2278             for (int i = numPrimFields; i &lt; fields.length; i++) {
2279                 long key = writeKeys[i];
2280                 if (key == Unsafe.INVALID_FIELD_OFFSET) {
2281                     continue;           // discard value
2282                 }
2283                 switch (typeCodes[i]) {
2284                     case &#39;L&#39;:
2285                     case &#39;[&#39;:
2286                         Object val = vals[offsets[i]];
2287                         if (val != null &amp;&amp;
2288                             !types[i - numPrimFields].isInstance(val))
2289                         {
2290                             Field f = fields[i].getField();
2291                             throw new ClassCastException(
2292                                 &quot;cannot assign instance of &quot; +
2293                                 val.getClass().getName() + &quot; to field &quot; +
2294                                 f.getDeclaringClass().getName() + &quot;.&quot; +
2295                                 f.getName() + &quot; of type &quot; +
2296                                 f.getType().getName() + &quot; in instance of &quot; +
2297                                 obj.getClass().getName());
2298                         }
2299                         if (!dryRun)
2300                             unsafe.putReference(obj, key, val);
2301                         break;
2302 
2303                     default:
2304                         throw new InternalError();
2305                 }
2306             }
2307         }
2308     }
2309 
2310     /**
2311      * Matches given set of serializable fields with serializable fields
2312      * described by the given local class descriptor, and returns a
2313      * FieldReflector instance capable of setting/getting values from the
2314      * subset of fields that match (non-matching fields are treated as filler,
2315      * for which get operations return default values and set operations
2316      * discard given values).  Throws InvalidClassException if unresolvable
2317      * type conflicts exist between the two sets of fields.
2318      */
2319     private static FieldReflector getReflector(ObjectStreamField[] fields,
2320                                                ObjectStreamClass localDesc)
2321         throws InvalidClassException
2322     {
2323         // class irrelevant if no fields
2324         Class&lt;?&gt; cl = (localDesc != null &amp;&amp; fields.length &gt; 0) ?
2325             localDesc.cl : null;
2326         processQueue(Caches.reflectorsQueue, Caches.reflectors);
2327         FieldReflectorKey key = new FieldReflectorKey(cl, fields,
2328                                                       Caches.reflectorsQueue);
2329         Reference&lt;?&gt; ref = Caches.reflectors.get(key);
2330         Object entry = null;
2331         if (ref != null) {
2332             entry = ref.get();
2333         }
2334         EntryFuture future = null;
2335         if (entry == null) {
2336             EntryFuture newEntry = new EntryFuture();
2337             Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);
2338             do {
2339                 if (ref != null) {
2340                     Caches.reflectors.remove(key, ref);
2341                 }
2342                 ref = Caches.reflectors.putIfAbsent(key, newRef);
2343                 if (ref != null) {
2344                     entry = ref.get();
2345                 }
2346             } while (ref != null &amp;&amp; entry == null);
2347             if (entry == null) {
2348                 future = newEntry;
2349             }
2350         }
2351 
2352         if (entry instanceof FieldReflector) {  // check common case first
2353             return (FieldReflector) entry;
2354         } else if (entry instanceof EntryFuture) {
2355             entry = ((EntryFuture) entry).get();
2356         } else if (entry == null) {
2357             try {
2358                 entry = new FieldReflector(matchFields(fields, localDesc));
2359             } catch (Throwable th) {
2360                 entry = th;
2361             }
2362             future.set(entry);
2363             Caches.reflectors.put(key, new SoftReference&lt;&gt;(entry));
2364         }
2365 
2366         if (entry instanceof FieldReflector) {
2367             return (FieldReflector) entry;
2368         } else if (entry instanceof InvalidClassException) {
2369             throw (InvalidClassException) entry;
2370         } else if (entry instanceof RuntimeException) {
2371             throw (RuntimeException) entry;
2372         } else if (entry instanceof Error) {
2373             throw (Error) entry;
2374         } else {
2375             throw new InternalError(&quot;unexpected entry: &quot; + entry);
2376         }
2377     }
2378 
2379     /**
2380      * FieldReflector cache lookup key.  Keys are considered equal if they
2381      * refer to the same class and equivalent field formats.
2382      */
2383     private static class FieldReflectorKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2384 
2385         private final String[] sigs;
2386         private final int hash;
2387         private final boolean nullClass;
2388 
2389         FieldReflectorKey(Class&lt;?&gt; cl, ObjectStreamField[] fields,
2390                           ReferenceQueue&lt;Class&lt;?&gt;&gt; queue)
2391         {
2392             super(cl, queue);
2393             nullClass = (cl == null);
2394             sigs = new String[2 * fields.length];
2395             for (int i = 0, j = 0; i &lt; fields.length; i++) {
2396                 ObjectStreamField f = fields[i];
2397                 sigs[j++] = f.getName();
2398                 sigs[j++] = f.getSignature();
2399             }
2400             hash = System.identityHashCode(cl) + Arrays.hashCode(sigs);
2401         }
2402 
2403         public int hashCode() {
2404             return hash;
2405         }
2406 
2407         public boolean equals(Object obj) {
2408             if (obj == this) {
2409                 return true;
2410             }
2411 
2412             if (obj instanceof FieldReflectorKey) {
2413                 FieldReflectorKey other = (FieldReflectorKey) obj;
2414                 Class&lt;?&gt; referent;
2415                 return (nullClass ? other.nullClass
2416                                   : ((referent = get()) != null) &amp;&amp;
2417                                     (referent == other.get())) &amp;&amp;
2418                         Arrays.equals(sigs, other.sigs);
2419             } else {
2420                 return false;
2421             }
2422         }
2423     }
2424 
2425     /**
2426      * Matches given set of serializable fields with serializable fields
2427      * obtained from the given local class descriptor (which contain bindings
2428      * to reflective Field objects).  Returns list of ObjectStreamFields in
2429      * which each ObjectStreamField whose signature matches that of a local
2430      * field contains a Field object for that field; unmatched
2431      * ObjectStreamFields contain null Field objects.  Shared/unshared settings
2432      * of the returned ObjectStreamFields also reflect those of matched local
2433      * ObjectStreamFields.  Throws InvalidClassException if unresolvable type
2434      * conflicts exist between the two sets of fields.
2435      */
2436     private static ObjectStreamField[] matchFields(ObjectStreamField[] fields,
2437                                                    ObjectStreamClass localDesc)
2438         throws InvalidClassException
2439     {
2440         ObjectStreamField[] localFields = (localDesc != null) ?
2441             localDesc.fields : NO_FIELDS;
2442 
2443         /*
2444          * Even if fields == localFields, we cannot simply return localFields
2445          * here.  In previous implementations of serialization,
2446          * ObjectStreamField.getType() returned Object.class if the
2447          * ObjectStreamField represented a non-primitive field and belonged to
2448          * a non-local class descriptor.  To preserve this (questionable)
2449          * behavior, the ObjectStreamField instances returned by matchFields
2450          * cannot report non-primitive types other than Object.class; hence
2451          * localFields cannot be returned directly.
2452          */
2453 
2454         ObjectStreamField[] matches = new ObjectStreamField[fields.length];
2455         for (int i = 0; i &lt; fields.length; i++) {
2456             ObjectStreamField f = fields[i], m = null;
2457             for (int j = 0; j &lt; localFields.length; j++) {
2458                 ObjectStreamField lf = localFields[j];
2459                 if (f.getName().equals(lf.getName())) {
2460                     if ((f.isPrimitive() || lf.isPrimitive()) &amp;&amp;
2461                         f.getTypeCode() != lf.getTypeCode())
2462                     {
2463                         throw new InvalidClassException(localDesc.name,
2464                             &quot;incompatible types for field &quot; + f.getName());
2465                     }
2466                     if (lf.getField() != null) {
2467                         m = new ObjectStreamField(
2468                             lf.getField(), lf.isUnshared(), false);
2469                     } else {
2470                         m = new ObjectStreamField(
2471                             lf.getName(), lf.getSignature(), lf.isUnshared());
2472                     }
2473                 }
2474             }
2475             if (m == null) {
2476                 m = new ObjectStreamField(
2477                     f.getName(), f.getSignature(), false);
2478             }
2479             m.setOffset(f.getOffset());
2480             matches[i] = m;
2481         }
2482         return matches;
2483     }
2484 
2485     /**
2486      * Removes from the specified map any keys that have been enqueued
2487      * on the specified reference queue.
2488      */
2489     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
2490                              ConcurrentMap&lt;? extends
2491                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
2492     {
2493         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
2494         while((ref = queue.poll()) != null) {
2495             map.remove(ref);
2496         }
2497     }
2498 
2499     /**
2500      *  Weak key for Class objects.
2501      *
2502      **/
2503     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2504         /**
2505          * saved value of the referent&#39;s identity hash code, to maintain
2506          * a consistent hash code after the referent has been cleared
2507          */
2508         private final int hash;
2509 
2510         /**
2511          * Create a new WeakClassKey to the given object, registered
2512          * with a queue.
2513          */
2514         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2515             super(cl, refQueue);
2516             hash = System.identityHashCode(cl);
2517         }
2518 
2519         /**
2520          * Returns the identity hash code of the original referent.
2521          */
2522         public int hashCode() {
2523             return hash;
2524         }
2525 
2526         /**
2527          * Returns true if the given object is this identical
2528          * WeakClassKey instance, or, if this object&#39;s referent has not
2529          * been cleared, if the given object is another WeakClassKey
2530          * instance with the identical non-null referent as this one.
2531          */
2532         public boolean equals(Object obj) {
2533             if (obj == this) {
2534                 return true;
2535             }
2536 
2537             if (obj instanceof WeakClassKey) {
2538                 Object referent = get();
2539                 return (referent != null) &amp;&amp;
2540                        (referent == ((WeakClassKey) obj).get());
2541             } else {
2542                 return false;
2543             }
2544         }
2545     }
2546 
2547     // a LRA cache of record deserialization constructors
2548     @SuppressWarnings(&quot;serial&quot;)
2549     private static final class DeserializationConstructorsCache
2550         extends ConcurrentHashMap&lt;DeserializationConstructorsCache.Key, MethodHandle&gt;  {
2551 
2552         // keep max. 10 cached entries - when the 11th element is inserted the oldest
2553         // is removed and 10 remains - 11 is the biggest map size where internal
2554         // table of 16 elements is sufficient (inserting 12th element would resize it to 32)
2555         private static final int MAX_SIZE = 10;
2556         private Key.Impl first, last; // first and last in FIFO queue
2557 
2558         DeserializationConstructorsCache() {
2559             // start small - if there is more than one shape of ObjectStreamClass
2560             // deserialized, there will typically be two (current version and previous version)
2561             super(2);
2562         }
2563 
2564         MethodHandle get(ObjectStreamField[] fields) {
2565             return get(new Key.Lookup(fields));
2566         }
2567 
2568         synchronized MethodHandle putIfAbsentAndGet(ObjectStreamField[] fields, MethodHandle mh) {
2569             Key.Impl key = new Key.Impl(fields);
2570             var oldMh = putIfAbsent(key, mh);
2571             if (oldMh != null) return oldMh;
2572             // else we did insert new entry -&gt; link the new key as last
2573             if (last == null) {
2574                 last = first = key;
2575             } else {
2576                 last = (last.next = key);
2577             }
2578             // may need to remove first
2579             if (size() &gt; MAX_SIZE) {
2580                 assert first != null;
2581                 remove(first);
2582                 first = first.next;
2583                 if (first == null) {
2584                     last = null;
2585                 }
2586             }
2587             return mh;
2588         }
2589 
2590         // a key composed of ObjectStreamField[] names and types
2591         static abstract class Key {
2592             abstract int length();
2593             abstract String fieldName(int i);
2594             abstract Class&lt;?&gt; fieldType(int i);
2595 
2596             @Override
2597             public final int hashCode() {
2598                 int n = length();
2599                 int h = 0;
2600                 for (int i = 0; i &lt; n; i++) h = h * 31 + fieldType(i).hashCode();
2601                 for (int i = 0; i &lt; n; i++) h = h * 31 + fieldName(i).hashCode();
2602                 return h;
2603             }
2604 
2605             @Override
2606             public final boolean equals(Object obj) {
2607                 if (!(obj instanceof Key)) return false;
2608                 Key other = (Key) obj;
2609                 int n = length();
2610                 if (n != other.length()) return false;
2611                 for (int i = 0; i &lt; n; i++) if (fieldType(i) != other.fieldType(i)) return false;
2612                 for (int i = 0; i &lt; n; i++) if (!fieldName(i).equals(other.fieldName(i))) return false;
2613                 return true;
2614             }
2615 
2616             // lookup key - just wraps ObjectStreamField[]
2617             static final class Lookup extends Key {
2618                 final ObjectStreamField[] fields;
2619 
2620                 Lookup(ObjectStreamField[] fields) { this.fields = fields; }
2621 
2622                 @Override
2623                 int length() { return fields.length; }
2624 
2625                 @Override
2626                 String fieldName(int i) { return fields[i].getName(); }
2627 
2628                 @Override
2629                 Class&lt;?&gt; fieldType(int i) { return fields[i].getType(); }
2630             }
2631 
2632             // real key - copies field names and types and forms FIFO queue in cache
2633             static final class Impl extends Key {
2634                 Impl next;
2635                 final String[] fieldNames;
2636                 final Class&lt;?&gt;[] fieldTypes;
2637 
2638                 Impl(ObjectStreamField[] fields) {
2639                     this.fieldNames = new String[fields.length];
2640                     this.fieldTypes = new Class&lt;?&gt;[fields.length];
2641                     for (int i = 0; i &lt; fields.length; i++) {
2642                         fieldNames[i] = fields[i].getName();
2643                         fieldTypes[i] = fields[i].getType();
2644                     }
2645                 }
2646 
2647                 @Override
2648                 int length() { return fieldNames.length; }
2649 
2650                 @Override
2651                 String fieldName(int i) { return fieldNames[i]; }
2652 
2653                 @Override
2654                 Class&lt;?&gt; fieldType(int i) { return fieldTypes[i]; }
2655             }
2656         }
2657     }
2658 
2659     /** Record specific support for retrieving and binding stream field values. */
2660     static final class RecordSupport {
2661         /**
2662          * Returns canonical record constructor adapted to take two arguments:
2663          * {@code (byte[] primValues, Object[] objValues)}
2664          * and return
2665          * {@code Object}
2666          */
2667         @SuppressWarnings(&quot;preview&quot;)
2668         static MethodHandle deserializationCtr(ObjectStreamClass desc) {
2669             // check the cached value 1st
2670             MethodHandle mh = desc.deserializationCtr;
2671             if (mh != null) return mh;
2672             mh = desc.deserializationCtrs.get(desc.getFields(false));
2673             if (mh != null) return desc.deserializationCtr = mh;
2674 
2675             // retrieve record components
2676             RecordComponent[] recordComponents;
2677             try {
2678                 Class&lt;?&gt; cls = desc.forClass();
2679                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;
2680                 recordComponents = AccessController.doPrivileged(pa);
2681             } catch (PrivilegedActionException e) {
2682                 throw new InternalError(e.getCause());
2683             }
2684 
2685             // retrieve the canonical constructor
2686             // (T1, T2, ..., Tn):TR
2687             mh = desc.getRecordConstructor();
2688 
2689             // change return type to Object
2690             // (T1, T2, ..., Tn):TR -&gt; (T1, T2, ..., Tn):Object
2691             mh = mh.asType(mh.type().changeReturnType(Object.class));
2692 
2693             // drop last 2 arguments representing primValues and objValues arrays
2694             // (T1, T2, ..., Tn):Object -&gt; (T1, T2, ..., Tn, byte[], Object[]):Object
2695             mh = MethodHandles.dropArguments(mh, mh.type().parameterCount(), byte[].class, Object[].class);
2696 
2697             for (int i = recordComponents.length-1; i &gt;= 0; i--) {
2698                 String name = recordComponents[i].getName();
2699                 Class&lt;?&gt; type = recordComponents[i].getType();
2700                 // obtain stream field extractor that extracts argument at
2701                 // position i (Ti+1) from primValues and objValues arrays
2702                 // (byte[], Object[]):Ti+1
2703                 MethodHandle combiner = streamFieldExtractor(name, type, desc);
2704                 // fold byte[] privValues and Object[] objValues into argument at position i (Ti+1)
2705                 // (..., Ti, Ti+1, byte[], Object[]):Object -&gt; (..., Ti, byte[], Object[]):Object
2706                 mh = MethodHandles.foldArguments(mh, i, combiner);
2707             }
2708             // what we are left with is a MethodHandle taking just the primValues
2709             // and objValues arrays and returning the constructed record instance
2710             // (byte[], Object[]):Object
2711 
2712             // store it into cache and return the 1st value stored
2713             return desc.deserializationCtr =
2714                 desc.deserializationCtrs.putIfAbsentAndGet(desc.getFields(false), mh);
2715         }
2716 
2717         /** Returns the number of primitive fields for the given descriptor. */
2718         private static int numberPrimValues(ObjectStreamClass desc) {
2719             ObjectStreamField[] fields = desc.getFields();
2720             int primValueCount = 0;
2721             for (int i = 0; i &lt; fields.length; i++) {
2722                 if (fields[i].isPrimitive())
2723                     primValueCount++;
2724                 else
2725                     break;  // can be no more
2726             }
2727             return primValueCount;
2728         }
2729 
2730         /**
2731          * Returns extractor MethodHandle taking the primValues and objValues arrays
2732          * and extracting the argument of canonical constructor with given name and type
2733          * or producing  default value for the given type if the field is absent.
2734          */
2735         private static MethodHandle streamFieldExtractor(String pName,
2736                                                          Class&lt;?&gt; pType,
2737                                                          ObjectStreamClass desc) {
2738             ObjectStreamField[] fields = desc.getFields(false);
2739 
2740             for (int i = 0; i &lt; fields.length; i++) {
2741                 ObjectStreamField f = fields[i];
2742                 String fName = f.getName();
2743                 if (!fName.equals(pName))
2744                     continue;
2745 
2746                 Class&lt;?&gt; fType = f.getField().getType();
2747                 if (!pType.isAssignableFrom(fType))
2748                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);
2749 
2750                 if (f.isPrimitive()) {
2751                     // (byte[], int):fType
2752                     MethodHandle mh = PRIM_VALUE_EXTRACTORS.get(fType);
2753                     if (mh == null) {
2754                         throw new InternalError(&quot;Unexpected type: &quot; + fType);
2755                     }
2756                     // bind offset
2757                     // (byte[], int):fType -&gt; (byte[]):fType
2758                     mh = MethodHandles.insertArguments(mh, 1, f.getOffset());
2759                     // drop objValues argument
2760                     // (byte[]):fType -&gt; (byte[], Object[]):fType
2761                     mh = MethodHandles.dropArguments(mh, 1, Object[].class);
2762                     // adapt return type to pType
2763                     // (byte[], Object[]):fType -&gt; (byte[], Object[]):pType
2764                     if (pType != fType) {
2765                         mh = mh.asType(mh.type().changeReturnType(pType));
2766                     }
2767                     return mh;
2768                 } else { // reference
2769                     // (Object[], int):Object
2770                     MethodHandle mh = MethodHandles.arrayElementGetter(Object[].class);
2771                     // bind index
2772                     // (Object[], int):Object -&gt; (Object[]):Object
2773                     mh = MethodHandles.insertArguments(mh, 1, i - numberPrimValues(desc));
2774                     // drop primValues argument
2775                     // (Object[]):Object -&gt; (byte[], Object[]):Object
2776                     mh = MethodHandles.dropArguments(mh, 0, byte[].class);
2777                     // adapt return type to pType
2778                     // (byte[], Object[]):Object -&gt; (byte[], Object[]):pType
2779                     if (pType != Object.class) {
2780                         mh = mh.asType(mh.type().changeReturnType(pType));
2781                     }
2782                     return mh;
2783                 }
2784             }
2785 
2786             // return default value extractor if no field matches pName
2787             return MethodHandles.empty(MethodType.methodType(pType, byte[].class, Object[].class));
2788         }
2789 
2790         private static final Map&lt;Class&lt;?&gt;, MethodHandle&gt; PRIM_VALUE_EXTRACTORS;
2791         static {
2792             var lkp = MethodHandles.lookup();
2793             try {
2794                 PRIM_VALUE_EXTRACTORS = Map.of(
2795                     byte.class, MethodHandles.arrayElementGetter(byte[].class),
2796                     short.class, lkp.findStatic(Bits.class, &quot;getShort&quot;, MethodType.methodType(short.class, byte[].class, int.class)),
2797                     int.class, lkp.findStatic(Bits.class, &quot;getInt&quot;, MethodType.methodType(int.class, byte[].class, int.class)),
2798                     long.class, lkp.findStatic(Bits.class, &quot;getLong&quot;, MethodType.methodType(long.class, byte[].class, int.class)),
2799                     float.class, lkp.findStatic(Bits.class, &quot;getFloat&quot;, MethodType.methodType(float.class, byte[].class, int.class)),
2800                     double.class, lkp.findStatic(Bits.class, &quot;getDouble&quot;, MethodType.methodType(double.class, byte[].class, int.class)),
2801                     char.class, lkp.findStatic(Bits.class, &quot;getChar&quot;, MethodType.methodType(char.class, byte[].class, int.class)),
2802                     boolean.class, lkp.findStatic(Bits.class, &quot;getBoolean&quot;, MethodType.methodType(boolean.class, byte[].class, int.class))
2803                 );
2804             } catch (NoSuchMethodException | IllegalAccessException e) {
2805                 throw new InternalError(&quot;Can&#39;t lookup Bits.getXXX&quot;, e);
2806             }
2807         }
2808     }
2809 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>