<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;
  34 import java.lang.reflect.Field;
  35 import java.lang.reflect.Modifier;
  36 import java.nio.ByteOrder;
  37 import java.util.Arrays;
  38 import java.util.Comparator;
  39 import java.util.HashMap;
  40 
  41 import jdk.vm.ci.common.JVMCIError;
  42 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  45 import jdk.vm.ci.meta.Assumptions.LeafType;
  46 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  47 import jdk.vm.ci.meta.Constant;
  48 import jdk.vm.ci.meta.JavaConstant;
  49 import jdk.vm.ci.meta.JavaKind;
  50 import jdk.vm.ci.meta.JavaType;
  51 import jdk.vm.ci.meta.ResolvedJavaField;
  52 import jdk.vm.ci.meta.ResolvedJavaMethod;
  53 import jdk.vm.ci.meta.ResolvedJavaType;
  54 import jdk.vm.ci.meta.UnresolvedJavaField;
  55 import jdk.vm.ci.meta.UnresolvedJavaType;
  56 
  57 /**
  58  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes. This class is not
  59  * an {@link MetaspaceHandleObject} because it doesn&#39;t have to be scanned for GC. It&#39;s liveness is
  60  * maintained by a reference to the {@link Class} instance.
  61  */
  62 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceObject {
  63 
  64     private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
  65     private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;
  66     private static final SortByOffset fieldSortingMethod = new SortByOffset();
  67 
  68     /**
  69      * The Java class this type represents.
  70      */
  71     private final long metadataPointer;
  72 
  73     private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
  74     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
  75     private volatile HotSpotResolvedJavaField[] instanceFields;
  76     private volatile HotSpotResolvedObjectTypeImpl[] interfaces;
  77     private HotSpotConstantPool constantPool;
  78     private final JavaConstant mirror;
  79     private HotSpotResolvedObjectTypeImpl superClass;
  80 
  81     /**
  82      * Managed exclusively by {@link HotSpotJDKReflection#getField}.
  83      */
  84     HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;
  85 
  86     static HotSpotResolvedObjectTypeImpl getJavaLangObject() {
  87         return runtime().getJavaLangObject();
  88     }
  89 
  90     /**
  91      * Gets the JVMCI mirror from a HotSpot type.
  92      *
  93      * Called from the VM.
  94      *
  95      * @param klassPointer a native pointer to the Klass*
  96      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  97      */
  98     @SuppressWarnings(&quot;unused&quot;)
  99     @VMEntryPoint
 100     private static HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {
 101         return runtime().fromMetaspace(klassPointer, signature);
 102     }
 103 
 104     /**
 105      * Creates the JVMCI mirror for a {@link Class} object.
 106      *
 107      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 108      * {@link Class} type.
 109      * &lt;/p&gt;
 110      *
 111      * @param metadataPointer the Klass* to create the mirror for
 112      */
 113     @SuppressWarnings(&quot;try&quot;)
 114     HotSpotResolvedObjectTypeImpl(long metadataPointer, String name) {
 115         super(name);
 116         assert metadataPointer != 0;
 117         this.metadataPointer = metadataPointer;
 118 
 119         // The mirror object must be in the global scope since
 120         // this object will be cached in HotSpotJVMCIRuntime.resolvedJavaTypes
 121         // and live across more than one compilation.
 122         try (HotSpotObjectConstantScope global = HotSpotObjectConstantScope.enterGlobalScope()) {
 123             this.mirror = runtime().compilerToVm.getJavaMirror(this);
 124             assert getName().charAt(0) != &#39;[&#39; || isArray() : getName();
 125         }
 126     }
 127 
 128     /**
 129      * Gets the metaspace Klass for this type.
 130      */
 131     long getMetaspaceKlass() {
 132         long metaspacePointer = getMetaspacePointer();
 133         if (metaspacePointer == 0) {
 134             throw new NullPointerException(&quot;Klass* is null&quot;);
 135         }
 136         return metaspacePointer;
 137     }
 138 
 139     @Override
 140     public long getMetaspacePointer() {
 141         return metadataPointer;
 142     }
 143 
 144     @Override
 145     public int getModifiers() {
 146         if (isArray()) {
 147             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 148         } else {
 149             return getAccessFlags() &amp; jvmClassModifiers();
 150         }
 151     }
 152 
 153     public int getAccessFlags() {
 154         HotSpotVMConfig config = config();
 155         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 156     }
 157 
 158     @Override
 159     public ResolvedJavaType getComponentType() {
 160         return runtime().compilerToVm.getComponentType(this);
 161     }
 162 
 163     @Override
 164     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 165         if (isLeaf()) {
 166             // No assumptions are required.
 167             return new AssumptionResult&lt;&gt;(this);
 168         }
 169         HotSpotVMConfig config = config();
 170         if (isArray()) {
 171             ResolvedJavaType elementalType = getElementalType();
 172             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 173             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 174                 /*
 175                  * If the elementType is leaf then the array is leaf under the same assumptions but
 176                  * only if the element type is exactly the leaf type. The element type can be
 177                  * abstract even if there is only one implementor of the abstract type.
 178                  */
 179                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 180                 result.add(elementType);
 181                 return result;
 182             }
 183             return null;
 184         } else if (isInterface()) {
 185             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 186             /*
 187              * If the implementor field contains itself that indicates that the interface has more
 188              * than one implementors (see: InstanceKlass::add_implementor).
 189              */
 190             if (implementor == null || implementor.equals(this)) {
 191                 return null;
 192             }
 193 
 194             assert !implementor.isInterface();
 195             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 196                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 197                 if (leafConcreteSubtype != null) {
 198                     assert !leafConcreteSubtype.getResult().equals(implementor);
 199                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 200                     // Accumulate leaf assumptions and return the combined result.
 201                     newResult.add(leafConcreteSubtype);
 202                     return newResult;
 203                 }
 204                 return null;
 205             }
 206             return concreteSubtype(implementor);
 207         } else {
 208             HotSpotResolvedObjectTypeImpl type = this;
 209             while (type.isAbstract()) {
 210                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 211                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 212                     return null;
 213                 }
 214                 type = subklass;
 215             }
 216             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 217                 return null;
 218             }
 219             if (this.isAbstract()) {
 220                 return concreteSubtype(type);
 221             } else {
 222                 assert this.equals(type);
 223                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 224             }
 225         }
 226     }
 227 
 228     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 229         if (type.isLeaf()) {
 230             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 231         } else {
 232             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 233         }
 234     }
 235 
 236     /**
 237      * Returns if type {@code type} is a leaf class. This is the case if the
 238      * {@code Klass::_subklass} field of the underlying class is zero.
 239      *
 240      * @return true if the type is a leaf class
 241      */
 242     private boolean isLeafClass() {
 243         return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;
 244     }
 245 
 246     /**
 247      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 248      * type {@code type}.
 249      *
 250      * @return value of the subklass field as metaspace klass pointer
 251      */
 252     private HotSpotResolvedObjectTypeImpl getSubklass() {
 253         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 254     }
 255 
 256     @Override
 257     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 258         if (isInterface()) {
 259             return null;
 260         }
 261         HotSpotResolvedObjectTypeImpl javaLangObject = runtime().getJavaLangObject();
 262         if (this.equals(javaLangObject)) {
 263             return null;
 264         }
 265         if (isArray()) {
 266             return javaLangObject;
 267         }
 268 
 269         // Cache result of native call
 270         if (superClass == null) {
 271             superClass = compilerToVM().getResolvedJavaType(this, config().superOffset, false);
 272         }
 273         return superClass;
 274     }
 275 
 276     @Override
 277     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 278         if (interfaces == null) {
 279             if (isArray()) {
<a name="1" id="anc1"></a><span class="line-modified"> 280                 HotSpotResolvedObjectTypeImpl[] types = new HotSpotResolvedObjectTypeImpl[2];</span>
 281                 types[0] = runtime().getJavaLangCloneable();
 282                 types[1] = runtime().getJavaLangSerializable();
<a name="2" id="anc2"></a>
 283                 this.interfaces = types;
 284             } else {
 285                 interfaces = runtime().compilerToVm.getInterfaces(this);
 286             }
 287         }
 288         return interfaces;
 289     }
 290 
 291     @Override
 292     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 293         if (!isInterface()) {
 294             throw new JVMCIError(&quot;Cannot call getSingleImplementor() on a non-interface type: %s&quot;, this);
 295         }
 296         return compilerToVM().getImplementor(this);
 297     }
 298 
 299     @Override
 300     public HotSpotResolvedObjectTypeImpl getSupertype() {
 301         if (isArray()) {
 302             ResolvedJavaType componentType = getComponentType();
 303             if (componentType.equals(getJavaLangObject()) || componentType.isPrimitive()) {
 304                 return getJavaLangObject();
 305             }
 306             HotSpotResolvedObjectTypeImpl supertype = ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype();
 307             return (HotSpotResolvedObjectTypeImpl) supertype.getArrayClass();
 308         }
 309         if (isInterface()) {
 310             return getJavaLangObject();
 311         }
 312         return getSuperclass();
 313     }
 314 
 315     @Override
 316     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 317         if (otherType.isPrimitive()) {
 318             return null;
 319         } else {
 320             HotSpotResolvedObjectTypeImpl t1 = this;
 321             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 322             while (true) {
 323                 if (t1.isAssignableFrom(t2)) {
 324                     return t1;
 325                 }
 326                 if (t2.isAssignableFrom(t1)) {
 327                     return t2;
 328                 }
 329                 t1 = t1.getSupertype();
 330                 t2 = t2.getSupertype();
 331             }
 332         }
 333     }
 334 
 335     @Override
 336     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 337         assert !isArray();
 338         if (!compilerToVM().hasFinalizableSubclass(this)) {
 339             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 340         }
 341         return new AssumptionResult&lt;&gt;(true);
 342     }
 343 
 344     @Override
 345     public boolean hasFinalizer() {
 346         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 347     }
 348 
 349     @Override
 350     public boolean isArray() {
 351         return layoutHelper() &lt; config().klassLayoutHelperNeutralValue;
 352     }
 353 
 354     @Override
 355     public boolean isEnum() {
 356         HotSpotResolvedObjectTypeImpl superclass = getSuperclass();
 357         return superclass != null &amp;&amp; superclass.equals(runtime().getJavaLangEnum());
 358     }
 359 
 360     @Override
 361     public boolean isInitialized() {
 362         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 363     }
 364 
 365     @Override
 366     public boolean isBeingInitialized() {
 367         return isArray() ? false : getInitState() == config().instanceKlassStateBeingInitialized;
 368     }
 369 
 370     @Override
 371     public boolean isLinked() {
 372         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 373     }
 374 
 375     @Override
 376     public void link() {
 377         if (!isLinked()) {
 378             runtime().compilerToVm.ensureLinked(this);
 379         }
 380     }
 381 
 382     @Override
 383     public boolean hasDefaultMethods() {
 384         HotSpotVMConfig config = config();
 385         int miscFlags = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassMiscFlagsOffset);
 386         return (miscFlags &amp; config.jvmMiscFlagsHasDefaultMethods) != 0;
 387     }
 388 
 389     @Override
 390     public boolean declaresDefaultMethods() {
 391         HotSpotVMConfig config = config();
 392         int miscFlags = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassMiscFlagsOffset);
 393         return (miscFlags &amp; config.jvmMiscFlagsDeclaresDefaultMethods) != 0;
 394     }
 395 
 396     /**
 397      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 398      * klass.
 399      *
 400      * @return state field value of this type
 401      */
 402     private int getInitState() {
 403         assert !isArray() : &quot;_init_state only exists in InstanceKlass&quot;;
 404         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 405     }
 406 
 407     @Override
 408     public void initialize() {
 409         if (!isInitialized()) {
 410             runtime().compilerToVm.ensureInitialized(this);
 411             assert isInitialized() || isBeingInitialized();
 412         }
 413     }
 414 
 415     @Override
 416     public boolean isInstance(JavaConstant obj) {
 417         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 418             return runtime().reflection.isInstance(this, (HotSpotObjectConstantImpl) obj);
 419         }
 420         return false;
 421     }
 422 
 423     @Override
 424     public boolean isInstanceClass() {
 425         return !isArray() &amp;&amp; !isInterface();
 426     }
 427 
 428     @Override
 429     public boolean isInterface() {
 430         return (getAccessFlags() &amp; config().jvmAccInterface) != 0;
 431     }
 432 
 433     @Override
 434     public boolean isAssignableFrom(ResolvedJavaType other) {
 435         assert other != null;
 436         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 437             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 438             return runtime().reflection.isAssignableFrom(this, otherType);
 439         }
 440         return false;
 441     }
 442 
 443     @Override
 444     public ResolvedJavaType getHostClass() {
 445         if (isArray()) {
 446             return null;
 447         }
 448         return compilerToVM().getHostClass(this);
 449     }
 450 
 451     @Override
 452     public boolean isJavaLangObject() {
 453         return getName().equals(&quot;Ljava/lang/Object;&quot;);
 454     }
 455 
 456     @Override
 457     public JavaKind getJavaKind() {
 458         return JavaKind.Object;
 459     }
 460 
 461     @Override
 462     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 463         assert !callerType.isArray();
 464         if (isInterface()) {
 465             // Methods can only be resolved against concrete types
 466             return null;
 467         }
 468         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic() &amp;&amp; !isSignaturePolymorphicHolder(method.getDeclaringClass())) {
 469             return method;
 470         }
 471         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 472             return null;
 473         }
 474         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 475         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 476         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 477     }
 478 
 479     @Override
 480     public HotSpotConstantPool getConstantPool() {
 481         if (constantPool == null || !isArray() &amp;&amp; UNSAFE.getAddress(getMetaspaceKlass() + config().instanceKlassConstantsOffset) != constantPool.getMetaspaceConstantPool()) {
 482             /*
 483              * If the pointer to the ConstantPool has changed since this was last read refresh the
 484              * HotSpotConstantPool wrapper object. This ensures that uses of the constant pool are
 485              * operating on the latest one and that HotSpotResolvedJavaMethodImpls will be able to
 486              * use the shared copy instead of creating their own instance.
 487              */
 488             constantPool = compilerToVM().getConstantPool(this);
 489         }
 490         return constantPool;
 491     }
 492 
 493     /**
 494      * Gets the instance size of this type. If an instance of this type cannot be fast path
 495      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 496      * be called if this is an array or interface type.
 497      */
 498     @Override
 499     public int instanceSize() {
 500         assert !isArray();
 501         assert !isInterface();
 502 
 503         HotSpotVMConfig config = config();
 504         final int layoutHelper = layoutHelper();
 505         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : &quot;must be instance&quot;;
 506 
 507         // See: Klass::layout_helper_size_in_bytes
 508         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 509 
 510         // See: Klass::layout_helper_needs_slow_path
 511         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 512 
 513         return needsSlowPath ? -size : size;
 514     }
 515 
 516     @Override
 517     public int layoutHelper() {
 518         HotSpotVMConfig config = config();
 519         assert getMetaspaceKlass() != 0 : getName();
 520         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 521     }
 522 
 523     @Override
 524     public long getFingerprint() {
 525         return compilerToVM().getFingerprint(getMetaspaceKlass());
 526     }
 527 
 528     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceHandle) {
 529         long metaspaceMethod = UNSAFE.getLong(metaspaceHandle);
 530         // Maintain cache as array.
 531         if (methodCacheArray == null) {
 532             methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
 533         }
 534 
 535         int i = 0;
 536         for (; i &lt; methodCacheArray.length; ++i) {
 537             HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
 538             if (curMethod == null) {
 539                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);
 540                 methodCacheArray[i] = newMethod;
 541                 return newMethod;
 542             } else if (curMethod.getMetaspaceMethod() == metaspaceMethod) {
 543                 return curMethod;
 544             }
 545         }
 546 
 547         // Fall-back to hash table.
 548         if (methodCacheHashMap == null) {
 549             methodCacheHashMap = new HashMap&lt;&gt;();
 550         }
 551 
 552         HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
 553         if (lookupResult == null) {
 554             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);
 555             methodCacheHashMap.put(metaspaceMethod, newMethod);
 556             return newMethod;
 557         } else {
 558             return lookupResult;
 559         }
 560     }
 561 
 562     @Override
 563     public int getVtableLength() {
 564         HotSpotVMConfig config = config();
 565         if (isInterface() || isArray()) {
 566             /* Everything has the core vtable of java.lang.Object */
 567             return config.baseVtableLength();
 568         }
 569         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 570         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + &quot; &quot; + config.vtableEntrySize;
 571         return result;
 572     }
 573 
 574     HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {
 575         return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);
 576     }
 577 
 578     @Override
 579     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 580         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 581         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 582         /*
 583          * Sometimes the receiver type in the graph hasn&#39;t stabilized to a subtype of declared
 584          * holder, usually because of phis, so make sure that the type is related to the declared
 585          * type before using it for lookup. Unlinked types should also be ignored because we can&#39;t
 586          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 587          * a deopt instead since they can&#39;t really be used if they aren&#39;t linked yet.
 588          */
 589         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 590             if (hmethod.canBeStaticallyBound()) {
 591                 // No assumptions are required.
 592                 return new AssumptionResult&lt;&gt;(hmethod);
 593             }
 594             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 595             if (result != null) {
 596                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 597             }
 598             return null;
 599         }
 600         /*
 601          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 602          * the correct method for the subtype.
 603          */
 604         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 605         if (resolvedMethod == null) {
 606             // The type isn&#39;t known to implement the method.
 607             return null;
 608         }
 609         if (resolvedMethod.canBeStaticallyBound()) {
 610             // No assumptions are required.
 611             return new AssumptionResult&lt;&gt;(resolvedMethod);
 612         }
 613 
 614         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 615         if (result != null) {
 616             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 617         }
 618         return null;
 619     }
 620 
 621     FieldInfo createFieldInfo(int index) {
 622         return new FieldInfo(index);
 623     }
 624 
 625     public void ensureInitialized() {
 626         runtime().compilerToVm.ensureInitialized(this);
 627     }
 628 
 629     @Override
 630     public boolean equals(Object obj) {
 631         if (obj == this) {
 632             return true;
 633         }
 634         if (!(obj instanceof HotSpotResolvedObjectTypeImpl)) {
 635             return false;
 636         }
 637         HotSpotResolvedObjectTypeImpl that = (HotSpotResolvedObjectTypeImpl) obj;
 638         return getMetaspaceKlass() == that.getMetaspaceKlass();
 639     }
 640 
 641     @Override
 642     JavaConstant getJavaMirror() {
 643         return mirror;
 644     }
 645 
 646     /**
 647      * This class represents the field information for one field contained in the fields array of an
 648      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 649      */
 650     class FieldInfo {
 651         /**
 652          * Native pointer into the array of Java shorts.
 653          */
 654         private final long metaspaceData;
 655 
 656         /**
 657          * Creates a field info for the field in the fields array at index {@code index}.
 658          *
 659          * @param index index to the fields array
 660          */
 661         FieldInfo(int index) {
 662             HotSpotVMConfig config = config();
 663             // Get Klass::_fields
 664             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 665             assert config.fieldInfoFieldSlots == 6 : &quot;revisit the field parsing code&quot;;
 666             int offset = config.fieldInfoFieldSlots * Short.BYTES * index;
 667             metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;
 668         }
 669 
 670         private int getAccessFlags() {
 671             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 672         }
 673 
 674         private int getNameIndex() {
 675             return readFieldSlot(config().fieldInfoNameIndexOffset);
 676         }
 677 
 678         private int getSignatureIndex() {
 679             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 680         }
 681 
 682         public int getOffset() {
 683             HotSpotVMConfig config = config();
 684             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 685             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 686             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 687             return offset;
 688         }
 689 
 690         /**
 691          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 692          * on top an array of Java shorts.
 693          */
 694         private int readFieldSlot(int index) {
 695             int offset = Short.BYTES * index;
 696             return UNSAFE.getChar(metaspaceData + offset);
 697         }
 698 
 699         /**
 700          * Returns the name of this field as a {@link String}. If the field is an internal field the
 701          * name index is pointing into the vmSymbols table.
 702          */
 703         public String getName() {
 704             final int nameIndex = getNameIndex();
 705             return isInternal() ? config().symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 706         }
 707 
 708         /**
 709          * Returns the signature of this field as {@link String}. If the field is an internal field
 710          * the signature index is pointing into the vmSymbols table.
 711          */
 712         public String getSignature() {
 713             final int signatureIndex = getSignatureIndex();
 714             return isInternal() ? config().symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 715         }
 716 
 717         public JavaType getType() {
 718             String signature = getSignature();
 719             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 720         }
 721 
 722         private boolean isInternal() {
 723             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 724         }
 725 
 726         public boolean isStatic() {
 727             return Modifier.isStatic(getAccessFlags());
 728         }
 729 
 730         public boolean hasGenericSignature() {
 731             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 732         }
 733     }
 734 
 735     static class SortByOffset implements Comparator&lt;ResolvedJavaField&gt; {
 736         public int compare(ResolvedJavaField a, ResolvedJavaField b) {
 737             return a.getOffset() - b.getOffset();
 738         }
 739     }
 740 
 741     @Override
 742     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 743         if (instanceFields == null) {
 744             if (isArray() || isInterface()) {
 745                 instanceFields = NO_FIELDS;
 746             } else {
 747                 HotSpotResolvedJavaField[] prepend = NO_FIELDS;
 748                 if (getSuperclass() != null) {
 749                     prepend = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 750                 }
 751                 instanceFields = getFields(false, prepend);
 752             }
 753         }
 754         if (!includeSuperclasses &amp;&amp; getSuperclass() != null) {
 755             int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
 756             if (superClassFieldCount == instanceFields.length) {
 757                 // This class does not have any instance fields of its own.
 758                 return NO_FIELDS;
 759             } else if (superClassFieldCount != 0) {
 760                 // Fields of the current class can be interleaved with fields of its super-classes
 761                 // but the array of fields to be returned must be sorted by increasing offset
 762                 // This code populates the array, then applies the sorting function
 763                 HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
 764                 int i = 0;
 765                 for (HotSpotResolvedJavaField f : instanceFields) {
 766                     if (f.getDeclaringClass() == this) {
 767                         result[i++] = f;
 768                     }
 769                 }
 770                 Arrays.sort(result, fieldSortingMethod);
 771                 return result;
 772             } else {
 773                 // The super classes of this class do not have any instance fields.
 774             }
 775         }
 776         return instanceFields;
 777     }
 778 
 779     @Override
 780     public ResolvedJavaField[] getStaticFields() {
 781         if (isArray()) {
 782             return new HotSpotResolvedJavaField[0];
 783         } else {
 784             return getFields(true, NO_FIELDS);
 785         }
 786     }
 787 
 788     /**
 789      * Gets the instance or static fields of this class.
 790      *
 791      * @param retrieveStaticFields specifies whether to return instance or static fields
 792      * @param prepend an array to be prepended to the returned result
 793      */
 794     private HotSpotResolvedJavaField[] getFields(boolean retrieveStaticFields, HotSpotResolvedJavaField[] prepend) {
 795         HotSpotVMConfig config = config();
 796         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 797         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 798         int resultCount = 0;
 799         int index = 0;
 800         for (int i = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 801             FieldInfo field = new FieldInfo(index);
 802             if (field.hasGenericSignature()) {
 803                 metaspaceFieldsLength--;
 804             }
 805 
 806             if (field.isStatic() == retrieveStaticFields) {
 807                 resultCount++;
 808             }
 809         }
 810 
 811         if (resultCount == 0) {
 812             return prepend;
 813         }
 814 
 815         int prependLength = prepend.length;
 816         resultCount += prependLength;
 817 
 818         HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
 819         if (prependLength != 0) {
 820             System.arraycopy(prepend, 0, result, 0, prependLength);
 821         }
 822 
 823         // Fields of the current class can be interleaved with fields of its super-classes
 824         // but the array of fields to be returned must be sorted by increasing offset
 825         // This code populates the array, then applies the sorting function
 826         int resultIndex = prependLength;
 827         for (int i = 0; i &lt; index; ++i) {
 828             FieldInfo field = new FieldInfo(i);
 829             if (field.isStatic() == retrieveStaticFields) {
 830                 int offset = field.getOffset();
 831                 HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
 832                 result[resultIndex++] = resolvedJavaField;
 833             }
 834         }
 835         Arrays.sort(result, fieldSortingMethod);
 836         return result;
 837     }
 838 
 839     @Override
 840     public String getSourceFileName() {
 841         if (isArray()) {
 842             return null;
 843         }
 844         return getConstantPool().getSourceFileName();
 845     }
 846 
 847     @Override
 848     public Annotation[] getAnnotations() {
 849         return runtime().reflection.getAnnotations(this);
 850     }
 851 
 852     @Override
 853     public Annotation[] getDeclaredAnnotations() {
 854         return runtime().reflection.getDeclaredAnnotations(this);
 855     }
 856 
 857     @Override
 858     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 859         return runtime().reflection.getAnnotation(this, annotationClass);
 860     }
 861 
 862     /**
 863      * Performs a fast-path check that this type is resolved in the context of a given accessing
 864      * class. A negative result does not mean this type is not resolved with respect to
 865      * {@code accessingClass}. That can only be determined by
 866      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 867      * re-resolving} the type.
 868      */
 869     @Override
 870     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 871         assert accessingClass != null;
 872         ResolvedJavaType elementType = getElementalType();
 873         if (elementType.isPrimitive()) {
 874             // Primitive type resolution is context free.
 875             return true;
 876         }
 877         if (elementType.getName().startsWith(&quot;Ljava/&quot;) &amp;&amp; hasSameClassLoader(runtime().getJavaLangObject())) {
 878             // Classes in a java.* package defined by the boot class loader are always resolved.
 879             return true;
 880         }
 881         HotSpotResolvedObjectTypeImpl otherMirror = ((HotSpotResolvedObjectTypeImpl) accessingClass);
 882         return hasSameClassLoader(otherMirror);
 883     }
 884 
 885     private boolean hasSameClassLoader(HotSpotResolvedObjectTypeImpl otherMirror) {
 886         return UnsafeAccess.UNSAFE.getAddress(getMetaspaceKlass() + config().classLoaderDataOffset) == UnsafeAccess.UNSAFE.getAddress(
 887                         otherMirror.getMetaspaceKlass() + config().classLoaderDataOffset);
 888     }
 889 
 890     @Override
 891     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 892         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 893             return this;
 894         }
 895         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 896         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 897     }
 898 
 899     /**
 900      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 901      */
 902     @Override
 903     public Constant klass() {
 904         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 905     }
 906 
 907     @Override
 908     public boolean isPrimaryType() {
 909         return config().secondarySuperCacheOffset != superCheckOffset();
 910     }
 911 
 912     @Override
 913     public int superCheckOffset() {
 914         HotSpotVMConfig config = config();
 915         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 916     }
 917 
 918     @Override
 919     public long prototypeMarkWord() {
 920         HotSpotVMConfig config = config();
 921         if (isArray()) {
 922             return config.arrayPrototypeMarkWord();
 923         } else {
 924             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 925         }
 926     }
 927 
 928     @Override
 929     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 930         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 931         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 932     }
 933 
 934     public ResolvedJavaField findStaticFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 935         ResolvedJavaField[] declaredFields = getStaticFields();
 936         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 937     }
 938 
 939     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
 940         for (ResolvedJavaField field : declaredFields) {
 941             long resolvedFieldOffset = field.getOffset();
 942             // @formatter:off
 943             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN &amp;&amp;
 944                     expectedEntryKind.isPrimitive() &amp;&amp;
 945                     !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 946                     field.getJavaKind().isPrimitive()) {
 947                 resolvedFieldOffset +=
 948                         field.getJavaKind().getByteCount() -
 949                                 Math.min(field.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 950             }
 951             if (resolvedFieldOffset == offset) {
 952                 return field;
 953             }
 954             // @formatter:on
 955         }
 956         return null;
 957     }
 958 
 959     @Override
 960     public boolean isLocal() {
 961         return runtime().reflection.isLocalClass(this);
 962     }
 963 
 964     @Override
 965     public boolean isMember() {
 966         return runtime().reflection.isMemberClass(this);
 967     }
 968 
 969     @Override
 970     public HotSpotResolvedObjectType getEnclosingType() {
 971         return runtime().reflection.getEnclosingClass(this);
 972     }
 973 
 974     @Override
 975     public ResolvedJavaMethod[] getDeclaredConstructors() {
 976         return runtime().compilerToVm.getDeclaredConstructors(this);
 977     }
 978 
 979     @Override
 980     public ResolvedJavaMethod[] getDeclaredMethods() {
 981         return runtime().compilerToVm.getDeclaredMethods(this);
 982     }
 983 
 984     @Override
 985     public ResolvedJavaMethod getClassInitializer() {
 986         if (!isArray()) {
 987             return compilerToVM().getClassInitializer(this);
 988         }
 989         return null;
 990     }
 991 
 992     @Override
 993     public String toString() {
 994         return &quot;HotSpotType&lt;&quot; + getName() + &quot;, resolved&gt;&quot;;
 995     }
 996 
 997     @Override
 998     public ResolvedJavaType lookupType(UnresolvedJavaType unresolvedJavaType, boolean resolve) {
 999         JavaType javaType = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedJavaType.getName(), this, resolve);
1000         if (javaType instanceof ResolvedJavaType) {
1001             return (ResolvedJavaType) javaType;
1002         }
1003         return null;
1004     }
1005 
1006     @Override
1007     public ResolvedJavaField resolveField(UnresolvedJavaField unresolvedJavaField, ResolvedJavaType accessingClass) {
1008         for (ResolvedJavaField field : getInstanceFields(false)) {
1009             if (field.getName().equals(unresolvedJavaField.getName())) {
1010                 return field;
1011             }
1012         }
1013         for (ResolvedJavaField field : getStaticFields()) {
1014             if (field.getName().equals(unresolvedJavaField.getName())) {
1015                 return field;
1016             }
1017         }
1018         throw new InternalError(unresolvedJavaField.toString());
1019     }
1020 
1021     @Override
1022     public boolean isCloneableWithAllocation() {
1023         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
1024     }
1025 
1026     JavaConstant readFieldValue(HotSpotResolvedJavaField field, boolean isVolatile) {
1027         return runtime().reflection.readFieldValue(this, field, isVolatile);
1028     }
1029 
1030     private int getMiscFlags() {
1031         return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);
1032     }
1033 
1034     @Override
1035     public boolean isUnsafeAnonymous() {
1036         return (getMiscFlags() &amp; config().instanceKlassMiscIsUnsafeAnonymous) != 0;
1037     }
1038 
1039 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>