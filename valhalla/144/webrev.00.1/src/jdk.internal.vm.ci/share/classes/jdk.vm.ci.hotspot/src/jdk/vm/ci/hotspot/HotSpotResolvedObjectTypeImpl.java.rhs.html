<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;
  34 import java.lang.reflect.Field;
  35 import java.lang.reflect.Modifier;
  36 import java.nio.ByteOrder;
  37 import java.util.Arrays;
  38 import java.util.Comparator;
  39 import java.util.HashMap;
  40 
  41 import jdk.vm.ci.common.JVMCIError;
  42 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  45 import jdk.vm.ci.meta.Assumptions.LeafType;
  46 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  47 import jdk.vm.ci.meta.Constant;
  48 import jdk.vm.ci.meta.JavaConstant;
  49 import jdk.vm.ci.meta.JavaKind;
  50 import jdk.vm.ci.meta.JavaType;
  51 import jdk.vm.ci.meta.ResolvedJavaField;
  52 import jdk.vm.ci.meta.ResolvedJavaMethod;
  53 import jdk.vm.ci.meta.ResolvedJavaType;
  54 import jdk.vm.ci.meta.UnresolvedJavaField;
  55 import jdk.vm.ci.meta.UnresolvedJavaType;
  56 
  57 /**
  58  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes. This class is not
  59  * an {@link MetaspaceHandleObject} because it doesn&#39;t have to be scanned for GC. It&#39;s liveness is
  60  * maintained by a reference to the {@link Class} instance.
  61  */
  62 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceObject {
  63 
  64     private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
  65     private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;
  66     private static final SortByOffset fieldSortingMethod = new SortByOffset();
  67 
  68     /**
  69      * The Java class this type represents.
  70      */
  71     private final long metadataPointer;
  72 
  73     private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
  74     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
  75     private volatile HotSpotResolvedJavaField[] instanceFields;
  76     private volatile HotSpotResolvedObjectTypeImpl[] interfaces;
  77     private HotSpotConstantPool constantPool;
  78     private final JavaConstant mirror;
  79     private HotSpotResolvedObjectTypeImpl superClass;
  80 
  81     /**
  82      * Managed exclusively by {@link HotSpotJDKReflection#getField}.
  83      */
  84     HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;
  85 
  86     static HotSpotResolvedObjectTypeImpl getJavaLangObject() {
  87         return runtime().getJavaLangObject();
  88     }
  89 
  90     /**
  91      * Gets the JVMCI mirror from a HotSpot type.
  92      *
  93      * Called from the VM.
  94      *
  95      * @param klassPointer a native pointer to the Klass*
  96      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  97      */
  98     @SuppressWarnings(&quot;unused&quot;)
  99     @VMEntryPoint
 100     private static HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {
 101         return runtime().fromMetaspace(klassPointer, signature);
 102     }
 103 
 104     /**
 105      * Creates the JVMCI mirror for a {@link Class} object.
 106      *
 107      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 108      * {@link Class} type.
 109      * &lt;/p&gt;
 110      *
 111      * @param metadataPointer the Klass* to create the mirror for
 112      */
 113     @SuppressWarnings(&quot;try&quot;)
 114     HotSpotResolvedObjectTypeImpl(long metadataPointer, String name) {
 115         super(name);
 116         assert metadataPointer != 0;
 117         this.metadataPointer = metadataPointer;
 118 
 119         // The mirror object must be in the global scope since
 120         // this object will be cached in HotSpotJVMCIRuntime.resolvedJavaTypes
 121         // and live across more than one compilation.
 122         try (HotSpotObjectConstantScope global = HotSpotObjectConstantScope.enterGlobalScope()) {
 123             this.mirror = runtime().compilerToVm.getJavaMirror(this);
 124             assert getName().charAt(0) != &#39;[&#39; || isArray() : getName();
 125         }
 126     }
 127 
 128     /**
 129      * Gets the metaspace Klass for this type.
 130      */
 131     long getMetaspaceKlass() {
 132         long metaspacePointer = getMetaspacePointer();
 133         if (metaspacePointer == 0) {
 134             throw new NullPointerException(&quot;Klass* is null&quot;);
 135         }
 136         return metaspacePointer;
 137     }
 138 
 139     @Override
 140     public long getMetaspacePointer() {
 141         return metadataPointer;
 142     }
 143 
 144     @Override
 145     public int getModifiers() {
 146         if (isArray()) {
 147             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 148         } else {
 149             return getAccessFlags() &amp; jvmClassModifiers();
 150         }
 151     }
 152 
 153     public int getAccessFlags() {
 154         HotSpotVMConfig config = config();
 155         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 156     }
 157 
 158     @Override
 159     public ResolvedJavaType getComponentType() {
 160         return runtime().compilerToVm.getComponentType(this);
 161     }
 162 
 163     @Override
 164     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 165         if (isLeaf()) {
 166             // No assumptions are required.
 167             return new AssumptionResult&lt;&gt;(this);
 168         }
 169         HotSpotVMConfig config = config();
 170         if (isArray()) {
 171             ResolvedJavaType elementalType = getElementalType();
 172             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 173             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 174                 /*
 175                  * If the elementType is leaf then the array is leaf under the same assumptions but
 176                  * only if the element type is exactly the leaf type. The element type can be
 177                  * abstract even if there is only one implementor of the abstract type.
 178                  */
 179                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 180                 result.add(elementType);
 181                 return result;
 182             }
 183             return null;
 184         } else if (isInterface()) {
 185             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 186             /*
 187              * If the implementor field contains itself that indicates that the interface has more
 188              * than one implementors (see: InstanceKlass::add_implementor).
 189              */
 190             if (implementor == null || implementor.equals(this)) {
 191                 return null;
 192             }
 193 
 194             assert !implementor.isInterface();
 195             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 196                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 197                 if (leafConcreteSubtype != null) {
 198                     assert !leafConcreteSubtype.getResult().equals(implementor);
 199                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 200                     // Accumulate leaf assumptions and return the combined result.
 201                     newResult.add(leafConcreteSubtype);
 202                     return newResult;
 203                 }
 204                 return null;
 205             }
 206             return concreteSubtype(implementor);
 207         } else {
 208             HotSpotResolvedObjectTypeImpl type = this;
 209             while (type.isAbstract()) {
 210                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 211                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 212                     return null;
 213                 }
 214                 type = subklass;
 215             }
 216             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 217                 return null;
 218             }
 219             if (this.isAbstract()) {
 220                 return concreteSubtype(type);
 221             } else {
 222                 assert this.equals(type);
 223                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 224             }
 225         }
 226     }
 227 
 228     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 229         if (type.isLeaf()) {
 230             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 231         } else {
 232             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 233         }
 234     }
 235 
 236     /**
 237      * Returns if type {@code type} is a leaf class. This is the case if the
 238      * {@code Klass::_subklass} field of the underlying class is zero.
 239      *
 240      * @return true if the type is a leaf class
 241      */
 242     private boolean isLeafClass() {
 243         return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;
 244     }
 245 
 246     /**
 247      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 248      * type {@code type}.
 249      *
 250      * @return value of the subklass field as metaspace klass pointer
 251      */
 252     private HotSpotResolvedObjectTypeImpl getSubklass() {
 253         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 254     }
 255 
 256     @Override
 257     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 258         if (isInterface()) {
 259             return null;
 260         }
 261         HotSpotResolvedObjectTypeImpl javaLangObject = runtime().getJavaLangObject();
 262         if (this.equals(javaLangObject)) {
 263             return null;
 264         }
 265         if (isArray()) {
 266             return javaLangObject;
 267         }
 268 
 269         // Cache result of native call
 270         if (superClass == null) {
 271             superClass = compilerToVM().getResolvedJavaType(this, config().superOffset, false);
 272         }
 273         return superClass;
 274     }
 275 
 276     @Override
 277     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 278         if (interfaces == null) {
 279             if (isArray()) {
<a name="1" id="anc1"></a><span class="line-modified"> 280                 HotSpotResolvedObjectTypeImpl[] types = new HotSpotResolvedObjectTypeImpl[3];</span>
 281                 types[0] = runtime().getJavaLangCloneable();
 282                 types[1] = runtime().getJavaLangSerializable();
<a name="2" id="anc2"></a><span class="line-added"> 283                 types[2] = runtime().getJavaLangIdentityObject();</span>
 284                 this.interfaces = types;
 285             } else {
 286                 interfaces = runtime().compilerToVm.getInterfaces(this);
 287             }
 288         }
 289         return interfaces;
 290     }
 291 
 292     @Override
 293     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 294         if (!isInterface()) {
 295             throw new JVMCIError(&quot;Cannot call getSingleImplementor() on a non-interface type: %s&quot;, this);
 296         }
 297         return compilerToVM().getImplementor(this);
 298     }
 299 
 300     @Override
 301     public HotSpotResolvedObjectTypeImpl getSupertype() {
 302         if (isArray()) {
 303             ResolvedJavaType componentType = getComponentType();
 304             if (componentType.equals(getJavaLangObject()) || componentType.isPrimitive()) {
 305                 return getJavaLangObject();
 306             }
 307             HotSpotResolvedObjectTypeImpl supertype = ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype();
 308             return (HotSpotResolvedObjectTypeImpl) supertype.getArrayClass();
 309         }
 310         if (isInterface()) {
 311             return getJavaLangObject();
 312         }
 313         return getSuperclass();
 314     }
 315 
 316     @Override
 317     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 318         if (otherType.isPrimitive()) {
 319             return null;
 320         } else {
 321             HotSpotResolvedObjectTypeImpl t1 = this;
 322             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 323             while (true) {
 324                 if (t1.isAssignableFrom(t2)) {
 325                     return t1;
 326                 }
 327                 if (t2.isAssignableFrom(t1)) {
 328                     return t2;
 329                 }
 330                 t1 = t1.getSupertype();
 331                 t2 = t2.getSupertype();
 332             }
 333         }
 334     }
 335 
 336     @Override
 337     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 338         assert !isArray();
 339         if (!compilerToVM().hasFinalizableSubclass(this)) {
 340             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 341         }
 342         return new AssumptionResult&lt;&gt;(true);
 343     }
 344 
 345     @Override
 346     public boolean hasFinalizer() {
 347         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 348     }
 349 
 350     @Override
 351     public boolean isArray() {
 352         return layoutHelper() &lt; config().klassLayoutHelperNeutralValue;
 353     }
 354 
 355     @Override
 356     public boolean isEnum() {
 357         HotSpotResolvedObjectTypeImpl superclass = getSuperclass();
 358         return superclass != null &amp;&amp; superclass.equals(runtime().getJavaLangEnum());
 359     }
 360 
 361     @Override
 362     public boolean isInitialized() {
 363         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 364     }
 365 
 366     @Override
 367     public boolean isBeingInitialized() {
 368         return isArray() ? false : getInitState() == config().instanceKlassStateBeingInitialized;
 369     }
 370 
 371     @Override
 372     public boolean isLinked() {
 373         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 374     }
 375 
 376     @Override
 377     public void link() {
 378         if (!isLinked()) {
 379             runtime().compilerToVm.ensureLinked(this);
 380         }
 381     }
 382 
 383     @Override
 384     public boolean hasDefaultMethods() {
 385         HotSpotVMConfig config = config();
 386         int miscFlags = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassMiscFlagsOffset);
 387         return (miscFlags &amp; config.jvmMiscFlagsHasDefaultMethods) != 0;
 388     }
 389 
 390     @Override
 391     public boolean declaresDefaultMethods() {
 392         HotSpotVMConfig config = config();
 393         int miscFlags = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassMiscFlagsOffset);
 394         return (miscFlags &amp; config.jvmMiscFlagsDeclaresDefaultMethods) != 0;
 395     }
 396 
 397     /**
 398      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 399      * klass.
 400      *
 401      * @return state field value of this type
 402      */
 403     private int getInitState() {
 404         assert !isArray() : &quot;_init_state only exists in InstanceKlass&quot;;
 405         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 406     }
 407 
 408     @Override
 409     public void initialize() {
 410         if (!isInitialized()) {
 411             runtime().compilerToVm.ensureInitialized(this);
 412             assert isInitialized() || isBeingInitialized();
 413         }
 414     }
 415 
 416     @Override
 417     public boolean isInstance(JavaConstant obj) {
 418         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 419             return runtime().reflection.isInstance(this, (HotSpotObjectConstantImpl) obj);
 420         }
 421         return false;
 422     }
 423 
 424     @Override
 425     public boolean isInstanceClass() {
 426         return !isArray() &amp;&amp; !isInterface();
 427     }
 428 
 429     @Override
 430     public boolean isInterface() {
 431         return (getAccessFlags() &amp; config().jvmAccInterface) != 0;
 432     }
 433 
 434     @Override
 435     public boolean isAssignableFrom(ResolvedJavaType other) {
 436         assert other != null;
 437         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 438             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 439             return runtime().reflection.isAssignableFrom(this, otherType);
 440         }
 441         return false;
 442     }
 443 
 444     @Override
 445     public ResolvedJavaType getHostClass() {
 446         if (isArray()) {
 447             return null;
 448         }
 449         return compilerToVM().getHostClass(this);
 450     }
 451 
 452     @Override
 453     public boolean isJavaLangObject() {
 454         return getName().equals(&quot;Ljava/lang/Object;&quot;);
 455     }
 456 
 457     @Override
 458     public JavaKind getJavaKind() {
 459         return JavaKind.Object;
 460     }
 461 
 462     @Override
 463     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 464         assert !callerType.isArray();
 465         if (isInterface()) {
 466             // Methods can only be resolved against concrete types
 467             return null;
 468         }
 469         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic() &amp;&amp; !isSignaturePolymorphicHolder(method.getDeclaringClass())) {
 470             return method;
 471         }
 472         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 473             return null;
 474         }
 475         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 476         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 477         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 478     }
 479 
 480     @Override
 481     public HotSpotConstantPool getConstantPool() {
 482         if (constantPool == null || !isArray() &amp;&amp; UNSAFE.getAddress(getMetaspaceKlass() + config().instanceKlassConstantsOffset) != constantPool.getMetaspaceConstantPool()) {
 483             /*
 484              * If the pointer to the ConstantPool has changed since this was last read refresh the
 485              * HotSpotConstantPool wrapper object. This ensures that uses of the constant pool are
 486              * operating on the latest one and that HotSpotResolvedJavaMethodImpls will be able to
 487              * use the shared copy instead of creating their own instance.
 488              */
 489             constantPool = compilerToVM().getConstantPool(this);
 490         }
 491         return constantPool;
 492     }
 493 
 494     /**
 495      * Gets the instance size of this type. If an instance of this type cannot be fast path
 496      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 497      * be called if this is an array or interface type.
 498      */
 499     @Override
 500     public int instanceSize() {
 501         assert !isArray();
 502         assert !isInterface();
 503 
 504         HotSpotVMConfig config = config();
 505         final int layoutHelper = layoutHelper();
 506         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : &quot;must be instance&quot;;
 507 
 508         // See: Klass::layout_helper_size_in_bytes
 509         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 510 
 511         // See: Klass::layout_helper_needs_slow_path
 512         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 513 
 514         return needsSlowPath ? -size : size;
 515     }
 516 
 517     @Override
 518     public int layoutHelper() {
 519         HotSpotVMConfig config = config();
 520         assert getMetaspaceKlass() != 0 : getName();
 521         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 522     }
 523 
 524     @Override
 525     public long getFingerprint() {
 526         return compilerToVM().getFingerprint(getMetaspaceKlass());
 527     }
 528 
 529     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceHandle) {
 530         long metaspaceMethod = UNSAFE.getLong(metaspaceHandle);
 531         // Maintain cache as array.
 532         if (methodCacheArray == null) {
 533             methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
 534         }
 535 
 536         int i = 0;
 537         for (; i &lt; methodCacheArray.length; ++i) {
 538             HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
 539             if (curMethod == null) {
 540                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);
 541                 methodCacheArray[i] = newMethod;
 542                 return newMethod;
 543             } else if (curMethod.getMetaspaceMethod() == metaspaceMethod) {
 544                 return curMethod;
 545             }
 546         }
 547 
 548         // Fall-back to hash table.
 549         if (methodCacheHashMap == null) {
 550             methodCacheHashMap = new HashMap&lt;&gt;();
 551         }
 552 
 553         HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
 554         if (lookupResult == null) {
 555             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);
 556             methodCacheHashMap.put(metaspaceMethod, newMethod);
 557             return newMethod;
 558         } else {
 559             return lookupResult;
 560         }
 561     }
 562 
 563     @Override
 564     public int getVtableLength() {
 565         HotSpotVMConfig config = config();
 566         if (isInterface() || isArray()) {
 567             /* Everything has the core vtable of java.lang.Object */
 568             return config.baseVtableLength();
 569         }
 570         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 571         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + &quot; &quot; + config.vtableEntrySize;
 572         return result;
 573     }
 574 
 575     HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {
 576         return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);
 577     }
 578 
 579     @Override
 580     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 581         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 582         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 583         /*
 584          * Sometimes the receiver type in the graph hasn&#39;t stabilized to a subtype of declared
 585          * holder, usually because of phis, so make sure that the type is related to the declared
 586          * type before using it for lookup. Unlinked types should also be ignored because we can&#39;t
 587          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 588          * a deopt instead since they can&#39;t really be used if they aren&#39;t linked yet.
 589          */
 590         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 591             if (hmethod.canBeStaticallyBound()) {
 592                 // No assumptions are required.
 593                 return new AssumptionResult&lt;&gt;(hmethod);
 594             }
 595             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 596             if (result != null) {
 597                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 598             }
 599             return null;
 600         }
 601         /*
 602          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 603          * the correct method for the subtype.
 604          */
 605         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 606         if (resolvedMethod == null) {
 607             // The type isn&#39;t known to implement the method.
 608             return null;
 609         }
 610         if (resolvedMethod.canBeStaticallyBound()) {
 611             // No assumptions are required.
 612             return new AssumptionResult&lt;&gt;(resolvedMethod);
 613         }
 614 
 615         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 616         if (result != null) {
 617             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 618         }
 619         return null;
 620     }
 621 
 622     FieldInfo createFieldInfo(int index) {
 623         return new FieldInfo(index);
 624     }
 625 
 626     public void ensureInitialized() {
 627         runtime().compilerToVm.ensureInitialized(this);
 628     }
 629 
 630     @Override
 631     public boolean equals(Object obj) {
 632         if (obj == this) {
 633             return true;
 634         }
 635         if (!(obj instanceof HotSpotResolvedObjectTypeImpl)) {
 636             return false;
 637         }
 638         HotSpotResolvedObjectTypeImpl that = (HotSpotResolvedObjectTypeImpl) obj;
 639         return getMetaspaceKlass() == that.getMetaspaceKlass();
 640     }
 641 
 642     @Override
 643     JavaConstant getJavaMirror() {
 644         return mirror;
 645     }
 646 
 647     /**
 648      * This class represents the field information for one field contained in the fields array of an
 649      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 650      */
 651     class FieldInfo {
 652         /**
 653          * Native pointer into the array of Java shorts.
 654          */
 655         private final long metaspaceData;
 656 
 657         /**
 658          * Creates a field info for the field in the fields array at index {@code index}.
 659          *
 660          * @param index index to the fields array
 661          */
 662         FieldInfo(int index) {
 663             HotSpotVMConfig config = config();
 664             // Get Klass::_fields
 665             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 666             assert config.fieldInfoFieldSlots == 6 : &quot;revisit the field parsing code&quot;;
 667             int offset = config.fieldInfoFieldSlots * Short.BYTES * index;
 668             metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;
 669         }
 670 
 671         private int getAccessFlags() {
 672             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 673         }
 674 
 675         private int getNameIndex() {
 676             return readFieldSlot(config().fieldInfoNameIndexOffset);
 677         }
 678 
 679         private int getSignatureIndex() {
 680             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 681         }
 682 
 683         public int getOffset() {
 684             HotSpotVMConfig config = config();
 685             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 686             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 687             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 688             return offset;
 689         }
 690 
 691         /**
 692          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 693          * on top an array of Java shorts.
 694          */
 695         private int readFieldSlot(int index) {
 696             int offset = Short.BYTES * index;
 697             return UNSAFE.getChar(metaspaceData + offset);
 698         }
 699 
 700         /**
 701          * Returns the name of this field as a {@link String}. If the field is an internal field the
 702          * name index is pointing into the vmSymbols table.
 703          */
 704         public String getName() {
 705             final int nameIndex = getNameIndex();
 706             return isInternal() ? config().symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 707         }
 708 
 709         /**
 710          * Returns the signature of this field as {@link String}. If the field is an internal field
 711          * the signature index is pointing into the vmSymbols table.
 712          */
 713         public String getSignature() {
 714             final int signatureIndex = getSignatureIndex();
 715             return isInternal() ? config().symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 716         }
 717 
 718         public JavaType getType() {
 719             String signature = getSignature();
 720             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 721         }
 722 
 723         private boolean isInternal() {
 724             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 725         }
 726 
 727         public boolean isStatic() {
 728             return Modifier.isStatic(getAccessFlags());
 729         }
 730 
 731         public boolean hasGenericSignature() {
 732             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 733         }
 734     }
 735 
 736     static class SortByOffset implements Comparator&lt;ResolvedJavaField&gt; {
 737         public int compare(ResolvedJavaField a, ResolvedJavaField b) {
 738             return a.getOffset() - b.getOffset();
 739         }
 740     }
 741 
 742     @Override
 743     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 744         if (instanceFields == null) {
 745             if (isArray() || isInterface()) {
 746                 instanceFields = NO_FIELDS;
 747             } else {
 748                 HotSpotResolvedJavaField[] prepend = NO_FIELDS;
 749                 if (getSuperclass() != null) {
 750                     prepend = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 751                 }
 752                 instanceFields = getFields(false, prepend);
 753             }
 754         }
 755         if (!includeSuperclasses &amp;&amp; getSuperclass() != null) {
 756             int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
 757             if (superClassFieldCount == instanceFields.length) {
 758                 // This class does not have any instance fields of its own.
 759                 return NO_FIELDS;
 760             } else if (superClassFieldCount != 0) {
 761                 // Fields of the current class can be interleaved with fields of its super-classes
 762                 // but the array of fields to be returned must be sorted by increasing offset
 763                 // This code populates the array, then applies the sorting function
 764                 HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
 765                 int i = 0;
 766                 for (HotSpotResolvedJavaField f : instanceFields) {
 767                     if (f.getDeclaringClass() == this) {
 768                         result[i++] = f;
 769                     }
 770                 }
 771                 Arrays.sort(result, fieldSortingMethod);
 772                 return result;
 773             } else {
 774                 // The super classes of this class do not have any instance fields.
 775             }
 776         }
 777         return instanceFields;
 778     }
 779 
 780     @Override
 781     public ResolvedJavaField[] getStaticFields() {
 782         if (isArray()) {
 783             return new HotSpotResolvedJavaField[0];
 784         } else {
 785             return getFields(true, NO_FIELDS);
 786         }
 787     }
 788 
 789     /**
 790      * Gets the instance or static fields of this class.
 791      *
 792      * @param retrieveStaticFields specifies whether to return instance or static fields
 793      * @param prepend an array to be prepended to the returned result
 794      */
 795     private HotSpotResolvedJavaField[] getFields(boolean retrieveStaticFields, HotSpotResolvedJavaField[] prepend) {
 796         HotSpotVMConfig config = config();
 797         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 798         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 799         int resultCount = 0;
 800         int index = 0;
 801         for (int i = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 802             FieldInfo field = new FieldInfo(index);
 803             if (field.hasGenericSignature()) {
 804                 metaspaceFieldsLength--;
 805             }
 806 
 807             if (field.isStatic() == retrieveStaticFields) {
 808                 resultCount++;
 809             }
 810         }
 811 
 812         if (resultCount == 0) {
 813             return prepend;
 814         }
 815 
 816         int prependLength = prepend.length;
 817         resultCount += prependLength;
 818 
 819         HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
 820         if (prependLength != 0) {
 821             System.arraycopy(prepend, 0, result, 0, prependLength);
 822         }
 823 
 824         // Fields of the current class can be interleaved with fields of its super-classes
 825         // but the array of fields to be returned must be sorted by increasing offset
 826         // This code populates the array, then applies the sorting function
 827         int resultIndex = prependLength;
 828         for (int i = 0; i &lt; index; ++i) {
 829             FieldInfo field = new FieldInfo(i);
 830             if (field.isStatic() == retrieveStaticFields) {
 831                 int offset = field.getOffset();
 832                 HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
 833                 result[resultIndex++] = resolvedJavaField;
 834             }
 835         }
 836         Arrays.sort(result, fieldSortingMethod);
 837         return result;
 838     }
 839 
 840     @Override
 841     public String getSourceFileName() {
 842         if (isArray()) {
 843             return null;
 844         }
 845         return getConstantPool().getSourceFileName();
 846     }
 847 
 848     @Override
 849     public Annotation[] getAnnotations() {
 850         return runtime().reflection.getAnnotations(this);
 851     }
 852 
 853     @Override
 854     public Annotation[] getDeclaredAnnotations() {
 855         return runtime().reflection.getDeclaredAnnotations(this);
 856     }
 857 
 858     @Override
 859     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 860         return runtime().reflection.getAnnotation(this, annotationClass);
 861     }
 862 
 863     /**
 864      * Performs a fast-path check that this type is resolved in the context of a given accessing
 865      * class. A negative result does not mean this type is not resolved with respect to
 866      * {@code accessingClass}. That can only be determined by
 867      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 868      * re-resolving} the type.
 869      */
 870     @Override
 871     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 872         assert accessingClass != null;
 873         ResolvedJavaType elementType = getElementalType();
 874         if (elementType.isPrimitive()) {
 875             // Primitive type resolution is context free.
 876             return true;
 877         }
 878         if (elementType.getName().startsWith(&quot;Ljava/&quot;) &amp;&amp; hasSameClassLoader(runtime().getJavaLangObject())) {
 879             // Classes in a java.* package defined by the boot class loader are always resolved.
 880             return true;
 881         }
 882         HotSpotResolvedObjectTypeImpl otherMirror = ((HotSpotResolvedObjectTypeImpl) accessingClass);
 883         return hasSameClassLoader(otherMirror);
 884     }
 885 
 886     private boolean hasSameClassLoader(HotSpotResolvedObjectTypeImpl otherMirror) {
 887         return UnsafeAccess.UNSAFE.getAddress(getMetaspaceKlass() + config().classLoaderDataOffset) == UnsafeAccess.UNSAFE.getAddress(
 888                         otherMirror.getMetaspaceKlass() + config().classLoaderDataOffset);
 889     }
 890 
 891     @Override
 892     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 893         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 894             return this;
 895         }
 896         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 897         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 898     }
 899 
 900     /**
 901      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 902      */
 903     @Override
 904     public Constant klass() {
 905         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 906     }
 907 
 908     @Override
 909     public boolean isPrimaryType() {
 910         return config().secondarySuperCacheOffset != superCheckOffset();
 911     }
 912 
 913     @Override
 914     public int superCheckOffset() {
 915         HotSpotVMConfig config = config();
 916         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 917     }
 918 
 919     @Override
 920     public long prototypeMarkWord() {
 921         HotSpotVMConfig config = config();
 922         if (isArray()) {
 923             return config.arrayPrototypeMarkWord();
 924         } else {
 925             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 926         }
 927     }
 928 
 929     @Override
 930     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 931         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 932         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 933     }
 934 
 935     public ResolvedJavaField findStaticFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 936         ResolvedJavaField[] declaredFields = getStaticFields();
 937         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 938     }
 939 
 940     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
 941         for (ResolvedJavaField field : declaredFields) {
 942             long resolvedFieldOffset = field.getOffset();
 943             // @formatter:off
 944             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN &amp;&amp;
 945                     expectedEntryKind.isPrimitive() &amp;&amp;
 946                     !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 947                     field.getJavaKind().isPrimitive()) {
 948                 resolvedFieldOffset +=
 949                         field.getJavaKind().getByteCount() -
 950                                 Math.min(field.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 951             }
 952             if (resolvedFieldOffset == offset) {
 953                 return field;
 954             }
 955             // @formatter:on
 956         }
 957         return null;
 958     }
 959 
 960     @Override
 961     public boolean isLocal() {
 962         return runtime().reflection.isLocalClass(this);
 963     }
 964 
 965     @Override
 966     public boolean isMember() {
 967         return runtime().reflection.isMemberClass(this);
 968     }
 969 
 970     @Override
 971     public HotSpotResolvedObjectType getEnclosingType() {
 972         return runtime().reflection.getEnclosingClass(this);
 973     }
 974 
 975     @Override
 976     public ResolvedJavaMethod[] getDeclaredConstructors() {
 977         return runtime().compilerToVm.getDeclaredConstructors(this);
 978     }
 979 
 980     @Override
 981     public ResolvedJavaMethod[] getDeclaredMethods() {
 982         return runtime().compilerToVm.getDeclaredMethods(this);
 983     }
 984 
 985     @Override
 986     public ResolvedJavaMethod getClassInitializer() {
 987         if (!isArray()) {
 988             return compilerToVM().getClassInitializer(this);
 989         }
 990         return null;
 991     }
 992 
 993     @Override
 994     public String toString() {
 995         return &quot;HotSpotType&lt;&quot; + getName() + &quot;, resolved&gt;&quot;;
 996     }
 997 
 998     @Override
 999     public ResolvedJavaType lookupType(UnresolvedJavaType unresolvedJavaType, boolean resolve) {
1000         JavaType javaType = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedJavaType.getName(), this, resolve);
1001         if (javaType instanceof ResolvedJavaType) {
1002             return (ResolvedJavaType) javaType;
1003         }
1004         return null;
1005     }
1006 
1007     @Override
1008     public ResolvedJavaField resolveField(UnresolvedJavaField unresolvedJavaField, ResolvedJavaType accessingClass) {
1009         for (ResolvedJavaField field : getInstanceFields(false)) {
1010             if (field.getName().equals(unresolvedJavaField.getName())) {
1011                 return field;
1012             }
1013         }
1014         for (ResolvedJavaField field : getStaticFields()) {
1015             if (field.getName().equals(unresolvedJavaField.getName())) {
1016                 return field;
1017             }
1018         }
1019         throw new InternalError(unresolvedJavaField.toString());
1020     }
1021 
1022     @Override
1023     public boolean isCloneableWithAllocation() {
1024         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
1025     }
1026 
1027     JavaConstant readFieldValue(HotSpotResolvedJavaField field, boolean isVolatile) {
1028         return runtime().reflection.readFieldValue(this, field, isVolatile);
1029     }
1030 
1031     private int getMiscFlags() {
1032         return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);
1033     }
1034 
1035     @Override
1036     public boolean isUnsafeAnonymous() {
1037         return (getMiscFlags() &amp; config().instanceKlassMiscIsUnsafeAnonymous) != 0;
1038     }
1039 
1040 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>