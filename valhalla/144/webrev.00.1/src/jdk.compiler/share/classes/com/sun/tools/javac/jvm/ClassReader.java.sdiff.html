<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Symtab.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../parser/JavacParser.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 




 108     /** Switch: allow sealed
 109      */
 110     boolean allowSealedTypes;
 111 
 112     /** Switch: allow records
 113      */
 114     boolean allowRecords;
 115 
 116    /** Lint option: warn about classfile issues
 117      */
 118     boolean lintClassfile;
 119 
 120     /** Switch: preserve parameter names from the variable table.
 121      */
 122     public boolean saveParameterNames;
 123 




 124     /**
 125      * The currently selected profile.
 126      */
 127     public final Profile profile;
 128 
 129     /** The log to use for verbose output
 130      */
 131     final Log log;
 132 
 133     /** The symbol table. */
 134     Symtab syms;
 135 
 136     Types types;
 137 
 138     /** The name table. */
 139     final Names names;
 140 
 141     /** Access to files
 142      */
 143     private final JavaFileManager fileManager;
</pre>
<hr />
<pre>
 255     protected ClassReader(Context context) {
 256         context.put(classReaderKey, this);
 257         annotate = Annotate.instance(context);
 258         names = Names.instance(context);
 259         syms = Symtab.instance(context);
 260         types = Types.instance(context);
 261         fileManager = context.get(JavaFileManager.class);
 262         if (fileManager == null)
 263             throw new AssertionError(&quot;FileManager initialization error&quot;);
 264         diagFactory = JCDiagnostic.Factory.instance(context);
 265         dcfh = DeferredCompletionFailureHandler.instance(context);
 266 
 267         log = Log.instance(context);
 268 
 269         Options options = Options.instance(context);
 270         verbose         = options.isSet(Option.VERBOSE);
 271 
 272         Source source = Source.instance(context);
 273         preview = Preview.instance(context);
 274         allowModules     = Feature.MODULES.allowedInSource(source);

 275         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 276                 Feature.RECORDS.allowedInSource(source);
 277         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 278                 Feature.SEALED_CLASSES.allowedInSource(source);
 279 
 280         saveParameterNames = options.isSet(PARAMETERS);

 281 
 282         profile = Profile.instance(context);
 283 
 284         typevars = WriteableScope.create(syms.noSymbol);
 285 
 286         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 287 
 288         initAttributeReaders();
 289     }
 290 
 291     /** Add member to class unless it is synthetic.
 292      */
 293     private void enterMember(ClassSymbol c, Symbol sym) {
 294         // Synthetic members are not entered -- reason lost to history (optimization?).
 295         // Lambda methods must be entered because they may have inner classes (which reference them)
<span class="line-modified"> 296         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))</span>

 297             c.members_field.enter(sym);


















 298     }
 299 
 300 /************************************************************************
 301  * Error Diagnoses
 302  ***********************************************************************/
 303 
 304     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 305         return new ClassFinder.BadClassFile (
 306             currentOwner.enclClass(),
 307             currentClassFile,
 308             diagFactory.fragment(key, args),
 309             diagFactory,
 310             dcfh);
 311     }
 312 
 313     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 314         return new ClassFinder.BadEnclosingMethodAttr (
 315             currentOwner.enclClass(),
 316             currentClassFile,
 317             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
</pre>
<hr />
<pre>
 452             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 453         }
 454         case &#39;B&#39;:
 455             sigp++;
 456             return syms.byteType;
 457         case &#39;C&#39;:
 458             sigp++;
 459             return syms.charType;
 460         case &#39;D&#39;:
 461             sigp++;
 462             return syms.doubleType;
 463         case &#39;F&#39;:
 464             sigp++;
 465             return syms.floatType;
 466         case &#39;I&#39;:
 467             sigp++;
 468             return syms.intType;
 469         case &#39;J&#39;:
 470             sigp++;
 471             return syms.longType;

 472         case &#39;L&#39;:
 473             {
 474                 // int oldsigp = sigp;
 475                 Type t = classSigToType();
 476                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 477                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 478                                        &quot;(please recompile from source)&quot;);
 479                 /*
 480                 System.err.println(&quot; decoded &quot; +
 481                                    new String(signature, oldsigp, sigp-oldsigp) +
 482                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 483                 */
 484                 return t;
 485             }
 486         case &#39;S&#39;:
 487             sigp++;
 488             return syms.shortType;
 489         case &#39;V&#39;:
 490             sigp++;
 491             return syms.voidType;
</pre>
<hr />
<pre>
 513             return new MethodType(argtypes,
 514                                   restype,
 515                                   thrown.reverse(),
 516                                   syms.methodClass);
 517         case &#39;&lt;&#39;:
 518             typevars = typevars.dup(currentOwner);
 519             Type poly = new ForAll(sigToTypeParams(), sigToType());
 520             typevars = typevars.leave();
 521             return poly;
 522         default:
 523             throw badClassFile(&quot;bad.signature&quot;,
 524                                Convert.utf2string(signature, sigp, 10));
 525         }
 526     }
 527 
 528     byte[] signatureBuffer = new byte[0];
 529     int sbp = 0;
 530     /** Convert class signature to type, where signature is implicit.
 531      */
 532     Type classSigToType() {
<span class="line-modified"> 533         if (signature[sigp] != &#39;L&#39;)</span>
 534             throw badClassFile(&quot;bad.class.signature&quot;,
 535                                Convert.utf2string(signature, sigp, 10));
 536         sigp++;
 537         Type outer = Type.noType;
 538         int startSbp = sbp;
 539 
 540         while (true) {
 541             final byte c = signature[sigp++];
 542             switch (c) {
 543 
 544             case &#39;;&#39;: {         // end
 545                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 546                                                          startSbp,
 547                                                          sbp - startSbp));
 548 
 549                 try {
 550                     return (outer == Type.noType) ?
 551                             t.erasure(types) :
 552                         new ClassType(outer, List.nil(), t);
 553                 } finally {
</pre>
<hr />
<pre>
 770         protected final Name name;
 771         protected final ClassFile.Version version;
 772         protected final Set&lt;AttributeKind&gt; kinds;
 773     }
 774 
 775     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 776             EnumSet.of(AttributeKind.CLASS);
 777     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 778             EnumSet.of(AttributeKind.MEMBER);
 779     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 780             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 781 
 782     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 783 
 784     private void initAttributeReaders() {
 785         AttributeReader[] readers = {
 786             // v45.3 attributes
 787 
 788             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 789                 protected void read(Symbol sym, int attrLen) {











 790                     if (saveParameterNames)
 791                         ((MethodSymbol)sym).code = readCode(sym);
 792                     else
 793                         bp = bp + attrLen;
 794                 }
 795             },
 796 
 797             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 798                 protected void read(Symbol sym, int attrLen) {
 799                     Object v = poolReader.getConstant(nextChar());
 800                     // Ignore ConstantValue attribute if field not final.
 801                     if ((sym.flags() &amp; FINAL) == 0) {
 802                         return;
 803                     }
 804                     VarSymbol var = (VarSymbol) sym;
 805                     switch (var.type.getTag()) {
 806                        case BOOLEAN:
 807                        case BYTE:
 808                        case CHAR:
 809                        case SHORT:
</pre>
<hr />
<pre>
1420                 sym.flags_field |= PROPRIETARY;
1421             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1422                 if (profile != Profile.DEFAULT) {
1423                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1424                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1425                             Attribute.Constant c = (Attribute.Constant)v.snd;
1426                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1427                                 sym.flags_field |= NOT_IN_PROFILE;
1428                             }
1429                         }
1430                     }
1431                 }
1432             } else if (proxy.type.tsym.flatName() == syms.previewFeatureInternalType.tsym.flatName()) {
1433                 sym.flags_field |= PREVIEW_API;
1434                 setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1435             } else {
1436                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1437                     target = proxy;
1438                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1439                     repeatable = proxy;


1440                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1441                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1442                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1443                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1444                     sym.flags_field |= PREVIEW_API;
1445                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1446                 }
1447                 proxies.append(proxy);
1448             }
1449         }
1450         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1451     }
1452     //where:
1453         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1454             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1455                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1456                     Attribute.Constant c = (Attribute.Constant)v.snd;
1457                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1458                         sym.flags_field |= flag;
1459                     }
</pre>
<hr />
<pre>
2197      */
2198     MethodSymbol readMethod() {
2199         long flags = adjustMethodFlags(nextChar());
2200         Name name = poolReader.getName(nextChar());
2201         Type type = poolReader.getType(nextChar());
2202         if (currentOwner.isInterface() &amp;&amp;
2203                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2204             if (majorVersion &gt; Version.V52.major ||
2205                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2206                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2207                     currentOwner.flags_field |= DEFAULT;
2208                     flags |= DEFAULT | ABSTRACT;
2209                 }
2210             } else {
2211                 //protect against ill-formed classfiles
2212                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2213                                    Integer.toString(majorVersion),
2214                                    Integer.toString(minorVersion));
2215             }
2216         }







2217         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2218             // Sometimes anonymous classes don&#39;t have an outer
2219             // instance, however, there is no reliable way to tell so
2220             // we never strip this$n
2221             // ditto for local classes. Local classes that have an enclosing method set
2222             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2223             // enclosing method (i.e. from initializers) will pass that check.
2224             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2225             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2226                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2227                                       type.getReturnType(),
2228                                       type.getThrownTypes(),
2229                                       syms.methodClass);
2230         }
2231         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2232         if (types.isSignaturePolymorphic(m)) {
2233             m.flags_field |= SIGNATURE_POLYMORPHIC;
2234         }
2235         if (saveParameterNames)
2236             initParameterNames(m);
</pre>
<hr />
<pre>
2421         }
2422     }
2423 
2424     /** Enter type variables of this classtype and all enclosing ones in
2425      *  `typevars&#39;.
2426      */
2427     protected void enterTypevars(Symbol sym, Type t) {
2428         if (t.getEnclosingType() != null) {
2429             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2430                 enterTypevars(sym.owner, t.getEnclosingType());
2431             }
2432         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2433             enterTypevars(sym.owner, sym.owner.type);
2434         }
2435         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2436             typevars.enter(xs.head.tsym);
2437         }
2438     }
2439 
2440     protected ClassSymbol enterClass(Name name) {




2441         return syms.enterClass(currentModule, name);
2442     }
2443 
2444     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2445         return syms.enterClass(currentModule, name, owner);
2446     }
2447 
2448     /** Read contents of a given class symbol `c&#39;. Both external and internal
2449      *  versions of an inner class are read.
2450      */
2451     void readClass(ClassSymbol c) {
2452         ClassType ct = (ClassType)c.type;
2453 
2454         // allocate scope for members
2455         c.members_field = WriteableScope.create(c);
2456 
2457         // prepare type variable table
2458         typevars = typevars.dup(currentOwner);
2459         if (ct.getEnclosingType().hasTag(CLASS))
2460             enterTypevars(c.owner, ct.getEnclosingType());
</pre>
<hr />
<pre>
2582         }
2583 
2584         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2585             if (!preview.isEnabled()) {
2586                 log.error(preview.disabledError(currentClassFile, majorVersion));
2587             } else {
2588                 preview.warnPreview(c.classfile, majorVersion);
2589             }
2590         }
2591 
2592         poolReader = new PoolReader(this, names, syms);
2593         bp = poolReader.readPool(buf, bp);
2594         if (signatureBuffer.length &lt; bp) {
2595             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2596             signatureBuffer = new byte[ns];
2597         }
2598         readClass(c);
2599     }
2600 
2601     public void readClassFile(ClassSymbol c) {


























2602         currentOwner = c;
2603         currentClassFile = c.classfile;
2604         warnedAttrs.clear();
2605         filling = true;
2606         target = null;
2607         repeatable = null;
2608         try {
2609             bp = 0;
2610             buf.reset();
2611             buf.appendStream(c.classfile.openInputStream());
2612             readClassBuffer(c);
2613             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2614                 List&lt;Type&gt; missing = missingTypeVariables;
2615                 List&lt;Type&gt; found = foundTypeVariables;
2616                 missingTypeVariables = List.nil();
2617                 foundTypeVariables = List.nil();
2618                 interimUses = List.nil();
2619                 interimProvides = List.nil();
2620                 filling = false;
2621                 ClassType ct = (ClassType)currentOwner.type;
</pre>
<hr />
<pre>
2677         return flags;
2678     }
2679 
2680     long adjustMethodFlags(long flags) {
2681         if ((flags &amp; ACC_BRIDGE) != 0) {
2682             flags &amp;= ~ACC_BRIDGE;
2683             flags |= BRIDGE;
2684         }
2685         if ((flags &amp; ACC_VARARGS) != 0) {
2686             flags &amp;= ~ACC_VARARGS;
2687             flags |= VARARGS;
2688         }
2689         return flags;
2690     }
2691 
2692     long adjustClassFlags(long flags) {
2693         if ((flags &amp; ACC_MODULE) != 0) {
2694             flags &amp;= ~ACC_MODULE;
2695             flags |= MODULE;
2696         }




2697         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2698     }
2699 
2700     /**
2701      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2702      * The attribute is only the last component of the original filename, so is unlikely
2703      * to be valid as is, so operations other than those to access the name throw
2704      * UnsupportedOperationException
2705      */
2706     private static class SourceFileObject implements JavaFileObject {
2707 
2708         /** The file&#39;s name.
2709          */
2710         private final Name name;
2711 
2712         public SourceFileObject(Name name) {
2713             this.name = name;
2714         }
2715 
2716         @Override @DefinedBy(Api.COMPILER)
</pre>
</td>
<td>
<hr />
<pre>
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
<span class="line-added"> 108     /** Switch: allow inline types.</span>
<span class="line-added"> 109      */</span>
<span class="line-added"> 110     boolean allowInlineTypes;</span>
<span class="line-added"> 111 </span>
 112     /** Switch: allow sealed
 113      */
 114     boolean allowSealedTypes;
 115 
 116     /** Switch: allow records
 117      */
 118     boolean allowRecords;
 119 
 120    /** Lint option: warn about classfile issues
 121      */
 122     boolean lintClassfile;
 123 
 124     /** Switch: preserve parameter names from the variable table.
 125      */
 126     public boolean saveParameterNames;
 127 
<span class="line-added"> 128     /** Switch: Should javac recongnize and handle value based classes specially ?</span>
<span class="line-added"> 129      */</span>
<span class="line-added"> 130     private boolean allowValueBasedClasses;</span>
<span class="line-added"> 131 </span>
 132     /**
 133      * The currently selected profile.
 134      */
 135     public final Profile profile;
 136 
 137     /** The log to use for verbose output
 138      */
 139     final Log log;
 140 
 141     /** The symbol table. */
 142     Symtab syms;
 143 
 144     Types types;
 145 
 146     /** The name table. */
 147     final Names names;
 148 
 149     /** Access to files
 150      */
 151     private final JavaFileManager fileManager;
</pre>
<hr />
<pre>
 263     protected ClassReader(Context context) {
 264         context.put(classReaderKey, this);
 265         annotate = Annotate.instance(context);
 266         names = Names.instance(context);
 267         syms = Symtab.instance(context);
 268         types = Types.instance(context);
 269         fileManager = context.get(JavaFileManager.class);
 270         if (fileManager == null)
 271             throw new AssertionError(&quot;FileManager initialization error&quot;);
 272         diagFactory = JCDiagnostic.Factory.instance(context);
 273         dcfh = DeferredCompletionFailureHandler.instance(context);
 274 
 275         log = Log.instance(context);
 276 
 277         Options options = Options.instance(context);
 278         verbose         = options.isSet(Option.VERBOSE);
 279 
 280         Source source = Source.instance(context);
 281         preview = Preview.instance(context);
 282         allowModules     = Feature.MODULES.allowedInSource(source);
<span class="line-added"> 283         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);</span>
 284         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 285                 Feature.RECORDS.allowedInSource(source);
 286         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 287                 Feature.SEALED_CLASSES.allowedInSource(source);
 288 
 289         saveParameterNames = options.isSet(PARAMETERS);
<span class="line-added"> 290         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);</span>
 291 
 292         profile = Profile.instance(context);
 293 
 294         typevars = WriteableScope.create(syms.noSymbol);
 295 
 296         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 297 
 298         initAttributeReaders();
 299     }
 300 
 301     /** Add member to class unless it is synthetic.
 302      */
 303     private void enterMember(ClassSymbol c, Symbol sym) {
 304         // Synthetic members are not entered -- reason lost to history (optimization?).
 305         // Lambda methods must be entered because they may have inner classes (which reference them)
<span class="line-modified"> 306         ClassSymbol refProjection =  c.isValue() ? c.referenceProjection() : null;</span>
<span class="line-added"> 307         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda)) {</span>
 308             c.members_field.enter(sym);
<span class="line-added"> 309             if (refProjection != null) {</span>
<span class="line-added"> 310                 Symbol clone = null;</span>
<span class="line-added"> 311                 if (sym.kind == MTH) {</span>
<span class="line-added"> 312                     MethodSymbol valMethod = (MethodSymbol)sym;</span>
<span class="line-added"> 313                     MethodSymbol refMethod = valMethod.clone(refProjection);</span>
<span class="line-added"> 314                     valMethod.projection = refMethod;</span>
<span class="line-added"> 315                     refMethod.projection = valMethod;</span>
<span class="line-added"> 316                     clone = refMethod;</span>
<span class="line-added"> 317                 } else if (sym.kind == VAR) {</span>
<span class="line-added"> 318                     VarSymbol valVar = (VarSymbol)sym;</span>
<span class="line-added"> 319                     VarSymbol refVar = valVar.clone(refProjection);</span>
<span class="line-added"> 320                     valVar.projection = refVar;</span>
<span class="line-added"> 321                     refVar.projection = valVar;</span>
<span class="line-added"> 322                     clone = refVar;</span>
<span class="line-added"> 323                 }</span>
<span class="line-added"> 324                 refProjection.members_field.enter(clone);</span>
<span class="line-added"> 325             }</span>
<span class="line-added"> 326         }</span>
 327     }
 328 
 329 /************************************************************************
 330  * Error Diagnoses
 331  ***********************************************************************/
 332 
 333     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 334         return new ClassFinder.BadClassFile (
 335             currentOwner.enclClass(),
 336             currentClassFile,
 337             diagFactory.fragment(key, args),
 338             diagFactory,
 339             dcfh);
 340     }
 341 
 342     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 343         return new ClassFinder.BadEnclosingMethodAttr (
 344             currentOwner.enclClass(),
 345             currentClassFile,
 346             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
</pre>
<hr />
<pre>
 481             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 482         }
 483         case &#39;B&#39;:
 484             sigp++;
 485             return syms.byteType;
 486         case &#39;C&#39;:
 487             sigp++;
 488             return syms.charType;
 489         case &#39;D&#39;:
 490             sigp++;
 491             return syms.doubleType;
 492         case &#39;F&#39;:
 493             sigp++;
 494             return syms.floatType;
 495         case &#39;I&#39;:
 496             sigp++;
 497             return syms.intType;
 498         case &#39;J&#39;:
 499             sigp++;
 500             return syms.longType;
<span class="line-added"> 501         case &#39;Q&#39;:</span>
 502         case &#39;L&#39;:
 503             {
 504                 // int oldsigp = sigp;
 505                 Type t = classSigToType();
 506                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 507                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 508                                        &quot;(please recompile from source)&quot;);
 509                 /*
 510                 System.err.println(&quot; decoded &quot; +
 511                                    new String(signature, oldsigp, sigp-oldsigp) +
 512                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 513                 */
 514                 return t;
 515             }
 516         case &#39;S&#39;:
 517             sigp++;
 518             return syms.shortType;
 519         case &#39;V&#39;:
 520             sigp++;
 521             return syms.voidType;
</pre>
<hr />
<pre>
 543             return new MethodType(argtypes,
 544                                   restype,
 545                                   thrown.reverse(),
 546                                   syms.methodClass);
 547         case &#39;&lt;&#39;:
 548             typevars = typevars.dup(currentOwner);
 549             Type poly = new ForAll(sigToTypeParams(), sigToType());
 550             typevars = typevars.leave();
 551             return poly;
 552         default:
 553             throw badClassFile(&quot;bad.signature&quot;,
 554                                Convert.utf2string(signature, sigp, 10));
 555         }
 556     }
 557 
 558     byte[] signatureBuffer = new byte[0];
 559     int sbp = 0;
 560     /** Convert class signature to type, where signature is implicit.
 561      */
 562     Type classSigToType() {
<span class="line-modified"> 563         if (signature[sigp] != &#39;L&#39; &amp;&amp; signature[sigp] != &#39;Q&#39;)</span>
 564             throw badClassFile(&quot;bad.class.signature&quot;,
 565                                Convert.utf2string(signature, sigp, 10));
 566         sigp++;
 567         Type outer = Type.noType;
 568         int startSbp = sbp;
 569 
 570         while (true) {
 571             final byte c = signature[sigp++];
 572             switch (c) {
 573 
 574             case &#39;;&#39;: {         // end
 575                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 576                                                          startSbp,
 577                                                          sbp - startSbp));
 578 
 579                 try {
 580                     return (outer == Type.noType) ?
 581                             t.erasure(types) :
 582                         new ClassType(outer, List.nil(), t);
 583                 } finally {
</pre>
<hr />
<pre>
 800         protected final Name name;
 801         protected final ClassFile.Version version;
 802         protected final Set&lt;AttributeKind&gt; kinds;
 803     }
 804 
 805     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 806             EnumSet.of(AttributeKind.CLASS);
 807     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 808             EnumSet.of(AttributeKind.MEMBER);
 809     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 810             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 811 
 812     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 813 
 814     private void initAttributeReaders() {
 815         AttributeReader[] readers = {
 816             // v45.3 attributes
 817 
 818             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 819                 protected void read(Symbol sym, int attrLen) {
<span class="line-added"> 820                     if (allowInlineTypes) {</span>
<span class="line-added"> 821                         if (sym.isConstructor()  &amp;&amp; ((MethodSymbol) sym).type.getParameterTypes().size() == 0) {</span>
<span class="line-added"> 822                             int code_length = buf.getInt(bp + 4);</span>
<span class="line-added"> 823                             if ((code_length == 1 &amp;&amp; buf.getByte( bp + 8) == (byte) ByteCodes.return_) ||</span>
<span class="line-added"> 824                                     (code_length == 5 &amp;&amp; buf.getByte(bp + 8) == ByteCodes.aload_0 &amp;&amp;</span>
<span class="line-added"> 825                                         buf.getByte( bp + 9) == (byte) ByteCodes.invokespecial &amp;&amp;</span>
<span class="line-added"> 826                                                 buf.getByte( bp + 12) == (byte) ByteCodes.return_)) {</span>
<span class="line-added"> 827                                     sym.flags_field |= EMPTYNOARGCONSTR;</span>
<span class="line-added"> 828                             }</span>
<span class="line-added"> 829                         }</span>
<span class="line-added"> 830                     }</span>
 831                     if (saveParameterNames)
 832                         ((MethodSymbol)sym).code = readCode(sym);
 833                     else
 834                         bp = bp + attrLen;
 835                 }
 836             },
 837 
 838             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 839                 protected void read(Symbol sym, int attrLen) {
 840                     Object v = poolReader.getConstant(nextChar());
 841                     // Ignore ConstantValue attribute if field not final.
 842                     if ((sym.flags() &amp; FINAL) == 0) {
 843                         return;
 844                     }
 845                     VarSymbol var = (VarSymbol) sym;
 846                     switch (var.type.getTag()) {
 847                        case BOOLEAN:
 848                        case BYTE:
 849                        case CHAR:
 850                        case SHORT:
</pre>
<hr />
<pre>
1461                 sym.flags_field |= PROPRIETARY;
1462             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1463                 if (profile != Profile.DEFAULT) {
1464                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1465                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1466                             Attribute.Constant c = (Attribute.Constant)v.snd;
1467                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1468                                 sym.flags_field |= NOT_IN_PROFILE;
1469                             }
1470                         }
1471                     }
1472                 }
1473             } else if (proxy.type.tsym.flatName() == syms.previewFeatureInternalType.tsym.flatName()) {
1474                 sym.flags_field |= PREVIEW_API;
1475                 setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1476             } else {
1477                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1478                     target = proxy;
1479                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1480                     repeatable = proxy;
<span class="line-added">1481                 } else if (allowValueBasedClasses &amp;&amp; sym.kind == TYP &amp;&amp; proxy.type.tsym == syms.valueBasedType.tsym) {</span>
<span class="line-added">1482                     sym.flags_field |= VALUEBASED;</span>
1483                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1484                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1485                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1486                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1487                     sym.flags_field |= PREVIEW_API;
1488                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1489                 }
1490                 proxies.append(proxy);
1491             }
1492         }
1493         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1494     }
1495     //where:
1496         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1497             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1498                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1499                     Attribute.Constant c = (Attribute.Constant)v.snd;
1500                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1501                         sym.flags_field |= flag;
1502                     }
</pre>
<hr />
<pre>
2240      */
2241     MethodSymbol readMethod() {
2242         long flags = adjustMethodFlags(nextChar());
2243         Name name = poolReader.getName(nextChar());
2244         Type type = poolReader.getType(nextChar());
2245         if (currentOwner.isInterface() &amp;&amp;
2246                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2247             if (majorVersion &gt; Version.V52.major ||
2248                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2249                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2250                     currentOwner.flags_field |= DEFAULT;
2251                     flags |= DEFAULT | ABSTRACT;
2252                 }
2253             } else {
2254                 //protect against ill-formed classfiles
2255                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2256                                    Integer.toString(majorVersion),
2257                                    Integer.toString(minorVersion));
2258             }
2259         }
<span class="line-added">2260         if (name == names.init &amp;&amp; ((flags &amp; STATIC) != 0)) {</span>
<span class="line-added">2261             flags &amp;= ~STATIC;</span>
<span class="line-added">2262             type = new MethodType(type.getParameterTypes(),</span>
<span class="line-added">2263                     syms.voidType,</span>
<span class="line-added">2264                     type.getThrownTypes(),</span>
<span class="line-added">2265                     syms.methodClass);</span>
<span class="line-added">2266         }</span>
2267         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2268             // Sometimes anonymous classes don&#39;t have an outer
2269             // instance, however, there is no reliable way to tell so
2270             // we never strip this$n
2271             // ditto for local classes. Local classes that have an enclosing method set
2272             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2273             // enclosing method (i.e. from initializers) will pass that check.
2274             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2275             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2276                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2277                                       type.getReturnType(),
2278                                       type.getThrownTypes(),
2279                                       syms.methodClass);
2280         }
2281         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2282         if (types.isSignaturePolymorphic(m)) {
2283             m.flags_field |= SIGNATURE_POLYMORPHIC;
2284         }
2285         if (saveParameterNames)
2286             initParameterNames(m);
</pre>
<hr />
<pre>
2471         }
2472     }
2473 
2474     /** Enter type variables of this classtype and all enclosing ones in
2475      *  `typevars&#39;.
2476      */
2477     protected void enterTypevars(Symbol sym, Type t) {
2478         if (t.getEnclosingType() != null) {
2479             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2480                 enterTypevars(sym.owner, t.getEnclosingType());
2481             }
2482         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2483             enterTypevars(sym.owner, sym.owner.type);
2484         }
2485         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2486             typevars.enter(xs.head.tsym);
2487         }
2488     }
2489 
2490     protected ClassSymbol enterClass(Name name) {
<span class="line-added">2491         if (allowInlineTypes &amp;&amp; name.toString().endsWith(&quot;$ref&quot;)) {</span>
<span class="line-added">2492             ClassSymbol v = syms.enterClass(currentModule, name.subName(0, name.length() - 4));</span>
<span class="line-added">2493             return v.referenceProjection();</span>
<span class="line-added">2494         }</span>
2495         return syms.enterClass(currentModule, name);
2496     }
2497 
2498     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2499         return syms.enterClass(currentModule, name, owner);
2500     }
2501 
2502     /** Read contents of a given class symbol `c&#39;. Both external and internal
2503      *  versions of an inner class are read.
2504      */
2505     void readClass(ClassSymbol c) {
2506         ClassType ct = (ClassType)c.type;
2507 
2508         // allocate scope for members
2509         c.members_field = WriteableScope.create(c);
2510 
2511         // prepare type variable table
2512         typevars = typevars.dup(currentOwner);
2513         if (ct.getEnclosingType().hasTag(CLASS))
2514             enterTypevars(c.owner, ct.getEnclosingType());
</pre>
<hr />
<pre>
2636         }
2637 
2638         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2639             if (!preview.isEnabled()) {
2640                 log.error(preview.disabledError(currentClassFile, majorVersion));
2641             } else {
2642                 preview.warnPreview(c.classfile, majorVersion);
2643             }
2644         }
2645 
2646         poolReader = new PoolReader(this, names, syms);
2647         bp = poolReader.readPool(buf, bp);
2648         if (signatureBuffer.length &lt; bp) {
2649             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2650             signatureBuffer = new byte[ns];
2651         }
2652         readClass(c);
2653     }
2654 
2655     public void readClassFile(ClassSymbol c) {
<span class="line-added">2656         readClassFileInternal(c);</span>
<span class="line-added">2657         if (c.isValue()) {</span>
<span class="line-added">2658             /* http://cr.openjdk.java.net/~briangoetz/valhalla/sov/04-translation.html</span>
<span class="line-added">2659                The relationship of value and reference projections differs between the language model</span>
<span class="line-added">2660                and the VM model. In the language, the value projection is not a subtype of the</span>
<span class="line-added">2661                reference projection; instead, the two are related by inline narrowing and widening</span>
<span class="line-added">2662                conversions, whereas in the VM, the two are related by actual subtyping.</span>
<span class="line-added">2663                Sever the subtyping relationship by rewiring the supertypes here and now.</span>
<span class="line-added">2664              */</span>
<span class="line-added">2665 </span>
<span class="line-added">2666             Name flatname = TypeSymbol.formFlatName(names.ref, c);</span>
<span class="line-added">2667             ClassSymbol referenceProjection = syms.getClass(currentModule, flatname);</span>
<span class="line-added">2668             if (referenceProjection != null) {</span>
<span class="line-added">2669                 if (referenceProjection.name != names.ref &amp;&amp; referenceProjection.owner.kind == PCK) {</span>
<span class="line-added">2670                     readClassFileInternal(referenceProjection);</span>
<span class="line-added">2671                     ClassType classType = (ClassType) c.type;</span>
<span class="line-added">2672                     classType.supertype_field = ((ClassType) referenceProjection.type).supertype_field;</span>
<span class="line-added">2673                     classType.interfaces_field = ((ClassType) referenceProjection.type).interfaces_field;</span>
<span class="line-added">2674                     // Discard the projection, it will be recomputed on the fly.</span>
<span class="line-added">2675                     referenceProjection.owner.members().remove(referenceProjection);</span>
<span class="line-added">2676                 }</span>
<span class="line-added">2677             }</span>
<span class="line-added">2678         }</span>
<span class="line-added">2679     }</span>
<span class="line-added">2680 </span>
<span class="line-added">2681     private void readClassFileInternal(ClassSymbol c) {</span>
2682         currentOwner = c;
2683         currentClassFile = c.classfile;
2684         warnedAttrs.clear();
2685         filling = true;
2686         target = null;
2687         repeatable = null;
2688         try {
2689             bp = 0;
2690             buf.reset();
2691             buf.appendStream(c.classfile.openInputStream());
2692             readClassBuffer(c);
2693             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2694                 List&lt;Type&gt; missing = missingTypeVariables;
2695                 List&lt;Type&gt; found = foundTypeVariables;
2696                 missingTypeVariables = List.nil();
2697                 foundTypeVariables = List.nil();
2698                 interimUses = List.nil();
2699                 interimProvides = List.nil();
2700                 filling = false;
2701                 ClassType ct = (ClassType)currentOwner.type;
</pre>
<hr />
<pre>
2757         return flags;
2758     }
2759 
2760     long adjustMethodFlags(long flags) {
2761         if ((flags &amp; ACC_BRIDGE) != 0) {
2762             flags &amp;= ~ACC_BRIDGE;
2763             flags |= BRIDGE;
2764         }
2765         if ((flags &amp; ACC_VARARGS) != 0) {
2766             flags &amp;= ~ACC_VARARGS;
2767             flags |= VARARGS;
2768         }
2769         return flags;
2770     }
2771 
2772     long adjustClassFlags(long flags) {
2773         if ((flags &amp; ACC_MODULE) != 0) {
2774             flags &amp;= ~ACC_MODULE;
2775             flags |= MODULE;
2776         }
<span class="line-added">2777         if ((flags &amp; ACC_VALUE) != 0) {</span>
<span class="line-added">2778             flags &amp;= ~ACC_VALUE;</span>
<span class="line-added">2779             flags |= allowInlineTypes ? VALUE : allowValueBasedClasses ? VALUEBASED : 0;</span>
<span class="line-added">2780         }</span>
2781         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2782     }
2783 
2784     /**
2785      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2786      * The attribute is only the last component of the original filename, so is unlikely
2787      * to be valid as is, so operations other than those to access the name throw
2788      * UnsupportedOperationException
2789      */
2790     private static class SourceFileObject implements JavaFileObject {
2791 
2792         /** The file&#39;s name.
2793          */
2794         private final Name name;
2795 
2796         public SourceFileObject(Name name) {
2797             this.name = name;
2798         }
2799 
2800         @Override @DefinedBy(Api.COMPILER)
</pre>
</td>
</tr>
</table>
<center><a href="../code/Symtab.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../parser/JavacParser.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>