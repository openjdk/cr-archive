<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.doclint;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.net.URI;
  31 import java.net.URISyntaxException;
  32 import java.util.Deque;
  33 import java.util.EnumSet;
  34 import java.util.HashMap;
  35 import java.util.HashSet;
  36 import java.util.LinkedList;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.Objects;
  40 import java.util.Set;
  41 import java.util.regex.Matcher;
  42 import java.util.regex.Pattern;
  43 
  44 import javax.lang.model.element.Element;
  45 import javax.lang.model.element.ElementKind;
  46 import javax.lang.model.element.ExecutableElement;
  47 import javax.lang.model.element.Name;
  48 import javax.lang.model.element.VariableElement;
  49 import javax.lang.model.type.TypeKind;
  50 import javax.lang.model.type.TypeMirror;
  51 import javax.tools.Diagnostic.Kind;
  52 import javax.tools.JavaFileObject;
  53 
  54 import com.sun.source.doctree.AttributeTree;
  55 import com.sun.source.doctree.AuthorTree;
  56 import com.sun.source.doctree.DocCommentTree;
  57 import com.sun.source.doctree.DocRootTree;
  58 import com.sun.source.doctree.DocTree;
  59 import com.sun.source.doctree.EndElementTree;
  60 import com.sun.source.doctree.EntityTree;
  61 import com.sun.source.doctree.ErroneousTree;
  62 import com.sun.source.doctree.IdentifierTree;
  63 import com.sun.source.doctree.IndexTree;
  64 import com.sun.source.doctree.InheritDocTree;
  65 import com.sun.source.doctree.LinkTree;
  66 import com.sun.source.doctree.LiteralTree;
  67 import com.sun.source.doctree.ParamTree;
  68 import com.sun.source.doctree.ProvidesTree;
  69 import com.sun.source.doctree.ReferenceTree;
  70 import com.sun.source.doctree.ReturnTree;
  71 import com.sun.source.doctree.SerialDataTree;
  72 import com.sun.source.doctree.SerialFieldTree;
  73 import com.sun.source.doctree.SinceTree;
  74 import com.sun.source.doctree.StartElementTree;
  75 import com.sun.source.doctree.SummaryTree;
  76 import com.sun.source.doctree.SystemPropertyTree;
  77 import com.sun.source.doctree.TextTree;
  78 import com.sun.source.doctree.ThrowsTree;
  79 import com.sun.source.doctree.UnknownBlockTagTree;
  80 import com.sun.source.doctree.UnknownInlineTagTree;
  81 import com.sun.source.doctree.UsesTree;
  82 import com.sun.source.doctree.ValueTree;
  83 import com.sun.source.doctree.VersionTree;
  84 import com.sun.source.tree.Tree;
  85 import com.sun.source.util.DocTreePath;
  86 import com.sun.source.util.DocTreePathScanner;
  87 import com.sun.source.util.TreePath;
  88 import com.sun.tools.doclint.HtmlTag.AttrKind;
  89 import com.sun.tools.javac.tree.DocPretty;
  90 import com.sun.tools.javac.util.Assert;
  91 import com.sun.tools.javac.util.DefinedBy;
  92 import com.sun.tools.javac.util.DefinedBy.Api;
  93 import com.sun.tools.javac.util.StringUtils;
  94 
  95 import static com.sun.tools.doclint.Messages.Group.*;
  96 
  97 
  98 /**
  99  * Validate a doc comment.
 100  *
 101  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 102  * If you write code that depends on this, you do so at your own
 103  * risk.  This code and its internal interfaces are subject to change
 104  * or deletion without notice.&lt;/b&gt;&lt;/p&gt;
 105  */
 106 public class Checker extends DocTreePathScanner&lt;Void, Void&gt; {
 107     final Env env;
 108 
 109     Set&lt;Element&gt; foundParams = new HashSet&lt;&gt;();
 110     Set&lt;TypeMirror&gt; foundThrows = new HashSet&lt;&gt;();
 111     Map&lt;Element, Set&lt;String&gt;&gt; foundAnchors = new HashMap&lt;&gt;();
 112     boolean foundInheritDoc = false;
 113     boolean foundReturn = false;
 114     boolean hasNonWhitespaceText = false;
 115 
 116     public enum Flag {
 117         TABLE_HAS_CAPTION,
 118         TABLE_IS_PRESENTATION,
 119         HAS_ELEMENT,
 120         HAS_HEADING,
 121         HAS_INLINE_TAG,
 122         HAS_TEXT,
 123         REPORTED_BAD_INLINE
 124     }
 125 
 126     static class TagStackItem {
 127         final DocTree tree; // typically, but not always, StartElementTree
 128         final HtmlTag tag;
 129         final Set&lt;HtmlTag.Attr&gt; attrs;
 130         final Set&lt;Flag&gt; flags;
 131         TagStackItem(DocTree tree, HtmlTag tag) {
 132             this.tree = tree;
 133             this.tag = tag;
 134             attrs = EnumSet.noneOf(HtmlTag.Attr.class);
 135             flags = EnumSet.noneOf(Flag.class);
 136         }
 137         @Override
 138         public String toString() {
 139             return String.valueOf(tag);
 140         }
 141     }
 142 
 143     private final Deque&lt;TagStackItem&gt; tagStack; // TODO: maybe want to record starting tree as well
 144     private HtmlTag currHeadingTag;
 145 
 146     private int implicitHeadingRank;
 147 
 148     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Top level&quot;&gt;
 149 
 150     Checker(Env env) {
 151         this.env = Assert.checkNonNull(env);
 152         tagStack = new LinkedList&lt;&gt;();
 153     }
 154 
 155     public Void scan(DocCommentTree tree, TreePath p) {
 156         env.initTypes();
 157         env.setCurrent(p, tree);
 158 
 159         boolean isOverridingMethod = !env.currOverriddenMethods.isEmpty();
 160         JavaFileObject fo = p.getCompilationUnit().getSourceFile();
 161 
 162         if (p.getLeaf().getKind() == Tree.Kind.PACKAGE) {
 163             // If p points to a package, the implied declaration is the
 164             // package declaration (if any) for the compilation unit.
 165             // Handle this case specially, because doc comments are only
 166             // expected in package-info files.
 167             boolean isPkgInfo = fo.isNameCompatible(&quot;package-info&quot;, JavaFileObject.Kind.SOURCE);
 168             if (tree == null) {
 169                 if (isPkgInfo)
 170                     reportMissing(&quot;dc.missing.comment&quot;);
 171                 return null;
 172             } else {
 173                 if (!isPkgInfo)
 174                     reportReference(&quot;dc.unexpected.comment&quot;);
 175             }
 176         } else if (tree != null &amp;&amp; fo.isNameCompatible(&quot;package&quot;, JavaFileObject.Kind.HTML)) {
 177             // a package.html file with a DocCommentTree
 178             if (tree.getFullBody().isEmpty()) {
 179                 reportMissing(&quot;dc.missing.comment&quot;);
 180                 return null;
 181             }
 182         } else {
 183             if (tree == null) {
 184                 if (!isSynthetic() &amp;&amp; !isOverridingMethod)
 185                     reportMissing(&quot;dc.missing.comment&quot;);
 186                 return null;
 187             }
 188         }
 189 
 190         tagStack.clear();
 191         currHeadingTag = null;
 192 
 193         foundParams.clear();
 194         foundThrows.clear();
 195         foundInheritDoc = false;
 196         foundReturn = false;
 197         hasNonWhitespaceText = false;
 198 
 199         switch (p.getLeaf().getKind()) {
 200             // the following are for declarations that have their own top-level page,
 201             // and so the doc comment comes after the &lt;h1&gt; page title.
 202             case MODULE:
 203             case PACKAGE:
 204             case CLASS:
 205             case INTERFACE:
 206             case ENUM:
 207             case ANNOTATION_TYPE:
 208             case RECORD:
 209                 implicitHeadingRank = 1;
 210                 break;
 211 
 212             // this is for html files
 213             // ... if it is a legacy package.html, the doc comment comes after the &lt;h1&gt; page title
 214             // ... otherwise, (e.g. overview file and doc-files/*.html files) no additional headings are inserted
 215             case COMPILATION_UNIT:
 216                 implicitHeadingRank = fo.isNameCompatible(&quot;package&quot;, JavaFileObject.Kind.HTML) ? 1 : 0;
 217                 break;
 218 
 219             // the following are for member declarations, which appear in the page
 220             // for the enclosing type, and so appear after the &lt;h2&gt; &quot;Members&quot;
 221             // aggregate heading and the specific &lt;h3&gt; &quot;Member signature&quot; heading.
 222             case METHOD:
 223             case VARIABLE:
 224                 implicitHeadingRank = 3;
 225                 break;
 226 
 227             default:
 228                 Assert.error(&quot;unexpected tree kind: &quot; + p.getLeaf().getKind() + &quot; &quot; + fo);
 229         }
 230 
 231         scan(new DocTreePath(p, tree), null);
 232 
 233         if (!isOverridingMethod) {
 234             switch (env.currElement.getKind()) {
 235                 case METHOD:
 236                 case CONSTRUCTOR: {
 237                     ExecutableElement ee = (ExecutableElement) env.currElement;
 238                     checkParamsDocumented(ee.getTypeParameters());
 239                     checkParamsDocumented(ee.getParameters());
 240                     switch (ee.getReturnType().getKind()) {
 241                         case VOID:
 242                         case NONE:
 243                             break;
 244                         default:
 245                             if (!foundReturn
 246                                     &amp;&amp; !foundInheritDoc
 247                                     &amp;&amp; !env.types.isSameType(ee.getReturnType(), env.java_lang_Void)) {
 248                                 reportMissing(&quot;dc.missing.return&quot;);
 249                             }
 250                     }
 251                     checkThrowsDocumented(ee.getThrownTypes());
 252                 }
 253             }
 254         }
 255 
 256         return null;
 257     }
 258 
 259     private void reportMissing(String code, Object... args) {
 260         env.messages.report(MISSING, Kind.WARNING, env.currPath.getLeaf(), code, args);
 261     }
 262 
 263     private void reportReference(String code, Object... args) {
 264         env.messages.report(REFERENCE, Kind.WARNING, env.currPath.getLeaf(), code, args);
 265     }
 266 
 267     @Override @DefinedBy(Api.COMPILER_TREE)
 268     public Void visitDocComment(DocCommentTree tree, Void ignore) {
 269         super.visitDocComment(tree, ignore);
 270         for (TagStackItem tsi: tagStack) {
 271             warnIfEmpty(tsi, null);
 272             if (tsi.tree.getKind() == DocTree.Kind.START_ELEMENT
 273                     &amp;&amp; tsi.tag.endKind == HtmlTag.EndKind.REQUIRED) {
 274                 StartElementTree t = (StartElementTree) tsi.tree;
 275                 env.messages.error(HTML, t, &quot;dc.tag.not.closed&quot;, t.getName());
 276             }
 277         }
 278         return null;
 279     }
 280     // &lt;/editor-fold&gt;
 281 
 282     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Text and entities.&quot;&gt;
 283 
 284     @Override @DefinedBy(Api.COMPILER_TREE)
 285     public Void visitText(TextTree tree, Void ignore) {
 286         hasNonWhitespaceText = hasNonWhitespace(tree);
 287         if (hasNonWhitespaceText) {
 288             checkAllowsText(tree);
 289             markEnclosingTag(Flag.HAS_TEXT);
 290         }
 291         return null;
 292     }
 293 
 294     @Override @DefinedBy(Api.COMPILER_TREE)
 295     public Void visitEntity(EntityTree tree, Void ignore) {
 296         checkAllowsText(tree);
 297         markEnclosingTag(Flag.HAS_TEXT);
 298         String name = tree.getName().toString();
 299         if (name.startsWith(&quot;#&quot;)) {
 300             int v = StringUtils.toLowerCase(name).startsWith(&quot;#x&quot;)
 301                     ? Integer.parseInt(name.substring(2), 16)
 302                     : Integer.parseInt(name.substring(1), 10);
 303             if (!Entity.isValid(v)) {
 304                 env.messages.error(HTML, tree, &quot;dc.entity.invalid&quot;, name);
 305             }
 306         } else if (!Entity.isValid(name)) {
 307             env.messages.error(HTML, tree, &quot;dc.entity.invalid&quot;, name);
 308         }
 309         return null;
 310     }
 311 
 312     void checkAllowsText(DocTree tree) {
 313         TagStackItem top = tagStack.peek();
 314         if (top != null
 315                 &amp;&amp; top.tree.getKind() == DocTree.Kind.START_ELEMENT
 316                 &amp;&amp; !top.tag.acceptsText()) {
 317             if (top.flags.add(Flag.REPORTED_BAD_INLINE)) {
 318                 env.messages.error(HTML, tree, &quot;dc.text.not.allowed&quot;,
 319                         ((StartElementTree) top.tree).getName());
 320             }
 321         }
 322     }
 323 
 324     // &lt;/editor-fold&gt;
 325 
 326     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;HTML elements&quot;&gt;
 327 
 328     @Override @DefinedBy(Api.COMPILER_TREE)
 329     public Void visitStartElement(StartElementTree tree, Void ignore) {
 330         final Name treeName = tree.getName();
 331         final HtmlTag t = HtmlTag.get(treeName);
 332         if (t == null) {
 333             env.messages.error(HTML, tree, &quot;dc.tag.unknown&quot;, treeName);
 334         } else if (t.allowedVersion != HtmlVersion.ALL &amp;&amp; t.allowedVersion != env.htmlVersion) {
 335             env.messages.error(HTML, tree, &quot;dc.tag.not.supported&quot;, treeName);
 336         } else {
 337             boolean done = false;
 338             for (TagStackItem tsi: tagStack) {
 339                 if (tsi.tag.accepts(t)) {
 340                     while (tagStack.peek() != tsi) {
 341                         warnIfEmpty(tagStack.peek(), null);
 342                         tagStack.pop();
 343                     }
 344                     done = true;
 345                     break;
 346                 } else if (tsi.tag.endKind != HtmlTag.EndKind.OPTIONAL) {
 347                     done = true;
 348                     break;
 349                 }
 350             }
 351             if (!done &amp;&amp; HtmlTag.BODY.accepts(t)) {
 352                 while (!tagStack.isEmpty()) {
 353                     warnIfEmpty(tagStack.peek(), null);
 354                     tagStack.pop();
 355                 }
 356             }
 357 
 358             markEnclosingTag(Flag.HAS_ELEMENT);
 359             checkStructure(tree, t);
 360 
 361             // tag specific checks
 362             switch (t) {
 363                 // check for out of sequence headings, such as &lt;h1&gt;...&lt;/h1&gt;  &lt;h3&gt;...&lt;/h3&gt;
 364                 case H1: case H2: case H3: case H4: case H5: case H6:
 365                     checkHeading(tree, t);
 366                     break;
 367             }
 368 
 369             if (t.flags.contains(HtmlTag.Flag.NO_NEST)) {
 370                 for (TagStackItem i: tagStack) {
 371                     if (t == i.tag) {
 372                         env.messages.warning(HTML, tree, &quot;dc.tag.nested.not.allowed&quot;, treeName);
 373                         break;
 374                     }
 375                 }
 376             }
 377         }
 378 
 379         // check for self closing tags, such as &lt;a id=&quot;name&quot;/&gt;
 380         if (tree.isSelfClosing() &amp;&amp; !isSelfClosingAllowed(t)) {
 381             env.messages.error(HTML, tree, &quot;dc.tag.self.closing&quot;, treeName);
 382         }
 383 
 384         try {
 385             TagStackItem parent = tagStack.peek();
 386             TagStackItem top = new TagStackItem(tree, t);
 387             tagStack.push(top);
 388 
 389             super.visitStartElement(tree, ignore);
 390 
 391             // handle attributes that may or may not have been found in start element
 392             if (t != null) {
 393                 switch (t) {
 394                     case CAPTION:
 395                         if (parent != null &amp;&amp; parent.tag == HtmlTag.TABLE)
 396                             parent.flags.add(Flag.TABLE_HAS_CAPTION);
 397                         break;
 398 
 399                     case H1: case H2: case H3: case H4: case H5: case H6:
 400                         if (parent != null &amp;&amp; (parent.tag == HtmlTag.SECTION || parent.tag == HtmlTag.ARTICLE)) {
 401                             parent.flags.add(Flag.HAS_HEADING);
 402                         }
 403                         break;
 404 
 405                     case IMG:
 406                         if (!top.attrs.contains(HtmlTag.Attr.ALT))
 407                             env.messages.error(ACCESSIBILITY, tree, &quot;dc.no.alt.attr.for.image&quot;);
 408                         break;
 409                 }
 410             }
 411 
 412             return null;
 413         } finally {
 414 
 415             if (t == null || t.endKind == HtmlTag.EndKind.NONE)
 416                 tagStack.pop();
 417         }
 418     }
 419 
 420     // so-called &quot;self-closing&quot; tags are only permitted in HTML 5, for void elements
 421     // https://html.spec.whatwg.org/multipage/syntax.html#start-tags
 422     private boolean isSelfClosingAllowed(HtmlTag tag) {
 423         return env.htmlVersion == HtmlVersion.HTML5
 424                 &amp;&amp; tag.endKind == HtmlTag.EndKind.NONE;
 425     }
 426 
 427     private void checkStructure(StartElementTree tree, HtmlTag t) {
 428         Name treeName = tree.getName();
 429         TagStackItem top = tagStack.peek();
 430         switch (t.blockType) {
 431             case BLOCK:
 432                 if (top == null || top.tag.accepts(t))
 433                     return;
 434 
 435                 switch (top.tree.getKind()) {
 436                     case START_ELEMENT: {
 437                         if (top.tag.blockType == HtmlTag.BlockType.INLINE) {
 438                             Name name = ((StartElementTree) top.tree).getName();
 439                             env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.inline.element&quot;,
 440                                     treeName, name);
 441                             return;
 442                         }
 443                     }
 444                     break;
 445 
 446                     case LINK:
 447                     case LINK_PLAIN: {
 448                         String name = top.tree.getKind().tagName;
 449                         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.inline.tag&quot;,
 450                                 treeName, name);
 451                         return;
 452                     }
 453                 }
 454                 break;
 455 
 456             case INLINE:
 457                 if (top == null || top.tag.accepts(t))
 458                     return;
 459                 break;
 460 
 461             case LIST_ITEM:
 462             case TABLE_ITEM:
 463                 if (top != null) {
 464                     // reset this flag so subsequent bad inline content gets reported
 465                     top.flags.remove(Flag.REPORTED_BAD_INLINE);
 466                     if (top.tag.accepts(t))
 467                         return;
 468                 }
 469                 break;
 470 
 471             case OTHER:
 472                 switch (t) {
 473                     case SCRIPT:
 474                         // &lt;script&gt; may or may not be allowed, depending on --allow-script-in-comments
 475                         // but we allow it here, and rely on a separate scanner to detect all uses
 476                         // of JavaScript, including &lt;script&gt; tags, and use in attributes, etc.
 477                         break;
 478 
 479                     default:
 480                         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed&quot;, treeName);
 481                 }
 482                 return;
 483         }
 484 
 485         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.here&quot;, treeName);
 486     }
 487 
 488     private void checkHeading(StartElementTree tree, HtmlTag tag) {
 489         // verify the new tag
 490         if (getHeadingRank(tag) &gt; getHeadingRank(currHeadingTag) + 1) {
 491             if (currHeadingTag == null) {
 492                 env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.1&quot;,
 493                         tag, implicitHeadingRank);
 494             } else {
 495                 env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.2&quot;,
 496                     tag, currHeadingTag);
 497             }
 498         } else if (getHeadingRank(tag) &lt;= implicitHeadingRank) {
 499             env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.3&quot;,
 500                     tag, implicitHeadingRank);
 501         }
 502 
 503         currHeadingTag = tag;
 504     }
 505 
 506     private int getHeadingRank(HtmlTag tag) {
 507         if (tag == null)
 508             return implicitHeadingRank;
 509         switch (tag) {
 510             case H1: return 1;
 511             case H2: return 2;
 512             case H3: return 3;
 513             case H4: return 4;
 514             case H5: return 5;
 515             case H6: return 6;
 516             default: throw new IllegalArgumentException();
 517         }
 518     }
 519 
 520     @Override @DefinedBy(Api.COMPILER_TREE)
 521     public Void visitEndElement(EndElementTree tree, Void ignore) {
 522         final Name treeName = tree.getName();
 523         final HtmlTag t = HtmlTag.get(treeName);
 524         if (t == null) {
 525             env.messages.error(HTML, tree, &quot;dc.tag.unknown&quot;, treeName);
 526         } else if (t.endKind == HtmlTag.EndKind.NONE) {
 527             env.messages.error(HTML, tree, &quot;dc.tag.end.not.permitted&quot;, treeName);
 528         } else {
 529             boolean done = false;
 530             while (!tagStack.isEmpty()) {
 531                 TagStackItem top = tagStack.peek();
 532                 if (t == top.tag) {
 533                     switch (t) {
 534                         case TABLE:
 535                             if (!top.flags.contains(Flag.TABLE_IS_PRESENTATION)
 536                                     &amp;&amp; !top.attrs.contains(HtmlTag.Attr.SUMMARY)
 537                                     &amp;&amp; !top.flags.contains(Flag.TABLE_HAS_CAPTION)) {
 538                                 env.messages.error(ACCESSIBILITY, tree,
 539                                         &quot;dc.no.summary.or.caption.for.table&quot;);
 540                             }
 541                             break;
 542 
 543                         case SECTION:
 544                         case ARTICLE:
 545                             if (env.htmlVersion == HtmlVersion.HTML5 &amp;&amp; !top.flags.contains(Flag.HAS_HEADING)) {
 546                                 env.messages.error(HTML, tree, &quot;dc.tag.requires.heading&quot;, treeName);
 547                             }
 548                             break;
 549                     }
 550                     warnIfEmpty(top, tree);
 551                     tagStack.pop();
 552                     done = true;
 553                     break;
 554                 } else if (top.tag == null || top.tag.endKind != HtmlTag.EndKind.REQUIRED) {
 555                     tagStack.pop();
 556                 } else {
 557                     boolean found = false;
 558                     for (TagStackItem si: tagStack) {
 559                         if (si.tag == t) {
 560                             found = true;
 561                             break;
 562                         }
 563                     }
 564                     if (found &amp;&amp; top.tree.getKind() == DocTree.Kind.START_ELEMENT) {
 565                         env.messages.error(HTML, top.tree, &quot;dc.tag.start.unmatched&quot;,
 566                                 ((StartElementTree) top.tree).getName());
 567                         tagStack.pop();
 568                     } else {
 569                         env.messages.error(HTML, tree, &quot;dc.tag.end.unexpected&quot;, treeName);
 570                         done = true;
 571                         break;
 572                     }
 573                 }
 574             }
 575 
 576             if (!done &amp;&amp; tagStack.isEmpty()) {
 577                 env.messages.error(HTML, tree, &quot;dc.tag.end.unexpected&quot;, treeName);
 578             }
 579         }
 580 
 581         return super.visitEndElement(tree, ignore);
 582     }
 583 
 584     void warnIfEmpty(TagStackItem tsi, DocTree endTree) {
 585         if (tsi.tag != null &amp;&amp; tsi.tree instanceof StartElementTree) {
 586             if (tsi.tag.flags.contains(HtmlTag.Flag.EXPECT_CONTENT)
 587                     &amp;&amp; !tsi.flags.contains(Flag.HAS_TEXT)
 588                     &amp;&amp; !tsi.flags.contains(Flag.HAS_ELEMENT)
 589                     &amp;&amp; !tsi.flags.contains(Flag.HAS_INLINE_TAG)) {
 590                 DocTree tree = (endTree != null) ? endTree : tsi.tree;
 591                 Name treeName = ((StartElementTree) tsi.tree).getName();
 592                 env.messages.warning(HTML, tree, &quot;dc.tag.empty&quot;, treeName);
 593             }
 594         }
 595     }
 596 
 597     // &lt;/editor-fold&gt;
 598 
 599     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;HTML attributes&quot;&gt;
 600 
 601     @Override @DefinedBy(Api.COMPILER_TREE) @SuppressWarnings(&quot;fallthrough&quot;)
 602     public Void visitAttribute(AttributeTree tree, Void ignore) {
 603         HtmlTag currTag = tagStack.peek().tag;
 604         if (currTag != null) {
 605             Name name = tree.getName();
 606             HtmlTag.Attr attr = currTag.getAttr(name);
 607             if (attr != null) {
 608                 if (env.htmlVersion == HtmlVersion.HTML4 &amp;&amp; attr.name().contains(&quot;-&quot;)) {
 609                     env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html4&quot;, name);
 610                 }
 611                 boolean first = tagStack.peek().attrs.add(attr);
 612                 if (!first)
 613                     env.messages.error(HTML, tree, &quot;dc.attr.repeated&quot;, name);
 614             }
 615             // for now, doclint allows all attribute names beginning with &quot;on&quot; as event handler names,
 616             // without checking the validity or applicability of the name
 617             if (!name.toString().startsWith(&quot;on&quot;)) {
 618                 AttrKind k = currTag.getAttrKind(name);
 619                 switch (env.htmlVersion) {
 620                     case HTML4:
 621                         validateHtml4Attrs(tree, name, k);
 622                         break;
 623 
 624                     case HTML5:
 625                         validateHtml5Attrs(tree, name, k);
 626                         break;
 627                 }
 628             }
 629 
 630             if (attr != null) {
 631                 switch (attr) {
 632                     case NAME:
 633                         if (currTag != HtmlTag.A) {
 634                             break;
 635                         }
 636                         // fallthrough
 637                     case ID:
 638                         String value = getAttrValue(tree);
 639                         if (value == null) {
 640                             env.messages.error(HTML, tree, &quot;dc.anchor.value.missing&quot;);
 641                         } else {
 642                             if (!validName.matcher(value).matches()) {
 643                                 env.messages.error(HTML, tree, &quot;dc.invalid.anchor&quot;, value);
 644                             }
 645                             if (!checkAnchor(value)) {
 646                                 env.messages.error(HTML, tree, &quot;dc.anchor.already.defined&quot;, value);
 647                             }
 648                         }
 649                         break;
 650 
 651                     case HREF:
 652                         if (currTag == HtmlTag.A) {
 653                             String v = getAttrValue(tree);
 654                             if (v == null || v.isEmpty()) {
 655                                 env.messages.error(HTML, tree, &quot;dc.attr.lacks.value&quot;);
 656                             } else {
 657                                 Matcher m = docRoot.matcher(v);
 658                                 if (m.matches()) {
 659                                     String rest = m.group(2);
 660                                     if (!rest.isEmpty())
 661                                         checkURI(tree, rest);
 662                                 } else {
 663                                     checkURI(tree, v);
 664                                 }
 665                             }
 666                         }
 667                         break;
 668 
 669                     case VALUE:
 670                         if (currTag == HtmlTag.LI) {
 671                             String v = getAttrValue(tree);
 672                             if (v == null || v.isEmpty()) {
 673                                 env.messages.error(HTML, tree, &quot;dc.attr.lacks.value&quot;);
 674                             } else if (!validNumber.matcher(v).matches()) {
 675                                 env.messages.error(HTML, tree, &quot;dc.attr.not.number&quot;);
 676                             }
 677                         }
 678                         break;
 679 
 680                     case BORDER:
 681                         if (currTag == HtmlTag.TABLE) {
 682                             String v = getAttrValue(tree);
 683                             try {
 684                                 if (env.htmlVersion == HtmlVersion.HTML5
 685                                         &amp;&amp; (v == null || (!v.isEmpty() &amp;&amp; Integer.parseInt(v) != 1))) {
 686                                     env.messages.error(HTML, tree, &quot;dc.attr.table.border.html5&quot;, attr);
 687                                 }
 688                             } catch (NumberFormatException ex) {
 689                                 env.messages.error(HTML, tree, &quot;dc.attr.table.border.html5&quot;, attr);
 690                             }
 691                         }
 692                         break;
 693 
 694                     case ROLE:
 695                         if (currTag == HtmlTag.TABLE) {
 696                             String v = getAttrValue(tree);
 697                             if (Objects.equals(v, &quot;presentation&quot;)) {
 698                                 tagStack.peek().flags.add(Flag.TABLE_IS_PRESENTATION);
 699                             }
 700                         }
 701                         break;
 702                 }
 703             }
 704         }
 705 
 706         // TODO: basic check on value
 707 
 708         return null;
 709     }
 710 
 711     private void validateHtml4Attrs(AttributeTree tree, Name name, AttrKind k) {
 712         switch (k) {
 713             case ALL:
 714             case HTML4:
 715                 break;
 716 
 717             case INVALID:
 718                 env.messages.error(HTML, tree, &quot;dc.attr.unknown&quot;, name);
 719                 break;
 720 
 721             case OBSOLETE:
 722                 env.messages.warning(HTML, tree, &quot;dc.attr.obsolete&quot;, name);
 723                 break;
 724 
 725             case USE_CSS:
 726                 env.messages.warning(HTML, tree, &quot;dc.attr.obsolete.use.css&quot;, name);
 727                 break;
 728 
 729             case HTML5:
 730                 env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html4&quot;, name);
 731                 break;
 732         }
 733     }
 734 
 735     private void validateHtml5Attrs(AttributeTree tree, Name name, AttrKind k) {
 736         switch (k) {
 737             case ALL:
 738             case HTML5:
 739                 break;
 740 
 741             case INVALID:
 742             case OBSOLETE:
 743             case USE_CSS:
 744             case HTML4:
 745                 env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html5&quot;, name);
 746                 break;
 747         }
 748     }
 749 
 750     private boolean checkAnchor(String name) {
 751         Element e = getEnclosingPackageOrClass(env.currElement);
 752         if (e == null)
 753             return true;
 754         Set&lt;String&gt; set = foundAnchors.get(e);
 755         if (set == null)
 756             foundAnchors.put(e, set = new HashSet&lt;&gt;());
 757         return set.add(name);
 758     }
 759 
 760     private Element getEnclosingPackageOrClass(Element e) {
 761         while (e != null) {
 762             switch (e.getKind()) {
 763                 case CLASS:
 764                 case ENUM:
 765                 case INTERFACE:
 766                 case PACKAGE:
 767                     return e;
 768                 default:
 769                     e = e.getEnclosingElement();
 770             }
 771         }
 772         return e;
 773     }
 774 
 775     // http://www.w3.org/TR/html401/types.html#type-name
 776     private static final Pattern validName = Pattern.compile(&quot;[A-Za-z][A-Za-z0-9-_:.]*&quot;);
 777 
 778     private static final Pattern validNumber = Pattern.compile(&quot;-?[0-9]+&quot;);
 779 
 780     // pattern to remove leading {@docRoot}/?
 781     private static final Pattern docRoot = Pattern.compile(&quot;(?i)(\\{@docRoot *\\}/?)?(.*)&quot;);
 782 
 783     private String getAttrValue(AttributeTree tree) {
 784         if (tree.getValue() == null)
 785             return null;
 786 
 787         StringWriter sw = new StringWriter();
 788         try {
 789             new DocPretty(sw).print(tree.getValue());
 790         } catch (IOException e) {
 791             // cannot happen
 792         }
 793         // ignore potential use of entities for now
 794         return sw.toString();
 795     }
 796 
 797     private void checkURI(AttributeTree tree, String uri) {
 798         // allow URIs beginning with javascript:, which would otherwise be rejected by the URI API.
 799         if (uri.startsWith(&quot;javascript:&quot;))
 800             return;
 801         try {
 802             URI u = new URI(uri);
 803         } catch (URISyntaxException e) {
 804             env.messages.error(HTML, tree, &quot;dc.invalid.uri&quot;, uri);
 805         }
 806     }
 807     // &lt;/editor-fold&gt;
 808 
 809     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;javadoc tags&quot;&gt;
 810 
 811     @Override @DefinedBy(Api.COMPILER_TREE)
 812     public Void visitAuthor(AuthorTree tree, Void ignore) {
 813         warnIfEmpty(tree, tree.getName());
 814         return super.visitAuthor(tree, ignore);
 815     }
 816 
 817     @Override @DefinedBy(Api.COMPILER_TREE)
 818     public Void visitDocRoot(DocRootTree tree, Void ignore) {
 819         markEnclosingTag(Flag.HAS_INLINE_TAG);
 820         return super.visitDocRoot(tree, ignore);
 821     }
 822 
 823     @Override @DefinedBy(Api.COMPILER_TREE)
 824     public Void visitIndex(IndexTree tree, Void ignore) {
 825         markEnclosingTag(Flag.HAS_INLINE_TAG);
 826         for (TagStackItem tsi : tagStack) {
 827             if (tsi.tag == HtmlTag.A) {
 828                 env.messages.warning(HTML, tree, &quot;dc.tag.a.within.a&quot;,
 829                         &quot;{@&quot; + tree.getTagName() + &quot;}&quot;);
 830                 break;
 831             }
 832         }
 833         return super.visitIndex(tree, ignore);
 834     }
 835 
 836     @Override @DefinedBy(Api.COMPILER_TREE)
 837     public Void visitInheritDoc(InheritDocTree tree, Void ignore) {
 838         markEnclosingTag(Flag.HAS_INLINE_TAG);
 839         // TODO: verify on overridden method
 840         foundInheritDoc = true;
 841         return super.visitInheritDoc(tree, ignore);
 842     }
 843 
 844     @Override @DefinedBy(Api.COMPILER_TREE)
 845     public Void visitLink(LinkTree tree, Void ignore) {
 846         markEnclosingTag(Flag.HAS_INLINE_TAG);
 847         // simulate inline context on tag stack
 848         HtmlTag t = (tree.getKind() == DocTree.Kind.LINK)
 849                 ? HtmlTag.CODE : HtmlTag.SPAN;
 850         tagStack.push(new TagStackItem(tree, t));
 851         try {
 852             return super.visitLink(tree, ignore);
 853         } finally {
 854             tagStack.pop();
 855         }
 856     }
 857 
 858     @Override @DefinedBy(Api.COMPILER_TREE)
 859     public Void visitLiteral(LiteralTree tree, Void ignore) {
 860         markEnclosingTag(Flag.HAS_INLINE_TAG);
 861         if (tree.getKind() == DocTree.Kind.CODE) {
 862             for (TagStackItem tsi: tagStack) {
 863                 if (tsi.tag == HtmlTag.CODE) {
 864                     env.messages.warning(HTML, tree, &quot;dc.tag.code.within.code&quot;);
 865                     break;
 866                 }
 867             }
 868         }
 869         return super.visitLiteral(tree, ignore);
 870     }
 871 
 872     @Override @DefinedBy(Api.COMPILER_TREE)
 873     @SuppressWarnings(&quot;fallthrough&quot;)
 874     public Void visitParam(ParamTree tree, Void ignore) {
 875         boolean typaram = tree.isTypeParameter();
 876         IdentifierTree nameTree = tree.getName();
 877         Element paramElement = nameTree != null ? env.trees.getElement(new DocTreePath(getCurrentPath(), nameTree)) : null;
 878 
 879         if (paramElement == null) {
 880             switch (env.currElement.getKind()) {
 881                 case CLASS: case INTERFACE: {
 882                     if (!typaram) {
 883                         env.messages.error(REFERENCE, tree, &quot;dc.invalid.param&quot;);
 884                         break;
 885                     }
 886                 }
 887                 case METHOD: case CONSTRUCTOR: {
 888                     env.messages.error(REFERENCE, nameTree, &quot;dc.param.name.not.found&quot;);
 889                     break;
 890                 }
 891 
 892                 default:
 893                     env.messages.error(REFERENCE, tree, &quot;dc.invalid.param&quot;);
 894                     break;
 895             }
 896         } else {
 897             boolean unique = foundParams.add(paramElement);
 898 
 899             if (!unique) {
 900                 env.messages.warning(REFERENCE, tree, &quot;dc.exists.param&quot;, nameTree);
 901             }
 902         }
 903 
 904         warnIfEmpty(tree, tree.getDescription());
 905         return super.visitParam(tree, ignore);
 906     }
 907 
 908     private void checkParamsDocumented(List&lt;? extends Element&gt; list) {
 909         if (foundInheritDoc)
 910             return;
 911 
 912         for (Element e: list) {
 913             if (!foundParams.contains(e)) {
 914                 CharSequence paramName = (e.getKind() == ElementKind.TYPE_PARAMETER)
 915                         ? &quot;&lt;&quot; + e.getSimpleName() + &quot;&gt;&quot;
 916                         : e.getSimpleName();
 917                 reportMissing(&quot;dc.missing.param&quot;, paramName);
 918             }
 919         }
 920     }
 921 
 922     @Override @DefinedBy(Api.COMPILER_TREE)
 923     public Void visitProvides(ProvidesTree tree, Void ignore) {
 924         Element e = env.trees.getElement(env.currPath);
 925         if (e.getKind() != ElementKind.MODULE) {
 926             env.messages.error(REFERENCE, tree, &quot;dc.invalid.provides&quot;);
 927         }
 928         ReferenceTree serviceType = tree.getServiceType();
 929         Element se = env.trees.getElement(new DocTreePath(getCurrentPath(), serviceType));
 930         if (se == null) {
 931             env.messages.error(REFERENCE, tree, &quot;dc.service.not.found&quot;);
 932         }
 933         return super.visitProvides(tree, ignore);
 934     }
 935 
 936     @Override @DefinedBy(Api.COMPILER_TREE)
 937     public Void visitReference(ReferenceTree tree, Void ignore) {
 938         Element e = env.trees.getElement(getCurrentPath());
 939         if (e == null)
 940             env.messages.error(REFERENCE, tree, &quot;dc.ref.not.found&quot;);
 941         return super.visitReference(tree, ignore);
 942     }
 943 
 944     @Override @DefinedBy(Api.COMPILER_TREE)
 945     public Void visitReturn(ReturnTree tree, Void ignore) {
 946         if (foundReturn) {
 947             env.messages.warning(REFERENCE, tree, &quot;dc.exists.return&quot;);
 948         }
 949 
 950         Element e = env.trees.getElement(env.currPath);
 951         if (e.getKind() != ElementKind.METHOD
 952                 || ((ExecutableElement) e).getReturnType().getKind() == TypeKind.VOID)
 953             env.messages.error(REFERENCE, tree, &quot;dc.invalid.return&quot;);
 954         foundReturn = true;
 955         warnIfEmpty(tree, tree.getDescription());
 956         return super.visitReturn(tree, ignore);
 957     }
 958 
 959     @Override @DefinedBy(Api.COMPILER_TREE)
 960     public Void visitSerialData(SerialDataTree tree, Void ignore) {
 961         warnIfEmpty(tree, tree.getDescription());
 962         return super.visitSerialData(tree, ignore);
 963     }
 964 
 965     @Override @DefinedBy(Api.COMPILER_TREE)
 966     public Void visitSerialField(SerialFieldTree tree, Void ignore) {
 967         warnIfEmpty(tree, tree.getDescription());
 968         return super.visitSerialField(tree, ignore);
 969     }
 970 
 971     @Override @DefinedBy(Api.COMPILER_TREE)
 972     public Void visitSince(SinceTree tree, Void ignore) {
 973         warnIfEmpty(tree, tree.getBody());
 974         return super.visitSince(tree, ignore);
 975     }
 976 
 977     @Override @DefinedBy(Api.COMPILER_TREE)
 978     public Void visitSummary(SummaryTree node, Void aVoid) {
 979         markEnclosingTag(Flag.HAS_INLINE_TAG);
 980         int idx = env.currDocComment.getFullBody().indexOf(node);
 981         // Warn if the node is preceded by non-whitespace characters,
 982         // or other non-text nodes.
 983         if ((idx == 1 &amp;&amp; hasNonWhitespaceText) || idx &gt; 1) {
 984             env.messages.warning(SYNTAX, node, &quot;dc.invalid.summary&quot;, node.getTagName());
 985         }
 986         return super.visitSummary(node, aVoid);
 987     }
 988 
 989     @Override @DefinedBy(Api.COMPILER_TREE)
 990     public Void visitSystemProperty(SystemPropertyTree tree, Void ignore) {
 991         markEnclosingTag(Flag.HAS_INLINE_TAG);
 992         for (TagStackItem tsi : tagStack) {
 993             if (tsi.tag == HtmlTag.A) {
 994                 env.messages.warning(HTML, tree, &quot;dc.tag.a.within.a&quot;,
 995                         &quot;{@&quot; + tree.getTagName() + &quot;}&quot;);
 996                 break;
 997             }
 998         }
 999         return super.visitSystemProperty(tree, ignore);
1000     }
1001 
1002     @Override @DefinedBy(Api.COMPILER_TREE)
1003     public Void visitThrows(ThrowsTree tree, Void ignore) {
1004         ReferenceTree exName = tree.getExceptionName();
1005         Element ex = env.trees.getElement(new DocTreePath(getCurrentPath(), exName));
1006         if (ex == null) {
1007             env.messages.error(REFERENCE, tree, &quot;dc.ref.not.found&quot;);
1008         } else if (isThrowable(ex.asType())) {
1009             switch (env.currElement.getKind()) {
1010                 case CONSTRUCTOR:
1011                 case METHOD:
1012                     if (isCheckedException(ex.asType())) {
1013                         ExecutableElement ee = (ExecutableElement) env.currElement;
1014                         checkThrowsDeclared(exName, ex.asType(), ee.getThrownTypes());
1015                     }
1016                     break;
1017                 default:
1018                     env.messages.error(REFERENCE, tree, &quot;dc.invalid.throws&quot;);
1019             }
1020         } else {
1021             env.messages.error(REFERENCE, tree, &quot;dc.invalid.throws&quot;);
1022         }
1023         warnIfEmpty(tree, tree.getDescription());
1024         return scan(tree.getDescription(), ignore);
1025     }
1026 
1027     private boolean isThrowable(TypeMirror tm) {
1028         switch (tm.getKind()) {
1029             case DECLARED:
1030             case TYPEVAR:
1031                 return env.types.isAssignable(tm, env.java_lang_Throwable);
1032         }
1033         return false;
1034     }
1035 
1036     private void checkThrowsDeclared(ReferenceTree tree, TypeMirror t, List&lt;? extends TypeMirror&gt; list) {
1037         boolean found = false;
1038         for (TypeMirror tl : list) {
1039             if (env.types.isAssignable(t, tl)) {
1040                 foundThrows.add(tl);
1041                 found = true;
1042             }
1043         }
1044         if (!found)
1045             env.messages.error(REFERENCE, tree, &quot;dc.exception.not.thrown&quot;, t);
1046     }
1047 
1048     private void checkThrowsDocumented(List&lt;? extends TypeMirror&gt; list) {
1049         if (foundInheritDoc)
1050             return;
1051 
1052         for (TypeMirror tl: list) {
1053             if (isCheckedException(tl) &amp;&amp; !foundThrows.contains(tl))
1054                 reportMissing(&quot;dc.missing.throws&quot;, tl);
1055         }
1056     }
1057 
1058     @Override @DefinedBy(Api.COMPILER_TREE)
1059     public Void visitUnknownBlockTag(UnknownBlockTagTree tree, Void ignore) {
1060         checkUnknownTag(tree, tree.getTagName());
1061         return super.visitUnknownBlockTag(tree, ignore);
1062     }
1063 
1064     @Override @DefinedBy(Api.COMPILER_TREE)
1065     public Void visitUnknownInlineTag(UnknownInlineTagTree tree, Void ignore) {
1066         markEnclosingTag(Flag.HAS_INLINE_TAG);
1067         checkUnknownTag(tree, tree.getTagName());
1068         return super.visitUnknownInlineTag(tree, ignore);
1069     }
1070 
1071     private void checkUnknownTag(DocTree tree, String tagName) {
1072         if (env.customTags != null &amp;&amp; !env.customTags.contains(tagName))
1073             env.messages.error(SYNTAX, tree, &quot;dc.tag.unknown&quot;, tagName);
1074     }
1075 
1076     @Override @DefinedBy(Api.COMPILER_TREE)
1077     public Void visitUses(UsesTree tree, Void ignore) {
1078         Element e = env.trees.getElement(env.currPath);
1079         if (e.getKind() != ElementKind.MODULE) {
1080             env.messages.error(REFERENCE, tree, &quot;dc.invalid.uses&quot;);
1081         }
1082         ReferenceTree serviceType = tree.getServiceType();
1083         Element se = env.trees.getElement(new DocTreePath(getCurrentPath(), serviceType));
1084         if (se == null) {
1085             env.messages.error(REFERENCE, tree, &quot;dc.service.not.found&quot;);
1086         }
1087         return super.visitUses(tree, ignore);
1088     }
1089 
1090     @Override @DefinedBy(Api.COMPILER_TREE)
1091     public Void visitValue(ValueTree tree, Void ignore) {
1092         ReferenceTree ref = tree.getReference();
1093         if (ref == null || ref.getSignature().isEmpty()) {
1094             if (!isConstant(env.currElement))
1095                 env.messages.error(REFERENCE, tree, &quot;dc.value.not.allowed.here&quot;);
1096         } else {
1097             Element e = env.trees.getElement(new DocTreePath(getCurrentPath(), ref));
1098             if (!isConstant(e))
1099                 env.messages.error(REFERENCE, tree, &quot;dc.value.not.a.constant&quot;);
1100         }
1101 
1102         markEnclosingTag(Flag.HAS_INLINE_TAG);
1103         return super.visitValue(tree, ignore);
1104     }
1105 
1106     private boolean isConstant(Element e) {
1107         if (e == null)
1108             return false;
1109 
1110         switch (e.getKind()) {
1111             case FIELD:
1112                 Object value = ((VariableElement) e).getConstantValue();
1113                 return (value != null); // can&#39;t distinguish &quot;not a constant&quot; from &quot;constant is null&quot;
1114             default:
1115                 return false;
1116         }
1117     }
1118 
1119     @Override @DefinedBy(Api.COMPILER_TREE)
1120     public Void visitVersion(VersionTree tree, Void ignore) {
1121         warnIfEmpty(tree, tree.getBody());
1122         return super.visitVersion(tree, ignore);
1123     }
1124 
1125     @Override @DefinedBy(Api.COMPILER_TREE)
1126     public Void visitErroneous(ErroneousTree tree, Void ignore) {
1127         env.messages.error(SYNTAX, tree, null, tree.getDiagnostic().getMessage(null));
1128         return null;
1129     }
1130     // &lt;/editor-fold&gt;
1131 
1132     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Utility methods&quot;&gt;
1133 
1134     private boolean isCheckedException(TypeMirror t) {
1135         return !(env.types.isAssignable(t, env.java_lang_Error)
1136                 || env.types.isAssignable(t, env.java_lang_RuntimeException));
1137     }
1138 
1139     private boolean isSynthetic() {
1140         switch (env.currElement.getKind()) {
1141             case CONSTRUCTOR:
1142                 // A synthetic default constructor has the same pos as the
1143                 // enclosing class
1144             case METHOD:
1145                 // Ditto for a synthetic method injected by the compiler (for value types)
1146                 TreePath p = env.currPath;
1147                 return env.getPos(p) == env.getPos(p.getParentPath());
1148         }
1149         return false;
1150     }
1151 
1152     void markEnclosingTag(Flag flag) {
1153         TagStackItem top = tagStack.peek();
1154         if (top != null)
1155             top.flags.add(flag);
1156     }
1157 
1158     String toString(TreePath p) {
1159         StringBuilder sb = new StringBuilder(&quot;TreePath[&quot;);
1160         toString(p, sb);
1161         sb.append(&quot;]&quot;);
1162         return sb.toString();
1163     }
1164 
1165     void toString(TreePath p, StringBuilder sb) {
1166         TreePath parent = p.getParentPath();
1167         if (parent != null) {
1168             toString(parent, sb);
1169             sb.append(&quot;,&quot;);
1170         }
1171        sb.append(p.getLeaf().getKind()).append(&quot;:&quot;).append(env.getPos(p)).append(&quot;:S&quot;).append(env.getStartPos(p));
1172     }
1173 
1174     void warnIfEmpty(DocTree tree, List&lt;? extends DocTree&gt; list) {
1175         for (DocTree d: list) {
1176             switch (d.getKind()) {
1177                 case TEXT:
1178                     if (hasNonWhitespace((TextTree) d))
1179                         return;
1180                     break;
1181                 default:
1182                     return;
1183             }
1184         }
1185         env.messages.warning(MISSING, tree, &quot;dc.empty&quot;, tree.getKind().tagName);
1186     }
1187 
1188     boolean hasNonWhitespace(TextTree tree) {
1189         String s = tree.getBody();
1190         for (int i = 0; i &lt; s.length(); i++) {
1191             Character c = s.charAt(i);
1192             if (!Character.isWhitespace(s.charAt(i)))
1193                 return true;
1194         }
1195         return false;
1196     }
1197 
1198     // &lt;/editor-fold&gt;
1199 
1200 }
    </pre>
  </body>
</html>