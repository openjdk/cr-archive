<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import java.util.function.IntFunction;
  40 
  41 import javax.lang.model.element.Modifier;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.tools.JavaFileManager;
  44 import javax.tools.JavaFileObject;
  45 
  46 import com.sun.tools.javac.code.Source.Feature;
  47 import com.sun.tools.javac.comp.Annotate;
  48 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  49 import com.sun.tools.javac.code.*;
  50 import com.sun.tools.javac.code.Directive.*;
  51 import com.sun.tools.javac.code.Lint.LintCategory;
  52 import com.sun.tools.javac.code.Scope.WriteableScope;
  53 import com.sun.tools.javac.code.Symbol.*;
  54 import com.sun.tools.javac.code.Symtab;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  57 import com.sun.tools.javac.file.BaseFileManager;
  58 import com.sun.tools.javac.file.PathFileObject;
  59 import com.sun.tools.javac.jvm.ClassFile.Version;
  60 import com.sun.tools.javac.jvm.PoolConstant.NameAndType;
  61 import com.sun.tools.javac.main.Option;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  64 import com.sun.tools.javac.util.*;
  65 import com.sun.tools.javac.util.DefinedBy.Api;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 import static com.sun.tools.javac.code.Flags.*;
  69 import static com.sun.tools.javac.code.Kinds.Kind.*;
  70 
  71 import com.sun.tools.javac.code.Scope.LookupKind;
  72 
  73 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  74 import static com.sun.tools.javac.code.TypeTag.CLASS;
  75 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  76 import static com.sun.tools.javac.jvm.ClassFile.*;
  77 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  78 
  79 import static com.sun.tools.javac.main.Option.PARAMETERS;
  80 
  81 /** This class provides operations to read a classfile into an internal
  82  *  representation. The internal representation is anchored in a
  83  *  ClassSymbol which contains in its scope symbol representations
  84  *  for all other definitions in the classfile. Top-level Classes themselves
  85  *  appear as members of the scopes of PackageSymbols.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
 108     /** Switch: allow sealed
 109      */
 110     boolean allowSealedTypes;
 111 
 112     /** Switch: allow records
 113      */
 114     boolean allowRecords;
 115 
 116    /** Lint option: warn about classfile issues
 117      */
 118     boolean lintClassfile;
 119 
 120     /** Switch: preserve parameter names from the variable table.
 121      */
 122     public boolean saveParameterNames;
 123 
 124     /**
 125      * The currently selected profile.
 126      */
 127     public final Profile profile;
 128 
 129     /** The log to use for verbose output
 130      */
 131     final Log log;
 132 
 133     /** The symbol table. */
 134     Symtab syms;
 135 
 136     Types types;
 137 
 138     /** The name table. */
 139     final Names names;
 140 
 141     /** Access to files
 142      */
 143     private final JavaFileManager fileManager;
 144 
 145     /** Factory for diagnostics
 146      */
 147     JCDiagnostic.Factory diagFactory;
 148 
 149     DeferredCompletionFailureHandler dcfh;
 150 
 151     /**
 152      * Support for preview language features.
 153      */
 154     Preview preview;
 155 
 156     /** The current scope where type variables are entered.
 157      */
 158     protected WriteableScope typevars;
 159 
 160     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 161     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 162 
 163     /** The path name of the class file currently being read.
 164      */
 165     protected JavaFileObject currentClassFile = null;
 166 
 167     /** The class or method currently being read.
 168      */
 169     protected Symbol currentOwner = null;
 170 
 171     /** The module containing the class currently being read.
 172      */
 173     protected ModuleSymbol currentModule = null;
 174 
 175     /** The buffer containing the currently read class file.
 176      */
 177     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);
 178 
 179     /** The current input pointer.
 180      */
 181     protected int bp;
 182 
 183     /** The pool reader.
 184      */
 185     PoolReader poolReader;
 186 
 187     /** The major version number of the class file being read. */
 188     int majorVersion;
 189     /** The minor version number of the class file being read. */
 190     int minorVersion;
 191 
 192     /** A table to hold the constant pool indices for method parameter
 193      * names, as given in LocalVariableTable attributes.
 194      */
 195     int[] parameterNameIndices;
 196 
 197     /**
 198      * A table to hold annotations for method parameters.
 199      */
 200     ParameterAnnotations[] parameterAnnotations;
 201 
 202     /**
 203      * A holder for parameter annotations.
 204      */
 205     static class ParameterAnnotations {
 206         List&lt;CompoundAnnotationProxy&gt; proxies;
 207 
 208         void add(List&lt;CompoundAnnotationProxy&gt; newAnnotations) {
 209             if (proxies == null) {
 210                 proxies = newAnnotations;
 211             } else {
 212                 proxies = proxies.prependList(newAnnotations);
 213             }
 214         }
 215     }
 216 
 217     /**
 218      * Whether or not any parameter names have been found.
 219      */
 220     boolean haveParameterNameIndices;
 221 
 222     /** Set this to false every time we start reading a method
 223      * and are saving parameter names.  Set it to true when we see
 224      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 225      * then we ignore the parameter names from the LVT.
 226      */
 227     boolean sawMethodParameters;
 228 
 229     /**
 230      * The set of attribute names for which warnings have been generated for the current class
 231      */
 232     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 233 
 234     /**
 235      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 236      * @Target
 237      */
 238     CompoundAnnotationProxy target;
 239 
 240     /**
 241      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with
 242      * @Repeatable
 243      */
 244     CompoundAnnotationProxy repeatable;
 245 
 246     /** Get the ClassReader instance for this invocation. */
 247     public static ClassReader instance(Context context) {
 248         ClassReader instance = context.get(classReaderKey);
 249         if (instance == null)
 250             instance = new ClassReader(context);
 251         return instance;
 252     }
 253 
 254     /** Construct a new class reader. */
 255     protected ClassReader(Context context) {
 256         context.put(classReaderKey, this);
 257         annotate = Annotate.instance(context);
 258         names = Names.instance(context);
 259         syms = Symtab.instance(context);
 260         types = Types.instance(context);
 261         fileManager = context.get(JavaFileManager.class);
 262         if (fileManager == null)
 263             throw new AssertionError(&quot;FileManager initialization error&quot;);
 264         diagFactory = JCDiagnostic.Factory.instance(context);
 265         dcfh = DeferredCompletionFailureHandler.instance(context);
 266 
 267         log = Log.instance(context);
 268 
 269         Options options = Options.instance(context);
 270         verbose         = options.isSet(Option.VERBOSE);
 271 
 272         Source source = Source.instance(context);
 273         preview = Preview.instance(context);
 274         allowModules     = Feature.MODULES.allowedInSource(source);
 275         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 276                 Feature.RECORDS.allowedInSource(source);
 277         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 278                 Feature.SEALED_CLASSES.allowedInSource(source);
 279 
 280         saveParameterNames = options.isSet(PARAMETERS);
 281 
 282         profile = Profile.instance(context);
 283 
 284         typevars = WriteableScope.create(syms.noSymbol);
 285 
 286         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 287 
 288         initAttributeReaders();
 289     }
 290 
 291     /** Add member to class unless it is synthetic.
 292      */
 293     private void enterMember(ClassSymbol c, Symbol sym) {
 294         // Synthetic members are not entered -- reason lost to history (optimization?).
 295         // Lambda methods must be entered because they may have inner classes (which reference them)
 296         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 297             c.members_field.enter(sym);
 298     }
 299 
 300 /************************************************************************
 301  * Error Diagnoses
 302  ***********************************************************************/
 303 
 304     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 305         return new ClassFinder.BadClassFile (
 306             currentOwner.enclClass(),
 307             currentClassFile,
 308             diagFactory.fragment(key, args),
 309             diagFactory,
 310             dcfh);
 311     }
 312 
 313     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 314         return new ClassFinder.BadEnclosingMethodAttr (
 315             currentOwner.enclClass(),
 316             currentClassFile,
 317             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 318             diagFactory,
 319             dcfh);
 320     }
 321 
 322 /************************************************************************
 323  * Buffer Access
 324  ***********************************************************************/
 325 
 326     /** Read a character.
 327      */
 328     char nextChar() {
 329         char res = buf.getChar(bp);
 330         bp += 2;
 331         return res;
 332     }
 333 
 334     /** Read a byte.
 335      */
 336     int nextByte() {
 337         return buf.getByte(bp++) &amp; 0xFF;
 338     }
 339 
 340     /** Read an integer.
 341      */
 342     int nextInt() {
 343         int res = buf.getInt(bp);
 344         bp += 4;
 345         return res;
 346     }
 347 
 348 /************************************************************************
 349  * Constant Pool Access
 350  ***********************************************************************/
 351 
 352     /** Read module_flags.
 353      */
 354     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 355         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 356         for (ModuleFlags f : ModuleFlags.values()) {
 357             if ((flags &amp; f.value) != 0)
 358                 set.add(f);
 359         }
 360         return set;
 361     }
 362 
 363     /** Read resolution_flags.
 364      */
 365     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 366         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 367         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 368             if ((flags &amp; f.value) != 0)
 369                 set.add(f);
 370         }
 371         return set;
 372     }
 373 
 374     /** Read exports_flags.
 375      */
 376     Set&lt;ExportsFlag&gt; readExportsFlags(int flags) {
 377         Set&lt;ExportsFlag&gt; set = EnumSet.noneOf(ExportsFlag.class);
 378         for (ExportsFlag f: ExportsFlag.values()) {
 379             if ((flags &amp; f.value) != 0)
 380                 set.add(f);
 381         }
 382         return set;
 383     }
 384 
 385     /** Read opens_flags.
 386      */
 387     Set&lt;OpensFlag&gt; readOpensFlags(int flags) {
 388         Set&lt;OpensFlag&gt; set = EnumSet.noneOf(OpensFlag.class);
 389         for (OpensFlag f: OpensFlag.values()) {
 390             if ((flags &amp; f.value) != 0)
 391                 set.add(f);
 392         }
 393         return set;
 394     }
 395 
 396     /** Read requires_flags.
 397      */
 398     Set&lt;RequiresFlag&gt; readRequiresFlags(int flags) {
 399         Set&lt;RequiresFlag&gt; set = EnumSet.noneOf(RequiresFlag.class);
 400         for (RequiresFlag f: RequiresFlag.values()) {
 401             if ((flags &amp; f.value) != 0)
 402                 set.add(f);
 403         }
 404         return set;
 405     }
 406 
 407 /************************************************************************
 408  * Reading Types
 409  ***********************************************************************/
 410 
 411     /** The unread portion of the currently read type is
 412      *  signature[sigp..siglimit-1].
 413      */
 414     byte[] signature;
 415     int sigp;
 416     int siglimit;
 417     boolean sigEnterPhase = false;
 418 
 419     /** Convert signature to type, where signature is a byte array segment.
 420      */
 421     Type sigToType(byte[] sig, int offset, int len) {
 422         signature = sig;
 423         sigp = offset;
 424         siglimit = offset + len;
 425         return sigToType();
 426     }
 427 
 428     /** Convert signature to type, where signature is implicit.
 429      */
 430     Type sigToType() {
 431         switch ((char) signature[sigp]) {
 432         case &#39;T&#39;:
 433             sigp++;
 434             int start = sigp;
 435             while (signature[sigp] != &#39;;&#39;) sigp++;
 436             sigp++;
 437             return sigEnterPhase
 438                 ? Type.noType
 439                 : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));
 440         case &#39;+&#39;: {
 441             sigp++;
 442             Type t = sigToType();
 443             return new WildcardType(t, BoundKind.EXTENDS, syms.boundClass);
 444         }
 445         case &#39;*&#39;:
 446             sigp++;
 447             return new WildcardType(syms.objectType, BoundKind.UNBOUND,
 448                                     syms.boundClass);
 449         case &#39;-&#39;: {
 450             sigp++;
 451             Type t = sigToType();
 452             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 453         }
 454         case &#39;B&#39;:
 455             sigp++;
 456             return syms.byteType;
 457         case &#39;C&#39;:
 458             sigp++;
 459             return syms.charType;
 460         case &#39;D&#39;:
 461             sigp++;
 462             return syms.doubleType;
 463         case &#39;F&#39;:
 464             sigp++;
 465             return syms.floatType;
 466         case &#39;I&#39;:
 467             sigp++;
 468             return syms.intType;
 469         case &#39;J&#39;:
 470             sigp++;
 471             return syms.longType;
 472         case &#39;L&#39;:
 473             {
 474                 // int oldsigp = sigp;
 475                 Type t = classSigToType();
 476                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 477                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 478                                        &quot;(please recompile from source)&quot;);
 479                 /*
 480                 System.err.println(&quot; decoded &quot; +
 481                                    new String(signature, oldsigp, sigp-oldsigp) +
 482                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 483                 */
 484                 return t;
 485             }
 486         case &#39;S&#39;:
 487             sigp++;
 488             return syms.shortType;
 489         case &#39;V&#39;:
 490             sigp++;
 491             return syms.voidType;
 492         case &#39;Z&#39;:
 493             sigp++;
 494             return syms.booleanType;
 495         case &#39;[&#39;:
 496             sigp++;
 497             return new ArrayType(sigToType(), syms.arrayClass);
 498         case &#39;(&#39;:
 499             sigp++;
 500             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 501             Type restype = sigToType();
 502             List&lt;Type&gt; thrown = List.nil();
 503             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {
 504                 sigp++;
 505                 thrown = thrown.prepend(sigToType());
 506             }
 507             // if there is a typevar in the throws clause we should state it.
 508             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 509                 if (l.head.hasTag(TYPEVAR)) {
 510                     l.head.tsym.flags_field |= THROWS;
 511                 }
 512             }
 513             return new MethodType(argtypes,
 514                                   restype,
 515                                   thrown.reverse(),
 516                                   syms.methodClass);
 517         case &#39;&lt;&#39;:
 518             typevars = typevars.dup(currentOwner);
 519             Type poly = new ForAll(sigToTypeParams(), sigToType());
 520             typevars = typevars.leave();
 521             return poly;
 522         default:
 523             throw badClassFile(&quot;bad.signature&quot;,
 524                                Convert.utf2string(signature, sigp, 10));
 525         }
 526     }
 527 
 528     byte[] signatureBuffer = new byte[0];
 529     int sbp = 0;
 530     /** Convert class signature to type, where signature is implicit.
 531      */
 532     Type classSigToType() {
 533         if (signature[sigp] != &#39;L&#39;)
 534             throw badClassFile(&quot;bad.class.signature&quot;,
 535                                Convert.utf2string(signature, sigp, 10));
 536         sigp++;
 537         Type outer = Type.noType;
 538         int startSbp = sbp;
 539 
 540         while (true) {
 541             final byte c = signature[sigp++];
 542             switch (c) {
 543 
 544             case &#39;;&#39;: {         // end
 545                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 546                                                          startSbp,
 547                                                          sbp - startSbp));
 548 
 549                 try {
 550                     return (outer == Type.noType) ?
 551                             t.erasure(types) :
 552                         new ClassType(outer, List.nil(), t);
 553                 } finally {
 554                     sbp = startSbp;
 555                 }
 556             }
 557 
 558             case &#39;&lt;&#39;:           // generic arguments
 559                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 560                                                          startSbp,
 561                                                          sbp - startSbp));
 562                 outer = new ClassType(outer, sigToTypes(&#39;&gt;&#39;), t) {
 563                         boolean completed = false;
 564                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 565                         public Type getEnclosingType() {
 566                             if (!completed) {
 567                                 completed = true;
 568                                 tsym.complete();
 569                                 Type enclosingType = tsym.type.getEnclosingType();
 570                                 if (enclosingType != Type.noType) {
 571                                     List&lt;Type&gt; typeArgs =
 572                                         super.getEnclosingType().allparams();
 573                                     List&lt;Type&gt; typeParams =
 574                                         enclosingType.allparams();
 575                                     if (typeParams.length() != typeArgs.length()) {
 576                                         // no &quot;rare&quot; types
 577                                         super.setEnclosingType(types.erasure(enclosingType));
 578                                     } else {
 579                                         super.setEnclosingType(types.subst(enclosingType,
 580                                                                            typeParams,
 581                                                                            typeArgs));
 582                                     }
 583                                 } else {
 584                                     super.setEnclosingType(Type.noType);
 585                                 }
 586                             }
 587                             return super.getEnclosingType();
 588                         }
 589                         @Override
 590                         public void setEnclosingType(Type outer) {
 591                             throw new UnsupportedOperationException();
 592                         }
 593                     };
 594                 switch (signature[sigp++]) {
 595                 case &#39;;&#39;:
 596                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {
 597                         // support old-style GJC signatures
 598                         // The signature produced was
 599                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 600                         // rather than say
 601                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 602                         // so we skip past &quot;.Lfoo/Outer$&quot;
 603                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 604                             3;  // &quot;.L&quot; and &quot;$&quot;
 605                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 606                         break;
 607                     } else {
 608                         sbp = startSbp;
 609                         return outer;
 610                     }
 611                 case &#39;.&#39;:
 612                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 613                     break;
 614                 default:
 615                     throw new AssertionError(signature[sigp-1]);
 616                 }
 617                 continue;
 618 
 619             case &#39;.&#39;:
 620                 //we have seen an enclosing non-generic class
 621                 if (outer != Type.noType) {
 622                     t = enterClass(names.fromUtf(signatureBuffer,
 623                                                  startSbp,
 624                                                  sbp - startSbp));
 625                     outer = new ClassType(outer, List.nil(), t);
 626                 }
 627                 signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 628                 continue;
 629             case &#39;/&#39;:
 630                 signatureBuffer[sbp++] = (byte)&#39;.&#39;;
 631                 continue;
 632             default:
 633                 signatureBuffer[sbp++] = c;
 634                 continue;
 635             }
 636         }
 637     }
 638 
 639     /** Convert (implicit) signature to list of types
 640      *  until `terminator&#39; is encountered.
 641      */
 642     List&lt;Type&gt; sigToTypes(char terminator) {
 643         List&lt;Type&gt; head = List.of(null);
 644         List&lt;Type&gt; tail = head;
 645         while (signature[sigp] != terminator)
 646             tail = tail.setTail(List.of(sigToType()));
 647         sigp++;
 648         return head.tail;
 649     }
 650 
 651     /** Convert signature to type parameters, where signature is a byte
 652      *  array segment.
 653      */
 654     List&lt;Type&gt; sigToTypeParams(byte[] sig, int offset, int len) {
 655         signature = sig;
 656         sigp = offset;
 657         siglimit = offset + len;
 658         return sigToTypeParams();
 659     }
 660 
 661     /** Convert signature to type parameters, where signature is implicit.
 662      */
 663     List&lt;Type&gt; sigToTypeParams() {
 664         List&lt;Type&gt; tvars = List.nil();
 665         if (signature[sigp] == &#39;&lt;&#39;) {
 666             sigp++;
 667             int start = sigp;
 668             sigEnterPhase = true;
 669             while (signature[sigp] != &#39;&gt;&#39;)
 670                 tvars = tvars.prepend(sigToTypeParam());
 671             sigEnterPhase = false;
 672             sigp = start;
 673             while (signature[sigp] != &#39;&gt;&#39;)
 674                 sigToTypeParam();
 675             sigp++;
 676         }
 677         return tvars.reverse();
 678     }
 679 
 680     /** Convert (implicit) signature to type parameter.
 681      */
 682     Type sigToTypeParam() {
 683         int start = sigp;
 684         while (signature[sigp] != &#39;:&#39;) sigp++;
 685         Name name = names.fromUtf(signature, start, sigp - start);
 686         TypeVar tvar;
 687         if (sigEnterPhase) {
 688             tvar = new TypeVar(name, currentOwner, syms.botType);
 689             typevars.enter(tvar.tsym);
 690         } else {
 691             tvar = (TypeVar)findTypeVar(name);
 692         }
 693         List&lt;Type&gt; bounds = List.nil();
 694         boolean allInterfaces = false;
 695         if (signature[sigp] == &#39;:&#39; &amp;&amp; signature[sigp+1] == &#39;:&#39;) {
 696             sigp++;
 697             allInterfaces = true;
 698         }
 699         while (signature[sigp] == &#39;:&#39;) {
 700             sigp++;
 701             bounds = bounds.prepend(sigToType());
 702         }
 703         if (!sigEnterPhase) {
 704             types.setBounds(tvar, bounds.reverse(), allInterfaces);
 705         }
 706         return tvar;
 707     }
 708 
 709     /** Find type variable with given name in `typevars&#39; scope.
 710      */
 711     Type findTypeVar(Name name) {
 712         Symbol s = typevars.findFirst(name);
 713         if (s != null) {
 714             return s.type;
 715         } else {
 716             if (readingClassAttr) {
 717                 // While reading the class attribute, the supertypes
 718                 // might refer to a type variable from an enclosing element
 719                 // (method or class).
 720                 // If the type variable is defined in the enclosing class,
 721                 // we can actually find it in
 722                 // currentOwner.owner.type.getTypeArguments()
 723                 // However, until we have read the enclosing method attribute
 724                 // we don&#39;t know for sure if this owner is correct.  It could
 725                 // be a method and there is no way to tell before reading the
 726                 // enclosing method attribute.
 727                 TypeVar t = new TypeVar(name, currentOwner, syms.botType);
 728                 missingTypeVariables = missingTypeVariables.prepend(t);
 729                 // System.err.println(&quot;Missing type var &quot; + name);
 730                 return t;
 731             }
 732             throw badClassFile(&quot;undecl.type.var&quot;, name);
 733         }
 734     }
 735 
 736 /************************************************************************
 737  * Reading Attributes
 738  ***********************************************************************/
 739 
 740     protected enum AttributeKind { CLASS, MEMBER }
 741 
 742     protected abstract class AttributeReader {
 743         protected AttributeReader(Name name, ClassFile.Version version, Set&lt;AttributeKind&gt; kinds) {
 744             this.name = name;
 745             this.version = version;
 746             this.kinds = kinds;
 747         }
 748 
 749         protected boolean accepts(AttributeKind kind) {
 750             if (kinds.contains(kind)) {
 751                 if (majorVersion &gt; version.major || (majorVersion == version.major &amp;&amp; minorVersion &gt;= version.minor))
 752                     return true;
 753 
 754                 if (lintClassfile &amp;&amp; !warnedAttrs.contains(name)) {
 755                     JavaFileObject prev = log.useSource(currentClassFile);
 756                     try {
 757                         log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,
 758                                     Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));
 759                     } finally {
 760                         log.useSource(prev);
 761                     }
 762                     warnedAttrs.add(name);
 763                 }
 764             }
 765             return false;
 766         }
 767 
 768         protected abstract void read(Symbol sym, int attrLen);
 769 
 770         protected final Name name;
 771         protected final ClassFile.Version version;
 772         protected final Set&lt;AttributeKind&gt; kinds;
 773     }
 774 
 775     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 776             EnumSet.of(AttributeKind.CLASS);
 777     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 778             EnumSet.of(AttributeKind.MEMBER);
 779     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 780             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 781 
 782     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 783 
 784     private void initAttributeReaders() {
 785         AttributeReader[] readers = {
 786             // v45.3 attributes
 787 
 788             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 789                 protected void read(Symbol sym, int attrLen) {
 790                     if (saveParameterNames)
 791                         ((MethodSymbol)sym).code = readCode(sym);
 792                     else
 793                         bp = bp + attrLen;
 794                 }
 795             },
 796 
 797             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 798                 protected void read(Symbol sym, int attrLen) {
 799                     Object v = poolReader.getConstant(nextChar());
 800                     // Ignore ConstantValue attribute if field not final.
 801                     if ((sym.flags() &amp; FINAL) == 0) {
 802                         return;
 803                     }
 804                     VarSymbol var = (VarSymbol) sym;
 805                     switch (var.type.getTag()) {
 806                        case BOOLEAN:
 807                        case BYTE:
 808                        case CHAR:
 809                        case SHORT:
 810                        case INT:
 811                            checkType(var, Integer.class, v);
 812                            break;
 813                        case LONG:
 814                            checkType(var, Long.class, v);
 815                            break;
 816                        case FLOAT:
 817                            checkType(var, Float.class, v);
 818                            break;
 819                        case DOUBLE:
 820                            checkType(var, Double.class, v);
 821                            break;
 822                        case CLASS:
 823                            if (var.type.tsym == syms.stringType.tsym) {
 824                                checkType(var, String.class, v);
 825                            } else {
 826                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);
 827                            }
 828                            break;
 829                        default:
 830                            // ignore ConstantValue attribute if type is not primitive or String
 831                            return;
 832                     }
 833                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
 834                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
 835                     }
 836                     var.setData(v);
 837                 }
 838 
 839                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
 840                     if (!clazz.isInstance(value)) {
 841                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
 842                     }
 843                 }
 844             },
 845 
 846             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 847                 protected void read(Symbol sym, int attrLen) {
 848                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
 849 
 850                     s.flags_field |= DEPRECATED;
 851                 }
 852             },
 853 
 854             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 855                 protected void read(Symbol sym, int attrLen) {
 856                     int nexceptions = nextChar();
 857                     List&lt;Type&gt; thrown = List.nil();
 858                     for (int j = 0; j &lt; nexceptions; j++)
 859                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);
 860                     if (sym.type.getThrownTypes().isEmpty())
 861                         sym.type.asMethodType().thrown = thrown.reverse();
 862                 }
 863             },
 864 
 865             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
 866                 protected void read(Symbol sym, int attrLen) {
 867                     ClassSymbol c = (ClassSymbol) sym;
 868                     if (currentModule.module_info == c) {
 869                         //prevent entering the classes too soon:
 870                         skipInnerClasses();
 871                     } else {
 872                         readInnerClasses(c);
 873                     }
 874                 }
 875             },
 876 
 877             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 878                 protected void read(Symbol sym, int attrLen) {
 879                     int newbp = bp + attrLen;
 880                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
 881                         // Pick up parameter names from the variable table.
 882                         // Parameter names are not explicitly identified as such,
 883                         // but all parameter name entries in the LocalVariableTable
 884                         // have a start_pc of 0.  Therefore, we record the name
 885                         // indices of all slots with a start_pc of zero in the
 886                         // parameterNameIndices array.
 887                         // Note that this implicitly honors the JVMS spec that
 888                         // there may be more than one LocalVariableTable, and that
 889                         // there is no specified ordering for the entries.
 890                         int numEntries = nextChar();
 891                         for (int i = 0; i &lt; numEntries; i++) {
 892                             int start_pc = nextChar();
 893                             int length = nextChar();
 894                             int nameIndex = nextChar();
 895                             int sigIndex = nextChar();
 896                             int register = nextChar();
 897                             if (start_pc == 0) {
 898                                 // ensure array large enough
 899                                 if (register &gt;= parameterNameIndices.length) {
 900                                     int newSize =
 901                                             Math.max(register + 1, parameterNameIndices.length + 8);
 902                                     parameterNameIndices =
 903                                             Arrays.copyOf(parameterNameIndices, newSize);
 904                                 }
 905                                 parameterNameIndices[register] = nameIndex;
 906                                 haveParameterNameIndices = true;
 907                             }
 908                         }
 909                     }
 910                     bp = newbp;
 911                 }
 912             },
 913 
 914             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
 915                 protected void read(Symbol sym, int attrLen) {
 916                     ClassSymbol c = (ClassSymbol) sym;
 917                     Name n = poolReader.getName(nextChar());
 918                     c.sourcefile = new SourceFileObject(n);
 919                     // If the class is a toplevel class, originating from a Java source file,
 920                     // but the class name does not match the file name, then it is
 921                     // an auxiliary class.
 922                     String sn = n.toString();
 923                     if (c.owner.kind == PCK &amp;&amp;
 924                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
 925                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
 926                         c.flags_field |= AUXILIARY;
 927                     }
 928                 }
 929             },
 930 
 931             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 932                 protected void read(Symbol sym, int attrLen) {
 933                     sym.flags_field |= SYNTHETIC;
 934                 }
 935             },
 936 
 937             // standard v49 attributes
 938 
 939             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
 940                 protected void read(Symbol sym, int attrLen) {
 941                     int newbp = bp + attrLen;
 942                     readEnclosingMethodAttr(sym);
 943                     bp = newbp;
 944                 }
 945             },
 946 
 947             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 948                 protected void read(Symbol sym, int attrLen) {
 949                     if (sym.kind == TYP) {
 950                         ClassSymbol c = (ClassSymbol) sym;
 951                         readingClassAttr = true;
 952                         try {
 953                             ClassType ct1 = (ClassType)c.type;
 954                             Assert.check(c == currentOwner);
 955                             ct1.typarams_field = poolReader.getName(nextChar())
 956                                     .map(ClassReader.this::sigToTypeParams);
 957                             ct1.supertype_field = sigToType();
 958                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
 959                             while (sigp != siglimit) is.append(sigToType());
 960                             ct1.interfaces_field = is.toList();
 961                         } finally {
 962                             readingClassAttr = false;
 963                         }
 964                     } else {
 965                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
 966                         sym.type = poolReader.getType(nextChar());
 967                         //- System.err.println(&quot; # &quot; + sym.type);
 968                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
 969                             sym.type.asMethodType().thrown = thrown;
 970 
 971                     }
 972                 }
 973             },
 974 
 975             // v49 annotation attributes
 976 
 977             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 978                 protected void read(Symbol sym, int attrLen) {
 979                     attachAnnotationDefault(sym);
 980                 }
 981             },
 982 
 983             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 984                 protected void read(Symbol sym, int attrLen) {
 985                     attachAnnotations(sym);
 986                 }
 987             },
 988 
 989             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 990                 protected void read(Symbol sym, int attrLen) {
 991                     readParameterAnnotations(sym);
 992                 }
 993             },
 994 
 995             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 996                 protected void read(Symbol sym, int attrLen) {
 997                     attachAnnotations(sym);
 998                 }
 999             },
1000 
1001             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1002                 protected void read(Symbol sym, int attrLen) {
1003                     readParameterAnnotations(sym);
1004                 }
1005             },
1006 
1007             // additional &quot;legacy&quot; v49 attributes, superseded by flags
1008 
1009             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1010                 protected void read(Symbol sym, int attrLen) {
1011                     sym.flags_field |= ANNOTATION;
1012                 }
1013             },
1014 
1015             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1016                 protected void read(Symbol sym, int attrLen) {
1017                     sym.flags_field |= BRIDGE;
1018                 }
1019             },
1020 
1021             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1022                 protected void read(Symbol sym, int attrLen) {
1023                     sym.flags_field |= ENUM;
1024                 }
1025             },
1026 
1027             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1028                 protected void read(Symbol sym, int attrLen) {
1029                     sym.flags_field |= VARARGS;
1030                 }
1031             },
1032 
1033             new AttributeReader(names.RuntimeVisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1034                 protected void read(Symbol sym, int attrLen) {
1035                     attachTypeAnnotations(sym);
1036                 }
1037             },
1038 
1039             new AttributeReader(names.RuntimeInvisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1040                 protected void read(Symbol sym, int attrLen) {
1041                     attachTypeAnnotations(sym);
1042                 }
1043             },
1044 
1045             // The following attributes for a Code attribute are not currently handled
1046             // StackMapTable
1047             // SourceDebugExtension
1048             // LineNumberTable
1049             // LocalVariableTypeTable
1050 
1051             // standard v52 attributes
1052 
1053             new AttributeReader(names.MethodParameters, V52, MEMBER_ATTRIBUTE) {
1054                 protected void read(Symbol sym, int attrlen) {
1055                     int newbp = bp + attrlen;
1056                     if (saveParameterNames) {
1057                         sawMethodParameters = true;
1058                         int numEntries = nextByte();
1059                         parameterNameIndices = new int[numEntries];
1060                         haveParameterNameIndices = true;
1061                         int index = 0;
1062                         for (int i = 0; i &lt; numEntries; i++) {
1063                             int nameIndex = nextChar();
1064                             int flags = nextChar();
1065                             if ((flags &amp; (Flags.MANDATED | Flags.SYNTHETIC)) != 0) {
1066                                 continue;
1067                             }
1068                             parameterNameIndices[index++] = nameIndex;
1069                         }
1070                     }
1071                     bp = newbp;
1072                 }
1073             },
1074 
1075             // standard v53 attributes
1076 
1077             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1078                 @Override
1079                 protected boolean accepts(AttributeKind kind) {
1080                     return super.accepts(kind) &amp;&amp; allowModules;
1081                 }
1082                 protected void read(Symbol sym, int attrLen) {
1083                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1084                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1085                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1086 
1087                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);
1088                         if (currentModule.name != moduleName) {
1089                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1090                         }
1091 
1092                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1093                         msym.flags.addAll(moduleFlags);
1094                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);
1095 
1096                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1097                         int nrequires = nextChar();
1098                         for (int i = 0; i &lt; nrequires; i++) {
1099                             ModuleSymbol rsym = poolReader.getModule(nextChar());
1100                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1101                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1102                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1103                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1104                                 }
1105                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1106                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1107                                 }
1108                             }
1109                             nextChar(); // skip compiled version
1110                             requires.add(new RequiresDirective(rsym, flags));
1111                         }
1112                         msym.requires = requires.toList();
1113                         directives.addAll(msym.requires);
1114 
1115                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1116                         int nexports = nextChar();
1117                         for (int i = 0; i &lt; nexports; i++) {
1118                             PackageSymbol p = poolReader.getPackage(nextChar());
1119                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1120                             int nto = nextChar();
1121                             List&lt;ModuleSymbol&gt; to;
1122                             if (nto == 0) {
1123                                 to = null;
1124                             } else {
1125                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1126                                 for (int t = 0; t &lt; nto; t++)
1127                                     lb.append(poolReader.getModule(nextChar()));
1128                                 to = lb.toList();
1129                             }
1130                             exports.add(new ExportsDirective(p, to, flags));
1131                         }
1132                         msym.exports = exports.toList();
1133                         directives.addAll(msym.exports);
1134                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1135                         int nopens = nextChar();
1136                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1137                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1138                         }
1139                         for (int i = 0; i &lt; nopens; i++) {
1140                             PackageSymbol p = poolReader.getPackage(nextChar());
1141                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1142                             int nto = nextChar();
1143                             List&lt;ModuleSymbol&gt; to;
1144                             if (nto == 0) {
1145                                 to = null;
1146                             } else {
1147                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1148                                 for (int t = 0; t &lt; nto; t++)
1149                                     lb.append(poolReader.getModule(nextChar()));
1150                                 to = lb.toList();
1151                             }
1152                             opens.add(new OpensDirective(p, to, flags));
1153                         }
1154                         msym.opens = opens.toList();
1155                         directives.addAll(msym.opens);
1156 
1157                         msym.directives = directives.toList();
1158 
1159                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1160                         int nuses = nextChar();
1161                         for (int i = 0; i &lt; nuses; i++) {
1162                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1163                             uses.add(new InterimUsesDirective(srvc));
1164                         }
1165                         interimUses = uses.toList();
1166 
1167                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1168                         int nprovides = nextChar();
1169                         for (int p = 0; p &lt; nprovides; p++) {
1170                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1171                             int nimpls = nextChar();
1172                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1173                             for (int i = 0; i &lt; nimpls; i++) {
1174                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));
1175                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1176                             }
1177                         }
1178                         interimProvides = provides.toList();
1179                     }
1180                 }
1181 
1182                 private Name classNameMapper(byte[] arr, int offset, int length) {
1183                     return names.fromUtf(ClassFile.internalize(arr, offset, length));
1184                 }
1185             },
1186 
1187             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1188                 @Override
1189                 protected boolean accepts(AttributeKind kind) {
1190                     return super.accepts(kind) &amp;&amp; allowModules;
1191                 }
1192                 protected void read(Symbol sym, int attrLen) {
1193                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1194                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1195                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1196                     }
1197                 }
1198             },
1199 
1200             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1201                 @Override
1202                 protected boolean accepts(AttributeKind kind) {
1203                     return super.accepts(kind) &amp;&amp; allowRecords;
1204                 }
1205                 protected void read(Symbol sym, int attrLen) {
1206                     if (sym.kind == TYP) {
1207                         sym.flags_field |= RECORD;
1208                     }
1209                     bp = bp + attrLen;
1210                 }
1211             },
1212             new AttributeReader(names.PermittedSubclasses, V59, CLASS_ATTRIBUTE) {
1213                 @Override
1214                 protected boolean accepts(AttributeKind kind) {
1215                     return super.accepts(kind) &amp;&amp; allowSealedTypes;
1216                 }
1217                 protected void read(Symbol sym, int attrLen) {
1218                     if (sym.kind == TYP) {
1219                         ListBuffer&lt;Symbol&gt; subtypes = new ListBuffer&lt;&gt;();
1220                         int numberOfPermittedSubtypes = nextChar();
1221                         for (int i = 0; i &lt; numberOfPermittedSubtypes; i++) {
1222                             subtypes.add(poolReader.getClass(nextChar()));
1223                         }
1224                         ((ClassSymbol)sym).permitted = subtypes.toList();
1225                     }
1226                 }
1227             },
1228         };
1229 
1230         for (AttributeReader r: readers)
1231             attributeReaders.put(r.name, r);
1232     }
1233 
1234     protected void readEnclosingMethodAttr(Symbol sym) {
1235         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1236         // remove sym from it&#39;s current owners scope and place it in
1237         // the scope specified by the attribute
1238         sym.owner.members().remove(sym);
1239         ClassSymbol self = (ClassSymbol)sym;
1240         ClassSymbol c = poolReader.getClass(nextChar());
1241         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1242 
1243         if (c.members_field == null || c.kind != TYP)
1244             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1245 
1246         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1247         if (nt != null &amp;&amp; m == null)
1248             throw badEnclosingMethod(self);
1249 
1250         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1251         self.owner = m != null ? m : c;
1252         if (self.name.isEmpty())
1253             self.fullname = names.empty;
1254         else
1255             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1256 
1257         if (m != null) {
1258             ((ClassType)sym.type).setEnclosingType(m.type);
1259         } else if ((self.flags_field &amp; STATIC) == 0) {
1260             ((ClassType)sym.type).setEnclosingType(c.type);
1261         } else {
1262             ((ClassType)sym.type).setEnclosingType(Type.noType);
1263         }
1264         enterTypevars(self, self.type);
1265         if (!missingTypeVariables.isEmpty()) {
1266             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1267             for (Type typevar : missingTypeVariables) {
1268                 typeVars.append(findTypeVar(typevar.tsym.name));
1269             }
1270             foundTypeVariables = typeVars.toList();
1271         } else {
1272             foundTypeVariables = List.nil();
1273         }
1274     }
1275 
1276     // See java.lang.Class
1277     private Name simpleBinaryName(Name self, Name enclosing) {
1278         if (!self.startsWith(enclosing)) {
1279             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1280         }
1281 
1282         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1283         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1284             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1285         int index = 1;
1286         while (index &lt; simpleBinaryName.length() &amp;&amp;
1287                isAsciiDigit(simpleBinaryName.charAt(index)))
1288             index++;
1289         return names.fromString(simpleBinaryName.substring(index));
1290     }
1291 
1292     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1293         if (nt == null)
1294             return null;
1295 
1296         MethodType type = nt.type.asMethodType();
1297 
1298         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1299             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1300                 return (MethodSymbol)sym;
1301         }
1302 
1303         if (nt.name != names.init)
1304             // not a constructor
1305             return null;
1306         if ((flags &amp; INTERFACE) != 0)
1307             // no enclosing instance
1308             return null;
1309         if (nt.type.getParameterTypes().isEmpty())
1310             // no parameters
1311             return null;
1312 
1313         // A constructor of an inner class.
1314         // Remove the first argument (the enclosing instance)
1315         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,
1316                                  nt.type.getReturnType(),
1317                                  nt.type.getThrownTypes(),
1318                                  syms.methodClass));
1319         // Try searching again
1320         return findMethod(nt, scope, flags);
1321     }
1322 
1323     /** Similar to Types.isSameType but avoids completion */
1324     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1325         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1326             .prepend(types.erasure(mt1.getReturnType()));
1327         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1328         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1329             if (types1.head.tsym != types2.head.tsym)
1330                 return false;
1331             types1 = types1.tail;
1332             types2 = types2.tail;
1333         }
1334         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1335     }
1336 
1337     /**
1338      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1339      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1340      */
1341     private static boolean isAsciiDigit(char c) {
1342         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1343     }
1344 
1345     /** Read member attributes.
1346      */
1347     void readMemberAttrs(Symbol sym) {
1348         readAttrs(sym, AttributeKind.MEMBER);
1349     }
1350 
1351     void readAttrs(Symbol sym, AttributeKind kind) {
1352         char ac = nextChar();
1353         for (int i = 0; i &lt; ac; i++) {
1354             Name attrName = poolReader.getName(nextChar());
1355             int attrLen = nextInt();
1356             AttributeReader r = attributeReaders.get(attrName);
1357             if (r != null &amp;&amp; r.accepts(kind))
1358                 r.read(sym, attrLen);
1359             else  {
1360                 bp = bp + attrLen;
1361             }
1362         }
1363     }
1364 
1365     private boolean readingClassAttr = false;
1366     private List&lt;Type&gt; missingTypeVariables = List.nil();
1367     private List&lt;Type&gt; foundTypeVariables = List.nil();
1368 
1369     /** Read class attributes.
1370      */
1371     void readClassAttrs(ClassSymbol c) {
1372         readAttrs(c, AttributeKind.CLASS);
1373     }
1374 
1375     /** Read code block.
1376      */
1377     Code readCode(Symbol owner) {
1378         nextChar(); // max_stack
1379         nextChar(); // max_locals
1380         final int  code_length = nextInt();
1381         bp += code_length;
1382         final char exception_table_length = nextChar();
1383         bp += exception_table_length * 8;
1384         readMemberAttrs(owner);
1385         return null;
1386     }
1387 
1388 /************************************************************************
1389  * Reading Java-language annotations
1390  ***********************************************************************/
1391 
1392     /**
1393      * Save annotations.
1394      */
1395     List&lt;CompoundAnnotationProxy&gt; readAnnotations() {
1396         int numAttributes = nextChar();
1397         ListBuffer&lt;CompoundAnnotationProxy&gt; annotations = new ListBuffer&lt;&gt;();
1398         for (int i = 0; i &lt; numAttributes; i++) {
1399             annotations.append(readCompoundAnnotation());
1400         }
1401         return annotations.toList();
1402     }
1403 
1404     /** Attach annotations.
1405      */
1406     void attachAnnotations(final Symbol sym) {
1407         attachAnnotations(sym, readAnnotations());
1408     }
1409 
1410     /**
1411      * Attach annotations.
1412      */
1413     void attachAnnotations(final Symbol sym, List&lt;CompoundAnnotationProxy&gt; annotations) {
1414         if (annotations.isEmpty()) {
1415             return;
1416         }
1417         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1418         for (CompoundAnnotationProxy proxy : annotations) {
1419             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1420                 sym.flags_field |= PROPRIETARY;
1421             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1422                 if (profile != Profile.DEFAULT) {
1423                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1424                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1425                             Attribute.Constant c = (Attribute.Constant)v.snd;
1426                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1427                                 sym.flags_field |= NOT_IN_PROFILE;
1428                             }
1429                         }
1430                     }
1431                 }
1432             } else if (proxy.type.tsym.flatName() == syms.previewFeatureInternalType.tsym.flatName()) {
1433                 sym.flags_field |= PREVIEW_API;
1434                 setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1435             } else {
1436                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1437                     target = proxy;
1438                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1439                     repeatable = proxy;
1440                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1441                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1442                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1443                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1444                     sym.flags_field |= PREVIEW_API;
1445                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1446                 }
1447                 proxies.append(proxy);
1448             }
1449         }
1450         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1451     }
1452     //where:
1453         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1454             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1455                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1456                     Attribute.Constant c = (Attribute.Constant)v.snd;
1457                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1458                         sym.flags_field |= flag;
1459                     }
1460                 }
1461             }
1462         }
1463 
1464     /** Read parameter annotations.
1465      */
1466     void readParameterAnnotations(Symbol meth) {
1467         int numParameters = buf.getByte(bp++) &amp; 0xFF;
1468         if (parameterAnnotations == null) {
1469             parameterAnnotations = new ParameterAnnotations[numParameters];
1470         } else if (parameterAnnotations.length != numParameters) {
1471             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1472         }
1473         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1474             if (parameterAnnotations[pnum] == null) {
1475                 parameterAnnotations[pnum] = new ParameterAnnotations();
1476             }
1477             parameterAnnotations[pnum].add(readAnnotations());
1478         }
1479     }
1480 
1481     void attachTypeAnnotations(final Symbol sym) {
1482         int numAttributes = nextChar();
1483         if (numAttributes != 0) {
1484             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1485             for (int i = 0; i &lt; numAttributes; i++)
1486                 proxies.append(readTypeAnnotation());
1487             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
1488         }
1489     }
1490 
1491     /** Attach the default value for an annotation element.
1492      */
1493     void attachAnnotationDefault(final Symbol sym) {
1494         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1495         final Attribute value = readAttributeValue();
1496 
1497         // The default value is set later during annotation. It might
1498         // be the case that the Symbol sym is annotated _after_ the
1499         // repeating instances that depend on this default value,
1500         // because of this we set an interim value that tells us this
1501         // element (most likely) has a default.
1502         //
1503         // Set interim value for now, reset just before we do this
1504         // properly at annotate time.
1505         meth.defaultValue = value;
1506         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1507     }
1508 
1509     Type readTypeOrClassSymbol(int i) {
1510         // support preliminary jsr175-format class files
1511         if (poolReader.hasTag(i, CONSTANT_Class))
1512             return poolReader.getClass(i).type;
1513         return readTypeToProxy(i);
1514     }
1515     Type readTypeToProxy(int i) {
1516         if (currentModule.module_info == currentOwner) {
1517             return new ProxyType(i);
1518         } else {
1519             return poolReader.getType(i);
1520         }
1521     }
1522 
1523     CompoundAnnotationProxy readCompoundAnnotation() {
1524         Type t;
1525         if (currentModule.module_info == currentOwner) {
1526             int cpIndex = nextChar();
1527             t = new ProxyType(cpIndex);
1528         } else {
1529             t = readTypeOrClassSymbol(nextChar());
1530         }
1531         int numFields = nextChar();
1532         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1533         for (int i=0; i&lt;numFields; i++) {
1534             Name name = poolReader.getName(nextChar());
1535             Attribute value = readAttributeValue();
1536             pairs.append(new Pair&lt;&gt;(name, value));
1537         }
1538         return new CompoundAnnotationProxy(t, pairs.toList());
1539     }
1540 
1541     TypeAnnotationProxy readTypeAnnotation() {
1542         TypeAnnotationPosition position = readPosition();
1543         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1544 
1545         return new TypeAnnotationProxy(proxy, position);
1546     }
1547 
1548     TypeAnnotationPosition readPosition() {
1549         int tag = nextByte(); // TargetType tag is a byte
1550 
1551         if (!TargetType.isValidTargetTypeValue(tag))
1552             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1553 
1554         TargetType type = TargetType.fromTargetTypeValue(tag);
1555 
1556         switch (type) {
1557         // instanceof
1558         case INSTANCEOF: {
1559             final int offset = nextChar();
1560             final TypeAnnotationPosition position =
1561                 TypeAnnotationPosition.instanceOf(readTypePath());
1562             position.offset = offset;
1563             return position;
1564         }
1565         // new expression
1566         case NEW: {
1567             final int offset = nextChar();
1568             final TypeAnnotationPosition position =
1569                 TypeAnnotationPosition.newObj(readTypePath());
1570             position.offset = offset;
1571             return position;
1572         }
1573         // constructor/method reference receiver
1574         case CONSTRUCTOR_REFERENCE: {
1575             final int offset = nextChar();
1576             final TypeAnnotationPosition position =
1577                 TypeAnnotationPosition.constructorRef(readTypePath());
1578             position.offset = offset;
1579             return position;
1580         }
1581         case METHOD_REFERENCE: {
1582             final int offset = nextChar();
1583             final TypeAnnotationPosition position =
1584                 TypeAnnotationPosition.methodRef(readTypePath());
1585             position.offset = offset;
1586             return position;
1587         }
1588         // local variable
1589         case LOCAL_VARIABLE: {
1590             final int table_length = nextChar();
1591             final int[] newLvarOffset = new int[table_length];
1592             final int[] newLvarLength = new int[table_length];
1593             final int[] newLvarIndex = new int[table_length];
1594 
1595             for (int i = 0; i &lt; table_length; ++i) {
1596                 newLvarOffset[i] = nextChar();
1597                 newLvarLength[i] = nextChar();
1598                 newLvarIndex[i] = nextChar();
1599             }
1600 
1601             final TypeAnnotationPosition position =
1602                     TypeAnnotationPosition.localVariable(readTypePath());
1603             position.lvarOffset = newLvarOffset;
1604             position.lvarLength = newLvarLength;
1605             position.lvarIndex = newLvarIndex;
1606             return position;
1607         }
1608         // resource variable
1609         case RESOURCE_VARIABLE: {
1610             final int table_length = nextChar();
1611             final int[] newLvarOffset = new int[table_length];
1612             final int[] newLvarLength = new int[table_length];
1613             final int[] newLvarIndex = new int[table_length];
1614 
1615             for (int i = 0; i &lt; table_length; ++i) {
1616                 newLvarOffset[i] = nextChar();
1617                 newLvarLength[i] = nextChar();
1618                 newLvarIndex[i] = nextChar();
1619             }
1620 
1621             final TypeAnnotationPosition position =
1622                     TypeAnnotationPosition.resourceVariable(readTypePath());
1623             position.lvarOffset = newLvarOffset;
1624             position.lvarLength = newLvarLength;
1625             position.lvarIndex = newLvarIndex;
1626             return position;
1627         }
1628         // exception parameter
1629         case EXCEPTION_PARAMETER: {
1630             final int exception_index = nextChar();
1631             final TypeAnnotationPosition position =
1632                 TypeAnnotationPosition.exceptionParameter(readTypePath());
1633             position.setExceptionIndex(exception_index);
1634             return position;
1635         }
1636         // method receiver
1637         case METHOD_RECEIVER:
1638             return TypeAnnotationPosition.methodReceiver(readTypePath());
1639         // type parameter
1640         case CLASS_TYPE_PARAMETER: {
1641             final int parameter_index = nextByte();
1642             return TypeAnnotationPosition
1643                 .typeParameter(readTypePath(), parameter_index);
1644         }
1645         case METHOD_TYPE_PARAMETER: {
1646             final int parameter_index = nextByte();
1647             return TypeAnnotationPosition
1648                 .methodTypeParameter(readTypePath(), parameter_index);
1649         }
1650         // type parameter bound
1651         case CLASS_TYPE_PARAMETER_BOUND: {
1652             final int parameter_index = nextByte();
1653             final int bound_index = nextByte();
1654             return TypeAnnotationPosition
1655                 .typeParameterBound(readTypePath(), parameter_index,
1656                                     bound_index);
1657         }
1658         case METHOD_TYPE_PARAMETER_BOUND: {
1659             final int parameter_index = nextByte();
1660             final int bound_index = nextByte();
1661             return TypeAnnotationPosition
1662                 .methodTypeParameterBound(readTypePath(), parameter_index,
1663                                           bound_index);
1664         }
1665         // class extends or implements clause
1666         case CLASS_EXTENDS: {
1667             final int type_index = nextChar();
1668             return TypeAnnotationPosition.classExtends(readTypePath(),
1669                                                        type_index);
1670         }
1671         // throws
1672         case THROWS: {
1673             final int type_index = nextChar();
1674             return TypeAnnotationPosition.methodThrows(readTypePath(),
1675                                                        type_index);
1676         }
1677         // method parameter
1678         case METHOD_FORMAL_PARAMETER: {
1679             final int parameter_index = nextByte();
1680             return TypeAnnotationPosition.methodParameter(readTypePath(),
1681                                                           parameter_index);
1682         }
1683         // type cast
1684         case CAST: {
1685             final int offset = nextChar();
1686             final int type_index = nextByte();
1687             final TypeAnnotationPosition position =
1688                 TypeAnnotationPosition.typeCast(readTypePath(), type_index);
1689             position.offset = offset;
1690             return position;
1691         }
1692         // method/constructor/reference type argument
1693         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: {
1694             final int offset = nextChar();
1695             final int type_index = nextByte();
1696             final TypeAnnotationPosition position = TypeAnnotationPosition
1697                 .constructorInvocationTypeArg(readTypePath(), type_index);
1698             position.offset = offset;
1699             return position;
1700         }
1701         case METHOD_INVOCATION_TYPE_ARGUMENT: {
1702             final int offset = nextChar();
1703             final int type_index = nextByte();
1704             final TypeAnnotationPosition position = TypeAnnotationPosition
1705                 .methodInvocationTypeArg(readTypePath(), type_index);
1706             position.offset = offset;
1707             return position;
1708         }
1709         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: {
1710             final int offset = nextChar();
1711             final int type_index = nextByte();
1712             final TypeAnnotationPosition position = TypeAnnotationPosition
1713                 .constructorRefTypeArg(readTypePath(), type_index);
1714             position.offset = offset;
1715             return position;
1716         }
1717         case METHOD_REFERENCE_TYPE_ARGUMENT: {
1718             final int offset = nextChar();
1719             final int type_index = nextByte();
1720             final TypeAnnotationPosition position = TypeAnnotationPosition
1721                 .methodRefTypeArg(readTypePath(), type_index);
1722             position.offset = offset;
1723             return position;
1724         }
1725         // We don&#39;t need to worry about these
1726         case METHOD_RETURN:
1727             return TypeAnnotationPosition.methodReturn(readTypePath());
1728         case FIELD:
1729             return TypeAnnotationPosition.field(readTypePath());
1730         case UNKNOWN:
1731             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1732         default:
1733             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1734         }
1735     }
1736 
1737     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1738         int len = nextByte();
1739         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1740         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1741             loc = loc.append(nextByte());
1742 
1743         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1744 
1745     }
1746 
1747     /**
1748      * Helper function to read an optional pool entry (with given function); this is used while parsing
1749      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,
1750      * as per JVMS.
1751      */
1752     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {
1753         return (index == 0) ?
1754                 defaultValue :
1755                 poolFunc.apply(index);
1756     }
1757 
1758     Attribute readAttributeValue() {
1759         char c = (char) buf.getByte(bp++);
1760         switch (c) {
1761         case &#39;B&#39;:
1762             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));
1763         case &#39;C&#39;:
1764             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));
1765         case &#39;D&#39;:
1766             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));
1767         case &#39;F&#39;:
1768             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));
1769         case &#39;I&#39;:
1770             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));
1771         case &#39;J&#39;:
1772             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));
1773         case &#39;S&#39;:
1774             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));
1775         case &#39;Z&#39;:
1776             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));
1777         case &#39;s&#39;:
1778             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());
1779         case &#39;e&#39;:
1780             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));
1781         case &#39;c&#39;:
1782             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1783         case &#39;[&#39;: {
1784             int n = nextChar();
1785             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1786             for (int i=0; i&lt;n; i++)
1787                 l.append(readAttributeValue());
1788             return new ArrayAttributeProxy(l.toList());
1789         }
1790         case &#39;@&#39;:
1791             return readCompoundAnnotation();
1792         default:
1793             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
1794         }
1795     }
1796 
1797     interface ProxyVisitor extends Attribute.Visitor {
1798         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
1799         void visitClassAttributeProxy(ClassAttributeProxy proxy);
1800         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
1801         void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy);
1802     }
1803 
1804     static class EnumAttributeProxy extends Attribute {
1805         Type enumType;
1806         Name enumerator;
1807         public EnumAttributeProxy(Type enumType, Name enumerator) {
1808             super(null);
1809             this.enumType = enumType;
1810             this.enumerator = enumerator;
1811         }
1812         public void accept(Visitor v) { ((ProxyVisitor)v).visitEnumAttributeProxy(this); }
1813         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1814         public String toString() {
1815             return &quot;/*proxy enum*/&quot; + enumType + &quot;.&quot; + enumerator;
1816         }
1817     }
1818 
1819     static class ClassAttributeProxy extends Attribute {
1820         Type classType;
1821         public ClassAttributeProxy(Type classType) {
1822             super(null);
1823             this.classType = classType;
1824         }
1825         public void accept(Visitor v) { ((ProxyVisitor)v).visitClassAttributeProxy(this); }
1826         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1827         public String toString() {
1828             return &quot;/*proxy class*/&quot; + classType + &quot;.class&quot;;
1829         }
1830     }
1831 
1832     static class ArrayAttributeProxy extends Attribute {
1833         List&lt;Attribute&gt; values;
1834         ArrayAttributeProxy(List&lt;Attribute&gt; values) {
1835             super(null);
1836             this.values = values;
1837         }
1838         public void accept(Visitor v) { ((ProxyVisitor)v).visitArrayAttributeProxy(this); }
1839         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1840         public String toString() {
1841             return &quot;{&quot; + values + &quot;}&quot;;
1842         }
1843     }
1844 
1845     /** A temporary proxy representing a compound attribute.
1846      */
1847     static class CompoundAnnotationProxy extends Attribute {
1848         final List&lt;Pair&lt;Name,Attribute&gt;&gt; values;
1849         public CompoundAnnotationProxy(Type type,
1850                                       List&lt;Pair&lt;Name,Attribute&gt;&gt; values) {
1851             super(type);
1852             this.values = values;
1853         }
1854         public void accept(Visitor v) { ((ProxyVisitor)v).visitCompoundAnnotationProxy(this); }
1855         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1856         public String toString() {
1857             StringBuilder buf = new StringBuilder();
1858             buf.append(&quot;@&quot;);
1859             buf.append(type.tsym.getQualifiedName());
1860             buf.append(&quot;/*proxy*/{&quot;);
1861             boolean first = true;
1862             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; v = values;
1863                  v.nonEmpty(); v = v.tail) {
1864                 Pair&lt;Name,Attribute&gt; value = v.head;
1865                 if (!first) buf.append(&quot;,&quot;);
1866                 first = false;
1867                 buf.append(value.fst);
1868                 buf.append(&quot;=&quot;);
1869                 buf.append(value.snd);
1870             }
1871             buf.append(&quot;}&quot;);
1872             return buf.toString();
1873         }
1874     }
1875 
1876     /** A temporary proxy representing a type annotation.
1877      */
1878     static class TypeAnnotationProxy {
1879         final CompoundAnnotationProxy compound;
1880         final TypeAnnotationPosition position;
1881         public TypeAnnotationProxy(CompoundAnnotationProxy compound,
1882                 TypeAnnotationPosition position) {
1883             this.compound = compound;
1884             this.position = position;
1885         }
1886     }
1887 
1888     class AnnotationDeproxy implements ProxyVisitor {
1889         private ClassSymbol requestingOwner;
1890 
1891         AnnotationDeproxy(ClassSymbol owner) {
1892             this.requestingOwner = owner;
1893         }
1894 
1895         List&lt;Attribute.Compound&gt; deproxyCompoundList(List&lt;CompoundAnnotationProxy&gt; pl) {
1896             // also must fill in types!!!!
1897             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
1898             for (List&lt;CompoundAnnotationProxy&gt; l = pl; l.nonEmpty(); l=l.tail) {
1899                 buf.append(deproxyCompound(l.head));
1900             }
1901             return buf.toList();
1902         }
1903 
1904         Attribute.Compound deproxyCompound(CompoundAnnotationProxy a) {
1905             Type annotationType = resolvePossibleProxyType(a.type);
1906             ListBuffer&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; buf = new ListBuffer&lt;&gt;();
1907             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; l = a.values;
1908                  l.nonEmpty();
1909                  l = l.tail) {
1910                 MethodSymbol meth = findAccessMethod(annotationType, l.head.fst);
1911                 buf.append(new Pair&lt;&gt;(meth, deproxy(meth.type.getReturnType(), l.head.snd)));
1912             }
1913             return new Attribute.Compound(annotationType, buf.toList());
1914         }
1915 
1916         MethodSymbol findAccessMethod(Type container, Name name) {
1917             CompletionFailure failure = null;
1918             try {
1919                 for (Symbol sym : container.tsym.members().getSymbolsByName(name)) {
1920                     if (sym.kind == MTH &amp;&amp; sym.type.getParameterTypes().length() == 0)
1921                         return (MethodSymbol) sym;
1922                 }
1923             } catch (CompletionFailure ex) {
1924                 failure = ex;
1925             }
1926             // The method wasn&#39;t found: emit a warning and recover
1927             JavaFileObject prevSource = log.useSource(requestingOwner.classfile);
1928             try {
1929                 if (lintClassfile) {
1930                     if (failure == null) {
1931                         log.warning(Warnings.AnnotationMethodNotFound(container, name));
1932                     } else {
1933                         log.warning(Warnings.AnnotationMethodNotFoundReason(container,
1934                                                                             name,
1935                                                                             failure.getDetailValue()));//diagnostic, if present
1936                     }
1937                 }
1938             } finally {
1939                 log.useSource(prevSource);
1940             }
1941             // Construct a new method type and symbol.  Use bottom
1942             // type (typeof null) as return type because this type is
1943             // a subtype of all reference types and can be converted
1944             // to primitive types by unboxing.
1945             MethodType mt = new MethodType(List.nil(),
1946                                            syms.botType,
1947                                            List.nil(),
1948                                            syms.methodClass);
1949             return new MethodSymbol(PUBLIC | ABSTRACT, name, mt, container.tsym);
1950         }
1951 
1952         Attribute result;
1953         Type type;
1954         Attribute deproxy(Type t, Attribute a) {
1955             Type oldType = type;
1956             try {
1957                 type = t;
1958                 a.accept(this);
1959                 return result;
1960             } finally {
1961                 type = oldType;
1962             }
1963         }
1964 
1965         // implement Attribute.Visitor below
1966 
1967         public void visitConstant(Attribute.Constant value) {
1968             // assert value.type == type;
1969             result = value;
1970         }
1971 
1972         public void visitClass(Attribute.Class clazz) {
1973             result = clazz;
1974         }
1975 
1976         public void visitEnum(Attribute.Enum e) {
1977             throw new AssertionError(); // shouldn&#39;t happen
1978         }
1979 
1980         public void visitCompound(Attribute.Compound compound) {
1981             throw new AssertionError(); // shouldn&#39;t happen
1982         }
1983 
1984         public void visitArray(Attribute.Array array) {
1985             throw new AssertionError(); // shouldn&#39;t happen
1986         }
1987 
1988         public void visitError(Attribute.Error e) {
1989             throw new AssertionError(); // shouldn&#39;t happen
1990         }
1991 
1992         public void visitEnumAttributeProxy(EnumAttributeProxy proxy) {
1993             // type.tsym.flatName() should == proxy.enumFlatName
1994             Type enumType = resolvePossibleProxyType(proxy.enumType);
1995             TypeSymbol enumTypeSym = enumType.tsym;
1996             VarSymbol enumerator = null;
1997             CompletionFailure failure = null;
1998             try {
1999                 for (Symbol sym : enumTypeSym.members().getSymbolsByName(proxy.enumerator)) {
2000                     if (sym.kind == VAR) {
2001                         enumerator = (VarSymbol)sym;
2002                         break;
2003                     }
2004                 }
2005             }
2006             catch (CompletionFailure ex) {
2007                 failure = ex;
2008             }
2009             if (enumerator == null) {
2010                 if (failure != null) {
2011                     log.warning(Warnings.UnknownEnumConstantReason(currentClassFile,
2012                                                                    enumTypeSym,
2013                                                                    proxy.enumerator,
2014                                                                    failure.getDiagnostic()));
2015                 } else {
2016                     log.warning(Warnings.UnknownEnumConstant(currentClassFile,
2017                                                              enumTypeSym,
2018                                                              proxy.enumerator));
2019                 }
2020                 result = new Attribute.Enum(enumTypeSym.type,
2021                         new VarSymbol(0, proxy.enumerator, syms.botType, enumTypeSym));
2022             } else {
2023                 result = new Attribute.Enum(enumTypeSym.type, enumerator);
2024             }
2025         }
2026 
2027         @Override
2028         public void visitClassAttributeProxy(ClassAttributeProxy proxy) {
2029             Type classType = resolvePossibleProxyType(proxy.classType);
2030             result = new Attribute.Class(types, classType);
2031         }
2032 
2033         public void visitArrayAttributeProxy(ArrayAttributeProxy proxy) {
2034             int length = proxy.values.length();
2035             Attribute[] ats = new Attribute[length];
2036             Type elemtype = types.elemtype(type);
2037             int i = 0;
2038             for (List&lt;Attribute&gt; p = proxy.values; p.nonEmpty(); p = p.tail) {
2039                 ats[i++] = deproxy(elemtype, p.head);
2040             }
2041             result = new Attribute.Array(type, ats);
2042         }
2043 
2044         public void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy) {
2045             result = deproxyCompound(proxy);
2046         }
2047 
2048         Type resolvePossibleProxyType(Type t) {
2049             if (t instanceof ProxyType) {
2050                 Assert.check(requestingOwner.owner.kind == MDL);
2051                 ModuleSymbol prevCurrentModule = currentModule;
2052                 currentModule = (ModuleSymbol) requestingOwner.owner;
2053                 try {
2054                     return ((ProxyType) t).resolve();
2055                 } finally {
2056                     currentModule = prevCurrentModule;
2057                 }
2058             } else {
2059                 return t;
2060             }
2061         }
2062     }
2063 
2064     class AnnotationDefaultCompleter extends AnnotationDeproxy implements Runnable {
2065         final MethodSymbol sym;
2066         final Attribute value;
2067         final JavaFileObject classFile = currentClassFile;
2068 
2069         AnnotationDefaultCompleter(MethodSymbol sym, Attribute value) {
2070             super(currentOwner.kind == MTH
2071                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2072             this.sym = sym;
2073             this.value = value;
2074         }
2075 
2076         @Override
2077         public void run() {
2078             JavaFileObject previousClassFile = currentClassFile;
2079             try {
2080                 // Reset the interim value set earlier in
2081                 // attachAnnotationDefault().
2082                 sym.defaultValue = null;
2083                 currentClassFile = classFile;
2084                 sym.defaultValue = deproxy(sym.type.getReturnType(), value);
2085             } finally {
2086                 currentClassFile = previousClassFile;
2087             }
2088         }
2089 
2090         @Override
2091         public String toString() {
2092             return &quot; ClassReader store default for &quot; + sym.owner + &quot;.&quot; + sym + &quot; is &quot; + value;
2093         }
2094     }
2095 
2096     class AnnotationCompleter extends AnnotationDeproxy implements Runnable {
2097         final Symbol sym;
2098         final List&lt;CompoundAnnotationProxy&gt; l;
2099         final JavaFileObject classFile;
2100 
2101         AnnotationCompleter(Symbol sym, List&lt;CompoundAnnotationProxy&gt; l) {
2102             super(currentOwner.kind == MTH
2103                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2104             if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
2105                 this.sym = sym.owner;
2106             } else {
2107                 this.sym = sym;
2108             }
2109             this.l = l;
2110             this.classFile = currentClassFile;
2111         }
2112 
2113         @Override
2114         public void run() {
2115             JavaFileObject previousClassFile = currentClassFile;
2116             try {
2117                 currentClassFile = classFile;
2118                 List&lt;Attribute.Compound&gt; newList = deproxyCompoundList(l);
2119                 for (Attribute.Compound attr : newList) {
2120                     if (attr.type.tsym == syms.deprecatedType.tsym) {
2121                         sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
2122                         Attribute forRemoval = attr.member(names.forRemoval);
2123                         if (forRemoval instanceof Attribute.Constant) {
2124                             Attribute.Constant c = (Attribute.Constant) forRemoval;
2125                             if (c.type == syms.booleanType &amp;&amp; ((Integer) c.value) != 0) {
2126                                 sym.flags_field |= DEPRECATED_REMOVAL;
2127                             }
2128                         }
2129                     }
2130                 }
2131                 if (sym.annotationsPendingCompletion()) {
2132                     sym.setDeclarationAttributes(newList);
2133                 } else {
2134                     sym.appendAttributes(newList);
2135                 }
2136             } finally {
2137                 currentClassFile = previousClassFile;
2138             }
2139         }
2140 
2141         @Override
2142         public String toString() {
2143             return &quot; ClassReader annotate &quot; + sym.owner + &quot;.&quot; + sym + &quot; with &quot; + l;
2144         }
2145     }
2146 
2147     class TypeAnnotationCompleter extends AnnotationCompleter {
2148 
2149         List&lt;TypeAnnotationProxy&gt; proxies;
2150 
2151         TypeAnnotationCompleter(Symbol sym,
2152                 List&lt;TypeAnnotationProxy&gt; proxies) {
2153             super(sym, List.nil());
2154             this.proxies = proxies;
2155         }
2156 
2157         List&lt;Attribute.TypeCompound&gt; deproxyTypeCompoundList(List&lt;TypeAnnotationProxy&gt; proxies) {
2158             ListBuffer&lt;Attribute.TypeCompound&gt; buf = new ListBuffer&lt;&gt;();
2159             for (TypeAnnotationProxy proxy: proxies) {
2160                 Attribute.Compound compound = deproxyCompound(proxy.compound);
2161                 Attribute.TypeCompound typeCompound = new Attribute.TypeCompound(compound, proxy.position);
2162                 buf.add(typeCompound);
2163             }
2164             return buf.toList();
2165         }
2166 
2167         @Override
2168         public void run() {
2169             JavaFileObject previousClassFile = currentClassFile;
2170             try {
2171                 currentClassFile = classFile;
2172                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2173                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2174             } finally {
2175                 currentClassFile = previousClassFile;
2176             }
2177         }
2178     }
2179 
2180 
2181 /************************************************************************
2182  * Reading Symbols
2183  ***********************************************************************/
2184 
2185     /** Read a field.
2186      */
2187     VarSymbol readField() {
2188         long flags = adjustFieldFlags(nextChar());
2189         Name name = poolReader.getName(nextChar());
2190         Type type = poolReader.getType(nextChar());
2191         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2192         readMemberAttrs(v);
2193         return v;
2194     }
2195 
2196     /** Read a method.
2197      */
2198     MethodSymbol readMethod() {
2199         long flags = adjustMethodFlags(nextChar());
2200         Name name = poolReader.getName(nextChar());
2201         Type type = poolReader.getType(nextChar());
2202         if (currentOwner.isInterface() &amp;&amp;
2203                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2204             if (majorVersion &gt; Version.V52.major ||
2205                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2206                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2207                     currentOwner.flags_field |= DEFAULT;
2208                     flags |= DEFAULT | ABSTRACT;
2209                 }
2210             } else {
2211                 //protect against ill-formed classfiles
2212                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2213                                    Integer.toString(majorVersion),
2214                                    Integer.toString(minorVersion));
2215             }
2216         }
2217         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2218             // Sometimes anonymous classes don&#39;t have an outer
2219             // instance, however, there is no reliable way to tell so
2220             // we never strip this$n
2221             // ditto for local classes. Local classes that have an enclosing method set
2222             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2223             // enclosing method (i.e. from initializers) will pass that check.
2224             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2225             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2226                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2227                                       type.getReturnType(),
2228                                       type.getThrownTypes(),
2229                                       syms.methodClass);
2230         }
2231         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2232         if (types.isSignaturePolymorphic(m)) {
2233             m.flags_field |= SIGNATURE_POLYMORPHIC;
2234         }
2235         if (saveParameterNames)
2236             initParameterNames(m);
2237         Symbol prevOwner = currentOwner;
2238         currentOwner = m;
2239         try {
2240             readMemberAttrs(m);
2241         } finally {
2242             currentOwner = prevOwner;
2243         }
2244         setParameters(m, type);
2245 
2246         if ((flags &amp; VARARGS) != 0) {
2247             final Type last = type.getParameterTypes().last();
2248             if (last == null || !last.hasTag(ARRAY)) {
2249                 m.flags_field &amp;= ~VARARGS;
2250                 throw badClassFile(&quot;malformed.vararg.method&quot;, m);
2251             }
2252         }
2253 
2254         return m;
2255     }
2256 
2257     private List&lt;Type&gt; adjustMethodParams(long flags, List&lt;Type&gt; args) {
2258         if (args.isEmpty()) {
2259             return args;
2260         }
2261         boolean isVarargs = (flags &amp; VARARGS) != 0;
2262         if (isVarargs) {
2263             Type varargsElem = args.last();
2264             ListBuffer&lt;Type&gt; adjustedArgs = new ListBuffer&lt;&gt;();
2265             for (Type t : args) {
2266                 adjustedArgs.append(t != varargsElem ?
2267                     t :
2268                     ((ArrayType)t).makeVarargs());
2269             }
2270             args = adjustedArgs.toList();
2271         }
2272         return args.tail;
2273     }
2274 
2275     /**
2276      * Init the parameter names array.
2277      * Parameter names are currently inferred from the names in the
2278      * LocalVariableTable attributes of a Code attribute.
2279      * (Note: this means parameter names are currently not available for
2280      * methods without a Code attribute.)
2281      * This method initializes an array in which to store the name indexes
2282      * of parameter names found in LocalVariableTable attributes. It is
2283      * slightly supersized to allow for additional slots with a start_pc of 0.
2284      */
2285     void initParameterNames(MethodSymbol sym) {
2286         // make allowance for synthetic parameters.
2287         final int excessSlots = 4;
2288         int expectedParameterSlots =
2289                 Code.width(sym.type.getParameterTypes()) + excessSlots;
2290         if (parameterNameIndices == null
2291                 || parameterNameIndices.length &lt; expectedParameterSlots) {
2292             parameterNameIndices = new int[expectedParameterSlots];
2293         } else
2294             Arrays.fill(parameterNameIndices, 0);
2295         haveParameterNameIndices = false;
2296         sawMethodParameters = false;
2297     }
2298 
2299     /**
2300      * Set the parameters for a method symbol, including any names and
2301      * annotations that were read.
2302      *
2303      * &lt;p&gt;The type of the symbol may have changed while reading the
2304      * method attributes (see the Signature attribute). This may be
2305      * because of generic information or because anonymous synthetic
2306      * parameters were added.   The original type (as read from the
2307      * method descriptor) is used to help guess the existence of
2308      * anonymous synthetic parameters.
2309      */
2310     void setParameters(MethodSymbol sym, Type jvmType) {
2311         // If we get parameter names from MethodParameters, then we
2312         // don&#39;t need to skip.
2313         int firstParam = 0;
2314         if (!sawMethodParameters) {
2315             firstParam = ((sym.flags() &amp; STATIC) == 0) ? 1 : 0;
2316             // the code in readMethod may have skipped the first
2317             // parameter when setting up the MethodType. If so, we
2318             // make a corresponding allowance here for the position of
2319             // the first parameter.  Note that this assumes the
2320             // skipped parameter has a width of 1 -- i.e. it is not
2321             // a double width type (long or double.)
2322             if (sym.name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2323                 // Sometimes anonymous classes don&#39;t have an outer
2324                 // instance, however, there is no reliable way to tell so
2325                 // we never strip this$n
2326                 if (!currentOwner.name.isEmpty())
2327                     firstParam += 1;
2328             }
2329 
2330             if (sym.type != jvmType) {
2331                 // reading the method attributes has caused the
2332                 // symbol&#39;s type to be changed. (i.e. the Signature
2333                 // attribute.)  This may happen if there are hidden
2334                 // (synthetic) parameters in the descriptor, but not
2335                 // in the Signature.  The position of these hidden
2336                 // parameters is unspecified; for now, assume they are
2337                 // at the beginning, and so skip over them. The
2338                 // primary case for this is two hidden parameters
2339                 // passed into Enum constructors.
2340                 int skip = Code.width(jvmType.getParameterTypes())
2341                         - Code.width(sym.type.getParameterTypes());
2342                 firstParam += skip;
2343             }
2344         }
2345         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();
2346         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2347         int nameIndex = firstParam;
2348         int annotationIndex = 0;
2349         for (Type t: sym.type.getParameterTypes()) {
2350             VarSymbol param = parameter(nameIndex, t, sym, paramNames);
2351             params.append(param);
2352             if (parameterAnnotations != null) {
2353                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2354                 if (annotations != null &amp;&amp; annotations.proxies != null
2355                         &amp;&amp; !annotations.proxies.isEmpty()) {
2356                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2357                 }
2358             }
2359             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2360             annotationIndex++;
2361         }
2362         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2363             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2364         }
2365         Assert.checkNull(sym.params);
2366         sym.params = params.toList();
2367         parameterAnnotations = null;
2368         parameterNameIndices = null;
2369     }
2370 
2371 
2372     // Returns the name for the parameter at position &#39;index&#39;, either using
2373     // names read from the MethodParameters, or by synthesizing a name that
2374     // is not on the &#39;exclude&#39; list.
2375     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {
2376         long flags = PARAMETER;
2377         Name argName;
2378         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2379                 &amp;&amp; parameterNameIndices[index] != 0) {
2380             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);
2381             flags |= NAME_FILLED;
2382         } else {
2383             String prefix = &quot;arg&quot;;
2384             while (true) {
2385                 argName = names.fromString(prefix + exclude.size());
2386                 if (!exclude.contains(argName))
2387                     break;
2388                 prefix += &quot;$&quot;;
2389             }
2390         }
2391         exclude.add(argName);
2392         return new ParamSymbol(flags, argName, t, owner);
2393     }
2394 
2395     /**
2396      * skip n bytes
2397      */
2398     void skipBytes(int n) {
2399         bp = bp + n;
2400     }
2401 
2402     /** Skip a field or method
2403      */
2404     void skipMember() {
2405         bp = bp + 6;
2406         char ac = nextChar();
2407         for (int i = 0; i &lt; ac; i++) {
2408             bp = bp + 2;
2409             int attrLen = nextInt();
2410             bp = bp + attrLen;
2411         }
2412     }
2413 
2414     void skipInnerClasses() {
2415         int n = nextChar();
2416         for (int i = 0; i &lt; n; i++) {
2417             nextChar();
2418             nextChar();
2419             nextChar();
2420             nextChar();
2421         }
2422     }
2423 
2424     /** Enter type variables of this classtype and all enclosing ones in
2425      *  `typevars&#39;.
2426      */
2427     protected void enterTypevars(Symbol sym, Type t) {
2428         if (t.getEnclosingType() != null) {
2429             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2430                 enterTypevars(sym.owner, t.getEnclosingType());
2431             }
2432         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2433             enterTypevars(sym.owner, sym.owner.type);
2434         }
2435         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2436             typevars.enter(xs.head.tsym);
2437         }
2438     }
2439 
2440     protected ClassSymbol enterClass(Name name) {
2441         return syms.enterClass(currentModule, name);
2442     }
2443 
2444     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2445         return syms.enterClass(currentModule, name, owner);
2446     }
2447 
2448     /** Read contents of a given class symbol `c&#39;. Both external and internal
2449      *  versions of an inner class are read.
2450      */
2451     void readClass(ClassSymbol c) {
2452         ClassType ct = (ClassType)c.type;
2453 
2454         // allocate scope for members
2455         c.members_field = WriteableScope.create(c);
2456 
2457         // prepare type variable table
2458         typevars = typevars.dup(currentOwner);
2459         if (ct.getEnclosingType().hasTag(CLASS))
2460             enterTypevars(c.owner, ct.getEnclosingType());
2461 
2462         // read flags, or skip if this is an inner class
2463         long f = nextChar();
2464         long flags = adjustClassFlags(f);
2465         if ((flags &amp; MODULE) == 0) {
2466             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2467             // read own class name and check that it matches
2468             currentModule = c.packge().modle;
2469             ClassSymbol self = poolReader.getClass(nextChar());
2470             if (c != self) {
2471                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2472                                    self.flatname);
2473             }
2474         } else {
2475             if (majorVersion &lt; Version.V53.major) {
2476                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2477                         Integer.toString(majorVersion),
2478                         Integer.toString(minorVersion));
2479             }
2480             c.flags_field = flags;
2481             currentModule = (ModuleSymbol) c.owner;
2482             int this_class = nextChar();
2483             // temp, no check on this_class
2484         }
2485 
2486         // class attributes must be read before class
2487         // skip ahead to read class attributes
2488         int startbp = bp;
2489         nextChar();
2490         char interfaceCount = nextChar();
2491         bp += interfaceCount * 2;
2492         char fieldCount = nextChar();
2493         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2494         char methodCount = nextChar();
2495         for (int i = 0; i &lt; methodCount; i++) skipMember();
2496         readClassAttrs(c);
2497 
2498         if (c.permitted != null &amp;&amp; !c.permitted.isEmpty()) {
2499             c.flags_field |= SEALED;
2500         }
2501 
2502         // reset and read rest of classinfo
2503         bp = startbp;
2504         int n = nextChar();
2505         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2506             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2507         }
2508         if (ct.supertype_field == null)
2509             ct.supertype_field =
2510                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2511         n = nextChar();
2512         List&lt;Type&gt; is = List.nil();
2513         for (int i = 0; i &lt; n; i++) {
2514             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2515             is = is.prepend(_inter);
2516         }
2517         if (ct.interfaces_field == null)
2518             ct.interfaces_field = is.reverse();
2519 
2520         Assert.check(fieldCount == nextChar());
2521         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2522         Assert.check(methodCount == nextChar());
2523         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2524 
2525         typevars = typevars.leave();
2526     }
2527 
2528     /** Read inner class info. For each inner/outer pair allocate a
2529      *  member class.
2530      */
2531     void readInnerClasses(ClassSymbol c) {
2532         int n = nextChar();
2533         for (int i = 0; i &lt; n; i++) {
2534             nextChar(); // skip inner class symbol
2535             int outerIdx = nextChar();
2536             int nameIdx = nextChar();
2537             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);
2538             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);
2539             if (name == null) name = names.empty;
2540             long flags = adjustClassFlags(nextChar());
2541             if (outer != null) { // we have a member class
2542                 if (name == names.empty)
2543                     name = names.one;
2544                 ClassSymbol member = enterClass(name, outer);
2545                 if ((flags &amp; STATIC) == 0) {
2546                     ((ClassType)member.type).setEnclosingType(outer.type);
2547                     if (member.erasure_field != null)
2548                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2549                 }
2550                 if (c == outer) {
2551                     member.flags_field = flags;
2552                     enterMember(c, member);
2553                 }
2554             }
2555         }
2556     }
2557 
2558     /** Read a class definition from the bytes in buf.
2559      */
2560     private void readClassBuffer(ClassSymbol c) throws IOException {
2561         int magic = nextInt();
2562         if (magic != JAVA_MAGIC)
2563             throw badClassFile(&quot;illegal.start.of.class.file&quot;);
2564 
2565         minorVersion = nextChar();
2566         majorVersion = nextChar();
2567         int maxMajor = Version.MAX().major;
2568         int maxMinor = Version.MAX().minor;
2569         if (majorVersion &gt; maxMajor ||
2570             majorVersion * 1000 + minorVersion &lt;
2571             Version.MIN().major * 1000 + Version.MIN().minor) {
2572             if (majorVersion == (maxMajor + 1))
2573                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2574                                                      majorVersion,
2575                                                      maxMajor));
2576             else
2577                 throw badClassFile(&quot;wrong.version&quot;,
2578                                    Integer.toString(majorVersion),
2579                                    Integer.toString(minorVersion),
2580                                    Integer.toString(maxMajor),
2581                                    Integer.toString(maxMinor));
2582         }
2583 
2584         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2585             if (!preview.isEnabled()) {
2586                 log.error(preview.disabledError(currentClassFile, majorVersion));
2587             } else {
2588                 preview.warnPreview(c.classfile, majorVersion);
2589             }
2590         }
2591 
2592         poolReader = new PoolReader(this, names, syms);
2593         bp = poolReader.readPool(buf, bp);
2594         if (signatureBuffer.length &lt; bp) {
2595             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2596             signatureBuffer = new byte[ns];
2597         }
2598         readClass(c);
2599     }
2600 
2601     public void readClassFile(ClassSymbol c) {
2602         currentOwner = c;
2603         currentClassFile = c.classfile;
2604         warnedAttrs.clear();
2605         filling = true;
2606         target = null;
2607         repeatable = null;
2608         try {
2609             bp = 0;
2610             buf.reset();
2611             buf.appendStream(c.classfile.openInputStream());
2612             readClassBuffer(c);
2613             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2614                 List&lt;Type&gt; missing = missingTypeVariables;
2615                 List&lt;Type&gt; found = foundTypeVariables;
2616                 missingTypeVariables = List.nil();
2617                 foundTypeVariables = List.nil();
2618                 interimUses = List.nil();
2619                 interimProvides = List.nil();
2620                 filling = false;
2621                 ClassType ct = (ClassType)currentOwner.type;
2622                 ct.supertype_field =
2623                     types.subst(ct.supertype_field, missing, found);
2624                 ct.interfaces_field =
2625                     types.subst(ct.interfaces_field, missing, found);
2626                 ct.typarams_field =
2627                     types.substBounds(ct.typarams_field, missing, found);
2628                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2629                     types.head.tsym.type = types.head;
2630                 }
2631             } else if (missingTypeVariables.isEmpty() !=
2632                        foundTypeVariables.isEmpty()) {
2633                 Name name = missingTypeVariables.head.tsym.name;
2634                 throw badClassFile(&quot;undecl.type.var&quot;, name);
2635             }
2636 
2637             if ((c.flags_field &amp; Flags.ANNOTATION) != 0) {
2638                 c.setAnnotationTypeMetadata(new AnnotationTypeMetadata(c, new CompleterDeproxy(c, target, repeatable)));
2639             } else {
2640                 c.setAnnotationTypeMetadata(AnnotationTypeMetadata.notAnAnnotationType());
2641             }
2642 
2643             if (c == currentModule.module_info) {
2644                 if (interimUses.nonEmpty() || interimProvides.nonEmpty()) {
2645                     Assert.check(currentModule.isCompleted());
2646                     currentModule.usesProvidesCompleter =
2647                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2648                 } else {
2649                     currentModule.uses = List.nil();
2650                     currentModule.provides = List.nil();
2651                 }
2652             }
2653         } catch (IOException | ClosedFileSystemException ex) {
2654             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2655         } catch (ArrayIndexOutOfBoundsException ex) {
2656             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2657         } finally {
2658             interimUses = List.nil();
2659             interimProvides = List.nil();
2660             missingTypeVariables = List.nil();
2661             foundTypeVariables = List.nil();
2662             filling = false;
2663         }
2664     }
2665 
2666     /** We can only read a single class file at a time; this
2667      *  flag keeps track of when we are currently reading a class
2668      *  file.
2669      */
2670     public boolean filling = false;
2671 
2672 /************************************************************************
2673  * Adjusting flags
2674  ***********************************************************************/
2675 
2676     long adjustFieldFlags(long flags) {
2677         return flags;
2678     }
2679 
2680     long adjustMethodFlags(long flags) {
2681         if ((flags &amp; ACC_BRIDGE) != 0) {
2682             flags &amp;= ~ACC_BRIDGE;
2683             flags |= BRIDGE;
2684         }
2685         if ((flags &amp; ACC_VARARGS) != 0) {
2686             flags &amp;= ~ACC_VARARGS;
2687             flags |= VARARGS;
2688         }
2689         return flags;
2690     }
2691 
2692     long adjustClassFlags(long flags) {
2693         if ((flags &amp; ACC_MODULE) != 0) {
2694             flags &amp;= ~ACC_MODULE;
2695             flags |= MODULE;
2696         }
2697         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2698     }
2699 
2700     /**
2701      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2702      * The attribute is only the last component of the original filename, so is unlikely
2703      * to be valid as is, so operations other than those to access the name throw
2704      * UnsupportedOperationException
2705      */
2706     private static class SourceFileObject implements JavaFileObject {
2707 
2708         /** The file&#39;s name.
2709          */
2710         private final Name name;
2711 
2712         public SourceFileObject(Name name) {
2713             this.name = name;
2714         }
2715 
2716         @Override @DefinedBy(Api.COMPILER)
2717         public URI toUri() {
2718             try {
2719                 return new URI(null, name.toString(), null);
2720             } catch (URISyntaxException e) {
2721                 throw new PathFileObject.CannotCreateUriError(name.toString(), e);
2722             }
2723         }
2724 
2725         @Override @DefinedBy(Api.COMPILER)
2726         public String getName() {
2727             return name.toString();
2728         }
2729 
2730         @Override @DefinedBy(Api.COMPILER)
2731         public JavaFileObject.Kind getKind() {
2732             return BaseFileManager.getKind(getName());
2733         }
2734 
2735         @Override @DefinedBy(Api.COMPILER)
2736         public InputStream openInputStream() {
2737             throw new UnsupportedOperationException();
2738         }
2739 
2740         @Override @DefinedBy(Api.COMPILER)
2741         public OutputStream openOutputStream() {
2742             throw new UnsupportedOperationException();
2743         }
2744 
2745         @Override @DefinedBy(Api.COMPILER)
2746         public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
2747             throw new UnsupportedOperationException();
2748         }
2749 
2750         @Override @DefinedBy(Api.COMPILER)
2751         public Reader openReader(boolean ignoreEncodingErrors) {
2752             throw new UnsupportedOperationException();
2753         }
2754 
2755         @Override @DefinedBy(Api.COMPILER)
2756         public Writer openWriter() {
2757             throw new UnsupportedOperationException();
2758         }
2759 
2760         @Override @DefinedBy(Api.COMPILER)
2761         public long getLastModified() {
2762             throw new UnsupportedOperationException();
2763         }
2764 
2765         @Override @DefinedBy(Api.COMPILER)
2766         public boolean delete() {
2767             throw new UnsupportedOperationException();
2768         }
2769 
2770         @Override @DefinedBy(Api.COMPILER)
2771         public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {
2772             return true; // fail-safe mode
2773         }
2774 
2775         @Override @DefinedBy(Api.COMPILER)
2776         public NestingKind getNestingKind() {
2777             return null;
2778         }
2779 
2780         @Override @DefinedBy(Api.COMPILER)
2781         public Modifier getAccessLevel() {
2782             return null;
2783         }
2784 
2785         /**
2786          * Check if two file objects are equal.
2787          * SourceFileObjects are just placeholder objects for the value of a
2788          * SourceFile attribute, and do not directly represent specific files.
2789          * Two SourceFileObjects are equal if their names are equal.
2790          */
2791         @Override
2792         public boolean equals(Object other) {
2793             if (this == other)
2794                 return true;
2795 
2796             if (!(other instanceof SourceFileObject))
2797                 return false;
2798 
2799             SourceFileObject o = (SourceFileObject) other;
2800             return name.equals(o.name);
2801         }
2802 
2803         @Override
2804         public int hashCode() {
2805             return name.hashCode();
2806         }
2807     }
2808 
2809     private class CompleterDeproxy implements AnnotationTypeCompleter {
2810         ClassSymbol proxyOn;
2811         CompoundAnnotationProxy target;
2812         CompoundAnnotationProxy repeatable;
2813 
2814         public CompleterDeproxy(ClassSymbol c, CompoundAnnotationProxy target,
2815                 CompoundAnnotationProxy repeatable)
2816         {
2817             this.proxyOn = c;
2818             this.target = target;
2819             this.repeatable = repeatable;
2820         }
2821 
2822         @Override
2823         public void complete(ClassSymbol sym) {
2824             Assert.check(proxyOn == sym);
2825             Attribute.Compound theTarget = null, theRepeatable = null;
2826             AnnotationDeproxy deproxy;
2827 
2828             try {
2829                 if (target != null) {
2830                     deproxy = new AnnotationDeproxy(proxyOn);
2831                     theTarget = deproxy.deproxyCompound(target);
2832                 }
2833 
2834                 if (repeatable != null) {
2835                     deproxy = new AnnotationDeproxy(proxyOn);
2836                     theRepeatable = deproxy.deproxyCompound(repeatable);
2837                 }
2838             } catch (Exception e) {
2839                 throw new CompletionFailure(sym,
2840                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),
2841                                             dcfh);
2842             }
2843 
2844             sym.getAnnotationTypeMetadata().setTarget(theTarget);
2845             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
2846         }
2847     }
2848 
2849     private class ProxyType extends Type {
2850 
2851         private final Name name;
2852 
2853         public ProxyType(int index) {
2854             super(syms.noSymbol, TypeMetadata.EMPTY);
2855             this.name = poolReader.getName(index);
2856         }
2857 
2858         @Override
2859         public TypeTag getTag() {
2860             return TypeTag.NONE;
2861         }
2862 
2863         @Override
2864         public Type cloneWithMetadata(TypeMetadata metadata) {
2865             throw new UnsupportedOperationException();
2866         }
2867 
2868         public Type resolve() {
2869             return name.map(ClassReader.this::sigToType);
2870         }
2871 
2872         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2873         public String toString() {
2874             return &quot;&lt;ProxyType&gt;&quot;;
2875         }
2876 
2877     }
2878 
2879     private static final class InterimUsesDirective {
2880         public final Name service;
2881 
2882         public InterimUsesDirective(Name service) {
2883             this.service = service;
2884         }
2885 
2886     }
2887 
2888     private static final class InterimProvidesDirective {
2889         public final Name service;
2890         public final List&lt;Name&gt; impls;
2891 
2892         public InterimProvidesDirective(Name service, List&lt;Name&gt; impls) {
2893             this.service = service;
2894             this.impls = impls;
2895         }
2896 
2897     }
2898 
2899     private final class UsesProvidesCompleter implements Completer {
2900         private final ModuleSymbol currentModule;
2901         private final List&lt;InterimUsesDirective&gt; interimUsesCopy;
2902         private final List&lt;InterimProvidesDirective&gt; interimProvidesCopy;
2903 
2904         public UsesProvidesCompleter(ModuleSymbol currentModule, List&lt;InterimUsesDirective&gt; interimUsesCopy, List&lt;InterimProvidesDirective&gt; interimProvidesCopy) {
2905             this.currentModule = currentModule;
2906             this.interimUsesCopy = interimUsesCopy;
2907             this.interimProvidesCopy = interimProvidesCopy;
2908         }
2909 
2910         @Override
2911         public void complete(Symbol sym) throws CompletionFailure {
2912             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
2913             directives.addAll(currentModule.directives);
2914             ListBuffer&lt;UsesDirective&gt; uses = new ListBuffer&lt;&gt;();
2915             for (InterimUsesDirective interim : interimUsesCopy) {
2916                 UsesDirective d = new UsesDirective(syms.enterClass(currentModule, interim.service));
2917                 uses.add(d);
2918                 directives.add(d);
2919             }
2920             currentModule.uses = uses.toList();
2921             ListBuffer&lt;ProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
2922             for (InterimProvidesDirective interim : interimProvidesCopy) {
2923                 ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
2924                 for (Name impl : interim.impls) {
2925                     impls.append(syms.enterClass(currentModule, impl));
2926                 }
2927                 ProvidesDirective d = new ProvidesDirective(syms.enterClass(currentModule, interim.service),
2928                                                             impls.toList());
2929                 provides.add(d);
2930                 directives.add(d);
2931             }
2932             currentModule.provides = provides.toList();
2933             currentModule.directives = directives.toList();
2934         }
2935     }
2936 }
    </pre>
  </body>
</html>