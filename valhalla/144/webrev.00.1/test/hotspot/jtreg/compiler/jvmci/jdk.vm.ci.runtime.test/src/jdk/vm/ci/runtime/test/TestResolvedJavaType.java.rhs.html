<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestResolvedJavaType.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @requires vm.jvmci
  27  * @library ../../../../../
  28  * @modules java.base/jdk.internal.org.objectweb.asm
  29  *          java.base/jdk.internal.reflect
  30  *          jdk.internal.vm.ci/jdk.vm.ci.meta
  31  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
  32  *          jdk.internal.vm.ci/jdk.vm.ci.common
  33  *          java.base/jdk.internal.misc
  34  * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestResolvedJavaType
  35  */
  36 
  37 package jdk.vm.ci.runtime.test;
  38 
  39 import static java.lang.reflect.Modifier.isAbstract;
  40 import static java.lang.reflect.Modifier.isFinal;
  41 import static java.lang.reflect.Modifier.isPrivate;
  42 import static java.lang.reflect.Modifier.isProtected;
  43 import static java.lang.reflect.Modifier.isPublic;
  44 import static java.lang.reflect.Modifier.isStatic;
  45 import static org.junit.Assert.assertArrayEquals;
  46 import static org.junit.Assert.assertEquals;
  47 import static org.junit.Assert.assertFalse;
  48 import static org.junit.Assert.assertNotNull;
  49 import static org.junit.Assert.assertNull;
  50 import static org.junit.Assert.assertTrue;
  51 
  52 import java.io.DataInputStream;
  53 import java.io.IOException;
  54 import java.io.InputStream;
  55 import java.lang.annotation.Annotation;
  56 import java.lang.invoke.MethodHandles.Lookup;
  57 import java.lang.reflect.AccessibleObject;
  58 import java.lang.reflect.Constructor;
  59 import java.lang.reflect.Field;
  60 import java.lang.reflect.Method;
  61 import java.lang.reflect.Modifier;
  62 import java.util.Arrays;
  63 import java.util.Collections;
  64 import java.util.function.Supplier;
  65 import java.util.HashMap;
  66 import java.util.HashSet;
  67 import java.util.Map;
  68 import java.util.Set;
  69 
  70 import org.junit.Assert;
  71 import org.junit.Test;
  72 
  73 import jdk.internal.org.objectweb.asm.*;
  74 import jdk.internal.reflect.ConstantPool;
  75 import jdk.vm.ci.common.JVMCIError;
  76 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  77 import jdk.vm.ci.meta.JavaConstant;
  78 import jdk.vm.ci.meta.JavaKind;
  79 import jdk.vm.ci.meta.ResolvedJavaField;
  80 import jdk.vm.ci.meta.ResolvedJavaMethod;
  81 import jdk.vm.ci.meta.ResolvedJavaType;
  82 
  83 /**
  84  * Tests for {@link ResolvedJavaType}.
  85  */
  86 @SuppressWarnings(&quot;unchecked&quot;)
  87 public class TestResolvedJavaType extends TypeUniverse {
  88     private static final Class&lt;? extends Annotation&gt; SIGNATURE_POLYMORPHIC_CLASS = findPolymorphicSignatureClass();
  89 
  90     public TestResolvedJavaType() {
  91     }
  92 
  93     private static Class&lt;? extends Annotation&gt; findPolymorphicSignatureClass() {
  94         Class&lt;? extends Annotation&gt; signaturePolyAnnotation = null;
  95         try {
  96             for (Class&lt;?&gt; clazz : TestResolvedJavaType.class.getClassLoader().loadClass(&quot;java.lang.invoke.MethodHandle&quot;).getDeclaredClasses()) {
  97                 if (clazz.getName().endsWith(&quot;PolymorphicSignature&quot;) &amp;&amp; Annotation.class.isAssignableFrom(clazz)) {
  98                     signaturePolyAnnotation = (Class&lt;? extends Annotation&gt;) clazz;
  99                     break;
 100                 }
 101             }
 102         } catch (Throwable e) {
 103             throw new AssertionError(&quot;Could not find annotation PolymorphicSignature in java.lang.invoke.MethodHandle&quot;, e);
 104         }
 105         assertNotNull(signaturePolyAnnotation);
 106         return signaturePolyAnnotation;
 107     }
 108 
 109     @Test
 110     public void findInstanceFieldWithOffsetTest() {
 111         for (Class&lt;?&gt; c : classes) {
 112             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 113             Set&lt;Field&gt; reflectionFields = getInstanceFields(c, true);
 114             for (Field f : reflectionFields) {
 115                 ResolvedJavaField rf = lookupField(type.getInstanceFields(true), f);
 116                 assertNotNull(rf);
 117                 long offset = isStatic(f.getModifiers()) ? unsafe.staticFieldOffset(f) : unsafe.objectFieldOffset(f);
 118                 ResolvedJavaField result = type.findInstanceFieldWithOffset(offset, rf.getJavaKind());
 119                 assertNotNull(result);
 120                 assertTrue(fieldsEqual(f, result));
 121             }
 122         }
 123     }
 124 
 125     @Test
 126     public void isInterfaceTest() {
 127         for (Class&lt;?&gt; c : classes) {
 128             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 129             boolean expected = c.isInterface();
 130             boolean actual = type.isInterface();
 131             assertEquals(expected, actual);
 132         }
 133     }
 134 
 135     @Test
 136     public void isEnumTest() {
 137         for (Class&lt;?&gt; c : classes) {
 138             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 139             boolean expected = c.isEnum();
 140             boolean actual = type.isEnum();
 141             assertEquals(expected, actual);
 142         }
 143     }
 144 
 145     @Test
 146     public void isInstanceClassTest() {
 147         for (Class&lt;?&gt; c : classes) {
 148             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 149             boolean expected = !c.isArray() &amp;&amp; !c.isPrimitive() &amp;&amp; !c.isInterface();
 150             boolean actual = type.isInstanceClass();
 151             assertEquals(expected, actual);
 152         }
 153     }
 154 
 155     @Test
 156     public void isArrayTest() {
 157         for (Class&lt;?&gt; c : classes) {
 158             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 159             boolean expected = c.isArray();
 160             boolean actual = type.isArray();
 161             assertEquals(expected, actual);
 162         }
 163     }
 164 
 165     private static Class&lt;?&gt; anonClass() throws Exception {
 166         ClassWriter cw = new ClassWriter(0);
 167         cw.visit(Opcodes.V1_8, Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, &quot;Anon&quot;, null, &quot;java/lang/Object&quot;, null);
 168         FieldVisitor intField = cw.visitField(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, &quot;intField&quot;, &quot;I&quot;, null, 0);
 169         intField.visitEnd();
 170         cw.visitEnd();
 171         return unsafe.defineAnonymousClass(TypeUniverse.class, cw.toByteArray(), null);
 172     }
 173 
 174     @Test
 175     public void getHostClassTest() throws Exception {
 176         ResolvedJavaType type = metaAccess.lookupJavaType(anonClass());
 177         ResolvedJavaType host = type.getHostClass();
 178         assertNotNull(host);
 179         for (Class&lt;?&gt; c : classes) {
 180             type = metaAccess.lookupJavaType(c);
 181             host = type.getHostClass();
 182             assertNull(host);
 183             if (type.equals(predicateType)) {
 184                 assertTrue(c.isHidden());
 185             }
 186         }
 187 
 188         class LocalClass {}
 189         Cloneable clone = new Cloneable() {};
 190         assertNull(metaAccess.lookupJavaType(LocalClass.class).getHostClass());
 191         assertNull(metaAccess.lookupJavaType(clone.getClass()).getHostClass());
 192 
 193         Supplier&lt;Runnable&gt; lambda = () -&gt; () -&gt; System.out.println(&quot;run&quot;);
 194         ResolvedJavaType lambdaType = metaAccess.lookupJavaType(lambda.getClass());
 195         ResolvedJavaType nestedLambdaType = metaAccess.lookupJavaType(lambda.get().getClass());
 196         assertNull(lambdaType.getHostClass());
 197         assertTrue(lambda.getClass().isHidden());
 198         assertNull(nestedLambdaType.getHostClass());
 199         assertTrue(lambda.get().getClass().isHidden());
 200     }
 201 
 202     @Test
 203     public void getModifiersTest() {
 204         for (Class&lt;?&gt; c : classes) {
 205             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 206             int mask = Modifier.classModifiers() &amp; ~Modifier.STATIC;
 207             int expected = c.getModifiers() &amp; mask;
 208             int actual = type.getModifiers() &amp; mask;
 209             Class&lt;?&gt; elementalType = c;
 210             while (elementalType.isArray()) {
 211                 elementalType = elementalType.getComponentType();
 212             }
 213             if (elementalType.isMemberClass()) {
 214                 // member class get their modifiers from the inner-class attribute in the JVM and
 215                 // from the classfile header in jvmci
 216                 expected &amp;= ~(Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED);
 217                 actual &amp;= ~(Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED);
 218             }
 219             assertEquals(String.format(&quot;%s: 0x%x != 0x%x&quot;, type, expected, actual), expected, actual);
 220         }
 221     }
 222 
 223     @Test
 224     public void isAssignableFromTest() {
 225         Class&lt;?&gt;[] all = classes.toArray(new Class&lt;?&gt;[classes.size()]);
 226         for (int i = 0; i &lt; all.length; i++) {
 227             Class&lt;?&gt; c1 = all[i];
 228             for (int j = i; j &lt; all.length; j++) {
 229                 Class&lt;?&gt; c2 = all[j];
 230                 ResolvedJavaType t1 = metaAccess.lookupJavaType(c1);
 231                 ResolvedJavaType t2 = metaAccess.lookupJavaType(c2);
 232                 boolean expected = c1.isAssignableFrom(c2);
 233                 boolean actual = t1.isAssignableFrom(t2);
 234                 assertEquals(expected, actual);
 235                 if (expected &amp;&amp; t1 != t2) {
 236                     assertFalse(t2.isAssignableFrom(t1));
 237                 }
 238             }
 239         }
 240     }
 241 
 242     @Test
 243     public void isInstanceTest() {
 244         for (ConstantValue cv : constants()) {
 245             JavaConstant c = cv.value;
 246             if (c.getJavaKind() == JavaKind.Object &amp;&amp; !c.isNull()) {
 247                 ResolvedJavaType cType = metaAccess.lookupJavaType(c);
 248                 for (ResolvedJavaType t : javaTypes) {
 249                     if (t.isAssignableFrom(cType)) {
 250                         assertTrue(t.isInstance(c));
 251                     } else {
 252                         assertFalse(t.isInstance(c));
 253                     }
 254                 }
 255             }
 256         }
 257     }
 258 
 259     @Test
 260     public void getSuperclassTest() {
 261         for (Class&lt;?&gt; c : classes) {
 262             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 263             Class&lt;?&gt; expected = c.getSuperclass();
 264             ResolvedJavaType actual = type.getSuperclass();
 265             if (expected == null) {
 266                 assertTrue(actual == null);
 267             } else {
 268                 assertNotNull(actual);
 269                 assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 270             }
 271         }
 272     }
 273 
 274     @Test
 275     public void getInterfacesTest() {
 276         for (Class&lt;?&gt; c : classes) {
 277             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 278             Class&lt;?&gt;[] expected = c.getInterfaces();
 279             ResolvedJavaType[] actual = type.getInterfaces();
<a name="1" id="anc1"></a><span class="line-modified"> 280             // With injection of the IdentityObject interface by the JVM, the number of</span>
<span class="line-added"> 281             // interfaces visible through reflection and through JVMCI could differ by one</span>
<span class="line-added"> 282             assertTrue(expected.length == actual.length || (actual.length - expected.length) == 1);</span>
 283             for (int i = 0; i &lt; expected.length; i++) {
 284                 assertTrue(actual[i].equals(metaAccess.lookupJavaType(expected[i])));
 285             }
 286         }
 287     }
 288 
 289     public Class&lt;?&gt; getSupertype(Class&lt;?&gt; c) {
 290         assert !c.isPrimitive();
 291         if (c.isArray()) {
 292             Class&lt;?&gt; componentType = c.getComponentType();
 293             if (componentType.isPrimitive() || componentType == Object.class) {
 294                 return Object.class;
 295             }
 296             return getArrayClass(getSupertype(componentType));
 297         }
 298         if (c.isInterface()) {
 299             return Object.class;
 300         }
 301         return c.getSuperclass();
 302     }
 303 
 304     public Class&lt;?&gt; findLeastCommonAncestor(Class&lt;?&gt; c1Initial, Class&lt;?&gt; c2Initial) {
 305         if (c1Initial.isPrimitive() || c2Initial.isPrimitive()) {
 306             return null;
 307         } else {
 308             Class&lt;?&gt; c1 = c1Initial;
 309             Class&lt;?&gt; c2 = c2Initial;
 310             while (true) {
 311                 if (c1.isAssignableFrom(c2)) {
 312                     return c1;
 313                 }
 314                 if (c2.isAssignableFrom(c1)) {
 315                     return c2;
 316                 }
 317                 c1 = getSupertype(c1);
 318                 c2 = getSupertype(c2);
 319             }
 320         }
 321     }
 322 
 323     @Test
 324     public void findLeastCommonAncestorTest() {
 325         Class&lt;?&gt;[] all = classes.toArray(new Class&lt;?&gt;[classes.size()]);
 326         for (int i = 0; i &lt; all.length; i++) {
 327             Class&lt;?&gt; c1 = all[i];
 328             for (int j = i; j &lt; all.length; j++) {
 329                 Class&lt;?&gt; c2 = all[j];
 330                 ResolvedJavaType t1 = metaAccess.lookupJavaType(c1);
 331                 ResolvedJavaType t2 = metaAccess.lookupJavaType(c2);
 332                 Class&lt;?&gt; expected = findLeastCommonAncestor(c1, c2);
 333                 ResolvedJavaType actual = t1.findLeastCommonAncestor(t2);
 334                 if (expected == null) {
 335                     assertTrue(actual == null);
 336                 } else {
 337                     assertNotNull(actual);
 338                     assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 339                 }
 340             }
 341         }
 342     }
 343 
 344     @Test
 345     public void linkTest() {
 346         for (Class&lt;?&gt; c : classes) {
 347             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 348             type.link();
 349         }
 350     }
 351 
 352     private class HidingClassLoader extends ClassLoader {
 353         @Override
 354         protected Class&lt;?&gt; findClass(final String name) throws ClassNotFoundException {
 355             if (name.endsWith(&quot;MissingInterface&quot;)) {
 356                 throw new ClassNotFoundException(&quot;missing&quot;);
 357             }
 358             byte[] classData = null;
 359             try {
 360                 InputStream is = HidingClassLoader.class.getResourceAsStream(&quot;/&quot; + name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);
 361                 classData = new byte[is.available()];
 362                 new DataInputStream(is).readFully(classData);
 363             } catch (IOException e) {
 364                 Assert.fail(&quot;can&#39;t access class: &quot; + name);
 365             }
 366 
 367             return defineClass(null, classData, 0, classData.length);
 368         }
 369 
 370         ResolvedJavaType lookupJavaType(String name) throws ClassNotFoundException {
 371             return metaAccess.lookupJavaType(loadClass(name));
 372         }
 373 
 374         HidingClassLoader() {
 375             super(null);
 376         }
 377 
 378     }
 379 
 380     interface MissingInterface {
 381     }
 382 
 383     static class MissingInterfaceImpl implements MissingInterface {
 384     }
 385 
 386     interface SomeInterface {
 387         default MissingInterface someMethod() {
 388             return new MissingInterfaceImpl();
 389         }
 390     }
 391 
 392     static class Wrapper implements SomeInterface {
 393     }
 394 
 395     @Test
 396     public void linkExceptionTest() throws ClassNotFoundException {
 397         HidingClassLoader cl = new HidingClassLoader();
 398         ResolvedJavaType inner = cl.lookupJavaType(Wrapper.class.getName());
 399         assertTrue(&quot;expected default methods&quot;, inner.hasDefaultMethods());
 400         try {
 401             inner.link();
 402             assertFalse(&quot;link should throw an exception&quot;, true);
 403         } catch (NoClassDefFoundError e) {
 404         }
 405     }
 406 
 407     @Test
 408     public void hasDefaultMethodsTest() {
 409         for (Class&lt;?&gt; c : classes) {
 410             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 411             assertEquals(hasDefaultMethods(type), type.hasDefaultMethods());
 412         }
 413     }
 414 
 415     @Test
 416     public void declaresDefaultMethodsTest() {
 417         for (Class&lt;?&gt; c : classes) {
 418             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 419             assertEquals(declaresDefaultMethods(type), type.declaresDefaultMethods());
 420         }
 421     }
 422 
 423     private static boolean hasDefaultMethods(ResolvedJavaType type) {
 424         if (!type.isInterface() &amp;&amp; type.getSuperclass() != null &amp;&amp; hasDefaultMethods(type.getSuperclass())) {
 425             return true;
 426         }
 427         for (ResolvedJavaType iface : type.getInterfaces()) {
 428             if (hasDefaultMethods(iface)) {
 429                 return true;
 430             }
 431         }
 432         return declaresDefaultMethods(type);
 433     }
 434 
 435     static boolean declaresDefaultMethods(ResolvedJavaType type) {
 436         if (!type.isInterface()) {
 437             /* Only interfaces can declare default methods. */
 438             return false;
 439         }
 440         for (ResolvedJavaMethod method : type.getDeclaredMethods()) {
 441             if (method.isDefault()) {
 442                 assert !Modifier.isStatic(method.getModifiers()) : &quot;Default method that is static?&quot;;
 443                 return true;
 444             }
 445         }
 446         return false;
 447     }
 448 
 449     private static class Base {
 450     }
 451 
 452     abstract static class Abstract1 extends Base {
 453     }
 454 
 455     interface Interface1 {
 456     }
 457 
 458     static class Concrete1 extends Abstract1 {
 459     }
 460 
 461     static class Concrete2 extends Abstract1 implements Interface1 {
 462     }
 463 
 464     static class Concrete3 extends Concrete2 {
 465     }
 466 
 467     static final class Final1 extends Abstract1 {
 468     }
 469 
 470     abstract static class Abstract4 extends Concrete3 {
 471     }
 472 
 473     void checkConcreteSubtype(ResolvedJavaType type, ResolvedJavaType expected) {
 474         AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = type.findLeafConcreteSubtype();
 475         if (leafConcreteSubtype == null) {
 476             // findLeafConcreteSubtype() is conservative
 477         } else {
 478             if (expected == null) {
 479                 assertNull(leafConcreteSubtype);
 480             } else {
 481                 assertTrue(leafConcreteSubtype.getResult().equals(expected));
 482             }
 483             assertTrue(!type.isLeaf() || leafConcreteSubtype.isAssumptionFree());
 484         }
 485 
 486         if (!type.isArray()) {
 487             ResolvedJavaType arrayType = type.getArrayClass();
 488             AssumptionResult&lt;ResolvedJavaType&gt; arraySubtype = arrayType.findLeafConcreteSubtype();
 489             if (arraySubtype != null) {
 490                 assertEquals(arraySubtype.getResult(), arrayType);
 491             } else {
 492                 // findLeafConcreteSubtype() method is conservative
 493             }
 494         }
 495     }
 496 
 497     @Test
 498     public void findLeafConcreteSubtypeTest() {
 499         ResolvedJavaType base = metaAccess.lookupJavaType(Base.class);
 500         checkConcreteSubtype(base, base);
 501 
 502         ResolvedJavaType a1 = metaAccess.lookupJavaType(Abstract1.class);
 503         ResolvedJavaType c1 = metaAccess.lookupJavaType(Concrete1.class);
 504 
 505         checkConcreteSubtype(base, null);
 506         checkConcreteSubtype(a1, c1);
 507         checkConcreteSubtype(c1, c1);
 508 
 509         ResolvedJavaType i1 = metaAccess.lookupJavaType(Interface1.class);
 510         ResolvedJavaType c2 = metaAccess.lookupJavaType(Concrete2.class);
 511 
 512         checkConcreteSubtype(base, null);
 513         checkConcreteSubtype(a1, null);
 514         checkConcreteSubtype(c1, c1);
 515         checkConcreteSubtype(i1, c2);
 516         checkConcreteSubtype(c2, c2);
 517 
 518         ResolvedJavaType c3 = metaAccess.lookupJavaType(Concrete3.class);
 519         checkConcreteSubtype(c2, null);
 520         checkConcreteSubtype(c3, c3);
 521 
 522         ResolvedJavaType a4 = metaAccess.lookupJavaType(Abstract4.class);
 523         checkConcreteSubtype(c3, null);
 524         checkConcreteSubtype(a4, null);
 525 
 526         ResolvedJavaType a1a = metaAccess.lookupJavaType(Abstract1[].class);
 527         checkConcreteSubtype(a1a, null);
 528         ResolvedJavaType i1a = metaAccess.lookupJavaType(Interface1[].class);
 529         checkConcreteSubtype(i1a, null);
 530         ResolvedJavaType c1a = metaAccess.lookupJavaType(Concrete1[].class);
 531         checkConcreteSubtype(c1a, c1a);
 532         ResolvedJavaType f1a = metaAccess.lookupJavaType(Final1[].class);
 533         checkConcreteSubtype(f1a, f1a);
 534 
 535         ResolvedJavaType obja = metaAccess.lookupJavaType(Object[].class);
 536         checkConcreteSubtype(obja, null);
 537 
 538         ResolvedJavaType inta = metaAccess.lookupJavaType(int[].class);
 539         checkConcreteSubtype(inta, inta);
 540     }
 541 
 542     interface NoImplementor {
 543     }
 544 
 545     interface SingleImplementorInterface {
 546     }
 547 
 548     static class SingleConcreteImplementor implements SingleImplementorInterface {
 549     }
 550 
 551     interface SingleAbstractImplementorInterface {
 552     }
 553 
 554     abstract static class SingleAbstractImplementor implements SingleAbstractImplementorInterface {
 555     }
 556 
 557     interface MultiImplementorInterface {
 558     }
 559 
 560     static class ConcreteImplementor1 implements MultiImplementorInterface {
 561     }
 562 
 563     static class ConcreteImplementor2 implements MultiImplementorInterface {
 564     }
 565 
 566     interface MultipleAbstractImplementorInterface {
 567     }
 568 
 569     abstract static class MultiAbstractImplementor1 implements MultipleAbstractImplementorInterface {
 570     }
 571 
 572     abstract static class MultiAbstractImplementor2 implements MultipleAbstractImplementorInterface {
 573     }
 574 
 575     interface SingleAbstractImplementorInterface2 {
 576     }
 577 
 578     interface ExtendedSingleImplementorInterface {
 579     }
 580 
 581     abstract static class SingleAbstractImplementor2 implements SingleAbstractImplementorInterface2 {
 582     }
 583 
 584     static class ConcreteTransitiveImplementor1 extends SingleAbstractImplementor2 implements ExtendedSingleImplementorInterface {
 585     }
 586 
 587     static class ConcreteTransitiveImplementor2 extends SingleAbstractImplementor2 implements ExtendedSingleImplementorInterface {
 588     }
 589 
 590     @Test
 591     public void getSingleImplementorTest() {
 592         ResolvedJavaType iNi = metaAccess.lookupJavaType(NoImplementor.class);
 593         assertNull(iNi.getSingleImplementor());
 594 
 595         ResolvedJavaType iSi = metaAccess.lookupJavaType(SingleImplementorInterface.class);
 596         ResolvedJavaType cSi = metaAccess.lookupJavaType(SingleConcreteImplementor.class);
 597         assertEquals(cSi, iSi.getSingleImplementor());
 598 
 599         ResolvedJavaType iSai = metaAccess.lookupJavaType(SingleAbstractImplementorInterface.class);
 600         ResolvedJavaType aSai = metaAccess.lookupJavaType(SingleAbstractImplementor.class);
 601         assertEquals(aSai, iSai.getSingleImplementor());
 602 
 603         ResolvedJavaType iMi = metaAccess.lookupJavaType(MultiImplementorInterface.class);
 604         metaAccess.lookupJavaType(ConcreteImplementor1.class);
 605         metaAccess.lookupJavaType(ConcreteImplementor2.class);
 606         assertEquals(iMi, iMi.getSingleImplementor());
 607 
 608         ResolvedJavaType iMai = metaAccess.lookupJavaType(MultipleAbstractImplementorInterface.class);
 609         metaAccess.lookupJavaType(MultiAbstractImplementor1.class);
 610         metaAccess.lookupJavaType(MultiAbstractImplementor2.class);
 611         assertEquals(iMai, iMai.getSingleImplementor());
 612 
 613         ResolvedJavaType iSai2 = metaAccess.lookupJavaType(SingleAbstractImplementorInterface2.class);
 614         ResolvedJavaType aSai2 = metaAccess.lookupJavaType(SingleAbstractImplementor2.class);
 615         metaAccess.lookupJavaType(ConcreteTransitiveImplementor1.class);
 616         metaAccess.lookupJavaType(ConcreteTransitiveImplementor2.class);
 617         assertEquals(aSai2, iSai2.getSingleImplementor());
 618 
 619         for (Class&lt;?&gt; c : classes) {
 620             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 621             try {
 622                 type.getSingleImplementor();
 623                 if (!c.isInterface()) {
 624                     throw new AssertionError(&quot;Expected exception for calling getSingleImplmentor on &quot; + c.getName());
 625                 }
 626             } catch (JVMCIError e) {
 627                 if (c.isInterface()) {
 628                     throw new AssertionError(&quot;Unexpected exception&quot;, e);
 629                 }
 630             }
 631         }
 632     }
 633 
 634     @Test(expected = JVMCIError.class)
 635     public void getSingleImplementorTestClassReceiver() {
 636         ResolvedJavaType base = metaAccess.lookupJavaType(Base.class);
 637         base.getSingleImplementor();
 638     }
 639 
 640     @Test(expected = JVMCIError.class)
 641     public void getSingleImplementorTestPrimitiveReceiver() {
 642         ResolvedJavaType primitive = metaAccess.lookupJavaType(int.class);
 643         primitive.getSingleImplementor();
 644     }
 645 
 646     @Test
 647     public void getComponentTypeTest() {
 648         for (Class&lt;?&gt; c : classes) {
 649             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 650             Class&lt;?&gt; expected = c.getComponentType();
 651             ResolvedJavaType actual = type.getComponentType();
 652             if (expected == null) {
 653                 assertNull(actual);
 654             } else {
 655                 assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 656             }
 657         }
 658     }
 659 
 660     @Test
 661     public void getArrayClassTest() {
 662         for (Class&lt;?&gt; c : classes) {
 663             if (c != void.class) {
 664                 ResolvedJavaType type = metaAccess.lookupJavaType(c);
 665                 Class&lt;?&gt; expected = getArrayClass(c);
 666                 ResolvedJavaType actual = type.getArrayClass();
 667                 assertTrue(actual.equals(metaAccess.lookupJavaType(expected)));
 668             }
 669         }
 670     }
 671 
 672     static class Declarations {
 673 
 674         final Method implementation;
 675         final Set&lt;Method&gt; declarations;
 676 
 677         Declarations(Method impl) {
 678             this.implementation = impl;
 679             declarations = new HashSet&lt;&gt;();
 680         }
 681     }
 682 
 683     /**
 684      * See &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.5&quot;&gt;Method
 685      * overriding&lt;/a&gt;.
 686      */
 687     static boolean isOverriderOf(Method impl, Method m) {
 688         if (!isPrivate(m.getModifiers()) &amp;&amp; !isFinal(m.getModifiers())) {
 689             if (m.getName().equals(impl.getName())) {
 690                 if (m.getReturnType() == impl.getReturnType()) {
 691                     if (Arrays.equals(m.getParameterTypes(), impl.getParameterTypes())) {
 692                         if (isPublic(m.getModifiers()) || isProtected(m.getModifiers())) {
 693                             // m is public or protected
 694                             return isPublic(impl.getModifiers()) || isProtected(impl.getModifiers());
 695                         } else {
 696                             // m is package-private
 697                             return impl.getDeclaringClass().getPackage() == m.getDeclaringClass().getPackage();
 698                         }
 699                     }
 700                 }
 701             }
 702         }
 703         return false;
 704     }
 705 
 706     static final Map&lt;Class&lt;?&gt;, VTable&gt; vtables = new HashMap&lt;&gt;();
 707 
 708     static class VTable {
 709 
 710         final Map&lt;NameAndSignature, Method&gt; methods = new HashMap&lt;&gt;();
 711     }
 712 
 713     static synchronized VTable getVTable(Class&lt;?&gt; c) {
 714         VTable vtable = vtables.get(c);
 715         if (vtable == null) {
 716             vtable = new VTable();
 717             if (c != Object.class) {
 718                 VTable superVtable = getVTable(c.getSuperclass());
 719                 vtable.methods.putAll(superVtable.methods);
 720             }
 721             for (Method m : c.getDeclaredMethods()) {
 722                 if (!isStatic(m.getModifiers()) &amp;&amp; !isPrivate(m.getModifiers())) {
 723                     if (isAbstract(m.getModifiers())) {
 724                         // A subclass makes a concrete method in a superclass abstract
 725                         vtable.methods.remove(new NameAndSignature(m));
 726                     } else {
 727                         vtable.methods.put(new NameAndSignature(m), m);
 728                     }
 729                 }
 730             }
 731             vtables.put(c, vtable);
 732         }
 733         return vtable;
 734     }
 735 
 736     static Set&lt;Method&gt; findDeclarations(Method impl, Class&lt;?&gt; c) {
 737         Set&lt;Method&gt; declarations = new HashSet&lt;&gt;();
 738         NameAndSignature implSig = new NameAndSignature(impl);
 739         if (c != null) {
 740             for (Method m : c.getDeclaredMethods()) {
 741                 if (new NameAndSignature(m).equals(implSig)) {
 742                     declarations.add(m);
 743                     break;
 744                 }
 745             }
 746             if (!c.isInterface()) {
 747                 declarations.addAll(findDeclarations(impl, c.getSuperclass()));
 748             }
 749             for (Class&lt;?&gt; i : c.getInterfaces()) {
 750                 declarations.addAll(findDeclarations(impl, i));
 751             }
 752         }
 753         return declarations;
 754     }
 755 
 756     @Test
 757     public void resolveMethodTest() {
 758         ResolvedJavaType context = metaAccess.lookupJavaType(TestResolvedJavaType.class);
 759         for (Class&lt;?&gt; c : classes) {
 760             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 761             if (c.isInterface()) {
 762                 for (Method m : c.getDeclaredMethods()) {
 763                     ResolvedJavaMethod resolved = metaAccess.lookupJavaMethod(m);
 764                     ResolvedJavaMethod impl = type.resolveMethod(resolved, context);
 765                     assertEquals(m.toString(), null, impl);
 766                 }
 767             } else if (c.isPrimitive()) {
 768                 assertEquals(&quot;No methods expected&quot;, c.getDeclaredMethods().length, 0);
 769             } else {
 770                 VTable vtable = getVTable(c);
 771                 for (Method impl : vtable.methods.values()) {
 772                     Set&lt;Method&gt; decls = findDeclarations(impl, c);
 773                     for (Method decl : decls) {
 774                         ResolvedJavaMethod m = metaAccess.lookupJavaMethod(decl);
 775                         if (m.isPublic()) {
 776                             ResolvedJavaMethod resolvedmethod = type.resolveMethod(m, context);
 777                             if (isSignaturePolymorphic(m)) {
 778                                 // Signature polymorphic methods must not be resolved
 779                                 assertNull(resolvedmethod);
 780                             } else {
 781                                 ResolvedJavaMethod i = metaAccess.lookupJavaMethod(impl);
 782                                 assertEquals(m.toString(), i, resolvedmethod);
 783                             }
 784                         }
 785                     }
 786                 }
 787             }
 788         }
 789     }
 790 
 791     @Test
 792     public void resolveConcreteMethodTest() {
 793         ResolvedJavaType context = metaAccess.lookupJavaType(TestResolvedJavaType.class);
 794         for (Class&lt;?&gt; c : classes) {
 795             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 796             if (c.isInterface()) {
 797                 for (Method m : c.getDeclaredMethods()) {
 798                     ResolvedJavaMethod resolved = metaAccess.lookupJavaMethod(m);
 799                     ResolvedJavaMethod impl = type.resolveConcreteMethod(resolved, context);
 800                     assertEquals(m.toString(), null, impl);
 801                 }
 802             } else if (c.isPrimitive()) {
 803                 assertEquals(&quot;No methods expected&quot;, c.getDeclaredMethods().length, 0);
 804             } else {
 805                 VTable vtable = getVTable(c);
 806                 for (Method impl : vtable.methods.values()) {
 807                     Set&lt;Method&gt; decls = findDeclarations(impl, c);
 808                     for (Method decl : decls) {
 809                         ResolvedJavaMethod m = metaAccess.lookupJavaMethod(decl);
 810                         if (m.isPublic()) {
 811                             ResolvedJavaMethod resolvedMethod = type.resolveConcreteMethod(m, context);
 812                             if (isSignaturePolymorphic(m)) {
 813                                 // Signature polymorphic methods must not be resolved
 814                                 assertNull(String.format(&quot;Got: %s&quot;, resolvedMethod), resolvedMethod);
 815                             } else {
 816                                 ResolvedJavaMethod i = metaAccess.lookupJavaMethod(impl);
 817                                 assertEquals(i, resolvedMethod);
 818                             }
 819                         }
 820                     }
 821                 }
 822                 for (Method m : c.getDeclaredMethods()) {
 823                     ResolvedJavaMethod impl = type.resolveConcreteMethod(metaAccess.lookupJavaMethod(m), context);
 824                     ResolvedJavaMethod expected = isAbstract(m.getModifiers()) ? null : impl;
 825                     assertEquals(type + &quot; &quot; + m.toString(), expected, impl);
 826                 }
 827             }
 828         }
 829     }
 830 
 831     @Test
 832     public void findUniqueConcreteMethodTest() throws NoSuchMethodException {
 833         ResolvedJavaMethod thisMethod = metaAccess.lookupJavaMethod(getClass().getDeclaredMethod(&quot;findUniqueConcreteMethodTest&quot;));
 834         ResolvedJavaMethod ucm = metaAccess.lookupJavaType(getClass()).findUniqueConcreteMethod(thisMethod).getResult();
 835         assertEquals(thisMethod, ucm);
 836     }
 837 
 838     public static Set&lt;Field&gt; getInstanceFields(Class&lt;?&gt; c, boolean includeSuperclasses) {
 839         if (c.isArray() || c.isPrimitive() || c.isInterface()) {
 840             return Collections.emptySet();
 841         }
 842         Set&lt;Field&gt; result = new HashSet&lt;&gt;();
 843         for (Field f : c.getDeclaredFields()) {
 844             if (!Modifier.isStatic(f.getModifiers())) {
 845                 result.add(f);
 846             }
 847         }
 848         if (includeSuperclasses &amp;&amp; c != Object.class) {
 849             result.addAll(getInstanceFields(c.getSuperclass(), true));
 850         }
 851         return result;
 852     }
 853 
 854     public static Set&lt;Field&gt; getStaticFields(Class&lt;?&gt; c) {
 855         Set&lt;Field&gt; result = new HashSet&lt;&gt;();
 856         for (Field f : c.getDeclaredFields()) {
 857             if (Modifier.isStatic(f.getModifiers())) {
 858                 result.add(f);
 859             }
 860         }
 861         return result;
 862     }
 863 
 864     public boolean fieldsEqual(Field f, ResolvedJavaField rjf) {
 865         return rjf.getDeclaringClass().equals(metaAccess.lookupJavaType(f.getDeclaringClass())) &amp;&amp; rjf.getName().equals(f.getName()) &amp;&amp;
 866                         rjf.getType().resolve(rjf.getDeclaringClass()).equals(metaAccess.lookupJavaType(f.getType()));
 867     }
 868 
 869     public ResolvedJavaField lookupField(ResolvedJavaField[] fields, Field key) {
 870         for (ResolvedJavaField rf : fields) {
 871             if (fieldsEqual(key, rf)) {
 872                 return rf;
 873             }
 874         }
 875         return null;
 876     }
 877 
 878     public Field lookupField(Set&lt;Field&gt; fields, ResolvedJavaField key) {
 879         for (Field f : fields) {
 880             if (fieldsEqual(f, key)) {
 881                 return f;
 882             }
 883         }
 884         return null;
 885     }
 886 
 887     private static boolean isHiddenFromReflection(ResolvedJavaField f) {
 888         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Throwable.class)) &amp;&amp; f.getName().equals(&quot;backtrace&quot;)) {
 889             return true;
 890         }
 891         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(ConstantPool.class)) &amp;&amp; f.getName().equals(&quot;constantPoolOop&quot;)) {
 892             return true;
 893         }
 894         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Class.class))) {
 895             return f.getName().equals(&quot;classLoader&quot;) || f.getName().equals(&quot;classData&quot;);
 896         }
 897         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Lookup.class))) {
 898             return f.getName().equals(&quot;allowedModes&quot;) || f.getName().equals(&quot;lookupClass&quot;);
 899         }
 900         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(ClassLoader.class)) ||
 901             f.getDeclaringClass().equals(metaAccess.lookupJavaType(AccessibleObject.class)) ||
 902             f.getDeclaringClass().equals(metaAccess.lookupJavaType(Constructor.class)) ||
 903             f.getDeclaringClass().equals(metaAccess.lookupJavaType(Field.class)) ||
 904             f.getDeclaringClass().equals(metaAccess.lookupJavaType(Method.class)) ||
 905             f.getDeclaringClass().equals(metaAccess.lookupJavaType(Module.class))) {
 906             return true;
 907         }
 908         return false;
 909     }
 910 
 911     @Test
 912     public void getInstanceFieldsTest() {
 913         for (Class&lt;?&gt; c : classes) {
 914             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 915             for (boolean includeSuperclasses : new boolean[]{true, false}) {
 916                 Set&lt;Field&gt; expected = getInstanceFields(c, includeSuperclasses);
 917                 ResolvedJavaField[] actual = type.getInstanceFields(includeSuperclasses);
 918                 for (Field f : expected) {
 919                     assertNotNull(lookupField(actual, f));
 920                 }
 921                 for (ResolvedJavaField rf : actual) {
 922                     if (!isHiddenFromReflection(rf)) {
 923                         assertEquals(rf.toString(), lookupField(expected, rf) != null, !rf.isInternal());
 924                     }
 925                 }
 926 
 927                 // Test stability of getInstanceFields
 928                 ResolvedJavaField[] actual2 = type.getInstanceFields(includeSuperclasses);
 929                 assertArrayEquals(actual, actual2);
 930             }
 931         }
 932     }
 933 
 934     @Test
 935     public void getStaticFieldsTest() {
 936         for (Class&lt;?&gt; c : classes) {
 937             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 938             Set&lt;Field&gt; expected = getStaticFields(c);
 939             ResolvedJavaField[] actual = type.getStaticFields();
 940             for (Field f : expected) {
 941                 assertNotNull(lookupField(actual, f));
 942             }
 943             for (ResolvedJavaField rf : actual) {
 944                 if (!isHiddenFromReflection(rf)) {
 945                     assertEquals(lookupField(expected, rf) != null, !rf.isInternal());
 946                 }
 947             }
 948 
 949             // Test stability of getStaticFields
 950             ResolvedJavaField[] actual2 = type.getStaticFields();
 951             assertArrayEquals(actual, actual2);
 952         }
 953     }
 954 
 955     @Test
 956     public void getDeclaredMethodsTest() {
 957         for (Class&lt;?&gt; c : classes) {
 958             ResolvedJavaType type = metaAccess.lookupJavaType(c);
 959             Method[] raw = c.getDeclaredMethods();
 960             Set&lt;ResolvedJavaMethod&gt; expected = new HashSet&lt;&gt;();
 961             for (Method m : raw) {
 962                 ResolvedJavaMethod resolvedMethod = metaAccess.lookupJavaMethod(m);
 963                 assertNotNull(resolvedMethod);
 964                 expected.add(resolvedMethod);
 965             }
 966             Set&lt;ResolvedJavaMethod&gt; actual = new HashSet&lt;&gt;(Arrays.asList(type.getDeclaredMethods()));
 967             assertEquals(expected, actual);
 968         }
 969     }
 970 
 971     static class A {
 972         static String name = &quot;foo&quot;;
 973     }
 974 
 975     static class B extends A {
 976     }
 977 
 978     static class C {
 979     }
 980 
 981     static class D {
 982         void foo() {
 983             // use of assertions causes the class to have a &lt;clinit&gt;
 984             assert getClass() != null;
 985         }
 986     }
 987 
 988     static class SubD extends D {
 989 
 990     }
 991 
 992     private static ResolvedJavaMethod getClassInitializer(Class&lt;?&gt; c) {
 993         ResolvedJavaMethod clinit = metaAccess.lookupJavaType(c).getClassInitializer();
 994         if (clinit != null) {
 995             assertEquals(0, clinit.getAnnotations().length);
 996             assertEquals(0, clinit.getDeclaredAnnotations().length);
 997         }
 998         return clinit;
 999     }
1000 
1001     @Test
1002     public void getClassInitializerTest() {
1003         assertNotNull(getClassInitializer(A.class));
1004         assertNotNull(getClassInitializer(D.class));
1005         assertNull(getClassInitializer(B.class));
1006         assertNull(getClassInitializer(C.class));
1007         assertNull(getClassInitializer(int.class));
1008         assertNull(getClassInitializer(void.class));
1009         for (Class&lt;?&gt; c : classes) {
1010             getClassInitializer(c);
1011         }
1012     }
1013 
1014     @Test
1015     public void getAnnotationsTest() {
1016         for (Class&lt;?&gt; c : classes) {
1017             ResolvedJavaType type = metaAccess.lookupJavaType(c);
1018             assertArrayEquals(c.getAnnotations(), type.getAnnotations());
1019         }
1020     }
1021 
1022     @Test
1023     public void getAnnotationTest() {
1024         for (Class&lt;?&gt; c : classes) {
1025             ResolvedJavaType type = metaAccess.lookupJavaType(c);
1026             for (Annotation a : c.getAnnotations()) {
1027                 assertEquals(a, type.getAnnotation(a.annotationType()));
1028             }
1029         }
1030     }
1031 
1032     @Test
1033     public void getSourceFileNameTest() {
1034         Class&lt;?&gt; c = Object.class;
1035         ResolvedJavaType type = metaAccess.lookupJavaType(c);
1036         assertEquals(type.getSourceFileName(), &quot;Object.java&quot;);
1037     }
1038 
1039     @Test
1040     public void memberClassesTest() {
1041         for (Class&lt;?&gt; c : classes) {
1042             ResolvedJavaType type = metaAccess.lookupJavaType(c);
1043             assertEquals(c.isLocalClass(), type.isLocal());
1044             assertEquals(c.isMemberClass(), type.isMember());
1045             Class&lt;?&gt; enclc = c.getEnclosingClass();
1046             ResolvedJavaType enclt = type.getEnclosingType();
1047             assertFalse(enclc == null ^ enclt == null);
1048             if (enclc != null) {
1049                 assertEquals(enclt, metaAccess.lookupJavaType(enclc));
1050             }
1051         }
1052     }
1053 
1054     @Test
1055     public void isLeafTest() {
1056         for (Class&lt;?&gt; c : classes) {
1057             ResolvedJavaType type = metaAccess.lookupJavaType(c);
1058             ResolvedJavaType arrayType = c != void.class ? metaAccess.lookupJavaType(getArrayClass(c)) : null;
1059             if (c.isPrimitive()) {
1060                 assertTrue(type.isLeaf());
1061                 assertTrue(arrayType == null || arrayType.isLeaf());
1062             } else {
1063                 assertTrue(c.toString(), type.isLeaf() == arrayType.isLeaf());
1064                 if (!c.isArray()) {
1065                     assertTrue(c.toString(), type.isLeaf() == Modifier.isFinal(c.getModifiers()));
1066                 }
1067             }
1068         }
1069     }
1070 
1071     static class TrivialCloneable implements Cloneable {
1072         @Override
1073         protected Object clone() {
1074             return new TrivialCloneable();
1075         }
1076     }
1077 
1078     @Test
1079     public void isCloneableWithAllocationTest() {
1080         ResolvedJavaType cloneable = metaAccess.lookupJavaType(Cloneable.class);
1081         for (Class&lt;?&gt; c : classes) {
1082             ResolvedJavaType type = metaAccess.lookupJavaType(c);
1083             if (type.isCloneableWithAllocation()) {
1084                 // Only Cloneable types should be allocation cloneable
1085                 assertTrue(c.toString(), cloneable.isAssignableFrom(type));
1086             }
1087         }
1088         /*
1089          * We can&#39;t know for sure which types should be allocation cloneable on a particular
1090          * platform but assume that at least totally trivial objects should be.
1091          */
1092         ResolvedJavaType trivialCloneable = metaAccess.lookupJavaType(TrivialCloneable.class);
1093         assertTrue(trivialCloneable.toString(), trivialCloneable.isCloneableWithAllocation());
1094     }
1095 
1096     @Test
1097     public void findMethodTest() {
1098         try {
1099             ResolvedJavaMethod findFoo = metaAccess.lookupJavaType(D.class).findMethod(&quot;foo&quot;, metaAccess.parseMethodDescriptor(&quot;()V&quot;));
1100             ResolvedJavaMethod expectedFoo = metaAccess.lookupJavaMethod(D.class.getDeclaredMethod(&quot;foo&quot;));
1101             assertEquals(expectedFoo, findFoo);
1102 
1103             ResolvedJavaMethod wrongReturnTypeFoo = metaAccess.lookupJavaType(D.class).findMethod(&quot;foo&quot;, metaAccess.parseMethodDescriptor(&quot;()I&quot;));
1104             assertNull(wrongReturnTypeFoo);
1105 
1106             ResolvedJavaMethod wrongArgumentsFoo = metaAccess.lookupJavaType(D.class).findMethod(&quot;foo&quot;, metaAccess.parseMethodDescriptor(&quot;(I)V&quot;));
1107             assertNull(wrongArgumentsFoo);
1108 
1109             ResolvedJavaMethod wrongNameFoo = metaAccess.lookupJavaType(D.class).findMethod(&quot;bar&quot;, metaAccess.parseMethodDescriptor(&quot;()V&quot;));
1110             assertNull(wrongNameFoo);
1111 
1112             ResolvedJavaMethod wrongClassFoo = metaAccess.lookupJavaType(SubD.class).findMethod(&quot;foo&quot;, metaAccess.parseMethodDescriptor(&quot;()V&quot;));
1113             assertNull(wrongClassFoo);
1114         } catch (NoSuchMethodException | SecurityException e) {
1115             throw new RuntimeException(e);
1116         }
1117     }
1118 
1119     private Method findTestMethod(Method apiMethod) {
1120         String testName = apiMethod.getName() + &quot;Test&quot;;
1121         for (Method m : getClass().getDeclaredMethods()) {
1122             if (m.getName().equals(testName) &amp;&amp; m.getAnnotation(Test.class) != null) {
1123                 return m;
1124             }
1125         }
1126         return null;
1127     }
1128 
1129     // @formatter:off
1130     private static final String[] untestedApiMethods = {
1131         &quot;initialize&quot;,
1132         &quot;isPrimitive&quot;,
1133         &quot;newArray&quot;,
1134         &quot;getDeclaredConstructors&quot;,
1135         &quot;isInitialized&quot;,
1136         &quot;isLinked&quot;,
1137         &quot;getJavaClass&quot;,
1138         &quot;getObjectHub&quot;,
1139         &quot;hasFinalizableSubclass&quot;,
1140         &quot;hasFinalizer&quot;,
1141         &quot;isLocal&quot;,
1142         &quot;isJavaLangObject&quot;,
1143         &quot;isMember&quot;,
1144         &quot;getElementalType&quot;,
1145         &quot;getEnclosingType&quot;,
1146         &quot;lookupType&quot;,
1147         &quot;resolveField&quot;,
1148         &quot;$jacocoInit&quot;
1149     };
1150     // @formatter:on
1151 
1152     /**
1153      * Ensures that any new methods added to {@link ResolvedJavaMethod} either have a test written
1154      * for them or are added to {@link #untestedApiMethods}.
1155      */
1156     @Test
1157     public void testCoverage() {
1158         Set&lt;String&gt; known = new HashSet&lt;&gt;(Arrays.asList(untestedApiMethods));
1159         for (Method m : ResolvedJavaType.class.getDeclaredMethods()) {
1160             if (findTestMethod(m) == null) {
1161                 assertTrue(&quot;test missing for &quot; + m, known.contains(m.getName()));
1162             } else {
1163                 assertFalse(&quot;test should be removed from untestedApiMethods&quot; + m, known.contains(m.getName()));
1164             }
1165         }
1166     }
1167 
1168     private static boolean isSignaturePolymorphic(ResolvedJavaMethod method) {
1169         return method.getAnnotation(SIGNATURE_POLYMORPHIC_CLASS) != null;
1170     }
1171 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>