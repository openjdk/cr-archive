<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/ObjectStreamClass.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/runtime/vmOperations.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/ObjectStreamClass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.lang.invoke.MethodHandle;
  29 import java.lang.invoke.MethodHandles;

  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.SoftReference;
  33 import java.lang.ref.WeakReference;
  34 import java.lang.reflect.Constructor;
  35 import java.lang.reflect.Field;
  36 import java.lang.reflect.InaccessibleObjectException;
  37 import java.lang.reflect.InvocationTargetException;
  38 import java.lang.reflect.RecordComponent;
  39 import java.lang.reflect.UndeclaredThrowableException;
  40 import java.lang.reflect.Member;
  41 import java.lang.reflect.Method;
  42 import java.lang.reflect.Modifier;
  43 import java.lang.reflect.Proxy;
  44 import java.security.AccessControlContext;
  45 import java.security.AccessController;
  46 import java.security.MessageDigest;
  47 import java.security.NoSuchAlgorithmException;
  48 import java.security.PermissionCollection;
  49 import java.security.Permissions;
  50 import java.security.PrivilegedAction;
  51 import java.security.PrivilegedActionException;
  52 import java.security.PrivilegedExceptionAction;
  53 import java.security.ProtectionDomain;
  54 import java.util.ArrayList;
  55 import java.util.Arrays;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashSet;

  59 import java.util.Set;
  60 import java.util.concurrent.ConcurrentHashMap;
  61 import java.util.concurrent.ConcurrentMap;
  62 import jdk.internal.misc.Unsafe;
  63 import jdk.internal.reflect.CallerSensitive;
  64 import jdk.internal.reflect.Reflection;
  65 import jdk.internal.reflect.ReflectionFactory;
  66 import jdk.internal.access.SharedSecrets;
  67 import jdk.internal.access.JavaSecurityAccess;
  68 import sun.reflect.misc.ReflectUtil;
  69 import static java.io.ObjectStreamField.*;
  70 
  71 /**
  72  * Serialization&#39;s descriptor for classes.  It contains the name and
  73  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  74  * loaded in this Java VM can be found/created using the lookup method.
  75  *
  76  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  77  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  78  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
</pre>
<hr />
<pre>
 175     /** exception (if any) to throw if non-enum deserialization attempted */
 176     private ExceptionInfo deserializeEx;
 177     /** exception (if any) to throw if non-enum serialization attempted */
 178     private ExceptionInfo serializeEx;
 179     /** exception (if any) to throw if default serialization attempted */
 180     private ExceptionInfo defaultSerializeEx;
 181 
 182     /** serializable fields */
 183     private ObjectStreamField[] fields;
 184     /** aggregate marshalled size of primitive fields */
 185     private int primDataSize;
 186     /** number of non-primitive fields */
 187     private int numObjFields;
 188     /** reflector for setting/getting serializable field values */
 189     private FieldReflector fieldRefl;
 190     /** data layout of serialized objects described by this class desc */
 191     private volatile ClassDataSlot[] dataLayout;
 192 
 193     /** serialization-appropriate constructor, or null if none */
 194     private Constructor&lt;?&gt; cons;
<span class="line-modified"> 195     /** record canonical constructor, or null */</span>
 196     private MethodHandle canonicalCtr;






 197     /** protection domains that need to be checked when calling the constructor */
 198     private ProtectionDomain[] domains;
 199 
 200     /** class-defined writeObject method, or null if none */
 201     private Method writeObjectMethod;
 202     /** class-defined readObject method, or null if none */
 203     private Method readObjectMethod;
 204     /** class-defined readObjectNoData method, or null if none */
 205     private Method readObjectNoDataMethod;
 206     /** class-defined writeReplace method, or null if none */
 207     private Method writeReplaceMethod;
 208     /** class-defined readResolve method, or null if none */
 209     private Method readResolveMethod;
 210 
 211     /** local class descriptor for represented class (may point to self) */
 212     private ObjectStreamClass localDesc;
 213     /** superclass descriptor appearing in stream */
 214     private ObjectStreamClass superDesc;
 215 
 216     /** true if, and only if, the object has been correctly initialized */
</pre>
<hr />
<pre>
 510                         fields = NO_FIELDS;
 511                         return null;
 512                     }
 513                     if (cl.isArray()) {
 514                         fields = NO_FIELDS;
 515                         return null;
 516                     }
 517 
 518                     suid = getDeclaredSUID(cl);
 519                     try {
 520                         fields = getSerialFields(cl);
 521                         computeFieldOffsets();
 522                     } catch (InvalidClassException e) {
 523                         serializeEx = deserializeEx =
 524                             new ExceptionInfo(e.classname, e.getMessage());
 525                         fields = NO_FIELDS;
 526                     }
 527 
 528                     if (isRecord) {
 529                         canonicalCtr = canonicalRecordCtr(cl);

 530                     } else if (externalizable) {
 531                         cons = getExternalizableConstructor(cl);
 532                     } else {
 533                         cons = getSerializableConstructor(cl);
 534                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 535                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 536                             Void.TYPE);
 537                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 538                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 539                             Void.TYPE);
 540                         readObjectNoDataMethod = getPrivateMethod(
 541                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 542                         hasWriteObjectData = (writeObjectMethod != null);
 543                     }
 544                     domains = getProtectionDomains(cons, cl);
 545                     writeReplaceMethod = getInheritableMethod(
 546                         cl, &quot;writeReplace&quot;, null, Object.class);
 547                     readResolveMethod = getInheritableMethod(
 548                         cl, &quot;readResolve&quot;, null, Object.class);
 549                     return null;
</pre>
<hr />
<pre>
 725                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 726             }
 727 
 728             if (!model.isEnum) {
 729                 if ((model.serializable == osc.serializable) &amp;&amp;
 730                         (model.externalizable != osc.externalizable)) {
 731                     throw new InvalidClassException(osc.name,
 732                             &quot;Serializable incompatible with Externalizable&quot;);
 733                 }
 734 
 735                 if ((model.serializable != osc.serializable) ||
 736                         (model.externalizable != osc.externalizable) ||
 737                         !(model.serializable || model.externalizable)) {
 738                     deserializeEx = new ExceptionInfo(
 739                             osc.name, &quot;class invalid for deserialization&quot;);
 740                 }
 741             }
 742         }
 743 
 744         this.cl = cl;
<span class="line-removed"> 745         if (cl != null) {</span>
<span class="line-removed"> 746             this.isRecord = isRecord(cl);</span>
<span class="line-removed"> 747             this.canonicalCtr = osc.canonicalCtr;</span>
<span class="line-removed"> 748         }</span>
 749         this.resolveEx = resolveEx;
 750         this.superDesc = superDesc;
 751         name = model.name;
 752         this.suid = suid;
 753         isProxy = false;
 754         isEnum = model.isEnum;
 755         serializable = model.serializable;
 756         externalizable = model.externalizable;
 757         hasBlockExternalData = model.hasBlockExternalData;
 758         hasWriteObjectData = model.hasWriteObjectData;
 759         fields = model.fields;
 760         primDataSize = model.primDataSize;
 761         numObjFields = model.numObjFields;
 762 
 763         if (osc != null) {
 764             localDesc = osc;





 765             writeObjectMethod = localDesc.writeObjectMethod;
 766             readObjectMethod = localDesc.readObjectMethod;
 767             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 768             writeReplaceMethod = localDesc.writeReplaceMethod;
 769             readResolveMethod = localDesc.readResolveMethod;
 770             if (deserializeEx == null) {
 771                 deserializeEx = localDesc.deserializeEx;
 772             }
 773             domains = localDesc.domains;
 774             assert isRecord(cl) ? localDesc.cons == null : true;
 775             cons = localDesc.cons;
 776         }
 777 
 778         fieldRefl = getReflector(fields, localDesc);
 779         // reassign to matched fields so as to reflect local unshared settings
 780         fields = fieldRefl.getFields();
 781 
 782         initialized = true;
 783     }
 784 
</pre>
<hr />
<pre>
2517          * Returns true if the given object is this identical
2518          * WeakClassKey instance, or, if this object&#39;s referent has not
2519          * been cleared, if the given object is another WeakClassKey
2520          * instance with the identical non-null referent as this one.
2521          */
2522         public boolean equals(Object obj) {
2523             if (obj == this) {
2524                 return true;
2525             }
2526 
2527             if (obj instanceof WeakClassKey) {
2528                 Object referent = get();
2529                 return (referent != null) &amp;&amp;
2530                        (referent == ((WeakClassKey) obj).get());
2531             } else {
2532                 return false;
2533             }
2534         }
2535     }
2536 
















































































































2537     /** Record specific support for retrieving and binding stream field values. */
2538     static final class RecordSupport {
<span class="line-modified">2539 </span>
<span class="line-modified">2540         /** Binds the given stream field values to the given method handle. */</span>




2541         @SuppressWarnings(&quot;preview&quot;)
<span class="line-modified">2542         static MethodHandle bindCtrValues(MethodHandle ctrMH,</span>
<span class="line-modified">2543                                           ObjectStreamClass desc,</span>
<span class="line-modified">2544                                           ObjectInputStream.FieldValues fieldValues) {</span>





2545             RecordComponent[] recordComponents;
2546             try {
2547                 Class&lt;?&gt; cls = desc.forClass();
2548                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;
2549                 recordComponents = AccessController.doPrivileged(pa);
2550             } catch (PrivilegedActionException e) {
2551                 throw new InternalError(e.getCause());
2552             }
2553 
<span class="line-modified">2554             Object[] args = new Object[recordComponents.length];</span>
<span class="line-modified">2555             for (int i = 0; i &lt; recordComponents.length; i++) {</span>











2556                 String name = recordComponents[i].getName();
<span class="line-modified">2557                 Class&lt;?&gt; type= recordComponents[i].getType();</span>
<span class="line-modified">2558                 Object o = streamFieldValue(name, type, desc, fieldValues);</span>
<span class="line-modified">2559                 args[i] = o;</span>





2560             }



2561 
<span class="line-modified">2562             return MethodHandles.insertArguments(ctrMH, 0, args);</span>


2563         }
2564 
2565         /** Returns the number of primitive fields for the given descriptor. */
2566         private static int numberPrimValues(ObjectStreamClass desc) {
2567             ObjectStreamField[] fields = desc.getFields();
2568             int primValueCount = 0;
2569             for (int i = 0; i &lt; fields.length; i++) {
2570                 if (fields[i].isPrimitive())
2571                     primValueCount++;
2572                 else
2573                     break;  // can be no more
2574             }
2575             return primValueCount;
2576         }
2577 
<span class="line-modified">2578         /** Returns the default value for the given type. */</span>
<span class="line-modified">2579         private static Object defaultValueFor(Class&lt;?&gt; pType) {</span>
<span class="line-modified">2580             if (pType == Integer.TYPE)</span>
<span class="line-removed">2581                 return 0;</span>
<span class="line-removed">2582             else if (pType == Byte.TYPE)</span>
<span class="line-removed">2583                 return (byte)0;</span>
<span class="line-removed">2584             else if (pType == Long.TYPE)</span>
<span class="line-removed">2585                 return 0L;</span>
<span class="line-removed">2586             else if (pType == Float.TYPE)</span>
<span class="line-removed">2587                 return 0.0f;</span>
<span class="line-removed">2588             else if (pType == Double.TYPE)</span>
<span class="line-removed">2589                 return 0.0d;</span>
<span class="line-removed">2590             else if (pType == Short.TYPE)</span>
<span class="line-removed">2591                 return (short)0;</span>
<span class="line-removed">2592             else if (pType == Character.TYPE)</span>
<span class="line-removed">2593                 return &#39;\u0000&#39;;</span>
<span class="line-removed">2594             else if (pType == Boolean.TYPE)</span>
<span class="line-removed">2595                 return false;</span>
<span class="line-removed">2596             else</span>
<span class="line-removed">2597                 return null;</span>
<span class="line-removed">2598         }</span>
<span class="line-removed">2599 </span>
<span class="line-removed">2600         /**</span>
<span class="line-removed">2601          * Returns the stream field value for the given name. The default value</span>
2602          * for the given type is returned if the field value is absent.
2603          */
<span class="line-modified">2604         private static Object streamFieldValue(String pName,</span>
<span class="line-modified">2605                                                Class&lt;?&gt; pType,</span>
<span class="line-modified">2606                                                ObjectStreamClass desc,</span>
<span class="line-modified">2607                                                ObjectInputStream.FieldValues fieldValues) {</span>
<span class="line-removed">2608             ObjectStreamField[] fields = desc.getFields();</span>
2609 
2610             for (int i = 0; i &lt; fields.length; i++) {
2611                 ObjectStreamField f = fields[i];
2612                 String fName = f.getName();
2613                 if (!fName.equals(pName))
2614                     continue;
2615 
2616                 Class&lt;?&gt; fType = f.getField().getType();
2617                 if (!pType.isAssignableFrom(fType))
2618                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);
2619 
2620                 if (f.isPrimitive()) {
<span class="line-modified">2621                     if (pType == Integer.TYPE)</span>
<span class="line-modified">2622                         return Bits.getInt(fieldValues.primValues, f.getOffset());</span>
<span class="line-modified">2623                     else if (fType == Byte.TYPE)</span>
<span class="line-removed">2624                         return fieldValues.primValues[f.getOffset()];</span>
<span class="line-removed">2625                     else if (fType == Long.TYPE)</span>
<span class="line-removed">2626                         return Bits.getLong(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2627                     else if (fType == Float.TYPE)</span>
<span class="line-removed">2628                         return Bits.getFloat(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2629                     else if (fType == Double.TYPE)</span>
<span class="line-removed">2630                         return Bits.getDouble(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2631                     else if (fType == Short.TYPE)</span>
<span class="line-removed">2632                         return Bits.getShort(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2633                     else if (fType == Character.TYPE)</span>
<span class="line-removed">2634                         return Bits.getChar(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2635                     else if (fType == Boolean.TYPE)</span>
<span class="line-removed">2636                         return Bits.getBoolean(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2637                     else</span>
2638                         throw new InternalError(&quot;Unexpected type: &quot; + fType);













2639                 } else { // reference
<span class="line-modified">2640                     return fieldValues.objValues[i - numberPrimValues(desc)];</span>













2641                 }
2642             }
2643 
<span class="line-modified">2644             return defaultValueFor(pType);</span>




















2645         }
2646     }
2647 }
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.lang.invoke.MethodHandle;
  29 import java.lang.invoke.MethodHandles;
<span class="line-added">  30 import java.lang.invoke.MethodType;</span>
  31 import java.lang.ref.Reference;
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.ref.SoftReference;
  34 import java.lang.ref.WeakReference;
  35 import java.lang.reflect.Constructor;
  36 import java.lang.reflect.Field;
  37 import java.lang.reflect.InaccessibleObjectException;
  38 import java.lang.reflect.InvocationTargetException;
  39 import java.lang.reflect.RecordComponent;
  40 import java.lang.reflect.UndeclaredThrowableException;
  41 import java.lang.reflect.Member;
  42 import java.lang.reflect.Method;
  43 import java.lang.reflect.Modifier;
  44 import java.lang.reflect.Proxy;
  45 import java.security.AccessControlContext;
  46 import java.security.AccessController;
  47 import java.security.MessageDigest;
  48 import java.security.NoSuchAlgorithmException;
  49 import java.security.PermissionCollection;
  50 import java.security.Permissions;
  51 import java.security.PrivilegedAction;
  52 import java.security.PrivilegedActionException;
  53 import java.security.PrivilegedExceptionAction;
  54 import java.security.ProtectionDomain;
  55 import java.util.ArrayList;
  56 import java.util.Arrays;
  57 import java.util.Collections;
  58 import java.util.Comparator;
  59 import java.util.HashSet;
<span class="line-added">  60 import java.util.Map;</span>
  61 import java.util.Set;
  62 import java.util.concurrent.ConcurrentHashMap;
  63 import java.util.concurrent.ConcurrentMap;
  64 import jdk.internal.misc.Unsafe;
  65 import jdk.internal.reflect.CallerSensitive;
  66 import jdk.internal.reflect.Reflection;
  67 import jdk.internal.reflect.ReflectionFactory;
  68 import jdk.internal.access.SharedSecrets;
  69 import jdk.internal.access.JavaSecurityAccess;
  70 import sun.reflect.misc.ReflectUtil;
  71 import static java.io.ObjectStreamField.*;
  72 
  73 /**
  74  * Serialization&#39;s descriptor for classes.  It contains the name and
  75  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  76  * loaded in this Java VM can be found/created using the lookup method.
  77  *
  78  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  79  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  80  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
</pre>
<hr />
<pre>
 177     /** exception (if any) to throw if non-enum deserialization attempted */
 178     private ExceptionInfo deserializeEx;
 179     /** exception (if any) to throw if non-enum serialization attempted */
 180     private ExceptionInfo serializeEx;
 181     /** exception (if any) to throw if default serialization attempted */
 182     private ExceptionInfo defaultSerializeEx;
 183 
 184     /** serializable fields */
 185     private ObjectStreamField[] fields;
 186     /** aggregate marshalled size of primitive fields */
 187     private int primDataSize;
 188     /** number of non-primitive fields */
 189     private int numObjFields;
 190     /** reflector for setting/getting serializable field values */
 191     private FieldReflector fieldRefl;
 192     /** data layout of serialized objects described by this class desc */
 193     private volatile ClassDataSlot[] dataLayout;
 194 
 195     /** serialization-appropriate constructor, or null if none */
 196     private Constructor&lt;?&gt; cons;
<span class="line-modified"> 197     /** record canonical constructor (shared among OSCs for same class), or null */</span>
 198     private MethodHandle canonicalCtr;
<span class="line-added"> 199     /** cache of record deserialization constructors per unique set of stream fields</span>
<span class="line-added"> 200      * (shared among OSCs for same class), or null */</span>
<span class="line-added"> 201     private DeserializationConstructorsCache deserializationCtrs;</span>
<span class="line-added"> 202     /** session-cache of record deserialization constructor</span>
<span class="line-added"> 203      * (in de-serialized OSC only), or null */</span>
<span class="line-added"> 204     private MethodHandle deserializationCtr;</span>
 205     /** protection domains that need to be checked when calling the constructor */
 206     private ProtectionDomain[] domains;
 207 
 208     /** class-defined writeObject method, or null if none */
 209     private Method writeObjectMethod;
 210     /** class-defined readObject method, or null if none */
 211     private Method readObjectMethod;
 212     /** class-defined readObjectNoData method, or null if none */
 213     private Method readObjectNoDataMethod;
 214     /** class-defined writeReplace method, or null if none */
 215     private Method writeReplaceMethod;
 216     /** class-defined readResolve method, or null if none */
 217     private Method readResolveMethod;
 218 
 219     /** local class descriptor for represented class (may point to self) */
 220     private ObjectStreamClass localDesc;
 221     /** superclass descriptor appearing in stream */
 222     private ObjectStreamClass superDesc;
 223 
 224     /** true if, and only if, the object has been correctly initialized */
</pre>
<hr />
<pre>
 518                         fields = NO_FIELDS;
 519                         return null;
 520                     }
 521                     if (cl.isArray()) {
 522                         fields = NO_FIELDS;
 523                         return null;
 524                     }
 525 
 526                     suid = getDeclaredSUID(cl);
 527                     try {
 528                         fields = getSerialFields(cl);
 529                         computeFieldOffsets();
 530                     } catch (InvalidClassException e) {
 531                         serializeEx = deserializeEx =
 532                             new ExceptionInfo(e.classname, e.getMessage());
 533                         fields = NO_FIELDS;
 534                     }
 535 
 536                     if (isRecord) {
 537                         canonicalCtr = canonicalRecordCtr(cl);
<span class="line-added"> 538                         deserializationCtrs = new DeserializationConstructorsCache();</span>
 539                     } else if (externalizable) {
 540                         cons = getExternalizableConstructor(cl);
 541                     } else {
 542                         cons = getSerializableConstructor(cl);
 543                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 544                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 545                             Void.TYPE);
 546                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 547                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 548                             Void.TYPE);
 549                         readObjectNoDataMethod = getPrivateMethod(
 550                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 551                         hasWriteObjectData = (writeObjectMethod != null);
 552                     }
 553                     domains = getProtectionDomains(cons, cl);
 554                     writeReplaceMethod = getInheritableMethod(
 555                         cl, &quot;writeReplace&quot;, null, Object.class);
 556                     readResolveMethod = getInheritableMethod(
 557                         cl, &quot;readResolve&quot;, null, Object.class);
 558                     return null;
</pre>
<hr />
<pre>
 734                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 735             }
 736 
 737             if (!model.isEnum) {
 738                 if ((model.serializable == osc.serializable) &amp;&amp;
 739                         (model.externalizable != osc.externalizable)) {
 740                     throw new InvalidClassException(osc.name,
 741                             &quot;Serializable incompatible with Externalizable&quot;);
 742                 }
 743 
 744                 if ((model.serializable != osc.serializable) ||
 745                         (model.externalizable != osc.externalizable) ||
 746                         !(model.serializable || model.externalizable)) {
 747                     deserializeEx = new ExceptionInfo(
 748                             osc.name, &quot;class invalid for deserialization&quot;);
 749                 }
 750             }
 751         }
 752 
 753         this.cl = cl;




 754         this.resolveEx = resolveEx;
 755         this.superDesc = superDesc;
 756         name = model.name;
 757         this.suid = suid;
 758         isProxy = false;
 759         isEnum = model.isEnum;
 760         serializable = model.serializable;
 761         externalizable = model.externalizable;
 762         hasBlockExternalData = model.hasBlockExternalData;
 763         hasWriteObjectData = model.hasWriteObjectData;
 764         fields = model.fields;
 765         primDataSize = model.primDataSize;
 766         numObjFields = model.numObjFields;
 767 
 768         if (osc != null) {
 769             localDesc = osc;
<span class="line-added"> 770             isRecord = localDesc.isRecord;</span>
<span class="line-added"> 771             // canonical record constructor is shared</span>
<span class="line-added"> 772             canonicalCtr = localDesc.canonicalCtr;</span>
<span class="line-added"> 773             // cache of deserialization constructors is shared</span>
<span class="line-added"> 774             deserializationCtrs = localDesc.deserializationCtrs;</span>
 775             writeObjectMethod = localDesc.writeObjectMethod;
 776             readObjectMethod = localDesc.readObjectMethod;
 777             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 778             writeReplaceMethod = localDesc.writeReplaceMethod;
 779             readResolveMethod = localDesc.readResolveMethod;
 780             if (deserializeEx == null) {
 781                 deserializeEx = localDesc.deserializeEx;
 782             }
 783             domains = localDesc.domains;
 784             assert isRecord(cl) ? localDesc.cons == null : true;
 785             cons = localDesc.cons;
 786         }
 787 
 788         fieldRefl = getReflector(fields, localDesc);
 789         // reassign to matched fields so as to reflect local unshared settings
 790         fields = fieldRefl.getFields();
 791 
 792         initialized = true;
 793     }
 794 
</pre>
<hr />
<pre>
2527          * Returns true if the given object is this identical
2528          * WeakClassKey instance, or, if this object&#39;s referent has not
2529          * been cleared, if the given object is another WeakClassKey
2530          * instance with the identical non-null referent as this one.
2531          */
2532         public boolean equals(Object obj) {
2533             if (obj == this) {
2534                 return true;
2535             }
2536 
2537             if (obj instanceof WeakClassKey) {
2538                 Object referent = get();
2539                 return (referent != null) &amp;&amp;
2540                        (referent == ((WeakClassKey) obj).get());
2541             } else {
2542                 return false;
2543             }
2544         }
2545     }
2546 
<span class="line-added">2547     // a LRA cache of record deserialization constructors</span>
<span class="line-added">2548     @SuppressWarnings(&quot;serial&quot;)</span>
<span class="line-added">2549     private static final class DeserializationConstructorsCache</span>
<span class="line-added">2550         extends ConcurrentHashMap&lt;DeserializationConstructorsCache.Key, MethodHandle&gt;  {</span>
<span class="line-added">2551 </span>
<span class="line-added">2552         // keep max. 10 cached entries - when the 11th element is inserted the oldest</span>
<span class="line-added">2553         // is removed and 10 remains - 11 is the biggest map size where internal</span>
<span class="line-added">2554         // table of 16 elements is sufficient (inserting 12th element would resize it to 32)</span>
<span class="line-added">2555         private static final int MAX_SIZE = 10;</span>
<span class="line-added">2556         private Key.Impl first, last; // first and last in FIFO queue</span>
<span class="line-added">2557 </span>
<span class="line-added">2558         DeserializationConstructorsCache() {</span>
<span class="line-added">2559             // start small - if there is more than one shape of ObjectStreamClass</span>
<span class="line-added">2560             // deserialized, there will typically be two (current version and previous version)</span>
<span class="line-added">2561             super(2);</span>
<span class="line-added">2562         }</span>
<span class="line-added">2563 </span>
<span class="line-added">2564         MethodHandle get(ObjectStreamField[] fields) {</span>
<span class="line-added">2565             return get(new Key.Lookup(fields));</span>
<span class="line-added">2566         }</span>
<span class="line-added">2567 </span>
<span class="line-added">2568         synchronized MethodHandle putIfAbsentAndGet(ObjectStreamField[] fields, MethodHandle mh) {</span>
<span class="line-added">2569             Key.Impl key = new Key.Impl(fields);</span>
<span class="line-added">2570             var oldMh = putIfAbsent(key, mh);</span>
<span class="line-added">2571             if (oldMh != null) return oldMh;</span>
<span class="line-added">2572             // else we did insert new entry -&gt; link the new key as last</span>
<span class="line-added">2573             if (last == null) {</span>
<span class="line-added">2574                 last = first = key;</span>
<span class="line-added">2575             } else {</span>
<span class="line-added">2576                 last = (last.next = key);</span>
<span class="line-added">2577             }</span>
<span class="line-added">2578             // may need to remove first</span>
<span class="line-added">2579             if (size() &gt; MAX_SIZE) {</span>
<span class="line-added">2580                 assert first != null;</span>
<span class="line-added">2581                 remove(first);</span>
<span class="line-added">2582                 first = first.next;</span>
<span class="line-added">2583                 if (first == null) {</span>
<span class="line-added">2584                     last = null;</span>
<span class="line-added">2585                 }</span>
<span class="line-added">2586             }</span>
<span class="line-added">2587             return mh;</span>
<span class="line-added">2588         }</span>
<span class="line-added">2589 </span>
<span class="line-added">2590         // a key composed of ObjectStreamField[] names and types</span>
<span class="line-added">2591         static abstract class Key {</span>
<span class="line-added">2592             abstract int length();</span>
<span class="line-added">2593             abstract String fieldName(int i);</span>
<span class="line-added">2594             abstract Class&lt;?&gt; fieldType(int i);</span>
<span class="line-added">2595 </span>
<span class="line-added">2596             @Override</span>
<span class="line-added">2597             public final int hashCode() {</span>
<span class="line-added">2598                 int n = length();</span>
<span class="line-added">2599                 int h = 0;</span>
<span class="line-added">2600                 for (int i = 0; i &lt; n; i++) h = h * 31 + fieldType(i).hashCode();</span>
<span class="line-added">2601                 for (int i = 0; i &lt; n; i++) h = h * 31 + fieldName(i).hashCode();</span>
<span class="line-added">2602                 return h;</span>
<span class="line-added">2603             }</span>
<span class="line-added">2604 </span>
<span class="line-added">2605             @Override</span>
<span class="line-added">2606             public final boolean equals(Object obj) {</span>
<span class="line-added">2607                 if (!(obj instanceof Key)) return false;</span>
<span class="line-added">2608                 Key other = (Key) obj;</span>
<span class="line-added">2609                 int n = length();</span>
<span class="line-added">2610                 if (n != other.length()) return false;</span>
<span class="line-added">2611                 for (int i = 0; i &lt; n; i++) if (fieldType(i) != other.fieldType(i)) return false;</span>
<span class="line-added">2612                 for (int i = 0; i &lt; n; i++) if (!fieldName(i).equals(other.fieldName(i))) return false;</span>
<span class="line-added">2613                 return true;</span>
<span class="line-added">2614             }</span>
<span class="line-added">2615 </span>
<span class="line-added">2616             // lookup key - just wraps ObjectStreamField[]</span>
<span class="line-added">2617             static final class Lookup extends Key {</span>
<span class="line-added">2618                 final ObjectStreamField[] fields;</span>
<span class="line-added">2619 </span>
<span class="line-added">2620                 Lookup(ObjectStreamField[] fields) { this.fields = fields; }</span>
<span class="line-added">2621 </span>
<span class="line-added">2622                 @Override</span>
<span class="line-added">2623                 int length() { return fields.length; }</span>
<span class="line-added">2624 </span>
<span class="line-added">2625                 @Override</span>
<span class="line-added">2626                 String fieldName(int i) { return fields[i].getName(); }</span>
<span class="line-added">2627 </span>
<span class="line-added">2628                 @Override</span>
<span class="line-added">2629                 Class&lt;?&gt; fieldType(int i) { return fields[i].getType(); }</span>
<span class="line-added">2630             }</span>
<span class="line-added">2631 </span>
<span class="line-added">2632             // real key - copies field names and types and forms FIFO queue in cache</span>
<span class="line-added">2633             static final class Impl extends Key {</span>
<span class="line-added">2634                 Impl next;</span>
<span class="line-added">2635                 final String[] fieldNames;</span>
<span class="line-added">2636                 final Class&lt;?&gt;[] fieldTypes;</span>
<span class="line-added">2637 </span>
<span class="line-added">2638                 Impl(ObjectStreamField[] fields) {</span>
<span class="line-added">2639                     this.fieldNames = new String[fields.length];</span>
<span class="line-added">2640                     this.fieldTypes = new Class&lt;?&gt;[fields.length];</span>
<span class="line-added">2641                     for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added">2642                         fieldNames[i] = fields[i].getName();</span>
<span class="line-added">2643                         fieldTypes[i] = fields[i].getType();</span>
<span class="line-added">2644                     }</span>
<span class="line-added">2645                 }</span>
<span class="line-added">2646 </span>
<span class="line-added">2647                 @Override</span>
<span class="line-added">2648                 int length() { return fieldNames.length; }</span>
<span class="line-added">2649 </span>
<span class="line-added">2650                 @Override</span>
<span class="line-added">2651                 String fieldName(int i) { return fieldNames[i]; }</span>
<span class="line-added">2652 </span>
<span class="line-added">2653                 @Override</span>
<span class="line-added">2654                 Class&lt;?&gt; fieldType(int i) { return fieldTypes[i]; }</span>
<span class="line-added">2655             }</span>
<span class="line-added">2656         }</span>
<span class="line-added">2657     }</span>
<span class="line-added">2658 </span>
2659     /** Record specific support for retrieving and binding stream field values. */
2660     static final class RecordSupport {
<span class="line-modified">2661         /**</span>
<span class="line-modified">2662          * Returns canonical record constructor adapted to take two arguments:</span>
<span class="line-added">2663          * {@code (byte[] primValues, Object[] objValues)}</span>
<span class="line-added">2664          * and return</span>
<span class="line-added">2665          * {@code Object}</span>
<span class="line-added">2666          */</span>
2667         @SuppressWarnings(&quot;preview&quot;)
<span class="line-modified">2668         static MethodHandle deserializationCtr(ObjectStreamClass desc) {</span>
<span class="line-modified">2669             // check the cached value 1st</span>
<span class="line-modified">2670             MethodHandle mh = desc.deserializationCtr;</span>
<span class="line-added">2671             if (mh != null) return mh;</span>
<span class="line-added">2672             mh = desc.deserializationCtrs.get(desc.getFields(false));</span>
<span class="line-added">2673             if (mh != null) return desc.deserializationCtr = mh;</span>
<span class="line-added">2674 </span>
<span class="line-added">2675             // retrieve record components</span>
2676             RecordComponent[] recordComponents;
2677             try {
2678                 Class&lt;?&gt; cls = desc.forClass();
2679                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;
2680                 recordComponents = AccessController.doPrivileged(pa);
2681             } catch (PrivilegedActionException e) {
2682                 throw new InternalError(e.getCause());
2683             }
2684 
<span class="line-modified">2685             // retrieve the canonical constructor</span>
<span class="line-modified">2686             // (T1, T2, ..., Tn):TR</span>
<span class="line-added">2687             mh = desc.getRecordConstructor();</span>
<span class="line-added">2688 </span>
<span class="line-added">2689             // change return type to Object</span>
<span class="line-added">2690             // (T1, T2, ..., Tn):TR -&gt; (T1, T2, ..., Tn):Object</span>
<span class="line-added">2691             mh = mh.asType(mh.type().changeReturnType(Object.class));</span>
<span class="line-added">2692 </span>
<span class="line-added">2693             // drop last 2 arguments representing primValues and objValues arrays</span>
<span class="line-added">2694             // (T1, T2, ..., Tn):Object -&gt; (T1, T2, ..., Tn, byte[], Object[]):Object</span>
<span class="line-added">2695             mh = MethodHandles.dropArguments(mh, mh.type().parameterCount(), byte[].class, Object[].class);</span>
<span class="line-added">2696 </span>
<span class="line-added">2697             for (int i = recordComponents.length-1; i &gt;= 0; i--) {</span>
2698                 String name = recordComponents[i].getName();
<span class="line-modified">2699                 Class&lt;?&gt; type = recordComponents[i].getType();</span>
<span class="line-modified">2700                 // obtain stream field extractor that extracts argument at</span>
<span class="line-modified">2701                 // position i (Ti+1) from primValues and objValues arrays</span>
<span class="line-added">2702                 // (byte[], Object[]):Ti+1</span>
<span class="line-added">2703                 MethodHandle combiner = streamFieldExtractor(name, type, desc);</span>
<span class="line-added">2704                 // fold byte[] privValues and Object[] objValues into argument at position i (Ti+1)</span>
<span class="line-added">2705                 // (..., Ti, Ti+1, byte[], Object[]):Object -&gt; (..., Ti, byte[], Object[]):Object</span>
<span class="line-added">2706                 mh = MethodHandles.foldArguments(mh, i, combiner);</span>
2707             }
<span class="line-added">2708             // what we are left with is a MethodHandle taking just the primValues</span>
<span class="line-added">2709             // and objValues arrays and returning the constructed record instance</span>
<span class="line-added">2710             // (byte[], Object[]):Object</span>
2711 
<span class="line-modified">2712             // store it into cache and return the 1st value stored</span>
<span class="line-added">2713             return desc.deserializationCtr =</span>
<span class="line-added">2714                 desc.deserializationCtrs.putIfAbsentAndGet(desc.getFields(false), mh);</span>
2715         }
2716 
2717         /** Returns the number of primitive fields for the given descriptor. */
2718         private static int numberPrimValues(ObjectStreamClass desc) {
2719             ObjectStreamField[] fields = desc.getFields();
2720             int primValueCount = 0;
2721             for (int i = 0; i &lt; fields.length; i++) {
2722                 if (fields[i].isPrimitive())
2723                     primValueCount++;
2724                 else
2725                     break;  // can be no more
2726             }
2727             return primValueCount;
2728         }
2729 
<span class="line-modified">2730         /**</span>
<span class="line-modified">2731          * Returns extractor MethodHandle taking the primValues and objValues arrays</span>
<span class="line-modified">2732          * and extracting the argument of canonical constructor with given name and type</span>





















2733          * or producing  default value for the given type if the field is absent.
2734          */
<span class="line-modified">2735         private static MethodHandle streamFieldExtractor(String pName,</span>
<span class="line-modified">2736                                                          Class&lt;?&gt; pType,</span>
<span class="line-modified">2737                                                          ObjectStreamClass desc) {</span>
<span class="line-modified">2738             ObjectStreamField[] fields = desc.getFields(false);</span>

2739 
2740             for (int i = 0; i &lt; fields.length; i++) {
2741                 ObjectStreamField f = fields[i];
2742                 String fName = f.getName();
2743                 if (!fName.equals(pName))
2744                     continue;
2745 
2746                 Class&lt;?&gt; fType = f.getField().getType();
2747                 if (!pType.isAssignableFrom(fType))
2748                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);
2749 
2750                 if (f.isPrimitive()) {
<span class="line-modified">2751                     // (byte[], int):fType</span>
<span class="line-modified">2752                     MethodHandle mh = PRIM_VALUE_EXTRACTORS.get(fType);</span>
<span class="line-modified">2753                     if (mh == null) {</span>














2754                         throw new InternalError(&quot;Unexpected type: &quot; + fType);
<span class="line-added">2755                     }</span>
<span class="line-added">2756                     // bind offset</span>
<span class="line-added">2757                     // (byte[], int):fType -&gt; (byte[]):fType</span>
<span class="line-added">2758                     mh = MethodHandles.insertArguments(mh, 1, f.getOffset());</span>
<span class="line-added">2759                     // drop objValues argument</span>
<span class="line-added">2760                     // (byte[]):fType -&gt; (byte[], Object[]):fType</span>
<span class="line-added">2761                     mh = MethodHandles.dropArguments(mh, 1, Object[].class);</span>
<span class="line-added">2762                     // adapt return type to pType</span>
<span class="line-added">2763                     // (byte[], Object[]):fType -&gt; (byte[], Object[]):pType</span>
<span class="line-added">2764                     if (pType != fType) {</span>
<span class="line-added">2765                         mh = mh.asType(mh.type().changeReturnType(pType));</span>
<span class="line-added">2766                     }</span>
<span class="line-added">2767                     return mh;</span>
2768                 } else { // reference
<span class="line-modified">2769                     // (Object[], int):Object</span>
<span class="line-added">2770                     MethodHandle mh = MethodHandles.arrayElementGetter(Object[].class);</span>
<span class="line-added">2771                     // bind index</span>
<span class="line-added">2772                     // (Object[], int):Object -&gt; (Object[]):Object</span>
<span class="line-added">2773                     mh = MethodHandles.insertArguments(mh, 1, i - numberPrimValues(desc));</span>
<span class="line-added">2774                     // drop primValues argument</span>
<span class="line-added">2775                     // (Object[]):Object -&gt; (byte[], Object[]):Object</span>
<span class="line-added">2776                     mh = MethodHandles.dropArguments(mh, 0, byte[].class);</span>
<span class="line-added">2777                     // adapt return type to pType</span>
<span class="line-added">2778                     // (byte[], Object[]):Object -&gt; (byte[], Object[]):pType</span>
<span class="line-added">2779                     if (pType != Object.class) {</span>
<span class="line-added">2780                         mh = mh.asType(mh.type().changeReturnType(pType));</span>
<span class="line-added">2781                     }</span>
<span class="line-added">2782                     return mh;</span>
2783                 }
2784             }
2785 
<span class="line-modified">2786             // return default value extractor if no field matches pName</span>
<span class="line-added">2787             return MethodHandles.empty(MethodType.methodType(pType, byte[].class, Object[].class));</span>
<span class="line-added">2788         }</span>
<span class="line-added">2789 </span>
<span class="line-added">2790         private static final Map&lt;Class&lt;?&gt;, MethodHandle&gt; PRIM_VALUE_EXTRACTORS;</span>
<span class="line-added">2791         static {</span>
<span class="line-added">2792             var lkp = MethodHandles.lookup();</span>
<span class="line-added">2793             try {</span>
<span class="line-added">2794                 PRIM_VALUE_EXTRACTORS = Map.of(</span>
<span class="line-added">2795                     byte.class, MethodHandles.arrayElementGetter(byte[].class),</span>
<span class="line-added">2796                     short.class, lkp.findStatic(Bits.class, &quot;getShort&quot;, MethodType.methodType(short.class, byte[].class, int.class)),</span>
<span class="line-added">2797                     int.class, lkp.findStatic(Bits.class, &quot;getInt&quot;, MethodType.methodType(int.class, byte[].class, int.class)),</span>
<span class="line-added">2798                     long.class, lkp.findStatic(Bits.class, &quot;getLong&quot;, MethodType.methodType(long.class, byte[].class, int.class)),</span>
<span class="line-added">2799                     float.class, lkp.findStatic(Bits.class, &quot;getFloat&quot;, MethodType.methodType(float.class, byte[].class, int.class)),</span>
<span class="line-added">2800                     double.class, lkp.findStatic(Bits.class, &quot;getDouble&quot;, MethodType.methodType(double.class, byte[].class, int.class)),</span>
<span class="line-added">2801                     char.class, lkp.findStatic(Bits.class, &quot;getChar&quot;, MethodType.methodType(char.class, byte[].class, int.class)),</span>
<span class="line-added">2802                     boolean.class, lkp.findStatic(Bits.class, &quot;getBoolean&quot;, MethodType.methodType(boolean.class, byte[].class, int.class))</span>
<span class="line-added">2803                 );</span>
<span class="line-added">2804             } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="line-added">2805                 throw new InternalError(&quot;Can&#39;t lookup Bits.getXXX&quot;, e);</span>
<span class="line-added">2806             }</span>
2807         }
2808     }
2809 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../hotspot/share/runtime/vmOperations.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>