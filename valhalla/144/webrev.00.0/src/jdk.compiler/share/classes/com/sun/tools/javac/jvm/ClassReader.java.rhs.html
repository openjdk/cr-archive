<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import java.util.function.IntFunction;
  40 
  41 import javax.lang.model.element.Modifier;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.tools.JavaFileManager;
  44 import javax.tools.JavaFileObject;
  45 
  46 import com.sun.tools.javac.code.Source.Feature;
  47 import com.sun.tools.javac.comp.Annotate;
  48 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  49 import com.sun.tools.javac.code.*;
  50 import com.sun.tools.javac.code.Directive.*;
  51 import com.sun.tools.javac.code.Lint.LintCategory;
  52 import com.sun.tools.javac.code.Scope.WriteableScope;
  53 import com.sun.tools.javac.code.Symbol.*;
  54 import com.sun.tools.javac.code.Symtab;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  57 import com.sun.tools.javac.file.BaseFileManager;
  58 import com.sun.tools.javac.file.PathFileObject;
  59 import com.sun.tools.javac.jvm.ClassFile.Version;
  60 import com.sun.tools.javac.jvm.PoolConstant.NameAndType;
  61 import com.sun.tools.javac.main.Option;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  64 import com.sun.tools.javac.util.*;
  65 import com.sun.tools.javac.util.DefinedBy.Api;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 import static com.sun.tools.javac.code.Flags.*;
  69 import static com.sun.tools.javac.code.Kinds.Kind.*;
  70 
  71 import com.sun.tools.javac.code.Scope.LookupKind;
  72 
  73 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  74 import static com.sun.tools.javac.code.TypeTag.CLASS;
  75 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  76 import static com.sun.tools.javac.jvm.ClassFile.*;
  77 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  78 
  79 import static com.sun.tools.javac.main.Option.PARAMETERS;
  80 
  81 /** This class provides operations to read a classfile into an internal
  82  *  representation. The internal representation is anchored in a
  83  *  ClassSymbol which contains in its scope symbol representations
  84  *  for all other definitions in the classfile. Top-level Classes themselves
  85  *  appear as members of the scopes of PackageSymbols.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
 108     /** Switch: allow inline types.
 109      */
 110     boolean allowInlineTypes;
 111 
 112     /** Switch: allow sealed
 113      */
 114     boolean allowSealedTypes;
 115 
 116     /** Switch: allow records
 117      */
 118     boolean allowRecords;
 119 
 120    /** Lint option: warn about classfile issues
 121      */
 122     boolean lintClassfile;
 123 
 124     /** Switch: preserve parameter names from the variable table.
 125      */
 126     public boolean saveParameterNames;
 127 
 128     /** Switch: Should javac recongnize and handle value based classes specially ?
 129      */
 130     private boolean allowValueBasedClasses;
 131 
 132     /**
 133      * The currently selected profile.
 134      */
 135     public final Profile profile;
 136 
 137     /** The log to use for verbose output
 138      */
 139     final Log log;
 140 
 141     /** The symbol table. */
 142     Symtab syms;
 143 
 144     Types types;
 145 
 146     /** The name table. */
 147     final Names names;
 148 
 149     /** Access to files
 150      */
 151     private final JavaFileManager fileManager;
 152 
 153     /** Factory for diagnostics
 154      */
 155     JCDiagnostic.Factory diagFactory;
 156 
 157     DeferredCompletionFailureHandler dcfh;
 158 
 159     /**
 160      * Support for preview language features.
 161      */
 162     Preview preview;
 163 
 164     /** The current scope where type variables are entered.
 165      */
 166     protected WriteableScope typevars;
 167 
 168     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 169     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 170 
 171     /** The path name of the class file currently being read.
 172      */
 173     protected JavaFileObject currentClassFile = null;
 174 
 175     /** The class or method currently being read.
 176      */
 177     protected Symbol currentOwner = null;
 178 
 179     /** The module containing the class currently being read.
 180      */
 181     protected ModuleSymbol currentModule = null;
 182 
 183     /** The buffer containing the currently read class file.
 184      */
 185     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);
 186 
 187     /** The current input pointer.
 188      */
 189     protected int bp;
 190 
 191     /** The pool reader.
 192      */
 193     PoolReader poolReader;
 194 
 195     /** The major version number of the class file being read. */
 196     int majorVersion;
 197     /** The minor version number of the class file being read. */
 198     int minorVersion;
 199 
 200     /** A table to hold the constant pool indices for method parameter
 201      * names, as given in LocalVariableTable attributes.
 202      */
 203     int[] parameterNameIndices;
 204 
 205     /**
 206      * A table to hold annotations for method parameters.
 207      */
 208     ParameterAnnotations[] parameterAnnotations;
 209 
 210     /**
 211      * A holder for parameter annotations.
 212      */
 213     static class ParameterAnnotations {
 214         List&lt;CompoundAnnotationProxy&gt; proxies;
 215 
 216         void add(List&lt;CompoundAnnotationProxy&gt; newAnnotations) {
 217             if (proxies == null) {
 218                 proxies = newAnnotations;
 219             } else {
 220                 proxies = proxies.prependList(newAnnotations);
 221             }
 222         }
 223     }
 224 
 225     /**
 226      * Whether or not any parameter names have been found.
 227      */
 228     boolean haveParameterNameIndices;
 229 
 230     /** Set this to false every time we start reading a method
 231      * and are saving parameter names.  Set it to true when we see
 232      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 233      * then we ignore the parameter names from the LVT.
 234      */
 235     boolean sawMethodParameters;
 236 
 237     /**
 238      * The set of attribute names for which warnings have been generated for the current class
 239      */
 240     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 241 
 242     /**
 243      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 244      * @Target
 245      */
 246     CompoundAnnotationProxy target;
 247 
 248     /**
 249      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with
 250      * @Repeatable
 251      */
 252     CompoundAnnotationProxy repeatable;
 253 
 254     /** Get the ClassReader instance for this invocation. */
 255     public static ClassReader instance(Context context) {
 256         ClassReader instance = context.get(classReaderKey);
 257         if (instance == null)
 258             instance = new ClassReader(context);
 259         return instance;
 260     }
 261 
 262     /** Construct a new class reader. */
 263     protected ClassReader(Context context) {
 264         context.put(classReaderKey, this);
 265         annotate = Annotate.instance(context);
 266         names = Names.instance(context);
 267         syms = Symtab.instance(context);
 268         types = Types.instance(context);
 269         fileManager = context.get(JavaFileManager.class);
 270         if (fileManager == null)
 271             throw new AssertionError(&quot;FileManager initialization error&quot;);
 272         diagFactory = JCDiagnostic.Factory.instance(context);
 273         dcfh = DeferredCompletionFailureHandler.instance(context);
 274 
 275         log = Log.instance(context);
 276 
 277         Options options = Options.instance(context);
 278         verbose         = options.isSet(Option.VERBOSE);
 279 
 280         Source source = Source.instance(context);
 281         preview = Preview.instance(context);
 282         allowModules     = Feature.MODULES.allowedInSource(source);
 283         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 284         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 285                 Feature.RECORDS.allowedInSource(source);
 286         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 287                 Feature.SEALED_CLASSES.allowedInSource(source);
 288 
 289         saveParameterNames = options.isSet(PARAMETERS);
 290         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 291 
 292         profile = Profile.instance(context);
 293 
 294         typevars = WriteableScope.create(syms.noSymbol);
 295 
 296         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 297 
 298         initAttributeReaders();
 299     }
 300 
 301     /** Add member to class unless it is synthetic.
 302      */
 303     private void enterMember(ClassSymbol c, Symbol sym) {
 304         // Synthetic members are not entered -- reason lost to history (optimization?).
 305         // Lambda methods must be entered because they may have inner classes (which reference them)
 306         ClassSymbol refProjection =  c.isValue() ? c.referenceProjection() : null;
 307         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda)) {
 308             c.members_field.enter(sym);
 309             if (refProjection != null) {
 310                 Symbol clone = null;
 311                 if (sym.kind == MTH) {
 312                     MethodSymbol valMethod = (MethodSymbol)sym;
 313                     MethodSymbol refMethod = valMethod.clone(refProjection);
 314                     valMethod.projection = refMethod;
 315                     refMethod.projection = valMethod;
 316                     clone = refMethod;
 317                 } else if (sym.kind == VAR) {
 318                     VarSymbol valVar = (VarSymbol)sym;
 319                     VarSymbol refVar = valVar.clone(refProjection);
 320                     valVar.projection = refVar;
 321                     refVar.projection = valVar;
 322                     clone = refVar;
 323                 }
 324                 refProjection.members_field.enter(clone);
 325             }
 326         }
 327     }
 328 
 329 /************************************************************************
 330  * Error Diagnoses
 331  ***********************************************************************/
 332 
 333     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 334         return new ClassFinder.BadClassFile (
 335             currentOwner.enclClass(),
 336             currentClassFile,
 337             diagFactory.fragment(key, args),
 338             diagFactory,
 339             dcfh);
 340     }
 341 
 342     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 343         return new ClassFinder.BadEnclosingMethodAttr (
 344             currentOwner.enclClass(),
 345             currentClassFile,
 346             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 347             diagFactory,
 348             dcfh);
 349     }
 350 
 351 /************************************************************************
 352  * Buffer Access
 353  ***********************************************************************/
 354 
 355     /** Read a character.
 356      */
 357     char nextChar() {
 358         char res = buf.getChar(bp);
 359         bp += 2;
 360         return res;
 361     }
 362 
 363     /** Read a byte.
 364      */
 365     int nextByte() {
 366         return buf.getByte(bp++) &amp; 0xFF;
 367     }
 368 
 369     /** Read an integer.
 370      */
 371     int nextInt() {
 372         int res = buf.getInt(bp);
 373         bp += 4;
 374         return res;
 375     }
 376 
 377 /************************************************************************
 378  * Constant Pool Access
 379  ***********************************************************************/
 380 
 381     /** Read module_flags.
 382      */
 383     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 384         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 385         for (ModuleFlags f : ModuleFlags.values()) {
 386             if ((flags &amp; f.value) != 0)
 387                 set.add(f);
 388         }
 389         return set;
 390     }
 391 
 392     /** Read resolution_flags.
 393      */
 394     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 395         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 396         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 397             if ((flags &amp; f.value) != 0)
 398                 set.add(f);
 399         }
 400         return set;
 401     }
 402 
 403     /** Read exports_flags.
 404      */
 405     Set&lt;ExportsFlag&gt; readExportsFlags(int flags) {
 406         Set&lt;ExportsFlag&gt; set = EnumSet.noneOf(ExportsFlag.class);
 407         for (ExportsFlag f: ExportsFlag.values()) {
 408             if ((flags &amp; f.value) != 0)
 409                 set.add(f);
 410         }
 411         return set;
 412     }
 413 
 414     /** Read opens_flags.
 415      */
 416     Set&lt;OpensFlag&gt; readOpensFlags(int flags) {
 417         Set&lt;OpensFlag&gt; set = EnumSet.noneOf(OpensFlag.class);
 418         for (OpensFlag f: OpensFlag.values()) {
 419             if ((flags &amp; f.value) != 0)
 420                 set.add(f);
 421         }
 422         return set;
 423     }
 424 
 425     /** Read requires_flags.
 426      */
 427     Set&lt;RequiresFlag&gt; readRequiresFlags(int flags) {
 428         Set&lt;RequiresFlag&gt; set = EnumSet.noneOf(RequiresFlag.class);
 429         for (RequiresFlag f: RequiresFlag.values()) {
 430             if ((flags &amp; f.value) != 0)
 431                 set.add(f);
 432         }
 433         return set;
 434     }
 435 
 436 /************************************************************************
 437  * Reading Types
 438  ***********************************************************************/
 439 
 440     /** The unread portion of the currently read type is
 441      *  signature[sigp..siglimit-1].
 442      */
 443     byte[] signature;
 444     int sigp;
 445     int siglimit;
 446     boolean sigEnterPhase = false;
 447 
 448     /** Convert signature to type, where signature is a byte array segment.
 449      */
 450     Type sigToType(byte[] sig, int offset, int len) {
 451         signature = sig;
 452         sigp = offset;
 453         siglimit = offset + len;
 454         return sigToType();
 455     }
 456 
 457     /** Convert signature to type, where signature is implicit.
 458      */
 459     Type sigToType() {
 460         switch ((char) signature[sigp]) {
 461         case &#39;T&#39;:
 462             sigp++;
 463             int start = sigp;
 464             while (signature[sigp] != &#39;;&#39;) sigp++;
 465             sigp++;
 466             return sigEnterPhase
 467                 ? Type.noType
 468                 : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));
 469         case &#39;+&#39;: {
 470             sigp++;
 471             Type t = sigToType();
 472             return new WildcardType(t, BoundKind.EXTENDS, syms.boundClass);
 473         }
 474         case &#39;*&#39;:
 475             sigp++;
 476             return new WildcardType(syms.objectType, BoundKind.UNBOUND,
 477                                     syms.boundClass);
 478         case &#39;-&#39;: {
 479             sigp++;
 480             Type t = sigToType();
 481             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 482         }
 483         case &#39;B&#39;:
 484             sigp++;
 485             return syms.byteType;
 486         case &#39;C&#39;:
 487             sigp++;
 488             return syms.charType;
 489         case &#39;D&#39;:
 490             sigp++;
 491             return syms.doubleType;
 492         case &#39;F&#39;:
 493             sigp++;
 494             return syms.floatType;
 495         case &#39;I&#39;:
 496             sigp++;
 497             return syms.intType;
 498         case &#39;J&#39;:
 499             sigp++;
 500             return syms.longType;
 501         case &#39;Q&#39;:
 502         case &#39;L&#39;:
 503             {
 504                 // int oldsigp = sigp;
 505                 Type t = classSigToType();
 506                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 507                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 508                                        &quot;(please recompile from source)&quot;);
 509                 /*
 510                 System.err.println(&quot; decoded &quot; +
 511                                    new String(signature, oldsigp, sigp-oldsigp) +
 512                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 513                 */
 514                 return t;
 515             }
 516         case &#39;S&#39;:
 517             sigp++;
 518             return syms.shortType;
 519         case &#39;V&#39;:
 520             sigp++;
 521             return syms.voidType;
 522         case &#39;Z&#39;:
 523             sigp++;
 524             return syms.booleanType;
 525         case &#39;[&#39;:
 526             sigp++;
 527             return new ArrayType(sigToType(), syms.arrayClass);
 528         case &#39;(&#39;:
 529             sigp++;
 530             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 531             Type restype = sigToType();
 532             List&lt;Type&gt; thrown = List.nil();
 533             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {
 534                 sigp++;
 535                 thrown = thrown.prepend(sigToType());
 536             }
 537             // if there is a typevar in the throws clause we should state it.
 538             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 539                 if (l.head.hasTag(TYPEVAR)) {
 540                     l.head.tsym.flags_field |= THROWS;
 541                 }
 542             }
 543             return new MethodType(argtypes,
 544                                   restype,
 545                                   thrown.reverse(),
 546                                   syms.methodClass);
 547         case &#39;&lt;&#39;:
 548             typevars = typevars.dup(currentOwner);
 549             Type poly = new ForAll(sigToTypeParams(), sigToType());
 550             typevars = typevars.leave();
 551             return poly;
 552         default:
 553             throw badClassFile(&quot;bad.signature&quot;,
 554                                Convert.utf2string(signature, sigp, 10));
 555         }
 556     }
 557 
 558     byte[] signatureBuffer = new byte[0];
 559     int sbp = 0;
 560     /** Convert class signature to type, where signature is implicit.
 561      */
 562     Type classSigToType() {
 563         if (signature[sigp] != &#39;L&#39; &amp;&amp; signature[sigp] != &#39;Q&#39;)
 564             throw badClassFile(&quot;bad.class.signature&quot;,
 565                                Convert.utf2string(signature, sigp, 10));
 566         sigp++;
 567         Type outer = Type.noType;
 568         int startSbp = sbp;
 569 
 570         while (true) {
 571             final byte c = signature[sigp++];
 572             switch (c) {
 573 
 574             case &#39;;&#39;: {         // end
 575                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 576                                                          startSbp,
 577                                                          sbp - startSbp));
 578 
 579                 try {
 580                     return (outer == Type.noType) ?
 581                             t.erasure(types) :
 582                         new ClassType(outer, List.nil(), t);
 583                 } finally {
 584                     sbp = startSbp;
 585                 }
 586             }
 587 
 588             case &#39;&lt;&#39;:           // generic arguments
 589                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 590                                                          startSbp,
 591                                                          sbp - startSbp));
 592                 outer = new ClassType(outer, sigToTypes(&#39;&gt;&#39;), t) {
 593                         boolean completed = false;
 594                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 595                         public Type getEnclosingType() {
 596                             if (!completed) {
 597                                 completed = true;
 598                                 tsym.complete();
 599                                 Type enclosingType = tsym.type.getEnclosingType();
 600                                 if (enclosingType != Type.noType) {
 601                                     List&lt;Type&gt; typeArgs =
 602                                         super.getEnclosingType().allparams();
 603                                     List&lt;Type&gt; typeParams =
 604                                         enclosingType.allparams();
 605                                     if (typeParams.length() != typeArgs.length()) {
 606                                         // no &quot;rare&quot; types
 607                                         super.setEnclosingType(types.erasure(enclosingType));
 608                                     } else {
 609                                         super.setEnclosingType(types.subst(enclosingType,
 610                                                                            typeParams,
 611                                                                            typeArgs));
 612                                     }
 613                                 } else {
 614                                     super.setEnclosingType(Type.noType);
 615                                 }
 616                             }
 617                             return super.getEnclosingType();
 618                         }
 619                         @Override
 620                         public void setEnclosingType(Type outer) {
 621                             throw new UnsupportedOperationException();
 622                         }
 623                     };
 624                 switch (signature[sigp++]) {
 625                 case &#39;;&#39;:
 626                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {
 627                         // support old-style GJC signatures
 628                         // The signature produced was
 629                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 630                         // rather than say
 631                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 632                         // so we skip past &quot;.Lfoo/Outer$&quot;
 633                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 634                             3;  // &quot;.L&quot; and &quot;$&quot;
 635                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 636                         break;
 637                     } else {
 638                         sbp = startSbp;
 639                         return outer;
 640                     }
 641                 case &#39;.&#39;:
 642                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 643                     break;
 644                 default:
 645                     throw new AssertionError(signature[sigp-1]);
 646                 }
 647                 continue;
 648 
 649             case &#39;.&#39;:
 650                 //we have seen an enclosing non-generic class
 651                 if (outer != Type.noType) {
 652                     t = enterClass(names.fromUtf(signatureBuffer,
 653                                                  startSbp,
 654                                                  sbp - startSbp));
 655                     outer = new ClassType(outer, List.nil(), t);
 656                 }
 657                 signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 658                 continue;
 659             case &#39;/&#39;:
 660                 signatureBuffer[sbp++] = (byte)&#39;.&#39;;
 661                 continue;
 662             default:
 663                 signatureBuffer[sbp++] = c;
 664                 continue;
 665             }
 666         }
 667     }
 668 
 669     /** Convert (implicit) signature to list of types
 670      *  until `terminator&#39; is encountered.
 671      */
 672     List&lt;Type&gt; sigToTypes(char terminator) {
 673         List&lt;Type&gt; head = List.of(null);
 674         List&lt;Type&gt; tail = head;
 675         while (signature[sigp] != terminator)
 676             tail = tail.setTail(List.of(sigToType()));
 677         sigp++;
 678         return head.tail;
 679     }
 680 
 681     /** Convert signature to type parameters, where signature is a byte
 682      *  array segment.
 683      */
 684     List&lt;Type&gt; sigToTypeParams(byte[] sig, int offset, int len) {
 685         signature = sig;
 686         sigp = offset;
 687         siglimit = offset + len;
 688         return sigToTypeParams();
 689     }
 690 
 691     /** Convert signature to type parameters, where signature is implicit.
 692      */
 693     List&lt;Type&gt; sigToTypeParams() {
 694         List&lt;Type&gt; tvars = List.nil();
 695         if (signature[sigp] == &#39;&lt;&#39;) {
 696             sigp++;
 697             int start = sigp;
 698             sigEnterPhase = true;
 699             while (signature[sigp] != &#39;&gt;&#39;)
 700                 tvars = tvars.prepend(sigToTypeParam());
 701             sigEnterPhase = false;
 702             sigp = start;
 703             while (signature[sigp] != &#39;&gt;&#39;)
 704                 sigToTypeParam();
 705             sigp++;
 706         }
 707         return tvars.reverse();
 708     }
 709 
 710     /** Convert (implicit) signature to type parameter.
 711      */
 712     Type sigToTypeParam() {
 713         int start = sigp;
 714         while (signature[sigp] != &#39;:&#39;) sigp++;
 715         Name name = names.fromUtf(signature, start, sigp - start);
 716         TypeVar tvar;
 717         if (sigEnterPhase) {
 718             tvar = new TypeVar(name, currentOwner, syms.botType);
 719             typevars.enter(tvar.tsym);
 720         } else {
 721             tvar = (TypeVar)findTypeVar(name);
 722         }
 723         List&lt;Type&gt; bounds = List.nil();
 724         boolean allInterfaces = false;
 725         if (signature[sigp] == &#39;:&#39; &amp;&amp; signature[sigp+1] == &#39;:&#39;) {
 726             sigp++;
 727             allInterfaces = true;
 728         }
 729         while (signature[sigp] == &#39;:&#39;) {
 730             sigp++;
 731             bounds = bounds.prepend(sigToType());
 732         }
 733         if (!sigEnterPhase) {
 734             types.setBounds(tvar, bounds.reverse(), allInterfaces);
 735         }
 736         return tvar;
 737     }
 738 
 739     /** Find type variable with given name in `typevars&#39; scope.
 740      */
 741     Type findTypeVar(Name name) {
 742         Symbol s = typevars.findFirst(name);
 743         if (s != null) {
 744             return s.type;
 745         } else {
 746             if (readingClassAttr) {
 747                 // While reading the class attribute, the supertypes
 748                 // might refer to a type variable from an enclosing element
 749                 // (method or class).
 750                 // If the type variable is defined in the enclosing class,
 751                 // we can actually find it in
 752                 // currentOwner.owner.type.getTypeArguments()
 753                 // However, until we have read the enclosing method attribute
 754                 // we don&#39;t know for sure if this owner is correct.  It could
 755                 // be a method and there is no way to tell before reading the
 756                 // enclosing method attribute.
 757                 TypeVar t = new TypeVar(name, currentOwner, syms.botType);
 758                 missingTypeVariables = missingTypeVariables.prepend(t);
 759                 // System.err.println(&quot;Missing type var &quot; + name);
 760                 return t;
 761             }
 762             throw badClassFile(&quot;undecl.type.var&quot;, name);
 763         }
 764     }
 765 
 766 /************************************************************************
 767  * Reading Attributes
 768  ***********************************************************************/
 769 
 770     protected enum AttributeKind { CLASS, MEMBER }
 771 
 772     protected abstract class AttributeReader {
 773         protected AttributeReader(Name name, ClassFile.Version version, Set&lt;AttributeKind&gt; kinds) {
 774             this.name = name;
 775             this.version = version;
 776             this.kinds = kinds;
 777         }
 778 
 779         protected boolean accepts(AttributeKind kind) {
 780             if (kinds.contains(kind)) {
 781                 if (majorVersion &gt; version.major || (majorVersion == version.major &amp;&amp; minorVersion &gt;= version.minor))
 782                     return true;
 783 
 784                 if (lintClassfile &amp;&amp; !warnedAttrs.contains(name)) {
 785                     JavaFileObject prev = log.useSource(currentClassFile);
 786                     try {
 787                         log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,
 788                                     Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));
 789                     } finally {
 790                         log.useSource(prev);
 791                     }
 792                     warnedAttrs.add(name);
 793                 }
 794             }
 795             return false;
 796         }
 797 
 798         protected abstract void read(Symbol sym, int attrLen);
 799 
 800         protected final Name name;
 801         protected final ClassFile.Version version;
 802         protected final Set&lt;AttributeKind&gt; kinds;
 803     }
 804 
 805     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 806             EnumSet.of(AttributeKind.CLASS);
 807     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 808             EnumSet.of(AttributeKind.MEMBER);
 809     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 810             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 811 
 812     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 813 
 814     private void initAttributeReaders() {
 815         AttributeReader[] readers = {
 816             // v45.3 attributes
 817 
 818             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 819                 protected void read(Symbol sym, int attrLen) {
 820                     if (allowInlineTypes) {
 821                         if (sym.isConstructor()  &amp;&amp; ((MethodSymbol) sym).type.getParameterTypes().size() == 0) {
 822                             int code_length = buf.getInt(bp + 4);
 823                             if ((code_length == 1 &amp;&amp; buf.getByte( bp + 8) == (byte) ByteCodes.return_) ||
 824                                     (code_length == 5 &amp;&amp; buf.getByte(bp + 8) == ByteCodes.aload_0 &amp;&amp;
 825                                         buf.getByte( bp + 9) == (byte) ByteCodes.invokespecial &amp;&amp;
 826                                                 buf.getByte( bp + 12) == (byte) ByteCodes.return_)) {
 827                                     sym.flags_field |= EMPTYNOARGCONSTR;
 828                             }
 829                         }
 830                     }
 831                     if (saveParameterNames)
 832                         ((MethodSymbol)sym).code = readCode(sym);
 833                     else
 834                         bp = bp + attrLen;
 835                 }
 836             },
 837 
 838             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 839                 protected void read(Symbol sym, int attrLen) {
 840                     Object v = poolReader.getConstant(nextChar());
 841                     // Ignore ConstantValue attribute if field not final.
 842                     if ((sym.flags() &amp; FINAL) == 0) {
 843                         return;
 844                     }
 845                     VarSymbol var = (VarSymbol) sym;
 846                     switch (var.type.getTag()) {
 847                        case BOOLEAN:
 848                        case BYTE:
 849                        case CHAR:
 850                        case SHORT:
 851                        case INT:
 852                            checkType(var, Integer.class, v);
 853                            break;
 854                        case LONG:
 855                            checkType(var, Long.class, v);
 856                            break;
 857                        case FLOAT:
 858                            checkType(var, Float.class, v);
 859                            break;
 860                        case DOUBLE:
 861                            checkType(var, Double.class, v);
 862                            break;
 863                        case CLASS:
 864                            if (var.type.tsym == syms.stringType.tsym) {
 865                                checkType(var, String.class, v);
 866                            } else {
 867                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);
 868                            }
 869                            break;
 870                        default:
 871                            // ignore ConstantValue attribute if type is not primitive or String
 872                            return;
 873                     }
 874                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
 875                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
 876                     }
 877                     var.setData(v);
 878                 }
 879 
 880                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
 881                     if (!clazz.isInstance(value)) {
 882                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
 883                     }
 884                 }
 885             },
 886 
 887             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 888                 protected void read(Symbol sym, int attrLen) {
 889                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
 890 
 891                     s.flags_field |= DEPRECATED;
 892                 }
 893             },
 894 
 895             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 896                 protected void read(Symbol sym, int attrLen) {
 897                     int nexceptions = nextChar();
 898                     List&lt;Type&gt; thrown = List.nil();
 899                     for (int j = 0; j &lt; nexceptions; j++)
 900                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);
 901                     if (sym.type.getThrownTypes().isEmpty())
 902                         sym.type.asMethodType().thrown = thrown.reverse();
 903                 }
 904             },
 905 
 906             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
 907                 protected void read(Symbol sym, int attrLen) {
 908                     ClassSymbol c = (ClassSymbol) sym;
 909                     if (currentModule.module_info == c) {
 910                         //prevent entering the classes too soon:
 911                         skipInnerClasses();
 912                     } else {
 913                         readInnerClasses(c);
 914                     }
 915                 }
 916             },
 917 
 918             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 919                 protected void read(Symbol sym, int attrLen) {
 920                     int newbp = bp + attrLen;
 921                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
 922                         // Pick up parameter names from the variable table.
 923                         // Parameter names are not explicitly identified as such,
 924                         // but all parameter name entries in the LocalVariableTable
 925                         // have a start_pc of 0.  Therefore, we record the name
 926                         // indices of all slots with a start_pc of zero in the
 927                         // parameterNameIndices array.
 928                         // Note that this implicitly honors the JVMS spec that
 929                         // there may be more than one LocalVariableTable, and that
 930                         // there is no specified ordering for the entries.
 931                         int numEntries = nextChar();
 932                         for (int i = 0; i &lt; numEntries; i++) {
 933                             int start_pc = nextChar();
 934                             int length = nextChar();
 935                             int nameIndex = nextChar();
 936                             int sigIndex = nextChar();
 937                             int register = nextChar();
 938                             if (start_pc == 0) {
 939                                 // ensure array large enough
 940                                 if (register &gt;= parameterNameIndices.length) {
 941                                     int newSize =
 942                                             Math.max(register + 1, parameterNameIndices.length + 8);
 943                                     parameterNameIndices =
 944                                             Arrays.copyOf(parameterNameIndices, newSize);
 945                                 }
 946                                 parameterNameIndices[register] = nameIndex;
 947                                 haveParameterNameIndices = true;
 948                             }
 949                         }
 950                     }
 951                     bp = newbp;
 952                 }
 953             },
 954 
 955             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
 956                 protected void read(Symbol sym, int attrLen) {
 957                     ClassSymbol c = (ClassSymbol) sym;
 958                     Name n = poolReader.getName(nextChar());
 959                     c.sourcefile = new SourceFileObject(n);
 960                     // If the class is a toplevel class, originating from a Java source file,
 961                     // but the class name does not match the file name, then it is
 962                     // an auxiliary class.
 963                     String sn = n.toString();
 964                     if (c.owner.kind == PCK &amp;&amp;
 965                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
 966                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
 967                         c.flags_field |= AUXILIARY;
 968                     }
 969                 }
 970             },
 971 
 972             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 973                 protected void read(Symbol sym, int attrLen) {
 974                     sym.flags_field |= SYNTHETIC;
 975                 }
 976             },
 977 
 978             // standard v49 attributes
 979 
 980             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
 981                 protected void read(Symbol sym, int attrLen) {
 982                     int newbp = bp + attrLen;
 983                     readEnclosingMethodAttr(sym);
 984                     bp = newbp;
 985                 }
 986             },
 987 
 988             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 989                 protected void read(Symbol sym, int attrLen) {
 990                     if (sym.kind == TYP) {
 991                         ClassSymbol c = (ClassSymbol) sym;
 992                         readingClassAttr = true;
 993                         try {
 994                             ClassType ct1 = (ClassType)c.type;
 995                             Assert.check(c == currentOwner);
 996                             ct1.typarams_field = poolReader.getName(nextChar())
 997                                     .map(ClassReader.this::sigToTypeParams);
 998                             ct1.supertype_field = sigToType();
 999                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
1000                             while (sigp != siglimit) is.append(sigToType());
1001                             ct1.interfaces_field = is.toList();
1002                         } finally {
1003                             readingClassAttr = false;
1004                         }
1005                     } else {
1006                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
1007                         sym.type = poolReader.getType(nextChar());
1008                         //- System.err.println(&quot; # &quot; + sym.type);
1009                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
1010                             sym.type.asMethodType().thrown = thrown;
1011 
1012                     }
1013                 }
1014             },
1015 
1016             // v49 annotation attributes
1017 
1018             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1019                 protected void read(Symbol sym, int attrLen) {
1020                     attachAnnotationDefault(sym);
1021                 }
1022             },
1023 
1024             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1025                 protected void read(Symbol sym, int attrLen) {
1026                     attachAnnotations(sym);
1027                 }
1028             },
1029 
1030             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1031                 protected void read(Symbol sym, int attrLen) {
1032                     readParameterAnnotations(sym);
1033                 }
1034             },
1035 
1036             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1037                 protected void read(Symbol sym, int attrLen) {
1038                     attachAnnotations(sym);
1039                 }
1040             },
1041 
1042             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1043                 protected void read(Symbol sym, int attrLen) {
1044                     readParameterAnnotations(sym);
1045                 }
1046             },
1047 
1048             // additional &quot;legacy&quot; v49 attributes, superseded by flags
1049 
1050             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1051                 protected void read(Symbol sym, int attrLen) {
1052                     sym.flags_field |= ANNOTATION;
1053                 }
1054             },
1055 
1056             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1057                 protected void read(Symbol sym, int attrLen) {
1058                     sym.flags_field |= BRIDGE;
1059                 }
1060             },
1061 
1062             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1063                 protected void read(Symbol sym, int attrLen) {
1064                     sym.flags_field |= ENUM;
1065                 }
1066             },
1067 
1068             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1069                 protected void read(Symbol sym, int attrLen) {
1070                     sym.flags_field |= VARARGS;
1071                 }
1072             },
1073 
1074             new AttributeReader(names.RuntimeVisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1075                 protected void read(Symbol sym, int attrLen) {
1076                     attachTypeAnnotations(sym);
1077                 }
1078             },
1079 
1080             new AttributeReader(names.RuntimeInvisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1081                 protected void read(Symbol sym, int attrLen) {
1082                     attachTypeAnnotations(sym);
1083                 }
1084             },
1085 
1086             // The following attributes for a Code attribute are not currently handled
1087             // StackMapTable
1088             // SourceDebugExtension
1089             // LineNumberTable
1090             // LocalVariableTypeTable
1091 
1092             // standard v52 attributes
1093 
1094             new AttributeReader(names.MethodParameters, V52, MEMBER_ATTRIBUTE) {
1095                 protected void read(Symbol sym, int attrlen) {
1096                     int newbp = bp + attrlen;
1097                     if (saveParameterNames) {
1098                         sawMethodParameters = true;
1099                         int numEntries = nextByte();
1100                         parameterNameIndices = new int[numEntries];
1101                         haveParameterNameIndices = true;
1102                         int index = 0;
1103                         for (int i = 0; i &lt; numEntries; i++) {
1104                             int nameIndex = nextChar();
1105                             int flags = nextChar();
1106                             if ((flags &amp; (Flags.MANDATED | Flags.SYNTHETIC)) != 0) {
1107                                 continue;
1108                             }
1109                             parameterNameIndices[index++] = nameIndex;
1110                         }
1111                     }
1112                     bp = newbp;
1113                 }
1114             },
1115 
1116             // standard v53 attributes
1117 
1118             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1119                 @Override
1120                 protected boolean accepts(AttributeKind kind) {
1121                     return super.accepts(kind) &amp;&amp; allowModules;
1122                 }
1123                 protected void read(Symbol sym, int attrLen) {
1124                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1125                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1126                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1127 
1128                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);
1129                         if (currentModule.name != moduleName) {
1130                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1131                         }
1132 
1133                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1134                         msym.flags.addAll(moduleFlags);
1135                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);
1136 
1137                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1138                         int nrequires = nextChar();
1139                         for (int i = 0; i &lt; nrequires; i++) {
1140                             ModuleSymbol rsym = poolReader.getModule(nextChar());
1141                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1142                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1143                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1144                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1145                                 }
1146                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1147                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1148                                 }
1149                             }
1150                             nextChar(); // skip compiled version
1151                             requires.add(new RequiresDirective(rsym, flags));
1152                         }
1153                         msym.requires = requires.toList();
1154                         directives.addAll(msym.requires);
1155 
1156                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1157                         int nexports = nextChar();
1158                         for (int i = 0; i &lt; nexports; i++) {
1159                             PackageSymbol p = poolReader.getPackage(nextChar());
1160                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1161                             int nto = nextChar();
1162                             List&lt;ModuleSymbol&gt; to;
1163                             if (nto == 0) {
1164                                 to = null;
1165                             } else {
1166                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1167                                 for (int t = 0; t &lt; nto; t++)
1168                                     lb.append(poolReader.getModule(nextChar()));
1169                                 to = lb.toList();
1170                             }
1171                             exports.add(new ExportsDirective(p, to, flags));
1172                         }
1173                         msym.exports = exports.toList();
1174                         directives.addAll(msym.exports);
1175                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1176                         int nopens = nextChar();
1177                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1178                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1179                         }
1180                         for (int i = 0; i &lt; nopens; i++) {
1181                             PackageSymbol p = poolReader.getPackage(nextChar());
1182                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1183                             int nto = nextChar();
1184                             List&lt;ModuleSymbol&gt; to;
1185                             if (nto == 0) {
1186                                 to = null;
1187                             } else {
1188                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1189                                 for (int t = 0; t &lt; nto; t++)
1190                                     lb.append(poolReader.getModule(nextChar()));
1191                                 to = lb.toList();
1192                             }
1193                             opens.add(new OpensDirective(p, to, flags));
1194                         }
1195                         msym.opens = opens.toList();
1196                         directives.addAll(msym.opens);
1197 
1198                         msym.directives = directives.toList();
1199 
1200                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1201                         int nuses = nextChar();
1202                         for (int i = 0; i &lt; nuses; i++) {
1203                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1204                             uses.add(new InterimUsesDirective(srvc));
1205                         }
1206                         interimUses = uses.toList();
1207 
1208                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1209                         int nprovides = nextChar();
1210                         for (int p = 0; p &lt; nprovides; p++) {
1211                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1212                             int nimpls = nextChar();
1213                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1214                             for (int i = 0; i &lt; nimpls; i++) {
1215                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));
1216                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1217                             }
1218                         }
1219                         interimProvides = provides.toList();
1220                     }
1221                 }
1222 
1223                 private Name classNameMapper(byte[] arr, int offset, int length) {
1224                     return names.fromUtf(ClassFile.internalize(arr, offset, length));
1225                 }
1226             },
1227 
1228             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1229                 @Override
1230                 protected boolean accepts(AttributeKind kind) {
1231                     return super.accepts(kind) &amp;&amp; allowModules;
1232                 }
1233                 protected void read(Symbol sym, int attrLen) {
1234                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1235                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1236                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1237                     }
1238                 }
1239             },
1240 
1241             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1242                 @Override
1243                 protected boolean accepts(AttributeKind kind) {
1244                     return super.accepts(kind) &amp;&amp; allowRecords;
1245                 }
1246                 protected void read(Symbol sym, int attrLen) {
1247                     if (sym.kind == TYP) {
1248                         sym.flags_field |= RECORD;
1249                     }
1250                     bp = bp + attrLen;
1251                 }
1252             },
1253             new AttributeReader(names.PermittedSubclasses, V59, CLASS_ATTRIBUTE) {
1254                 @Override
1255                 protected boolean accepts(AttributeKind kind) {
1256                     return super.accepts(kind) &amp;&amp; allowSealedTypes;
1257                 }
1258                 protected void read(Symbol sym, int attrLen) {
1259                     if (sym.kind == TYP) {
1260                         ListBuffer&lt;Symbol&gt; subtypes = new ListBuffer&lt;&gt;();
1261                         int numberOfPermittedSubtypes = nextChar();
1262                         for (int i = 0; i &lt; numberOfPermittedSubtypes; i++) {
1263                             subtypes.add(poolReader.getClass(nextChar()));
1264                         }
1265                         ((ClassSymbol)sym).permitted = subtypes.toList();
1266                     }
1267                 }
1268             },
1269         };
1270 
1271         for (AttributeReader r: readers)
1272             attributeReaders.put(r.name, r);
1273     }
1274 
1275     protected void readEnclosingMethodAttr(Symbol sym) {
1276         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1277         // remove sym from it&#39;s current owners scope and place it in
1278         // the scope specified by the attribute
1279         sym.owner.members().remove(sym);
1280         ClassSymbol self = (ClassSymbol)sym;
1281         ClassSymbol c = poolReader.getClass(nextChar());
1282         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1283 
1284         if (c.members_field == null || c.kind != TYP)
1285             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1286 
1287         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1288         if (nt != null &amp;&amp; m == null)
1289             throw badEnclosingMethod(self);
1290 
1291         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1292         self.owner = m != null ? m : c;
1293         if (self.name.isEmpty())
1294             self.fullname = names.empty;
1295         else
1296             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1297 
1298         if (m != null) {
1299             ((ClassType)sym.type).setEnclosingType(m.type);
1300         } else if ((self.flags_field &amp; STATIC) == 0) {
1301             ((ClassType)sym.type).setEnclosingType(c.type);
1302         } else {
1303             ((ClassType)sym.type).setEnclosingType(Type.noType);
1304         }
1305         enterTypevars(self, self.type);
1306         if (!missingTypeVariables.isEmpty()) {
1307             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1308             for (Type typevar : missingTypeVariables) {
1309                 typeVars.append(findTypeVar(typevar.tsym.name));
1310             }
1311             foundTypeVariables = typeVars.toList();
1312         } else {
1313             foundTypeVariables = List.nil();
1314         }
1315     }
1316 
1317     // See java.lang.Class
1318     private Name simpleBinaryName(Name self, Name enclosing) {
1319         if (!self.startsWith(enclosing)) {
1320             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1321         }
1322 
1323         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1324         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1325             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1326         int index = 1;
1327         while (index &lt; simpleBinaryName.length() &amp;&amp;
1328                isAsciiDigit(simpleBinaryName.charAt(index)))
1329             index++;
1330         return names.fromString(simpleBinaryName.substring(index));
1331     }
1332 
1333     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1334         if (nt == null)
1335             return null;
1336 
1337         MethodType type = nt.type.asMethodType();
1338 
1339         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1340             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1341                 return (MethodSymbol)sym;
1342         }
1343 
1344         if (nt.name != names.init)
1345             // not a constructor
1346             return null;
1347         if ((flags &amp; INTERFACE) != 0)
1348             // no enclosing instance
1349             return null;
1350         if (nt.type.getParameterTypes().isEmpty())
1351             // no parameters
1352             return null;
1353 
1354         // A constructor of an inner class.
1355         // Remove the first argument (the enclosing instance)
1356         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,
1357                                  nt.type.getReturnType(),
1358                                  nt.type.getThrownTypes(),
1359                                  syms.methodClass));
1360         // Try searching again
1361         return findMethod(nt, scope, flags);
1362     }
1363 
1364     /** Similar to Types.isSameType but avoids completion */
1365     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1366         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1367             .prepend(types.erasure(mt1.getReturnType()));
1368         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1369         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1370             if (types1.head.tsym != types2.head.tsym)
1371                 return false;
1372             types1 = types1.tail;
1373             types2 = types2.tail;
1374         }
1375         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1376     }
1377 
1378     /**
1379      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1380      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1381      */
1382     private static boolean isAsciiDigit(char c) {
1383         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1384     }
1385 
1386     /** Read member attributes.
1387      */
1388     void readMemberAttrs(Symbol sym) {
1389         readAttrs(sym, AttributeKind.MEMBER);
1390     }
1391 
1392     void readAttrs(Symbol sym, AttributeKind kind) {
1393         char ac = nextChar();
1394         for (int i = 0; i &lt; ac; i++) {
1395             Name attrName = poolReader.getName(nextChar());
1396             int attrLen = nextInt();
1397             AttributeReader r = attributeReaders.get(attrName);
1398             if (r != null &amp;&amp; r.accepts(kind))
1399                 r.read(sym, attrLen);
1400             else  {
1401                 bp = bp + attrLen;
1402             }
1403         }
1404     }
1405 
1406     private boolean readingClassAttr = false;
1407     private List&lt;Type&gt; missingTypeVariables = List.nil();
1408     private List&lt;Type&gt; foundTypeVariables = List.nil();
1409 
1410     /** Read class attributes.
1411      */
1412     void readClassAttrs(ClassSymbol c) {
1413         readAttrs(c, AttributeKind.CLASS);
1414     }
1415 
1416     /** Read code block.
1417      */
1418     Code readCode(Symbol owner) {
1419         nextChar(); // max_stack
1420         nextChar(); // max_locals
1421         final int  code_length = nextInt();
1422         bp += code_length;
1423         final char exception_table_length = nextChar();
1424         bp += exception_table_length * 8;
1425         readMemberAttrs(owner);
1426         return null;
1427     }
1428 
1429 /************************************************************************
1430  * Reading Java-language annotations
1431  ***********************************************************************/
1432 
1433     /**
1434      * Save annotations.
1435      */
1436     List&lt;CompoundAnnotationProxy&gt; readAnnotations() {
1437         int numAttributes = nextChar();
1438         ListBuffer&lt;CompoundAnnotationProxy&gt; annotations = new ListBuffer&lt;&gt;();
1439         for (int i = 0; i &lt; numAttributes; i++) {
1440             annotations.append(readCompoundAnnotation());
1441         }
1442         return annotations.toList();
1443     }
1444 
1445     /** Attach annotations.
1446      */
1447     void attachAnnotations(final Symbol sym) {
1448         attachAnnotations(sym, readAnnotations());
1449     }
1450 
1451     /**
1452      * Attach annotations.
1453      */
1454     void attachAnnotations(final Symbol sym, List&lt;CompoundAnnotationProxy&gt; annotations) {
1455         if (annotations.isEmpty()) {
1456             return;
1457         }
1458         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1459         for (CompoundAnnotationProxy proxy : annotations) {
1460             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1461                 sym.flags_field |= PROPRIETARY;
1462             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1463                 if (profile != Profile.DEFAULT) {
1464                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1465                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1466                             Attribute.Constant c = (Attribute.Constant)v.snd;
1467                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1468                                 sym.flags_field |= NOT_IN_PROFILE;
1469                             }
1470                         }
1471                     }
1472                 }
<a name="1" id="anc1"></a><span class="line-added">1473             } else if (proxy.type.tsym.flatName() == syms.previewFeatureInternalType.tsym.flatName()) {</span>
<span class="line-added">1474                 sym.flags_field |= PREVIEW_API;</span>
<span class="line-added">1475                 setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);</span>
1476             } else {
1477                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1478                     target = proxy;
1479                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1480                     repeatable = proxy;
1481                 } else if (allowValueBasedClasses &amp;&amp; sym.kind == TYP &amp;&amp; proxy.type.tsym == syms.valueBasedType.tsym) {
1482                     sym.flags_field |= VALUEBASED;
1483                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1484                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1485                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1486                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1487                     sym.flags_field |= PREVIEW_API;
1488                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1489                 }
1490                 proxies.append(proxy);
1491             }
1492         }
1493         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1494     }
1495     //where:
1496         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1497             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1498                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1499                     Attribute.Constant c = (Attribute.Constant)v.snd;
1500                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1501                         sym.flags_field |= flag;
1502                     }
1503                 }
1504             }
1505         }
1506 
1507     /** Read parameter annotations.
1508      */
1509     void readParameterAnnotations(Symbol meth) {
1510         int numParameters = buf.getByte(bp++) &amp; 0xFF;
1511         if (parameterAnnotations == null) {
1512             parameterAnnotations = new ParameterAnnotations[numParameters];
1513         } else if (parameterAnnotations.length != numParameters) {
1514             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1515         }
1516         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1517             if (parameterAnnotations[pnum] == null) {
1518                 parameterAnnotations[pnum] = new ParameterAnnotations();
1519             }
1520             parameterAnnotations[pnum].add(readAnnotations());
1521         }
1522     }
1523 
1524     void attachTypeAnnotations(final Symbol sym) {
1525         int numAttributes = nextChar();
1526         if (numAttributes != 0) {
1527             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1528             for (int i = 0; i &lt; numAttributes; i++)
1529                 proxies.append(readTypeAnnotation());
1530             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
1531         }
1532     }
1533 
1534     /** Attach the default value for an annotation element.
1535      */
1536     void attachAnnotationDefault(final Symbol sym) {
1537         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1538         final Attribute value = readAttributeValue();
1539 
1540         // The default value is set later during annotation. It might
1541         // be the case that the Symbol sym is annotated _after_ the
1542         // repeating instances that depend on this default value,
1543         // because of this we set an interim value that tells us this
1544         // element (most likely) has a default.
1545         //
1546         // Set interim value for now, reset just before we do this
1547         // properly at annotate time.
1548         meth.defaultValue = value;
1549         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1550     }
1551 
1552     Type readTypeOrClassSymbol(int i) {
1553         // support preliminary jsr175-format class files
1554         if (poolReader.hasTag(i, CONSTANT_Class))
1555             return poolReader.getClass(i).type;
1556         return readTypeToProxy(i);
1557     }
1558     Type readTypeToProxy(int i) {
1559         if (currentModule.module_info == currentOwner) {
1560             return new ProxyType(i);
1561         } else {
1562             return poolReader.getType(i);
1563         }
1564     }
1565 
1566     CompoundAnnotationProxy readCompoundAnnotation() {
1567         Type t;
1568         if (currentModule.module_info == currentOwner) {
1569             int cpIndex = nextChar();
1570             t = new ProxyType(cpIndex);
1571         } else {
1572             t = readTypeOrClassSymbol(nextChar());
1573         }
1574         int numFields = nextChar();
1575         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1576         for (int i=0; i&lt;numFields; i++) {
1577             Name name = poolReader.getName(nextChar());
1578             Attribute value = readAttributeValue();
1579             pairs.append(new Pair&lt;&gt;(name, value));
1580         }
1581         return new CompoundAnnotationProxy(t, pairs.toList());
1582     }
1583 
1584     TypeAnnotationProxy readTypeAnnotation() {
1585         TypeAnnotationPosition position = readPosition();
1586         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1587 
1588         return new TypeAnnotationProxy(proxy, position);
1589     }
1590 
1591     TypeAnnotationPosition readPosition() {
1592         int tag = nextByte(); // TargetType tag is a byte
1593 
1594         if (!TargetType.isValidTargetTypeValue(tag))
1595             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1596 
1597         TargetType type = TargetType.fromTargetTypeValue(tag);
1598 
1599         switch (type) {
1600         // instanceof
1601         case INSTANCEOF: {
1602             final int offset = nextChar();
1603             final TypeAnnotationPosition position =
1604                 TypeAnnotationPosition.instanceOf(readTypePath());
1605             position.offset = offset;
1606             return position;
1607         }
1608         // new expression
1609         case NEW: {
1610             final int offset = nextChar();
1611             final TypeAnnotationPosition position =
1612                 TypeAnnotationPosition.newObj(readTypePath());
1613             position.offset = offset;
1614             return position;
1615         }
1616         // constructor/method reference receiver
1617         case CONSTRUCTOR_REFERENCE: {
1618             final int offset = nextChar();
1619             final TypeAnnotationPosition position =
1620                 TypeAnnotationPosition.constructorRef(readTypePath());
1621             position.offset = offset;
1622             return position;
1623         }
1624         case METHOD_REFERENCE: {
1625             final int offset = nextChar();
1626             final TypeAnnotationPosition position =
1627                 TypeAnnotationPosition.methodRef(readTypePath());
1628             position.offset = offset;
1629             return position;
1630         }
1631         // local variable
1632         case LOCAL_VARIABLE: {
1633             final int table_length = nextChar();
1634             final int[] newLvarOffset = new int[table_length];
1635             final int[] newLvarLength = new int[table_length];
1636             final int[] newLvarIndex = new int[table_length];
1637 
1638             for (int i = 0; i &lt; table_length; ++i) {
1639                 newLvarOffset[i] = nextChar();
1640                 newLvarLength[i] = nextChar();
1641                 newLvarIndex[i] = nextChar();
1642             }
1643 
1644             final TypeAnnotationPosition position =
1645                     TypeAnnotationPosition.localVariable(readTypePath());
1646             position.lvarOffset = newLvarOffset;
1647             position.lvarLength = newLvarLength;
1648             position.lvarIndex = newLvarIndex;
1649             return position;
1650         }
1651         // resource variable
1652         case RESOURCE_VARIABLE: {
1653             final int table_length = nextChar();
1654             final int[] newLvarOffset = new int[table_length];
1655             final int[] newLvarLength = new int[table_length];
1656             final int[] newLvarIndex = new int[table_length];
1657 
1658             for (int i = 0; i &lt; table_length; ++i) {
1659                 newLvarOffset[i] = nextChar();
1660                 newLvarLength[i] = nextChar();
1661                 newLvarIndex[i] = nextChar();
1662             }
1663 
1664             final TypeAnnotationPosition position =
1665                     TypeAnnotationPosition.resourceVariable(readTypePath());
1666             position.lvarOffset = newLvarOffset;
1667             position.lvarLength = newLvarLength;
1668             position.lvarIndex = newLvarIndex;
1669             return position;
1670         }
1671         // exception parameter
1672         case EXCEPTION_PARAMETER: {
1673             final int exception_index = nextChar();
1674             final TypeAnnotationPosition position =
1675                 TypeAnnotationPosition.exceptionParameter(readTypePath());
1676             position.setExceptionIndex(exception_index);
1677             return position;
1678         }
1679         // method receiver
1680         case METHOD_RECEIVER:
1681             return TypeAnnotationPosition.methodReceiver(readTypePath());
1682         // type parameter
1683         case CLASS_TYPE_PARAMETER: {
1684             final int parameter_index = nextByte();
1685             return TypeAnnotationPosition
1686                 .typeParameter(readTypePath(), parameter_index);
1687         }
1688         case METHOD_TYPE_PARAMETER: {
1689             final int parameter_index = nextByte();
1690             return TypeAnnotationPosition
1691                 .methodTypeParameter(readTypePath(), parameter_index);
1692         }
1693         // type parameter bound
1694         case CLASS_TYPE_PARAMETER_BOUND: {
1695             final int parameter_index = nextByte();
1696             final int bound_index = nextByte();
1697             return TypeAnnotationPosition
1698                 .typeParameterBound(readTypePath(), parameter_index,
1699                                     bound_index);
1700         }
1701         case METHOD_TYPE_PARAMETER_BOUND: {
1702             final int parameter_index = nextByte();
1703             final int bound_index = nextByte();
1704             return TypeAnnotationPosition
1705                 .methodTypeParameterBound(readTypePath(), parameter_index,
1706                                           bound_index);
1707         }
1708         // class extends or implements clause
1709         case CLASS_EXTENDS: {
1710             final int type_index = nextChar();
1711             return TypeAnnotationPosition.classExtends(readTypePath(),
1712                                                        type_index);
1713         }
1714         // throws
1715         case THROWS: {
1716             final int type_index = nextChar();
1717             return TypeAnnotationPosition.methodThrows(readTypePath(),
1718                                                        type_index);
1719         }
1720         // method parameter
1721         case METHOD_FORMAL_PARAMETER: {
1722             final int parameter_index = nextByte();
1723             return TypeAnnotationPosition.methodParameter(readTypePath(),
1724                                                           parameter_index);
1725         }
1726         // type cast
1727         case CAST: {
1728             final int offset = nextChar();
1729             final int type_index = nextByte();
1730             final TypeAnnotationPosition position =
1731                 TypeAnnotationPosition.typeCast(readTypePath(), type_index);
1732             position.offset = offset;
1733             return position;
1734         }
1735         // method/constructor/reference type argument
1736         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: {
1737             final int offset = nextChar();
1738             final int type_index = nextByte();
1739             final TypeAnnotationPosition position = TypeAnnotationPosition
1740                 .constructorInvocationTypeArg(readTypePath(), type_index);
1741             position.offset = offset;
1742             return position;
1743         }
1744         case METHOD_INVOCATION_TYPE_ARGUMENT: {
1745             final int offset = nextChar();
1746             final int type_index = nextByte();
1747             final TypeAnnotationPosition position = TypeAnnotationPosition
1748                 .methodInvocationTypeArg(readTypePath(), type_index);
1749             position.offset = offset;
1750             return position;
1751         }
1752         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: {
1753             final int offset = nextChar();
1754             final int type_index = nextByte();
1755             final TypeAnnotationPosition position = TypeAnnotationPosition
1756                 .constructorRefTypeArg(readTypePath(), type_index);
1757             position.offset = offset;
1758             return position;
1759         }
1760         case METHOD_REFERENCE_TYPE_ARGUMENT: {
1761             final int offset = nextChar();
1762             final int type_index = nextByte();
1763             final TypeAnnotationPosition position = TypeAnnotationPosition
1764                 .methodRefTypeArg(readTypePath(), type_index);
1765             position.offset = offset;
1766             return position;
1767         }
1768         // We don&#39;t need to worry about these
1769         case METHOD_RETURN:
1770             return TypeAnnotationPosition.methodReturn(readTypePath());
1771         case FIELD:
1772             return TypeAnnotationPosition.field(readTypePath());
1773         case UNKNOWN:
1774             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1775         default:
1776             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1777         }
1778     }
1779 
1780     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1781         int len = nextByte();
1782         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1783         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1784             loc = loc.append(nextByte());
1785 
1786         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1787 
1788     }
1789 
1790     /**
1791      * Helper function to read an optional pool entry (with given function); this is used while parsing
1792      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,
1793      * as per JVMS.
1794      */
1795     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {
1796         return (index == 0) ?
1797                 defaultValue :
1798                 poolFunc.apply(index);
1799     }
1800 
1801     Attribute readAttributeValue() {
1802         char c = (char) buf.getByte(bp++);
1803         switch (c) {
1804         case &#39;B&#39;:
1805             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));
1806         case &#39;C&#39;:
1807             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));
1808         case &#39;D&#39;:
1809             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));
1810         case &#39;F&#39;:
1811             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));
1812         case &#39;I&#39;:
1813             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));
1814         case &#39;J&#39;:
1815             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));
1816         case &#39;S&#39;:
1817             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));
1818         case &#39;Z&#39;:
1819             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));
1820         case &#39;s&#39;:
1821             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());
1822         case &#39;e&#39;:
1823             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));
1824         case &#39;c&#39;:
1825             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1826         case &#39;[&#39;: {
1827             int n = nextChar();
1828             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1829             for (int i=0; i&lt;n; i++)
1830                 l.append(readAttributeValue());
1831             return new ArrayAttributeProxy(l.toList());
1832         }
1833         case &#39;@&#39;:
1834             return readCompoundAnnotation();
1835         default:
1836             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
1837         }
1838     }
1839 
1840     interface ProxyVisitor extends Attribute.Visitor {
1841         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
1842         void visitClassAttributeProxy(ClassAttributeProxy proxy);
1843         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
1844         void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy);
1845     }
1846 
1847     static class EnumAttributeProxy extends Attribute {
1848         Type enumType;
1849         Name enumerator;
1850         public EnumAttributeProxy(Type enumType, Name enumerator) {
1851             super(null);
1852             this.enumType = enumType;
1853             this.enumerator = enumerator;
1854         }
1855         public void accept(Visitor v) { ((ProxyVisitor)v).visitEnumAttributeProxy(this); }
1856         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1857         public String toString() {
1858             return &quot;/*proxy enum*/&quot; + enumType + &quot;.&quot; + enumerator;
1859         }
1860     }
1861 
1862     static class ClassAttributeProxy extends Attribute {
1863         Type classType;
1864         public ClassAttributeProxy(Type classType) {
1865             super(null);
1866             this.classType = classType;
1867         }
1868         public void accept(Visitor v) { ((ProxyVisitor)v).visitClassAttributeProxy(this); }
1869         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1870         public String toString() {
1871             return &quot;/*proxy class*/&quot; + classType + &quot;.class&quot;;
1872         }
1873     }
1874 
1875     static class ArrayAttributeProxy extends Attribute {
1876         List&lt;Attribute&gt; values;
1877         ArrayAttributeProxy(List&lt;Attribute&gt; values) {
1878             super(null);
1879             this.values = values;
1880         }
1881         public void accept(Visitor v) { ((ProxyVisitor)v).visitArrayAttributeProxy(this); }
1882         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1883         public String toString() {
1884             return &quot;{&quot; + values + &quot;}&quot;;
1885         }
1886     }
1887 
1888     /** A temporary proxy representing a compound attribute.
1889      */
1890     static class CompoundAnnotationProxy extends Attribute {
1891         final List&lt;Pair&lt;Name,Attribute&gt;&gt; values;
1892         public CompoundAnnotationProxy(Type type,
1893                                       List&lt;Pair&lt;Name,Attribute&gt;&gt; values) {
1894             super(type);
1895             this.values = values;
1896         }
1897         public void accept(Visitor v) { ((ProxyVisitor)v).visitCompoundAnnotationProxy(this); }
1898         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1899         public String toString() {
1900             StringBuilder buf = new StringBuilder();
1901             buf.append(&quot;@&quot;);
1902             buf.append(type.tsym.getQualifiedName());
1903             buf.append(&quot;/*proxy*/{&quot;);
1904             boolean first = true;
1905             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; v = values;
1906                  v.nonEmpty(); v = v.tail) {
1907                 Pair&lt;Name,Attribute&gt; value = v.head;
1908                 if (!first) buf.append(&quot;,&quot;);
1909                 first = false;
1910                 buf.append(value.fst);
1911                 buf.append(&quot;=&quot;);
1912                 buf.append(value.snd);
1913             }
1914             buf.append(&quot;}&quot;);
1915             return buf.toString();
1916         }
1917     }
1918 
1919     /** A temporary proxy representing a type annotation.
1920      */
1921     static class TypeAnnotationProxy {
1922         final CompoundAnnotationProxy compound;
1923         final TypeAnnotationPosition position;
1924         public TypeAnnotationProxy(CompoundAnnotationProxy compound,
1925                 TypeAnnotationPosition position) {
1926             this.compound = compound;
1927             this.position = position;
1928         }
1929     }
1930 
1931     class AnnotationDeproxy implements ProxyVisitor {
1932         private ClassSymbol requestingOwner;
1933 
1934         AnnotationDeproxy(ClassSymbol owner) {
1935             this.requestingOwner = owner;
1936         }
1937 
1938         List&lt;Attribute.Compound&gt; deproxyCompoundList(List&lt;CompoundAnnotationProxy&gt; pl) {
1939             // also must fill in types!!!!
1940             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
1941             for (List&lt;CompoundAnnotationProxy&gt; l = pl; l.nonEmpty(); l=l.tail) {
1942                 buf.append(deproxyCompound(l.head));
1943             }
1944             return buf.toList();
1945         }
1946 
1947         Attribute.Compound deproxyCompound(CompoundAnnotationProxy a) {
1948             Type annotationType = resolvePossibleProxyType(a.type);
1949             ListBuffer&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; buf = new ListBuffer&lt;&gt;();
1950             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; l = a.values;
1951                  l.nonEmpty();
1952                  l = l.tail) {
1953                 MethodSymbol meth = findAccessMethod(annotationType, l.head.fst);
1954                 buf.append(new Pair&lt;&gt;(meth, deproxy(meth.type.getReturnType(), l.head.snd)));
1955             }
1956             return new Attribute.Compound(annotationType, buf.toList());
1957         }
1958 
1959         MethodSymbol findAccessMethod(Type container, Name name) {
1960             CompletionFailure failure = null;
1961             try {
1962                 for (Symbol sym : container.tsym.members().getSymbolsByName(name)) {
1963                     if (sym.kind == MTH &amp;&amp; sym.type.getParameterTypes().length() == 0)
1964                         return (MethodSymbol) sym;
1965                 }
1966             } catch (CompletionFailure ex) {
1967                 failure = ex;
1968             }
1969             // The method wasn&#39;t found: emit a warning and recover
1970             JavaFileObject prevSource = log.useSource(requestingOwner.classfile);
1971             try {
1972                 if (lintClassfile) {
1973                     if (failure == null) {
1974                         log.warning(Warnings.AnnotationMethodNotFound(container, name));
1975                     } else {
1976                         log.warning(Warnings.AnnotationMethodNotFoundReason(container,
1977                                                                             name,
1978                                                                             failure.getDetailValue()));//diagnostic, if present
1979                     }
1980                 }
1981             } finally {
1982                 log.useSource(prevSource);
1983             }
1984             // Construct a new method type and symbol.  Use bottom
1985             // type (typeof null) as return type because this type is
1986             // a subtype of all reference types and can be converted
1987             // to primitive types by unboxing.
1988             MethodType mt = new MethodType(List.nil(),
1989                                            syms.botType,
1990                                            List.nil(),
1991                                            syms.methodClass);
1992             return new MethodSymbol(PUBLIC | ABSTRACT, name, mt, container.tsym);
1993         }
1994 
1995         Attribute result;
1996         Type type;
1997         Attribute deproxy(Type t, Attribute a) {
1998             Type oldType = type;
1999             try {
2000                 type = t;
2001                 a.accept(this);
2002                 return result;
2003             } finally {
2004                 type = oldType;
2005             }
2006         }
2007 
2008         // implement Attribute.Visitor below
2009 
2010         public void visitConstant(Attribute.Constant value) {
2011             // assert value.type == type;
2012             result = value;
2013         }
2014 
2015         public void visitClass(Attribute.Class clazz) {
2016             result = clazz;
2017         }
2018 
2019         public void visitEnum(Attribute.Enum e) {
2020             throw new AssertionError(); // shouldn&#39;t happen
2021         }
2022 
2023         public void visitCompound(Attribute.Compound compound) {
2024             throw new AssertionError(); // shouldn&#39;t happen
2025         }
2026 
2027         public void visitArray(Attribute.Array array) {
2028             throw new AssertionError(); // shouldn&#39;t happen
2029         }
2030 
2031         public void visitError(Attribute.Error e) {
2032             throw new AssertionError(); // shouldn&#39;t happen
2033         }
2034 
2035         public void visitEnumAttributeProxy(EnumAttributeProxy proxy) {
2036             // type.tsym.flatName() should == proxy.enumFlatName
2037             Type enumType = resolvePossibleProxyType(proxy.enumType);
2038             TypeSymbol enumTypeSym = enumType.tsym;
2039             VarSymbol enumerator = null;
2040             CompletionFailure failure = null;
2041             try {
2042                 for (Symbol sym : enumTypeSym.members().getSymbolsByName(proxy.enumerator)) {
2043                     if (sym.kind == VAR) {
2044                         enumerator = (VarSymbol)sym;
2045                         break;
2046                     }
2047                 }
2048             }
2049             catch (CompletionFailure ex) {
2050                 failure = ex;
2051             }
2052             if (enumerator == null) {
2053                 if (failure != null) {
2054                     log.warning(Warnings.UnknownEnumConstantReason(currentClassFile,
2055                                                                    enumTypeSym,
2056                                                                    proxy.enumerator,
2057                                                                    failure.getDiagnostic()));
2058                 } else {
2059                     log.warning(Warnings.UnknownEnumConstant(currentClassFile,
2060                                                              enumTypeSym,
2061                                                              proxy.enumerator));
2062                 }
2063                 result = new Attribute.Enum(enumTypeSym.type,
2064                         new VarSymbol(0, proxy.enumerator, syms.botType, enumTypeSym));
2065             } else {
2066                 result = new Attribute.Enum(enumTypeSym.type, enumerator);
2067             }
2068         }
2069 
2070         @Override
2071         public void visitClassAttributeProxy(ClassAttributeProxy proxy) {
2072             Type classType = resolvePossibleProxyType(proxy.classType);
2073             result = new Attribute.Class(types, classType);
2074         }
2075 
2076         public void visitArrayAttributeProxy(ArrayAttributeProxy proxy) {
2077             int length = proxy.values.length();
2078             Attribute[] ats = new Attribute[length];
2079             Type elemtype = types.elemtype(type);
2080             int i = 0;
2081             for (List&lt;Attribute&gt; p = proxy.values; p.nonEmpty(); p = p.tail) {
2082                 ats[i++] = deproxy(elemtype, p.head);
2083             }
2084             result = new Attribute.Array(type, ats);
2085         }
2086 
2087         public void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy) {
2088             result = deproxyCompound(proxy);
2089         }
2090 
2091         Type resolvePossibleProxyType(Type t) {
2092             if (t instanceof ProxyType) {
2093                 Assert.check(requestingOwner.owner.kind == MDL);
2094                 ModuleSymbol prevCurrentModule = currentModule;
2095                 currentModule = (ModuleSymbol) requestingOwner.owner;
2096                 try {
2097                     return ((ProxyType) t).resolve();
2098                 } finally {
2099                     currentModule = prevCurrentModule;
2100                 }
2101             } else {
2102                 return t;
2103             }
2104         }
2105     }
2106 
2107     class AnnotationDefaultCompleter extends AnnotationDeproxy implements Runnable {
2108         final MethodSymbol sym;
2109         final Attribute value;
2110         final JavaFileObject classFile = currentClassFile;
2111 
2112         AnnotationDefaultCompleter(MethodSymbol sym, Attribute value) {
2113             super(currentOwner.kind == MTH
2114                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2115             this.sym = sym;
2116             this.value = value;
2117         }
2118 
2119         @Override
2120         public void run() {
2121             JavaFileObject previousClassFile = currentClassFile;
2122             try {
2123                 // Reset the interim value set earlier in
2124                 // attachAnnotationDefault().
2125                 sym.defaultValue = null;
2126                 currentClassFile = classFile;
2127                 sym.defaultValue = deproxy(sym.type.getReturnType(), value);
2128             } finally {
2129                 currentClassFile = previousClassFile;
2130             }
2131         }
2132 
2133         @Override
2134         public String toString() {
2135             return &quot; ClassReader store default for &quot; + sym.owner + &quot;.&quot; + sym + &quot; is &quot; + value;
2136         }
2137     }
2138 
2139     class AnnotationCompleter extends AnnotationDeproxy implements Runnable {
2140         final Symbol sym;
2141         final List&lt;CompoundAnnotationProxy&gt; l;
2142         final JavaFileObject classFile;
2143 
2144         AnnotationCompleter(Symbol sym, List&lt;CompoundAnnotationProxy&gt; l) {
2145             super(currentOwner.kind == MTH
2146                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2147             if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
2148                 this.sym = sym.owner;
2149             } else {
2150                 this.sym = sym;
2151             }
2152             this.l = l;
2153             this.classFile = currentClassFile;
2154         }
2155 
2156         @Override
2157         public void run() {
2158             JavaFileObject previousClassFile = currentClassFile;
2159             try {
2160                 currentClassFile = classFile;
2161                 List&lt;Attribute.Compound&gt; newList = deproxyCompoundList(l);
2162                 for (Attribute.Compound attr : newList) {
2163                     if (attr.type.tsym == syms.deprecatedType.tsym) {
2164                         sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
2165                         Attribute forRemoval = attr.member(names.forRemoval);
2166                         if (forRemoval instanceof Attribute.Constant) {
2167                             Attribute.Constant c = (Attribute.Constant) forRemoval;
2168                             if (c.type == syms.booleanType &amp;&amp; ((Integer) c.value) != 0) {
2169                                 sym.flags_field |= DEPRECATED_REMOVAL;
2170                             }
2171                         }
2172                     }
2173                 }
2174                 if (sym.annotationsPendingCompletion()) {
2175                     sym.setDeclarationAttributes(newList);
2176                 } else {
2177                     sym.appendAttributes(newList);
2178                 }
2179             } finally {
2180                 currentClassFile = previousClassFile;
2181             }
2182         }
2183 
2184         @Override
2185         public String toString() {
2186             return &quot; ClassReader annotate &quot; + sym.owner + &quot;.&quot; + sym + &quot; with &quot; + l;
2187         }
2188     }
2189 
2190     class TypeAnnotationCompleter extends AnnotationCompleter {
2191 
2192         List&lt;TypeAnnotationProxy&gt; proxies;
2193 
2194         TypeAnnotationCompleter(Symbol sym,
2195                 List&lt;TypeAnnotationProxy&gt; proxies) {
2196             super(sym, List.nil());
2197             this.proxies = proxies;
2198         }
2199 
2200         List&lt;Attribute.TypeCompound&gt; deproxyTypeCompoundList(List&lt;TypeAnnotationProxy&gt; proxies) {
2201             ListBuffer&lt;Attribute.TypeCompound&gt; buf = new ListBuffer&lt;&gt;();
2202             for (TypeAnnotationProxy proxy: proxies) {
2203                 Attribute.Compound compound = deproxyCompound(proxy.compound);
2204                 Attribute.TypeCompound typeCompound = new Attribute.TypeCompound(compound, proxy.position);
2205                 buf.add(typeCompound);
2206             }
2207             return buf.toList();
2208         }
2209 
2210         @Override
2211         public void run() {
2212             JavaFileObject previousClassFile = currentClassFile;
2213             try {
2214                 currentClassFile = classFile;
2215                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2216                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2217             } finally {
2218                 currentClassFile = previousClassFile;
2219             }
2220         }
2221     }
2222 
2223 
2224 /************************************************************************
2225  * Reading Symbols
2226  ***********************************************************************/
2227 
2228     /** Read a field.
2229      */
2230     VarSymbol readField() {
2231         long flags = adjustFieldFlags(nextChar());
2232         Name name = poolReader.getName(nextChar());
2233         Type type = poolReader.getType(nextChar());
2234         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2235         readMemberAttrs(v);
2236         return v;
2237     }
2238 
2239     /** Read a method.
2240      */
2241     MethodSymbol readMethod() {
2242         long flags = adjustMethodFlags(nextChar());
2243         Name name = poolReader.getName(nextChar());
2244         Type type = poolReader.getType(nextChar());
2245         if (currentOwner.isInterface() &amp;&amp;
2246                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2247             if (majorVersion &gt; Version.V52.major ||
2248                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2249                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2250                     currentOwner.flags_field |= DEFAULT;
2251                     flags |= DEFAULT | ABSTRACT;
2252                 }
2253             } else {
2254                 //protect against ill-formed classfiles
2255                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2256                                    Integer.toString(majorVersion),
2257                                    Integer.toString(minorVersion));
2258             }
2259         }
2260         if (name == names.init &amp;&amp; ((flags &amp; STATIC) != 0)) {
2261             flags &amp;= ~STATIC;
2262             type = new MethodType(type.getParameterTypes(),
2263                     syms.voidType,
2264                     type.getThrownTypes(),
2265                     syms.methodClass);
2266         }
2267         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2268             // Sometimes anonymous classes don&#39;t have an outer
2269             // instance, however, there is no reliable way to tell so
2270             // we never strip this$n
2271             // ditto for local classes. Local classes that have an enclosing method set
2272             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2273             // enclosing method (i.e. from initializers) will pass that check.
2274             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2275             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2276                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2277                                       type.getReturnType(),
2278                                       type.getThrownTypes(),
2279                                       syms.methodClass);
2280         }
2281         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2282         if (types.isSignaturePolymorphic(m)) {
2283             m.flags_field |= SIGNATURE_POLYMORPHIC;
2284         }
2285         if (saveParameterNames)
2286             initParameterNames(m);
2287         Symbol prevOwner = currentOwner;
2288         currentOwner = m;
2289         try {
2290             readMemberAttrs(m);
2291         } finally {
2292             currentOwner = prevOwner;
2293         }
2294         setParameters(m, type);
2295 
2296         if ((flags &amp; VARARGS) != 0) {
2297             final Type last = type.getParameterTypes().last();
2298             if (last == null || !last.hasTag(ARRAY)) {
2299                 m.flags_field &amp;= ~VARARGS;
2300                 throw badClassFile(&quot;malformed.vararg.method&quot;, m);
2301             }
2302         }
2303 
2304         return m;
2305     }
2306 
2307     private List&lt;Type&gt; adjustMethodParams(long flags, List&lt;Type&gt; args) {
2308         if (args.isEmpty()) {
2309             return args;
2310         }
2311         boolean isVarargs = (flags &amp; VARARGS) != 0;
2312         if (isVarargs) {
2313             Type varargsElem = args.last();
2314             ListBuffer&lt;Type&gt; adjustedArgs = new ListBuffer&lt;&gt;();
2315             for (Type t : args) {
2316                 adjustedArgs.append(t != varargsElem ?
2317                     t :
2318                     ((ArrayType)t).makeVarargs());
2319             }
2320             args = adjustedArgs.toList();
2321         }
2322         return args.tail;
2323     }
2324 
2325     /**
2326      * Init the parameter names array.
2327      * Parameter names are currently inferred from the names in the
2328      * LocalVariableTable attributes of a Code attribute.
2329      * (Note: this means parameter names are currently not available for
2330      * methods without a Code attribute.)
2331      * This method initializes an array in which to store the name indexes
2332      * of parameter names found in LocalVariableTable attributes. It is
2333      * slightly supersized to allow for additional slots with a start_pc of 0.
2334      */
2335     void initParameterNames(MethodSymbol sym) {
2336         // make allowance for synthetic parameters.
2337         final int excessSlots = 4;
2338         int expectedParameterSlots =
2339                 Code.width(sym.type.getParameterTypes()) + excessSlots;
2340         if (parameterNameIndices == null
2341                 || parameterNameIndices.length &lt; expectedParameterSlots) {
2342             parameterNameIndices = new int[expectedParameterSlots];
2343         } else
2344             Arrays.fill(parameterNameIndices, 0);
2345         haveParameterNameIndices = false;
2346         sawMethodParameters = false;
2347     }
2348 
2349     /**
2350      * Set the parameters for a method symbol, including any names and
2351      * annotations that were read.
2352      *
2353      * &lt;p&gt;The type of the symbol may have changed while reading the
2354      * method attributes (see the Signature attribute). This may be
2355      * because of generic information or because anonymous synthetic
2356      * parameters were added.   The original type (as read from the
2357      * method descriptor) is used to help guess the existence of
2358      * anonymous synthetic parameters.
2359      */
2360     void setParameters(MethodSymbol sym, Type jvmType) {
2361         // If we get parameter names from MethodParameters, then we
2362         // don&#39;t need to skip.
2363         int firstParam = 0;
2364         if (!sawMethodParameters) {
2365             firstParam = ((sym.flags() &amp; STATIC) == 0) ? 1 : 0;
2366             // the code in readMethod may have skipped the first
2367             // parameter when setting up the MethodType. If so, we
2368             // make a corresponding allowance here for the position of
2369             // the first parameter.  Note that this assumes the
2370             // skipped parameter has a width of 1 -- i.e. it is not
2371             // a double width type (long or double.)
2372             if (sym.name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2373                 // Sometimes anonymous classes don&#39;t have an outer
2374                 // instance, however, there is no reliable way to tell so
2375                 // we never strip this$n
2376                 if (!currentOwner.name.isEmpty())
2377                     firstParam += 1;
2378             }
2379 
2380             if (sym.type != jvmType) {
2381                 // reading the method attributes has caused the
2382                 // symbol&#39;s type to be changed. (i.e. the Signature
2383                 // attribute.)  This may happen if there are hidden
2384                 // (synthetic) parameters in the descriptor, but not
2385                 // in the Signature.  The position of these hidden
2386                 // parameters is unspecified; for now, assume they are
2387                 // at the beginning, and so skip over them. The
2388                 // primary case for this is two hidden parameters
2389                 // passed into Enum constructors.
2390                 int skip = Code.width(jvmType.getParameterTypes())
2391                         - Code.width(sym.type.getParameterTypes());
2392                 firstParam += skip;
2393             }
2394         }
2395         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();
2396         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2397         int nameIndex = firstParam;
2398         int annotationIndex = 0;
2399         for (Type t: sym.type.getParameterTypes()) {
2400             VarSymbol param = parameter(nameIndex, t, sym, paramNames);
2401             params.append(param);
2402             if (parameterAnnotations != null) {
2403                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2404                 if (annotations != null &amp;&amp; annotations.proxies != null
2405                         &amp;&amp; !annotations.proxies.isEmpty()) {
2406                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2407                 }
2408             }
2409             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2410             annotationIndex++;
2411         }
2412         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2413             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2414         }
2415         Assert.checkNull(sym.params);
2416         sym.params = params.toList();
2417         parameterAnnotations = null;
2418         parameterNameIndices = null;
2419     }
2420 
2421 
2422     // Returns the name for the parameter at position &#39;index&#39;, either using
2423     // names read from the MethodParameters, or by synthesizing a name that
2424     // is not on the &#39;exclude&#39; list.
2425     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {
2426         long flags = PARAMETER;
2427         Name argName;
2428         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2429                 &amp;&amp; parameterNameIndices[index] != 0) {
2430             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);
2431             flags |= NAME_FILLED;
2432         } else {
2433             String prefix = &quot;arg&quot;;
2434             while (true) {
2435                 argName = names.fromString(prefix + exclude.size());
2436                 if (!exclude.contains(argName))
2437                     break;
2438                 prefix += &quot;$&quot;;
2439             }
2440         }
2441         exclude.add(argName);
2442         return new ParamSymbol(flags, argName, t, owner);
2443     }
2444 
2445     /**
2446      * skip n bytes
2447      */
2448     void skipBytes(int n) {
2449         bp = bp + n;
2450     }
2451 
2452     /** Skip a field or method
2453      */
2454     void skipMember() {
2455         bp = bp + 6;
2456         char ac = nextChar();
2457         for (int i = 0; i &lt; ac; i++) {
2458             bp = bp + 2;
2459             int attrLen = nextInt();
2460             bp = bp + attrLen;
2461         }
2462     }
2463 
2464     void skipInnerClasses() {
2465         int n = nextChar();
2466         for (int i = 0; i &lt; n; i++) {
2467             nextChar();
2468             nextChar();
2469             nextChar();
2470             nextChar();
2471         }
2472     }
2473 
2474     /** Enter type variables of this classtype and all enclosing ones in
2475      *  `typevars&#39;.
2476      */
2477     protected void enterTypevars(Symbol sym, Type t) {
2478         if (t.getEnclosingType() != null) {
2479             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2480                 enterTypevars(sym.owner, t.getEnclosingType());
2481             }
2482         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2483             enterTypevars(sym.owner, sym.owner.type);
2484         }
2485         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2486             typevars.enter(xs.head.tsym);
2487         }
2488     }
2489 
2490     protected ClassSymbol enterClass(Name name) {
2491         if (allowInlineTypes &amp;&amp; name.toString().endsWith(&quot;$ref&quot;)) {
2492             ClassSymbol v = syms.enterClass(currentModule, name.subName(0, name.length() - 4));
2493             return v.referenceProjection();
2494         }
2495         return syms.enterClass(currentModule, name);
2496     }
2497 
2498     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2499         return syms.enterClass(currentModule, name, owner);
2500     }
2501 
2502     /** Read contents of a given class symbol `c&#39;. Both external and internal
2503      *  versions of an inner class are read.
2504      */
2505     void readClass(ClassSymbol c) {
2506         ClassType ct = (ClassType)c.type;
2507 
2508         // allocate scope for members
2509         c.members_field = WriteableScope.create(c);
2510 
2511         // prepare type variable table
2512         typevars = typevars.dup(currentOwner);
2513         if (ct.getEnclosingType().hasTag(CLASS))
2514             enterTypevars(c.owner, ct.getEnclosingType());
2515 
2516         // read flags, or skip if this is an inner class
2517         long f = nextChar();
2518         long flags = adjustClassFlags(f);
2519         if ((flags &amp; MODULE) == 0) {
2520             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2521             // read own class name and check that it matches
2522             currentModule = c.packge().modle;
2523             ClassSymbol self = poolReader.getClass(nextChar());
2524             if (c != self) {
2525                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2526                                    self.flatname);
2527             }
2528         } else {
2529             if (majorVersion &lt; Version.V53.major) {
2530                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2531                         Integer.toString(majorVersion),
2532                         Integer.toString(minorVersion));
2533             }
2534             c.flags_field = flags;
2535             currentModule = (ModuleSymbol) c.owner;
2536             int this_class = nextChar();
2537             // temp, no check on this_class
2538         }
2539 
2540         // class attributes must be read before class
2541         // skip ahead to read class attributes
2542         int startbp = bp;
2543         nextChar();
2544         char interfaceCount = nextChar();
2545         bp += interfaceCount * 2;
2546         char fieldCount = nextChar();
2547         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2548         char methodCount = nextChar();
2549         for (int i = 0; i &lt; methodCount; i++) skipMember();
2550         readClassAttrs(c);
2551 
2552         if (c.permitted != null &amp;&amp; !c.permitted.isEmpty()) {
2553             c.flags_field |= SEALED;
2554         }
2555 
2556         // reset and read rest of classinfo
2557         bp = startbp;
2558         int n = nextChar();
2559         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2560             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2561         }
2562         if (ct.supertype_field == null)
2563             ct.supertype_field =
2564                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2565         n = nextChar();
2566         List&lt;Type&gt; is = List.nil();
2567         for (int i = 0; i &lt; n; i++) {
2568             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2569             is = is.prepend(_inter);
2570         }
2571         if (ct.interfaces_field == null)
2572             ct.interfaces_field = is.reverse();
2573 
2574         Assert.check(fieldCount == nextChar());
2575         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2576         Assert.check(methodCount == nextChar());
2577         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2578 
2579         typevars = typevars.leave();
2580     }
2581 
2582     /** Read inner class info. For each inner/outer pair allocate a
2583      *  member class.
2584      */
2585     void readInnerClasses(ClassSymbol c) {
2586         int n = nextChar();
2587         for (int i = 0; i &lt; n; i++) {
2588             nextChar(); // skip inner class symbol
2589             int outerIdx = nextChar();
2590             int nameIdx = nextChar();
2591             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);
2592             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);
2593             if (name == null) name = names.empty;
2594             long flags = adjustClassFlags(nextChar());
2595             if (outer != null) { // we have a member class
2596                 if (name == names.empty)
2597                     name = names.one;
2598                 ClassSymbol member = enterClass(name, outer);
2599                 if ((flags &amp; STATIC) == 0) {
2600                     ((ClassType)member.type).setEnclosingType(outer.type);
2601                     if (member.erasure_field != null)
2602                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2603                 }
2604                 if (c == outer) {
2605                     member.flags_field = flags;
2606                     enterMember(c, member);
2607                 }
2608             }
2609         }
2610     }
2611 
2612     /** Read a class definition from the bytes in buf.
2613      */
2614     private void readClassBuffer(ClassSymbol c) throws IOException {
2615         int magic = nextInt();
2616         if (magic != JAVA_MAGIC)
2617             throw badClassFile(&quot;illegal.start.of.class.file&quot;);
2618 
2619         minorVersion = nextChar();
2620         majorVersion = nextChar();
2621         int maxMajor = Version.MAX().major;
2622         int maxMinor = Version.MAX().minor;
2623         if (majorVersion &gt; maxMajor ||
2624             majorVersion * 1000 + minorVersion &lt;
2625             Version.MIN().major * 1000 + Version.MIN().minor) {
2626             if (majorVersion == (maxMajor + 1))
2627                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2628                                                      majorVersion,
2629                                                      maxMajor));
2630             else
2631                 throw badClassFile(&quot;wrong.version&quot;,
2632                                    Integer.toString(majorVersion),
2633                                    Integer.toString(minorVersion),
2634                                    Integer.toString(maxMajor),
2635                                    Integer.toString(maxMinor));
2636         }
2637 
2638         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2639             if (!preview.isEnabled()) {
2640                 log.error(preview.disabledError(currentClassFile, majorVersion));
2641             } else {
2642                 preview.warnPreview(c.classfile, majorVersion);
2643             }
2644         }
2645 
2646         poolReader = new PoolReader(this, names, syms);
2647         bp = poolReader.readPool(buf, bp);
2648         if (signatureBuffer.length &lt; bp) {
2649             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2650             signatureBuffer = new byte[ns];
2651         }
2652         readClass(c);
2653     }
2654 
2655     public void readClassFile(ClassSymbol c) {
2656         readClassFileInternal(c);
2657         if (c.isValue()) {
2658             /* http://cr.openjdk.java.net/~briangoetz/valhalla/sov/04-translation.html
2659                The relationship of value and reference projections differs between the language model
2660                and the VM model. In the language, the value projection is not a subtype of the
2661                reference projection; instead, the two are related by inline narrowing and widening
2662                conversions, whereas in the VM, the two are related by actual subtyping.
2663                Sever the subtyping relationship by rewiring the supertypes here and now.
2664              */
2665 
2666             Name flatname = TypeSymbol.formFlatName(names.ref, c);
2667             ClassSymbol referenceProjection = syms.getClass(currentModule, flatname);
2668             if (referenceProjection != null) {
2669                 if (referenceProjection.name != names.ref &amp;&amp; referenceProjection.owner.kind == PCK) {
2670                     readClassFileInternal(referenceProjection);
2671                     ClassType classType = (ClassType) c.type;
2672                     classType.supertype_field = ((ClassType) referenceProjection.type).supertype_field;
2673                     classType.interfaces_field = ((ClassType) referenceProjection.type).interfaces_field;
2674                     // Discard the projection, it will be recomputed on the fly.
2675                     referenceProjection.owner.members().remove(referenceProjection);
2676                 }
2677             }
2678         }
2679     }
2680 
2681     private void readClassFileInternal(ClassSymbol c) {
2682         currentOwner = c;
2683         currentClassFile = c.classfile;
2684         warnedAttrs.clear();
2685         filling = true;
2686         target = null;
2687         repeatable = null;
2688         try {
2689             bp = 0;
2690             buf.reset();
2691             buf.appendStream(c.classfile.openInputStream());
2692             readClassBuffer(c);
2693             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2694                 List&lt;Type&gt; missing = missingTypeVariables;
2695                 List&lt;Type&gt; found = foundTypeVariables;
2696                 missingTypeVariables = List.nil();
2697                 foundTypeVariables = List.nil();
2698                 interimUses = List.nil();
2699                 interimProvides = List.nil();
2700                 filling = false;
2701                 ClassType ct = (ClassType)currentOwner.type;
2702                 ct.supertype_field =
2703                     types.subst(ct.supertype_field, missing, found);
2704                 ct.interfaces_field =
2705                     types.subst(ct.interfaces_field, missing, found);
2706                 ct.typarams_field =
2707                     types.substBounds(ct.typarams_field, missing, found);
2708                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2709                     types.head.tsym.type = types.head;
2710                 }
2711             } else if (missingTypeVariables.isEmpty() !=
2712                        foundTypeVariables.isEmpty()) {
2713                 Name name = missingTypeVariables.head.tsym.name;
2714                 throw badClassFile(&quot;undecl.type.var&quot;, name);
2715             }
2716 
2717             if ((c.flags_field &amp; Flags.ANNOTATION) != 0) {
2718                 c.setAnnotationTypeMetadata(new AnnotationTypeMetadata(c, new CompleterDeproxy(c, target, repeatable)));
2719             } else {
2720                 c.setAnnotationTypeMetadata(AnnotationTypeMetadata.notAnAnnotationType());
2721             }
2722 
2723             if (c == currentModule.module_info) {
2724                 if (interimUses.nonEmpty() || interimProvides.nonEmpty()) {
2725                     Assert.check(currentModule.isCompleted());
2726                     currentModule.usesProvidesCompleter =
2727                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2728                 } else {
2729                     currentModule.uses = List.nil();
2730                     currentModule.provides = List.nil();
2731                 }
2732             }
2733         } catch (IOException | ClosedFileSystemException ex) {
2734             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2735         } catch (ArrayIndexOutOfBoundsException ex) {
2736             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2737         } finally {
2738             interimUses = List.nil();
2739             interimProvides = List.nil();
2740             missingTypeVariables = List.nil();
2741             foundTypeVariables = List.nil();
2742             filling = false;
2743         }
2744     }
2745 
2746     /** We can only read a single class file at a time; this
2747      *  flag keeps track of when we are currently reading a class
2748      *  file.
2749      */
2750     public boolean filling = false;
2751 
2752 /************************************************************************
2753  * Adjusting flags
2754  ***********************************************************************/
2755 
2756     long adjustFieldFlags(long flags) {
2757         return flags;
2758     }
2759 
2760     long adjustMethodFlags(long flags) {
2761         if ((flags &amp; ACC_BRIDGE) != 0) {
2762             flags &amp;= ~ACC_BRIDGE;
2763             flags |= BRIDGE;
2764         }
2765         if ((flags &amp; ACC_VARARGS) != 0) {
2766             flags &amp;= ~ACC_VARARGS;
2767             flags |= VARARGS;
2768         }
2769         return flags;
2770     }
2771 
2772     long adjustClassFlags(long flags) {
2773         if ((flags &amp; ACC_MODULE) != 0) {
2774             flags &amp;= ~ACC_MODULE;
2775             flags |= MODULE;
2776         }
2777         if ((flags &amp; ACC_VALUE) != 0) {
2778             flags &amp;= ~ACC_VALUE;
2779             flags |= allowInlineTypes ? VALUE : allowValueBasedClasses ? VALUEBASED : 0;
2780         }
2781         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2782     }
2783 
2784     /**
2785      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2786      * The attribute is only the last component of the original filename, so is unlikely
2787      * to be valid as is, so operations other than those to access the name throw
2788      * UnsupportedOperationException
2789      */
2790     private static class SourceFileObject implements JavaFileObject {
2791 
2792         /** The file&#39;s name.
2793          */
2794         private final Name name;
2795 
2796         public SourceFileObject(Name name) {
2797             this.name = name;
2798         }
2799 
2800         @Override @DefinedBy(Api.COMPILER)
2801         public URI toUri() {
2802             try {
2803                 return new URI(null, name.toString(), null);
2804             } catch (URISyntaxException e) {
2805                 throw new PathFileObject.CannotCreateUriError(name.toString(), e);
2806             }
2807         }
2808 
2809         @Override @DefinedBy(Api.COMPILER)
2810         public String getName() {
2811             return name.toString();
2812         }
2813 
2814         @Override @DefinedBy(Api.COMPILER)
2815         public JavaFileObject.Kind getKind() {
2816             return BaseFileManager.getKind(getName());
2817         }
2818 
2819         @Override @DefinedBy(Api.COMPILER)
2820         public InputStream openInputStream() {
2821             throw new UnsupportedOperationException();
2822         }
2823 
2824         @Override @DefinedBy(Api.COMPILER)
2825         public OutputStream openOutputStream() {
2826             throw new UnsupportedOperationException();
2827         }
2828 
2829         @Override @DefinedBy(Api.COMPILER)
2830         public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
2831             throw new UnsupportedOperationException();
2832         }
2833 
2834         @Override @DefinedBy(Api.COMPILER)
2835         public Reader openReader(boolean ignoreEncodingErrors) {
2836             throw new UnsupportedOperationException();
2837         }
2838 
2839         @Override @DefinedBy(Api.COMPILER)
2840         public Writer openWriter() {
2841             throw new UnsupportedOperationException();
2842         }
2843 
2844         @Override @DefinedBy(Api.COMPILER)
2845         public long getLastModified() {
2846             throw new UnsupportedOperationException();
2847         }
2848 
2849         @Override @DefinedBy(Api.COMPILER)
2850         public boolean delete() {
2851             throw new UnsupportedOperationException();
2852         }
2853 
2854         @Override @DefinedBy(Api.COMPILER)
2855         public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {
2856             return true; // fail-safe mode
2857         }
2858 
2859         @Override @DefinedBy(Api.COMPILER)
2860         public NestingKind getNestingKind() {
2861             return null;
2862         }
2863 
2864         @Override @DefinedBy(Api.COMPILER)
2865         public Modifier getAccessLevel() {
2866             return null;
2867         }
2868 
2869         /**
2870          * Check if two file objects are equal.
2871          * SourceFileObjects are just placeholder objects for the value of a
2872          * SourceFile attribute, and do not directly represent specific files.
2873          * Two SourceFileObjects are equal if their names are equal.
2874          */
2875         @Override
2876         public boolean equals(Object other) {
2877             if (this == other)
2878                 return true;
2879 
2880             if (!(other instanceof SourceFileObject))
2881                 return false;
2882 
2883             SourceFileObject o = (SourceFileObject) other;
2884             return name.equals(o.name);
2885         }
2886 
2887         @Override
2888         public int hashCode() {
2889             return name.hashCode();
2890         }
2891     }
2892 
2893     private class CompleterDeproxy implements AnnotationTypeCompleter {
2894         ClassSymbol proxyOn;
2895         CompoundAnnotationProxy target;
2896         CompoundAnnotationProxy repeatable;
2897 
2898         public CompleterDeproxy(ClassSymbol c, CompoundAnnotationProxy target,
2899                 CompoundAnnotationProxy repeatable)
2900         {
2901             this.proxyOn = c;
2902             this.target = target;
2903             this.repeatable = repeatable;
2904         }
2905 
2906         @Override
2907         public void complete(ClassSymbol sym) {
2908             Assert.check(proxyOn == sym);
2909             Attribute.Compound theTarget = null, theRepeatable = null;
2910             AnnotationDeproxy deproxy;
2911 
2912             try {
2913                 if (target != null) {
2914                     deproxy = new AnnotationDeproxy(proxyOn);
2915                     theTarget = deproxy.deproxyCompound(target);
2916                 }
2917 
2918                 if (repeatable != null) {
2919                     deproxy = new AnnotationDeproxy(proxyOn);
2920                     theRepeatable = deproxy.deproxyCompound(repeatable);
2921                 }
2922             } catch (Exception e) {
2923                 throw new CompletionFailure(sym,
2924                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),
2925                                             dcfh);
2926             }
2927 
2928             sym.getAnnotationTypeMetadata().setTarget(theTarget);
2929             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
2930         }
2931     }
2932 
2933     private class ProxyType extends Type {
2934 
2935         private final Name name;
2936 
2937         public ProxyType(int index) {
2938             super(syms.noSymbol, TypeMetadata.EMPTY);
2939             this.name = poolReader.getName(index);
2940         }
2941 
2942         @Override
2943         public TypeTag getTag() {
2944             return TypeTag.NONE;
2945         }
2946 
2947         @Override
2948         public Type cloneWithMetadata(TypeMetadata metadata) {
2949             throw new UnsupportedOperationException();
2950         }
2951 
2952         public Type resolve() {
2953             return name.map(ClassReader.this::sigToType);
2954         }
2955 
2956         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2957         public String toString() {
2958             return &quot;&lt;ProxyType&gt;&quot;;
2959         }
2960 
2961     }
2962 
2963     private static final class InterimUsesDirective {
2964         public final Name service;
2965 
2966         public InterimUsesDirective(Name service) {
2967             this.service = service;
2968         }
2969 
2970     }
2971 
2972     private static final class InterimProvidesDirective {
2973         public final Name service;
2974         public final List&lt;Name&gt; impls;
2975 
2976         public InterimProvidesDirective(Name service, List&lt;Name&gt; impls) {
2977             this.service = service;
2978             this.impls = impls;
2979         }
2980 
2981     }
2982 
2983     private final class UsesProvidesCompleter implements Completer {
2984         private final ModuleSymbol currentModule;
2985         private final List&lt;InterimUsesDirective&gt; interimUsesCopy;
2986         private final List&lt;InterimProvidesDirective&gt; interimProvidesCopy;
2987 
2988         public UsesProvidesCompleter(ModuleSymbol currentModule, List&lt;InterimUsesDirective&gt; interimUsesCopy, List&lt;InterimProvidesDirective&gt; interimProvidesCopy) {
2989             this.currentModule = currentModule;
2990             this.interimUsesCopy = interimUsesCopy;
2991             this.interimProvidesCopy = interimProvidesCopy;
2992         }
2993 
2994         @Override
2995         public void complete(Symbol sym) throws CompletionFailure {
2996             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
2997             directives.addAll(currentModule.directives);
2998             ListBuffer&lt;UsesDirective&gt; uses = new ListBuffer&lt;&gt;();
2999             for (InterimUsesDirective interim : interimUsesCopy) {
3000                 UsesDirective d = new UsesDirective(syms.enterClass(currentModule, interim.service));
3001                 uses.add(d);
3002                 directives.add(d);
3003             }
3004             currentModule.uses = uses.toList();
3005             ListBuffer&lt;ProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
3006             for (InterimProvidesDirective interim : interimProvidesCopy) {
3007                 ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
3008                 for (Name impl : interim.impls) {
3009                     impls.append(syms.enterClass(currentModule, impl));
3010                 }
3011                 ProvidesDirective d = new ProvidesDirective(syms.enterClass(currentModule, interim.service),
3012                                                             impls.toList());
3013                 provides.add(d);
3014                 directives.add(d);
3015             }
3016             currentModule.provides = provides.toList();
3017             currentModule.directives = directives.toList();
3018         }
3019     }
3020 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>