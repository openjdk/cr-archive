<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import java.util.function.IntFunction;
  40 
  41 import javax.lang.model.element.Modifier;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.tools.JavaFileManager;
  44 import javax.tools.JavaFileObject;
  45 
  46 import com.sun.tools.javac.code.Source.Feature;
  47 import com.sun.tools.javac.comp.Annotate;
  48 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  49 import com.sun.tools.javac.code.*;
  50 import com.sun.tools.javac.code.Directive.*;
  51 import com.sun.tools.javac.code.Lint.LintCategory;
  52 import com.sun.tools.javac.code.Scope.WriteableScope;
  53 import com.sun.tools.javac.code.Symbol.*;
  54 import com.sun.tools.javac.code.Symtab;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  57 import com.sun.tools.javac.file.BaseFileManager;
  58 import com.sun.tools.javac.file.PathFileObject;
  59 import com.sun.tools.javac.jvm.ClassFile.Version;
  60 import com.sun.tools.javac.jvm.PoolConstant.NameAndType;
  61 import com.sun.tools.javac.main.Option;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  64 import com.sun.tools.javac.util.*;
  65 import com.sun.tools.javac.util.DefinedBy.Api;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 import static com.sun.tools.javac.code.Flags.*;
  69 import static com.sun.tools.javac.code.Kinds.Kind.*;
  70 
  71 import com.sun.tools.javac.code.Scope.LookupKind;
  72 
  73 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  74 import static com.sun.tools.javac.code.TypeTag.CLASS;
  75 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  76 import static com.sun.tools.javac.jvm.ClassFile.*;
  77 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  78 
  79 import static com.sun.tools.javac.main.Option.PARAMETERS;
  80 
  81 /** This class provides operations to read a classfile into an internal
  82  *  representation. The internal representation is anchored in a
  83  *  ClassSymbol which contains in its scope symbol representations
  84  *  for all other definitions in the classfile. Top-level Classes themselves
  85  *  appear as members of the scopes of PackageSymbols.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
 108     /** Switch: allow inline types.
 109      */
 110     boolean allowInlineTypes;
 111 
 112     /** Switch: allow sealed
 113      */
 114     boolean allowSealedTypes;
 115 
 116     /** Switch: allow records
 117      */
 118     boolean allowRecords;
 119 
 120    /** Lint option: warn about classfile issues
 121      */
 122     boolean lintClassfile;
 123 
 124     /** Switch: preserve parameter names from the variable table.
 125      */
 126     public boolean saveParameterNames;
 127 
 128     /** Switch: Should javac recongnize and handle value based classes specially ?
 129      */
 130     private boolean allowValueBasedClasses;
 131 
 132     /**
 133      * The currently selected profile.
 134      */
 135     public final Profile profile;
 136 
 137     /** The log to use for verbose output
 138      */
 139     final Log log;
 140 
 141     /** The symbol table. */
 142     Symtab syms;
 143 
 144     Types types;
 145 
 146     /** The name table. */
 147     final Names names;
 148 
 149     /** Access to files
 150      */
 151     private final JavaFileManager fileManager;
 152 
 153     /** Factory for diagnostics
 154      */
 155     JCDiagnostic.Factory diagFactory;
 156 
 157     DeferredCompletionFailureHandler dcfh;
 158 
 159     /**
 160      * Support for preview language features.
 161      */
 162     Preview preview;
 163 
 164     /** The current scope where type variables are entered.
 165      */
 166     protected WriteableScope typevars;
 167 
 168     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 169     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 170 
 171     /** The path name of the class file currently being read.
 172      */
 173     protected JavaFileObject currentClassFile = null;
 174 
 175     /** The class or method currently being read.
 176      */
 177     protected Symbol currentOwner = null;
 178 
 179     /** The module containing the class currently being read.
 180      */
 181     protected ModuleSymbol currentModule = null;
 182 
 183     /** The buffer containing the currently read class file.
 184      */
 185     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);
 186 
 187     /** The current input pointer.
 188      */
 189     protected int bp;
 190 
 191     /** The pool reader.
 192      */
 193     PoolReader poolReader;
 194 
 195     /** The major version number of the class file being read. */
 196     int majorVersion;
 197     /** The minor version number of the class file being read. */
 198     int minorVersion;
 199 
 200     /** A table to hold the constant pool indices for method parameter
 201      * names, as given in LocalVariableTable attributes.
 202      */
 203     int[] parameterNameIndices;
 204 
 205     /**
 206      * A table to hold annotations for method parameters.
 207      */
 208     ParameterAnnotations[] parameterAnnotations;
 209 
 210     /**
 211      * A holder for parameter annotations.
 212      */
 213     static class ParameterAnnotations {
 214         List&lt;CompoundAnnotationProxy&gt; proxies;
 215 
 216         void add(List&lt;CompoundAnnotationProxy&gt; newAnnotations) {
 217             if (proxies == null) {
 218                 proxies = newAnnotations;
 219             } else {
 220                 proxies = proxies.prependList(newAnnotations);
 221             }
 222         }
 223     }
 224 
 225     /**
 226      * Whether or not any parameter names have been found.
 227      */
 228     boolean haveParameterNameIndices;
 229 
 230     /** Set this to false every time we start reading a method
 231      * and are saving parameter names.  Set it to true when we see
 232      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 233      * then we ignore the parameter names from the LVT.
 234      */
 235     boolean sawMethodParameters;
 236 
 237     /**
 238      * The set of attribute names for which warnings have been generated for the current class
 239      */
 240     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 241 
 242     /**
 243      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 244      * @Target
 245      */
 246     CompoundAnnotationProxy target;
 247 
 248     /**
 249      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with
 250      * @Repeatable
 251      */
 252     CompoundAnnotationProxy repeatable;
 253 
 254     /** Get the ClassReader instance for this invocation. */
 255     public static ClassReader instance(Context context) {
 256         ClassReader instance = context.get(classReaderKey);
 257         if (instance == null)
 258             instance = new ClassReader(context);
 259         return instance;
 260     }
 261 
 262     /** Construct a new class reader. */
 263     protected ClassReader(Context context) {
 264         context.put(classReaderKey, this);
 265         annotate = Annotate.instance(context);
 266         names = Names.instance(context);
 267         syms = Symtab.instance(context);
 268         types = Types.instance(context);
 269         fileManager = context.get(JavaFileManager.class);
 270         if (fileManager == null)
 271             throw new AssertionError(&quot;FileManager initialization error&quot;);
 272         diagFactory = JCDiagnostic.Factory.instance(context);
 273         dcfh = DeferredCompletionFailureHandler.instance(context);
 274 
 275         log = Log.instance(context);
 276 
 277         Options options = Options.instance(context);
 278         verbose         = options.isSet(Option.VERBOSE);
 279 
 280         Source source = Source.instance(context);
 281         preview = Preview.instance(context);
 282         allowModules     = Feature.MODULES.allowedInSource(source);
 283         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 284         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 285                 Feature.RECORDS.allowedInSource(source);
 286         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 287                 Feature.SEALED_CLASSES.allowedInSource(source);
 288 
 289         saveParameterNames = options.isSet(PARAMETERS);
 290         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 291 
 292         profile = Profile.instance(context);
 293 
 294         typevars = WriteableScope.create(syms.noSymbol);
 295 
 296         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 297 
 298         initAttributeReaders();
 299     }
 300 
 301     /** Add member to class unless it is synthetic.
 302      */
 303     private void enterMember(ClassSymbol c, Symbol sym) {
 304         // Synthetic members are not entered -- reason lost to history (optimization?).
 305         // Lambda methods must be entered because they may have inner classes (which reference them)
 306         ClassSymbol refProjection =  c.isValue() ? c.referenceProjection() : null;
 307         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda)) {
 308             c.members_field.enter(sym);
 309             if (refProjection != null) {
 310                 Symbol clone = null;
 311                 if (sym.kind == MTH) {
 312                     MethodSymbol valMethod = (MethodSymbol)sym;
 313                     MethodSymbol refMethod = valMethod.clone(refProjection);
 314                     valMethod.projection = refMethod;
 315                     refMethod.projection = valMethod;
 316                     clone = refMethod;
 317                 } else if (sym.kind == VAR) {
 318                     VarSymbol valVar = (VarSymbol)sym;
 319                     VarSymbol refVar = valVar.clone(refProjection);
 320                     valVar.projection = refVar;
 321                     refVar.projection = valVar;
 322                     clone = refVar;
 323                 }
 324                 refProjection.members_field.enter(clone);
 325             }
 326         }
 327     }
 328 
 329 /************************************************************************
 330  * Error Diagnoses
 331  ***********************************************************************/
 332 
 333     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 334         return new ClassFinder.BadClassFile (
 335             currentOwner.enclClass(),
 336             currentClassFile,
 337             diagFactory.fragment(key, args),
 338             diagFactory,
 339             dcfh);
 340     }
 341 
 342     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 343         return new ClassFinder.BadEnclosingMethodAttr (
 344             currentOwner.enclClass(),
 345             currentClassFile,
 346             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 347             diagFactory,
 348             dcfh);
 349     }
 350 
 351 /************************************************************************
 352  * Buffer Access
 353  ***********************************************************************/
 354 
 355     /** Read a character.
 356      */
 357     char nextChar() {
 358         char res = buf.getChar(bp);
 359         bp += 2;
 360         return res;
 361     }
 362 
 363     /** Read a byte.
 364      */
 365     int nextByte() {
 366         return buf.getByte(bp++) &amp; 0xFF;
 367     }
 368 
 369     /** Read an integer.
 370      */
 371     int nextInt() {
 372         int res = buf.getInt(bp);
 373         bp += 4;
 374         return res;
 375     }
 376 
 377 /************************************************************************
 378  * Constant Pool Access
 379  ***********************************************************************/
 380 
 381     /** Read module_flags.
 382      */
 383     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 384         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 385         for (ModuleFlags f : ModuleFlags.values()) {
 386             if ((flags &amp; f.value) != 0)
 387                 set.add(f);
 388         }
 389         return set;
 390     }
 391 
 392     /** Read resolution_flags.
 393      */
 394     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 395         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 396         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 397             if ((flags &amp; f.value) != 0)
 398                 set.add(f);
 399         }
 400         return set;
 401     }
 402 
 403     /** Read exports_flags.
 404      */
 405     Set&lt;ExportsFlag&gt; readExportsFlags(int flags) {
 406         Set&lt;ExportsFlag&gt; set = EnumSet.noneOf(ExportsFlag.class);
 407         for (ExportsFlag f: ExportsFlag.values()) {
 408             if ((flags &amp; f.value) != 0)
 409                 set.add(f);
 410         }
 411         return set;
 412     }
 413 
 414     /** Read opens_flags.
 415      */
 416     Set&lt;OpensFlag&gt; readOpensFlags(int flags) {
 417         Set&lt;OpensFlag&gt; set = EnumSet.noneOf(OpensFlag.class);
 418         for (OpensFlag f: OpensFlag.values()) {
 419             if ((flags &amp; f.value) != 0)
 420                 set.add(f);
 421         }
 422         return set;
 423     }
 424 
 425     /** Read requires_flags.
 426      */
 427     Set&lt;RequiresFlag&gt; readRequiresFlags(int flags) {
 428         Set&lt;RequiresFlag&gt; set = EnumSet.noneOf(RequiresFlag.class);
 429         for (RequiresFlag f: RequiresFlag.values()) {
 430             if ((flags &amp; f.value) != 0)
 431                 set.add(f);
 432         }
 433         return set;
 434     }
 435 
 436 /************************************************************************
 437  * Reading Types
 438  ***********************************************************************/
 439 
 440     /** The unread portion of the currently read type is
 441      *  signature[sigp..siglimit-1].
 442      */
 443     byte[] signature;
 444     int sigp;
 445     int siglimit;
 446     boolean sigEnterPhase = false;
 447 
 448     /** Convert signature to type, where signature is a byte array segment.
 449      */
 450     Type sigToType(byte[] sig, int offset, int len) {
 451         signature = sig;
 452         sigp = offset;
 453         siglimit = offset + len;
 454         return sigToType();
 455     }
 456 
 457     /** Convert signature to type, where signature is implicit.
 458      */
 459     Type sigToType() {
 460         switch ((char) signature[sigp]) {
 461         case &#39;T&#39;:
 462             sigp++;
 463             int start = sigp;
 464             while (signature[sigp] != &#39;;&#39;) sigp++;
 465             sigp++;
 466             return sigEnterPhase
 467                 ? Type.noType
 468                 : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));
 469         case &#39;+&#39;: {
 470             sigp++;
 471             Type t = sigToType();
 472             return new WildcardType(t, BoundKind.EXTENDS, syms.boundClass);
 473         }
 474         case &#39;*&#39;:
 475             sigp++;
 476             return new WildcardType(syms.objectType, BoundKind.UNBOUND,
 477                                     syms.boundClass);
 478         case &#39;-&#39;: {
 479             sigp++;
 480             Type t = sigToType();
 481             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 482         }
 483         case &#39;B&#39;:
 484             sigp++;
 485             return syms.byteType;
 486         case &#39;C&#39;:
 487             sigp++;
 488             return syms.charType;
 489         case &#39;D&#39;:
 490             sigp++;
 491             return syms.doubleType;
 492         case &#39;F&#39;:
 493             sigp++;
 494             return syms.floatType;
 495         case &#39;I&#39;:
 496             sigp++;
 497             return syms.intType;
 498         case &#39;J&#39;:
 499             sigp++;
 500             return syms.longType;
 501         case &#39;Q&#39;:
 502         case &#39;L&#39;:
 503             {
 504                 // int oldsigp = sigp;
 505                 Type t = classSigToType();
 506                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 507                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 508                                        &quot;(please recompile from source)&quot;);
 509                 /*
 510                 System.err.println(&quot; decoded &quot; +
 511                                    new String(signature, oldsigp, sigp-oldsigp) +
 512                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 513                 */
 514                 return t;
 515             }
 516         case &#39;S&#39;:
 517             sigp++;
 518             return syms.shortType;
 519         case &#39;V&#39;:
 520             sigp++;
 521             return syms.voidType;
 522         case &#39;Z&#39;:
 523             sigp++;
 524             return syms.booleanType;
 525         case &#39;[&#39;:
 526             sigp++;
 527             return new ArrayType(sigToType(), syms.arrayClass);
 528         case &#39;(&#39;:
 529             sigp++;
 530             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 531             Type restype = sigToType();
 532             List&lt;Type&gt; thrown = List.nil();
 533             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {
 534                 sigp++;
 535                 thrown = thrown.prepend(sigToType());
 536             }
 537             // if there is a typevar in the throws clause we should state it.
 538             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 539                 if (l.head.hasTag(TYPEVAR)) {
 540                     l.head.tsym.flags_field |= THROWS;
 541                 }
 542             }
 543             return new MethodType(argtypes,
 544                                   restype,
 545                                   thrown.reverse(),
 546                                   syms.methodClass);
 547         case &#39;&lt;&#39;:
 548             typevars = typevars.dup(currentOwner);
 549             Type poly = new ForAll(sigToTypeParams(), sigToType());
 550             typevars = typevars.leave();
 551             return poly;
 552         default:
 553             throw badClassFile(&quot;bad.signature&quot;,
 554                                Convert.utf2string(signature, sigp, 10));
 555         }
 556     }
 557 
 558     byte[] signatureBuffer = new byte[0];
 559     int sbp = 0;
 560     /** Convert class signature to type, where signature is implicit.
 561      */
 562     Type classSigToType() {
 563         if (signature[sigp] != &#39;L&#39; &amp;&amp; signature[sigp] != &#39;Q&#39;)
 564             throw badClassFile(&quot;bad.class.signature&quot;,
 565                                Convert.utf2string(signature, sigp, 10));
 566         sigp++;
 567         Type outer = Type.noType;
 568         int startSbp = sbp;
 569 
 570         while (true) {
 571             final byte c = signature[sigp++];
 572             switch (c) {
 573 
 574             case &#39;;&#39;: {         // end
 575                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 576                                                          startSbp,
 577                                                          sbp - startSbp));
 578 
 579                 try {
 580                     return (outer == Type.noType) ?
 581                             t.erasure(types) :
 582                         new ClassType(outer, List.nil(), t);
 583                 } finally {
 584                     sbp = startSbp;
 585                 }
 586             }
 587 
 588             case &#39;&lt;&#39;:           // generic arguments
 589                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 590                                                          startSbp,
 591                                                          sbp - startSbp));
 592                 outer = new ClassType(outer, sigToTypes(&#39;&gt;&#39;), t) {
 593                         boolean completed = false;
 594                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 595                         public Type getEnclosingType() {
 596                             if (!completed) {
 597                                 completed = true;
 598                                 tsym.complete();
 599                                 Type enclosingType = tsym.type.getEnclosingType();
 600                                 if (enclosingType != Type.noType) {
 601                                     List&lt;Type&gt; typeArgs =
 602                                         super.getEnclosingType().allparams();
 603                                     List&lt;Type&gt; typeParams =
 604                                         enclosingType.allparams();
 605                                     if (typeParams.length() != typeArgs.length()) {
 606                                         // no &quot;rare&quot; types
 607                                         super.setEnclosingType(types.erasure(enclosingType));
 608                                     } else {
 609                                         super.setEnclosingType(types.subst(enclosingType,
 610                                                                            typeParams,
 611                                                                            typeArgs));
 612                                     }
 613                                 } else {
 614                                     super.setEnclosingType(Type.noType);
 615                                 }
 616                             }
 617                             return super.getEnclosingType();
 618                         }
 619                         @Override
 620                         public void setEnclosingType(Type outer) {
 621                             throw new UnsupportedOperationException();
 622                         }
 623                     };
 624                 switch (signature[sigp++]) {
 625                 case &#39;;&#39;:
 626                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {
 627                         // support old-style GJC signatures
 628                         // The signature produced was
 629                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 630                         // rather than say
 631                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 632                         // so we skip past &quot;.Lfoo/Outer$&quot;
 633                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 634                             3;  // &quot;.L&quot; and &quot;$&quot;
 635                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 636                         break;
 637                     } else {
 638                         sbp = startSbp;
 639                         return outer;
 640                     }
 641                 case &#39;.&#39;:
 642                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 643                     break;
 644                 default:
 645                     throw new AssertionError(signature[sigp-1]);
 646                 }
 647                 continue;
 648 
 649             case &#39;.&#39;:
 650                 //we have seen an enclosing non-generic class
 651                 if (outer != Type.noType) {
 652                     t = enterClass(names.fromUtf(signatureBuffer,
 653                                                  startSbp,
 654                                                  sbp - startSbp));
 655                     outer = new ClassType(outer, List.nil(), t);
 656                 }
 657                 signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 658                 continue;
 659             case &#39;/&#39;:
 660                 signatureBuffer[sbp++] = (byte)&#39;.&#39;;
 661                 continue;
 662             default:
 663                 signatureBuffer[sbp++] = c;
 664                 continue;
 665             }
 666         }
 667     }
 668 
 669     /** Convert (implicit) signature to list of types
 670      *  until `terminator&#39; is encountered.
 671      */
 672     List&lt;Type&gt; sigToTypes(char terminator) {
 673         List&lt;Type&gt; head = List.of(null);
 674         List&lt;Type&gt; tail = head;
 675         while (signature[sigp] != terminator)
 676             tail = tail.setTail(List.of(sigToType()));
 677         sigp++;
 678         return head.tail;
 679     }
 680 
 681     /** Convert signature to type parameters, where signature is a byte
 682      *  array segment.
 683      */
 684     List&lt;Type&gt; sigToTypeParams(byte[] sig, int offset, int len) {
 685         signature = sig;
 686         sigp = offset;
 687         siglimit = offset + len;
 688         return sigToTypeParams();
 689     }
 690 
 691     /** Convert signature to type parameters, where signature is implicit.
 692      */
 693     List&lt;Type&gt; sigToTypeParams() {
 694         List&lt;Type&gt; tvars = List.nil();
 695         if (signature[sigp] == &#39;&lt;&#39;) {
 696             sigp++;
 697             int start = sigp;
 698             sigEnterPhase = true;
 699             while (signature[sigp] != &#39;&gt;&#39;)
 700                 tvars = tvars.prepend(sigToTypeParam());
 701             sigEnterPhase = false;
 702             sigp = start;
 703             while (signature[sigp] != &#39;&gt;&#39;)
 704                 sigToTypeParam();
 705             sigp++;
 706         }
 707         return tvars.reverse();
 708     }
 709 
 710     /** Convert (implicit) signature to type parameter.
 711      */
 712     Type sigToTypeParam() {
 713         int start = sigp;
 714         while (signature[sigp] != &#39;:&#39;) sigp++;
 715         Name name = names.fromUtf(signature, start, sigp - start);
 716         TypeVar tvar;
 717         if (sigEnterPhase) {
 718             tvar = new TypeVar(name, currentOwner, syms.botType);
 719             typevars.enter(tvar.tsym);
 720         } else {
 721             tvar = (TypeVar)findTypeVar(name);
 722         }
 723         List&lt;Type&gt; bounds = List.nil();
 724         boolean allInterfaces = false;
 725         if (signature[sigp] == &#39;:&#39; &amp;&amp; signature[sigp+1] == &#39;:&#39;) {
 726             sigp++;
 727             allInterfaces = true;
 728         }
 729         while (signature[sigp] == &#39;:&#39;) {
 730             sigp++;
 731             bounds = bounds.prepend(sigToType());
 732         }
 733         if (!sigEnterPhase) {
 734             types.setBounds(tvar, bounds.reverse(), allInterfaces);
 735         }
 736         return tvar;
 737     }
 738 
 739     /** Find type variable with given name in `typevars&#39; scope.
 740      */
 741     Type findTypeVar(Name name) {
 742         Symbol s = typevars.findFirst(name);
 743         if (s != null) {
 744             return s.type;
 745         } else {
 746             if (readingClassAttr) {
 747                 // While reading the class attribute, the supertypes
 748                 // might refer to a type variable from an enclosing element
 749                 // (method or class).
 750                 // If the type variable is defined in the enclosing class,
 751                 // we can actually find it in
 752                 // currentOwner.owner.type.getTypeArguments()
 753                 // However, until we have read the enclosing method attribute
 754                 // we don&#39;t know for sure if this owner is correct.  It could
 755                 // be a method and there is no way to tell before reading the
 756                 // enclosing method attribute.
 757                 TypeVar t = new TypeVar(name, currentOwner, syms.botType);
 758                 missingTypeVariables = missingTypeVariables.prepend(t);
 759                 // System.err.println(&quot;Missing type var &quot; + name);
 760                 return t;
 761             }
 762             throw badClassFile(&quot;undecl.type.var&quot;, name);
 763         }
 764     }
 765 
 766 /************************************************************************
 767  * Reading Attributes
 768  ***********************************************************************/
 769 
 770     protected enum AttributeKind { CLASS, MEMBER }
 771 
 772     protected abstract class AttributeReader {
 773         protected AttributeReader(Name name, ClassFile.Version version, Set&lt;AttributeKind&gt; kinds) {
 774             this.name = name;
 775             this.version = version;
 776             this.kinds = kinds;
 777         }
 778 
 779         protected boolean accepts(AttributeKind kind) {
 780             if (kinds.contains(kind)) {
 781                 if (majorVersion &gt; version.major || (majorVersion == version.major &amp;&amp; minorVersion &gt;= version.minor))
 782                     return true;
 783 
 784                 if (lintClassfile &amp;&amp; !warnedAttrs.contains(name)) {
 785                     JavaFileObject prev = log.useSource(currentClassFile);
 786                     try {
 787                         log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,
 788                                     Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));
 789                     } finally {
 790                         log.useSource(prev);
 791                     }
 792                     warnedAttrs.add(name);
 793                 }
 794             }
 795             return false;
 796         }
 797 
 798         protected abstract void read(Symbol sym, int attrLen);
 799 
 800         protected final Name name;
 801         protected final ClassFile.Version version;
 802         protected final Set&lt;AttributeKind&gt; kinds;
 803     }
 804 
 805     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 806             EnumSet.of(AttributeKind.CLASS);
 807     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 808             EnumSet.of(AttributeKind.MEMBER);
 809     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 810             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 811 
 812     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 813 
 814     private void initAttributeReaders() {
 815         AttributeReader[] readers = {
 816             // v45.3 attributes
 817 
 818             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 819                 protected void read(Symbol sym, int attrLen) {
 820                     if (allowInlineTypes) {
 821                         if (sym.isConstructor()  &amp;&amp; ((MethodSymbol) sym).type.getParameterTypes().size() == 0) {
 822                             int code_length = buf.getInt(bp + 4);
 823                             if ((code_length == 1 &amp;&amp; buf.getByte( bp + 8) == (byte) ByteCodes.return_) ||
 824                                     (code_length == 5 &amp;&amp; buf.getByte(bp + 8) == ByteCodes.aload_0 &amp;&amp;
 825                                         buf.getByte( bp + 9) == (byte) ByteCodes.invokespecial &amp;&amp;
 826                                                 buf.getByte( bp + 12) == (byte) ByteCodes.return_)) {
 827                                     sym.flags_field |= EMPTYNOARGCONSTR;
 828                             }
 829                         }
 830                     }
 831                     if (saveParameterNames)
 832                         ((MethodSymbol)sym).code = readCode(sym);
 833                     else
 834                         bp = bp + attrLen;
 835                 }
 836             },
 837 
 838             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 839                 protected void read(Symbol sym, int attrLen) {
 840                     Object v = poolReader.getConstant(nextChar());
 841                     // Ignore ConstantValue attribute if field not final.
 842                     if ((sym.flags() &amp; FINAL) == 0) {
 843                         return;
 844                     }
 845                     VarSymbol var = (VarSymbol) sym;
 846                     switch (var.type.getTag()) {
 847                        case BOOLEAN:
 848                        case BYTE:
 849                        case CHAR:
 850                        case SHORT:
 851                        case INT:
 852                            checkType(var, Integer.class, v);
 853                            break;
 854                        case LONG:
 855                            checkType(var, Long.class, v);
 856                            break;
 857                        case FLOAT:
 858                            checkType(var, Float.class, v);
 859                            break;
 860                        case DOUBLE:
 861                            checkType(var, Double.class, v);
 862                            break;
 863                        case CLASS:
 864                            if (var.type.tsym == syms.stringType.tsym) {
 865                                checkType(var, String.class, v);
 866                            } else {
 867                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);
 868                            }
 869                            break;
 870                        default:
 871                            // ignore ConstantValue attribute if type is not primitive or String
 872                            return;
 873                     }
 874                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
 875                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
 876                     }
 877                     var.setData(v);
 878                 }
 879 
 880                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
 881                     if (!clazz.isInstance(value)) {
 882                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
 883                     }
 884                 }
 885             },
 886 
 887             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 888                 protected void read(Symbol sym, int attrLen) {
 889                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
 890 
 891                     s.flags_field |= DEPRECATED;
 892                 }
 893             },
 894 
 895             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 896                 protected void read(Symbol sym, int attrLen) {
 897                     int nexceptions = nextChar();
 898                     List&lt;Type&gt; thrown = List.nil();
 899                     for (int j = 0; j &lt; nexceptions; j++)
 900                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);
 901                     if (sym.type.getThrownTypes().isEmpty())
 902                         sym.type.asMethodType().thrown = thrown.reverse();
 903                 }
 904             },
 905 
 906             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
 907                 protected void read(Symbol sym, int attrLen) {
 908                     ClassSymbol c = (ClassSymbol) sym;
 909                     if (currentModule.module_info == c) {
 910                         //prevent entering the classes too soon:
 911                         skipInnerClasses();
 912                     } else {
 913                         readInnerClasses(c);
 914                     }
 915                 }
 916             },
 917 
 918             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 919                 protected void read(Symbol sym, int attrLen) {
 920                     int newbp = bp + attrLen;
 921                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
 922                         // Pick up parameter names from the variable table.
 923                         // Parameter names are not explicitly identified as such,
 924                         // but all parameter name entries in the LocalVariableTable
 925                         // have a start_pc of 0.  Therefore, we record the name
 926                         // indices of all slots with a start_pc of zero in the
 927                         // parameterNameIndices array.
 928                         // Note that this implicitly honors the JVMS spec that
 929                         // there may be more than one LocalVariableTable, and that
 930                         // there is no specified ordering for the entries.
 931                         int numEntries = nextChar();
 932                         for (int i = 0; i &lt; numEntries; i++) {
 933                             int start_pc = nextChar();
 934                             int length = nextChar();
 935                             int nameIndex = nextChar();
 936                             int sigIndex = nextChar();
 937                             int register = nextChar();
 938                             if (start_pc == 0) {
 939                                 // ensure array large enough
 940                                 if (register &gt;= parameterNameIndices.length) {
 941                                     int newSize =
 942                                             Math.max(register + 1, parameterNameIndices.length + 8);
 943                                     parameterNameIndices =
 944                                             Arrays.copyOf(parameterNameIndices, newSize);
 945                                 }
 946                                 parameterNameIndices[register] = nameIndex;
 947                                 haveParameterNameIndices = true;
 948                             }
 949                         }
 950                     }
 951                     bp = newbp;
 952                 }
 953             },
 954 
 955             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
 956                 protected void read(Symbol sym, int attrLen) {
 957                     ClassSymbol c = (ClassSymbol) sym;
 958                     Name n = poolReader.getName(nextChar());
 959                     c.sourcefile = new SourceFileObject(n);
 960                     // If the class is a toplevel class, originating from a Java source file,
 961                     // but the class name does not match the file name, then it is
 962                     // an auxiliary class.
 963                     String sn = n.toString();
 964                     if (c.owner.kind == PCK &amp;&amp;
 965                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
 966                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
 967                         c.flags_field |= AUXILIARY;
 968                     }
 969                 }
 970             },
 971 
 972             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 973                 protected void read(Symbol sym, int attrLen) {
 974                     sym.flags_field |= SYNTHETIC;
 975                 }
 976             },
 977 
 978             // standard v49 attributes
 979 
 980             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
 981                 protected void read(Symbol sym, int attrLen) {
 982                     int newbp = bp + attrLen;
 983                     readEnclosingMethodAttr(sym);
 984                     bp = newbp;
 985                 }
 986             },
 987 
 988             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 989                 protected void read(Symbol sym, int attrLen) {
 990                     if (sym.kind == TYP) {
 991                         ClassSymbol c = (ClassSymbol) sym;
 992                         readingClassAttr = true;
 993                         try {
 994                             ClassType ct1 = (ClassType)c.type;
 995                             Assert.check(c == currentOwner);
 996                             ct1.typarams_field = poolReader.getName(nextChar())
 997                                     .map(ClassReader.this::sigToTypeParams);
 998                             ct1.supertype_field = sigToType();
 999                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
1000                             while (sigp != siglimit) is.append(sigToType());
1001                             ct1.interfaces_field = is.toList();
1002                         } finally {
1003                             readingClassAttr = false;
1004                         }
1005                     } else {
1006                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
1007                         sym.type = poolReader.getType(nextChar());
1008                         //- System.err.println(&quot; # &quot; + sym.type);
1009                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
1010                             sym.type.asMethodType().thrown = thrown;
1011 
1012                     }
1013                 }
1014             },
1015 
1016             // v49 annotation attributes
1017 
1018             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1019                 protected void read(Symbol sym, int attrLen) {
1020                     attachAnnotationDefault(sym);
1021                 }
1022             },
1023 
1024             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1025                 protected void read(Symbol sym, int attrLen) {
1026                     attachAnnotations(sym);
1027                 }
1028             },
1029 
1030             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1031                 protected void read(Symbol sym, int attrLen) {
1032                     readParameterAnnotations(sym);
1033                 }
1034             },
1035 
1036             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1037                 protected void read(Symbol sym, int attrLen) {
1038                     attachAnnotations(sym);
1039                 }
1040             },
1041 
1042             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1043                 protected void read(Symbol sym, int attrLen) {
1044                     readParameterAnnotations(sym);
1045                 }
1046             },
1047 
1048             // additional &quot;legacy&quot; v49 attributes, superseded by flags
1049 
1050             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1051                 protected void read(Symbol sym, int attrLen) {
1052                     sym.flags_field |= ANNOTATION;
1053                 }
1054             },
1055 
1056             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1057                 protected void read(Symbol sym, int attrLen) {
1058                     sym.flags_field |= BRIDGE;
1059                 }
1060             },
1061 
1062             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1063                 protected void read(Symbol sym, int attrLen) {
1064                     sym.flags_field |= ENUM;
1065                 }
1066             },
1067 
1068             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1069                 protected void read(Symbol sym, int attrLen) {
1070                     sym.flags_field |= VARARGS;
1071                 }
1072             },
1073 
1074             new AttributeReader(names.RuntimeVisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1075                 protected void read(Symbol sym, int attrLen) {
1076                     attachTypeAnnotations(sym);
1077                 }
1078             },
1079 
1080             new AttributeReader(names.RuntimeInvisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1081                 protected void read(Symbol sym, int attrLen) {
1082                     attachTypeAnnotations(sym);
1083                 }
1084             },
1085 
1086             // The following attributes for a Code attribute are not currently handled
1087             // StackMapTable
1088             // SourceDebugExtension
1089             // LineNumberTable
1090             // LocalVariableTypeTable
1091 
1092             // standard v52 attributes
1093 
1094             new AttributeReader(names.MethodParameters, V52, MEMBER_ATTRIBUTE) {
1095                 protected void read(Symbol sym, int attrlen) {
1096                     int newbp = bp + attrlen;
1097                     if (saveParameterNames) {
1098                         sawMethodParameters = true;
1099                         int numEntries = nextByte();
1100                         parameterNameIndices = new int[numEntries];
1101                         haveParameterNameIndices = true;
1102                         int index = 0;
1103                         for (int i = 0; i &lt; numEntries; i++) {
1104                             int nameIndex = nextChar();
1105                             int flags = nextChar();
1106                             if ((flags &amp; (Flags.MANDATED | Flags.SYNTHETIC)) != 0) {
1107                                 continue;
1108                             }
1109                             parameterNameIndices[index++] = nameIndex;
1110                         }
1111                     }
1112                     bp = newbp;
1113                 }
1114             },
1115 
1116             // standard v53 attributes
1117 
1118             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1119                 @Override
1120                 protected boolean accepts(AttributeKind kind) {
1121                     return super.accepts(kind) &amp;&amp; allowModules;
1122                 }
1123                 protected void read(Symbol sym, int attrLen) {
1124                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1125                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1126                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1127 
1128                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);
1129                         if (currentModule.name != moduleName) {
1130                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1131                         }
1132 
1133                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1134                         msym.flags.addAll(moduleFlags);
1135                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);
1136 
1137                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1138                         int nrequires = nextChar();
1139                         for (int i = 0; i &lt; nrequires; i++) {
1140                             ModuleSymbol rsym = poolReader.getModule(nextChar());
1141                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1142                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1143                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1144                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1145                                 }
1146                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1147                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1148                                 }
1149                             }
1150                             nextChar(); // skip compiled version
1151                             requires.add(new RequiresDirective(rsym, flags));
1152                         }
1153                         msym.requires = requires.toList();
1154                         directives.addAll(msym.requires);
1155 
1156                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1157                         int nexports = nextChar();
1158                         for (int i = 0; i &lt; nexports; i++) {
1159                             PackageSymbol p = poolReader.getPackage(nextChar());
1160                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1161                             int nto = nextChar();
1162                             List&lt;ModuleSymbol&gt; to;
1163                             if (nto == 0) {
1164                                 to = null;
1165                             } else {
1166                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1167                                 for (int t = 0; t &lt; nto; t++)
1168                                     lb.append(poolReader.getModule(nextChar()));
1169                                 to = lb.toList();
1170                             }
1171                             exports.add(new ExportsDirective(p, to, flags));
1172                         }
1173                         msym.exports = exports.toList();
1174                         directives.addAll(msym.exports);
1175                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1176                         int nopens = nextChar();
1177                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1178                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1179                         }
1180                         for (int i = 0; i &lt; nopens; i++) {
1181                             PackageSymbol p = poolReader.getPackage(nextChar());
1182                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1183                             int nto = nextChar();
1184                             List&lt;ModuleSymbol&gt; to;
1185                             if (nto == 0) {
1186                                 to = null;
1187                             } else {
1188                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1189                                 for (int t = 0; t &lt; nto; t++)
1190                                     lb.append(poolReader.getModule(nextChar()));
1191                                 to = lb.toList();
1192                             }
1193                             opens.add(new OpensDirective(p, to, flags));
1194                         }
1195                         msym.opens = opens.toList();
1196                         directives.addAll(msym.opens);
1197 
1198                         msym.directives = directives.toList();
1199 
1200                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1201                         int nuses = nextChar();
1202                         for (int i = 0; i &lt; nuses; i++) {
1203                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1204                             uses.add(new InterimUsesDirective(srvc));
1205                         }
1206                         interimUses = uses.toList();
1207 
1208                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1209                         int nprovides = nextChar();
1210                         for (int p = 0; p &lt; nprovides; p++) {
1211                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1212                             int nimpls = nextChar();
1213                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1214                             for (int i = 0; i &lt; nimpls; i++) {
1215                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));
1216                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1217                             }
1218                         }
1219                         interimProvides = provides.toList();
1220                     }
1221                 }
1222 
1223                 private Name classNameMapper(byte[] arr, int offset, int length) {
1224                     return names.fromUtf(ClassFile.internalize(arr, offset, length));
1225                 }
1226             },
1227 
1228             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1229                 @Override
1230                 protected boolean accepts(AttributeKind kind) {
1231                     return super.accepts(kind) &amp;&amp; allowModules;
1232                 }
1233                 protected void read(Symbol sym, int attrLen) {
1234                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1235                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1236                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1237                     }
1238                 }
1239             },
1240 
1241             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1242                 @Override
1243                 protected boolean accepts(AttributeKind kind) {
1244                     return super.accepts(kind) &amp;&amp; allowRecords;
1245                 }
1246                 protected void read(Symbol sym, int attrLen) {
1247                     if (sym.kind == TYP) {
1248                         sym.flags_field |= RECORD;
1249                     }
1250                     bp = bp + attrLen;
1251                 }
1252             },
1253             new AttributeReader(names.PermittedSubclasses, V59, CLASS_ATTRIBUTE) {
1254                 @Override
1255                 protected boolean accepts(AttributeKind kind) {
1256                     return super.accepts(kind) &amp;&amp; allowSealedTypes;
1257                 }
1258                 protected void read(Symbol sym, int attrLen) {
1259                     if (sym.kind == TYP) {
1260                         ListBuffer&lt;Symbol&gt; subtypes = new ListBuffer&lt;&gt;();
1261                         int numberOfPermittedSubtypes = nextChar();
1262                         for (int i = 0; i &lt; numberOfPermittedSubtypes; i++) {
1263                             subtypes.add(poolReader.getClass(nextChar()));
1264                         }
1265                         ((ClassSymbol)sym).permitted = subtypes.toList();
1266                     }
1267                 }
1268             },
1269         };
1270 
1271         for (AttributeReader r: readers)
1272             attributeReaders.put(r.name, r);
1273     }
1274 
1275     protected void readEnclosingMethodAttr(Symbol sym) {
1276         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1277         // remove sym from it&#39;s current owners scope and place it in
1278         // the scope specified by the attribute
1279         sym.owner.members().remove(sym);
1280         ClassSymbol self = (ClassSymbol)sym;
1281         ClassSymbol c = poolReader.getClass(nextChar());
1282         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1283 
1284         if (c.members_field == null || c.kind != TYP)
1285             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1286 
1287         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1288         if (nt != null &amp;&amp; m == null)
1289             throw badEnclosingMethod(self);
1290 
1291         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1292         self.owner = m != null ? m : c;
1293         if (self.name.isEmpty())
1294             self.fullname = names.empty;
1295         else
1296             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1297 
1298         if (m != null) {
1299             ((ClassType)sym.type).setEnclosingType(m.type);
1300         } else if ((self.flags_field &amp; STATIC) == 0) {
1301             ((ClassType)sym.type).setEnclosingType(c.type);
1302         } else {
1303             ((ClassType)sym.type).setEnclosingType(Type.noType);
1304         }
1305         enterTypevars(self, self.type);
1306         if (!missingTypeVariables.isEmpty()) {
1307             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1308             for (Type typevar : missingTypeVariables) {
1309                 typeVars.append(findTypeVar(typevar.tsym.name));
1310             }
1311             foundTypeVariables = typeVars.toList();
1312         } else {
1313             foundTypeVariables = List.nil();
1314         }
1315     }
1316 
1317     // See java.lang.Class
1318     private Name simpleBinaryName(Name self, Name enclosing) {
1319         if (!self.startsWith(enclosing)) {
1320             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1321         }
1322 
1323         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1324         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1325             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1326         int index = 1;
1327         while (index &lt; simpleBinaryName.length() &amp;&amp;
1328                isAsciiDigit(simpleBinaryName.charAt(index)))
1329             index++;
1330         return names.fromString(simpleBinaryName.substring(index));
1331     }
1332 
1333     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1334         if (nt == null)
1335             return null;
1336 
1337         MethodType type = nt.type.asMethodType();
1338 
1339         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1340             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1341                 return (MethodSymbol)sym;
1342         }
1343 
1344         if (nt.name != names.init)
1345             // not a constructor
1346             return null;
1347         if ((flags &amp; INTERFACE) != 0)
1348             // no enclosing instance
1349             return null;
1350         if (nt.type.getParameterTypes().isEmpty())
1351             // no parameters
1352             return null;
1353 
1354         // A constructor of an inner class.
1355         // Remove the first argument (the enclosing instance)
1356         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,
1357                                  nt.type.getReturnType(),
1358                                  nt.type.getThrownTypes(),
1359                                  syms.methodClass));
1360         // Try searching again
1361         return findMethod(nt, scope, flags);
1362     }
1363 
1364     /** Similar to Types.isSameType but avoids completion */
1365     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1366         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1367             .prepend(types.erasure(mt1.getReturnType()));
1368         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1369         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1370             if (types1.head.tsym != types2.head.tsym)
1371                 return false;
1372             types1 = types1.tail;
1373             types2 = types2.tail;
1374         }
1375         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1376     }
1377 
1378     /**
1379      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1380      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1381      */
1382     private static boolean isAsciiDigit(char c) {
1383         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1384     }
1385 
1386     /** Read member attributes.
1387      */
1388     void readMemberAttrs(Symbol sym) {
1389         readAttrs(sym, AttributeKind.MEMBER);
1390     }
1391 
1392     void readAttrs(Symbol sym, AttributeKind kind) {
1393         char ac = nextChar();
1394         for (int i = 0; i &lt; ac; i++) {
1395             Name attrName = poolReader.getName(nextChar());
1396             int attrLen = nextInt();
1397             AttributeReader r = attributeReaders.get(attrName);
1398             if (r != null &amp;&amp; r.accepts(kind))
1399                 r.read(sym, attrLen);
1400             else  {
1401                 bp = bp + attrLen;
1402             }
1403         }
1404     }
1405 
1406     private boolean readingClassAttr = false;
1407     private List&lt;Type&gt; missingTypeVariables = List.nil();
1408     private List&lt;Type&gt; foundTypeVariables = List.nil();
1409 
1410     /** Read class attributes.
1411      */
1412     void readClassAttrs(ClassSymbol c) {
1413         readAttrs(c, AttributeKind.CLASS);
1414     }
1415 
1416     /** Read code block.
1417      */
1418     Code readCode(Symbol owner) {
1419         nextChar(); // max_stack
1420         nextChar(); // max_locals
1421         final int  code_length = nextInt();
1422         bp += code_length;
1423         final char exception_table_length = nextChar();
1424         bp += exception_table_length * 8;
1425         readMemberAttrs(owner);
1426         return null;
1427     }
1428 
1429 /************************************************************************
1430  * Reading Java-language annotations
1431  ***********************************************************************/
1432 
1433     /**
1434      * Save annotations.
1435      */
1436     List&lt;CompoundAnnotationProxy&gt; readAnnotations() {
1437         int numAttributes = nextChar();
1438         ListBuffer&lt;CompoundAnnotationProxy&gt; annotations = new ListBuffer&lt;&gt;();
1439         for (int i = 0; i &lt; numAttributes; i++) {
1440             annotations.append(readCompoundAnnotation());
1441         }
1442         return annotations.toList();
1443     }
1444 
1445     /** Attach annotations.
1446      */
1447     void attachAnnotations(final Symbol sym) {
1448         attachAnnotations(sym, readAnnotations());
1449     }
1450 
1451     /**
1452      * Attach annotations.
1453      */
1454     void attachAnnotations(final Symbol sym, List&lt;CompoundAnnotationProxy&gt; annotations) {
1455         if (annotations.isEmpty()) {
1456             return;
1457         }
1458         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1459         for (CompoundAnnotationProxy proxy : annotations) {
1460             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1461                 sym.flags_field |= PROPRIETARY;
1462             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1463                 if (profile != Profile.DEFAULT) {
1464                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1465                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1466                             Attribute.Constant c = (Attribute.Constant)v.snd;
1467                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1468                                 sym.flags_field |= NOT_IN_PROFILE;
1469                             }
1470                         }
1471                     }
1472                 }
<a name="1" id="anc1"></a>


1473             } else {
1474                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1475                     target = proxy;
1476                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1477                     repeatable = proxy;
1478                 } else if (allowValueBasedClasses &amp;&amp; sym.kind == TYP &amp;&amp; proxy.type.tsym == syms.valueBasedType.tsym) {
1479                     sym.flags_field |= VALUEBASED;
1480                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1481                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1482                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1483                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1484                     sym.flags_field |= PREVIEW_API;
1485                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1486                 }
1487                 proxies.append(proxy);
1488             }
1489         }
1490         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1491     }
1492     //where:
1493         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1494             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1495                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1496                     Attribute.Constant c = (Attribute.Constant)v.snd;
1497                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1498                         sym.flags_field |= flag;
1499                     }
1500                 }
1501             }
1502         }
1503 
1504     /** Read parameter annotations.
1505      */
1506     void readParameterAnnotations(Symbol meth) {
1507         int numParameters = buf.getByte(bp++) &amp; 0xFF;
1508         if (parameterAnnotations == null) {
1509             parameterAnnotations = new ParameterAnnotations[numParameters];
1510         } else if (parameterAnnotations.length != numParameters) {
1511             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1512         }
1513         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1514             if (parameterAnnotations[pnum] == null) {
1515                 parameterAnnotations[pnum] = new ParameterAnnotations();
1516             }
1517             parameterAnnotations[pnum].add(readAnnotations());
1518         }
1519     }
1520 
1521     void attachTypeAnnotations(final Symbol sym) {
1522         int numAttributes = nextChar();
1523         if (numAttributes != 0) {
1524             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1525             for (int i = 0; i &lt; numAttributes; i++)
1526                 proxies.append(readTypeAnnotation());
1527             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
1528         }
1529     }
1530 
1531     /** Attach the default value for an annotation element.
1532      */
1533     void attachAnnotationDefault(final Symbol sym) {
1534         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1535         final Attribute value = readAttributeValue();
1536 
1537         // The default value is set later during annotation. It might
1538         // be the case that the Symbol sym is annotated _after_ the
1539         // repeating instances that depend on this default value,
1540         // because of this we set an interim value that tells us this
1541         // element (most likely) has a default.
1542         //
1543         // Set interim value for now, reset just before we do this
1544         // properly at annotate time.
1545         meth.defaultValue = value;
1546         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1547     }
1548 
1549     Type readTypeOrClassSymbol(int i) {
1550         // support preliminary jsr175-format class files
1551         if (poolReader.hasTag(i, CONSTANT_Class))
1552             return poolReader.getClass(i).type;
1553         return readTypeToProxy(i);
1554     }
1555     Type readTypeToProxy(int i) {
1556         if (currentModule.module_info == currentOwner) {
1557             return new ProxyType(i);
1558         } else {
1559             return poolReader.getType(i);
1560         }
1561     }
1562 
1563     CompoundAnnotationProxy readCompoundAnnotation() {
1564         Type t;
1565         if (currentModule.module_info == currentOwner) {
1566             int cpIndex = nextChar();
1567             t = new ProxyType(cpIndex);
1568         } else {
1569             t = readTypeOrClassSymbol(nextChar());
1570         }
1571         int numFields = nextChar();
1572         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1573         for (int i=0; i&lt;numFields; i++) {
1574             Name name = poolReader.getName(nextChar());
1575             Attribute value = readAttributeValue();
1576             pairs.append(new Pair&lt;&gt;(name, value));
1577         }
1578         return new CompoundAnnotationProxy(t, pairs.toList());
1579     }
1580 
1581     TypeAnnotationProxy readTypeAnnotation() {
1582         TypeAnnotationPosition position = readPosition();
1583         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1584 
1585         return new TypeAnnotationProxy(proxy, position);
1586     }
1587 
1588     TypeAnnotationPosition readPosition() {
1589         int tag = nextByte(); // TargetType tag is a byte
1590 
1591         if (!TargetType.isValidTargetTypeValue(tag))
1592             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1593 
1594         TargetType type = TargetType.fromTargetTypeValue(tag);
1595 
1596         switch (type) {
1597         // instanceof
1598         case INSTANCEOF: {
1599             final int offset = nextChar();
1600             final TypeAnnotationPosition position =
1601                 TypeAnnotationPosition.instanceOf(readTypePath());
1602             position.offset = offset;
1603             return position;
1604         }
1605         // new expression
1606         case NEW: {
1607             final int offset = nextChar();
1608             final TypeAnnotationPosition position =
1609                 TypeAnnotationPosition.newObj(readTypePath());
1610             position.offset = offset;
1611             return position;
1612         }
1613         // constructor/method reference receiver
1614         case CONSTRUCTOR_REFERENCE: {
1615             final int offset = nextChar();
1616             final TypeAnnotationPosition position =
1617                 TypeAnnotationPosition.constructorRef(readTypePath());
1618             position.offset = offset;
1619             return position;
1620         }
1621         case METHOD_REFERENCE: {
1622             final int offset = nextChar();
1623             final TypeAnnotationPosition position =
1624                 TypeAnnotationPosition.methodRef(readTypePath());
1625             position.offset = offset;
1626             return position;
1627         }
1628         // local variable
1629         case LOCAL_VARIABLE: {
1630             final int table_length = nextChar();
1631             final int[] newLvarOffset = new int[table_length];
1632             final int[] newLvarLength = new int[table_length];
1633             final int[] newLvarIndex = new int[table_length];
1634 
1635             for (int i = 0; i &lt; table_length; ++i) {
1636                 newLvarOffset[i] = nextChar();
1637                 newLvarLength[i] = nextChar();
1638                 newLvarIndex[i] = nextChar();
1639             }
1640 
1641             final TypeAnnotationPosition position =
1642                     TypeAnnotationPosition.localVariable(readTypePath());
1643             position.lvarOffset = newLvarOffset;
1644             position.lvarLength = newLvarLength;
1645             position.lvarIndex = newLvarIndex;
1646             return position;
1647         }
1648         // resource variable
1649         case RESOURCE_VARIABLE: {
1650             final int table_length = nextChar();
1651             final int[] newLvarOffset = new int[table_length];
1652             final int[] newLvarLength = new int[table_length];
1653             final int[] newLvarIndex = new int[table_length];
1654 
1655             for (int i = 0; i &lt; table_length; ++i) {
1656                 newLvarOffset[i] = nextChar();
1657                 newLvarLength[i] = nextChar();
1658                 newLvarIndex[i] = nextChar();
1659             }
1660 
1661             final TypeAnnotationPosition position =
1662                     TypeAnnotationPosition.resourceVariable(readTypePath());
1663             position.lvarOffset = newLvarOffset;
1664             position.lvarLength = newLvarLength;
1665             position.lvarIndex = newLvarIndex;
1666             return position;
1667         }
1668         // exception parameter
1669         case EXCEPTION_PARAMETER: {
1670             final int exception_index = nextChar();
1671             final TypeAnnotationPosition position =
1672                 TypeAnnotationPosition.exceptionParameter(readTypePath());
1673             position.setExceptionIndex(exception_index);
1674             return position;
1675         }
1676         // method receiver
1677         case METHOD_RECEIVER:
1678             return TypeAnnotationPosition.methodReceiver(readTypePath());
1679         // type parameter
1680         case CLASS_TYPE_PARAMETER: {
1681             final int parameter_index = nextByte();
1682             return TypeAnnotationPosition
1683                 .typeParameter(readTypePath(), parameter_index);
1684         }
1685         case METHOD_TYPE_PARAMETER: {
1686             final int parameter_index = nextByte();
1687             return TypeAnnotationPosition
1688                 .methodTypeParameter(readTypePath(), parameter_index);
1689         }
1690         // type parameter bound
1691         case CLASS_TYPE_PARAMETER_BOUND: {
1692             final int parameter_index = nextByte();
1693             final int bound_index = nextByte();
1694             return TypeAnnotationPosition
1695                 .typeParameterBound(readTypePath(), parameter_index,
1696                                     bound_index);
1697         }
1698         case METHOD_TYPE_PARAMETER_BOUND: {
1699             final int parameter_index = nextByte();
1700             final int bound_index = nextByte();
1701             return TypeAnnotationPosition
1702                 .methodTypeParameterBound(readTypePath(), parameter_index,
1703                                           bound_index);
1704         }
1705         // class extends or implements clause
1706         case CLASS_EXTENDS: {
1707             final int type_index = nextChar();
1708             return TypeAnnotationPosition.classExtends(readTypePath(),
1709                                                        type_index);
1710         }
1711         // throws
1712         case THROWS: {
1713             final int type_index = nextChar();
1714             return TypeAnnotationPosition.methodThrows(readTypePath(),
1715                                                        type_index);
1716         }
1717         // method parameter
1718         case METHOD_FORMAL_PARAMETER: {
1719             final int parameter_index = nextByte();
1720             return TypeAnnotationPosition.methodParameter(readTypePath(),
1721                                                           parameter_index);
1722         }
1723         // type cast
1724         case CAST: {
1725             final int offset = nextChar();
1726             final int type_index = nextByte();
1727             final TypeAnnotationPosition position =
1728                 TypeAnnotationPosition.typeCast(readTypePath(), type_index);
1729             position.offset = offset;
1730             return position;
1731         }
1732         // method/constructor/reference type argument
1733         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: {
1734             final int offset = nextChar();
1735             final int type_index = nextByte();
1736             final TypeAnnotationPosition position = TypeAnnotationPosition
1737                 .constructorInvocationTypeArg(readTypePath(), type_index);
1738             position.offset = offset;
1739             return position;
1740         }
1741         case METHOD_INVOCATION_TYPE_ARGUMENT: {
1742             final int offset = nextChar();
1743             final int type_index = nextByte();
1744             final TypeAnnotationPosition position = TypeAnnotationPosition
1745                 .methodInvocationTypeArg(readTypePath(), type_index);
1746             position.offset = offset;
1747             return position;
1748         }
1749         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: {
1750             final int offset = nextChar();
1751             final int type_index = nextByte();
1752             final TypeAnnotationPosition position = TypeAnnotationPosition
1753                 .constructorRefTypeArg(readTypePath(), type_index);
1754             position.offset = offset;
1755             return position;
1756         }
1757         case METHOD_REFERENCE_TYPE_ARGUMENT: {
1758             final int offset = nextChar();
1759             final int type_index = nextByte();
1760             final TypeAnnotationPosition position = TypeAnnotationPosition
1761                 .methodRefTypeArg(readTypePath(), type_index);
1762             position.offset = offset;
1763             return position;
1764         }
1765         // We don&#39;t need to worry about these
1766         case METHOD_RETURN:
1767             return TypeAnnotationPosition.methodReturn(readTypePath());
1768         case FIELD:
1769             return TypeAnnotationPosition.field(readTypePath());
1770         case UNKNOWN:
1771             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1772         default:
1773             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1774         }
1775     }
1776 
1777     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1778         int len = nextByte();
1779         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1780         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1781             loc = loc.append(nextByte());
1782 
1783         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1784 
1785     }
1786 
1787     /**
1788      * Helper function to read an optional pool entry (with given function); this is used while parsing
1789      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,
1790      * as per JVMS.
1791      */
1792     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {
1793         return (index == 0) ?
1794                 defaultValue :
1795                 poolFunc.apply(index);
1796     }
1797 
1798     Attribute readAttributeValue() {
1799         char c = (char) buf.getByte(bp++);
1800         switch (c) {
1801         case &#39;B&#39;:
1802             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));
1803         case &#39;C&#39;:
1804             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));
1805         case &#39;D&#39;:
1806             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));
1807         case &#39;F&#39;:
1808             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));
1809         case &#39;I&#39;:
1810             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));
1811         case &#39;J&#39;:
1812             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));
1813         case &#39;S&#39;:
1814             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));
1815         case &#39;Z&#39;:
1816             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));
1817         case &#39;s&#39;:
1818             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());
1819         case &#39;e&#39;:
1820             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));
1821         case &#39;c&#39;:
1822             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1823         case &#39;[&#39;: {
1824             int n = nextChar();
1825             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1826             for (int i=0; i&lt;n; i++)
1827                 l.append(readAttributeValue());
1828             return new ArrayAttributeProxy(l.toList());
1829         }
1830         case &#39;@&#39;:
1831             return readCompoundAnnotation();
1832         default:
1833             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
1834         }
1835     }
1836 
1837     interface ProxyVisitor extends Attribute.Visitor {
1838         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
1839         void visitClassAttributeProxy(ClassAttributeProxy proxy);
1840         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
1841         void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy);
1842     }
1843 
1844     static class EnumAttributeProxy extends Attribute {
1845         Type enumType;
1846         Name enumerator;
1847         public EnumAttributeProxy(Type enumType, Name enumerator) {
1848             super(null);
1849             this.enumType = enumType;
1850             this.enumerator = enumerator;
1851         }
1852         public void accept(Visitor v) { ((ProxyVisitor)v).visitEnumAttributeProxy(this); }
1853         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1854         public String toString() {
1855             return &quot;/*proxy enum*/&quot; + enumType + &quot;.&quot; + enumerator;
1856         }
1857     }
1858 
1859     static class ClassAttributeProxy extends Attribute {
1860         Type classType;
1861         public ClassAttributeProxy(Type classType) {
1862             super(null);
1863             this.classType = classType;
1864         }
1865         public void accept(Visitor v) { ((ProxyVisitor)v).visitClassAttributeProxy(this); }
1866         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1867         public String toString() {
1868             return &quot;/*proxy class*/&quot; + classType + &quot;.class&quot;;
1869         }
1870     }
1871 
1872     static class ArrayAttributeProxy extends Attribute {
1873         List&lt;Attribute&gt; values;
1874         ArrayAttributeProxy(List&lt;Attribute&gt; values) {
1875             super(null);
1876             this.values = values;
1877         }
1878         public void accept(Visitor v) { ((ProxyVisitor)v).visitArrayAttributeProxy(this); }
1879         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1880         public String toString() {
1881             return &quot;{&quot; + values + &quot;}&quot;;
1882         }
1883     }
1884 
1885     /** A temporary proxy representing a compound attribute.
1886      */
1887     static class CompoundAnnotationProxy extends Attribute {
1888         final List&lt;Pair&lt;Name,Attribute&gt;&gt; values;
1889         public CompoundAnnotationProxy(Type type,
1890                                       List&lt;Pair&lt;Name,Attribute&gt;&gt; values) {
1891             super(type);
1892             this.values = values;
1893         }
1894         public void accept(Visitor v) { ((ProxyVisitor)v).visitCompoundAnnotationProxy(this); }
1895         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1896         public String toString() {
1897             StringBuilder buf = new StringBuilder();
1898             buf.append(&quot;@&quot;);
1899             buf.append(type.tsym.getQualifiedName());
1900             buf.append(&quot;/*proxy*/{&quot;);
1901             boolean first = true;
1902             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; v = values;
1903                  v.nonEmpty(); v = v.tail) {
1904                 Pair&lt;Name,Attribute&gt; value = v.head;
1905                 if (!first) buf.append(&quot;,&quot;);
1906                 first = false;
1907                 buf.append(value.fst);
1908                 buf.append(&quot;=&quot;);
1909                 buf.append(value.snd);
1910             }
1911             buf.append(&quot;}&quot;);
1912             return buf.toString();
1913         }
1914     }
1915 
1916     /** A temporary proxy representing a type annotation.
1917      */
1918     static class TypeAnnotationProxy {
1919         final CompoundAnnotationProxy compound;
1920         final TypeAnnotationPosition position;
1921         public TypeAnnotationProxy(CompoundAnnotationProxy compound,
1922                 TypeAnnotationPosition position) {
1923             this.compound = compound;
1924             this.position = position;
1925         }
1926     }
1927 
1928     class AnnotationDeproxy implements ProxyVisitor {
1929         private ClassSymbol requestingOwner;
1930 
1931         AnnotationDeproxy(ClassSymbol owner) {
1932             this.requestingOwner = owner;
1933         }
1934 
1935         List&lt;Attribute.Compound&gt; deproxyCompoundList(List&lt;CompoundAnnotationProxy&gt; pl) {
1936             // also must fill in types!!!!
1937             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
1938             for (List&lt;CompoundAnnotationProxy&gt; l = pl; l.nonEmpty(); l=l.tail) {
1939                 buf.append(deproxyCompound(l.head));
1940             }
1941             return buf.toList();
1942         }
1943 
1944         Attribute.Compound deproxyCompound(CompoundAnnotationProxy a) {
1945             Type annotationType = resolvePossibleProxyType(a.type);
1946             ListBuffer&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; buf = new ListBuffer&lt;&gt;();
1947             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; l = a.values;
1948                  l.nonEmpty();
1949                  l = l.tail) {
1950                 MethodSymbol meth = findAccessMethod(annotationType, l.head.fst);
1951                 buf.append(new Pair&lt;&gt;(meth, deproxy(meth.type.getReturnType(), l.head.snd)));
1952             }
1953             return new Attribute.Compound(annotationType, buf.toList());
1954         }
1955 
1956         MethodSymbol findAccessMethod(Type container, Name name) {
1957             CompletionFailure failure = null;
1958             try {
1959                 for (Symbol sym : container.tsym.members().getSymbolsByName(name)) {
1960                     if (sym.kind == MTH &amp;&amp; sym.type.getParameterTypes().length() == 0)
1961                         return (MethodSymbol) sym;
1962                 }
1963             } catch (CompletionFailure ex) {
1964                 failure = ex;
1965             }
1966             // The method wasn&#39;t found: emit a warning and recover
1967             JavaFileObject prevSource = log.useSource(requestingOwner.classfile);
1968             try {
1969                 if (lintClassfile) {
1970                     if (failure == null) {
1971                         log.warning(Warnings.AnnotationMethodNotFound(container, name));
1972                     } else {
1973                         log.warning(Warnings.AnnotationMethodNotFoundReason(container,
1974                                                                             name,
1975                                                                             failure.getDetailValue()));//diagnostic, if present
1976                     }
1977                 }
1978             } finally {
1979                 log.useSource(prevSource);
1980             }
1981             // Construct a new method type and symbol.  Use bottom
1982             // type (typeof null) as return type because this type is
1983             // a subtype of all reference types and can be converted
1984             // to primitive types by unboxing.
1985             MethodType mt = new MethodType(List.nil(),
1986                                            syms.botType,
1987                                            List.nil(),
1988                                            syms.methodClass);
1989             return new MethodSymbol(PUBLIC | ABSTRACT, name, mt, container.tsym);
1990         }
1991 
1992         Attribute result;
1993         Type type;
1994         Attribute deproxy(Type t, Attribute a) {
1995             Type oldType = type;
1996             try {
1997                 type = t;
1998                 a.accept(this);
1999                 return result;
2000             } finally {
2001                 type = oldType;
2002             }
2003         }
2004 
2005         // implement Attribute.Visitor below
2006 
2007         public void visitConstant(Attribute.Constant value) {
2008             // assert value.type == type;
2009             result = value;
2010         }
2011 
2012         public void visitClass(Attribute.Class clazz) {
2013             result = clazz;
2014         }
2015 
2016         public void visitEnum(Attribute.Enum e) {
2017             throw new AssertionError(); // shouldn&#39;t happen
2018         }
2019 
2020         public void visitCompound(Attribute.Compound compound) {
2021             throw new AssertionError(); // shouldn&#39;t happen
2022         }
2023 
2024         public void visitArray(Attribute.Array array) {
2025             throw new AssertionError(); // shouldn&#39;t happen
2026         }
2027 
2028         public void visitError(Attribute.Error e) {
2029             throw new AssertionError(); // shouldn&#39;t happen
2030         }
2031 
2032         public void visitEnumAttributeProxy(EnumAttributeProxy proxy) {
2033             // type.tsym.flatName() should == proxy.enumFlatName
2034             Type enumType = resolvePossibleProxyType(proxy.enumType);
2035             TypeSymbol enumTypeSym = enumType.tsym;
2036             VarSymbol enumerator = null;
2037             CompletionFailure failure = null;
2038             try {
2039                 for (Symbol sym : enumTypeSym.members().getSymbolsByName(proxy.enumerator)) {
2040                     if (sym.kind == VAR) {
2041                         enumerator = (VarSymbol)sym;
2042                         break;
2043                     }
2044                 }
2045             }
2046             catch (CompletionFailure ex) {
2047                 failure = ex;
2048             }
2049             if (enumerator == null) {
2050                 if (failure != null) {
2051                     log.warning(Warnings.UnknownEnumConstantReason(currentClassFile,
2052                                                                    enumTypeSym,
2053                                                                    proxy.enumerator,
2054                                                                    failure.getDiagnostic()));
2055                 } else {
2056                     log.warning(Warnings.UnknownEnumConstant(currentClassFile,
2057                                                              enumTypeSym,
2058                                                              proxy.enumerator));
2059                 }
2060                 result = new Attribute.Enum(enumTypeSym.type,
2061                         new VarSymbol(0, proxy.enumerator, syms.botType, enumTypeSym));
2062             } else {
2063                 result = new Attribute.Enum(enumTypeSym.type, enumerator);
2064             }
2065         }
2066 
2067         @Override
2068         public void visitClassAttributeProxy(ClassAttributeProxy proxy) {
2069             Type classType = resolvePossibleProxyType(proxy.classType);
2070             result = new Attribute.Class(types, classType);
2071         }
2072 
2073         public void visitArrayAttributeProxy(ArrayAttributeProxy proxy) {
2074             int length = proxy.values.length();
2075             Attribute[] ats = new Attribute[length];
2076             Type elemtype = types.elemtype(type);
2077             int i = 0;
2078             for (List&lt;Attribute&gt; p = proxy.values; p.nonEmpty(); p = p.tail) {
2079                 ats[i++] = deproxy(elemtype, p.head);
2080             }
2081             result = new Attribute.Array(type, ats);
2082         }
2083 
2084         public void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy) {
2085             result = deproxyCompound(proxy);
2086         }
2087 
2088         Type resolvePossibleProxyType(Type t) {
2089             if (t instanceof ProxyType) {
2090                 Assert.check(requestingOwner.owner.kind == MDL);
2091                 ModuleSymbol prevCurrentModule = currentModule;
2092                 currentModule = (ModuleSymbol) requestingOwner.owner;
2093                 try {
2094                     return ((ProxyType) t).resolve();
2095                 } finally {
2096                     currentModule = prevCurrentModule;
2097                 }
2098             } else {
2099                 return t;
2100             }
2101         }
2102     }
2103 
2104     class AnnotationDefaultCompleter extends AnnotationDeproxy implements Runnable {
2105         final MethodSymbol sym;
2106         final Attribute value;
2107         final JavaFileObject classFile = currentClassFile;
2108 
2109         AnnotationDefaultCompleter(MethodSymbol sym, Attribute value) {
2110             super(currentOwner.kind == MTH
2111                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2112             this.sym = sym;
2113             this.value = value;
2114         }
2115 
2116         @Override
2117         public void run() {
2118             JavaFileObject previousClassFile = currentClassFile;
2119             try {
2120                 // Reset the interim value set earlier in
2121                 // attachAnnotationDefault().
2122                 sym.defaultValue = null;
2123                 currentClassFile = classFile;
2124                 sym.defaultValue = deproxy(sym.type.getReturnType(), value);
2125             } finally {
2126                 currentClassFile = previousClassFile;
2127             }
2128         }
2129 
2130         @Override
2131         public String toString() {
2132             return &quot; ClassReader store default for &quot; + sym.owner + &quot;.&quot; + sym + &quot; is &quot; + value;
2133         }
2134     }
2135 
2136     class AnnotationCompleter extends AnnotationDeproxy implements Runnable {
2137         final Symbol sym;
2138         final List&lt;CompoundAnnotationProxy&gt; l;
2139         final JavaFileObject classFile;
2140 
2141         AnnotationCompleter(Symbol sym, List&lt;CompoundAnnotationProxy&gt; l) {
2142             super(currentOwner.kind == MTH
2143                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2144             if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
2145                 this.sym = sym.owner;
2146             } else {
2147                 this.sym = sym;
2148             }
2149             this.l = l;
2150             this.classFile = currentClassFile;
2151         }
2152 
2153         @Override
2154         public void run() {
2155             JavaFileObject previousClassFile = currentClassFile;
2156             try {
2157                 currentClassFile = classFile;
2158                 List&lt;Attribute.Compound&gt; newList = deproxyCompoundList(l);
2159                 for (Attribute.Compound attr : newList) {
2160                     if (attr.type.tsym == syms.deprecatedType.tsym) {
2161                         sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
2162                         Attribute forRemoval = attr.member(names.forRemoval);
2163                         if (forRemoval instanceof Attribute.Constant) {
2164                             Attribute.Constant c = (Attribute.Constant) forRemoval;
2165                             if (c.type == syms.booleanType &amp;&amp; ((Integer) c.value) != 0) {
2166                                 sym.flags_field |= DEPRECATED_REMOVAL;
2167                             }
2168                         }
2169                     }
2170                 }
2171                 if (sym.annotationsPendingCompletion()) {
2172                     sym.setDeclarationAttributes(newList);
2173                 } else {
2174                     sym.appendAttributes(newList);
2175                 }
2176             } finally {
2177                 currentClassFile = previousClassFile;
2178             }
2179         }
2180 
2181         @Override
2182         public String toString() {
2183             return &quot; ClassReader annotate &quot; + sym.owner + &quot;.&quot; + sym + &quot; with &quot; + l;
2184         }
2185     }
2186 
2187     class TypeAnnotationCompleter extends AnnotationCompleter {
2188 
2189         List&lt;TypeAnnotationProxy&gt; proxies;
2190 
2191         TypeAnnotationCompleter(Symbol sym,
2192                 List&lt;TypeAnnotationProxy&gt; proxies) {
2193             super(sym, List.nil());
2194             this.proxies = proxies;
2195         }
2196 
2197         List&lt;Attribute.TypeCompound&gt; deproxyTypeCompoundList(List&lt;TypeAnnotationProxy&gt; proxies) {
2198             ListBuffer&lt;Attribute.TypeCompound&gt; buf = new ListBuffer&lt;&gt;();
2199             for (TypeAnnotationProxy proxy: proxies) {
2200                 Attribute.Compound compound = deproxyCompound(proxy.compound);
2201                 Attribute.TypeCompound typeCompound = new Attribute.TypeCompound(compound, proxy.position);
2202                 buf.add(typeCompound);
2203             }
2204             return buf.toList();
2205         }
2206 
2207         @Override
2208         public void run() {
2209             JavaFileObject previousClassFile = currentClassFile;
2210             try {
2211                 currentClassFile = classFile;
2212                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2213                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2214             } finally {
2215                 currentClassFile = previousClassFile;
2216             }
2217         }
2218     }
2219 
2220 
2221 /************************************************************************
2222  * Reading Symbols
2223  ***********************************************************************/
2224 
2225     /** Read a field.
2226      */
2227     VarSymbol readField() {
2228         long flags = adjustFieldFlags(nextChar());
2229         Name name = poolReader.getName(nextChar());
2230         Type type = poolReader.getType(nextChar());
2231         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2232         readMemberAttrs(v);
2233         return v;
2234     }
2235 
2236     /** Read a method.
2237      */
2238     MethodSymbol readMethod() {
2239         long flags = adjustMethodFlags(nextChar());
2240         Name name = poolReader.getName(nextChar());
2241         Type type = poolReader.getType(nextChar());
2242         if (currentOwner.isInterface() &amp;&amp;
2243                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2244             if (majorVersion &gt; Version.V52.major ||
2245                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2246                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2247                     currentOwner.flags_field |= DEFAULT;
2248                     flags |= DEFAULT | ABSTRACT;
2249                 }
2250             } else {
2251                 //protect against ill-formed classfiles
2252                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2253                                    Integer.toString(majorVersion),
2254                                    Integer.toString(minorVersion));
2255             }
2256         }
2257         if (name == names.init &amp;&amp; ((flags &amp; STATIC) != 0)) {
2258             flags &amp;= ~STATIC;
2259             type = new MethodType(type.getParameterTypes(),
2260                     syms.voidType,
2261                     type.getThrownTypes(),
2262                     syms.methodClass);
2263         }
2264         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2265             // Sometimes anonymous classes don&#39;t have an outer
2266             // instance, however, there is no reliable way to tell so
2267             // we never strip this$n
2268             // ditto for local classes. Local classes that have an enclosing method set
2269             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2270             // enclosing method (i.e. from initializers) will pass that check.
2271             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2272             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2273                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2274                                       type.getReturnType(),
2275                                       type.getThrownTypes(),
2276                                       syms.methodClass);
2277         }
2278         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2279         if (types.isSignaturePolymorphic(m)) {
2280             m.flags_field |= SIGNATURE_POLYMORPHIC;
2281         }
2282         if (saveParameterNames)
2283             initParameterNames(m);
2284         Symbol prevOwner = currentOwner;
2285         currentOwner = m;
2286         try {
2287             readMemberAttrs(m);
2288         } finally {
2289             currentOwner = prevOwner;
2290         }
2291         setParameters(m, type);
2292 
2293         if ((flags &amp; VARARGS) != 0) {
2294             final Type last = type.getParameterTypes().last();
2295             if (last == null || !last.hasTag(ARRAY)) {
2296                 m.flags_field &amp;= ~VARARGS;
2297                 throw badClassFile(&quot;malformed.vararg.method&quot;, m);
2298             }
2299         }
2300 
2301         return m;
2302     }
2303 
2304     private List&lt;Type&gt; adjustMethodParams(long flags, List&lt;Type&gt; args) {
2305         if (args.isEmpty()) {
2306             return args;
2307         }
2308         boolean isVarargs = (flags &amp; VARARGS) != 0;
2309         if (isVarargs) {
2310             Type varargsElem = args.last();
2311             ListBuffer&lt;Type&gt; adjustedArgs = new ListBuffer&lt;&gt;();
2312             for (Type t : args) {
2313                 adjustedArgs.append(t != varargsElem ?
2314                     t :
2315                     ((ArrayType)t).makeVarargs());
2316             }
2317             args = adjustedArgs.toList();
2318         }
2319         return args.tail;
2320     }
2321 
2322     /**
2323      * Init the parameter names array.
2324      * Parameter names are currently inferred from the names in the
2325      * LocalVariableTable attributes of a Code attribute.
2326      * (Note: this means parameter names are currently not available for
2327      * methods without a Code attribute.)
2328      * This method initializes an array in which to store the name indexes
2329      * of parameter names found in LocalVariableTable attributes. It is
2330      * slightly supersized to allow for additional slots with a start_pc of 0.
2331      */
2332     void initParameterNames(MethodSymbol sym) {
2333         // make allowance for synthetic parameters.
2334         final int excessSlots = 4;
2335         int expectedParameterSlots =
2336                 Code.width(sym.type.getParameterTypes()) + excessSlots;
2337         if (parameterNameIndices == null
2338                 || parameterNameIndices.length &lt; expectedParameterSlots) {
2339             parameterNameIndices = new int[expectedParameterSlots];
2340         } else
2341             Arrays.fill(parameterNameIndices, 0);
2342         haveParameterNameIndices = false;
2343         sawMethodParameters = false;
2344     }
2345 
2346     /**
2347      * Set the parameters for a method symbol, including any names and
2348      * annotations that were read.
2349      *
2350      * &lt;p&gt;The type of the symbol may have changed while reading the
2351      * method attributes (see the Signature attribute). This may be
2352      * because of generic information or because anonymous synthetic
2353      * parameters were added.   The original type (as read from the
2354      * method descriptor) is used to help guess the existence of
2355      * anonymous synthetic parameters.
2356      */
2357     void setParameters(MethodSymbol sym, Type jvmType) {
2358         // If we get parameter names from MethodParameters, then we
2359         // don&#39;t need to skip.
2360         int firstParam = 0;
2361         if (!sawMethodParameters) {
2362             firstParam = ((sym.flags() &amp; STATIC) == 0) ? 1 : 0;
2363             // the code in readMethod may have skipped the first
2364             // parameter when setting up the MethodType. If so, we
2365             // make a corresponding allowance here for the position of
2366             // the first parameter.  Note that this assumes the
2367             // skipped parameter has a width of 1 -- i.e. it is not
2368             // a double width type (long or double.)
2369             if (sym.name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2370                 // Sometimes anonymous classes don&#39;t have an outer
2371                 // instance, however, there is no reliable way to tell so
2372                 // we never strip this$n
2373                 if (!currentOwner.name.isEmpty())
2374                     firstParam += 1;
2375             }
2376 
2377             if (sym.type != jvmType) {
2378                 // reading the method attributes has caused the
2379                 // symbol&#39;s type to be changed. (i.e. the Signature
2380                 // attribute.)  This may happen if there are hidden
2381                 // (synthetic) parameters in the descriptor, but not
2382                 // in the Signature.  The position of these hidden
2383                 // parameters is unspecified; for now, assume they are
2384                 // at the beginning, and so skip over them. The
2385                 // primary case for this is two hidden parameters
2386                 // passed into Enum constructors.
2387                 int skip = Code.width(jvmType.getParameterTypes())
2388                         - Code.width(sym.type.getParameterTypes());
2389                 firstParam += skip;
2390             }
2391         }
2392         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();
2393         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2394         int nameIndex = firstParam;
2395         int annotationIndex = 0;
2396         for (Type t: sym.type.getParameterTypes()) {
2397             VarSymbol param = parameter(nameIndex, t, sym, paramNames);
2398             params.append(param);
2399             if (parameterAnnotations != null) {
2400                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2401                 if (annotations != null &amp;&amp; annotations.proxies != null
2402                         &amp;&amp; !annotations.proxies.isEmpty()) {
2403                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2404                 }
2405             }
2406             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2407             annotationIndex++;
2408         }
2409         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2410             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2411         }
2412         Assert.checkNull(sym.params);
2413         sym.params = params.toList();
2414         parameterAnnotations = null;
2415         parameterNameIndices = null;
2416     }
2417 
2418 
2419     // Returns the name for the parameter at position &#39;index&#39;, either using
2420     // names read from the MethodParameters, or by synthesizing a name that
2421     // is not on the &#39;exclude&#39; list.
2422     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {
2423         long flags = PARAMETER;
2424         Name argName;
2425         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2426                 &amp;&amp; parameterNameIndices[index] != 0) {
2427             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);
2428             flags |= NAME_FILLED;
2429         } else {
2430             String prefix = &quot;arg&quot;;
2431             while (true) {
2432                 argName = names.fromString(prefix + exclude.size());
2433                 if (!exclude.contains(argName))
2434                     break;
2435                 prefix += &quot;$&quot;;
2436             }
2437         }
2438         exclude.add(argName);
2439         return new ParamSymbol(flags, argName, t, owner);
2440     }
2441 
2442     /**
2443      * skip n bytes
2444      */
2445     void skipBytes(int n) {
2446         bp = bp + n;
2447     }
2448 
2449     /** Skip a field or method
2450      */
2451     void skipMember() {
2452         bp = bp + 6;
2453         char ac = nextChar();
2454         for (int i = 0; i &lt; ac; i++) {
2455             bp = bp + 2;
2456             int attrLen = nextInt();
2457             bp = bp + attrLen;
2458         }
2459     }
2460 
2461     void skipInnerClasses() {
2462         int n = nextChar();
2463         for (int i = 0; i &lt; n; i++) {
2464             nextChar();
2465             nextChar();
2466             nextChar();
2467             nextChar();
2468         }
2469     }
2470 
2471     /** Enter type variables of this classtype and all enclosing ones in
2472      *  `typevars&#39;.
2473      */
2474     protected void enterTypevars(Symbol sym, Type t) {
2475         if (t.getEnclosingType() != null) {
2476             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2477                 enterTypevars(sym.owner, t.getEnclosingType());
2478             }
2479         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2480             enterTypevars(sym.owner, sym.owner.type);
2481         }
2482         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2483             typevars.enter(xs.head.tsym);
2484         }
2485     }
2486 
2487     protected ClassSymbol enterClass(Name name) {
2488         if (allowInlineTypes &amp;&amp; name.toString().endsWith(&quot;$ref&quot;)) {
2489             ClassSymbol v = syms.enterClass(currentModule, name.subName(0, name.length() - 4));
2490             return v.referenceProjection();
2491         }
2492         return syms.enterClass(currentModule, name);
2493     }
2494 
2495     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2496         return syms.enterClass(currentModule, name, owner);
2497     }
2498 
2499     /** Read contents of a given class symbol `c&#39;. Both external and internal
2500      *  versions of an inner class are read.
2501      */
2502     void readClass(ClassSymbol c) {
2503         ClassType ct = (ClassType)c.type;
2504 
2505         // allocate scope for members
2506         c.members_field = WriteableScope.create(c);
2507 
2508         // prepare type variable table
2509         typevars = typevars.dup(currentOwner);
2510         if (ct.getEnclosingType().hasTag(CLASS))
2511             enterTypevars(c.owner, ct.getEnclosingType());
2512 
2513         // read flags, or skip if this is an inner class
2514         long f = nextChar();
2515         long flags = adjustClassFlags(f);
2516         if ((flags &amp; MODULE) == 0) {
2517             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2518             // read own class name and check that it matches
2519             currentModule = c.packge().modle;
2520             ClassSymbol self = poolReader.getClass(nextChar());
2521             if (c != self) {
2522                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2523                                    self.flatname);
2524             }
2525         } else {
2526             if (majorVersion &lt; Version.V53.major) {
2527                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2528                         Integer.toString(majorVersion),
2529                         Integer.toString(minorVersion));
2530             }
2531             c.flags_field = flags;
2532             currentModule = (ModuleSymbol) c.owner;
2533             int this_class = nextChar();
2534             // temp, no check on this_class
2535         }
2536 
2537         // class attributes must be read before class
2538         // skip ahead to read class attributes
2539         int startbp = bp;
2540         nextChar();
2541         char interfaceCount = nextChar();
2542         bp += interfaceCount * 2;
2543         char fieldCount = nextChar();
2544         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2545         char methodCount = nextChar();
2546         for (int i = 0; i &lt; methodCount; i++) skipMember();
2547         readClassAttrs(c);
2548 
2549         if (c.permitted != null &amp;&amp; !c.permitted.isEmpty()) {
2550             c.flags_field |= SEALED;
2551         }
2552 
2553         // reset and read rest of classinfo
2554         bp = startbp;
2555         int n = nextChar();
2556         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2557             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2558         }
2559         if (ct.supertype_field == null)
2560             ct.supertype_field =
2561                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2562         n = nextChar();
2563         List&lt;Type&gt; is = List.nil();
2564         for (int i = 0; i &lt; n; i++) {
2565             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2566             is = is.prepend(_inter);
2567         }
2568         if (ct.interfaces_field == null)
2569             ct.interfaces_field = is.reverse();
2570 
2571         Assert.check(fieldCount == nextChar());
2572         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2573         Assert.check(methodCount == nextChar());
2574         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2575 
2576         typevars = typevars.leave();
2577     }
2578 
2579     /** Read inner class info. For each inner/outer pair allocate a
2580      *  member class.
2581      */
2582     void readInnerClasses(ClassSymbol c) {
2583         int n = nextChar();
2584         for (int i = 0; i &lt; n; i++) {
2585             nextChar(); // skip inner class symbol
2586             int outerIdx = nextChar();
2587             int nameIdx = nextChar();
2588             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);
2589             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);
2590             if (name == null) name = names.empty;
2591             long flags = adjustClassFlags(nextChar());
2592             if (outer != null) { // we have a member class
2593                 if (name == names.empty)
2594                     name = names.one;
2595                 ClassSymbol member = enterClass(name, outer);
2596                 if ((flags &amp; STATIC) == 0) {
2597                     ((ClassType)member.type).setEnclosingType(outer.type);
2598                     if (member.erasure_field != null)
2599                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2600                 }
2601                 if (c == outer) {
2602                     member.flags_field = flags;
2603                     enterMember(c, member);
2604                 }
2605             }
2606         }
2607     }
2608 
2609     /** Read a class definition from the bytes in buf.
2610      */
2611     private void readClassBuffer(ClassSymbol c) throws IOException {
2612         int magic = nextInt();
2613         if (magic != JAVA_MAGIC)
2614             throw badClassFile(&quot;illegal.start.of.class.file&quot;);
2615 
2616         minorVersion = nextChar();
2617         majorVersion = nextChar();
2618         int maxMajor = Version.MAX().major;
2619         int maxMinor = Version.MAX().minor;
2620         if (majorVersion &gt; maxMajor ||
2621             majorVersion * 1000 + minorVersion &lt;
2622             Version.MIN().major * 1000 + Version.MIN().minor) {
2623             if (majorVersion == (maxMajor + 1))
2624                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2625                                                      majorVersion,
2626                                                      maxMajor));
2627             else
2628                 throw badClassFile(&quot;wrong.version&quot;,
2629                                    Integer.toString(majorVersion),
2630                                    Integer.toString(minorVersion),
2631                                    Integer.toString(maxMajor),
2632                                    Integer.toString(maxMinor));
2633         }
2634 
2635         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2636             if (!preview.isEnabled()) {
2637                 log.error(preview.disabledError(currentClassFile, majorVersion));
2638             } else {
2639                 preview.warnPreview(c.classfile, majorVersion);
2640             }
2641         }
2642 
2643         poolReader = new PoolReader(this, names, syms);
2644         bp = poolReader.readPool(buf, bp);
2645         if (signatureBuffer.length &lt; bp) {
2646             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2647             signatureBuffer = new byte[ns];
2648         }
2649         readClass(c);
2650     }
2651 
2652     public void readClassFile(ClassSymbol c) {
2653         readClassFileInternal(c);
2654         if (c.isValue()) {
2655             /* http://cr.openjdk.java.net/~briangoetz/valhalla/sov/04-translation.html
2656                The relationship of value and reference projections differs between the language model
2657                and the VM model. In the language, the value projection is not a subtype of the
2658                reference projection; instead, the two are related by inline narrowing and widening
2659                conversions, whereas in the VM, the two are related by actual subtyping.
2660                Sever the subtyping relationship by rewiring the supertypes here and now.
2661              */
2662 
2663             Name flatname = TypeSymbol.formFlatName(names.ref, c);
2664             ClassSymbol referenceProjection = syms.getClass(currentModule, flatname);
2665             if (referenceProjection != null) {
2666                 if (referenceProjection.name != names.ref &amp;&amp; referenceProjection.owner.kind == PCK) {
2667                     readClassFileInternal(referenceProjection);
2668                     ClassType classType = (ClassType) c.type;
2669                     classType.supertype_field = ((ClassType) referenceProjection.type).supertype_field;
2670                     classType.interfaces_field = ((ClassType) referenceProjection.type).interfaces_field;
2671                     // Discard the projection, it will be recomputed on the fly.
2672                     referenceProjection.owner.members().remove(referenceProjection);
2673                 }
2674             }
2675         }
2676     }
2677 
2678     private void readClassFileInternal(ClassSymbol c) {
2679         currentOwner = c;
2680         currentClassFile = c.classfile;
2681         warnedAttrs.clear();
2682         filling = true;
2683         target = null;
2684         repeatable = null;
2685         try {
2686             bp = 0;
2687             buf.reset();
2688             buf.appendStream(c.classfile.openInputStream());
2689             readClassBuffer(c);
2690             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2691                 List&lt;Type&gt; missing = missingTypeVariables;
2692                 List&lt;Type&gt; found = foundTypeVariables;
2693                 missingTypeVariables = List.nil();
2694                 foundTypeVariables = List.nil();
2695                 interimUses = List.nil();
2696                 interimProvides = List.nil();
2697                 filling = false;
2698                 ClassType ct = (ClassType)currentOwner.type;
2699                 ct.supertype_field =
2700                     types.subst(ct.supertype_field, missing, found);
2701                 ct.interfaces_field =
2702                     types.subst(ct.interfaces_field, missing, found);
2703                 ct.typarams_field =
2704                     types.substBounds(ct.typarams_field, missing, found);
2705                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2706                     types.head.tsym.type = types.head;
2707                 }
2708             } else if (missingTypeVariables.isEmpty() !=
2709                        foundTypeVariables.isEmpty()) {
2710                 Name name = missingTypeVariables.head.tsym.name;
2711                 throw badClassFile(&quot;undecl.type.var&quot;, name);
2712             }
2713 
2714             if ((c.flags_field &amp; Flags.ANNOTATION) != 0) {
2715                 c.setAnnotationTypeMetadata(new AnnotationTypeMetadata(c, new CompleterDeproxy(c, target, repeatable)));
2716             } else {
2717                 c.setAnnotationTypeMetadata(AnnotationTypeMetadata.notAnAnnotationType());
2718             }
2719 
2720             if (c == currentModule.module_info) {
2721                 if (interimUses.nonEmpty() || interimProvides.nonEmpty()) {
2722                     Assert.check(currentModule.isCompleted());
2723                     currentModule.usesProvidesCompleter =
2724                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2725                 } else {
2726                     currentModule.uses = List.nil();
2727                     currentModule.provides = List.nil();
2728                 }
2729             }
2730         } catch (IOException | ClosedFileSystemException ex) {
2731             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2732         } catch (ArrayIndexOutOfBoundsException ex) {
2733             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2734         } finally {
2735             interimUses = List.nil();
2736             interimProvides = List.nil();
2737             missingTypeVariables = List.nil();
2738             foundTypeVariables = List.nil();
2739             filling = false;
2740         }
2741     }
2742 
2743     /** We can only read a single class file at a time; this
2744      *  flag keeps track of when we are currently reading a class
2745      *  file.
2746      */
2747     public boolean filling = false;
2748 
2749 /************************************************************************
2750  * Adjusting flags
2751  ***********************************************************************/
2752 
2753     long adjustFieldFlags(long flags) {
2754         return flags;
2755     }
2756 
2757     long adjustMethodFlags(long flags) {
2758         if ((flags &amp; ACC_BRIDGE) != 0) {
2759             flags &amp;= ~ACC_BRIDGE;
2760             flags |= BRIDGE;
2761         }
2762         if ((flags &amp; ACC_VARARGS) != 0) {
2763             flags &amp;= ~ACC_VARARGS;
2764             flags |= VARARGS;
2765         }
2766         return flags;
2767     }
2768 
2769     long adjustClassFlags(long flags) {
2770         if ((flags &amp; ACC_MODULE) != 0) {
2771             flags &amp;= ~ACC_MODULE;
2772             flags |= MODULE;
2773         }
2774         if ((flags &amp; ACC_VALUE) != 0) {
2775             flags &amp;= ~ACC_VALUE;
2776             flags |= allowInlineTypes ? VALUE : allowValueBasedClasses ? VALUEBASED : 0;
2777         }
2778         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2779     }
2780 
2781     /**
2782      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2783      * The attribute is only the last component of the original filename, so is unlikely
2784      * to be valid as is, so operations other than those to access the name throw
2785      * UnsupportedOperationException
2786      */
2787     private static class SourceFileObject implements JavaFileObject {
2788 
2789         /** The file&#39;s name.
2790          */
2791         private final Name name;
2792 
2793         public SourceFileObject(Name name) {
2794             this.name = name;
2795         }
2796 
2797         @Override @DefinedBy(Api.COMPILER)
2798         public URI toUri() {
2799             try {
2800                 return new URI(null, name.toString(), null);
2801             } catch (URISyntaxException e) {
2802                 throw new PathFileObject.CannotCreateUriError(name.toString(), e);
2803             }
2804         }
2805 
2806         @Override @DefinedBy(Api.COMPILER)
2807         public String getName() {
2808             return name.toString();
2809         }
2810 
2811         @Override @DefinedBy(Api.COMPILER)
2812         public JavaFileObject.Kind getKind() {
2813             return BaseFileManager.getKind(getName());
2814         }
2815 
2816         @Override @DefinedBy(Api.COMPILER)
2817         public InputStream openInputStream() {
2818             throw new UnsupportedOperationException();
2819         }
2820 
2821         @Override @DefinedBy(Api.COMPILER)
2822         public OutputStream openOutputStream() {
2823             throw new UnsupportedOperationException();
2824         }
2825 
2826         @Override @DefinedBy(Api.COMPILER)
2827         public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
2828             throw new UnsupportedOperationException();
2829         }
2830 
2831         @Override @DefinedBy(Api.COMPILER)
2832         public Reader openReader(boolean ignoreEncodingErrors) {
2833             throw new UnsupportedOperationException();
2834         }
2835 
2836         @Override @DefinedBy(Api.COMPILER)
2837         public Writer openWriter() {
2838             throw new UnsupportedOperationException();
2839         }
2840 
2841         @Override @DefinedBy(Api.COMPILER)
2842         public long getLastModified() {
2843             throw new UnsupportedOperationException();
2844         }
2845 
2846         @Override @DefinedBy(Api.COMPILER)
2847         public boolean delete() {
2848             throw new UnsupportedOperationException();
2849         }
2850 
2851         @Override @DefinedBy(Api.COMPILER)
2852         public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {
2853             return true; // fail-safe mode
2854         }
2855 
2856         @Override @DefinedBy(Api.COMPILER)
2857         public NestingKind getNestingKind() {
2858             return null;
2859         }
2860 
2861         @Override @DefinedBy(Api.COMPILER)
2862         public Modifier getAccessLevel() {
2863             return null;
2864         }
2865 
2866         /**
2867          * Check if two file objects are equal.
2868          * SourceFileObjects are just placeholder objects for the value of a
2869          * SourceFile attribute, and do not directly represent specific files.
2870          * Two SourceFileObjects are equal if their names are equal.
2871          */
2872         @Override
2873         public boolean equals(Object other) {
2874             if (this == other)
2875                 return true;
2876 
2877             if (!(other instanceof SourceFileObject))
2878                 return false;
2879 
2880             SourceFileObject o = (SourceFileObject) other;
2881             return name.equals(o.name);
2882         }
2883 
2884         @Override
2885         public int hashCode() {
2886             return name.hashCode();
2887         }
2888     }
2889 
2890     private class CompleterDeproxy implements AnnotationTypeCompleter {
2891         ClassSymbol proxyOn;
2892         CompoundAnnotationProxy target;
2893         CompoundAnnotationProxy repeatable;
2894 
2895         public CompleterDeproxy(ClassSymbol c, CompoundAnnotationProxy target,
2896                 CompoundAnnotationProxy repeatable)
2897         {
2898             this.proxyOn = c;
2899             this.target = target;
2900             this.repeatable = repeatable;
2901         }
2902 
2903         @Override
2904         public void complete(ClassSymbol sym) {
2905             Assert.check(proxyOn == sym);
2906             Attribute.Compound theTarget = null, theRepeatable = null;
2907             AnnotationDeproxy deproxy;
2908 
2909             try {
2910                 if (target != null) {
2911                     deproxy = new AnnotationDeproxy(proxyOn);
2912                     theTarget = deproxy.deproxyCompound(target);
2913                 }
2914 
2915                 if (repeatable != null) {
2916                     deproxy = new AnnotationDeproxy(proxyOn);
2917                     theRepeatable = deproxy.deproxyCompound(repeatable);
2918                 }
2919             } catch (Exception e) {
2920                 throw new CompletionFailure(sym,
2921                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),
2922                                             dcfh);
2923             }
2924 
2925             sym.getAnnotationTypeMetadata().setTarget(theTarget);
2926             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
2927         }
2928     }
2929 
2930     private class ProxyType extends Type {
2931 
2932         private final Name name;
2933 
2934         public ProxyType(int index) {
2935             super(syms.noSymbol, TypeMetadata.EMPTY);
2936             this.name = poolReader.getName(index);
2937         }
2938 
2939         @Override
2940         public TypeTag getTag() {
2941             return TypeTag.NONE;
2942         }
2943 
2944         @Override
2945         public Type cloneWithMetadata(TypeMetadata metadata) {
2946             throw new UnsupportedOperationException();
2947         }
2948 
2949         public Type resolve() {
2950             return name.map(ClassReader.this::sigToType);
2951         }
2952 
2953         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2954         public String toString() {
2955             return &quot;&lt;ProxyType&gt;&quot;;
2956         }
2957 
2958     }
2959 
2960     private static final class InterimUsesDirective {
2961         public final Name service;
2962 
2963         public InterimUsesDirective(Name service) {
2964             this.service = service;
2965         }
2966 
2967     }
2968 
2969     private static final class InterimProvidesDirective {
2970         public final Name service;
2971         public final List&lt;Name&gt; impls;
2972 
2973         public InterimProvidesDirective(Name service, List&lt;Name&gt; impls) {
2974             this.service = service;
2975             this.impls = impls;
2976         }
2977 
2978     }
2979 
2980     private final class UsesProvidesCompleter implements Completer {
2981         private final ModuleSymbol currentModule;
2982         private final List&lt;InterimUsesDirective&gt; interimUsesCopy;
2983         private final List&lt;InterimProvidesDirective&gt; interimProvidesCopy;
2984 
2985         public UsesProvidesCompleter(ModuleSymbol currentModule, List&lt;InterimUsesDirective&gt; interimUsesCopy, List&lt;InterimProvidesDirective&gt; interimProvidesCopy) {
2986             this.currentModule = currentModule;
2987             this.interimUsesCopy = interimUsesCopy;
2988             this.interimProvidesCopy = interimProvidesCopy;
2989         }
2990 
2991         @Override
2992         public void complete(Symbol sym) throws CompletionFailure {
2993             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
2994             directives.addAll(currentModule.directives);
2995             ListBuffer&lt;UsesDirective&gt; uses = new ListBuffer&lt;&gt;();
2996             for (InterimUsesDirective interim : interimUsesCopy) {
2997                 UsesDirective d = new UsesDirective(syms.enterClass(currentModule, interim.service));
2998                 uses.add(d);
2999                 directives.add(d);
3000             }
3001             currentModule.uses = uses.toList();
3002             ListBuffer&lt;ProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
3003             for (InterimProvidesDirective interim : interimProvidesCopy) {
3004                 ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
3005                 for (Name impl : interim.impls) {
3006                     impls.append(syms.enterClass(currentModule, impl));
3007                 }
3008                 ProvidesDirective d = new ProvidesDirective(syms.enterClass(currentModule, interim.service),
3009                                                             impls.toList());
3010                 provides.add(d);
3011                 directives.add(d);
3012             }
3013             currentModule.provides = provides.toList();
3014             currentModule.directives = directives.toList();
3015         }
3016     }
3017 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>