<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/interpreter/bytecodes.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/bytecodes.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;oops/method.hpp&quot;
 29 #include &quot;utilities/align.hpp&quot;
 30 #include &quot;utilities/bytes.hpp&quot;
 31 
 32 
 33 #if defined(WIN32) &amp;&amp; (defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1600))
 34 // Windows AMD64 Compiler Hangs compiling this file
 35 // unless optimization is off
 36 #ifdef _M_AMD64
 37 #pragma optimize (&quot;&quot;, off)
 38 #endif
 39 #endif
 40 
 41 
 42 bool            Bytecodes::_is_initialized = false;
 43 const char*     Bytecodes::_name          [Bytecodes::number_of_codes];
 44 BasicType       Bytecodes::_result_type   [Bytecodes::number_of_codes];
 45 s_char          Bytecodes::_depth         [Bytecodes::number_of_codes];
 46 u_char          Bytecodes::_lengths       [Bytecodes::number_of_codes];
 47 Bytecodes::Code Bytecodes::_java_code     [Bytecodes::number_of_codes];
 48 unsigned short  Bytecodes::_flags         [(1&lt;&lt;BitsPerByte)*2];
 49 
 50 #ifdef ASSERT
 51 bool Bytecodes::check_method(const Method* method, address bcp) {
 52   return method-&gt;contains(bcp);
 53 }
 54 #endif
 55 
 56 bool Bytecodes::check_must_rewrite(Bytecodes::Code code) {
 57   assert(can_rewrite(code), &quot;post-check only&quot;);
 58 
 59   // Some codes are conditionally rewriting.  Look closely at them.
 60   switch (code) {
 61   case Bytecodes::_aload_0:
 62     // Even if RewriteFrequentPairs is turned on,
 63     // the _aload_0 code might delay its rewrite until
 64     // a following _getfield rewrites itself.
 65     return false;
 66 
 67   case Bytecodes::_lookupswitch:
 68     return false;  // the rewrite is not done by the interpreter
 69 
 70   case Bytecodes::_new:
 71     // (Could actually look at the class here, but the profit would be small.)
 72     return false;  // the rewrite is not always done
 73 
 74   default:
 75     // No other special cases.
 76     return true;
 77   }
 78 }
 79 
 80 Bytecodes::Code Bytecodes::code_at(Method* method, int bci) {
 81   return code_at(method, method-&gt;bcp_from(bci));
 82 }
 83 
 84 Bytecodes::Code Bytecodes::non_breakpoint_code_at(const Method* method, address bcp) {
 85   assert(method != NULL, &quot;must have the method for breakpoint conversion&quot;);
 86   assert(method-&gt;contains(bcp), &quot;must be valid bcp in method&quot;);
 87   return method-&gt;orig_bytecode_at(method-&gt;bci_from(bcp));
 88 }
 89 
 90 int Bytecodes::special_length_at(Bytecodes::Code code, address bcp, address end) {
 91   switch (code) {
 92   case _wide:
 93     if (end != NULL &amp;&amp; bcp + 1 &gt;= end) {
 94       return -1; // don&#39;t read past end of code buffer
 95     }
 96     return wide_length_for(cast(*(bcp + 1)));
 97   case _tableswitch:
 98     { address aligned_bcp = align_up(bcp + 1, jintSize);
 99       if (end != NULL &amp;&amp; aligned_bcp + 3*jintSize &gt;= end) {
100         return -1; // don&#39;t read past end of code buffer
101       }
102       jlong lo = (jint)Bytes::get_Java_u4(aligned_bcp + 1*jintSize);
103       jlong hi = (jint)Bytes::get_Java_u4(aligned_bcp + 2*jintSize);
104       jlong len = (aligned_bcp - bcp) + (3 + hi - lo + 1)*jintSize;
105       // only return len if it can be represented as a positive int;
106       // return -1 otherwise
107       return (len &gt; 0 &amp;&amp; len == (int)len) ? len : -1;
108     }
109 
110   case _lookupswitch:      // fall through
111   case _fast_binaryswitch: // fall through
112   case _fast_linearswitch:
113     { address aligned_bcp = align_up(bcp + 1, jintSize);
114       if (end != NULL &amp;&amp; aligned_bcp + 2*jintSize &gt;= end) {
115         return -1; // don&#39;t read past end of code buffer
116       }
117       jlong npairs = (jint)Bytes::get_Java_u4(aligned_bcp + jintSize);
118       jlong len = (aligned_bcp - bcp) + (2 + 2*npairs)*jintSize;
119       // only return len if it can be represented as a positive int;
120       // return -1 otherwise
121       return (len &gt; 0 &amp;&amp; len == (int)len) ? len : -1;
122     }
123   default:
124     // Note: Length functions must return &lt;=0 for invalid bytecodes.
125     return 0;
126   }
127 }
128 
129 // At a breakpoint instruction, this returns the breakpoint&#39;s length,
130 // otherwise, it&#39;s the same as special_length_at().  This is used by
131 // the RawByteCodeStream, which wants to see the actual bytecode
132 // values (including breakpoint).  RawByteCodeStream is used by the
133 // verifier when reading in bytecode to verify.  Other mechanisms that
134 // run at runtime (such as generateOopMaps) need to iterate over the code
135 // and don&#39;t expect to see breakpoints: they want to see the instruction
136 // which was replaced so that they can get the correct length and find
137 // the next bytecode.
138 //
139 // &#39;end&#39; indicates the end of the code buffer, which we should not try to read
140 // past.
141 int Bytecodes::raw_special_length_at(address bcp, address end) {
142   Code code = code_or_bp_at(bcp);
143   if (code == _breakpoint) {
144     return 1;
145   } else {
146     return special_length_at(code, bcp, end);
147   }
148 }
149 
150 
151 
152 void Bytecodes::def(Code code, const char* name, const char* format, const char* wide_format, BasicType result_type, int depth, bool can_trap) {
153   def(code, name, format, wide_format, result_type, depth, can_trap, code);
154 }
155 
156 
157 void Bytecodes::def(Code code, const char* name, const char* format, const char* wide_format, BasicType result_type, int depth, bool can_trap, Code java_code) {
158   assert(wide_format == NULL || format != NULL, &quot;short form must exist if there&#39;s a wide form&quot;);
159   int len  = (format      != NULL ? (int) strlen(format)      : 0);
160   int wlen = (wide_format != NULL ? (int) strlen(wide_format) : 0);
161   _name          [code] = name;
162   _result_type   [code] = result_type;
163   _depth         [code] = depth;
164   _lengths       [code] = (wlen &lt;&lt; 4) | (len &amp; 0xF);
165   _java_code     [code] = java_code;
166   int bc_flags = 0;
167   if (can_trap)           bc_flags |= _bc_can_trap;
168   if (java_code != code)  bc_flags |= _bc_can_rewrite;
169   _flags[(u1)code+0*(1&lt;&lt;BitsPerByte)] = compute_flags(format,      bc_flags);
170   _flags[(u1)code+1*(1&lt;&lt;BitsPerByte)] = compute_flags(wide_format, bc_flags);
171   assert(is_defined(code)      == (format != NULL),      &quot;&quot;);
172   assert(wide_is_defined(code) == (wide_format != NULL), &quot;&quot;);
173   assert(length_for(code)      == len, &quot;&quot;);
174   assert(wide_length_for(code) == wlen, &quot;&quot;);
175 }
176 
177 
178 // Format strings interpretation:
179 //
180 // b: bytecode
181 // c: signed constant, Java byte-ordering
182 // i: unsigned local index, Java byte-ordering (I = native byte ordering)
183 // j: unsigned CP cache index, Java byte-ordering (J = native byte ordering)
184 // k: unsigned CP index, Java byte-ordering
185 // o: branch offset, Java byte-ordering
186 // _: unused/ignored
187 // w: wide bytecode
188 //
189 // Note: The format strings are used for 2 purposes:
190 //       1. to specify the length of the bytecode
191 //          (= number of characters in format string)
192 //       2. to derive bytecode format flags (_fmt_has_k, etc.)
193 //
194 // Note: For bytecodes with variable length, the format string is the empty string.
195 
196 int Bytecodes::compute_flags(const char* format, int more_flags) {
197   if (format == NULL)  return 0;  // not even more_flags
198   int flags = more_flags;
199   const char* fp = format;
200   switch (*fp) {
201   case &#39;\0&#39;:
202     flags |= _fmt_not_simple; // but variable
203     break;
204   case &#39;b&#39;:
205     flags |= _fmt_not_variable;  // but simple
206     ++fp;  // skip &#39;b&#39;
207     break;
208   case &#39;w&#39;:
209     flags |= _fmt_not_variable | _fmt_not_simple;
210     ++fp;  // skip &#39;w&#39;
211     guarantee(*fp == &#39;b&#39;, &quot;wide format must start with &#39;wb&#39;&quot;);
212     ++fp;  // skip &#39;b&#39;
213     break;
214   }
215 
216   int has_nbo = 0, has_jbo = 0, has_size = 0;
217   for (;;) {
218     int this_flag = 0;
219     char fc = *fp++;
220     switch (fc) {
221     case &#39;\0&#39;:  // end of string
222       assert(flags == (jchar)flags, &quot;change _format_flags&quot;);
223       return flags;
224 
225     case &#39;_&#39;: continue;         // ignore these
226 
227     case &#39;j&#39;: this_flag = _fmt_has_j; has_jbo = 1; break;
228     case &#39;k&#39;: this_flag = _fmt_has_k; has_jbo = 1; break;
229     case &#39;i&#39;: this_flag = _fmt_has_i; has_jbo = 1; break;
230     case &#39;c&#39;: this_flag = _fmt_has_c; has_jbo = 1; break;
231     case &#39;o&#39;: this_flag = _fmt_has_o; has_jbo = 1; break;
232 
233     // uppercase versions mark native byte order (from Rewriter)
234     // actually, only the &#39;J&#39; case happens currently
235     case &#39;J&#39;: this_flag = _fmt_has_j; has_nbo = 1; break;
236     case &#39;K&#39;: this_flag = _fmt_has_k; has_nbo = 1; break;
237     case &#39;I&#39;: this_flag = _fmt_has_i; has_nbo = 1; break;
238     case &#39;C&#39;: this_flag = _fmt_has_c; has_nbo = 1; break;
239     case &#39;O&#39;: this_flag = _fmt_has_o; has_nbo = 1; break;
240     default:  guarantee(false, &quot;bad char in format&quot;);
241     }
242 
243     flags |= this_flag;
244 
245     guarantee(!(has_jbo &amp;&amp; has_nbo), &quot;mixed byte orders in format&quot;);
246     if (has_nbo)
247       flags |= _fmt_has_nbo;
248 
249     int this_size = 1;
250     if (*fp == fc) {
251       // advance beyond run of the same characters
252       this_size = 2;
253       while (*++fp == fc)  this_size++;
254       switch (this_size) {
255       case 2: flags |= _fmt_has_u2; break;
256       case 4: flags |= _fmt_has_u4; break;
257       default: guarantee(false, &quot;bad rep count in format&quot;);
258       }
259     }
260     guarantee(has_size == 0 ||                     // no field yet
261               this_size == has_size ||             // same size
262               this_size &lt; has_size &amp;&amp; *fp == &#39;\0&#39;, // last field can be short
263               &quot;mixed field sizes in format&quot;);
264     has_size = this_size;
265   }
266 }
267 
268 void Bytecodes::initialize() {
269   if (_is_initialized) return;
270   assert(number_of_codes &lt;= 256, &quot;too many bytecodes&quot;);
271 
272   // initialize bytecode tables - didn&#39;t use static array initializers
273   // (such as {}) so we can do additional consistency checks and init-
274   // code is independent of actual bytecode numbering.
275   //
276   // Note 1: NULL for the format string means the bytecode doesn&#39;t exist
277   //         in that form.
278   //
279   // Note 2: The result type is T_ILLEGAL for bytecodes where the top of stack
280   //         type after execution is not only determined by the bytecode itself.
281 
282   //  Java bytecodes
283   //  bytecode               bytecode name           format   wide f.   result tp  stk traps
284   def(_nop                 , &quot;nop&quot;                 , &quot;b&quot;    , NULL    , T_VOID   ,  0, false);
285   def(_aconst_null         , &quot;aconst_null&quot;         , &quot;b&quot;    , NULL    , T_OBJECT ,  1, false);
286   def(_iconst_m1           , &quot;iconst_m1&quot;           , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
287   def(_iconst_0            , &quot;iconst_0&quot;            , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
288   def(_iconst_1            , &quot;iconst_1&quot;            , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
289   def(_iconst_2            , &quot;iconst_2&quot;            , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
290   def(_iconst_3            , &quot;iconst_3&quot;            , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
291   def(_iconst_4            , &quot;iconst_4&quot;            , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
292   def(_iconst_5            , &quot;iconst_5&quot;            , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
293   def(_lconst_0            , &quot;lconst_0&quot;            , &quot;b&quot;    , NULL    , T_LONG   ,  2, false);
294   def(_lconst_1            , &quot;lconst_1&quot;            , &quot;b&quot;    , NULL    , T_LONG   ,  2, false);
295   def(_fconst_0            , &quot;fconst_0&quot;            , &quot;b&quot;    , NULL    , T_FLOAT  ,  1, false);
296   def(_fconst_1            , &quot;fconst_1&quot;            , &quot;b&quot;    , NULL    , T_FLOAT  ,  1, false);
297   def(_fconst_2            , &quot;fconst_2&quot;            , &quot;b&quot;    , NULL    , T_FLOAT  ,  1, false);
298   def(_dconst_0            , &quot;dconst_0&quot;            , &quot;b&quot;    , NULL    , T_DOUBLE ,  2, false);
299   def(_dconst_1            , &quot;dconst_1&quot;            , &quot;b&quot;    , NULL    , T_DOUBLE ,  2, false);
300   def(_bipush              , &quot;bipush&quot;              , &quot;bc&quot;   , NULL    , T_INT    ,  1, false);
301   def(_sipush              , &quot;sipush&quot;              , &quot;bcc&quot;  , NULL    , T_INT    ,  1, false);
302   def(_ldc                 , &quot;ldc&quot;                 , &quot;bk&quot;   , NULL    , T_ILLEGAL,  1, true );
303   def(_ldc_w               , &quot;ldc_w&quot;               , &quot;bkk&quot;  , NULL    , T_ILLEGAL,  1, true );
304   def(_ldc2_w              , &quot;ldc2_w&quot;              , &quot;bkk&quot;  , NULL    , T_ILLEGAL,  2, true );
305   def(_iload               , &quot;iload&quot;               , &quot;bi&quot;   , &quot;wbii&quot;  , T_INT    ,  1, false);
306   def(_lload               , &quot;lload&quot;               , &quot;bi&quot;   , &quot;wbii&quot;  , T_LONG   ,  2, false);
307   def(_fload               , &quot;fload&quot;               , &quot;bi&quot;   , &quot;wbii&quot;  , T_FLOAT  ,  1, false);
308   def(_dload               , &quot;dload&quot;               , &quot;bi&quot;   , &quot;wbii&quot;  , T_DOUBLE ,  2, false);
309   def(_aload               , &quot;aload&quot;               , &quot;bi&quot;   , &quot;wbii&quot;  , T_OBJECT ,  1, false);
310   def(_iload_0             , &quot;iload_0&quot;             , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
311   def(_iload_1             , &quot;iload_1&quot;             , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
312   def(_iload_2             , &quot;iload_2&quot;             , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
313   def(_iload_3             , &quot;iload_3&quot;             , &quot;b&quot;    , NULL    , T_INT    ,  1, false);
314   def(_lload_0             , &quot;lload_0&quot;             , &quot;b&quot;    , NULL    , T_LONG   ,  2, false);
315   def(_lload_1             , &quot;lload_1&quot;             , &quot;b&quot;    , NULL    , T_LONG   ,  2, false);
316   def(_lload_2             , &quot;lload_2&quot;             , &quot;b&quot;    , NULL    , T_LONG   ,  2, false);
317   def(_lload_3             , &quot;lload_3&quot;             , &quot;b&quot;    , NULL    , T_LONG   ,  2, false);
318   def(_fload_0             , &quot;fload_0&quot;             , &quot;b&quot;    , NULL    , T_FLOAT  ,  1, false);
319   def(_fload_1             , &quot;fload_1&quot;             , &quot;b&quot;    , NULL    , T_FLOAT  ,  1, false);
320   def(_fload_2             , &quot;fload_2&quot;             , &quot;b&quot;    , NULL    , T_FLOAT  ,  1, false);
321   def(_fload_3             , &quot;fload_3&quot;             , &quot;b&quot;    , NULL    , T_FLOAT  ,  1, false);
322   def(_dload_0             , &quot;dload_0&quot;             , &quot;b&quot;    , NULL    , T_DOUBLE ,  2, false);
323   def(_dload_1             , &quot;dload_1&quot;             , &quot;b&quot;    , NULL    , T_DOUBLE ,  2, false);
324   def(_dload_2             , &quot;dload_2&quot;             , &quot;b&quot;    , NULL    , T_DOUBLE ,  2, false);
325   def(_dload_3             , &quot;dload_3&quot;             , &quot;b&quot;    , NULL    , T_DOUBLE ,  2, false);
326   def(_aload_0             , &quot;aload_0&quot;             , &quot;b&quot;    , NULL    , T_OBJECT ,  1, true ); // rewriting in interpreter
327   def(_aload_1             , &quot;aload_1&quot;             , &quot;b&quot;    , NULL    , T_OBJECT ,  1, false);
328   def(_aload_2             , &quot;aload_2&quot;             , &quot;b&quot;    , NULL    , T_OBJECT ,  1, false);
329   def(_aload_3             , &quot;aload_3&quot;             , &quot;b&quot;    , NULL    , T_OBJECT ,  1, false);
330   def(_iaload              , &quot;iaload&quot;              , &quot;b&quot;    , NULL    , T_INT    , -1, true );
331   def(_laload              , &quot;laload&quot;              , &quot;b&quot;    , NULL    , T_LONG   ,  0, true );
332   def(_faload              , &quot;faload&quot;              , &quot;b&quot;    , NULL    , T_FLOAT  , -1, true );
333   def(_daload              , &quot;daload&quot;              , &quot;b&quot;    , NULL    , T_DOUBLE ,  0, true );
334   def(_aaload              , &quot;aaload&quot;              , &quot;b&quot;    , NULL    , T_OBJECT , -1, true );
335   def(_baload              , &quot;baload&quot;              , &quot;b&quot;    , NULL    , T_INT    , -1, true );
336   def(_caload              , &quot;caload&quot;              , &quot;b&quot;    , NULL    , T_INT    , -1, true );
337   def(_saload              , &quot;saload&quot;              , &quot;b&quot;    , NULL    , T_INT    , -1, true );
338   def(_istore              , &quot;istore&quot;              , &quot;bi&quot;   , &quot;wbii&quot;  , T_VOID   , -1, false);
339   def(_lstore              , &quot;lstore&quot;              , &quot;bi&quot;   , &quot;wbii&quot;  , T_VOID   , -2, false);
340   def(_fstore              , &quot;fstore&quot;              , &quot;bi&quot;   , &quot;wbii&quot;  , T_VOID   , -1, false);
341   def(_dstore              , &quot;dstore&quot;              , &quot;bi&quot;   , &quot;wbii&quot;  , T_VOID   , -2, false);
342   def(_astore              , &quot;astore&quot;              , &quot;bi&quot;   , &quot;wbii&quot;  , T_VOID   , -1, false);
343   def(_istore_0            , &quot;istore_0&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
344   def(_istore_1            , &quot;istore_1&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
345   def(_istore_2            , &quot;istore_2&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
346   def(_istore_3            , &quot;istore_3&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
347   def(_lstore_0            , &quot;lstore_0&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -2, false);
348   def(_lstore_1            , &quot;lstore_1&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -2, false);
349   def(_lstore_2            , &quot;lstore_2&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -2, false);
350   def(_lstore_3            , &quot;lstore_3&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -2, false);
351   def(_fstore_0            , &quot;fstore_0&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
352   def(_fstore_1            , &quot;fstore_1&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
353   def(_fstore_2            , &quot;fstore_2&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
354   def(_fstore_3            , &quot;fstore_3&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
355   def(_dstore_0            , &quot;dstore_0&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -2, false);
356   def(_dstore_1            , &quot;dstore_1&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -2, false);
357   def(_dstore_2            , &quot;dstore_2&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -2, false);
358   def(_dstore_3            , &quot;dstore_3&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -2, false);
359   def(_astore_0            , &quot;astore_0&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
360   def(_astore_1            , &quot;astore_1&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
361   def(_astore_2            , &quot;astore_2&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
362   def(_astore_3            , &quot;astore_3&quot;            , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
363   def(_iastore             , &quot;iastore&quot;             , &quot;b&quot;    , NULL    , T_VOID   , -3, true );
364   def(_lastore             , &quot;lastore&quot;             , &quot;b&quot;    , NULL    , T_VOID   , -4, true );
365   def(_fastore             , &quot;fastore&quot;             , &quot;b&quot;    , NULL    , T_VOID   , -3, true );
366   def(_dastore             , &quot;dastore&quot;             , &quot;b&quot;    , NULL    , T_VOID   , -4, true );
367   def(_aastore             , &quot;aastore&quot;             , &quot;b&quot;    , NULL    , T_VOID   , -3, true );
368   def(_bastore             , &quot;bastore&quot;             , &quot;b&quot;    , NULL    , T_VOID   , -3, true );
369   def(_castore             , &quot;castore&quot;             , &quot;b&quot;    , NULL    , T_VOID   , -3, true );
370   def(_sastore             , &quot;sastore&quot;             , &quot;b&quot;    , NULL    , T_VOID   , -3, true );
371   def(_pop                 , &quot;pop&quot;                 , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
372   def(_pop2                , &quot;pop2&quot;                , &quot;b&quot;    , NULL    , T_VOID   , -2, false);
373   def(_dup                 , &quot;dup&quot;                 , &quot;b&quot;    , NULL    , T_VOID   ,  1, false);
374   def(_dup_x1              , &quot;dup_x1&quot;              , &quot;b&quot;    , NULL    , T_VOID   ,  1, false);
375   def(_dup_x2              , &quot;dup_x2&quot;              , &quot;b&quot;    , NULL    , T_VOID   ,  1, false);
376   def(_dup2                , &quot;dup2&quot;                , &quot;b&quot;    , NULL    , T_VOID   ,  2, false);
377   def(_dup2_x1             , &quot;dup2_x1&quot;             , &quot;b&quot;    , NULL    , T_VOID   ,  2, false);
378   def(_dup2_x2             , &quot;dup2_x2&quot;             , &quot;b&quot;    , NULL    , T_VOID   ,  2, false);
379   def(_swap                , &quot;swap&quot;                , &quot;b&quot;    , NULL    , T_VOID   ,  0, false);
380   def(_iadd                , &quot;iadd&quot;                , &quot;b&quot;    , NULL    , T_INT    , -1, false);
381   def(_ladd                , &quot;ladd&quot;                , &quot;b&quot;    , NULL    , T_LONG   , -2, false);
382   def(_fadd                , &quot;fadd&quot;                , &quot;b&quot;    , NULL    , T_FLOAT  , -1, false);
383   def(_dadd                , &quot;dadd&quot;                , &quot;b&quot;    , NULL    , T_DOUBLE , -2, false);
384   def(_isub                , &quot;isub&quot;                , &quot;b&quot;    , NULL    , T_INT    , -1, false);
385   def(_lsub                , &quot;lsub&quot;                , &quot;b&quot;    , NULL    , T_LONG   , -2, false);
386   def(_fsub                , &quot;fsub&quot;                , &quot;b&quot;    , NULL    , T_FLOAT  , -1, false);
387   def(_dsub                , &quot;dsub&quot;                , &quot;b&quot;    , NULL    , T_DOUBLE , -2, false);
388   def(_imul                , &quot;imul&quot;                , &quot;b&quot;    , NULL    , T_INT    , -1, false);
389   def(_lmul                , &quot;lmul&quot;                , &quot;b&quot;    , NULL    , T_LONG   , -2, false);
390   def(_fmul                , &quot;fmul&quot;                , &quot;b&quot;    , NULL    , T_FLOAT  , -1, false);
391   def(_dmul                , &quot;dmul&quot;                , &quot;b&quot;    , NULL    , T_DOUBLE , -2, false);
392   def(_idiv                , &quot;idiv&quot;                , &quot;b&quot;    , NULL    , T_INT    , -1, true );
393   def(_ldiv                , &quot;ldiv&quot;                , &quot;b&quot;    , NULL    , T_LONG   , -2, true );
394   def(_fdiv                , &quot;fdiv&quot;                , &quot;b&quot;    , NULL    , T_FLOAT  , -1, false);
395   def(_ddiv                , &quot;ddiv&quot;                , &quot;b&quot;    , NULL    , T_DOUBLE , -2, false);
396   def(_irem                , &quot;irem&quot;                , &quot;b&quot;    , NULL    , T_INT    , -1, true );
397   def(_lrem                , &quot;lrem&quot;                , &quot;b&quot;    , NULL    , T_LONG   , -2, true );
398   def(_frem                , &quot;frem&quot;                , &quot;b&quot;    , NULL    , T_FLOAT  , -1, false);
399   def(_drem                , &quot;drem&quot;                , &quot;b&quot;    , NULL    , T_DOUBLE , -2, false);
400   def(_ineg                , &quot;ineg&quot;                , &quot;b&quot;    , NULL    , T_INT    ,  0, false);
401   def(_lneg                , &quot;lneg&quot;                , &quot;b&quot;    , NULL    , T_LONG   ,  0, false);
402   def(_fneg                , &quot;fneg&quot;                , &quot;b&quot;    , NULL    , T_FLOAT  ,  0, false);
403   def(_dneg                , &quot;dneg&quot;                , &quot;b&quot;    , NULL    , T_DOUBLE ,  0, false);
404   def(_ishl                , &quot;ishl&quot;                , &quot;b&quot;    , NULL    , T_INT    , -1, false);
405   def(_lshl                , &quot;lshl&quot;                , &quot;b&quot;    , NULL    , T_LONG   , -1, false);
406   def(_ishr                , &quot;ishr&quot;                , &quot;b&quot;    , NULL    , T_INT    , -1, false);
407   def(_lshr                , &quot;lshr&quot;                , &quot;b&quot;    , NULL    , T_LONG   , -1, false);
408   def(_iushr               , &quot;iushr&quot;               , &quot;b&quot;    , NULL    , T_INT    , -1, false);
409   def(_lushr               , &quot;lushr&quot;               , &quot;b&quot;    , NULL    , T_LONG   , -1, false);
410   def(_iand                , &quot;iand&quot;                , &quot;b&quot;    , NULL    , T_INT    , -1, false);
411   def(_land                , &quot;land&quot;                , &quot;b&quot;    , NULL    , T_LONG   , -2, false);
412   def(_ior                 , &quot;ior&quot;                 , &quot;b&quot;    , NULL    , T_INT    , -1, false);
413   def(_lor                 , &quot;lor&quot;                 , &quot;b&quot;    , NULL    , T_LONG   , -2, false);
414   def(_ixor                , &quot;ixor&quot;                , &quot;b&quot;    , NULL    , T_INT    , -1, false);
415   def(_lxor                , &quot;lxor&quot;                , &quot;b&quot;    , NULL    , T_LONG   , -2, false);
416   def(_iinc                , &quot;iinc&quot;                , &quot;bic&quot;  , &quot;wbiicc&quot;, T_VOID   ,  0, false);
417   def(_i2l                 , &quot;i2l&quot;                 , &quot;b&quot;    , NULL    , T_LONG   ,  1, false);
418   def(_i2f                 , &quot;i2f&quot;                 , &quot;b&quot;    , NULL    , T_FLOAT  ,  0, false);
419   def(_i2d                 , &quot;i2d&quot;                 , &quot;b&quot;    , NULL    , T_DOUBLE ,  1, false);
420   def(_l2i                 , &quot;l2i&quot;                 , &quot;b&quot;    , NULL    , T_INT    , -1, false);
421   def(_l2f                 , &quot;l2f&quot;                 , &quot;b&quot;    , NULL    , T_FLOAT  , -1, false);
422   def(_l2d                 , &quot;l2d&quot;                 , &quot;b&quot;    , NULL    , T_DOUBLE ,  0, false);
423   def(_f2i                 , &quot;f2i&quot;                 , &quot;b&quot;    , NULL    , T_INT    ,  0, false);
424   def(_f2l                 , &quot;f2l&quot;                 , &quot;b&quot;    , NULL    , T_LONG   ,  1, false);
425   def(_f2d                 , &quot;f2d&quot;                 , &quot;b&quot;    , NULL    , T_DOUBLE ,  1, false);
426   def(_d2i                 , &quot;d2i&quot;                 , &quot;b&quot;    , NULL    , T_INT    , -1, false);
427   def(_d2l                 , &quot;d2l&quot;                 , &quot;b&quot;    , NULL    , T_LONG   ,  0, false);
428   def(_d2f                 , &quot;d2f&quot;                 , &quot;b&quot;    , NULL    , T_FLOAT  , -1, false);
429   def(_i2b                 , &quot;i2b&quot;                 , &quot;b&quot;    , NULL    , T_BYTE   ,  0, false);
430   def(_i2c                 , &quot;i2c&quot;                 , &quot;b&quot;    , NULL    , T_CHAR   ,  0, false);
431   def(_i2s                 , &quot;i2s&quot;                 , &quot;b&quot;    , NULL    , T_SHORT  ,  0, false);
432   def(_lcmp                , &quot;lcmp&quot;                , &quot;b&quot;    , NULL    , T_VOID   , -3, false);
433   def(_fcmpl               , &quot;fcmpl&quot;               , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
434   def(_fcmpg               , &quot;fcmpg&quot;               , &quot;b&quot;    , NULL    , T_VOID   , -1, false);
435   def(_dcmpl               , &quot;dcmpl&quot;               , &quot;b&quot;    , NULL    , T_VOID   , -3, false);
436   def(_dcmpg               , &quot;dcmpg&quot;               , &quot;b&quot;    , NULL    , T_VOID   , -3, false);
437   def(_ifeq                , &quot;ifeq&quot;                , &quot;boo&quot;  , NULL    , T_VOID   , -1, false);
438   def(_ifne                , &quot;ifne&quot;                , &quot;boo&quot;  , NULL    , T_VOID   , -1, false);
439   def(_iflt                , &quot;iflt&quot;                , &quot;boo&quot;  , NULL    , T_VOID   , -1, false);
440   def(_ifge                , &quot;ifge&quot;                , &quot;boo&quot;  , NULL    , T_VOID   , -1, false);
441   def(_ifgt                , &quot;ifgt&quot;                , &quot;boo&quot;  , NULL    , T_VOID   , -1, false);
442   def(_ifle                , &quot;ifle&quot;                , &quot;boo&quot;  , NULL    , T_VOID   , -1, false);
443   def(_if_icmpeq           , &quot;if_icmpeq&quot;           , &quot;boo&quot;  , NULL    , T_VOID   , -2, false);
444   def(_if_icmpne           , &quot;if_icmpne&quot;           , &quot;boo&quot;  , NULL    , T_VOID   , -2, false);
445   def(_if_icmplt           , &quot;if_icmplt&quot;           , &quot;boo&quot;  , NULL    , T_VOID   , -2, false);
446   def(_if_icmpge           , &quot;if_icmpge&quot;           , &quot;boo&quot;  , NULL    , T_VOID   , -2, false);
447   def(_if_icmpgt           , &quot;if_icmpgt&quot;           , &quot;boo&quot;  , NULL    , T_VOID   , -2, false);
448   def(_if_icmple           , &quot;if_icmple&quot;           , &quot;boo&quot;  , NULL    , T_VOID   , -2, false);
449   def(_if_acmpeq           , &quot;if_acmpeq&quot;           , &quot;boo&quot;  , NULL    , T_VOID   , -2, false);
450   def(_if_acmpne           , &quot;if_acmpne&quot;           , &quot;boo&quot;  , NULL    , T_VOID   , -2, false);
451   def(_goto                , &quot;goto&quot;                , &quot;boo&quot;  , NULL    , T_VOID   ,  0, false);
452   def(_jsr                 , &quot;jsr&quot;                 , &quot;boo&quot;  , NULL    , T_INT    ,  0, false);
453   def(_ret                 , &quot;ret&quot;                 , &quot;bi&quot;   , &quot;wbii&quot;  , T_VOID   ,  0, false);
454   def(_tableswitch         , &quot;tableswitch&quot;         , &quot;&quot;     , NULL    , T_VOID   , -1, false); // may have backward branches
455   def(_lookupswitch        , &quot;lookupswitch&quot;        , &quot;&quot;     , NULL    , T_VOID   , -1, false); // rewriting in interpreter
456   def(_ireturn             , &quot;ireturn&quot;             , &quot;b&quot;    , NULL    , T_INT    , -1, true);
457   def(_lreturn             , &quot;lreturn&quot;             , &quot;b&quot;    , NULL    , T_LONG   , -2, true);
458   def(_freturn             , &quot;freturn&quot;             , &quot;b&quot;    , NULL    , T_FLOAT  , -1, true);
459   def(_dreturn             , &quot;dreturn&quot;             , &quot;b&quot;    , NULL    , T_DOUBLE , -2, true);
460   def(_areturn             , &quot;areturn&quot;             , &quot;b&quot;    , NULL    , T_OBJECT , -1, true);
461   def(_return              , &quot;return&quot;              , &quot;b&quot;    , NULL    , T_VOID   ,  0, true);
462   def(_getstatic           , &quot;getstatic&quot;           , &quot;bJJ&quot;  , NULL    , T_ILLEGAL,  1, true );
463   def(_putstatic           , &quot;putstatic&quot;           , &quot;bJJ&quot;  , NULL    , T_ILLEGAL, -1, true );
464   def(_getfield            , &quot;getfield&quot;            , &quot;bJJ&quot;  , NULL    , T_ILLEGAL,  0, true );
465   def(_putfield            , &quot;putfield&quot;            , &quot;bJJ&quot;  , NULL    , T_ILLEGAL, -2, true );
466   def(_invokevirtual       , &quot;invokevirtual&quot;       , &quot;bJJ&quot;  , NULL    , T_ILLEGAL, -1, true);
467   def(_invokespecial       , &quot;invokespecial&quot;       , &quot;bJJ&quot;  , NULL    , T_ILLEGAL, -1, true);
468   def(_invokestatic        , &quot;invokestatic&quot;        , &quot;bJJ&quot;  , NULL    , T_ILLEGAL,  0, true);
469   def(_invokeinterface     , &quot;invokeinterface&quot;     , &quot;bJJ__&quot;, NULL    , T_ILLEGAL, -1, true);
470   def(_invokedynamic       , &quot;invokedynamic&quot;       , &quot;bJJJJ&quot;, NULL    , T_ILLEGAL,  0, true );
471   def(_new                 , &quot;new&quot;                 , &quot;bkk&quot;  , NULL    , T_OBJECT ,  1, true );
472   def(_newarray            , &quot;newarray&quot;            , &quot;bc&quot;   , NULL    , T_OBJECT ,  0, true );
473   def(_anewarray           , &quot;anewarray&quot;           , &quot;bkk&quot;  , NULL    , T_OBJECT ,  0, true );
474   def(_arraylength         , &quot;arraylength&quot;         , &quot;b&quot;    , NULL    , T_VOID   ,  0, true );
475   def(_athrow              , &quot;athrow&quot;              , &quot;b&quot;    , NULL    , T_VOID   , -1, true );
476   def(_checkcast           , &quot;checkcast&quot;           , &quot;bkk&quot;  , NULL    , T_OBJECT ,  0, true );
477   def(_instanceof          , &quot;instanceof&quot;          , &quot;bkk&quot;  , NULL    , T_INT    ,  0, true );
478   def(_monitorenter        , &quot;monitorenter&quot;        , &quot;b&quot;    , NULL    , T_VOID   , -1, true );
479   def(_monitorexit         , &quot;monitorexit&quot;         , &quot;b&quot;    , NULL    , T_VOID   , -1, true );
480   def(_wide                , &quot;wide&quot;                , &quot;&quot;     , NULL    , T_VOID   ,  0, false);
481   def(_multianewarray      , &quot;multianewarray&quot;      , &quot;bkkc&quot; , NULL    , T_OBJECT ,  1, true );
482   def(_ifnull              , &quot;ifnull&quot;              , &quot;boo&quot;  , NULL    , T_VOID   , -1, false);
483   def(_ifnonnull           , &quot;ifnonnull&quot;           , &quot;boo&quot;  , NULL    , T_VOID   , -1, false);
484   def(_goto_w              , &quot;goto_w&quot;              , &quot;boooo&quot;, NULL    , T_VOID   ,  0, false);
485   def(_jsr_w               , &quot;jsr_w&quot;               , &quot;boooo&quot;, NULL    , T_INT    ,  0, false);
486   def(_breakpoint          , &quot;breakpoint&quot;          , &quot;&quot;     , NULL    , T_VOID   ,  0, true);
487   def(_defaultvalue        , &quot;defaultvalue&quot;        , &quot;bkk&quot;  , NULL    , T_OBJECT ,  1, true);
488   def(_withfield           , &quot;withfield&quot;           , &quot;bJJ&quot;  , NULL    , T_OBJECT , -1, true );
489 
490   //  JVM bytecodes
491   //  bytecode               bytecode name           format   wide f.   result tp  stk traps  std code
492 
493   def(_fast_agetfield      , &quot;fast_agetfield&quot;      , &quot;bJJ&quot;  , NULL    , T_OBJECT ,  0, true , _getfield       );
494   def(_fast_qgetfield      , &quot;fast_qgetfield&quot;      , &quot;bJJ&quot;  , NULL    , T_OBJECT ,  0, true , _getfield       );
495   def(_fast_bgetfield      , &quot;fast_bgetfield&quot;      , &quot;bJJ&quot;  , NULL    , T_INT    ,  0, true , _getfield       );
496   def(_fast_cgetfield      , &quot;fast_cgetfield&quot;      , &quot;bJJ&quot;  , NULL    , T_CHAR   ,  0, true , _getfield       );
497   def(_fast_dgetfield      , &quot;fast_dgetfield&quot;      , &quot;bJJ&quot;  , NULL    , T_DOUBLE ,  0, true , _getfield       );
498   def(_fast_fgetfield      , &quot;fast_fgetfield&quot;      , &quot;bJJ&quot;  , NULL    , T_FLOAT  ,  0, true , _getfield       );
499   def(_fast_igetfield      , &quot;fast_igetfield&quot;      , &quot;bJJ&quot;  , NULL    , T_INT    ,  0, true , _getfield       );
500   def(_fast_lgetfield      , &quot;fast_lgetfield&quot;      , &quot;bJJ&quot;  , NULL    , T_LONG   ,  0, true , _getfield       );
501   def(_fast_sgetfield      , &quot;fast_sgetfield&quot;      , &quot;bJJ&quot;  , NULL    , T_SHORT  ,  0, true , _getfield       );
502 
503   def(_fast_aputfield      , &quot;fast_aputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_OBJECT ,  0, true , _putfield       );
504   def(_fast_qputfield      , &quot;fast_qputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_OBJECT ,  0, true , _putfield       );
505   def(_fast_bputfield      , &quot;fast_bputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_INT    ,  0, true , _putfield       );
506   def(_fast_zputfield      , &quot;fast_zputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_INT    ,  0, true , _putfield       );
507   def(_fast_cputfield      , &quot;fast_cputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_CHAR   ,  0, true , _putfield       );
508   def(_fast_dputfield      , &quot;fast_dputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_DOUBLE ,  0, true , _putfield       );
509   def(_fast_fputfield      , &quot;fast_fputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_FLOAT  ,  0, true , _putfield       );
510   def(_fast_iputfield      , &quot;fast_iputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_INT    ,  0, true , _putfield       );
511   def(_fast_lputfield      , &quot;fast_lputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_LONG   ,  0, true , _putfield       );
512   def(_fast_sputfield      , &quot;fast_sputfield&quot;      , &quot;bJJ&quot;  , NULL    , T_SHORT  ,  0, true , _putfield       );
513 
514   def(_fast_aload_0        , &quot;fast_aload_0&quot;        , &quot;b&quot;    , NULL    , T_OBJECT ,  1, true , _aload_0        );
515   def(_fast_iaccess_0      , &quot;fast_iaccess_0&quot;      , &quot;b_JJ&quot; , NULL    , T_INT    ,  1, true , _aload_0        );
516   def(_fast_aaccess_0      , &quot;fast_aaccess_0&quot;      , &quot;b_JJ&quot; , NULL    , T_OBJECT ,  1, true , _aload_0        );
517   def(_fast_faccess_0      , &quot;fast_faccess_0&quot;      , &quot;b_JJ&quot; , NULL    , T_OBJECT ,  1, true , _aload_0        );
518 
519   def(_fast_iload          , &quot;fast_iload&quot;          , &quot;bi&quot;   , NULL    , T_INT    ,  1, false, _iload);
520   def(_fast_iload2         , &quot;fast_iload2&quot;         , &quot;bi_i&quot; , NULL    , T_INT    ,  2, false, _iload);
521   def(_fast_icaload        , &quot;fast_icaload&quot;        , &quot;bi_&quot;  , NULL    , T_INT    ,  0, false, _iload);
522 
523   // Faster method invocation.
524   def(_fast_invokevfinal   , &quot;fast_invokevfinal&quot;   , &quot;bJJ&quot;  , NULL    , T_ILLEGAL, -1, true, _invokevirtual   );
525 
526   def(_fast_linearswitch   , &quot;fast_linearswitch&quot;   , &quot;&quot;     , NULL    , T_VOID   , -1, false, _lookupswitch   );
527   def(_fast_binaryswitch   , &quot;fast_binaryswitch&quot;   , &quot;&quot;     , NULL    , T_VOID   , -1, false, _lookupswitch   );
528 
529   def(_return_register_finalizer , &quot;return_register_finalizer&quot; , &quot;b&quot;    , NULL    , T_VOID   ,  0, true, _return);
530 
531   def(_invokehandle        , &quot;invokehandle&quot;        , &quot;bJJ&quot;  , NULL    , T_ILLEGAL, -1, true, _invokevirtual   );
532 
533   def(_fast_aldc           , &quot;fast_aldc&quot;           , &quot;bj&quot;   , NULL    , T_OBJECT,   1, true,  _ldc   );
534   def(_fast_aldc_w         , &quot;fast_aldc_w&quot;         , &quot;bJJ&quot;  , NULL    , T_OBJECT,   1, true,  _ldc_w );
535 
536   def(_nofast_getfield     , &quot;nofast_getfield&quot;     , &quot;bJJ&quot;  , NULL    , T_ILLEGAL,  0, true,  _getfield       );
537   def(_nofast_putfield     , &quot;nofast_putfield&quot;     , &quot;bJJ&quot;  , NULL    , T_ILLEGAL, -2, true , _putfield       );
538 
539   def(_nofast_aload_0      , &quot;nofast_aload_0&quot;      , &quot;b&quot;    , NULL    , T_OBJECT,   1, true , _aload_0        );
540   def(_nofast_iload        , &quot;nofast_iload&quot;        , &quot;bi&quot;   , NULL    , T_INT,      1, false, _iload          );
541 
542   def(_shouldnotreachhere  , &quot;_shouldnotreachhere&quot; , &quot;b&quot;    , NULL    , T_VOID   ,  0, false);
543 
544   // compare can_trap information for each bytecode with the
545   // can_trap information for the corresponding base bytecode
546   // (if a rewritten bytecode can trap, so must the base bytecode)
547   #ifdef ASSERT
548     { for (int i = 0; i &lt; number_of_codes; i++) {
549         if (is_defined(i)) {
550           Code code = cast(i);
551           Code java = java_code(code);
552           if (can_trap(code) &amp;&amp; !can_trap(java))
553             fatal(&quot;%s can trap =&gt; %s can trap, too&quot;, name(code), name(java));
554         }
555       }
556     }
557   #endif
558 
559   // initialization successful
560   _is_initialized = true;
561 }
562 
563 
564 void bytecodes_init() {
565   Bytecodes::initialize();
566 }
567 
568 // Restore optimization
569 #ifdef _M_AMD64
570 #pragma optimize (&quot;&quot;, on)
571 #endif
    </pre>
  </body>
</html>