<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/phaseX.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/block.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/idealGraphPrinter.hpp&quot;
  35 #include &quot;opto/loopnode.hpp&quot;
  36 #include &quot;opto/machnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/phaseX.hpp&quot;
  39 #include &quot;opto/regalloc.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;utilities/macros.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 //=============================================================================
  45 #define NODE_HASH_MINIMUM_SIZE    255
  46 //------------------------------NodeHash---------------------------------------
  47 NodeHash::NodeHash(uint est_max_size) :
  48   _a(Thread::current()-&gt;resource_area()),
  49   _max( round_up(est_max_size &lt; NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),
  50   _inserts(0), _insert_limit( insert_limit() ),
  51   _table( NEW_ARENA_ARRAY( _a , Node* , _max ) ) // (Node**)_a-&gt;Amalloc(_max * sizeof(Node*)) ),
  52 #ifndef PRODUCT
  53   , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),
  54   _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),
  55    _total_inserts(0), _total_insert_probes(0)
  56 #endif
  57 {
  58   // _sentinel must be in the current node space
  59   _sentinel = new ProjNode(NULL, TypeFunc::Control);
  60   memset(_table,0,sizeof(Node*)*_max);
  61 }
  62 
  63 //------------------------------NodeHash---------------------------------------
  64 NodeHash::NodeHash(Arena *arena, uint est_max_size) :
  65   _a(arena),
  66   _max( round_up(est_max_size &lt; NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),
  67   _inserts(0), _insert_limit( insert_limit() ),
  68   _table( NEW_ARENA_ARRAY( _a , Node* , _max ) )
  69 #ifndef PRODUCT
  70   , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),
  71   _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),
  72    _total_inserts(0), _total_insert_probes(0)
  73 #endif
  74 {
  75   // _sentinel must be in the current node space
  76   _sentinel = new ProjNode(NULL, TypeFunc::Control);
  77   memset(_table,0,sizeof(Node*)*_max);
  78 }
  79 
  80 //------------------------------NodeHash---------------------------------------
  81 NodeHash::NodeHash(NodeHash *nh) {
  82   debug_only(_table = (Node**)badAddress);   // interact correctly w/ operator=
  83   // just copy in all the fields
  84   *this = *nh;
  85   // nh-&gt;_sentinel must be in the current node space
  86 }
  87 
  88 void NodeHash::replace_with(NodeHash *nh) {
  89   debug_only(_table = (Node**)badAddress);   // interact correctly w/ operator=
  90   // just copy in all the fields
  91   *this = *nh;
  92   // nh-&gt;_sentinel must be in the current node space
  93 }
  94 
  95 //------------------------------hash_find--------------------------------------
  96 // Find in hash table
  97 Node *NodeHash::hash_find( const Node *n ) {
  98   // ((Node*)n)-&gt;set_hash( n-&gt;hash() );
  99   uint hash = n-&gt;hash();
 100   if (hash == Node::NO_HASH) {
 101     NOT_PRODUCT( _lookup_misses++ );
 102     return NULL;
 103   }
 104   uint key = hash &amp; (_max-1);
 105   uint stride = key | 0x01;
 106   NOT_PRODUCT( _look_probes++ );
 107   Node *k = _table[key];        // Get hashed value
 108   if( !k ) {                    // ?Miss?
 109     NOT_PRODUCT( _lookup_misses++ );
 110     return NULL;                // Miss!
 111   }
 112 
 113   int op = n-&gt;Opcode();
 114   uint req = n-&gt;req();
 115   while( 1 ) {                  // While probing hash table
 116     if( k-&gt;req() == req &amp;&amp;      // Same count of inputs
 117         k-&gt;Opcode() == op ) {   // Same Opcode
 118       for( uint i=0; i&lt;req; i++ )
 119         if( n-&gt;in(i)!=k-&gt;in(i)) // Different inputs?
 120           goto collision;       // &quot;goto&quot; is a speed hack...
 121       if( n-&gt;cmp(*k) ) {        // Check for any special bits
 122         NOT_PRODUCT( _lookup_hits++ );
 123         return k;               // Hit!
 124       }
 125     }
 126   collision:
 127     NOT_PRODUCT( _look_probes++ );
 128     key = (key + stride/*7*/) &amp; (_max-1); // Stride through table with relative prime
 129     k = _table[key];            // Get hashed value
 130     if( !k ) {                  // ?Miss?
 131       NOT_PRODUCT( _lookup_misses++ );
 132       return NULL;              // Miss!
 133     }
 134   }
 135   ShouldNotReachHere();
 136   return NULL;
 137 }
 138 
 139 //------------------------------hash_find_insert-------------------------------
 140 // Find in hash table, insert if not already present
 141 // Used to preserve unique entries in hash table
 142 Node *NodeHash::hash_find_insert( Node *n ) {
 143   // n-&gt;set_hash( );
 144   uint hash = n-&gt;hash();
 145   if (hash == Node::NO_HASH) {
 146     NOT_PRODUCT( _lookup_misses++ );
 147     return NULL;
 148   }
 149   uint key = hash &amp; (_max-1);
 150   uint stride = key | 0x01;     // stride must be relatively prime to table siz
 151   uint first_sentinel = 0;      // replace a sentinel if seen.
 152   NOT_PRODUCT( _look_probes++ );
 153   Node *k = _table[key];        // Get hashed value
 154   if( !k ) {                    // ?Miss?
 155     NOT_PRODUCT( _lookup_misses++ );
 156     _table[key] = n;            // Insert into table!
 157     debug_only(n-&gt;enter_hash_lock()); // Lock down the node while in the table.
 158     check_grow();               // Grow table if insert hit limit
 159     return NULL;                // Miss!
 160   }
 161   else if( k == _sentinel ) {
 162     first_sentinel = key;      // Can insert here
 163   }
 164 
 165   int op = n-&gt;Opcode();
 166   uint req = n-&gt;req();
 167   while( 1 ) {                  // While probing hash table
 168     if( k-&gt;req() == req &amp;&amp;      // Same count of inputs
 169         k-&gt;Opcode() == op ) {   // Same Opcode
 170       for( uint i=0; i&lt;req; i++ )
 171         if( n-&gt;in(i)!=k-&gt;in(i)) // Different inputs?
 172           goto collision;       // &quot;goto&quot; is a speed hack...
 173       if( n-&gt;cmp(*k) ) {        // Check for any special bits
 174         NOT_PRODUCT( _lookup_hits++ );
 175         return k;               // Hit!
 176       }
 177     }
 178   collision:
 179     NOT_PRODUCT( _look_probes++ );
 180     key = (key + stride) &amp; (_max-1); // Stride through table w/ relative prime
 181     k = _table[key];            // Get hashed value
 182     if( !k ) {                  // ?Miss?
 183       NOT_PRODUCT( _lookup_misses++ );
 184       key = (first_sentinel == 0) ? key : first_sentinel; // ?saw sentinel?
 185       _table[key] = n;          // Insert into table!
 186       debug_only(n-&gt;enter_hash_lock()); // Lock down the node while in the table.
 187       check_grow();             // Grow table if insert hit limit
 188       return NULL;              // Miss!
 189     }
 190     else if( first_sentinel == 0 &amp;&amp; k == _sentinel ) {
 191       first_sentinel = key;    // Can insert here
 192     }
 193 
 194   }
 195   ShouldNotReachHere();
 196   return NULL;
 197 }
 198 
 199 //------------------------------hash_insert------------------------------------
 200 // Insert into hash table
 201 void NodeHash::hash_insert( Node *n ) {
 202   // // &quot;conflict&quot; comments -- print nodes that conflict
 203   // bool conflict = false;
 204   // n-&gt;set_hash();
 205   uint hash = n-&gt;hash();
 206   if (hash == Node::NO_HASH) {
 207     return;
 208   }
 209   check_grow();
 210   uint key = hash &amp; (_max-1);
 211   uint stride = key | 0x01;
 212 
 213   while( 1 ) {                  // While probing hash table
 214     NOT_PRODUCT( _insert_probes++ );
 215     Node *k = _table[key];      // Get hashed value
 216     if( !k || (k == _sentinel) ) break;       // Found a slot
 217     assert( k != n, &quot;already inserted&quot; );
 218     // if( PrintCompilation &amp;&amp; PrintOptoStatistics &amp;&amp; Verbose ) { tty-&gt;print(&quot;  conflict: &quot;); k-&gt;dump(); conflict = true; }
 219     key = (key + stride) &amp; (_max-1); // Stride through table w/ relative prime
 220   }
 221   _table[key] = n;              // Insert into table!
 222   debug_only(n-&gt;enter_hash_lock()); // Lock down the node while in the table.
 223   // if( conflict ) { n-&gt;dump(); }
 224 }
 225 
 226 //------------------------------hash_delete------------------------------------
 227 // Replace in hash table with sentinel
 228 bool NodeHash::hash_delete( const Node *n ) {
 229   Node *k;
 230   uint hash = n-&gt;hash();
 231   if (hash == Node::NO_HASH) {
 232     NOT_PRODUCT( _delete_misses++ );
 233     return false;
 234   }
 235   uint key = hash &amp; (_max-1);
 236   uint stride = key | 0x01;
 237   debug_only( uint counter = 0; );
 238   for( ; /* (k != NULL) &amp;&amp; (k != _sentinel) */; ) {
 239     debug_only( counter++ );
 240     NOT_PRODUCT( _delete_probes++ );
 241     k = _table[key];            // Get hashed value
 242     if( !k ) {                  // Miss?
 243       NOT_PRODUCT( _delete_misses++ );
 244       return false;             // Miss! Not in chain
 245     }
 246     else if( n == k ) {
 247       NOT_PRODUCT( _delete_hits++ );
 248       _table[key] = _sentinel;  // Hit! Label as deleted entry
 249       debug_only(((Node*)n)-&gt;exit_hash_lock()); // Unlock the node upon removal from table.
 250       return true;
 251     }
 252     else {
 253       // collision: move through table with prime offset
 254       key = (key + stride/*7*/) &amp; (_max-1);
 255       assert( counter &lt;= _insert_limit, &quot;Cycle in hash-table&quot;);
 256     }
 257   }
 258   ShouldNotReachHere();
 259   return false;
 260 }
 261 
 262 //------------------------------round_up---------------------------------------
 263 // Round up to nearest power of 2
 264 uint NodeHash::round_up(uint x) {
 265   x += (x &gt;&gt; 2);                  // Add 25% slop
 266   return MAX2(16U, round_up_power_of_2(x));
 267 }
 268 
 269 //------------------------------grow-------------------------------------------
 270 // Grow _table to next power of 2 and insert old entries
 271 void  NodeHash::grow() {
 272   // Record old state
 273   uint   old_max   = _max;
 274   Node **old_table = _table;
 275   // Construct new table with twice the space
 276 #ifndef PRODUCT
 277   _grows++;
 278   _total_inserts       += _inserts;
 279   _total_insert_probes += _insert_probes;
 280   _insert_probes   = 0;
 281 #endif
 282   _inserts         = 0;
 283   _max     = _max &lt;&lt; 1;
 284   _table   = NEW_ARENA_ARRAY( _a , Node* , _max ); // (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
 285   memset(_table,0,sizeof(Node*)*_max);
 286   _insert_limit = insert_limit();
 287   // Insert old entries into the new table
 288   for( uint i = 0; i &lt; old_max; i++ ) {
 289     Node *m = *old_table++;
 290     if( !m || m == _sentinel ) continue;
 291     debug_only(m-&gt;exit_hash_lock()); // Unlock the node upon removal from old table.
 292     hash_insert(m);
 293   }
 294 }
 295 
 296 //------------------------------clear------------------------------------------
 297 // Clear all entries in _table to NULL but keep storage
 298 void  NodeHash::clear() {
 299 #ifdef ASSERT
 300   // Unlock all nodes upon removal from table.
 301   for (uint i = 0; i &lt; _max; i++) {
 302     Node* n = _table[i];
 303     if (!n || n == _sentinel)  continue;
 304     n-&gt;exit_hash_lock();
 305   }
 306 #endif
 307 
 308   memset( _table, 0, _max * sizeof(Node*) );
 309 }
 310 
 311 //-----------------------remove_useless_nodes----------------------------------
 312 // Remove useless nodes from value table,
 313 // implementation does not depend on hash function
 314 void NodeHash::remove_useless_nodes(VectorSet &amp;useful) {
 315 
 316   // Dead nodes in the hash table inherited from GVN should not replace
 317   // existing nodes, remove dead nodes.
 318   uint max = size();
 319   Node *sentinel_node = sentinel();
 320   for( uint i = 0; i &lt; max; ++i ) {
 321     Node *n = at(i);
 322     if(n != NULL &amp;&amp; n != sentinel_node &amp;&amp; !useful.test(n-&gt;_idx)) {
 323       debug_only(n-&gt;exit_hash_lock()); // Unlock the node when removed
 324       _table[i] = sentinel_node;       // Replace with placeholder
 325     }
 326   }
 327 }
 328 
 329 
 330 void NodeHash::check_no_speculative_types() {
 331 #ifdef ASSERT
 332   uint max = size();
 333   Node *sentinel_node = sentinel();
 334   for (uint i = 0; i &lt; max; ++i) {
 335     Node *n = at(i);
 336     if(n != NULL &amp;&amp; n != sentinel_node &amp;&amp; n-&gt;is_Type() &amp;&amp; n-&gt;outcnt() &gt; 0) {
 337       TypeNode* tn = n-&gt;as_Type();
 338       const Type* t = tn-&gt;type();
 339       const Type* t_no_spec = t-&gt;remove_speculative();
 340       assert(t == t_no_spec, &quot;dead node in hash table or missed node during speculative cleanup&quot;);
 341     }
 342   }
 343 #endif
 344 }
 345 
 346 #ifndef PRODUCT
 347 //------------------------------dump-------------------------------------------
 348 // Dump statistics for the hash table
 349 void NodeHash::dump() {
 350   _total_inserts       += _inserts;
 351   _total_insert_probes += _insert_probes;
 352   if (PrintCompilation &amp;&amp; PrintOptoStatistics &amp;&amp; Verbose &amp;&amp; (_inserts &gt; 0)) {
 353     if (WizardMode) {
 354       for (uint i=0; i&lt;_max; i++) {
 355         if (_table[i])
 356           tty-&gt;print(&quot;%d/%d/%d &quot;,i,_table[i]-&gt;hash()&amp;(_max-1),_table[i]-&gt;_idx);
 357       }
 358     }
 359     tty-&gt;print(&quot;\nGVN Hash stats:  %d grows to %d max_size\n&quot;, _grows, _max);
 360     tty-&gt;print(&quot;  %d/%d (%8.1f%% full)\n&quot;, _inserts, _max, (double)_inserts/_max*100.0);
 361     tty-&gt;print(&quot;  %dp/(%dh+%dm) (%8.2f probes/lookup)\n&quot;, _look_probes, _lookup_hits, _lookup_misses, (double)_look_probes/(_lookup_hits+_lookup_misses));
 362     tty-&gt;print(&quot;  %dp/%di (%8.2f probes/insert)\n&quot;, _total_insert_probes, _total_inserts, (double)_total_insert_probes/_total_inserts);
 363     // sentinels increase lookup cost, but not insert cost
 364     assert((_lookup_misses+_lookup_hits)*4+100 &gt;= _look_probes, &quot;bad hash function&quot;);
 365     assert( _inserts+(_inserts&gt;&gt;3) &lt; _max, &quot;table too full&quot; );
 366     assert( _inserts*3+100 &gt;= _insert_probes, &quot;bad hash function&quot; );
 367   }
 368 }
 369 
 370 Node *NodeHash::find_index(uint idx) { // For debugging
 371   // Find an entry by its index value
 372   for( uint i = 0; i &lt; _max; i++ ) {
 373     Node *m = _table[i];
 374     if( !m || m == _sentinel ) continue;
 375     if( m-&gt;_idx == (uint)idx ) return m;
 376   }
 377   return NULL;
 378 }
 379 #endif
 380 
 381 #ifdef ASSERT
 382 NodeHash::~NodeHash() {
 383   // Unlock all nodes upon destruction of table.
 384   if (_table != (Node**)badAddress)  clear();
 385 }
 386 
 387 void NodeHash::operator=(const NodeHash&amp; nh) {
 388   // Unlock all nodes upon replacement of table.
 389   if (&amp;nh == this)  return;
 390   if (_table != (Node**)badAddress)  clear();
 391   memcpy((void*)this, (void*)&amp;nh, sizeof(*this));
 392   // Do not increment hash_lock counts again.
 393   // Instead, be sure we never again use the source table.
 394   ((NodeHash*)&amp;nh)-&gt;_table = (Node**)badAddress;
 395 }
 396 
 397 
 398 #endif
 399 
 400 
 401 //=============================================================================
 402 //------------------------------PhaseRemoveUseless-----------------------------
 403 // 1) Use a breadthfirst walk to collect useful nodes reachable from root.
 404 PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN *gvn, Unique_Node_List *worklist, PhaseNumber phase_num) : Phase(phase_num),
 405   _useful(Thread::current()-&gt;resource_area()) {
 406 
 407   // Implementation requires &#39;UseLoopSafepoints == true&#39; and an edge from root
 408   // to each SafePointNode at a backward branch.  Inserted in add_safepoint().
 409   if( !UseLoopSafepoints || !OptoRemoveUseless ) return;
 410 
 411   // Identify nodes that are reachable from below, useful.
 412   C-&gt;identify_useful_nodes(_useful);
 413   // Update dead node list
 414   C-&gt;update_dead_node_list(_useful);
 415 
 416   // Remove all useless nodes from PhaseValues&#39; recorded types
 417   // Must be done before disconnecting nodes to preserve hash-table-invariant
 418   gvn-&gt;remove_useless_nodes(_useful.member_set());
 419 
 420   // Remove all useless nodes from future worklist
 421   worklist-&gt;remove_useless_nodes(_useful.member_set());
 422 
 423   // Disconnect &#39;useless&#39; nodes that are adjacent to useful nodes
 424   C-&gt;remove_useless_nodes(_useful);
 425 }
 426 
 427 //=============================================================================
 428 //------------------------------PhaseRenumberLive------------------------------
 429 // First, remove useless nodes (equivalent to identifying live nodes).
 430 // Then, renumber live nodes.
 431 //
 432 // The set of live nodes is returned by PhaseRemoveUseless in the _useful structure.
 433 // If the number of live nodes is &#39;x&#39; (where &#39;x&#39; == _useful.size()), then the
 434 // PhaseRenumberLive updates the node ID of each node (the _idx field) with a unique
 435 // value in the range [0, x).
 436 //
 437 // At the end of the PhaseRenumberLive phase, the compiler&#39;s count of unique nodes is
 438 // updated to &#39;x&#39; and the list of dead nodes is reset (as there are no dead nodes).
 439 //
 440 // The PhaseRenumberLive phase updates two data structures with the new node IDs.
 441 // (1) The worklist is used by the PhaseIterGVN phase to identify nodes that must be
 442 // processed. A new worklist (with the updated node IDs) is returned in &#39;new_worklist&#39;.
 443 // (2) Type information (the field PhaseGVN::_types) maps type information to each
 444 // node ID. The mapping is updated to use the new node IDs as well. Updated type
 445 // information is returned in PhaseGVN::_types.
 446 //
 447 // The PhaseRenumberLive phase does not preserve the order of elements in the worklist.
 448 //
 449 // Other data structures used by the compiler are not updated. The hash table for value
 450 // numbering (the field PhaseGVN::_table) is not updated because computing the hash
 451 // values is not based on node IDs. The field PhaseGVN::_nodes is not updated either
 452 // because it is empty wherever PhaseRenumberLive is used.
 453 PhaseRenumberLive::PhaseRenumberLive(PhaseGVN* gvn,
 454                                      Unique_Node_List* worklist, Unique_Node_List* new_worklist,
 455                                      PhaseNumber phase_num) :
 456   PhaseRemoveUseless(gvn, worklist, Remove_Useless_And_Renumber_Live),
 457   _new_type_array(C-&gt;comp_arena()),
 458   _old2new_map(C-&gt;unique(), C-&gt;unique(), -1),
 459   _delayed(Thread::current()-&gt;resource_area()),
 460   _is_pass_finished(false),
 461   _live_node_count(C-&gt;live_nodes())
 462 {
 463   assert(RenumberLiveNodes, &quot;RenumberLiveNodes must be set to true for node renumbering to take place&quot;);
 464   assert(C-&gt;live_nodes() == _useful.size(), &quot;the number of live nodes must match the number of useful nodes&quot;);
 465   assert(gvn-&gt;nodes_size() == 0, &quot;GVN must not contain any nodes at this point&quot;);
 466   assert(_delayed.size() == 0, &quot;should be empty&quot;);
 467 
 468   uint worklist_size = worklist-&gt;size();
 469 
 470   // Iterate over the set of live nodes.
 471   for (uint current_idx = 0; current_idx &lt; _useful.size(); current_idx++) {
 472     Node* n = _useful.at(current_idx);
 473 
 474     bool in_worklist = false;
 475     if (worklist-&gt;member(n)) {
 476       in_worklist = true;
 477     }
 478 
 479     const Type* type = gvn-&gt;type_or_null(n);
 480     _new_type_array.map(current_idx, type);
 481 
 482     assert(_old2new_map.at(n-&gt;_idx) == -1, &quot;already seen&quot;);
 483     _old2new_map.at_put(n-&gt;_idx, current_idx);
 484 
 485     n-&gt;set_idx(current_idx); // Update node ID.
 486 
 487     if (in_worklist) {
 488       new_worklist-&gt;push(n);
 489     }
 490 
 491     if (update_embedded_ids(n) &lt; 0) {
 492       _delayed.push(n); // has embedded IDs; handle later
 493     }
 494   }
 495 
 496   assert(worklist_size == new_worklist-&gt;size(), &quot;the new worklist must have the same size as the original worklist&quot;);
 497   assert(_live_node_count == _useful.size(), &quot;all live nodes must be processed&quot;);
 498 
 499   _is_pass_finished = true; // pass finished; safe to process delayed updates
 500 
 501   while (_delayed.size() &gt; 0) {
 502     Node* n = _delayed.pop();
 503     int no_of_updates = update_embedded_ids(n);
 504     assert(no_of_updates &gt; 0, &quot;should be updated&quot;);
 505   }
 506 
 507   // Replace the compiler&#39;s type information with the updated type information.
 508   gvn-&gt;replace_types(_new_type_array);
 509 
 510   // Update the unique node count of the compilation to the number of currently live nodes.
 511   C-&gt;set_unique(_live_node_count);
 512 
 513   // Set the dead node count to 0 and reset dead node list.
 514   C-&gt;reset_dead_node_list();
 515 }
 516 
 517 int PhaseRenumberLive::new_index(int old_idx) {
 518   assert(_is_pass_finished, &quot;not finished&quot;);
 519   if (_old2new_map.at(old_idx) == -1) { // absent
 520     // Allocate a placeholder to preserve uniqueness
 521     _old2new_map.at_put(old_idx, _live_node_count);
 522     _live_node_count++;
 523   }
 524   return _old2new_map.at(old_idx);
 525 }
 526 
 527 int PhaseRenumberLive::update_embedded_ids(Node* n) {
 528   int no_of_updates = 0;
 529   if (n-&gt;is_Phi()) {
 530     PhiNode* phi = n-&gt;as_Phi();
 531     if (phi-&gt;_inst_id != -1) {
 532       if (!_is_pass_finished) {
 533         return -1; // delay
 534       }
 535       int new_idx = new_index(phi-&gt;_inst_id);
 536       assert(new_idx != -1, &quot;&quot;);
 537       phi-&gt;_inst_id = new_idx;
 538       no_of_updates++;
 539     }
 540     if (phi-&gt;_inst_mem_id != -1) {
 541       if (!_is_pass_finished) {
 542         return -1; // delay
 543       }
 544       int new_idx = new_index(phi-&gt;_inst_mem_id);
 545       assert(new_idx != -1, &quot;&quot;);
 546       phi-&gt;_inst_mem_id = new_idx;
 547       no_of_updates++;
 548     }
 549   }
 550 
 551   const Type* type = _new_type_array.fast_lookup(n-&gt;_idx);
 552   if (type != NULL &amp;&amp; type-&gt;isa_oopptr() &amp;&amp; type-&gt;is_oopptr()-&gt;is_known_instance()) {
 553     if (!_is_pass_finished) {
 554         return -1; // delay
 555     }
 556     int old_idx = type-&gt;is_oopptr()-&gt;instance_id();
 557     int new_idx = new_index(old_idx);
 558     const Type* new_type = type-&gt;is_oopptr()-&gt;with_instance_id(new_idx);
 559     _new_type_array.map(n-&gt;_idx, new_type);
 560     no_of_updates++;
 561   }
 562 
 563   return no_of_updates;
 564 }
 565 
 566 //=============================================================================
 567 //------------------------------PhaseTransform---------------------------------
 568 PhaseTransform::PhaseTransform( PhaseNumber pnum ) : Phase(pnum),
 569   _arena(Thread::current()-&gt;resource_area()),
 570   _nodes(_arena),
 571   _types(_arena)
 572 {
 573   init_con_caches();
 574 #ifndef PRODUCT
 575   clear_progress();
 576   clear_transforms();
 577   set_allow_progress(true);
 578 #endif
 579   // Force allocation for currently existing nodes
 580   _types.map(C-&gt;unique(), NULL);
 581 }
 582 
 583 //------------------------------PhaseTransform---------------------------------
 584 PhaseTransform::PhaseTransform( Arena *arena, PhaseNumber pnum ) : Phase(pnum),
 585   _arena(arena),
 586   _nodes(arena),
 587   _types(arena)
 588 {
 589   init_con_caches();
 590 #ifndef PRODUCT
 591   clear_progress();
 592   clear_transforms();
 593   set_allow_progress(true);
 594 #endif
 595   // Force allocation for currently existing nodes
 596   _types.map(C-&gt;unique(), NULL);
 597 }
 598 
 599 //------------------------------PhaseTransform---------------------------------
 600 // Initialize with previously generated type information
 601 PhaseTransform::PhaseTransform( PhaseTransform *pt, PhaseNumber pnum ) : Phase(pnum),
 602   _arena(pt-&gt;_arena),
 603   _nodes(pt-&gt;_nodes),
 604   _types(pt-&gt;_types)
 605 {
 606   init_con_caches();
 607 #ifndef PRODUCT
 608   clear_progress();
 609   clear_transforms();
 610   set_allow_progress(true);
 611 #endif
 612 }
 613 
 614 void PhaseTransform::init_con_caches() {
 615   memset(_icons,0,sizeof(_icons));
 616   memset(_lcons,0,sizeof(_lcons));
 617   memset(_zcons,0,sizeof(_zcons));
 618 }
 619 
 620 
 621 //--------------------------------find_int_type--------------------------------
 622 const TypeInt* PhaseTransform::find_int_type(Node* n) {
 623   if (n == NULL)  return NULL;
 624   // Call type_or_null(n) to determine node&#39;s type since we might be in
 625   // parse phase and call n-&gt;Value() may return wrong type.
 626   // (For example, a phi node at the beginning of loop parsing is not ready.)
 627   const Type* t = type_or_null(n);
 628   if (t == NULL)  return NULL;
 629   return t-&gt;isa_int();
 630 }
 631 
 632 
 633 //-------------------------------find_long_type--------------------------------
 634 const TypeLong* PhaseTransform::find_long_type(Node* n) {
 635   if (n == NULL)  return NULL;
 636   // (See comment above on type_or_null.)
 637   const Type* t = type_or_null(n);
 638   if (t == NULL)  return NULL;
 639   return t-&gt;isa_long();
 640 }
 641 
 642 
 643 #ifndef PRODUCT
 644 void PhaseTransform::dump_old2new_map() const {
 645   _nodes.dump();
 646 }
 647 
 648 void PhaseTransform::dump_new( uint nidx ) const {
 649   for( uint i=0; i&lt;_nodes.Size(); i++ )
 650     if( _nodes[i] &amp;&amp; _nodes[i]-&gt;_idx == nidx ) {
 651       _nodes[i]-&gt;dump();
 652       tty-&gt;cr();
 653       tty-&gt;print_cr(&quot;Old index= %d&quot;,i);
 654       return;
 655     }
 656   tty-&gt;print_cr(&quot;Node %d not found in the new indices&quot;, nidx);
 657 }
 658 
 659 //------------------------------dump_types-------------------------------------
 660 void PhaseTransform::dump_types( ) const {
 661   _types.dump();
 662 }
 663 
 664 //------------------------------dump_nodes_and_types---------------------------
 665 void PhaseTransform::dump_nodes_and_types(const Node *root, uint depth, bool only_ctrl) {
 666   VectorSet visited(Thread::current()-&gt;resource_area());
 667   dump_nodes_and_types_recur( root, depth, only_ctrl, visited );
 668 }
 669 
 670 //------------------------------dump_nodes_and_types_recur---------------------
 671 void PhaseTransform::dump_nodes_and_types_recur( const Node *n, uint depth, bool only_ctrl, VectorSet &amp;visited) {
 672   if( !n ) return;
 673   if( depth == 0 ) return;
 674   if( visited.test_set(n-&gt;_idx) ) return;
 675   for( uint i=0; i&lt;n-&gt;len(); i++ ) {
 676     if( only_ctrl &amp;&amp; !(n-&gt;is_Region()) &amp;&amp; i != TypeFunc::Control ) continue;
 677     dump_nodes_and_types_recur( n-&gt;in(i), depth-1, only_ctrl, visited );
 678   }
 679   n-&gt;dump();
 680   if (type_or_null(n) != NULL) {
 681     tty-&gt;print(&quot;      &quot;); type(n)-&gt;dump(); tty-&gt;cr();
 682   }
 683 }
 684 
 685 #endif
 686 
 687 
 688 //=============================================================================
 689 //------------------------------PhaseValues------------------------------------
 690 // Set minimum table size to &quot;255&quot;
 691 PhaseValues::PhaseValues( Arena *arena, uint est_max_size ) : PhaseTransform(arena, GVN), _table(arena, est_max_size) {
 692   NOT_PRODUCT( clear_new_values(); )
 693 }
 694 
 695 //------------------------------PhaseValues------------------------------------
 696 // Set minimum table size to &quot;255&quot;
 697 PhaseValues::PhaseValues( PhaseValues *ptv ) : PhaseTransform( ptv, GVN ),
 698   _table(&amp;ptv-&gt;_table) {
 699   NOT_PRODUCT( clear_new_values(); )
 700 }
 701 
 702 //------------------------------~PhaseValues-----------------------------------
 703 #ifndef PRODUCT
 704 PhaseValues::~PhaseValues() {
 705   _table.dump();
 706 
 707   // Statistics for value progress and efficiency
 708   if( PrintCompilation &amp;&amp; Verbose &amp;&amp; WizardMode ) {
 709     tty-&gt;print(&quot;\n%sValues: %d nodes ---&gt; %d/%d (%d)&quot;,
 710       is_IterGVN() ? &quot;Iter&quot; : &quot;    &quot;, C-&gt;unique(), made_progress(), made_transforms(), made_new_values());
 711     if( made_transforms() != 0 ) {
 712       tty-&gt;print_cr(&quot;  ratio %f&quot;, made_progress()/(float)made_transforms() );
 713     } else {
 714       tty-&gt;cr();
 715     }
 716   }
 717 }
 718 #endif
 719 
 720 //------------------------------makecon----------------------------------------
 721 ConNode* PhaseTransform::makecon(const Type *t) {
 722   assert(t-&gt;singleton(), &quot;must be a constant&quot;);
 723   assert(!t-&gt;empty() || t == Type::TOP, &quot;must not be vacuous range&quot;);
 724   switch (t-&gt;base()) {  // fast paths
 725   case Type::Half:
 726   case Type::Top:  return (ConNode*) C-&gt;top();
 727   case Type::Int:  return intcon( t-&gt;is_int()-&gt;get_con() );
 728   case Type::Long: return longcon( t-&gt;is_long()-&gt;get_con() );
 729   default:         break;
 730   }
 731   if (t-&gt;is_zero_type())
 732     return zerocon(t-&gt;basic_type());
 733   return uncached_makecon(t);
 734 }
 735 
 736 //--------------------------uncached_makecon-----------------------------------
 737 // Make an idealized constant - one of ConINode, ConPNode, etc.
 738 ConNode* PhaseValues::uncached_makecon(const Type *t) {
 739   assert(t-&gt;singleton(), &quot;must be a constant&quot;);
 740   ConNode* x = ConNode::make(t);
 741   ConNode* k = (ConNode*)hash_find_insert(x); // Value numbering
 742   if (k == NULL) {
 743     set_type(x, t);             // Missed, provide type mapping
 744     GrowableArray&lt;Node_Notes*&gt;* nna = C-&gt;node_note_array();
 745     if (nna != NULL) {
 746       Node_Notes* loc = C-&gt;locate_node_notes(nna, x-&gt;_idx, true);
 747       loc-&gt;clear(); // do not put debug info on constants
 748     }
 749   } else {
 750     x-&gt;destruct();              // Hit, destroy duplicate constant
 751     x = k;                      // use existing constant
 752   }
 753   return x;
 754 }
 755 
 756 //------------------------------intcon-----------------------------------------
 757 // Fast integer constant.  Same as &quot;transform(new ConINode(TypeInt::make(i)))&quot;
 758 ConINode* PhaseTransform::intcon(jint i) {
 759   // Small integer?  Check cache! Check that cached node is not dead
 760   if (i &gt;= _icon_min &amp;&amp; i &lt;= _icon_max) {
 761     ConINode* icon = _icons[i-_icon_min];
 762     if (icon != NULL &amp;&amp; icon-&gt;in(TypeFunc::Control) != NULL)
 763       return icon;
 764   }
 765   ConINode* icon = (ConINode*) uncached_makecon(TypeInt::make(i));
 766   assert(icon-&gt;is_Con(), &quot;&quot;);
 767   if (i &gt;= _icon_min &amp;&amp; i &lt;= _icon_max)
 768     _icons[i-_icon_min] = icon;   // Cache small integers
 769   return icon;
 770 }
 771 
 772 //------------------------------longcon----------------------------------------
 773 // Fast long constant.
 774 ConLNode* PhaseTransform::longcon(jlong l) {
 775   // Small integer?  Check cache! Check that cached node is not dead
 776   if (l &gt;= _lcon_min &amp;&amp; l &lt;= _lcon_max) {
 777     ConLNode* lcon = _lcons[l-_lcon_min];
 778     if (lcon != NULL &amp;&amp; lcon-&gt;in(TypeFunc::Control) != NULL)
 779       return lcon;
 780   }
 781   ConLNode* lcon = (ConLNode*) uncached_makecon(TypeLong::make(l));
 782   assert(lcon-&gt;is_Con(), &quot;&quot;);
 783   if (l &gt;= _lcon_min &amp;&amp; l &lt;= _lcon_max)
 784     _lcons[l-_lcon_min] = lcon;      // Cache small integers
 785   return lcon;
 786 }
 787 
 788 //------------------------------zerocon-----------------------------------------
 789 // Fast zero or null constant. Same as &quot;transform(ConNode::make(Type::get_zero_type(bt)))&quot;
 790 ConNode* PhaseTransform::zerocon(BasicType bt) {
 791   assert((uint)bt &lt;= _zcon_max, &quot;domain check&quot;);
 792   ConNode* zcon = _zcons[bt];
 793   if (zcon != NULL &amp;&amp; zcon-&gt;in(TypeFunc::Control) != NULL)
 794     return zcon;
 795   zcon = (ConNode*) uncached_makecon(Type::get_zero_type(bt));
 796   _zcons[bt] = zcon;
 797   return zcon;
 798 }
 799 
 800 
 801 
 802 //=============================================================================
 803 Node* PhaseGVN::apply_ideal(Node* k, bool can_reshape) {
 804   Node* i = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;ideal_node(this, k, can_reshape);
 805   if (i == NULL) {
 806     i = k-&gt;Ideal(this, can_reshape);
 807   }
 808   return i;
 809 }
 810 
 811 //------------------------------transform--------------------------------------
 812 // Return a node which computes the same function as this node, but in a
 813 // faster or cheaper fashion.
 814 Node *PhaseGVN::transform( Node *n ) {
 815   return transform_no_reclaim(n);
 816 }
 817 
 818 //------------------------------transform--------------------------------------
 819 // Return a node which computes the same function as this node, but
 820 // in a faster or cheaper fashion.
 821 Node *PhaseGVN::transform_no_reclaim( Node *n ) {
 822   NOT_PRODUCT( set_transforms(); )
 823 
 824   // Apply the Ideal call in a loop until it no longer applies
 825   Node *k = n;
 826   NOT_PRODUCT( uint loop_count = 0; )
 827   while( 1 ) {
 828     Node *i = apply_ideal(k, /*can_reshape=*/false);
 829     if( !i ) break;
 830     assert( i-&gt;_idx &gt;= k-&gt;_idx, &quot;Idealize should return new nodes, use Identity to return old nodes&quot; );
 831     k = i;
 832     assert(loop_count++ &lt; K, &quot;infinite loop in PhaseGVN::transform&quot;);
 833   }
 834   NOT_PRODUCT( if( loop_count != 0 ) { set_progress(); } )
 835 
 836 
 837   // If brand new node, make space in type array.
 838   ensure_type_or_null(k);
 839 
 840   // Since I just called &#39;Value&#39; to compute the set of run-time values
 841   // for this Node, and &#39;Value&#39; is non-local (and therefore expensive) I&#39;ll
 842   // cache Value.  Later requests for the local phase-&gt;type of this Node can
 843   // use the cached Value instead of suffering with &#39;bottom_type&#39;.
 844   const Type *t = k-&gt;Value(this); // Get runtime Value set
 845   assert(t != NULL, &quot;value sanity&quot;);
 846   if (type_or_null(k) != t) {
 847 #ifndef PRODUCT
 848     // Do not count initial visit to node as a transformation
 849     if (type_or_null(k) == NULL) {
 850       inc_new_values();
 851       set_progress();
 852     }
 853 #endif
 854     set_type(k, t);
 855     // If k is a TypeNode, capture any more-precise type permanently into Node
 856     k-&gt;raise_bottom_type(t);
 857   }
 858 
 859   if( t-&gt;singleton() &amp;&amp; !k-&gt;is_Con() ) {
 860     NOT_PRODUCT( set_progress(); )
 861     return makecon(t);          // Turn into a constant
 862   }
 863 
 864   // Now check for Identities
 865   Node *i = k-&gt;Identity(this);  // Look for a nearby replacement
 866   if( i != k ) {                // Found? Return replacement!
 867     NOT_PRODUCT( set_progress(); )
 868     return i;
 869   }
 870 
 871   // Global Value Numbering
 872   i = hash_find_insert(k);      // Insert if new
 873   if( i &amp;&amp; (i != k) ) {
 874     // Return the pre-existing node
 875     NOT_PRODUCT( set_progress(); )
 876     return i;
 877   }
 878 
 879   // Return Idealized original
 880   return k;
 881 }
 882 
 883 bool PhaseGVN::is_dominator_helper(Node *d, Node *n, bool linear_only) {
 884   if (d-&gt;is_top() || (d-&gt;is_Proj() &amp;&amp; d-&gt;in(0)-&gt;is_top())) {
 885     return false;
 886   }
 887   if (n-&gt;is_top() || (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
 888     return false;
 889   }
 890   assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
 891   int i = 0;
 892   while (d != n) {
 893     n = IfNode::up_one_dom(n, linear_only);
 894     i++;
 895     if (n == NULL || i &gt;= 100) {
 896       return false;
 897     }
 898   }
 899   return true;
 900 }
 901 
 902 #ifdef ASSERT
 903 //------------------------------dead_loop_check--------------------------------
 904 // Check for a simple dead loop when a data node references itself directly
 905 // or through an other data node excluding cons and phis.
 906 void PhaseGVN::dead_loop_check( Node *n ) {
 907   // Phi may reference itself in a loop
 908   if (n != NULL &amp;&amp; !n-&gt;is_dead_loop_safe() &amp;&amp; !n-&gt;is_CFG()) {
 909     // Do 2 levels check and only data inputs.
 910     bool no_dead_loop = true;
 911     uint cnt = n-&gt;req();
 912     for (uint i = 1; i &lt; cnt &amp;&amp; no_dead_loop; i++) {
 913       Node *in = n-&gt;in(i);
 914       if (in == n) {
 915         no_dead_loop = false;
 916       } else if (in != NULL &amp;&amp; !in-&gt;is_dead_loop_safe()) {
 917         uint icnt = in-&gt;req();
 918         for (uint j = 1; j &lt; icnt &amp;&amp; no_dead_loop; j++) {
 919           if (in-&gt;in(j) == n || in-&gt;in(j) == in)
 920             no_dead_loop = false;
 921         }
 922       }
 923     }
 924     if (!no_dead_loop) n-&gt;dump(3);
 925     assert(no_dead_loop, &quot;dead loop detected&quot;);
 926   }
 927 }
 928 #endif
 929 
 930 //=============================================================================
 931 //------------------------------PhaseIterGVN-----------------------------------
 932 // Initialize with previous PhaseIterGVN info; used by PhaseCCP
 933 PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn ) : PhaseGVN(igvn),
 934                                                    _delay_transform(igvn-&gt;_delay_transform),
 935                                                    _stack( igvn-&gt;_stack ),
 936                                                    _worklist( igvn-&gt;_worklist )
 937 {
 938 }
 939 
 940 //------------------------------PhaseIterGVN-----------------------------------
 941 // Initialize with previous PhaseGVN info from Parser
 942 PhaseIterGVN::PhaseIterGVN( PhaseGVN *gvn ) : PhaseGVN(gvn),
 943                                               _delay_transform(false),
 944 // TODO: Before incremental inlining it was allocated only once and it was fine. Now that
 945 //       the constructor is used in incremental inlining, this consumes too much memory:
 946 //                                            _stack(C-&gt;live_nodes() &gt;&gt; 1),
 947 //       So, as a band-aid, we replace this by:
 948                                               _stack(C-&gt;comp_arena(), 32),
 949                                               _worklist(*C-&gt;for_igvn())
 950 {
 951   uint max;
 952 
 953   // Dead nodes in the hash table inherited from GVN were not treated as
 954   // roots during def-use info creation; hence they represent an invisible
 955   // use.  Clear them out.
 956   max = _table.size();
 957   for( uint i = 0; i &lt; max; ++i ) {
 958     Node *n = _table.at(i);
 959     if(n != NULL &amp;&amp; n != _table.sentinel() &amp;&amp; n-&gt;outcnt() == 0) {
 960       if( n-&gt;is_top() ) continue;
 961       assert( false, &quot;Parse::remove_useless_nodes missed this node&quot;);
 962       hash_delete(n);
 963     }
 964   }
 965 
 966   // Any Phis or Regions on the worklist probably had uses that could not
 967   // make more progress because the uses were made while the Phis and Regions
 968   // were in half-built states.  Put all uses of Phis and Regions on worklist.
 969   max = _worklist.size();
 970   for( uint j = 0; j &lt; max; j++ ) {
 971     Node *n = _worklist.at(j);
 972     uint uop = n-&gt;Opcode();
 973     if( uop == Op_Phi || uop == Op_Region ||
 974         n-&gt;is_Type() ||
 975         n-&gt;is_Mem() )
 976       add_users_to_worklist(n);
 977   }
 978 }
 979 
 980 /**
 981  * Initialize worklist for each node.
 982  */
 983 void PhaseIterGVN::init_worklist(Node* first) {
 984   Unique_Node_List to_process;
 985   to_process.push(first);
 986 
 987   while (to_process.size() &gt; 0) {
 988     Node* n = to_process.pop();
 989     if (!_worklist.member(n)) {
 990       _worklist.push(n);
 991 
 992       uint cnt = n-&gt;req();
 993       for(uint i = 0; i &lt; cnt; i++) {
 994         Node* m = n-&gt;in(i);
 995         if (m != NULL) {
 996           to_process.push(m);
 997         }
 998       }
 999     }
1000   }
1001 }
1002 
1003 #ifndef PRODUCT
1004 void PhaseIterGVN::verify_step(Node* n) {
1005   if (VerifyIterativeGVN) {
1006     _verify_window[_verify_counter % _verify_window_size] = n;
1007     ++_verify_counter;
1008     if (C-&gt;unique() &lt; 1000 || 0 == _verify_counter % (C-&gt;unique() &lt; 10000 ? 10 : 100)) {
1009       ++_verify_full_passes;
1010       Node::verify(C-&gt;root(), -1);
1011     }
1012     for (int i = 0; i &lt; _verify_window_size; i++) {
1013       Node* n = _verify_window[i];
1014       if (n == NULL) {
1015         continue;
1016       }
1017       if (n-&gt;in(0) == NodeSentinel) { // xform_idom
1018         _verify_window[i] = n-&gt;in(1);
1019         --i;
1020         continue;
1021       }
1022       // Typical fanout is 1-2, so this call visits about 6 nodes.
1023       Node::verify(n, 4);
1024     }
1025   }
1026 }
1027 
1028 void PhaseIterGVN::trace_PhaseIterGVN(Node* n, Node* nn, const Type* oldtype) {
1029   if (TraceIterativeGVN) {
1030     uint wlsize = _worklist.size();
1031     const Type* newtype = type_or_null(n);
1032     if (nn != n) {
1033       // print old node
1034       tty-&gt;print(&quot;&lt; &quot;);
1035       if (oldtype != newtype &amp;&amp; oldtype != NULL) {
1036         oldtype-&gt;dump();
1037       }
1038       do { tty-&gt;print(&quot;\t&quot;); } while (tty-&gt;position() &lt; 16);
1039       tty-&gt;print(&quot;&lt;&quot;);
1040       n-&gt;dump();
1041     }
1042     if (oldtype != newtype || nn != n) {
1043       // print new node and/or new type
1044       if (oldtype == NULL) {
1045         tty-&gt;print(&quot;* &quot;);
1046       } else if (nn != n) {
1047         tty-&gt;print(&quot;&gt; &quot;);
1048       } else {
1049         tty-&gt;print(&quot;= &quot;);
1050       }
1051       if (newtype == NULL) {
1052         tty-&gt;print(&quot;null&quot;);
1053       } else {
1054         newtype-&gt;dump();
1055       }
1056       do { tty-&gt;print(&quot;\t&quot;); } while (tty-&gt;position() &lt; 16);
1057       nn-&gt;dump();
1058     }
1059     if (Verbose &amp;&amp; wlsize &lt; _worklist.size()) {
1060       tty-&gt;print(&quot;  Push {&quot;);
1061       while (wlsize != _worklist.size()) {
1062         Node* pushed = _worklist.at(wlsize++);
1063         tty-&gt;print(&quot; %d&quot;, pushed-&gt;_idx);
1064       }
1065       tty-&gt;print_cr(&quot; }&quot;);
1066     }
1067     if (nn != n) {
1068       // ignore n, it might be subsumed
1069       verify_step((Node*) NULL);
1070     }
1071   }
1072 }
1073 
1074 void PhaseIterGVN::init_verifyPhaseIterGVN() {
1075   _verify_counter = 0;
1076   _verify_full_passes = 0;
1077   for (int i = 0; i &lt; _verify_window_size; i++) {
1078     _verify_window[i] = NULL;
1079   }
1080 #ifdef ASSERT
1081   // Verify that all modified nodes are on _worklist
1082   Unique_Node_List* modified_list = C-&gt;modified_nodes();
1083   while (modified_list != NULL &amp;&amp; modified_list-&gt;size()) {
1084     Node* n = modified_list-&gt;pop();
1085     if (n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con() &amp;&amp; !_worklist.member(n)) {
1086       n-&gt;dump();
1087       assert(false, &quot;modified node is not on IGVN._worklist&quot;);
1088     }
1089   }
1090 #endif
1091 }
1092 
1093 void PhaseIterGVN::verify_PhaseIterGVN() {
1094 #ifdef ASSERT
1095   // Verify nodes with changed inputs.
1096   Unique_Node_List* modified_list = C-&gt;modified_nodes();
1097   while (modified_list != NULL &amp;&amp; modified_list-&gt;size()) {
1098     Node* n = modified_list-&gt;pop();
1099     if (n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con()) { // skip dead and Con nodes
1100       n-&gt;dump();
1101       assert(false, &quot;modified node was not processed by IGVN.transform_old()&quot;);
1102     }
1103   }
1104 #endif
1105 
1106   C-&gt;verify_graph_edges();
1107   if (VerifyIterativeGVN &amp;&amp; PrintOpto) {
1108     if (_verify_counter == _verify_full_passes) {
1109       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms and verify passes&quot;,
1110                     (int) _verify_full_passes);
1111     } else {
1112       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms, %d full verify passes&quot;,
1113                   (int) _verify_counter, (int) _verify_full_passes);
1114     }
1115   }
1116 
1117 #ifdef ASSERT
1118   while (modified_list-&gt;size()) {
1119     Node* n = modified_list-&gt;pop();
1120     n-&gt;dump();
1121     assert(false, &quot;VerifyIterativeGVN: new modified node was added&quot;);
1122   }
1123 #endif
1124 }
1125 #endif /* PRODUCT */
1126 
1127 #ifdef ASSERT
1128 /**
1129  * Dumps information that can help to debug the problem. A debug
1130  * build fails with an assert.
1131  */
1132 void PhaseIterGVN::dump_infinite_loop_info(Node* n) {
1133   n-&gt;dump(4);
1134   _worklist.dump();
1135   assert(false, &quot;infinite loop in PhaseIterGVN::optimize&quot;);
1136 }
1137 
1138 /**
1139  * Prints out information about IGVN if the &#39;verbose&#39; option is used.
1140  */
1141 void PhaseIterGVN::trace_PhaseIterGVN_verbose(Node* n, int num_processed) {
1142   if (TraceIterativeGVN &amp;&amp; Verbose) {
1143     tty-&gt;print(&quot;  Pop &quot;);
1144     n-&gt;dump();
1145     if ((num_processed % 100) == 0) {
1146       _worklist.print_set();
1147     }
1148   }
1149 }
1150 #endif /* ASSERT */
1151 
1152 void PhaseIterGVN::optimize() {
1153   DEBUG_ONLY(uint num_processed  = 0;)
1154   NOT_PRODUCT(init_verifyPhaseIterGVN();)
1155 
1156   uint loop_count = 0;
1157   // Pull from worklist and transform the node. If the node has changed,
1158   // update edge info and put uses on worklist.
1159   while(_worklist.size()) {
1160     if (C-&gt;check_node_count(NodeLimitFudgeFactor * 2, &quot;Out of nodes&quot;)) {
1161       return;
1162     }
1163     Node* n  = _worklist.pop();
1164     if (++loop_count &gt;= K * C-&gt;live_nodes()) {
1165       DEBUG_ONLY(dump_infinite_loop_info(n);)
1166       C-&gt;record_method_not_compilable(&quot;infinite loop in PhaseIterGVN::optimize&quot;);
1167       return;
1168     }
1169     DEBUG_ONLY(trace_PhaseIterGVN_verbose(n, num_processed++);)
1170     if (n-&gt;outcnt() != 0) {
1171       NOT_PRODUCT(const Type* oldtype = type_or_null(n));
1172       // Do the transformation
1173       Node* nn = transform_old(n);
1174       NOT_PRODUCT(trace_PhaseIterGVN(n, nn, oldtype);)
1175     } else if (!n-&gt;is_top()) {
1176       remove_dead_node(n);
1177     }
1178   }
1179   NOT_PRODUCT(verify_PhaseIterGVN();)
1180 }
1181 
1182 
1183 /**
1184  * Register a new node with the optimizer.  Update the types array, the def-use
1185  * info.  Put on worklist.
1186  */
1187 Node* PhaseIterGVN::register_new_node_with_optimizer(Node* n, Node* orig) {
1188   set_type_bottom(n);
1189   _worklist.push(n);
1190   if (orig != NULL)  C-&gt;copy_node_notes_to(n, orig);
1191   return n;
1192 }
1193 
1194 //------------------------------transform--------------------------------------
1195 // Non-recursive: idealize Node &#39;n&#39; with respect to its inputs and its value
1196 Node *PhaseIterGVN::transform( Node *n ) {
1197   // If brand new node, make space in type array, and give it a type.
1198   ensure_type_or_null(n);
1199   if (type_or_null(n) == NULL) {
1200     set_type_bottom(n);
1201   }
1202 
1203   if (_delay_transform) {
1204     // Add the node to the worklist but don&#39;t optimize for now
1205     _worklist.push(n);
1206     return n;
1207   }
1208 
1209   return transform_old(n);
1210 }
1211 
1212 Node *PhaseIterGVN::transform_old(Node* n) {
1213   DEBUG_ONLY(uint loop_count = 0;);
1214   NOT_PRODUCT(set_transforms());
1215 
1216   // Remove &#39;n&#39; from hash table in case it gets modified
1217   _table.hash_delete(n);
1218   if (VerifyIterativeGVN) {
1219    assert(!_table.find_index(n-&gt;_idx), &quot;found duplicate entry in table&quot;);
1220   }
1221 
1222   // Apply the Ideal call in a loop until it no longer applies
1223   Node* k = n;
1224   DEBUG_ONLY(dead_loop_check(k);)
1225   DEBUG_ONLY(bool is_new = (k-&gt;outcnt() == 0);)
1226   C-&gt;remove_modified_node(k);
1227   Node* i = apply_ideal(k, /*can_reshape=*/true);
1228   assert(i != k || is_new || i-&gt;outcnt() &gt; 0, &quot;don&#39;t return dead nodes&quot;);
1229 #ifndef PRODUCT
1230   verify_step(k);
1231 #endif
1232 
1233   while (i != NULL) {
1234 #ifdef ASSERT
1235     if (loop_count &gt;= K) {
1236       dump_infinite_loop_info(i);
1237     }
1238     loop_count++;
1239 #endif
1240     assert((i-&gt;_idx &gt;= k-&gt;_idx) || i-&gt;is_top(), &quot;Idealize should return new nodes, use Identity to return old nodes&quot;);
1241     // Made a change; put users of original Node on worklist
1242     add_users_to_worklist(k);
1243     // Replacing root of transform tree?
1244     if (k != i) {
1245       // Make users of old Node now use new.
1246       subsume_node(k, i);
1247       k = i;
1248     }
1249     DEBUG_ONLY(dead_loop_check(k);)
1250     // Try idealizing again
1251     DEBUG_ONLY(is_new = (k-&gt;outcnt() == 0);)
1252     C-&gt;remove_modified_node(k);
1253     i = apply_ideal(k, /*can_reshape=*/true);
1254     assert(i != k || is_new || (i-&gt;outcnt() &gt; 0), &quot;don&#39;t return dead nodes&quot;);
1255 #ifndef PRODUCT
1256     verify_step(k);
1257 #endif
1258   }
1259 
1260   // If brand new node, make space in type array.
1261   ensure_type_or_null(k);
1262 
1263   // See what kind of values &#39;k&#39; takes on at runtime
1264   const Type* t = k-&gt;Value(this);
1265   assert(t != NULL, &quot;value sanity&quot;);
1266 
1267   // Since I just called &#39;Value&#39; to compute the set of run-time values
1268   // for this Node, and &#39;Value&#39; is non-local (and therefore expensive) I&#39;ll
1269   // cache Value.  Later requests for the local phase-&gt;type of this Node can
1270   // use the cached Value instead of suffering with &#39;bottom_type&#39;.
1271   if (type_or_null(k) != t) {
1272 #ifndef PRODUCT
1273     inc_new_values();
1274     set_progress();
1275 #endif
1276     set_type(k, t);
1277     // If k is a TypeNode, capture any more-precise type permanently into Node
1278     k-&gt;raise_bottom_type(t);
1279     // Move users of node to worklist
1280     add_users_to_worklist(k);
1281   }
1282   // If &#39;k&#39; computes a constant, replace it with a constant
1283   if (t-&gt;singleton() &amp;&amp; !k-&gt;is_Con()) {
1284     NOT_PRODUCT(set_progress();)
1285     Node* con = makecon(t);     // Make a constant
1286     add_users_to_worklist(k);
1287     subsume_node(k, con);       // Everybody using k now uses con
1288     return con;
1289   }
1290 
1291   // Now check for Identities
1292   i = k-&gt;Identity(this);      // Look for a nearby replacement
1293   if (i != k) {                // Found? Return replacement!
1294     NOT_PRODUCT(set_progress();)
1295     add_users_to_worklist(k);
1296     subsume_node(k, i);       // Everybody using k now uses i
1297     return i;
1298   }
1299 
1300   // Global Value Numbering
1301   i = hash_find_insert(k);      // Check for pre-existing node
1302   if (i &amp;&amp; (i != k)) {
1303     // Return the pre-existing node if it isn&#39;t dead
1304     NOT_PRODUCT(set_progress();)
1305     add_users_to_worklist(k);
1306     subsume_node(k, i);       // Everybody using k now uses i
1307     return i;
1308   }
1309 
1310   // Return Idealized original
1311   return k;
1312 }
1313 
1314 //---------------------------------saturate------------------------------------
1315 const Type* PhaseIterGVN::saturate(const Type* new_type, const Type* old_type,
1316                                    const Type* limit_type) const {
1317   return new_type-&gt;narrow(old_type);
1318 }
1319 
1320 //------------------------------remove_globally_dead_node----------------------
1321 // Kill a globally dead Node.  All uses are also globally dead and are
1322 // aggressively trimmed.
1323 void PhaseIterGVN::remove_globally_dead_node( Node *dead ) {
1324   enum DeleteProgress {
1325     PROCESS_INPUTS,
1326     PROCESS_OUTPUTS
1327   };
1328   assert(_stack.is_empty(), &quot;not empty&quot;);
1329   _stack.push(dead, PROCESS_INPUTS);
1330 
1331   while (_stack.is_nonempty()) {
1332     dead = _stack.node();
1333     if (dead-&gt;Opcode() == Op_SafePoint) {
1334       dead-&gt;as_SafePoint()-&gt;disconnect_from_root(this);
1335     }
1336     uint progress_state = _stack.index();
1337     assert(dead != C-&gt;root(), &quot;killing root, eh?&quot;);
1338     assert(!dead-&gt;is_top(), &quot;add check for top when pushing&quot;);
1339     NOT_PRODUCT( set_progress(); )
1340     if (progress_state == PROCESS_INPUTS) {
1341       // After following inputs, continue to outputs
1342       _stack.set_index(PROCESS_OUTPUTS);
1343       if (!dead-&gt;is_Con()) { // Don&#39;t kill cons but uses
1344         bool recurse = false;
1345         // Remove from hash table
1346         _table.hash_delete( dead );
1347         // Smash all inputs to &#39;dead&#39;, isolating him completely
1348         for (uint i = 0; i &lt; dead-&gt;req(); i++) {
1349           Node *in = dead-&gt;in(i);
1350           if (in != NULL &amp;&amp; in != C-&gt;top()) {  // Points to something?
1351             int nrep = dead-&gt;replace_edge(in, NULL);  // Kill edges
1352             assert((nrep &gt; 0), &quot;sanity&quot;);
1353             if (in-&gt;outcnt() == 0) { // Made input go dead?
1354               _stack.push(in, PROCESS_INPUTS); // Recursively remove
1355               recurse = true;
1356             } else if (in-&gt;outcnt() == 1 &amp;&amp;
1357                        in-&gt;has_special_unique_user()) {
1358               _worklist.push(in-&gt;unique_out());
1359             } else if (in-&gt;outcnt() &lt;= 2 &amp;&amp; dead-&gt;is_Phi()) {
1360               if (in-&gt;Opcode() == Op_Region) {
1361                 _worklist.push(in);
1362               } else if (in-&gt;is_Store()) {
1363                 DUIterator_Fast imax, i = in-&gt;fast_outs(imax);
1364                 _worklist.push(in-&gt;fast_out(i));
1365                 i++;
1366                 if (in-&gt;outcnt() == 2) {
1367                   _worklist.push(in-&gt;fast_out(i));
1368                   i++;
1369                 }
1370                 assert(!(i &lt; imax), &quot;sanity&quot;);
1371               }
1372             } else {
1373               BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;enqueue_useful_gc_barrier(this, in);
1374             }
1375             if (ReduceFieldZeroing &amp;&amp; dead-&gt;is_Load() &amp;&amp; i == MemNode::Memory &amp;&amp;
1376                 in-&gt;is_Proj() &amp;&amp; in-&gt;in(0) != NULL &amp;&amp; in-&gt;in(0)-&gt;is_Initialize()) {
1377               // A Load that directly follows an InitializeNode is
1378               // going away. The Stores that follow are candidates
1379               // again to be captured by the InitializeNode.
1380               for (DUIterator_Fast jmax, j = in-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1381                 Node *n = in-&gt;fast_out(j);
1382                 if (n-&gt;is_Store()) {
1383                   _worklist.push(n);
1384                 }
1385               }
1386             }
1387           } // if (in != NULL &amp;&amp; in != C-&gt;top())
1388         } // for (uint i = 0; i &lt; dead-&gt;req(); i++)
1389         if (recurse) {
1390           continue;
1391         }
1392       } // if (!dead-&gt;is_Con())
1393     } // if (progress_state == PROCESS_INPUTS)
1394 
1395     // Aggressively kill globally dead uses
1396     // (Rather than pushing all the outs at once, we push one at a time,
1397     // plus the parent to resume later, because of the indefinite number
1398     // of edge deletions per loop trip.)
1399     if (dead-&gt;outcnt() &gt; 0) {
1400       // Recursively remove output edges
1401       _stack.push(dead-&gt;raw_out(0), PROCESS_INPUTS);
1402     } else {
1403       // Finished disconnecting all input and output edges.
1404       _stack.pop();
1405       // Remove dead node from iterative worklist
1406       _worklist.remove(dead);
1407       C-&gt;remove_modified_node(dead);
1408       // Constant node that has no out-edges and has only one in-edge from
1409       // root is usually dead. However, sometimes reshaping walk makes
1410       // it reachable by adding use edges. So, we will NOT count Con nodes
1411       // as dead to be conservative about the dead node count at any
1412       // given time.
1413       if (!dead-&gt;is_Con()) {
1414         C-&gt;record_dead_node(dead-&gt;_idx);
1415       }
1416       if (dead-&gt;is_macro()) {
1417         C-&gt;remove_macro_node(dead);
1418       }
1419       if (dead-&gt;is_expensive()) {
1420         C-&gt;remove_expensive_node(dead);
1421       }
1422       CastIINode* cast = dead-&gt;isa_CastII();
1423       if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
1424         C-&gt;remove_range_check_cast(cast);
1425       }
1426       if (dead-&gt;Opcode() == Op_Opaque4) {
1427         C-&gt;remove_opaque4_node(dead);
1428       }
1429       if (dead-&gt;is_InlineTypeBase()) {
1430         C-&gt;remove_inline_type(dead);
1431       }
1432       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1433       bs-&gt;unregister_potential_barrier_node(dead);
1434     }
1435   } // while (_stack.is_nonempty())
1436 }
1437 
1438 //------------------------------subsume_node-----------------------------------
1439 // Remove users from node &#39;old&#39; and add them to node &#39;nn&#39;.
1440 void PhaseIterGVN::subsume_node( Node *old, Node *nn ) {
1441   if (old-&gt;Opcode() == Op_SafePoint) {
1442     old-&gt;as_SafePoint()-&gt;disconnect_from_root(this);
1443   }
1444   assert( old != hash_find(old), &quot;should already been removed&quot; );
1445   assert( old != C-&gt;top(), &quot;cannot subsume top node&quot;);
1446   // Copy debug or profile information to the new version:
1447   C-&gt;copy_node_notes_to(nn, old);
1448   // Move users of node &#39;old&#39; to node &#39;nn&#39;
1449   for (DUIterator_Last imin, i = old-&gt;last_outs(imin); i &gt;= imin; ) {
1450     Node* use = old-&gt;last_out(i);  // for each use...
1451     // use might need re-hashing (but it won&#39;t if it&#39;s a new node)
1452     rehash_node_delayed(use);
1453     // Update use-def info as well
1454     // We remove all occurrences of old within use-&gt;in,
1455     // so as to avoid rehashing any node more than once.
1456     // The hash table probe swamps any outer loop overhead.
1457     uint num_edges = 0;
1458     for (uint jmax = use-&gt;len(), j = 0; j &lt; jmax; j++) {
1459       if (use-&gt;in(j) == old) {
1460         use-&gt;set_req(j, nn);
1461         ++num_edges;
1462       }
1463     }
1464     i -= num_edges;    // we deleted 1 or more copies of this edge
1465   }
1466 
1467   // Search for instance field data PhiNodes in the same region pointing to the old
1468   // memory PhiNode and update their instance memory ids to point to the new node.
1469   if (old-&gt;is_Phi() &amp;&amp; old-&gt;as_Phi()-&gt;type()-&gt;has_memory() &amp;&amp; old-&gt;in(0) != NULL) {
1470     Node* region = old-&gt;in(0);
1471     for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
1472       PhiNode* phi = region-&gt;fast_out(i)-&gt;isa_Phi();
1473       if (phi != NULL &amp;&amp; phi-&gt;inst_mem_id() == (int)old-&gt;_idx) {
1474         phi-&gt;set_inst_mem_id((int)nn-&gt;_idx);
1475       }
1476     }
1477   }
1478 
1479   // Smash all inputs to &#39;old&#39;, isolating him completely
1480   Node *temp = new Node(1);
1481   temp-&gt;init_req(0,nn);     // Add a use to nn to prevent him from dying
1482   remove_dead_node( old );
1483   temp-&gt;del_req(0);         // Yank bogus edge
1484 #ifndef PRODUCT
1485   if( VerifyIterativeGVN ) {
1486     for ( int i = 0; i &lt; _verify_window_size; i++ ) {
1487       if ( _verify_window[i] == old )
1488         _verify_window[i] = nn;
1489     }
1490   }
1491 #endif
1492   _worklist.remove(temp);   // this can be necessary
1493   temp-&gt;destruct();         // reuse the _idx of this little guy
1494 }
1495 
1496 void PhaseIterGVN::replace_in_uses(Node* n, Node* m) {
1497   assert(n != NULL, &quot;sanity&quot;);
1498   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1499     Node* u = n-&gt;fast_out(i);
1500     if (u != n) {
1501       rehash_node_delayed(u);
1502       int nb = u-&gt;replace_edge(n, m);
1503       --i, imax -= nb;
1504     }
1505   }
1506   assert(n-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);
1507 }
1508 
1509 //------------------------------add_users_to_worklist--------------------------
1510 void PhaseIterGVN::add_users_to_worklist0( Node *n ) {
1511   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1512     _worklist.push(n-&gt;fast_out(i));  // Push on worklist
1513   }
1514 }
1515 
1516 // Return counted loop Phi if as a counted loop exit condition, cmp
1517 // compares the the induction variable with n
1518 static PhiNode* countedloop_phi_from_cmp(CmpINode* cmp, Node* n) {
1519   for (DUIterator_Fast imax, i = cmp-&gt;fast_outs(imax); i &lt; imax; i++) {
1520     Node* bol = cmp-&gt;fast_out(i);
1521     for (DUIterator_Fast i2max, i2 = bol-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1522       Node* iff = bol-&gt;fast_out(i2);
1523       if (iff-&gt;is_CountedLoopEnd()) {
1524         CountedLoopEndNode* cle = iff-&gt;as_CountedLoopEnd();
1525         if (cle-&gt;limit() == n) {
1526           PhiNode* phi = cle-&gt;phi();
1527           if (phi != NULL) {
1528             return phi;
1529           }
1530         }
1531       }
1532     }
1533   }
1534   return NULL;
1535 }
1536 
1537 void PhaseIterGVN::add_users_to_worklist( Node *n ) {
1538   add_users_to_worklist0(n);
1539 
1540   // Move users of node to worklist
1541   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1542     Node* use = n-&gt;fast_out(i); // Get use
1543 
1544     if( use-&gt;is_Multi() ||      // Multi-definer?  Push projs on worklist
1545         use-&gt;is_Store() )       // Enable store/load same address
1546       add_users_to_worklist0(use);
1547 
1548     // If we changed the receiver type to a call, we need to revisit
1549     // the Catch following the call.  It&#39;s looking for a non-NULL
1550     // receiver to know when to enable the regular fall-through path
1551     // in addition to the NullPtrException path.
1552     if (use-&gt;is_CallDynamicJava() &amp;&amp; n == use-&gt;in(TypeFunc::Parms)) {
1553       Node* p = use-&gt;as_CallDynamicJava()-&gt;proj_out_or_null(TypeFunc::Control);
1554       if (p != NULL) {
1555         add_users_to_worklist0(p);
1556       }
1557     }
1558 
1559     uint use_op = use-&gt;Opcode();
1560     if(use-&gt;is_Cmp()) {       // Enable CMP/BOOL optimization
1561       add_users_to_worklist(use); // Put Bool on worklist
1562       if (use-&gt;outcnt() &gt; 0) {
1563         Node* bol = use-&gt;raw_out(0);
1564         if (bol-&gt;outcnt() &gt; 0) {
1565           Node* iff = bol-&gt;raw_out(0);
1566           if (iff-&gt;outcnt() == 2) {
1567             // Look for the &#39;is_x2logic&#39; pattern: &quot;x ? : 0 : 1&quot; and put the
1568             // phi merging either 0 or 1 onto the worklist
1569             Node* ifproj0 = iff-&gt;raw_out(0);
1570             Node* ifproj1 = iff-&gt;raw_out(1);
1571             if (ifproj0-&gt;outcnt() &gt; 0 &amp;&amp; ifproj1-&gt;outcnt() &gt; 0) {
1572               Node* region0 = ifproj0-&gt;raw_out(0);
1573               Node* region1 = ifproj1-&gt;raw_out(0);
1574               if( region0 == region1 )
1575                 add_users_to_worklist0(region0);
1576             }
1577           }
1578         }
1579       }
1580       if (use_op == Op_CmpI) {
1581         Node* phi = countedloop_phi_from_cmp((CmpINode*)use, n);
1582         if (phi != NULL) {
1583           // If an opaque node feeds into the limit condition of a
1584           // CountedLoop, we need to process the Phi node for the
1585           // induction variable when the opaque node is removed:
1586           // the range of values taken by the Phi is now known and
1587           // so its type is also known.
1588           _worklist.push(phi);
1589         }
1590         Node* in1 = use-&gt;in(1);
1591         for (uint i = 0; i &lt; in1-&gt;outcnt(); i++) {
1592           if (in1-&gt;raw_out(i)-&gt;Opcode() == Op_CastII) {
1593             Node* castii = in1-&gt;raw_out(i);
1594             if (castii-&gt;in(0) != NULL &amp;&amp; castii-&gt;in(0)-&gt;in(0) != NULL &amp;&amp; castii-&gt;in(0)-&gt;in(0)-&gt;is_If()) {
1595               Node* ifnode = castii-&gt;in(0)-&gt;in(0);
1596               if (ifnode-&gt;in(1) != NULL &amp;&amp; ifnode-&gt;in(1)-&gt;is_Bool() &amp;&amp; ifnode-&gt;in(1)-&gt;in(1) == use) {
1597                 // Reprocess a CastII node that may depend on an
1598                 // opaque node value when the opaque node is
1599                 // removed. In case it carries a dependency we can do
1600                 // a better job of computing its type.
1601                 _worklist.push(castii);
1602               }
1603             }
1604           }
1605         }
1606       }
1607     }
1608 
1609     // Inline type nodes can have other inline types as users. If an input gets
1610     // updated, make sure that inline type users get a chance for optimization.
1611     if (use-&gt;is_InlineTypeBase()) {
1612       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1613         Node* u = use-&gt;fast_out(i2);
1614         if (u-&gt;is_InlineTypeBase())
1615           _worklist.push(u);
1616       }
1617     }
1618     // If changed Cast input, check Phi users for simple cycles
1619     if (use-&gt;is_ConstraintCast()) {
1620       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1621         Node* u = use-&gt;fast_out(i2);
1622         if (u-&gt;is_Phi())
1623           _worklist.push(u);
1624       }
1625     }
1626     // If changed LShift inputs, check RShift users for useless sign-ext
1627     if( use_op == Op_LShiftI ) {
1628       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1629         Node* u = use-&gt;fast_out(i2);
1630         if (u-&gt;Opcode() == Op_RShiftI)
1631           _worklist.push(u);
1632       }
1633     }
1634     // If changed AddI/SubI inputs, check CmpU for range check optimization.
1635     if (use_op == Op_AddI || use_op == Op_SubI) {
1636       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1637         Node* u = use-&gt;fast_out(i2);
1638         if (u-&gt;is_Cmp() &amp;&amp; (u-&gt;Opcode() == Op_CmpU)) {
1639           _worklist.push(u);
1640         }
1641       }
1642     }
1643     // If changed AddP inputs, check Stores for loop invariant
1644     if( use_op == Op_AddP ) {
1645       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1646         Node* u = use-&gt;fast_out(i2);
1647         if (u-&gt;is_Mem())
1648           _worklist.push(u);
1649       }
1650     }
1651     // If changed initialization activity, check dependent Stores
1652     if (use_op == Op_Allocate || use_op == Op_AllocateArray) {
1653       InitializeNode* init = use-&gt;as_Allocate()-&gt;initialization();
1654       if (init != NULL) {
1655         Node* imem = init-&gt;proj_out_or_null(TypeFunc::Memory);
1656         if (imem != NULL)  add_users_to_worklist0(imem);
1657       }
1658     }
1659     if (use_op == Op_Initialize) {
1660       Node* imem = use-&gt;as_Initialize()-&gt;proj_out_or_null(TypeFunc::Memory);
1661       if (imem != NULL)  add_users_to_worklist0(imem);
1662     }
1663     if (use_op == Op_CastP2X) {
1664       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1665         Node* u = use-&gt;fast_out(i2);
1666         if (u-&gt;Opcode() == Op_AndX) {
1667           _worklist.push(u);
1668         }
1669       }
1670     }
1671     // Loading the java mirror from a Klass requires two loads and the type
1672     // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1673     //   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))
1674     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1675     bool has_load_barrier_nodes = bs-&gt;has_load_barrier_nodes();
1676 
1677     if (use_op == Op_LoadP &amp;&amp; use-&gt;bottom_type()-&gt;isa_rawptr()) {
1678       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1679         Node* u = use-&gt;fast_out(i2);
1680         const Type* ut = u-&gt;bottom_type();
1681         if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr()) {
1682           if (has_load_barrier_nodes) {
1683             // Search for load barriers behind the load
1684             for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1685               Node* b = u-&gt;fast_out(i3);
1686               if (bs-&gt;is_gc_barrier_node(b)) {
1687                 _worklist.push(b);
1688               }
1689             }
1690           }
1691           _worklist.push(u);
1692         }
1693       }
1694     }
1695 
1696     // Give CallStaticJavaNode::remove_useless_allocation a chance to run
1697     if (use-&gt;is_Region()) {
1698       Node* c = use;
1699       do {
1700         c = c-&gt;unique_ctrl_out();
1701       } while (c != NULL &amp;&amp; c-&gt;is_Region());
1702       if (c != NULL &amp;&amp; c-&gt;is_CallStaticJava() &amp;&amp; c-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) {
1703         _worklist.push(c);
1704       }
1705     }
1706   }
1707 }
1708 
1709 /**
1710  * Remove the speculative part of all types that we know of
1711  */
1712 void PhaseIterGVN::remove_speculative_types()  {
1713   assert(UseTypeSpeculation, &quot;speculation is off&quot;);
1714   for (uint i = 0; i &lt; _types.Size(); i++)  {
1715     const Type* t = _types.fast_lookup(i);
1716     if (t != NULL) {
1717       _types.map(i, t-&gt;remove_speculative());
1718     }
1719   }
1720   _table.check_no_speculative_types();
1721 }
1722 
1723 //=============================================================================
1724 #ifndef PRODUCT
1725 uint PhaseCCP::_total_invokes   = 0;
1726 uint PhaseCCP::_total_constants = 0;
1727 #endif
1728 //------------------------------PhaseCCP---------------------------------------
1729 // Conditional Constant Propagation, ala Wegman &amp; Zadeck
1730 PhaseCCP::PhaseCCP( PhaseIterGVN *igvn ) : PhaseIterGVN(igvn) {
1731   NOT_PRODUCT( clear_constants(); )
1732   assert( _worklist.size() == 0, &quot;&quot; );
1733   // Clear out _nodes from IterGVN.  Must be clear to transform call.
1734   _nodes.clear();               // Clear out from IterGVN
1735   analyze();
1736 }
1737 
1738 #ifndef PRODUCT
1739 //------------------------------~PhaseCCP--------------------------------------
1740 PhaseCCP::~PhaseCCP() {
1741   inc_invokes();
1742   _total_constants += count_constants();
1743 }
1744 #endif
1745 
1746 
1747 #ifdef ASSERT
1748 static bool ccp_type_widens(const Type* t, const Type* t0) {
1749   assert(t-&gt;meet(t0) == t, &quot;Not monotonic&quot;);
1750   switch (t-&gt;base() == t0-&gt;base() ? t-&gt;base() : Type::Top) {
1751   case Type::Int:
1752     assert(t0-&gt;isa_int()-&gt;_widen &lt;= t-&gt;isa_int()-&gt;_widen, &quot;widen increases&quot;);
1753     break;
1754   case Type::Long:
1755     assert(t0-&gt;isa_long()-&gt;_widen &lt;= t-&gt;isa_long()-&gt;_widen, &quot;widen increases&quot;);
1756     break;
1757   default:
1758     break;
1759   }
1760   return true;
1761 }
1762 #endif //ASSERT
1763 
1764 //------------------------------analyze----------------------------------------
1765 void PhaseCCP::analyze() {
1766   // Initialize all types to TOP, optimistic analysis
1767   for (int i = C-&gt;unique() - 1; i &gt;= 0; i--)  {
1768     _types.map(i,Type::TOP);
1769   }
1770 
1771   // Push root onto worklist
1772   Unique_Node_List worklist;
1773   worklist.push(C-&gt;root());
1774 
1775   // Pull from worklist; compute new value; push changes out.
1776   // This loop is the meat of CCP.
1777   while( worklist.size() ) {
1778     Node *n = worklist.pop();
1779     const Type *t = n-&gt;Value(this);
1780     if (t != type(n)) {
1781       assert(ccp_type_widens(t, type(n)), &quot;ccp type must widen&quot;);
1782 #ifndef PRODUCT
1783       if( TracePhaseCCP ) {
1784         t-&gt;dump();
1785         do { tty-&gt;print(&quot;\t&quot;); } while (tty-&gt;position() &lt; 16);
1786         n-&gt;dump();
1787       }
1788 #endif
1789       set_type(n, t);
1790       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1791         Node* m = n-&gt;fast_out(i);   // Get user
1792         if (m-&gt;is_Region()) {  // New path to Region?  Must recheck Phis too
1793           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1794             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1795             if (p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1796               worklist.push(p); // Propagate change to user
1797             }
1798           }
1799         }
1800         // If we changed the receiver type to a call, we need to revisit
1801         // the Catch following the call.  It&#39;s looking for a non-NULL
1802         // receiver to know when to enable the regular fall-through path
1803         // in addition to the NullPtrException path
1804         if (m-&gt;is_Call()) {
1805           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1806             Node* p = m-&gt;fast_out(i2);  // Propagate changes to uses
1807             if (p-&gt;is_Proj() &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Control) {
1808               Node* catch_node = p-&gt;find_out_with(Op_Catch);
1809               if (catch_node != NULL) {
1810                 worklist.push(catch_node);
1811               }
1812             }
1813           }
1814         }
1815         if (m-&gt;bottom_type() != type(m)) { // If not already bottomed out
1816           worklist.push(m);     // Propagate change to user
1817         }
1818 
1819         // CmpU nodes can get their type information from two nodes up in the
1820         // graph (instead of from the nodes immediately above). Make sure they
1821         // are added to the worklist if nodes they depend on are updated, since
1822         // they could be missed and get wrong types otherwise.
1823         uint m_op = m-&gt;Opcode();
1824         if (m_op == Op_AddI || m_op == Op_SubI) {
1825           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1826             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1827             if (p-&gt;Opcode() == Op_CmpU) {
1828               // Got a CmpU which might need the new type information from node n.
1829               if(p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1830                 worklist.push(p); // Propagate change to user
1831               }
1832             }
1833           }
1834         }
1835         // If n is used in a counted loop exit condition then the type
1836         // of the counted loop&#39;s Phi depends on the type of n. See
1837         // PhiNode::Value().
1838         if (m_op == Op_CmpI) {
1839           PhiNode* phi = countedloop_phi_from_cmp((CmpINode*)m, n);
1840           if (phi != NULL) {
1841             worklist.push(phi);
1842           }
1843         }
1844         if (m_op == Op_CastP2X) {
1845           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1846             Node* u = m-&gt;fast_out(i2);
1847             if (u-&gt;Opcode() == Op_AndX) {
1848               worklist.push(u);
1849             }
1850           }
1851         }
1852         // Loading the java mirror from a Klass requires two loads and the type
1853         // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1854         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1855         bool has_load_barrier_nodes = bs-&gt;has_load_barrier_nodes();
1856 
1857         if (m_op == Op_LoadP &amp;&amp; m-&gt;bottom_type()-&gt;isa_rawptr()) {
1858           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1859             Node* u = m-&gt;fast_out(i2);
1860             const Type* ut = u-&gt;bottom_type();
1861             if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr() &amp;&amp; ut != type(u)) {
1862               if (has_load_barrier_nodes) {
1863                 // Search for load barriers behind the load
1864                 for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1865                   Node* b = u-&gt;fast_out(i3);
1866                   if (bs-&gt;is_gc_barrier_node(b)) {
1867                     worklist.push(b);
1868                   }
1869                 }
1870               }
1871               worklist.push(u);
1872             }
1873           }
1874         }
1875       }
1876     }
1877   }
1878 }
1879 
1880 //------------------------------do_transform-----------------------------------
1881 // Top level driver for the recursive transformer
1882 void PhaseCCP::do_transform() {
1883   // Correct leaves of new-space Nodes; they point to old-space.
1884   C-&gt;set_root( transform(C-&gt;root())-&gt;as_Root() );
1885   assert( C-&gt;top(),  &quot;missing TOP node&quot; );
1886   assert( C-&gt;root(), &quot;missing root&quot; );
1887 }
1888 
1889 //------------------------------transform--------------------------------------
1890 // Given a Node in old-space, clone him into new-space.
1891 // Convert any of his old-space children into new-space children.
1892 Node *PhaseCCP::transform( Node *n ) {
1893   Node *new_node = _nodes[n-&gt;_idx]; // Check for transformed node
1894   if( new_node != NULL )
1895     return new_node;                // Been there, done that, return old answer
1896   new_node = transform_once(n);     // Check for constant
1897   _nodes.map( n-&gt;_idx, new_node );  // Flag as having been cloned
1898 
1899   // Allocate stack of size _nodes.Size()/2 to avoid frequent realloc
1900   GrowableArray &lt;Node *&gt; trstack(C-&gt;live_nodes() &gt;&gt; 1);
1901 
1902   trstack.push(new_node);           // Process children of cloned node
1903   while ( trstack.is_nonempty() ) {
1904     Node *clone = trstack.pop();
1905     uint cnt = clone-&gt;req();
1906     for( uint i = 0; i &lt; cnt; i++ ) {          // For all inputs do
1907       Node *input = clone-&gt;in(i);
1908       if( input != NULL ) {                    // Ignore NULLs
1909         Node *new_input = _nodes[input-&gt;_idx]; // Check for cloned input node
1910         if( new_input == NULL ) {
1911           new_input = transform_once(input);   // Check for constant
1912           _nodes.map( input-&gt;_idx, new_input );// Flag as having been cloned
1913           trstack.push(new_input);
1914         }
1915         assert( new_input == clone-&gt;in(i), &quot;insanity check&quot;);
1916       }
1917     }
1918   }
1919   return new_node;
1920 }
1921 
1922 
1923 //------------------------------transform_once---------------------------------
1924 // For PhaseCCP, transformation is IDENTITY unless Node computed a constant.
1925 Node *PhaseCCP::transform_once( Node *n ) {
1926   const Type *t = type(n);
1927   // Constant?  Use constant Node instead
1928   if( t-&gt;singleton() ) {
1929     Node *nn = n;               // Default is to return the original constant
1930     if( t == Type::TOP ) {
1931       // cache my top node on the Compile instance
1932       if( C-&gt;cached_top_node() == NULL || C-&gt;cached_top_node()-&gt;in(0) == NULL ) {
1933         C-&gt;set_cached_top_node(ConNode::make(Type::TOP));
1934         set_type(C-&gt;top(), Type::TOP);
1935       }
1936       nn = C-&gt;top();
1937     }
1938     if( !n-&gt;is_Con() ) {
1939       if( t != Type::TOP ) {
1940         nn = makecon(t);        // ConNode::make(t);
1941         NOT_PRODUCT( inc_constants(); )
1942       } else if( n-&gt;is_Region() ) { // Unreachable region
1943         // Note: nn == C-&gt;top()
1944         n-&gt;set_req(0, NULL);        // Cut selfreference
1945         bool progress = true;
1946         uint max = n-&gt;outcnt();
1947         DUIterator i;
1948         while (progress) {
1949           progress = false;
1950           // Eagerly remove dead phis to avoid phis copies creation.
1951           for (i = n-&gt;outs(); n-&gt;has_out(i); i++) {
1952             Node* m = n-&gt;out(i);
1953             if (m-&gt;is_Phi()) {
1954               assert(type(m) == Type::TOP, &quot;Unreachable region should not have live phis.&quot;);
1955               replace_node(m, nn);
1956               if (max != n-&gt;outcnt()) {
1957                 progress = true;
1958                 i = n-&gt;refresh_out_pos(i);
1959                 max = n-&gt;outcnt();
1960               }
1961             }
1962           }
1963         }
1964       }
1965       replace_node(n,nn);       // Update DefUse edges for new constant
1966     }
1967     return nn;
1968   }
1969 
1970   // If x is a TypeNode, capture any more-precise type permanently into Node
1971   if (t != n-&gt;bottom_type()) {
1972     hash_delete(n);             // changing bottom type may force a rehash
1973     n-&gt;raise_bottom_type(t);
1974     _worklist.push(n);          // n re-enters the hash table via the worklist
1975   }
1976 
1977   // TEMPORARY fix to ensure that 2nd GVN pass eliminates NULL checks
1978   switch( n-&gt;Opcode() ) {
1979   case Op_FastLock:      // Revisit FastLocks for lock coarsening
1980   case Op_If:
1981   case Op_CountedLoopEnd:
1982   case Op_Region:
1983   case Op_Loop:
1984   case Op_CountedLoop:
1985   case Op_Conv2B:
1986   case Op_Opaque1:
1987   case Op_Opaque2:
1988     _worklist.push(n);
1989     break;
1990   default:
1991     break;
1992   }
1993 
1994   return  n;
1995 }
1996 
1997 //---------------------------------saturate------------------------------------
1998 const Type* PhaseCCP::saturate(const Type* new_type, const Type* old_type,
1999                                const Type* limit_type) const {
2000   const Type* wide_type = new_type-&gt;widen(old_type, limit_type);
2001   if (wide_type != new_type) {          // did we widen?
2002     // If so, we may have widened beyond the limit type.  Clip it back down.
2003     new_type = wide_type-&gt;filter(limit_type);
2004   }
2005   return new_type;
2006 }
2007 
2008 //------------------------------print_statistics-------------------------------
2009 #ifndef PRODUCT
2010 void PhaseCCP::print_statistics() {
2011   tty-&gt;print_cr(&quot;CCP: %d  constants found: %d&quot;, _total_invokes, _total_constants);
2012 }
2013 #endif
2014 
2015 
2016 //=============================================================================
2017 #ifndef PRODUCT
2018 uint PhasePeephole::_total_peepholes = 0;
2019 #endif
2020 //------------------------------PhasePeephole----------------------------------
2021 // Conditional Constant Propagation, ala Wegman &amp; Zadeck
2022 PhasePeephole::PhasePeephole( PhaseRegAlloc *regalloc, PhaseCFG &amp;cfg )
2023   : PhaseTransform(Peephole), _regalloc(regalloc), _cfg(cfg) {
2024   NOT_PRODUCT( clear_peepholes(); )
2025 }
2026 
2027 #ifndef PRODUCT
2028 //------------------------------~PhasePeephole---------------------------------
2029 PhasePeephole::~PhasePeephole() {
2030   _total_peepholes += count_peepholes();
2031 }
2032 #endif
2033 
2034 //------------------------------transform--------------------------------------
2035 Node *PhasePeephole::transform( Node *n ) {
2036   ShouldNotCallThis();
2037   return NULL;
2038 }
2039 
2040 //------------------------------do_transform-----------------------------------
2041 void PhasePeephole::do_transform() {
2042   bool method_name_not_printed = true;
2043 
2044   // Examine each basic block
2045   for (uint block_number = 1; block_number &lt; _cfg.number_of_blocks(); ++block_number) {
2046     Block* block = _cfg.get_block(block_number);
2047     bool block_not_printed = true;
2048 
2049     // and each instruction within a block
2050     uint end_index = block-&gt;number_of_nodes();
2051     // block-&gt;end_idx() not valid after PhaseRegAlloc
2052     for( uint instruction_index = 1; instruction_index &lt; end_index; ++instruction_index ) {
2053       Node     *n = block-&gt;get_node(instruction_index);
2054       if( n-&gt;is_Mach() ) {
2055         MachNode *m = n-&gt;as_Mach();
2056         int deleted_count = 0;
2057         // check for peephole opportunities
2058         MachNode *m2 = m-&gt;peephole(block, instruction_index, _regalloc, deleted_count);
2059         if( m2 != NULL ) {
2060 #ifndef PRODUCT
2061           if( PrintOptoPeephole ) {
2062             // Print method, first time only
2063             if( C-&gt;method() &amp;&amp; method_name_not_printed ) {
2064               C-&gt;method()-&gt;print_short_name(); tty-&gt;cr();
2065               method_name_not_printed = false;
2066             }
2067             // Print this block
2068             if( Verbose &amp;&amp; block_not_printed) {
2069               tty-&gt;print_cr(&quot;in block&quot;);
2070               block-&gt;dump();
2071               block_not_printed = false;
2072             }
2073             // Print instructions being deleted
2074             for( int i = (deleted_count - 1); i &gt;= 0; --i ) {
2075               block-&gt;get_node(instruction_index-i)-&gt;as_Mach()-&gt;format(_regalloc); tty-&gt;cr();
2076             }
2077             tty-&gt;print_cr(&quot;replaced with&quot;);
2078             // Print new instruction
2079             m2-&gt;format(_regalloc);
2080             tty-&gt;print(&quot;\n\n&quot;);
2081           }
2082 #endif
2083           // Remove old nodes from basic block and update instruction_index
2084           // (old nodes still exist and may have edges pointing to them
2085           //  as register allocation info is stored in the allocator using
2086           //  the node index to live range mappings.)
2087           uint safe_instruction_index = (instruction_index - deleted_count);
2088           for( ; (instruction_index &gt; safe_instruction_index); --instruction_index ) {
2089             block-&gt;remove_node( instruction_index );
2090           }
2091           // install new node after safe_instruction_index
2092           block-&gt;insert_node(m2, safe_instruction_index + 1);
2093           end_index = block-&gt;number_of_nodes() - 1; // Recompute new block size
2094           NOT_PRODUCT( inc_peepholes(); )
2095         }
2096       }
2097     }
2098   }
2099 }
2100 
2101 //------------------------------print_statistics-------------------------------
2102 #ifndef PRODUCT
2103 void PhasePeephole::print_statistics() {
2104   tty-&gt;print_cr(&quot;Peephole: peephole rules applied: %d&quot;,  _total_peepholes);
2105 }
2106 #endif
2107 
2108 
2109 //=============================================================================
2110 //------------------------------set_req_X--------------------------------------
2111 void Node::set_req_X( uint i, Node *n, PhaseIterGVN *igvn ) {
2112   assert( is_not_dead(n), &quot;can not use dead node&quot;);
2113   assert( igvn-&gt;hash_find(this) != this, &quot;Need to remove from hash before changing edges&quot; );
2114   Node *old = in(i);
2115   set_req(i, n);
2116 
2117   // old goes dead?
2118   if( old ) {
2119     switch (old-&gt;outcnt()) {
2120     case 0:
2121       // Put into the worklist to kill later. We do not kill it now because the
2122       // recursive kill will delete the current node (this) if dead-loop exists
2123       if (!old-&gt;is_top())
2124         igvn-&gt;_worklist.push( old );
2125       break;
2126     case 1:
2127       if( old-&gt;is_Store() || old-&gt;has_special_unique_user() )
2128         igvn-&gt;add_users_to_worklist( old );
2129       break;
2130     case 2:
2131       if( old-&gt;is_Store() )
2132         igvn-&gt;add_users_to_worklist( old );
2133       if( old-&gt;Opcode() == Op_Region )
2134         igvn-&gt;_worklist.push(old);
2135       break;
2136     case 3:
2137       if( old-&gt;Opcode() == Op_Region ) {
2138         igvn-&gt;_worklist.push(old);
2139         igvn-&gt;add_users_to_worklist( old );
2140       }
2141       break;
2142     default:
2143       break;
2144     }
2145 
2146     BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;enqueue_useful_gc_barrier(igvn, old);
2147   }
2148 
2149 }
2150 
2151 //-------------------------------replace_by-----------------------------------
2152 // Using def-use info, replace one node for another.  Follow the def-use info
2153 // to all users of the OLD node.  Then make all uses point to the NEW node.
2154 void Node::replace_by(Node *new_node) {
2155   assert(!is_top(), &quot;top node has no DU info&quot;);
2156   for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; ) {
2157     Node* use = last_out(i);
2158     uint uses_found = 0;
2159     for (uint j = 0; j &lt; use-&gt;len(); j++) {
2160       if (use-&gt;in(j) == this) {
2161         if (j &lt; use-&gt;req())
2162               use-&gt;set_req(j, new_node);
2163         else  use-&gt;set_prec(j, new_node);
2164         uses_found++;
2165       }
2166     }
2167     i -= uses_found;    // we deleted 1 or more copies of this edge
2168   }
2169 }
2170 
2171 //=============================================================================
2172 //-----------------------------------------------------------------------------
2173 void Type_Array::grow( uint i ) {
2174   if( !_max ) {
2175     _max = 1;
2176     _types = (const Type**)_a-&gt;Amalloc( _max * sizeof(Type*) );
2177     _types[0] = NULL;
2178   }
2179   uint old = _max;
2180   _max = next_power_of_2(i);
2181   _types = (const Type**)_a-&gt;Arealloc( _types, old*sizeof(Type*),_max*sizeof(Type*));
2182   memset( &amp;_types[old], 0, (_max-old)*sizeof(Type*) );
2183 }
2184 
2185 //------------------------------dump-------------------------------------------
2186 #ifndef PRODUCT
2187 void Type_Array::dump() const {
2188   uint max = Size();
2189   for( uint i = 0; i &lt; max; i++ ) {
2190     if( _types[i] != NULL ) {
2191       tty-&gt;print(&quot;  %d\t== &quot;, i); _types[i]-&gt;dump(); tty-&gt;cr();
2192     }
2193   }
2194 }
2195 #endif
    </pre>
  </body>
</html>