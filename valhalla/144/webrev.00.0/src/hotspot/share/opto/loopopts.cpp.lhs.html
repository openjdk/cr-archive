<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/loopopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/divnode.hpp&quot;
  36 #include &quot;opto/inlinetypenode.hpp&quot;
  37 #include &quot;opto/loopnode.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/mulnode.hpp&quot;
  40 #include &quot;opto/movenode.hpp&quot;
  41 #include &quot;opto/opaquenode.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
  43 #include &quot;opto/subnode.hpp&quot;
  44 #include &quot;opto/subtypenode.hpp&quot;
  45 #include &quot;utilities/macros.hpp&quot;
  46 
  47 //=============================================================================
  48 //------------------------------split_thru_phi---------------------------------
  49 // Split Node &#39;n&#39; through merge point if there is enough win.
  50 Node *PhaseIdealLoop::split_thru_phi( Node *n, Node *region, int policy ) {
  51   if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; n-&gt;bottom_type() != TypeLong::LONG) {
  52     // ConvI2L may have type information on it which is unsafe to push up
  53     // so disable this for now
  54     return NULL;
  55   }
  56 
  57   // Splitting range check CastIIs through a loop induction Phi can
  58   // cause new Phis to be created that are left unrelated to the loop
  59   // induction Phi and prevent optimizations (vectorization)
  60   if (n-&gt;Opcode() == Op_CastII &amp;&amp; n-&gt;as_CastII()-&gt;has_range_check() &amp;&amp;
  61       region-&gt;is_CountedLoop() &amp;&amp; n-&gt;in(1) == region-&gt;as_CountedLoop()-&gt;phi()) {
  62     return NULL;
  63   }
  64 
  65   // Inline types should not be split through Phis because they cannot be merged
  66   // through Phi nodes but each value input needs to be merged individually.
  67   if (n-&gt;is_InlineType()) {
  68     return NULL;
  69   }
  70 
  71   int wins = 0;
  72   assert(!n-&gt;is_CFG(), &quot;&quot;);
  73   assert(region-&gt;is_Region(), &quot;&quot;);
  74 
  75   const Type* type = n-&gt;bottom_type();
  76   const TypeOopPtr *t_oop = _igvn.type(n)-&gt;isa_oopptr();
  77   Node *phi;
  78   if (t_oop != NULL &amp;&amp; t_oop-&gt;is_known_instance_field()) {
  79     int iid    = t_oop-&gt;instance_id();
  80     int index  = C-&gt;get_alias_index(t_oop);
  81     int offset = t_oop-&gt;offset();
  82     phi = new PhiNode(region, type, NULL, iid, index, offset);
  83   } else {
  84     phi = PhiNode::make_blank(region, n);
  85   }
  86   uint old_unique = C-&gt;unique();
  87   for (uint i = 1; i &lt; region-&gt;req(); i++) {
  88     Node *x;
  89     Node* the_clone = NULL;
  90     if (region-&gt;in(i) == C-&gt;top()) {
  91       x = C-&gt;top();             // Dead path?  Use a dead data op
  92     } else {
  93       x = n-&gt;clone();           // Else clone up the data op
  94       the_clone = x;            // Remember for possible deletion.
  95       // Alter data node to use pre-phi inputs
  96       if (n-&gt;in(0) == region)
  97         x-&gt;set_req( 0, region-&gt;in(i) );
  98       for (uint j = 1; j &lt; n-&gt;req(); j++) {
  99         Node *in = n-&gt;in(j);
 100         if (in-&gt;is_Phi() &amp;&amp; in-&gt;in(0) == region)
 101           x-&gt;set_req( j, in-&gt;in(i) ); // Use pre-Phi input for the clone
 102       }
 103     }
 104     // Check for a &#39;win&#39; on some paths
 105     const Type *t = x-&gt;Value(&amp;_igvn);
 106 
 107     bool singleton = t-&gt;singleton();
 108 
 109     // A TOP singleton indicates that there are no possible values incoming
 110     // along a particular edge. In most cases, this is OK, and the Phi will
 111     // be eliminated later in an Ideal call. However, we can&#39;t allow this to
 112     // happen if the singleton occurs on loop entry, as the elimination of
 113     // the PhiNode may cause the resulting node to migrate back to a previous
 114     // loop iteration.
 115     if (singleton &amp;&amp; t == Type::TOP) {
 116       // Is_Loop() == false does not confirm the absence of a loop (e.g., an
 117       // irreducible loop may not be indicated by an affirmative is_Loop());
 118       // therefore, the only top we can split thru a phi is on a backedge of
 119       // a loop.
 120       singleton &amp;= region-&gt;is_Loop() &amp;&amp; (i != LoopNode::EntryControl);
 121     }
 122 
 123     if (singleton) {
 124       wins++;
 125       x = ((PhaseGVN&amp;)_igvn).makecon(t);
 126     } else {
 127       // We now call Identity to try to simplify the cloned node.
 128       // Note that some Identity methods call phase-&gt;type(this).
 129       // Make sure that the type array is big enough for
 130       // our new node, even though we may throw the node away.
 131       // (Note: This tweaking with igvn only works because x is a new node.)
 132       _igvn.set_type(x, t);
 133       // If x is a TypeNode, capture any more-precise type permanently into Node
 134       // otherwise it will be not updated during igvn-&gt;transform since
 135       // igvn-&gt;type(x) is set to x-&gt;Value() already.
 136       x-&gt;raise_bottom_type(t);
 137       Node* y = x-&gt;Identity(&amp;_igvn);
 138       if (y != x) {
 139         wins++;
 140         x = y;
 141       } else {
 142         y = _igvn.hash_find(x);
 143         if (y) {
 144           wins++;
 145           x = y;
 146         } else {
 147           // Else x is a new node we are keeping
 148           // We do not need register_new_node_with_optimizer
 149           // because set_type has already been called.
 150           _igvn._worklist.push(x);
 151         }
 152       }
 153     }
 154     if (x != the_clone &amp;&amp; the_clone != NULL)
 155       _igvn.remove_dead_node(the_clone);
 156     phi-&gt;set_req( i, x );
 157   }
 158   // Too few wins?
 159   if (wins &lt;= policy) {
 160     _igvn.remove_dead_node(phi);
 161     return NULL;
 162   }
 163 
 164   // Record Phi
 165   register_new_node( phi, region );
 166 
 167   for (uint i2 = 1; i2 &lt; phi-&gt;req(); i2++) {
 168     Node *x = phi-&gt;in(i2);
 169     // If we commoned up the cloned &#39;x&#39; with another existing Node,
 170     // the existing Node picks up a new use.  We need to make the
 171     // existing Node occur higher up so it dominates its uses.
 172     Node *old_ctrl;
 173     IdealLoopTree *old_loop;
 174 
 175     if (x-&gt;is_Con()) {
 176       // Constant&#39;s control is always root.
 177       set_ctrl(x, C-&gt;root());
 178       continue;
 179     }
 180     // The occasional new node
 181     if (x-&gt;_idx &gt;= old_unique) {     // Found a new, unplaced node?
 182       old_ctrl = NULL;
 183       old_loop = NULL;               // Not in any prior loop
 184     } else {
 185       old_ctrl = get_ctrl(x);
 186       old_loop = get_loop(old_ctrl); // Get prior loop
 187     }
 188     // New late point must dominate new use
 189     Node *new_ctrl = dom_lca(old_ctrl, region-&gt;in(i2));
 190     if (new_ctrl == old_ctrl) // Nothing is changed
 191       continue;
 192 
 193     IdealLoopTree *new_loop = get_loop(new_ctrl);
 194 
 195     // Don&#39;t move x into a loop if its uses are
 196     // outside of loop. Otherwise x will be cloned
 197     // for each use outside of this loop.
 198     IdealLoopTree *use_loop = get_loop(region);
 199     if (!new_loop-&gt;is_member(use_loop) &amp;&amp;
 200         (old_loop == NULL || !new_loop-&gt;is_member(old_loop))) {
 201       // Take early control, later control will be recalculated
 202       // during next iteration of loop optimizations.
 203       new_ctrl = get_early_ctrl(x);
 204       new_loop = get_loop(new_ctrl);
 205     }
 206     // Set new location
 207     set_ctrl(x, new_ctrl);
 208     // If changing loop bodies, see if we need to collect into new body
 209     if (old_loop != new_loop) {
 210       if (old_loop &amp;&amp; !old_loop-&gt;_child)
 211         old_loop-&gt;_body.yank(x);
 212       if (!new_loop-&gt;_child)
 213         new_loop-&gt;_body.push(x);  // Collect body info
 214     }
 215   }
 216 
 217   return phi;
 218 }
 219 
 220 //------------------------------dominated_by------------------------------------
 221 // Replace the dominated test with an obvious true or false.  Place it on the
 222 // IGVN worklist for later cleanup.  Move control-dependent data Nodes on the
 223 // live path up to the dominating control.
 224 void PhaseIdealLoop::dominated_by( Node *prevdom, Node *iff, bool flip, bool exclude_loop_predicate ) {
 225   if (VerifyLoopOptimizations &amp;&amp; PrintOpto) { tty-&gt;print_cr(&quot;dominating test&quot;); }
 226 
 227   // prevdom is the dominating projection of the dominating test.
 228   assert( iff-&gt;is_If(), &quot;&quot; );
 229   assert(iff-&gt;Opcode() == Op_If || iff-&gt;Opcode() == Op_CountedLoopEnd || iff-&gt;Opcode() == Op_RangeCheck, &quot;Check this code when new subtype is added&quot;);
 230   int pop = prevdom-&gt;Opcode();
 231   assert( pop == Op_IfFalse || pop == Op_IfTrue, &quot;&quot; );
 232   if (flip) {
 233     if (pop == Op_IfTrue)
 234       pop = Op_IfFalse;
 235     else
 236       pop = Op_IfTrue;
 237   }
 238   // &#39;con&#39; is set to true or false to kill the dominated test.
 239   Node *con = _igvn.makecon(pop == Op_IfTrue ? TypeInt::ONE : TypeInt::ZERO);
 240   set_ctrl(con, C-&gt;root()); // Constant gets a new use
 241   // Hack the dominated test
 242   _igvn.replace_input_of(iff, 1, con);
 243 
 244   // If I dont have a reachable TRUE and FALSE path following the IfNode then
 245   // I can assume this path reaches an infinite loop.  In this case it&#39;s not
 246   // important to optimize the data Nodes - either the whole compilation will
 247   // be tossed or this path (and all data Nodes) will go dead.
 248   if (iff-&gt;outcnt() != 2) return;
 249 
 250   // Make control-dependent data Nodes on the live path (path that will remain
 251   // once the dominated IF is removed) become control-dependent on the
 252   // dominating projection.
 253   Node* dp = iff-&gt;as_If()-&gt;proj_out_or_null(pop == Op_IfTrue);
 254 
 255   // Loop predicates may have depending checks which should not
 256   // be skipped. For example, range check predicate has two checks
 257   // for lower and upper bounds.
 258   if (dp == NULL)
 259     return;
 260 
 261   ProjNode* dp_proj  = dp-&gt;as_Proj();
 262   ProjNode* unc_proj = iff-&gt;as_If()-&gt;proj_out(1 - dp_proj-&gt;_con)-&gt;as_Proj();
 263   if (exclude_loop_predicate &amp;&amp;
 264       (unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||
 265        unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL ||
 266        unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_range_check) != NULL)) {
 267     // If this is a range check (IfNode::is_range_check), do not
 268     // reorder because Compile::allow_range_check_smearing might have
 269     // changed the check.
 270     return; // Let IGVN transformation change control dependence.
 271   }
 272 
 273   IdealLoopTree *old_loop = get_loop(dp);
 274 
 275   for (DUIterator_Fast imax, i = dp-&gt;fast_outs(imax); i &lt; imax; i++) {
 276     Node* cd = dp-&gt;fast_out(i); // Control-dependent node
 277     if (cd-&gt;depends_only_on_test()) {
 278       assert(cd-&gt;in(0) == dp, &quot;&quot;);
 279       _igvn.replace_input_of(cd, 0, prevdom);
 280       set_early_ctrl(cd);
 281       IdealLoopTree *new_loop = get_loop(get_ctrl(cd));
 282       if (old_loop != new_loop) {
 283         if (!old_loop-&gt;_child) old_loop-&gt;_body.yank(cd);
 284         if (!new_loop-&gt;_child) new_loop-&gt;_body.push(cd);
 285       }
 286       --i;
 287       --imax;
 288     }
 289   }
 290 }
 291 
 292 //------------------------------has_local_phi_input----------------------------
 293 // Return TRUE if &#39;n&#39; has Phi inputs from its local block and no other
 294 // block-local inputs (all non-local-phi inputs come from earlier blocks)
 295 Node *PhaseIdealLoop::has_local_phi_input( Node *n ) {
 296   Node *n_ctrl = get_ctrl(n);
 297   // See if some inputs come from a Phi in this block, or from before
 298   // this block.
 299   uint i;
 300   for( i = 1; i &lt; n-&gt;req(); i++ ) {
 301     Node *phi = n-&gt;in(i);
 302     if( phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == n_ctrl )
 303       break;
 304   }
 305   if( i &gt;= n-&gt;req() )
 306     return NULL;                // No Phi inputs; nowhere to clone thru
 307 
 308   // Check for inputs created between &#39;n&#39; and the Phi input.  These
 309   // must split as well; they have already been given the chance
 310   // (courtesy of a post-order visit) and since they did not we must
 311   // recover the &#39;cost&#39; of splitting them by being very profitable
 312   // when splitting &#39;n&#39;.  Since this is unlikely we simply give up.
 313   for( i = 1; i &lt; n-&gt;req(); i++ ) {
 314     Node *m = n-&gt;in(i);
 315     if( get_ctrl(m) == n_ctrl &amp;&amp; !m-&gt;is_Phi() ) {
 316       // We allow the special case of AddP&#39;s with no local inputs.
 317       // This allows us to split-up address expressions.
 318       if (m-&gt;is_AddP() &amp;&amp;
 319           get_ctrl(m-&gt;in(2)) != n_ctrl &amp;&amp;
 320           get_ctrl(m-&gt;in(3)) != n_ctrl) {
 321         // Move the AddP up to dominating point
 322         Node* c = find_non_split_ctrl(idom(n_ctrl));
 323         if (c-&gt;is_OuterStripMinedLoop()) {
 324           c-&gt;as_Loop()-&gt;verify_strip_mined(1);
 325           c = c-&gt;in(LoopNode::EntryControl);
 326         }
 327         set_ctrl_and_loop(m, c);
 328         continue;
 329       }
 330       return NULL;
 331     }
 332     assert(n-&gt;is_Phi() || m-&gt;is_Phi() || is_dominator(get_ctrl(m), n_ctrl), &quot;m has strange control&quot;);
 333   }
 334 
 335   return n_ctrl;
 336 }
 337 
 338 //------------------------------remix_address_expressions----------------------
 339 // Rework addressing expressions to get the most loop-invariant stuff
 340 // moved out.  We&#39;d like to do all associative operators, but it&#39;s especially
 341 // important (common) to do address expressions.
 342 Node *PhaseIdealLoop::remix_address_expressions( Node *n ) {
 343   if (!has_ctrl(n))  return NULL;
 344   Node *n_ctrl = get_ctrl(n);
 345   IdealLoopTree *n_loop = get_loop(n_ctrl);
 346 
 347   // See if &#39;n&#39; mixes loop-varying and loop-invariant inputs and
 348   // itself is loop-varying.
 349 
 350   // Only interested in binary ops (and AddP)
 351   if( n-&gt;req() &lt; 3 || n-&gt;req() &gt; 4 ) return NULL;
 352 
 353   Node *n1_ctrl = get_ctrl(n-&gt;in(                    1));
 354   Node *n2_ctrl = get_ctrl(n-&gt;in(                    2));
 355   Node *n3_ctrl = get_ctrl(n-&gt;in(n-&gt;req() == 3 ? 2 : 3));
 356   IdealLoopTree *n1_loop = get_loop( n1_ctrl );
 357   IdealLoopTree *n2_loop = get_loop( n2_ctrl );
 358   IdealLoopTree *n3_loop = get_loop( n3_ctrl );
 359 
 360   // Does one of my inputs spin in a tighter loop than self?
 361   if( (n_loop-&gt;is_member( n1_loop ) &amp;&amp; n_loop != n1_loop) ||
 362       (n_loop-&gt;is_member( n2_loop ) &amp;&amp; n_loop != n2_loop) ||
 363       (n_loop-&gt;is_member( n3_loop ) &amp;&amp; n_loop != n3_loop) )
 364     return NULL;                // Leave well enough alone
 365 
 366   // Is at least one of my inputs loop-invariant?
 367   if( n1_loop == n_loop &amp;&amp;
 368       n2_loop == n_loop &amp;&amp;
 369       n3_loop == n_loop )
 370     return NULL;                // No loop-invariant inputs
 371 
 372 
 373   int n_op = n-&gt;Opcode();
 374 
 375   // Replace expressions like ((V+I) &lt;&lt; 2) with (V&lt;&lt;2 + I&lt;&lt;2).
 376   if( n_op == Op_LShiftI ) {
 377     // Scale is loop invariant
 378     Node *scale = n-&gt;in(2);
 379     Node *scale_ctrl = get_ctrl(scale);
 380     IdealLoopTree *scale_loop = get_loop(scale_ctrl );
 381     if( n_loop == scale_loop || !scale_loop-&gt;is_member( n_loop ) )
 382       return NULL;
 383     const TypeInt *scale_t = scale-&gt;bottom_type()-&gt;isa_int();
 384     if( scale_t &amp;&amp; scale_t-&gt;is_con() &amp;&amp; scale_t-&gt;get_con() &gt;= 16 )
 385       return NULL;              // Dont bother with byte/short masking
 386     // Add must vary with loop (else shift would be loop-invariant)
 387     Node *add = n-&gt;in(1);
 388     Node *add_ctrl = get_ctrl(add);
 389     IdealLoopTree *add_loop = get_loop(add_ctrl);
 390     //assert( n_loop == add_loop, &quot;&quot; );
 391     if( n_loop != add_loop ) return NULL;  // happens w/ evil ZKM loops
 392 
 393     // Convert I-V into I+ (0-V); same for V-I
 394     if( add-&gt;Opcode() == Op_SubI &amp;&amp;
 395         _igvn.type( add-&gt;in(1) ) != TypeInt::ZERO ) {
 396       Node *zero = _igvn.intcon(0);
 397       set_ctrl(zero, C-&gt;root());
 398       Node *neg = new SubINode( _igvn.intcon(0), add-&gt;in(2) );
 399       register_new_node( neg, get_ctrl(add-&gt;in(2) ) );
 400       add = new AddINode( add-&gt;in(1), neg );
 401       register_new_node( add, add_ctrl );
 402     }
 403     if( add-&gt;Opcode() != Op_AddI ) return NULL;
 404     // See if one add input is loop invariant
 405     Node *add_var = add-&gt;in(1);
 406     Node *add_var_ctrl = get_ctrl(add_var);
 407     IdealLoopTree *add_var_loop = get_loop(add_var_ctrl );
 408     Node *add_invar = add-&gt;in(2);
 409     Node *add_invar_ctrl = get_ctrl(add_invar);
 410     IdealLoopTree *add_invar_loop = get_loop(add_invar_ctrl );
 411     if( add_var_loop == n_loop ) {
 412     } else if( add_invar_loop == n_loop ) {
 413       // Swap to find the invariant part
 414       add_invar = add_var;
 415       add_invar_ctrl = add_var_ctrl;
 416       add_invar_loop = add_var_loop;
 417       add_var = add-&gt;in(2);
 418       Node *add_var_ctrl = get_ctrl(add_var);
 419       IdealLoopTree *add_var_loop = get_loop(add_var_ctrl );
 420     } else                      // Else neither input is loop invariant
 421       return NULL;
 422     if( n_loop == add_invar_loop || !add_invar_loop-&gt;is_member( n_loop ) )
 423       return NULL;              // No invariant part of the add?
 424 
 425     // Yes!  Reshape address expression!
 426     Node *inv_scale = new LShiftINode( add_invar, scale );
 427     Node *inv_scale_ctrl =
 428       dom_depth(add_invar_ctrl) &gt; dom_depth(scale_ctrl) ?
 429       add_invar_ctrl : scale_ctrl;
 430     register_new_node( inv_scale, inv_scale_ctrl );
 431     Node *var_scale = new LShiftINode( add_var, scale );
 432     register_new_node( var_scale, n_ctrl );
 433     Node *var_add = new AddINode( var_scale, inv_scale );
 434     register_new_node( var_add, n_ctrl );
 435     _igvn.replace_node( n, var_add );
 436     return var_add;
 437   }
 438 
 439   // Replace (I+V) with (V+I)
 440   if( n_op == Op_AddI ||
 441       n_op == Op_AddL ||
 442       n_op == Op_AddF ||
 443       n_op == Op_AddD ||
 444       n_op == Op_MulI ||
 445       n_op == Op_MulL ||
 446       n_op == Op_MulF ||
 447       n_op == Op_MulD ) {
 448     if( n2_loop == n_loop ) {
 449       assert( n1_loop != n_loop, &quot;&quot; );
 450       n-&gt;swap_edges(1, 2);
 451     }
 452   }
 453 
 454   // Replace ((I1 +p V) +p I2) with ((I1 +p I2) +p V),
 455   // but not if I2 is a constant.
 456   if( n_op == Op_AddP ) {
 457     if( n2_loop == n_loop &amp;&amp; n3_loop != n_loop ) {
 458       if( n-&gt;in(2)-&gt;Opcode() == Op_AddP &amp;&amp; !n-&gt;in(3)-&gt;is_Con() ) {
 459         Node *n22_ctrl = get_ctrl(n-&gt;in(2)-&gt;in(2));
 460         Node *n23_ctrl = get_ctrl(n-&gt;in(2)-&gt;in(3));
 461         IdealLoopTree *n22loop = get_loop( n22_ctrl );
 462         IdealLoopTree *n23_loop = get_loop( n23_ctrl );
 463         if( n22loop != n_loop &amp;&amp; n22loop-&gt;is_member(n_loop) &amp;&amp;
 464             n23_loop == n_loop ) {
 465           Node *add1 = new AddPNode( n-&gt;in(1), n-&gt;in(2)-&gt;in(2), n-&gt;in(3) );
 466           // Stuff new AddP in the loop preheader
 467           register_new_node( add1, n_loop-&gt;_head-&gt;in(LoopNode::EntryControl) );
 468           Node *add2 = new AddPNode( n-&gt;in(1), add1, n-&gt;in(2)-&gt;in(3) );
 469           register_new_node( add2, n_ctrl );
 470           _igvn.replace_node( n, add2 );
 471           return add2;
 472         }
 473       }
 474     }
 475 
 476     // Replace (I1 +p (I2 + V)) with ((I1 +p I2) +p V)
 477     if (n2_loop != n_loop &amp;&amp; n3_loop == n_loop) {
 478       if (n-&gt;in(3)-&gt;Opcode() == Op_AddX) {
 479         Node *V = n-&gt;in(3)-&gt;in(1);
 480         Node *I = n-&gt;in(3)-&gt;in(2);
 481         if (is_member(n_loop,get_ctrl(V))) {
 482         } else {
 483           Node *tmp = V; V = I; I = tmp;
 484         }
 485         if (!is_member(n_loop,get_ctrl(I))) {
 486           Node *add1 = new AddPNode(n-&gt;in(1), n-&gt;in(2), I);
 487           // Stuff new AddP in the loop preheader
 488           register_new_node(add1, n_loop-&gt;_head-&gt;in(LoopNode::EntryControl));
 489           Node *add2 = new AddPNode(n-&gt;in(1), add1, V);
 490           register_new_node(add2, n_ctrl);
 491           _igvn.replace_node(n, add2);
 492           return add2;
 493         }
 494       }
 495     }
 496   }
 497 
 498   return NULL;
 499 }
 500 
 501 // Optimize ((in1[2*i] * in2[2*i]) + (in1[2*i+1] * in2[2*i+1]))
 502 Node *PhaseIdealLoop::convert_add_to_muladd(Node* n) {
 503   assert(n-&gt;Opcode() == Op_AddI, &quot;sanity&quot;);
 504   Node * nn = NULL;
 505   Node * in1 = n-&gt;in(1);
 506   Node * in2 = n-&gt;in(2);
 507   if (in1-&gt;Opcode() == Op_MulI &amp;&amp; in2-&gt;Opcode() == Op_MulI) {
 508     IdealLoopTree* loop_n = get_loop(get_ctrl(n));
 509     if (loop_n-&gt;is_counted() &amp;&amp;
 510         loop_n-&gt;_head-&gt;as_Loop()-&gt;is_valid_counted_loop() &amp;&amp;
 511         Matcher::match_rule_supported(Op_MulAddVS2VI) &amp;&amp;
 512         Matcher::match_rule_supported(Op_MulAddS2I)) {
 513       Node* mul_in1 = in1-&gt;in(1);
 514       Node* mul_in2 = in1-&gt;in(2);
 515       Node* mul_in3 = in2-&gt;in(1);
 516       Node* mul_in4 = in2-&gt;in(2);
 517       if (mul_in1-&gt;Opcode() == Op_LoadS &amp;&amp;
 518           mul_in2-&gt;Opcode() == Op_LoadS &amp;&amp;
 519           mul_in3-&gt;Opcode() == Op_LoadS &amp;&amp;
 520           mul_in4-&gt;Opcode() == Op_LoadS) {
 521         IdealLoopTree* loop1 = get_loop(get_ctrl(mul_in1));
 522         IdealLoopTree* loop2 = get_loop(get_ctrl(mul_in2));
 523         IdealLoopTree* loop3 = get_loop(get_ctrl(mul_in3));
 524         IdealLoopTree* loop4 = get_loop(get_ctrl(mul_in4));
 525         IdealLoopTree* loop5 = get_loop(get_ctrl(in1));
 526         IdealLoopTree* loop6 = get_loop(get_ctrl(in2));
 527         // All nodes should be in the same counted loop.
 528         if (loop_n == loop1 &amp;&amp; loop_n == loop2 &amp;&amp; loop_n == loop3 &amp;&amp;
 529             loop_n == loop4 &amp;&amp; loop_n == loop5 &amp;&amp; loop_n == loop6) {
 530           Node* adr1 = mul_in1-&gt;in(MemNode::Address);
 531           Node* adr2 = mul_in2-&gt;in(MemNode::Address);
 532           Node* adr3 = mul_in3-&gt;in(MemNode::Address);
 533           Node* adr4 = mul_in4-&gt;in(MemNode::Address);
 534           if (adr1-&gt;is_AddP() &amp;&amp; adr2-&gt;is_AddP() &amp;&amp; adr3-&gt;is_AddP() &amp;&amp; adr4-&gt;is_AddP()) {
 535             if ((adr1-&gt;in(AddPNode::Base) == adr3-&gt;in(AddPNode::Base)) &amp;&amp;
 536                 (adr2-&gt;in(AddPNode::Base) == adr4-&gt;in(AddPNode::Base))) {
 537               nn = new MulAddS2INode(mul_in1, mul_in2, mul_in3, mul_in4);
 538               register_new_node(nn, get_ctrl(n));
 539               _igvn.replace_node(n, nn);
 540               return nn;
 541             } else if ((adr1-&gt;in(AddPNode::Base) == adr4-&gt;in(AddPNode::Base)) &amp;&amp;
 542                        (adr2-&gt;in(AddPNode::Base) == adr3-&gt;in(AddPNode::Base))) {
 543               nn = new MulAddS2INode(mul_in1, mul_in2, mul_in4, mul_in3);
 544               register_new_node(nn, get_ctrl(n));
 545               _igvn.replace_node(n, nn);
 546               return nn;
 547             }
 548           }
 549         }
 550       }
 551     }
 552   }
 553   return nn;
 554 }
 555 
 556 //------------------------------conditional_move-------------------------------
 557 // Attempt to replace a Phi with a conditional move.  We have some pretty
 558 // strict profitability requirements.  All Phis at the merge point must
 559 // be converted, so we can remove the control flow.  We need to limit the
 560 // number of c-moves to a small handful.  All code that was in the side-arms
 561 // of the CFG diamond is now speculatively executed.  This code has to be
 562 // &quot;cheap enough&quot;.  We are pretty much limited to CFG diamonds that merge
 563 // 1 or 2 items with a total of 1 or 2 ops executed speculatively.
 564 Node *PhaseIdealLoop::conditional_move( Node *region ) {
 565 
 566   assert(region-&gt;is_Region(), &quot;sanity check&quot;);
 567   if (region-&gt;req() != 3) return NULL;
 568 
 569   // Check for CFG diamond
 570   Node *lp = region-&gt;in(1);
 571   Node *rp = region-&gt;in(2);
 572   if (!lp || !rp) return NULL;
 573   Node *lp_c = lp-&gt;in(0);
 574   if (lp_c == NULL || lp_c != rp-&gt;in(0) || !lp_c-&gt;is_If()) return NULL;
 575   IfNode *iff = lp_c-&gt;as_If();
 576 
 577   // Check for ops pinned in an arm of the diamond.
 578   // Can&#39;t remove the control flow in this case
 579   if (lp-&gt;outcnt() &gt; 1) return NULL;
 580   if (rp-&gt;outcnt() &gt; 1) return NULL;
 581 
 582   IdealLoopTree* r_loop = get_loop(region);
 583   assert(r_loop == get_loop(iff), &quot;sanity&quot;);
 584   // Always convert to CMOVE if all results are used only outside this loop.
 585   bool used_inside_loop = (r_loop == _ltree_root);
 586 
 587   // Check profitability
 588   int cost = 0;
 589   int phis = 0;
 590   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
 591     Node *out = region-&gt;fast_out(i);
 592     if (!out-&gt;is_Phi()) continue; // Ignore other control edges, etc
 593     phis++;
 594     PhiNode* phi = out-&gt;as_Phi();
 595     BasicType bt = phi-&gt;type()-&gt;basic_type();
 596     switch (bt) {
 597     case T_DOUBLE:
 598     case T_FLOAT:
 599       if (C-&gt;use_cmove()) {
 600         continue; //TODO: maybe we want to add some cost
 601       }
 602       cost += Matcher::float_cmove_cost(); // Could be very expensive
 603       break;
 604     case T_LONG: {
 605       cost += Matcher::long_cmove_cost(); // May encodes as 2 CMOV&#39;s
 606     }
 607     case T_INT:                 // These all CMOV fine
 608     case T_ADDRESS: {           // (RawPtr)
 609       cost++;
 610       break;
 611     }
 612     case T_NARROWOOP: // Fall through
 613     case T_OBJECT: {            // Base oops are OK, but not derived oops
 614       const TypeOopPtr *tp = phi-&gt;type()-&gt;make_ptr()-&gt;isa_oopptr();
 615       // Derived pointers are Bad (tm): what&#39;s the Base (for GC purposes) of a
 616       // CMOVE&#39;d derived pointer?  It&#39;s a CMOVE&#39;d derived base.  Thus
 617       // CMOVE&#39;ing a derived pointer requires we also CMOVE the base.  If we
 618       // have a Phi for the base here that we convert to a CMOVE all is well
 619       // and good.  But if the base is dead, we&#39;ll not make a CMOVE.  Later
 620       // the allocator will have to produce a base by creating a CMOVE of the
 621       // relevant bases.  This puts the allocator in the business of
 622       // manufacturing expensive instructions, generally a bad plan.
 623       // Just Say No to Conditionally-Moved Derived Pointers.
 624       if (tp &amp;&amp; tp-&gt;offset() != 0)
 625         return NULL;
 626       cost++;
 627       break;
 628     }
 629     default:
 630       return NULL;              // In particular, can&#39;t do memory or I/O
 631     }
 632     // Add in cost any speculative ops
 633     for (uint j = 1; j &lt; region-&gt;req(); j++) {
 634       Node *proj = region-&gt;in(j);
 635       Node *inp = phi-&gt;in(j);
 636       if (get_ctrl(inp) == proj) { // Found local op
 637         cost++;
 638         // Check for a chain of dependent ops; these will all become
 639         // speculative in a CMOV.
 640         for (uint k = 1; k &lt; inp-&gt;req(); k++)
 641           if (get_ctrl(inp-&gt;in(k)) == proj)
 642             cost += ConditionalMoveLimit; // Too much speculative goo
 643       }
 644     }
 645     // See if the Phi is used by a Cmp or Narrow oop Decode/Encode.
 646     // This will likely Split-If, a higher-payoff operation.
 647     for (DUIterator_Fast kmax, k = phi-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 648       Node* use = phi-&gt;fast_out(k);
 649       if (use-&gt;is_Cmp() || use-&gt;is_DecodeNarrowPtr() || use-&gt;is_EncodeNarrowPtr())
 650         cost += ConditionalMoveLimit;
 651       // Is there a use inside the loop?
 652       // Note: check only basic types since CMoveP is pinned.
 653       if (!used_inside_loop &amp;&amp; is_java_primitive(bt)) {
 654         IdealLoopTree* u_loop = get_loop(has_ctrl(use) ? get_ctrl(use) : use);
 655         if (r_loop == u_loop || r_loop-&gt;is_member(u_loop)) {
 656           used_inside_loop = true;
 657         }
 658       }
 659     }
 660   }//for
 661   Node* bol = iff-&gt;in(1);
 662   if (bol-&gt;Opcode() == Op_Opaque4) {
 663     return NULL; // Ignore loop predicate checks (the Opaque4 ensures they will go away)
 664   }
 665   assert(bol-&gt;Opcode() == Op_Bool, &quot;Unexpected node&quot;);
 666   int cmp_op = bol-&gt;in(1)-&gt;Opcode();
 667   if (cmp_op == Op_SubTypeCheck) { // SubTypeCheck expansion expects an IfNode
 668     return NULL;
 669   }
 670   // It is expensive to generate flags from a float compare.
 671   // Avoid duplicated float compare.
 672   if (phis &gt; 1 &amp;&amp; (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) return NULL;
 673 
 674   float infrequent_prob = PROB_UNLIKELY_MAG(3);
 675   // Ignore cost and blocks frequency if CMOVE can be moved outside the loop.
 676   if (used_inside_loop) {
 677     if (cost &gt;= ConditionalMoveLimit) return NULL; // Too much goo
 678 
 679     // BlockLayoutByFrequency optimization moves infrequent branch
 680     // from hot path. No point in CMOV&#39;ing in such case (110 is used
 681     // instead of 100 to take into account not exactness of float value).
 682     if (BlockLayoutByFrequency) {
 683       infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage/110.0f);
 684     }
 685   }
 686   // Check for highly predictable branch.  No point in CMOV&#39;ing if
 687   // we are going to predict accurately all the time.
 688   if (C-&gt;use_cmove() &amp;&amp; (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) {
 689     //keep going
 690   } else if (iff-&gt;_prob &lt; infrequent_prob ||
 691       iff-&gt;_prob &gt; (1.0f - infrequent_prob))
 692     return NULL;
 693 
 694   // --------------
 695   // Now replace all Phis with CMOV&#39;s
 696   Node *cmov_ctrl = iff-&gt;in(0);
 697   uint flip = (lp-&gt;Opcode() == Op_IfTrue);
 698   Node_List wq;
 699   while (1) {
 700     PhiNode* phi = NULL;
 701     for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
 702       Node *out = region-&gt;fast_out(i);
 703       if (out-&gt;is_Phi()) {
 704         phi = out-&gt;as_Phi();
 705         break;
 706       }
 707     }
 708     if (phi == NULL)  break;
 709     if (PrintOpto &amp;&amp; VerifyLoopOptimizations) { tty-&gt;print_cr(&quot;CMOV&quot;); }
 710     // Move speculative ops
 711     wq.push(phi);
 712     while (wq.size() &gt; 0) {
 713       Node *n = wq.pop();
 714       for (uint j = 1; j &lt; n-&gt;req(); j++) {
 715         Node* m = n-&gt;in(j);
 716         if (m != NULL &amp;&amp; !is_dominator(get_ctrl(m), cmov_ctrl)) {
 717 #ifndef PRODUCT
 718           if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
 719             tty-&gt;print(&quot;  speculate: &quot;);
 720             m-&gt;dump();
 721           }
 722 #endif
 723           set_ctrl(m, cmov_ctrl);
 724           wq.push(m);
 725         }
 726       }
 727     }
 728     Node *cmov = CMoveNode::make(cmov_ctrl, iff-&gt;in(1), phi-&gt;in(1+flip), phi-&gt;in(2-flip), _igvn.type(phi));
 729     register_new_node( cmov, cmov_ctrl );
 730     _igvn.replace_node( phi, cmov );
 731 #ifndef PRODUCT
 732     if (TraceLoopOpts) {
 733       tty-&gt;print(&quot;CMOV  &quot;);
 734       r_loop-&gt;dump_head();
 735       if (Verbose) {
 736         bol-&gt;in(1)-&gt;dump(1);
 737         cmov-&gt;dump(1);
 738       }
 739     }
 740     if (VerifyLoopOptimizations) verify();
 741 #endif
 742   }
 743 
 744   // The useless CFG diamond will fold up later; see the optimization in
 745   // RegionNode::Ideal.
 746   _igvn._worklist.push(region);
 747 
 748   return iff-&gt;in(1);
 749 }
 750 
 751 static void enqueue_cfg_uses(Node* m, Unique_Node_List&amp; wq) {
 752   for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
 753     Node* u = m-&gt;fast_out(i);
 754     if (u-&gt;is_CFG()) {
 755       if (u-&gt;Opcode() == Op_NeverBranch) {
 756         u = ((NeverBranchNode*)u)-&gt;proj_out(0);
 757         enqueue_cfg_uses(u, wq);
 758       } else {
 759         wq.push(u);
 760       }
 761     }
 762   }
 763 }
 764 
 765 // Try moving a store out of a loop, right before the loop
 766 Node* PhaseIdealLoop::try_move_store_before_loop(Node* n, Node *n_ctrl) {
 767   // Store has to be first in the loop body
 768   IdealLoopTree *n_loop = get_loop(n_ctrl);
 769   if (n-&gt;is_Store() &amp;&amp; n_loop != _ltree_root &amp;&amp;
 770       n_loop-&gt;is_loop() &amp;&amp; n_loop-&gt;_head-&gt;is_Loop() &amp;&amp;
 771       n-&gt;in(0) != NULL) {
 772     Node* address = n-&gt;in(MemNode::Address);
 773     Node* value = n-&gt;in(MemNode::ValueIn);
 774     Node* mem = n-&gt;in(MemNode::Memory);
 775     IdealLoopTree* address_loop = get_loop(get_ctrl(address));
 776     IdealLoopTree* value_loop = get_loop(get_ctrl(value));
 777 
 778     // - address and value must be loop invariant
 779     // - memory must be a memory Phi for the loop
 780     // - Store must be the only store on this memory slice in the
 781     // loop: if there&#39;s another store following this one then value
 782     // written at iteration i by the second store could be overwritten
 783     // at iteration i+n by the first store: it&#39;s not safe to move the
 784     // first store out of the loop
 785     // - nothing must observe the memory Phi: it guarantees no read
 786     // before the store, we are also guaranteed the store post
 787     // dominates the loop head (ignoring a possible early
 788     // exit). Otherwise there would be extra Phi involved between the
 789     // loop&#39;s Phi and the store.
 790     // - there must be no early exit from the loop before the Store
 791     // (such an exit most of the time would be an extra use of the
 792     // memory Phi but sometimes is a bottom memory Phi that takes the
 793     // store as input).
 794 
 795     if (!n_loop-&gt;is_member(address_loop) &amp;&amp;
 796         !n_loop-&gt;is_member(value_loop) &amp;&amp;
 797         mem-&gt;is_Phi() &amp;&amp; mem-&gt;in(0) == n_loop-&gt;_head &amp;&amp;
 798         mem-&gt;outcnt() == 1 &amp;&amp;
 799         mem-&gt;in(LoopNode::LoopBackControl) == n) {
 800 
 801       assert(n_loop-&gt;_tail != NULL, &quot;need a tail&quot;);
 802       assert(is_dominator(n_ctrl, n_loop-&gt;_tail), &quot;store control must not be in a branch in the loop&quot;);
 803 
 804       // Verify that there&#39;s no early exit of the loop before the store.
 805       bool ctrl_ok = false;
 806       {
 807         // Follow control from loop head until n, we exit the loop or
 808         // we reach the tail
 809         ResourceMark rm;
 810         Unique_Node_List wq;
 811         wq.push(n_loop-&gt;_head);
 812 
 813         for (uint next = 0; next &lt; wq.size(); ++next) {
 814           Node *m = wq.at(next);
 815           if (m == n-&gt;in(0)) {
 816             ctrl_ok = true;
 817             continue;
 818           }
 819           assert(!has_ctrl(m), &quot;should be CFG&quot;);
 820           if (!n_loop-&gt;is_member(get_loop(m)) || m == n_loop-&gt;_tail) {
 821             ctrl_ok = false;
 822             break;
 823           }
 824           enqueue_cfg_uses(m, wq);
 825           if (wq.size() &gt; 10) {
 826             ctrl_ok = false;
 827             break;
 828           }
 829         }
 830       }
 831       if (ctrl_ok) {
 832         // move the Store
 833         _igvn.replace_input_of(mem, LoopNode::LoopBackControl, mem);
 834         _igvn.replace_input_of(n, 0, n_loop-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl));
 835         _igvn.replace_input_of(n, MemNode::Memory, mem-&gt;in(LoopNode::EntryControl));
 836         // Disconnect the phi now. An empty phi can confuse other
 837         // optimizations in this pass of loop opts.
 838         _igvn.replace_node(mem, mem-&gt;in(LoopNode::EntryControl));
 839         n_loop-&gt;_body.yank(mem);
 840 
 841         set_ctrl_and_loop(n, n-&gt;in(0));
 842 
 843         return n;
 844       }
 845     }
 846   }
 847   return NULL;
 848 }
 849 
 850 // Try moving a store out of a loop, right after the loop
 851 void PhaseIdealLoop::try_move_store_after_loop(Node* n) {
 852   if (n-&gt;is_Store() &amp;&amp; n-&gt;in(0) != NULL) {
 853     Node *n_ctrl = get_ctrl(n);
 854     IdealLoopTree *n_loop = get_loop(n_ctrl);
 855     // Store must be in a loop
 856     if (n_loop != _ltree_root &amp;&amp; !n_loop-&gt;_irreducible) {
 857       Node* address = n-&gt;in(MemNode::Address);
 858       Node* value = n-&gt;in(MemNode::ValueIn);
 859       IdealLoopTree* address_loop = get_loop(get_ctrl(address));
 860       // address must be loop invariant
 861       if (!n_loop-&gt;is_member(address_loop)) {
 862         // Store must be last on this memory slice in the loop and
 863         // nothing in the loop must observe it
 864         Node* phi = NULL;
 865         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 866           Node* u = n-&gt;fast_out(i);
 867           if (has_ctrl(u)) { // control use?
 868             IdealLoopTree *u_loop = get_loop(get_ctrl(u));
 869             if (!n_loop-&gt;is_member(u_loop)) {
 870               continue;
 871             }
 872             if (u-&gt;is_Phi() &amp;&amp; u-&gt;in(0) == n_loop-&gt;_head) {
 873               assert(_igvn.type(u) == Type::MEMORY, &quot;bad phi&quot;);
 874               // multiple phis on the same slice are possible
 875               if (phi != NULL) {
 876                 return;
 877               }
 878               phi = u;
 879               continue;
 880             }
 881           }
 882           return;
 883         }
 884         if (phi != NULL) {
 885           // Nothing in the loop before the store (next iteration)
 886           // must observe the stored value
 887           bool mem_ok = true;
 888           {
 889             ResourceMark rm;
 890             Unique_Node_List wq;
 891             wq.push(phi);
 892             for (uint next = 0; next &lt; wq.size() &amp;&amp; mem_ok; ++next) {
 893               Node *m = wq.at(next);
 894               for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem_ok; i++) {
 895                 Node* u = m-&gt;fast_out(i);
 896                 if (u-&gt;is_Store() || u-&gt;is_Phi()) {
 897                   if (u != n) {
 898                     wq.push(u);
 899                     mem_ok = (wq.size() &lt;= 10);
 900                   }
 901                 } else {
 902                   mem_ok = false;
 903                   break;
 904                 }
 905               }
 906             }
 907           }
 908           if (mem_ok) {
 909             // Move the store out of the loop if the LCA of all
 910             // users (except for the phi) is outside the loop.
 911             Node* hook = new Node(1);
 912             hook-&gt;init_req(0, n_ctrl); // Add an input to prevent hook from being dead
 913             _igvn.rehash_node_delayed(phi);
 914             int count = phi-&gt;replace_edge(n, hook);
 915             assert(count &gt; 0, &quot;inconsistent phi&quot;);
 916 
 917             // Compute latest point this store can go
 918             Node* lca = get_late_ctrl(n, get_ctrl(n));
 919             if (lca-&gt;is_OuterStripMinedLoop()) {
 920               lca = lca-&gt;in(LoopNode::EntryControl);
 921             }
 922             if (n_loop-&gt;is_member(get_loop(lca))) {
 923               // LCA is in the loop - bail out
 924               _igvn.replace_node(hook, n);
 925               return;
 926             }
 927 #ifdef ASSERT
 928             if (n_loop-&gt;_head-&gt;is_Loop() &amp;&amp; n_loop-&gt;_head-&gt;as_Loop()-&gt;is_strip_mined()) {
 929               assert(n_loop-&gt;_head-&gt;Opcode() == Op_CountedLoop, &quot;outer loop is a strip mined&quot;);
 930               n_loop-&gt;_head-&gt;as_Loop()-&gt;verify_strip_mined(1);
 931               Node* outer = n_loop-&gt;_head-&gt;as_CountedLoop()-&gt;outer_loop();
 932               IdealLoopTree* outer_loop = get_loop(outer);
 933               assert(n_loop-&gt;_parent == outer_loop, &quot;broken loop tree&quot;);
 934               assert(get_loop(lca) == outer_loop, &quot;safepoint in outer loop consume all memory state&quot;);
 935             }
 936 #endif
 937 
 938             // Move store out of the loop
 939             _igvn.replace_node(hook, n-&gt;in(MemNode::Memory));
 940             _igvn.replace_input_of(n, 0, lca);
 941             set_ctrl_and_loop(n, lca);
 942 
 943             // Disconnect the phi now. An empty phi can confuse other
 944             // optimizations in this pass of loop opts..
 945             if (phi-&gt;in(LoopNode::LoopBackControl) == phi) {
 946               _igvn.replace_node(phi, phi-&gt;in(LoopNode::EntryControl));
 947               n_loop-&gt;_body.yank(phi);
 948             }
 949           }
 950         }
 951       }
 952     }
 953   }
 954 }
 955 
 956 //------------------------------split_if_with_blocks_pre-----------------------
 957 // Do the real work in a non-recursive function.  Data nodes want to be
 958 // cloned in the pre-order so they can feed each other nicely.
 959 Node *PhaseIdealLoop::split_if_with_blocks_pre( Node *n ) {
 960   // Cloning these guys is unlikely to win
 961   int n_op = n-&gt;Opcode();
 962   if( n_op == Op_MergeMem ) return n;
 963   if( n-&gt;is_Proj() ) return n;
 964   // Do not clone-up CmpFXXX variations, as these are always
 965   // followed by a CmpI
 966   if( n-&gt;is_Cmp() ) return n;
 967   // Attempt to use a conditional move instead of a phi/branch
 968   if( ConditionalMoveLimit &gt; 0 &amp;&amp; n_op == Op_Region ) {
 969     Node *cmov = conditional_move( n );
 970     if( cmov ) return cmov;
 971   }
 972   if( n-&gt;is_CFG() || n-&gt;is_LoadStore() )
 973     return n;
 974   if( n_op == Op_Opaque1 ||     // Opaque nodes cannot be mod&#39;d
 975       n_op == Op_Opaque2 ) {
 976     if( !C-&gt;major_progress() )   // If chance of no more loop opts...
 977       _igvn._worklist.push(n);  // maybe we&#39;ll remove them
 978     return n;
 979   }
 980 
 981   if( n-&gt;is_Con() ) return n;   // No cloning for Con nodes
 982 
 983   Node *n_ctrl = get_ctrl(n);
 984   if( !n_ctrl ) return n;       // Dead node
 985 
 986   Node* res = try_move_store_before_loop(n, n_ctrl);
 987   if (res != NULL) {
 988     return n;
 989   }
 990 
 991   // Attempt to remix address expressions for loop invariants
 992   Node *m = remix_address_expressions( n );
 993   if( m ) return m;
 994 
 995   if (n_op == Op_AddI) {
 996     Node *nn = convert_add_to_muladd( n );
 997     if ( nn ) return nn;
 998   }
 999 
1000   if (n-&gt;is_ConstraintCast()) {
1001     Node* dom_cast = n-&gt;as_ConstraintCast()-&gt;dominating_cast(&amp;_igvn, this);
1002     // ConstraintCastNode::dominating_cast() uses node control input to determine domination.
1003     // Node control inputs don&#39;t necessarily agree with loop control info (due to
1004     // transformations happened in between), thus additional dominance check is needed
1005     // to keep loop info valid.
1006     if (dom_cast != NULL &amp;&amp; is_dominator(get_ctrl(dom_cast), get_ctrl(n))) {
1007       _igvn.replace_node(n, dom_cast);
1008       return dom_cast;
1009     }
1010   }
1011 
1012   // Determine if the Node has inputs from some local Phi.
1013   // Returns the block to clone thru.
1014   Node *n_blk = has_local_phi_input( n );
1015   if( !n_blk ) return n;
1016 
1017   // Do not clone the trip counter through on a CountedLoop
1018   // (messes up the canonical shape).
1019   if( n_blk-&gt;is_CountedLoop() &amp;&amp; n-&gt;Opcode() == Op_AddI ) return n;
1020 
1021   // Check for having no control input; not pinned.  Allow
1022   // dominating control.
1023   if (n-&gt;in(0)) {
1024     Node *dom = idom(n_blk);
1025     if (dom_lca(n-&gt;in(0), dom) != n-&gt;in(0)) {
1026       return n;
1027     }
1028   }
1029   // Policy: when is it profitable.  You must get more wins than
1030   // policy before it is considered profitable.  Policy is usually 0,
1031   // so 1 win is considered profitable.  Big merges will require big
1032   // cloning, so get a larger policy.
1033   int policy = n_blk-&gt;req() &gt;&gt; 2;
1034 
1035   // If the loop is a candidate for range check elimination,
1036   // delay splitting through it&#39;s phi until a later loop optimization
1037   if (n_blk-&gt;is_CountedLoop()) {
1038     IdealLoopTree *lp = get_loop(n_blk);
1039     if (lp &amp;&amp; lp-&gt;_rce_candidate) {
1040       return n;
1041     }
1042   }
1043 
1044   if (must_throttle_split_if()) return n;
1045 
1046   // Split &#39;n&#39; through the merge point if it is profitable
1047   Node *phi = split_thru_phi( n, n_blk, policy );
1048   if (!phi) return n;
1049 
1050   // Found a Phi to split thru!
1051   // Replace &#39;n&#39; with the new phi
1052   _igvn.replace_node( n, phi );
1053   // Moved a load around the loop, &#39;en-registering&#39; something.
1054   if (n_blk-&gt;is_Loop() &amp;&amp; n-&gt;is_Load() &amp;&amp;
1055       !phi-&gt;in(LoopNode::LoopBackControl)-&gt;is_Load())
1056     C-&gt;set_major_progress();
1057 
1058   return phi;
1059 }
1060 
1061 static bool merge_point_too_heavy(Compile* C, Node* region) {
1062   // Bail out if the region and its phis have too many users.
1063   int weight = 0;
1064   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
1065     weight += region-&gt;fast_out(i)-&gt;outcnt();
1066   }
1067   int nodes_left = C-&gt;max_node_limit() - C-&gt;live_nodes();
1068   if (weight * 8 &gt; nodes_left) {
1069     if (PrintOpto) {
1070       tty-&gt;print_cr(&quot;*** Split-if bails out:  %d nodes, region weight %d&quot;, C-&gt;unique(), weight);
1071     }
1072     return true;
1073   } else {
1074     return false;
1075   }
1076 }
1077 
1078 static bool merge_point_safe(Node* region) {
1079   // 4799512: Stop split_if_with_blocks from splitting a block with a ConvI2LNode
1080   // having a PhiNode input. This sidesteps the dangerous case where the split
1081   // ConvI2LNode may become TOP if the input Value() does not
1082   // overlap the ConvI2L range, leaving a node which may not dominate its
1083   // uses.
1084   // A better fix for this problem can be found in the BugTraq entry, but
1085   // expediency for Mantis demands this hack.
1086 #ifdef _LP64
1087   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
1088     Node* n = region-&gt;fast_out(i);
1089     if (n-&gt;is_Phi()) {
1090       for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1091         Node* m = n-&gt;fast_out(j);
1092         if (m-&gt;Opcode() == Op_ConvI2L)
1093           return false;
1094         if (m-&gt;is_CastII() &amp;&amp; m-&gt;isa_CastII()-&gt;has_range_check()) {
1095           return false;
1096         }
1097       }
1098     }
1099   }
1100 #endif
1101   return true;
1102 }
1103 
1104 
1105 //------------------------------place_near_use---------------------------------
1106 // Place some computation next to use but not inside inner loops.
1107 // For inner loop uses move it to the preheader area.
1108 Node *PhaseIdealLoop::place_near_use(Node *useblock) const {
1109   IdealLoopTree *u_loop = get_loop( useblock );
1110   if (u_loop-&gt;_irreducible) {
1111     return useblock;
1112   }
1113   if (u_loop-&gt;_child) {
1114     if (useblock == u_loop-&gt;_head &amp;&amp; u_loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1115       return u_loop-&gt;_head-&gt;in(LoopNode::EntryControl);
1116     }
1117     return useblock;
1118   }
1119   return u_loop-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1120 }
1121 
1122 
1123 bool PhaseIdealLoop::identical_backtoback_ifs(Node *n) {
1124   if (!n-&gt;is_If() || n-&gt;is_CountedLoopEnd()) {
1125     return false;
1126   }
1127   if (!n-&gt;in(0)-&gt;is_Region()) {
1128     return false;
1129   }
1130   Node* region = n-&gt;in(0);
1131   Node* dom = idom(region);
1132   if (!dom-&gt;is_If() || dom-&gt;in(1) != n-&gt;in(1)) {
1133     return false;
1134   }
1135   IfNode* dom_if = dom-&gt;as_If();
1136   Node* proj_true = dom_if-&gt;proj_out(1);
1137   Node* proj_false = dom_if-&gt;proj_out(0);
1138 
1139   for (uint i = 1; i &lt; region-&gt;req(); i++) {
1140     if (is_dominator(proj_true, region-&gt;in(i))) {
1141       continue;
1142     }
1143     if (is_dominator(proj_false, region-&gt;in(i))) {
1144       continue;
1145     }
1146     return false;
1147   }
1148 
1149   return true;
1150 }
1151 
1152 
1153 bool PhaseIdealLoop::can_split_if(Node* n_ctrl) {
1154   if (must_throttle_split_if()) {
1155     return false;
1156   }
1157 
1158   // Do not do &#39;split-if&#39; if irreducible loops are present.
1159   if (_has_irreducible_loops) {
1160     return false;
1161   }
1162 
1163   if (merge_point_too_heavy(C, n_ctrl)) {
1164     return false;
1165   }
1166 
1167   // Do not do &#39;split-if&#39; if some paths are dead.  First do dead code
1168   // elimination and then see if its still profitable.
1169   for (uint i = 1; i &lt; n_ctrl-&gt;req(); i++) {
1170     if (n_ctrl-&gt;in(i) == C-&gt;top()) {
1171       return false;
1172     }
1173   }
1174 
1175   // If trying to do a &#39;Split-If&#39; at the loop head, it is only
1176   // profitable if the cmp folds up on BOTH paths.  Otherwise we
1177   // risk peeling a loop forever.
1178 
1179   // CNC - Disabled for now.  Requires careful handling of loop
1180   // body selection for the cloned code.  Also, make sure we check
1181   // for any input path not being in the same loop as n_ctrl.  For
1182   // irreducible loops we cannot check for &#39;n_ctrl-&gt;is_Loop()&#39;
1183   // because the alternative loop entry points won&#39;t be converted
1184   // into LoopNodes.
1185   IdealLoopTree *n_loop = get_loop(n_ctrl);
1186   for (uint j = 1; j &lt; n_ctrl-&gt;req(); j++) {
1187     if (get_loop(n_ctrl-&gt;in(j)) != n_loop) {
1188       return false;
1189     }
1190   }
1191 
1192   // Check for safety of the merge point.
1193   if (!merge_point_safe(n_ctrl)) {
1194     return false;
1195   }
1196 
1197   return true;
1198 }
1199 
1200 // Detect if the node is the inner strip-mined loop
1201 // Return: NULL if it&#39;s not the case, or the exit of outer strip-mined loop
1202 static Node* is_inner_of_stripmined_loop(const Node* out) {
1203   Node* out_le = NULL;
1204 
1205   if (out-&gt;is_CountedLoopEnd()) {
1206       const CountedLoopNode* loop = out-&gt;as_CountedLoopEnd()-&gt;loopnode();
1207 
1208       if (loop != NULL &amp;&amp; loop-&gt;is_strip_mined()) {
1209         out_le = loop-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop()-&gt;outer_loop_exit();
1210       }
1211   }
1212 
1213   return out_le;
1214 }
1215 
1216 bool PhaseIdealLoop::flatten_array_element_type_check(Node *n) {
1217   // If the CmpP is a subtype check for a value that has just been
1218   // loaded from an array, the subtype check guarantees the value
1219   // can&#39;t be stored in a flattened array and the load of the value
1220   // happens with a flattened array check then: push the type check
1221   // through the phi of the flattened array check. This needs special
1222   // logic because the subtype check&#39;s input is not a phi but a
1223   // LoadKlass that must first be cloned through the phi.
1224   if (n-&gt;Opcode() != Op_CmpP) {
1225     return false;
1226   }
1227 
1228   Node* klassptr = n-&gt;in(1);
1229   Node* klasscon = n-&gt;in(2);
1230 
1231   if (klassptr-&gt;is_DecodeNarrowPtr()) {
1232     klassptr = klassptr-&gt;in(1);
1233   }
1234 
1235   if (klassptr-&gt;Opcode() != Op_LoadKlass &amp;&amp; klassptr-&gt;Opcode() != Op_LoadNKlass) {
1236     return false;
1237   }
1238 
1239   if (!klasscon-&gt;is_Con()) {
1240     return false;
1241   }
1242 
1243   Node* addr = klassptr-&gt;in(MemNode::Address);
1244 
1245   if (!addr-&gt;is_AddP()) {
1246     return false;
1247   }
1248 
1249   intptr_t offset;
1250   Node* obj = AddPNode::Ideal_base_and_offset(addr, &amp;_igvn, offset);
1251 
1252   if (obj == NULL) {
1253     return false;
1254   }
1255 
1256   assert(obj != NULL &amp;&amp; addr-&gt;in(AddPNode::Base) == addr-&gt;in(AddPNode::Address), &quot;malformed AddP?&quot;);
1257   if (obj-&gt;Opcode() == Op_CastPP) {
1258     obj = obj-&gt;in(1);
1259   }
1260 
1261   if (!obj-&gt;is_Phi()) {
1262     return false;
1263   }
1264 
1265   Node* region = obj-&gt;in(0);
1266 
1267   Node* phi = PhiNode::make_blank(region, n-&gt;in(1));
1268   for (uint i = 1; i &lt; region-&gt;req(); i++) {
1269     Node* in = obj-&gt;in(i);
1270     Node* ctrl = get_ctrl(in);
1271     if (addr-&gt;in(AddPNode::Base) != obj) {
1272       Node* cast = addr-&gt;in(AddPNode::Base);
1273       assert(cast-&gt;Opcode() == Op_CastPP &amp;&amp; cast-&gt;in(0) != NULL, &quot;inconsistent subgraph&quot;);
1274       Node* cast_clone = cast-&gt;clone();
1275       cast_clone-&gt;set_req(0, region-&gt;in(i));
1276       cast_clone-&gt;set_req(1, in);
1277       register_new_node(cast_clone, region-&gt;in(i));
1278       _igvn.set_type(cast_clone, cast_clone-&gt;Value(&amp;_igvn));
1279       in = cast_clone;
1280     }
1281     Node* addr_clone = addr-&gt;clone();
1282     addr_clone-&gt;set_req(AddPNode::Base, in);
1283     addr_clone-&gt;set_req(AddPNode::Address, in);
1284     register_new_node(addr_clone, ctrl);
1285     _igvn.set_type(addr_clone, addr_clone-&gt;Value(&amp;_igvn));
1286     Node* klassptr_clone = klassptr-&gt;clone();
1287     klassptr_clone-&gt;set_req(2, addr_clone);
1288     register_new_node(klassptr_clone, ctrl);
1289     _igvn.set_type(klassptr_clone, klassptr_clone-&gt;Value(&amp;_igvn));
1290     if (klassptr != n-&gt;in(1)) {
1291       Node* decode = n-&gt;in(1);
1292       assert(decode-&gt;is_DecodeNarrowPtr(), &quot;inconsistent subgraph&quot;);
1293       Node* decode_clone = decode-&gt;clone();
1294       decode_clone-&gt;set_req(1, klassptr_clone);
1295       register_new_node(decode_clone, ctrl);
1296       _igvn.set_type(decode_clone, decode_clone-&gt;Value(&amp;_igvn));
1297       klassptr_clone = decode_clone;
1298     }
1299     phi-&gt;set_req(i, klassptr_clone);
1300   }
1301   register_new_node(phi, region);
1302   Node* orig = n-&gt;in(1);
1303   _igvn.replace_input_of(n, 1, phi);
1304   split_if_with_blocks_post(n);
1305   if (n-&gt;outcnt() != 0) {
1306     _igvn.replace_input_of(n, 1, orig);
1307     _igvn.remove_dead_node(phi);
1308   }
1309   return true;
1310 }
1311 
1312 //------------------------------split_if_with_blocks_post----------------------
1313 // Do the real work in a non-recursive function.  CFG hackery wants to be
1314 // in the post-order, so it can dirty the I-DOM info and not use the dirtied
1315 // info.
1316 void PhaseIdealLoop::split_if_with_blocks_post(Node *n) {
1317 
1318   if (flatten_array_element_type_check(n)) {
1319     return;
1320   }
1321 
1322   // Cloning Cmp through Phi&#39;s involves the split-if transform.
1323   // FastLock is not used by an If
1324   if (n-&gt;is_Cmp() &amp;&amp; !n-&gt;is_FastLock()) {
1325     Node *n_ctrl = get_ctrl(n);
1326     // Determine if the Node has inputs from some local Phi.
1327     // Returns the block to clone thru.
1328     Node *n_blk = has_local_phi_input(n);
1329     if (n_blk != n_ctrl) {
1330       return;
1331     }
1332 
1333     if (!can_split_if(n_ctrl)) {
1334       return;
1335     }
1336 
1337     if (n-&gt;outcnt() != 1) {
1338       return; // Multiple bool&#39;s from 1 compare?
1339     }
1340     Node *bol = n-&gt;unique_out();
1341     assert(bol-&gt;is_Bool(), &quot;expect a bool here&quot;);
1342     if (bol-&gt;outcnt() != 1) {
1343       return;// Multiple branches from 1 compare?
1344     }
1345     Node *iff = bol-&gt;unique_out();
1346 
1347     // Check some safety conditions
1348     if (iff-&gt;is_If()) {        // Classic split-if?
1349       if (iff-&gt;in(0) != n_ctrl) {
1350         return; // Compare must be in same blk as if
1351       }
1352     } else if (iff-&gt;is_CMove()) { // Trying to split-up a CMOVE
1353       // Can&#39;t split CMove with different control edge.
1354       if (iff-&gt;in(0) != NULL &amp;&amp; iff-&gt;in(0) != n_ctrl ) {
1355         return;
1356       }
1357       if (get_ctrl(iff-&gt;in(2)) == n_ctrl ||
1358           get_ctrl(iff-&gt;in(3)) == n_ctrl) {
1359         return;                 // Inputs not yet split-up
1360       }
1361       if (get_loop(n_ctrl) != get_loop(get_ctrl(iff))) {
1362         return;                 // Loop-invar test gates loop-varying CMOVE
1363       }
1364     } else {
1365       return;  // some other kind of node, such as an Allocate
1366     }
1367 
1368     // When is split-if profitable?  Every &#39;win&#39; on means some control flow
1369     // goes dead, so it&#39;s almost always a win.
1370     int policy = 0;
1371     // Split compare &#39;n&#39; through the merge point if it is profitable
1372     Node *phi = split_thru_phi( n, n_ctrl, policy);
1373     if (!phi) {
1374       return;
1375     }
1376 
1377     // Found a Phi to split thru!
1378     // Replace &#39;n&#39; with the new phi
1379     _igvn.replace_node(n, phi);
1380 
1381     // Now split the bool up thru the phi
1382     Node *bolphi = split_thru_phi(bol, n_ctrl, -1);
1383     guarantee(bolphi != NULL, &quot;null boolean phi node&quot;);
1384 
1385     _igvn.replace_node(bol, bolphi);
1386     assert(iff-&gt;in(1) == bolphi, &quot;&quot;);
1387 
1388     if (bolphi-&gt;Value(&amp;_igvn)-&gt;singleton()) {
1389       return;
1390     }
1391 
1392     // Conditional-move?  Must split up now
1393     if (!iff-&gt;is_If()) {
1394       Node *cmovphi = split_thru_phi(iff, n_ctrl, -1);
1395       _igvn.replace_node(iff, cmovphi);
1396       return;
1397     }
1398 
1399     // Now split the IF
1400     do_split_if(iff);
1401     return;
1402   }
1403 
1404   // Two identical ifs back to back can be merged
1405   if (identical_backtoback_ifs(n) &amp;&amp; can_split_if(n-&gt;in(0))) {
1406     Node *n_ctrl = n-&gt;in(0);
1407     PhiNode* bolphi = PhiNode::make_blank(n_ctrl, n-&gt;in(1));
1408     IfNode* dom_if = idom(n_ctrl)-&gt;as_If();
1409     Node* proj_true = dom_if-&gt;proj_out(1);
1410     Node* proj_false = dom_if-&gt;proj_out(0);
1411     Node* con_true = _igvn.makecon(TypeInt::ONE);
1412     Node* con_false = _igvn.makecon(TypeInt::ZERO);
1413 
1414     for (uint i = 1; i &lt; n_ctrl-&gt;req(); i++) {
1415       if (is_dominator(proj_true, n_ctrl-&gt;in(i))) {
1416         bolphi-&gt;init_req(i, con_true);
1417       } else {
1418         assert(is_dominator(proj_false, n_ctrl-&gt;in(i)), &quot;bad if&quot;);
1419         bolphi-&gt;init_req(i, con_false);
1420       }
1421     }
1422     register_new_node(bolphi, n_ctrl);
1423     _igvn.replace_input_of(n, 1, bolphi);
1424 
1425     // Now split the IF
1426     do_split_if(n);
1427     return;
1428   }
1429 
1430   // Check for an IF ready to split; one that has its
1431   // condition codes input coming from a Phi at the block start.
1432   int n_op = n-&gt;Opcode();
1433 
1434   // Check for an IF being dominated by another IF same test
1435   if (n_op == Op_If ||
1436       n_op == Op_RangeCheck) {
1437     Node *bol = n-&gt;in(1);
1438     uint max = bol-&gt;outcnt();
1439     // Check for same test used more than once?
1440     if (max &gt; 1 &amp;&amp; bol-&gt;is_Bool()) {
1441       // Search up IDOMs to see if this IF is dominated.
1442       Node *cutoff = get_ctrl(bol);
1443 
1444       // Now search up IDOMs till cutoff, looking for a dominating test
1445       Node *prevdom = n;
1446       Node *dom = idom(prevdom);
1447       while (dom != cutoff) {
1448         if (dom-&gt;req() &gt; 1 &amp;&amp; dom-&gt;in(1) == bol &amp;&amp; prevdom-&gt;in(0) == dom) {
1449           // It&#39;s invalid to move control dependent data nodes in the inner
1450           // strip-mined loop, because:
1451           //  1) break validation of LoopNode::verify_strip_mined()
1452           //  2) move code with side-effect in strip-mined loop
1453           // Move to the exit of outer strip-mined loop in that case.
1454           Node* out_le = is_inner_of_stripmined_loop(dom);
1455           if (out_le != NULL) {
1456             prevdom = out_le;
1457           }
1458           // Replace the dominated test with an obvious true or false.
1459           // Place it on the IGVN worklist for later cleanup.
1460           C-&gt;set_major_progress();
1461           dominated_by(prevdom, n, false, true);
1462 #ifndef PRODUCT
1463           if( VerifyLoopOptimizations ) verify();
1464 #endif
1465           return;
1466         }
1467         prevdom = dom;
1468         dom = idom(prevdom);
1469       }
1470     }
1471   }
1472 
1473   // See if a shared loop-varying computation has no loop-varying uses.
1474   // Happens if something is only used for JVM state in uncommon trap exits,
1475   // like various versions of induction variable+offset.  Clone the
1476   // computation per usage to allow it to sink out of the loop.
1477   if (has_ctrl(n) &amp;&amp; !n-&gt;in(0)) {// n not dead and has no control edge (can float about)
1478     Node *n_ctrl = get_ctrl(n);
1479     IdealLoopTree *n_loop = get_loop(n_ctrl);
1480     if( n_loop != _ltree_root ) {
1481       DUIterator_Fast imax, i = n-&gt;fast_outs(imax);
1482       for (; i &lt; imax; i++) {
1483         Node* u = n-&gt;fast_out(i);
1484         if( !has_ctrl(u) )     break; // Found control user
1485         IdealLoopTree *u_loop = get_loop(get_ctrl(u));
1486         if( u_loop == n_loop ) break; // Found loop-varying use
1487         if( n_loop-&gt;is_member( u_loop ) ) break; // Found use in inner loop
1488         if( u-&gt;Opcode() == Op_Opaque1 ) break; // Found loop limit, bugfix for 4677003
1489       }
1490       bool did_break = (i &lt; imax);  // Did we break out of the previous loop?
1491       if (!did_break &amp;&amp; n-&gt;outcnt() &gt; 1) { // All uses in outer loops!
1492         Node *late_load_ctrl = NULL;
1493         if (n-&gt;is_Load()) {
1494           // If n is a load, get and save the result from get_late_ctrl(),
1495           // to be later used in calculating the control for n&#39;s clones.
1496           clear_dom_lca_tags();
1497           late_load_ctrl = get_late_ctrl(n, n_ctrl);
1498         }
1499         // If n is a load, and the late control is the same as the current
1500         // control, then the cloning of n is a pointless exercise, because
1501         // GVN will ensure that we end up where we started.
1502         if (!n-&gt;is_Load() || late_load_ctrl != n_ctrl) {
1503           for (DUIterator_Last jmin, j = n-&gt;last_outs(jmin); j &gt;= jmin; ) {
1504             Node *u = n-&gt;last_out(j); // Clone private computation per use
1505             _igvn.rehash_node_delayed(u);
1506             Node *x = n-&gt;clone(); // Clone computation
1507             Node *x_ctrl = NULL;
1508             if( u-&gt;is_Phi() ) {
1509               // Replace all uses of normal nodes.  Replace Phi uses
1510               // individually, so the separate Nodes can sink down
1511               // different paths.
1512               uint k = 1;
1513               while( u-&gt;in(k) != n ) k++;
1514               u-&gt;set_req( k, x );
1515               // x goes next to Phi input path
1516               x_ctrl = u-&gt;in(0)-&gt;in(k);
1517               --j;
1518             } else {              // Normal use
1519               // Replace all uses
1520               for( uint k = 0; k &lt; u-&gt;req(); k++ ) {
1521                 if( u-&gt;in(k) == n ) {
1522                   u-&gt;set_req( k, x );
1523                   --j;
1524                 }
1525               }
1526               x_ctrl = get_ctrl(u);
1527             }
1528 
1529             // Find control for &#39;x&#39; next to use but not inside inner loops.
1530             // For inner loop uses get the preheader area.
1531             x_ctrl = place_near_use(x_ctrl);
1532 
1533             if (n-&gt;is_Load()) {
1534               // For loads, add a control edge to a CFG node outside of the loop
1535               // to force them to not combine and return back inside the loop
1536               // during GVN optimization (4641526).
1537               //
1538               // Because we are setting the actual control input, factor in
1539               // the result from get_late_ctrl() so we respect any
1540               // anti-dependences. (6233005).
1541               x_ctrl = dom_lca(late_load_ctrl, x_ctrl);
1542 
1543               // Don&#39;t allow the control input to be a CFG splitting node.
1544               // Such nodes should only have ProjNodes as outs, e.g. IfNode
1545               // should only have IfTrueNode and IfFalseNode (4985384).
1546               x_ctrl = find_non_split_ctrl(x_ctrl);
1547 
1548               IdealLoopTree* x_loop = get_loop(x_ctrl);
1549               Node* x_head = x_loop-&gt;_head;
1550               if (x_head-&gt;is_Loop() &amp;&amp; (x_head-&gt;is_OuterStripMinedLoop() || x_head-&gt;as_Loop()-&gt;is_strip_mined()) &amp;&amp; is_dominator(n_ctrl, x_head)) {
1551                 // Anti dependence analysis is sometimes too
1552                 // conservative: a store in the outer strip mined loop
1553                 // can prevent a load from floating out of the outer
1554                 // strip mined loop but the load may not be referenced
1555                 // from the safepoint: loop strip mining verification
1556                 // code reports a problem in that case. Make sure the
1557                 // load is not moved in the outer strip mined loop in
1558                 // that case.
1559                 x_ctrl = x_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1560               }
1561               assert(dom_depth(n_ctrl) &lt;= dom_depth(x_ctrl), &quot;n is later than its clone&quot;);
1562 
1563               x-&gt;set_req(0, x_ctrl);
1564             }
1565             register_new_node(x, x_ctrl);
1566 
1567             // Some institutional knowledge is needed here: &#39;x&#39; is
1568             // yanked because if the optimizer runs GVN on it all the
1569             // cloned x&#39;s will common up and undo this optimization and
1570             // be forced back in the loop.
1571             // I tried setting control edges on the x&#39;s to force them to
1572             // not combine, but the matching gets worried when it tries
1573             // to fold a StoreP and an AddP together (as part of an
1574             // address expression) and the AddP and StoreP have
1575             // different controls.
1576             if (!x-&gt;is_Load() &amp;&amp; !x-&gt;is_DecodeNarrowPtr()) _igvn._worklist.yank(x);
1577           }
1578           _igvn.remove_dead_node(n);
1579         }
1580       }
1581     }
1582   }
1583 
1584   try_move_store_after_loop(n);
1585 
1586   // Remove multiple allocations of the same inline type
1587   if (n-&gt;is_InlineType()) {
1588     n-&gt;as_InlineType()-&gt;remove_redundant_allocations(&amp;_igvn, this);
1589     return; // n is now dead
1590   }
1591 
1592   // Check for Opaque2&#39;s who&#39;s loop has disappeared - who&#39;s input is in the
1593   // same loop nest as their output.  Remove &#39;em, they are no longer useful.
1594   if( n_op == Op_Opaque2 &amp;&amp;
1595       n-&gt;in(1) != NULL &amp;&amp;
1596       get_loop(get_ctrl(n)) == get_loop(get_ctrl(n-&gt;in(1))) ) {
1597     _igvn.replace_node( n, n-&gt;in(1) );
1598   }
1599 }
1600 
1601 //------------------------------split_if_with_blocks---------------------------
1602 // Check for aggressive application of &#39;split-if&#39; optimization,
1603 // using basic block level info.
1604 void PhaseIdealLoop::split_if_with_blocks(VectorSet &amp;visited, Node_Stack &amp;nstack) {
1605   Node* root = C-&gt;root();
1606   visited.set(root-&gt;_idx); // first, mark root as visited
1607   // Do pre-visit work for root
1608   Node* n   = split_if_with_blocks_pre(root);
1609   uint  cnt = n-&gt;outcnt();
1610   uint  i   = 0;
1611 
1612   while (true) {
1613     // Visit all children
1614     if (i &lt; cnt) {
1615       Node* use = n-&gt;raw_out(i);
1616       ++i;
1617       if (use-&gt;outcnt() != 0 &amp;&amp; !visited.test_set(use-&gt;_idx)) {
1618         // Now do pre-visit work for this use
1619         use = split_if_with_blocks_pre(use);
1620         nstack.push(n, i); // Save parent and next use&#39;s index.
1621         n   = use;         // Process all children of current use.
1622         cnt = use-&gt;outcnt();
1623         i   = 0;
1624       }
1625     }
1626     else {
1627       // All of n&#39;s children have been processed, complete post-processing.
1628       if (cnt != 0 &amp;&amp; !n-&gt;is_Con()) {
1629         assert(has_node(n), &quot;no dead nodes&quot;);
1630         split_if_with_blocks_post(n);
1631       }
1632       if (must_throttle_split_if()) {
1633         nstack.clear();
1634       }
1635       if (nstack.is_empty()) {
1636         // Finished all nodes on stack.
1637         break;
1638       }
1639       // Get saved parent node and next use&#39;s index. Visit the rest of uses.
1640       n   = nstack.node();
1641       cnt = n-&gt;outcnt();
1642       i   = nstack.index();
1643       nstack.pop();
1644     }
1645   }
1646 }
1647 
1648 
1649 //=============================================================================
1650 //
1651 //                   C L O N E   A   L O O P   B O D Y
1652 //
1653 
1654 //------------------------------clone_iff--------------------------------------
1655 // Passed in a Phi merging (recursively) some nearly equivalent Bool/Cmps.
1656 // &quot;Nearly&quot; because all Nodes have been cloned from the original in the loop,
1657 // but the fall-in edges to the Cmp are different.  Clone bool/Cmp pairs
1658 // through the Phi recursively, and return a Bool.
1659 Node* PhaseIdealLoop::clone_iff(PhiNode *phi, IdealLoopTree *loop) {
1660 
1661   // Convert this Phi into a Phi merging Bools
1662   uint i;
1663   for (i = 1; i &lt; phi-&gt;req(); i++) {
1664     Node *b = phi-&gt;in(i);
1665     if (b-&gt;is_Phi()) {
1666       _igvn.replace_input_of(phi, i, clone_iff(b-&gt;as_Phi(), loop));
1667     } else {
1668       assert(b-&gt;is_Bool() || b-&gt;Opcode() == Op_Opaque4, &quot;&quot;);
1669     }
1670   }
1671 
1672   Node* n = phi-&gt;in(1);
1673   Node* sample_opaque = NULL;
1674   Node *sample_bool = NULL;
1675   if (n-&gt;Opcode() == Op_Opaque4) {
1676     sample_opaque = n;
1677     sample_bool = n-&gt;in(1);
1678     assert(sample_bool-&gt;is_Bool(), &quot;wrong type&quot;);
1679   } else {
1680     sample_bool = n;
1681   }
1682   Node *sample_cmp = sample_bool-&gt;in(1);
1683 
1684   // Make Phis to merge the Cmp&#39;s inputs.
1685   PhiNode *phi1 = new PhiNode(phi-&gt;in(0), Type::TOP);
1686   PhiNode *phi2 = new PhiNode(phi-&gt;in(0), Type::TOP);
1687   for (i = 1; i &lt; phi-&gt;req(); i++) {
1688     Node *n1 = sample_opaque == NULL ? phi-&gt;in(i)-&gt;in(1)-&gt;in(1) : phi-&gt;in(i)-&gt;in(1)-&gt;in(1)-&gt;in(1);
1689     Node *n2 = sample_opaque == NULL ? phi-&gt;in(i)-&gt;in(1)-&gt;in(2) : phi-&gt;in(i)-&gt;in(1)-&gt;in(1)-&gt;in(2);
1690     phi1-&gt;set_req(i, n1);
1691     phi2-&gt;set_req(i, n2);
1692     phi1-&gt;set_type(phi1-&gt;type()-&gt;meet_speculative(n1-&gt;bottom_type()));
1693     phi2-&gt;set_type(phi2-&gt;type()-&gt;meet_speculative(n2-&gt;bottom_type()));
1694   }
1695   // See if these Phis have been made before.
1696   // Register with optimizer
1697   Node *hit1 = _igvn.hash_find_insert(phi1);
1698   if (hit1) {                   // Hit, toss just made Phi
1699     _igvn.remove_dead_node(phi1); // Remove new phi
1700     assert(hit1-&gt;is_Phi(), &quot;&quot; );
1701     phi1 = (PhiNode*)hit1;      // Use existing phi
1702   } else {                      // Miss
1703     _igvn.register_new_node_with_optimizer(phi1);
1704   }
1705   Node *hit2 = _igvn.hash_find_insert(phi2);
1706   if (hit2) {                   // Hit, toss just made Phi
1707     _igvn.remove_dead_node(phi2); // Remove new phi
1708     assert(hit2-&gt;is_Phi(), &quot;&quot; );
1709     phi2 = (PhiNode*)hit2;      // Use existing phi
1710   } else {                      // Miss
1711     _igvn.register_new_node_with_optimizer(phi2);
1712   }
1713   // Register Phis with loop/block info
1714   set_ctrl(phi1, phi-&gt;in(0));
1715   set_ctrl(phi2, phi-&gt;in(0));
1716   // Make a new Cmp
1717   Node *cmp = sample_cmp-&gt;clone();
1718   cmp-&gt;set_req(1, phi1);
1719   cmp-&gt;set_req(2, phi2);
1720   _igvn.register_new_node_with_optimizer(cmp);
1721   set_ctrl(cmp, phi-&gt;in(0));
1722 
1723   // Make a new Bool
1724   Node *b = sample_bool-&gt;clone();
1725   b-&gt;set_req(1,cmp);
1726   _igvn.register_new_node_with_optimizer(b);
1727   set_ctrl(b, phi-&gt;in(0));
1728 
1729   if (sample_opaque != NULL) {
1730     Node* opaque = sample_opaque-&gt;clone();
1731     opaque-&gt;set_req(1, b);
1732     _igvn.register_new_node_with_optimizer(opaque);
1733     set_ctrl(opaque, phi-&gt;in(0));
1734     return opaque;
1735   }
1736 
1737   assert(b-&gt;is_Bool(), &quot;&quot;);
1738   return b;
1739 }
1740 
1741 //------------------------------clone_bool-------------------------------------
1742 // Passed in a Phi merging (recursively) some nearly equivalent Bool/Cmps.
1743 // &quot;Nearly&quot; because all Nodes have been cloned from the original in the loop,
1744 // but the fall-in edges to the Cmp are different.  Clone bool/Cmp pairs
1745 // through the Phi recursively, and return a Bool.
1746 CmpNode *PhaseIdealLoop::clone_bool( PhiNode *phi, IdealLoopTree *loop ) {
1747   uint i;
1748   // Convert this Phi into a Phi merging Bools
1749   for( i = 1; i &lt; phi-&gt;req(); i++ ) {
1750     Node *b = phi-&gt;in(i);
1751     if( b-&gt;is_Phi() ) {
1752       _igvn.replace_input_of(phi, i, clone_bool( b-&gt;as_Phi(), loop ));
1753     } else {
1754       assert( b-&gt;is_Cmp() || b-&gt;is_top(), &quot;inputs are all Cmp or TOP&quot; );
1755     }
1756   }
1757 
1758   Node *sample_cmp = phi-&gt;in(1);
1759 
1760   // Make Phis to merge the Cmp&#39;s inputs.
1761   PhiNode *phi1 = new PhiNode( phi-&gt;in(0), Type::TOP );
1762   PhiNode *phi2 = new PhiNode( phi-&gt;in(0), Type::TOP );
1763   for( uint j = 1; j &lt; phi-&gt;req(); j++ ) {
1764     Node *cmp_top = phi-&gt;in(j); // Inputs are all Cmp or TOP
1765     Node *n1, *n2;
1766     if( cmp_top-&gt;is_Cmp() ) {
1767       n1 = cmp_top-&gt;in(1);
1768       n2 = cmp_top-&gt;in(2);
1769     } else {
1770       n1 = n2 = cmp_top;
1771     }
1772     phi1-&gt;set_req( j, n1 );
1773     phi2-&gt;set_req( j, n2 );
1774     phi1-&gt;set_type(phi1-&gt;type()-&gt;meet_speculative(n1-&gt;bottom_type()));
1775     phi2-&gt;set_type(phi2-&gt;type()-&gt;meet_speculative(n2-&gt;bottom_type()));
1776   }
1777 
1778   // See if these Phis have been made before.
1779   // Register with optimizer
1780   Node *hit1 = _igvn.hash_find_insert(phi1);
1781   if( hit1 ) {                  // Hit, toss just made Phi
1782     _igvn.remove_dead_node(phi1); // Remove new phi
1783     assert( hit1-&gt;is_Phi(), &quot;&quot; );
1784     phi1 = (PhiNode*)hit1;      // Use existing phi
1785   } else {                      // Miss
1786     _igvn.register_new_node_with_optimizer(phi1);
1787   }
1788   Node *hit2 = _igvn.hash_find_insert(phi2);
1789   if( hit2 ) {                  // Hit, toss just made Phi
1790     _igvn.remove_dead_node(phi2); // Remove new phi
1791     assert( hit2-&gt;is_Phi(), &quot;&quot; );
1792     phi2 = (PhiNode*)hit2;      // Use existing phi
1793   } else {                      // Miss
1794     _igvn.register_new_node_with_optimizer(phi2);
1795   }
1796   // Register Phis with loop/block info
1797   set_ctrl(phi1, phi-&gt;in(0));
1798   set_ctrl(phi2, phi-&gt;in(0));
1799   // Make a new Cmp
1800   Node *cmp = sample_cmp-&gt;clone();
1801   cmp-&gt;set_req( 1, phi1 );
1802   cmp-&gt;set_req( 2, phi2 );
1803   _igvn.register_new_node_with_optimizer(cmp);
1804   set_ctrl(cmp, phi-&gt;in(0));
1805 
1806   assert( cmp-&gt;is_Cmp(), &quot;&quot; );
1807   return (CmpNode*)cmp;
1808 }
1809 
1810 //------------------------------sink_use---------------------------------------
1811 // If &#39;use&#39; was in the loop-exit block, it now needs to be sunk
1812 // below the post-loop merge point.
1813 void PhaseIdealLoop::sink_use( Node *use, Node *post_loop ) {
1814   if (!use-&gt;is_CFG() &amp;&amp; get_ctrl(use) == post_loop-&gt;in(2)) {
1815     set_ctrl(use, post_loop);
1816     for (DUIterator j = use-&gt;outs(); use-&gt;has_out(j); j++)
1817       sink_use(use-&gt;out(j), post_loop);
1818   }
1819 }
1820 
1821 void PhaseIdealLoop::clone_loop_handle_data_uses(Node* old, Node_List &amp;old_new,
1822                                                  IdealLoopTree* loop, IdealLoopTree* outer_loop,
1823                                                  Node_List*&amp; split_if_set, Node_List*&amp; split_bool_set,
1824                                                  Node_List*&amp; split_cex_set, Node_List&amp; worklist,
1825                                                  uint new_counter, CloneLoopMode mode) {
1826   Node* nnn = old_new[old-&gt;_idx];
1827   // Copy uses to a worklist, so I can munge the def-use info
1828   // with impunity.
1829   for (DUIterator_Fast jmax, j = old-&gt;fast_outs(jmax); j &lt; jmax; j++)
1830     worklist.push(old-&gt;fast_out(j));
1831 
1832   while( worklist.size() ) {
1833     Node *use = worklist.pop();
1834     if (!has_node(use))  continue; // Ignore dead nodes
1835     if (use-&gt;in(0) == C-&gt;top())  continue;
1836     IdealLoopTree *use_loop = get_loop( has_ctrl(use) ? get_ctrl(use) : use );
1837     // Check for data-use outside of loop - at least one of OLD or USE
1838     // must not be a CFG node.
1839 #ifdef ASSERT
1840     if (loop-&gt;_head-&gt;as_Loop()-&gt;is_strip_mined() &amp;&amp; outer_loop-&gt;is_member(use_loop) &amp;&amp; !loop-&gt;is_member(use_loop) &amp;&amp; old_new[use-&gt;_idx] == NULL) {
1841       Node* sfpt = loop-&gt;_head-&gt;as_CountedLoop()-&gt;outer_safepoint();
1842       assert(mode != IgnoreStripMined, &quot;incorrect cloning mode&quot;);
1843       assert((mode == ControlAroundStripMined &amp;&amp; use == sfpt) || !use-&gt;is_reachable_from_root(), &quot;missed a node&quot;);
1844     }
1845 #endif
1846     if (!loop-&gt;is_member(use_loop) &amp;&amp; !outer_loop-&gt;is_member(use_loop) &amp;&amp; (!old-&gt;is_CFG() || !use-&gt;is_CFG())) {
1847 
1848       // If the Data use is an IF, that means we have an IF outside of the
1849       // loop that is switching on a condition that is set inside of the
1850       // loop.  Happens if people set a loop-exit flag; then test the flag
1851       // in the loop to break the loop, then test is again outside of the
1852       // loop to determine which way the loop exited.
1853       // Loop predicate If node connects to Bool node through Opaque1 node.
1854       if (use-&gt;is_If() || use-&gt;is_CMove() || C-&gt;is_predicate_opaq(use) || use-&gt;Opcode() == Op_Opaque4) {
1855         // Since this code is highly unlikely, we lazily build the worklist
1856         // of such Nodes to go split.
1857         if (!split_if_set) {
<a name="1" id="anc1"></a><span class="line-modified">1858           ResourceArea *area = Thread::current()-&gt;resource_area();</span>
<span class="line-removed">1859           split_if_set = new Node_List(area);</span>
1860         }
1861         split_if_set-&gt;push(use);
1862       }
1863       if (use-&gt;is_Bool()) {
1864         if (!split_bool_set) {
<a name="2" id="anc2"></a><span class="line-modified">1865           ResourceArea *area = Thread::current()-&gt;resource_area();</span>
<span class="line-removed">1866           split_bool_set = new Node_List(area);</span>
1867         }
1868         split_bool_set-&gt;push(use);
1869       }
1870       if (use-&gt;Opcode() == Op_CreateEx) {
1871         if (!split_cex_set) {
<a name="3" id="anc3"></a><span class="line-modified">1872           ResourceArea *area = Thread::current()-&gt;resource_area();</span>
<span class="line-removed">1873           split_cex_set = new Node_List(area);</span>
1874         }
1875         split_cex_set-&gt;push(use);
1876       }
1877 
1878 
1879       // Get &quot;block&quot; use is in
1880       uint idx = 0;
1881       while( use-&gt;in(idx) != old ) idx++;
1882       Node *prev = use-&gt;is_CFG() ? use : get_ctrl(use);
1883       assert(!loop-&gt;is_member(get_loop(prev)) &amp;&amp; !outer_loop-&gt;is_member(get_loop(prev)), &quot;&quot; );
1884       Node *cfg = prev-&gt;_idx &gt;= new_counter
1885         ? prev-&gt;in(2)
1886         : idom(prev);
1887       if( use-&gt;is_Phi() )     // Phi use is in prior block
1888         cfg = prev-&gt;in(idx);  // NOT in block of Phi itself
1889       if (cfg-&gt;is_top()) {    // Use is dead?
1890         _igvn.replace_input_of(use, idx, C-&gt;top());
1891         continue;
1892       }
1893 
1894       // If use is referenced through control edge... (idx == 0)
1895       if (mode == IgnoreStripMined &amp;&amp; idx == 0) {
1896         LoopNode *head = loop-&gt;_head-&gt;as_Loop();
1897         if (head-&gt;is_strip_mined() &amp;&amp; is_dominator(head-&gt;outer_loop_exit(), prev)) {
1898           // That node is outside the inner loop, leave it outside the
1899           // outer loop as well to not confuse verification code.
1900           assert(!loop-&gt;_parent-&gt;is_member(use_loop), &quot;should be out of the outer loop&quot;);
1901           _igvn.replace_input_of(use, 0, head-&gt;outer_loop_exit());
1902           continue;
1903         }
1904       }
1905 
1906       while(!outer_loop-&gt;is_member(get_loop(cfg))) {
1907         prev = cfg;
1908         cfg = cfg-&gt;_idx &gt;= new_counter ? cfg-&gt;in(2) : idom(cfg);
1909       }
1910       // If the use occurs after merging several exits from the loop, then
1911       // old value must have dominated all those exits.  Since the same old
1912       // value was used on all those exits we did not need a Phi at this
1913       // merge point.  NOW we do need a Phi here.  Each loop exit value
1914       // is now merged with the peeled body exit; each exit gets its own
1915       // private Phi and those Phis need to be merged here.
1916       Node *phi;
1917       if( prev-&gt;is_Region() ) {
1918         if( idx == 0 ) {      // Updating control edge?
1919           phi = prev;         // Just use existing control
1920         } else {              // Else need a new Phi
1921           phi = PhiNode::make( prev, old );
1922           // Now recursively fix up the new uses of old!
1923           for( uint i = 1; i &lt; prev-&gt;req(); i++ ) {
1924             worklist.push(phi); // Onto worklist once for each &#39;old&#39; input
1925           }
1926         }
1927       } else {
1928         // Get new RegionNode merging old and new loop exits
1929         prev = old_new[prev-&gt;_idx];
1930         assert( prev, &quot;just made this in step 7&quot; );
1931         if( idx == 0) {      // Updating control edge?
1932           phi = prev;         // Just use existing control
1933         } else {              // Else need a new Phi
1934           // Make a new Phi merging data values properly
1935           phi = PhiNode::make( prev, old );
1936           phi-&gt;set_req( 1, nnn );
1937         }
1938       }
1939       // If inserting a new Phi, check for prior hits
1940       if( idx != 0 ) {
1941         Node *hit = _igvn.hash_find_insert(phi);
1942         if( hit == NULL ) {
1943           _igvn.register_new_node_with_optimizer(phi); // Register new phi
1944         } else {                                      // or
1945           // Remove the new phi from the graph and use the hit
1946           _igvn.remove_dead_node(phi);
1947           phi = hit;                                  // Use existing phi
1948         }
1949         set_ctrl(phi, prev);
1950       }
1951       // Make &#39;use&#39; use the Phi instead of the old loop body exit value
1952       _igvn.replace_input_of(use, idx, phi);
1953       if( use-&gt;_idx &gt;= new_counter ) { // If updating new phis
1954         // Not needed for correctness, but prevents a weak assert
1955         // in AddPNode from tripping (when we end up with different
1956         // base &amp; derived Phis that will become the same after
1957         // IGVN does CSE).
1958         Node *hit = _igvn.hash_find_insert(use);
1959         if( hit )             // Go ahead and re-hash for hits.
1960           _igvn.replace_node( use, hit );
1961       }
1962 
1963       // If &#39;use&#39; was in the loop-exit block, it now needs to be sunk
1964       // below the post-loop merge point.
1965       sink_use( use, prev );
1966     }
1967   }
1968 }
1969 
1970 static void clone_outer_loop_helper(Node* n, const IdealLoopTree *loop, const IdealLoopTree* outer_loop,
1971                                     const Node_List &amp;old_new, Unique_Node_List&amp; wq, PhaseIdealLoop* phase,
1972                                     bool check_old_new) {
1973   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1974     Node* u = n-&gt;fast_out(j);
1975     assert(check_old_new || old_new[u-&gt;_idx] == NULL, &quot;shouldn&#39;t have been cloned&quot;);
1976     if (!u-&gt;is_CFG() &amp;&amp; (!check_old_new || old_new[u-&gt;_idx] == NULL)) {
1977       Node* c = phase-&gt;get_ctrl(u);
1978       IdealLoopTree* u_loop = phase-&gt;get_loop(c);
1979       assert(!loop-&gt;is_member(u_loop), &quot;can be in outer loop or out of both loops only&quot;);
1980       if (outer_loop-&gt;is_member(u_loop)) {
1981         wq.push(u);
1982       }
1983     }
1984   }
1985 }
1986 
1987 void PhaseIdealLoop::clone_outer_loop(LoopNode* head, CloneLoopMode mode, IdealLoopTree *loop,
1988                                       IdealLoopTree* outer_loop, int dd, Node_List &amp;old_new,
1989                                       Node_List&amp; extra_data_nodes) {
1990   if (head-&gt;is_strip_mined() &amp;&amp; mode != IgnoreStripMined) {
1991     CountedLoopNode* cl = head-&gt;as_CountedLoop();
1992     Node* l = cl-&gt;outer_loop();
1993     Node* tail = cl-&gt;outer_loop_tail();
1994     IfNode* le = cl-&gt;outer_loop_end();
1995     Node* sfpt = cl-&gt;outer_safepoint();
1996     CountedLoopEndNode* cle = cl-&gt;loopexit();
1997     CountedLoopNode* new_cl = old_new[cl-&gt;_idx]-&gt;as_CountedLoop();
1998     CountedLoopEndNode* new_cle = new_cl-&gt;as_CountedLoop()-&gt;loopexit_or_null();
1999     Node* cle_out = cle-&gt;proj_out(false);
2000 
2001     Node* new_sfpt = NULL;
2002     Node* new_cle_out = cle_out-&gt;clone();
2003     old_new.map(cle_out-&gt;_idx, new_cle_out);
2004     if (mode == CloneIncludesStripMined) {
2005       // clone outer loop body
2006       Node* new_l = l-&gt;clone();
2007       Node* new_tail = tail-&gt;clone();
2008       IfNode* new_le = le-&gt;clone()-&gt;as_If();
2009       new_sfpt = sfpt-&gt;clone();
2010 
2011       set_loop(new_l, outer_loop-&gt;_parent);
2012       set_idom(new_l, new_l-&gt;in(LoopNode::EntryControl), dd);
2013       set_loop(new_cle_out, outer_loop-&gt;_parent);
2014       set_idom(new_cle_out, new_cle, dd);
2015       set_loop(new_sfpt, outer_loop-&gt;_parent);
2016       set_idom(new_sfpt, new_cle_out, dd);
2017       set_loop(new_le, outer_loop-&gt;_parent);
2018       set_idom(new_le, new_sfpt, dd);
2019       set_loop(new_tail, outer_loop-&gt;_parent);
2020       set_idom(new_tail, new_le, dd);
2021       set_idom(new_cl, new_l, dd);
2022 
2023       old_new.map(l-&gt;_idx, new_l);
2024       old_new.map(tail-&gt;_idx, new_tail);
2025       old_new.map(le-&gt;_idx, new_le);
2026       old_new.map(sfpt-&gt;_idx, new_sfpt);
2027 
2028       new_l-&gt;set_req(LoopNode::LoopBackControl, new_tail);
2029       new_l-&gt;set_req(0, new_l);
2030       new_tail-&gt;set_req(0, new_le);
2031       new_le-&gt;set_req(0, new_sfpt);
2032       new_sfpt-&gt;set_req(0, new_cle_out);
2033       new_cle_out-&gt;set_req(0, new_cle);
2034       new_cl-&gt;set_req(LoopNode::EntryControl, new_l);
2035 
2036       _igvn.register_new_node_with_optimizer(new_l);
2037       _igvn.register_new_node_with_optimizer(new_tail);
2038       _igvn.register_new_node_with_optimizer(new_le);
2039     } else {
2040       Node *newhead = old_new[loop-&gt;_head-&gt;_idx];
2041       newhead-&gt;as_Loop()-&gt;clear_strip_mined();
2042       _igvn.replace_input_of(newhead, LoopNode::EntryControl, newhead-&gt;in(LoopNode::EntryControl)-&gt;in(LoopNode::EntryControl));
2043       set_idom(newhead, newhead-&gt;in(LoopNode::EntryControl), dd);
2044     }
2045     // Look at data node that were assigned a control in the outer
2046     // loop: they are kept in the outer loop by the safepoint so start
2047     // from the safepoint node&#39;s inputs.
2048     IdealLoopTree* outer_loop = get_loop(l);
2049     Node_Stack stack(2);
2050     stack.push(sfpt, 1);
2051     uint new_counter = C-&gt;unique();
2052     while (stack.size() &gt; 0) {
2053       Node* n = stack.node();
2054       uint i = stack.index();
2055       while (i &lt; n-&gt;req() &amp;&amp;
2056              (n-&gt;in(i) == NULL ||
2057               !has_ctrl(n-&gt;in(i)) ||
2058               get_loop(get_ctrl(n-&gt;in(i))) != outer_loop ||
2059               (old_new[n-&gt;in(i)-&gt;_idx] != NULL &amp;&amp; old_new[n-&gt;in(i)-&gt;_idx]-&gt;_idx &gt;= new_counter))) {
2060         i++;
2061       }
2062       if (i &lt; n-&gt;req()) {
2063         stack.set_index(i+1);
2064         stack.push(n-&gt;in(i), 0);
2065       } else {
2066         assert(old_new[n-&gt;_idx] == NULL || n == sfpt || old_new[n-&gt;_idx]-&gt;_idx &lt; new_counter, &quot;no clone yet&quot;);
2067         Node* m = n == sfpt ? new_sfpt : n-&gt;clone();
2068         if (m != NULL) {
2069           for (uint i = 0; i &lt; n-&gt;req(); i++) {
2070             if (m-&gt;in(i) != NULL &amp;&amp; old_new[m-&gt;in(i)-&gt;_idx] != NULL) {
2071               m-&gt;set_req(i, old_new[m-&gt;in(i)-&gt;_idx]);
2072             }
2073           }
2074         } else {
2075           assert(n == sfpt &amp;&amp; mode != CloneIncludesStripMined, &quot;where&#39;s the safepoint clone?&quot;);
2076         }
2077         if (n != sfpt) {
2078           extra_data_nodes.push(n);
2079           _igvn.register_new_node_with_optimizer(m);
2080           assert(get_ctrl(n) == cle_out, &quot;what other control?&quot;);
2081           set_ctrl(m, new_cle_out);
2082           old_new.map(n-&gt;_idx, m);
2083         }
2084         stack.pop();
2085       }
2086     }
2087     if (mode == CloneIncludesStripMined) {
2088       _igvn.register_new_node_with_optimizer(new_sfpt);
2089       _igvn.register_new_node_with_optimizer(new_cle_out);
2090     }
2091     // Some other transformation may have pessimistically assign some
2092     // data nodes to the outer loop. Set their control so they are out
2093     // of the outer loop.
2094     ResourceMark rm;
2095     Unique_Node_List wq;
2096     for (uint i = 0; i &lt; extra_data_nodes.size(); i++) {
2097       Node* old = extra_data_nodes.at(i);
2098       clone_outer_loop_helper(old, loop, outer_loop, old_new, wq, this, true);
2099     }
2100     Node* new_ctrl = cl-&gt;outer_loop_exit();
2101     assert(get_loop(new_ctrl) != outer_loop, &quot;must be out of the loop nest&quot;);
2102     for (uint i = 0; i &lt; wq.size(); i++) {
2103       Node* n = wq.at(i);
2104       set_ctrl(n, new_ctrl);
2105       clone_outer_loop_helper(n, loop, outer_loop, old_new, wq, this, false);
2106     }
2107   } else {
2108     Node *newhead = old_new[loop-&gt;_head-&gt;_idx];
2109     set_idom(newhead, newhead-&gt;in(LoopNode::EntryControl), dd);
2110   }
2111 }
2112 
2113 //------------------------------clone_loop-------------------------------------
2114 //
2115 //                   C L O N E   A   L O O P   B O D Y
2116 //
2117 // This is the basic building block of the loop optimizations.  It clones an
2118 // entire loop body.  It makes an old_new loop body mapping; with this mapping
2119 // you can find the new-loop equivalent to an old-loop node.  All new-loop
2120 // nodes are exactly equal to their old-loop counterparts, all edges are the
2121 // same.  All exits from the old-loop now have a RegionNode that merges the
2122 // equivalent new-loop path.  This is true even for the normal &quot;loop-exit&quot;
2123 // condition.  All uses of loop-invariant old-loop values now come from (one
2124 // or more) Phis that merge their new-loop equivalents.
2125 //
2126 // This operation leaves the graph in an illegal state: there are two valid
2127 // control edges coming from the loop pre-header to both loop bodies.  I&#39;ll
2128 // definitely have to hack the graph after running this transform.
2129 //
2130 // From this building block I will further edit edges to perform loop peeling
2131 // or loop unrolling or iteration splitting (Range-Check-Elimination), etc.
2132 //
2133 // Parameter side_by_size_idom:
2134 //   When side_by_size_idom is NULL, the dominator tree is constructed for
2135 //      the clone loop to dominate the original.  Used in construction of
2136 //      pre-main-post loop sequence.
2137 //   When nonnull, the clone and original are side-by-side, both are
2138 //      dominated by the side_by_side_idom node.  Used in construction of
2139 //      unswitched loops.
2140 void PhaseIdealLoop::clone_loop( IdealLoopTree *loop, Node_List &amp;old_new, int dd,
2141                                 CloneLoopMode mode, Node* side_by_side_idom) {
2142 
2143   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
2144   head-&gt;verify_strip_mined(1);
2145 
2146   if (C-&gt;do_vector_loop() &amp;&amp; PrintOpto) {
2147     const char* mname = C-&gt;method()-&gt;name()-&gt;as_quoted_ascii();
2148     if (mname != NULL) {
2149       tty-&gt;print(&quot;PhaseIdealLoop::clone_loop: for vectorize method %s\n&quot;, mname);
2150     }
2151   }
2152 
2153   CloneMap&amp; cm = C-&gt;clone_map();
2154   Dict* dict = cm.dict();
2155   if (C-&gt;do_vector_loop()) {
2156     cm.set_clone_idx(cm.max_gen()+1);
2157 #ifndef PRODUCT
2158     if (PrintOpto) {
2159       tty-&gt;print_cr(&quot;PhaseIdealLoop::clone_loop: _clone_idx %d&quot;, cm.clone_idx());
2160       loop-&gt;dump_head();
2161     }
2162 #endif
2163   }
2164 
2165   // Step 1: Clone the loop body.  Make the old-&gt;new mapping.
2166   uint i;
2167   for( i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2168     Node *old = loop-&gt;_body.at(i);
2169     Node *nnn = old-&gt;clone();
2170     old_new.map( old-&gt;_idx, nnn );
2171     if (C-&gt;do_vector_loop()) {
2172       cm.verify_insert_and_clone(old, nnn, cm.clone_idx());
2173     }
2174     _igvn.register_new_node_with_optimizer(nnn);
2175   }
2176 
2177   IdealLoopTree* outer_loop = (head-&gt;is_strip_mined() &amp;&amp; mode != IgnoreStripMined) ? get_loop(head-&gt;as_CountedLoop()-&gt;outer_loop()) : loop;
2178 
2179   // Step 2: Fix the edges in the new body.  If the old input is outside the
2180   // loop use it.  If the old input is INside the loop, use the corresponding
2181   // new node instead.
2182   for( i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2183     Node *old = loop-&gt;_body.at(i);
2184     Node *nnn = old_new[old-&gt;_idx];
2185     // Fix CFG/Loop controlling the new node
2186     if (has_ctrl(old)) {
2187       set_ctrl(nnn, old_new[get_ctrl(old)-&gt;_idx]);
2188     } else {
2189       set_loop(nnn, outer_loop-&gt;_parent);
2190       if (old-&gt;outcnt() &gt; 0) {
2191         set_idom( nnn, old_new[idom(old)-&gt;_idx], dd );
2192       }
2193     }
2194     // Correct edges to the new node
2195     for( uint j = 0; j &lt; nnn-&gt;req(); j++ ) {
2196         Node *n = nnn-&gt;in(j);
2197         if( n ) {
2198           IdealLoopTree *old_in_loop = get_loop( has_ctrl(n) ? get_ctrl(n) : n );
2199           if( loop-&gt;is_member( old_in_loop ) )
2200             nnn-&gt;set_req(j, old_new[n-&gt;_idx]);
2201         }
2202     }
2203     _igvn.hash_find_insert(nnn);
2204   }
2205 
<a name="4" id="anc4"></a><span class="line-modified">2206   ResourceArea *area = Thread::current()-&gt;resource_area();</span>
<span class="line-removed">2207   Node_List extra_data_nodes(area); // data nodes in the outer strip mined loop</span>
2208   clone_outer_loop(head, mode, loop, outer_loop, dd, old_new, extra_data_nodes);
2209 
2210   // Step 3: Now fix control uses.  Loop varying control uses have already
2211   // been fixed up (as part of all input edges in Step 2).  Loop invariant
2212   // control uses must be either an IfFalse or an IfTrue.  Make a merge
2213   // point to merge the old and new IfFalse/IfTrue nodes; make the use
2214   // refer to this.
<a name="5" id="anc5"></a><span class="line-modified">2215   Node_List worklist(area);</span>
2216   uint new_counter = C-&gt;unique();
2217   for( i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2218     Node* old = loop-&gt;_body.at(i);
2219     if( !old-&gt;is_CFG() ) continue;
2220 
2221     // Copy uses to a worklist, so I can munge the def-use info
2222     // with impunity.
2223     for (DUIterator_Fast jmax, j = old-&gt;fast_outs(jmax); j &lt; jmax; j++)
2224       worklist.push(old-&gt;fast_out(j));
2225 
2226     while( worklist.size() ) {  // Visit all uses
2227       Node *use = worklist.pop();
2228       if (!has_node(use))  continue; // Ignore dead nodes
2229       IdealLoopTree *use_loop = get_loop( has_ctrl(use) ? get_ctrl(use) : use );
2230       if( !loop-&gt;is_member( use_loop ) &amp;&amp; use-&gt;is_CFG() ) {
2231         // Both OLD and USE are CFG nodes here.
2232         assert( use-&gt;is_Proj(), &quot;&quot; );
2233         Node* nnn = old_new[old-&gt;_idx];
2234 
2235         Node* newuse = NULL;
2236         if (head-&gt;is_strip_mined() &amp;&amp; mode != IgnoreStripMined) {
2237           CountedLoopNode* cl = head-&gt;as_CountedLoop();
2238           CountedLoopEndNode* cle = cl-&gt;loopexit();
2239           Node* cle_out = cle-&gt;proj_out_or_null(false);
2240           if (use == cle_out) {
2241             IfNode* le = cl-&gt;outer_loop_end();
2242             use = le-&gt;proj_out(false);
2243             use_loop = get_loop(use);
2244             if (mode == CloneIncludesStripMined) {
2245               nnn = old_new[le-&gt;_idx];
2246             } else {
2247               newuse = old_new[cle_out-&gt;_idx];
2248             }
2249           }
2250         }
2251         if (newuse == NULL) {
2252           newuse = use-&gt;clone();
2253         }
2254 
2255         // Clone the loop exit control projection
2256         if (C-&gt;do_vector_loop()) {
2257           cm.verify_insert_and_clone(use, newuse, cm.clone_idx());
2258         }
2259         newuse-&gt;set_req(0,nnn);
2260         _igvn.register_new_node_with_optimizer(newuse);
2261         set_loop(newuse, use_loop);
2262         set_idom(newuse, nnn, dom_depth(nnn) + 1 );
2263 
2264         // We need a Region to merge the exit from the peeled body and the
2265         // exit from the old loop body.
2266         RegionNode *r = new RegionNode(3);
2267         // Map the old use to the new merge point
2268         old_new.map( use-&gt;_idx, r );
2269         uint dd_r = MIN2(dom_depth(newuse),dom_depth(use));
2270         assert( dd_r &gt;= dom_depth(dom_lca(newuse,use)), &quot;&quot; );
2271 
2272         // The original user of &#39;use&#39; uses &#39;r&#39; instead.
2273         for (DUIterator_Last lmin, l = use-&gt;last_outs(lmin); l &gt;= lmin;) {
2274           Node* useuse = use-&gt;last_out(l);
2275           _igvn.rehash_node_delayed(useuse);
2276           uint uses_found = 0;
2277           if( useuse-&gt;in(0) == use ) {
2278             useuse-&gt;set_req(0, r);
2279             uses_found++;
2280             if( useuse-&gt;is_CFG() ) {
2281               // This is not a dom_depth &gt; dd_r because when new
2282               // control flow is constructed by a loop opt, a node and
2283               // its dominator can end up at the same dom_depth
2284               assert(dom_depth(useuse) &gt;= dd_r, &quot;&quot;);
2285               set_idom(useuse, r, dom_depth(useuse));
2286             }
2287           }
2288           for( uint k = 1; k &lt; useuse-&gt;req(); k++ ) {
2289             if( useuse-&gt;in(k) == use ) {
2290               useuse-&gt;set_req(k, r);
2291               uses_found++;
2292               if (useuse-&gt;is_Loop() &amp;&amp; k == LoopNode::EntryControl) {
2293                 // This is not a dom_depth &gt; dd_r because when new
2294                 // control flow is constructed by a loop opt, a node
2295                 // and its dominator can end up at the same dom_depth
2296                 assert(dom_depth(useuse) &gt;= dd_r , &quot;&quot;);
2297                 set_idom(useuse, r, dom_depth(useuse));
2298               }
2299             }
2300           }
2301           l -= uses_found;    // we deleted 1 or more copies of this edge
2302         }
2303 
2304         // Now finish up &#39;r&#39;
2305         r-&gt;set_req( 1, newuse );
2306         r-&gt;set_req( 2,    use );
2307         _igvn.register_new_node_with_optimizer(r);
2308         set_loop(r, use_loop);
2309         set_idom(r, !side_by_side_idom ? newuse-&gt;in(0) : side_by_side_idom, dd_r);
2310       } // End of if a loop-exit test
2311     }
2312   }
2313 
2314   // Step 4: If loop-invariant use is not control, it must be dominated by a
2315   // loop exit IfFalse/IfTrue.  Find &quot;proper&quot; loop exit.  Make a Region
2316   // there if needed.  Make a Phi there merging old and new used values.
2317   Node_List *split_if_set = NULL;
2318   Node_List *split_bool_set = NULL;
2319   Node_List *split_cex_set = NULL;
2320   for( i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2321     Node* old = loop-&gt;_body.at(i);
2322     clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,
2323                                 split_bool_set, split_cex_set, worklist, new_counter,
2324                                 mode);
2325   }
2326 
2327   for (i = 0; i &lt; extra_data_nodes.size(); i++) {
2328     Node* old = extra_data_nodes.at(i);
2329     clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,
2330                                 split_bool_set, split_cex_set, worklist, new_counter,
2331                                 mode);
2332   }
2333 
2334   // Check for IFs that need splitting/cloning.  Happens if an IF outside of
2335   // the loop uses a condition set in the loop.  The original IF probably
2336   // takes control from one or more OLD Regions (which in turn get from NEW
2337   // Regions).  In any case, there will be a set of Phis for each merge point
2338   // from the IF up to where the original BOOL def exists the loop.
2339   if (split_if_set) {
2340     while (split_if_set-&gt;size()) {
2341       Node *iff = split_if_set-&gt;pop();
2342       if (iff-&gt;in(1)-&gt;is_Phi()) {
2343         Node *b = clone_iff(iff-&gt;in(1)-&gt;as_Phi(), loop);
2344         _igvn.replace_input_of(iff, 1, b);
2345       }
2346     }
2347   }
2348   if (split_bool_set) {
2349     while (split_bool_set-&gt;size()) {
2350       Node *b = split_bool_set-&gt;pop();
2351       Node *phi = b-&gt;in(1);
2352       assert(phi-&gt;is_Phi(), &quot;&quot;);
2353       CmpNode *cmp = clone_bool((PhiNode*)phi, loop);
2354       _igvn.replace_input_of(b, 1, cmp);
2355     }
2356   }
2357   if (split_cex_set) {
2358     while (split_cex_set-&gt;size()) {
2359       Node *b = split_cex_set-&gt;pop();
2360       assert(b-&gt;in(0)-&gt;is_Region(), &quot;&quot;);
2361       assert(b-&gt;in(1)-&gt;is_Phi(), &quot;&quot;);
2362       assert(b-&gt;in(0)-&gt;in(0) == b-&gt;in(1)-&gt;in(0), &quot;&quot;);
2363       split_up(b, b-&gt;in(0), NULL);
2364     }
2365   }
2366 
2367 }
2368 
2369 
2370 //---------------------- stride_of_possible_iv -------------------------------------
2371 // Looks for an iff/bool/comp with one operand of the compare
2372 // being a cycle involving an add and a phi,
2373 // with an optional truncation (left-shift followed by a right-shift)
2374 // of the add. Returns zero if not an iv.
2375 int PhaseIdealLoop::stride_of_possible_iv(Node* iff) {
2376   Node* trunc1 = NULL;
2377   Node* trunc2 = NULL;
2378   const TypeInt* ttype = NULL;
2379   if (!iff-&gt;is_If() || iff-&gt;in(1) == NULL || !iff-&gt;in(1)-&gt;is_Bool()) {
2380     return 0;
2381   }
2382   BoolNode* bl = iff-&gt;in(1)-&gt;as_Bool();
2383   Node* cmp = bl-&gt;in(1);
2384   if (!cmp || (cmp-&gt;Opcode() != Op_CmpI &amp;&amp; cmp-&gt;Opcode() != Op_CmpU)) {
2385     return 0;
2386   }
2387   // Must have an invariant operand
2388   if (is_member(get_loop(iff), get_ctrl(cmp-&gt;in(2)))) {
2389     return 0;
2390   }
2391   Node* add2 = NULL;
2392   Node* cmp1 = cmp-&gt;in(1);
2393   if (cmp1-&gt;is_Phi()) {
2394     // (If (Bool (CmpX phi:(Phi ...(Optional-trunc(AddI phi add2))) )))
2395     Node* phi = cmp1;
2396     for (uint i = 1; i &lt; phi-&gt;req(); i++) {
2397       Node* in = phi-&gt;in(i);
2398       Node* add = CountedLoopNode::match_incr_with_optional_truncation(in,
2399                                 &amp;trunc1, &amp;trunc2, &amp;ttype);
2400       if (add &amp;&amp; add-&gt;in(1) == phi) {
2401         add2 = add-&gt;in(2);
2402         break;
2403       }
2404     }
2405   } else {
2406     // (If (Bool (CmpX addtrunc:(Optional-trunc((AddI (Phi ...addtrunc...) add2)) )))
2407     Node* addtrunc = cmp1;
2408     Node* add = CountedLoopNode::match_incr_with_optional_truncation(addtrunc,
2409                                 &amp;trunc1, &amp;trunc2, &amp;ttype);
2410     if (add &amp;&amp; add-&gt;in(1)-&gt;is_Phi()) {
2411       Node* phi = add-&gt;in(1);
2412       for (uint i = 1; i &lt; phi-&gt;req(); i++) {
2413         if (phi-&gt;in(i) == addtrunc) {
2414           add2 = add-&gt;in(2);
2415           break;
2416         }
2417       }
2418     }
2419   }
2420   if (add2 != NULL) {
2421     const TypeInt* add2t = _igvn.type(add2)-&gt;is_int();
2422     if (add2t-&gt;is_con()) {
2423       return add2t-&gt;get_con();
2424     }
2425   }
2426   return 0;
2427 }
2428 
2429 
2430 //---------------------- stay_in_loop -------------------------------------
2431 // Return the (unique) control output node that&#39;s in the loop (if it exists.)
2432 Node* PhaseIdealLoop::stay_in_loop( Node* n, IdealLoopTree *loop) {
2433   Node* unique = NULL;
2434   if (!n) return NULL;
2435   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2436     Node* use = n-&gt;fast_out(i);
2437     if (!has_ctrl(use) &amp;&amp; loop-&gt;is_member(get_loop(use))) {
2438       if (unique != NULL) {
2439         return NULL;
2440       }
2441       unique = use;
2442     }
2443   }
2444   return unique;
2445 }
2446 
2447 //------------------------------ register_node -------------------------------------
2448 // Utility to register node &quot;n&quot; with PhaseIdealLoop
2449 void PhaseIdealLoop::register_node(Node* n, IdealLoopTree *loop, Node* pred, int ddepth) {
2450   _igvn.register_new_node_with_optimizer(n);
2451   loop-&gt;_body.push(n);
2452   if (n-&gt;is_CFG()) {
2453     set_loop(n, loop);
2454     set_idom(n, pred, ddepth);
2455   } else {
2456     set_ctrl(n, pred);
2457   }
2458 }
2459 
2460 //------------------------------ proj_clone -------------------------------------
2461 // Utility to create an if-projection
2462 ProjNode* PhaseIdealLoop::proj_clone(ProjNode* p, IfNode* iff) {
2463   ProjNode* c = p-&gt;clone()-&gt;as_Proj();
2464   c-&gt;set_req(0, iff);
2465   return c;
2466 }
2467 
2468 //------------------------------ short_circuit_if -------------------------------------
2469 // Force the iff control output to be the live_proj
2470 Node* PhaseIdealLoop::short_circuit_if(IfNode* iff, ProjNode* live_proj) {
2471   guarantee(live_proj != NULL, &quot;null projection&quot;);
2472   int proj_con = live_proj-&gt;_con;
2473   assert(proj_con == 0 || proj_con == 1, &quot;false or true projection&quot;);
2474   Node *con = _igvn.intcon(proj_con);
2475   set_ctrl(con, C-&gt;root());
2476   if (iff) {
2477     iff-&gt;set_req(1, con);
2478   }
2479   return con;
2480 }
2481 
2482 //------------------------------ insert_if_before_proj -------------------------------------
2483 // Insert a new if before an if projection (* - new node)
2484 //
2485 // before
2486 //           if(test)
2487 //           /     \
2488 //          v       v
2489 //    other-proj   proj (arg)
2490 //
2491 // after
2492 //           if(test)
2493 //           /     \
2494 //          /       v
2495 //         |      * proj-clone
2496 //         v          |
2497 //    other-proj      v
2498 //                * new_if(relop(cmp[IU](left,right)))
2499 //                  /  \
2500 //                 v    v
2501 //         * new-proj  proj
2502 //         (returned)
2503 //
2504 ProjNode* PhaseIdealLoop::insert_if_before_proj(Node* left, bool Signed, BoolTest::mask relop, Node* right, ProjNode* proj) {
2505   IfNode* iff = proj-&gt;in(0)-&gt;as_If();
2506   IdealLoopTree *loop = get_loop(proj);
2507   ProjNode *other_proj = iff-&gt;proj_out(!proj-&gt;is_IfTrue())-&gt;as_Proj();
2508   int ddepth = dom_depth(proj);
2509 
2510   _igvn.rehash_node_delayed(iff);
2511   _igvn.rehash_node_delayed(proj);
2512 
2513   proj-&gt;set_req(0, NULL);  // temporary disconnect
2514   ProjNode* proj2 = proj_clone(proj, iff);
2515   register_node(proj2, loop, iff, ddepth);
2516 
2517   Node* cmp = Signed ? (Node*) new CmpINode(left, right) : (Node*) new CmpUNode(left, right);
2518   register_node(cmp, loop, proj2, ddepth);
2519 
2520   BoolNode* bol = new BoolNode(cmp, relop);
2521   register_node(bol, loop, proj2, ddepth);
2522 
2523   int opcode = iff-&gt;Opcode();
2524   assert(opcode == Op_If || opcode == Op_RangeCheck, &quot;unexpected opcode&quot;);
2525   IfNode* new_if = (opcode == Op_If) ? new IfNode(proj2, bol, iff-&gt;_prob, iff-&gt;_fcnt):
2526     new RangeCheckNode(proj2, bol, iff-&gt;_prob, iff-&gt;_fcnt);
2527   register_node(new_if, loop, proj2, ddepth);
2528 
2529   proj-&gt;set_req(0, new_if); // reattach
2530   set_idom(proj, new_if, ddepth);
2531 
2532   ProjNode* new_exit = proj_clone(other_proj, new_if)-&gt;as_Proj();
2533   guarantee(new_exit != NULL, &quot;null exit node&quot;);
2534   register_node(new_exit, get_loop(other_proj), new_if, ddepth);
2535 
2536   return new_exit;
2537 }
2538 
2539 //------------------------------ insert_region_before_proj -------------------------------------
2540 // Insert a region before an if projection (* - new node)
2541 //
2542 // before
2543 //           if(test)
2544 //          /      |
2545 //         v       |
2546 //       proj      v
2547 //               other-proj
2548 //
2549 // after
2550 //           if(test)
2551 //          /      |
2552 //         v       |
2553 // * proj-clone    v
2554 //         |     other-proj
2555 //         v
2556 // * new-region
2557 //         |
2558 //         v
2559 // *      dum_if
2560 //       /     \
2561 //      v       \
2562 // * dum-proj    v
2563 //              proj
2564 //
2565 RegionNode* PhaseIdealLoop::insert_region_before_proj(ProjNode* proj) {
2566   IfNode* iff = proj-&gt;in(0)-&gt;as_If();
2567   IdealLoopTree *loop = get_loop(proj);
2568   ProjNode *other_proj = iff-&gt;proj_out(!proj-&gt;is_IfTrue())-&gt;as_Proj();
2569   int ddepth = dom_depth(proj);
2570 
2571   _igvn.rehash_node_delayed(iff);
2572   _igvn.rehash_node_delayed(proj);
2573 
2574   proj-&gt;set_req(0, NULL);  // temporary disconnect
2575   ProjNode* proj2 = proj_clone(proj, iff);
2576   register_node(proj2, loop, iff, ddepth);
2577 
2578   RegionNode* reg = new RegionNode(2);
2579   reg-&gt;set_req(1, proj2);
2580   register_node(reg, loop, iff, ddepth);
2581 
2582   IfNode* dum_if = new IfNode(reg, short_circuit_if(NULL, proj), iff-&gt;_prob, iff-&gt;_fcnt);
2583   register_node(dum_if, loop, reg, ddepth);
2584 
2585   proj-&gt;set_req(0, dum_if); // reattach
2586   set_idom(proj, dum_if, ddepth);
2587 
2588   ProjNode* dum_proj = proj_clone(other_proj, dum_if);
2589   register_node(dum_proj, loop, dum_if, ddepth);
2590 
2591   return reg;
2592 }
2593 
2594 //------------------------------ insert_cmpi_loop_exit -------------------------------------
2595 // Clone a signed compare loop exit from an unsigned compare and
2596 // insert it before the unsigned cmp on the stay-in-loop path.
2597 // All new nodes inserted in the dominator tree between the original
2598 // if and it&#39;s projections.  The original if test is replaced with
2599 // a constant to force the stay-in-loop path.
2600 //
2601 // This is done to make sure that the original if and it&#39;s projections
2602 // still dominate the same set of control nodes, that the ctrl() relation
2603 // from data nodes to them is preserved, and that their loop nesting is
2604 // preserved.
2605 //
2606 // before
2607 //          if(i &lt;u limit)    unsigned compare loop exit
2608 //         /       |
2609 //        v        v
2610 //   exit-proj   stay-in-loop-proj
2611 //
2612 // after
2613 //          if(stay-in-loop-const)  original if
2614 //         /       |
2615 //        /        v
2616 //       /  if(i &lt;  limit)    new signed test
2617 //      /  /       |
2618 //     /  /        v
2619 //    /  /  if(i &lt;u limit)    new cloned unsigned test
2620 //   /  /   /      |
2621 //   v  v  v       |
2622 //    region       |
2623 //        |        |
2624 //      dum-if     |
2625 //     /  |        |
2626 // ether  |        |
2627 //        v        v
2628 //   exit-proj   stay-in-loop-proj
2629 //
2630 IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree *loop) {
2631   const bool Signed   = true;
2632   const bool Unsigned = false;
2633 
2634   BoolNode* bol = if_cmpu-&gt;in(1)-&gt;as_Bool();
2635   if (bol-&gt;_test._test != BoolTest::lt) return NULL;
2636   CmpNode* cmpu = bol-&gt;in(1)-&gt;as_Cmp();
2637   if (cmpu-&gt;Opcode() != Op_CmpU) return NULL;
2638   int stride = stride_of_possible_iv(if_cmpu);
2639   if (stride == 0) return NULL;
2640 
2641   Node* lp_proj = stay_in_loop(if_cmpu, loop);
2642   guarantee(lp_proj != NULL, &quot;null loop node&quot;);
2643 
2644   ProjNode* lp_continue = lp_proj-&gt;as_Proj();
2645   ProjNode* lp_exit     = if_cmpu-&gt;proj_out(!lp_continue-&gt;is_IfTrue())-&gt;as_Proj();
2646 
2647   Node* limit = NULL;
2648   if (stride &gt; 0) {
2649     limit = cmpu-&gt;in(2);
2650   } else {
2651     limit = _igvn.makecon(TypeInt::ZERO);
2652     set_ctrl(limit, C-&gt;root());
2653   }
2654   // Create a new region on the exit path
2655   RegionNode* reg = insert_region_before_proj(lp_exit);
2656   guarantee(reg != NULL, &quot;null region node&quot;);
2657 
2658   // Clone the if-cmpu-true-false using a signed compare
2659   BoolTest::mask rel_i = stride &gt; 0 ? bol-&gt;_test._test : BoolTest::ge;
2660   ProjNode* cmpi_exit = insert_if_before_proj(cmpu-&gt;in(1), Signed, rel_i, limit, lp_continue);
2661   reg-&gt;add_req(cmpi_exit);
2662 
2663   // Clone the if-cmpu-true-false
2664   BoolTest::mask rel_u = bol-&gt;_test._test;
2665   ProjNode* cmpu_exit = insert_if_before_proj(cmpu-&gt;in(1), Unsigned, rel_u, cmpu-&gt;in(2), lp_continue);
2666   reg-&gt;add_req(cmpu_exit);
2667 
2668   // Force original if to stay in loop.
2669   short_circuit_if(if_cmpu, lp_continue);
2670 
2671   return cmpi_exit-&gt;in(0)-&gt;as_If();
2672 }
2673 
2674 //------------------------------ remove_cmpi_loop_exit -------------------------------------
2675 // Remove a previously inserted signed compare loop exit.
2676 void PhaseIdealLoop::remove_cmpi_loop_exit(IfNode* if_cmp, IdealLoopTree *loop) {
2677   Node* lp_proj = stay_in_loop(if_cmp, loop);
2678   assert(if_cmp-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
2679          stay_in_loop(lp_proj, loop)-&gt;is_If() &amp;&amp;
2680          stay_in_loop(lp_proj, loop)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpU, &quot;inserted cmpi before cmpu&quot;);
2681   Node *con = _igvn.makecon(lp_proj-&gt;is_IfTrue() ? TypeInt::ONE : TypeInt::ZERO);
2682   set_ctrl(con, C-&gt;root());
2683   if_cmp-&gt;set_req(1, con);
2684 }
2685 
2686 //------------------------------ scheduled_nodelist -------------------------------------
2687 // Create a post order schedule of nodes that are in the
2688 // &quot;member&quot; set.  The list is returned in &quot;sched&quot;.
2689 // The first node in &quot;sched&quot; is the loop head, followed by
2690 // nodes which have no inputs in the &quot;member&quot; set, and then
2691 // followed by the nodes that have an immediate input dependence
2692 // on a node in &quot;sched&quot;.
2693 void PhaseIdealLoop::scheduled_nodelist( IdealLoopTree *loop, VectorSet&amp; member, Node_List &amp;sched ) {
2694 
2695   assert(member.test(loop-&gt;_head-&gt;_idx), &quot;loop head must be in member set&quot;);
<a name="6" id="anc6"></a><span class="line-modified">2696   Arena *a = Thread::current()-&gt;resource_area();</span>
<span class="line-modified">2697   VectorSet visited(a);</span>
<span class="line-removed">2698   Node_Stack nstack(a, loop-&gt;_body.size());</span>
2699 
2700   Node* n  = loop-&gt;_head;  // top of stack is cached in &quot;n&quot;
2701   uint idx = 0;
2702   visited.set(n-&gt;_idx);
2703 
2704   // Initially push all with no inputs from within member set
2705   for(uint i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2706     Node *elt = loop-&gt;_body.at(i);
2707     if (member.test(elt-&gt;_idx)) {
2708       bool found = false;
2709       for (uint j = 0; j &lt; elt-&gt;req(); j++) {
2710         Node* def = elt-&gt;in(j);
2711         if (def &amp;&amp; member.test(def-&gt;_idx) &amp;&amp; def != elt) {
2712           found = true;
2713           break;
2714         }
2715       }
2716       if (!found &amp;&amp; elt != loop-&gt;_head) {
2717         nstack.push(n, idx);
2718         n = elt;
2719         assert(!visited.test(n-&gt;_idx), &quot;not seen yet&quot;);
2720         visited.set(n-&gt;_idx);
2721       }
2722     }
2723   }
2724 
2725   // traverse out&#39;s that are in the member set
2726   while (true) {
2727     if (idx &lt; n-&gt;outcnt()) {
2728       Node* use = n-&gt;raw_out(idx);
2729       idx++;
2730       if (!visited.test_set(use-&gt;_idx)) {
2731         if (member.test(use-&gt;_idx)) {
2732           nstack.push(n, idx);
2733           n = use;
2734           idx = 0;
2735         }
2736       }
2737     } else {
2738       // All outputs processed
2739       sched.push(n);
2740       if (nstack.is_empty()) break;
2741       n   = nstack.node();
2742       idx = nstack.index();
2743       nstack.pop();
2744     }
2745   }
2746 }
2747 
2748 
2749 //------------------------------ has_use_in_set -------------------------------------
2750 // Has a use in the vector set
2751 bool PhaseIdealLoop::has_use_in_set( Node* n, VectorSet&amp; vset ) {
2752   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2753     Node* use = n-&gt;fast_out(j);
2754     if (vset.test(use-&gt;_idx)) {
2755       return true;
2756     }
2757   }
2758   return false;
2759 }
2760 
2761 
2762 //------------------------------ has_use_internal_to_set -------------------------------------
2763 // Has use internal to the vector set (ie. not in a phi at the loop head)
2764 bool PhaseIdealLoop::has_use_internal_to_set( Node* n, VectorSet&amp; vset, IdealLoopTree *loop ) {
2765   Node* head  = loop-&gt;_head;
2766   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2767     Node* use = n-&gt;fast_out(j);
2768     if (vset.test(use-&gt;_idx) &amp;&amp; !(use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == head)) {
2769       return true;
2770     }
2771   }
2772   return false;
2773 }
2774 
2775 
2776 //------------------------------ clone_for_use_outside_loop -------------------------------------
2777 // clone &quot;n&quot; for uses that are outside of loop
2778 int PhaseIdealLoop::clone_for_use_outside_loop( IdealLoopTree *loop, Node* n, Node_List&amp; worklist ) {
2779   int cloned = 0;
2780   assert(worklist.size() == 0, &quot;should be empty&quot;);
2781   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2782     Node* use = n-&gt;fast_out(j);
2783     if( !loop-&gt;is_member(get_loop(has_ctrl(use) ? get_ctrl(use) : use)) ) {
2784       worklist.push(use);
2785     }
2786   }
2787   while( worklist.size() ) {
2788     Node *use = worklist.pop();
2789     if (!has_node(use) || use-&gt;in(0) == C-&gt;top()) continue;
2790     uint j;
2791     for (j = 0; j &lt; use-&gt;req(); j++) {
2792       if (use-&gt;in(j) == n) break;
2793     }
2794     assert(j &lt; use-&gt;req(), &quot;must be there&quot;);
2795 
2796     // clone &quot;n&quot; and insert it between the inputs of &quot;n&quot; and the use outside the loop
2797     Node* n_clone = n-&gt;clone();
2798     _igvn.replace_input_of(use, j, n_clone);
2799     cloned++;
2800     Node* use_c;
2801     if (!use-&gt;is_Phi()) {
2802       use_c = has_ctrl(use) ? get_ctrl(use) : use-&gt;in(0);
2803     } else {
2804       // Use in a phi is considered a use in the associated predecessor block
2805       use_c = use-&gt;in(0)-&gt;in(j);
2806     }
2807     set_ctrl(n_clone, use_c);
2808     assert(!loop-&gt;is_member(get_loop(use_c)), &quot;should be outside loop&quot;);
2809     get_loop(use_c)-&gt;_body.push(n_clone);
2810     _igvn.register_new_node_with_optimizer(n_clone);
2811 #ifndef PRODUCT
2812     if (TracePartialPeeling) {
2813       tty-&gt;print_cr(&quot;loop exit cloning old: %d new: %d newbb: %d&quot;, n-&gt;_idx, n_clone-&gt;_idx, get_ctrl(n_clone)-&gt;_idx);
2814     }
2815 #endif
2816   }
2817   return cloned;
2818 }
2819 
2820 
2821 //------------------------------ clone_for_special_use_inside_loop -------------------------------------
2822 // clone &quot;n&quot; for special uses that are in the not_peeled region.
2823 // If these def-uses occur in separate blocks, the code generator
2824 // marks the method as not compilable.  For example, if a &quot;BoolNode&quot;
2825 // is in a different basic block than the &quot;IfNode&quot; that uses it, then
2826 // the compilation is aborted in the code generator.
2827 void PhaseIdealLoop::clone_for_special_use_inside_loop( IdealLoopTree *loop, Node* n,
2828                                                         VectorSet&amp; not_peel, Node_List&amp; sink_list, Node_List&amp; worklist ) {
2829   if (n-&gt;is_Phi() || n-&gt;is_Load()) {
2830     return;
2831   }
2832   assert(worklist.size() == 0, &quot;should be empty&quot;);
2833   for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2834     Node* use = n-&gt;fast_out(j);
2835     if ( not_peel.test(use-&gt;_idx) &amp;&amp;
2836          (use-&gt;is_If() || use-&gt;is_CMove() || use-&gt;is_Bool()) &amp;&amp;
2837          use-&gt;in(1) == n)  {
2838       worklist.push(use);
2839     }
2840   }
2841   if (worklist.size() &gt; 0) {
2842     // clone &quot;n&quot; and insert it between inputs of &quot;n&quot; and the use
2843     Node* n_clone = n-&gt;clone();
2844     loop-&gt;_body.push(n_clone);
2845     _igvn.register_new_node_with_optimizer(n_clone);
2846     set_ctrl(n_clone, get_ctrl(n));
2847     sink_list.push(n_clone);
2848     not_peel.set(n_clone-&gt;_idx);
2849 #ifndef PRODUCT
2850     if (TracePartialPeeling) {
2851       tty-&gt;print_cr(&quot;special not_peeled cloning old: %d new: %d&quot;, n-&gt;_idx, n_clone-&gt;_idx);
2852     }
2853 #endif
2854     while( worklist.size() ) {
2855       Node *use = worklist.pop();
2856       _igvn.rehash_node_delayed(use);
2857       for (uint j = 1; j &lt; use-&gt;req(); j++) {
2858         if (use-&gt;in(j) == n) {
2859           use-&gt;set_req(j, n_clone);
2860         }
2861       }
2862     }
2863   }
2864 }
2865 
2866 
2867 //------------------------------ insert_phi_for_loop -------------------------------------
2868 // Insert phi(lp_entry_val, back_edge_val) at use-&gt;in(idx) for loop lp if phi does not already exist
2869 void PhaseIdealLoop::insert_phi_for_loop( Node* use, uint idx, Node* lp_entry_val, Node* back_edge_val, LoopNode* lp ) {
2870   Node *phi = PhiNode::make(lp, back_edge_val);
2871   phi-&gt;set_req(LoopNode::EntryControl, lp_entry_val);
2872   // Use existing phi if it already exists
2873   Node *hit = _igvn.hash_find_insert(phi);
2874   if( hit == NULL ) {
2875     _igvn.register_new_node_with_optimizer(phi);
2876     set_ctrl(phi, lp);
2877   } else {
2878     // Remove the new phi from the graph and use the hit
2879     _igvn.remove_dead_node(phi);
2880     phi = hit;
2881   }
2882   _igvn.replace_input_of(use, idx, phi);
2883 }
2884 
2885 #ifdef ASSERT
2886 //------------------------------ is_valid_loop_partition -------------------------------------
2887 // Validate the loop partition sets: peel and not_peel
2888 bool PhaseIdealLoop::is_valid_loop_partition( IdealLoopTree *loop, VectorSet&amp; peel, Node_List&amp; peel_list,
2889                                               VectorSet&amp; not_peel ) {
2890   uint i;
2891   // Check that peel_list entries are in the peel set
2892   for (i = 0; i &lt; peel_list.size(); i++) {
2893     if (!peel.test(peel_list.at(i)-&gt;_idx)) {
2894       return false;
2895     }
2896   }
2897   // Check at loop members are in one of peel set or not_peel set
2898   for (i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2899     Node *def  = loop-&gt;_body.at(i);
2900     uint di = def-&gt;_idx;
2901     // Check that peel set elements are in peel_list
2902     if (peel.test(di)) {
2903       if (not_peel.test(di)) {
2904         return false;
2905       }
2906       // Must be in peel_list also
2907       bool found = false;
2908       for (uint j = 0; j &lt; peel_list.size(); j++) {
2909         if (peel_list.at(j)-&gt;_idx == di) {
2910           found = true;
2911           break;
2912         }
2913       }
2914       if (!found) {
2915         return false;
2916       }
2917     } else if (not_peel.test(di)) {
2918       if (peel.test(di)) {
2919         return false;
2920       }
2921     } else {
2922       return false;
2923     }
2924   }
2925   return true;
2926 }
2927 
2928 //------------------------------ is_valid_clone_loop_exit_use -------------------------------------
2929 // Ensure a use outside of loop is of the right form
2930 bool PhaseIdealLoop::is_valid_clone_loop_exit_use( IdealLoopTree *loop, Node* use, uint exit_idx) {
2931   Node *use_c = has_ctrl(use) ? get_ctrl(use) : use;
2932   return (use-&gt;is_Phi() &amp;&amp;
2933           use_c-&gt;is_Region() &amp;&amp; use_c-&gt;req() == 3 &amp;&amp;
2934           (use_c-&gt;in(exit_idx)-&gt;Opcode() == Op_IfTrue ||
2935            use_c-&gt;in(exit_idx)-&gt;Opcode() == Op_IfFalse ||
2936            use_c-&gt;in(exit_idx)-&gt;Opcode() == Op_JumpProj) &amp;&amp;
2937           loop-&gt;is_member( get_loop( use_c-&gt;in(exit_idx)-&gt;in(0) ) ) );
2938 }
2939 
2940 //------------------------------ is_valid_clone_loop_form -------------------------------------
2941 // Ensure that all uses outside of loop are of the right form
2942 bool PhaseIdealLoop::is_valid_clone_loop_form( IdealLoopTree *loop, Node_List&amp; peel_list,
2943                                                uint orig_exit_idx, uint clone_exit_idx) {
2944   uint len = peel_list.size();
2945   for (uint i = 0; i &lt; len; i++) {
2946     Node *def = peel_list.at(i);
2947 
2948     for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2949       Node *use = def-&gt;fast_out(j);
2950       Node *use_c = has_ctrl(use) ? get_ctrl(use) : use;
2951       if (!loop-&gt;is_member(get_loop(use_c))) {
2952         // use is not in the loop, check for correct structure
2953         if (use-&gt;in(0) == def) {
2954           // Okay
2955         } else if (!is_valid_clone_loop_exit_use(loop, use, orig_exit_idx)) {
2956           return false;
2957         }
2958       }
2959     }
2960   }
2961   return true;
2962 }
2963 #endif
2964 
2965 //------------------------------ partial_peel -------------------------------------
2966 // Partially peel (aka loop rotation) the top portion of a loop (called
2967 // the peel section below) by cloning it and placing one copy just before
2968 // the new loop head and the other copy at the bottom of the new loop.
2969 //
2970 //    before                       after                where it came from
2971 //
2972 //    stmt1                        stmt1
2973 //  loop:                          stmt2                     clone
2974 //    stmt2                        if condA goto exitA       clone
2975 //    if condA goto exitA        new_loop:                   new
2976 //    stmt3                        stmt3                     clone
2977 //    if !condB goto loop          if condB goto exitB       clone
2978 //  exitB:                         stmt2                     orig
2979 //    stmt4                        if !condA goto new_loop   orig
2980 //  exitA:                         goto exitA
2981 //                               exitB:
2982 //                                 stmt4
2983 //                               exitA:
2984 //
2985 // Step 1: find the cut point: an exit test on probable
2986 //         induction variable.
2987 // Step 2: schedule (with cloning) operations in the peel
2988 //         section that can be executed after the cut into
2989 //         the section that is not peeled.  This may need
2990 //         to clone operations into exit blocks.  For
2991 //         instance, a reference to A[i] in the not-peel
2992 //         section and a reference to B[i] in an exit block
2993 //         may cause a left-shift of i by 2 to be placed
2994 //         in the peel block.  This step will clone the left
2995 //         shift into the exit block and sink the left shift
2996 //         from the peel to the not-peel section.
2997 // Step 3: clone the loop, retarget the control, and insert
2998 //         phis for values that are live across the new loop
2999 //         head.  This is very dependent on the graph structure
3000 //         from clone_loop.  It creates region nodes for
3001 //         exit control and associated phi nodes for values
3002 //         flow out of the loop through that exit.  The region
3003 //         node is dominated by the clone&#39;s control projection.
3004 //         So the clone&#39;s peel section is placed before the
3005 //         new loop head, and the clone&#39;s not-peel section is
3006 //         forms the top part of the new loop.  The original
3007 //         peel section forms the tail of the new loop.
3008 // Step 4: update the dominator tree and recompute the
3009 //         dominator depth.
3010 //
3011 //                   orig
3012 //
3013 //                   stmt1
3014 //                     |
3015 //                     v
3016 //               loop predicate
3017 //                     |
3018 //                     v
3019 //                   loop&lt;----+
3020 //                     |      |
3021 //                   stmt2    |
3022 //                     |      |
3023 //                     v      |
3024 //                    ifA     |
3025 //                   / |      |
3026 //                  v  v      |
3027 //               false true   ^  &lt;-- last_peel
3028 //               /     |      |
3029 //              /   ===|==cut |
3030 //             /     stmt3    |  &lt;-- first_not_peel
3031 //            /        |      |
3032 //            |        v      |
3033 //            v       ifB     |
3034 //          exitA:   / \      |
3035 //                  /   \     |
3036 //                 v     v    |
3037 //               false true   |
3038 //               /       \    |
3039 //              /         ----+
3040 //             |
3041 //             v
3042 //           exitB:
3043 //           stmt4
3044 //
3045 //
3046 //            after clone loop
3047 //
3048 //                   stmt1
3049 //                     |
3050 //                     v
3051 //               loop predicate
3052 //                 /       \
3053 //        clone   /         \   orig
3054 //               /           \
3055 //              /             \
3056 //             v               v
3057 //   +----&gt;loop                loop&lt;----+
3058 //   |      |                    |      |
3059 //   |    stmt2                stmt2    |
3060 //   |      |                    |      |
3061 //   |      v                    v      |
3062 //   |      ifA                 ifA     |
3063 //   |      | \                / |      |
3064 //   |      v  v              v  v      |
3065 //   ^    true  false      false true   ^  &lt;-- last_peel
3066 //   |      |   ^   \       /    |      |
3067 //   | cut==|==  \   \     /  ===|==cut |
3068 //   |    stmt3   \   \   /    stmt3    |  &lt;-- first_not_peel
3069 //   |      |    dom   | |       |      |
3070 //   |      v      \  1v v2      v      |
3071 //   |      ifB     regionA     ifB     |
3072 //   |      / \        |       / \      |
3073 //   |     /   \       v      /   \     |
3074 //   |    v     v    exitA:  v     v    |
3075 //   |    true  false      false true   |
3076 //   |    /     ^   \      /       \    |
3077 //   +----       \   \    /         ----+
3078 //               dom  \  /
3079 //                 \  1v v2
3080 //                  regionB
3081 //                     |
3082 //                     v
3083 //                   exitB:
3084 //                   stmt4
3085 //
3086 //
3087 //           after partial peel
3088 //
3089 //                  stmt1
3090 //                     |
3091 //                     v
3092 //               loop predicate
3093 //                 /
3094 //        clone   /             orig
3095 //               /          TOP
3096 //              /             \
3097 //             v               v
3098 //    TOP-&gt;loop                loop----+
3099 //          |                    |      |
3100 //        stmt2                stmt2    |
3101 //          |                    |      |
3102 //          v                    v      |
3103 //          ifA                 ifA     |
3104 //          | \                / |      |
3105 //          v  v              v  v      |
3106 //        true  false      false true   |     &lt;-- last_peel
3107 //          |   ^   \       /    +------|---+
3108 //  +-&gt;newloop   \   \     /  === ==cut |   |
3109 //  |     stmt3   \   \   /     TOP     |   |
3110 //  |       |    dom   | |      stmt3   |   | &lt;-- first_not_peel
3111 //  |       v      \  1v v2      v      |   |
3112 //  |       ifB     regionA     ifB     ^   v
3113 //  |       / \        |       / \      |   |
3114 //  |      /   \       v      /   \     |   |
3115 //  |     v     v    exitA:  v     v    |   |
3116 //  |     true  false      false true   |   |
3117 //  |     /     ^   \      /       \    |   |
3118 //  |    |       \   \    /         v   |   |
3119 //  |    |       dom  \  /         TOP  |   |
3120 //  |    |         \  1v v2             |   |
3121 //  ^    v          regionB             |   |
3122 //  |    |             |                |   |
3123 //  |    |             v                ^   v
3124 //  |    |           exitB:             |   |
3125 //  |    |           stmt4              |   |
3126 //  |    +------------&gt;-----------------+   |
3127 //  |                                       |
3128 //  +-----------------&lt;---------------------+
3129 //
3130 //
3131 //              final graph
3132 //
3133 //                  stmt1
3134 //                    |
3135 //                    v
3136 //               loop predicate
3137 //                    |
3138 //                    v
3139 //                  stmt2 clone
3140 //                    |
3141 //                    v
3142 //         ........&gt; ifA clone
3143 //         :        / |
3144 //        dom      /  |
3145 //         :      v   v
3146 //         :  false   true
3147 //         :  |       |
3148 //         :  |       v
3149 //         :  |    newloop&lt;-----+
3150 //         :  |        |        |
3151 //         :  |     stmt3 clone |
3152 //         :  |        |        |
3153 //         :  |        v        |
3154 //         :  |       ifB       |
3155 //         :  |      / \        |
3156 //         :  |     v   v       |
3157 //         :  |  false true     |
3158 //         :  |   |     |       |
3159 //         :  |   v    stmt2    |
3160 //         :  | exitB:  |       |
3161 //         :  | stmt4   v       |
3162 //         :  |       ifA orig  |
3163 //         :  |      /  \       |
3164 //         :  |     /    \      |
3165 //         :  |    v     v      |
3166 //         :  |  false  true    |
3167 //         :  |  /        \     |
3168 //         :  v  v         -----+
3169 //          RegionA
3170 //             |
3171 //             v
3172 //           exitA
3173 //
3174 bool PhaseIdealLoop::partial_peel( IdealLoopTree *loop, Node_List &amp;old_new ) {
3175 
3176   assert(!loop-&gt;_head-&gt;is_CountedLoop(), &quot;Non-counted loop only&quot;);
3177   if (!loop-&gt;_head-&gt;is_Loop()) {
3178     return false;
3179   }
3180   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
3181 
3182   if (head-&gt;is_partial_peel_loop() || head-&gt;partial_peel_has_failed()) {
3183     return false;
3184   }
3185 
3186   // Check for complex exit control
3187   for (uint ii = 0; ii &lt; loop-&gt;_body.size(); ii++) {
3188     Node *n = loop-&gt;_body.at(ii);
3189     int opc = n-&gt;Opcode();
3190     if (n-&gt;is_Call()        ||
3191         opc == Op_Catch     ||
3192         opc == Op_CatchProj ||
3193         opc == Op_Jump      ||
3194         opc == Op_JumpProj) {
3195 #ifndef PRODUCT
3196       if (TracePartialPeeling) {
3197         tty-&gt;print_cr(&quot;\nExit control too complex: lp: %d&quot;, head-&gt;_idx);
3198       }
3199 #endif
3200       return false;
3201     }
3202   }
3203 
3204   int dd = dom_depth(head);
3205 
3206   // Step 1: find cut point
3207 
3208   // Walk up dominators to loop head looking for first loop exit
3209   // which is executed on every path thru loop.
3210   IfNode *peel_if = NULL;
3211   IfNode *peel_if_cmpu = NULL;
3212 
3213   Node *iff = loop-&gt;tail();
3214   while (iff != head) {
3215     if (iff-&gt;is_If()) {
3216       Node *ctrl = get_ctrl(iff-&gt;in(1));
3217       if (ctrl-&gt;is_top()) return false; // Dead test on live IF.
3218       // If loop-varying exit-test, check for induction variable
3219       if (loop-&gt;is_member(get_loop(ctrl)) &amp;&amp;
3220           loop-&gt;is_loop_exit(iff) &amp;&amp;
3221           is_possible_iv_test(iff)) {
3222         Node* cmp = iff-&gt;in(1)-&gt;in(1);
3223         if (cmp-&gt;Opcode() == Op_CmpI) {
3224           peel_if = iff-&gt;as_If();
3225         } else {
3226           assert(cmp-&gt;Opcode() == Op_CmpU, &quot;must be CmpI or CmpU&quot;);
3227           peel_if_cmpu = iff-&gt;as_If();
3228         }
3229       }
3230     }
3231     iff = idom(iff);
3232   }
3233 
3234   // Prefer signed compare over unsigned compare.
3235   IfNode* new_peel_if = NULL;
3236   if (peel_if == NULL) {
3237     if (!PartialPeelAtUnsignedTests || peel_if_cmpu == NULL) {
3238       return false;   // No peel point found
3239     }
3240     new_peel_if = insert_cmpi_loop_exit(peel_if_cmpu, loop);
3241     if (new_peel_if == NULL) {
3242       return false;   // No peel point found
3243     }
3244     peel_if = new_peel_if;
3245   }
3246   Node* last_peel        = stay_in_loop(peel_if, loop);
3247   Node* first_not_peeled = stay_in_loop(last_peel, loop);
3248   if (first_not_peeled == NULL || first_not_peeled == head) {
3249     return false;
3250   }
3251 
3252 #ifndef PRODUCT
3253   if (TraceLoopOpts) {
3254     tty-&gt;print(&quot;PartialPeel  &quot;);
3255     loop-&gt;dump_head();
3256   }
3257 
3258   if (TracePartialPeeling) {
3259     tty-&gt;print_cr(&quot;before partial peel one iteration&quot;);
3260     Node_List wl;
3261     Node* t = head-&gt;in(2);
3262     while (true) {
3263       wl.push(t);
3264       if (t == head) break;
3265       t = idom(t);
3266     }
3267     while (wl.size() &gt; 0) {
3268       Node* tt = wl.pop();
3269       tt-&gt;dump();
3270       if (tt == last_peel) tty-&gt;print_cr(&quot;-- cut --&quot;);
3271     }
3272   }
3273 #endif
<a name="7" id="anc7"></a><span class="line-modified">3274   ResourceArea *area = Thread::current()-&gt;resource_area();</span>
<span class="line-modified">3275   VectorSet peel(area);</span>
<span class="line-modified">3276   VectorSet not_peel(area);</span>
<span class="line-modified">3277   Node_List peel_list(area);</span>
<span class="line-modified">3278   Node_List worklist(area);</span>
<span class="line-removed">3279   Node_List sink_list(area);</span>
3280 
3281   uint estimate = loop-&gt;est_loop_clone_sz(1);
3282   if (exceeding_node_budget(estimate)) {
3283     return false;
3284   }
3285 
3286   // Set of cfg nodes to peel are those that are executable from
3287   // the head through last_peel.
3288   assert(worklist.size() == 0, &quot;should be empty&quot;);
3289   worklist.push(head);
3290   peel.set(head-&gt;_idx);
3291   while (worklist.size() &gt; 0) {
3292     Node *n = worklist.pop();
3293     if (n != last_peel) {
3294       for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3295         Node* use = n-&gt;fast_out(j);
3296         if (use-&gt;is_CFG() &amp;&amp;
3297             loop-&gt;is_member(get_loop(use)) &amp;&amp;
3298             !peel.test_set(use-&gt;_idx)) {
3299           worklist.push(use);
3300         }
3301       }
3302     }
3303   }
3304 
3305   // Set of non-cfg nodes to peel are those that are control
3306   // dependent on the cfg nodes.
3307   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
3308     Node *n = loop-&gt;_body.at(i);
3309     Node *n_c = has_ctrl(n) ? get_ctrl(n) : n;
3310     if (peel.test(n_c-&gt;_idx)) {
3311       peel.set(n-&gt;_idx);
3312     } else {
3313       not_peel.set(n-&gt;_idx);
3314     }
3315   }
3316 
3317   // Step 2: move operations from the peeled section down into the
3318   //         not-peeled section
3319 
3320   // Get a post order schedule of nodes in the peel region
3321   // Result in right-most operand.
3322   scheduled_nodelist(loop, peel, peel_list);
3323 
3324   assert(is_valid_loop_partition(loop, peel, peel_list, not_peel), &quot;bad partition&quot;);
3325 
3326   // For future check for too many new phis
3327   uint old_phi_cnt = 0;
3328   for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3329     Node* use = head-&gt;fast_out(j);
3330     if (use-&gt;is_Phi()) old_phi_cnt++;
3331   }
3332 
3333 #ifndef PRODUCT
3334   if (TracePartialPeeling) {
3335     tty-&gt;print_cr(&quot;\npeeled list&quot;);
3336   }
3337 #endif
3338 
3339   // Evacuate nodes in peel region into the not_peeled region if possible
3340   uint new_phi_cnt = 0;
3341   uint cloned_for_outside_use = 0;
3342   for (uint i = 0; i &lt; peel_list.size();) {
3343     Node* n = peel_list.at(i);
3344 #ifndef PRODUCT
3345   if (TracePartialPeeling) n-&gt;dump();
3346 #endif
3347     bool incr = true;
3348     if (!n-&gt;is_CFG()) {
3349       if (has_use_in_set(n, not_peel)) {
3350         // If not used internal to the peeled region,
3351         // move &quot;n&quot; from peeled to not_peeled region.
3352         if (!has_use_internal_to_set(n, peel, loop)) {
3353           // if not pinned and not a load (which maybe anti-dependent on a store)
3354           // and not a CMove (Matcher expects only bool-&gt;cmove).
3355           if (n-&gt;in(0) == NULL &amp;&amp; !n-&gt;is_Load() &amp;&amp; !n-&gt;is_CMove()) {
3356             cloned_for_outside_use += clone_for_use_outside_loop(loop, n, worklist);
3357             sink_list.push(n);
3358             peel.remove(n-&gt;_idx);
3359             not_peel.set(n-&gt;_idx);
3360             peel_list.remove(i);
3361             incr = false;
3362 #ifndef PRODUCT
3363             if (TracePartialPeeling) {
3364               tty-&gt;print_cr(&quot;sink to not_peeled region: %d newbb: %d&quot;,
3365                             n-&gt;_idx, get_ctrl(n)-&gt;_idx);
3366             }
3367 #endif
3368           }
3369         } else {
3370           // Otherwise check for special def-use cases that span
3371           // the peel/not_peel boundary such as bool-&gt;if
3372           clone_for_special_use_inside_loop(loop, n, not_peel, sink_list, worklist);
3373           new_phi_cnt++;
3374         }
3375       }
3376     }
3377     if (incr) i++;
3378   }
3379 
3380   estimate += cloned_for_outside_use + new_phi_cnt;
3381   bool exceed_node_budget = !may_require_nodes(estimate);
3382   bool exceed_phi_limit = new_phi_cnt &gt; old_phi_cnt + PartialPeelNewPhiDelta;
3383 
3384   if (exceed_node_budget || exceed_phi_limit) {
3385 #ifndef PRODUCT
3386     if (TracePartialPeeling) {
3387       tty-&gt;print_cr(&quot;\nToo many new phis: %d  old %d new cmpi: %c&quot;,
3388                     new_phi_cnt, old_phi_cnt, new_peel_if != NULL?&#39;T&#39;:&#39;F&#39;);
3389     }
3390 #endif
3391     if (new_peel_if != NULL) {
3392       remove_cmpi_loop_exit(new_peel_if, loop);
3393     }
3394     // Inhibit more partial peeling on this loop
3395     assert(!head-&gt;is_partial_peel_loop(), &quot;not partial peeled&quot;);
3396     head-&gt;mark_partial_peel_failed();
3397     if (cloned_for_outside_use &gt; 0) {
3398       // Terminate this round of loop opts because
3399       // the graph outside this loop was changed.
3400       C-&gt;set_major_progress();
3401       return true;
3402     }
3403     return false;
3404   }
3405 
3406   // Step 3: clone loop, retarget control, and insert new phis
3407 
3408   // Create new loop head for new phis and to hang
3409   // the nodes being moved (sinked) from the peel region.
3410   LoopNode* new_head = new LoopNode(last_peel, last_peel);
3411   new_head-&gt;set_unswitch_count(head-&gt;unswitch_count()); // Preserve
3412   _igvn.register_new_node_with_optimizer(new_head);
3413   assert(first_not_peeled-&gt;in(0) == last_peel, &quot;last_peel &lt;- first_not_peeled&quot;);
3414   _igvn.replace_input_of(first_not_peeled, 0, new_head);
3415   set_loop(new_head, loop);
3416   loop-&gt;_body.push(new_head);
3417   not_peel.set(new_head-&gt;_idx);
3418   set_idom(new_head, last_peel, dom_depth(first_not_peeled));
3419   set_idom(first_not_peeled, new_head, dom_depth(first_not_peeled));
3420 
3421   while (sink_list.size() &gt; 0) {
3422     Node* n = sink_list.pop();
3423     set_ctrl(n, new_head);
3424   }
3425 
3426   assert(is_valid_loop_partition(loop, peel, peel_list, not_peel), &quot;bad partition&quot;);
3427 
3428   clone_loop(loop, old_new, dd, IgnoreStripMined);
3429 
3430   const uint clone_exit_idx = 1;
3431   const uint orig_exit_idx  = 2;
3432   assert(is_valid_clone_loop_form(loop, peel_list, orig_exit_idx, clone_exit_idx), &quot;bad clone loop&quot;);
3433 
3434   Node* head_clone             = old_new[head-&gt;_idx];
3435   LoopNode* new_head_clone     = old_new[new_head-&gt;_idx]-&gt;as_Loop();
3436   Node* orig_tail_clone        = head_clone-&gt;in(2);
3437 
3438   // Add phi if &quot;def&quot; node is in peel set and &quot;use&quot; is not
3439 
3440   for (uint i = 0; i &lt; peel_list.size(); i++) {
3441     Node *def  = peel_list.at(i);
3442     if (!def-&gt;is_CFG()) {
3443       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3444         Node *use = def-&gt;fast_out(j);
3445         if (has_node(use) &amp;&amp; use-&gt;in(0) != C-&gt;top() &amp;&amp;
3446             (!peel.test(use-&gt;_idx) ||
3447              (use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == head)) ) {
3448           worklist.push(use);
3449         }
3450       }
3451       while( worklist.size() ) {
3452         Node *use = worklist.pop();
3453         for (uint j = 1; j &lt; use-&gt;req(); j++) {
3454           Node* n = use-&gt;in(j);
3455           if (n == def) {
3456 
3457             // &quot;def&quot; is in peel set, &quot;use&quot; is not in peel set
3458             // or &quot;use&quot; is in the entry boundary (a phi) of the peel set
3459 
3460             Node* use_c = has_ctrl(use) ? get_ctrl(use) : use;
3461 
3462             if ( loop-&gt;is_member(get_loop( use_c )) ) {
3463               // use is in loop
3464               if (old_new[use-&gt;_idx] != NULL) { // null for dead code
3465                 Node* use_clone = old_new[use-&gt;_idx];
3466                 _igvn.replace_input_of(use, j, C-&gt;top());
3467                 insert_phi_for_loop( use_clone, j, old_new[def-&gt;_idx], def, new_head_clone );
3468               }
3469             } else {
3470               assert(is_valid_clone_loop_exit_use(loop, use, orig_exit_idx), &quot;clone loop format&quot;);
3471               // use is not in the loop, check if the live range includes the cut
3472               Node* lp_if = use_c-&gt;in(orig_exit_idx)-&gt;in(0);
3473               if (not_peel.test(lp_if-&gt;_idx)) {
3474                 assert(j == orig_exit_idx, &quot;use from original loop&quot;);
3475                 insert_phi_for_loop( use, clone_exit_idx, old_new[def-&gt;_idx], def, new_head_clone );
3476               }
3477             }
3478           }
3479         }
3480       }
3481     }
3482   }
3483 
3484   // Step 3b: retarget control
3485 
3486   // Redirect control to the new loop head if a cloned node in
3487   // the not_peeled region has control that points into the peeled region.
3488   // This necessary because the cloned peeled region will be outside
3489   // the loop.
3490   //                            from    to
3491   //          cloned-peeled    &lt;---+
3492   //    new_head_clone:            |    &lt;--+
3493   //          cloned-not_peeled  in(0)    in(0)
3494   //          orig-peeled
3495 
3496   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
3497     Node *n = loop-&gt;_body.at(i);
3498     if (!n-&gt;is_CFG()           &amp;&amp; n-&gt;in(0) != NULL        &amp;&amp;
3499         not_peel.test(n-&gt;_idx) &amp;&amp; peel.test(n-&gt;in(0)-&gt;_idx)) {
3500       Node* n_clone = old_new[n-&gt;_idx];
3501       _igvn.replace_input_of(n_clone, 0, new_head_clone);
3502     }
3503   }
3504 
3505   // Backedge of the surviving new_head (the clone) is original last_peel
3506   _igvn.replace_input_of(new_head_clone, LoopNode::LoopBackControl, last_peel);
3507 
3508   // Cut first node in original not_peel set
3509   _igvn.rehash_node_delayed(new_head);                     // Multiple edge updates:
3510   new_head-&gt;set_req(LoopNode::EntryControl,    C-&gt;top());  //   use rehash_node_delayed / set_req instead of
3511   new_head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());  //   multiple replace_input_of calls
3512 
3513   // Copy head_clone back-branch info to original head
3514   // and remove original head&#39;s loop entry and
3515   // clone head&#39;s back-branch
3516   _igvn.rehash_node_delayed(head); // Multiple edge updates
3517   head-&gt;set_req(LoopNode::EntryControl,    head_clone-&gt;in(LoopNode::LoopBackControl));
3518   head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
3519   _igvn.replace_input_of(head_clone, LoopNode::LoopBackControl, C-&gt;top());
3520 
3521   // Similarly modify the phis
3522   for (DUIterator_Fast kmax, k = head-&gt;fast_outs(kmax); k &lt; kmax; k++) {
3523     Node* use = head-&gt;fast_out(k);
3524     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
3525       Node* use_clone = old_new[use-&gt;_idx];
3526       _igvn.rehash_node_delayed(use); // Multiple edge updates
3527       use-&gt;set_req(LoopNode::EntryControl,    use_clone-&gt;in(LoopNode::LoopBackControl));
3528       use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
3529       _igvn.replace_input_of(use_clone, LoopNode::LoopBackControl, C-&gt;top());
3530     }
3531   }
3532 
3533   // Step 4: update dominator tree and dominator depth
3534 
3535   set_idom(head, orig_tail_clone, dd);
3536   recompute_dom_depth();
3537 
3538   // Inhibit more partial peeling on this loop
3539   new_head_clone-&gt;set_partial_peel_loop();
3540   C-&gt;set_major_progress();
3541   loop-&gt;record_for_igvn();
3542 
3543 #ifndef PRODUCT
3544   if (TracePartialPeeling) {
3545     tty-&gt;print_cr(&quot;\nafter partial peel one iteration&quot;);
<a name="8" id="anc8"></a><span class="line-modified">3546     Node_List wl(area);</span>
3547     Node* t = last_peel;
3548     while (true) {
3549       wl.push(t);
3550       if (t == head_clone) break;
3551       t = idom(t);
3552     }
3553     while (wl.size() &gt; 0) {
3554       Node* tt = wl.pop();
3555       if (tt == head) tty-&gt;print_cr(&quot;orig head&quot;);
3556       else if (tt == new_head_clone) tty-&gt;print_cr(&quot;new head&quot;);
3557       else if (tt == head_clone) tty-&gt;print_cr(&quot;clone head&quot;);
3558       tt-&gt;dump();
3559     }
3560   }
3561 #endif
3562   return true;
3563 }
3564 
3565 //------------------------------reorg_offsets----------------------------------
3566 // Reorganize offset computations to lower register pressure.  Mostly
3567 // prevent loop-fallout uses of the pre-incremented trip counter (which are
3568 // then alive with the post-incremented trip counter forcing an extra
3569 // register move)
3570 void PhaseIdealLoop::reorg_offsets(IdealLoopTree *loop) {
3571   // Perform it only for canonical counted loops.
3572   // Loop&#39;s shape could be messed up by iteration_split_impl.
3573   if (!loop-&gt;_head-&gt;is_CountedLoop())
3574     return;
3575   if (!loop-&gt;_head-&gt;as_Loop()-&gt;is_valid_counted_loop())
3576     return;
3577 
3578   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
3579   CountedLoopEndNode *cle = cl-&gt;loopexit();
3580   Node *exit = cle-&gt;proj_out(false);
3581   Node *phi = cl-&gt;phi();
3582 
3583   // Check for the special case when using the pre-incremented trip-counter on
3584   // the fall-out  path (forces the pre-incremented  and post-incremented trip
3585   // counter to be live  at the same time).  Fix this by  adjusting to use the
3586   // post-increment trip counter.
3587 
3588   bool progress = true;
3589   while (progress) {
3590     progress = false;
3591     for (DUIterator_Fast imax, i = phi-&gt;fast_outs(imax); i &lt; imax; i++) {
3592       Node* use = phi-&gt;fast_out(i);   // User of trip-counter
3593       if (!has_ctrl(use))  continue;
3594       Node *u_ctrl = get_ctrl(use);
3595       if (use-&gt;is_Phi()) {
3596         u_ctrl = NULL;
3597         for (uint j = 1; j &lt; use-&gt;req(); j++)
3598           if (use-&gt;in(j) == phi)
3599             u_ctrl = dom_lca(u_ctrl, use-&gt;in(0)-&gt;in(j));
3600       }
3601       IdealLoopTree *u_loop = get_loop(u_ctrl);
3602       // Look for loop-invariant use
3603       if (u_loop == loop) continue;
3604       if (loop-&gt;is_member(u_loop)) continue;
3605       // Check that use is live out the bottom.  Assuming the trip-counter
3606       // update is right at the bottom, uses of of the loop middle are ok.
3607       if (dom_lca(exit, u_ctrl) != exit) continue;
3608       // Hit!  Refactor use to use the post-incremented tripcounter.
3609       // Compute a post-increment tripcounter.
3610       Node* c = exit;
3611       if (cl-&gt;is_strip_mined()) {
3612         IdealLoopTree* outer_loop = get_loop(cl-&gt;outer_loop());
3613         if (!outer_loop-&gt;is_member(u_loop)) {
3614           c = cl-&gt;outer_loop_exit();
3615         }
3616       }
3617       Node *opaq = new Opaque2Node(C, cle-&gt;incr());
3618       register_new_node(opaq, c);
3619       Node *neg_stride = _igvn.intcon(-cle-&gt;stride_con());
3620       set_ctrl(neg_stride, C-&gt;root());
3621       Node *post = new AddINode(opaq, neg_stride);
3622       register_new_node(post, c);
3623       _igvn.rehash_node_delayed(use);
3624       for (uint j = 1; j &lt; use-&gt;req(); j++) {
3625         if (use-&gt;in(j) == phi)
3626           use-&gt;set_req(j, post);
3627       }
3628       // Since DU info changed, rerun loop
3629       progress = true;
3630       break;
3631     }
3632   }
3633 
3634 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>