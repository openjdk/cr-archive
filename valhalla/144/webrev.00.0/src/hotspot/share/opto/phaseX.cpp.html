<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/phaseX.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/block.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/idealGraphPrinter.hpp&quot;
  35 #include &quot;opto/loopnode.hpp&quot;
  36 #include &quot;opto/machnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/phaseX.hpp&quot;
  39 #include &quot;opto/regalloc.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;utilities/macros.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 //=============================================================================
  45 #define NODE_HASH_MINIMUM_SIZE    255
  46 //------------------------------NodeHash---------------------------------------
  47 NodeHash::NodeHash(uint est_max_size) :
  48   _a(Thread::current()-&gt;resource_area()),
  49   _max( round_up(est_max_size &lt; NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),
  50   _inserts(0), _insert_limit( insert_limit() ),
  51   _table( NEW_ARENA_ARRAY( _a , Node* , _max ) ) // (Node**)_a-&gt;Amalloc(_max * sizeof(Node*)) ),
  52 #ifndef PRODUCT
  53   , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),
  54   _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),
  55    _total_inserts(0), _total_insert_probes(0)
  56 #endif
  57 {
  58   // _sentinel must be in the current node space
  59   _sentinel = new ProjNode(NULL, TypeFunc::Control);
  60   memset(_table,0,sizeof(Node*)*_max);
  61 }
  62 
  63 //------------------------------NodeHash---------------------------------------
  64 NodeHash::NodeHash(Arena *arena, uint est_max_size) :
  65   _a(arena),
  66   _max( round_up(est_max_size &lt; NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),
  67   _inserts(0), _insert_limit( insert_limit() ),
  68   _table( NEW_ARENA_ARRAY( _a , Node* , _max ) )
  69 #ifndef PRODUCT
  70   , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),
  71   _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),
  72    _total_inserts(0), _total_insert_probes(0)
  73 #endif
  74 {
  75   // _sentinel must be in the current node space
  76   _sentinel = new ProjNode(NULL, TypeFunc::Control);
  77   memset(_table,0,sizeof(Node*)*_max);
  78 }
  79 
  80 //------------------------------NodeHash---------------------------------------
  81 NodeHash::NodeHash(NodeHash *nh) {
  82   debug_only(_table = (Node**)badAddress);   // interact correctly w/ operator=
  83   // just copy in all the fields
  84   *this = *nh;
  85   // nh-&gt;_sentinel must be in the current node space
  86 }
  87 
  88 void NodeHash::replace_with(NodeHash *nh) {
  89   debug_only(_table = (Node**)badAddress);   // interact correctly w/ operator=
  90   // just copy in all the fields
  91   *this = *nh;
  92   // nh-&gt;_sentinel must be in the current node space
  93 }
  94 
  95 //------------------------------hash_find--------------------------------------
  96 // Find in hash table
  97 Node *NodeHash::hash_find( const Node *n ) {
  98   // ((Node*)n)-&gt;set_hash( n-&gt;hash() );
  99   uint hash = n-&gt;hash();
 100   if (hash == Node::NO_HASH) {
 101     NOT_PRODUCT( _lookup_misses++ );
 102     return NULL;
 103   }
 104   uint key = hash &amp; (_max-1);
 105   uint stride = key | 0x01;
 106   NOT_PRODUCT( _look_probes++ );
 107   Node *k = _table[key];        // Get hashed value
 108   if( !k ) {                    // ?Miss?
 109     NOT_PRODUCT( _lookup_misses++ );
 110     return NULL;                // Miss!
 111   }
 112 
 113   int op = n-&gt;Opcode();
 114   uint req = n-&gt;req();
 115   while( 1 ) {                  // While probing hash table
 116     if( k-&gt;req() == req &amp;&amp;      // Same count of inputs
 117         k-&gt;Opcode() == op ) {   // Same Opcode
 118       for( uint i=0; i&lt;req; i++ )
 119         if( n-&gt;in(i)!=k-&gt;in(i)) // Different inputs?
 120           goto collision;       // &quot;goto&quot; is a speed hack...
 121       if( n-&gt;cmp(*k) ) {        // Check for any special bits
 122         NOT_PRODUCT( _lookup_hits++ );
 123         return k;               // Hit!
 124       }
 125     }
 126   collision:
 127     NOT_PRODUCT( _look_probes++ );
 128     key = (key + stride/*7*/) &amp; (_max-1); // Stride through table with relative prime
 129     k = _table[key];            // Get hashed value
 130     if( !k ) {                  // ?Miss?
 131       NOT_PRODUCT( _lookup_misses++ );
 132       return NULL;              // Miss!
 133     }
 134   }
 135   ShouldNotReachHere();
 136   return NULL;
 137 }
 138 
 139 //------------------------------hash_find_insert-------------------------------
 140 // Find in hash table, insert if not already present
 141 // Used to preserve unique entries in hash table
 142 Node *NodeHash::hash_find_insert( Node *n ) {
 143   // n-&gt;set_hash( );
 144   uint hash = n-&gt;hash();
 145   if (hash == Node::NO_HASH) {
 146     NOT_PRODUCT( _lookup_misses++ );
 147     return NULL;
 148   }
 149   uint key = hash &amp; (_max-1);
 150   uint stride = key | 0x01;     // stride must be relatively prime to table siz
 151   uint first_sentinel = 0;      // replace a sentinel if seen.
 152   NOT_PRODUCT( _look_probes++ );
 153   Node *k = _table[key];        // Get hashed value
 154   if( !k ) {                    // ?Miss?
 155     NOT_PRODUCT( _lookup_misses++ );
 156     _table[key] = n;            // Insert into table!
 157     debug_only(n-&gt;enter_hash_lock()); // Lock down the node while in the table.
 158     check_grow();               // Grow table if insert hit limit
 159     return NULL;                // Miss!
 160   }
 161   else if( k == _sentinel ) {
 162     first_sentinel = key;      // Can insert here
 163   }
 164 
 165   int op = n-&gt;Opcode();
 166   uint req = n-&gt;req();
 167   while( 1 ) {                  // While probing hash table
 168     if( k-&gt;req() == req &amp;&amp;      // Same count of inputs
 169         k-&gt;Opcode() == op ) {   // Same Opcode
 170       for( uint i=0; i&lt;req; i++ )
 171         if( n-&gt;in(i)!=k-&gt;in(i)) // Different inputs?
 172           goto collision;       // &quot;goto&quot; is a speed hack...
 173       if( n-&gt;cmp(*k) ) {        // Check for any special bits
 174         NOT_PRODUCT( _lookup_hits++ );
 175         return k;               // Hit!
 176       }
 177     }
 178   collision:
 179     NOT_PRODUCT( _look_probes++ );
 180     key = (key + stride) &amp; (_max-1); // Stride through table w/ relative prime
 181     k = _table[key];            // Get hashed value
 182     if( !k ) {                  // ?Miss?
 183       NOT_PRODUCT( _lookup_misses++ );
 184       key = (first_sentinel == 0) ? key : first_sentinel; // ?saw sentinel?
 185       _table[key] = n;          // Insert into table!
 186       debug_only(n-&gt;enter_hash_lock()); // Lock down the node while in the table.
 187       check_grow();             // Grow table if insert hit limit
 188       return NULL;              // Miss!
 189     }
 190     else if( first_sentinel == 0 &amp;&amp; k == _sentinel ) {
 191       first_sentinel = key;    // Can insert here
 192     }
 193 
 194   }
 195   ShouldNotReachHere();
 196   return NULL;
 197 }
 198 
 199 //------------------------------hash_insert------------------------------------
 200 // Insert into hash table
 201 void NodeHash::hash_insert( Node *n ) {
 202   // // &quot;conflict&quot; comments -- print nodes that conflict
 203   // bool conflict = false;
 204   // n-&gt;set_hash();
 205   uint hash = n-&gt;hash();
 206   if (hash == Node::NO_HASH) {
 207     return;
 208   }
 209   check_grow();
 210   uint key = hash &amp; (_max-1);
 211   uint stride = key | 0x01;
 212 
 213   while( 1 ) {                  // While probing hash table
 214     NOT_PRODUCT( _insert_probes++ );
 215     Node *k = _table[key];      // Get hashed value
 216     if( !k || (k == _sentinel) ) break;       // Found a slot
 217     assert( k != n, &quot;already inserted&quot; );
 218     // if( PrintCompilation &amp;&amp; PrintOptoStatistics &amp;&amp; Verbose ) { tty-&gt;print(&quot;  conflict: &quot;); k-&gt;dump(); conflict = true; }
 219     key = (key + stride) &amp; (_max-1); // Stride through table w/ relative prime
 220   }
 221   _table[key] = n;              // Insert into table!
 222   debug_only(n-&gt;enter_hash_lock()); // Lock down the node while in the table.
 223   // if( conflict ) { n-&gt;dump(); }
 224 }
 225 
 226 //------------------------------hash_delete------------------------------------
 227 // Replace in hash table with sentinel
 228 bool NodeHash::hash_delete( const Node *n ) {
 229   Node *k;
 230   uint hash = n-&gt;hash();
 231   if (hash == Node::NO_HASH) {
 232     NOT_PRODUCT( _delete_misses++ );
 233     return false;
 234   }
 235   uint key = hash &amp; (_max-1);
 236   uint stride = key | 0x01;
 237   debug_only( uint counter = 0; );
 238   for( ; /* (k != NULL) &amp;&amp; (k != _sentinel) */; ) {
 239     debug_only( counter++ );
 240     NOT_PRODUCT( _delete_probes++ );
 241     k = _table[key];            // Get hashed value
 242     if( !k ) {                  // Miss?
 243       NOT_PRODUCT( _delete_misses++ );
 244       return false;             // Miss! Not in chain
 245     }
 246     else if( n == k ) {
 247       NOT_PRODUCT( _delete_hits++ );
 248       _table[key] = _sentinel;  // Hit! Label as deleted entry
 249       debug_only(((Node*)n)-&gt;exit_hash_lock()); // Unlock the node upon removal from table.
 250       return true;
 251     }
 252     else {
 253       // collision: move through table with prime offset
 254       key = (key + stride/*7*/) &amp; (_max-1);
 255       assert( counter &lt;= _insert_limit, &quot;Cycle in hash-table&quot;);
 256     }
 257   }
 258   ShouldNotReachHere();
 259   return false;
 260 }
 261 
 262 //------------------------------round_up---------------------------------------
 263 // Round up to nearest power of 2
 264 uint NodeHash::round_up(uint x) {
 265   x += (x &gt;&gt; 2);                  // Add 25% slop
 266   return MAX2(16U, round_up_power_of_2(x));
 267 }
 268 
 269 //------------------------------grow-------------------------------------------
 270 // Grow _table to next power of 2 and insert old entries
 271 void  NodeHash::grow() {
 272   // Record old state
 273   uint   old_max   = _max;
 274   Node **old_table = _table;
 275   // Construct new table with twice the space
 276 #ifndef PRODUCT
 277   _grows++;
 278   _total_inserts       += _inserts;
 279   _total_insert_probes += _insert_probes;
 280   _insert_probes   = 0;
 281 #endif
 282   _inserts         = 0;
 283   _max     = _max &lt;&lt; 1;
 284   _table   = NEW_ARENA_ARRAY( _a , Node* , _max ); // (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
 285   memset(_table,0,sizeof(Node*)*_max);
 286   _insert_limit = insert_limit();
 287   // Insert old entries into the new table
 288   for( uint i = 0; i &lt; old_max; i++ ) {
 289     Node *m = *old_table++;
 290     if( !m || m == _sentinel ) continue;
 291     debug_only(m-&gt;exit_hash_lock()); // Unlock the node upon removal from old table.
 292     hash_insert(m);
 293   }
 294 }
 295 
 296 //------------------------------clear------------------------------------------
 297 // Clear all entries in _table to NULL but keep storage
 298 void  NodeHash::clear() {
 299 #ifdef ASSERT
 300   // Unlock all nodes upon removal from table.
 301   for (uint i = 0; i &lt; _max; i++) {
 302     Node* n = _table[i];
 303     if (!n || n == _sentinel)  continue;
 304     n-&gt;exit_hash_lock();
 305   }
 306 #endif
 307 
 308   memset( _table, 0, _max * sizeof(Node*) );
 309 }
 310 
 311 //-----------------------remove_useless_nodes----------------------------------
 312 // Remove useless nodes from value table,
 313 // implementation does not depend on hash function
 314 void NodeHash::remove_useless_nodes(VectorSet &amp;useful) {
 315 
 316   // Dead nodes in the hash table inherited from GVN should not replace
 317   // existing nodes, remove dead nodes.
 318   uint max = size();
 319   Node *sentinel_node = sentinel();
 320   for( uint i = 0; i &lt; max; ++i ) {
 321     Node *n = at(i);
 322     if(n != NULL &amp;&amp; n != sentinel_node &amp;&amp; !useful.test(n-&gt;_idx)) {
 323       debug_only(n-&gt;exit_hash_lock()); // Unlock the node when removed
 324       _table[i] = sentinel_node;       // Replace with placeholder
 325     }
 326   }
 327 }
 328 
 329 
 330 void NodeHash::check_no_speculative_types() {
 331 #ifdef ASSERT
 332   uint max = size();
 333   Node *sentinel_node = sentinel();
 334   for (uint i = 0; i &lt; max; ++i) {
 335     Node *n = at(i);
 336     if(n != NULL &amp;&amp; n != sentinel_node &amp;&amp; n-&gt;is_Type() &amp;&amp; n-&gt;outcnt() &gt; 0) {
 337       TypeNode* tn = n-&gt;as_Type();
 338       const Type* t = tn-&gt;type();
 339       const Type* t_no_spec = t-&gt;remove_speculative();
 340       assert(t == t_no_spec, &quot;dead node in hash table or missed node during speculative cleanup&quot;);
 341     }
 342   }
 343 #endif
 344 }
 345 
 346 #ifndef PRODUCT
 347 //------------------------------dump-------------------------------------------
 348 // Dump statistics for the hash table
 349 void NodeHash::dump() {
 350   _total_inserts       += _inserts;
 351   _total_insert_probes += _insert_probes;
 352   if (PrintCompilation &amp;&amp; PrintOptoStatistics &amp;&amp; Verbose &amp;&amp; (_inserts &gt; 0)) {
 353     if (WizardMode) {
 354       for (uint i=0; i&lt;_max; i++) {
 355         if (_table[i])
 356           tty-&gt;print(&quot;%d/%d/%d &quot;,i,_table[i]-&gt;hash()&amp;(_max-1),_table[i]-&gt;_idx);
 357       }
 358     }
 359     tty-&gt;print(&quot;\nGVN Hash stats:  %d grows to %d max_size\n&quot;, _grows, _max);
 360     tty-&gt;print(&quot;  %d/%d (%8.1f%% full)\n&quot;, _inserts, _max, (double)_inserts/_max*100.0);
 361     tty-&gt;print(&quot;  %dp/(%dh+%dm) (%8.2f probes/lookup)\n&quot;, _look_probes, _lookup_hits, _lookup_misses, (double)_look_probes/(_lookup_hits+_lookup_misses));
 362     tty-&gt;print(&quot;  %dp/%di (%8.2f probes/insert)\n&quot;, _total_insert_probes, _total_inserts, (double)_total_insert_probes/_total_inserts);
 363     // sentinels increase lookup cost, but not insert cost
 364     assert((_lookup_misses+_lookup_hits)*4+100 &gt;= _look_probes, &quot;bad hash function&quot;);
 365     assert( _inserts+(_inserts&gt;&gt;3) &lt; _max, &quot;table too full&quot; );
 366     assert( _inserts*3+100 &gt;= _insert_probes, &quot;bad hash function&quot; );
 367   }
 368 }
 369 
 370 Node *NodeHash::find_index(uint idx) { // For debugging
 371   // Find an entry by its index value
 372   for( uint i = 0; i &lt; _max; i++ ) {
 373     Node *m = _table[i];
 374     if( !m || m == _sentinel ) continue;
 375     if( m-&gt;_idx == (uint)idx ) return m;
 376   }
 377   return NULL;
 378 }
 379 #endif
 380 
 381 #ifdef ASSERT
 382 NodeHash::~NodeHash() {
 383   // Unlock all nodes upon destruction of table.
 384   if (_table != (Node**)badAddress)  clear();
 385 }
 386 
 387 void NodeHash::operator=(const NodeHash&amp; nh) {
 388   // Unlock all nodes upon replacement of table.
 389   if (&amp;nh == this)  return;
 390   if (_table != (Node**)badAddress)  clear();
 391   memcpy((void*)this, (void*)&amp;nh, sizeof(*this));
 392   // Do not increment hash_lock counts again.
 393   // Instead, be sure we never again use the source table.
 394   ((NodeHash*)&amp;nh)-&gt;_table = (Node**)badAddress;
 395 }
 396 
 397 
 398 #endif
 399 
 400 
 401 //=============================================================================
 402 //------------------------------PhaseRemoveUseless-----------------------------
 403 // 1) Use a breadthfirst walk to collect useful nodes reachable from root.
 404 PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN* gvn, Unique_Node_List* worklist, PhaseNumber phase_num) : Phase(phase_num) {
 405 
 406   // Implementation requires &#39;UseLoopSafepoints == true&#39; and an edge from root
 407   // to each SafePointNode at a backward branch.  Inserted in add_safepoint().
 408   if( !UseLoopSafepoints || !OptoRemoveUseless ) return;
 409 
 410   // Identify nodes that are reachable from below, useful.
 411   C-&gt;identify_useful_nodes(_useful);
 412   // Update dead node list
 413   C-&gt;update_dead_node_list(_useful);
 414 
 415   // Remove all useless nodes from PhaseValues&#39; recorded types
 416   // Must be done before disconnecting nodes to preserve hash-table-invariant
 417   gvn-&gt;remove_useless_nodes(_useful.member_set());
 418 
 419   // Remove all useless nodes from future worklist
 420   worklist-&gt;remove_useless_nodes(_useful.member_set());
 421 
 422   // Disconnect &#39;useless&#39; nodes that are adjacent to useful nodes
 423   C-&gt;remove_useless_nodes(_useful);
 424 }
 425 
 426 //=============================================================================
 427 //------------------------------PhaseRenumberLive------------------------------
 428 // First, remove useless nodes (equivalent to identifying live nodes).
 429 // Then, renumber live nodes.
 430 //
 431 // The set of live nodes is returned by PhaseRemoveUseless in the _useful structure.
 432 // If the number of live nodes is &#39;x&#39; (where &#39;x&#39; == _useful.size()), then the
 433 // PhaseRenumberLive updates the node ID of each node (the _idx field) with a unique
 434 // value in the range [0, x).
 435 //
 436 // At the end of the PhaseRenumberLive phase, the compiler&#39;s count of unique nodes is
 437 // updated to &#39;x&#39; and the list of dead nodes is reset (as there are no dead nodes).
 438 //
 439 // The PhaseRenumberLive phase updates two data structures with the new node IDs.
 440 // (1) The worklist is used by the PhaseIterGVN phase to identify nodes that must be
 441 // processed. A new worklist (with the updated node IDs) is returned in &#39;new_worklist&#39;.
 442 // (2) Type information (the field PhaseGVN::_types) maps type information to each
 443 // node ID. The mapping is updated to use the new node IDs as well. Updated type
 444 // information is returned in PhaseGVN::_types.
 445 //
 446 // The PhaseRenumberLive phase does not preserve the order of elements in the worklist.
 447 //
 448 // Other data structures used by the compiler are not updated. The hash table for value
 449 // numbering (the field PhaseGVN::_table) is not updated because computing the hash
 450 // values is not based on node IDs. The field PhaseGVN::_nodes is not updated either
 451 // because it is empty wherever PhaseRenumberLive is used.
 452 PhaseRenumberLive::PhaseRenumberLive(PhaseGVN* gvn,
 453                                      Unique_Node_List* worklist, Unique_Node_List* new_worklist,
 454                                      PhaseNumber phase_num) :
 455   PhaseRemoveUseless(gvn, worklist, Remove_Useless_And_Renumber_Live),
 456   _new_type_array(C-&gt;comp_arena()),
 457   _old2new_map(C-&gt;unique(), C-&gt;unique(), -1),
 458   _is_pass_finished(false),
 459   _live_node_count(C-&gt;live_nodes())
 460 {
 461   assert(RenumberLiveNodes, &quot;RenumberLiveNodes must be set to true for node renumbering to take place&quot;);
 462   assert(C-&gt;live_nodes() == _useful.size(), &quot;the number of live nodes must match the number of useful nodes&quot;);
 463   assert(gvn-&gt;nodes_size() == 0, &quot;GVN must not contain any nodes at this point&quot;);
 464   assert(_delayed.size() == 0, &quot;should be empty&quot;);
 465 
 466   uint worklist_size = worklist-&gt;size();
 467 
 468   // Iterate over the set of live nodes.
 469   for (uint current_idx = 0; current_idx &lt; _useful.size(); current_idx++) {
 470     Node* n = _useful.at(current_idx);
 471 
 472     bool in_worklist = false;
 473     if (worklist-&gt;member(n)) {
 474       in_worklist = true;
 475     }
 476 
 477     const Type* type = gvn-&gt;type_or_null(n);
 478     _new_type_array.map(current_idx, type);
 479 
 480     assert(_old2new_map.at(n-&gt;_idx) == -1, &quot;already seen&quot;);
 481     _old2new_map.at_put(n-&gt;_idx, current_idx);
 482 
 483     n-&gt;set_idx(current_idx); // Update node ID.
 484 
 485     if (in_worklist) {
 486       new_worklist-&gt;push(n);
 487     }
 488 
 489     if (update_embedded_ids(n) &lt; 0) {
 490       _delayed.push(n); // has embedded IDs; handle later
 491     }
 492   }
 493 
 494   assert(worklist_size == new_worklist-&gt;size(), &quot;the new worklist must have the same size as the original worklist&quot;);
 495   assert(_live_node_count == _useful.size(), &quot;all live nodes must be processed&quot;);
 496 
 497   _is_pass_finished = true; // pass finished; safe to process delayed updates
 498 
 499   while (_delayed.size() &gt; 0) {
 500     Node* n = _delayed.pop();
 501     int no_of_updates = update_embedded_ids(n);
 502     assert(no_of_updates &gt; 0, &quot;should be updated&quot;);
 503   }
 504 
 505   // Replace the compiler&#39;s type information with the updated type information.
 506   gvn-&gt;replace_types(_new_type_array);
 507 
 508   // Update the unique node count of the compilation to the number of currently live nodes.
 509   C-&gt;set_unique(_live_node_count);
 510 
 511   // Set the dead node count to 0 and reset dead node list.
 512   C-&gt;reset_dead_node_list();
 513 }
 514 
 515 int PhaseRenumberLive::new_index(int old_idx) {
 516   assert(_is_pass_finished, &quot;not finished&quot;);
 517   if (_old2new_map.at(old_idx) == -1) { // absent
 518     // Allocate a placeholder to preserve uniqueness
 519     _old2new_map.at_put(old_idx, _live_node_count);
 520     _live_node_count++;
 521   }
 522   return _old2new_map.at(old_idx);
 523 }
 524 
 525 int PhaseRenumberLive::update_embedded_ids(Node* n) {
 526   int no_of_updates = 0;
 527   if (n-&gt;is_Phi()) {
 528     PhiNode* phi = n-&gt;as_Phi();
 529     if (phi-&gt;_inst_id != -1) {
 530       if (!_is_pass_finished) {
 531         return -1; // delay
 532       }
 533       int new_idx = new_index(phi-&gt;_inst_id);
 534       assert(new_idx != -1, &quot;&quot;);
 535       phi-&gt;_inst_id = new_idx;
 536       no_of_updates++;
 537     }
 538     if (phi-&gt;_inst_mem_id != -1) {
 539       if (!_is_pass_finished) {
 540         return -1; // delay
 541       }
 542       int new_idx = new_index(phi-&gt;_inst_mem_id);
 543       assert(new_idx != -1, &quot;&quot;);
 544       phi-&gt;_inst_mem_id = new_idx;
 545       no_of_updates++;
 546     }
 547   }
 548 
 549   const Type* type = _new_type_array.fast_lookup(n-&gt;_idx);
 550   if (type != NULL &amp;&amp; type-&gt;isa_oopptr() &amp;&amp; type-&gt;is_oopptr()-&gt;is_known_instance()) {
 551     if (!_is_pass_finished) {
 552         return -1; // delay
 553     }
 554     int old_idx = type-&gt;is_oopptr()-&gt;instance_id();
 555     int new_idx = new_index(old_idx);
 556     const Type* new_type = type-&gt;is_oopptr()-&gt;with_instance_id(new_idx);
 557     _new_type_array.map(n-&gt;_idx, new_type);
 558     no_of_updates++;
 559   }
 560 
 561   return no_of_updates;
 562 }
 563 
 564 //=============================================================================
 565 //------------------------------PhaseTransform---------------------------------
 566 PhaseTransform::PhaseTransform( PhaseNumber pnum ) : Phase(pnum),
 567   _arena(Thread::current()-&gt;resource_area()),
 568   _nodes(_arena),
 569   _types(_arena)
 570 {
 571   init_con_caches();
 572 #ifndef PRODUCT
 573   clear_progress();
 574   clear_transforms();
 575   set_allow_progress(true);
 576 #endif
 577   // Force allocation for currently existing nodes
 578   _types.map(C-&gt;unique(), NULL);
 579 }
 580 
 581 //------------------------------PhaseTransform---------------------------------
 582 PhaseTransform::PhaseTransform( Arena *arena, PhaseNumber pnum ) : Phase(pnum),
 583   _arena(arena),
 584   _nodes(arena),
 585   _types(arena)
 586 {
 587   init_con_caches();
 588 #ifndef PRODUCT
 589   clear_progress();
 590   clear_transforms();
 591   set_allow_progress(true);
 592 #endif
 593   // Force allocation for currently existing nodes
 594   _types.map(C-&gt;unique(), NULL);
 595 }
 596 
 597 //------------------------------PhaseTransform---------------------------------
 598 // Initialize with previously generated type information
 599 PhaseTransform::PhaseTransform( PhaseTransform *pt, PhaseNumber pnum ) : Phase(pnum),
 600   _arena(pt-&gt;_arena),
 601   _nodes(pt-&gt;_nodes),
 602   _types(pt-&gt;_types)
 603 {
 604   init_con_caches();
 605 #ifndef PRODUCT
 606   clear_progress();
 607   clear_transforms();
 608   set_allow_progress(true);
 609 #endif
 610 }
 611 
 612 void PhaseTransform::init_con_caches() {
 613   memset(_icons,0,sizeof(_icons));
 614   memset(_lcons,0,sizeof(_lcons));
 615   memset(_zcons,0,sizeof(_zcons));
 616 }
 617 
 618 
 619 //--------------------------------find_int_type--------------------------------
 620 const TypeInt* PhaseTransform::find_int_type(Node* n) {
 621   if (n == NULL)  return NULL;
 622   // Call type_or_null(n) to determine node&#39;s type since we might be in
 623   // parse phase and call n-&gt;Value() may return wrong type.
 624   // (For example, a phi node at the beginning of loop parsing is not ready.)
 625   const Type* t = type_or_null(n);
 626   if (t == NULL)  return NULL;
 627   return t-&gt;isa_int();
 628 }
 629 
 630 
 631 //-------------------------------find_long_type--------------------------------
 632 const TypeLong* PhaseTransform::find_long_type(Node* n) {
 633   if (n == NULL)  return NULL;
 634   // (See comment above on type_or_null.)
 635   const Type* t = type_or_null(n);
 636   if (t == NULL)  return NULL;
 637   return t-&gt;isa_long();
 638 }
 639 
 640 
 641 #ifndef PRODUCT
 642 void PhaseTransform::dump_old2new_map() const {
 643   _nodes.dump();
 644 }
 645 
 646 void PhaseTransform::dump_new( uint nidx ) const {
 647   for( uint i=0; i&lt;_nodes.Size(); i++ )
 648     if( _nodes[i] &amp;&amp; _nodes[i]-&gt;_idx == nidx ) {
 649       _nodes[i]-&gt;dump();
 650       tty-&gt;cr();
 651       tty-&gt;print_cr(&quot;Old index= %d&quot;,i);
 652       return;
 653     }
 654   tty-&gt;print_cr(&quot;Node %d not found in the new indices&quot;, nidx);
 655 }
 656 
 657 //------------------------------dump_types-------------------------------------
 658 void PhaseTransform::dump_types( ) const {
 659   _types.dump();
 660 }
 661 
 662 //------------------------------dump_nodes_and_types---------------------------
 663 void PhaseTransform::dump_nodes_and_types(const Node* root, uint depth, bool only_ctrl) {
 664   VectorSet visited;
 665   dump_nodes_and_types_recur(root, depth, only_ctrl, visited);
 666 }
 667 
 668 //------------------------------dump_nodes_and_types_recur---------------------
 669 void PhaseTransform::dump_nodes_and_types_recur( const Node *n, uint depth, bool only_ctrl, VectorSet &amp;visited) {
 670   if( !n ) return;
 671   if( depth == 0 ) return;
 672   if( visited.test_set(n-&gt;_idx) ) return;
 673   for( uint i=0; i&lt;n-&gt;len(); i++ ) {
 674     if( only_ctrl &amp;&amp; !(n-&gt;is_Region()) &amp;&amp; i != TypeFunc::Control ) continue;
 675     dump_nodes_and_types_recur( n-&gt;in(i), depth-1, only_ctrl, visited );
 676   }
 677   n-&gt;dump();
 678   if (type_or_null(n) != NULL) {
 679     tty-&gt;print(&quot;      &quot;); type(n)-&gt;dump(); tty-&gt;cr();
 680   }
 681 }
 682 
 683 #endif
 684 
 685 
 686 //=============================================================================
 687 //------------------------------PhaseValues------------------------------------
 688 // Set minimum table size to &quot;255&quot;
 689 PhaseValues::PhaseValues( Arena *arena, uint est_max_size ) : PhaseTransform(arena, GVN), _table(arena, est_max_size) {
 690   NOT_PRODUCT( clear_new_values(); )
 691 }
 692 
 693 //------------------------------PhaseValues------------------------------------
 694 // Set minimum table size to &quot;255&quot;
 695 PhaseValues::PhaseValues( PhaseValues *ptv ) : PhaseTransform( ptv, GVN ),
 696   _table(&amp;ptv-&gt;_table) {
 697   NOT_PRODUCT( clear_new_values(); )
 698 }
 699 
 700 //------------------------------~PhaseValues-----------------------------------
 701 #ifndef PRODUCT
 702 PhaseValues::~PhaseValues() {
 703   _table.dump();
 704 
 705   // Statistics for value progress and efficiency
 706   if( PrintCompilation &amp;&amp; Verbose &amp;&amp; WizardMode ) {
 707     tty-&gt;print(&quot;\n%sValues: %d nodes ---&gt; %d/%d (%d)&quot;,
 708       is_IterGVN() ? &quot;Iter&quot; : &quot;    &quot;, C-&gt;unique(), made_progress(), made_transforms(), made_new_values());
 709     if( made_transforms() != 0 ) {
 710       tty-&gt;print_cr(&quot;  ratio %f&quot;, made_progress()/(float)made_transforms() );
 711     } else {
 712       tty-&gt;cr();
 713     }
 714   }
 715 }
 716 #endif
 717 
 718 //------------------------------makecon----------------------------------------
 719 ConNode* PhaseTransform::makecon(const Type *t) {
 720   assert(t-&gt;singleton(), &quot;must be a constant&quot;);
 721   assert(!t-&gt;empty() || t == Type::TOP, &quot;must not be vacuous range&quot;);
 722   switch (t-&gt;base()) {  // fast paths
 723   case Type::Half:
 724   case Type::Top:  return (ConNode*) C-&gt;top();
 725   case Type::Int:  return intcon( t-&gt;is_int()-&gt;get_con() );
 726   case Type::Long: return longcon( t-&gt;is_long()-&gt;get_con() );
 727   default:         break;
 728   }
 729   if (t-&gt;is_zero_type())
 730     return zerocon(t-&gt;basic_type());
 731   return uncached_makecon(t);
 732 }
 733 
 734 //--------------------------uncached_makecon-----------------------------------
 735 // Make an idealized constant - one of ConINode, ConPNode, etc.
 736 ConNode* PhaseValues::uncached_makecon(const Type *t) {
 737   assert(t-&gt;singleton(), &quot;must be a constant&quot;);
 738   ConNode* x = ConNode::make(t);
 739   ConNode* k = (ConNode*)hash_find_insert(x); // Value numbering
 740   if (k == NULL) {
 741     set_type(x, t);             // Missed, provide type mapping
 742     GrowableArray&lt;Node_Notes*&gt;* nna = C-&gt;node_note_array();
 743     if (nna != NULL) {
 744       Node_Notes* loc = C-&gt;locate_node_notes(nna, x-&gt;_idx, true);
 745       loc-&gt;clear(); // do not put debug info on constants
 746     }
 747   } else {
 748     x-&gt;destruct();              // Hit, destroy duplicate constant
 749     x = k;                      // use existing constant
 750   }
 751   return x;
 752 }
 753 
 754 //------------------------------intcon-----------------------------------------
 755 // Fast integer constant.  Same as &quot;transform(new ConINode(TypeInt::make(i)))&quot;
 756 ConINode* PhaseTransform::intcon(jint i) {
 757   // Small integer?  Check cache! Check that cached node is not dead
 758   if (i &gt;= _icon_min &amp;&amp; i &lt;= _icon_max) {
 759     ConINode* icon = _icons[i-_icon_min];
 760     if (icon != NULL &amp;&amp; icon-&gt;in(TypeFunc::Control) != NULL)
 761       return icon;
 762   }
 763   ConINode* icon = (ConINode*) uncached_makecon(TypeInt::make(i));
 764   assert(icon-&gt;is_Con(), &quot;&quot;);
 765   if (i &gt;= _icon_min &amp;&amp; i &lt;= _icon_max)
 766     _icons[i-_icon_min] = icon;   // Cache small integers
 767   return icon;
 768 }
 769 
 770 //------------------------------longcon----------------------------------------
 771 // Fast long constant.
 772 ConLNode* PhaseTransform::longcon(jlong l) {
 773   // Small integer?  Check cache! Check that cached node is not dead
 774   if (l &gt;= _lcon_min &amp;&amp; l &lt;= _lcon_max) {
 775     ConLNode* lcon = _lcons[l-_lcon_min];
 776     if (lcon != NULL &amp;&amp; lcon-&gt;in(TypeFunc::Control) != NULL)
 777       return lcon;
 778   }
 779   ConLNode* lcon = (ConLNode*) uncached_makecon(TypeLong::make(l));
 780   assert(lcon-&gt;is_Con(), &quot;&quot;);
 781   if (l &gt;= _lcon_min &amp;&amp; l &lt;= _lcon_max)
 782     _lcons[l-_lcon_min] = lcon;      // Cache small integers
 783   return lcon;
 784 }
 785 
 786 //------------------------------zerocon-----------------------------------------
 787 // Fast zero or null constant. Same as &quot;transform(ConNode::make(Type::get_zero_type(bt)))&quot;
 788 ConNode* PhaseTransform::zerocon(BasicType bt) {
 789   assert((uint)bt &lt;= _zcon_max, &quot;domain check&quot;);
 790   ConNode* zcon = _zcons[bt];
 791   if (zcon != NULL &amp;&amp; zcon-&gt;in(TypeFunc::Control) != NULL)
 792     return zcon;
 793   zcon = (ConNode*) uncached_makecon(Type::get_zero_type(bt));
 794   _zcons[bt] = zcon;
 795   return zcon;
 796 }
 797 
 798 
 799 
 800 //=============================================================================
 801 Node* PhaseGVN::apply_ideal(Node* k, bool can_reshape) {
 802   Node* i = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;ideal_node(this, k, can_reshape);
 803   if (i == NULL) {
 804     i = k-&gt;Ideal(this, can_reshape);
 805   }
 806   return i;
 807 }
 808 
 809 //------------------------------transform--------------------------------------
 810 // Return a node which computes the same function as this node, but in a
 811 // faster or cheaper fashion.
 812 Node *PhaseGVN::transform( Node *n ) {
 813   return transform_no_reclaim(n);
 814 }
 815 
 816 //------------------------------transform--------------------------------------
 817 // Return a node which computes the same function as this node, but
 818 // in a faster or cheaper fashion.
 819 Node *PhaseGVN::transform_no_reclaim( Node *n ) {
 820   NOT_PRODUCT( set_transforms(); )
 821 
 822   // Apply the Ideal call in a loop until it no longer applies
 823   Node *k = n;
 824   NOT_PRODUCT( uint loop_count = 0; )
 825   while( 1 ) {
 826     Node *i = apply_ideal(k, /*can_reshape=*/false);
 827     if( !i ) break;
 828     assert( i-&gt;_idx &gt;= k-&gt;_idx, &quot;Idealize should return new nodes, use Identity to return old nodes&quot; );
 829     k = i;
 830     assert(loop_count++ &lt; K, &quot;infinite loop in PhaseGVN::transform&quot;);
 831   }
 832   NOT_PRODUCT( if( loop_count != 0 ) { set_progress(); } )
 833 
 834 
 835   // If brand new node, make space in type array.
 836   ensure_type_or_null(k);
 837 
 838   // Since I just called &#39;Value&#39; to compute the set of run-time values
 839   // for this Node, and &#39;Value&#39; is non-local (and therefore expensive) I&#39;ll
 840   // cache Value.  Later requests for the local phase-&gt;type of this Node can
 841   // use the cached Value instead of suffering with &#39;bottom_type&#39;.
 842   const Type *t = k-&gt;Value(this); // Get runtime Value set
 843   assert(t != NULL, &quot;value sanity&quot;);
 844   if (type_or_null(k) != t) {
 845 #ifndef PRODUCT
 846     // Do not count initial visit to node as a transformation
 847     if (type_or_null(k) == NULL) {
 848       inc_new_values();
 849       set_progress();
 850     }
 851 #endif
 852     set_type(k, t);
 853     // If k is a TypeNode, capture any more-precise type permanently into Node
 854     k-&gt;raise_bottom_type(t);
 855   }
 856 
 857   if( t-&gt;singleton() &amp;&amp; !k-&gt;is_Con() ) {
 858     NOT_PRODUCT( set_progress(); )
 859     return makecon(t);          // Turn into a constant
 860   }
 861 
 862   // Now check for Identities
 863   Node *i = k-&gt;Identity(this);  // Look for a nearby replacement
 864   if( i != k ) {                // Found? Return replacement!
 865     NOT_PRODUCT( set_progress(); )
 866     return i;
 867   }
 868 
 869   // Global Value Numbering
 870   i = hash_find_insert(k);      // Insert if new
 871   if( i &amp;&amp; (i != k) ) {
 872     // Return the pre-existing node
 873     NOT_PRODUCT( set_progress(); )
 874     return i;
 875   }
 876 
 877   // Return Idealized original
 878   return k;
 879 }
 880 
 881 bool PhaseGVN::is_dominator_helper(Node *d, Node *n, bool linear_only) {
 882   if (d-&gt;is_top() || (d-&gt;is_Proj() &amp;&amp; d-&gt;in(0)-&gt;is_top())) {
 883     return false;
 884   }
 885   if (n-&gt;is_top() || (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
 886     return false;
 887   }
 888   assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
 889   int i = 0;
 890   while (d != n) {
 891     n = IfNode::up_one_dom(n, linear_only);
 892     i++;
 893     if (n == NULL || i &gt;= 100) {
 894       return false;
 895     }
 896   }
 897   return true;
 898 }
 899 
 900 #ifdef ASSERT
 901 //------------------------------dead_loop_check--------------------------------
 902 // Check for a simple dead loop when a data node references itself directly
 903 // or through an other data node excluding cons and phis.
 904 void PhaseGVN::dead_loop_check( Node *n ) {
 905   // Phi may reference itself in a loop
 906   if (n != NULL &amp;&amp; !n-&gt;is_dead_loop_safe() &amp;&amp; !n-&gt;is_CFG()) {
 907     // Do 2 levels check and only data inputs.
 908     bool no_dead_loop = true;
 909     uint cnt = n-&gt;req();
 910     for (uint i = 1; i &lt; cnt &amp;&amp; no_dead_loop; i++) {
 911       Node *in = n-&gt;in(i);
 912       if (in == n) {
 913         no_dead_loop = false;
 914       } else if (in != NULL &amp;&amp; !in-&gt;is_dead_loop_safe()) {
 915         uint icnt = in-&gt;req();
 916         for (uint j = 1; j &lt; icnt &amp;&amp; no_dead_loop; j++) {
 917           if (in-&gt;in(j) == n || in-&gt;in(j) == in)
 918             no_dead_loop = false;
 919         }
 920       }
 921     }
 922     if (!no_dead_loop) n-&gt;dump(3);
 923     assert(no_dead_loop, &quot;dead loop detected&quot;);
 924   }
 925 }
 926 #endif
 927 
 928 //=============================================================================
 929 //------------------------------PhaseIterGVN-----------------------------------
 930 // Initialize with previous PhaseIterGVN info; used by PhaseCCP
 931 PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn ) : PhaseGVN(igvn),
 932                                                    _delay_transform(igvn-&gt;_delay_transform),
 933                                                    _stack( igvn-&gt;_stack ),
 934                                                    _worklist( igvn-&gt;_worklist )
 935 {
 936 }
 937 
 938 //------------------------------PhaseIterGVN-----------------------------------
 939 // Initialize with previous PhaseGVN info from Parser
 940 PhaseIterGVN::PhaseIterGVN( PhaseGVN *gvn ) : PhaseGVN(gvn),
 941                                               _delay_transform(false),
 942 // TODO: Before incremental inlining it was allocated only once and it was fine. Now that
 943 //       the constructor is used in incremental inlining, this consumes too much memory:
 944 //                                            _stack(C-&gt;live_nodes() &gt;&gt; 1),
 945 //       So, as a band-aid, we replace this by:
 946                                               _stack(C-&gt;comp_arena(), 32),
 947                                               _worklist(*C-&gt;for_igvn())
 948 {
 949   uint max;
 950 
 951   // Dead nodes in the hash table inherited from GVN were not treated as
 952   // roots during def-use info creation; hence they represent an invisible
 953   // use.  Clear them out.
 954   max = _table.size();
 955   for( uint i = 0; i &lt; max; ++i ) {
 956     Node *n = _table.at(i);
 957     if(n != NULL &amp;&amp; n != _table.sentinel() &amp;&amp; n-&gt;outcnt() == 0) {
 958       if( n-&gt;is_top() ) continue;
 959       assert( false, &quot;Parse::remove_useless_nodes missed this node&quot;);
 960       hash_delete(n);
 961     }
 962   }
 963 
 964   // Any Phis or Regions on the worklist probably had uses that could not
 965   // make more progress because the uses were made while the Phis and Regions
 966   // were in half-built states.  Put all uses of Phis and Regions on worklist.
 967   max = _worklist.size();
 968   for( uint j = 0; j &lt; max; j++ ) {
 969     Node *n = _worklist.at(j);
 970     uint uop = n-&gt;Opcode();
 971     if( uop == Op_Phi || uop == Op_Region ||
 972         n-&gt;is_Type() ||
 973         n-&gt;is_Mem() )
 974       add_users_to_worklist(n);
 975   }
 976 }
 977 
 978 /**
 979  * Initialize worklist for each node.
 980  */
 981 void PhaseIterGVN::init_worklist(Node* first) {
 982   Unique_Node_List to_process;
 983   to_process.push(first);
 984 
 985   while (to_process.size() &gt; 0) {
 986     Node* n = to_process.pop();
 987     if (!_worklist.member(n)) {
 988       _worklist.push(n);
 989 
 990       uint cnt = n-&gt;req();
 991       for(uint i = 0; i &lt; cnt; i++) {
 992         Node* m = n-&gt;in(i);
 993         if (m != NULL) {
 994           to_process.push(m);
 995         }
 996       }
 997     }
 998   }
 999 }
1000 
1001 #ifndef PRODUCT
1002 void PhaseIterGVN::verify_step(Node* n) {
1003   if (VerifyIterativeGVN) {
1004     _verify_window[_verify_counter % _verify_window_size] = n;
1005     ++_verify_counter;
1006     if (C-&gt;unique() &lt; 1000 || 0 == _verify_counter % (C-&gt;unique() &lt; 10000 ? 10 : 100)) {
1007       ++_verify_full_passes;
1008       Node::verify(C-&gt;root(), -1);
1009     }
1010     for (int i = 0; i &lt; _verify_window_size; i++) {
1011       Node* n = _verify_window[i];
1012       if (n == NULL) {
1013         continue;
1014       }
1015       if (n-&gt;in(0) == NodeSentinel) { // xform_idom
1016         _verify_window[i] = n-&gt;in(1);
1017         --i;
1018         continue;
1019       }
1020       // Typical fanout is 1-2, so this call visits about 6 nodes.
1021       Node::verify(n, 4);
1022     }
1023   }
1024 }
1025 
1026 void PhaseIterGVN::trace_PhaseIterGVN(Node* n, Node* nn, const Type* oldtype) {
1027   if (TraceIterativeGVN) {
1028     uint wlsize = _worklist.size();
1029     const Type* newtype = type_or_null(n);
1030     if (nn != n) {
1031       // print old node
1032       tty-&gt;print(&quot;&lt; &quot;);
1033       if (oldtype != newtype &amp;&amp; oldtype != NULL) {
1034         oldtype-&gt;dump();
1035       }
1036       do { tty-&gt;print(&quot;\t&quot;); } while (tty-&gt;position() &lt; 16);
1037       tty-&gt;print(&quot;&lt;&quot;);
1038       n-&gt;dump();
1039     }
1040     if (oldtype != newtype || nn != n) {
1041       // print new node and/or new type
1042       if (oldtype == NULL) {
1043         tty-&gt;print(&quot;* &quot;);
1044       } else if (nn != n) {
1045         tty-&gt;print(&quot;&gt; &quot;);
1046       } else {
1047         tty-&gt;print(&quot;= &quot;);
1048       }
1049       if (newtype == NULL) {
1050         tty-&gt;print(&quot;null&quot;);
1051       } else {
1052         newtype-&gt;dump();
1053       }
1054       do { tty-&gt;print(&quot;\t&quot;); } while (tty-&gt;position() &lt; 16);
1055       nn-&gt;dump();
1056     }
1057     if (Verbose &amp;&amp; wlsize &lt; _worklist.size()) {
1058       tty-&gt;print(&quot;  Push {&quot;);
1059       while (wlsize != _worklist.size()) {
1060         Node* pushed = _worklist.at(wlsize++);
1061         tty-&gt;print(&quot; %d&quot;, pushed-&gt;_idx);
1062       }
1063       tty-&gt;print_cr(&quot; }&quot;);
1064     }
1065     if (nn != n) {
1066       // ignore n, it might be subsumed
1067       verify_step((Node*) NULL);
1068     }
1069   }
1070 }
1071 
1072 void PhaseIterGVN::init_verifyPhaseIterGVN() {
1073   _verify_counter = 0;
1074   _verify_full_passes = 0;
1075   for (int i = 0; i &lt; _verify_window_size; i++) {
1076     _verify_window[i] = NULL;
1077   }
1078 #ifdef ASSERT
1079   // Verify that all modified nodes are on _worklist
1080   Unique_Node_List* modified_list = C-&gt;modified_nodes();
1081   while (modified_list != NULL &amp;&amp; modified_list-&gt;size()) {
1082     Node* n = modified_list-&gt;pop();
1083     if (n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con() &amp;&amp; !_worklist.member(n)) {
1084       n-&gt;dump();
1085       assert(false, &quot;modified node is not on IGVN._worklist&quot;);
1086     }
1087   }
1088 #endif
1089 }
1090 
1091 void PhaseIterGVN::verify_PhaseIterGVN() {
1092 #ifdef ASSERT
1093   // Verify nodes with changed inputs.
1094   Unique_Node_List* modified_list = C-&gt;modified_nodes();
1095   while (modified_list != NULL &amp;&amp; modified_list-&gt;size()) {
1096     Node* n = modified_list-&gt;pop();
1097     if (n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con()) { // skip dead and Con nodes
1098       n-&gt;dump();
1099       assert(false, &quot;modified node was not processed by IGVN.transform_old()&quot;);
1100     }
1101   }
1102 #endif
1103 
1104   C-&gt;verify_graph_edges();
1105   if (VerifyIterativeGVN &amp;&amp; PrintOpto) {
1106     if (_verify_counter == _verify_full_passes) {
1107       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms and verify passes&quot;,
1108                     (int) _verify_full_passes);
1109     } else {
1110       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms, %d full verify passes&quot;,
1111                   (int) _verify_counter, (int) _verify_full_passes);
1112     }
1113   }
1114 
1115 #ifdef ASSERT
1116   while (modified_list-&gt;size()) {
1117     Node* n = modified_list-&gt;pop();
1118     n-&gt;dump();
1119     assert(false, &quot;VerifyIterativeGVN: new modified node was added&quot;);
1120   }
1121 #endif
1122 }
1123 #endif /* PRODUCT */
1124 
1125 #ifdef ASSERT
1126 /**
1127  * Dumps information that can help to debug the problem. A debug
1128  * build fails with an assert.
1129  */
1130 void PhaseIterGVN::dump_infinite_loop_info(Node* n) {
1131   n-&gt;dump(4);
1132   _worklist.dump();
1133   assert(false, &quot;infinite loop in PhaseIterGVN::optimize&quot;);
1134 }
1135 
1136 /**
1137  * Prints out information about IGVN if the &#39;verbose&#39; option is used.
1138  */
1139 void PhaseIterGVN::trace_PhaseIterGVN_verbose(Node* n, int num_processed) {
1140   if (TraceIterativeGVN &amp;&amp; Verbose) {
1141     tty-&gt;print(&quot;  Pop &quot;);
1142     n-&gt;dump();
1143     if ((num_processed % 100) == 0) {
1144       _worklist.print_set();
1145     }
1146   }
1147 }
1148 #endif /* ASSERT */
1149 
1150 void PhaseIterGVN::optimize() {
1151   DEBUG_ONLY(uint num_processed  = 0;)
1152   NOT_PRODUCT(init_verifyPhaseIterGVN();)
1153 
1154   uint loop_count = 0;
1155   // Pull from worklist and transform the node. If the node has changed,
1156   // update edge info and put uses on worklist.
1157   while(_worklist.size()) {
1158     if (C-&gt;check_node_count(NodeLimitFudgeFactor * 2, &quot;Out of nodes&quot;)) {
1159       return;
1160     }
1161     Node* n  = _worklist.pop();
1162     if (++loop_count &gt;= K * C-&gt;live_nodes()) {
1163       DEBUG_ONLY(dump_infinite_loop_info(n);)
1164       C-&gt;record_method_not_compilable(&quot;infinite loop in PhaseIterGVN::optimize&quot;);
1165       return;
1166     }
1167     DEBUG_ONLY(trace_PhaseIterGVN_verbose(n, num_processed++);)
1168     if (n-&gt;outcnt() != 0) {
1169       NOT_PRODUCT(const Type* oldtype = type_or_null(n));
1170       // Do the transformation
1171       Node* nn = transform_old(n);
1172       NOT_PRODUCT(trace_PhaseIterGVN(n, nn, oldtype);)
1173     } else if (!n-&gt;is_top()) {
1174       remove_dead_node(n);
1175     }
1176   }
1177   NOT_PRODUCT(verify_PhaseIterGVN();)
1178 }
1179 
1180 
1181 /**
1182  * Register a new node with the optimizer.  Update the types array, the def-use
1183  * info.  Put on worklist.
1184  */
1185 Node* PhaseIterGVN::register_new_node_with_optimizer(Node* n, Node* orig) {
1186   set_type_bottom(n);
1187   _worklist.push(n);
1188   if (orig != NULL)  C-&gt;copy_node_notes_to(n, orig);
1189   return n;
1190 }
1191 
1192 //------------------------------transform--------------------------------------
1193 // Non-recursive: idealize Node &#39;n&#39; with respect to its inputs and its value
1194 Node *PhaseIterGVN::transform( Node *n ) {
1195   // If brand new node, make space in type array, and give it a type.
1196   ensure_type_or_null(n);
1197   if (type_or_null(n) == NULL) {
1198     set_type_bottom(n);
1199   }
1200 
1201   if (_delay_transform) {
1202     // Add the node to the worklist but don&#39;t optimize for now
1203     _worklist.push(n);
1204     return n;
1205   }
1206 
1207   return transform_old(n);
1208 }
1209 
1210 Node *PhaseIterGVN::transform_old(Node* n) {
1211   DEBUG_ONLY(uint loop_count = 0;);
1212   NOT_PRODUCT(set_transforms());
1213 
1214   // Remove &#39;n&#39; from hash table in case it gets modified
1215   _table.hash_delete(n);
1216   if (VerifyIterativeGVN) {
1217    assert(!_table.find_index(n-&gt;_idx), &quot;found duplicate entry in table&quot;);
1218   }
1219 
1220   // Apply the Ideal call in a loop until it no longer applies
1221   Node* k = n;
1222   DEBUG_ONLY(dead_loop_check(k);)
1223   DEBUG_ONLY(bool is_new = (k-&gt;outcnt() == 0);)
1224   C-&gt;remove_modified_node(k);
1225   Node* i = apply_ideal(k, /*can_reshape=*/true);
1226   assert(i != k || is_new || i-&gt;outcnt() &gt; 0, &quot;don&#39;t return dead nodes&quot;);
1227 #ifndef PRODUCT
1228   verify_step(k);
1229 #endif
1230 
1231   while (i != NULL) {
1232 #ifdef ASSERT
1233     if (loop_count &gt;= K) {
1234       dump_infinite_loop_info(i);
1235     }
1236     loop_count++;
1237 #endif
1238     assert((i-&gt;_idx &gt;= k-&gt;_idx) || i-&gt;is_top(), &quot;Idealize should return new nodes, use Identity to return old nodes&quot;);
1239     // Made a change; put users of original Node on worklist
1240     add_users_to_worklist(k);
1241     // Replacing root of transform tree?
1242     if (k != i) {
1243       // Make users of old Node now use new.
1244       subsume_node(k, i);
1245       k = i;
1246     }
1247     DEBUG_ONLY(dead_loop_check(k);)
1248     // Try idealizing again
1249     DEBUG_ONLY(is_new = (k-&gt;outcnt() == 0);)
1250     C-&gt;remove_modified_node(k);
1251     i = apply_ideal(k, /*can_reshape=*/true);
1252     assert(i != k || is_new || (i-&gt;outcnt() &gt; 0), &quot;don&#39;t return dead nodes&quot;);
1253 #ifndef PRODUCT
1254     verify_step(k);
1255 #endif
1256   }
1257 
1258   // If brand new node, make space in type array.
1259   ensure_type_or_null(k);
1260 
1261   // See what kind of values &#39;k&#39; takes on at runtime
1262   const Type* t = k-&gt;Value(this);
1263   assert(t != NULL, &quot;value sanity&quot;);
1264 
1265   // Since I just called &#39;Value&#39; to compute the set of run-time values
1266   // for this Node, and &#39;Value&#39; is non-local (and therefore expensive) I&#39;ll
1267   // cache Value.  Later requests for the local phase-&gt;type of this Node can
1268   // use the cached Value instead of suffering with &#39;bottom_type&#39;.
1269   if (type_or_null(k) != t) {
1270 #ifndef PRODUCT
1271     inc_new_values();
1272     set_progress();
1273 #endif
1274     set_type(k, t);
1275     // If k is a TypeNode, capture any more-precise type permanently into Node
1276     k-&gt;raise_bottom_type(t);
1277     // Move users of node to worklist
1278     add_users_to_worklist(k);
1279   }
1280   // If &#39;k&#39; computes a constant, replace it with a constant
1281   if (t-&gt;singleton() &amp;&amp; !k-&gt;is_Con()) {
1282     NOT_PRODUCT(set_progress();)
1283     Node* con = makecon(t);     // Make a constant
1284     add_users_to_worklist(k);
1285     subsume_node(k, con);       // Everybody using k now uses con
1286     return con;
1287   }
1288 
1289   // Now check for Identities
1290   i = k-&gt;Identity(this);      // Look for a nearby replacement
1291   if (i != k) {                // Found? Return replacement!
1292     NOT_PRODUCT(set_progress();)
1293     add_users_to_worklist(k);
1294     subsume_node(k, i);       // Everybody using k now uses i
1295     return i;
1296   }
1297 
1298   // Global Value Numbering
1299   i = hash_find_insert(k);      // Check for pre-existing node
1300   if (i &amp;&amp; (i != k)) {
1301     // Return the pre-existing node if it isn&#39;t dead
1302     NOT_PRODUCT(set_progress();)
1303     add_users_to_worklist(k);
1304     subsume_node(k, i);       // Everybody using k now uses i
1305     return i;
1306   }
1307 
1308   // Return Idealized original
1309   return k;
1310 }
1311 
1312 //---------------------------------saturate------------------------------------
1313 const Type* PhaseIterGVN::saturate(const Type* new_type, const Type* old_type,
1314                                    const Type* limit_type) const {
1315   return new_type-&gt;narrow(old_type);
1316 }
1317 
1318 //------------------------------remove_globally_dead_node----------------------
1319 // Kill a globally dead Node.  All uses are also globally dead and are
1320 // aggressively trimmed.
1321 void PhaseIterGVN::remove_globally_dead_node( Node *dead ) {
1322   enum DeleteProgress {
1323     PROCESS_INPUTS,
1324     PROCESS_OUTPUTS
1325   };
1326   assert(_stack.is_empty(), &quot;not empty&quot;);
1327   _stack.push(dead, PROCESS_INPUTS);
1328 
1329   while (_stack.is_nonempty()) {
1330     dead = _stack.node();
1331     if (dead-&gt;Opcode() == Op_SafePoint) {
1332       dead-&gt;as_SafePoint()-&gt;disconnect_from_root(this);
1333     }
1334     uint progress_state = _stack.index();
1335     assert(dead != C-&gt;root(), &quot;killing root, eh?&quot;);
1336     assert(!dead-&gt;is_top(), &quot;add check for top when pushing&quot;);
1337     NOT_PRODUCT( set_progress(); )
1338     if (progress_state == PROCESS_INPUTS) {
1339       // After following inputs, continue to outputs
1340       _stack.set_index(PROCESS_OUTPUTS);
1341       if (!dead-&gt;is_Con()) { // Don&#39;t kill cons but uses
1342         bool recurse = false;
1343         // Remove from hash table
1344         _table.hash_delete( dead );
1345         // Smash all inputs to &#39;dead&#39;, isolating him completely
1346         for (uint i = 0; i &lt; dead-&gt;req(); i++) {
1347           Node *in = dead-&gt;in(i);
1348           if (in != NULL &amp;&amp; in != C-&gt;top()) {  // Points to something?
1349             int nrep = dead-&gt;replace_edge(in, NULL);  // Kill edges
1350             assert((nrep &gt; 0), &quot;sanity&quot;);
1351             if (in-&gt;outcnt() == 0) { // Made input go dead?
1352               _stack.push(in, PROCESS_INPUTS); // Recursively remove
1353               recurse = true;
1354             } else if (in-&gt;outcnt() == 1 &amp;&amp;
1355                        in-&gt;has_special_unique_user()) {
1356               _worklist.push(in-&gt;unique_out());
1357             } else if (in-&gt;outcnt() &lt;= 2 &amp;&amp; dead-&gt;is_Phi()) {
1358               if (in-&gt;Opcode() == Op_Region) {
1359                 _worklist.push(in);
1360               } else if (in-&gt;is_Store()) {
1361                 DUIterator_Fast imax, i = in-&gt;fast_outs(imax);
1362                 _worklist.push(in-&gt;fast_out(i));
1363                 i++;
1364                 if (in-&gt;outcnt() == 2) {
1365                   _worklist.push(in-&gt;fast_out(i));
1366                   i++;
1367                 }
1368                 assert(!(i &lt; imax), &quot;sanity&quot;);
1369               }
1370             } else {
1371               BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;enqueue_useful_gc_barrier(this, in);
1372             }
1373             if (ReduceFieldZeroing &amp;&amp; dead-&gt;is_Load() &amp;&amp; i == MemNode::Memory &amp;&amp;
1374                 in-&gt;is_Proj() &amp;&amp; in-&gt;in(0) != NULL &amp;&amp; in-&gt;in(0)-&gt;is_Initialize()) {
1375               // A Load that directly follows an InitializeNode is
1376               // going away. The Stores that follow are candidates
1377               // again to be captured by the InitializeNode.
1378               for (DUIterator_Fast jmax, j = in-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1379                 Node *n = in-&gt;fast_out(j);
1380                 if (n-&gt;is_Store()) {
1381                   _worklist.push(n);
1382                 }
1383               }
1384             }
1385           } // if (in != NULL &amp;&amp; in != C-&gt;top())
1386         } // for (uint i = 0; i &lt; dead-&gt;req(); i++)
1387         if (recurse) {
1388           continue;
1389         }
1390       } // if (!dead-&gt;is_Con())
1391     } // if (progress_state == PROCESS_INPUTS)
1392 
1393     // Aggressively kill globally dead uses
1394     // (Rather than pushing all the outs at once, we push one at a time,
1395     // plus the parent to resume later, because of the indefinite number
1396     // of edge deletions per loop trip.)
1397     if (dead-&gt;outcnt() &gt; 0) {
1398       // Recursively remove output edges
1399       _stack.push(dead-&gt;raw_out(0), PROCESS_INPUTS);
1400     } else {
1401       // Finished disconnecting all input and output edges.
1402       _stack.pop();
1403       // Remove dead node from iterative worklist
1404       _worklist.remove(dead);
1405       C-&gt;remove_modified_node(dead);
1406       // Constant node that has no out-edges and has only one in-edge from
1407       // root is usually dead. However, sometimes reshaping walk makes
1408       // it reachable by adding use edges. So, we will NOT count Con nodes
1409       // as dead to be conservative about the dead node count at any
1410       // given time.
1411       if (!dead-&gt;is_Con()) {
1412         C-&gt;record_dead_node(dead-&gt;_idx);
1413       }
1414       if (dead-&gt;is_macro()) {
1415         C-&gt;remove_macro_node(dead);
1416       }
1417       if (dead-&gt;is_expensive()) {
1418         C-&gt;remove_expensive_node(dead);
1419       }
1420       CastIINode* cast = dead-&gt;isa_CastII();
1421       if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
1422         C-&gt;remove_range_check_cast(cast);
1423       }
1424       if (dead-&gt;Opcode() == Op_Opaque4) {
1425         C-&gt;remove_opaque4_node(dead);
1426       }
1427       if (dead-&gt;is_InlineTypeBase()) {
1428         C-&gt;remove_inline_type(dead);
1429       }
1430       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1431       bs-&gt;unregister_potential_barrier_node(dead);
1432     }
1433   } // while (_stack.is_nonempty())
1434 }
1435 
1436 //------------------------------subsume_node-----------------------------------
1437 // Remove users from node &#39;old&#39; and add them to node &#39;nn&#39;.
1438 void PhaseIterGVN::subsume_node( Node *old, Node *nn ) {
1439   if (old-&gt;Opcode() == Op_SafePoint) {
1440     old-&gt;as_SafePoint()-&gt;disconnect_from_root(this);
1441   }
1442   assert( old != hash_find(old), &quot;should already been removed&quot; );
1443   assert( old != C-&gt;top(), &quot;cannot subsume top node&quot;);
1444   // Copy debug or profile information to the new version:
1445   C-&gt;copy_node_notes_to(nn, old);
1446   // Move users of node &#39;old&#39; to node &#39;nn&#39;
1447   for (DUIterator_Last imin, i = old-&gt;last_outs(imin); i &gt;= imin; ) {
1448     Node* use = old-&gt;last_out(i);  // for each use...
1449     // use might need re-hashing (but it won&#39;t if it&#39;s a new node)
1450     rehash_node_delayed(use);
1451     // Update use-def info as well
1452     // We remove all occurrences of old within use-&gt;in,
1453     // so as to avoid rehashing any node more than once.
1454     // The hash table probe swamps any outer loop overhead.
1455     uint num_edges = 0;
1456     for (uint jmax = use-&gt;len(), j = 0; j &lt; jmax; j++) {
1457       if (use-&gt;in(j) == old) {
1458         use-&gt;set_req(j, nn);
1459         ++num_edges;
1460       }
1461     }
1462     i -= num_edges;    // we deleted 1 or more copies of this edge
1463   }
1464 
1465   // Search for instance field data PhiNodes in the same region pointing to the old
1466   // memory PhiNode and update their instance memory ids to point to the new node.
1467   if (old-&gt;is_Phi() &amp;&amp; old-&gt;as_Phi()-&gt;type()-&gt;has_memory() &amp;&amp; old-&gt;in(0) != NULL) {
1468     Node* region = old-&gt;in(0);
1469     for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
1470       PhiNode* phi = region-&gt;fast_out(i)-&gt;isa_Phi();
1471       if (phi != NULL &amp;&amp; phi-&gt;inst_mem_id() == (int)old-&gt;_idx) {
1472         phi-&gt;set_inst_mem_id((int)nn-&gt;_idx);
1473       }
1474     }
1475   }
1476 
1477   // Smash all inputs to &#39;old&#39;, isolating him completely
1478   Node *temp = new Node(1);
1479   temp-&gt;init_req(0,nn);     // Add a use to nn to prevent him from dying
1480   remove_dead_node( old );
1481   temp-&gt;del_req(0);         // Yank bogus edge
1482 #ifndef PRODUCT
1483   if( VerifyIterativeGVN ) {
1484     for ( int i = 0; i &lt; _verify_window_size; i++ ) {
1485       if ( _verify_window[i] == old )
1486         _verify_window[i] = nn;
1487     }
1488   }
1489 #endif
1490   _worklist.remove(temp);   // this can be necessary
1491   temp-&gt;destruct();         // reuse the _idx of this little guy
1492 }
1493 
1494 void PhaseIterGVN::replace_in_uses(Node* n, Node* m) {
1495   assert(n != NULL, &quot;sanity&quot;);
1496   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1497     Node* u = n-&gt;fast_out(i);
1498     if (u != n) {
1499       rehash_node_delayed(u);
1500       int nb = u-&gt;replace_edge(n, m);
1501       --i, imax -= nb;
1502     }
1503   }
1504   assert(n-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);
1505 }
1506 
1507 //------------------------------add_users_to_worklist--------------------------
1508 void PhaseIterGVN::add_users_to_worklist0( Node *n ) {
1509   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1510     _worklist.push(n-&gt;fast_out(i));  // Push on worklist
1511   }
1512 }
1513 
1514 // Return counted loop Phi if as a counted loop exit condition, cmp
1515 // compares the the induction variable with n
1516 static PhiNode* countedloop_phi_from_cmp(CmpINode* cmp, Node* n) {
1517   for (DUIterator_Fast imax, i = cmp-&gt;fast_outs(imax); i &lt; imax; i++) {
1518     Node* bol = cmp-&gt;fast_out(i);
1519     for (DUIterator_Fast i2max, i2 = bol-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1520       Node* iff = bol-&gt;fast_out(i2);
1521       if (iff-&gt;is_CountedLoopEnd()) {
1522         CountedLoopEndNode* cle = iff-&gt;as_CountedLoopEnd();
1523         if (cle-&gt;limit() == n) {
1524           PhiNode* phi = cle-&gt;phi();
1525           if (phi != NULL) {
1526             return phi;
1527           }
1528         }
1529       }
1530     }
1531   }
1532   return NULL;
1533 }
1534 
1535 void PhaseIterGVN::add_users_to_worklist( Node *n ) {
1536   add_users_to_worklist0(n);
1537 
1538   // Move users of node to worklist
1539   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1540     Node* use = n-&gt;fast_out(i); // Get use
1541 
1542     if( use-&gt;is_Multi() ||      // Multi-definer?  Push projs on worklist
1543         use-&gt;is_Store() )       // Enable store/load same address
1544       add_users_to_worklist0(use);
1545 
1546     // If we changed the receiver type to a call, we need to revisit
1547     // the Catch following the call.  It&#39;s looking for a non-NULL
1548     // receiver to know when to enable the regular fall-through path
1549     // in addition to the NullPtrException path.
1550     if (use-&gt;is_CallDynamicJava() &amp;&amp; n == use-&gt;in(TypeFunc::Parms)) {
1551       Node* p = use-&gt;as_CallDynamicJava()-&gt;proj_out_or_null(TypeFunc::Control);
1552       if (p != NULL) {
1553         add_users_to_worklist0(p);
1554       }
1555     }
1556 
1557     uint use_op = use-&gt;Opcode();
1558     if(use-&gt;is_Cmp()) {       // Enable CMP/BOOL optimization
1559       add_users_to_worklist(use); // Put Bool on worklist
1560       if (use-&gt;outcnt() &gt; 0) {
1561         Node* bol = use-&gt;raw_out(0);
1562         if (bol-&gt;outcnt() &gt; 0) {
1563           Node* iff = bol-&gt;raw_out(0);
1564           if (iff-&gt;outcnt() == 2) {
1565             // Look for the &#39;is_x2logic&#39; pattern: &quot;x ? : 0 : 1&quot; and put the
1566             // phi merging either 0 or 1 onto the worklist
1567             Node* ifproj0 = iff-&gt;raw_out(0);
1568             Node* ifproj1 = iff-&gt;raw_out(1);
1569             if (ifproj0-&gt;outcnt() &gt; 0 &amp;&amp; ifproj1-&gt;outcnt() &gt; 0) {
1570               Node* region0 = ifproj0-&gt;raw_out(0);
1571               Node* region1 = ifproj1-&gt;raw_out(0);
1572               if( region0 == region1 )
1573                 add_users_to_worklist0(region0);
1574             }
1575           }
1576         }
1577       }
1578       if (use_op == Op_CmpI) {
1579         Node* phi = countedloop_phi_from_cmp((CmpINode*)use, n);
1580         if (phi != NULL) {
1581           // If an opaque node feeds into the limit condition of a
1582           // CountedLoop, we need to process the Phi node for the
1583           // induction variable when the opaque node is removed:
1584           // the range of values taken by the Phi is now known and
1585           // so its type is also known.
1586           _worklist.push(phi);
1587         }
1588         Node* in1 = use-&gt;in(1);
1589         for (uint i = 0; i &lt; in1-&gt;outcnt(); i++) {
1590           if (in1-&gt;raw_out(i)-&gt;Opcode() == Op_CastII) {
1591             Node* castii = in1-&gt;raw_out(i);
1592             if (castii-&gt;in(0) != NULL &amp;&amp; castii-&gt;in(0)-&gt;in(0) != NULL &amp;&amp; castii-&gt;in(0)-&gt;in(0)-&gt;is_If()) {
1593               Node* ifnode = castii-&gt;in(0)-&gt;in(0);
1594               if (ifnode-&gt;in(1) != NULL &amp;&amp; ifnode-&gt;in(1)-&gt;is_Bool() &amp;&amp; ifnode-&gt;in(1)-&gt;in(1) == use) {
1595                 // Reprocess a CastII node that may depend on an
1596                 // opaque node value when the opaque node is
1597                 // removed. In case it carries a dependency we can do
1598                 // a better job of computing its type.
1599                 _worklist.push(castii);
1600               }
1601             }
1602           }
1603         }
1604       }
1605     }
1606 
1607     // Inline type nodes can have other inline types as users. If an input gets
1608     // updated, make sure that inline type users get a chance for optimization.
1609     if (use-&gt;is_InlineTypeBase()) {
1610       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1611         Node* u = use-&gt;fast_out(i2);
1612         if (u-&gt;is_InlineTypeBase())
1613           _worklist.push(u);
1614       }
1615     }
1616     // If changed Cast input, check Phi users for simple cycles
1617     if (use-&gt;is_ConstraintCast()) {
1618       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1619         Node* u = use-&gt;fast_out(i2);
1620         if (u-&gt;is_Phi())
1621           _worklist.push(u);
1622       }
1623     }
1624     // If changed LShift inputs, check RShift users for useless sign-ext
1625     if( use_op == Op_LShiftI ) {
1626       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1627         Node* u = use-&gt;fast_out(i2);
1628         if (u-&gt;Opcode() == Op_RShiftI)
1629           _worklist.push(u);
1630       }
1631     }
1632     // If changed AddI/SubI inputs, check CmpU for range check optimization.
1633     if (use_op == Op_AddI || use_op == Op_SubI) {
1634       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1635         Node* u = use-&gt;fast_out(i2);
1636         if (u-&gt;is_Cmp() &amp;&amp; (u-&gt;Opcode() == Op_CmpU)) {
1637           _worklist.push(u);
1638         }
1639       }
1640     }
1641     // If changed AddP inputs, check Stores for loop invariant
1642     if( use_op == Op_AddP ) {
1643       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1644         Node* u = use-&gt;fast_out(i2);
1645         if (u-&gt;is_Mem())
1646           _worklist.push(u);
1647       }
1648     }
1649     // If changed initialization activity, check dependent Stores
1650     if (use_op == Op_Allocate || use_op == Op_AllocateArray) {
1651       InitializeNode* init = use-&gt;as_Allocate()-&gt;initialization();
1652       if (init != NULL) {
1653         Node* imem = init-&gt;proj_out_or_null(TypeFunc::Memory);
1654         if (imem != NULL)  add_users_to_worklist0(imem);
1655       }
1656     }
1657     if (use_op == Op_Initialize) {
1658       Node* imem = use-&gt;as_Initialize()-&gt;proj_out_or_null(TypeFunc::Memory);
1659       if (imem != NULL)  add_users_to_worklist0(imem);
1660     }
1661     if (use_op == Op_CastP2X) {
1662       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1663         Node* u = use-&gt;fast_out(i2);
1664         if (u-&gt;Opcode() == Op_AndX) {
1665           _worklist.push(u);
1666         }
1667       }
1668     }
1669     // Loading the java mirror from a Klass requires two loads and the type
1670     // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1671     //   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))
1672     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1673     bool has_load_barrier_nodes = bs-&gt;has_load_barrier_nodes();
1674 
1675     if (use_op == Op_LoadP &amp;&amp; use-&gt;bottom_type()-&gt;isa_rawptr()) {
1676       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1677         Node* u = use-&gt;fast_out(i2);
1678         const Type* ut = u-&gt;bottom_type();
1679         if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr()) {
1680           if (has_load_barrier_nodes) {
1681             // Search for load barriers behind the load
1682             for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1683               Node* b = u-&gt;fast_out(i3);
1684               if (bs-&gt;is_gc_barrier_node(b)) {
1685                 _worklist.push(b);
1686               }
1687             }
1688           }
1689           _worklist.push(u);
1690         }
1691       }
1692     }
1693 
1694     // Give CallStaticJavaNode::remove_useless_allocation a chance to run
1695     if (use-&gt;is_Region()) {
1696       Node* c = use;
1697       do {
1698         c = c-&gt;unique_ctrl_out();
1699       } while (c != NULL &amp;&amp; c-&gt;is_Region());
1700       if (c != NULL &amp;&amp; c-&gt;is_CallStaticJava() &amp;&amp; c-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) {
1701         _worklist.push(c);
1702       }
1703     }
1704   }
1705 }
1706 
1707 /**
1708  * Remove the speculative part of all types that we know of
1709  */
1710 void PhaseIterGVN::remove_speculative_types()  {
1711   assert(UseTypeSpeculation, &quot;speculation is off&quot;);
1712   for (uint i = 0; i &lt; _types.Size(); i++)  {
1713     const Type* t = _types.fast_lookup(i);
1714     if (t != NULL) {
1715       _types.map(i, t-&gt;remove_speculative());
1716     }
1717   }
1718   _table.check_no_speculative_types();
1719 }
1720 
1721 //=============================================================================
1722 #ifndef PRODUCT
1723 uint PhaseCCP::_total_invokes   = 0;
1724 uint PhaseCCP::_total_constants = 0;
1725 #endif
1726 //------------------------------PhaseCCP---------------------------------------
1727 // Conditional Constant Propagation, ala Wegman &amp; Zadeck
1728 PhaseCCP::PhaseCCP( PhaseIterGVN *igvn ) : PhaseIterGVN(igvn) {
1729   NOT_PRODUCT( clear_constants(); )
1730   assert( _worklist.size() == 0, &quot;&quot; );
1731   // Clear out _nodes from IterGVN.  Must be clear to transform call.
1732   _nodes.clear();               // Clear out from IterGVN
1733   analyze();
1734 }
1735 
1736 #ifndef PRODUCT
1737 //------------------------------~PhaseCCP--------------------------------------
1738 PhaseCCP::~PhaseCCP() {
1739   inc_invokes();
1740   _total_constants += count_constants();
1741 }
1742 #endif
1743 
1744 
1745 #ifdef ASSERT
1746 static bool ccp_type_widens(const Type* t, const Type* t0) {
1747   assert(t-&gt;meet(t0) == t, &quot;Not monotonic&quot;);
1748   switch (t-&gt;base() == t0-&gt;base() ? t-&gt;base() : Type::Top) {
1749   case Type::Int:
1750     assert(t0-&gt;isa_int()-&gt;_widen &lt;= t-&gt;isa_int()-&gt;_widen, &quot;widen increases&quot;);
1751     break;
1752   case Type::Long:
1753     assert(t0-&gt;isa_long()-&gt;_widen &lt;= t-&gt;isa_long()-&gt;_widen, &quot;widen increases&quot;);
1754     break;
1755   default:
1756     break;
1757   }
1758   return true;
1759 }
1760 #endif //ASSERT
1761 
1762 //------------------------------analyze----------------------------------------
1763 void PhaseCCP::analyze() {
1764   // Initialize all types to TOP, optimistic analysis
1765   for (int i = C-&gt;unique() - 1; i &gt;= 0; i--)  {
1766     _types.map(i,Type::TOP);
1767   }
1768 
1769   // Push root onto worklist
1770   Unique_Node_List worklist;
1771   worklist.push(C-&gt;root());
1772 
1773   // Pull from worklist; compute new value; push changes out.
1774   // This loop is the meat of CCP.
1775   while( worklist.size() ) {
1776     Node *n = worklist.pop();
1777     const Type *t = n-&gt;Value(this);
1778     if (t != type(n)) {
1779       assert(ccp_type_widens(t, type(n)), &quot;ccp type must widen&quot;);
1780 #ifndef PRODUCT
1781       if( TracePhaseCCP ) {
1782         t-&gt;dump();
1783         do { tty-&gt;print(&quot;\t&quot;); } while (tty-&gt;position() &lt; 16);
1784         n-&gt;dump();
1785       }
1786 #endif
1787       set_type(n, t);
1788       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1789         Node* m = n-&gt;fast_out(i);   // Get user
1790         if (m-&gt;is_Region()) {  // New path to Region?  Must recheck Phis too
1791           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1792             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1793             if (p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1794               worklist.push(p); // Propagate change to user
1795             }
1796           }
1797         }
1798         // If we changed the receiver type to a call, we need to revisit
1799         // the Catch following the call.  It&#39;s looking for a non-NULL
1800         // receiver to know when to enable the regular fall-through path
1801         // in addition to the NullPtrException path
1802         if (m-&gt;is_Call()) {
1803           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1804             Node* p = m-&gt;fast_out(i2);  // Propagate changes to uses
1805             if (p-&gt;is_Proj() &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Control) {
1806               Node* catch_node = p-&gt;find_out_with(Op_Catch);
1807               if (catch_node != NULL) {
1808                 worklist.push(catch_node);
1809               }
1810             }
1811           }
1812         }
1813         if (m-&gt;bottom_type() != type(m)) { // If not already bottomed out
1814           worklist.push(m);     // Propagate change to user
1815         }
1816 
1817         // CmpU nodes can get their type information from two nodes up in the
1818         // graph (instead of from the nodes immediately above). Make sure they
1819         // are added to the worklist if nodes they depend on are updated, since
1820         // they could be missed and get wrong types otherwise.
1821         uint m_op = m-&gt;Opcode();
1822         if (m_op == Op_AddI || m_op == Op_SubI) {
1823           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1824             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1825             if (p-&gt;Opcode() == Op_CmpU) {
1826               // Got a CmpU which might need the new type information from node n.
1827               if(p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1828                 worklist.push(p); // Propagate change to user
1829               }
1830             }
1831           }
1832         }
1833         // If n is used in a counted loop exit condition then the type
1834         // of the counted loop&#39;s Phi depends on the type of n. See
1835         // PhiNode::Value().
1836         if (m_op == Op_CmpI) {
1837           PhiNode* phi = countedloop_phi_from_cmp((CmpINode*)m, n);
1838           if (phi != NULL) {
1839             worklist.push(phi);
1840           }
1841         }
1842         if (m_op == Op_CastP2X) {
1843           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1844             Node* u = m-&gt;fast_out(i2);
1845             if (u-&gt;Opcode() == Op_AndX) {
1846               worklist.push(u);
1847             }
1848           }
1849         }
1850         // Loading the java mirror from a Klass requires two loads and the type
1851         // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1852         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1853         bool has_load_barrier_nodes = bs-&gt;has_load_barrier_nodes();
1854 
1855         if (m_op == Op_LoadP &amp;&amp; m-&gt;bottom_type()-&gt;isa_rawptr()) {
1856           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1857             Node* u = m-&gt;fast_out(i2);
1858             const Type* ut = u-&gt;bottom_type();
1859             if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr() &amp;&amp; ut != type(u)) {
1860               if (has_load_barrier_nodes) {
1861                 // Search for load barriers behind the load
1862                 for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1863                   Node* b = u-&gt;fast_out(i3);
1864                   if (bs-&gt;is_gc_barrier_node(b)) {
1865                     worklist.push(b);
1866                   }
1867                 }
1868               }
1869               worklist.push(u);
1870             }
1871           }
1872         }
1873       }
1874     }
1875   }
1876 }
1877 
1878 //------------------------------do_transform-----------------------------------
1879 // Top level driver for the recursive transformer
1880 void PhaseCCP::do_transform() {
1881   // Correct leaves of new-space Nodes; they point to old-space.
1882   C-&gt;set_root( transform(C-&gt;root())-&gt;as_Root() );
1883   assert( C-&gt;top(),  &quot;missing TOP node&quot; );
1884   assert( C-&gt;root(), &quot;missing root&quot; );
1885 }
1886 
1887 //------------------------------transform--------------------------------------
1888 // Given a Node in old-space, clone him into new-space.
1889 // Convert any of his old-space children into new-space children.
1890 Node *PhaseCCP::transform( Node *n ) {
1891   Node *new_node = _nodes[n-&gt;_idx]; // Check for transformed node
1892   if( new_node != NULL )
1893     return new_node;                // Been there, done that, return old answer
1894   new_node = transform_once(n);     // Check for constant
1895   _nodes.map( n-&gt;_idx, new_node );  // Flag as having been cloned
1896 
1897   // Allocate stack of size _nodes.Size()/2 to avoid frequent realloc
1898   GrowableArray &lt;Node *&gt; trstack(C-&gt;live_nodes() &gt;&gt; 1);
1899 
1900   trstack.push(new_node);           // Process children of cloned node
1901   while ( trstack.is_nonempty() ) {
1902     Node *clone = trstack.pop();
1903     uint cnt = clone-&gt;req();
1904     for( uint i = 0; i &lt; cnt; i++ ) {          // For all inputs do
1905       Node *input = clone-&gt;in(i);
1906       if( input != NULL ) {                    // Ignore NULLs
1907         Node *new_input = _nodes[input-&gt;_idx]; // Check for cloned input node
1908         if( new_input == NULL ) {
1909           new_input = transform_once(input);   // Check for constant
1910           _nodes.map( input-&gt;_idx, new_input );// Flag as having been cloned
1911           trstack.push(new_input);
1912         }
1913         assert( new_input == clone-&gt;in(i), &quot;insanity check&quot;);
1914       }
1915     }
1916   }
1917   return new_node;
1918 }
1919 
1920 
1921 //------------------------------transform_once---------------------------------
1922 // For PhaseCCP, transformation is IDENTITY unless Node computed a constant.
1923 Node *PhaseCCP::transform_once( Node *n ) {
1924   const Type *t = type(n);
1925   // Constant?  Use constant Node instead
1926   if( t-&gt;singleton() ) {
1927     Node *nn = n;               // Default is to return the original constant
1928     if( t == Type::TOP ) {
1929       // cache my top node on the Compile instance
1930       if( C-&gt;cached_top_node() == NULL || C-&gt;cached_top_node()-&gt;in(0) == NULL ) {
1931         C-&gt;set_cached_top_node(ConNode::make(Type::TOP));
1932         set_type(C-&gt;top(), Type::TOP);
1933       }
1934       nn = C-&gt;top();
1935     }
1936     if( !n-&gt;is_Con() ) {
1937       if( t != Type::TOP ) {
1938         nn = makecon(t);        // ConNode::make(t);
1939         NOT_PRODUCT( inc_constants(); )
1940       } else if( n-&gt;is_Region() ) { // Unreachable region
1941         // Note: nn == C-&gt;top()
1942         n-&gt;set_req(0, NULL);        // Cut selfreference
1943         bool progress = true;
1944         uint max = n-&gt;outcnt();
1945         DUIterator i;
1946         while (progress) {
1947           progress = false;
1948           // Eagerly remove dead phis to avoid phis copies creation.
1949           for (i = n-&gt;outs(); n-&gt;has_out(i); i++) {
1950             Node* m = n-&gt;out(i);
1951             if (m-&gt;is_Phi()) {
1952               assert(type(m) == Type::TOP, &quot;Unreachable region should not have live phis.&quot;);
1953               replace_node(m, nn);
1954               if (max != n-&gt;outcnt()) {
1955                 progress = true;
1956                 i = n-&gt;refresh_out_pos(i);
1957                 max = n-&gt;outcnt();
1958               }
1959             }
1960           }
1961         }
1962       }
1963       replace_node(n,nn);       // Update DefUse edges for new constant
1964     }
1965     return nn;
1966   }
1967 
1968   // If x is a TypeNode, capture any more-precise type permanently into Node
1969   if (t != n-&gt;bottom_type()) {
1970     hash_delete(n);             // changing bottom type may force a rehash
1971     n-&gt;raise_bottom_type(t);
1972     _worklist.push(n);          // n re-enters the hash table via the worklist
1973   }
1974 
1975   // TEMPORARY fix to ensure that 2nd GVN pass eliminates NULL checks
1976   switch( n-&gt;Opcode() ) {
1977   case Op_FastLock:      // Revisit FastLocks for lock coarsening
1978   case Op_If:
1979   case Op_CountedLoopEnd:
1980   case Op_Region:
1981   case Op_Loop:
1982   case Op_CountedLoop:
1983   case Op_Conv2B:
1984   case Op_Opaque1:
1985   case Op_Opaque2:
1986     _worklist.push(n);
1987     break;
1988   default:
1989     break;
1990   }
1991 
1992   return  n;
1993 }
1994 
1995 //---------------------------------saturate------------------------------------
1996 const Type* PhaseCCP::saturate(const Type* new_type, const Type* old_type,
1997                                const Type* limit_type) const {
1998   const Type* wide_type = new_type-&gt;widen(old_type, limit_type);
1999   if (wide_type != new_type) {          // did we widen?
2000     // If so, we may have widened beyond the limit type.  Clip it back down.
2001     new_type = wide_type-&gt;filter(limit_type);
2002   }
2003   return new_type;
2004 }
2005 
2006 //------------------------------print_statistics-------------------------------
2007 #ifndef PRODUCT
2008 void PhaseCCP::print_statistics() {
2009   tty-&gt;print_cr(&quot;CCP: %d  constants found: %d&quot;, _total_invokes, _total_constants);
2010 }
2011 #endif
2012 
2013 
2014 //=============================================================================
2015 #ifndef PRODUCT
2016 uint PhasePeephole::_total_peepholes = 0;
2017 #endif
2018 //------------------------------PhasePeephole----------------------------------
2019 // Conditional Constant Propagation, ala Wegman &amp; Zadeck
2020 PhasePeephole::PhasePeephole( PhaseRegAlloc *regalloc, PhaseCFG &amp;cfg )
2021   : PhaseTransform(Peephole), _regalloc(regalloc), _cfg(cfg) {
2022   NOT_PRODUCT( clear_peepholes(); )
2023 }
2024 
2025 #ifndef PRODUCT
2026 //------------------------------~PhasePeephole---------------------------------
2027 PhasePeephole::~PhasePeephole() {
2028   _total_peepholes += count_peepholes();
2029 }
2030 #endif
2031 
2032 //------------------------------transform--------------------------------------
2033 Node *PhasePeephole::transform( Node *n ) {
2034   ShouldNotCallThis();
2035   return NULL;
2036 }
2037 
2038 //------------------------------do_transform-----------------------------------
2039 void PhasePeephole::do_transform() {
2040   bool method_name_not_printed = true;
2041 
2042   // Examine each basic block
2043   for (uint block_number = 1; block_number &lt; _cfg.number_of_blocks(); ++block_number) {
2044     Block* block = _cfg.get_block(block_number);
2045     bool block_not_printed = true;
2046 
2047     // and each instruction within a block
2048     uint end_index = block-&gt;number_of_nodes();
2049     // block-&gt;end_idx() not valid after PhaseRegAlloc
2050     for( uint instruction_index = 1; instruction_index &lt; end_index; ++instruction_index ) {
2051       Node     *n = block-&gt;get_node(instruction_index);
2052       if( n-&gt;is_Mach() ) {
2053         MachNode *m = n-&gt;as_Mach();
2054         int deleted_count = 0;
2055         // check for peephole opportunities
2056         MachNode *m2 = m-&gt;peephole(block, instruction_index, _regalloc, deleted_count);
2057         if( m2 != NULL ) {
2058 #ifndef PRODUCT
2059           if( PrintOptoPeephole ) {
2060             // Print method, first time only
2061             if( C-&gt;method() &amp;&amp; method_name_not_printed ) {
2062               C-&gt;method()-&gt;print_short_name(); tty-&gt;cr();
2063               method_name_not_printed = false;
2064             }
2065             // Print this block
2066             if( Verbose &amp;&amp; block_not_printed) {
2067               tty-&gt;print_cr(&quot;in block&quot;);
2068               block-&gt;dump();
2069               block_not_printed = false;
2070             }
2071             // Print instructions being deleted
2072             for( int i = (deleted_count - 1); i &gt;= 0; --i ) {
2073               block-&gt;get_node(instruction_index-i)-&gt;as_Mach()-&gt;format(_regalloc); tty-&gt;cr();
2074             }
2075             tty-&gt;print_cr(&quot;replaced with&quot;);
2076             // Print new instruction
2077             m2-&gt;format(_regalloc);
2078             tty-&gt;print(&quot;\n\n&quot;);
2079           }
2080 #endif
2081           // Remove old nodes from basic block and update instruction_index
2082           // (old nodes still exist and may have edges pointing to them
2083           //  as register allocation info is stored in the allocator using
2084           //  the node index to live range mappings.)
2085           uint safe_instruction_index = (instruction_index - deleted_count);
2086           for( ; (instruction_index &gt; safe_instruction_index); --instruction_index ) {
2087             block-&gt;remove_node( instruction_index );
2088           }
2089           // install new node after safe_instruction_index
2090           block-&gt;insert_node(m2, safe_instruction_index + 1);
2091           end_index = block-&gt;number_of_nodes() - 1; // Recompute new block size
2092           NOT_PRODUCT( inc_peepholes(); )
2093         }
2094       }
2095     }
2096   }
2097 }
2098 
2099 //------------------------------print_statistics-------------------------------
2100 #ifndef PRODUCT
2101 void PhasePeephole::print_statistics() {
2102   tty-&gt;print_cr(&quot;Peephole: peephole rules applied: %d&quot;,  _total_peepholes);
2103 }
2104 #endif
2105 
2106 
2107 //=============================================================================
2108 //------------------------------set_req_X--------------------------------------
2109 void Node::set_req_X( uint i, Node *n, PhaseIterGVN *igvn ) {
2110   assert( is_not_dead(n), &quot;can not use dead node&quot;);
2111   assert( igvn-&gt;hash_find(this) != this, &quot;Need to remove from hash before changing edges&quot; );
2112   Node *old = in(i);
2113   set_req(i, n);
2114 
2115   // old goes dead?
2116   if( old ) {
2117     switch (old-&gt;outcnt()) {
2118     case 0:
2119       // Put into the worklist to kill later. We do not kill it now because the
2120       // recursive kill will delete the current node (this) if dead-loop exists
2121       if (!old-&gt;is_top())
2122         igvn-&gt;_worklist.push( old );
2123       break;
2124     case 1:
2125       if( old-&gt;is_Store() || old-&gt;has_special_unique_user() )
2126         igvn-&gt;add_users_to_worklist( old );
2127       break;
2128     case 2:
2129       if( old-&gt;is_Store() )
2130         igvn-&gt;add_users_to_worklist( old );
2131       if( old-&gt;Opcode() == Op_Region )
2132         igvn-&gt;_worklist.push(old);
2133       break;
2134     case 3:
2135       if( old-&gt;Opcode() == Op_Region ) {
2136         igvn-&gt;_worklist.push(old);
2137         igvn-&gt;add_users_to_worklist( old );
2138       }
2139       break;
2140     default:
2141       break;
2142     }
2143 
2144     BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;enqueue_useful_gc_barrier(igvn, old);
2145   }
2146 
2147 }
2148 
2149 //-------------------------------replace_by-----------------------------------
2150 // Using def-use info, replace one node for another.  Follow the def-use info
2151 // to all users of the OLD node.  Then make all uses point to the NEW node.
2152 void Node::replace_by(Node *new_node) {
2153   assert(!is_top(), &quot;top node has no DU info&quot;);
2154   for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; ) {
2155     Node* use = last_out(i);
2156     uint uses_found = 0;
2157     for (uint j = 0; j &lt; use-&gt;len(); j++) {
2158       if (use-&gt;in(j) == this) {
2159         if (j &lt; use-&gt;req())
2160               use-&gt;set_req(j, new_node);
2161         else  use-&gt;set_prec(j, new_node);
2162         uses_found++;
2163       }
2164     }
2165     i -= uses_found;    // we deleted 1 or more copies of this edge
2166   }
2167 }
2168 
2169 //=============================================================================
2170 //-----------------------------------------------------------------------------
2171 void Type_Array::grow( uint i ) {
2172   if( !_max ) {
2173     _max = 1;
2174     _types = (const Type**)_a-&gt;Amalloc( _max * sizeof(Type*) );
2175     _types[0] = NULL;
2176   }
2177   uint old = _max;
2178   _max = next_power_of_2(i);
2179   _types = (const Type**)_a-&gt;Arealloc( _types, old*sizeof(Type*),_max*sizeof(Type*));
2180   memset( &amp;_types[old], 0, (_max-old)*sizeof(Type*) );
2181 }
2182 
2183 //------------------------------dump-------------------------------------------
2184 #ifndef PRODUCT
2185 void Type_Array::dump() const {
2186   uint max = Size();
2187   for( uint i = 0; i &lt; max; i++ ) {
2188     if( _types[i] != NULL ) {
2189       tty-&gt;print(&quot;  %d\t== &quot;, i); _types[i]-&gt;dump(); tty-&gt;cr();
2190     }
2191   }
2192 }
2193 #endif
    </pre>
  </body>
</html>