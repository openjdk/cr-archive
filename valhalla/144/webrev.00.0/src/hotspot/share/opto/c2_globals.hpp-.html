<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/c2_globals.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OPTO_C2_GLOBALS_HPP
 26 #define SHARE_OPTO_C2_GLOBALS_HPP
 27 
 28 #include &quot;runtime/globals_shared.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 #include CPU_HEADER(c2_globals)
 32 #include OS_HEADER(c2_globals)
 33 
 34 //
 35 // Defines all globals flags used by the server compiler.
 36 //
 37 
 38 #define C2_FLAGS(develop, \
 39                  develop_pd, \
 40                  product, \
 41                  product_pd, \
 42                  diagnostic, \
 43                  diagnostic_pd, \
 44                  experimental, \
 45                  notproduct, \
 46                  range, \
 47                  constraint) \
 48                                                                             \
 49   diagnostic(bool, StressLCM, false,                                        \
 50           &quot;Randomize instruction scheduling in LCM&quot;)                        \
 51                                                                             \
 52   diagnostic(bool, StressGCM, false,                                        \
 53           &quot;Randomize instruction scheduling in GCM&quot;)                        \
 54                                                                             \
 55   develop(bool, StressMethodHandleLinkerInlining, false,                    \
 56           &quot;Stress inlining through method handle linkers&quot;)                  \
 57                                                                             \
 58   develop(intx, OptoPrologueNops, 0,                                        \
 59           &quot;Insert this many extra nop instructions &quot;                        \
 60           &quot;in the prologue of every nmethod&quot;)                               \
 61           range(0, 128)                                                     \
 62                                                                             \
 63   product_pd(intx, InteriorEntryAlignment,                                  \
 64           &quot;Code alignment for interior entry points &quot;                       \
 65           &quot;in generated code (in bytes)&quot;)                                   \
 66           constraint(InteriorEntryAlignmentConstraintFunc, AfterErgo)       \
 67                                                                             \
 68   product(intx, MaxLoopPad, (OptoLoopAlignment-1),                          \
 69           &quot;Align a loop if padding size in bytes is less or equal to this &quot; \
 70           &quot;value&quot;)                                                          \
 71           range(0, max_jint)                                                \
 72                                                                             \
 73   product(intx, MaxVectorSize, 64,                                          \
 74           &quot;Max vector size in bytes, &quot;                                      \
 75           &quot;actual size could be less depending on elements type&quot;)           \
 76           range(0, max_jint)                                                \
 77                                                                             \
 78   product(bool, AlignVector, true,                                          \
 79           &quot;Perform vector store/load alignment in loop&quot;)                    \
 80                                                                             \
 81   product(intx, NumberOfLoopInstrToAlign, 4,                                \
 82           &quot;Number of first instructions in a loop to align&quot;)                \
 83           range(0, max_jint)                                                \
 84                                                                             \
 85   notproduct(intx, IndexSetWatch, 0,                                        \
 86           &quot;Trace all operations on this IndexSet (-1 means all, 0 none)&quot;)   \
 87           range(-1, 0)                                                      \
 88                                                                             \
 89   develop(intx, OptoNodeListSize, 4,                                        \
 90           &quot;Starting allocation size of Node_List data structures&quot;)          \
 91           range(0, max_jint)                                                \
 92                                                                             \
 93   develop(intx, OptoBlockListSize, 8,                                       \
 94           &quot;Starting allocation size of Block_List data structures&quot;)         \
 95           range(0, max_jint)                                                \
 96                                                                             \
 97   develop(intx, OptoPeepholeAt, -1,                                         \
 98           &quot;Apply peephole optimizations to this peephole rule&quot;)             \
 99                                                                             \
100   notproduct(bool, PrintIdeal, false,                                       \
101           &quot;Print ideal graph before code generation&quot;)                       \
102                                                                             \
103   notproduct(bool, PrintOpto, false,                                        \
104           &quot;Print compiler2 attempts&quot;)                                       \
105                                                                             \
106   notproduct(bool, PrintOptoInlining, false,                                \
107           &quot;Print compiler2 inlining decisions&quot;)                             \
108                                                                             \
109   notproduct(bool, VerifyIdealNodeCount, false,                             \
110           &quot;Verify that tracked dead ideal node count is accurate&quot;)          \
111                                                                             \
112   notproduct(bool, PrintIdealNodeCount, false,                              \
113           &quot;Print liveness counts of ideal nodes&quot;)                           \
114                                                                             \
115   notproduct(bool, VerifyOptoOopOffsets, false,                             \
116           &quot;Check types of base addresses in field references&quot;)              \
117                                                                             \
118   develop(bool, IdealizedNumerics, false,                                   \
119           &quot;Check performance difference allowing FP &quot;                       \
120           &quot;associativity and commutativity...&quot;)                             \
121                                                                             \
122   diagnostic_pd(bool, IdealizeClearArrayNode,                               \
123           &quot;Replace ClearArrayNode by subgraph of basic operations.&quot;)        \
124                                                                             \
125   develop(bool, OptoBreakpoint, false,                                      \
126           &quot;insert breakpoint at method entry&quot;)                              \
127                                                                             \
128   notproduct(bool, OptoBreakpointOSR, false,                                \
129           &quot;insert breakpoint at osr method entry&quot;)                          \
130                                                                             \
131   notproduct(intx, BreakAtNode, 0,                                          \
132           &quot;Break at construction of this Node (either _idx or _debug_idx)&quot;) \
133                                                                             \
134   notproduct(bool, OptoBreakpointC2R, false,                                \
135           &quot;insert breakpoint at runtime stub entry&quot;)                        \
136                                                                             \
137   notproduct(bool, OptoNoExecute, false,                                    \
138           &quot;Attempt to parse and compile but do not execute generated code&quot;) \
139                                                                             \
140   notproduct(bool, PrintOptoStatistics, false,                              \
141           &quot;Print New compiler statistics&quot;)                                  \
142                                                                             \
143   diagnostic(bool, PrintOptoAssembly, false,                                \
144           &quot;Print New compiler assembly output&quot;)                             \
145                                                                             \
146   develop_pd(bool, OptoPeephole,                                            \
147           &quot;Apply peephole optimizations after register allocation&quot;)         \
148                                                                             \
149   develop(bool, OptoRemoveUseless, true,                                    \
150           &quot;Remove useless nodes after parsing&quot;)                             \
151                                                                             \
152   notproduct(bool, PrintFrameConverterAssembly, false,                      \
153           &quot;Print New compiler assembly output for frame converters&quot;)        \
154                                                                             \
155   notproduct(bool, PrintParseStatistics, false,                             \
156           &quot;Print nodes, transforms and new values made per bytecode parsed&quot;)\
157                                                                             \
158   notproduct(bool, PrintOptoPeephole, false,                                \
159           &quot;Print New compiler peephole replacements&quot;)                       \
160                                                                             \
161   develop(bool, PrintCFGBlockFreq, false,                                   \
162           &quot;Print CFG block freqencies&quot;)                                     \
163                                                                             \
164   develop(bool, TraceOptoParse, false,                                      \
165           &quot;Trace bytecode parse and control-flow merge&quot;)                    \
166                                                                             \
167   product_pd(intx,  LoopUnrollLimit,                                        \
168           &quot;Unroll loop bodies with node count less than this&quot;)              \
169           range(0, max_jint / 4)                                            \
170                                                                             \
171   product_pd(intx, LoopPercentProfileLimit,                                 \
172              &quot;Unroll loop bodies with % node count of profile limit&quot;)       \
173              range(10, 100)                                                 \
174                                                                             \
175   product(intx,  LoopMaxUnroll, 16,                                         \
176           &quot;Maximum number of unrolls for main loop&quot;)                        \
177           range(0, max_jint)                                                \
178                                                                             \
179   product_pd(bool,  SuperWordLoopUnrollAnalysis,                            \
180            &quot;Map number of unrolls for main loop via &quot;                       \
181            &quot;Superword Level Parallelism analysis&quot;)                          \
182                                                                             \
183   experimental(bool, PostLoopMultiversioning, false,                        \
184            &quot;Multi versioned post loops to eliminate range checks&quot;)          \
185                                                                             \
186   notproduct(bool, TraceSuperWordLoopUnrollAnalysis, false,                 \
187           &quot;Trace what Superword Level Parallelism analysis applies&quot;)        \
188                                                                             \
189   diagnostic(bool, UseVectorMacroLogic, true,                               \
190           &quot;Use ternary macro logic instructions&quot;)                           \
191                                                                             \
192   product(intx,  LoopUnrollMin, 4,                                          \
193           &quot;Minimum number of unroll loop bodies before checking progress&quot;   \
194           &quot;of rounds of unroll,optimize,..&quot;)                                \
195           range(0, max_jint)                                                \
196                                                                             \
197   product(bool, UseSubwordForMaxVector, true,                               \
198           &quot;Use Subword Analysis to set maximum vector size&quot;)                \
199                                                                             \
200   product(bool, UseVectorCmov, false,                                       \
201           &quot;Use Vectorized Cmov&quot;)                                            \
202                                                                             \
203   develop(intx, UnrollLimitForProfileCheck, 1,                              \
204           &quot;Don&#39;t use profile_trip_cnt() to restrict unrolling until &quot;       \
205           &quot;unrolling would push the number of unrolled iterations above &quot;   \
206           &quot;UnrollLimitForProfileCheck. A higher value allows more &quot;         \
207           &quot;unrolling. Zero acts as a very large value.&quot; )                   \
208           range(0, max_intx)                                                \
209                                                                             \
210   product(intx, MultiArrayExpandLimit, 6,                                   \
211           &quot;Maximum number of individual allocations in an inline-expanded &quot; \
212           &quot;multianewarray instruction&quot;)                                     \
213           range(0, max_jint)                                                \
214                                                                             \
215   notproduct(bool, TraceProfileTripCount, false,                            \
216           &quot;Trace profile loop trip count information&quot;)                      \
217                                                                             \
218   product(bool, UseCountedLoopSafepoints, false,                            \
219           &quot;Force counted loops to keep a safepoint&quot;)                        \
220                                                                             \
221   product(bool, UseLoopPredicate, true,                                     \
222           &quot;Generate a predicate to select fast/slow loop versions&quot;)         \
223                                                                             \
224   develop(bool, TraceLoopPredicate, false,                                  \
225           &quot;Trace generation of loop predicates&quot;)                            \
226                                                                             \
227   develop(bool, TraceLoopOpts, false,                                       \
228           &quot;Trace executed loop optimizations&quot;)                              \
229                                                                             \
230   develop(bool, TraceLoopLimitCheck, false,                                 \
231           &quot;Trace generation of loop limits checks&quot;)                         \
232                                                                             \
233   develop(bool, TraceRangeLimitCheck, false,                                \
234           &quot;Trace additional overflow checks in RCE&quot;)                        \
235                                                                             \
236   /* OptimizeFill not yet supported on PowerPC. */                          \
237   product(bool, OptimizeFill, true PPC64_ONLY(&amp;&amp; false),                    \
238           &quot;convert fill/copy loops into intrinsic&quot;)                         \
239                                                                             \
240   develop(bool, TraceOptimizeFill, false,                                   \
241           &quot;print detailed information about fill conversion&quot;)               \
242                                                                             \
243   develop(bool, OptoCoalesce, true,                                         \
244           &quot;Use Conservative Copy Coalescing in the Register Allocator&quot;)     \
245                                                                             \
246   develop(bool, UseUniqueSubclasses, true,                                  \
247           &quot;Narrow an abstract reference to the unique concrete subclass&quot;)   \
248                                                                             \
249   develop(bool, UseExactTypes, true,                                        \
250           &quot;Use exact types to eliminate array store checks and v-calls&quot;)    \
251                                                                             \
252   product(intx, TrackedInitializationLimit, 50,                             \
253           &quot;When initializing fields, track up to this many words&quot;)          \
254           range(0, 65535)                                                   \
255                                                                             \
256   product(bool, ReduceFieldZeroing, true,                                   \
257           &quot;When initializing fields, try to avoid needless zeroing&quot;)        \
258                                                                             \
259   product(bool, ReduceInitialCardMarks, true,                               \
260           &quot;When initializing fields, try to avoid needless card marks&quot;)     \
261                                                                             \
262   product(bool, ReduceBulkZeroing, true,                                    \
263           &quot;When bulk-initializing, try to avoid needless zeroing&quot;)          \
264                                                                             \
265   product(bool, UseFPUForSpilling, false,                                   \
266           &quot;Spill integer registers to FPU instead of stack when possible&quot;)  \
267                                                                             \
268   develop_pd(intx, RegisterCostAreaRatio,                                   \
269           &quot;Spill selection in reg allocator: scale area by (X/64K) before &quot; \
270           &quot;adding cost&quot;)                                                    \
271                                                                             \
272   develop_pd(bool, UseCISCSpill,                                            \
273           &quot;Use ADLC supplied cisc instructions during allocation&quot;)          \
274                                                                             \
275   notproduct(bool, VerifyGraphEdges , false,                                \
276           &quot;Verify Bi-directional Edges&quot;)                                    \
277                                                                             \
278   notproduct(bool, VerifyDUIterators, true,                                 \
279           &quot;Verify the safety of all iterations of Bi-directional Edges&quot;)    \
280                                                                             \
281   notproduct(bool, VerifyHashTableKeys, true,                               \
282           &quot;Verify the immutability of keys in the VN hash tables&quot;)          \
283                                                                             \
284   notproduct(bool, VerifyRegisterAllocator , false,                         \
285           &quot;Verify Register Allocator&quot;)                                      \
286                                                                             \
287   develop_pd(intx, FLOATPRESSURE,                                           \
288           &quot;Number of float LRG&#39;s that constitute high register pressure&quot;)   \
289           range(0, max_jint)                                                \
290                                                                             \
291   develop_pd(intx, INTPRESSURE,                                             \
292           &quot;Number of integer LRG&#39;s that constitute high register pressure&quot;) \
293           range(0, max_jint)                                                \
294                                                                             \
295   notproduct(bool, TraceOptoPipelining, false,                              \
296           &quot;Trace pipelining information&quot;)                                   \
297                                                                             \
298   notproduct(bool, TraceOptoOutput, false,                                  \
299           &quot;Trace pipelining information&quot;)                                   \
300                                                                             \
301   product_pd(bool, OptoScheduling,                                          \
302           &quot;Instruction Scheduling after register allocation&quot;)               \
303                                                                             \
304   product_pd(bool, OptoRegScheduling,                                       \
305           &quot;Instruction Scheduling before register allocation for pressure&quot;) \
306                                                                             \
307   product(bool, PartialPeelLoop, true,                                      \
308           &quot;Partial peel (rotate) loops&quot;)                                    \
309                                                                             \
310   product(intx, PartialPeelNewPhiDelta, 0,                                  \
311           &quot;Additional phis that can be created by partial peeling&quot;)         \
312           range(0, max_jint)                                                \
313                                                                             \
314   notproduct(bool, TracePartialPeeling, false,                              \
315           &quot;Trace partial peeling (loop rotation) information&quot;)              \
316                                                                             \
317   product(bool, PartialPeelAtUnsignedTests, true,                           \
318           &quot;Partial peel at unsigned tests if no signed test exists&quot;)        \
319                                                                             \
320   product(bool, ReassociateInvariants, true,                                \
321           &quot;Enable reassociation of expressions with loop invariants.&quot;)      \
322                                                                             \
323   product(bool, LoopUnswitching, true,                                      \
324           &quot;Enable loop unswitching (a form of invariant test hoisting)&quot;)    \
325                                                                             \
326   notproduct(bool, TraceLoopUnswitching, false,                             \
327           &quot;Trace loop unswitching&quot;)                                         \
328                                                                             \
329   product(bool, AllowVectorizeOnDemand, true,                               \
330           &quot;Globally supress vectorization set in VectorizeMethod&quot;)          \
331                                                                             \
332   product(bool, UseSuperWord, true,                                         \
333           &quot;Transform scalar operations into superword operations&quot;)          \
334                                                                             \
335   develop(bool, SuperWordRTDepCheck, false,                                 \
336           &quot;Enable runtime dependency checks.&quot;)                              \
337                                                                             \
338   product(bool, SuperWordReductions, true,                                  \
339           &quot;Enable reductions support in superword.&quot;)                        \
340                                                                             \
341   product(bool, UseCMoveUnconditionally, false,                             \
342           &quot;Use CMove (scalar and vector) ignoring profitability test.&quot;)     \
343                                                                             \
344   product(bool, DoReserveCopyInSuperWord, true,                             \
345           &quot;Create reserve copy of graph in SuperWord.&quot;)                     \
346                                                                             \
347   notproduct(bool, TraceSuperWord, false,                                   \
348           &quot;Trace superword transforms&quot;)                                     \
349                                                                             \
350   notproduct(bool, TraceNewVectors, false,                                  \
351           &quot;Trace creation of Vector nodes&quot;)                                 \
352                                                                             \
353   product_pd(bool, OptoBundling,                                            \
354           &quot;Generate nops to fill i-cache lines&quot;)                            \
355                                                                             \
356   product_pd(intx, ConditionalMoveLimit,                                    \
357           &quot;Limit of ops to make speculative when using CMOVE&quot;)              \
358           range(0, max_jint)                                                \
359                                                                             \
360   product(bool, UseRDPCForConstantTableBase, false,                         \
361           &quot;Use Sparc RDPC instruction for the constant table base.&quot;)        \
362                                                                             \
363   notproduct(bool, PrintIdealGraph, false,                                  \
364           &quot;Print ideal graph to XML file / network interface. &quot;             \
365           &quot;By default attempts to connect to the visualizer on a socket.&quot;)  \
366                                                                             \
367   notproduct(intx, PrintIdealGraphLevel, 0,                                 \
368           &quot;Level of detail of the ideal graph printout. &quot;                   \
369           &quot;System-wide value, -1=printing is disabled, &quot;                    \
370           &quot;0=print nothing except IGVPrintLevel directives, &quot;               \
371           &quot;4=all details printed. &quot;                                         \
372           &quot;Level of detail of printouts can be set on a per-method level &quot;  \
373           &quot;as well by using CompileCommand=option.&quot;)                        \
374           range(-1, 4)                                                      \
375                                                                             \
376   notproduct(intx, PrintIdealGraphPort, 4444,                               \
377           &quot;Ideal graph printer to network port&quot;)                            \
378           range(0, SHRT_MAX)                                                \
379                                                                             \
380   notproduct(ccstr, PrintIdealGraphAddress, &quot;127.0.0.1&quot;,                    \
381           &quot;IP address to connect to visualizer&quot;)                            \
382                                                                             \
383   notproduct(ccstr, PrintIdealGraphFile, NULL,                              \
384           &quot;File to dump ideal graph to.  If set overrides the &quot;             \
385           &quot;use of the network&quot;)                                             \
386                                                                             \
387   product(bool, UseBimorphicInlining, true,                                 \
388           &quot;Profiling based inlining for two receivers&quot;)                     \
389                                                                             \
390   product(bool, UseOnlyInlinedBimorphic, true,                              \
391           &quot;Don&#39;t use BimorphicInlining if can&#39;t inline a second method&quot;)    \
392                                                                             \
393   product(bool, InsertMemBarAfterArraycopy, true,                           \
394           &quot;Insert memory barrier after arraycopy call&quot;)                     \
395                                                                             \
396   develop(bool, SubsumeLoads, true,                                         \
397           &quot;Attempt to compile while subsuming loads into machine &quot;          \
398           &quot;instructions.&quot;)                                                  \
399                                                                             \
400   develop(bool, StressRecompilation, false,                                 \
401           &quot;Recompile each compiled method without subsuming loads &quot;         \
402           &quot;or escape analysis.&quot;)                                            \
403                                                                             \
404   develop(intx, ImplicitNullCheckThreshold, 3,                              \
405           &quot;Don&#39;t do implicit null checks if NPE&#39;s in a method exceeds &quot;     \
406           &quot;limit&quot;)                                                          \
407           range(0, max_jint)                                                \
408                                                                             \
409   product(intx, LoopOptsCount, 43,                                          \
410           &quot;Set level of loop optimization for tier 1 compiles&quot;)             \
411           range(5, 43)                                                      \
412                                                                             \
413   /* controls for heat-based inlining */                                    \
414                                                                             \
415   develop(intx, NodeCountInliningCutoff, 18000,                             \
416           &quot;If parser node generation exceeds limit stop inlining&quot;)          \
417           range(0, max_jint)                                                \
418                                                                             \
419   develop(intx, NodeCountInliningStep, 1000,                                \
420           &quot;Target size of warm calls inlined between optimization passes&quot;)  \
421           range(0, max_jint)                                                \
422                                                                             \
423   develop(bool, InlineWarmCalls, false,                                     \
424           &quot;Use a heat-based priority queue to govern inlining&quot;)             \
425                                                                             \
426   /* Max values must not exceed WarmCallInfo::MAX_VALUE(). */               \
427   develop(intx, HotCallCountThreshold, 999999,                              \
428           &quot;large numbers of calls (per method invocation) force hotness&quot;)   \
429           range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \
430                                                                             \
431   develop(intx, HotCallProfitThreshold, 999999,                             \
432           &quot;highly profitable inlining opportunities force hotness&quot;)         \
433           range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \
434                                                                             \
435   develop(intx, HotCallTrivialWork, -1,                                     \
436           &quot;trivial execution time (no larger than this) forces hotness&quot;)    \
437           range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \
438                                                                             \
439   develop(intx, HotCallTrivialSize, -1,                                     \
440           &quot;trivial methods (no larger than this) force calls to be hot&quot;)    \
441           range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \
442                                                                             \
443   develop(intx, WarmCallMinCount, -1,                                       \
444           &quot;number of calls (per method invocation) to enable inlining&quot;)     \
445           range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \
446                                                                             \
447   develop(intx, WarmCallMinProfit, -1,                                      \
448           &quot;number of calls (per method invocation) to enable inlining&quot;)     \
449           range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \
450                                                                             \
451   develop(intx, WarmCallMaxWork, 999999,                                    \
452           &quot;execution time of the largest inlinable method&quot;)                 \
453           range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \
454                                                                             \
455   develop(intx, WarmCallMaxSize, 999999,                                    \
456           &quot;size of the largest inlinable method&quot;)                           \
457           range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \
458                                                                             \
459   product(intx, MaxNodeLimit, 80000,                                        \
460           &quot;Maximum number of nodes&quot;)                                        \
461           range(1000, max_jint / 3)                                         \
462                                                                             \
463   product(intx, NodeLimitFudgeFactor, 2000,                                 \
464           &quot;Fudge Factor for certain optimizations&quot;)                         \
465           constraint(NodeLimitFudgeFactorConstraintFunc, AfterErgo)         \
466                                                                             \
467   product(bool, UseJumpTables, true,                                        \
468           &quot;Use JumpTables instead of a binary search tree for switches&quot;)    \
469                                                                             \
470   product(bool, UseDivMod, true,                                            \
471           &quot;Use combined DivMod instruction if available&quot;)                   \
472                                                                             \
473   product_pd(intx, MinJumpTableSize,                                        \
474           &quot;Minimum number of targets in a generated jump table&quot;)            \
475           range(0, max_intx)                                                \
476                                                                             \
477   product(intx, MaxJumpTableSize, 65000,                                    \
478           &quot;Maximum number of targets in a generated jump table&quot;)            \
479           range(0, max_intx)                                                \
480                                                                             \
481   product(intx, MaxJumpTableSparseness, 5,                                  \
482           &quot;Maximum sparseness for jumptables&quot;)                              \
483           range(0, max_intx / 4)                                            \
484                                                                             \
485   product(bool, EliminateLocks, true,                                       \
486           &quot;Coarsen locks when possible&quot;)                                    \
487                                                                             \
488   product(bool, EliminateNestedLocks, true,                                 \
489           &quot;Eliminate nested locks of the same object when possible&quot;)        \
490                                                                             \
491   notproduct(bool, PrintLockStatistics, false,                              \
492           &quot;Print precise statistics on the dynamic lock usage&quot;)             \
493                                                                             \
494   diagnostic(bool, PrintPreciseBiasedLockingStatistics, false,              \
495           &quot;(Deprecated) Print per-lock-site statistics of biased locking &quot;  \
496           &quot;in JVM&quot;)                                                         \
497                                                                             \
498   diagnostic(bool, PrintPreciseRTMLockingStatistics, false,                 \
499           &quot;Print per-lock-site statistics of rtm locking in JVM&quot;)           \
500                                                                             \
501   notproduct(bool, PrintEliminateLocks, false,                              \
502           &quot;Print out when locks are eliminated&quot;)                            \
503                                                                             \
504   product(bool, EliminateAutoBox, true,                                     \
505           &quot;Control optimizations for autobox elimination&quot;)                  \
506                                                                             \
507   product(intx, AutoBoxCacheMax, 128,                                       \
508           &quot;Sets max value cached by the java.lang.Integer autobox cache&quot;)   \
509           range(0, max_jint)                                                \
510                                                                             \
511   diagnostic(bool, AggressiveUnboxing, true,                                \
512           &quot;Control optimizations for aggressive boxing elimination&quot;)        \
513                                                                             \
514   develop(bool, TracePostallocExpand, false, &quot;Trace expanding nodes after&quot;  \
515           &quot; register allocation.&quot;)                                          \
516                                                                             \
517   product(bool, DoEscapeAnalysis, true,                                     \
518           &quot;Perform escape analysis&quot;)                                        \
519                                                                             \
520   product(double, EscapeAnalysisTimeout, 20. DEBUG_ONLY(+40.),              \
521           &quot;Abort EA when it reaches time limit (in sec)&quot;)                   \
522           range(0, DBL_MAX)                                                 \
523                                                                             \
524   develop(bool, ExitEscapeAnalysisOnTimeout, true,                          \
525           &quot;Exit or throw assert in EA when it reaches time limit&quot;)          \
526                                                                             \
527   notproduct(bool, PrintEscapeAnalysis, false,                              \
528           &quot;Print the results of escape analysis&quot;)                           \
529                                                                             \
530   product(bool, EliminateAllocations, true,                                 \
531           &quot;Use escape analysis to eliminate allocations&quot;)                   \
532                                                                             \
533   notproduct(bool, PrintEliminateAllocations, false,                        \
534           &quot;Print out when allocations are eliminated&quot;)                      \
535                                                                             \
536   product(intx, EliminateAllocationArraySizeLimit, 64,                      \
537           &quot;Array size (number of elements) limit for scalar replacement&quot;)   \
538           range(0, max_jint)                                                \
539                                                                             \
540   product(bool, OptimizePtrCompare, true,                                   \
541           &quot;Use escape analysis to optimize pointers compare&quot;)               \
542                                                                             \
543   notproduct(bool, PrintOptimizePtrCompare, false,                          \
544           &quot;Print information about optimized pointers compare&quot;)             \
545                                                                             \
546   notproduct(bool, VerifyConnectionGraph , true,                            \
547           &quot;Verify Connection Graph construction in Escape Analysis&quot;)        \
548                                                                             \
549   product(bool, UseOptoBiasInlining, true,                                  \
550           &quot;(Deprecated) Generate biased locking code in C2 ideal graph&quot;)    \
551                                                                             \
552   product(bool, OptimizeStringConcat, true,                                 \
553           &quot;Optimize the construction of Strings by StringBuilder&quot;)          \
554                                                                             \
555   notproduct(bool, PrintOptimizeStringConcat, false,                        \
556           &quot;Print information about transformations performed on Strings&quot;)   \
557                                                                             \
558   product(intx, ValueSearchLimit, 1000,                                     \
559           &quot;Recursion limit in PhaseMacroExpand::value_from_mem_phi&quot;)        \
560           range(0, max_jint)                                                \
561                                                                             \
562   product(intx, MaxLabelRootDepth, 1100,                                    \
563           &quot;Maximum times call Label_Root to prevent stack overflow&quot;)        \
564           range(100, max_jint)                                              \
565                                                                             \
566   diagnostic(intx, DominatorSearchLimit, 1000,                              \
567           &quot;Iterations limit in Node::dominates&quot;)                            \
568           range(0, max_jint)                                                \
569                                                                             \
570   product(bool, BlockLayoutByFrequency, true,                               \
571           &quot;Use edge frequencies to drive block ordering&quot;)                   \
572                                                                             \
573   product(intx, BlockLayoutMinDiamondPercentage, 20,                        \
574           &quot;Miniumum %% of a successor (predecessor) for which block &quot;       \
575           &quot;layout a will allow a fork (join) in a single chain&quot;)            \
576           range(0, 100)                                                     \
577                                                                             \
578   product(bool, BlockLayoutRotateLoops, true,                               \
579           &quot;Allow back branches to be fall throughs in the block layout&quot;)    \
580                                                                             \
581   diagnostic(bool, InlineReflectionGetCallerClass, true,                    \
582           &quot;inline sun.reflect.Reflection.getCallerClass(), known to be &quot;    \
583           &quot;part of base library DLL&quot;)                                       \
584                                                                             \
585   diagnostic(bool, InlineObjectCopy, true,                                  \
586           &quot;inline Object.clone and Arrays.copyOf[Range] intrinsics&quot;)        \
587                                                                             \
588   diagnostic(bool, SpecialStringCompareTo, true,                            \
589           &quot;special version of string compareTo&quot;)                            \
590                                                                             \
591   diagnostic(bool, SpecialStringIndexOf, true,                              \
592           &quot;special version of string indexOf&quot;)                              \
593                                                                             \
594   diagnostic(bool, SpecialStringEquals, true,                               \
595           &quot;special version of string equals&quot;)                               \
596                                                                             \
597   diagnostic(bool, SpecialArraysEquals, true,                               \
598           &quot;special version of Arrays.equals(char[],char[])&quot;)                \
599                                                                             \
600   diagnostic(bool, SpecialEncodeISOArray, true,                             \
601           &quot;special version of ISO_8859_1$Encoder.encodeISOArray&quot;)           \
602                                                                             \
603   develop(bool, BailoutToInterpreterForThrows, false,                       \
604           &quot;Compiled methods which throws/catches exceptions will be &quot;       \
605           &quot;deopt and intp.&quot;)                                                \
606                                                                             \
607   develop(bool, ConvertCmpD2CmpF, true,                                     \
608           &quot;Convert cmpD to cmpF when one input is constant in float range&quot;) \
609                                                                             \
610   develop(bool, ConvertFloat2IntClipping, true,                             \
611           &quot;Convert float2int clipping idiom to integer clipping&quot;)           \
612                                                                             \
613   develop(bool, MonomorphicArrayCheck, true,                                \
614           &quot;Uncommon-trap array store checks that require full type check&quot;)  \
615                                                                             \
616   notproduct(bool, TracePhaseCCP, false,                                    \
617           &quot;Print progress during Conditional Constant Propagation&quot;)         \
618                                                                             \
619   develop(bool, PrintDominators, false,                                     \
620           &quot;Print out dominator trees for GVN&quot;)                              \
621                                                                             \
622   diagnostic(bool, TraceSpilling, false,                                    \
623           &quot;Trace spilling&quot;)                                                 \
624                                                                             \
625   diagnostic(bool, TraceTypeProfile, false,                                 \
626           &quot;Trace type profile&quot;)                                             \
627                                                                             \
628   develop(bool, PoisonOSREntry, true,                                       \
629            &quot;Detect abnormal calls to OSR code&quot;)                             \
630                                                                             \
631   develop(bool, SoftMatchFailure, trueInProduct,                            \
632           &quot;If the DFA fails to match a node, print a message and bail out&quot;) \
633                                                                             \
634   develop(bool, InlineAccessors, true,                                      \
635           &quot;inline accessor methods (get/set)&quot;)                              \
636                                                                             \
637   product(intx, TypeProfileMajorReceiverPercent, 90,                        \
638           &quot;% of major receiver type to all profiled receivers&quot;)             \
639           range(0, 100)                                                     \
640                                                                             \
641   diagnostic(bool, PrintIntrinsics, false,                                  \
642           &quot;prints attempted and successful inlining of intrinsics&quot;)         \
643                                                                             \
644   develop(bool, StressReflectiveCode, false,                                \
645           &quot;Use inexact types at allocations, etc., to test reflection&quot;)     \
646                                                                             \
647   diagnostic(bool, DebugInlinedCalls, true,                                 \
648          &quot;If false, restricts profiled locations to the root method only&quot;)  \
649                                                                             \
650   notproduct(bool, VerifyLoopOptimizations, false,                          \
651           &quot;verify major loop optimizations&quot;)                                \
652                                                                             \
653   diagnostic(bool, ProfileDynamicTypes, true,                               \
654           &quot;do extra type profiling and use it more aggressively&quot;)           \
655                                                                             \
656   develop(bool, TraceIterativeGVN, false,                                   \
657           &quot;Print progress during Iterative Global Value Numbering&quot;)         \
658                                                                             \
659   develop(bool, VerifyIterativeGVN, false,                                  \
660           &quot;Verify Def-Use modifications during sparse Iterative Global &quot;    \
661           &quot;Value Numbering&quot;)                                                \
662                                                                             \
663   notproduct(bool, TraceCISCSpill, false,                                   \
664           &quot;Trace allocators use of cisc spillable instructions&quot;)            \
665                                                                             \
666   product(bool, SplitIfBlocks, true,                                        \
667           &quot;Clone compares and control flow through merge points to fold &quot;   \
668           &quot;some branches&quot;)                                                  \
669                                                                             \
670   develop(intx, FreqCountInvocations,  1,                                   \
671           &quot;Scaling factor for branch frequencies (deprecated)&quot;)             \
672           range(1, max_intx)                                                \
673                                                                             \
674   product(intx, AliasLevel,     3,                                          \
675           &quot;0 for no aliasing, 1 for oop/field/static/array split, &quot;         \
676           &quot;2 for class split, 3 for unique instances&quot;)                      \
677           range(0, 3)                                                       \
678           constraint(AliasLevelConstraintFunc,AfterErgo)                    \
679                                                                             \
680   develop(bool, VerifyAliases, false,                                       \
681           &quot;perform extra checks on the results of alias analysis&quot;)          \
682                                                                             \
683   product(intx, MaxInlineLevel, 15,                                         \
684           &quot;maximum number of nested calls that are inlined by high tier &quot;   \
685           &quot;compiler&quot;)                                                       \
686           range(0, max_jint)                                                \
687                                                                             \
688   product(intx, MaxRecursiveInlineLevel, 1,                                 \
689           &quot;maximum number of nested recursive calls that are inlined by &quot;   \
690           &quot;high tier compiler&quot;)                                             \
691           range(0, max_jint)                                                \
692                                                                             \
693   product_pd(intx, InlineSmallCode,                                         \
694           &quot;Only inline already compiled methods if their code size is &quot;     \
695           &quot;less than this&quot;)                                                 \
696           range(0, max_jint)                                                \
697                                                                             \
698   product(intx, MaxInlineSize, 35,                                          \
699           &quot;The maximum bytecode size of a method to be inlined by high &quot;    \
700           &quot;tier compiler&quot;)                                                  \
701           range(0, max_jint)                                                \
702                                                                             \
703   product_pd(intx, FreqInlineSize,                                          \
704           &quot;The maximum bytecode size of a frequent method to be inlined&quot;)   \
705           range(0, max_jint)                                                \
706                                                                             \
707   product(intx, MaxTrivialSize, 6,                                          \
708           &quot;The maximum bytecode size of a trivial method to be inlined by &quot; \
709           &quot;high tier compiler&quot;)                                             \
710           range(0, max_jint)                                                \
711                                                                             \
712   product(bool, IncrementalInline, true,                                    \
713           &quot;do post parse inlining&quot;)                                         \
714                                                                             \
715   develop(bool, AlwaysIncrementalInline, false,                             \
716           &quot;do all inlining incrementally&quot;)                                  \
717                                                                             \
718   product(intx, LiveNodeCountInliningCutoff, 40000,                         \
719           &quot;max number of live nodes in a method&quot;)                           \
720           range(0, max_juint / 8)                                           \
721                                                                             \
722   diagnostic(bool, OptimizeExpensiveOps, true,                              \
723           &quot;Find best control for expensive operations&quot;)                     \
724                                                                             \
725   diagnostic(bool, UseMathExactIntrinsics, true,                            \
726           &quot;Enables intrinsification of various java.lang.Math functions&quot;)   \
727                                                                             \
728   diagnostic(bool, UseCharacterCompareIntrinsics, false,                    \
729           &quot;Enables intrinsification of java.lang.Character functions&quot;)      \
730                                                                             \
731   diagnostic(bool, UseMultiplyToLenIntrinsic, false,                        \
732           &quot;Enables intrinsification of BigInteger.multiplyToLen()&quot;)         \
733                                                                             \
734   diagnostic(bool, UseSquareToLenIntrinsic, false,                          \
735           &quot;Enables intrinsification of BigInteger.squareToLen()&quot;)           \
736                                                                             \
737   diagnostic(bool, UseMulAddIntrinsic, false,                               \
738           &quot;Enables intrinsification of BigInteger.mulAdd()&quot;)                \
739                                                                             \
740   diagnostic(bool, UseMontgomeryMultiplyIntrinsic, false,                   \
741           &quot;Enables intrinsification of BigInteger.montgomeryMultiply()&quot;)    \
742                                                                             \
743   diagnostic(bool, UseMontgomerySquareIntrinsic, false,                     \
744           &quot;Enables intrinsification of BigInteger.montgomerySquare()&quot;)      \
745                                                                             \
746   product(bool, UseTypeSpeculation, true,                                   \
747           &quot;Speculatively propagate types from profiles&quot;)                    \
748                                                                             \
749   diagnostic(bool, UseInlineDepthForSpeculativeTypes, true,                 \
750           &quot;Carry inline depth of profile point with speculative type &quot;      \
751           &quot;and give priority to profiling from lower inline depth&quot;)         \
752                                                                             \
753   product_pd(bool, TrapBasedRangeChecks,                                    \
754           &quot;Generate code for range checks that uses a cmp and trap &quot;        \
755           &quot;instruction raising SIGTRAP. Used on PPC64.&quot;)                    \
756                                                                             \
757   product(intx, ArrayCopyLoadStoreMaxElem, 8,                               \
758           &quot;Maximum number of arraycopy elements inlined as a sequence of&quot;   \
759           &quot;loads/stores&quot;)                                                   \
760           range(0, max_intx)                                                \
761                                                                             \
762   develop(bool, StressArrayCopyMacroNode, false,                            \
763           &quot;Perform ArrayCopy load/store replacement during IGVN only&quot;)      \
764                                                                             \
765   develop(bool, RenumberLiveNodes, true,                                    \
766           &quot;Renumber live nodes&quot;)                                            \
767                                                                             \
768   product(uintx, LoopStripMiningIter, 0,                                    \
769           &quot;Number of iterations in strip mined loop&quot;)                       \
770           range(0, max_juint)                                               \
771                                                                             \
772   product(uintx, LoopStripMiningIterShortLoop, 0,                           \
773           &quot;Loop with fewer iterations are not strip mined&quot;)                 \
774           range(0, max_juint)                                               \
775                                                                             \
776   product(bool, UseProfiledLoopPredicate, true,                             \
777           &quot;Move predicates out of loops based on profiling data&quot;)           \
778                                                                             \
779   product(bool, UseArrayLoadStoreProfile, false,                            \
780           &quot;Take advantage of profiling at array load/store&quot;)                \
781                                                                             \
782   diagnostic(bool, ExpandSubTypeCheckAtParseTime, false,                    \
783           &quot;Do not use subtype check macro node&quot;)                            \
784 
785 #endif // SHARE_OPTO_C2_GLOBALS_HPP
    </pre>
  </body>
</html>