<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/escape.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;libadt/vectset.hpp&quot;
  31 #include &quot;memory/allocation.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;opto/c2compiler.hpp&quot;
  34 #include &quot;opto/arraycopynode.hpp&quot;
  35 #include &quot;opto/callnode.hpp&quot;
  36 #include &quot;opto/cfgnode.hpp&quot;
  37 #include &quot;opto/compile.hpp&quot;
  38 #include &quot;opto/escape.hpp&quot;
  39 #include &quot;opto/phaseX.hpp&quot;
  40 #include &quot;opto/movenode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 
  44 ConnectionGraph::ConnectionGraph(Compile * C, PhaseIterGVN *igvn) :
  45   _nodes(C-&gt;comp_arena(), C-&gt;unique(), C-&gt;unique(), NULL),
  46   _in_worklist(C-&gt;comp_arena()),
  47   _next_pidx(0),
  48   _collecting(true),
  49   _verify(false),
  50   _compile(C),
  51   _igvn(igvn),
  52   _node_map(C-&gt;comp_arena()) {
  53   // Add unknown java object.
  54   add_java_object(C-&gt;top(), PointsToNode::GlobalEscape);
  55   phantom_obj = ptnode_adr(C-&gt;top()-&gt;_idx)-&gt;as_JavaObject();
  56   // Add ConP(#NULL) and ConN(#NULL) nodes.
  57   Node* oop_null = igvn-&gt;zerocon(T_OBJECT);
  58   assert(oop_null-&gt;_idx &lt; nodes_size(), &quot;should be created already&quot;);
  59   add_java_object(oop_null, PointsToNode::NoEscape);
  60   null_obj = ptnode_adr(oop_null-&gt;_idx)-&gt;as_JavaObject();
  61   if (UseCompressedOops) {
  62     Node* noop_null = igvn-&gt;zerocon(T_NARROWOOP);
  63     assert(noop_null-&gt;_idx &lt; nodes_size(), &quot;should be created already&quot;);
  64     map_ideal_node(noop_null, null_obj);
  65   }
  66   _pcmp_neq = NULL; // Should be initialized
  67   _pcmp_eq  = NULL;
  68 }
  69 
  70 bool ConnectionGraph::has_candidates(Compile *C) {
  71   // EA brings benefits only when the code has allocations and/or locks which
  72   // are represented by ideal Macro nodes.
  73   int cnt = C-&gt;macro_count();
  74   for (int i = 0; i &lt; cnt; i++) {
  75     Node *n = C-&gt;macro_node(i);
  76     if (n-&gt;is_Allocate())
  77       return true;
  78     if (n-&gt;is_Lock()) {
  79       Node* obj = n-&gt;as_Lock()-&gt;obj_node()-&gt;uncast();
  80       if (!(obj-&gt;is_Parm() || obj-&gt;is_Con()))
  81         return true;
  82     }
  83     if (n-&gt;is_CallStaticJava() &amp;&amp;
  84         n-&gt;as_CallStaticJava()-&gt;is_boxing_method()) {
  85       return true;
  86     }
  87   }
  88   return false;
  89 }
  90 
  91 void ConnectionGraph::do_analysis(Compile *C, PhaseIterGVN *igvn) {
  92   Compile::TracePhase tp(&quot;escapeAnalysis&quot;, &amp;Phase::timers[Phase::_t_escapeAnalysis]);
  93   ResourceMark rm;
  94 
  95   // Add ConP#NULL and ConN#NULL nodes before ConnectionGraph construction
  96   // to create space for them in ConnectionGraph::_nodes[].
  97   Node* oop_null = igvn-&gt;zerocon(T_OBJECT);
  98   Node* noop_null = igvn-&gt;zerocon(T_NARROWOOP);
  99   ConnectionGraph* congraph = new(C-&gt;comp_arena()) ConnectionGraph(C, igvn);
 100   // Perform escape analysis
 101   if (congraph-&gt;compute_escape()) {
 102     // There are non escaping objects.
 103     C-&gt;set_congraph(congraph);
 104   }
 105   // Cleanup.
 106   if (oop_null-&gt;outcnt() == 0)
 107     igvn-&gt;hash_delete(oop_null);
 108   if (noop_null-&gt;outcnt() == 0)
 109     igvn-&gt;hash_delete(noop_null);
 110 }
 111 
 112 bool ConnectionGraph::compute_escape() {
 113   Compile* C = _compile;
 114   PhaseGVN* igvn = _igvn;
 115 
 116   // Worklists used by EA.
 117   Unique_Node_List delayed_worklist;
 118   GrowableArray&lt;Node*&gt; alloc_worklist;
 119   GrowableArray&lt;Node*&gt; ptr_cmp_worklist;
 120   GrowableArray&lt;Node*&gt; storestore_worklist;
 121   GrowableArray&lt;ArrayCopyNode*&gt; arraycopy_worklist;
 122   GrowableArray&lt;PointsToNode*&gt;   ptnodes_worklist;
 123   GrowableArray&lt;JavaObjectNode*&gt; java_objects_worklist;
 124   GrowableArray&lt;JavaObjectNode*&gt; non_escaped_worklist;
 125   GrowableArray&lt;FieldNode*&gt;      oop_fields_worklist;
 126   DEBUG_ONLY( GrowableArray&lt;Node*&gt; addp_worklist; )
 127 
 128   { Compile::TracePhase tp(&quot;connectionGraph&quot;, &amp;Phase::timers[Phase::_t_connectionGraph]);
 129 
 130   // 1. Populate Connection Graph (CG) with PointsTo nodes.
 131   ideal_nodes.map(C-&gt;live_nodes(), NULL);  // preallocate space
 132   // Initialize worklist
 133   if (C-&gt;root() != NULL) {
 134     ideal_nodes.push(C-&gt;root());
 135   }
 136   // Processed ideal nodes are unique on ideal_nodes list
 137   // but several ideal nodes are mapped to the phantom_obj.
 138   // To avoid duplicated entries on the following worklists
 139   // add the phantom_obj only once to them.
 140   ptnodes_worklist.append(phantom_obj);
 141   java_objects_worklist.append(phantom_obj);
 142   for( uint next = 0; next &lt; ideal_nodes.size(); ++next ) {
 143     Node* n = ideal_nodes.at(next);
 144     if ((n-&gt;Opcode() == Op_LoadX || n-&gt;Opcode() == Op_StoreX) &amp;&amp;
 145         !n-&gt;in(MemNode::Address)-&gt;is_AddP() &amp;&amp;
 146         _igvn-&gt;type(n-&gt;in(MemNode::Address))-&gt;isa_oopptr()) {
 147       // Load/Store at mark work address is at offset 0 so has no AddP which confuses EA
 148       Node* addp = new AddPNode(n-&gt;in(MemNode::Address), n-&gt;in(MemNode::Address), _igvn-&gt;MakeConX(0));
 149       _igvn-&gt;register_new_node_with_optimizer(addp);
 150       _igvn-&gt;replace_input_of(n, MemNode::Address, addp);
 151       ideal_nodes.push(addp);
 152       _nodes.at_put_grow(addp-&gt;_idx, NULL, NULL);
 153     }
 154     // Create PointsTo nodes and add them to Connection Graph. Called
 155     // only once per ideal node since ideal_nodes is Unique_Node list.
 156     add_node_to_connection_graph(n, &amp;delayed_worklist);
 157     PointsToNode* ptn = ptnode_adr(n-&gt;_idx);
 158     if (ptn != NULL &amp;&amp; ptn != phantom_obj) {
 159       ptnodes_worklist.append(ptn);
 160       if (ptn-&gt;is_JavaObject()) {
 161         java_objects_worklist.append(ptn-&gt;as_JavaObject());
 162         if ((n-&gt;is_Allocate() || n-&gt;is_CallStaticJava()) &amp;&amp;
 163             (ptn-&gt;escape_state() &lt; PointsToNode::GlobalEscape)) {
 164           // Only allocations and java static calls results are interesting.
 165           non_escaped_worklist.append(ptn-&gt;as_JavaObject());
 166         }
 167       } else if (ptn-&gt;is_Field() &amp;&amp; ptn-&gt;as_Field()-&gt;is_oop()) {
 168         oop_fields_worklist.append(ptn-&gt;as_Field());
 169       }
 170     }
 171     if (n-&gt;is_MergeMem()) {
 172       // Collect all MergeMem nodes to add memory slices for
 173       // scalar replaceable objects in split_unique_types().
 174       _mergemem_worklist.append(n-&gt;as_MergeMem());
 175     } else if (OptimizePtrCompare &amp;&amp; n-&gt;is_Cmp() &amp;&amp;
 176                (n-&gt;Opcode() == Op_CmpP || n-&gt;Opcode() == Op_CmpN)) {
 177       // Collect compare pointers nodes.
 178       ptr_cmp_worklist.append(n);
 179     } else if (n-&gt;is_MemBarStoreStore()) {
 180       // Collect all MemBarStoreStore nodes so that depending on the
 181       // escape status of the associated Allocate node some of them
 182       // may be eliminated.
 183       storestore_worklist.append(n);
 184     } else if (n-&gt;is_MemBar() &amp;&amp; (n-&gt;Opcode() == Op_MemBarRelease) &amp;&amp;
 185                (n-&gt;req() &gt; MemBarNode::Precedent)) {
 186       record_for_optimizer(n);
 187 #ifdef ASSERT
 188     } else if (n-&gt;is_AddP()) {
 189       // Collect address nodes for graph verification.
 190       addp_worklist.append(n);
 191 #endif
 192     } else if (n-&gt;is_ArrayCopy()) {
 193       // Keep a list of ArrayCopy nodes so if one of its input is non
 194       // escaping, we can record a unique type
 195       arraycopy_worklist.append(n-&gt;as_ArrayCopy());
 196     }
 197     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 198       Node* m = n-&gt;fast_out(i);   // Get user
 199       ideal_nodes.push(m);
 200     }
 201   }
 202   if (non_escaped_worklist.length() == 0) {
 203     _collecting = false;
 204     return false; // Nothing to do.
 205   }
 206   // Add final simple edges to graph.
 207   while(delayed_worklist.size() &gt; 0) {
 208     Node* n = delayed_worklist.pop();
 209     add_final_edges(n);
 210   }
 211   int ptnodes_length = ptnodes_worklist.length();
 212 
 213 #ifdef ASSERT
 214   if (VerifyConnectionGraph) {
 215     // Verify that no new simple edges could be created and all
 216     // local vars has edges.
 217     _verify = true;
 218     for (int next = 0; next &lt; ptnodes_length; ++next) {
 219       PointsToNode* ptn = ptnodes_worklist.at(next);
 220       add_final_edges(ptn-&gt;ideal_node());
 221       if (ptn-&gt;is_LocalVar() &amp;&amp; ptn-&gt;edge_count() == 0) {
 222         ptn-&gt;dump();
 223         assert(ptn-&gt;as_LocalVar()-&gt;edge_count() &gt; 0, &quot;sanity&quot;);
 224       }
 225     }
 226     _verify = false;
 227   }
 228 #endif
 229   // Bytecode analyzer BCEscapeAnalyzer, used for Call nodes
 230   // processing, calls to CI to resolve symbols (types, fields, methods)
 231   // referenced in bytecode. During symbol resolution VM may throw
 232   // an exception which CI cleans and converts to compilation failure.
 233   if (C-&gt;failing())  return false;
 234 
 235   // 2. Finish Graph construction by propagating references to all
 236   //    java objects through graph.
 237   if (!complete_connection_graph(ptnodes_worklist, non_escaped_worklist,
 238                                  java_objects_worklist, oop_fields_worklist)) {
 239     // All objects escaped or hit time or iterations limits.
 240     _collecting = false;
 241     return false;
 242   }
 243 
 244   // 3. Adjust scalar_replaceable state of nonescaping objects and push
 245   //    scalar replaceable allocations on alloc_worklist for processing
 246   //    in split_unique_types().
 247   int non_escaped_length = non_escaped_worklist.length();
 248   for (int next = 0; next &lt; non_escaped_length; next++) {
 249     JavaObjectNode* ptn = non_escaped_worklist.at(next);
 250     bool noescape = (ptn-&gt;escape_state() == PointsToNode::NoEscape);
 251     Node* n = ptn-&gt;ideal_node();
 252     if (n-&gt;is_Allocate()) {
 253       n-&gt;as_Allocate()-&gt;_is_non_escaping = noescape;
 254     }
 255     if (n-&gt;is_CallStaticJava()) {
 256       n-&gt;as_CallStaticJava()-&gt;_is_non_escaping = noescape;
 257     }
 258     if (noescape &amp;&amp; ptn-&gt;scalar_replaceable()) {
 259       adjust_scalar_replaceable_state(ptn);
 260       if (ptn-&gt;scalar_replaceable()) {
 261         alloc_worklist.append(ptn-&gt;ideal_node());
 262       }
 263     }
 264   }
 265 
 266 #ifdef ASSERT
 267   if (VerifyConnectionGraph) {
 268     // Verify that graph is complete - no new edges could be added or needed.
 269     verify_connection_graph(ptnodes_worklist, non_escaped_worklist,
 270                             java_objects_worklist, addp_worklist);
 271   }
 272   assert(C-&gt;unique() == nodes_size(), &quot;no new ideal nodes should be added during ConnectionGraph build&quot;);
 273   assert(null_obj-&gt;escape_state() == PointsToNode::NoEscape &amp;&amp;
 274          null_obj-&gt;edge_count() == 0 &amp;&amp;
 275          !null_obj-&gt;arraycopy_src() &amp;&amp;
 276          !null_obj-&gt;arraycopy_dst(), &quot;sanity&quot;);
 277 #endif
 278 
 279   _collecting = false;
 280 
 281   } // TracePhase t3(&quot;connectionGraph&quot;)
 282 
 283   // 4. Optimize ideal graph based on EA information.
 284   bool has_non_escaping_obj = (non_escaped_worklist.length() &gt; 0);
 285   if (has_non_escaping_obj) {
 286     optimize_ideal_graph(ptr_cmp_worklist, storestore_worklist);
 287   }
 288 
 289 #ifndef PRODUCT
 290   if (PrintEscapeAnalysis) {
 291     dump(ptnodes_worklist); // Dump ConnectionGraph
 292   }
 293 #endif
 294 
 295   bool has_scalar_replaceable_candidates = (alloc_worklist.length() &gt; 0);
 296 #ifdef ASSERT
 297   if (VerifyConnectionGraph) {
 298     int alloc_length = alloc_worklist.length();
 299     for (int next = 0; next &lt; alloc_length; ++next) {
 300       Node* n = alloc_worklist.at(next);
 301       PointsToNode* ptn = ptnode_adr(n-&gt;_idx);
 302       assert(ptn-&gt;escape_state() == PointsToNode::NoEscape &amp;&amp; ptn-&gt;scalar_replaceable(), &quot;sanity&quot;);
 303     }
 304   }
 305 #endif
 306 
 307   // 5. Separate memory graph for scalar replaceable allcations.
 308   if (has_scalar_replaceable_candidates &amp;&amp;
 309       C-&gt;AliasLevel() &gt;= 3 &amp;&amp; EliminateAllocations) {
 310     // Now use the escape information to create unique types for
 311     // scalar replaceable objects.
 312     split_unique_types(alloc_worklist, arraycopy_worklist);
 313     if (C-&gt;failing())  return false;
 314     C-&gt;print_method(PHASE_AFTER_EA, 2);
 315 
 316 #ifdef ASSERT
 317   } else if (Verbose &amp;&amp; (PrintEscapeAnalysis || PrintEliminateAllocations)) {
 318     tty-&gt;print(&quot;=== No allocations eliminated for &quot;);
 319     C-&gt;method()-&gt;print_short_name();
 320     if(!EliminateAllocations) {
 321       tty-&gt;print(&quot; since EliminateAllocations is off ===&quot;);
 322     } else if(!has_scalar_replaceable_candidates) {
 323       tty-&gt;print(&quot; since there are no scalar replaceable candidates ===&quot;);
 324     } else if(C-&gt;AliasLevel() &lt; 3) {
 325       tty-&gt;print(&quot; since AliasLevel &lt; 3 ===&quot;);
 326     }
 327     tty-&gt;cr();
 328 #endif
 329   }
 330   return has_non_escaping_obj;
 331 }
 332 
 333 // Utility function for nodes that load an object
 334 void ConnectionGraph::add_objload_to_connection_graph(Node *n, Unique_Node_List *delayed_worklist) {
 335   // Using isa_ptr() instead of isa_oopptr() for LoadP and Phi because
 336   // ThreadLocal has RawPtr type.
 337   const Type* t = _igvn-&gt;type(n);
 338   if (t-&gt;make_ptr() != NULL) {
 339     Node* adr = n-&gt;in(MemNode::Address);
 340 #ifdef ASSERT
 341     if (!adr-&gt;is_AddP()) {
 342       assert(_igvn-&gt;type(adr)-&gt;isa_rawptr(), &quot;sanity&quot;);
 343     } else {
 344       assert((ptnode_adr(adr-&gt;_idx) == NULL ||
 345               ptnode_adr(adr-&gt;_idx)-&gt;as_Field()-&gt;is_oop()), &quot;sanity&quot;);
 346     }
 347 #endif
 348     add_local_var_and_edge(n, PointsToNode::NoEscape,
 349                            adr, delayed_worklist);
 350   }
 351 }
 352 
 353 // Populate Connection Graph with PointsTo nodes and create simple
 354 // connection graph edges.
 355 void ConnectionGraph::add_node_to_connection_graph(Node *n, Unique_Node_List *delayed_worklist) {
 356   assert(!_verify, &quot;this method should not be called for verification&quot;);
 357   PhaseGVN* igvn = _igvn;
 358   uint n_idx = n-&gt;_idx;
 359   PointsToNode* n_ptn = ptnode_adr(n_idx);
 360   if (n_ptn != NULL)
 361     return; // No need to redefine PointsTo node during first iteration.
 362 
 363   int opcode = n-&gt;Opcode();
 364   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_add_to_con_graph(this, igvn, delayed_worklist, n, opcode);
 365   if (gc_handled) {
 366     return; // Ignore node if already handled by GC.
 367   }
 368 
 369   if (n-&gt;is_Call()) {
 370     // Arguments to allocation and locking don&#39;t escape.
 371     if (n-&gt;is_AbstractLock()) {
 372       // Put Lock and Unlock nodes on IGVN worklist to process them during
 373       // first IGVN optimization when escape information is still available.
 374       record_for_optimizer(n);
 375     } else if (n-&gt;is_Allocate()) {
 376       add_call_node(n-&gt;as_Call());
 377       record_for_optimizer(n);
 378     } else {
 379       if (n-&gt;is_CallStaticJava()) {
 380         const char* name = n-&gt;as_CallStaticJava()-&gt;_name;
 381         if (name != NULL &amp;&amp; strcmp(name, &quot;uncommon_trap&quot;) == 0)
 382           return; // Skip uncommon traps
 383       }
 384       // Don&#39;t mark as processed since call&#39;s arguments have to be processed.
 385       delayed_worklist-&gt;push(n);
 386       // Check if a call returns an object.
 387       if ((n-&gt;as_Call()-&gt;returns_pointer() &amp;&amp;
 388            n-&gt;as_Call()-&gt;proj_out_or_null(TypeFunc::Parms) != NULL) ||
 389           (n-&gt;is_CallStaticJava() &amp;&amp;
 390            n-&gt;as_CallStaticJava()-&gt;is_boxing_method())) {
 391         add_call_node(n-&gt;as_Call());
 392       } else if (n-&gt;as_Call()-&gt;tf()-&gt;returns_inline_type_as_fields()) {
 393         bool returns_oop = false;
 394         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax &amp;&amp; !returns_oop; i++) {
 395           ProjNode* pn = n-&gt;fast_out(i)-&gt;as_Proj();
 396           if (pn-&gt;_con &gt;= TypeFunc::Parms &amp;&amp; pn-&gt;bottom_type()-&gt;isa_ptr()) {
 397             returns_oop = true;
 398           }
 399         }
 400         if (returns_oop) {
 401           add_call_node(n-&gt;as_Call());
 402         }
 403       }
 404     }
 405     return;
 406   }
 407   // Put this check here to process call arguments since some call nodes
 408   // point to phantom_obj.
 409   if (n_ptn == phantom_obj || n_ptn == null_obj)
 410     return; // Skip predefined nodes.
 411 
 412   switch (opcode) {
 413     case Op_AddP: {
 414       Node* base = get_addp_base(n);
 415       PointsToNode* ptn_base = ptnode_adr(base-&gt;_idx);
 416       // Field nodes are created for all field types. They are used in
 417       // adjust_scalar_replaceable_state() and split_unique_types().
 418       // Note, non-oop fields will have only base edges in Connection
 419       // Graph because such fields are not used for oop loads and stores.
 420       int offset = address_offset(n, igvn);
 421       add_field(n, PointsToNode::NoEscape, offset);
 422       if (ptn_base == NULL) {
 423         delayed_worklist-&gt;push(n); // Process it later.
 424       } else {
 425         n_ptn = ptnode_adr(n_idx);
 426         add_base(n_ptn-&gt;as_Field(), ptn_base);
 427       }
 428       break;
 429     }
 430     case Op_CastX2P: {
 431       map_ideal_node(n, phantom_obj);
 432       break;
 433     }
 434     case Op_InlineTypePtr:
 435     case Op_CastPP:
 436     case Op_CheckCastPP:
 437     case Op_EncodeP:
 438     case Op_DecodeN:
 439     case Op_EncodePKlass:
 440     case Op_DecodeNKlass: {
 441       add_local_var_and_edge(n, PointsToNode::NoEscape,
 442                              n-&gt;in(1), delayed_worklist);
 443       break;
 444     }
 445     case Op_CMoveP: {
 446       add_local_var(n, PointsToNode::NoEscape);
 447       // Do not add edges during first iteration because some could be
 448       // not defined yet.
 449       delayed_worklist-&gt;push(n);
 450       break;
 451     }
 452     case Op_ConP:
 453     case Op_ConN:
 454     case Op_ConNKlass: {
 455       // assume all oop constants globally escape except for null
 456       PointsToNode::EscapeState es;
 457       const Type* t = igvn-&gt;type(n);
 458       if (t == TypePtr::NULL_PTR || t == TypeNarrowOop::NULL_PTR) {
 459         es = PointsToNode::NoEscape;
 460       } else {
 461         es = PointsToNode::GlobalEscape;
 462       }
 463       add_java_object(n, es);
 464       break;
 465     }
 466     case Op_CreateEx: {
 467       // assume that all exception objects globally escape
 468       map_ideal_node(n, phantom_obj);
 469       break;
 470     }
 471     case Op_LoadKlass:
 472     case Op_LoadNKlass: {
 473       // Unknown class is loaded
 474       map_ideal_node(n, phantom_obj);
 475       break;
 476     }
 477     case Op_LoadP:
 478     case Op_LoadN:
 479     case Op_LoadPLocked: {
 480       add_objload_to_connection_graph(n, delayed_worklist);
 481       break;
 482     }
 483     case Op_Parm: {
 484       map_ideal_node(n, phantom_obj);
 485       break;
 486     }
 487     case Op_PartialSubtypeCheck: {
 488       // Produces Null or notNull and is used in only in CmpP so
 489       // phantom_obj could be used.
 490       map_ideal_node(n, phantom_obj); // Result is unknown
 491       break;
 492     }
 493     case Op_Phi: {
 494       // Using isa_ptr() instead of isa_oopptr() for LoadP and Phi because
 495       // ThreadLocal has RawPtr type.
 496       const Type* t = n-&gt;as_Phi()-&gt;type();
 497       if (t-&gt;make_ptr() != NULL) {
 498         add_local_var(n, PointsToNode::NoEscape);
 499         // Do not add edges during first iteration because some could be
 500         // not defined yet.
 501         delayed_worklist-&gt;push(n);
 502       }
 503       break;
 504     }
 505     case Op_Proj: {
 506       // we are only interested in the oop result projection from a call
 507       if (n-&gt;as_Proj()-&gt;_con &gt;= TypeFunc::Parms &amp;&amp; n-&gt;in(0)-&gt;is_Call() &amp;&amp;
 508           (n-&gt;in(0)-&gt;as_Call()-&gt;returns_pointer() || n-&gt;bottom_type()-&gt;isa_ptr())) {
 509         assert((n-&gt;as_Proj()-&gt;_con == TypeFunc::Parms &amp;&amp; n-&gt;in(0)-&gt;as_Call()-&gt;returns_pointer()) ||
 510                n-&gt;in(0)-&gt;as_Call()-&gt;tf()-&gt;returns_inline_type_as_fields(), &quot;what kind of oop return is it?&quot;);
 511         add_local_var_and_edge(n, PointsToNode::NoEscape,
 512                                n-&gt;in(0), delayed_worklist);
 513       }
 514       break;
 515     }
 516     case Op_Rethrow: // Exception object escapes
 517     case Op_Return: {
 518       if (n-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
 519           igvn-&gt;type(n-&gt;in(TypeFunc::Parms))-&gt;isa_oopptr()) {
 520         // Treat Return value as LocalVar with GlobalEscape escape state.
 521         add_local_var_and_edge(n, PointsToNode::GlobalEscape,
 522                                n-&gt;in(TypeFunc::Parms), delayed_worklist);
 523       }
 524       break;
 525     }
 526     case Op_CompareAndExchangeP:
 527     case Op_CompareAndExchangeN:
 528     case Op_GetAndSetP:
 529     case Op_GetAndSetN: {
 530       add_objload_to_connection_graph(n, delayed_worklist);
 531       // fallthrough
 532     }
 533     case Op_StoreP:
 534     case Op_StoreN:
 535     case Op_StoreNKlass:
 536     case Op_StorePConditional:
 537     case Op_WeakCompareAndSwapP:
 538     case Op_WeakCompareAndSwapN:
 539     case Op_CompareAndSwapP:
 540     case Op_CompareAndSwapN: {
 541       add_to_congraph_unsafe_access(n, opcode, delayed_worklist);
 542       break;
 543     }
 544     case Op_AryEq:
 545     case Op_HasNegatives:
 546     case Op_StrComp:
 547     case Op_StrEquals:
 548     case Op_StrIndexOf:
 549     case Op_StrIndexOfChar:
 550     case Op_StrInflatedCopy:
 551     case Op_StrCompressedCopy:
 552     case Op_EncodeISOArray: {
 553       add_local_var(n, PointsToNode::ArgEscape);
 554       delayed_worklist-&gt;push(n); // Process it later.
 555       break;
 556     }
 557     case Op_ThreadLocal: {
 558       add_java_object(n, PointsToNode::ArgEscape);
 559       break;
 560     }
 561     default:
 562       ; // Do nothing for nodes not related to EA.
 563   }
 564   return;
 565 }
 566 
 567 #ifdef ASSERT
 568 #define ELSE_FAIL(name)                               \
 569       /* Should not be called for not pointer type. */  \
 570       n-&gt;dump(1);                                       \
 571       assert(false, name);                              \
 572       break;
 573 #else
 574 #define ELSE_FAIL(name) \
 575       break;
 576 #endif
 577 
 578 // Add final simple edges to graph.
 579 void ConnectionGraph::add_final_edges(Node *n) {
 580   PointsToNode* n_ptn = ptnode_adr(n-&gt;_idx);
 581 #ifdef ASSERT
 582   if (_verify &amp;&amp; n_ptn-&gt;is_JavaObject())
 583     return; // This method does not change graph for JavaObject.
 584 #endif
 585 
 586   if (n-&gt;is_Call()) {
 587     process_call_arguments(n-&gt;as_Call());
 588     return;
 589   }
 590   assert(n-&gt;is_Store() || n-&gt;is_LoadStore() ||
 591          (n_ptn != NULL) &amp;&amp; (n_ptn-&gt;ideal_node() != NULL),
 592          &quot;node should be registered already&quot;);
 593   int opcode = n-&gt;Opcode();
 594   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_add_final_edges(this, _igvn, n, opcode);
 595   if (gc_handled) {
 596     return; // Ignore node if already handled by GC.
 597   }
 598   switch (opcode) {
 599     case Op_AddP: {
 600       Node* base = get_addp_base(n);
 601       PointsToNode* ptn_base = ptnode_adr(base-&gt;_idx);
 602       assert(ptn_base != NULL, &quot;field&#39;s base should be registered&quot;);
 603       add_base(n_ptn-&gt;as_Field(), ptn_base);
 604       break;
 605     }
 606     case Op_InlineTypePtr:
 607     case Op_CastPP:
 608     case Op_CheckCastPP:
 609     case Op_EncodeP:
 610     case Op_DecodeN:
 611     case Op_EncodePKlass:
 612     case Op_DecodeNKlass: {
 613       add_local_var_and_edge(n, PointsToNode::NoEscape,
 614                              n-&gt;in(1), NULL);
 615       break;
 616     }
 617     case Op_CMoveP: {
 618       for (uint i = CMoveNode::IfFalse; i &lt; n-&gt;req(); i++) {
 619         Node* in = n-&gt;in(i);
 620         if (in == NULL)
 621           continue;  // ignore NULL
 622         Node* uncast_in = in-&gt;uncast();
 623         if (uncast_in-&gt;is_top() || uncast_in == n)
 624           continue;  // ignore top or inputs which go back this node
 625         PointsToNode* ptn = ptnode_adr(in-&gt;_idx);
 626         assert(ptn != NULL, &quot;node should be registered&quot;);
 627         add_edge(n_ptn, ptn);
 628       }
 629       break;
 630     }
 631     case Op_LoadP:
 632     case Op_LoadN:
 633     case Op_LoadPLocked: {
 634       // Using isa_ptr() instead of isa_oopptr() for LoadP and Phi because
 635       // ThreadLocal has RawPtr type.
 636       const Type* t = _igvn-&gt;type(n);
 637       if (t-&gt;make_ptr() != NULL) {
 638         Node* adr = n-&gt;in(MemNode::Address);
 639         add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);
 640         break;
 641       }
 642       ELSE_FAIL(&quot;Op_LoadP&quot;);
 643     }
 644     case Op_Phi: {
 645       // Using isa_ptr() instead of isa_oopptr() for LoadP and Phi because
 646       // ThreadLocal has RawPtr type.
 647       const Type* t = n-&gt;as_Phi()-&gt;type();
 648       if (t-&gt;make_ptr() != NULL) {
 649         for (uint i = 1; i &lt; n-&gt;req(); i++) {
 650           Node* in = n-&gt;in(i);
 651           if (in == NULL)
 652             continue;  // ignore NULL
 653           Node* uncast_in = in-&gt;uncast();
 654           if (uncast_in-&gt;is_top() || uncast_in == n)
 655             continue;  // ignore top or inputs which go back this node
 656           PointsToNode* ptn = ptnode_adr(in-&gt;_idx);
 657           assert(ptn != NULL, &quot;node should be registered&quot;);
 658           add_edge(n_ptn, ptn);
 659         }
 660         break;
 661       }
 662       ELSE_FAIL(&quot;Op_Phi&quot;);
 663     }
 664     case Op_Proj: {
 665       // we are only interested in the oop result projection from a call
 666       if (n-&gt;as_Proj()-&gt;_con &gt;= TypeFunc::Parms &amp;&amp; n-&gt;in(0)-&gt;is_Call() &amp;&amp;
 667           (n-&gt;in(0)-&gt;as_Call()-&gt;returns_pointer()|| n-&gt;bottom_type()-&gt;isa_ptr())) {
 668         assert((n-&gt;as_Proj()-&gt;_con == TypeFunc::Parms &amp;&amp; n-&gt;in(0)-&gt;as_Call()-&gt;returns_pointer()) ||
 669                n-&gt;in(0)-&gt;as_Call()-&gt;tf()-&gt;returns_inline_type_as_fields(), &quot;what kind of oop return is it?&quot;);
 670         add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(0), NULL);
 671         break;
 672       }
 673       ELSE_FAIL(&quot;Op_Proj&quot;);
 674     }
 675     case Op_Rethrow: // Exception object escapes
 676     case Op_Return: {
 677       if (n-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
 678           _igvn-&gt;type(n-&gt;in(TypeFunc::Parms))-&gt;isa_oopptr()) {
 679         // Treat Return value as LocalVar with GlobalEscape escape state.
 680         add_local_var_and_edge(n, PointsToNode::GlobalEscape,
 681                                n-&gt;in(TypeFunc::Parms), NULL);
 682         break;
 683       }
 684       ELSE_FAIL(&quot;Op_Return&quot;);
 685     }
 686     case Op_StoreP:
 687     case Op_StoreN:
 688     case Op_StoreNKlass:
 689     case Op_StorePConditional:
 690     case Op_CompareAndExchangeP:
 691     case Op_CompareAndExchangeN:
 692     case Op_CompareAndSwapP:
 693     case Op_CompareAndSwapN:
 694     case Op_WeakCompareAndSwapP:
 695     case Op_WeakCompareAndSwapN:
 696     case Op_GetAndSetP:
 697     case Op_GetAndSetN: {
 698       if (add_final_edges_unsafe_access(n, opcode)) {
 699         break;
 700       }
 701       ELSE_FAIL(&quot;Op_StoreP&quot;);
 702     }
 703     case Op_AryEq:
 704     case Op_HasNegatives:
 705     case Op_StrComp:
 706     case Op_StrEquals:
 707     case Op_StrIndexOf:
 708     case Op_StrIndexOfChar:
 709     case Op_StrInflatedCopy:
 710     case Op_StrCompressedCopy:
 711     case Op_EncodeISOArray: {
 712       // char[]/byte[] arrays passed to string intrinsic do not escape but
 713       // they are not scalar replaceable. Adjust escape state for them.
 714       // Start from in(2) edge since in(1) is memory edge.
 715       for (uint i = 2; i &lt; n-&gt;req(); i++) {
 716         Node* adr = n-&gt;in(i);
 717         const Type* at = _igvn-&gt;type(adr);
 718         if (!adr-&gt;is_top() &amp;&amp; at-&gt;isa_ptr()) {
 719           assert(at == Type::TOP || at == TypePtr::NULL_PTR ||
 720                  at-&gt;isa_ptr() != NULL, &quot;expecting a pointer&quot;);
 721           if (adr-&gt;is_AddP()) {
 722             adr = get_addp_base(adr);
 723           }
 724           PointsToNode* ptn = ptnode_adr(adr-&gt;_idx);
 725           assert(ptn != NULL, &quot;node should be registered&quot;);
 726           add_edge(n_ptn, ptn);
 727         }
 728       }
 729       break;
 730     }
 731     default: {
 732       // This method should be called only for EA specific nodes which may
 733       // miss some edges when they were created.
 734 #ifdef ASSERT
 735       n-&gt;dump(1);
 736 #endif
 737       guarantee(false, &quot;unknown node&quot;);
 738     }
 739   }
 740   return;
 741 }
 742 
 743 void ConnectionGraph::add_to_congraph_unsafe_access(Node* n, uint opcode, Unique_Node_List* delayed_worklist) {
 744   Node* adr = n-&gt;in(MemNode::Address);
 745   const Type* adr_type = _igvn-&gt;type(adr);
 746   adr_type = adr_type-&gt;make_ptr();
 747   if (adr_type == NULL) {
 748     return; // skip dead nodes
 749   }
 750   if (adr_type-&gt;isa_oopptr()
 751       || ((opcode == Op_StoreP || opcode == Op_StoreN || opcode == Op_StoreNKlass)
 752           &amp;&amp; adr_type == TypeRawPtr::NOTNULL
 753           &amp;&amp; adr-&gt;in(AddPNode::Address)-&gt;is_Proj()
 754           &amp;&amp; adr-&gt;in(AddPNode::Address)-&gt;in(0)-&gt;is_Allocate())) {
 755     delayed_worklist-&gt;push(n); // Process it later.
 756 #ifdef ASSERT
 757     assert (adr-&gt;is_AddP(), &quot;expecting an AddP&quot;);
 758     if (adr_type == TypeRawPtr::NOTNULL) {
 759       // Verify a raw address for a store captured by Initialize node.
 760       int offs = (int) _igvn-&gt;find_intptr_t_con(adr-&gt;in(AddPNode::Offset), Type::OffsetBot);
 761       assert(offs != Type::OffsetBot, &quot;offset must be a constant&quot;);
 762     }
 763 #endif
 764   } else {
 765     // Ignore copy the displaced header to the BoxNode (OSR compilation).
 766     if (adr-&gt;is_BoxLock()) {
 767       return;
 768     }
 769     // Stored value escapes in unsafe access.
 770     if ((opcode == Op_StoreP) &amp;&amp; adr_type-&gt;isa_rawptr()) {
 771       delayed_worklist-&gt;push(n); // Process unsafe access later.
 772       return;
 773     }
 774 #ifdef ASSERT
 775     n-&gt;dump(1);
 776     assert(false, &quot;not unsafe&quot;);
 777 #endif
 778   }
 779 }
 780 
 781 bool ConnectionGraph::add_final_edges_unsafe_access(Node* n, uint opcode) {
 782   Node* adr = n-&gt;in(MemNode::Address);
 783   const Type *adr_type = _igvn-&gt;type(adr);
 784   adr_type = adr_type-&gt;make_ptr();
 785 #ifdef ASSERT
 786   if (adr_type == NULL) {
 787     n-&gt;dump(1);
 788     assert(adr_type != NULL, &quot;dead node should not be on list&quot;);
 789     return true;
 790   }
 791 #endif
 792 
 793   if (opcode == Op_GetAndSetP || opcode == Op_GetAndSetN ||
 794       opcode == Op_CompareAndExchangeN || opcode == Op_CompareAndExchangeP) {
 795     add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);
 796   }
 797 
 798   if (adr_type-&gt;isa_oopptr()
 799       || ((opcode == Op_StoreP || opcode == Op_StoreN || opcode == Op_StoreNKlass)
 800            &amp;&amp; adr_type == TypeRawPtr::NOTNULL
 801            &amp;&amp; adr-&gt;in(AddPNode::Address)-&gt;is_Proj()
 802            &amp;&amp; adr-&gt;in(AddPNode::Address)-&gt;in(0)-&gt;is_Allocate())) {
 803     // Point Address to Value
 804     PointsToNode* adr_ptn = ptnode_adr(adr-&gt;_idx);
 805     assert(adr_ptn != NULL &amp;&amp;
 806            adr_ptn-&gt;as_Field()-&gt;is_oop(), &quot;node should be registered&quot;);
 807     Node* val = n-&gt;in(MemNode::ValueIn);
 808     PointsToNode* ptn = ptnode_adr(val-&gt;_idx);
 809     assert(ptn != NULL, &quot;node should be registered&quot;);
 810     add_edge(adr_ptn, ptn);
 811     return true;
 812   } else if ((opcode == Op_StoreP) &amp;&amp; adr_type-&gt;isa_rawptr()) {
 813     // Stored value escapes in unsafe access.
 814     Node* val = n-&gt;in(MemNode::ValueIn);
 815     PointsToNode* ptn = ptnode_adr(val-&gt;_idx);
 816     assert(ptn != NULL, &quot;node should be registered&quot;);
 817     set_escape_state(ptn, PointsToNode::GlobalEscape);
 818     // Add edge to object for unsafe access with offset.
 819     PointsToNode* adr_ptn = ptnode_adr(adr-&gt;_idx);
 820     assert(adr_ptn != NULL, &quot;node should be registered&quot;);
 821     if (adr_ptn-&gt;is_Field()) {
 822       assert(adr_ptn-&gt;as_Field()-&gt;is_oop(), &quot;should be oop field&quot;);
 823       add_edge(adr_ptn, ptn);
 824     }
 825     return true;
 826   }
 827   return false;
 828 }
 829 
 830 void ConnectionGraph::add_call_node(CallNode* call) {
 831   assert(call-&gt;returns_pointer() || call-&gt;tf()-&gt;returns_inline_type_as_fields(), &quot;only for call which returns pointer&quot;);
 832   uint call_idx = call-&gt;_idx;
 833   if (call-&gt;is_Allocate()) {
 834     Node* k = call-&gt;in(AllocateNode::KlassNode);
 835     const TypeKlassPtr* kt = k-&gt;bottom_type()-&gt;isa_klassptr();
 836     assert(kt != NULL, &quot;TypeKlassPtr  required.&quot;);
 837     ciKlass* cik = kt-&gt;klass();
 838     PointsToNode::EscapeState es = PointsToNode::NoEscape;
 839     bool scalar_replaceable = true;
 840     if (call-&gt;is_AllocateArray()) {
 841       if (!cik-&gt;is_array_klass()) { // StressReflectiveCode
 842         es = PointsToNode::GlobalEscape;
 843       } else {
 844         int length = call-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 845         if (length &lt; 0 || length &gt; EliminateAllocationArraySizeLimit) {
 846           // Not scalar replaceable if the length is not constant or too big.
 847           scalar_replaceable = false;
 848         }
 849       }
 850     } else {  // Allocate instance
 851       if (cik-&gt;is_subclass_of(_compile-&gt;env()-&gt;Thread_klass()) ||
 852           cik-&gt;is_subclass_of(_compile-&gt;env()-&gt;Reference_klass()) ||
 853          !cik-&gt;is_instance_klass() || // StressReflectiveCode
 854          !cik-&gt;as_instance_klass()-&gt;can_be_instantiated() ||
 855           cik-&gt;as_instance_klass()-&gt;has_finalizer()) {
 856         es = PointsToNode::GlobalEscape;
 857       }
 858     }
 859     add_java_object(call, es);
 860     PointsToNode* ptn = ptnode_adr(call_idx);
 861     if (!scalar_replaceable &amp;&amp; ptn-&gt;scalar_replaceable()) {
 862       ptn-&gt;set_scalar_replaceable(false);
 863     }
 864   } else if (call-&gt;is_CallStaticJava()) {
 865     // Call nodes could be different types:
 866     //
 867     // 1. CallDynamicJavaNode (what happened during call is unknown):
 868     //
 869     //    - mapped to GlobalEscape JavaObject node if oop is returned;
 870     //
 871     //    - all oop arguments are escaping globally;
 872     //
 873     // 2. CallStaticJavaNode (execute bytecode analysis if possible):
 874     //
 875     //    - the same as CallDynamicJavaNode if can&#39;t do bytecode analysis;
 876     //
 877     //    - mapped to GlobalEscape JavaObject node if unknown oop is returned;
 878     //    - mapped to NoEscape JavaObject node if non-escaping object allocated
 879     //      during call is returned;
 880     //    - mapped to ArgEscape LocalVar node pointed to object arguments
 881     //      which are returned and does not escape during call;
 882     //
 883     //    - oop arguments escaping status is defined by bytecode analysis;
 884     //
 885     // For a static call, we know exactly what method is being called.
 886     // Use bytecode estimator to record whether the call&#39;s return value escapes.
 887     ciMethod* meth = call-&gt;as_CallJava()-&gt;method();
 888     if (meth == NULL) {
 889       const char* name = call-&gt;as_CallStaticJava()-&gt;_name;
 890       assert(strncmp(name, &quot;_multianewarray&quot;, 15) == 0, &quot;TODO: add failed case check&quot;);
 891       // Returns a newly allocated unescaped object.
 892       add_java_object(call, PointsToNode::NoEscape);
 893       ptnode_adr(call_idx)-&gt;set_scalar_replaceable(false);
 894     } else if (meth-&gt;is_boxing_method()) {
 895       // Returns boxing object
 896       PointsToNode::EscapeState es;
 897       vmIntrinsics::ID intr = meth-&gt;intrinsic_id();
 898       if (intr == vmIntrinsics::_floatValue || intr == vmIntrinsics::_doubleValue) {
 899         // It does not escape if object is always allocated.
 900         es = PointsToNode::NoEscape;
 901       } else {
 902         // It escapes globally if object could be loaded from cache.
 903         es = PointsToNode::GlobalEscape;
 904       }
 905       add_java_object(call, es);
 906     } else {
 907       BCEscapeAnalyzer* call_analyzer = meth-&gt;get_bcea();
 908       call_analyzer-&gt;copy_dependencies(_compile-&gt;dependencies());
 909       if (call_analyzer-&gt;is_return_allocated()) {
 910         // Returns a newly allocated unescaped object, simply
 911         // update dependency information.
 912         // Mark it as NoEscape so that objects referenced by
 913         // it&#39;s fields will be marked as NoEscape at least.
 914         add_java_object(call, PointsToNode::NoEscape);
 915         ptnode_adr(call_idx)-&gt;set_scalar_replaceable(false);
 916       } else {
 917         // Determine whether any arguments are returned.
 918         const TypeTuple* d = call-&gt;tf()-&gt;domain_cc();
 919         bool ret_arg = false;
 920         for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 921           if (d-&gt;field_at(i)-&gt;isa_ptr() != NULL &amp;&amp;
 922               call_analyzer-&gt;is_arg_returned(i - TypeFunc::Parms)) {
 923             ret_arg = true;
 924             break;
 925           }
 926         }
 927         if (ret_arg) {
 928           add_local_var(call, PointsToNode::ArgEscape);
 929         } else {
 930           // Returns unknown object.
 931           map_ideal_node(call, phantom_obj);
 932         }
 933       }
 934     }
 935   } else {
 936     // An other type of call, assume the worst case:
 937     // returned value is unknown and globally escapes.
 938     assert(call-&gt;Opcode() == Op_CallDynamicJava, &quot;add failed case check&quot;);
 939     map_ideal_node(call, phantom_obj);
 940   }
 941 }
 942 
 943 void ConnectionGraph::process_call_arguments(CallNode *call) {
 944     bool is_arraycopy = false;
 945     switch (call-&gt;Opcode()) {
 946 #ifdef ASSERT
 947     case Op_Allocate:
 948     case Op_AllocateArray:
 949     case Op_Lock:
 950     case Op_Unlock:
 951       assert(false, &quot;should be done already&quot;);
 952       break;
 953 #endif
 954     case Op_ArrayCopy:
 955     case Op_CallLeafNoFP:
 956       // Most array copies are ArrayCopy nodes at this point but there
 957       // are still a few direct calls to the copy subroutines (See
 958       // PhaseStringOpts::copy_string())
 959       is_arraycopy = (call-&gt;Opcode() == Op_ArrayCopy) ||
 960         call-&gt;as_CallLeaf()-&gt;is_call_to_arraycopystub();
 961       // fall through
 962     case Op_CallLeaf: {
 963       // Stub calls, objects do not escape but they are not scale replaceable.
 964       // Adjust escape state for outgoing arguments.
 965       const TypeTuple * d = call-&gt;tf()-&gt;domain_sig();
 966       bool src_has_oops = false;
 967       for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 968         const Type* at = d-&gt;field_at(i);
 969         Node *arg = call-&gt;in(i);
 970         if (arg == NULL) {
 971           continue;
 972         }
 973         const Type *aat = _igvn-&gt;type(arg);
 974         if (arg-&gt;is_top() || !at-&gt;isa_ptr() || !aat-&gt;isa_ptr())
 975           continue;
 976         if (arg-&gt;is_AddP()) {
 977           //
 978           // The inline_native_clone() case when the arraycopy stub is called
 979           // after the allocation before Initialize and CheckCastPP nodes.
 980           // Or normal arraycopy for object arrays case.
 981           //
 982           // Set AddP&#39;s base (Allocate) as not scalar replaceable since
 983           // pointer to the base (with offset) is passed as argument.
 984           //
 985           arg = get_addp_base(arg);
 986         }
 987         PointsToNode* arg_ptn = ptnode_adr(arg-&gt;_idx);
 988         assert(arg_ptn != NULL, &quot;should be registered&quot;);
 989         PointsToNode::EscapeState arg_esc = arg_ptn-&gt;escape_state();
 990         if (is_arraycopy || arg_esc &lt; PointsToNode::ArgEscape) {
 991           assert(aat == Type::TOP || aat == TypePtr::NULL_PTR ||
 992                  aat-&gt;isa_ptr() != NULL, &quot;expecting an Ptr&quot;);
 993           bool arg_has_oops = aat-&gt;isa_oopptr() &amp;&amp;
 994                               (aat-&gt;isa_oopptr()-&gt;klass() == NULL || aat-&gt;isa_instptr() ||
 995                                (aat-&gt;isa_aryptr() &amp;&amp; aat-&gt;isa_aryptr()-&gt;klass()-&gt;is_obj_array_klass()) ||
 996                                (aat-&gt;isa_aryptr() &amp;&amp; aat-&gt;isa_aryptr()-&gt;elem() != NULL &amp;&amp;
 997                                 aat-&gt;isa_aryptr()-&gt;elem()-&gt;isa_inlinetype() &amp;&amp;
 998                                 aat-&gt;isa_aryptr()-&gt;elem()-&gt;inline_klass()-&gt;contains_oops()));
 999           if (i == TypeFunc::Parms) {
1000             src_has_oops = arg_has_oops;
1001           }
1002           //
1003           // src or dst could be j.l.Object when other is basic type array:
1004           //
1005           //   arraycopy(char[],0,Object*,0,size);
1006           //   arraycopy(Object*,0,char[],0,size);
1007           //
1008           // Don&#39;t add edges in such cases.
1009           //
1010           bool arg_is_arraycopy_dest = src_has_oops &amp;&amp; is_arraycopy &amp;&amp;
1011                                        arg_has_oops &amp;&amp; (i &gt; TypeFunc::Parms);
1012 #ifdef ASSERT
1013           if (!(is_arraycopy ||
1014                 BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(call) ||
1015                 (call-&gt;as_CallLeaf()-&gt;_name != NULL &amp;&amp;
1016                  (strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;updateBytesCRC32&quot;) == 0 ||
1017                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;updateBytesCRC32C&quot;) == 0 ||
1018                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;updateBytesAdler32&quot;) == 0 ||
1019                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;aescrypt_encryptBlock&quot;) == 0 ||
1020                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;aescrypt_decryptBlock&quot;) == 0 ||
1021                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;cipherBlockChaining_encryptAESCrypt&quot;) == 0 ||
1022                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;cipherBlockChaining_decryptAESCrypt&quot;) == 0 ||
1023                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;electronicCodeBook_encryptAESCrypt&quot;) == 0 ||
1024                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;electronicCodeBook_decryptAESCrypt&quot;) == 0 ||
1025                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;counterMode_AESCrypt&quot;) == 0 ||
1026                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;ghash_processBlocks&quot;) == 0 ||
1027                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;encodeBlock&quot;) == 0 ||
1028                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha1_implCompress&quot;) == 0 ||
1029                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha1_implCompressMB&quot;) == 0 ||
1030                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha256_implCompress&quot;) == 0 ||
1031                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha256_implCompressMB&quot;) == 0 ||
1032                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha512_implCompress&quot;) == 0 ||
1033                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha512_implCompressMB&quot;) == 0 ||
1034                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;multiplyToLen&quot;) == 0 ||
1035                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;squareToLen&quot;) == 0 ||
1036                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;mulAdd&quot;) == 0 ||
1037                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;montgomery_multiply&quot;) == 0 ||
1038                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;montgomery_square&quot;) == 0 ||
1039                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;vectorizedMismatch&quot;) == 0 ||
1040                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;load_unknown_inline&quot;) == 0 ||
1041                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;store_unknown_inline&quot;) == 0 ||
1042                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;bigIntegerRightShiftWorker&quot;) == 0 ||
1043                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;bigIntegerLeftShiftWorker&quot;) == 0 ||
1044                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;vectorizedMismatch&quot;) == 0)
1045                  ))) {
1046             call-&gt;dump();
1047             fatal(&quot;EA unexpected CallLeaf %s&quot;, call-&gt;as_CallLeaf()-&gt;_name);
1048           }
1049 #endif
1050           // Always process arraycopy&#39;s destination object since
1051           // we need to add all possible edges to references in
1052           // source object.
1053           if (arg_esc &gt;= PointsToNode::ArgEscape &amp;&amp;
1054               !arg_is_arraycopy_dest) {
1055             continue;
1056           }
1057           PointsToNode::EscapeState es = PointsToNode::ArgEscape;
1058           if (call-&gt;is_ArrayCopy()) {
1059             ArrayCopyNode* ac = call-&gt;as_ArrayCopy();
1060             if (ac-&gt;is_clonebasic() ||
1061                 ac-&gt;is_arraycopy_validated() ||
1062                 ac-&gt;is_copyof_validated() ||
1063                 ac-&gt;is_copyofrange_validated()) {
1064               es = PointsToNode::NoEscape;
1065             }
1066           }
1067           set_escape_state(arg_ptn, es);
1068           if (arg_is_arraycopy_dest) {
1069             Node* src = call-&gt;in(TypeFunc::Parms);
1070             if (src-&gt;is_AddP()) {
1071               src = get_addp_base(src);
1072             }
1073             PointsToNode* src_ptn = ptnode_adr(src-&gt;_idx);
1074             assert(src_ptn != NULL, &quot;should be registered&quot;);
1075             if (arg_ptn != src_ptn) {
1076               // Special arraycopy edge:
1077               // A destination object&#39;s field can&#39;t have the source object
1078               // as base since objects escape states are not related.
1079               // Only escape state of destination object&#39;s fields affects
1080               // escape state of fields in source object.
1081               add_arraycopy(call, es, src_ptn, arg_ptn);
1082             }
1083           }
1084         }
1085       }
1086       break;
1087     }
1088     case Op_CallStaticJava: {
1089       // For a static call, we know exactly what method is being called.
1090       // Use bytecode estimator to record the call&#39;s escape affects
1091 #ifdef ASSERT
1092       const char* name = call-&gt;as_CallStaticJava()-&gt;_name;
1093       assert((name == NULL || strcmp(name, &quot;uncommon_trap&quot;) != 0), &quot;normal calls only&quot;);
1094 #endif
1095       ciMethod* meth = call-&gt;as_CallJava()-&gt;method();
1096       if ((meth != NULL) &amp;&amp; meth-&gt;is_boxing_method()) {
1097         break; // Boxing methods do not modify any oops.
1098       }
1099       BCEscapeAnalyzer* call_analyzer = (meth !=NULL) ? meth-&gt;get_bcea() : NULL;
1100       // fall-through if not a Java method or no analyzer information
1101       if (call_analyzer != NULL) {
1102         PointsToNode* call_ptn = ptnode_adr(call-&gt;_idx);
1103         const TypeTuple* d = call-&gt;tf()-&gt;domain_cc();
1104         for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
1105           const Type* at = d-&gt;field_at(i);
1106           int k = i - TypeFunc::Parms;
1107           Node* arg = call-&gt;in(i);
1108           PointsToNode* arg_ptn = ptnode_adr(arg-&gt;_idx);
1109           if (at-&gt;isa_ptr() != NULL &amp;&amp;
1110               call_analyzer-&gt;is_arg_returned(k)) {
1111             // The call returns arguments.
1112             if (call_ptn != NULL) { // Is call&#39;s result used?
1113               assert(call_ptn-&gt;is_LocalVar(), &quot;node should be registered&quot;);
1114               assert(arg_ptn != NULL, &quot;node should be registered&quot;);
1115               add_edge(call_ptn, arg_ptn);
1116             }
1117           }
1118           if (at-&gt;isa_oopptr() != NULL &amp;&amp;
1119               arg_ptn-&gt;escape_state() &lt; PointsToNode::GlobalEscape) {
1120             if (!call_analyzer-&gt;is_arg_stack(k)) {
1121               // The argument global escapes
1122               set_escape_state(arg_ptn, PointsToNode::GlobalEscape);
1123             } else {
1124               set_escape_state(arg_ptn, PointsToNode::ArgEscape);
1125               if (!call_analyzer-&gt;is_arg_local(k)) {
1126                 // The argument itself doesn&#39;t escape, but any fields might
1127                 set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape);
1128               }
1129             }
1130           }
1131         }
1132         if (call_ptn != NULL &amp;&amp; call_ptn-&gt;is_LocalVar()) {
1133           // The call returns arguments.
1134           assert(call_ptn-&gt;edge_count() &gt; 0, &quot;sanity&quot;);
1135           if (!call_analyzer-&gt;is_return_local()) {
1136             // Returns also unknown object.
1137             add_edge(call_ptn, phantom_obj);
1138           }
1139         }
1140         break;
1141       }
1142     }
1143     default: {
1144       // Fall-through here if not a Java method or no analyzer information
1145       // or some other type of call, assume the worst case: all arguments
1146       // globally escape.
1147       const TypeTuple* d = call-&gt;tf()-&gt;domain_cc();
1148       for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
1149         const Type* at = d-&gt;field_at(i);
1150         if (at-&gt;isa_oopptr() != NULL) {
1151           Node* arg = call-&gt;in(i);
1152           if (arg-&gt;is_AddP()) {
1153             arg = get_addp_base(arg);
1154           }
1155           assert(ptnode_adr(arg-&gt;_idx) != NULL, &quot;should be defined already&quot;);
1156           set_escape_state(ptnode_adr(arg-&gt;_idx), PointsToNode::GlobalEscape);
1157         }
1158       }
1159     }
1160   }
1161 }
1162 
1163 
1164 // Finish Graph construction.
1165 bool ConnectionGraph::complete_connection_graph(
1166                          GrowableArray&lt;PointsToNode*&gt;&amp;   ptnodes_worklist,
1167                          GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist,
1168                          GrowableArray&lt;JavaObjectNode*&gt;&amp; java_objects_worklist,
1169                          GrowableArray&lt;FieldNode*&gt;&amp;      oop_fields_worklist) {
1170   // Normally only 1-3 passes needed to build Connection Graph depending
1171   // on graph complexity. Observed 8 passes in jvm2008 compiler.compiler.
1172   // Set limit to 20 to catch situation when something did go wrong and
1173   // bailout Escape Analysis.
1174   // Also limit build time to 20 sec (60 in debug VM), EscapeAnalysisTimeout flag.
1175 #define CG_BUILD_ITER_LIMIT 20
1176 
1177   // Propagate GlobalEscape and ArgEscape escape states and check that
1178   // we still have non-escaping objects. The method pushs on _worklist
1179   // Field nodes which reference phantom_object.
1180   if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist)) {
1181     return false; // Nothing to do.
1182   }
1183   // Now propagate references to all JavaObject nodes.
1184   int java_objects_length = java_objects_worklist.length();
1185   elapsedTimer time;
1186   bool timeout = false;
1187   int new_edges = 1;
1188   int iterations = 0;
1189   do {
1190     while ((new_edges &gt; 0) &amp;&amp;
1191            (iterations++ &lt; CG_BUILD_ITER_LIMIT)) {
1192       double start_time = time.seconds();
1193       time.start();
1194       new_edges = 0;
1195       // Propagate references to phantom_object for nodes pushed on _worklist
1196       // by find_non_escaped_objects() and find_field_value().
1197       new_edges += add_java_object_edges(phantom_obj, false);
1198       for (int next = 0; next &lt; java_objects_length; ++next) {
1199         JavaObjectNode* ptn = java_objects_worklist.at(next);
1200         new_edges += add_java_object_edges(ptn, true);
1201 
1202 #define SAMPLE_SIZE 4
1203         if ((next % SAMPLE_SIZE) == 0) {
1204           // Each 4 iterations calculate how much time it will take
1205           // to complete graph construction.
1206           time.stop();
1207           // Poll for requests from shutdown mechanism to quiesce compiler
1208           // because Connection graph construction may take long time.
1209           CompileBroker::maybe_block();
1210           double stop_time = time.seconds();
1211           double time_per_iter = (stop_time - start_time) / (double)SAMPLE_SIZE;
1212           double time_until_end = time_per_iter * (double)(java_objects_length - next);
1213           if ((start_time + time_until_end) &gt;= EscapeAnalysisTimeout) {
1214             timeout = true;
1215             break; // Timeout
1216           }
1217           start_time = stop_time;
1218           time.start();
1219         }
1220 #undef SAMPLE_SIZE
1221 
1222       }
1223       if (timeout) break;
1224       if (new_edges &gt; 0) {
1225         // Update escape states on each iteration if graph was updated.
1226         if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist)) {
1227           return false; // Nothing to do.
1228         }
1229       }
1230       time.stop();
1231       if (time.seconds() &gt;= EscapeAnalysisTimeout) {
1232         timeout = true;
1233         break;
1234       }
1235     }
1236     if ((iterations &lt; CG_BUILD_ITER_LIMIT) &amp;&amp; !timeout) {
1237       time.start();
1238       // Find fields which have unknown value.
1239       int fields_length = oop_fields_worklist.length();
1240       for (int next = 0; next &lt; fields_length; next++) {
1241         FieldNode* field = oop_fields_worklist.at(next);
1242         if (field-&gt;edge_count() == 0) {
1243           new_edges += find_field_value(field);
1244           // This code may added new edges to phantom_object.
1245           // Need an other cycle to propagate references to phantom_object.
1246         }
1247       }
1248       time.stop();
1249       if (time.seconds() &gt;= EscapeAnalysisTimeout) {
1250         timeout = true;
1251         break;
1252       }
1253     } else {
1254       new_edges = 0; // Bailout
1255     }
1256   } while (new_edges &gt; 0);
1257 
1258   // Bailout if passed limits.
1259   if ((iterations &gt;= CG_BUILD_ITER_LIMIT) || timeout) {
1260     Compile* C = _compile;
1261     if (C-&gt;log() != NULL) {
1262       C-&gt;log()-&gt;begin_elem(&quot;connectionGraph_bailout reason=&#39;reached &quot;);
1263       C-&gt;log()-&gt;text(&quot;%s&quot;, timeout ? &quot;time&quot; : &quot;iterations&quot;);
1264       C-&gt;log()-&gt;end_elem(&quot; limit&#39;&quot;);
1265     }
1266     assert(ExitEscapeAnalysisOnTimeout, &quot;infinite EA connection graph build (%f sec, %d iterations) with %d nodes and worklist size %d&quot;,
1267            time.seconds(), iterations, nodes_size(), ptnodes_worklist.length());
1268     // Possible infinite build_connection_graph loop,
1269     // bailout (no changes to ideal graph were made).
1270     return false;
1271   }
1272 #ifdef ASSERT
1273   if (Verbose &amp;&amp; PrintEscapeAnalysis) {
1274     tty-&gt;print_cr(&quot;EA: %d iterations to build connection graph with %d nodes and worklist size %d&quot;,
1275                   iterations, nodes_size(), ptnodes_worklist.length());
1276   }
1277 #endif
1278 
1279 #undef CG_BUILD_ITER_LIMIT
1280 
1281   // Find fields initialized by NULL for non-escaping Allocations.
1282   int non_escaped_length = non_escaped_worklist.length();
1283   for (int next = 0; next &lt; non_escaped_length; next++) {
1284     JavaObjectNode* ptn = non_escaped_worklist.at(next);
1285     PointsToNode::EscapeState es = ptn-&gt;escape_state();
1286     assert(es &lt;= PointsToNode::ArgEscape, &quot;sanity&quot;);
1287     if (es == PointsToNode::NoEscape) {
1288       if (find_init_values(ptn, null_obj, _igvn) &gt; 0) {
1289         // Adding references to NULL object does not change escape states
1290         // since it does not escape. Also no fields are added to NULL object.
1291         add_java_object_edges(null_obj, false);
1292       }
1293     }
1294     Node* n = ptn-&gt;ideal_node();
1295     if (n-&gt;is_Allocate()) {
1296       // The object allocated by this Allocate node will never be
1297       // seen by an other thread. Mark it so that when it is
1298       // expanded no MemBarStoreStore is added.
1299       InitializeNode* ini = n-&gt;as_Allocate()-&gt;initialization();
1300       if (ini != NULL)
1301         ini-&gt;set_does_not_escape();
1302     }
1303   }
1304   return true; // Finished graph construction.
1305 }
1306 
1307 // Propagate GlobalEscape and ArgEscape escape states to all nodes
1308 // and check that we still have non-escaping java objects.
1309 bool ConnectionGraph::find_non_escaped_objects(GrowableArray&lt;PointsToNode*&gt;&amp; ptnodes_worklist,
1310                                                GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist) {
1311   GrowableArray&lt;PointsToNode*&gt; escape_worklist;
1312   // First, put all nodes with GlobalEscape and ArgEscape states on worklist.
1313   int ptnodes_length = ptnodes_worklist.length();
1314   for (int next = 0; next &lt; ptnodes_length; ++next) {
1315     PointsToNode* ptn = ptnodes_worklist.at(next);
1316     if (ptn-&gt;escape_state() &gt;= PointsToNode::ArgEscape ||
1317         ptn-&gt;fields_escape_state() &gt;= PointsToNode::ArgEscape) {
1318       escape_worklist.push(ptn);
1319     }
1320   }
1321   // Set escape states to referenced nodes (edges list).
1322   while (escape_worklist.length() &gt; 0) {
1323     PointsToNode* ptn = escape_worklist.pop();
1324     PointsToNode::EscapeState es  = ptn-&gt;escape_state();
1325     PointsToNode::EscapeState field_es = ptn-&gt;fields_escape_state();
1326     if (ptn-&gt;is_Field() &amp;&amp; ptn-&gt;as_Field()-&gt;is_oop() &amp;&amp;
1327         es &gt;= PointsToNode::ArgEscape) {
1328       // GlobalEscape or ArgEscape state of field means it has unknown value.
1329       if (add_edge(ptn, phantom_obj)) {
1330         // New edge was added
1331         add_field_uses_to_worklist(ptn-&gt;as_Field());
1332       }
1333     }
1334     for (EdgeIterator i(ptn); i.has_next(); i.next()) {
1335       PointsToNode* e = i.get();
1336       if (e-&gt;is_Arraycopy()) {
1337         assert(ptn-&gt;arraycopy_dst(), &quot;sanity&quot;);
1338         // Propagate only fields escape state through arraycopy edge.
1339         if (e-&gt;fields_escape_state() &lt; field_es) {
1340           set_fields_escape_state(e, field_es);
1341           escape_worklist.push(e);
1342         }
1343       } else if (es &gt;= field_es) {
1344         // fields_escape_state is also set to &#39;es&#39; if it is less than &#39;es&#39;.
1345         if (e-&gt;escape_state() &lt; es) {
1346           set_escape_state(e, es);
1347           escape_worklist.push(e);
1348         }
1349       } else {
1350         // Propagate field escape state.
1351         bool es_changed = false;
1352         if (e-&gt;fields_escape_state() &lt; field_es) {
1353           set_fields_escape_state(e, field_es);
1354           es_changed = true;
1355         }
1356         if ((e-&gt;escape_state() &lt; field_es) &amp;&amp;
1357             e-&gt;is_Field() &amp;&amp; ptn-&gt;is_JavaObject() &amp;&amp;
1358             e-&gt;as_Field()-&gt;is_oop()) {
1359           // Change escape state of referenced fields.
1360           set_escape_state(e, field_es);
1361           es_changed = true;
1362         } else if (e-&gt;escape_state() &lt; es) {
1363           set_escape_state(e, es);
1364           es_changed = true;
1365         }
1366         if (es_changed) {
1367           escape_worklist.push(e);
1368         }
1369       }
1370     }
1371   }
1372   // Remove escaped objects from non_escaped list.
1373   for (int next = non_escaped_worklist.length()-1; next &gt;= 0 ; --next) {
1374     JavaObjectNode* ptn = non_escaped_worklist.at(next);
1375     if (ptn-&gt;escape_state() &gt;= PointsToNode::GlobalEscape) {
1376       non_escaped_worklist.delete_at(next);
1377     }
1378     if (ptn-&gt;escape_state() == PointsToNode::NoEscape) {
1379       // Find fields in non-escaped allocations which have unknown value.
1380       find_init_values(ptn, phantom_obj, NULL);
1381     }
1382   }
1383   return (non_escaped_worklist.length() &gt; 0);
1384 }
1385 
1386 // Add all references to JavaObject node by walking over all uses.
1387 int ConnectionGraph::add_java_object_edges(JavaObjectNode* jobj, bool populate_worklist) {
1388   int new_edges = 0;
1389   if (populate_worklist) {
1390     // Populate _worklist by uses of jobj&#39;s uses.
1391     for (UseIterator i(jobj); i.has_next(); i.next()) {
1392       PointsToNode* use = i.get();
1393       if (use-&gt;is_Arraycopy())
1394         continue;
1395       add_uses_to_worklist(use);
1396       if (use-&gt;is_Field() &amp;&amp; use-&gt;as_Field()-&gt;is_oop()) {
1397         // Put on worklist all field&#39;s uses (loads) and
1398         // related field nodes (same base and offset).
1399         add_field_uses_to_worklist(use-&gt;as_Field());
1400       }
1401     }
1402   }
1403   for (int l = 0; l &lt; _worklist.length(); l++) {
1404     PointsToNode* use = _worklist.at(l);
1405     if (PointsToNode::is_base_use(use)) {
1406       // Add reference from jobj to field and from field to jobj (field&#39;s base).
1407       use = PointsToNode::get_use_node(use)-&gt;as_Field();
1408       if (add_base(use-&gt;as_Field(), jobj)) {
1409         new_edges++;
1410       }
1411       continue;
1412     }
1413     assert(!use-&gt;is_JavaObject(), &quot;sanity&quot;);
1414     if (use-&gt;is_Arraycopy()) {
1415       if (jobj == null_obj) // NULL object does not have field edges
1416         continue;
1417       // Added edge from Arraycopy node to arraycopy&#39;s source java object
1418       if (add_edge(use, jobj)) {
1419         jobj-&gt;set_arraycopy_src();
1420         new_edges++;
1421       }
1422       // and stop here.
1423       continue;
1424     }
1425     if (!add_edge(use, jobj))
1426       continue; // No new edge added, there was such edge already.
1427     new_edges++;
1428     if (use-&gt;is_LocalVar()) {
1429       add_uses_to_worklist(use);
1430       if (use-&gt;arraycopy_dst()) {
1431         for (EdgeIterator i(use); i.has_next(); i.next()) {
1432           PointsToNode* e = i.get();
1433           if (e-&gt;is_Arraycopy()) {
1434             if (jobj == null_obj) // NULL object does not have field edges
1435               continue;
1436             // Add edge from arraycopy&#39;s destination java object to Arraycopy node.
1437             if (add_edge(jobj, e)) {
1438               new_edges++;
1439               jobj-&gt;set_arraycopy_dst();
1440             }
1441           }
1442         }
1443       }
1444     } else {
1445       // Added new edge to stored in field values.
1446       // Put on worklist all field&#39;s uses (loads) and
1447       // related field nodes (same base and offset).
1448       add_field_uses_to_worklist(use-&gt;as_Field());
1449     }
1450   }
1451   _worklist.clear();
1452   _in_worklist.reset();
1453   return new_edges;
1454 }
1455 
1456 // Put on worklist all related field nodes.
1457 void ConnectionGraph::add_field_uses_to_worklist(FieldNode* field) {
1458   assert(field-&gt;is_oop(), &quot;sanity&quot;);
1459   int offset = field-&gt;offset();
1460   add_uses_to_worklist(field);
1461   // Loop over all bases of this field and push on worklist Field nodes
1462   // with the same offset and base (since they may reference the same field).
1463   for (BaseIterator i(field); i.has_next(); i.next()) {
1464     PointsToNode* base = i.get();
1465     add_fields_to_worklist(field, base);
1466     // Check if the base was source object of arraycopy and go over arraycopy&#39;s
1467     // destination objects since values stored to a field of source object are
1468     // accessable by uses (loads) of fields of destination objects.
1469     if (base-&gt;arraycopy_src()) {
1470       for (UseIterator j(base); j.has_next(); j.next()) {
1471         PointsToNode* arycp = j.get();
1472         if (arycp-&gt;is_Arraycopy()) {
1473           for (UseIterator k(arycp); k.has_next(); k.next()) {
1474             PointsToNode* abase = k.get();
1475             if (abase-&gt;arraycopy_dst() &amp;&amp; abase != base) {
1476               // Look for the same arraycopy reference.
1477               add_fields_to_worklist(field, abase);
1478             }
1479           }
1480         }
1481       }
1482     }
1483   }
1484 }
1485 
1486 // Put on worklist all related field nodes.
1487 void ConnectionGraph::add_fields_to_worklist(FieldNode* field, PointsToNode* base) {
1488   int offset = field-&gt;offset();
1489   if (base-&gt;is_LocalVar()) {
1490     for (UseIterator j(base); j.has_next(); j.next()) {
1491       PointsToNode* f = j.get();
1492       if (PointsToNode::is_base_use(f)) { // Field
1493         f = PointsToNode::get_use_node(f);
1494         if (f == field || !f-&gt;as_Field()-&gt;is_oop())
1495           continue;
1496         int offs = f-&gt;as_Field()-&gt;offset();
1497         if (offs == offset || offset == Type::OffsetBot || offs == Type::OffsetBot) {
1498           add_to_worklist(f);
1499         }
1500       }
1501     }
1502   } else {
1503     assert(base-&gt;is_JavaObject(), &quot;sanity&quot;);
1504     if (// Skip phantom_object since it is only used to indicate that
1505         // this field&#39;s content globally escapes.
1506         (base != phantom_obj) &amp;&amp;
1507         // NULL object node does not have fields.
1508         (base != null_obj)) {
1509       for (EdgeIterator i(base); i.has_next(); i.next()) {
1510         PointsToNode* f = i.get();
1511         // Skip arraycopy edge since store to destination object field
1512         // does not update value in source object field.
1513         if (f-&gt;is_Arraycopy()) {
1514           assert(base-&gt;arraycopy_dst(), &quot;sanity&quot;);
1515           continue;
1516         }
1517         if (f == field || !f-&gt;as_Field()-&gt;is_oop())
1518           continue;
1519         int offs = f-&gt;as_Field()-&gt;offset();
1520         if (offs == offset || offset == Type::OffsetBot || offs == Type::OffsetBot) {
1521           add_to_worklist(f);
1522         }
1523       }
1524     }
1525   }
1526 }
1527 
1528 // Find fields which have unknown value.
1529 int ConnectionGraph::find_field_value(FieldNode* field) {
1530   // Escaped fields should have init value already.
1531   assert(field-&gt;escape_state() == PointsToNode::NoEscape, &quot;sanity&quot;);
1532   int new_edges = 0;
1533   for (BaseIterator i(field); i.has_next(); i.next()) {
1534     PointsToNode* base = i.get();
1535     if (base-&gt;is_JavaObject()) {
1536       // Skip Allocate&#39;s fields which will be processed later.
1537       if (base-&gt;ideal_node()-&gt;is_Allocate())
1538         return 0;
1539       assert(base == null_obj, &quot;only NULL ptr base expected here&quot;);
1540     }
1541   }
1542   if (add_edge(field, phantom_obj)) {
1543     // New edge was added
1544     new_edges++;
1545     add_field_uses_to_worklist(field);
1546   }
1547   return new_edges;
1548 }
1549 
1550 // Find fields initializing values for allocations.
1551 int ConnectionGraph::find_init_values(JavaObjectNode* pta, PointsToNode* init_val, PhaseTransform* phase) {
1552   assert(pta-&gt;escape_state() == PointsToNode::NoEscape, &quot;Not escaped Allocate nodes only&quot;);
1553   int new_edges = 0;
1554   Node* alloc = pta-&gt;ideal_node();
1555   if (init_val == phantom_obj) {
1556     // Do nothing for Allocate nodes since its fields values are
1557     // &quot;known&quot; unless they are initialized by arraycopy/clone.
1558     if (alloc-&gt;is_Allocate() &amp;&amp; !pta-&gt;arraycopy_dst())
1559       return 0;
1560     assert(pta-&gt;arraycopy_dst() || alloc-&gt;as_CallStaticJava(), &quot;sanity&quot;);
1561 #ifdef ASSERT
1562     if (!pta-&gt;arraycopy_dst() &amp;&amp; alloc-&gt;as_CallStaticJava()-&gt;method() == NULL) {
1563       const char* name = alloc-&gt;as_CallStaticJava()-&gt;_name;
1564       assert(strncmp(name, &quot;_multianewarray&quot;, 15) == 0, &quot;sanity&quot;);
1565     }
1566 #endif
1567     // Non-escaped allocation returned from Java or runtime call have
1568     // unknown values in fields.
1569     for (EdgeIterator i(pta); i.has_next(); i.next()) {
1570       PointsToNode* field = i.get();
1571       if (field-&gt;is_Field() &amp;&amp; field-&gt;as_Field()-&gt;is_oop()) {
1572         if (add_edge(field, phantom_obj)) {
1573           // New edge was added
1574           new_edges++;
1575           add_field_uses_to_worklist(field-&gt;as_Field());
1576         }
1577       }
1578     }
1579     return new_edges;
1580   }
1581   assert(init_val == null_obj, &quot;sanity&quot;);
1582   // Do nothing for Call nodes since its fields values are unknown.
1583   if (!alloc-&gt;is_Allocate())
1584     return 0;
1585 
1586   InitializeNode* ini = alloc-&gt;as_Allocate()-&gt;initialization();
1587   bool visited_bottom_offset = false;
1588   GrowableArray&lt;int&gt; offsets_worklist;
1589 
1590   // Check if an oop field&#39;s initializing value is recorded and add
1591   // a corresponding NULL if field&#39;s value if it is not recorded.
1592   // Connection Graph does not record a default initialization by NULL
1593   // captured by Initialize node.
1594   //
1595   for (EdgeIterator i(pta); i.has_next(); i.next()) {
1596     PointsToNode* field = i.get(); // Field (AddP)
1597     if (!field-&gt;is_Field() || !field-&gt;as_Field()-&gt;is_oop())
1598       continue; // Not oop field
1599     int offset = field-&gt;as_Field()-&gt;offset();
1600     if (offset == Type::OffsetBot) {
1601       if (!visited_bottom_offset) {
1602         // OffsetBot is used to reference array&#39;s element,
1603         // always add reference to NULL to all Field nodes since we don&#39;t
1604         // known which element is referenced.
1605         if (add_edge(field, null_obj)) {
1606           // New edge was added
1607           new_edges++;
1608           add_field_uses_to_worklist(field-&gt;as_Field());
1609           visited_bottom_offset = true;
1610         }
1611       }
1612     } else {
1613       // Check only oop fields.
1614       const Type* adr_type = field-&gt;ideal_node()-&gt;as_AddP()-&gt;bottom_type();
1615       if (adr_type-&gt;isa_rawptr()) {
1616 #ifdef ASSERT
1617         // Raw pointers are used for initializing stores so skip it
1618         // since it should be recorded already
1619         Node* base = get_addp_base(field-&gt;ideal_node());
1620         assert(adr_type-&gt;isa_rawptr() &amp;&amp; base-&gt;is_Proj() &amp;&amp;
1621                (base-&gt;in(0) == alloc),&quot;unexpected pointer type&quot;);
1622 #endif
1623         continue;
1624       }
1625       if (!offsets_worklist.contains(offset)) {
1626         offsets_worklist.append(offset);
1627         Node* value = NULL;
1628         if (ini != NULL) {
1629           // StoreP::memory_type() == T_ADDRESS
1630           BasicType ft = UseCompressedOops ? T_NARROWOOP : T_ADDRESS;
1631           Node* store = ini-&gt;find_captured_store(offset, type2aelembytes(ft, true), phase);
1632           // Make sure initializing store has the same type as this AddP.
1633           // This AddP may reference non existing field because it is on a
1634           // dead branch of bimorphic call which is not eliminated yet.
1635           if (store != NULL &amp;&amp; store-&gt;is_Store() &amp;&amp;
1636               store-&gt;as_Store()-&gt;memory_type() == ft) {
1637             value = store-&gt;in(MemNode::ValueIn);
1638 #ifdef ASSERT
1639             if (VerifyConnectionGraph) {
1640               // Verify that AddP already points to all objects the value points to.
1641               PointsToNode* val = ptnode_adr(value-&gt;_idx);
1642               assert((val != NULL), &quot;should be processed already&quot;);
1643               PointsToNode* missed_obj = NULL;
1644               if (val-&gt;is_JavaObject()) {
1645                 if (!field-&gt;points_to(val-&gt;as_JavaObject())) {
1646                   missed_obj = val;
1647                 }
1648               } else {
1649                 if (!val-&gt;is_LocalVar() || (val-&gt;edge_count() == 0)) {
1650                   tty-&gt;print_cr(&quot;----------init store has invalid value -----&quot;);
1651                   store-&gt;dump();
1652                   val-&gt;dump();
1653                   assert(val-&gt;is_LocalVar() &amp;&amp; (val-&gt;edge_count() &gt; 0), &quot;should be processed already&quot;);
1654                 }
1655                 for (EdgeIterator j(val); j.has_next(); j.next()) {
1656                   PointsToNode* obj = j.get();
1657                   if (obj-&gt;is_JavaObject()) {
1658                     if (!field-&gt;points_to(obj-&gt;as_JavaObject())) {
1659                       missed_obj = obj;
1660                       break;
1661                     }
1662                   }
1663                 }
1664               }
1665               if (missed_obj != NULL) {
1666                 tty-&gt;print_cr(&quot;----------field---------------------------------&quot;);
1667                 field-&gt;dump();
1668                 tty-&gt;print_cr(&quot;----------missed reference to object------------&quot;);
1669                 missed_obj-&gt;dump();
1670                 tty-&gt;print_cr(&quot;----------object referenced by init store-------&quot;);
1671                 store-&gt;dump();
1672                 val-&gt;dump();
1673                 assert(!field-&gt;points_to(missed_obj-&gt;as_JavaObject()), &quot;missed JavaObject reference&quot;);
1674               }
1675             }
1676 #endif
1677           } else {
1678             // There could be initializing stores which follow allocation.
1679             // For example, a volatile field store is not collected
1680             // by Initialize node.
1681             //
1682             // Need to check for dependent loads to separate such stores from
1683             // stores which follow loads. For now, add initial value NULL so
1684             // that compare pointers optimization works correctly.
1685           }
1686         }
1687         if (value == NULL) {
1688           // A field&#39;s initializing value was not recorded. Add NULL.
1689           if (add_edge(field, null_obj)) {
1690             // New edge was added
1691             new_edges++;
1692             add_field_uses_to_worklist(field-&gt;as_Field());
1693           }
1694         }
1695       }
1696     }
1697   }
1698   return new_edges;
1699 }
1700 
1701 // Adjust scalar_replaceable state after Connection Graph is built.
1702 void ConnectionGraph::adjust_scalar_replaceable_state(JavaObjectNode* jobj) {
1703   // Search for non-escaping objects which are not scalar replaceable
1704   // and mark them to propagate the state to referenced objects.
1705 
1706   // 1. An object is not scalar replaceable if the field into which it is
1707   // stored has unknown offset (stored into unknown element of an array).
1708   //
1709   for (UseIterator i(jobj); i.has_next(); i.next()) {
1710     PointsToNode* use = i.get();
1711     if (use-&gt;is_Arraycopy()) {
1712       continue;
1713     }
1714     if (use-&gt;is_Field()) {
1715       FieldNode* field = use-&gt;as_Field();
1716       assert(field-&gt;is_oop() &amp;&amp; field-&gt;scalar_replaceable(), &quot;sanity&quot;);
1717       if (field-&gt;offset() == Type::OffsetBot) {
1718         jobj-&gt;set_scalar_replaceable(false);
1719         return;
1720       }
1721       // 2. An object is not scalar replaceable if the field into which it is
1722       // stored has multiple bases one of which is null.
1723       if (field-&gt;base_count() &gt; 1) {
1724         for (BaseIterator i(field); i.has_next(); i.next()) {
1725           PointsToNode* base = i.get();
1726           if (base == null_obj) {
1727             jobj-&gt;set_scalar_replaceable(false);
1728             return;
1729           }
1730         }
1731       }
1732     }
1733     assert(use-&gt;is_Field() || use-&gt;is_LocalVar(), &quot;sanity&quot;);
1734     // 3. An object is not scalar replaceable if it is merged with other objects.
1735     for (EdgeIterator j(use); j.has_next(); j.next()) {
1736       PointsToNode* ptn = j.get();
1737       if (ptn-&gt;is_JavaObject() &amp;&amp; ptn != jobj) {
1738         // Mark all objects.
1739         jobj-&gt;set_scalar_replaceable(false);
1740         ptn-&gt;set_scalar_replaceable(false);
1741       }
1742     }
1743     if (!jobj-&gt;scalar_replaceable()) {
1744       return;
1745     }
1746   }
1747 
1748   for (EdgeIterator j(jobj); j.has_next(); j.next()) {
1749     if (j.get()-&gt;is_Arraycopy()) {
1750       continue;
1751     }
1752 
1753     // Non-escaping object node should point only to field nodes.
1754     FieldNode* field = j.get()-&gt;as_Field();
1755     int offset = field-&gt;as_Field()-&gt;offset();
1756 
1757     // 4. An object is not scalar replaceable if it has a field with unknown
1758     // offset (array&#39;s element is accessed in loop).
1759     if (offset == Type::OffsetBot) {
1760       jobj-&gt;set_scalar_replaceable(false);
1761       return;
1762     }
1763     // 5. Currently an object is not scalar replaceable if a LoadStore node
1764     // access its field since the field value is unknown after it.
1765     //
1766     Node* n = field-&gt;ideal_node();
1767 
1768     // Test for an unsafe access that was parsed as maybe off heap
1769     // (with a CheckCastPP to raw memory).
1770     assert(n-&gt;is_AddP(), &quot;expect an address computation&quot;);
1771     if (n-&gt;in(AddPNode::Base)-&gt;is_top() &amp;&amp;
1772         n-&gt;in(AddPNode::Address)-&gt;Opcode() == Op_CheckCastPP) {
1773       assert(n-&gt;in(AddPNode::Address)-&gt;bottom_type()-&gt;isa_rawptr(), &quot;raw address so raw cast expected&quot;);
1774       assert(_igvn-&gt;type(n-&gt;in(AddPNode::Address)-&gt;in(1))-&gt;isa_oopptr(), &quot;cast pattern at unsafe access expected&quot;);
1775       jobj-&gt;set_scalar_replaceable(false);
1776       return;
1777     }
1778 
1779     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1780       Node* u = n-&gt;fast_out(i);
1781       if (u-&gt;is_LoadStore() || (u-&gt;is_Mem() &amp;&amp; u-&gt;as_Mem()-&gt;is_mismatched_access())) {
1782         jobj-&gt;set_scalar_replaceable(false);
1783         return;
1784       }
1785     }
1786 
1787     // 6. Or the address may point to more then one object. This may produce
1788     // the false positive result (set not scalar replaceable)
1789     // since the flow-insensitive escape analysis can&#39;t separate
1790     // the case when stores overwrite the field&#39;s value from the case
1791     // when stores happened on different control branches.
1792     //
1793     // Note: it will disable scalar replacement in some cases:
1794     //
1795     //    Point p[] = new Point[1];
1796     //    p[0] = new Point(); // Will be not scalar replaced
1797     //
1798     // but it will save us from incorrect optimizations in next cases:
1799     //
1800     //    Point p[] = new Point[1];
1801     //    if ( x ) p[0] = new Point(); // Will be not scalar replaced
1802     //
1803     if (field-&gt;base_count() &gt; 1) {
1804       for (BaseIterator i(field); i.has_next(); i.next()) {
1805         PointsToNode* base = i.get();
1806         // Don&#39;t take into account LocalVar nodes which
1807         // may point to only one object which should be also
1808         // this field&#39;s base by now.
1809         if (base-&gt;is_JavaObject() &amp;&amp; base != jobj) {
1810           // Mark all bases.
1811           jobj-&gt;set_scalar_replaceable(false);
1812           base-&gt;set_scalar_replaceable(false);
1813         }
1814       }
1815     }
1816   }
1817 }
1818 
1819 #ifdef ASSERT
1820 void ConnectionGraph::verify_connection_graph(
1821                          GrowableArray&lt;PointsToNode*&gt;&amp;   ptnodes_worklist,
1822                          GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist,
1823                          GrowableArray&lt;JavaObjectNode*&gt;&amp; java_objects_worklist,
1824                          GrowableArray&lt;Node*&gt;&amp; addp_worklist) {
1825   // Verify that graph is complete - no new edges could be added.
1826   int java_objects_length = java_objects_worklist.length();
1827   int non_escaped_length  = non_escaped_worklist.length();
1828   int new_edges = 0;
1829   for (int next = 0; next &lt; java_objects_length; ++next) {
1830     JavaObjectNode* ptn = java_objects_worklist.at(next);
1831     new_edges += add_java_object_edges(ptn, true);
1832   }
1833   assert(new_edges == 0, &quot;graph was not complete&quot;);
1834   // Verify that escape state is final.
1835   int length = non_escaped_worklist.length();
1836   find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist);
1837   assert((non_escaped_length == non_escaped_worklist.length()) &amp;&amp;
1838          (non_escaped_length == length) &amp;&amp;
1839          (_worklist.length() == 0), &quot;escape state was not final&quot;);
1840 
1841   // Verify fields information.
1842   int addp_length = addp_worklist.length();
1843   for (int next = 0; next &lt; addp_length; ++next ) {
1844     Node* n = addp_worklist.at(next);
1845     FieldNode* field = ptnode_adr(n-&gt;_idx)-&gt;as_Field();
1846     if (field-&gt;is_oop()) {
1847       // Verify that field has all bases
1848       Node* base = get_addp_base(n);
1849       PointsToNode* ptn = ptnode_adr(base-&gt;_idx);
1850       if (ptn-&gt;is_JavaObject()) {
1851         assert(field-&gt;has_base(ptn-&gt;as_JavaObject()), &quot;sanity&quot;);
1852       } else {
1853         assert(ptn-&gt;is_LocalVar(), &quot;sanity&quot;);
1854         for (EdgeIterator i(ptn); i.has_next(); i.next()) {
1855           PointsToNode* e = i.get();
1856           if (e-&gt;is_JavaObject()) {
1857             assert(field-&gt;has_base(e-&gt;as_JavaObject()), &quot;sanity&quot;);
1858           }
1859         }
1860       }
1861       // Verify that all fields have initializing values.
1862       if (field-&gt;edge_count() == 0) {
1863         tty-&gt;print_cr(&quot;----------field does not have references----------&quot;);
1864         field-&gt;dump();
1865         for (BaseIterator i(field); i.has_next(); i.next()) {
1866           PointsToNode* base = i.get();
1867           tty-&gt;print_cr(&quot;----------field has next base---------------------&quot;);
1868           base-&gt;dump();
1869           if (base-&gt;is_JavaObject() &amp;&amp; (base != phantom_obj) &amp;&amp; (base != null_obj)) {
1870             tty-&gt;print_cr(&quot;----------base has fields-------------------------&quot;);
1871             for (EdgeIterator j(base); j.has_next(); j.next()) {
1872               j.get()-&gt;dump();
1873             }
1874             tty-&gt;print_cr(&quot;----------base has references---------------------&quot;);
1875             for (UseIterator j(base); j.has_next(); j.next()) {
1876               j.get()-&gt;dump();
1877             }
1878           }
1879         }
1880         for (UseIterator i(field); i.has_next(); i.next()) {
1881           i.get()-&gt;dump();
1882         }
1883         assert(field-&gt;edge_count() &gt; 0, &quot;sanity&quot;);
1884       }
1885     }
1886   }
1887 }
1888 #endif
1889 
1890 // Optimize ideal graph.
1891 void ConnectionGraph::optimize_ideal_graph(GrowableArray&lt;Node*&gt;&amp; ptr_cmp_worklist,
1892                                            GrowableArray&lt;Node*&gt;&amp; storestore_worklist) {
1893   Compile* C = _compile;
1894   PhaseIterGVN* igvn = _igvn;
1895   if (EliminateLocks) {
1896     // Mark locks before changing ideal graph.
1897     int cnt = C-&gt;macro_count();
1898     for( int i=0; i &lt; cnt; i++ ) {
1899       Node *n = C-&gt;macro_node(i);
1900       if (n-&gt;is_AbstractLock()) { // Lock and Unlock nodes
1901         AbstractLockNode* alock = n-&gt;as_AbstractLock();
1902         if (!alock-&gt;is_non_esc_obj()) {
1903           const Type* obj_type = igvn-&gt;type(alock-&gt;obj_node());
1904           if (not_global_escape(alock-&gt;obj_node()) &amp;&amp;
1905               !obj_type-&gt;isa_inlinetype() &amp;&amp; !obj_type-&gt;is_inlinetypeptr()) {
1906             assert(!alock-&gt;is_eliminated() || alock-&gt;is_coarsened(), &quot;sanity&quot;);
1907             // The lock could be marked eliminated by lock coarsening
1908             // code during first IGVN before EA. Replace coarsened flag
1909             // to eliminate all associated locks/unlocks.
1910 #ifdef ASSERT
1911             alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc3&quot;);
1912 #endif
1913             alock-&gt;set_non_esc_obj();
1914           }
1915         }
1916       }
1917     }
1918   }
1919 
1920   if (OptimizePtrCompare) {
1921     // Add ConI(#CC_GT) and ConI(#CC_EQ).
1922     _pcmp_neq = igvn-&gt;makecon(TypeInt::CC_GT);
1923     _pcmp_eq = igvn-&gt;makecon(TypeInt::CC_EQ);
1924     // Optimize objects compare.
1925     while (ptr_cmp_worklist.length() != 0) {
1926       Node *n = ptr_cmp_worklist.pop();
1927       Node *res = optimize_ptr_compare(n);
1928       if (res != NULL) {
1929 #ifndef PRODUCT
1930         if (PrintOptimizePtrCompare) {
1931           tty-&gt;print_cr(&quot;++++ Replaced: %d %s(%d,%d) --&gt; %s&quot;, n-&gt;_idx, (n-&gt;Opcode() == Op_CmpP ? &quot;CmpP&quot; : &quot;CmpN&quot;), n-&gt;in(1)-&gt;_idx, n-&gt;in(2)-&gt;_idx, (res == _pcmp_eq ? &quot;EQ&quot; : &quot;NotEQ&quot;));
1932           if (Verbose) {
1933             n-&gt;dump(1);
1934           }
1935         }
1936 #endif
1937         igvn-&gt;replace_node(n, res);
1938       }
1939     }
1940     // cleanup
1941     if (_pcmp_neq-&gt;outcnt() == 0)
1942       igvn-&gt;hash_delete(_pcmp_neq);
1943     if (_pcmp_eq-&gt;outcnt()  == 0)
1944       igvn-&gt;hash_delete(_pcmp_eq);
1945   }
1946 
1947   // For MemBarStoreStore nodes added in library_call.cpp, check
1948   // escape status of associated AllocateNode and optimize out
1949   // MemBarStoreStore node if the allocated object never escapes.
1950   while (storestore_worklist.length() != 0) {
1951     Node *n = storestore_worklist.pop();
1952     MemBarStoreStoreNode *storestore = n -&gt;as_MemBarStoreStore();
1953     Node *alloc = storestore-&gt;in(MemBarNode::Precedent)-&gt;in(0);
1954     assert (alloc-&gt;is_Allocate(), &quot;storestore should point to AllocateNode&quot;);
1955     if (not_global_escape(alloc)) {
1956       MemBarNode* mb = MemBarNode::make(C, Op_MemBarCPUOrder, Compile::AliasIdxBot);
1957       mb-&gt;init_req(TypeFunc::Memory, storestore-&gt;in(TypeFunc::Memory));
1958       mb-&gt;init_req(TypeFunc::Control, storestore-&gt;in(TypeFunc::Control));
1959       igvn-&gt;register_new_node_with_optimizer(mb);
1960       igvn-&gt;replace_node(storestore, mb);
1961     }
1962   }
1963 }
1964 
1965 // Optimize objects compare.
1966 Node* ConnectionGraph::optimize_ptr_compare(Node* n) {
1967   assert(OptimizePtrCompare, &quot;sanity&quot;);
1968   PointsToNode* ptn1 = ptnode_adr(n-&gt;in(1)-&gt;_idx);
1969   PointsToNode* ptn2 = ptnode_adr(n-&gt;in(2)-&gt;_idx);
1970   JavaObjectNode* jobj1 = unique_java_object(n-&gt;in(1));
1971   JavaObjectNode* jobj2 = unique_java_object(n-&gt;in(2));
1972   assert(ptn1-&gt;is_JavaObject() || ptn1-&gt;is_LocalVar(), &quot;sanity&quot;);
1973   assert(ptn2-&gt;is_JavaObject() || ptn2-&gt;is_LocalVar(), &quot;sanity&quot;);
1974 
1975   // Check simple cases first.
1976   if (jobj1 != NULL) {
1977     if (jobj1-&gt;escape_state() == PointsToNode::NoEscape) {
1978       if (jobj1 == jobj2) {
1979         // Comparing the same not escaping object.
1980         return _pcmp_eq;
1981       }
1982       Node* obj = jobj1-&gt;ideal_node();
1983       // Comparing not escaping allocation.
1984       if ((obj-&gt;is_Allocate() || obj-&gt;is_CallStaticJava()) &amp;&amp;
1985           !ptn2-&gt;points_to(jobj1)) {
1986         return _pcmp_neq; // This includes nullness check.
1987       }
1988     }
1989   }
1990   if (jobj2 != NULL) {
1991     if (jobj2-&gt;escape_state() == PointsToNode::NoEscape) {
1992       Node* obj = jobj2-&gt;ideal_node();
1993       // Comparing not escaping allocation.
1994       if ((obj-&gt;is_Allocate() || obj-&gt;is_CallStaticJava()) &amp;&amp;
1995           !ptn1-&gt;points_to(jobj2)) {
1996         return _pcmp_neq; // This includes nullness check.
1997       }
1998     }
1999   }
2000   if (jobj1 != NULL &amp;&amp; jobj1 != phantom_obj &amp;&amp;
2001       jobj2 != NULL &amp;&amp; jobj2 != phantom_obj &amp;&amp;
2002       jobj1-&gt;ideal_node()-&gt;is_Con() &amp;&amp;
2003       jobj2-&gt;ideal_node()-&gt;is_Con()) {
2004     // Klass or String constants compare. Need to be careful with
2005     // compressed pointers - compare types of ConN and ConP instead of nodes.
2006     const Type* t1 = jobj1-&gt;ideal_node()-&gt;get_ptr_type();
2007     const Type* t2 = jobj2-&gt;ideal_node()-&gt;get_ptr_type();
2008     if (t1-&gt;make_ptr() == t2-&gt;make_ptr()) {
2009       return _pcmp_eq;
2010     } else {
2011       return _pcmp_neq;
2012     }
2013   }
2014   if (ptn1-&gt;meet(ptn2)) {
2015     return NULL; // Sets are not disjoint
2016   }
2017 
2018   // Sets are disjoint.
2019   bool set1_has_unknown_ptr = ptn1-&gt;points_to(phantom_obj);
2020   bool set2_has_unknown_ptr = ptn2-&gt;points_to(phantom_obj);
2021   bool set1_has_null_ptr    = ptn1-&gt;points_to(null_obj);
2022   bool set2_has_null_ptr    = ptn2-&gt;points_to(null_obj);
2023   if ((set1_has_unknown_ptr &amp;&amp; set2_has_null_ptr) ||
2024       (set2_has_unknown_ptr &amp;&amp; set1_has_null_ptr)) {
2025     // Check nullness of unknown object.
2026     return NULL;
2027   }
2028 
2029   // Disjointness by itself is not sufficient since
2030   // alias analysis is not complete for escaped objects.
2031   // Disjoint sets are definitely unrelated only when
2032   // at least one set has only not escaping allocations.
2033   if (!set1_has_unknown_ptr &amp;&amp; !set1_has_null_ptr) {
2034     if (ptn1-&gt;non_escaping_allocation()) {
2035       return _pcmp_neq;
2036     }
2037   }
2038   if (!set2_has_unknown_ptr &amp;&amp; !set2_has_null_ptr) {
2039     if (ptn2-&gt;non_escaping_allocation()) {
2040       return _pcmp_neq;
2041     }
2042   }
2043   return NULL;
2044 }
2045 
2046 // Connection Graph constuction functions.
2047 
2048 void ConnectionGraph::add_local_var(Node *n, PointsToNode::EscapeState es) {
2049   PointsToNode* ptadr = _nodes.at(n-&gt;_idx);
2050   if (ptadr != NULL) {
2051     assert(ptadr-&gt;is_LocalVar() &amp;&amp; ptadr-&gt;ideal_node() == n, &quot;sanity&quot;);
2052     return;
2053   }
2054   Compile* C = _compile;
2055   ptadr = new (C-&gt;comp_arena()) LocalVarNode(this, n, es);
2056   _nodes.at_put(n-&gt;_idx, ptadr);
2057 }
2058 
2059 void ConnectionGraph::add_java_object(Node *n, PointsToNode::EscapeState es) {
2060   PointsToNode* ptadr = _nodes.at(n-&gt;_idx);
2061   if (ptadr != NULL) {
2062     assert(ptadr-&gt;is_JavaObject() &amp;&amp; ptadr-&gt;ideal_node() == n, &quot;sanity&quot;);
2063     return;
2064   }
2065   Compile* C = _compile;
2066   ptadr = new (C-&gt;comp_arena()) JavaObjectNode(this, n, es);
2067   _nodes.at_put(n-&gt;_idx, ptadr);
2068 }
2069 
2070 void ConnectionGraph::add_field(Node *n, PointsToNode::EscapeState es, int offset) {
2071   PointsToNode* ptadr = _nodes.at(n-&gt;_idx);
2072   if (ptadr != NULL) {
2073     assert(ptadr-&gt;is_Field() &amp;&amp; ptadr-&gt;ideal_node() == n, &quot;sanity&quot;);
2074     return;
2075   }
2076   bool unsafe = false;
2077   bool is_oop = is_oop_field(n, offset, &amp;unsafe);
2078   if (unsafe) {
2079     es = PointsToNode::GlobalEscape;
2080   }
2081   Compile* C = _compile;
2082   FieldNode* field = new (C-&gt;comp_arena()) FieldNode(this, n, es, offset, is_oop);
2083   _nodes.at_put(n-&gt;_idx, field);
2084 }
2085 
2086 void ConnectionGraph::add_arraycopy(Node *n, PointsToNode::EscapeState es,
2087                                     PointsToNode* src, PointsToNode* dst) {
2088   assert(!src-&gt;is_Field() &amp;&amp; !dst-&gt;is_Field(), &quot;only for JavaObject and LocalVar&quot;);
2089   assert((src != null_obj) &amp;&amp; (dst != null_obj), &quot;not for ConP NULL&quot;);
2090   PointsToNode* ptadr = _nodes.at(n-&gt;_idx);
2091   if (ptadr != NULL) {
2092     assert(ptadr-&gt;is_Arraycopy() &amp;&amp; ptadr-&gt;ideal_node() == n, &quot;sanity&quot;);
2093     return;
2094   }
2095   Compile* C = _compile;
2096   ptadr = new (C-&gt;comp_arena()) ArraycopyNode(this, n, es);
2097   _nodes.at_put(n-&gt;_idx, ptadr);
2098   // Add edge from arraycopy node to source object.
2099   (void)add_edge(ptadr, src);
2100   src-&gt;set_arraycopy_src();
2101   // Add edge from destination object to arraycopy node.
2102   (void)add_edge(dst, ptadr);
2103   dst-&gt;set_arraycopy_dst();
2104 }
2105 
2106 bool ConnectionGraph::is_oop_field(Node* n, int offset, bool* unsafe) {
2107   const Type* adr_type = n-&gt;as_AddP()-&gt;bottom_type();
2108   int field_offset = adr_type-&gt;isa_aryptr() ? adr_type-&gt;isa_aryptr()-&gt;field_offset().get() : Type::OffsetBot;
2109   BasicType bt = T_INT;
2110   if (offset == Type::OffsetBot &amp;&amp; field_offset == Type::OffsetBot) {
2111     // Check only oop fields.
2112     if (!adr_type-&gt;isa_aryptr() ||
2113         (adr_type-&gt;isa_aryptr()-&gt;klass() == NULL) ||
2114          adr_type-&gt;isa_aryptr()-&gt;klass()-&gt;is_obj_array_klass()) {
2115       // OffsetBot is used to reference array&#39;s element. Ignore first AddP.
2116       if (find_second_addp(n, n-&gt;in(AddPNode::Base)) == NULL) {
2117         bt = T_OBJECT;
2118       }
2119     }
2120   } else if (offset != oopDesc::klass_offset_in_bytes()) {
2121     if (adr_type-&gt;isa_instptr()) {
2122       ciField* field = _compile-&gt;alias_type(adr_type-&gt;is_ptr())-&gt;field();
2123       if (field != NULL) {
2124         bt = field-&gt;layout_type();
2125       } else {
2126         // Check for unsafe oop field access
2127         if (n-&gt;has_out_with(Op_StoreP, Op_LoadP, Op_StoreN, Op_LoadN) ||
2128             n-&gt;has_out_with(Op_GetAndSetP, Op_GetAndSetN, Op_CompareAndExchangeP, Op_CompareAndExchangeN) ||
2129             n-&gt;has_out_with(Op_CompareAndSwapP, Op_CompareAndSwapN, Op_WeakCompareAndSwapP, Op_WeakCompareAndSwapN) ||
2130             BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_has_out_with_unsafe_object(n)) {
2131           bt = T_OBJECT;
2132           (*unsafe) = true;
2133         }
2134       }
2135     } else if (adr_type-&gt;isa_aryptr()) {
2136       if (offset == arrayOopDesc::length_offset_in_bytes()) {
2137         // Ignore array length load.
2138       } else if (find_second_addp(n, n-&gt;in(AddPNode::Base)) != NULL) {
2139         // Ignore first AddP.
2140       } else {
2141         const Type* elemtype = adr_type-&gt;isa_aryptr()-&gt;elem();
2142         if (elemtype-&gt;isa_inlinetype() &amp;&amp; field_offset != Type::OffsetBot) {
2143           ciInlineKlass* vk = elemtype-&gt;inline_klass();
2144           field_offset += vk-&gt;first_field_offset();
2145           bt = vk-&gt;get_field_by_offset(field_offset, false)-&gt;layout_type();
2146         } else {
2147           bt = elemtype-&gt;array_element_basic_type();
2148         }
2149       }
2150     } else if (adr_type-&gt;isa_rawptr() || adr_type-&gt;isa_klassptr()) {
2151       // Allocation initialization, ThreadLocal field access, unsafe access
2152       if (n-&gt;has_out_with(Op_StoreP, Op_LoadP, Op_StoreN, Op_LoadN) ||
2153           n-&gt;has_out_with(Op_GetAndSetP, Op_GetAndSetN, Op_CompareAndExchangeP, Op_CompareAndExchangeN) ||
2154           n-&gt;has_out_with(Op_CompareAndSwapP, Op_CompareAndSwapN, Op_WeakCompareAndSwapP, Op_WeakCompareAndSwapN) ||
2155           BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_has_out_with_unsafe_object(n)) {
2156         bt = T_OBJECT;
2157       }
2158     }
2159   }
2160   // Note: T_NARROWOOP is not classed as a real reference type
2161   return (is_reference_type(bt) || bt == T_NARROWOOP);
2162 }
2163 
2164 // Returns unique pointed java object or NULL.
2165 JavaObjectNode* ConnectionGraph::unique_java_object(Node *n) {
2166   assert(!_collecting, &quot;should not call when constructed graph&quot;);
2167   // If the node was created after the escape computation we can&#39;t answer.
2168   uint idx = n-&gt;_idx;
2169   if (idx &gt;= nodes_size()) {
2170     return NULL;
2171   }
2172   PointsToNode* ptn = ptnode_adr(idx);
2173   if (ptn == NULL) {
2174     return NULL;
2175   }
2176   if (ptn-&gt;is_JavaObject()) {
2177     return ptn-&gt;as_JavaObject();
2178   }
2179   assert(ptn-&gt;is_LocalVar(), &quot;sanity&quot;);
2180   // Check all java objects it points to.
2181   JavaObjectNode* jobj = NULL;
2182   for (EdgeIterator i(ptn); i.has_next(); i.next()) {
2183     PointsToNode* e = i.get();
2184     if (e-&gt;is_JavaObject()) {
2185       if (jobj == NULL) {
2186         jobj = e-&gt;as_JavaObject();
2187       } else if (jobj != e) {
2188         return NULL;
2189       }
2190     }
2191   }
2192   return jobj;
2193 }
2194 
2195 // Return true if this node points only to non-escaping allocations.
2196 bool PointsToNode::non_escaping_allocation() {
2197   if (is_JavaObject()) {
2198     Node* n = ideal_node();
2199     if (n-&gt;is_Allocate() || n-&gt;is_CallStaticJava()) {
2200       return (escape_state() == PointsToNode::NoEscape);
2201     } else {
2202       return false;
2203     }
2204   }
2205   assert(is_LocalVar(), &quot;sanity&quot;);
2206   // Check all java objects it points to.
2207   for (EdgeIterator i(this); i.has_next(); i.next()) {
2208     PointsToNode* e = i.get();
2209     if (e-&gt;is_JavaObject()) {
2210       Node* n = e-&gt;ideal_node();
2211       if ((e-&gt;escape_state() != PointsToNode::NoEscape) ||
2212           !(n-&gt;is_Allocate() || n-&gt;is_CallStaticJava())) {
2213         return false;
2214       }
2215     }
2216   }
2217   return true;
2218 }
2219 
2220 // Return true if we know the node does not escape globally.
2221 bool ConnectionGraph::not_global_escape(Node *n) {
2222   assert(!_collecting, &quot;should not call during graph construction&quot;);
2223   // If the node was created after the escape computation we can&#39;t answer.
2224   uint idx = n-&gt;_idx;
2225   if (idx &gt;= nodes_size()) {
2226     return false;
2227   }
2228   PointsToNode* ptn = ptnode_adr(idx);
2229   if (ptn == NULL) {
2230     return false; // not in congraph (e.g. ConI)
2231   }
2232   PointsToNode::EscapeState es = ptn-&gt;escape_state();
2233   // If we have already computed a value, return it.
2234   if (es &gt;= PointsToNode::GlobalEscape)
2235     return false;
2236   if (ptn-&gt;is_JavaObject()) {
2237     return true; // (es &lt; PointsToNode::GlobalEscape);
2238   }
2239   assert(ptn-&gt;is_LocalVar(), &quot;sanity&quot;);
2240   // Check all java objects it points to.
2241   for (EdgeIterator i(ptn); i.has_next(); i.next()) {
2242     if (i.get()-&gt;escape_state() &gt;= PointsToNode::GlobalEscape)
2243       return false;
2244   }
2245   return true;
2246 }
2247 
2248 
2249 // Helper functions
2250 
2251 // Return true if this node points to specified node or nodes it points to.
2252 bool PointsToNode::points_to(JavaObjectNode* ptn) const {
2253   if (is_JavaObject()) {
2254     return (this == ptn);
2255   }
2256   assert(is_LocalVar() || is_Field(), &quot;sanity&quot;);
2257   for (EdgeIterator i(this); i.has_next(); i.next()) {
2258     if (i.get() == ptn)
2259       return true;
2260   }
2261   return false;
2262 }
2263 
2264 // Return true if one node points to an other.
2265 bool PointsToNode::meet(PointsToNode* ptn) {
2266   if (this == ptn) {
2267     return true;
2268   } else if (ptn-&gt;is_JavaObject()) {
2269     return this-&gt;points_to(ptn-&gt;as_JavaObject());
2270   } else if (this-&gt;is_JavaObject()) {
2271     return ptn-&gt;points_to(this-&gt;as_JavaObject());
2272   }
2273   assert(this-&gt;is_LocalVar() &amp;&amp; ptn-&gt;is_LocalVar(), &quot;sanity&quot;);
2274   int ptn_count =  ptn-&gt;edge_count();
2275   for (EdgeIterator i(this); i.has_next(); i.next()) {
2276     PointsToNode* this_e = i.get();
2277     for (int j = 0; j &lt; ptn_count; j++) {
2278       if (this_e == ptn-&gt;edge(j))
2279         return true;
2280     }
2281   }
2282   return false;
2283 }
2284 
2285 #ifdef ASSERT
2286 // Return true if bases point to this java object.
2287 bool FieldNode::has_base(JavaObjectNode* jobj) const {
2288   for (BaseIterator i(this); i.has_next(); i.next()) {
2289     if (i.get() == jobj)
2290       return true;
2291   }
2292   return false;
2293 }
2294 #endif
2295 
2296 int ConnectionGraph::address_offset(Node* adr, PhaseTransform *phase) {
2297   const Type *adr_type = phase-&gt;type(adr);
2298   if (adr-&gt;is_AddP() &amp;&amp; adr_type-&gt;isa_oopptr() == NULL &amp;&amp;
2299       adr-&gt;in(AddPNode::Address)-&gt;is_Proj() &amp;&amp;
2300       adr-&gt;in(AddPNode::Address)-&gt;in(0)-&gt;is_Allocate()) {
2301     // We are computing a raw address for a store captured by an Initialize
2302     // compute an appropriate address type. AddP cases #3 and #5 (see below).
2303     int offs = (int)phase-&gt;find_intptr_t_con(adr-&gt;in(AddPNode::Offset), Type::OffsetBot);
2304     assert(offs != Type::OffsetBot ||
2305            adr-&gt;in(AddPNode::Address)-&gt;in(0)-&gt;is_AllocateArray(),
2306            &quot;offset must be a constant or it is initialization of array&quot;);
2307     return offs;
2308   }
2309   return adr_type-&gt;is_ptr()-&gt;flattened_offset();
2310 }
2311 
2312 Node* ConnectionGraph::get_addp_base(Node *addp) {
2313   assert(addp-&gt;is_AddP(), &quot;must be AddP&quot;);
2314   //
2315   // AddP cases for Base and Address inputs:
2316   // case #1. Direct object&#39;s field reference:
2317   //     Allocate
2318   //       |
2319   //     Proj #5 ( oop result )
2320   //       |
2321   //     CheckCastPP (cast to instance type)
2322   //      | |
2323   //     AddP  ( base == address )
2324   //
2325   // case #2. Indirect object&#39;s field reference:
2326   //      Phi
2327   //       |
2328   //     CastPP (cast to instance type)
2329   //      | |
2330   //     AddP  ( base == address )
2331   //
2332   // case #3. Raw object&#39;s field reference for Initialize node:
2333   //      Allocate
2334   //        |
2335   //      Proj #5 ( oop result )
2336   //  top   |
2337   //     \  |
2338   //     AddP  ( base == top )
2339   //
2340   // case #4. Array&#39;s element reference:
2341   //   {CheckCastPP | CastPP}
2342   //     |  | |
2343   //     |  AddP ( array&#39;s element offset )
2344   //     |  |
2345   //     AddP ( array&#39;s offset )
2346   //
2347   // case #5. Raw object&#39;s field reference for arraycopy stub call:
2348   //          The inline_native_clone() case when the arraycopy stub is called
2349   //          after the allocation before Initialize and CheckCastPP nodes.
2350   //      Allocate
2351   //        |
2352   //      Proj #5 ( oop result )
2353   //       | |
2354   //       AddP  ( base == address )
2355   //
2356   // case #6. Constant Pool, ThreadLocal, CastX2P or
2357   //          Raw object&#39;s field reference:
2358   //      {ConP, ThreadLocal, CastX2P, raw Load}
2359   //  top   |
2360   //     \  |
2361   //     AddP  ( base == top )
2362   //
2363   // case #7. Klass&#39;s field reference.
2364   //      LoadKlass
2365   //       | |
2366   //       AddP  ( base == address )
2367   //
2368   // case #8. narrow Klass&#39;s field reference.
2369   //      LoadNKlass
2370   //       |
2371   //      DecodeN
2372   //       | |
2373   //       AddP  ( base == address )
2374   //
2375   // case #9. Mixed unsafe access
2376   //    {instance}
2377   //        |
2378   //      CheckCastPP (raw)
2379   //  top   |
2380   //     \  |
2381   //     AddP  ( base == top )
2382   //
2383   Node *base = addp-&gt;in(AddPNode::Base);
2384   if (base-&gt;uncast()-&gt;is_top()) { // The AddP case #3 and #6 and #9.
2385     base = addp-&gt;in(AddPNode::Address);
2386     while (base-&gt;is_AddP()) {
2387       // Case #6 (unsafe access) may have several chained AddP nodes.
2388       assert(base-&gt;in(AddPNode::Base)-&gt;uncast()-&gt;is_top(), &quot;expected unsafe access address only&quot;);
2389       base = base-&gt;in(AddPNode::Address);
2390     }
2391     if (base-&gt;Opcode() == Op_CheckCastPP &amp;&amp;
2392         base-&gt;bottom_type()-&gt;isa_rawptr() &amp;&amp;
2393         _igvn-&gt;type(base-&gt;in(1))-&gt;isa_oopptr()) {
2394       base = base-&gt;in(1); // Case #9
2395     } else {
2396       Node* uncast_base = base-&gt;uncast();
2397       int opcode = uncast_base-&gt;Opcode();
2398       assert(opcode == Op_ConP || opcode == Op_ThreadLocal ||
2399              opcode == Op_CastX2P || uncast_base-&gt;is_DecodeNarrowPtr() ||
2400              (uncast_base-&gt;is_Mem() &amp;&amp; (uncast_base-&gt;bottom_type()-&gt;isa_rawptr() != NULL)) ||
2401              (uncast_base-&gt;is_Proj() &amp;&amp; uncast_base-&gt;in(0)-&gt;is_Allocate()), &quot;sanity&quot;);
2402     }
2403   }
2404   return base;
2405 }
2406 
2407 Node* ConnectionGraph::find_second_addp(Node* addp, Node* n) {
2408   assert(addp-&gt;is_AddP() &amp;&amp; addp-&gt;outcnt() &gt; 0, &quot;Don&#39;t process dead nodes&quot;);
2409   Node* addp2 = addp-&gt;raw_out(0);
2410   if (addp-&gt;outcnt() == 1 &amp;&amp; addp2-&gt;is_AddP() &amp;&amp;
2411       addp2-&gt;in(AddPNode::Base) == n &amp;&amp;
2412       addp2-&gt;in(AddPNode::Address) == addp) {
2413     assert(addp-&gt;in(AddPNode::Base) == n, &quot;expecting the same base&quot;);
2414     //
2415     // Find array&#39;s offset to push it on worklist first and
2416     // as result process an array&#39;s element offset first (pushed second)
2417     // to avoid CastPP for the array&#39;s offset.
2418     // Otherwise the inserted CastPP (LocalVar) will point to what
2419     // the AddP (Field) points to. Which would be wrong since
2420     // the algorithm expects the CastPP has the same point as
2421     // as AddP&#39;s base CheckCastPP (LocalVar).
2422     //
2423     //    ArrayAllocation
2424     //     |
2425     //    CheckCastPP
2426     //     |
2427     //    memProj (from ArrayAllocation CheckCastPP)
2428     //     |  ||
2429     //     |  ||   Int (element index)
2430     //     |  ||    |   ConI (log(element size))
2431     //     |  ||    |   /
2432     //     |  ||   LShift
2433     //     |  ||  /
2434     //     |  AddP (array&#39;s element offset)
2435     //     |  |
2436     //     |  | ConI (array&#39;s offset: #12(32-bits) or #24(64-bits))
2437     //     | / /
2438     //     AddP (array&#39;s offset)
2439     //      |
2440     //     Load/Store (memory operation on array&#39;s element)
2441     //
2442     return addp2;
2443   }
2444   return NULL;
2445 }
2446 
2447 //
2448 // Adjust the type and inputs of an AddP which computes the
2449 // address of a field of an instance
2450 //
2451 bool ConnectionGraph::split_AddP(Node *addp, Node *base) {
2452   PhaseGVN* igvn = _igvn;
2453   const TypeOopPtr *base_t = igvn-&gt;type(base)-&gt;isa_oopptr();
2454   assert(base_t != NULL &amp;&amp; base_t-&gt;is_known_instance(), &quot;expecting instance oopptr&quot;);
2455   const TypeOopPtr *t = igvn-&gt;type(addp)-&gt;isa_oopptr();
2456   if (t == NULL) {
2457     // We are computing a raw address for a store captured by an Initialize
2458     // compute an appropriate address type (cases #3 and #5).
2459     assert(igvn-&gt;type(addp) == TypeRawPtr::NOTNULL, &quot;must be raw pointer&quot;);
2460     assert(addp-&gt;in(AddPNode::Address)-&gt;is_Proj(), &quot;base of raw address must be result projection from allocation&quot;);
2461     intptr_t offs = (int)igvn-&gt;find_intptr_t_con(addp-&gt;in(AddPNode::Offset), Type::OffsetBot);
2462     assert(offs != Type::OffsetBot, &quot;offset must be a constant&quot;);
2463     if (base_t-&gt;isa_aryptr() != NULL) {
2464       // In the case of a flattened inline type array, each field has its
2465       // own slice so we need to extract the field being accessed from
2466       // the address computation
2467       t = base_t-&gt;isa_aryptr()-&gt;add_field_offset_and_offset(offs)-&gt;is_oopptr();
2468     } else {
2469       t = base_t-&gt;add_offset(offs)-&gt;is_oopptr();
2470     }
2471   }
2472   int inst_id = base_t-&gt;instance_id();
2473   assert(!t-&gt;is_known_instance() || t-&gt;instance_id() == inst_id,
2474                              &quot;old type must be non-instance or match new type&quot;);
2475 
2476   // The type &#39;t&#39; could be subclass of &#39;base_t&#39;.
2477   // As result t-&gt;offset() could be large then base_t&#39;s size and it will
2478   // cause the failure in add_offset() with narrow oops since TypeOopPtr()
2479   // constructor verifies correctness of the offset.
2480   //
2481   // It could happened on subclass&#39;s branch (from the type profiling
2482   // inlining) which was not eliminated during parsing since the exactness
2483   // of the allocation type was not propagated to the subclass type check.
2484   //
2485   // Or the type &#39;t&#39; could be not related to &#39;base_t&#39; at all.
2486   // It could happen when CHA type is different from MDO type on a dead path
2487   // (for example, from instanceof check) which is not collapsed during parsing.
2488   //
2489   // Do nothing for such AddP node and don&#39;t process its users since
2490   // this code branch will go away.
2491   //
2492   if (!t-&gt;is_known_instance() &amp;&amp;
2493       !base_t-&gt;klass()-&gt;is_subtype_of(t-&gt;klass())) {
2494      return false; // bail out
2495   }
2496   const TypePtr* tinst = base_t-&gt;add_offset(t-&gt;offset());
2497   if (tinst-&gt;isa_aryptr() &amp;&amp; t-&gt;isa_aryptr()) {
2498     // In the case of a flattened inline type array, each field has its
2499     // own slice so we need to keep track of the field being accessed.
2500     tinst = tinst-&gt;is_aryptr()-&gt;with_field_offset(t-&gt;is_aryptr()-&gt;field_offset().get());
2501   }
2502 
2503   // Do NOT remove the next line: ensure a new alias index is allocated
2504   // for the instance type. Note: C++ will not remove it since the call
2505   // has side effect.
2506   int alias_idx = _compile-&gt;get_alias_index(tinst);
2507   igvn-&gt;set_type(addp, tinst);
2508   // record the allocation in the node map
2509   set_map(addp, get_map(base-&gt;_idx));
2510   // Set addp&#39;s Base and Address to &#39;base&#39;.
2511   Node *abase = addp-&gt;in(AddPNode::Base);
2512   Node *adr   = addp-&gt;in(AddPNode::Address);
2513   if (adr-&gt;is_Proj() &amp;&amp; adr-&gt;in(0)-&gt;is_Allocate() &amp;&amp;
2514       adr-&gt;in(0)-&gt;_idx == (uint)inst_id) {
2515     // Skip AddP cases #3 and #5.
2516   } else {
2517     assert(!abase-&gt;is_top(), &quot;sanity&quot;); // AddP case #3
2518     if (abase != base) {
2519       igvn-&gt;hash_delete(addp);
2520       addp-&gt;set_req(AddPNode::Base, base);
2521       if (abase == adr) {
2522         addp-&gt;set_req(AddPNode::Address, base);
2523       } else {
2524         // AddP case #4 (adr is array&#39;s element offset AddP node)
2525 #ifdef ASSERT
2526         const TypeOopPtr *atype = igvn-&gt;type(adr)-&gt;isa_oopptr();
2527         assert(adr-&gt;is_AddP() &amp;&amp; atype != NULL &amp;&amp;
2528                atype-&gt;instance_id() == inst_id, &quot;array&#39;s element offset should be processed first&quot;);
2529 #endif
2530       }
2531       igvn-&gt;hash_insert(addp);
2532     }
2533   }
2534   // Put on IGVN worklist since at least addp&#39;s type was changed above.
2535   record_for_optimizer(addp);
2536   return true;
2537 }
2538 
2539 //
2540 // Create a new version of orig_phi if necessary. Returns either the newly
2541 // created phi or an existing phi.  Sets create_new to indicate whether a new
2542 // phi was created.  Cache the last newly created phi in the node map.
2543 //
2544 PhiNode *ConnectionGraph::create_split_phi(PhiNode *orig_phi, int alias_idx, GrowableArray&lt;PhiNode *&gt;  &amp;orig_phi_worklist, bool &amp;new_created) {
2545   Compile *C = _compile;
2546   PhaseGVN* igvn = _igvn;
2547   new_created = false;
2548   int phi_alias_idx = C-&gt;get_alias_index(orig_phi-&gt;adr_type());
2549   // nothing to do if orig_phi is bottom memory or matches alias_idx
2550   if (phi_alias_idx == alias_idx) {
2551     return orig_phi;
2552   }
2553   // Have we recently created a Phi for this alias index?
2554   PhiNode *result = get_map_phi(orig_phi-&gt;_idx);
2555   if (result != NULL &amp;&amp; C-&gt;get_alias_index(result-&gt;adr_type()) == alias_idx) {
2556     return result;
2557   }
2558   // Previous check may fail when the same wide memory Phi was split into Phis
2559   // for different memory slices. Search all Phis for this region.
2560   if (result != NULL) {
2561     Node* region = orig_phi-&gt;in(0);
2562     for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
2563       Node* phi = region-&gt;fast_out(i);
2564       if (phi-&gt;is_Phi() &amp;&amp;
2565           C-&gt;get_alias_index(phi-&gt;as_Phi()-&gt;adr_type()) == alias_idx) {
2566         assert(phi-&gt;_idx &gt;= nodes_size(), &quot;only new Phi per instance memory slice&quot;);
2567         return phi-&gt;as_Phi();
2568       }
2569     }
2570   }
2571   if (C-&gt;live_nodes() + 2*NodeLimitFudgeFactor &gt; C-&gt;max_node_limit()) {
2572     if (C-&gt;do_escape_analysis() == true &amp;&amp; !C-&gt;failing()) {
2573       // Retry compilation without escape analysis.
2574       // If this is the first failure, the sentinel string will &quot;stick&quot;
2575       // to the Compile object, and the C2Compiler will see it and retry.
2576       C-&gt;record_failure(C2Compiler::retry_no_escape_analysis());
2577     }
2578     return NULL;
2579   }
2580   orig_phi_worklist.append_if_missing(orig_phi);
2581   const TypePtr *atype = C-&gt;get_adr_type(alias_idx);
2582   result = PhiNode::make(orig_phi-&gt;in(0), NULL, Type::MEMORY, atype);
2583   C-&gt;copy_node_notes_to(result, orig_phi);
2584   igvn-&gt;set_type(result, result-&gt;bottom_type());
2585   record_for_optimizer(result);
2586   set_map(orig_phi, result);
2587   new_created = true;
2588   return result;
2589 }
2590 
2591 //
2592 // Return a new version of Memory Phi &quot;orig_phi&quot; with the inputs having the
2593 // specified alias index.
2594 //
2595 PhiNode *ConnectionGraph::split_memory_phi(PhiNode *orig_phi, int alias_idx, GrowableArray&lt;PhiNode *&gt;  &amp;orig_phi_worklist) {
2596   assert(alias_idx != Compile::AliasIdxBot, &quot;can&#39;t split out bottom memory&quot;);
2597   Compile *C = _compile;
2598   PhaseGVN* igvn = _igvn;
2599   bool new_phi_created;
2600   PhiNode *result = create_split_phi(orig_phi, alias_idx, orig_phi_worklist, new_phi_created);
2601   if (!new_phi_created) {
2602     return result;
2603   }
2604   GrowableArray&lt;PhiNode *&gt;  phi_list;
2605   GrowableArray&lt;uint&gt;  cur_input;
2606   PhiNode *phi = orig_phi;
2607   uint idx = 1;
2608   bool finished = false;
2609   while(!finished) {
2610     while (idx &lt; phi-&gt;req()) {
2611       Node *mem = find_inst_mem(phi-&gt;in(idx), alias_idx, orig_phi_worklist);
2612       if (mem != NULL &amp;&amp; mem-&gt;is_Phi()) {
2613         PhiNode *newphi = create_split_phi(mem-&gt;as_Phi(), alias_idx, orig_phi_worklist, new_phi_created);
2614         if (new_phi_created) {
2615           // found an phi for which we created a new split, push current one on worklist and begin
2616           // processing new one
2617           phi_list.push(phi);
2618           cur_input.push(idx);
2619           phi = mem-&gt;as_Phi();
2620           result = newphi;
2621           idx = 1;
2622           continue;
2623         } else {
2624           mem = newphi;
2625         }
2626       }
2627       if (C-&gt;failing()) {
2628         return NULL;
2629       }
2630       result-&gt;set_req(idx++, mem);
2631     }
2632 #ifdef ASSERT
2633     // verify that the new Phi has an input for each input of the original
2634     assert( phi-&gt;req() == result-&gt;req(), &quot;must have same number of inputs.&quot;);
2635     assert( result-&gt;in(0) != NULL &amp;&amp; result-&gt;in(0) == phi-&gt;in(0), &quot;regions must match&quot;);
2636 #endif
2637     // Check if all new phi&#39;s inputs have specified alias index.
2638     // Otherwise use old phi.
2639     for (uint i = 1; i &lt; phi-&gt;req(); i++) {
2640       Node* in = result-&gt;in(i);
2641       assert((phi-&gt;in(i) == NULL) == (in == NULL), &quot;inputs must correspond.&quot;);
2642     }
2643     // we have finished processing a Phi, see if there are any more to do
2644     finished = (phi_list.length() == 0 );
2645     if (!finished) {
2646       phi = phi_list.pop();
2647       idx = cur_input.pop();
2648       PhiNode *prev_result = get_map_phi(phi-&gt;_idx);
2649       prev_result-&gt;set_req(idx++, result);
2650       result = prev_result;
2651     }
2652   }
2653   return result;
2654 }
2655 
2656 //
2657 // The next methods are derived from methods in MemNode.
2658 //
2659 Node* ConnectionGraph::step_through_mergemem(MergeMemNode *mmem, int alias_idx, const TypeOopPtr *toop) {
2660   Node *mem = mmem;
2661   // TypeOopPtr::NOTNULL+any is an OOP with unknown offset - generally
2662   // means an array I have not precisely typed yet.  Do not do any
2663   // alias stuff with it any time soon.
2664   if (toop-&gt;base() != Type::AnyPtr &amp;&amp;
2665       !(toop-&gt;klass() != NULL &amp;&amp;
2666         toop-&gt;klass()-&gt;is_java_lang_Object() &amp;&amp;
2667         toop-&gt;offset() == Type::OffsetBot)) {
2668     mem = mmem-&gt;memory_at(alias_idx);
2669     // Update input if it is progress over what we have now
2670   }
2671   return mem;
2672 }
2673 
2674 //
2675 // Move memory users to their memory slices.
2676 //
2677 void ConnectionGraph::move_inst_mem(Node* n, GrowableArray&lt;PhiNode *&gt;  &amp;orig_phis) {
2678   Compile* C = _compile;
2679   PhaseGVN* igvn = _igvn;
2680   const TypePtr* tp = igvn-&gt;type(n-&gt;in(MemNode::Address))-&gt;isa_ptr();
2681   assert(tp != NULL, &quot;ptr type&quot;);
2682   int alias_idx = C-&gt;get_alias_index(tp);
2683   int general_idx = C-&gt;get_general_index(alias_idx);
2684 
2685   // Move users first
2686   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2687     Node* use = n-&gt;fast_out(i);
2688     if (use-&gt;is_MergeMem()) {
2689       MergeMemNode* mmem = use-&gt;as_MergeMem();
2690       assert(n == mmem-&gt;memory_at(alias_idx), &quot;should be on instance memory slice&quot;);
2691       if (n != mmem-&gt;memory_at(general_idx) || alias_idx == general_idx) {
2692         continue; // Nothing to do
2693       }
2694       // Replace previous general reference to mem node.
2695       uint orig_uniq = C-&gt;unique();
2696       Node* m = find_inst_mem(n, general_idx, orig_phis);
2697       assert(orig_uniq == C-&gt;unique(), &quot;no new nodes&quot;);
2698       mmem-&gt;set_memory_at(general_idx, m);
2699       --imax;
2700       --i;
2701     } else if (use-&gt;is_MemBar()) {
2702       assert(!use-&gt;is_Initialize(), &quot;initializing stores should not be moved&quot;);
2703       if (use-&gt;req() &gt; MemBarNode::Precedent &amp;&amp;
2704           use-&gt;in(MemBarNode::Precedent) == n) {
2705         // Don&#39;t move related membars.
2706         record_for_optimizer(use);
2707         continue;
2708       }
2709       tp = use-&gt;as_MemBar()-&gt;adr_type()-&gt;isa_ptr();
2710       if ((tp != NULL &amp;&amp; C-&gt;get_alias_index(tp) == alias_idx) ||
2711           alias_idx == general_idx) {
2712         continue; // Nothing to do
2713       }
2714       // Move to general memory slice.
2715       uint orig_uniq = C-&gt;unique();
2716       Node* m = find_inst_mem(n, general_idx, orig_phis);
2717       assert(orig_uniq == C-&gt;unique(), &quot;no new nodes&quot;);
2718       igvn-&gt;hash_delete(use);
2719       imax -= use-&gt;replace_edge(n, m);
2720       igvn-&gt;hash_insert(use);
2721       record_for_optimizer(use);
2722       --i;
2723 #ifdef ASSERT
2724     } else if (use-&gt;is_Mem()) {
2725       if (use-&gt;Opcode() == Op_StoreCM &amp;&amp; use-&gt;in(MemNode::OopStore) == n) {
2726         // Don&#39;t move related cardmark.
2727         continue;
2728       }
2729       // Memory nodes should have new memory input.
2730       tp = igvn-&gt;type(use-&gt;in(MemNode::Address))-&gt;isa_ptr();
2731       assert(tp != NULL, &quot;ptr type&quot;);
2732       int idx = C-&gt;get_alias_index(tp);
2733       assert(get_map(use-&gt;_idx) != NULL || idx == alias_idx,
2734              &quot;Following memory nodes should have new memory input or be on the same memory slice&quot;);
2735     } else if (use-&gt;is_Phi()) {
2736       // Phi nodes should be split and moved already.
2737       tp = use-&gt;as_Phi()-&gt;adr_type()-&gt;isa_ptr();
2738       assert(tp != NULL, &quot;ptr type&quot;);
2739       int idx = C-&gt;get_alias_index(tp);
2740       assert(idx == alias_idx, &quot;Following Phi nodes should be on the same memory slice&quot;);
2741     } else {
2742       use-&gt;dump();
2743       assert(false, &quot;should not be here&quot;);
2744 #endif
2745     }
2746   }
2747 }
2748 
2749 //
2750 // Search memory chain of &quot;mem&quot; to find a MemNode whose address
2751 // is the specified alias index.
2752 //
2753 Node* ConnectionGraph::find_inst_mem(Node *orig_mem, int alias_idx, GrowableArray&lt;PhiNode *&gt;  &amp;orig_phis) {
2754   if (orig_mem == NULL)
2755     return orig_mem;
2756   Compile* C = _compile;
2757   PhaseGVN* igvn = _igvn;
2758   const TypeOopPtr *toop = C-&gt;get_adr_type(alias_idx)-&gt;isa_oopptr();
2759   bool is_instance = (toop != NULL) &amp;&amp; toop-&gt;is_known_instance();
2760   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
2761   Node *prev = NULL;
2762   Node *result = orig_mem;
2763   while (prev != result) {
2764     prev = result;
2765     if (result == start_mem)
2766       break;  // hit one of our sentinels
2767     if (result-&gt;is_Mem()) {
2768       const Type *at = igvn-&gt;type(result-&gt;in(MemNode::Address));
2769       if (at == Type::TOP)
2770         break; // Dead
2771       assert (at-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
2772       int idx = C-&gt;get_alias_index(at-&gt;is_ptr());
2773       if (idx == alias_idx)
2774         break; // Found
2775       if (!is_instance &amp;&amp; (at-&gt;isa_oopptr() == NULL ||
2776                            !at-&gt;is_oopptr()-&gt;is_known_instance())) {
2777         break; // Do not skip store to general memory slice.
2778       }
2779       result = result-&gt;in(MemNode::Memory);
2780     }
2781     if (!is_instance)
2782       continue;  // don&#39;t search further for non-instance types
2783     // skip over a call which does not affect this memory slice
2784     if (result-&gt;is_Proj() &amp;&amp; result-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
2785       Node *proj_in = result-&gt;in(0);
2786       if (proj_in-&gt;is_Allocate() &amp;&amp; proj_in-&gt;_idx == (uint)toop-&gt;instance_id()) {
2787         break;  // hit one of our sentinels
2788       } else if (proj_in-&gt;is_Call()) {
2789         // ArrayCopy node processed here as well
2790         CallNode *call = proj_in-&gt;as_Call();
2791         if (!call-&gt;may_modify(toop, igvn)) {
2792           result = call-&gt;in(TypeFunc::Memory);
2793         }
2794       } else if (proj_in-&gt;is_Initialize()) {
2795         AllocateNode* alloc = proj_in-&gt;as_Initialize()-&gt;allocation();
2796         // Stop if this is the initialization for the object instance which
2797         // which contains this memory slice, otherwise skip over it.
2798         if (alloc == NULL || alloc-&gt;_idx != (uint)toop-&gt;instance_id()) {
2799           result = proj_in-&gt;in(TypeFunc::Memory);
2800         }
2801       } else if (proj_in-&gt;is_MemBar()) {
2802         // Check if there is an array copy for a clone
2803         // Step over GC barrier when ReduceInitialCardMarks is disabled
2804         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2805         Node* control_proj_ac = bs-&gt;step_over_gc_barrier(proj_in-&gt;in(0));
2806 
2807         if (control_proj_ac-&gt;is_Proj() &amp;&amp; control_proj_ac-&gt;in(0)-&gt;is_ArrayCopy()) {
2808           // Stop if it is a clone
2809           ArrayCopyNode* ac = control_proj_ac-&gt;in(0)-&gt;as_ArrayCopy();
2810           if (ac-&gt;may_modify(toop, igvn)) {
2811             break;
2812           }
2813         }
2814         result = proj_in-&gt;in(TypeFunc::Memory);
2815       }
2816     } else if (result-&gt;is_MergeMem()) {
2817       MergeMemNode *mmem = result-&gt;as_MergeMem();
2818       result = step_through_mergemem(mmem, alias_idx, toop);
2819       if (result == mmem-&gt;base_memory()) {
2820         // Didn&#39;t find instance memory, search through general slice recursively.
2821         result = mmem-&gt;memory_at(C-&gt;get_general_index(alias_idx));
2822         result = find_inst_mem(result, alias_idx, orig_phis);
2823         if (C-&gt;failing()) {
2824           return NULL;
2825         }
2826         mmem-&gt;set_memory_at(alias_idx, result);
2827       }
2828     } else if (result-&gt;is_Phi() &amp;&amp;
2829                C-&gt;get_alias_index(result-&gt;as_Phi()-&gt;adr_type()) != alias_idx) {
2830       Node *un = result-&gt;as_Phi()-&gt;unique_input(igvn);
2831       if (un != NULL) {
2832         orig_phis.append_if_missing(result-&gt;as_Phi());
2833         result = un;
2834       } else {
2835         break;
2836       }
2837     } else if (result-&gt;is_ClearArray()) {
2838       if (!ClearArrayNode::step_through(&amp;result, (uint)toop-&gt;instance_id(), igvn)) {
2839         // Can not bypass initialization of the instance
2840         // we are looking for.
2841         break;
2842       }
2843       // Otherwise skip it (the call updated &#39;result&#39; value).
2844     } else if (result-&gt;Opcode() == Op_SCMemProj) {
2845       Node* mem = result-&gt;in(0);
2846       Node* adr = NULL;
2847       if (mem-&gt;is_LoadStore()) {
2848         adr = mem-&gt;in(MemNode::Address);
2849       } else {
2850         assert(mem-&gt;Opcode() == Op_EncodeISOArray ||
2851                mem-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
2852         adr = mem-&gt;in(3); // Memory edge corresponds to destination array
2853       }
2854       const Type *at = igvn-&gt;type(adr);
2855       if (at != Type::TOP) {
2856         assert(at-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
2857         int idx = C-&gt;get_alias_index(at-&gt;is_ptr());
2858         if (idx == alias_idx) {
2859           // Assert in debug mode
2860           assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
2861           break; // In product mode return SCMemProj node
2862         }
2863       }
2864       result = mem-&gt;in(MemNode::Memory);
2865     } else if (result-&gt;Opcode() == Op_StrInflatedCopy) {
2866       Node* adr = result-&gt;in(3); // Memory edge corresponds to destination array
2867       const Type *at = igvn-&gt;type(adr);
2868       if (at != Type::TOP) {
2869         assert(at-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
2870         int idx = C-&gt;get_alias_index(at-&gt;is_ptr());
2871         if (idx == alias_idx) {
2872           // Assert in debug mode
2873           assert(false, &quot;Object is not scalar replaceable if a StrInflatedCopy node accesses its field&quot;);
2874           break; // In product mode return SCMemProj node
2875         }
2876       }
2877       result = result-&gt;in(MemNode::Memory);
2878     }
2879   }
2880   if (result-&gt;is_Phi()) {
2881     PhiNode *mphi = result-&gt;as_Phi();
2882     assert(mphi-&gt;bottom_type() == Type::MEMORY, &quot;memory phi required&quot;);
2883     const TypePtr *t = mphi-&gt;adr_type();
2884     if (!is_instance) {
2885       // Push all non-instance Phis on the orig_phis worklist to update inputs
2886       // during Phase 4 if needed.
2887       orig_phis.append_if_missing(mphi);
2888     } else if (C-&gt;get_alias_index(t) != alias_idx) {
2889       // Create a new Phi with the specified alias index type.
2890       result = split_memory_phi(mphi, alias_idx, orig_phis);
2891     }
2892   }
2893   // the result is either MemNode, PhiNode, InitializeNode.
2894   return result;
2895 }
2896 
2897 //
2898 //  Convert the types of unescaped object to instance types where possible,
2899 //  propagate the new type information through the graph, and update memory
2900 //  edges and MergeMem inputs to reflect the new type.
2901 //
2902 //  We start with allocations (and calls which may be allocations)  on alloc_worklist.
2903 //  The processing is done in 4 phases:
2904 //
2905 //  Phase 1:  Process possible allocations from alloc_worklist.  Create instance
2906 //            types for the CheckCastPP for allocations where possible.
2907 //            Propagate the new types through users as follows:
2908 //               casts and Phi:  push users on alloc_worklist
2909 //               AddP:  cast Base and Address inputs to the instance type
2910 //                      push any AddP users on alloc_worklist and push any memnode
2911 //                      users onto memnode_worklist.
2912 //  Phase 2:  Process MemNode&#39;s from memnode_worklist. compute new address type and
2913 //            search the Memory chain for a store with the appropriate type
2914 //            address type.  If a Phi is found, create a new version with
2915 //            the appropriate memory slices from each of the Phi inputs.
2916 //            For stores, process the users as follows:
2917 //               MemNode:  push on memnode_worklist
2918 //               MergeMem: push on mergemem_worklist
2919 //  Phase 3:  Process MergeMem nodes from mergemem_worklist.  Walk each memory slice
2920 //            moving the first node encountered of each  instance type to the
2921 //            the input corresponding to its alias index.
2922 //            appropriate memory slice.
2923 //  Phase 4:  Update the inputs of non-instance memory Phis and the Memory input of memnodes.
2924 //
2925 // In the following example, the CheckCastPP nodes are the cast of allocation
2926 // results and the allocation of node 29 is unescaped and eligible to be an
2927 // instance type.
2928 //
2929 // We start with:
2930 //
2931 //     7 Parm #memory
2932 //    10  ConI  &quot;12&quot;
2933 //    19  CheckCastPP   &quot;Foo&quot;
2934 //    20  AddP  _ 19 19 10  Foo+12  alias_index=4
2935 //    29  CheckCastPP   &quot;Foo&quot;
2936 //    30  AddP  _ 29 29 10  Foo+12  alias_index=4
2937 //
2938 //    40  StoreP  25   7  20   ... alias_index=4
2939 //    50  StoreP  35  40  30   ... alias_index=4
2940 //    60  StoreP  45  50  20   ... alias_index=4
2941 //    70  LoadP    _  60  30   ... alias_index=4
2942 //    80  Phi     75  50  60   Memory alias_index=4
2943 //    90  LoadP    _  80  30   ... alias_index=4
2944 //   100  LoadP    _  80  20   ... alias_index=4
2945 //
2946 //
2947 // Phase 1 creates an instance type for node 29 assigning it an instance id of 24
2948 // and creating a new alias index for node 30.  This gives:
2949 //
2950 //     7 Parm #memory
2951 //    10  ConI  &quot;12&quot;
2952 //    19  CheckCastPP   &quot;Foo&quot;
2953 //    20  AddP  _ 19 19 10  Foo+12  alias_index=4
2954 //    29  CheckCastPP   &quot;Foo&quot;  iid=24
2955 //    30  AddP  _ 29 29 10  Foo+12  alias_index=6  iid=24
2956 //
2957 //    40  StoreP  25   7  20   ... alias_index=4
2958 //    50  StoreP  35  40  30   ... alias_index=6
2959 //    60  StoreP  45  50  20   ... alias_index=4
2960 //    70  LoadP    _  60  30   ... alias_index=6
2961 //    80  Phi     75  50  60   Memory alias_index=4
2962 //    90  LoadP    _  80  30   ... alias_index=6
2963 //   100  LoadP    _  80  20   ... alias_index=4
2964 //
2965 // In phase 2, new memory inputs are computed for the loads and stores,
2966 // And a new version of the phi is created.  In phase 4, the inputs to
2967 // node 80 are updated and then the memory nodes are updated with the
2968 // values computed in phase 2.  This results in:
2969 //
2970 //     7 Parm #memory
2971 //    10  ConI  &quot;12&quot;
2972 //    19  CheckCastPP   &quot;Foo&quot;
2973 //    20  AddP  _ 19 19 10  Foo+12  alias_index=4
2974 //    29  CheckCastPP   &quot;Foo&quot;  iid=24
2975 //    30  AddP  _ 29 29 10  Foo+12  alias_index=6  iid=24
2976 //
2977 //    40  StoreP  25  7   20   ... alias_index=4
2978 //    50  StoreP  35  7   30   ... alias_index=6
2979 //    60  StoreP  45  40  20   ... alias_index=4
2980 //    70  LoadP    _  50  30   ... alias_index=6
2981 //    80  Phi     75  40  60   Memory alias_index=4
2982 //   120  Phi     75  50  50   Memory alias_index=6
2983 //    90  LoadP    _ 120  30   ... alias_index=6
2984 //   100  LoadP    _  80  20   ... alias_index=4
2985 //
2986 void ConnectionGraph::split_unique_types(GrowableArray&lt;Node *&gt;  &amp;alloc_worklist, GrowableArray&lt;ArrayCopyNode*&gt; &amp;arraycopy_worklist) {
2987   GrowableArray&lt;Node *&gt;  memnode_worklist;
2988   GrowableArray&lt;PhiNode *&gt;  orig_phis;
2989   PhaseIterGVN  *igvn = _igvn;
2990   uint new_index_start = (uint) _compile-&gt;num_alias_types();
2991   Arena* arena = Thread::current()-&gt;resource_area();
2992   VectorSet visited(arena);
2993   ideal_nodes.clear(); // Reset for use with set_map/get_map.
2994   uint unique_old = _compile-&gt;unique();
2995 
2996   //  Phase 1:  Process possible allocations from alloc_worklist.
2997   //  Create instance types for the CheckCastPP for allocations where possible.
2998   //
2999   // (Note: don&#39;t forget to change the order of the second AddP node on
3000   //  the alloc_worklist if the order of the worklist processing is changed,
3001   //  see the comment in find_second_addp().)
3002   //
3003   while (alloc_worklist.length() != 0) {
3004     Node *n = alloc_worklist.pop();
3005     uint ni = n-&gt;_idx;
3006     if (n-&gt;is_Call()) {
3007       CallNode *alloc = n-&gt;as_Call();
3008       // copy escape information to call node
3009       PointsToNode* ptn = ptnode_adr(alloc-&gt;_idx);
3010       PointsToNode::EscapeState es = ptn-&gt;escape_state();
3011       // We have an allocation or call which returns a Java object,
3012       // see if it is unescaped.
3013       if (es != PointsToNode::NoEscape || !ptn-&gt;scalar_replaceable())
3014         continue;
3015       // Find CheckCastPP for the allocate or for the return value of a call
3016       n = alloc-&gt;result_cast();
3017       if (n == NULL) {            // No uses except Initialize node
3018         if (alloc-&gt;is_Allocate()) {
3019           // Set the scalar_replaceable flag for allocation
3020           // so it could be eliminated if it has no uses.
3021           alloc-&gt;as_Allocate()-&gt;_is_scalar_replaceable = true;
3022         }
3023         if (alloc-&gt;is_CallStaticJava()) {
3024           // Set the scalar_replaceable flag for boxing method
3025           // so it could be eliminated if it has no uses.
3026           alloc-&gt;as_CallStaticJava()-&gt;_is_scalar_replaceable = true;
3027         }
3028         continue;
3029       }
3030       if (!n-&gt;is_CheckCastPP()) { // not unique CheckCastPP.
3031         assert(!alloc-&gt;is_Allocate(), &quot;allocation should have unique type&quot;);
3032         continue;
3033       }
3034 
3035       // The inline code for Object.clone() casts the allocation result to
3036       // java.lang.Object and then to the actual type of the allocated
3037       // object. Detect this case and use the second cast.
3038       // Also detect j.l.reflect.Array.newInstance(jobject, jint) case when
3039       // the allocation result is cast to java.lang.Object and then
3040       // to the actual Array type.
3041       if (alloc-&gt;is_Allocate() &amp;&amp; n-&gt;as_Type()-&gt;type() == TypeInstPtr::NOTNULL
3042           &amp;&amp; (alloc-&gt;is_AllocateArray() ||
3043               igvn-&gt;type(alloc-&gt;in(AllocateNode::KlassNode)) != TypeKlassPtr::OBJECT)) {
3044         Node *cast2 = NULL;
3045         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3046           Node *use = n-&gt;fast_out(i);
3047           if (use-&gt;is_CheckCastPP()) {
3048             cast2 = use;
3049             break;
3050           }
3051         }
3052         if (cast2 != NULL) {
3053           n = cast2;
3054         } else {
3055           // Non-scalar replaceable if the allocation type is unknown statically
3056           // (reflection allocation), the object can&#39;t be restored during
3057           // deoptimization without precise type.
3058           continue;
3059         }
3060       }
3061 
3062       const TypeOopPtr *t = igvn-&gt;type(n)-&gt;isa_oopptr();
3063       if (t == NULL)
3064         continue;  // not a TypeOopPtr
3065       if (!t-&gt;klass_is_exact())
3066         continue; // not an unique type
3067 
3068       if (alloc-&gt;is_Allocate()) {
3069         // Set the scalar_replaceable flag for allocation
3070         // so it could be eliminated.
3071         alloc-&gt;as_Allocate()-&gt;_is_scalar_replaceable = true;
3072       }
3073       if (alloc-&gt;is_CallStaticJava()) {
3074         // Set the scalar_replaceable flag for boxing method
3075         // so it could be eliminated.
3076         alloc-&gt;as_CallStaticJava()-&gt;_is_scalar_replaceable = true;
3077       }
3078       set_escape_state(ptnode_adr(n-&gt;_idx), es); // CheckCastPP escape state
3079       // in order for an object to be scalar-replaceable, it must be:
3080       //   - a direct allocation (not a call returning an object)
3081       //   - non-escaping
3082       //   - eligible to be a unique type
3083       //   - not determined to be ineligible by escape analysis
3084       set_map(alloc, n);
3085       set_map(n, alloc);
3086       const TypeOopPtr* tinst = t-&gt;cast_to_instance_id(ni);
3087       igvn-&gt;hash_delete(n);
3088       igvn-&gt;set_type(n,  tinst);
3089       n-&gt;raise_bottom_type(tinst);
3090       igvn-&gt;hash_insert(n);
3091       record_for_optimizer(n);
3092       // Allocate an alias index for the header fields. Accesses to
3093       // the header emitted during macro expansion wouldn&#39;t have
3094       // correct memory state otherwise.
3095       _compile-&gt;get_alias_index(tinst-&gt;add_offset(oopDesc::mark_offset_in_bytes()));
3096       _compile-&gt;get_alias_index(tinst-&gt;add_offset(oopDesc::klass_offset_in_bytes()));
3097       if (alloc-&gt;is_Allocate() &amp;&amp; (t-&gt;isa_instptr() || t-&gt;isa_aryptr())) {
3098 
3099         // First, put on the worklist all Field edges from Connection Graph
3100         // which is more accurate than putting immediate users from Ideal Graph.
3101         for (EdgeIterator e(ptn); e.has_next(); e.next()) {
3102           PointsToNode* tgt = e.get();
3103           if (tgt-&gt;is_Arraycopy()) {
3104             continue;
3105           }
3106           Node* use = tgt-&gt;ideal_node();
3107           assert(tgt-&gt;is_Field() &amp;&amp; use-&gt;is_AddP(),
3108                  &quot;only AddP nodes are Field edges in CG&quot;);
3109           if (use-&gt;outcnt() &gt; 0) { // Don&#39;t process dead nodes
3110             Node* addp2 = find_second_addp(use, use-&gt;in(AddPNode::Base));
3111             if (addp2 != NULL) {
3112               assert(alloc-&gt;is_AllocateArray(),&quot;array allocation was expected&quot;);
3113               alloc_worklist.append_if_missing(addp2);
3114             }
3115             alloc_worklist.append_if_missing(use);
3116           }
3117         }
3118 
3119         // An allocation may have an Initialize which has raw stores. Scan
3120         // the users of the raw allocation result and push AddP users
3121         // on alloc_worklist.
3122         Node *raw_result = alloc-&gt;proj_out_or_null(TypeFunc::Parms);
3123         assert (raw_result != NULL, &quot;must have an allocation result&quot;);
3124         for (DUIterator_Fast imax, i = raw_result-&gt;fast_outs(imax); i &lt; imax; i++) {
3125           Node *use = raw_result-&gt;fast_out(i);
3126           if (use-&gt;is_AddP() &amp;&amp; use-&gt;outcnt() &gt; 0) { // Don&#39;t process dead nodes
3127             Node* addp2 = find_second_addp(use, raw_result);
3128             if (addp2 != NULL) {
3129               assert(alloc-&gt;is_AllocateArray(),&quot;array allocation was expected&quot;);
3130               alloc_worklist.append_if_missing(addp2);
3131             }
3132             alloc_worklist.append_if_missing(use);
3133           } else if (use-&gt;is_MemBar()) {
3134             memnode_worklist.append_if_missing(use);
3135           }
3136         }
3137       }
3138     } else if (n-&gt;is_AddP()) {
3139       JavaObjectNode* jobj = unique_java_object(get_addp_base(n));
3140       if (jobj == NULL || jobj == phantom_obj) {
3141 #ifdef ASSERT
3142         ptnode_adr(get_addp_base(n)-&gt;_idx)-&gt;dump();
3143         ptnode_adr(n-&gt;_idx)-&gt;dump();
3144         assert(jobj != NULL &amp;&amp; jobj != phantom_obj, &quot;escaped allocation&quot;);
3145 #endif
3146         _compile-&gt;record_failure(C2Compiler::retry_no_escape_analysis());
3147         return;
3148       }
3149       Node *base = get_map(jobj-&gt;idx());  // CheckCastPP node
3150       if (!split_AddP(n, base)) continue; // wrong type from dead path
3151     } else if (n-&gt;is_Phi() ||
3152                n-&gt;is_CheckCastPP() ||
3153                n-&gt;is_EncodeP() ||
3154                n-&gt;is_DecodeN() ||
3155                (n-&gt;is_ConstraintCast() &amp;&amp; n-&gt;Opcode() == Op_CastPP)) {
3156       if (visited.test_set(n-&gt;_idx)) {
3157         assert(n-&gt;is_Phi(), &quot;loops only through Phi&#39;s&quot;);
3158         continue;  // already processed
3159       }
3160       JavaObjectNode* jobj = unique_java_object(n);
3161       if (jobj == NULL || jobj == phantom_obj) {
3162 #ifdef ASSERT
3163         ptnode_adr(n-&gt;_idx)-&gt;dump();
3164         assert(jobj != NULL &amp;&amp; jobj != phantom_obj, &quot;escaped allocation&quot;);
3165 #endif
3166         _compile-&gt;record_failure(C2Compiler::retry_no_escape_analysis());
3167         return;
3168       } else {
3169         Node *val = get_map(jobj-&gt;idx());   // CheckCastPP node
3170         TypeNode *tn = n-&gt;as_Type();
3171         const TypeOopPtr* tinst = igvn-&gt;type(val)-&gt;isa_oopptr();
3172         assert(tinst != NULL &amp;&amp; tinst-&gt;is_known_instance() &amp;&amp;
3173                tinst-&gt;instance_id() == jobj-&gt;idx() , &quot;instance type expected.&quot;);
3174 
3175         const Type *tn_type = igvn-&gt;type(tn);
3176         const TypeOopPtr *tn_t;
3177         if (tn_type-&gt;isa_narrowoop()) {
3178           tn_t = tn_type-&gt;make_ptr()-&gt;isa_oopptr();
3179         } else {
3180           tn_t = tn_type-&gt;isa_oopptr();
3181         }
3182         if (tn_t != NULL &amp;&amp; tinst-&gt;klass()-&gt;is_subtype_of(tn_t-&gt;klass())) {
3183           if (tn_type-&gt;isa_narrowoop()) {
3184             tn_type = tinst-&gt;make_narrowoop();
3185           } else {
3186             tn_type = tinst;
3187           }
3188           igvn-&gt;hash_delete(tn);
3189           igvn-&gt;set_type(tn, tn_type);
3190           tn-&gt;set_type(tn_type);
3191           igvn-&gt;hash_insert(tn);
3192           record_for_optimizer(n);
3193         } else {
3194           assert(tn_type == TypePtr::NULL_PTR ||
3195                  tn_t != NULL &amp;&amp; !tinst-&gt;klass()-&gt;is_subtype_of(tn_t-&gt;klass()),
3196                  &quot;unexpected type&quot;);
3197           continue; // Skip dead path with different type
3198         }
3199       }
3200     } else {
3201       debug_only(n-&gt;dump();)
3202       assert(false, &quot;EA: unexpected node&quot;);
3203       continue;
3204     }
3205     // push allocation&#39;s users on appropriate worklist
3206     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3207       Node *use = n-&gt;fast_out(i);
3208       if (use-&gt;is_Mem() &amp;&amp; use-&gt;in(MemNode::Address) == n) {
3209         // Load/store to instance&#39;s field
3210         memnode_worklist.append_if_missing(use);
3211       } else if (use-&gt;is_MemBar()) {
3212         if (use-&gt;in(TypeFunc::Memory) == n) { // Ignore precedent edge
3213           memnode_worklist.append_if_missing(use);
3214         }
3215       } else if (use-&gt;is_AddP() &amp;&amp; use-&gt;outcnt() &gt; 0) { // No dead nodes
3216         Node* addp2 = find_second_addp(use, n);
3217         if (addp2 != NULL) {
3218           alloc_worklist.append_if_missing(addp2);
3219         }
3220         alloc_worklist.append_if_missing(use);
3221       } else if (use-&gt;is_Phi() ||
3222                  use-&gt;is_CheckCastPP() ||
3223                  use-&gt;is_EncodeNarrowPtr() ||
3224                  use-&gt;is_DecodeNarrowPtr() ||
3225                  (use-&gt;is_ConstraintCast() &amp;&amp; use-&gt;Opcode() == Op_CastPP)) {
3226         alloc_worklist.append_if_missing(use);
3227 #ifdef ASSERT
3228       } else if (use-&gt;is_Mem()) {
3229         assert(use-&gt;in(MemNode::Address) != n, &quot;EA: missing allocation reference path&quot;);
3230       } else if (use-&gt;is_MergeMem()) {
3231         assert(_mergemem_worklist.contains(use-&gt;as_MergeMem()), &quot;EA: missing MergeMem node in the worklist&quot;);
3232       } else if (use-&gt;is_SafePoint()) {
3233         // Look for MergeMem nodes for calls which reference unique allocation
3234         // (through CheckCastPP nodes) even for debug info.
3235         Node* m = use-&gt;in(TypeFunc::Memory);
3236         if (m-&gt;is_MergeMem()) {
3237           assert(_mergemem_worklist.contains(m-&gt;as_MergeMem()), &quot;EA: missing MergeMem node in the worklist&quot;);
3238         }
3239       } else if (use-&gt;Opcode() == Op_EncodeISOArray) {
3240         if (use-&gt;in(MemNode::Memory) == n || use-&gt;in(3) == n) {
3241           // EncodeISOArray overwrites destination array
3242           memnode_worklist.append_if_missing(use);
3243         }
3244       } else if (use-&gt;Opcode() == Op_Return) {
3245         assert(_compile-&gt;tf()-&gt;returns_inline_type_as_fields(), &quot;must return an inline type&quot;);
3246         // Get InlineKlass by removing the tag bit from the metadata pointer
3247         Node* klass = use-&gt;in(TypeFunc::Parms);
3248         intptr_t ptr = igvn-&gt;type(klass)-&gt;isa_rawptr()-&gt;get_con();
3249         clear_nth_bit(ptr, 0);
3250         assert(Metaspace::contains((void*)ptr), &quot;should be klass&quot;);
3251         assert(((InlineKlass*)ptr)-&gt;contains_oops(), &quot;returned inline type must contain a reference field&quot;);
3252       } else {
3253         uint op = use-&gt;Opcode();
3254         if ((op == Op_StrCompressedCopy || op == Op_StrInflatedCopy) &amp;&amp;
3255             (use-&gt;in(MemNode::Memory) == n)) {
3256           // They overwrite memory edge corresponding to destination array,
3257           memnode_worklist.append_if_missing(use);
3258         } else if (!(op == Op_CmpP || op == Op_Conv2B ||
3259               op == Op_CastP2X || op == Op_StoreCM ||
3260               op == Op_FastLock || op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||
3261               op == Op_StrCompressedCopy || op == Op_StrInflatedCopy ||
3262               op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar ||
3263               op == Op_SubTypeCheck || op == Op_InlineType || op == Op_InlineTypePtr ||
3264               BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(use))) {
3265           n-&gt;dump();
3266           use-&gt;dump();
3267           assert(false, &quot;EA: missing allocation reference path&quot;);
3268         }
3269 #endif
3270       }
3271     }
3272 
3273   }
3274 
3275   // Go over all ArrayCopy nodes and if one of the inputs has a unique
3276   // type, record it in the ArrayCopy node so we know what memory this
3277   // node uses/modified.
3278   for (int next = 0; next &lt; arraycopy_worklist.length(); next++) {
3279     ArrayCopyNode* ac = arraycopy_worklist.at(next);
3280     Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
3281     if (dest-&gt;is_AddP()) {
3282       dest = get_addp_base(dest);
3283     }
3284     JavaObjectNode* jobj = unique_java_object(dest);
3285     if (jobj != NULL) {
3286       Node *base = get_map(jobj-&gt;idx());
3287       if (base != NULL) {
3288         const TypeOopPtr *base_t = _igvn-&gt;type(base)-&gt;isa_oopptr();
3289         ac-&gt;_dest_type = base_t;
3290       }
3291     }
3292     Node* src = ac-&gt;in(ArrayCopyNode::Src);
3293     if (src-&gt;is_AddP()) {
3294       src = get_addp_base(src);
3295     }
3296     jobj = unique_java_object(src);
3297     if (jobj != NULL) {
3298       Node* base = get_map(jobj-&gt;idx());
3299       if (base != NULL) {
3300         const TypeOopPtr *base_t = _igvn-&gt;type(base)-&gt;isa_oopptr();
3301         ac-&gt;_src_type = base_t;
3302       }
3303     }
3304   }
3305 
3306   // New alias types were created in split_AddP().
3307   uint new_index_end = (uint) _compile-&gt;num_alias_types();
3308   assert(unique_old == _compile-&gt;unique(), &quot;there should be no new ideal nodes after Phase 1&quot;);
3309 
3310   //  Phase 2:  Process MemNode&#39;s from memnode_worklist. compute new address type and
3311   //            compute new values for Memory inputs  (the Memory inputs are not
3312   //            actually updated until phase 4.)
3313   if (memnode_worklist.length() == 0)
3314     return;  // nothing to do
3315   while (memnode_worklist.length() != 0) {
3316     Node *n = memnode_worklist.pop();
3317     if (visited.test_set(n-&gt;_idx))
3318       continue;
3319     if (n-&gt;is_Phi() || n-&gt;is_ClearArray()) {
3320       // we don&#39;t need to do anything, but the users must be pushed
3321     } else if (n-&gt;is_MemBar()) { // Initialize, MemBar nodes
3322       // we don&#39;t need to do anything, but the users must be pushed
3323       n = n-&gt;as_MemBar()-&gt;proj_out_or_null(TypeFunc::Memory);
3324       if (n == NULL)
3325         continue;
3326     } else if (n-&gt;Opcode() == Op_StrCompressedCopy ||
3327                n-&gt;Opcode() == Op_EncodeISOArray) {
3328       // get the memory projection
3329       n = n-&gt;find_out_with(Op_SCMemProj);
3330       assert(n != NULL &amp;&amp; n-&gt;Opcode() == Op_SCMemProj, &quot;memory projection required&quot;);
3331     } else if (n-&gt;is_CallLeaf() &amp;&amp; n-&gt;as_CallLeaf()-&gt;_name != NULL &amp;&amp;
3332                strcmp(n-&gt;as_CallLeaf()-&gt;_name, &quot;store_unknown_inline&quot;) == 0) {
3333       n = n-&gt;as_CallLeaf()-&gt;proj_out(TypeFunc::Memory);
3334     } else {
3335       assert(n-&gt;is_Mem(), &quot;memory node required.&quot;);
3336       Node *addr = n-&gt;in(MemNode::Address);
3337       const Type *addr_t = igvn-&gt;type(addr);
3338       if (addr_t == Type::TOP)
3339         continue;
3340       assert (addr_t-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
3341       int alias_idx = _compile-&gt;get_alias_index(addr_t-&gt;is_ptr());
3342       assert ((uint)alias_idx &lt; new_index_end, &quot;wrong alias index&quot;);
3343       Node *mem = find_inst_mem(n-&gt;in(MemNode::Memory), alias_idx, orig_phis);
3344       if (_compile-&gt;failing()) {
3345         return;
3346       }
3347       if (mem != n-&gt;in(MemNode::Memory)) {
3348         // We delay the memory edge update since we need old one in
3349         // MergeMem code below when instances memory slices are separated.
3350         set_map(n, mem);
3351       }
3352       if (n-&gt;is_Load()) {
3353         continue;  // don&#39;t push users
3354       } else if (n-&gt;is_LoadStore()) {
3355         // get the memory projection
3356         n = n-&gt;find_out_with(Op_SCMemProj);
3357         assert(n != NULL &amp;&amp; n-&gt;Opcode() == Op_SCMemProj, &quot;memory projection required&quot;);
3358       }
3359     }
3360     // push user on appropriate worklist
3361     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3362       Node *use = n-&gt;fast_out(i);
3363       if (use-&gt;is_Phi() || use-&gt;is_ClearArray()) {
3364         memnode_worklist.append_if_missing(use);
3365       } else if (use-&gt;is_Mem() &amp;&amp; use-&gt;in(MemNode::Memory) == n) {
3366         if (use-&gt;Opcode() == Op_StoreCM) // Ignore cardmark stores
3367           continue;
3368         memnode_worklist.append_if_missing(use);
3369       } else if (use-&gt;is_MemBar()) {
3370         if (use-&gt;in(TypeFunc::Memory) == n) { // Ignore precedent edge
3371           memnode_worklist.append_if_missing(use);
3372         }
3373 #ifdef ASSERT
3374       } else if (use-&gt;is_Mem()) {
3375         assert(use-&gt;in(MemNode::Memory) != n, &quot;EA: missing memory path&quot;);
3376       } else if (use-&gt;is_MergeMem()) {
3377         assert(_mergemem_worklist.contains(use-&gt;as_MergeMem()), &quot;EA: missing MergeMem node in the worklist&quot;);
3378       } else if (use-&gt;Opcode() == Op_EncodeISOArray) {
3379         if (use-&gt;in(MemNode::Memory) == n || use-&gt;in(3) == n) {
3380           // EncodeISOArray overwrites destination array
3381           memnode_worklist.append_if_missing(use);
3382         }
3383       } else if (use-&gt;is_CallLeaf() &amp;&amp; use-&gt;as_CallLeaf()-&gt;_name != NULL &amp;&amp;
3384                  strcmp(use-&gt;as_CallLeaf()-&gt;_name, &quot;store_unknown_inline&quot;) == 0) {
3385         // store_unknown_inline overwrites destination array
3386         memnode_worklist.append_if_missing(use);
3387       } else {
3388         uint op = use-&gt;Opcode();
3389         if ((use-&gt;in(MemNode::Memory) == n) &amp;&amp;
3390             (op == Op_StrCompressedCopy || op == Op_StrInflatedCopy)) {
3391           // They overwrite memory edge corresponding to destination array,
3392           memnode_worklist.append_if_missing(use);
3393         } else if (!(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(use) ||
3394               op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||
3395               op == Op_StrCompressedCopy || op == Op_StrInflatedCopy ||
3396               op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar)) {
3397           n-&gt;dump();
3398           use-&gt;dump();
3399           assert(false, &quot;EA: missing memory path&quot;);
3400         }
3401 #endif
3402       }
3403     }
3404   }
3405 
3406   //  Phase 3:  Process MergeMem nodes from mergemem_worklist.
3407   //            Walk each memory slice moving the first node encountered of each
3408   //            instance type to the input corresponding to its alias index.
3409   uint length = _mergemem_worklist.length();
3410   for( uint next = 0; next &lt; length; ++next ) {
3411     MergeMemNode* nmm = _mergemem_worklist.at(next);
3412     assert(!visited.test_set(nmm-&gt;_idx), &quot;should not be visited before&quot;);
3413     // Note: we don&#39;t want to use MergeMemStream here because we only want to
3414     // scan inputs which exist at the start, not ones we add during processing.
3415     // Note 2: MergeMem may already contains instance memory slices added
3416     // during find_inst_mem() call when memory nodes were processed above.
3417     igvn-&gt;hash_delete(nmm);
3418     uint nslices = MIN2(nmm-&gt;req(), new_index_start);
3419     for (uint i = Compile::AliasIdxRaw+1; i &lt; nslices; i++) {
3420       Node* mem = nmm-&gt;in(i);
3421       Node* cur = NULL;
3422       if (mem == NULL || mem-&gt;is_top())
3423         continue;
3424       // First, update mergemem by moving memory nodes to corresponding slices
3425       // if their type became more precise since this mergemem was created.
3426       while (mem-&gt;is_Mem()) {
3427         const Type *at = igvn-&gt;type(mem-&gt;in(MemNode::Address));
3428         if (at != Type::TOP) {
3429           assert (at-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
3430           uint idx = (uint)_compile-&gt;get_alias_index(at-&gt;is_ptr());
3431           if (idx == i) {
3432             if (cur == NULL)
3433               cur = mem;
3434           } else {
3435             if (idx &gt;= nmm-&gt;req() || nmm-&gt;is_empty_memory(nmm-&gt;in(idx))) {
3436               nmm-&gt;set_memory_at(idx, mem);
3437             }
3438           }
3439         }
3440         mem = mem-&gt;in(MemNode::Memory);
3441       }
3442       nmm-&gt;set_memory_at(i, (cur != NULL) ? cur : mem);
3443       // Find any instance of the current type if we haven&#39;t encountered
3444       // already a memory slice of the instance along the memory chain.
3445       for (uint ni = new_index_start; ni &lt; new_index_end; ni++) {
3446         if((uint)_compile-&gt;get_general_index(ni) == i) {
3447           Node *m = (ni &gt;= nmm-&gt;req()) ? nmm-&gt;empty_memory() : nmm-&gt;in(ni);
3448           if (nmm-&gt;is_empty_memory(m)) {
3449             Node* result = find_inst_mem(mem, ni, orig_phis);
3450             if (_compile-&gt;failing()) {
3451               return;
3452             }
3453             nmm-&gt;set_memory_at(ni, result);
3454           }
3455         }
3456       }
3457     }
3458     // Find the rest of instances values
3459     for (uint ni = new_index_start; ni &lt; new_index_end; ni++) {
3460       const TypeOopPtr *tinst = _compile-&gt;get_adr_type(ni)-&gt;isa_oopptr();
3461       Node* result = step_through_mergemem(nmm, ni, tinst);
3462       if (result == nmm-&gt;base_memory()) {
3463         // Didn&#39;t find instance memory, search through general slice recursively.
3464         result = nmm-&gt;memory_at(_compile-&gt;get_general_index(ni));
3465         result = find_inst_mem(result, ni, orig_phis);
3466         if (_compile-&gt;failing()) {
3467           return;
3468         }
3469         nmm-&gt;set_memory_at(ni, result);
3470       }
3471     }
3472     igvn-&gt;hash_insert(nmm);
3473     record_for_optimizer(nmm);
3474   }
3475 
3476   //  Phase 4:  Update the inputs of non-instance memory Phis and
3477   //            the Memory input of memnodes
3478   // First update the inputs of any non-instance Phi&#39;s from
3479   // which we split out an instance Phi.  Note we don&#39;t have
3480   // to recursively process Phi&#39;s encountered on the input memory
3481   // chains as is done in split_memory_phi() since they will
3482   // also be processed here.
3483   for (int j = 0; j &lt; orig_phis.length(); j++) {
3484     PhiNode *phi = orig_phis.at(j);
3485     int alias_idx = _compile-&gt;get_alias_index(phi-&gt;adr_type());
3486     igvn-&gt;hash_delete(phi);
3487     for (uint i = 1; i &lt; phi-&gt;req(); i++) {
3488       Node *mem = phi-&gt;in(i);
3489       Node *new_mem = find_inst_mem(mem, alias_idx, orig_phis);
3490       if (_compile-&gt;failing()) {
3491         return;
3492       }
3493       if (mem != new_mem) {
3494         phi-&gt;set_req(i, new_mem);
3495       }
3496     }
3497     igvn-&gt;hash_insert(phi);
3498     record_for_optimizer(phi);
3499   }
3500 
3501   // Update the memory inputs of MemNodes with the value we computed
3502   // in Phase 2 and move stores memory users to corresponding memory slices.
3503   // Disable memory split verification code until the fix for 6984348.
3504   // Currently it produces false negative results since it does not cover all cases.
3505 #if 0 // ifdef ASSERT
3506   visited.Reset();
3507   Node_Stack old_mems(arena, _compile-&gt;unique() &gt;&gt; 2);
3508 #endif
3509   for (uint i = 0; i &lt; ideal_nodes.size(); i++) {
3510     Node*    n = ideal_nodes.at(i);
3511     Node* nmem = get_map(n-&gt;_idx);
3512     assert(nmem != NULL, &quot;sanity&quot;);
3513     if (n-&gt;is_Mem()) {
3514 #if 0 // ifdef ASSERT
3515       Node* old_mem = n-&gt;in(MemNode::Memory);
3516       if (!visited.test_set(old_mem-&gt;_idx)) {
3517         old_mems.push(old_mem, old_mem-&gt;outcnt());
3518       }
3519 #endif
3520       assert(n-&gt;in(MemNode::Memory) != nmem, &quot;sanity&quot;);
3521       if (!n-&gt;is_Load()) {
3522         // Move memory users of a store first.
3523         move_inst_mem(n, orig_phis);
3524       }
3525       // Now update memory input
3526       igvn-&gt;hash_delete(n);
3527       n-&gt;set_req(MemNode::Memory, nmem);
3528       igvn-&gt;hash_insert(n);
3529       record_for_optimizer(n);
3530     } else {
3531       assert(n-&gt;is_Allocate() || n-&gt;is_CheckCastPP() ||
3532              n-&gt;is_AddP() || n-&gt;is_Phi(), &quot;unknown node used for set_map()&quot;);
3533     }
3534   }
3535 #if 0 // ifdef ASSERT
3536   // Verify that memory was split correctly
3537   while (old_mems.is_nonempty()) {
3538     Node* old_mem = old_mems.node();
3539     uint  old_cnt = old_mems.index();
3540     old_mems.pop();
3541     assert(old_cnt == old_mem-&gt;outcnt(), &quot;old mem could be lost&quot;);
3542   }
3543 #endif
3544 }
3545 
3546 #ifndef PRODUCT
3547 static const char *node_type_names[] = {
3548   &quot;UnknownType&quot;,
3549   &quot;JavaObject&quot;,
3550   &quot;LocalVar&quot;,
3551   &quot;Field&quot;,
3552   &quot;Arraycopy&quot;
3553 };
3554 
3555 static const char *esc_names[] = {
3556   &quot;UnknownEscape&quot;,
3557   &quot;NoEscape&quot;,
3558   &quot;ArgEscape&quot;,
3559   &quot;GlobalEscape&quot;
3560 };
3561 
3562 void PointsToNode::dump(bool print_state) const {
3563   NodeType nt = node_type();
3564   tty-&gt;print(&quot;%s &quot;, node_type_names[(int) nt]);
3565   if (print_state) {
3566     EscapeState es = escape_state();
3567     EscapeState fields_es = fields_escape_state();
3568     tty-&gt;print(&quot;%s(%s) &quot;, esc_names[(int)es], esc_names[(int)fields_es]);
3569     if (nt == PointsToNode::JavaObject &amp;&amp; !this-&gt;scalar_replaceable())
3570       tty-&gt;print(&quot;NSR &quot;);
3571   }
3572   if (is_Field()) {
3573     FieldNode* f = (FieldNode*)this;
3574     if (f-&gt;is_oop())
3575       tty-&gt;print(&quot;oop &quot;);
3576     if (f-&gt;offset() &gt; 0)
3577       tty-&gt;print(&quot;+%d &quot;, f-&gt;offset());
3578     tty-&gt;print(&quot;(&quot;);
3579     for (BaseIterator i(f); i.has_next(); i.next()) {
3580       PointsToNode* b = i.get();
3581       tty-&gt;print(&quot; %d%s&quot;, b-&gt;idx(),(b-&gt;is_JavaObject() ? &quot;P&quot; : &quot;&quot;));
3582     }
3583     tty-&gt;print(&quot; )&quot;);
3584   }
3585   tty-&gt;print(&quot;[&quot;);
3586   for (EdgeIterator i(this); i.has_next(); i.next()) {
3587     PointsToNode* e = i.get();
3588     tty-&gt;print(&quot; %d%s%s&quot;, e-&gt;idx(),(e-&gt;is_JavaObject() ? &quot;P&quot; : (e-&gt;is_Field() ? &quot;F&quot; : &quot;&quot;)), e-&gt;is_Arraycopy() ? &quot;cp&quot; : &quot;&quot;);
3589   }
3590   tty-&gt;print(&quot; [&quot;);
3591   for (UseIterator i(this); i.has_next(); i.next()) {
3592     PointsToNode* u = i.get();
3593     bool is_base = false;
3594     if (PointsToNode::is_base_use(u)) {
3595       is_base = true;
3596       u = PointsToNode::get_use_node(u)-&gt;as_Field();
3597     }
3598     tty-&gt;print(&quot; %d%s%s&quot;, u-&gt;idx(), is_base ? &quot;b&quot; : &quot;&quot;, u-&gt;is_Arraycopy() ? &quot;cp&quot; : &quot;&quot;);
3599   }
3600   tty-&gt;print(&quot; ]]  &quot;);
3601   if (_node == NULL)
3602     tty-&gt;print_cr(&quot;&lt;null&gt;&quot;);
3603   else
3604     _node-&gt;dump();
3605 }
3606 
3607 void ConnectionGraph::dump(GrowableArray&lt;PointsToNode*&gt;&amp; ptnodes_worklist) {
3608   bool first = true;
3609   int ptnodes_length = ptnodes_worklist.length();
3610   for (int i = 0; i &lt; ptnodes_length; i++) {
3611     PointsToNode *ptn = ptnodes_worklist.at(i);
3612     if (ptn == NULL || !ptn-&gt;is_JavaObject())
3613       continue;
3614     PointsToNode::EscapeState es = ptn-&gt;escape_state();
3615     if ((es != PointsToNode::NoEscape) &amp;&amp; !Verbose) {
3616       continue;
3617     }
3618     Node* n = ptn-&gt;ideal_node();
3619     if (n-&gt;is_Allocate() || (n-&gt;is_CallStaticJava() &amp;&amp;
3620                              n-&gt;as_CallStaticJava()-&gt;is_boxing_method())) {
3621       if (first) {
3622         tty-&gt;cr();
3623         tty-&gt;print(&quot;======== Connection graph for &quot;);
3624         _compile-&gt;method()-&gt;print_short_name();
3625         tty-&gt;cr();
3626         first = false;
3627       }
3628       ptn-&gt;dump();
3629       // Print all locals and fields which reference this allocation
3630       for (UseIterator j(ptn); j.has_next(); j.next()) {
3631         PointsToNode* use = j.get();
3632         if (use-&gt;is_LocalVar()) {
3633           use-&gt;dump(Verbose);
3634         } else if (Verbose) {
3635           use-&gt;dump();
3636         }
3637       }
3638       tty-&gt;cr();
3639     }
3640   }
3641 }
3642 #endif
3643 
3644 void ConnectionGraph::record_for_optimizer(Node *n) {
3645   _igvn-&gt;_worklist.push(n);
3646   _igvn-&gt;add_users_to_worklist(n);
3647 }
    </pre>
  </body>
</html>