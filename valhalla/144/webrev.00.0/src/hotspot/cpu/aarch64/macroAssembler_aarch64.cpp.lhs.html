<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &lt;sys/types.h&gt;
  27 
  28 #include &quot;precompiled.hpp&quot;
  29 #include &quot;jvm.h&quot;
  30 #include &quot;asm/assembler.hpp&quot;
  31 #include &quot;asm/assembler.inline.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;gc/shared/cardTable.hpp&quot;
  34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  35 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;compiler/disassembler.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/accessDecorators.hpp&quot;
  42 #include &quot;oops/compressedOops.inline.hpp&quot;
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/signature_cc.hpp&quot;
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
  52 #ifdef COMPILER1
  53 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  54 #endif
  55 #ifdef COMPILER2
  56 #include &quot;oops/oop.hpp&quot;
  57 #include &quot;opto/compile.hpp&quot;
  58 #include &quot;opto/node.hpp&quot;
  59 #include &quot;opto/output.hpp&quot;
  60 #endif
  61 
  62 #ifdef PRODUCT
  63 #define BLOCK_COMMENT(str) /* nothing */
  64 #else
  65 #define BLOCK_COMMENT(str) block_comment(str)
  66 #endif
  67 #define STOP(str) stop(str);
  68 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  69 
  70 // Patch any kind of instruction; there may be several instructions.
  71 // Return the total length (in bytes) of the instructions.
  72 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  73   int instructions = 1;
  74   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  75   long offset = (target - branch) &gt;&gt; 2;
  76   unsigned insn = *(unsigned*)branch;
  77   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
  78     // Load register (literal)
  79     Instruction_aarch64::spatch(branch, 23, 5, offset);
  80   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
  81     // Unconditional branch (immediate)
  82     Instruction_aarch64::spatch(branch, 25, 0, offset);
  83   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
  84     // Conditional branch (immediate)
  85     Instruction_aarch64::spatch(branch, 23, 5, offset);
  86   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
  87     // Compare &amp; branch (immediate)
  88     Instruction_aarch64::spatch(branch, 23, 5, offset);
  89   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
  90     // Test &amp; branch (immediate)
  91     Instruction_aarch64::spatch(branch, 18, 5, offset);
  92   } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
  93     // PC-rel. addressing
  94     offset = target-branch;
  95     int shift = Instruction_aarch64::extract(insn, 31, 31);
  96     if (shift) {
  97       u_int64_t dest = (u_int64_t)target;
  98       uint64_t pc_page = (uint64_t)branch &gt;&gt; 12;
  99       uint64_t adr_page = (uint64_t)target &gt;&gt; 12;
 100       unsigned offset_lo = dest &amp; 0xfff;
 101       offset = adr_page - pc_page;
 102 
 103       // We handle 4 types of PC relative addressing
 104       //   1 - adrp    Rx, target_page
 105       //       ldr/str Ry, [Rx, #offset_in_page]
 106       //   2 - adrp    Rx, target_page
 107       //       add     Ry, Rx, #offset_in_page
 108       //   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 109       //       movk    Rx, #imm16&lt;&lt;32
 110       //   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 111       // In the first 3 cases we must check that Rx is the same in the adrp and the
 112       // subsequent ldr/str, add or movk instruction. Otherwise we could accidentally end
 113       // up treating a type 4 relocation as a type 1, 2 or 3 just because it happened
 114       // to be followed by a random unrelated ldr/str, add or movk instruction.
 115       //
 116       unsigned insn2 = ((unsigned*)branch)[1];
 117       if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &amp;&amp;
 118                 Instruction_aarch64::extract(insn, 4, 0) ==
 119                         Instruction_aarch64::extract(insn2, 9, 5)) {
 120         // Load/store register (unsigned immediate)
 121         unsigned size = Instruction_aarch64::extract(insn2, 31, 30);
 122         Instruction_aarch64::patch(branch + sizeof (unsigned),
 123                                     21, 10, offset_lo &gt;&gt; size);
 124         guarantee(((dest &gt;&gt; size) &lt;&lt; size) == dest, &quot;misaligned target&quot;);
 125         instructions = 2;
 126       } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &amp;&amp;
 127                 Instruction_aarch64::extract(insn, 4, 0) ==
 128                         Instruction_aarch64::extract(insn2, 4, 0)) {
 129         // add (immediate)
 130         Instruction_aarch64::patch(branch + sizeof (unsigned),
 131                                    21, 10, offset_lo);
 132         instructions = 2;
 133       } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &amp;&amp;
 134                    Instruction_aarch64::extract(insn, 4, 0) ==
 135                      Instruction_aarch64::extract(insn2, 4, 0)) {
 136         // movk #imm16&lt;&lt;32
 137         Instruction_aarch64::patch(branch + 4, 20, 5, (uint64_t)target &gt;&gt; 32);
 138         long dest = ((long)target &amp; 0xffffffffL) | ((long)branch &amp; 0xffff00000000L);
 139         long pc_page = (long)branch &gt;&gt; 12;
 140         long adr_page = (long)dest &gt;&gt; 12;
 141         offset = adr_page - pc_page;
 142         instructions = 2;
 143       }
 144     }
 145     int offset_lo = offset &amp; 3;
 146     offset &gt;&gt;= 2;
 147     Instruction_aarch64::spatch(branch, 23, 5, offset);
 148     Instruction_aarch64::patch(branch, 30, 29, offset_lo);
 149   } else if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100) {
 150     u_int64_t dest = (u_int64_t)target;
 151     // Move wide constant
 152     assert(nativeInstruction_at(branch+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 153     assert(nativeInstruction_at(branch+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 154     Instruction_aarch64::patch(branch, 20, 5, dest &amp; 0xffff);
 155     Instruction_aarch64::patch(branch+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 156     Instruction_aarch64::patch(branch+8, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 157     assert(target_addr_for_insn(branch) == target, &quot;should be&quot;);
 158     instructions = 3;
 159   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 160              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 161     // nothing to do
 162     assert(target == 0, &quot;did not expect to relocate target for polling page load&quot;);
 163   } else {
 164     ShouldNotReachHere();
 165   }
 166   return instructions * NativeInstruction::instruction_size;
 167 }
 168 
 169 int MacroAssembler::patch_oop(address insn_addr, address o) {
 170   int instructions;
 171   unsigned insn = *(unsigned*)insn_addr;
 172   assert(nativeInstruction_at(insn_addr+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 173 
 174   // OOPs are either narrow (32 bits) or wide (48 bits).  We encode
 175   // narrow OOPs by setting the upper 16 bits in the first
 176   // instruction.
 177   if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010101) {
 178     // Move narrow OOP
 179     narrowOop n = CompressedOops::encode((oop)o);
 180     Instruction_aarch64::patch(insn_addr, 20, 5, n &gt;&gt; 16);
 181     Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
 182     instructions = 2;
 183   } else {
 184     // Move wide OOP
 185     assert(nativeInstruction_at(insn_addr+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 186     uintptr_t dest = (uintptr_t)o;
 187     Instruction_aarch64::patch(insn_addr, 20, 5, dest &amp; 0xffff);
 188     Instruction_aarch64::patch(insn_addr+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 189     Instruction_aarch64::patch(insn_addr+8, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 190     instructions = 3;
 191   }
 192   return instructions * NativeInstruction::instruction_size;
 193 }
 194 
 195 int MacroAssembler::patch_narrow_klass(address insn_addr, narrowKlass n) {
 196   // Metatdata pointers are either narrow (32 bits) or wide (48 bits).
 197   // We encode narrow ones by setting the upper 16 bits in the first
 198   // instruction.
 199   NativeInstruction *insn = nativeInstruction_at(insn_addr);
 200   assert(Instruction_aarch64::extract(insn-&gt;encoding(), 31, 21) == 0b11010010101 &amp;&amp;
 201          nativeInstruction_at(insn_addr+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 202 
 203   Instruction_aarch64::patch(insn_addr, 20, 5, n &gt;&gt; 16);
 204   Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
 205   return 2 * NativeInstruction::instruction_size;
 206 }
 207 
 208 address MacroAssembler::target_addr_for_insn(address insn_addr, unsigned insn) {
 209   long offset = 0;
 210   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b011011) == 0b00011000) {
 211     // Load register (literal)
 212     offset = Instruction_aarch64::sextract(insn, 23, 5);
 213     return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 214   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
 215     // Unconditional branch (immediate)
 216     offset = Instruction_aarch64::sextract(insn, 25, 0);
 217   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
 218     // Conditional branch (immediate)
 219     offset = Instruction_aarch64::sextract(insn, 23, 5);
 220   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
 221     // Compare &amp; branch (immediate)
 222     offset = Instruction_aarch64::sextract(insn, 23, 5);
 223    } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
 224     // Test &amp; branch (immediate)
 225     offset = Instruction_aarch64::sextract(insn, 18, 5);
 226   } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
 227     // PC-rel. addressing
 228     offset = Instruction_aarch64::extract(insn, 30, 29);
 229     offset |= Instruction_aarch64::sextract(insn, 23, 5) &lt;&lt; 2;
 230     int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;
 231     if (shift) {
 232       offset &lt;&lt;= shift;
 233       uint64_t target_page = ((uint64_t)insn_addr) + offset;
 234       target_page &amp;= ((uint64_t)-1) &lt;&lt; shift;
 235       // Return the target address for the following sequences
 236       //   1 - adrp    Rx, target_page
 237       //       ldr/str Ry, [Rx, #offset_in_page]
 238       //   2 - adrp    Rx, target_page
 239       //       add     Ry, Rx, #offset_in_page
 240       //   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 241       //       movk    Rx, #imm12&lt;&lt;32
 242       //   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 243       //
 244       // In the first two cases  we check that the register is the same and
 245       // return the target_page + the offset within the page.
 246       // Otherwise we assume it is a page aligned relocation and return
 247       // the target page only.
 248       //
 249       unsigned insn2 = ((unsigned*)insn_addr)[1];
 250       if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &amp;&amp;
 251                 Instruction_aarch64::extract(insn, 4, 0) ==
 252                         Instruction_aarch64::extract(insn2, 9, 5)) {
 253         // Load/store register (unsigned immediate)
 254         unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);
 255         unsigned int size = Instruction_aarch64::extract(insn2, 31, 30);
 256         return address(target_page + (byte_offset &lt;&lt; size));
 257       } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &amp;&amp;
 258                 Instruction_aarch64::extract(insn, 4, 0) ==
 259                         Instruction_aarch64::extract(insn2, 4, 0)) {
 260         // add (immediate)
 261         unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);
 262         return address(target_page + byte_offset);
 263       } else {
 264         if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110  &amp;&amp;
 265                Instruction_aarch64::extract(insn, 4, 0) ==
 266                  Instruction_aarch64::extract(insn2, 4, 0)) {
 267           target_page = (target_page &amp; 0xffffffff) |
 268                          ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) &lt;&lt; 32);
 269         }
 270         return (address)target_page;
 271       }
 272     } else {
 273       ShouldNotReachHere();
 274     }
 275   } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
 276     u_int32_t *insns = (u_int32_t *)insn_addr;
 277     // Move wide constant: movz, movk, movk.  See movptr().
 278     assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 279     assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 280     return address(u_int64_t(Instruction_aarch64::extract(insns[0], 20, 5))
 281                    + (u_int64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)
 282                    + (u_int64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));
 283   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 284              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 285     return 0;
 286   } else {
 287     ShouldNotReachHere();
 288   }
 289   return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 290 }
 291 
 292 void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
 293   ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));
 294   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
 295 }
 296 
 297 // Just like safepoint_poll, but use an acquiring load for thread-
 298 // local polling.
 299 //
 300 // We need an acquire here to ensure that any subsequent load of the
 301 // global SafepointSynchronize::_state flag is ordered after this load
 302 // of the local Thread::_polling page.  We don&#39;t want this poll to
 303 // return false (i.e. not safepointing) and a later poll of the global
 304 // SafepointSynchronize::_state spuriously to return true.
 305 //
 306 // This is to avoid a race when we&#39;re in a native-&gt;Java transition
 307 // racing the code which wakes up from a safepoint.
 308 //
 309 void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
 310   lea(rscratch1, Address(rthread, Thread::polling_page_offset()));
 311   ldar(rscratch1, rscratch1);
 312   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
 313 }
 314 
 315 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 316   // we must set sp to zero to clear frame
 317   str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
 318 
 319   // must clear fp, so that compiled frames are not confused; it is
 320   // possible that we need it only for debugging
 321   if (clear_fp) {
 322     str(zr, Address(rthread, JavaThread::last_Java_fp_offset()));
 323   }
 324 
 325   // Always clear the pc because it could have been set by make_walkable()
 326   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 327 }
 328 
 329 // Calls to C land
 330 //
 331 // When entering C land, the rfp, &amp; resp of the last Java frame have to be recorded
 332 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
 333 // has to be reset to 0. This is required to allow proper stack traversal.
 334 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 335                                          Register last_java_fp,
 336                                          Register last_java_pc,
 337                                          Register scratch) {
 338 
 339   if (last_java_pc-&gt;is_valid()) {
 340       str(last_java_pc, Address(rthread,
 341                                 JavaThread::frame_anchor_offset()
 342                                 + JavaFrameAnchor::last_Java_pc_offset()));
 343     }
 344 
 345   // determine last_java_sp register
 346   if (last_java_sp == sp) {
 347     mov(scratch, sp);
 348     last_java_sp = scratch;
 349   } else if (!last_java_sp-&gt;is_valid()) {
 350     last_java_sp = esp;
 351   }
 352 
 353   str(last_java_sp, Address(rthread, JavaThread::last_Java_sp_offset()));
 354 
 355   // last_java_fp is optional
 356   if (last_java_fp-&gt;is_valid()) {
 357     str(last_java_fp, Address(rthread, JavaThread::last_Java_fp_offset()));
 358   }
 359 }
 360 
 361 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 362                                          Register last_java_fp,
 363                                          address  last_java_pc,
 364                                          Register scratch) {
 365   assert(last_java_pc != NULL, &quot;must provide a valid PC&quot;);
 366 
 367   adr(scratch, last_java_pc);
 368   str(scratch, Address(rthread,
 369                        JavaThread::frame_anchor_offset()
 370                        + JavaFrameAnchor::last_Java_pc_offset()));
 371 
 372   set_last_Java_frame(last_java_sp, last_java_fp, noreg, scratch);
 373 }
 374 
 375 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 376                                          Register last_java_fp,
 377                                          Label &amp;L,
 378                                          Register scratch) {
 379   if (L.is_bound()) {
 380     set_last_Java_frame(last_java_sp, last_java_fp, target(L), scratch);
 381   } else {
 382     InstructionMark im(this);
 383     L.add_patch_at(code(), locator());
 384     set_last_Java_frame(last_java_sp, last_java_fp, pc() /* Patched later */, scratch);
 385   }
 386 }
 387 
 388 void MacroAssembler::far_call(Address entry, CodeBuffer *cbuf, Register tmp) {
 389   assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
 390   assert(CodeCache::find_blob(entry.target()) != NULL,
 391          &quot;destination of far call not found in code cache&quot;);
 392   if (far_branches()) {
 393     unsigned long offset;
 394     // We can use ADRP here because we know that the total size of
 395     // the code cache cannot exceed 2Gb.
 396     adrp(tmp, entry, offset);
 397     add(tmp, tmp, offset);
 398     if (cbuf) cbuf-&gt;set_insts_mark();
 399     blr(tmp);
 400   } else {
 401     if (cbuf) cbuf-&gt;set_insts_mark();
 402     bl(entry);
 403   }
 404 }
 405 
 406 void MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {
 407   assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
 408   assert(CodeCache::find_blob(entry.target()) != NULL,
 409          &quot;destination of far call not found in code cache&quot;);
 410   if (far_branches()) {
 411     unsigned long offset;
 412     // We can use ADRP here because we know that the total size of
 413     // the code cache cannot exceed 2Gb.
 414     adrp(tmp, entry, offset);
 415     add(tmp, tmp, offset);
 416     if (cbuf) cbuf-&gt;set_insts_mark();
 417     br(tmp);
 418   } else {
 419     if (cbuf) cbuf-&gt;set_insts_mark();
 420     b(entry);
 421   }
 422 }
 423 
 424 void MacroAssembler::reserved_stack_check() {
 425     // testing if reserved zone needs to be enabled
 426     Label no_reserved_zone_enabling;
 427 
 428     ldr(rscratch1, Address(rthread, JavaThread::reserved_stack_activation_offset()));
 429     cmp(sp, rscratch1);
 430     br(Assembler::LO, no_reserved_zone_enabling);
 431 
 432     enter();   // LR and FP are live.
 433     lea(rscratch1, CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone));
 434     mov(c_rarg0, rthread);
 435     blr(rscratch1);
 436     leave();
 437 
 438     // We have already removed our own frame.
 439     // throw_delayed_StackOverflowError will think that it&#39;s been
 440     // called by our caller.
 441     lea(rscratch1, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
 442     br(rscratch1);
 443     should_not_reach_here();
 444 
 445     bind(no_reserved_zone_enabling);
 446 }
 447 
 448 int MacroAssembler::biased_locking_enter(Register lock_reg,
 449                                          Register obj_reg,
 450                                          Register swap_reg,
 451                                          Register tmp_reg,
 452                                          bool swap_reg_contains_mark,
 453                                          Label&amp; done,
 454                                          Label* slow_case,
 455                                          BiasedLockingCounters* counters) {
 456   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 457   assert_different_registers(lock_reg, obj_reg, swap_reg);
 458 
 459   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL)
 460     counters = BiasedLocking::counters();
 461 
 462   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);
 463   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
 464   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
 465   Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());
 466   Address saved_mark_addr(lock_reg, 0);
 467 
 468   // Biased locking
 469   // See whether the lock is currently biased toward our thread and
 470   // whether the epoch is still valid
 471   // Note that the runtime guarantees sufficient alignment of JavaThread
 472   // pointers to allow age to be placed into low bits
 473   // First check to see whether biasing is even enabled for this object
 474   Label cas_label;
 475   int null_check_offset = -1;
 476   if (!swap_reg_contains_mark) {
 477     null_check_offset = offset();
 478     ldr(swap_reg, mark_addr);
 479   }
 480   andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);
 481   cmp(tmp_reg, (u1)markWord::biased_lock_pattern);
 482   br(Assembler::NE, cas_label);
 483   // The bias pattern is present in the object&#39;s header. Need to check
 484   // whether the bias owner and the epoch are both still current.
 485   load_prototype_header(tmp_reg, obj_reg);
 486   orr(tmp_reg, tmp_reg, rthread);
 487   eor(tmp_reg, swap_reg, tmp_reg);
 488   andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));
 489   if (counters != NULL) {
 490     Label around;
 491     cbnz(tmp_reg, around);
 492     atomic_incw(Address((address)counters-&gt;biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);
 493     b(done);
 494     bind(around);
 495   } else {
 496     cbz(tmp_reg, done);
 497   }
 498 
 499   Label try_revoke_bias;
 500   Label try_rebias;
 501 
 502   // At this point we know that the header has the bias pattern and
 503   // that we are not the bias owner in the current epoch. We need to
 504   // figure out more details about the state of the header in order to
 505   // know what operations can be legally performed on the object&#39;s
 506   // header.
 507 
 508   // If the low three bits in the xor result aren&#39;t clear, that means
 509   // the prototype header is no longer biased and we have to revoke
 510   // the bias on this object.
 511   andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);
 512   cbnz(rscratch1, try_revoke_bias);
 513 
 514   // Biasing is still enabled for this data type. See whether the
 515   // epoch of the current bias is still valid, meaning that the epoch
 516   // bits of the mark word are equal to the epoch bits of the
 517   // prototype header. (Note that the prototype header&#39;s epoch bits
 518   // only change at a safepoint.) If not, attempt to rebias the object
 519   // toward the current thread. Note that we must be absolutely sure
 520   // that the current epoch is invalid in order to do this because
 521   // otherwise the manipulations it performs on the mark word are
 522   // illegal.
 523   andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);
 524   cbnz(rscratch1, try_rebias);
 525 
 526   // The epoch of the current bias is still valid but we know nothing
 527   // about the owner; it might be set or it might be clear. Try to
 528   // acquire the bias of the object using an atomic operation. If this
 529   // fails we will go in to the runtime to revoke the object&#39;s bias.
 530   // Note that we first construct the presumed unbiased header so we
 531   // don&#39;t accidentally blow away another thread&#39;s valid bias.
 532   {
 533     Label here;
 534     mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
 535     andr(swap_reg, swap_reg, rscratch1);
 536     orr(tmp_reg, swap_reg, rthread);
 537     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);
 538     // If the biasing toward our thread failed, this means that
 539     // another thread succeeded in biasing it toward itself and we
 540     // need to revoke that bias. The revocation will occur in the
 541     // interpreter runtime in the slow case.
 542     bind(here);
 543     if (counters != NULL) {
 544       atomic_incw(Address((address)counters-&gt;anonymously_biased_lock_entry_count_addr()),
 545                   tmp_reg, rscratch1, rscratch2);
 546     }
 547   }
 548   b(done);
 549 
 550   bind(try_rebias);
 551   // At this point we know the epoch has expired, meaning that the
 552   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
 553   // circumstances _only_, we are allowed to use the current header&#39;s
 554   // value as the comparison value when doing the cas to acquire the
 555   // bias in the current epoch. In other words, we allow transfer of
 556   // the bias from one thread to another directly in this situation.
 557   //
 558   // FIXME: due to a lack of registers we currently blow away the age
 559   // bits in this situation. Should attempt to preserve them.
 560   {
 561     Label here;
 562     load_prototype_header(tmp_reg, obj_reg);
 563     orr(tmp_reg, rthread, tmp_reg);
 564     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);
 565     // If the biasing toward our thread failed, then another thread
 566     // succeeded in biasing it toward itself and we need to revoke that
 567     // bias. The revocation will occur in the runtime in the slow case.
 568     bind(here);
 569     if (counters != NULL) {
 570       atomic_incw(Address((address)counters-&gt;rebiased_lock_entry_count_addr()),
 571                   tmp_reg, rscratch1, rscratch2);
 572     }
 573   }
 574   b(done);
 575 
 576   bind(try_revoke_bias);
 577   // The prototype mark in the klass doesn&#39;t have the bias bit set any
 578   // more, indicating that objects of this data type are not supposed
 579   // to be biased any more. We are going to try to reset the mark of
 580   // this object to the prototype value and fall through to the
 581   // CAS-based locking scheme. Note that if our CAS fails, it means
 582   // that another thread raced us for the privilege of revoking the
 583   // bias of this particular object, so it&#39;s okay to continue in the
 584   // normal locking code.
 585   //
 586   // FIXME: due to a lack of registers we currently blow away the age
 587   // bits in this situation. Should attempt to preserve them.
 588   {
 589     Label here, nope;
 590     load_prototype_header(tmp_reg, obj_reg);
 591     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &amp;nope);
 592     bind(here);
 593 
 594     // Fall through to the normal CAS-based lock, because no matter what
 595     // the result of the above CAS, some thread must have succeeded in
 596     // removing the bias bit from the object&#39;s header.
 597     if (counters != NULL) {
 598       atomic_incw(Address((address)counters-&gt;revoked_lock_entry_count_addr()), tmp_reg,
 599                   rscratch1, rscratch2);
 600     }
 601     bind(nope);
 602   }
 603 
 604   bind(cas_label);
 605 
 606   return null_check_offset;
 607 }
 608 
 609 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 610   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 611 
 612   // Check for biased locking unlock case, which is a no-op
 613   // Note: we do not have to check the thread ID for two reasons.
 614   // First, the interpreter checks for IllegalMonitorStateException at
 615   // a higher level. Second, if the bias was revoked while we held the
 616   // lock, the object could not be rebiased toward another thread, so
 617   // the bias bit would be clear.
 618   ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 619   andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);
 620   cmp(temp_reg, (u1)markWord::biased_lock_pattern);
 621   br(Assembler::EQ, done);
 622 }
 623 
 624 static void pass_arg0(MacroAssembler* masm, Register arg) {
 625   if (c_rarg0 != arg ) {
 626     masm-&gt;mov(c_rarg0, arg);
 627   }
 628 }
 629 
 630 static void pass_arg1(MacroAssembler* masm, Register arg) {
 631   if (c_rarg1 != arg ) {
 632     masm-&gt;mov(c_rarg1, arg);
 633   }
 634 }
 635 
 636 static void pass_arg2(MacroAssembler* masm, Register arg) {
 637   if (c_rarg2 != arg ) {
 638     masm-&gt;mov(c_rarg2, arg);
 639   }
 640 }
 641 
 642 static void pass_arg3(MacroAssembler* masm, Register arg) {
 643   if (c_rarg3 != arg ) {
 644     masm-&gt;mov(c_rarg3, arg);
 645   }
 646 }
 647 
 648 void MacroAssembler::call_VM_base(Register oop_result,
 649                                   Register java_thread,
 650                                   Register last_java_sp,
 651                                   address  entry_point,
 652                                   int      number_of_arguments,
 653                                   bool     check_exceptions) {
 654    // determine java_thread register
 655   if (!java_thread-&gt;is_valid()) {
 656     java_thread = rthread;
 657   }
 658 
 659   // determine last_java_sp register
 660   if (!last_java_sp-&gt;is_valid()) {
 661     last_java_sp = esp;
 662   }
 663 
 664   // debugging support
 665   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 666   assert(java_thread == rthread, &quot;unexpected register&quot;);
 667 #ifdef ASSERT
 668   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
 669   // if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);
 670 #endif // ASSERT
 671 
 672   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
 673   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
 674 
 675   // push java thread (becomes first argument of C function)
 676 
 677   mov(c_rarg0, java_thread);
 678 
 679   // set last Java frame before call
 680   assert(last_java_sp != rfp, &quot;can&#39;t use rfp&quot;);
 681 
 682   Label l;
 683   set_last_Java_frame(last_java_sp, rfp, l, rscratch1);
 684 
 685   // do the call, remove parameters
 686   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments, &amp;l);
 687 
 688   // reset last Java frame
 689   // Only interpreter should have to clear fp
 690   reset_last_Java_frame(true);
 691 
 692    // C++ interp handles this in the interpreter
 693   check_and_handle_popframe(java_thread);
 694   check_and_handle_earlyret(java_thread);
 695 
 696   if (check_exceptions) {
 697     // check for pending exceptions (java_thread is set upon return)
 698     ldr(rscratch1, Address(java_thread, in_bytes(Thread::pending_exception_offset())));
 699     Label ok;
 700     cbz(rscratch1, ok);
 701     lea(rscratch1, RuntimeAddress(StubRoutines::forward_exception_entry()));
 702     br(rscratch1);
 703     bind(ok);
 704   }
 705 
 706   // get oop result if there is one and reset the value in the thread
 707   if (oop_result-&gt;is_valid()) {
 708     get_vm_result(oop_result, java_thread);
 709   }
 710 }
 711 
 712 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 713   call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);
 714 }
 715 
 716 // Maybe emit a call via a trampoline.  If the code cache is small
 717 // trampolines won&#39;t be emitted.
 718 
 719 address MacroAssembler::trampoline_call(Address entry, CodeBuffer *cbuf) {
 720   assert(JavaThread::current()-&gt;is_Compiler_thread(), &quot;just checking&quot;);
 721   assert(entry.rspec().type() == relocInfo::runtime_call_type
 722          || entry.rspec().type() == relocInfo::opt_virtual_call_type
 723          || entry.rspec().type() == relocInfo::static_call_type
 724          || entry.rspec().type() == relocInfo::virtual_call_type, &quot;wrong reloc type&quot;);
 725 
 726   // We need a trampoline if branches are far.
 727   if (far_branches()) {
 728     bool in_scratch_emit_size = false;
 729 #ifdef COMPILER2
 730     // We don&#39;t want to emit a trampoline if C2 is generating dummy
 731     // code during its branch shortening phase.
 732     CompileTask* task = ciEnv::current()-&gt;task();
 733     in_scratch_emit_size =
 734       (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
 735        Compile::current()-&gt;output()-&gt;in_scratch_emit_size());
 736 #endif
 737     if (!in_scratch_emit_size) {
 738       address stub = emit_trampoline_stub(offset(), entry.target());
 739       if (stub == NULL) {
 740         return NULL; // CodeCache is full
 741       }
 742     }
 743   }
 744 
 745   if (cbuf) cbuf-&gt;set_insts_mark();
 746   relocate(entry.rspec());
 747   if (!far_branches()) {
 748     bl(entry.target());
 749   } else {
 750     bl(pc());
 751   }
 752   // just need to return a non-null address
 753   return pc();
 754 }
 755 
 756 
 757 // Emit a trampoline stub for a call to a target which is too far away.
 758 //
 759 // code sequences:
 760 //
 761 // call-site:
 762 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 763 //
 764 // Related trampoline stub for this call site in the stub section:
 765 //   load the call target from the constant pool
 766 //   branch (LR still points to the call site above)
 767 
 768 address MacroAssembler::emit_trampoline_stub(int insts_call_instruction_offset,
 769                                              address dest) {
 770   // Max stub size: alignment nop, TrampolineStub.
 771   address stub = start_a_stub(NativeInstruction::instruction_size
 772                    + NativeCallTrampolineStub::instruction_size);
 773   if (stub == NULL) {
 774     return NULL;  // CodeBuffer::expand failed
 775   }
 776 
 777   // Create a trampoline stub relocation which relates this trampoline stub
 778   // with the call instruction at insts_call_instruction_offset in the
 779   // instructions code-section.
 780   align(wordSize);
 781   relocate(trampoline_stub_Relocation::spec(code()-&gt;insts()-&gt;start()
 782                                             + insts_call_instruction_offset));
 783   const int stub_start_offset = offset();
 784 
 785   // Now, create the trampoline stub&#39;s code:
 786   // - load the call
 787   // - call
 788   Label target;
 789   ldr(rscratch1, target);
 790   br(rscratch1);
 791   bind(target);
 792   assert(offset() - stub_start_offset == NativeCallTrampolineStub::data_offset,
 793          &quot;should be&quot;);
 794   emit_int64((int64_t)dest);
 795 
 796   const address stub_start_addr = addr_at(stub_start_offset);
 797 
 798   assert(is_NativeCallTrampolineStub_at(stub_start_addr), &quot;doesn&#39;t look like a trampoline&quot;);
 799 
 800   end_a_stub();
 801   return stub_start_addr;
 802 }
 803 
 804 void MacroAssembler::emit_static_call_stub() {
 805   // CompiledDirectStaticCall::set_to_interpreted knows the
 806   // exact layout of this stub.
 807 
 808   isb();
 809   mov_metadata(rmethod, (Metadata*)NULL);
 810 
 811   // Jump to the entry point of the i2c stub.
 812   movptr(rscratch1, 0);
 813   br(rscratch1);
 814 }
 815 
 816 void MacroAssembler::c2bool(Register x) {
 817   // implements x == 0 ? 0 : 1
 818   // note: must only look at least-significant byte of x
 819   //       since C-style booleans are stored in one byte
 820   //       only! (was bug)
 821   tst(x, 0xff);
 822   cset(x, Assembler::NE);
 823 }
 824 
 825 address MacroAssembler::ic_call(address entry, jint method_index) {
 826   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
 827   // address const_ptr = long_constant((jlong)Universe::non_oop_word());
 828   // unsigned long offset;
 829   // ldr_constant(rscratch2, const_ptr);
 830   movptr(rscratch2, (uintptr_t)Universe::non_oop_word());
 831   return trampoline_call(Address(entry, rh));
 832 }
 833 
 834 // Implementation of call_VM versions
 835 
 836 void MacroAssembler::call_VM(Register oop_result,
 837                              address entry_point,
 838                              bool check_exceptions) {
 839   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
 840 }
 841 
 842 void MacroAssembler::call_VM(Register oop_result,
 843                              address entry_point,
 844                              Register arg_1,
 845                              bool check_exceptions) {
 846   pass_arg1(this, arg_1);
 847   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
 848 }
 849 
 850 void MacroAssembler::call_VM(Register oop_result,
 851                              address entry_point,
 852                              Register arg_1,
 853                              Register arg_2,
 854                              bool check_exceptions) {
 855   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 856   pass_arg2(this, arg_2);
 857   pass_arg1(this, arg_1);
 858   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
 859 }
 860 
 861 void MacroAssembler::call_VM(Register oop_result,
 862                              address entry_point,
 863                              Register arg_1,
 864                              Register arg_2,
 865                              Register arg_3,
 866                              bool check_exceptions) {
 867   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
 868   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
 869   pass_arg3(this, arg_3);
 870 
 871   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 872   pass_arg2(this, arg_2);
 873 
 874   pass_arg1(this, arg_1);
 875   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
 876 }
 877 
 878 void MacroAssembler::call_VM(Register oop_result,
 879                              Register last_java_sp,
 880                              address entry_point,
 881                              int number_of_arguments,
 882                              bool check_exceptions) {
 883   call_VM_base(oop_result, rthread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 884 }
 885 
 886 void MacroAssembler::call_VM(Register oop_result,
 887                              Register last_java_sp,
 888                              address entry_point,
 889                              Register arg_1,
 890                              bool check_exceptions) {
 891   pass_arg1(this, arg_1);
 892   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 893 }
 894 
 895 void MacroAssembler::call_VM(Register oop_result,
 896                              Register last_java_sp,
 897                              address entry_point,
 898                              Register arg_1,
 899                              Register arg_2,
 900                              bool check_exceptions) {
 901 
 902   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 903   pass_arg2(this, arg_2);
 904   pass_arg1(this, arg_1);
 905   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 906 }
 907 
 908 void MacroAssembler::call_VM(Register oop_result,
 909                              Register last_java_sp,
 910                              address entry_point,
 911                              Register arg_1,
 912                              Register arg_2,
 913                              Register arg_3,
 914                              bool check_exceptions) {
 915   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
 916   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
 917   pass_arg3(this, arg_3);
 918   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 919   pass_arg2(this, arg_2);
 920   pass_arg1(this, arg_1);
 921   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 922 }
 923 
 924 
 925 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
 926   ldr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
 927   str(zr, Address(java_thread, JavaThread::vm_result_offset()));
 928   verify_oop(oop_result, &quot;broken oop in call_VM_base&quot;);
 929 }
 930 
 931 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
 932   ldr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
 933   str(zr, Address(java_thread, JavaThread::vm_result_2_offset()));
 934 }
 935 
 936 void MacroAssembler::align(int modulus) {
 937   while (offset() % modulus != 0) nop();
 938 }
 939 
 940 // these are no-ops overridden by InterpreterMacroAssembler
 941 
 942 void MacroAssembler::check_and_handle_earlyret(Register java_thread) { }
 943 
 944 void MacroAssembler::check_and_handle_popframe(Register java_thread) { }
 945 
 946 
 947 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
 948                                                       Register tmp,
 949                                                       int offset) {
 950   intptr_t value = *delayed_value_addr;
 951   if (value != 0)
 952     return RegisterOrConstant(value + offset);
 953 
 954   // load indirectly to solve generation ordering problem
 955   ldr(tmp, ExternalAddress((address) delayed_value_addr));
 956 
 957   if (offset != 0)
 958     add(tmp, tmp, offset);
 959 
 960   return RegisterOrConstant(tmp);
 961 }
 962 
 963 // Look up the method for a megamorphic invokeinterface call.
 964 // The target method is determined by &lt;intf_klass, itable_index&gt;.
 965 // The receiver klass is in recv_klass.
 966 // On success, the result will be in method_result, and execution falls through.
 967 // On failure, execution transfers to the given label.
 968 void MacroAssembler::lookup_interface_method(Register recv_klass,
 969                                              Register intf_klass,
 970                                              RegisterOrConstant itable_index,
 971                                              Register method_result,
 972                                              Register scan_temp,
 973                                              Label&amp; L_no_such_interface,
 974                          bool return_method) {
 975   assert_different_registers(recv_klass, intf_klass, scan_temp);
 976   assert_different_registers(method_result, intf_klass, scan_temp);
 977   assert(recv_klass != method_result || !return_method,
 978      &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
 979   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
 980          &quot;caller must use same register for non-constant itable index as for method&quot;);
 981 
 982   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
 983   int vtable_base = in_bytes(Klass::vtable_start_offset());
 984   int itentry_off = itableMethodEntry::method_offset_in_bytes();
 985   int scan_step   = itableOffsetEntry::size() * wordSize;
 986   int vte_size    = vtableEntry::size_in_bytes();
 987   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
 988 
 989   ldrw(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
 990 
 991   // %%% Could store the aligned, prescaled offset in the klassoop.
 992   // lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
 993   lea(scan_temp, Address(recv_klass, scan_temp, Address::lsl(3)));
 994   add(scan_temp, scan_temp, vtable_base);
 995 
 996   if (return_method) {
 997     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
 998     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
 999     // lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
1000     lea(recv_klass, Address(recv_klass, itable_index, Address::lsl(3)));
1001     if (itentry_off)
1002       add(recv_klass, recv_klass, itentry_off);
1003   }
1004 
1005   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
1006   //   if (scan-&gt;interface() == intf) {
1007   //     result = (klass + scan-&gt;offset() + itable_index);
1008   //   }
1009   // }
1010   Label search, found_method;
1011 
1012   for (int peel = 1; peel &gt;= 0; peel--) {
1013     ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
1014     cmp(intf_klass, method_result);
1015 
1016     if (peel) {
1017       br(Assembler::EQ, found_method);
1018     } else {
1019       br(Assembler::NE, search);
1020       // (invert the test to fall through to found_method...)
1021     }
1022 
1023     if (!peel)  break;
1024 
1025     bind(search);
1026 
1027     // Check that the previous entry is non-null.  A null entry means that
1028     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
1029     // same as when the caller was compiled.
1030     cbz(method_result, L_no_such_interface);
1031     add(scan_temp, scan_temp, scan_step);
1032   }
1033 
1034   bind(found_method);
1035 
1036   // Got a hit.
1037   if (return_method) {
1038     ldrw(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
1039     ldr(method_result, Address(recv_klass, scan_temp, Address::uxtw(0)));
1040   }
1041 }
1042 
1043 // virtual method calling
1044 void MacroAssembler::lookup_virtual_method(Register recv_klass,
1045                                            RegisterOrConstant vtable_index,
1046                                            Register method_result) {
1047   const int base = in_bytes(Klass::vtable_start_offset());
1048   assert(vtableEntry::size() * wordSize == 8,
1049          &quot;adjust the scaling in the code below&quot;);
1050   int vtable_offset_in_bytes = base + vtableEntry::method_offset_in_bytes();
1051 
1052   if (vtable_index.is_register()) {
1053     lea(method_result, Address(recv_klass,
1054                                vtable_index.as_register(),
1055                                Address::lsl(LogBytesPerWord)));
1056     ldr(method_result, Address(method_result, vtable_offset_in_bytes));
1057   } else {
1058     vtable_offset_in_bytes += vtable_index.as_constant() * wordSize;
1059     ldr(method_result,
1060         form_address(rscratch1, recv_klass, vtable_offset_in_bytes, 0));
1061   }
1062 }
1063 
1064 void MacroAssembler::check_klass_subtype(Register sub_klass,
1065                            Register super_klass,
1066                            Register temp_reg,
1067                            Label&amp; L_success) {
1068   Label L_failure;
1069   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
1070   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
1071   bind(L_failure);
1072 }
1073 
1074 
1075 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
1076                                                    Register super_klass,
1077                                                    Register temp_reg,
1078                                                    Label* L_success,
1079                                                    Label* L_failure,
1080                                                    Label* L_slow_path,
1081                                         RegisterOrConstant super_check_offset) {
1082   assert_different_registers(sub_klass, super_klass, temp_reg);
1083   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
1084   if (super_check_offset.is_register()) {
1085     assert_different_registers(sub_klass, super_klass,
1086                                super_check_offset.as_register());
1087   } else if (must_load_sco) {
1088     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
1089   }
1090 
1091   Label L_fallthrough;
1092   int label_nulls = 0;
1093   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
1094   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
1095   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
1096   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
1097 
1098   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
1099   int sco_offset = in_bytes(Klass::super_check_offset_offset());
1100   Address super_check_offset_addr(super_klass, sco_offset);
1101 
1102   // Hacked jmp, which may only be used just before L_fallthrough.
1103 #define final_jmp(label)                                                \
1104   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
1105   else                            b(label)                /*omit semi*/
1106 
1107   // If the pointers are equal, we are done (e.g., String[] elements).
1108   // This self-check enables sharing of secondary supertype arrays among
1109   // non-primary types such as array-of-interface.  Otherwise, each such
1110   // type would need its own customized SSA.
1111   // We move this check to the front of the fast path because many
1112   // type checks are in fact trivially successful in this manner,
1113   // so we get a nicely predicted branch right at the start of the check.
1114   cmp(sub_klass, super_klass);
1115   br(Assembler::EQ, *L_success);
1116 
1117   // Check the supertype display:
1118   if (must_load_sco) {
1119     ldrw(temp_reg, super_check_offset_addr);
1120     super_check_offset = RegisterOrConstant(temp_reg);
1121   }
1122   Address super_check_addr(sub_klass, super_check_offset);
1123   ldr(rscratch1, super_check_addr);
1124   cmp(super_klass, rscratch1); // load displayed supertype
1125 
1126   // This check has worked decisively for primary supers.
1127   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
1128   // (Secondary supers are interfaces and very deeply nested subtypes.)
1129   // This works in the same check above because of a tricky aliasing
1130   // between the super_cache and the primary super display elements.
1131   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
1132   // Note that the cache is updated below if it does not help us find
1133   // what we need immediately.
1134   // So if it was a primary super, we can just fail immediately.
1135   // Otherwise, it&#39;s the slow path for us (no success at this point).
1136 
1137   if (super_check_offset.is_register()) {
1138     br(Assembler::EQ, *L_success);
1139     subs(zr, super_check_offset.as_register(), sc_offset);
1140     if (L_failure == &amp;L_fallthrough) {
1141       br(Assembler::EQ, *L_slow_path);
1142     } else {
1143       br(Assembler::NE, *L_failure);
1144       final_jmp(*L_slow_path);
1145     }
1146   } else if (super_check_offset.as_constant() == sc_offset) {
1147     // Need a slow path; fast failure is impossible.
1148     if (L_slow_path == &amp;L_fallthrough) {
1149       br(Assembler::EQ, *L_success);
1150     } else {
1151       br(Assembler::NE, *L_slow_path);
1152       final_jmp(*L_success);
1153     }
1154   } else {
1155     // No slow path; it&#39;s a fast decision.
1156     if (L_failure == &amp;L_fallthrough) {
1157       br(Assembler::EQ, *L_success);
1158     } else {
1159       br(Assembler::NE, *L_failure);
1160       final_jmp(*L_success);
1161     }
1162   }
1163 
1164   bind(L_fallthrough);
1165 
1166 #undef final_jmp
1167 }
1168 
1169 // These two are taken from x86, but they look generally useful
1170 
1171 // scans count pointer sized words at [addr] for occurence of value,
1172 // generic
1173 void MacroAssembler::repne_scan(Register addr, Register value, Register count,
1174                                 Register scratch) {
1175   Label Lloop, Lexit;
1176   cbz(count, Lexit);
1177   bind(Lloop);
1178   ldr(scratch, post(addr, wordSize));
1179   cmp(value, scratch);
1180   br(EQ, Lexit);
1181   sub(count, count, 1);
1182   cbnz(count, Lloop);
1183   bind(Lexit);
1184 }
1185 
1186 // scans count 4 byte words at [addr] for occurence of value,
1187 // generic
1188 void MacroAssembler::repne_scanw(Register addr, Register value, Register count,
1189                                 Register scratch) {
1190   Label Lloop, Lexit;
1191   cbz(count, Lexit);
1192   bind(Lloop);
1193   ldrw(scratch, post(addr, wordSize));
1194   cmpw(value, scratch);
1195   br(EQ, Lexit);
1196   sub(count, count, 1);
1197   cbnz(count, Lloop);
1198   bind(Lexit);
1199 }
1200 
1201 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
1202                                                    Register super_klass,
1203                                                    Register temp_reg,
1204                                                    Register temp2_reg,
1205                                                    Label* L_success,
1206                                                    Label* L_failure,
1207                                                    bool set_cond_codes) {
1208   assert_different_registers(sub_klass, super_klass, temp_reg);
1209   if (temp2_reg != noreg)
1210     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, rscratch1);
1211 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
1212 
1213   Label L_fallthrough;
1214   int label_nulls = 0;
1215   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
1216   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
1217   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
1218 
1219   // a couple of useful fields in sub_klass:
1220   int ss_offset = in_bytes(Klass::secondary_supers_offset());
1221   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
1222   Address secondary_supers_addr(sub_klass, ss_offset);
1223   Address super_cache_addr(     sub_klass, sc_offset);
1224 
1225   BLOCK_COMMENT(&quot;check_klass_subtype_slow_path&quot;);
1226 
1227   // Do a linear scan of the secondary super-klass chain.
1228   // This code is rarely used, so simplicity is a virtue here.
1229   // The repne_scan instruction uses fixed registers, which we must spill.
1230   // Don&#39;t worry too much about pre-existing connections with the input regs.
1231 
1232   assert(sub_klass != r0, &quot;killed reg&quot;); // killed by mov(r0, super)
1233   assert(sub_klass != r2, &quot;killed reg&quot;); // killed by lea(r2, &amp;pst_counter)
1234 
1235   RegSet pushed_registers;
1236   if (!IS_A_TEMP(r2))    pushed_registers += r2;
1237   if (!IS_A_TEMP(r5))    pushed_registers += r5;
1238 
1239   if (super_klass != r0 || UseCompressedOops) {
1240     if (!IS_A_TEMP(r0))   pushed_registers += r0;
1241   }
1242 
1243   push(pushed_registers, sp);
1244 
1245   // Get super_klass value into r0 (even if it was in r5 or r2).
1246   if (super_klass != r0) {
1247     mov(r0, super_klass);
1248   }
1249 
1250 #ifndef PRODUCT
1251   mov(rscratch2, (address)&amp;SharedRuntime::_partial_subtype_ctr);
1252   Address pst_counter_addr(rscratch2);
1253   ldr(rscratch1, pst_counter_addr);
1254   add(rscratch1, rscratch1, 1);
1255   str(rscratch1, pst_counter_addr);
1256 #endif //PRODUCT
1257 
1258   // We will consult the secondary-super array.
1259   ldr(r5, secondary_supers_addr);
1260   // Load the array length.
1261   ldrw(r2, Address(r5, Array&lt;Klass*&gt;::length_offset_in_bytes()));
1262   // Skip to start of data.
1263   add(r5, r5, Array&lt;Klass*&gt;::base_offset_in_bytes());
1264 
1265   cmp(sp, zr); // Clear Z flag; SP is never zero
1266   // Scan R2 words at [R5] for an occurrence of R0.
1267   // Set NZ/Z based on last compare.
1268   repne_scan(r5, r0, r2, rscratch1);
1269 
1270   // Unspill the temp. registers:
1271   pop(pushed_registers, sp);
1272 
1273   br(Assembler::NE, *L_failure);
1274 
1275   // Success.  Cache the super we found and proceed in triumph.
1276   str(super_klass, super_cache_addr);
1277 
1278   if (L_success != &amp;L_fallthrough) {
1279     b(*L_success);
1280   }
1281 
1282 #undef IS_A_TEMP
1283 
1284   bind(L_fallthrough);
1285 }
1286 
1287 void MacroAssembler::clinit_barrier(Register klass, Register scratch, Label* L_fast_path, Label* L_slow_path) {
1288   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
1289   assert_different_registers(klass, rthread, scratch);
1290 
1291   Label L_fallthrough, L_tmp;
1292   if (L_fast_path == NULL) {
1293     L_fast_path = &amp;L_fallthrough;
1294   } else if (L_slow_path == NULL) {
1295     L_slow_path = &amp;L_fallthrough;
1296   }
1297   // Fast path check: class is fully initialized
1298   ldrb(scratch, Address(klass, InstanceKlass::init_state_offset()));
1299   subs(zr, scratch, InstanceKlass::fully_initialized);
1300   br(Assembler::EQ, *L_fast_path);
1301 
1302   // Fast path check: current thread is initializer thread
1303   ldr(scratch, Address(klass, InstanceKlass::init_thread_offset()));
1304   cmp(rthread, scratch);
1305 
1306   if (L_slow_path == &amp;L_fallthrough) {
1307     br(Assembler::EQ, *L_fast_path);
1308     bind(*L_slow_path);
1309   } else if (L_fast_path == &amp;L_fallthrough) {
1310     br(Assembler::NE, *L_slow_path);
1311     bind(*L_fast_path);
1312   } else {
1313     Unimplemented();
1314   }
1315 }
1316 
1317 void MacroAssembler::verify_oop(Register reg, const char* s) {
1318   if (!VerifyOops || VerifyAdapterSharing) {
1319     // Below address of the code string confuses VerifyAdapterSharing
1320     // because it may differ between otherwise equivalent adapters.
1321     return;
1322   }
1323 
1324   // Pass register number to verify_oop_subroutine
1325   const char* b = NULL;
1326   {
1327     ResourceMark rm;
1328     stringStream ss;
1329     ss.print(&quot;verify_oop: %s: %s&quot;, reg-&gt;name(), s);
1330     b = code_string(ss.as_string());
1331   }
1332   BLOCK_COMMENT(&quot;verify_oop {&quot;);
1333 
1334   stp(r0, rscratch1, Address(pre(sp, -2 * wordSize)));
1335   stp(rscratch2, lr, Address(pre(sp, -2 * wordSize)));
1336 
1337   mov(r0, reg);
1338   movptr(rscratch1, (uintptr_t)(address)b);
1339 
1340   // call indirectly to solve generation ordering problem
1341   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
1342   ldr(rscratch2, Address(rscratch2));
1343   blr(rscratch2);
1344 
1345   ldp(rscratch2, lr, Address(post(sp, 2 * wordSize)));
1346   ldp(r0, rscratch1, Address(post(sp, 2 * wordSize)));
1347 
1348   BLOCK_COMMENT(&quot;} verify_oop&quot;);
1349 }
1350 
1351 void MacroAssembler::verify_oop_addr(Address addr, const char* s) {
1352   if (!VerifyOops || VerifyAdapterSharing) {
1353     // Below address of the code string confuses VerifyAdapterSharing
1354     // because it may differ between otherwise equivalent adapters.
1355     return;
1356   }
1357 
1358   const char* b = NULL;
1359   {
1360     ResourceMark rm;
1361     stringStream ss;
1362     ss.print(&quot;verify_oop_addr: %s&quot;, s);
1363     b = code_string(ss.as_string());
1364   }
1365   BLOCK_COMMENT(&quot;verify_oop_addr {&quot;);
1366 
1367   stp(r0, rscratch1, Address(pre(sp, -2 * wordSize)));
1368   stp(rscratch2, lr, Address(pre(sp, -2 * wordSize)));
1369 
1370   // addr may contain sp so we will have to adjust it based on the
1371   // pushes that we just did.
1372   if (addr.uses(sp)) {
1373     lea(r0, addr);
1374     ldr(r0, Address(r0, 4 * wordSize));
1375   } else {
1376     ldr(r0, addr);
1377   }
1378   movptr(rscratch1, (uintptr_t)(address)b);
1379 
1380   // call indirectly to solve generation ordering problem
1381   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
1382   ldr(rscratch2, Address(rscratch2));
1383   blr(rscratch2);
1384 
1385   ldp(rscratch2, lr, Address(post(sp, 2 * wordSize)));
1386   ldp(r0, rscratch1, Address(post(sp, 2 * wordSize)));
1387 
1388   BLOCK_COMMENT(&quot;} verify_oop_addr&quot;);
1389 }
1390 
1391 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
1392                                          int extra_slot_offset) {
1393   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
1394   int stackElementSize = Interpreter::stackElementSize;
1395   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
1396 #ifdef ASSERT
1397   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
1398   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
1399 #endif
1400   if (arg_slot.is_constant()) {
1401     return Address(esp, arg_slot.as_constant() * stackElementSize
1402                    + offset);
1403   } else {
1404     add(rscratch1, esp, arg_slot.as_register(),
1405         ext::uxtx, exact_log2(stackElementSize));
1406     return Address(rscratch1, offset);
1407   }
1408 }
1409 
1410 void MacroAssembler::call_VM_leaf_base(address entry_point,
1411                                        int number_of_arguments,
1412                                        Label *retaddr) {
1413   Label E, L;
1414 
1415   stp(rscratch1, rmethod, Address(pre(sp, -2 * wordSize)));
1416 
1417   mov(rscratch1, entry_point);
1418   blr(rscratch1);
1419   if (retaddr)
1420     bind(*retaddr);
1421 
1422   ldp(rscratch1, rmethod, Address(post(sp, 2 * wordSize)));
1423   maybe_isb();
1424 }
1425 
1426 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1427   call_VM_leaf_base(entry_point, number_of_arguments);
1428 }
1429 
1430 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1431   pass_arg0(this, arg_0);
1432   call_VM_leaf_base(entry_point, 1);
1433 }
1434 
1435 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1436   pass_arg0(this, arg_0);
1437   pass_arg1(this, arg_1);
1438   call_VM_leaf_base(entry_point, 2);
1439 }
1440 
1441 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0,
1442                                   Register arg_1, Register arg_2) {
1443   pass_arg0(this, arg_0);
1444   pass_arg1(this, arg_1);
1445   pass_arg2(this, arg_2);
1446   call_VM_leaf_base(entry_point, 3);
1447 }
1448 
1449 void MacroAssembler::super_call_VM_leaf(address entry_point) {
1450   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1451 }
1452 
1453 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1454   pass_arg0(this, arg_0);
1455   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1456 }
1457 
1458 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1459 
1460   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1461   pass_arg1(this, arg_1);
1462   pass_arg0(this, arg_0);
1463   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1464 }
1465 
1466 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1467   assert(arg_0 != c_rarg2, &quot;smashed arg&quot;);
1468   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
1469   pass_arg2(this, arg_2);
1470   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1471   pass_arg1(this, arg_1);
1472   pass_arg0(this, arg_0);
1473   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1474 }
1475 
1476 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1477   assert(arg_0 != c_rarg3, &quot;smashed arg&quot;);
1478   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
1479   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
1480   pass_arg3(this, arg_3);
1481   assert(arg_0 != c_rarg2, &quot;smashed arg&quot;);
1482   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
1483   pass_arg2(this, arg_2);
1484   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1485   pass_arg1(this, arg_1);
1486   pass_arg0(this, arg_0);
1487   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1488 }
1489 
1490 void MacroAssembler::null_check(Register reg, int offset) {
1491   if (needs_explicit_null_check(offset)) {
1492     // provoke OS NULL exception if reg = NULL by
1493     // accessing M[reg] w/o changing any registers
1494     // NOTE: this is plenty to provoke a segv
1495     ldr(zr, Address(reg));
1496   } else {
1497     // nothing to do, (later) access of M[reg + offset]
1498     // will provoke OS NULL exception if reg = NULL
1499   }
1500 }
1501 
1502 void MacroAssembler::test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value) {
1503   ldrw(temp_reg, Address(klass, Klass::access_flags_offset()));
1504   andr(temp_reg, temp_reg, JVM_ACC_VALUE);
1505   cbnz(temp_reg, is_value);
1506 }
1507 
1508 void MacroAssembler::test_field_is_inline_type(Register flags, Register temp_reg, Label&amp; is_inline) {
1509   (void) temp_reg; // keep signature uniform with x86
1510   tbnz(flags, ConstantPoolCacheEntry::is_inline_field_shift, is_inline);
1511 }
1512 
1513 void MacroAssembler::test_field_is_not_inline_type(Register flags, Register temp_reg, Label&amp; not_inline) {
1514   (void) temp_reg; // keep signature uniform with x86
1515   tbz(flags, ConstantPoolCacheEntry::is_inline_field_shift, not_inline);
1516 }
1517 
1518 void MacroAssembler::test_field_is_inlined(Register flags, Register temp_reg, Label&amp; is_flattened) {
1519   (void) temp_reg; // keep signature uniform with x86
1520   tbnz(flags, ConstantPoolCacheEntry::is_flattened_field_shift, is_flattened);
1521 }
1522 
1523 void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg, Label&amp; is_flattened_array) {
1524   load_storage_props(temp_reg, oop);
1525   andr(temp_reg, temp_reg, ArrayStorageProperties::flattened_value);
1526   cbnz(temp_reg, is_flattened_array);
1527 }
1528 
1529 void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&amp; is_null_free_array) {
1530   load_storage_props(temp_reg, oop);
1531   andr(temp_reg, temp_reg, ArrayStorageProperties::null_free_value);
1532   cbnz(temp_reg, is_null_free_array);
1533 }
1534 
1535 // MacroAssembler protected routines needed to implement
1536 // public methods
1537 
1538 void MacroAssembler::mov(Register r, Address dest) {
1539   code_section()-&gt;relocate(pc(), dest.rspec());
1540   u_int64_t imm64 = (u_int64_t)dest.target();
1541   movptr(r, imm64);
1542 }
1543 
1544 // Move a constant pointer into r.  In AArch64 mode the virtual
1545 // address space is 48 bits in size, so we only need three
1546 // instructions to create a patchable instruction sequence that can
1547 // reach anywhere.
1548 void MacroAssembler::movptr(Register r, uintptr_t imm64) {
1549 #ifndef PRODUCT
1550   {
1551     char buffer[64];
1552     snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
1553     block_comment(buffer);
1554   }
1555 #endif
1556   assert(imm64 &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
1557   movz(r, imm64 &amp; 0xffff);
1558   imm64 &gt;&gt;= 16;
1559   movk(r, imm64 &amp; 0xffff, 16);
1560   imm64 &gt;&gt;= 16;
1561   movk(r, imm64 &amp; 0xffff, 32);
1562 }
1563 
1564 // Macro to mov replicated immediate to vector register.
1565 //  Vd will get the following values for different arrangements in T
1566 //   imm32 == hex 000000gh  T8B:  Vd = ghghghghghghghgh
1567 //   imm32 == hex 000000gh  T16B: Vd = ghghghghghghghghghghghghghghghgh
1568 //   imm32 == hex 0000efgh  T4H:  Vd = efghefghefghefgh
1569 //   imm32 == hex 0000efgh  T8H:  Vd = efghefghefghefghefghefghefghefgh
1570 //   imm32 == hex abcdefgh  T2S:  Vd = abcdefghabcdefgh
1571 //   imm32 == hex abcdefgh  T4S:  Vd = abcdefghabcdefghabcdefghabcdefgh
1572 //   T1D/T2D: invalid
1573 void MacroAssembler::mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32) {
1574   assert(T != T1D &amp;&amp; T != T2D, &quot;invalid arrangement&quot;);
1575   if (T == T8B || T == T16B) {
1576     assert((imm32 &amp; ~0xff) == 0, &quot;extraneous bits in unsigned imm32 (T8B/T16B)&quot;);
1577     movi(Vd, T, imm32 &amp; 0xff, 0);
1578     return;
1579   }
1580   u_int32_t nimm32 = ~imm32;
1581   if (T == T4H || T == T8H) {
1582     assert((imm32  &amp; ~0xffff) == 0, &quot;extraneous bits in unsigned imm32 (T4H/T8H)&quot;);
1583     imm32 &amp;= 0xffff;
1584     nimm32 &amp;= 0xffff;
1585   }
1586   u_int32_t x = imm32;
1587   int movi_cnt = 0;
1588   int movn_cnt = 0;
1589   while (x) { if (x &amp; 0xff) movi_cnt++; x &gt;&gt;= 8; }
1590   x = nimm32;
1591   while (x) { if (x &amp; 0xff) movn_cnt++; x &gt;&gt;= 8; }
1592   if (movn_cnt &lt; movi_cnt) imm32 = nimm32;
1593   unsigned lsl = 0;
1594   while (imm32 &amp;&amp; (imm32 &amp; 0xff) == 0) { lsl += 8; imm32 &gt;&gt;= 8; }
1595   if (movn_cnt &lt; movi_cnt)
1596     mvni(Vd, T, imm32 &amp; 0xff, lsl);
1597   else
1598     movi(Vd, T, imm32 &amp; 0xff, lsl);
1599   imm32 &gt;&gt;= 8; lsl += 8;
1600   while (imm32) {
1601     while ((imm32 &amp; 0xff) == 0) { lsl += 8; imm32 &gt;&gt;= 8; }
1602     if (movn_cnt &lt; movi_cnt)
1603       bici(Vd, T, imm32 &amp; 0xff, lsl);
1604     else
1605       orri(Vd, T, imm32 &amp; 0xff, lsl);
1606     lsl += 8; imm32 &gt;&gt;= 8;
1607   }
1608 }
1609 
1610 void MacroAssembler::mov_immediate64(Register dst, u_int64_t imm64)
1611 {
1612 #ifndef PRODUCT
1613   {
1614     char buffer[64];
1615     snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
1616     block_comment(buffer);
1617   }
1618 #endif
1619   if (operand_valid_for_logical_immediate(false, imm64)) {
1620     orr(dst, zr, imm64);
1621   } else {
1622     // we can use a combination of MOVZ or MOVN with
1623     // MOVK to build up the constant
1624     u_int64_t imm_h[4];
1625     int zero_count = 0;
1626     int neg_count = 0;
1627     int i;
1628     for (i = 0; i &lt; 4; i++) {
1629       imm_h[i] = ((imm64 &gt;&gt; (i * 16)) &amp; 0xffffL);
1630       if (imm_h[i] == 0) {
1631         zero_count++;
1632       } else if (imm_h[i] == 0xffffL) {
1633         neg_count++;
1634       }
1635     }
1636     if (zero_count == 4) {
1637       // one MOVZ will do
1638       movz(dst, 0);
1639     } else if (neg_count == 4) {
1640       // one MOVN will do
1641       movn(dst, 0);
1642     } else if (zero_count == 3) {
1643       for (i = 0; i &lt; 4; i++) {
1644         if (imm_h[i] != 0L) {
1645           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1646           break;
1647         }
1648       }
1649     } else if (neg_count == 3) {
1650       // one MOVN will do
1651       for (int i = 0; i &lt; 4; i++) {
1652         if (imm_h[i] != 0xffffL) {
1653           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1654           break;
1655         }
1656       }
1657     } else if (zero_count == 2) {
1658       // one MOVZ and one MOVK will do
1659       for (i = 0; i &lt; 3; i++) {
1660         if (imm_h[i] != 0L) {
1661           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1662           i++;
1663           break;
1664         }
1665       }
1666       for (;i &lt; 4; i++) {
1667         if (imm_h[i] != 0L) {
1668           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1669         }
1670       }
1671     } else if (neg_count == 2) {
1672       // one MOVN and one MOVK will do
1673       for (i = 0; i &lt; 4; i++) {
1674         if (imm_h[i] != 0xffffL) {
1675           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1676           i++;
1677           break;
1678         }
1679       }
1680       for (;i &lt; 4; i++) {
1681         if (imm_h[i] != 0xffffL) {
1682           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1683         }
1684       }
1685     } else if (zero_count == 1) {
1686       // one MOVZ and two MOVKs will do
1687       for (i = 0; i &lt; 4; i++) {
1688         if (imm_h[i] != 0L) {
1689           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1690           i++;
1691           break;
1692         }
1693       }
1694       for (;i &lt; 4; i++) {
1695         if (imm_h[i] != 0x0L) {
1696           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1697         }
1698       }
1699     } else if (neg_count == 1) {
1700       // one MOVN and two MOVKs will do
1701       for (i = 0; i &lt; 4; i++) {
1702         if (imm_h[i] != 0xffffL) {
1703           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1704           i++;
1705           break;
1706         }
1707       }
1708       for (;i &lt; 4; i++) {
1709         if (imm_h[i] != 0xffffL) {
1710           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1711         }
1712       }
1713     } else {
1714       // use a MOVZ and 3 MOVKs (makes it easier to debug)
1715       movz(dst, (u_int32_t)imm_h[0], 0);
1716       for (i = 1; i &lt; 4; i++) {
1717         movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1718       }
1719     }
1720   }
1721 }
1722 
1723 void MacroAssembler::mov_immediate32(Register dst, u_int32_t imm32)
1724 {
1725 #ifndef PRODUCT
1726     {
1727       char buffer[64];
1728       snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX32, imm32);
1729       block_comment(buffer);
1730     }
1731 #endif
1732   if (operand_valid_for_logical_immediate(true, imm32)) {
1733     orrw(dst, zr, imm32);
1734   } else {
1735     // we can use MOVZ, MOVN or two calls to MOVK to build up the
1736     // constant
1737     u_int32_t imm_h[2];
1738     imm_h[0] = imm32 &amp; 0xffff;
1739     imm_h[1] = ((imm32 &gt;&gt; 16) &amp; 0xffff);
1740     if (imm_h[0] == 0) {
1741       movzw(dst, imm_h[1], 16);
1742     } else if (imm_h[0] == 0xffff) {
1743       movnw(dst, imm_h[1] ^ 0xffff, 16);
1744     } else if (imm_h[1] == 0) {
1745       movzw(dst, imm_h[0], 0);
1746     } else if (imm_h[1] == 0xffff) {
1747       movnw(dst, imm_h[0] ^ 0xffff, 0);
1748     } else {
1749       // use a MOVZ and MOVK (makes it easier to debug)
1750       movzw(dst, imm_h[0], 0);
1751       movkw(dst, imm_h[1], 16);
1752     }
1753   }
1754 }
1755 
1756 // Form an address from base + offset in Rd.  Rd may or may
1757 // not actually be used: you must use the Address that is returned.
1758 // It is up to you to ensure that the shift provided matches the size
1759 // of your data.
1760 Address MacroAssembler::form_address(Register Rd, Register base, long byte_offset, int shift) {
1761   if (Address::offset_ok_for_immed(byte_offset, shift))
1762     // It fits; no need for any heroics
1763     return Address(base, byte_offset);
1764 
1765   // Don&#39;t do anything clever with negative or misaligned offsets
1766   unsigned mask = (1 &lt;&lt; shift) - 1;
1767   if (byte_offset &lt; 0 || byte_offset &amp; mask) {
1768     mov(Rd, byte_offset);
1769     add(Rd, base, Rd);
1770     return Address(Rd);
1771   }
1772 
1773   // See if we can do this with two 12-bit offsets
1774   {
1775     unsigned long word_offset = byte_offset &gt;&gt; shift;
1776     unsigned long masked_offset = word_offset &amp; 0xfff000;
1777     if (Address::offset_ok_for_immed(word_offset - masked_offset, 0)
1778         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(masked_offset &lt;&lt; shift)) {
1779       add(Rd, base, masked_offset &lt;&lt; shift);
1780       word_offset -= masked_offset;
1781       return Address(Rd, word_offset &lt;&lt; shift);
1782     }
1783   }
1784 
1785   // Do it the hard way
1786   mov(Rd, byte_offset);
1787   add(Rd, base, Rd);
1788   return Address(Rd);
1789 }
1790 
1791 void MacroAssembler::atomic_incw(Register counter_addr, Register tmp, Register tmp2) {
1792   if (UseLSE) {
1793     mov(tmp, 1);
1794     ldadd(Assembler::word, tmp, zr, counter_addr);
1795     return;
1796   }
1797   Label retry_load;
1798   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
1799     prfm(Address(counter_addr), PSTL1STRM);
1800   bind(retry_load);
1801   // flush and load exclusive from the memory location
1802   ldxrw(tmp, counter_addr);
1803   addw(tmp, tmp, 1);
1804   // if we store+flush with no intervening write tmp wil be zero
1805   stxrw(tmp2, tmp, counter_addr);
1806   cbnzw(tmp2, retry_load);
1807 }
1808 
1809 
1810 int MacroAssembler::corrected_idivl(Register result, Register ra, Register rb,
1811                                     bool want_remainder, Register scratch)
1812 {
1813   // Full implementation of Java idiv and irem.  The function
1814   // returns the (pc) offset of the div instruction - may be needed
1815   // for implicit exceptions.
1816   //
1817   // constraint : ra/rb =/= scratch
1818   //         normal case
1819   //
1820   // input : ra: dividend
1821   //         rb: divisor
1822   //
1823   // result: either
1824   //         quotient  (= ra idiv rb)
1825   //         remainder (= ra irem rb)
1826 
1827   assert(ra != scratch &amp;&amp; rb != scratch, &quot;reg cannot be scratch&quot;);
1828 
1829   int idivl_offset = offset();
1830   if (! want_remainder) {
1831     sdivw(result, ra, rb);
1832   } else {
1833     sdivw(scratch, ra, rb);
1834     Assembler::msubw(result, scratch, rb, ra);
1835   }
1836 
1837   return idivl_offset;
1838 }
1839 
1840 int MacroAssembler::corrected_idivq(Register result, Register ra, Register rb,
1841                                     bool want_remainder, Register scratch)
1842 {
1843   // Full implementation of Java ldiv and lrem.  The function
1844   // returns the (pc) offset of the div instruction - may be needed
1845   // for implicit exceptions.
1846   //
1847   // constraint : ra/rb =/= scratch
1848   //         normal case
1849   //
1850   // input : ra: dividend
1851   //         rb: divisor
1852   //
1853   // result: either
1854   //         quotient  (= ra idiv rb)
1855   //         remainder (= ra irem rb)
1856 
1857   assert(ra != scratch &amp;&amp; rb != scratch, &quot;reg cannot be scratch&quot;);
1858 
1859   int idivq_offset = offset();
1860   if (! want_remainder) {
1861     sdiv(result, ra, rb);
1862   } else {
1863     sdiv(scratch, ra, rb);
1864     Assembler::msub(result, scratch, rb, ra);
1865   }
1866 
1867   return idivq_offset;
1868 }
1869 
1870 void MacroAssembler::membar(Membar_mask_bits order_constraint) {
1871   address prev = pc() - NativeMembar::instruction_size;
1872   address last = code()-&gt;last_insn();
1873   if (last != NULL &amp;&amp; nativeInstruction_at(last)-&gt;is_Membar() &amp;&amp; prev == last) {
1874     NativeMembar *bar = NativeMembar_at(prev);
1875     // We are merging two memory barrier instructions.  On AArch64 we
1876     // can do this simply by ORing them together.
1877     bar-&gt;set_kind(bar-&gt;get_kind() | order_constraint);
1878     BLOCK_COMMENT(&quot;merged membar&quot;);
1879   } else {
1880     code()-&gt;set_last_insn(pc());
1881     dmb(Assembler::barrier(order_constraint));
1882   }
1883 }
1884 
1885 bool MacroAssembler::try_merge_ldst(Register rt, const Address &amp;adr, size_t size_in_bytes, bool is_store) {
1886   if (ldst_can_merge(rt, adr, size_in_bytes, is_store)) {
1887     merge_ldst(rt, adr, size_in_bytes, is_store);
1888     code()-&gt;clear_last_insn();
1889     return true;
1890   } else {
1891     assert(size_in_bytes == 8 || size_in_bytes == 4, &quot;only 8 bytes or 4 bytes load/store is supported.&quot;);
1892     const unsigned mask = size_in_bytes - 1;
1893     if (adr.getMode() == Address::base_plus_offset &amp;&amp;
1894         (adr.offset() &amp; mask) == 0) { // only supports base_plus_offset.
1895       code()-&gt;set_last_insn(pc());
1896     }
1897     return false;
1898   }
1899 }
1900 
1901 void MacroAssembler::ldr(Register Rx, const Address &amp;adr) {
1902   // We always try to merge two adjacent loads into one ldp.
1903   if (!try_merge_ldst(Rx, adr, 8, false)) {
1904     Assembler::ldr(Rx, adr);
1905   }
1906 }
1907 
1908 void MacroAssembler::ldrw(Register Rw, const Address &amp;adr) {
1909   // We always try to merge two adjacent loads into one ldp.
1910   if (!try_merge_ldst(Rw, adr, 4, false)) {
1911     Assembler::ldrw(Rw, adr);
1912   }
1913 }
1914 
1915 void MacroAssembler::str(Register Rx, const Address &amp;adr) {
1916   // We always try to merge two adjacent stores into one stp.
1917   if (!try_merge_ldst(Rx, adr, 8, true)) {
1918     Assembler::str(Rx, adr);
1919   }
1920 }
1921 
1922 void MacroAssembler::strw(Register Rw, const Address &amp;adr) {
1923   // We always try to merge two adjacent stores into one stp.
1924   if (!try_merge_ldst(Rw, adr, 4, true)) {
1925     Assembler::strw(Rw, adr);
1926   }
1927 }
1928 
1929 // MacroAssembler routines found actually to be needed
1930 
1931 void MacroAssembler::push(Register src)
1932 {
1933   str(src, Address(pre(esp, -1 * wordSize)));
1934 }
1935 
1936 void MacroAssembler::pop(Register dst)
1937 {
1938   ldr(dst, Address(post(esp, 1 * wordSize)));
1939 }
1940 
1941 // Note: load_unsigned_short used to be called load_unsigned_word.
1942 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
1943   int off = offset();
1944   ldrh(dst, src);
1945   return off;
1946 }
1947 
1948 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
1949   int off = offset();
1950   ldrb(dst, src);
1951   return off;
1952 }
1953 
1954 int MacroAssembler::load_signed_short(Register dst, Address src) {
1955   int off = offset();
1956   ldrsh(dst, src);
1957   return off;
1958 }
1959 
1960 int MacroAssembler::load_signed_byte(Register dst, Address src) {
1961   int off = offset();
1962   ldrsb(dst, src);
1963   return off;
1964 }
1965 
1966 int MacroAssembler::load_signed_short32(Register dst, Address src) {
1967   int off = offset();
1968   ldrshw(dst, src);
1969   return off;
1970 }
1971 
1972 int MacroAssembler::load_signed_byte32(Register dst, Address src) {
1973   int off = offset();
1974   ldrsbw(dst, src);
1975   return off;
1976 }
1977 
1978 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
1979   switch (size_in_bytes) {
1980   case  8:  ldr(dst, src); break;
1981   case  4:  ldrw(dst, src); break;
1982   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
1983   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
1984   default:  ShouldNotReachHere();
1985   }
1986 }
1987 
1988 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
1989   switch (size_in_bytes) {
1990   case  8:  str(src, dst); break;
1991   case  4:  strw(src, dst); break;
1992   case  2:  strh(src, dst); break;
1993   case  1:  strb(src, dst); break;
1994   default:  ShouldNotReachHere();
1995   }
1996 }
1997 
1998 void MacroAssembler::decrementw(Register reg, int value)
1999 {
2000   if (value &lt; 0)  { incrementw(reg, -value);      return; }
2001   if (value == 0) {                               return; }
2002   if (value &lt; (1 &lt;&lt; 12)) { subw(reg, reg, value); return; }
2003   /* else */ {
2004     guarantee(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
2005     movw(rscratch2, (unsigned)value);
2006     subw(reg, reg, rscratch2);
2007   }
2008 }
2009 
2010 void MacroAssembler::decrement(Register reg, int value)
2011 {
2012   if (value &lt; 0)  { increment(reg, -value);      return; }
2013   if (value == 0) {                              return; }
2014   if (value &lt; (1 &lt;&lt; 12)) { sub(reg, reg, value); return; }
2015   /* else */ {
2016     assert(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
2017     mov(rscratch2, (unsigned long)value);
2018     sub(reg, reg, rscratch2);
2019   }
2020 }
2021 
2022 void MacroAssembler::decrementw(Address dst, int value)
2023 {
2024   assert(!dst.uses(rscratch1), &quot;invalid dst for address decrement&quot;);
2025   if (dst.getMode() == Address::literal) {
2026     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2027     lea(rscratch2, dst);
2028     dst = Address(rscratch2);
2029   }
2030   ldrw(rscratch1, dst);
2031   decrementw(rscratch1, value);
2032   strw(rscratch1, dst);
2033 }
2034 
2035 void MacroAssembler::decrement(Address dst, int value)
2036 {
2037   assert(!dst.uses(rscratch1), &quot;invalid address for decrement&quot;);
2038   if (dst.getMode() == Address::literal) {
2039     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2040     lea(rscratch2, dst);
2041     dst = Address(rscratch2);
2042   }
2043   ldr(rscratch1, dst);
2044   decrement(rscratch1, value);
2045   str(rscratch1, dst);
2046 }
2047 
2048 void MacroAssembler::incrementw(Register reg, int value)
2049 {
2050   if (value &lt; 0)  { decrementw(reg, -value);      return; }
2051   if (value == 0) {                               return; }
2052   if (value &lt; (1 &lt;&lt; 12)) { addw(reg, reg, value); return; }
2053   /* else */ {
2054     assert(reg != rscratch2, &quot;invalid dst for register increment&quot;);
2055     movw(rscratch2, (unsigned)value);
2056     addw(reg, reg, rscratch2);
2057   }
2058 }
2059 
2060 void MacroAssembler::increment(Register reg, int value)
2061 {
2062   if (value &lt; 0)  { decrement(reg, -value);      return; }
2063   if (value == 0) {                              return; }
2064   if (value &lt; (1 &lt;&lt; 12)) { add(reg, reg, value); return; }
2065   /* else */ {
2066     assert(reg != rscratch2, &quot;invalid dst for register increment&quot;);
2067     movw(rscratch2, (unsigned)value);
2068     add(reg, reg, rscratch2);
2069   }
2070 }
2071 
2072 void MacroAssembler::incrementw(Address dst, int value)
2073 {
2074   assert(!dst.uses(rscratch1), &quot;invalid dst for address increment&quot;);
2075   if (dst.getMode() == Address::literal) {
2076     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2077     lea(rscratch2, dst);
2078     dst = Address(rscratch2);
2079   }
2080   ldrw(rscratch1, dst);
2081   incrementw(rscratch1, value);
2082   strw(rscratch1, dst);
2083 }
2084 
2085 void MacroAssembler::increment(Address dst, int value)
2086 {
2087   assert(!dst.uses(rscratch1), &quot;invalid dst for address increment&quot;);
2088   if (dst.getMode() == Address::literal) {
2089     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2090     lea(rscratch2, dst);
2091     dst = Address(rscratch2);
2092   }
2093   ldr(rscratch1, dst);
2094   increment(rscratch1, value);
2095   str(rscratch1, dst);
2096 }
2097 
2098 
2099 void MacroAssembler::pusha() {
2100   push(0x7fffffff, sp);
2101 }
2102 
2103 void MacroAssembler::popa() {
2104   pop(0x7fffffff, sp);
2105 }
2106 
2107 // Push lots of registers in the bit set supplied.  Don&#39;t push sp.
2108 // Return the number of words pushed
2109 int MacroAssembler::push(unsigned int bitset, Register stack) {
2110   int words_pushed = 0;
2111 
2112   // Scan bitset to accumulate register pairs
2113   unsigned char regs[32];
2114   int count = 0;
2115   for (int reg = 0; reg &lt;= 30; reg++) {
2116     if (1 &amp; bitset)
2117       regs[count++] = reg;
2118     bitset &gt;&gt;= 1;
2119   }
2120   regs[count++] = zr-&gt;encoding_nocheck();
2121   count &amp;= ~1;  // Only push an even nuber of regs
2122 
2123   if (count) {
2124     stp(as_Register(regs[0]), as_Register(regs[1]),
2125        Address(pre(stack, -count * wordSize)));
2126     words_pushed += 2;
2127   }
2128   for (int i = 2; i &lt; count; i += 2) {
2129     stp(as_Register(regs[i]), as_Register(regs[i+1]),
2130        Address(stack, i * wordSize));
2131     words_pushed += 2;
2132   }
2133 
2134   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2135 
2136   return count;
2137 }
2138 
2139 int MacroAssembler::pop(unsigned int bitset, Register stack) {
2140   int words_pushed = 0;
2141 
2142   // Scan bitset to accumulate register pairs
2143   unsigned char regs[32];
2144   int count = 0;
2145   for (int reg = 0; reg &lt;= 30; reg++) {
2146     if (1 &amp; bitset)
2147       regs[count++] = reg;
2148     bitset &gt;&gt;= 1;
2149   }
2150   regs[count++] = zr-&gt;encoding_nocheck();
2151   count &amp;= ~1;
2152 
2153   for (int i = 2; i &lt; count; i += 2) {
2154     ldp(as_Register(regs[i]), as_Register(regs[i+1]),
2155        Address(stack, i * wordSize));
2156     words_pushed += 2;
2157   }
2158   if (count) {
2159     ldp(as_Register(regs[0]), as_Register(regs[1]),
2160        Address(post(stack, count * wordSize)));
2161     words_pushed += 2;
2162   }
2163 
2164   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2165 
2166   return count;
2167 }
2168 
2169 // Push lots of registers in the bit set supplied.  Don&#39;t push sp.
2170 // Return the number of words pushed
2171 int MacroAssembler::push_fp(unsigned int bitset, Register stack) {
2172   int words_pushed = 0;
2173 
2174   // Scan bitset to accumulate register pairs
2175   unsigned char regs[32];
2176   int count = 0;
2177   for (int reg = 0; reg &lt;= 31; reg++) {
2178     if (1 &amp; bitset)
2179       regs[count++] = reg;
2180     bitset &gt;&gt;= 1;
2181   }
<a name="1" id="anc1"></a><span class="line-modified">2182   regs[count++] = zr-&gt;encoding_nocheck();</span>
<span class="line-modified">2183   count &amp;= ~1;  // Only push an even number of regs</span>
<span class="line-removed">2184 </span>
<span class="line-removed">2185   // Always pushing full 128 bit registers.</span>
<span class="line-removed">2186   if (count) {</span>
<span class="line-removed">2187     stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -count * wordSize * 2)));</span>
2188     words_pushed += 2;
2189   }
<a name="2" id="anc2"></a><span class="line-modified">2190   for (int i = 2; i &lt; count; i += 2) {</span>













2191     stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
2192     words_pushed += 2;
2193   }
2194 
<a name="3" id="anc3"></a><span class="line-modified">2195   assert(words_pushed == count, &quot;oops, pushed != count&quot;);</span>





2196   return count;
2197 }
2198 
2199 int MacroAssembler::pop_fp(unsigned int bitset, Register stack) {
2200   int words_pushed = 0;
2201 
2202   // Scan bitset to accumulate register pairs
2203   unsigned char regs[32];
2204   int count = 0;
2205   for (int reg = 0; reg &lt;= 31; reg++) {
2206     if (1 &amp; bitset)
2207       regs[count++] = reg;
2208     bitset &gt;&gt;= 1;
2209   }
<a name="4" id="anc4"></a><span class="line-modified">2210   regs[count++] = zr-&gt;encoding_nocheck();</span>
<span class="line-modified">2211   count &amp;= ~1;</span>
<span class="line-removed">2212 </span>
<span class="line-removed">2213   for (int i = 2; i &lt; count; i += 2) {</span>
<span class="line-removed">2214     ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));</span>
2215     words_pushed += 2;
2216   }
<a name="5" id="anc5"></a><span class="line-modified">2217   if (count) {</span>
<span class="line-modified">2218     ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, count * wordSize * 2)));</span>














2219     words_pushed += 2;
2220   }
2221 
<a name="6" id="anc6"></a><span class="line-modified">2222   assert(words_pushed == count, &quot;oops, pushed != count&quot;);</span>



2223 
2224   return count;
2225 }
2226 
2227 #ifdef ASSERT
2228 void MacroAssembler::verify_heapbase(const char* msg) {
2229 #if 0
2230   assert (UseCompressedOops || UseCompressedClassPointers, &quot;should be compressed&quot;);
2231   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
2232   if (!UseCompressedOops || Universe::ptr_base() == NULL) {
2233     // rheapbase is allocated as general register
2234     return;
2235   }
2236   if (CheckCompressedOops) {
2237     Label ok;
2238     push(1 &lt;&lt; rscratch1-&gt;encoding(), sp); // cmpptr trashes rscratch1
2239     cmpptr(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
2240     br(Assembler::EQ, ok);
2241     stop(msg);
2242     bind(ok);
2243     pop(1 &lt;&lt; rscratch1-&gt;encoding(), sp);
2244   }
2245 #endif
2246 }
2247 #endif
2248 
2249 void MacroAssembler::resolve_jobject(Register value, Register thread, Register tmp) {
2250   Label done, not_weak;
2251   cbz(value, done);           // Use NULL as-is.
2252 
2253   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
2254   tbz(r0, 0, not_weak);    // Test for jweak tag.
2255 
2256   // Resolve jweak.
2257   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,
2258                  Address(value, -JNIHandles::weak_tag_value), tmp, thread);
2259   verify_oop(value);
2260   b(done);
2261 
2262   bind(not_weak);
2263   // Resolve (untagged) jobject.
2264   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
2265   verify_oop(value);
2266   bind(done);
2267 }
2268 
2269 void MacroAssembler::stop(const char* msg) {
2270   BLOCK_COMMENT(msg);
2271   dcps1(0xdeae);
2272   emit_int64((uintptr_t)msg);
2273 }
2274 
2275 void MacroAssembler::unimplemented(const char* what) {
2276   const char* buf = NULL;
2277   {
2278     ResourceMark rm;
2279     stringStream ss;
2280     ss.print(&quot;unimplemented: %s&quot;, what);
2281     buf = code_string(ss.as_string());
2282   }
2283   stop(buf);
2284 }
2285 
2286 // If a constant does not fit in an immediate field, generate some
2287 // number of MOV instructions and then perform the operation.
2288 void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
2289                                            add_sub_imm_insn insn1,
2290                                            add_sub_reg_insn insn2) {
2291   assert(Rd != zr, &quot;Rd = zr and not setting flags?&quot;);
2292   if (operand_valid_for_add_sub_immediate((int)imm)) {
2293     (this-&gt;*insn1)(Rd, Rn, imm);
2294   } else {
2295     if (uabs(imm) &lt; (1 &lt;&lt; 24)) {
2296        (this-&gt;*insn1)(Rd, Rn, imm &amp; -(1 &lt;&lt; 12));
2297        (this-&gt;*insn1)(Rd, Rd, imm &amp; ((1 &lt;&lt; 12)-1));
2298     } else {
2299        assert_different_registers(Rd, Rn);
2300        mov(Rd, (uint64_t)imm);
2301        (this-&gt;*insn2)(Rd, Rn, Rd, LSL, 0);
2302     }
2303   }
2304 }
2305 
2306 // Seperate vsn which sets the flags. Optimisations are more restricted
2307 // because we must set the flags correctly.
2308 void MacroAssembler::wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
2309                                            add_sub_imm_insn insn1,
2310                                            add_sub_reg_insn insn2) {
2311   if (operand_valid_for_add_sub_immediate((int)imm)) {
2312     (this-&gt;*insn1)(Rd, Rn, imm);
2313   } else {
2314     assert_different_registers(Rd, Rn);
2315     assert(Rd != zr, &quot;overflow in immediate operand&quot;);
2316     mov(Rd, (uint64_t)imm);
2317     (this-&gt;*insn2)(Rd, Rn, Rd, LSL, 0);
2318   }
2319 }
2320 
2321 
2322 void MacroAssembler::add(Register Rd, Register Rn, RegisterOrConstant increment) {
2323   if (increment.is_register()) {
2324     add(Rd, Rn, increment.as_register());
2325   } else {
2326     add(Rd, Rn, increment.as_constant());
2327   }
2328 }
2329 
2330 void MacroAssembler::addw(Register Rd, Register Rn, RegisterOrConstant increment) {
2331   if (increment.is_register()) {
2332     addw(Rd, Rn, increment.as_register());
2333   } else {
2334     addw(Rd, Rn, increment.as_constant());
2335   }
2336 }
2337 
2338 void MacroAssembler::sub(Register Rd, Register Rn, RegisterOrConstant decrement) {
2339   if (decrement.is_register()) {
2340     sub(Rd, Rn, decrement.as_register());
2341   } else {
2342     sub(Rd, Rn, decrement.as_constant());
2343   }
2344 }
2345 
2346 void MacroAssembler::subw(Register Rd, Register Rn, RegisterOrConstant decrement) {
2347   if (decrement.is_register()) {
2348     subw(Rd, Rn, decrement.as_register());
2349   } else {
2350     subw(Rd, Rn, decrement.as_constant());
2351   }
2352 }
2353 
2354 void MacroAssembler::reinit_heapbase()
2355 {
2356   if (UseCompressedOops) {
2357     if (Universe::is_fully_initialized()) {
2358       mov(rheapbase, CompressedOops::ptrs_base());
2359     } else {
2360       lea(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
2361       ldr(rheapbase, Address(rheapbase));
2362     }
2363   }
2364 }
2365 
2366 // this simulates the behaviour of the x86 cmpxchg instruction using a
2367 // load linked/store conditional pair. we use the acquire/release
2368 // versions of these instructions so that we flush pending writes as
2369 // per Java semantics.
2370 
2371 // n.b the x86 version assumes the old value to be compared against is
2372 // in rax and updates rax with the value located in memory if the
2373 // cmpxchg fails. we supply a register for the old value explicitly
2374 
2375 // the aarch64 load linked/store conditional instructions do not
2376 // accept an offset. so, unlike x86, we must provide a plain register
2377 // to identify the memory word to be compared/exchanged rather than a
2378 // register+offset Address.
2379 
2380 void MacroAssembler::cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
2381                                 Label &amp;succeed, Label *fail) {
2382   // oldv holds comparison value
2383   // newv holds value to write in exchange
2384   // addr identifies memory word to compare against/update
2385   if (UseLSE) {
2386     mov(tmp, oldv);
2387     casal(Assembler::xword, oldv, newv, addr);
2388     cmp(tmp, oldv);
2389     br(Assembler::EQ, succeed);
2390     membar(AnyAny);
2391   } else {
2392     Label retry_load, nope;
2393     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2394       prfm(Address(addr), PSTL1STRM);
2395     bind(retry_load);
2396     // flush and load exclusive from the memory location
2397     // and fail if it is not what we expect
2398     ldaxr(tmp, addr);
2399     cmp(tmp, oldv);
2400     br(Assembler::NE, nope);
2401     // if we store+flush with no intervening write tmp wil be zero
2402     stlxr(tmp, newv, addr);
2403     cbzw(tmp, succeed);
2404     // retry so we only ever return after a load fails to compare
2405     // ensures we don&#39;t return a stale value after a failed write.
2406     b(retry_load);
2407     // if the memory word differs we return it in oldv and signal a fail
2408     bind(nope);
2409     membar(AnyAny);
2410     mov(oldv, tmp);
2411   }
2412   if (fail)
2413     b(*fail);
2414 }
2415 
2416 void MacroAssembler::cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
2417                                         Label &amp;succeed, Label *fail) {
2418   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;assumption&quot;);
2419   cmpxchgptr(oldv, newv, obj, tmp, succeed, fail);
2420 }
2421 
2422 void MacroAssembler::cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
2423                                 Label &amp;succeed, Label *fail) {
2424   // oldv holds comparison value
2425   // newv holds value to write in exchange
2426   // addr identifies memory word to compare against/update
2427   // tmp returns 0/1 for success/failure
2428   if (UseLSE) {
2429     mov(tmp, oldv);
2430     casal(Assembler::word, oldv, newv, addr);
2431     cmp(tmp, oldv);
2432     br(Assembler::EQ, succeed);
2433     membar(AnyAny);
2434   } else {
2435     Label retry_load, nope;
2436     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2437       prfm(Address(addr), PSTL1STRM);
2438     bind(retry_load);
2439     // flush and load exclusive from the memory location
2440     // and fail if it is not what we expect
2441     ldaxrw(tmp, addr);
2442     cmp(tmp, oldv);
2443     br(Assembler::NE, nope);
2444     // if we store+flush with no intervening write tmp wil be zero
2445     stlxrw(tmp, newv, addr);
2446     cbzw(tmp, succeed);
2447     // retry so we only ever return after a load fails to compare
2448     // ensures we don&#39;t return a stale value after a failed write.
2449     b(retry_load);
2450     // if the memory word differs we return it in oldv and signal a fail
2451     bind(nope);
2452     membar(AnyAny);
2453     mov(oldv, tmp);
2454   }
2455   if (fail)
2456     b(*fail);
2457 }
2458 
2459 // A generic CAS; success or failure is in the EQ flag.  A weak CAS
2460 // doesn&#39;t retry and may fail spuriously.  If the oldval is wanted,
2461 // Pass a register for the result, otherwise pass noreg.
2462 
2463 // Clobbers rscratch1
2464 void MacroAssembler::cmpxchg(Register addr, Register expected,
2465                              Register new_val,
2466                              enum operand_size size,
2467                              bool acquire, bool release,
2468                              bool weak,
2469                              Register result) {
2470   if (result == noreg)  result = rscratch1;
2471   BLOCK_COMMENT(&quot;cmpxchg {&quot;);
2472   if (UseLSE) {
2473     mov(result, expected);
2474     lse_cas(result, new_val, addr, size, acquire, release, /*not_pair*/ true);
2475     compare_eq(result, expected, size);
2476   } else {
2477     Label retry_load, done;
2478     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2479       prfm(Address(addr), PSTL1STRM);
2480     bind(retry_load);
2481     load_exclusive(result, addr, size, acquire);
2482     compare_eq(result, expected, size);
2483     br(Assembler::NE, done);
2484     store_exclusive(rscratch1, new_val, addr, size, release);
2485     if (weak) {
2486       cmpw(rscratch1, 0u);  // If the store fails, return NE to our caller.
2487     } else {
2488       cbnzw(rscratch1, retry_load);
2489     }
2490     bind(done);
2491   }
2492   BLOCK_COMMENT(&quot;} cmpxchg&quot;);
2493 }
2494 
2495 // A generic comparison. Only compares for equality, clobbers rscratch1.
2496 void MacroAssembler::compare_eq(Register rm, Register rn, enum operand_size size) {
2497   if (size == xword) {
2498     cmp(rm, rn);
2499   } else if (size == word) {
2500     cmpw(rm, rn);
2501   } else if (size == halfword) {
2502     eorw(rscratch1, rm, rn);
2503     ands(zr, rscratch1, 0xffff);
2504   } else if (size == byte) {
2505     eorw(rscratch1, rm, rn);
2506     ands(zr, rscratch1, 0xff);
2507   } else {
2508     ShouldNotReachHere();
2509   }
2510 }
2511 
2512 
2513 static bool different(Register a, RegisterOrConstant b, Register c) {
2514   if (b.is_constant())
2515     return a != c;
2516   else
2517     return a != b.as_register() &amp;&amp; a != c &amp;&amp; b.as_register() != c;
2518 }
2519 
2520 #define ATOMIC_OP(NAME, LDXR, OP, IOP, AOP, STXR, sz)                   \
2521 void MacroAssembler::atomic_##NAME(Register prev, RegisterOrConstant incr, Register addr) { \
2522   if (UseLSE) {                                                         \
2523     prev = prev-&gt;is_valid() ? prev : zr;                                \
2524     if (incr.is_register()) {                                           \
2525       AOP(sz, incr.as_register(), prev, addr);                          \
2526     } else {                                                            \
2527       mov(rscratch2, incr.as_constant());                               \
2528       AOP(sz, rscratch2, prev, addr);                                   \
2529     }                                                                   \
2530     return;                                                             \
2531   }                                                                     \
2532   Register result = rscratch2;                                          \
2533   if (prev-&gt;is_valid())                                                 \
2534     result = different(prev, incr, addr) ? prev : rscratch2;            \
2535                                                                         \
2536   Label retry_load;                                                     \
2537   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))         \
2538     prfm(Address(addr), PSTL1STRM);                                     \
2539   bind(retry_load);                                                     \
2540   LDXR(result, addr);                                                   \
2541   OP(rscratch1, result, incr);                                          \
2542   STXR(rscratch2, rscratch1, addr);                                     \
2543   cbnzw(rscratch2, retry_load);                                         \
2544   if (prev-&gt;is_valid() &amp;&amp; prev != result) {                             \
2545     IOP(prev, rscratch1, incr);                                         \
2546   }                                                                     \
2547 }
2548 
2549 ATOMIC_OP(add, ldxr, add, sub, ldadd, stxr, Assembler::xword)
2550 ATOMIC_OP(addw, ldxrw, addw, subw, ldadd, stxrw, Assembler::word)
2551 ATOMIC_OP(addal, ldaxr, add, sub, ldaddal, stlxr, Assembler::xword)
2552 ATOMIC_OP(addalw, ldaxrw, addw, subw, ldaddal, stlxrw, Assembler::word)
2553 
2554 #undef ATOMIC_OP
2555 
2556 #define ATOMIC_XCHG(OP, AOP, LDXR, STXR, sz)                            \
2557 void MacroAssembler::atomic_##OP(Register prev, Register newv, Register addr) { \
2558   if (UseLSE) {                                                         \
2559     prev = prev-&gt;is_valid() ? prev : zr;                                \
2560     AOP(sz, newv, prev, addr);                                          \
2561     return;                                                             \
2562   }                                                                     \
2563   Register result = rscratch2;                                          \
2564   if (prev-&gt;is_valid())                                                 \
2565     result = different(prev, newv, addr) ? prev : rscratch2;            \
2566                                                                         \
2567   Label retry_load;                                                     \
2568   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))         \
2569     prfm(Address(addr), PSTL1STRM);                                     \
2570   bind(retry_load);                                                     \
2571   LDXR(result, addr);                                                   \
2572   STXR(rscratch1, newv, addr);                                          \
2573   cbnzw(rscratch1, retry_load);                                         \
2574   if (prev-&gt;is_valid() &amp;&amp; prev != result)                               \
2575     mov(prev, result);                                                  \
2576 }
2577 
2578 ATOMIC_XCHG(xchg, swp, ldxr, stxr, Assembler::xword)
2579 ATOMIC_XCHG(xchgw, swp, ldxrw, stxrw, Assembler::word)
2580 ATOMIC_XCHG(xchgal, swpal, ldaxr, stlxr, Assembler::xword)
2581 ATOMIC_XCHG(xchgalw, swpal, ldaxrw, stlxrw, Assembler::word)
2582 
2583 #undef ATOMIC_XCHG
2584 
2585 #ifndef PRODUCT
2586 extern &quot;C&quot; void findpc(intptr_t x);
2587 #endif
2588 
2589 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[])
2590 {
2591   // In order to get locks to work, we need to fake a in_VM state
2592   if (ShowMessageBoxOnError ) {
2593     JavaThread* thread = JavaThread::current();
2594     JavaThreadState saved_state = thread-&gt;thread_state();
2595     thread-&gt;set_thread_state(_thread_in_vm);
2596 #ifndef PRODUCT
2597     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
2598       ttyLocker ttyl;
2599       BytecodeCounter::print();
2600     }
2601 #endif
2602     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
2603       ttyLocker ttyl;
2604       tty-&gt;print_cr(&quot; pc = 0x%016lx&quot;, pc);
2605 #ifndef PRODUCT
2606       tty-&gt;cr();
2607       findpc(pc);
2608       tty-&gt;cr();
2609 #endif
2610       tty-&gt;print_cr(&quot; r0 = 0x%016lx&quot;, regs[0]);
2611       tty-&gt;print_cr(&quot; r1 = 0x%016lx&quot;, regs[1]);
2612       tty-&gt;print_cr(&quot; r2 = 0x%016lx&quot;, regs[2]);
2613       tty-&gt;print_cr(&quot; r3 = 0x%016lx&quot;, regs[3]);
2614       tty-&gt;print_cr(&quot; r4 = 0x%016lx&quot;, regs[4]);
2615       tty-&gt;print_cr(&quot; r5 = 0x%016lx&quot;, regs[5]);
2616       tty-&gt;print_cr(&quot; r6 = 0x%016lx&quot;, regs[6]);
2617       tty-&gt;print_cr(&quot; r7 = 0x%016lx&quot;, regs[7]);
2618       tty-&gt;print_cr(&quot; r8 = 0x%016lx&quot;, regs[8]);
2619       tty-&gt;print_cr(&quot; r9 = 0x%016lx&quot;, regs[9]);
2620       tty-&gt;print_cr(&quot;r10 = 0x%016lx&quot;, regs[10]);
2621       tty-&gt;print_cr(&quot;r11 = 0x%016lx&quot;, regs[11]);
2622       tty-&gt;print_cr(&quot;r12 = 0x%016lx&quot;, regs[12]);
2623       tty-&gt;print_cr(&quot;r13 = 0x%016lx&quot;, regs[13]);
2624       tty-&gt;print_cr(&quot;r14 = 0x%016lx&quot;, regs[14]);
2625       tty-&gt;print_cr(&quot;r15 = 0x%016lx&quot;, regs[15]);
2626       tty-&gt;print_cr(&quot;r16 = 0x%016lx&quot;, regs[16]);
2627       tty-&gt;print_cr(&quot;r17 = 0x%016lx&quot;, regs[17]);
2628       tty-&gt;print_cr(&quot;r18 = 0x%016lx&quot;, regs[18]);
2629       tty-&gt;print_cr(&quot;r19 = 0x%016lx&quot;, regs[19]);
2630       tty-&gt;print_cr(&quot;r20 = 0x%016lx&quot;, regs[20]);
2631       tty-&gt;print_cr(&quot;r21 = 0x%016lx&quot;, regs[21]);
2632       tty-&gt;print_cr(&quot;r22 = 0x%016lx&quot;, regs[22]);
2633       tty-&gt;print_cr(&quot;r23 = 0x%016lx&quot;, regs[23]);
2634       tty-&gt;print_cr(&quot;r24 = 0x%016lx&quot;, regs[24]);
2635       tty-&gt;print_cr(&quot;r25 = 0x%016lx&quot;, regs[25]);
2636       tty-&gt;print_cr(&quot;r26 = 0x%016lx&quot;, regs[26]);
2637       tty-&gt;print_cr(&quot;r27 = 0x%016lx&quot;, regs[27]);
2638       tty-&gt;print_cr(&quot;r28 = 0x%016lx&quot;, regs[28]);
2639       tty-&gt;print_cr(&quot;r30 = 0x%016lx&quot;, regs[30]);
2640       tty-&gt;print_cr(&quot;r31 = 0x%016lx&quot;, regs[31]);
2641       BREAKPOINT;
2642     }
2643   }
2644   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
2645 }
2646 
2647 void MacroAssembler::push_call_clobbered_registers() {
2648   int step = 4 * wordSize;
2649   push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
2650   sub(sp, sp, step);
2651   mov(rscratch1, -step);
2652   // Push v0-v7, v16-v31.
2653   for (int i = 31; i&gt;= 4; i -= 4) {
2654     if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
2655       st1(as_FloatRegister(i-3), as_FloatRegister(i-2), as_FloatRegister(i-1),
2656           as_FloatRegister(i), T1D, Address(post(sp, rscratch1)));
2657   }
2658   st1(as_FloatRegister(0), as_FloatRegister(1), as_FloatRegister(2),
2659       as_FloatRegister(3), T1D, Address(sp));
2660 }
2661 
2662 void MacroAssembler::pop_call_clobbered_registers() {
2663   for (int i = 0; i &lt; 32; i += 4) {
2664     if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
2665       ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2666           as_FloatRegister(i+3), T1D, Address(post(sp, 4 * wordSize)));
2667   }
2668 
2669   pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
2670 }
2671 
2672 void MacroAssembler::push_CPU_state(bool save_vectors) {
2673   int step = (save_vectors ? 8 : 4) * wordSize;
2674   push(0x3fffffff, sp);         // integer registers except lr &amp; sp
2675   mov(rscratch1, -step);
2676   sub(sp, sp, step);
2677   for (int i = 28; i &gt;= 4; i -= 4) {
2678     st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2679         as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));
2680   }
2681   st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);
2682 }
2683 
2684 void MacroAssembler::pop_CPU_state(bool restore_vectors) {
2685   int step = (restore_vectors ? 8 : 4) * wordSize;
2686   for (int i = 0; i &lt;= 28; i += 4)
2687     ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2688         as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));
2689   pop(0x3fffffff, sp);         // integer registers except lr &amp; sp
2690 }
2691 
2692 /**
2693  * Helpers for multiply_to_len().
2694  */
2695 void MacroAssembler::add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
2696                                      Register src1, Register src2) {
2697   adds(dest_lo, dest_lo, src1);
2698   adc(dest_hi, dest_hi, zr);
2699   adds(dest_lo, dest_lo, src2);
2700   adc(final_dest_hi, dest_hi, zr);
2701 }
2702 
2703 // Generate an address from (r + r1 extend offset).  &quot;size&quot; is the
2704 // size of the operand.  The result may be in rscratch2.
2705 Address MacroAssembler::offsetted_address(Register r, Register r1,
2706                                           Address::extend ext, int offset, int size) {
2707   if (offset || (ext.shift() % size != 0)) {
2708     lea(rscratch2, Address(r, r1, ext));
2709     return Address(rscratch2, offset);
2710   } else {
2711     return Address(r, r1, ext);
2712   }
2713 }
2714 
2715 Address MacroAssembler::spill_address(int size, int offset, Register tmp)
2716 {
2717   assert(offset &gt;= 0, &quot;spill to negative address?&quot;);
2718   // Offset reachable ?
2719   //   Not aligned - 9 bits signed offset
2720   //   Aligned - 12 bits unsigned offset shifted
2721   Register base = sp;
2722   if ((offset &amp; (size-1)) &amp;&amp; offset &gt;= (1&lt;&lt;8)) {
2723     add(tmp, base, offset &amp; ((1&lt;&lt;12)-1));
2724     base = tmp;
2725     offset &amp;= -1u&lt;&lt;12;
2726   }
2727 
2728   if (offset &gt;= (1&lt;&lt;12) * size) {
2729     add(tmp, base, offset &amp; (((1&lt;&lt;12)-1)&lt;&lt;12));
2730     base = tmp;
2731     offset &amp;= ~(((1&lt;&lt;12)-1)&lt;&lt;12);
2732   }
2733 
2734   return Address(base, offset);
2735 }
2736 
2737 // Checks whether offset is aligned.
2738 // Returns true if it is, else false.
2739 bool MacroAssembler::merge_alignment_check(Register base,
2740                                            size_t size,
2741                                            long cur_offset,
2742                                            long prev_offset) const {
2743   if (AvoidUnalignedAccesses) {
2744     if (base == sp) {
2745       // Checks whether low offset if aligned to pair of registers.
2746       long pair_mask = size * 2 - 1;
2747       long offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;
2748       return (offset &amp; pair_mask) == 0;
2749     } else { // If base is not sp, we can&#39;t guarantee the access is aligned.
2750       return false;
2751     }
2752   } else {
2753     long mask = size - 1;
2754     // Load/store pair instruction only supports element size aligned offset.
2755     return (cur_offset &amp; mask) == 0 &amp;&amp; (prev_offset &amp; mask) == 0;
2756   }
2757 }
2758 
2759 // Checks whether current and previous loads/stores can be merged.
2760 // Returns true if it can be merged, else false.
2761 bool MacroAssembler::ldst_can_merge(Register rt,
2762                                     const Address &amp;adr,
2763                                     size_t cur_size_in_bytes,
2764                                     bool is_store) const {
2765   address prev = pc() - NativeInstruction::instruction_size;
2766   address last = code()-&gt;last_insn();
2767 
2768   if (last == NULL || !nativeInstruction_at(last)-&gt;is_Imm_LdSt()) {
2769     return false;
2770   }
2771 
2772   if (adr.getMode() != Address::base_plus_offset || prev != last) {
2773     return false;
2774   }
2775 
2776   NativeLdSt* prev_ldst = NativeLdSt_at(prev);
2777   size_t prev_size_in_bytes = prev_ldst-&gt;size_in_bytes();
2778 
2779   assert(prev_size_in_bytes == 4 || prev_size_in_bytes == 8, &quot;only supports 64/32bit merging.&quot;);
2780   assert(cur_size_in_bytes == 4 || cur_size_in_bytes == 8, &quot;only supports 64/32bit merging.&quot;);
2781 
2782   if (cur_size_in_bytes != prev_size_in_bytes || is_store != prev_ldst-&gt;is_store()) {
2783     return false;
2784   }
2785 
2786   long max_offset = 63 * prev_size_in_bytes;
2787   long min_offset = -64 * prev_size_in_bytes;
2788 
2789   assert(prev_ldst-&gt;is_not_pre_post_index(), &quot;pre-index or post-index is not supported to be merged.&quot;);
2790 
2791   // Only same base can be merged.
2792   if (adr.base() != prev_ldst-&gt;base()) {
2793     return false;
2794   }
2795 
2796   long cur_offset = adr.offset();
2797   long prev_offset = prev_ldst-&gt;offset();
2798   size_t diff = abs(cur_offset - prev_offset);
2799   if (diff != prev_size_in_bytes) {
2800     return false;
2801   }
2802 
2803   // Following cases can not be merged:
2804   // ldr x2, [x2, #8]
2805   // ldr x3, [x2, #16]
2806   // or:
2807   // ldr x2, [x3, #8]
2808   // ldr x2, [x3, #16]
2809   // If t1 and t2 is the same in &quot;ldp t1, t2, [xn, #imm]&quot;, we&#39;ll get SIGILL.
2810   if (!is_store &amp;&amp; (adr.base() == prev_ldst-&gt;target() || rt == prev_ldst-&gt;target())) {
2811     return false;
2812   }
2813 
2814   long low_offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;
2815   // Offset range must be in ldp/stp instruction&#39;s range.
2816   if (low_offset &gt; max_offset || low_offset &lt; min_offset) {
2817     return false;
2818   }
2819 
2820   if (merge_alignment_check(adr.base(), prev_size_in_bytes, cur_offset, prev_offset)) {
2821     return true;
2822   }
2823 
2824   return false;
2825 }
2826 
2827 // Merge current load/store with previous load/store into ldp/stp.
2828 void MacroAssembler::merge_ldst(Register rt,
2829                                 const Address &amp;adr,
2830                                 size_t cur_size_in_bytes,
2831                                 bool is_store) {
2832 
2833   assert(ldst_can_merge(rt, adr, cur_size_in_bytes, is_store) == true, &quot;cur and prev must be able to be merged.&quot;);
2834 
2835   Register rt_low, rt_high;
2836   address prev = pc() - NativeInstruction::instruction_size;
2837   NativeLdSt* prev_ldst = NativeLdSt_at(prev);
2838 
2839   long offset;
2840 
2841   if (adr.offset() &lt; prev_ldst-&gt;offset()) {
2842     offset = adr.offset();
2843     rt_low = rt;
2844     rt_high = prev_ldst-&gt;target();
2845   } else {
2846     offset = prev_ldst-&gt;offset();
2847     rt_low = prev_ldst-&gt;target();
2848     rt_high = rt;
2849   }
2850 
2851   Address adr_p = Address(prev_ldst-&gt;base(), offset);
2852   // Overwrite previous generated binary.
2853   code_section()-&gt;set_end(prev);
2854 
2855   const int sz = prev_ldst-&gt;size_in_bytes();
2856   assert(sz == 8 || sz == 4, &quot;only supports 64/32bit merging.&quot;);
2857   if (!is_store) {
2858     BLOCK_COMMENT(&quot;merged ldr pair&quot;);
2859     if (sz == 8) {
2860       ldp(rt_low, rt_high, adr_p);
2861     } else {
2862       ldpw(rt_low, rt_high, adr_p);
2863     }
2864   } else {
2865     BLOCK_COMMENT(&quot;merged str pair&quot;);
2866     if (sz == 8) {
2867       stp(rt_low, rt_high, adr_p);
2868     } else {
2869       stpw(rt_low, rt_high, adr_p);
2870     }
2871   }
2872 }
2873 
2874 /**
2875  * Multiply 64 bit by 64 bit first loop.
2876  */
2877 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
2878                                            Register y, Register y_idx, Register z,
2879                                            Register carry, Register product,
2880                                            Register idx, Register kdx) {
2881   //
2882   //  jlong carry, x[], y[], z[];
2883   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
2884   //    huge_128 product = y[idx] * x[xstart] + carry;
2885   //    z[kdx] = (jlong)product;
2886   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
2887   //  }
2888   //  z[xstart] = carry;
2889   //
2890 
2891   Label L_first_loop, L_first_loop_exit;
2892   Label L_one_x, L_one_y, L_multiply;
2893 
2894   subsw(xstart, xstart, 1);
2895   br(Assembler::MI, L_one_x);
2896 
2897   lea(rscratch1, Address(x, xstart, Address::lsl(LogBytesPerInt)));
2898   ldr(x_xstart, Address(rscratch1));
2899   ror(x_xstart, x_xstart, 32); // convert big-endian to little-endian
2900 
2901   bind(L_first_loop);
2902   subsw(idx, idx, 1);
2903   br(Assembler::MI, L_first_loop_exit);
2904   subsw(idx, idx, 1);
2905   br(Assembler::MI, L_one_y);
2906   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2907   ldr(y_idx, Address(rscratch1));
2908   ror(y_idx, y_idx, 32); // convert big-endian to little-endian
2909   bind(L_multiply);
2910 
2911   // AArch64 has a multiply-accumulate instruction that we can&#39;t use
2912   // here because it has no way to process carries, so we have to use
2913   // separate add and adc instructions.  Bah.
2914   umulh(rscratch1, x_xstart, y_idx); // x_xstart * y_idx -&gt; rscratch1:product
2915   mul(product, x_xstart, y_idx);
2916   adds(product, product, carry);
2917   adc(carry, rscratch1, zr);   // x_xstart * y_idx + carry -&gt; carry:product
2918 
2919   subw(kdx, kdx, 2);
2920   ror(product, product, 32); // back to big-endian
2921   str(product, offsetted_address(z, kdx, Address::uxtw(LogBytesPerInt), 0, BytesPerLong));
2922 
2923   b(L_first_loop);
2924 
2925   bind(L_one_y);
2926   ldrw(y_idx, Address(y,  0));
2927   b(L_multiply);
2928 
2929   bind(L_one_x);
2930   ldrw(x_xstart, Address(x,  0));
2931   b(L_first_loop);
2932 
2933   bind(L_first_loop_exit);
2934 }
2935 
2936 /**
2937  * Multiply 128 bit by 128. Unrolled inner loop.
2938  *
2939  */
2940 void MacroAssembler::multiply_128_x_128_loop(Register y, Register z,
2941                                              Register carry, Register carry2,
2942                                              Register idx, Register jdx,
2943                                              Register yz_idx1, Register yz_idx2,
2944                                              Register tmp, Register tmp3, Register tmp4,
2945                                              Register tmp6, Register product_hi) {
2946 
2947   //   jlong carry, x[], y[], z[];
2948   //   int kdx = ystart+1;
2949   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
2950   //     huge_128 tmp3 = (y[idx+1] * product_hi) + z[kdx+idx+1] + carry;
2951   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
2952   //     huge_128 tmp4 = (y[idx]   * product_hi) + z[kdx+idx] + carry2;
2953   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
2954   //     z[kdx+idx+1] = (jlong)tmp3;
2955   //     z[kdx+idx] = (jlong)tmp4;
2956   //   }
2957   //   idx += 2;
2958   //   if (idx &gt; 0) {
2959   //     yz_idx1 = (y[idx] * product_hi) + z[kdx+idx] + carry;
2960   //     z[kdx+idx] = (jlong)yz_idx1;
2961   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
2962   //   }
2963   //
2964 
2965   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
2966 
2967   lsrw(jdx, idx, 2);
2968 
2969   bind(L_third_loop);
2970 
2971   subsw(jdx, jdx, 1);
2972   br(Assembler::MI, L_third_loop_exit);
2973   subw(idx, idx, 4);
2974 
2975   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2976 
2977   ldp(yz_idx2, yz_idx1, Address(rscratch1, 0));
2978 
2979   lea(tmp6, Address(z, idx, Address::uxtw(LogBytesPerInt)));
2980 
2981   ror(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
2982   ror(yz_idx2, yz_idx2, 32);
2983 
2984   ldp(rscratch2, rscratch1, Address(tmp6, 0));
2985 
2986   mul(tmp3, product_hi, yz_idx1);  //  yz_idx1 * product_hi -&gt; tmp4:tmp3
2987   umulh(tmp4, product_hi, yz_idx1);
2988 
2989   ror(rscratch1, rscratch1, 32); // convert big-endian to little-endian
2990   ror(rscratch2, rscratch2, 32);
2991 
2992   mul(tmp, product_hi, yz_idx2);   //  yz_idx2 * product_hi -&gt; carry2:tmp
2993   umulh(carry2, product_hi, yz_idx2);
2994 
2995   // propagate sum of both multiplications into carry:tmp4:tmp3
2996   adds(tmp3, tmp3, carry);
2997   adc(tmp4, tmp4, zr);
2998   adds(tmp3, tmp3, rscratch1);
2999   adcs(tmp4, tmp4, tmp);
3000   adc(carry, carry2, zr);
3001   adds(tmp4, tmp4, rscratch2);
3002   adc(carry, carry, zr);
3003 
3004   ror(tmp3, tmp3, 32); // convert little-endian to big-endian
3005   ror(tmp4, tmp4, 32);
3006   stp(tmp4, tmp3, Address(tmp6, 0));
3007 
3008   b(L_third_loop);
3009   bind (L_third_loop_exit);
3010 
3011   andw (idx, idx, 0x3);
3012   cbz(idx, L_post_third_loop_done);
3013 
3014   Label L_check_1;
3015   subsw(idx, idx, 2);
3016   br(Assembler::MI, L_check_1);
3017 
3018   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
3019   ldr(yz_idx1, Address(rscratch1, 0));
3020   ror(yz_idx1, yz_idx1, 32);
3021   mul(tmp3, product_hi, yz_idx1);  //  yz_idx1 * product_hi -&gt; tmp4:tmp3
3022   umulh(tmp4, product_hi, yz_idx1);
3023   lea(rscratch1, Address(z, idx, Address::uxtw(LogBytesPerInt)));
3024   ldr(yz_idx2, Address(rscratch1, 0));
3025   ror(yz_idx2, yz_idx2, 32);
3026 
3027   add2_with_carry(carry, tmp4, tmp3, carry, yz_idx2);
3028 
3029   ror(tmp3, tmp3, 32);
3030   str(tmp3, Address(rscratch1, 0));
3031 
3032   bind (L_check_1);
3033 
3034   andw (idx, idx, 0x1);
3035   subsw(idx, idx, 1);
3036   br(Assembler::MI, L_post_third_loop_done);
3037   ldrw(tmp4, Address(y, idx, Address::uxtw(LogBytesPerInt)));
3038   mul(tmp3, tmp4, product_hi);  //  tmp4 * product_hi -&gt; carry2:tmp3
3039   umulh(carry2, tmp4, product_hi);
3040   ldrw(tmp4, Address(z, idx, Address::uxtw(LogBytesPerInt)));
3041 
3042   add2_with_carry(carry2, tmp3, tmp4, carry);
3043 
3044   strw(tmp3, Address(z, idx, Address::uxtw(LogBytesPerInt)));
3045   extr(carry, carry2, tmp3, 32);
3046 
3047   bind(L_post_third_loop_done);
3048 }
3049 
3050 /**
3051  * Code for BigInteger::multiplyToLen() instrinsic.
3052  *
3053  * r0: x
3054  * r1: xlen
3055  * r2: y
3056  * r3: ylen
3057  * r4:  z
3058  * r5: zlen
3059  * r10: tmp1
3060  * r11: tmp2
3061  * r12: tmp3
3062  * r13: tmp4
3063  * r14: tmp5
3064  * r15: tmp6
3065  * r16: tmp7
3066  *
3067  */
3068 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen,
3069                                      Register z, Register zlen,
3070                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4,
3071                                      Register tmp5, Register tmp6, Register product_hi) {
3072 
3073   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);
3074 
3075   const Register idx = tmp1;
3076   const Register kdx = tmp2;
3077   const Register xstart = tmp3;
3078 
3079   const Register y_idx = tmp4;
3080   const Register carry = tmp5;
3081   const Register product  = xlen;
3082   const Register x_xstart = zlen;  // reuse register
3083 
3084   // First Loop.
3085   //
3086   //  final static long LONG_MASK = 0xffffffffL;
3087   //  int xstart = xlen - 1;
3088   //  int ystart = ylen - 1;
3089   //  long carry = 0;
3090   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
3091   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
3092   //    z[kdx] = (int)product;
3093   //    carry = product &gt;&gt;&gt; 32;
3094   //  }
3095   //  z[xstart] = (int)carry;
3096   //
3097 
3098   movw(idx, ylen);      // idx = ylen;
3099   movw(kdx, zlen);      // kdx = xlen+ylen;
3100   mov(carry, zr);       // carry = 0;
3101 
3102   Label L_done;
3103 
3104   movw(xstart, xlen);
3105   subsw(xstart, xstart, 1);
3106   br(Assembler::MI, L_done);
3107 
3108   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
3109 
3110   Label L_second_loop;
3111   cbzw(kdx, L_second_loop);
3112 
3113   Label L_carry;
3114   subw(kdx, kdx, 1);
3115   cbzw(kdx, L_carry);
3116 
3117   strw(carry, Address(z, kdx, Address::uxtw(LogBytesPerInt)));
3118   lsr(carry, carry, 32);
3119   subw(kdx, kdx, 1);
3120 
3121   bind(L_carry);
3122   strw(carry, Address(z, kdx, Address::uxtw(LogBytesPerInt)));
3123 
3124   // Second and third (nested) loops.
3125   //
3126   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
3127   //   carry = 0;
3128   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
3129   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
3130   //                    (z[k] &amp; LONG_MASK) + carry;
3131   //     z[k] = (int)product;
3132   //     carry = product &gt;&gt;&gt; 32;
3133   //   }
3134   //   z[i] = (int)carry;
3135   // }
3136   //
3137   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = product_hi
3138 
3139   const Register jdx = tmp1;
3140 
3141   bind(L_second_loop);
3142   mov(carry, zr);                // carry = 0;
3143   movw(jdx, ylen);               // j = ystart+1
3144 
3145   subsw(xstart, xstart, 1);      // i = xstart-1;
3146   br(Assembler::MI, L_done);
3147 
3148   str(z, Address(pre(sp, -4 * wordSize)));
3149 
3150   Label L_last_x;
3151   lea(z, offsetted_address(z, xstart, Address::uxtw(LogBytesPerInt), 4, BytesPerInt)); // z = z + k - j
3152   subsw(xstart, xstart, 1);       // i = xstart-1;
3153   br(Assembler::MI, L_last_x);
3154 
3155   lea(rscratch1, Address(x, xstart, Address::uxtw(LogBytesPerInt)));
3156   ldr(product_hi, Address(rscratch1));
3157   ror(product_hi, product_hi, 32);  // convert big-endian to little-endian
3158 
3159   Label L_third_loop_prologue;
3160   bind(L_third_loop_prologue);
3161 
3162   str(ylen, Address(sp, wordSize));
3163   stp(x, xstart, Address(sp, 2 * wordSize));
3164   multiply_128_x_128_loop(y, z, carry, x, jdx, ylen, product,
3165                           tmp2, x_xstart, tmp3, tmp4, tmp6, product_hi);
3166   ldp(z, ylen, Address(post(sp, 2 * wordSize)));
3167   ldp(x, xlen, Address(post(sp, 2 * wordSize)));   // copy old xstart -&gt; xlen
3168 
3169   addw(tmp3, xlen, 1);
3170   strw(carry, Address(z, tmp3, Address::uxtw(LogBytesPerInt)));
3171   subsw(tmp3, tmp3, 1);
3172   br(Assembler::MI, L_done);
3173 
3174   lsr(carry, carry, 32);
3175   strw(carry, Address(z, tmp3, Address::uxtw(LogBytesPerInt)));
3176   b(L_second_loop);
3177 
3178   // Next infrequent code is moved outside loops.
3179   bind(L_last_x);
3180   ldrw(product_hi, Address(x,  0));
3181   b(L_third_loop_prologue);
3182 
3183   bind(L_done);
3184 }
3185 
3186 // Code for BigInteger::mulAdd instrinsic
3187 // out     = r0
3188 // in      = r1
3189 // offset  = r2  (already out.length-offset)
3190 // len     = r3
3191 // k       = r4
3192 //
3193 // pseudo code from java implementation:
3194 // carry = 0;
3195 // offset = out.length-offset - 1;
3196 // for (int j=len-1; j &gt;= 0; j--) {
3197 //     product = (in[j] &amp; LONG_MASK) * kLong + (out[offset] &amp; LONG_MASK) + carry;
3198 //     out[offset--] = (int)product;
3199 //     carry = product &gt;&gt;&gt; 32;
3200 // }
3201 // return (int)carry;
3202 void MacroAssembler::mul_add(Register out, Register in, Register offset,
3203       Register len, Register k) {
3204     Label LOOP, END;
3205     // pre-loop
3206     cmp(len, zr); // cmp, not cbz/cbnz: to use condition twice =&gt; less branches
3207     csel(out, zr, out, Assembler::EQ);
3208     br(Assembler::EQ, END);
3209     add(in, in, len, LSL, 2); // in[j+1] address
3210     add(offset, out, offset, LSL, 2); // out[offset + 1] address
3211     mov(out, zr); // used to keep carry now
3212     BIND(LOOP);
3213     ldrw(rscratch1, Address(pre(in, -4)));
3214     madd(rscratch1, rscratch1, k, out);
3215     ldrw(rscratch2, Address(pre(offset, -4)));
3216     add(rscratch1, rscratch1, rscratch2);
3217     strw(rscratch1, Address(offset));
3218     lsr(out, rscratch1, 32);
3219     subs(len, len, 1);
3220     br(Assembler::NE, LOOP);
3221     BIND(END);
3222 }
3223 
3224 /**
3225  * Emits code to update CRC-32 with a byte value according to constants in table
3226  *
3227  * @param [in,out]crc   Register containing the crc.
3228  * @param [in]val       Register containing the byte to fold into the CRC.
3229  * @param [in]table     Register containing the table of crc constants.
3230  *
3231  * uint32_t crc;
3232  * val = crc_table[(val ^ crc) &amp; 0xFF];
3233  * crc = val ^ (crc &gt;&gt; 8);
3234  *
3235  */
3236 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
3237   eor(val, val, crc);
3238   andr(val, val, 0xff);
3239   ldrw(val, Address(table, val, Address::lsl(2)));
3240   eor(crc, val, crc, Assembler::LSR, 8);
3241 }
3242 
3243 /**
3244  * Emits code to update CRC-32 with a 32-bit value according to tables 0 to 3
3245  *
3246  * @param [in,out]crc   Register containing the crc.
3247  * @param [in]v         Register containing the 32-bit to fold into the CRC.
3248  * @param [in]table0    Register containing table 0 of crc constants.
3249  * @param [in]table1    Register containing table 1 of crc constants.
3250  * @param [in]table2    Register containing table 2 of crc constants.
3251  * @param [in]table3    Register containing table 3 of crc constants.
3252  *
3253  * uint32_t crc;
3254  *   v = crc ^ v
3255  *   crc = table3[v&amp;0xff]^table2[(v&gt;&gt;8)&amp;0xff]^table1[(v&gt;&gt;16)&amp;0xff]^table0[v&gt;&gt;24]
3256  *
3257  */
3258 void MacroAssembler::update_word_crc32(Register crc, Register v, Register tmp,
3259         Register table0, Register table1, Register table2, Register table3,
3260         bool upper) {
3261   eor(v, crc, v, upper ? LSR:LSL, upper ? 32:0);
3262   uxtb(tmp, v);
3263   ldrw(crc, Address(table3, tmp, Address::lsl(2)));
3264   ubfx(tmp, v, 8, 8);
3265   ldrw(tmp, Address(table2, tmp, Address::lsl(2)));
3266   eor(crc, crc, tmp);
3267   ubfx(tmp, v, 16, 8);
3268   ldrw(tmp, Address(table1, tmp, Address::lsl(2)));
3269   eor(crc, crc, tmp);
3270   ubfx(tmp, v, 24, 8);
3271   ldrw(tmp, Address(table0, tmp, Address::lsl(2)));
3272   eor(crc, crc, tmp);
3273 }
3274 
3275 void MacroAssembler::kernel_crc32_using_crc32(Register crc, Register buf,
3276         Register len, Register tmp0, Register tmp1, Register tmp2,
3277         Register tmp3) {
3278     Label CRC_by64_loop, CRC_by4_loop, CRC_by1_loop, CRC_less64, CRC_by64_pre, CRC_by32_loop, CRC_less32, L_exit;
3279     assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2, tmp3);
3280 
3281     mvnw(crc, crc);
3282 
3283     subs(len, len, 128);
3284     br(Assembler::GE, CRC_by64_pre);
3285   BIND(CRC_less64);
3286     adds(len, len, 128-32);
3287     br(Assembler::GE, CRC_by32_loop);
3288   BIND(CRC_less32);
3289     adds(len, len, 32-4);
3290     br(Assembler::GE, CRC_by4_loop);
3291     adds(len, len, 4);
3292     br(Assembler::GT, CRC_by1_loop);
3293     b(L_exit);
3294 
3295   BIND(CRC_by32_loop);
3296     ldp(tmp0, tmp1, Address(post(buf, 16)));
3297     subs(len, len, 32);
3298     crc32x(crc, crc, tmp0);
3299     ldr(tmp2, Address(post(buf, 8)));
3300     crc32x(crc, crc, tmp1);
3301     ldr(tmp3, Address(post(buf, 8)));
3302     crc32x(crc, crc, tmp2);
3303     crc32x(crc, crc, tmp3);
3304     br(Assembler::GE, CRC_by32_loop);
3305     cmn(len, 32);
3306     br(Assembler::NE, CRC_less32);
3307     b(L_exit);
3308 
3309   BIND(CRC_by4_loop);
3310     ldrw(tmp0, Address(post(buf, 4)));
3311     subs(len, len, 4);
3312     crc32w(crc, crc, tmp0);
3313     br(Assembler::GE, CRC_by4_loop);
3314     adds(len, len, 4);
3315     br(Assembler::LE, L_exit);
3316   BIND(CRC_by1_loop);
3317     ldrb(tmp0, Address(post(buf, 1)));
3318     subs(len, len, 1);
3319     crc32b(crc, crc, tmp0);
3320     br(Assembler::GT, CRC_by1_loop);
3321     b(L_exit);
3322 
3323   BIND(CRC_by64_pre);
3324     sub(buf, buf, 8);
3325     ldp(tmp0, tmp1, Address(buf, 8));
3326     crc32x(crc, crc, tmp0);
3327     ldr(tmp2, Address(buf, 24));
3328     crc32x(crc, crc, tmp1);
3329     ldr(tmp3, Address(buf, 32));
3330     crc32x(crc, crc, tmp2);
3331     ldr(tmp0, Address(buf, 40));
3332     crc32x(crc, crc, tmp3);
3333     ldr(tmp1, Address(buf, 48));
3334     crc32x(crc, crc, tmp0);
3335     ldr(tmp2, Address(buf, 56));
3336     crc32x(crc, crc, tmp1);
3337     ldr(tmp3, Address(pre(buf, 64)));
3338 
3339     b(CRC_by64_loop);
3340 
3341     align(CodeEntryAlignment);
3342   BIND(CRC_by64_loop);
3343     subs(len, len, 64);
3344     crc32x(crc, crc, tmp2);
3345     ldr(tmp0, Address(buf, 8));
3346     crc32x(crc, crc, tmp3);
3347     ldr(tmp1, Address(buf, 16));
3348     crc32x(crc, crc, tmp0);
3349     ldr(tmp2, Address(buf, 24));
3350     crc32x(crc, crc, tmp1);
3351     ldr(tmp3, Address(buf, 32));
3352     crc32x(crc, crc, tmp2);
3353     ldr(tmp0, Address(buf, 40));
3354     crc32x(crc, crc, tmp3);
3355     ldr(tmp1, Address(buf, 48));
3356     crc32x(crc, crc, tmp0);
3357     ldr(tmp2, Address(buf, 56));
3358     crc32x(crc, crc, tmp1);
3359     ldr(tmp3, Address(pre(buf, 64)));
3360     br(Assembler::GE, CRC_by64_loop);
3361 
3362     // post-loop
3363     crc32x(crc, crc, tmp2);
3364     crc32x(crc, crc, tmp3);
3365 
3366     sub(len, len, 64);
3367     add(buf, buf, 8);
3368     cmn(len, 128);
3369     br(Assembler::NE, CRC_less64);
3370   BIND(L_exit);
3371     mvnw(crc, crc);
3372 }
3373 
3374 /**
3375  * @param crc   register containing existing CRC (32-bit)
3376  * @param buf   register pointing to input byte buffer (byte*)
3377  * @param len   register containing number of bytes
3378  * @param table register that will contain address of CRC table
3379  * @param tmp   scratch register
3380  */
3381 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,
3382         Register table0, Register table1, Register table2, Register table3,
3383         Register tmp, Register tmp2, Register tmp3) {
3384   Label L_by16, L_by16_loop, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;
3385   unsigned long offset;
3386 
3387   if (UseCRC32) {
3388       kernel_crc32_using_crc32(crc, buf, len, table0, table1, table2, table3);
3389       return;
3390   }
3391 
3392     mvnw(crc, crc);
3393 
3394     adrp(table0, ExternalAddress(StubRoutines::crc_table_addr()), offset);
3395     if (offset) add(table0, table0, offset);
3396     add(table1, table0, 1*256*sizeof(juint));
3397     add(table2, table0, 2*256*sizeof(juint));
3398     add(table3, table0, 3*256*sizeof(juint));
3399 
3400   if (UseNeon) {
3401       cmp(len, (u1)64);
3402       br(Assembler::LT, L_by16);
3403       eor(v16, T16B, v16, v16);
3404 
3405     Label L_fold;
3406 
3407       add(tmp, table0, 4*256*sizeof(juint)); // Point at the Neon constants
3408 
3409       ld1(v0, v1, T2D, post(buf, 32));
3410       ld1r(v4, T2D, post(tmp, 8));
3411       ld1r(v5, T2D, post(tmp, 8));
3412       ld1r(v6, T2D, post(tmp, 8));
3413       ld1r(v7, T2D, post(tmp, 8));
3414       mov(v16, T4S, 0, crc);
3415 
3416       eor(v0, T16B, v0, v16);
3417       sub(len, len, 64);
3418 
3419     BIND(L_fold);
3420       pmull(v22, T8H, v0, v5, T8B);
3421       pmull(v20, T8H, v0, v7, T8B);
3422       pmull(v23, T8H, v0, v4, T8B);
3423       pmull(v21, T8H, v0, v6, T8B);
3424 
3425       pmull2(v18, T8H, v0, v5, T16B);
3426       pmull2(v16, T8H, v0, v7, T16B);
3427       pmull2(v19, T8H, v0, v4, T16B);
3428       pmull2(v17, T8H, v0, v6, T16B);
3429 
3430       uzp1(v24, T8H, v20, v22);
3431       uzp2(v25, T8H, v20, v22);
3432       eor(v20, T16B, v24, v25);
3433 
3434       uzp1(v26, T8H, v16, v18);
3435       uzp2(v27, T8H, v16, v18);
3436       eor(v16, T16B, v26, v27);
3437 
3438       ushll2(v22, T4S, v20, T8H, 8);
3439       ushll(v20, T4S, v20, T4H, 8);
3440 
3441       ushll2(v18, T4S, v16, T8H, 8);
3442       ushll(v16, T4S, v16, T4H, 8);
3443 
3444       eor(v22, T16B, v23, v22);
3445       eor(v18, T16B, v19, v18);
3446       eor(v20, T16B, v21, v20);
3447       eor(v16, T16B, v17, v16);
3448 
3449       uzp1(v17, T2D, v16, v20);
3450       uzp2(v21, T2D, v16, v20);
3451       eor(v17, T16B, v17, v21);
3452 
3453       ushll2(v20, T2D, v17, T4S, 16);
3454       ushll(v16, T2D, v17, T2S, 16);
3455 
3456       eor(v20, T16B, v20, v22);
3457       eor(v16, T16B, v16, v18);
3458 
3459       uzp1(v17, T2D, v20, v16);
3460       uzp2(v21, T2D, v20, v16);
3461       eor(v28, T16B, v17, v21);
3462 
3463       pmull(v22, T8H, v1, v5, T8B);
3464       pmull(v20, T8H, v1, v7, T8B);
3465       pmull(v23, T8H, v1, v4, T8B);
3466       pmull(v21, T8H, v1, v6, T8B);
3467 
3468       pmull2(v18, T8H, v1, v5, T16B);
3469       pmull2(v16, T8H, v1, v7, T16B);
3470       pmull2(v19, T8H, v1, v4, T16B);
3471       pmull2(v17, T8H, v1, v6, T16B);
3472 
3473       ld1(v0, v1, T2D, post(buf, 32));
3474 
3475       uzp1(v24, T8H, v20, v22);
3476       uzp2(v25, T8H, v20, v22);
3477       eor(v20, T16B, v24, v25);
3478 
3479       uzp1(v26, T8H, v16, v18);
3480       uzp2(v27, T8H, v16, v18);
3481       eor(v16, T16B, v26, v27);
3482 
3483       ushll2(v22, T4S, v20, T8H, 8);
3484       ushll(v20, T4S, v20, T4H, 8);
3485 
3486       ushll2(v18, T4S, v16, T8H, 8);
3487       ushll(v16, T4S, v16, T4H, 8);
3488 
3489       eor(v22, T16B, v23, v22);
3490       eor(v18, T16B, v19, v18);
3491       eor(v20, T16B, v21, v20);
3492       eor(v16, T16B, v17, v16);
3493 
3494       uzp1(v17, T2D, v16, v20);
3495       uzp2(v21, T2D, v16, v20);
3496       eor(v16, T16B, v17, v21);
3497 
3498       ushll2(v20, T2D, v16, T4S, 16);
3499       ushll(v16, T2D, v16, T2S, 16);
3500 
3501       eor(v20, T16B, v22, v20);
3502       eor(v16, T16B, v16, v18);
3503 
3504       uzp1(v17, T2D, v20, v16);
3505       uzp2(v21, T2D, v20, v16);
3506       eor(v20, T16B, v17, v21);
3507 
3508       shl(v16, T2D, v28, 1);
3509       shl(v17, T2D, v20, 1);
3510 
3511       eor(v0, T16B, v0, v16);
3512       eor(v1, T16B, v1, v17);
3513 
3514       subs(len, len, 32);
3515       br(Assembler::GE, L_fold);
3516 
3517       mov(crc, 0);
3518       mov(tmp, v0, T1D, 0);
3519       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3520       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3521       mov(tmp, v0, T1D, 1);
3522       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3523       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3524       mov(tmp, v1, T1D, 0);
3525       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3526       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3527       mov(tmp, v1, T1D, 1);
3528       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3529       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3530 
3531       add(len, len, 32);
3532   }
3533 
3534   BIND(L_by16);
3535     subs(len, len, 16);
3536     br(Assembler::GE, L_by16_loop);
3537     adds(len, len, 16-4);
3538     br(Assembler::GE, L_by4_loop);
3539     adds(len, len, 4);
3540     br(Assembler::GT, L_by1_loop);
3541     b(L_exit);
3542 
3543   BIND(L_by4_loop);
3544     ldrw(tmp, Address(post(buf, 4)));
3545     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3);
3546     subs(len, len, 4);
3547     br(Assembler::GE, L_by4_loop);
3548     adds(len, len, 4);
3549     br(Assembler::LE, L_exit);
3550   BIND(L_by1_loop);
3551     subs(len, len, 1);
3552     ldrb(tmp, Address(post(buf, 1)));
3553     update_byte_crc32(crc, tmp, table0);
3554     br(Assembler::GT, L_by1_loop);
3555     b(L_exit);
3556 
3557     align(CodeEntryAlignment);
3558   BIND(L_by16_loop);
3559     subs(len, len, 16);
3560     ldp(tmp, tmp3, Address(post(buf, 16)));
3561     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3562     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3563     update_word_crc32(crc, tmp3, tmp2, table0, table1, table2, table3, false);
3564     update_word_crc32(crc, tmp3, tmp2, table0, table1, table2, table3, true);
3565     br(Assembler::GE, L_by16_loop);
3566     adds(len, len, 16-4);
3567     br(Assembler::GE, L_by4_loop);
3568     adds(len, len, 4);
3569     br(Assembler::GT, L_by1_loop);
3570   BIND(L_exit);
3571     mvnw(crc, crc);
3572 }
3573 
3574 void MacroAssembler::kernel_crc32c_using_crc32c(Register crc, Register buf,
3575         Register len, Register tmp0, Register tmp1, Register tmp2,
3576         Register tmp3) {
3577     Label CRC_by64_loop, CRC_by4_loop, CRC_by1_loop, CRC_less64, CRC_by64_pre, CRC_by32_loop, CRC_less32, L_exit;
3578     assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2, tmp3);
3579 
3580     subs(len, len, 128);
3581     br(Assembler::GE, CRC_by64_pre);
3582   BIND(CRC_less64);
3583     adds(len, len, 128-32);
3584     br(Assembler::GE, CRC_by32_loop);
3585   BIND(CRC_less32);
3586     adds(len, len, 32-4);
3587     br(Assembler::GE, CRC_by4_loop);
3588     adds(len, len, 4);
3589     br(Assembler::GT, CRC_by1_loop);
3590     b(L_exit);
3591 
3592   BIND(CRC_by32_loop);
3593     ldp(tmp0, tmp1, Address(post(buf, 16)));
3594     subs(len, len, 32);
3595     crc32cx(crc, crc, tmp0);
3596     ldr(tmp2, Address(post(buf, 8)));
3597     crc32cx(crc, crc, tmp1);
3598     ldr(tmp3, Address(post(buf, 8)));
3599     crc32cx(crc, crc, tmp2);
3600     crc32cx(crc, crc, tmp3);
3601     br(Assembler::GE, CRC_by32_loop);
3602     cmn(len, 32);
3603     br(Assembler::NE, CRC_less32);
3604     b(L_exit);
3605 
3606   BIND(CRC_by4_loop);
3607     ldrw(tmp0, Address(post(buf, 4)));
3608     subs(len, len, 4);
3609     crc32cw(crc, crc, tmp0);
3610     br(Assembler::GE, CRC_by4_loop);
3611     adds(len, len, 4);
3612     br(Assembler::LE, L_exit);
3613   BIND(CRC_by1_loop);
3614     ldrb(tmp0, Address(post(buf, 1)));
3615     subs(len, len, 1);
3616     crc32cb(crc, crc, tmp0);
3617     br(Assembler::GT, CRC_by1_loop);
3618     b(L_exit);
3619 
3620   BIND(CRC_by64_pre);
3621     sub(buf, buf, 8);
3622     ldp(tmp0, tmp1, Address(buf, 8));
3623     crc32cx(crc, crc, tmp0);
3624     ldr(tmp2, Address(buf, 24));
3625     crc32cx(crc, crc, tmp1);
3626     ldr(tmp3, Address(buf, 32));
3627     crc32cx(crc, crc, tmp2);
3628     ldr(tmp0, Address(buf, 40));
3629     crc32cx(crc, crc, tmp3);
3630     ldr(tmp1, Address(buf, 48));
3631     crc32cx(crc, crc, tmp0);
3632     ldr(tmp2, Address(buf, 56));
3633     crc32cx(crc, crc, tmp1);
3634     ldr(tmp3, Address(pre(buf, 64)));
3635 
3636     b(CRC_by64_loop);
3637 
3638     align(CodeEntryAlignment);
3639   BIND(CRC_by64_loop);
3640     subs(len, len, 64);
3641     crc32cx(crc, crc, tmp2);
3642     ldr(tmp0, Address(buf, 8));
3643     crc32cx(crc, crc, tmp3);
3644     ldr(tmp1, Address(buf, 16));
3645     crc32cx(crc, crc, tmp0);
3646     ldr(tmp2, Address(buf, 24));
3647     crc32cx(crc, crc, tmp1);
3648     ldr(tmp3, Address(buf, 32));
3649     crc32cx(crc, crc, tmp2);
3650     ldr(tmp0, Address(buf, 40));
3651     crc32cx(crc, crc, tmp3);
3652     ldr(tmp1, Address(buf, 48));
3653     crc32cx(crc, crc, tmp0);
3654     ldr(tmp2, Address(buf, 56));
3655     crc32cx(crc, crc, tmp1);
3656     ldr(tmp3, Address(pre(buf, 64)));
3657     br(Assembler::GE, CRC_by64_loop);
3658 
3659     // post-loop
3660     crc32cx(crc, crc, tmp2);
3661     crc32cx(crc, crc, tmp3);
3662 
3663     sub(len, len, 64);
3664     add(buf, buf, 8);
3665     cmn(len, 128);
3666     br(Assembler::NE, CRC_less64);
3667   BIND(L_exit);
3668 }
3669 
3670 /**
3671  * @param crc   register containing existing CRC (32-bit)
3672  * @param buf   register pointing to input byte buffer (byte*)
3673  * @param len   register containing number of bytes
3674  * @param table register that will contain address of CRC table
3675  * @param tmp   scratch register
3676  */
3677 void MacroAssembler::kernel_crc32c(Register crc, Register buf, Register len,
3678         Register table0, Register table1, Register table2, Register table3,
3679         Register tmp, Register tmp2, Register tmp3) {
3680   kernel_crc32c_using_crc32c(crc, buf, len, table0, table1, table2, table3);
3681 }
3682 
3683 
3684 SkipIfEqual::SkipIfEqual(
3685     MacroAssembler* masm, const bool* flag_addr, bool value) {
3686   _masm = masm;
3687   unsigned long offset;
3688   _masm-&gt;adrp(rscratch1, ExternalAddress((address)flag_addr), offset);
3689   _masm-&gt;ldrb(rscratch1, Address(rscratch1, offset));
3690   _masm-&gt;cbzw(rscratch1, _label);
3691 }
3692 
3693 SkipIfEqual::~SkipIfEqual() {
3694   _masm-&gt;bind(_label);
3695 }
3696 
3697 void MacroAssembler::addptr(const Address &amp;dst, int32_t src) {
3698   Address adr;
3699   switch(dst.getMode()) {
3700   case Address::base_plus_offset:
3701     // This is the expected mode, although we allow all the other
3702     // forms below.
3703     adr = form_address(rscratch2, dst.base(), dst.offset(), LogBytesPerWord);
3704     break;
3705   default:
3706     lea(rscratch2, dst);
3707     adr = Address(rscratch2);
3708     break;
3709   }
3710   ldr(rscratch1, adr);
3711   add(rscratch1, rscratch1, src);
3712   str(rscratch1, adr);
3713 }
3714 
3715 void MacroAssembler::cmpptr(Register src1, Address src2) {
3716   unsigned long offset;
3717   adrp(rscratch1, src2, offset);
3718   ldr(rscratch1, Address(rscratch1, offset));
3719   cmp(src1, rscratch1);
3720 }
3721 
3722 void MacroAssembler::cmpoop(Register obj1, Register obj2) {
3723   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3724   bs-&gt;obj_equals(this, obj1, obj2);
3725 }
3726 
3727 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
3728   load_method_holder(rresult, rmethod);
3729   ldr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
3730 }
3731 
3732 void MacroAssembler::load_method_holder(Register holder, Register method) {
3733   ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
3734   ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
3735   ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
3736 }
3737 
3738 void MacroAssembler::load_metadata(Register dst, Register src) {
3739   if (UseCompressedClassPointers) {
3740     ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3741   } else {
3742     ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3743   }
3744 }
3745 
3746 void MacroAssembler::load_klass(Register dst, Register src) {
3747   load_metadata(dst, src);
3748   if (UseCompressedClassPointers) {
3749     andr(dst, dst, oopDesc::compressed_klass_mask());
3750     decode_klass_not_null(dst);
3751   } else {
3752     ubfm(dst, dst, 0, 63 - oopDesc::storage_props_nof_bits);
3753   }
3754 }
3755 
3756 // ((OopHandle)result).resolve();
3757 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3758   // OopHandle::resolve is an indirection.
3759   access_load_at(T_OBJECT, IN_NATIVE, result, Address(result, 0), tmp, noreg);
3760 }
3761 
3762 // ((WeakHandle)result).resolve();
3763 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
3764   assert_different_registers(rresult, rtmp);
3765   Label resolved;
3766 
3767   // A null weak handle resolves to null.
3768   cbz(rresult, resolved);
3769 
3770   // Only 64 bit platforms support GCs that require a tmp register
3771   // Only IN_HEAP loads require a thread_tmp register
3772   // WeakHandle::resolve is an indirection like jweak.
3773   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3774                  rresult, Address(rresult), rtmp, /*tmp_thread*/noreg);
3775   bind(resolved);
3776 }
3777 
3778 void MacroAssembler::load_mirror(Register dst, Register method, Register tmp) {
3779   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3780   ldr(dst, Address(rmethod, Method::const_offset()));
3781   ldr(dst, Address(dst, ConstMethod::constants_offset()));
3782   ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));
3783   ldr(dst, Address(dst, mirror_offset));
3784   resolve_oop_handle(dst, tmp);
3785 }
3786 
3787 void MacroAssembler::load_storage_props(Register dst, Register src) {
3788   load_metadata(dst, src);
3789   if (UseCompressedClassPointers) {
3790     asrw(dst, dst, oopDesc::narrow_storage_props_shift);
3791   } else {
3792     asr(dst, dst, oopDesc::wide_storage_props_shift);
3793   }
3794 }
3795 
3796 void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
3797   if (UseCompressedClassPointers) {
3798     ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3799     if (CompressedKlassPointers::base() == NULL) {
3800       cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());
3801       return;
3802     } else if (((uint64_t)CompressedKlassPointers::base() &amp; 0xffffffff) == 0
3803                &amp;&amp; CompressedKlassPointers::shift() == 0) {
3804       // Only the bottom 32 bits matter
3805       cmpw(trial_klass, tmp);
3806       return;
3807     }
3808     decode_klass_not_null(tmp);
3809   } else {
3810     ldr(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3811   }
3812   cmp(trial_klass, tmp);
3813 }
3814 
3815 void MacroAssembler::load_prototype_header(Register dst, Register src) {
3816   load_klass(dst, src);
3817   ldr(dst, Address(dst, Klass::prototype_header_offset()));
3818 }
3819 
3820 void MacroAssembler::store_klass(Register dst, Register src) {
3821   // FIXME: Should this be a store release?  concurrent gcs assumes
3822   // klass length is valid if klass field is not null.
3823   if (UseCompressedClassPointers) {
3824     encode_klass_not_null(src);
3825     strw(src, Address(dst, oopDesc::klass_offset_in_bytes()));
3826   } else {
3827     str(src, Address(dst, oopDesc::klass_offset_in_bytes()));
3828   }
3829 }
3830 
3831 void MacroAssembler::store_klass_gap(Register dst, Register src) {
3832   if (UseCompressedClassPointers) {
3833     // Store to klass gap in destination
3834     strw(src, Address(dst, oopDesc::klass_gap_offset_in_bytes()));
3835   }
3836 }
3837 
3838 // Algorithm must match CompressedOops::encode.
3839 void MacroAssembler::encode_heap_oop(Register d, Register s) {
3840 #ifdef ASSERT
3841   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
3842 #endif
3843   verify_oop(s, &quot;broken oop in encode_heap_oop&quot;);
3844   if (CompressedOops::base() == NULL) {
3845     if (CompressedOops::shift() != 0) {
3846       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3847       lsr(d, s, LogMinObjAlignmentInBytes);
3848     } else {
3849       mov(d, s);
3850     }
3851   } else {
3852     subs(d, s, rheapbase);
3853     csel(d, d, zr, Assembler::HS);
3854     lsr(d, d, LogMinObjAlignmentInBytes);
3855 
3856     /*  Old algorithm: is this any worse?
3857     Label nonnull;
3858     cbnz(r, nonnull);
3859     sub(r, r, rheapbase);
3860     bind(nonnull);
3861     lsr(r, r, LogMinObjAlignmentInBytes);
3862     */
3863   }
3864 }
3865 
3866 void MacroAssembler::encode_heap_oop_not_null(Register r) {
3867 #ifdef ASSERT
3868   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
3869   if (CheckCompressedOops) {
3870     Label ok;
3871     cbnz(r, ok);
3872     stop(&quot;null oop passed to encode_heap_oop_not_null&quot;);
3873     bind(ok);
3874   }
3875 #endif
3876   verify_oop(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
3877   if (CompressedOops::base() != NULL) {
3878     sub(r, r, rheapbase);
3879   }
3880   if (CompressedOops::shift() != 0) {
3881     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3882     lsr(r, r, LogMinObjAlignmentInBytes);
3883   }
3884 }
3885 
3886 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
3887 #ifdef ASSERT
3888   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
3889   if (CheckCompressedOops) {
3890     Label ok;
3891     cbnz(src, ok);
3892     stop(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
3893     bind(ok);
3894   }
3895 #endif
3896   verify_oop(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
3897 
3898   Register data = src;
3899   if (CompressedOops::base() != NULL) {
3900     sub(dst, src, rheapbase);
3901     data = dst;
3902   }
3903   if (CompressedOops::shift() != 0) {
3904     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3905     lsr(dst, data, LogMinObjAlignmentInBytes);
3906     data = dst;
3907   }
3908   if (data == src)
3909     mov(dst, src);
3910 }
3911 
3912 void  MacroAssembler::decode_heap_oop(Register d, Register s) {
3913 #ifdef ASSERT
3914   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
3915 #endif
3916   if (CompressedOops::base() == NULL) {
3917     if (CompressedOops::shift() != 0 || d != s) {
3918       lsl(d, s, CompressedOops::shift());
3919     }
3920   } else {
3921     Label done;
3922     if (d != s)
3923       mov(d, s);
3924     cbz(s, done);
3925     add(d, rheapbase, s, Assembler::LSL, LogMinObjAlignmentInBytes);
3926     bind(done);
3927   }
3928   verify_oop(d, &quot;broken oop in decode_heap_oop&quot;);
3929 }
3930 
3931 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
3932   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
3933   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3934   // Cannot assert, unverified entry point counts instructions (see .ad file)
3935   // vtableStubs also counts instructions in pd_code_size_limit.
3936   // Also do not verify_oop as this is called by verify_oop.
3937   if (CompressedOops::shift() != 0) {
3938     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3939     if (CompressedOops::base() != NULL) {
3940       add(r, rheapbase, r, Assembler::LSL, LogMinObjAlignmentInBytes);
3941     } else {
3942       add(r, zr, r, Assembler::LSL, LogMinObjAlignmentInBytes);
3943     }
3944   } else {
3945     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
3946   }
3947 }
3948 
3949 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
3950   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
3951   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3952   // Cannot assert, unverified entry point counts instructions (see .ad file)
3953   // vtableStubs also counts instructions in pd_code_size_limit.
3954   // Also do not verify_oop as this is called by verify_oop.
3955   if (CompressedOops::shift() != 0) {
3956     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3957     if (CompressedOops::base() != NULL) {
3958       add(dst, rheapbase, src, Assembler::LSL, LogMinObjAlignmentInBytes);
3959     } else {
3960       add(dst, zr, src, Assembler::LSL, LogMinObjAlignmentInBytes);
3961     }
3962   } else {
3963     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
3964     if (dst != src) {
3965       mov(dst, src);
3966     }
3967   }
3968 }
3969 
3970 MacroAssembler::KlassDecodeMode MacroAssembler::_klass_decode_mode(KlassDecodeNone);
3971 
3972 MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode() {
3973   assert(UseCompressedClassPointers, &quot;not using compressed class pointers&quot;);
3974   assert(Metaspace::initialized(), &quot;metaspace not initialized yet&quot;);
3975 
3976   if (_klass_decode_mode != KlassDecodeNone) {
3977     return _klass_decode_mode;
3978   }
3979 
3980   assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift()
3981          || 0 == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
3982 
3983   if (CompressedKlassPointers::base() == NULL) {
3984     return (_klass_decode_mode = KlassDecodeZero);
3985   }
3986 
3987   if (operand_valid_for_logical_immediate(
3988         /*is32*/false, (uint64_t)CompressedKlassPointers::base())) {
3989     const uint64_t range_mask =
3990       (1UL &lt;&lt; log2_intptr(CompressedKlassPointers::range())) - 1;
3991     if (((uint64_t)CompressedKlassPointers::base() &amp; range_mask) == 0) {
3992       return (_klass_decode_mode = KlassDecodeXor);
3993     }
3994   }
3995 
3996   const uint64_t shifted_base =
3997     (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();
3998   guarantee((shifted_base &amp; 0xffff0000ffffffff) == 0,
3999             &quot;compressed class base bad alignment&quot;);
4000 
4001   return (_klass_decode_mode = KlassDecodeMovk);
4002 }
4003 
4004 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
4005   switch (klass_decode_mode()) {
4006   case KlassDecodeZero:
4007     if (CompressedKlassPointers::shift() != 0) {
4008       lsr(dst, src, LogKlassAlignmentInBytes);
4009     } else {
4010       if (dst != src) mov(dst, src);
4011     }
4012     break;
4013 
4014   case KlassDecodeXor:
4015     if (CompressedKlassPointers::shift() != 0) {
4016       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
4017       lsr(dst, dst, LogKlassAlignmentInBytes);
4018     } else {
4019       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
4020     }
4021     break;
4022 
4023   case KlassDecodeMovk:
4024     if (CompressedKlassPointers::shift() != 0) {
4025       ubfx(dst, src, LogKlassAlignmentInBytes, 32);
4026     } else {
4027       movw(dst, src);
4028     }
4029     break;
4030 
4031   case KlassDecodeNone:
4032     ShouldNotReachHere();
4033     break;
4034   }
4035 }
4036 
4037 void MacroAssembler::encode_klass_not_null(Register r) {
4038   encode_klass_not_null(r, r);
4039 }
4040 
4041 void  MacroAssembler::decode_klass_not_null(Register dst, Register src) {
4042   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4043 
4044   switch (klass_decode_mode()) {
4045   case KlassDecodeZero:
4046     if (CompressedKlassPointers::shift() != 0) {
4047       lsl(dst, src, LogKlassAlignmentInBytes);
4048     } else {
4049       if (dst != src) mov(dst, src);
4050     }
4051     break;
4052 
4053   case KlassDecodeXor:
4054     if (CompressedKlassPointers::shift() != 0) {
4055       lsl(dst, src, LogKlassAlignmentInBytes);
4056       eor(dst, dst, (uint64_t)CompressedKlassPointers::base());
4057     } else {
4058       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
4059     }
4060     break;
4061 
4062   case KlassDecodeMovk: {
4063     const uint64_t shifted_base =
4064       (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();
4065 
4066     if (dst != src) movw(dst, src);
4067     movk(dst, shifted_base &gt;&gt; 32, 32);
4068 
4069     if (CompressedKlassPointers::shift() != 0) {
4070       lsl(dst, dst, LogKlassAlignmentInBytes);
4071     }
4072 
4073     break;
4074   }
4075 
4076   case KlassDecodeNone:
4077     ShouldNotReachHere();
4078     break;
4079   }
4080 }
4081 
4082 void  MacroAssembler::decode_klass_not_null(Register r) {
4083   decode_klass_not_null(r, r);
4084 }
4085 
4086 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4087 #ifdef ASSERT
4088   {
4089     ThreadInVMfromUnknown tiv;
4090     assert (UseCompressedOops, &quot;should only be used for compressed oops&quot;);
4091     assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4092     assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4093     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4094   }
4095 #endif
4096   int oop_index = oop_recorder()-&gt;find_index(obj);
4097   InstructionMark im(this);
4098   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4099   code_section()-&gt;relocate(inst_mark(), rspec);
4100   movz(dst, 0xDEAD, 16);
4101   movk(dst, 0xBEEF);
4102 }
4103 
4104 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4105   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4106   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4107   int index = oop_recorder()-&gt;find_index(k);
4108   assert(! Universe::heap()-&gt;is_in(k), &quot;should not be an oop&quot;);
4109 
4110   InstructionMark im(this);
4111   RelocationHolder rspec = metadata_Relocation::spec(index);
4112   code_section()-&gt;relocate(inst_mark(), rspec);
4113   narrowKlass nk = CompressedKlassPointers::encode(k);
4114   movz(dst, (nk &gt;&gt; 16), 16);
4115   movk(dst, nk &amp; 0xffff);
4116 }
4117 
4118 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
4119                                     Register dst, Address src,
4120                                     Register tmp1, Register thread_tmp) {
4121   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4122   decorators = AccessInternal::decorator_fixup(decorators);
4123   bool as_raw = (decorators &amp; AS_RAW) != 0;
4124   if (as_raw) {
4125     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4126   } else {
4127     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4128   }
4129 }
4130 
4131 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
4132                                      Address dst, Register src,
4133                                      Register tmp1, Register thread_tmp, Register tmp3) {
4134 
4135   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4136   decorators = AccessInternal::decorator_fixup(decorators);
4137   bool as_raw = (decorators &amp; AS_RAW) != 0;
4138   if (as_raw) {
4139     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);
4140   } else {
4141     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);
4142   }
4143 }
4144 
4145 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4146   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4147   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4148     decorators |= ACCESS_READ | ACCESS_WRITE;
4149   }
4150   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4151   return bs-&gt;resolve(this, decorators, obj);
4152 }
4153 
4154 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4155                                    Register thread_tmp, DecoratorSet decorators) {
4156   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4157 }
4158 
4159 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4160                                             Register thread_tmp, DecoratorSet decorators) {
4161   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4162 }
4163 
4164 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4165                                     Register thread_tmp, Register tmp3, DecoratorSet decorators) {
4166   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp, tmp3);
4167 }
4168 
4169 // Used for storing NULLs.
4170 void MacroAssembler::store_heap_oop_null(Address dst) {
4171   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);
4172 }
4173 
4174 Address MacroAssembler::allocate_metadata_address(Metadata* obj) {
4175   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
4176   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
4177   RelocationHolder rspec = metadata_Relocation::spec(index);
4178   return Address((address)obj, rspec);
4179 }
4180 
4181 // Move an oop into a register.  immediate is true if we want
4182 // immediate instructions and nmethod entry barriers are not enabled.
4183 // i.e. we are not going to patch this instruction while the code is being
4184 // executed by another thread.
4185 void MacroAssembler::movoop(Register dst, jobject obj, bool immediate) {
4186   int oop_index;
4187   if (obj == NULL) {
4188     oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
4189   } else {
4190 #ifdef ASSERT
4191     {
4192       ThreadInVMfromUnknown tiv;
4193       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4194     }
4195 #endif
4196     oop_index = oop_recorder()-&gt;find_index(obj);
4197   }
4198   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4199 
4200   // nmethod entry barrier necessitate using the constant pool. They have to be
4201   // ordered with respected to oop accesses.
4202   // Using immediate literals would necessitate ISBs.
4203   if (BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL || !immediate) {
4204     address dummy = address(uintptr_t(pc()) &amp; -wordSize); // A nearby aligned address
4205     ldr_constant(dst, Address(dummy, rspec));
4206   } else
4207     mov(dst, Address((address)obj, rspec));
4208 
4209 }
4210 
4211 // Move a metadata address into a register.
4212 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
4213   int oop_index;
4214   if (obj == NULL) {
4215     oop_index = oop_recorder()-&gt;allocate_metadata_index(obj);
4216   } else {
4217     oop_index = oop_recorder()-&gt;find_index(obj);
4218   }
4219   RelocationHolder rspec = metadata_Relocation::spec(oop_index);
4220   mov(dst, Address((address)obj, rspec));
4221 }
4222 
4223 Address MacroAssembler::constant_oop_address(jobject obj) {
4224 #ifdef ASSERT
4225   {
4226     ThreadInVMfromUnknown tiv;
4227     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4228     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
4229   }
4230 #endif
4231   int oop_index = oop_recorder()-&gt;find_index(obj);
4232   return Address((address)obj, oop_Relocation::spec(oop_index));
4233 }
4234 
4235 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
4236 void MacroAssembler::tlab_allocate(Register obj,
4237                                    Register var_size_in_bytes,
4238                                    int con_size_in_bytes,
4239                                    Register t1,
4240                                    Register t2,
4241                                    Label&amp; slow_case) {
4242   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4243   bs-&gt;tlab_allocate(this, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
4244 }
4245 
4246 // Defines obj, preserves var_size_in_bytes
4247 void MacroAssembler::eden_allocate(Register obj,
4248                                    Register var_size_in_bytes,
4249                                    int con_size_in_bytes,
4250                                    Register t1,
4251                                    Label&amp; slow_case) {
4252   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4253   bs-&gt;eden_allocate(this, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
4254 }
4255 
4256 // Zero words; len is in bytes
4257 // Destroys all registers except addr
4258 // len must be a nonzero multiple of wordSize
4259 void MacroAssembler::zero_memory(Register addr, Register len, Register t1) {
4260   assert_different_registers(addr, len, t1, rscratch1, rscratch2);
4261 
4262 #ifdef ASSERT
4263   { Label L;
4264     tst(len, BytesPerWord - 1);
4265     br(Assembler::EQ, L);
4266     stop(&quot;len is not a multiple of BytesPerWord&quot;);
4267     bind(L);
4268   }
4269 #endif
4270 
4271 #ifndef PRODUCT
4272   block_comment(&quot;zero memory&quot;);
4273 #endif
4274 
4275   Label loop;
4276   Label entry;
4277 
4278 //  Algorithm:
4279 //
4280 //    scratch1 = cnt &amp; 7;
4281 //    cnt -= scratch1;
4282 //    p += scratch1;
4283 //    switch (scratch1) {
4284 //      do {
4285 //        cnt -= 8;
4286 //          p[-8] = 0;
4287 //        case 7:
4288 //          p[-7] = 0;
4289 //        case 6:
4290 //          p[-6] = 0;
4291 //          // ...
4292 //        case 1:
4293 //          p[-1] = 0;
4294 //        case 0:
4295 //          p += 8;
4296 //      } while (cnt);
4297 //    }
4298 
4299   const int unroll = 8; // Number of str(zr) instructions we&#39;ll unroll
4300 
4301   lsr(len, len, LogBytesPerWord);
4302   andr(rscratch1, len, unroll - 1);  // tmp1 = cnt % unroll
4303   sub(len, len, rscratch1);      // cnt -= unroll
4304   // t1 always points to the end of the region we&#39;re about to zero
4305   add(t1, addr, rscratch1, Assembler::LSL, LogBytesPerWord);
4306   adr(rscratch2, entry);
4307   sub(rscratch2, rscratch2, rscratch1, Assembler::LSL, 2);
4308   br(rscratch2);
4309   bind(loop);
4310   sub(len, len, unroll);
4311   for (int i = -unroll; i &lt; 0; i++)
4312     Assembler::str(zr, Address(t1, i * wordSize));
4313   bind(entry);
4314   add(t1, t1, unroll * wordSize);
4315   cbnz(len, loop);
4316 }
4317 
4318 void MacroAssembler::verify_tlab() {
4319 #ifdef ASSERT
4320   if (UseTLAB &amp;&amp; VerifyOops) {
4321     Label next, ok;
4322 
4323     stp(rscratch2, rscratch1, Address(pre(sp, -16)));
4324 
4325     ldr(rscratch2, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
4326     ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_start_offset())));
4327     cmp(rscratch2, rscratch1);
4328     br(Assembler::HS, next);
4329     STOP(&quot;assert(top &gt;= start)&quot;);
4330     should_not_reach_here();
4331 
4332     bind(next);
4333     ldr(rscratch2, Address(rthread, in_bytes(JavaThread::tlab_end_offset())));
4334     ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
4335     cmp(rscratch2, rscratch1);
4336     br(Assembler::HS, ok);
4337     STOP(&quot;assert(top &lt;= end)&quot;);
4338     should_not_reach_here();
4339 
4340     bind(ok);
4341     ldp(rscratch2, rscratch1, Address(post(sp, 16)));
4342   }
4343 #endif
4344 }
4345 
4346 // Writes to stack successive pages until offset reached to check for
4347 // stack overflow + shadow pages.  This clobbers tmp.
4348 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
4349   assert_different_registers(tmp, size, rscratch1);
4350   mov(tmp, sp);
4351   // Bang stack for total size given plus shadow page size.
4352   // Bang one page at a time because large size can bang beyond yellow and
4353   // red zones.
4354   Label loop;
4355   mov(rscratch1, os::vm_page_size());
4356   bind(loop);
4357   lea(tmp, Address(tmp, -os::vm_page_size()));
4358   subsw(size, size, rscratch1);
4359   str(size, Address(tmp));
4360   br(Assembler::GT, loop);
4361 
4362   // Bang down shadow pages too.
4363   // At this point, (tmp-0) is the last address touched, so don&#39;t
4364   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
4365   // was post-decremented.)  Skip this address by starting at i=1, and
4366   // touch a few more pages below.  N.B.  It is important to touch all
4367   // the way down to and including i=StackShadowPages.
4368   for (int i = 0; i &lt; (int)(JavaThread::stack_shadow_zone_size() / os::vm_page_size()) - 1; i++) {
4369     // this could be any sized move but this is can be a debugging crumb
4370     // so the bigger the better.
4371     lea(tmp, Address(tmp, -os::vm_page_size()));
4372     str(size, Address(tmp));
4373   }
4374 }
4375 
4376 // Move the address of the polling page into dest.
4377 void MacroAssembler::get_polling_page(Register dest, relocInfo::relocType rtype) {
4378   ldr(dest, Address(rthread, Thread::polling_page_offset()));
4379 }
4380 
4381 // Move the address of the polling page into r, then read the polling
4382 // page.
4383 address MacroAssembler::fetch_and_read_polling_page(Register r, relocInfo::relocType rtype) {
4384   get_polling_page(r, rtype);
4385   return read_polling_page(r, rtype);
4386 }
4387 
4388 // Read the polling page.  The address of the polling page must
4389 // already be in r.
4390 address MacroAssembler::read_polling_page(Register r, relocInfo::relocType rtype) {
4391   InstructionMark im(this);
4392   code_section()-&gt;relocate(inst_mark(), rtype);
4393   ldrw(zr, Address(r, 0));
4394   return inst_mark();
4395 }
4396 
4397 void MacroAssembler::adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset) {
4398   relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
4399   unsigned long low_page = (unsigned long)CodeCache::low_bound() &gt;&gt; 12;
4400   unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) &gt;&gt; 12;
4401   unsigned long dest_page = (unsigned long)dest.target() &gt;&gt; 12;
4402   long offset_low = dest_page - low_page;
4403   long offset_high = dest_page - high_page;
4404 
4405   assert(is_valid_AArch64_address(dest.target()), &quot;bad address&quot;);
4406   assert(dest.getMode() == Address::literal, &quot;ADRP must be applied to a literal address&quot;);
4407 
4408   InstructionMark im(this);
4409   code_section()-&gt;relocate(inst_mark(), dest.rspec());
4410   // 8143067: Ensure that the adrp can reach the dest from anywhere within
4411   // the code cache so that if it is relocated we know it will still reach
4412   if (offset_high &gt;= -(1&lt;&lt;20) &amp;&amp; offset_low &lt; (1&lt;&lt;20)) {
4413     _adrp(reg1, dest.target());
4414   } else {
4415     unsigned long target = (unsigned long)dest.target();
4416     unsigned long adrp_target
4417       = (target &amp; 0xffffffffUL) | ((unsigned long)pc() &amp; 0xffff00000000UL);
4418 
4419     _adrp(reg1, (address)adrp_target);
4420     movk(reg1, target &gt;&gt; 32, 32);
4421   }
4422   byte_offset = (unsigned long)dest.target() &amp; 0xfff;
4423 }
4424 
4425 void MacroAssembler::load_byte_map_base(Register reg) {
4426   CardTable::CardValue* byte_map_base =
4427     ((CardTableBarrierSet*)(BarrierSet::barrier_set()))-&gt;card_table()-&gt;byte_map_base();
4428 
4429   if (is_valid_AArch64_address((address)byte_map_base)) {
4430     // Strictly speaking the byte_map_base isn&#39;t an address at all,
4431     // and it might even be negative.
4432     unsigned long offset;
4433     adrp(reg, ExternalAddress((address)byte_map_base), offset);
4434     // We expect offset to be zero with most collectors.
4435     if (offset != 0) {
4436       add(reg, reg, offset);
4437     }
4438   } else {
4439     mov(reg, (uint64_t)byte_map_base);
4440   }
4441 }
4442 
4443 void MacroAssembler::build_frame(int framesize) {
4444   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4445   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4446     sub(sp, sp, framesize);
4447     stp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4448     if (PreserveFramePointer) add(rfp, sp, framesize - 2 * wordSize);
4449   } else {
4450     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
4451     if (PreserveFramePointer) mov(rfp, sp);
4452     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4453       sub(sp, sp, framesize - 2 * wordSize);
4454     else {
4455       mov(rscratch1, framesize - 2 * wordSize);
4456       sub(sp, sp, rscratch1);
4457     }
4458   }
4459 }
4460 
4461 void MacroAssembler::remove_frame(int framesize) {
4462   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4463   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4464     ldp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4465     add(sp, sp, framesize);
4466   } else {
4467     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4468       add(sp, sp, framesize - 2 * wordSize);
4469     else {
4470       mov(rscratch1, framesize - 2 * wordSize);
4471       add(sp, sp, rscratch1);
4472     }
4473     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
4474   }
4475 }
4476 
4477 
4478 // This method checks if provided byte array contains byte with highest bit set.
4479 void MacroAssembler::has_negatives(Register ary1, Register len, Register result) {
4480     // Simple and most common case of aligned small array which is not at the
4481     // end of memory page is placed here. All other cases are in stub.
4482     Label LOOP, END, STUB, STUB_LONG, SET_RESULT, DONE;
4483     const uint64_t UPPER_BIT_MASK=0x8080808080808080;
4484     assert_different_registers(ary1, len, result);
4485 
4486     cmpw(len, 0);
4487     br(LE, SET_RESULT);
4488     cmpw(len, 4 * wordSize);
4489     br(GE, STUB_LONG); // size &gt; 32 then go to stub
4490 
4491     int shift = 64 - exact_log2(os::vm_page_size());
4492     lsl(rscratch1, ary1, shift);
4493     mov(rscratch2, (size_t)(4 * wordSize) &lt;&lt; shift);
4494     adds(rscratch2, rscratch1, rscratch2);  // At end of page?
4495     br(CS, STUB); // at the end of page then go to stub
4496     subs(len, len, wordSize);
4497     br(LT, END);
4498 
4499   BIND(LOOP);
4500     ldr(rscratch1, Address(post(ary1, wordSize)));
4501     tst(rscratch1, UPPER_BIT_MASK);
4502     br(NE, SET_RESULT);
4503     subs(len, len, wordSize);
4504     br(GE, LOOP);
4505     cmpw(len, -wordSize);
4506     br(EQ, SET_RESULT);
4507 
4508   BIND(END);
4509     ldr(result, Address(ary1));
4510     sub(len, zr, len, LSL, 3); // LSL 3 is to get bits from bytes
4511     lslv(result, result, len);
4512     tst(result, UPPER_BIT_MASK);
4513     b(SET_RESULT);
4514 
4515   BIND(STUB);
4516     RuntimeAddress has_neg =  RuntimeAddress(StubRoutines::aarch64::has_negatives());
4517     assert(has_neg.target() != NULL, &quot;has_negatives stub has not been generated&quot;);
4518     trampoline_call(has_neg);
4519     b(DONE);
4520 
4521   BIND(STUB_LONG);
4522     RuntimeAddress has_neg_long =  RuntimeAddress(
4523             StubRoutines::aarch64::has_negatives_long());
4524     assert(has_neg_long.target() != NULL, &quot;has_negatives stub has not been generated&quot;);
4525     trampoline_call(has_neg_long);
4526     b(DONE);
4527 
4528   BIND(SET_RESULT);
4529     cset(result, NE); // set true or false
4530 
4531   BIND(DONE);
4532 }
4533 
4534 void MacroAssembler::arrays_equals(Register a1, Register a2, Register tmp3,
4535                                    Register tmp4, Register tmp5, Register result,
4536                                    Register cnt1, int elem_size) {
4537   Label DONE, SAME;
4538   Register tmp1 = rscratch1;
4539   Register tmp2 = rscratch2;
4540   Register cnt2 = tmp2;  // cnt2 only used in array length compare
4541   int elem_per_word = wordSize/elem_size;
4542   int log_elem_size = exact_log2(elem_size);
4543   int length_offset = arrayOopDesc::length_offset_in_bytes();
4544   int base_offset
4545     = arrayOopDesc::base_offset_in_bytes(elem_size == 2 ? T_CHAR : T_BYTE);
4546   int stubBytesThreshold = 3 * 64 + (UseSIMDForArrayEquals ? 0 : 16);
4547 
4548   assert(elem_size == 1 || elem_size == 2, &quot;must be char or byte&quot;);
4549   assert_different_registers(a1, a2, result, cnt1, rscratch1, rscratch2);
4550 
4551 #ifndef PRODUCT
4552   {
4553     const char kind = (elem_size == 2) ? &#39;U&#39; : &#39;L&#39;;
4554     char comment[64];
4555     snprintf(comment, sizeof comment, &quot;array_equals%c{&quot;, kind);
4556     BLOCK_COMMENT(comment);
4557   }
4558 #endif
4559 
4560   // if (a1 == a2)
4561   //     return true;
4562   cmpoop(a1, a2); // May have read barriers for a1 and a2.
4563   br(EQ, SAME);
4564 
4565   if (UseSimpleArrayEquals) {
4566     Label NEXT_WORD, SHORT, TAIL03, TAIL01, A_MIGHT_BE_NULL, A_IS_NOT_NULL;
4567     // if (a1 == null || a2 == null)
4568     //     return false;
4569     // a1 &amp; a2 == 0 means (some-pointer is null) or
4570     // (very-rare-or-even-probably-impossible-pointer-values)
4571     // so, we can save one branch in most cases
4572     tst(a1, a2);
4573     mov(result, false);
4574     br(EQ, A_MIGHT_BE_NULL);
4575     // if (a1.length != a2.length)
4576     //      return false;
4577     bind(A_IS_NOT_NULL);
4578     ldrw(cnt1, Address(a1, length_offset));
4579     ldrw(cnt2, Address(a2, length_offset));
4580     eorw(tmp5, cnt1, cnt2);
4581     cbnzw(tmp5, DONE);
4582     lea(a1, Address(a1, base_offset));
4583     lea(a2, Address(a2, base_offset));
4584     // Check for short strings, i.e. smaller than wordSize.
4585     subs(cnt1, cnt1, elem_per_word);
4586     br(Assembler::LT, SHORT);
4587     // Main 8 byte comparison loop.
4588     bind(NEXT_WORD); {
4589       ldr(tmp1, Address(post(a1, wordSize)));
4590       ldr(tmp2, Address(post(a2, wordSize)));
4591       subs(cnt1, cnt1, elem_per_word);
4592       eor(tmp5, tmp1, tmp2);
4593       cbnz(tmp5, DONE);
4594     } br(GT, NEXT_WORD);
4595     // Last longword.  In the case where length == 4 we compare the
4596     // same longword twice, but that&#39;s still faster than another
4597     // conditional branch.
4598     // cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when
4599     // length == 4.
4600     if (log_elem_size &gt; 0)
4601       lsl(cnt1, cnt1, log_elem_size);
4602     ldr(tmp3, Address(a1, cnt1));
4603     ldr(tmp4, Address(a2, cnt1));
4604     eor(tmp5, tmp3, tmp4);
4605     cbnz(tmp5, DONE);
4606     b(SAME);
4607     bind(A_MIGHT_BE_NULL);
4608     // in case both a1 and a2 are not-null, proceed with loads
4609     cbz(a1, DONE);
4610     cbz(a2, DONE);
4611     b(A_IS_NOT_NULL);
4612     bind(SHORT);
4613 
4614     tbz(cnt1, 2 - log_elem_size, TAIL03); // 0-7 bytes left.
4615     {
4616       ldrw(tmp1, Address(post(a1, 4)));
4617       ldrw(tmp2, Address(post(a2, 4)));
4618       eorw(tmp5, tmp1, tmp2);
4619       cbnzw(tmp5, DONE);
4620     }
4621     bind(TAIL03);
4622     tbz(cnt1, 1 - log_elem_size, TAIL01); // 0-3 bytes left.
4623     {
4624       ldrh(tmp3, Address(post(a1, 2)));
4625       ldrh(tmp4, Address(post(a2, 2)));
4626       eorw(tmp5, tmp3, tmp4);
4627       cbnzw(tmp5, DONE);
4628     }
4629     bind(TAIL01);
4630     if (elem_size == 1) { // Only needed when comparing byte arrays.
4631       tbz(cnt1, 0, SAME); // 0-1 bytes left.
4632       {
4633         ldrb(tmp1, a1);
4634         ldrb(tmp2, a2);
4635         eorw(tmp5, tmp1, tmp2);
4636         cbnzw(tmp5, DONE);
4637       }
4638     }
4639   } else {
4640     Label NEXT_DWORD, SHORT, TAIL, TAIL2, STUB, EARLY_OUT,
4641         CSET_EQ, LAST_CHECK;
4642     mov(result, false);
4643     cbz(a1, DONE);
4644     ldrw(cnt1, Address(a1, length_offset));
4645     cbz(a2, DONE);
4646     ldrw(cnt2, Address(a2, length_offset));
4647     // on most CPUs a2 is still &quot;locked&quot;(surprisingly) in ldrw and it&#39;s
4648     // faster to perform another branch before comparing a1 and a2
4649     cmp(cnt1, (u1)elem_per_word);
4650     br(LE, SHORT); // short or same
4651     ldr(tmp3, Address(pre(a1, base_offset)));
4652     subs(zr, cnt1, stubBytesThreshold);
4653     br(GE, STUB);
4654     ldr(tmp4, Address(pre(a2, base_offset)));
4655     sub(tmp5, zr, cnt1, LSL, 3 + log_elem_size);
4656     cmp(cnt2, cnt1);
4657     br(NE, DONE);
4658 
4659     // Main 16 byte comparison loop with 2 exits
4660     bind(NEXT_DWORD); {
4661       ldr(tmp1, Address(pre(a1, wordSize)));
4662       ldr(tmp2, Address(pre(a2, wordSize)));
4663       subs(cnt1, cnt1, 2 * elem_per_word);
4664       br(LE, TAIL);
4665       eor(tmp4, tmp3, tmp4);
4666       cbnz(tmp4, DONE);
4667       ldr(tmp3, Address(pre(a1, wordSize)));
4668       ldr(tmp4, Address(pre(a2, wordSize)));
4669       cmp(cnt1, (u1)elem_per_word);
4670       br(LE, TAIL2);
4671       cmp(tmp1, tmp2);
4672     } br(EQ, NEXT_DWORD);
4673     b(DONE);
4674 
4675     bind(TAIL);
4676     eor(tmp4, tmp3, tmp4);
4677     eor(tmp2, tmp1, tmp2);
4678     lslv(tmp2, tmp2, tmp5);
4679     orr(tmp5, tmp4, tmp2);
4680     cmp(tmp5, zr);
4681     b(CSET_EQ);
4682 
4683     bind(TAIL2);
4684     eor(tmp2, tmp1, tmp2);
4685     cbnz(tmp2, DONE);
4686     b(LAST_CHECK);
4687 
4688     bind(STUB);
4689     ldr(tmp4, Address(pre(a2, base_offset)));
4690     cmp(cnt2, cnt1);
4691     br(NE, DONE);
4692     if (elem_size == 2) { // convert to byte counter
4693       lsl(cnt1, cnt1, 1);
4694     }
4695     eor(tmp5, tmp3, tmp4);
4696     cbnz(tmp5, DONE);
4697     RuntimeAddress stub = RuntimeAddress(StubRoutines::aarch64::large_array_equals());
4698     assert(stub.target() != NULL, &quot;array_equals_long stub has not been generated&quot;);
4699     trampoline_call(stub);
4700     b(DONE);
4701 
4702     bind(EARLY_OUT);
4703     // (a1 != null &amp;&amp; a2 == null) || (a1 != null &amp;&amp; a2 != null &amp;&amp; a1 == a2)
4704     // so, if a2 == null =&gt; return false(0), else return true, so we can return a2
4705     mov(result, a2);
4706     b(DONE);
4707     bind(SHORT);
4708     cmp(cnt2, cnt1);
4709     br(NE, DONE);
4710     cbz(cnt1, SAME);
4711     sub(tmp5, zr, cnt1, LSL, 3 + log_elem_size);
4712     ldr(tmp3, Address(a1, base_offset));
4713     ldr(tmp4, Address(a2, base_offset));
4714     bind(LAST_CHECK);
4715     eor(tmp4, tmp3, tmp4);
4716     lslv(tmp5, tmp4, tmp5);
4717     cmp(tmp5, zr);
4718     bind(CSET_EQ);
4719     cset(result, EQ);
4720     b(DONE);
4721   }
4722 
4723   bind(SAME);
4724   mov(result, true);
4725   // That&#39;s it.
4726   bind(DONE);
4727 
4728   BLOCK_COMMENT(&quot;} array_equals&quot;);
4729 }
4730 
4731 // Compare Strings
4732 
4733 // For Strings we&#39;re passed the address of the first characters in a1
4734 // and a2 and the length in cnt1.
4735 // elem_size is the element size in bytes: either 1 or 2.
4736 // There are two implementations.  For arrays &gt;= 8 bytes, all
4737 // comparisons (including the final one, which may overlap) are
4738 // performed 8 bytes at a time.  For strings &lt; 8 bytes, we compare a
4739 // halfword, then a short, and then a byte.
4740 
4741 void MacroAssembler::string_equals(Register a1, Register a2,
4742                                    Register result, Register cnt1, int elem_size)
4743 {
4744   Label SAME, DONE, SHORT, NEXT_WORD;
4745   Register tmp1 = rscratch1;
4746   Register tmp2 = rscratch2;
4747   Register cnt2 = tmp2;  // cnt2 only used in array length compare
4748 
4749   assert(elem_size == 1 || elem_size == 2, &quot;must be 2 or 1 byte&quot;);
4750   assert_different_registers(a1, a2, result, cnt1, rscratch1, rscratch2);
4751 
4752 #ifndef PRODUCT
4753   {
4754     const char kind = (elem_size == 2) ? &#39;U&#39; : &#39;L&#39;;
4755     char comment[64];
4756     snprintf(comment, sizeof comment, &quot;{string_equals%c&quot;, kind);
4757     BLOCK_COMMENT(comment);
4758   }
4759 #endif
4760 
4761   mov(result, false);
4762 
4763   // Check for short strings, i.e. smaller than wordSize.
4764   subs(cnt1, cnt1, wordSize);
4765   br(Assembler::LT, SHORT);
4766   // Main 8 byte comparison loop.
4767   bind(NEXT_WORD); {
4768     ldr(tmp1, Address(post(a1, wordSize)));
4769     ldr(tmp2, Address(post(a2, wordSize)));
4770     subs(cnt1, cnt1, wordSize);
4771     eor(tmp1, tmp1, tmp2);
4772     cbnz(tmp1, DONE);
4773   } br(GT, NEXT_WORD);
4774   // Last longword.  In the case where length == 4 we compare the
4775   // same longword twice, but that&#39;s still faster than another
4776   // conditional branch.
4777   // cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when
4778   // length == 4.
4779   ldr(tmp1, Address(a1, cnt1));
4780   ldr(tmp2, Address(a2, cnt1));
4781   eor(tmp2, tmp1, tmp2);
4782   cbnz(tmp2, DONE);
4783   b(SAME);
4784 
4785   bind(SHORT);
4786   Label TAIL03, TAIL01;
4787 
4788   tbz(cnt1, 2, TAIL03); // 0-7 bytes left.
4789   {
4790     ldrw(tmp1, Address(post(a1, 4)));
4791     ldrw(tmp2, Address(post(a2, 4)));
4792     eorw(tmp1, tmp1, tmp2);
4793     cbnzw(tmp1, DONE);
4794   }
4795   bind(TAIL03);
4796   tbz(cnt1, 1, TAIL01); // 0-3 bytes left.
4797   {
4798     ldrh(tmp1, Address(post(a1, 2)));
4799     ldrh(tmp2, Address(post(a2, 2)));
4800     eorw(tmp1, tmp1, tmp2);
4801     cbnzw(tmp1, DONE);
4802   }
4803   bind(TAIL01);
4804   if (elem_size == 1) { // Only needed when comparing 1-byte elements
4805     tbz(cnt1, 0, SAME); // 0-1 bytes left.
4806     {
4807       ldrb(tmp1, a1);
4808       ldrb(tmp2, a2);
4809       eorw(tmp1, tmp1, tmp2);
4810       cbnzw(tmp1, DONE);
4811     }
4812   }
4813   // Arrays are equal.
4814   bind(SAME);
4815   mov(result, true);
4816 
4817   // That&#39;s it.
4818   bind(DONE);
4819   BLOCK_COMMENT(&quot;} string_equals&quot;);
4820 }
4821 
4822 
4823 // The size of the blocks erased by the zero_blocks stub.  We must
4824 // handle anything smaller than this ourselves in zero_words().
4825 const int MacroAssembler::zero_words_block_size = 8;
4826 
4827 // zero_words() is used by C2 ClearArray patterns.  It is as small as
4828 // possible, handling small word counts locally and delegating
4829 // anything larger to the zero_blocks stub.  It is expanded many times
4830 // in compiled code, so it is important to keep it short.
4831 
4832 // ptr:   Address of a buffer to be zeroed.
4833 // cnt:   Count in HeapWords.
4834 //
4835 // ptr, cnt, rscratch1, and rscratch2 are clobbered.
4836 void MacroAssembler::zero_words(Register ptr, Register cnt)
4837 {
4838   assert(is_power_of_2(zero_words_block_size), &quot;adjust this&quot;);
4839   assert(ptr == r10 &amp;&amp; cnt == r11, &quot;mismatch in register usage&quot;);
4840 
4841   BLOCK_COMMENT(&quot;zero_words {&quot;);
4842   cmp(cnt, (u1)zero_words_block_size);
4843   Label around;
4844   br(LO, around);
4845   {
4846     RuntimeAddress zero_blocks =  RuntimeAddress(StubRoutines::aarch64::zero_blocks());
4847     assert(zero_blocks.target() != NULL, &quot;zero_blocks stub has not been generated&quot;);
4848     if (StubRoutines::aarch64::complete()) {
4849       trampoline_call(zero_blocks);
4850     } else {
4851       bl(zero_blocks);
4852     }
4853   }
4854   bind(around);
4855   for (int i = zero_words_block_size &gt;&gt; 1; i &gt; 1; i &gt;&gt;= 1) {
4856     Label l;
4857     tbz(cnt, exact_log2(i), l);
4858     for (int j = 0; j &lt; i; j += 2) {
4859       stp(zr, zr, post(ptr, 16));
4860     }
4861     bind(l);
4862   }
4863   {
4864     Label l;
4865     tbz(cnt, 0, l);
4866     str(zr, Address(ptr));
4867     bind(l);
4868   }
4869   BLOCK_COMMENT(&quot;} zero_words&quot;);
4870 }
4871 
4872 // base:         Address of a buffer to be zeroed, 8 bytes aligned.
4873 // cnt:          Immediate count in HeapWords.
4874 #define SmallArraySize (18 * BytesPerLong)
4875 void MacroAssembler::zero_words(Register base, u_int64_t cnt)
4876 {
4877   BLOCK_COMMENT(&quot;zero_words {&quot;);
4878   int i = cnt &amp; 1;  // store any odd word to start
4879   if (i) str(zr, Address(base));
4880 
4881   if (cnt &lt;= SmallArraySize / BytesPerLong) {
4882     for (; i &lt; (int)cnt; i += 2)
4883       stp(zr, zr, Address(base, i * wordSize));
4884   } else {
4885     const int unroll = 4; // Number of stp(zr, zr) instructions we&#39;ll unroll
4886     int remainder = cnt % (2 * unroll);
4887     for (; i &lt; remainder; i += 2)
4888       stp(zr, zr, Address(base, i * wordSize));
4889 
4890     Label loop;
4891     Register cnt_reg = rscratch1;
4892     Register loop_base = rscratch2;
4893     cnt = cnt - remainder;
4894     mov(cnt_reg, cnt);
4895     // adjust base and prebias by -2 * wordSize so we can pre-increment
4896     add(loop_base, base, (remainder - 2) * wordSize);
4897     bind(loop);
4898     sub(cnt_reg, cnt_reg, 2 * unroll);
4899     for (i = 1; i &lt; unroll; i++)
4900       stp(zr, zr, Address(loop_base, 2 * i * wordSize));
4901     stp(zr, zr, Address(pre(loop_base, 2 * unroll * wordSize)));
4902     cbnz(cnt_reg, loop);
4903   }
4904   BLOCK_COMMENT(&quot;} zero_words&quot;);
4905 }
4906 
4907 // Zero blocks of memory by using DC ZVA.
4908 //
4909 // Aligns the base address first sufficently for DC ZVA, then uses
4910 // DC ZVA repeatedly for every full block.  cnt is the size to be
4911 // zeroed in HeapWords.  Returns the count of words left to be zeroed
4912 // in cnt.
4913 //
4914 // NOTE: This is intended to be used in the zero_blocks() stub.  If
4915 // you want to use it elsewhere, note that cnt must be &gt;= 2*zva_length.
4916 void MacroAssembler::zero_dcache_blocks(Register base, Register cnt) {
4917   Register tmp = rscratch1;
4918   Register tmp2 = rscratch2;
4919   int zva_length = VM_Version::zva_length();
4920   Label initial_table_end, loop_zva;
4921   Label fini;
4922 
4923   // Base must be 16 byte aligned. If not just return and let caller handle it
4924   tst(base, 0x0f);
4925   br(Assembler::NE, fini);
4926   // Align base with ZVA length.
4927   neg(tmp, base);
4928   andr(tmp, tmp, zva_length - 1);
4929 
4930   // tmp: the number of bytes to be filled to align the base with ZVA length.
4931   add(base, base, tmp);
4932   sub(cnt, cnt, tmp, Assembler::ASR, 3);
4933   adr(tmp2, initial_table_end);
4934   sub(tmp2, tmp2, tmp, Assembler::LSR, 2);
4935   br(tmp2);
4936 
4937   for (int i = -zva_length + 16; i &lt; 0; i += 16)
4938     stp(zr, zr, Address(base, i));
4939   bind(initial_table_end);
4940 
4941   sub(cnt, cnt, zva_length &gt;&gt; 3);
4942   bind(loop_zva);
4943   dc(Assembler::ZVA, base);
4944   subs(cnt, cnt, zva_length &gt;&gt; 3);
4945   add(base, base, zva_length);
4946   br(Assembler::GE, loop_zva);
4947   add(cnt, cnt, zva_length &gt;&gt; 3); // count not zeroed by DC ZVA
4948   bind(fini);
4949 }
4950 
4951 // base:   Address of a buffer to be filled, 8 bytes aligned.
4952 // cnt:    Count in 8-byte unit.
4953 // value:  Value to be filled with.
4954 // base will point to the end of the buffer after filling.
4955 void MacroAssembler::fill_words(Register base, Register cnt, Register value)
4956 {
4957 //  Algorithm:
4958 //
4959 //    scratch1 = cnt &amp; 7;
4960 //    cnt -= scratch1;
4961 //    p += scratch1;
4962 //    switch (scratch1) {
4963 //      do {
4964 //        cnt -= 8;
4965 //          p[-8] = v;
4966 //        case 7:
4967 //          p[-7] = v;
4968 //        case 6:
4969 //          p[-6] = v;
4970 //          // ...
4971 //        case 1:
4972 //          p[-1] = v;
4973 //        case 0:
4974 //          p += 8;
4975 //      } while (cnt);
4976 //    }
4977 
4978   assert_different_registers(base, cnt, value, rscratch1, rscratch2);
4979 
4980   Label fini, skip, entry, loop;
4981   const int unroll = 8; // Number of stp instructions we&#39;ll unroll
4982 
4983   cbz(cnt, fini);
4984   tbz(base, 3, skip);
4985   str(value, Address(post(base, 8)));
4986   sub(cnt, cnt, 1);
4987   bind(skip);
4988 
4989   andr(rscratch1, cnt, (unroll-1) * 2);
4990   sub(cnt, cnt, rscratch1);
4991   add(base, base, rscratch1, Assembler::LSL, 3);
4992   adr(rscratch2, entry);
4993   sub(rscratch2, rscratch2, rscratch1, Assembler::LSL, 1);
4994   br(rscratch2);
4995 
4996   bind(loop);
4997   add(base, base, unroll * 16);
4998   for (int i = -unroll; i &lt; 0; i++)
4999     stp(value, value, Address(base, i * 16));
5000   bind(entry);
5001   subs(cnt, cnt, unroll * 2);
5002   br(Assembler::GE, loop);
5003 
5004   tbz(cnt, 0, fini);
5005   str(value, Address(post(base, 8)));
5006   bind(fini);
5007 }
5008 
5009 // Intrinsic for sun/nio/cs/ISO_8859_1$Encoder.implEncodeISOArray and
5010 // java/lang/StringUTF16.compress.
5011 void MacroAssembler::encode_iso_array(Register src, Register dst,
5012                       Register len, Register result,
5013                       FloatRegister Vtmp1, FloatRegister Vtmp2,
5014                       FloatRegister Vtmp3, FloatRegister Vtmp4)
5015 {
5016     Label DONE, SET_RESULT, NEXT_32, NEXT_32_PRFM, LOOP_8, NEXT_8, LOOP_1, NEXT_1,
5017         NEXT_32_START, NEXT_32_PRFM_START;
5018     Register tmp1 = rscratch1, tmp2 = rscratch2;
5019 
5020       mov(result, len); // Save initial len
5021 
5022       cmp(len, (u1)8); // handle shortest strings first
5023       br(LT, LOOP_1);
5024       cmp(len, (u1)32);
5025       br(LT, NEXT_8);
5026       // The following code uses the SIMD &#39;uzp1&#39; and &#39;uzp2&#39; instructions
5027       // to convert chars to bytes
5028       if (SoftwarePrefetchHintDistance &gt;= 0) {
5029         ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5030         subs(tmp2, len, SoftwarePrefetchHintDistance/2 + 16);
5031         br(LE, NEXT_32_START);
5032         b(NEXT_32_PRFM_START);
5033         BIND(NEXT_32_PRFM);
5034           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5035         BIND(NEXT_32_PRFM_START);
5036           prfm(Address(src, SoftwarePrefetchHintDistance));
5037           orr(v4, T16B, Vtmp1, Vtmp2);
5038           orr(v5, T16B, Vtmp3, Vtmp4);
5039           uzp1(Vtmp1, T16B, Vtmp1, Vtmp2);
5040           uzp1(Vtmp3, T16B, Vtmp3, Vtmp4);
5041           uzp2(v5, T16B, v4, v5); // high bytes
5042           umov(tmp2, v5, D, 1);
5043           fmovd(tmp1, v5);
5044           orr(tmp1, tmp1, tmp2);
5045           cbnz(tmp1, LOOP_8);
5046           stpq(Vtmp1, Vtmp3, dst);
5047           sub(len, len, 32);
5048           add(dst, dst, 32);
5049           add(src, src, 64);
5050           subs(tmp2, len, SoftwarePrefetchHintDistance/2 + 16);
5051           br(GE, NEXT_32_PRFM);
5052           cmp(len, (u1)32);
5053           br(LT, LOOP_8);
5054         BIND(NEXT_32);
5055           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5056         BIND(NEXT_32_START);
5057       } else {
5058         BIND(NEXT_32);
5059           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5060       }
5061       prfm(Address(src, SoftwarePrefetchHintDistance));
5062       uzp1(v4, T16B, Vtmp1, Vtmp2);
5063       uzp1(v5, T16B, Vtmp3, Vtmp4);
5064       orr(Vtmp1, T16B, Vtmp1, Vtmp2);
5065       orr(Vtmp3, T16B, Vtmp3, Vtmp4);
5066       uzp2(Vtmp1, T16B, Vtmp1, Vtmp3); // high bytes
5067       umov(tmp2, Vtmp1, D, 1);
5068       fmovd(tmp1, Vtmp1);
5069       orr(tmp1, tmp1, tmp2);
5070       cbnz(tmp1, LOOP_8);
5071       stpq(v4, v5, dst);
5072       sub(len, len, 32);
5073       add(dst, dst, 32);
5074       add(src, src, 64);
5075       cmp(len, (u1)32);
5076       br(GE, NEXT_32);
5077       cbz(len, DONE);
5078 
5079     BIND(LOOP_8);
5080       cmp(len, (u1)8);
5081       br(LT, LOOP_1);
5082     BIND(NEXT_8);
5083       ld1(Vtmp1, T8H, src);
5084       uzp1(Vtmp2, T16B, Vtmp1, Vtmp1); // low bytes
5085       uzp2(Vtmp3, T16B, Vtmp1, Vtmp1); // high bytes
5086       fmovd(tmp1, Vtmp3);
5087       cbnz(tmp1, NEXT_1);
5088       strd(Vtmp2, dst);
5089 
5090       sub(len, len, 8);
5091       add(dst, dst, 8);
5092       add(src, src, 16);
5093       cmp(len, (u1)8);
5094       br(GE, NEXT_8);
5095 
5096     BIND(LOOP_1);
5097 
5098     cbz(len, DONE);
5099     BIND(NEXT_1);
5100       ldrh(tmp1, Address(post(src, 2)));
5101       tst(tmp1, 0xff00);
5102       br(NE, SET_RESULT);
5103       strb(tmp1, Address(post(dst, 1)));
5104       subs(len, len, 1);
5105       br(GT, NEXT_1);
5106 
5107     BIND(SET_RESULT);
5108       sub(result, result, len); // Return index where we stopped
5109                                 // Return len == 0 if we processed all
5110                                 // characters
5111     BIND(DONE);
5112 }
5113 
5114 
5115 // Inflate byte[] array to char[].
5116 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
5117                                         FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,
5118                                         Register tmp4) {
5119   Label big, done, after_init, to_stub;
5120 
5121   assert_different_registers(src, dst, len, tmp4, rscratch1);
5122 
5123   fmovd(vtmp1, zr);
5124   lsrw(tmp4, len, 3);
5125   bind(after_init);
5126   cbnzw(tmp4, big);
5127   // Short string: less than 8 bytes.
5128   {
5129     Label loop, tiny;
5130 
5131     cmpw(len, 4);
5132     br(LT, tiny);
5133     // Use SIMD to do 4 bytes.
5134     ldrs(vtmp2, post(src, 4));
5135     zip1(vtmp3, T8B, vtmp2, vtmp1);
5136     subw(len, len, 4);
5137     strd(vtmp3, post(dst, 8));
5138 
5139     cbzw(len, done);
5140 
5141     // Do the remaining bytes by steam.
5142     bind(loop);
5143     ldrb(tmp4, post(src, 1));
5144     strh(tmp4, post(dst, 2));
5145     subw(len, len, 1);
5146 
5147     bind(tiny);
5148     cbnz(len, loop);
5149 
5150     b(done);
5151   }
5152 
5153   if (SoftwarePrefetchHintDistance &gt;= 0) {
5154     bind(to_stub);
5155       RuntimeAddress stub =  RuntimeAddress(StubRoutines::aarch64::large_byte_array_inflate());
5156       assert(stub.target() != NULL, &quot;large_byte_array_inflate stub has not been generated&quot;);
5157       trampoline_call(stub);
5158       b(after_init);
5159   }
5160 
5161   // Unpack the bytes 8 at a time.
5162   bind(big);
5163   {
5164     Label loop, around, loop_last, loop_start;
5165 
5166     if (SoftwarePrefetchHintDistance &gt;= 0) {
5167       const int large_loop_threshold = (64 + 16)/8;
5168       ldrd(vtmp2, post(src, 8));
5169       andw(len, len, 7);
5170       cmp(tmp4, (u1)large_loop_threshold);
5171       br(GE, to_stub);
5172       b(loop_start);
5173 
5174       bind(loop);
5175       ldrd(vtmp2, post(src, 8));
5176       bind(loop_start);
5177       subs(tmp4, tmp4, 1);
5178       br(EQ, loop_last);
5179       zip1(vtmp2, T16B, vtmp2, vtmp1);
5180       ldrd(vtmp3, post(src, 8));
5181       st1(vtmp2, T8H, post(dst, 16));
5182       subs(tmp4, tmp4, 1);
5183       zip1(vtmp3, T16B, vtmp3, vtmp1);
5184       st1(vtmp3, T8H, post(dst, 16));
5185       br(NE, loop);
5186       b(around);
5187       bind(loop_last);
5188       zip1(vtmp2, T16B, vtmp2, vtmp1);
5189       st1(vtmp2, T8H, post(dst, 16));
5190       bind(around);
5191       cbz(len, done);
5192     } else {
5193       andw(len, len, 7);
5194       bind(loop);
5195       ldrd(vtmp2, post(src, 8));
5196       sub(tmp4, tmp4, 1);
5197       zip1(vtmp3, T16B, vtmp2, vtmp1);
5198       st1(vtmp3, T8H, post(dst, 16));
5199       cbnz(tmp4, loop);
5200     }
5201   }
5202 
5203   // Do the tail of up to 8 bytes.
5204   add(src, src, len);
5205   ldrd(vtmp3, Address(src, -8));
5206   add(dst, dst, len, ext::uxtw, 1);
5207   zip1(vtmp3, T16B, vtmp3, vtmp1);
5208   strq(vtmp3, Address(dst, -16));
5209 
5210   bind(done);
5211 }
5212 
5213 // Compress char[] array to byte[].
5214 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
5215                                          FloatRegister tmp1Reg, FloatRegister tmp2Reg,
5216                                          FloatRegister tmp3Reg, FloatRegister tmp4Reg,
5217                                          Register result) {
5218   encode_iso_array(src, dst, len, result,
5219                    tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg);
5220   cmp(len, zr);
5221   csel(result, result, zr, EQ);
5222 }
5223 
5224 // get_thread() can be called anywhere inside generated code so we
5225 // need to save whatever non-callee save context might get clobbered
5226 // by the call to JavaThread::aarch64_get_thread_helper() or, indeed,
5227 // the call setup code.
5228 //
5229 // aarch64_get_thread_helper() clobbers only r0, r1, and flags.
5230 //
5231 void MacroAssembler::get_thread(Register dst) {
5232   RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;
5233   push(saved_regs, sp);
5234 
5235   mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));
5236   blr(lr);
5237   if (dst != c_rarg0) {
5238     mov(dst, c_rarg0);
5239   }
5240 
5241   pop(saved_regs, sp);
5242 }
5243 
5244 // C2 compiled method&#39;s prolog code
5245 // Moved here from aarch64.ad to support Valhalla code belows
5246 void MacroAssembler::verified_entry(Compile* C, int sp_inc) {
5247 
5248 // n.b. frame size includes space for return pc and rfp
5249   const long framesize = C-&gt;frame_size_in_bytes();
5250   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2 * wordSize alignment&quot;);
5251 
5252   // insert a nop at the start of the prolog so we can patch in a
5253   // branch if we need to invalidate the method later
5254   nop();
5255 
5256   int bangsize = C-&gt;bang_size_in_bytes();
5257   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)
5258      generate_stack_overflow_check(bangsize);
5259 
5260   build_frame(framesize);
5261 
5262   if (VerifyStackAtCalls) {
5263     Unimplemented();
5264   }
5265 }
5266 
5267 int MacroAssembler::store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter) {
5268   // An inline type might be returned. If fields are in registers we
5269   // need to allocate an inline type instance and initialize it with
5270   // the value of the fields.
5271   Label skip;
5272   // We only need a new buffered inline type if a new one is not returned
5273   cmp(r0, (u1) 1);
5274   br(Assembler::EQ, skip);
5275   int call_offset = -1;
5276 
5277   Label slow_case;
5278 
5279   // Try to allocate a new buffered inline type (from the heap)
5280   if (UseTLAB) {
5281 
5282     if (vk != NULL) {
5283       // Called from C1, where the return type is statically known.
5284       mov(r1, (intptr_t)vk-&gt;get_InlineKlass());
5285       jint lh = vk-&gt;layout_helper();
5286       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);
5287       mov(r14, lh);
5288     } else {
5289        // Call from interpreter. R0 contains ((the InlineKlass* of the return type) | 0x01)
5290        andr(r1, r0, -2);
5291        // get obj size
5292        ldrw(r14, Address(rscratch1 /*klass*/, Klass::layout_helper_offset()));
5293     }
5294 
5295      ldr(r13, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
5296 
5297      // check whether we have space in TLAB,
5298      // rscratch1 contains pointer to just allocated obj
5299       lea(r14, Address(r13, r14));
5300       ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_end_offset())));
5301 
5302       cmp(r14, rscratch1);
5303       br(Assembler::GT, slow_case);
5304 
5305       // OK we have room in TLAB,
5306       // Set new TLAB top
5307       str(r14, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
5308 
5309       // Set new class always locked
5310       mov(rscratch1, (uint64_t) markWord::always_locked_prototype().value());
5311       str(rscratch1, Address(r13, oopDesc::mark_offset_in_bytes()));
5312 
5313       store_klass_gap(r13, zr);  // zero klass gap for compressed oops
5314       if (vk == NULL) {
5315         // store_klass corrupts rbx, so save it in rax for later use (interpreter case only).
5316          mov(r0, r1);
5317       }
5318 
5319       store_klass(r13, r1);  // klass
5320 
5321       if (vk != NULL) {
5322         // FIXME -- do the packing in-line to avoid the runtime call
5323         mov(r0, r13);
5324         far_call(RuntimeAddress(vk-&gt;pack_handler())); // no need for call info as this will not safepoint.
5325       } else {
5326 
5327         // We have our new buffered inline type, initialize its fields with an inline class specific handler
5328         ldr(r1, Address(r0, InstanceKlass::adr_inlineklass_fixed_block_offset()));
5329         ldr(r1, Address(r1, InlineKlass::pack_handler_offset()));
5330 
5331         // Mov new class to r0 and call pack_handler
5332         mov(r0, r13);
5333         blr(r1);
5334       }
5335       b(skip);
5336   }
5337 
5338   bind(slow_case);
5339   // We failed to allocate a new inline type, fall back to a runtime
5340   // call. Some oop field may be live in some registers but we can&#39;t
5341   // tell. That runtime call will take care of preserving them
5342   // across a GC if there&#39;s one.
5343 
5344 
5345   if (from_interpreter) {
5346     super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());
5347   } else {
5348     ldr(rscratch1, RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));
5349     blr(rscratch1);
5350     call_offset = offset();
5351   }
5352 
5353   bind(skip);
5354   return call_offset;
5355 }
5356 
5357 // Move a value between registers/stack slots and update the reg_state
5358 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {
5359   if (reg_state[to-&gt;value()] == reg_written) {
5360     return true; // Already written
5361   }
5362 
5363   if (from != to &amp;&amp; bt != T_VOID) {
5364     if (reg_state[to-&gt;value()] == reg_readonly) {
5365       return false; // Not yet writable
5366     }
5367     if (from-&gt;is_reg()) {
5368       if (to-&gt;is_reg()) {
5369         mov(to-&gt;as_Register(), from-&gt;as_Register());
5370       } else {
5371         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5372         Address to_addr = Address(sp, st_off);
5373         if (from-&gt;is_FloatRegister()) {
5374           if (bt == T_DOUBLE) {
5375              strd(from-&gt;as_FloatRegister(), to_addr);
5376           } else {
5377              assert(bt == T_FLOAT, &quot;must be float&quot;);
5378              strs(from-&gt;as_FloatRegister(), to_addr);
5379           }
5380         } else {
5381           str(from-&gt;as_Register(), to_addr);
5382         }
5383       }
5384     } else {
5385       Address from_addr = Address(sp, from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset);
5386       if (to-&gt;is_reg()) {
5387         if (to-&gt;is_FloatRegister()) {
5388           if (bt == T_DOUBLE) {
5389              ldrd(to-&gt;as_FloatRegister(), from_addr);
5390           } else {
5391             assert(bt == T_FLOAT, &quot;must be float&quot;);
5392             ldrs(to-&gt;as_FloatRegister(), from_addr);
5393           }
5394         } else {
5395           ldr(to-&gt;as_Register(), from_addr);
5396         }
5397       } else {
5398         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5399         ldr(rscratch1, from_addr);
5400         str(rscratch1, Address(sp, st_off));
5401       }
5402     }
5403   }
5404 
5405   // Update register states
5406   reg_state[from-&gt;value()] = reg_writable;
5407   reg_state[to-&gt;value()] = reg_written;
5408   return true;
5409 }
5410 
5411 // Read all fields from an inline type oop and store the values in registers/stack slots
5412 bool MacroAssembler::unpack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,
5413                                           int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {
5414   Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;
5415   assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);
5416 
5417 
5418   int vt = 1;
5419   bool done = true;
5420   bool mark_done = true;
5421   do {
5422     sig_index--;
5423     BasicType bt = sig-&gt;at(sig_index)._bt;
5424     if (bt == T_INLINE_TYPE) {
5425       vt--;
5426     } else if (bt == T_VOID &amp;&amp;
5427                sig-&gt;at(sig_index-1)._bt != T_LONG &amp;&amp;
5428                sig-&gt;at(sig_index-1)._bt != T_DOUBLE) {
5429       vt++;
5430     } else if (SigEntry::is_reserved_entry(sig, sig_index)) {
5431       to_index--; // Ignore this
5432     } else {
5433       assert(to_index &gt;= 0, &quot;invalid to_index&quot;);
5434       VMRegPair pair_to = regs_to[to_index--];
5435       VMReg to = pair_to.first();
5436 
5437       if (bt == T_VOID) continue;
5438 
5439       int idx = (int) to-&gt;value();
5440       if (reg_state[idx] == reg_readonly) {
5441          if (idx != from-&gt;value()) {
5442            mark_done = false;
5443          }
5444          done = false;
5445          continue;
5446       } else if (reg_state[idx] == reg_written) {
5447         continue;
5448       } else {
5449         assert(reg_state[idx] == reg_writable, &quot;must be writable&quot;);
5450         reg_state[idx] = reg_written;
5451       }
5452 
5453       if (fromReg == noreg) {
5454         int st_off = from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5455         ldr(rscratch2, Address(sp, st_off));
5456         fromReg = rscratch2;
5457       }
5458 
5459       int off = sig-&gt;at(sig_index)._offset;
5460       assert(off &gt; 0, &quot;offset in object should be positive&quot;);
5461       bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
5462 
5463       Address fromAddr = Address(fromReg, off);
5464       bool is_signed = (bt != T_CHAR) &amp;&amp; (bt != T_BOOLEAN);
5465 
5466       if (!to-&gt;is_FloatRegister()) {
5467 
5468         Register dst = to-&gt;is_stack() ? rscratch1 : to-&gt;as_Register();
5469 
5470         if (is_oop) {
5471           load_heap_oop(dst, fromAddr);
5472         } else {
5473           load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);
5474         }
5475         if (to-&gt;is_stack()) {
5476           int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5477           str(dst, Address(sp, st_off));
5478         }
5479       } else {
5480         if (bt == T_DOUBLE) {
5481           ldrd(to-&gt;as_FloatRegister(), fromAddr);
5482         } else {
5483           assert(bt == T_FLOAT, &quot;must be float&quot;);
5484           ldrs(to-&gt;as_FloatRegister(), fromAddr);
5485         }
5486      }
5487 
5488     }
5489 
5490   } while (vt != 0);
5491 
5492   if (mark_done &amp;&amp; reg_state[from-&gt;value()] != reg_written) {
5493     // This is okay because no one else will write to that slot
5494     reg_state[from-&gt;value()] = reg_writable;
5495   }
5496   return done;
5497 }
5498 
5499 // Pack fields back into an inline type oop
5500 bool MacroAssembler::pack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
5501                                         VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
5502                                         int ret_off, int extra_stack_offset) {
5503   assert(sig-&gt;at(sig_index)._bt == T_INLINE_TYPE, &quot;should be at end delimiter&quot;);
5504   assert(to-&gt;is_valid(), &quot;must be&quot;);
5505 
5506   if (reg_state[to-&gt;value()] == reg_written) {
5507     skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5508     return true; // Already written
5509   }
5510 
5511   Register val_array = r0;
5512   Register val_obj_tmp = r11;
5513   Register from_reg_tmp = r10;
5514   Register tmp1 = r14;
5515   Register tmp2 = r13;
5516   Register tmp3 = r1;
5517   Register val_obj = to-&gt;is_stack() ? val_obj_tmp : to-&gt;as_Register();
5518 
5519   if (reg_state[to-&gt;value()] == reg_readonly) {
5520     if (!is_reg_in_unpacked_fields(sig, sig_index, to, regs_from, regs_from_count, from_index)) {
5521       skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5522       return false; // Not yet writable
5523     }
5524     val_obj = val_obj_tmp;
5525   }
5526 
5527   int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_INLINE_TYPE);
5528   load_heap_oop(val_obj, Address(val_array, index));
5529 
5530   ScalarizedValueArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);
5531   VMRegPair from_pair;
5532   BasicType bt;
5533 
5534   while (stream.next(from_pair, bt)) {
5535     int off = sig-&gt;at(stream.sig_cc_index())._offset;
5536     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
5537     bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
5538     size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;
5539 
5540     VMReg from_r1 = from_pair.first();
5541     VMReg from_r2 = from_pair.second();
5542 
5543     // Pack the scalarized field into the value object.
5544     Address dst(val_obj, off);
5545 
5546     if (!from_r1-&gt;is_FloatRegister()) {
5547       Register from_reg;
5548       if (from_r1-&gt;is_stack()) {
5549         from_reg = from_reg_tmp;
5550         int ld_off = from_r1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5551         load_sized_value(from_reg, Address(sp, ld_off), size_in_bytes, /* is_signed */ false);
5552       } else {
5553         from_reg = from_r1-&gt;as_Register();
5554       }
5555 
5556       if (is_oop) {
5557         DecoratorSet decorators = IN_HEAP | ACCESS_WRITE;
5558         store_heap_oop(dst, from_reg, tmp1, tmp2, tmp3, decorators);
5559       } else {
5560         store_sized_value(dst, from_reg, size_in_bytes);
5561       }
5562     } else {
5563       if (from_r2-&gt;is_valid()) {
5564         strd(from_r1-&gt;as_FloatRegister(), dst);
5565       } else {
5566         strs(from_r1-&gt;as_FloatRegister(), dst);
5567       }
5568     }
5569 
5570     reg_state[from_r1-&gt;value()] = reg_writable;
5571   }
5572   sig_index = stream.sig_cc_index();
5573   from_index = stream.regs_cc_index();
5574 
5575   assert(reg_state[to-&gt;value()] == reg_writable, &quot;must have already been read&quot;);
5576   bool success = move_helper(val_obj-&gt;as_VMReg(), to, T_OBJECT, reg_state, ret_off, extra_stack_offset);
5577   assert(success, &quot;to register must be writeable&quot;);
5578 
5579   return true;
5580 }
5581 
5582 // Unpack all inline type arguments passed as oops
5583 void MacroAssembler::unpack_inline_args(Compile* C, bool receiver_only) {
5584   int sp_inc = unpack_inline_args_common(C, receiver_only);
5585   // Emit code for verified entry and save increment for stack repair on return
5586   verified_entry(C, sp_inc);
5587 }
5588 
5589 int MacroAssembler::shuffle_inline_args(bool is_packing, bool receiver_only, int extra_stack_offset,
5590                                         BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
5591                                         int args_passed, int args_on_stack, VMRegPair* regs,            // from
5592                                         int args_passed_to, int args_on_stack_to, VMRegPair* regs_to) { // to
5593   // Check if we need to extend the stack for packing/unpacking
5594   int sp_inc = (args_on_stack_to - args_on_stack) * VMRegImpl::stack_slot_size;
5595   if (sp_inc &gt; 0) {
5596     sp_inc = align_up(sp_inc, StackAlignmentInBytes);
5597     if (!is_packing) {
5598       // Save the return address, adjust the stack (make sure it is properly
5599       // 16-byte aligned) and copy the return address to the new top of the stack.
5600       // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).
5601       // FIXME: We need not to preserve return address on aarch64
5602       pop(rscratch1);
5603       sub(sp, sp, sp_inc);
5604       push(rscratch1);
5605     }
5606   } else {
5607     // The scalarized calling convention needs less stack space than the unscalarized one.
5608     // No need to extend the stack, the caller will take care of these adjustments.
5609     sp_inc = 0;
5610   }
5611 
5612   int ret_off; // make sure we don&#39;t overwrite the return address
5613   if (is_packing) {
5614     // For C1 code, the VIEP doesn&#39;t have reserved slots, so we store the returned address at
5615     // rsp[0] during shuffling.
5616     ret_off = 0;
5617   } else {
5618     // C2 code ensures that sp_inc is a reserved slot.
5619     ret_off = sp_inc;
5620   }
5621 
5622   return shuffle_inline_args_common(is_packing, receiver_only, extra_stack_offset,
5623                                     sig_bt, sig_cc,
5624                                     args_passed, args_on_stack, regs,
5625                                     args_passed_to, args_on_stack_to, regs_to,
5626                                     sp_inc, ret_off);
5627 }
5628 
5629 VMReg MacroAssembler::spill_reg_for(VMReg reg) {
5630   return (reg-&gt;is_FloatRegister()) ? v0-&gt;as_VMReg() : r14-&gt;as_VMReg();
5631 }
5632 
5633 void MacroAssembler::cache_wb(Address line) {
5634   assert(line.getMode() == Address::base_plus_offset, &quot;mode should be base_plus_offset&quot;);
5635   assert(line.index() == noreg, &quot;index should be noreg&quot;);
5636   assert(line.offset() == 0, &quot;offset should be 0&quot;);
5637   // would like to assert this
5638   // assert(line._ext.shift == 0, &quot;shift should be zero&quot;);
5639   if (VM_Version::supports_dcpop()) {
5640     // writeback using clear virtual address to point of persistence
5641     dc(Assembler::CVAP, line.base());
5642   } else {
5643     // no need to generate anything as Unsafe.writebackMemory should
5644     // never invoke this stub
5645   }
5646 }
5647 
5648 void MacroAssembler::cache_wbsync(bool is_pre) {
5649   // we only need a barrier post sync
5650   if (!is_pre) {
5651     membar(Assembler::AnyAny);
5652   }
5653 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>