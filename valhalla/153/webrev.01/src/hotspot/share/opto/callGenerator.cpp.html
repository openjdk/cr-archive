<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/callGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  27 #include &quot;ci/ciCallSite.hpp&quot;
  28 #include &quot;ci/ciObjArray.hpp&quot;
  29 #include &quot;ci/ciMemberName.hpp&quot;
  30 #include &quot;ci/ciMethodHandle.hpp&quot;
  31 #include &quot;classfile/javaClasses.hpp&quot;
  32 #include &quot;compiler/compileLog.hpp&quot;
  33 #include &quot;opto/addnode.hpp&quot;
  34 #include &quot;opto/callGenerator.hpp&quot;
  35 #include &quot;opto/callnode.hpp&quot;
  36 #include &quot;opto/castnode.hpp&quot;
  37 #include &quot;opto/cfgnode.hpp&quot;
  38 #include &quot;opto/inlinetypenode.hpp&quot;
  39 #include &quot;opto/parse.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/runtime.hpp&quot;
  42 #include &quot;opto/subnode.hpp&quot;
  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 
  45 // Utility function.
  46 const TypeFunc* CallGenerator::tf() const {
  47   return TypeFunc::make(method());
  48 }
  49 
  50 bool CallGenerator::is_inlined_method_handle_intrinsic(JVMState* jvms, ciMethod* m) {
  51   return is_inlined_method_handle_intrinsic(jvms-&gt;method(), jvms-&gt;bci(), m);
  52 }
  53 
  54 bool CallGenerator::is_inlined_method_handle_intrinsic(ciMethod* caller, int bci, ciMethod* m) {
  55   ciMethod* symbolic_info = caller-&gt;get_method_at_bci(bci);
  56   return is_inlined_method_handle_intrinsic(symbolic_info, m);
  57 }
  58 
  59 bool CallGenerator::is_inlined_method_handle_intrinsic(ciMethod* symbolic_info, ciMethod* m) {
  60   return symbolic_info-&gt;is_method_handle_intrinsic() &amp;&amp; !m-&gt;is_method_handle_intrinsic();
  61 }
  62 
  63 //-----------------------------ParseGenerator---------------------------------
  64 // Internal class which handles all direct bytecode traversal.
  65 class ParseGenerator : public InlineCallGenerator {
  66 private:
  67   bool  _is_osr;
  68   float _expected_uses;
  69 
  70 public:
  71   ParseGenerator(ciMethod* method, float expected_uses, bool is_osr = false)
  72     : InlineCallGenerator(method)
  73   {
  74     _is_osr        = is_osr;
  75     _expected_uses = expected_uses;
  76     assert(InlineTree::check_can_parse(method) == NULL, &quot;parse must be possible&quot;);
  77   }
  78 
  79   virtual bool      is_parse() const           { return true; }
  80   virtual JVMState* generate(JVMState* jvms);
  81   int is_osr() { return _is_osr; }
  82 
  83 };
  84 
  85 JVMState* ParseGenerator::generate(JVMState* jvms) {
  86   Compile* C = Compile::current();
  87   C-&gt;print_inlining_update(this);
  88 
  89   if (is_osr()) {
  90     // The JVMS for a OSR has a single argument (see its TypeFunc).
  91     assert(jvms-&gt;depth() == 1, &quot;no inline OSR&quot;);
  92   }
  93 
  94   if (C-&gt;failing()) {
  95     return NULL;  // bailing out of the compile; do not try to parse
  96   }
  97 
  98   Parse parser(jvms, method(), _expected_uses);
  99   // Grab signature for matching/allocation
 100   GraphKit&amp; exits = parser.exits();
 101 
 102   if (C-&gt;failing()) {
 103     while (exits.pop_exception_state() != NULL) ;
 104     return NULL;
 105   }
 106 
 107   assert(exits.jvms()-&gt;same_calls_as(jvms), &quot;sanity&quot;);
 108 
 109   // Simply return the exit state of the parser,
 110   // augmented by any exceptional states.
 111   return exits.transfer_exceptions_into_jvms();
 112 }
 113 
 114 //---------------------------DirectCallGenerator------------------------------
 115 // Internal class which handles all out-of-line calls w/o receiver type checks.
 116 class DirectCallGenerator : public CallGenerator {
 117  private:
 118   CallStaticJavaNode* _call_node;
 119   // Force separate memory and I/O projections for the exceptional
 120   // paths to facilitate late inlining.
 121   bool                _separate_io_proj;
 122 
 123  public:
 124   DirectCallGenerator(ciMethod* method, bool separate_io_proj)
 125     : CallGenerator(method),
 126       _call_node(NULL),
 127       _separate_io_proj(separate_io_proj)
 128   {
 129     if (InlineTypeReturnedAsFields &amp;&amp; method-&gt;is_method_handle_intrinsic()) {
 130       // If that call has not been optimized by the time optimizations are over,
 131       // we&#39;ll need to add a call to create an inline type instance from the klass
 132       // returned by the call (see PhaseMacroExpand::expand_mh_intrinsic_return).
 133       // Separating memory and I/O projections for exceptions is required to
 134       // perform that graph transformation.
 135       _separate_io_proj = true;
 136     }
 137   }
 138   virtual JVMState* generate(JVMState* jvms);
 139 
 140   CallStaticJavaNode* call_node() const { return _call_node; }
 141 };
 142 
 143 JVMState* DirectCallGenerator::generate(JVMState* jvms) {
 144   GraphKit kit(jvms);
 145   kit.C-&gt;print_inlining_update(this);
 146   PhaseGVN&amp; gvn = kit.gvn();
 147   bool is_static = method()-&gt;is_static();
 148   address target = is_static ? SharedRuntime::get_resolve_static_call_stub()
 149                              : SharedRuntime::get_resolve_opt_virtual_call_stub();
 150 
 151   if (kit.C-&gt;log() != NULL) {
 152     kit.C-&gt;log()-&gt;elem(&quot;direct_call bci=&#39;%d&#39;&quot;, jvms-&gt;bci());
 153   }
 154 
 155   CallStaticJavaNode *call = new CallStaticJavaNode(kit.C, tf(), target, method(), kit.bci());
 156   if (is_inlined_method_handle_intrinsic(jvms, method())) {
 157     // To be able to issue a direct call and skip a call to MH.linkTo*/invokeBasic adapter,
 158     // additional information about the method being invoked should be attached
 159     // to the call site to make resolution logic work
 160     // (see SharedRuntime::resolve_static_call_C).
 161     call-&gt;set_override_symbolic_info(true);
 162   }
 163   _call_node = call;  // Save the call node in case we need it later
 164   if (!is_static) {
 165     // Make an explicit receiver null_check as part of this call.
 166     // Since we share a map with the caller, his JVMS gets adjusted.
 167     kit.null_check_receiver_before_call(method());
 168     if (kit.stopped()) {
 169       // And dump it back to the caller, decorated with any exceptions:
 170       return kit.transfer_exceptions_into_jvms();
 171     }
 172     // Mark the call node as virtual, sort of:
 173     call-&gt;set_optimized_virtual(true);
 174     if (method()-&gt;is_method_handle_intrinsic() ||
 175         method()-&gt;is_compiled_lambda_form()) {
 176       call-&gt;set_method_handle_invoke(true);
 177     }
 178   }
 179   kit.set_arguments_for_java_call(call, is_late_inline());
 180   if (kit.stopped()) {
 181     return kit.transfer_exceptions_into_jvms();
 182   }
 183   kit.set_edges_for_java_call(call, false, _separate_io_proj);
 184   Node* ret = kit.set_results_for_java_call(call, _separate_io_proj);
 185   kit.push_node(method()-&gt;return_type()-&gt;basic_type(), ret);
 186   return kit.transfer_exceptions_into_jvms();
 187 }
 188 
 189 //--------------------------VirtualCallGenerator------------------------------
 190 // Internal class which handles all out-of-line calls checking receiver type.
 191 class VirtualCallGenerator : public CallGenerator {
 192 private:
 193   int _vtable_index;
 194 public:
 195   VirtualCallGenerator(ciMethod* method, int vtable_index)
 196     : CallGenerator(method), _vtable_index(vtable_index)
 197   {
 198     assert(vtable_index == Method::invalid_vtable_index ||
 199            vtable_index &gt;= 0, &quot;either invalid or usable&quot;);
 200   }
 201   virtual bool      is_virtual() const          { return true; }
 202   virtual JVMState* generate(JVMState* jvms);
 203 };
 204 
 205 JVMState* VirtualCallGenerator::generate(JVMState* jvms) {
 206   GraphKit kit(jvms);
 207   Node* receiver = kit.argument(0);
 208   kit.C-&gt;print_inlining_update(this);
 209 
 210   if (kit.C-&gt;log() != NULL) {
 211     kit.C-&gt;log()-&gt;elem(&quot;virtual_call bci=&#39;%d&#39;&quot;, jvms-&gt;bci());
 212   }
 213 
 214   // If the receiver is a constant null, do not torture the system
 215   // by attempting to call through it.  The compile will proceed
 216   // correctly, but may bail out in final_graph_reshaping, because
 217   // the call instruction will have a seemingly deficient out-count.
 218   // (The bailout says something misleading about an &quot;infinite loop&quot;.)
 219   if (!receiver-&gt;is_InlineType() &amp;&amp; kit.gvn().type(receiver)-&gt;higher_equal(TypePtr::NULL_PTR)) {
 220     assert(Bytecodes::is_invoke(kit.java_bc()), &quot;%d: %s&quot;, kit.java_bc(), Bytecodes::name(kit.java_bc()));
 221     ciMethod* declared_method = kit.method()-&gt;get_method_at_bci(kit.bci());
 222     int arg_size = declared_method-&gt;signature()-&gt;arg_size_for_bc(kit.java_bc());
 223     kit.inc_sp(arg_size);  // restore arguments
 224     kit.uncommon_trap(Deoptimization::Reason_null_check,
 225                       Deoptimization::Action_none,
 226                       NULL, &quot;null receiver&quot;);
 227     return kit.transfer_exceptions_into_jvms();
 228   }
 229 
 230   // Ideally we would unconditionally do a null check here and let it
 231   // be converted to an implicit check based on profile information.
 232   // However currently the conversion to implicit null checks in
 233   // Block::implicit_null_check() only looks for loads and stores, not calls.
 234   ciMethod *caller = kit.method();
 235   ciMethodData *caller_md = (caller == NULL) ? NULL : caller-&gt;method_data();
 236   if (!UseInlineCaches || !ImplicitNullChecks || !os::zero_page_read_protected() ||
 237        ((ImplicitNullCheckThreshold &gt; 0) &amp;&amp; caller_md &amp;&amp;
 238        (caller_md-&gt;trap_count(Deoptimization::Reason_null_check)
 239        &gt;= (uint)ImplicitNullCheckThreshold))) {
 240     // Make an explicit receiver null_check as part of this call.
 241     // Since we share a map with the caller, his JVMS gets adjusted.
 242     receiver = kit.null_check_receiver_before_call(method());
 243     if (kit.stopped()) {
 244       // And dump it back to the caller, decorated with any exceptions:
 245       return kit.transfer_exceptions_into_jvms();
 246     }
 247   }
 248 
 249   assert(!method()-&gt;is_static(), &quot;virtual call must not be to static&quot;);
 250   assert(!method()-&gt;is_final(), &quot;virtual call should not be to final&quot;);
 251   assert(!method()-&gt;is_private(), &quot;virtual call should not be to private&quot;);
 252   assert(_vtable_index == Method::invalid_vtable_index || !UseInlineCaches,
 253          &quot;no vtable calls if +UseInlineCaches &quot;);
 254   address target = SharedRuntime::get_resolve_virtual_call_stub();
 255   // Normal inline cache used for call
 256   CallDynamicJavaNode *call = new CallDynamicJavaNode(tf(), target, method(), _vtable_index, kit.bci());
 257   if (is_inlined_method_handle_intrinsic(jvms, method())) {
 258     // To be able to issue a direct call (optimized virtual or virtual)
 259     // and skip a call to MH.linkTo*/invokeBasic adapter, additional information
 260     // about the method being invoked should be attached to the call site to
 261     // make resolution logic work (see SharedRuntime::resolve_{virtual,opt_virtual}_call_C).
 262     call-&gt;set_override_symbolic_info(true);
 263   }
 264   kit.set_arguments_for_java_call(call);
 265   if (kit.stopped()) {
 266     return kit.transfer_exceptions_into_jvms();
 267   }
 268   kit.set_edges_for_java_call(call);
 269   Node* ret = kit.set_results_for_java_call(call);
 270   kit.push_node(method()-&gt;return_type()-&gt;basic_type(), ret);
 271 
 272   // Represent the effect of an implicit receiver null_check
 273   // as part of this call.  Since we share a map with the caller,
 274   // his JVMS gets adjusted.
 275   kit.cast_not_null(receiver);
 276   return kit.transfer_exceptions_into_jvms();
 277 }
 278 
 279 CallGenerator* CallGenerator::for_inline(ciMethod* m, float expected_uses) {
 280   if (InlineTree::check_can_parse(m) != NULL)  return NULL;
 281   return new ParseGenerator(m, expected_uses);
 282 }
 283 
 284 // As a special case, the JVMS passed to this CallGenerator is
 285 // for the method execution already in progress, not just the JVMS
 286 // of the caller.  Thus, this CallGenerator cannot be mixed with others!
 287 CallGenerator* CallGenerator::for_osr(ciMethod* m, int osr_bci) {
 288   if (InlineTree::check_can_parse(m) != NULL)  return NULL;
 289   float past_uses = m-&gt;interpreter_invocation_count();
 290   float expected_uses = past_uses;
 291   return new ParseGenerator(m, expected_uses, true);
 292 }
 293 
 294 CallGenerator* CallGenerator::for_direct_call(ciMethod* m, bool separate_io_proj) {
 295   assert(!m-&gt;is_abstract(), &quot;for_direct_call mismatch&quot;);
 296   return new DirectCallGenerator(m, separate_io_proj);
 297 }
 298 
 299 CallGenerator* CallGenerator::for_virtual_call(ciMethod* m, int vtable_index) {
 300   assert(!m-&gt;is_static(), &quot;for_virtual_call mismatch&quot;);
 301   assert(!m-&gt;is_method_handle_intrinsic(), &quot;should be a direct call&quot;);
 302   return new VirtualCallGenerator(m, vtable_index);
 303 }
 304 
 305 // Allow inlining decisions to be delayed
 306 class LateInlineCallGenerator : public DirectCallGenerator {
 307  private:
 308   jlong _unique_id;   // unique id for log compilation
 309   bool _is_pure_call; // a hint that the call doesn&#39;t have important side effects to care about
 310 
 311  protected:
 312   CallGenerator* _inline_cg;
 313   virtual bool do_late_inline_check(JVMState* jvms) { return true; }
 314 
 315  public:
 316   LateInlineCallGenerator(ciMethod* method, CallGenerator* inline_cg, bool is_pure_call = false) :
 317     DirectCallGenerator(method, true), _unique_id(0), _is_pure_call(is_pure_call), _inline_cg(inline_cg) {}
 318 
 319   virtual bool is_late_inline() const { return true; }
 320 
 321   // Convert the CallStaticJava into an inline
 322   virtual void do_late_inline();
 323 
 324   virtual JVMState* generate(JVMState* jvms) {
 325     Compile *C = Compile::current();
 326 
 327     C-&gt;log_inline_id(this);
 328 
 329     // Record that this call site should be revisited once the main
 330     // parse is finished.
 331     if (!is_mh_late_inline()) {
 332       C-&gt;add_late_inline(this);
 333     }
 334 
 335     // Emit the CallStaticJava and request separate projections so
 336     // that the late inlining logic can distinguish between fall
 337     // through and exceptional uses of the memory and io projections
 338     // as is done for allocations and macro expansion.
 339     return DirectCallGenerator::generate(jvms);
 340   }
 341 
 342   virtual void print_inlining_late(const char* msg) {
 343     CallNode* call = call_node();
 344     Compile* C = Compile::current();
 345     C-&gt;print_inlining_assert_ready();
 346     C-&gt;print_inlining(method(), call-&gt;jvms()-&gt;depth()-1, call-&gt;jvms()-&gt;bci(), msg);
 347     C-&gt;print_inlining_move_to(this);
 348     C-&gt;print_inlining_update_delayed(this);
 349   }
 350 
 351   virtual void set_unique_id(jlong id) {
 352     _unique_id = id;
 353   }
 354 
 355   virtual jlong unique_id() const {
 356     return _unique_id;
 357   }
 358 
 359   virtual CallGenerator* inline_cg() {
 360     return _inline_cg;
 361   }
 362 };
 363 
 364 void LateInlineCallGenerator::do_late_inline() {
 365   // Can&#39;t inline it
 366   CallStaticJavaNode* call = call_node();
 367   if (call == NULL || call-&gt;outcnt() == 0 ||
 368       call-&gt;in(0) == NULL || call-&gt;in(0)-&gt;is_top()) {
 369     return;
 370   }
 371 
 372   const GrowableArray&lt;SigEntry&gt;* sig_cc = method()-&gt;get_sig_cc();
 373   const TypeTuple* r = call-&gt;tf()-&gt;domain_cc();
 374   for (uint i1 = TypeFunc::Parms, i2 = 0; i1 &lt; r-&gt;cnt(); i1++) {
 375     if (sig_cc != NULL) {
 376       // Skip reserved entries
 377       while (!SigEntry::skip_value_delimiters(sig_cc, i2)) {
 378         i2++;
 379       }
 380       if (SigEntry::is_reserved_entry(sig_cc, i2++)) {
 381         assert(call-&gt;in(i1)-&gt;is_top(), &quot;should be top&quot;);
 382         continue;
 383       }
 384     }
 385     if (call-&gt;in(i1)-&gt;is_top() &amp;&amp; r-&gt;field_at(i1) != Type::HALF) {
 386       assert(Compile::current()-&gt;inlining_incrementally(), &quot;shouldn&#39;t happen during parsing&quot;);
 387       return;
 388     }
 389   }
 390 
 391   if (call-&gt;in(TypeFunc::Memory)-&gt;is_top()) {
 392     assert(Compile::current()-&gt;inlining_incrementally(), &quot;shouldn&#39;t happen during parsing&quot;);
 393     return;
 394   }
 395 
 396   // check for unreachable loop
 397   CallProjections* callprojs = call-&gt;extract_projections(true);
 398   if (callprojs-&gt;fallthrough_catchproj == call-&gt;in(0) ||
 399       callprojs-&gt;catchall_catchproj == call-&gt;in(0) ||
 400       callprojs-&gt;fallthrough_memproj == call-&gt;in(TypeFunc::Memory) ||
 401       callprojs-&gt;catchall_memproj == call-&gt;in(TypeFunc::Memory) ||
 402       callprojs-&gt;fallthrough_ioproj == call-&gt;in(TypeFunc::I_O) ||
 403       callprojs-&gt;catchall_ioproj == call-&gt;in(TypeFunc::I_O) ||
 404       (callprojs-&gt;exobj != NULL &amp;&amp; call-&gt;find_edge(callprojs-&gt;exobj) != -1)) {
 405     return;
 406   }
 407   bool result_not_used = true;
 408   for (uint i = 0; i &lt; callprojs-&gt;nb_resproj; i++) {
 409     if (callprojs-&gt;resproj[i] != NULL) {
 410       if (callprojs-&gt;resproj[i]-&gt;outcnt() != 0) {
 411         result_not_used = false;
 412       }
 413       if (call-&gt;find_edge(callprojs-&gt;resproj[i]) != -1) {
 414         return;
 415       }
 416     }
 417   }
 418 
 419   Compile* C = Compile::current();
 420   // Remove inlined methods from Compiler&#39;s lists.
 421   if (call-&gt;is_macro()) {
 422     C-&gt;remove_macro_node(call);
 423   }
 424 
 425   if (_is_pure_call &amp;&amp; result_not_used) {
 426     // The call is marked as pure (no important side effects), but result isn&#39;t used.
 427     // It&#39;s safe to remove the call.
 428     GraphKit kit(call-&gt;jvms());
 429     kit.replace_call(call, C-&gt;top(), true);
 430   } else {
 431     // Make a clone of the JVMState that appropriate to use for driving a parse
 432     JVMState* old_jvms = call-&gt;jvms();
 433     JVMState* jvms = old_jvms-&gt;clone_shallow(C);
 434     uint size = call-&gt;req();
 435     SafePointNode* map = new SafePointNode(size, jvms);
 436     for (uint i1 = 0; i1 &lt; size; i1++) {
 437       map-&gt;init_req(i1, call-&gt;in(i1));
 438     }
 439 
 440     PhaseGVN&amp; gvn = *C-&gt;initial_gvn();
 441     // Make sure the state is a MergeMem for parsing.
 442     if (!map-&gt;in(TypeFunc::Memory)-&gt;is_MergeMem()) {
 443       Node* mem = MergeMemNode::make(map-&gt;in(TypeFunc::Memory));
 444       gvn.set_type_bottom(mem);
 445       map-&gt;set_req(TypeFunc::Memory, mem);
 446     }
 447 
 448     // blow away old call arguments
 449     for (uint i1 = TypeFunc::Parms; i1 &lt; r-&gt;cnt(); i1++) {
 450       map-&gt;set_req(i1, C-&gt;top());
 451     }
 452     jvms-&gt;set_map(map);
 453 
 454     // Make enough space in the expression stack to transfer
 455     // the incoming arguments and return value.
 456     map-&gt;ensure_stack(jvms, jvms-&gt;method()-&gt;max_stack());
 457     const TypeTuple *domain_sig = call-&gt;_tf-&gt;domain_sig();
 458     ExtendedSignature sig_cc = ExtendedSignature(method()-&gt;get_sig_cc(), SigEntryFilter());
 459     uint nargs = method()-&gt;arg_size();
 460     assert(domain_sig-&gt;cnt() - TypeFunc::Parms == nargs, &quot;inconsistent signature&quot;);
 461 
 462     uint j = TypeFunc::Parms;
 463     for (uint i1 = 0; i1 &lt; nargs; i1++) {
 464       const Type* t = domain_sig-&gt;field_at(TypeFunc::Parms + i1);
 465       if (method()-&gt;has_scalarized_args() &amp;&amp; t-&gt;is_inlinetypeptr() &amp;&amp; !t-&gt;maybe_null()) {
 466         // Inline type arguments are not passed by reference: we get an argument per
 467         // field of the inline type. Build InlineTypeNodes from the inline type arguments.
 468         GraphKit arg_kit(jvms, &amp;gvn);
 469         InlineTypeNode* vt = InlineTypeNode::make_from_multi(&amp;arg_kit, call, sig_cc, t-&gt;inline_klass(), j, true);
 470         map-&gt;set_control(arg_kit.control());
 471         map-&gt;set_argument(jvms, i1, vt);
 472       } else {
 473         map-&gt;set_argument(jvms, i1, call-&gt;in(j++));
 474         BasicType bt = t-&gt;basic_type();
 475         while (SigEntry::next_is_reserved(sig_cc, bt, true)) {
 476           j += type2size[bt]; // Skip reserved arguments
 477         }
 478       }
 479     }
 480 
 481     C-&gt;print_inlining_assert_ready();
 482 
 483     C-&gt;print_inlining_move_to(this);
 484 
 485     C-&gt;log_late_inline(this);
 486 
 487     // This check is done here because for_method_handle_inline() method
 488     // needs jvms for inlined state.
 489     if (!do_late_inline_check(jvms)) {
 490       map-&gt;disconnect_inputs(NULL, C);
 491       return;
 492     }
 493 
 494     // Allocate a buffer for the returned InlineTypeNode because the caller expects an oop return.
 495     // Do this before the method handle call in case the buffer allocation triggers deoptimization.
 496     Node* buffer_oop = NULL;
 497     if (is_mh_late_inline() &amp;&amp; _inline_cg-&gt;method()-&gt;return_type()-&gt;is_inlinetype()) {
 498       GraphKit arg_kit(jvms, &amp;gvn);
 499       {
 500         PreserveReexecuteState preexecs(&amp;arg_kit);
 501         arg_kit.jvms()-&gt;set_should_reexecute(true);
 502         arg_kit.inc_sp(nargs);
 503         Node* klass_node = arg_kit.makecon(TypeKlassPtr::make(_inline_cg-&gt;method()-&gt;return_type()-&gt;as_inline_klass()));
 504         buffer_oop = arg_kit.new_instance(klass_node, NULL, NULL, /* deoptimize_on_exception */ true);
 505       }
 506       jvms = arg_kit.transfer_exceptions_into_jvms();
 507     }
 508 
 509     // Setup default node notes to be picked up by the inlining
 510     Node_Notes* old_nn = C-&gt;node_notes_at(call-&gt;_idx);
 511     if (old_nn != NULL) {
 512       Node_Notes* entry_nn = old_nn-&gt;clone(C);
 513       entry_nn-&gt;set_jvms(jvms);
 514       C-&gt;set_default_node_notes(entry_nn);
 515     }
 516 
 517     // Now perform the inlining using the synthesized JVMState
 518     JVMState* new_jvms = _inline_cg-&gt;generate(jvms);
 519     if (new_jvms == NULL)  return;  // no change
 520     if (C-&gt;failing())      return;
 521 
 522     // Capture any exceptional control flow
 523     GraphKit kit(new_jvms);
 524 
 525     // Find the result object
 526     Node* result = C-&gt;top();
 527     int   result_size = method()-&gt;return_type()-&gt;size();
 528     if (result_size != 0 &amp;&amp; !kit.stopped()) {
 529       result = (result_size == 1) ? kit.pop() : kit.pop_pair();
 530     }
 531 
 532     C-&gt;set_has_loops(C-&gt;has_loops() || _inline_cg-&gt;method()-&gt;has_loops());
 533     C-&gt;env()-&gt;notice_inlined_method(_inline_cg-&gt;method());
 534     C-&gt;set_inlining_progress(true);
 535     C-&gt;set_do_cleanup(kit.stopped()); // path is dead; needs cleanup
 536 
 537     // Handle inline type returns
 538     bool returned_as_fields = call-&gt;tf()-&gt;returns_inline_type_as_fields();
 539     if (result-&gt;is_InlineType()) {
 540       // Only possible if is_mh_late_inline() when the callee does not &quot;know&quot; that the caller expects an oop
 541       assert(is_mh_late_inline() &amp;&amp; !returned_as_fields, &quot;sanity&quot;);
 542       assert(buffer_oop != NULL, &quot;should have allocated a buffer&quot;);
 543       InlineTypeNode* vt = result-&gt;as_InlineType();
 544       vt-&gt;store(&amp;kit, buffer_oop, buffer_oop, vt-&gt;type()-&gt;inline_klass(), 0);
 545       // Do not let stores that initialize this buffer be reordered with a subsequent
 546       // store that would make this buffer accessible by other threads.
 547       AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer_oop, &amp;kit.gvn());
 548       assert(alloc != NULL, &quot;must have an allocation node&quot;);
 549       kit.insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
 550       result = buffer_oop;
 551     } else if (result-&gt;is_InlineTypePtr() &amp;&amp; returned_as_fields) {
 552       result-&gt;as_InlineTypePtr()-&gt;replace_call_results(&amp;kit, call, C);
 553     }
 554 
 555     kit.replace_call(call, result, true);
 556   }
 557 }
 558 
 559 
 560 CallGenerator* CallGenerator::for_late_inline(ciMethod* method, CallGenerator* inline_cg) {
 561   return new LateInlineCallGenerator(method, inline_cg);
 562 }
 563 
 564 class LateInlineMHCallGenerator : public LateInlineCallGenerator {
 565   ciMethod* _caller;
 566   int _attempt;
 567   bool _input_not_const;
 568 
 569   virtual bool do_late_inline_check(JVMState* jvms);
 570   virtual bool already_attempted() const { return _attempt &gt; 0; }
 571 
 572  public:
 573   LateInlineMHCallGenerator(ciMethod* caller, ciMethod* callee, bool input_not_const) :
 574     LateInlineCallGenerator(callee, NULL), _caller(caller), _attempt(0), _input_not_const(input_not_const) {}
 575 
 576   virtual bool is_mh_late_inline() const { return true; }
 577 
 578   virtual JVMState* generate(JVMState* jvms) {
 579     JVMState* new_jvms = LateInlineCallGenerator::generate(jvms);
 580 
 581     Compile* C = Compile::current();
 582     if (_input_not_const) {
 583       // inlining won&#39;t be possible so no need to enqueue right now.
 584       call_node()-&gt;set_generator(this);
 585     } else {
 586       C-&gt;add_late_inline(this);
 587     }
 588     return new_jvms;
 589   }
 590 };
 591 
 592 bool LateInlineMHCallGenerator::do_late_inline_check(JVMState* jvms) {
 593 
 594   CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), _input_not_const);
 595 
 596   // AlwaysIncrementalInline causes for_method_handle_inline() to
 597   // return a LateInlineCallGenerator. Extract the
 598   // InlineCallGenerato from it.
 599   if (AlwaysIncrementalInline &amp;&amp; cg != NULL &amp;&amp; cg-&gt;is_late_inline()) {
 600     cg = cg-&gt;inline_cg();
 601   }
 602 
 603   Compile::current()-&gt;print_inlining_update_delayed(this);
 604 
 605   if (!_input_not_const) {
 606     _attempt++;
 607   }
 608 
 609   if (cg != NULL &amp;&amp; (cg-&gt;is_inline() || cg-&gt;is_inlined_method_handle_intrinsic(jvms, cg-&gt;method()))) {
 610     assert(!cg-&gt;is_late_inline(), &quot;we&#39;re doing late inlining&quot;);
 611     _inline_cg = cg;
 612     Compile::current()-&gt;dec_number_of_mh_late_inlines();
 613     return true;
 614   }
 615 
 616   call_node()-&gt;set_generator(this);
 617   return false;
 618 }
 619 
 620 CallGenerator* CallGenerator::for_mh_late_inline(ciMethod* caller, ciMethod* callee, bool input_not_const) {
 621   Compile::current()-&gt;inc_number_of_mh_late_inlines();
 622   CallGenerator* cg = new LateInlineMHCallGenerator(caller, callee, input_not_const);
 623   return cg;
 624 }
 625 
 626 class LateInlineStringCallGenerator : public LateInlineCallGenerator {
 627 
 628  public:
 629   LateInlineStringCallGenerator(ciMethod* method, CallGenerator* inline_cg) :
 630     LateInlineCallGenerator(method, inline_cg) {}
 631 
 632   virtual JVMState* generate(JVMState* jvms) {
 633     Compile *C = Compile::current();
 634 
 635     C-&gt;log_inline_id(this);
 636 
 637     C-&gt;add_string_late_inline(this);
 638 
 639     JVMState* new_jvms =  DirectCallGenerator::generate(jvms);
 640     return new_jvms;
 641   }
 642 
 643   virtual bool is_string_late_inline() const { return true; }
 644 };
 645 
 646 CallGenerator* CallGenerator::for_string_late_inline(ciMethod* method, CallGenerator* inline_cg) {
 647   return new LateInlineStringCallGenerator(method, inline_cg);
 648 }
 649 
 650 class LateInlineBoxingCallGenerator : public LateInlineCallGenerator {
 651 
 652  public:
 653   LateInlineBoxingCallGenerator(ciMethod* method, CallGenerator* inline_cg) :
 654     LateInlineCallGenerator(method, inline_cg, /*is_pure=*/true) {}
 655 
 656   virtual JVMState* generate(JVMState* jvms) {
 657     Compile *C = Compile::current();
 658 
 659     C-&gt;log_inline_id(this);
 660 
 661     C-&gt;add_boxing_late_inline(this);
 662 
 663     JVMState* new_jvms =  DirectCallGenerator::generate(jvms);
 664     return new_jvms;
 665   }
 666 };
 667 
 668 CallGenerator* CallGenerator::for_boxing_late_inline(ciMethod* method, CallGenerator* inline_cg) {
 669   return new LateInlineBoxingCallGenerator(method, inline_cg);
 670 }
 671 
 672 //---------------------------WarmCallGenerator--------------------------------
 673 // Internal class which handles initial deferral of inlining decisions.
 674 class WarmCallGenerator : public CallGenerator {
 675   WarmCallInfo*   _call_info;
 676   CallGenerator*  _if_cold;
 677   CallGenerator*  _if_hot;
 678   bool            _is_virtual;   // caches virtuality of if_cold
 679   bool            _is_inline;    // caches inline-ness of if_hot
 680 
 681 public:
 682   WarmCallGenerator(WarmCallInfo* ci,
 683                     CallGenerator* if_cold,
 684                     CallGenerator* if_hot)
 685     : CallGenerator(if_cold-&gt;method())
 686   {
 687     assert(method() == if_hot-&gt;method(), &quot;consistent choices&quot;);
 688     _call_info  = ci;
 689     _if_cold    = if_cold;
 690     _if_hot     = if_hot;
 691     _is_virtual = if_cold-&gt;is_virtual();
 692     _is_inline  = if_hot-&gt;is_inline();
 693   }
 694 
 695   virtual bool      is_inline() const           { return _is_inline; }
 696   virtual bool      is_virtual() const          { return _is_virtual; }
 697   virtual bool      is_deferred() const         { return true; }
 698 
 699   virtual JVMState* generate(JVMState* jvms);
 700 };
 701 
 702 
 703 CallGenerator* CallGenerator::for_warm_call(WarmCallInfo* ci,
 704                                             CallGenerator* if_cold,
 705                                             CallGenerator* if_hot) {
 706   return new WarmCallGenerator(ci, if_cold, if_hot);
 707 }
 708 
 709 JVMState* WarmCallGenerator::generate(JVMState* jvms) {
 710   Compile* C = Compile::current();
 711   C-&gt;print_inlining_update(this);
 712 
 713   if (C-&gt;log() != NULL) {
 714     C-&gt;log()-&gt;elem(&quot;warm_call bci=&#39;%d&#39;&quot;, jvms-&gt;bci());
 715   }
 716   jvms = _if_cold-&gt;generate(jvms);
 717   if (jvms != NULL) {
 718     Node* m = jvms-&gt;map()-&gt;control();
 719     if (m-&gt;is_CatchProj()) m = m-&gt;in(0);  else m = C-&gt;top();
 720     if (m-&gt;is_Catch())     m = m-&gt;in(0);  else m = C-&gt;top();
 721     if (m-&gt;is_Proj())      m = m-&gt;in(0);  else m = C-&gt;top();
 722     if (m-&gt;is_CallJava()) {
 723       _call_info-&gt;set_call(m-&gt;as_Call());
 724       _call_info-&gt;set_hot_cg(_if_hot);
 725 #ifndef PRODUCT
 726       if (PrintOpto || PrintOptoInlining) {
 727         tty-&gt;print_cr(&quot;Queueing for warm inlining at bci %d:&quot;, jvms-&gt;bci());
 728         tty-&gt;print(&quot;WCI: &quot;);
 729         _call_info-&gt;print();
 730       }
 731 #endif
 732       _call_info-&gt;set_heat(_call_info-&gt;compute_heat());
 733       C-&gt;set_warm_calls(_call_info-&gt;insert_into(C-&gt;warm_calls()));
 734     }
 735   }
 736   return jvms;
 737 }
 738 
 739 void WarmCallInfo::make_hot() {
 740   Unimplemented();
 741 }
 742 
 743 void WarmCallInfo::make_cold() {
 744   // No action:  Just dequeue.
 745 }
 746 
 747 
 748 //------------------------PredictedCallGenerator------------------------------
 749 // Internal class which handles all out-of-line calls checking receiver type.
 750 class PredictedCallGenerator : public CallGenerator {
 751   ciKlass*       _predicted_receiver;
 752   CallGenerator* _if_missed;
 753   CallGenerator* _if_hit;
 754   float          _hit_prob;
 755   bool           _exact_check;
 756 
 757 public:
 758   PredictedCallGenerator(ciKlass* predicted_receiver,
 759                          CallGenerator* if_missed,
 760                          CallGenerator* if_hit, bool exact_check,
 761                          float hit_prob)
 762     : CallGenerator(if_missed-&gt;method())
 763   {
 764     // The call profile data may predict the hit_prob as extreme as 0 or 1.
 765     // Remove the extremes values from the range.
 766     if (hit_prob &gt; PROB_MAX)   hit_prob = PROB_MAX;
 767     if (hit_prob &lt; PROB_MIN)   hit_prob = PROB_MIN;
 768 
 769     _predicted_receiver = predicted_receiver;
 770     _if_missed          = if_missed;
 771     _if_hit             = if_hit;
 772     _hit_prob           = hit_prob;
 773     _exact_check        = exact_check;
 774   }
 775 
 776   virtual bool      is_virtual()   const    { return true; }
 777   virtual bool      is_inline()    const    { return _if_hit-&gt;is_inline(); }
 778   virtual bool      is_deferred()  const    { return _if_hit-&gt;is_deferred(); }
 779 
 780   virtual JVMState* generate(JVMState* jvms);
 781 };
 782 
 783 
 784 CallGenerator* CallGenerator::for_predicted_call(ciKlass* predicted_receiver,
 785                                                  CallGenerator* if_missed,
 786                                                  CallGenerator* if_hit,
 787                                                  float hit_prob) {
 788   return new PredictedCallGenerator(predicted_receiver, if_missed, if_hit,
 789                                     /*exact_check=*/true, hit_prob);
 790 }
 791 
 792 CallGenerator* CallGenerator::for_guarded_call(ciKlass* guarded_receiver,
 793                                                CallGenerator* if_missed,
 794                                                CallGenerator* if_hit) {
 795   return new PredictedCallGenerator(guarded_receiver, if_missed, if_hit,
 796                                     /*exact_check=*/false, PROB_ALWAYS);
 797 }
 798 
 799 JVMState* PredictedCallGenerator::generate(JVMState* jvms) {
 800   GraphKit kit(jvms);
 801   kit.C-&gt;print_inlining_update(this);
 802   PhaseGVN&amp; gvn = kit.gvn();
 803   // We need an explicit receiver null_check before checking its type.
 804   // We share a map with the caller, so his JVMS gets adjusted.
 805   Node* receiver = kit.argument(0);
 806   CompileLog* log = kit.C-&gt;log();
 807   if (log != NULL) {
 808     log-&gt;elem(&quot;predicted_call bci=&#39;%d&#39; exact=&#39;%d&#39; klass=&#39;%d&#39;&quot;,
 809               jvms-&gt;bci(), (_exact_check ? 1 : 0), log-&gt;identify(_predicted_receiver));
 810   }
 811 
 812   receiver = kit.null_check_receiver_before_call(method());
 813   if (kit.stopped()) {
 814     return kit.transfer_exceptions_into_jvms();
 815   }
 816 
 817   // Make a copy of the replaced nodes in case we need to restore them
 818   ReplacedNodes replaced_nodes = kit.map()-&gt;replaced_nodes();
 819   replaced_nodes.clone();
 820 
 821   Node* casted_receiver = receiver;  // will get updated in place...
 822   Node* slow_ctl = NULL;
 823   if (_exact_check) {
 824     slow_ctl = kit.type_check_receiver(receiver, _predicted_receiver, _hit_prob,
 825                                        &amp;casted_receiver);
 826   } else {
 827     slow_ctl = kit.subtype_check_receiver(receiver, _predicted_receiver,
 828                                           &amp;casted_receiver);
 829   }
 830 
 831   SafePointNode* slow_map = NULL;
 832   JVMState* slow_jvms = NULL;
 833   { PreserveJVMState pjvms(&amp;kit);
 834     kit.set_control(slow_ctl);
 835     if (!kit.stopped()) {
 836       slow_jvms = _if_missed-&gt;generate(kit.sync_jvms());
 837       if (kit.failing())
 838         return NULL;  // might happen because of NodeCountInliningCutoff
 839       assert(slow_jvms != NULL, &quot;must be&quot;);
 840       kit.add_exception_states_from(slow_jvms);
 841       kit.set_map(slow_jvms-&gt;map());
 842       if (!kit.stopped())
 843         slow_map = kit.stop();
 844     }
 845   }
 846 
 847   if (kit.stopped()) {
 848     // Instance exactly does not matches the desired type.
 849     kit.set_jvms(slow_jvms);
 850     return kit.transfer_exceptions_into_jvms();
 851   }
 852 
 853   // fall through if the instance exactly matches the desired type
 854   kit.replace_in_map(receiver, casted_receiver);
 855 
 856   // Make the hot call:
 857   JVMState* new_jvms = _if_hit-&gt;generate(kit.sync_jvms());
 858   if (new_jvms == NULL) {
 859     // Inline failed, so make a direct call.
 860     assert(_if_hit-&gt;is_inline(), &quot;must have been a failed inline&quot;);
 861     CallGenerator* cg = CallGenerator::for_direct_call(_if_hit-&gt;method());
 862     new_jvms = cg-&gt;generate(kit.sync_jvms());
 863   }
 864   kit.add_exception_states_from(new_jvms);
 865   kit.set_jvms(new_jvms);
 866 
 867   // Need to merge slow and fast?
 868   if (slow_map == NULL) {
 869     // The fast path is the only path remaining.
 870     return kit.transfer_exceptions_into_jvms();
 871   }
 872 
 873   if (kit.stopped()) {
 874     // Inlined method threw an exception, so it&#39;s just the slow path after all.
 875     kit.set_jvms(slow_jvms);
 876     return kit.transfer_exceptions_into_jvms();
 877   }
 878 
 879   // Allocate inline types if they are merged with objects (similar to Parse::merge_common())
 880   uint tos = kit.jvms()-&gt;stkoff() + kit.sp();
 881   uint limit = slow_map-&gt;req();
 882   for (uint i = TypeFunc::Parms; i &lt; limit; i++) {
 883     Node* m = kit.map()-&gt;in(i);
 884     Node* n = slow_map-&gt;in(i);
 885     const Type* t = gvn.type(m)-&gt;meet_speculative(gvn.type(n));
 886     if (m-&gt;is_InlineType() &amp;&amp; !t-&gt;isa_inlinetype()) {
 887       // Allocate inline type in fast path
 888       m = m-&gt;as_InlineType()-&gt;buffer(&amp;kit);
 889       kit.map()-&gt;set_req(i, m);
 890     }
 891     if (n-&gt;is_InlineType() &amp;&amp; !t-&gt;isa_inlinetype()) {
 892       // Allocate inline type in slow path
 893       PreserveJVMState pjvms(&amp;kit);
 894       kit.set_map(slow_map);
 895       n = n-&gt;as_InlineType()-&gt;buffer(&amp;kit);
 896       kit.map()-&gt;set_req(i, n);
 897       slow_map = kit.stop();
 898     }
 899   }
 900 
 901   // There are 2 branches and the replaced nodes are only valid on
 902   // one: restore the replaced nodes to what they were before the
 903   // branch.
 904   kit.map()-&gt;set_replaced_nodes(replaced_nodes);
 905 
 906   // Finish the diamond.
 907   kit.C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
 908   RegionNode* region = new RegionNode(3);
 909   region-&gt;init_req(1, kit.control());
 910   region-&gt;init_req(2, slow_map-&gt;control());
 911   kit.set_control(gvn.transform(region));
 912   Node* iophi = PhiNode::make(region, kit.i_o(), Type::ABIO);
 913   iophi-&gt;set_req(2, slow_map-&gt;i_o());
 914   kit.set_i_o(gvn.transform(iophi));
 915   // Merge memory
 916   kit.merge_memory(slow_map-&gt;merged_memory(), region, 2);
 917   // Transform new memory Phis.
 918   for (MergeMemStream mms(kit.merged_memory()); mms.next_non_empty();) {
 919     Node* phi = mms.memory();
 920     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == region) {
 921       mms.set_memory(gvn.transform(phi));
 922     }
 923   }
 924   for (uint i = TypeFunc::Parms; i &lt; limit; i++) {
 925     // Skip unused stack slots; fast forward to monoff();
 926     if (i == tos) {
 927       i = kit.jvms()-&gt;monoff();
 928       if( i &gt;= limit ) break;
 929     }
 930     Node* m = kit.map()-&gt;in(i);
 931     Node* n = slow_map-&gt;in(i);
 932     if (m != n) {
 933       const Type* t = gvn.type(m)-&gt;meet_speculative(gvn.type(n));
 934       Node* phi = PhiNode::make(region, m, t);
 935       phi-&gt;set_req(2, n);
 936       kit.map()-&gt;set_req(i, gvn.transform(phi));
 937     }
 938   }
 939   return kit.transfer_exceptions_into_jvms();
 940 }
 941 
 942 
 943 CallGenerator* CallGenerator::for_method_handle_call(JVMState* jvms, ciMethod* caller, ciMethod* callee) {
 944   assert(callee-&gt;is_method_handle_intrinsic(), &quot;for_method_handle_call mismatch&quot;);
 945   bool input_not_const;
 946   CallGenerator* cg = CallGenerator::for_method_handle_inline(jvms, caller, callee, input_not_const);
 947   Compile* C = Compile::current();
 948   if (cg != NULL) {
 949     if (AlwaysIncrementalInline) {
 950       return CallGenerator::for_late_inline(callee, cg);
 951     } else {
 952       return cg;
 953     }
 954   }
 955   int bci = jvms-&gt;bci();
 956   ciCallProfile profile = caller-&gt;call_profile_at_bci(bci);
 957   int call_site_count = caller-&gt;scale_count(profile.count());
 958 
 959   if (IncrementalInline &amp;&amp; (AlwaysIncrementalInline ||
 960                             (call_site_count &gt; 0 &amp;&amp; (input_not_const || !C-&gt;inlining_incrementally() || C-&gt;over_inlining_cutoff())))) {
 961     return CallGenerator::for_mh_late_inline(caller, callee, input_not_const);
 962   } else {
 963     // Out-of-line call.
 964     return CallGenerator::for_direct_call(callee);
 965   }
 966 }
 967 
 968 static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit&amp; kit) {
 969   PhaseGVN&amp; gvn = kit.gvn();
 970   Node* arg = kit.argument(arg_nb);
 971   const Type* arg_type = arg-&gt;bottom_type();
 972   const Type* sig_type = TypeOopPtr::make_from_klass(t-&gt;as_klass());
 973   if (arg_type-&gt;isa_oopptr() &amp;&amp; !arg_type-&gt;higher_equal(sig_type)) {
 974     const Type* narrowed_arg_type = arg_type-&gt;join_speculative(sig_type); // keep speculative part
 975     arg = gvn.transform(new CheckCastPPNode(kit.control(), arg, narrowed_arg_type));
 976     kit.set_argument(arg_nb, arg);
 977   }
 978   if (sig_type-&gt;is_inlinetypeptr() &amp;&amp; !arg-&gt;is_InlineType() &amp;&amp;
 979       !kit.gvn().type(arg)-&gt;maybe_null() &amp;&amp; t-&gt;as_inline_klass()-&gt;is_scalarizable()) {
 980     arg = InlineTypeNode::make_from_oop(&amp;kit, arg, t-&gt;as_inline_klass());
 981     kit.set_argument(arg_nb, arg);
 982   }
 983 }
 984 
 985 CallGenerator* CallGenerator::for_method_handle_inline(JVMState* jvms, ciMethod* caller, ciMethod* callee, bool&amp; input_not_const) {
 986   GraphKit kit(jvms);
 987   PhaseGVN&amp; gvn = kit.gvn();
 988   Compile* C = kit.C;
 989   vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
 990   input_not_const = true;
 991   switch (iid) {
 992   case vmIntrinsics::_invokeBasic:
 993     {
 994       // Get MethodHandle receiver:
 995       Node* receiver = kit.argument(0);
 996       if (receiver-&gt;Opcode() == Op_ConP) {
 997         input_not_const = false;
 998         const TypeOopPtr* oop_ptr = receiver-&gt;bottom_type()-&gt;is_oopptr();
 999         ciMethod* target = oop_ptr-&gt;const_oop()-&gt;as_method_handle()-&gt;get_vmtarget();
1000         const int vtable_index = Method::invalid_vtable_index;
1001 
1002         if (!ciMethod::is_consistent_info(callee, target)) {
1003           print_inlining_failure(C, callee, jvms-&gt;depth() - 1, jvms-&gt;bci(),
1004                                  &quot;signatures mismatch&quot;);
1005           return NULL;
1006         }
1007 
1008         CallGenerator* cg = C-&gt;call_generator(target, vtable_index,
1009                                               false /* call_does_dispatch */,
1010                                               jvms,
1011                                               true /* allow_inline */,
1012                                               PROB_ALWAYS,
1013                                               NULL,
1014                                               true);
1015         return cg;
1016       } else {
1017         print_inlining_failure(C, callee, jvms-&gt;depth() - 1, jvms-&gt;bci(),
1018                                &quot;receiver not constant&quot;);
1019       }
1020     }
1021     break;
1022 
1023   case vmIntrinsics::_linkToVirtual:
1024   case vmIntrinsics::_linkToStatic:
1025   case vmIntrinsics::_linkToSpecial:
1026   case vmIntrinsics::_linkToInterface:
1027     {
1028       int nargs = callee-&gt;arg_size();
1029       // Get MemberName argument:
1030       Node* member_name = kit.argument(nargs - 1);
1031       if (member_name-&gt;Opcode() == Op_ConP) {
1032         input_not_const = false;
1033         const TypeOopPtr* oop_ptr = member_name-&gt;bottom_type()-&gt;is_oopptr();
1034         ciMethod* target = oop_ptr-&gt;const_oop()-&gt;as_member_name()-&gt;get_vmtarget();
1035 
1036         if (!ciMethod::is_consistent_info(callee, target)) {
1037           print_inlining_failure(C, callee, jvms-&gt;depth() - 1, jvms-&gt;bci(),
1038                                  &quot;signatures mismatch&quot;);
1039           return NULL;
1040         }
1041 
1042         // In lambda forms we erase signature types to avoid resolving issues
1043         // involving class loaders.  When we optimize a method handle invoke
1044         // to a direct call we must cast the receiver and arguments to its
1045         // actual types.
1046         ciSignature* signature = target-&gt;signature();
1047         const int receiver_skip = target-&gt;is_static() ? 0 : 1;
1048         // Cast receiver to its type.
1049         if (!target-&gt;is_static()) {
1050           cast_argument(nargs, 0, signature-&gt;accessing_klass(), kit);
1051         }
1052         // Cast reference arguments to its type.
1053         for (int i = 0, j = 0; i &lt; signature-&gt;count(); i++) {
1054           ciType* t = signature-&gt;type_at(i);
1055           if (t-&gt;is_klass()) {
1056             cast_argument(nargs, receiver_skip + j, t, kit);
1057           }
1058           j += t-&gt;size();  // long and double take two slots
1059         }
1060 
1061         // Try to get the most accurate receiver type
1062         const bool is_virtual              = (iid == vmIntrinsics::_linkToVirtual);
1063         const bool is_virtual_or_interface = (is_virtual || iid == vmIntrinsics::_linkToInterface);
1064         int  vtable_index       = Method::invalid_vtable_index;
1065         bool call_does_dispatch = false;
1066 
1067         ciKlass* speculative_receiver_type = NULL;
1068         if (is_virtual_or_interface) {
1069           ciInstanceKlass* klass = target-&gt;holder();
1070           Node*             receiver_node = kit.argument(0);
1071           const TypeOopPtr* receiver_type = gvn.type(receiver_node)-&gt;isa_oopptr();
1072           // call_does_dispatch and vtable_index are out-parameters.  They might be changed.
1073           // optimize_virtual_call() takes 2 different holder
1074           // arguments for a corner case that doesn&#39;t apply here (see
1075           // Parse::do_call())
1076           target = C-&gt;optimize_virtual_call(caller, jvms-&gt;bci(), klass, klass,
1077                                             target, receiver_type, is_virtual,
1078                                             call_does_dispatch, vtable_index, // out-parameters
1079                                             false /* check_access */);
1080           // We lack profiling at this call but type speculation may
1081           // provide us with a type
1082           speculative_receiver_type = (receiver_type != NULL) ? receiver_type-&gt;speculative_type() : NULL;
1083         }
1084         CallGenerator* cg = C-&gt;call_generator(target, vtable_index, call_does_dispatch, jvms,
1085                                               !StressMethodHandleLinkerInlining /* allow_inline */,
1086                                               PROB_ALWAYS,
1087                                               speculative_receiver_type,
1088                                               true);
1089         return cg;
1090       } else {
1091         print_inlining_failure(C, callee, jvms-&gt;depth() - 1, jvms-&gt;bci(),
1092                                &quot;member_name not constant&quot;);
1093       }
1094     }
1095     break;
1096 
1097   default:
1098     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
1099     break;
1100   }
1101   return NULL;
1102 }
1103 
1104 
1105 //------------------------PredicatedIntrinsicGenerator------------------------------
1106 // Internal class which handles all predicated Intrinsic calls.
1107 class PredicatedIntrinsicGenerator : public CallGenerator {
1108   CallGenerator* _intrinsic;
1109   CallGenerator* _cg;
1110 
1111 public:
1112   PredicatedIntrinsicGenerator(CallGenerator* intrinsic,
1113                                CallGenerator* cg)
1114     : CallGenerator(cg-&gt;method())
1115   {
1116     _intrinsic = intrinsic;
1117     _cg        = cg;
1118   }
1119 
1120   virtual bool      is_virtual()   const    { return true; }
1121   virtual bool      is_inlined()   const    { return true; }
1122   virtual bool      is_intrinsic() const    { return true; }
1123 
1124   virtual JVMState* generate(JVMState* jvms);
1125 };
1126 
1127 
1128 CallGenerator* CallGenerator::for_predicated_intrinsic(CallGenerator* intrinsic,
1129                                                        CallGenerator* cg) {
1130   return new PredicatedIntrinsicGenerator(intrinsic, cg);
1131 }
1132 
1133 
1134 JVMState* PredicatedIntrinsicGenerator::generate(JVMState* jvms) {
1135   // The code we want to generate here is:
1136   //    if (receiver == NULL)
1137   //        uncommon_Trap
1138   //    if (predicate(0))
1139   //        do_intrinsic(0)
1140   //    else
1141   //    if (predicate(1))
1142   //        do_intrinsic(1)
1143   //    ...
1144   //    else
1145   //        do_java_comp
1146 
1147   GraphKit kit(jvms);
1148   PhaseGVN&amp; gvn = kit.gvn();
1149 
1150   CompileLog* log = kit.C-&gt;log();
1151   if (log != NULL) {
1152     log-&gt;elem(&quot;predicated_intrinsic bci=&#39;%d&#39; method=&#39;%d&#39;&quot;,
1153               jvms-&gt;bci(), log-&gt;identify(method()));
1154   }
1155 
1156   if (!method()-&gt;is_static()) {
1157     // We need an explicit receiver null_check before checking its type in predicate.
1158     // We share a map with the caller, so his JVMS gets adjusted.
1159     kit.null_check_receiver_before_call(method());
1160     if (kit.stopped()) {
1161       return kit.transfer_exceptions_into_jvms();
1162     }
1163   }
1164 
1165   int n_predicates = _intrinsic-&gt;predicates_count();
1166   assert(n_predicates &gt; 0, &quot;sanity&quot;);
1167 
1168   JVMState** result_jvms = NEW_RESOURCE_ARRAY(JVMState*, (n_predicates+1));
1169 
1170   // Region for normal compilation code if intrinsic failed.
1171   Node* slow_region = new RegionNode(1);
1172 
1173   int results = 0;
1174   for (int predicate = 0; (predicate &lt; n_predicates) &amp;&amp; !kit.stopped(); predicate++) {
1175 #ifdef ASSERT
1176     JVMState* old_jvms = kit.jvms();
1177     SafePointNode* old_map = kit.map();
1178     Node* old_io  = old_map-&gt;i_o();
1179     Node* old_mem = old_map-&gt;memory();
1180     Node* old_exc = old_map-&gt;next_exception();
1181 #endif
1182     Node* else_ctrl = _intrinsic-&gt;generate_predicate(kit.sync_jvms(), predicate);
1183 #ifdef ASSERT
1184     // Assert(no_new_memory &amp;&amp; no_new_io &amp;&amp; no_new_exceptions) after generate_predicate.
1185     assert(old_jvms == kit.jvms(), &quot;generate_predicate should not change jvm state&quot;);
1186     SafePointNode* new_map = kit.map();
1187     assert(old_io  == new_map-&gt;i_o(), &quot;generate_predicate should not change i_o&quot;);
1188     assert(old_mem == new_map-&gt;memory(), &quot;generate_predicate should not change memory&quot;);
1189     assert(old_exc == new_map-&gt;next_exception(), &quot;generate_predicate should not add exceptions&quot;);
1190 #endif
1191     if (!kit.stopped()) {
1192       PreserveJVMState pjvms(&amp;kit);
1193       // Generate intrinsic code:
1194       JVMState* new_jvms = _intrinsic-&gt;generate(kit.sync_jvms());
1195       if (new_jvms == NULL) {
1196         // Intrinsic failed, use normal compilation path for this predicate.
1197         slow_region-&gt;add_req(kit.control());
1198       } else {
1199         kit.add_exception_states_from(new_jvms);
1200         kit.set_jvms(new_jvms);
1201         if (!kit.stopped()) {
1202           result_jvms[results++] = kit.jvms();
1203         }
1204       }
1205     }
1206     if (else_ctrl == NULL) {
1207       else_ctrl = kit.C-&gt;top();
1208     }
1209     kit.set_control(else_ctrl);
1210   }
1211   if (!kit.stopped()) {
1212     // Final &#39;else&#39; after predicates.
1213     slow_region-&gt;add_req(kit.control());
1214   }
1215   if (slow_region-&gt;req() &gt; 1) {
1216     PreserveJVMState pjvms(&amp;kit);
1217     // Generate normal compilation code:
1218     kit.set_control(gvn.transform(slow_region));
1219     JVMState* new_jvms = _cg-&gt;generate(kit.sync_jvms());
1220     if (kit.failing())
1221       return NULL;  // might happen because of NodeCountInliningCutoff
1222     assert(new_jvms != NULL, &quot;must be&quot;);
1223     kit.add_exception_states_from(new_jvms);
1224     kit.set_jvms(new_jvms);
1225     if (!kit.stopped()) {
1226       result_jvms[results++] = kit.jvms();
1227     }
1228   }
1229 
1230   if (results == 0) {
1231     // All paths ended in uncommon traps.
1232     (void) kit.stop();
1233     return kit.transfer_exceptions_into_jvms();
1234   }
1235 
1236   if (results == 1) { // Only one path
1237     kit.set_jvms(result_jvms[0]);
1238     return kit.transfer_exceptions_into_jvms();
1239   }
1240 
1241   // Merge all paths.
1242   kit.C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1243   RegionNode* region = new RegionNode(results + 1);
1244   Node* iophi = PhiNode::make(region, kit.i_o(), Type::ABIO);
1245   for (int i = 0; i &lt; results; i++) {
1246     JVMState* jvms = result_jvms[i];
1247     int path = i + 1;
1248     SafePointNode* map = jvms-&gt;map();
1249     region-&gt;init_req(path, map-&gt;control());
1250     iophi-&gt;set_req(path, map-&gt;i_o());
1251     if (i == 0) {
1252       kit.set_jvms(jvms);
1253     } else {
1254       kit.merge_memory(map-&gt;merged_memory(), region, path);
1255     }
1256   }
1257   kit.set_control(gvn.transform(region));
1258   kit.set_i_o(gvn.transform(iophi));
1259   // Transform new memory Phis.
1260   for (MergeMemStream mms(kit.merged_memory()); mms.next_non_empty();) {
1261     Node* phi = mms.memory();
1262     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == region) {
1263       mms.set_memory(gvn.transform(phi));
1264     }
1265   }
1266 
1267   // Merge debug info.
1268   Node** ins = NEW_RESOURCE_ARRAY(Node*, results);
1269   uint tos = kit.jvms()-&gt;stkoff() + kit.sp();
1270   Node* map = kit.map();
1271   uint limit = map-&gt;req();
1272   for (uint i = TypeFunc::Parms; i &lt; limit; i++) {
1273     // Skip unused stack slots; fast forward to monoff();
1274     if (i == tos) {
1275       i = kit.jvms()-&gt;monoff();
1276       if( i &gt;= limit ) break;
1277     }
1278     Node* n = map-&gt;in(i);
1279     ins[0] = n;
1280     const Type* t = gvn.type(n);
1281     bool needs_phi = false;
1282     for (int j = 1; j &lt; results; j++) {
1283       JVMState* jvms = result_jvms[j];
1284       Node* jmap = jvms-&gt;map();
1285       Node* m = NULL;
1286       if (jmap-&gt;req() &gt; i) {
1287         m = jmap-&gt;in(i);
1288         if (m != n) {
1289           needs_phi = true;
1290           t = t-&gt;meet_speculative(gvn.type(m));
1291         }
1292       }
1293       ins[j] = m;
1294     }
1295     if (needs_phi) {
1296       Node* phi = PhiNode::make(region, n, t);
1297       for (int j = 1; j &lt; results; j++) {
1298         phi-&gt;set_req(j + 1, ins[j]);
1299       }
1300       map-&gt;set_req(i, gvn.transform(phi));
1301     }
1302   }
1303 
1304   return kit.transfer_exceptions_into_jvms();
1305 }
1306 
1307 //-------------------------UncommonTrapCallGenerator-----------------------------
1308 // Internal class which handles all out-of-line calls checking receiver type.
1309 class UncommonTrapCallGenerator : public CallGenerator {
1310   Deoptimization::DeoptReason _reason;
1311   Deoptimization::DeoptAction _action;
1312 
1313 public:
1314   UncommonTrapCallGenerator(ciMethod* m,
1315                             Deoptimization::DeoptReason reason,
1316                             Deoptimization::DeoptAction action)
1317     : CallGenerator(m)
1318   {
1319     _reason = reason;
1320     _action = action;
1321   }
1322 
1323   virtual bool      is_virtual() const          { ShouldNotReachHere(); return false; }
1324   virtual bool      is_trap() const             { return true; }
1325 
1326   virtual JVMState* generate(JVMState* jvms);
1327 };
1328 
1329 
1330 CallGenerator*
1331 CallGenerator::for_uncommon_trap(ciMethod* m,
1332                                  Deoptimization::DeoptReason reason,
1333                                  Deoptimization::DeoptAction action) {
1334   return new UncommonTrapCallGenerator(m, reason, action);
1335 }
1336 
1337 
1338 JVMState* UncommonTrapCallGenerator::generate(JVMState* jvms) {
1339   GraphKit kit(jvms);
1340   kit.C-&gt;print_inlining_update(this);
1341   // Take the trap with arguments pushed on the stack.  (Cf. null_check_receiver).
1342   // Callsite signature can be different from actual method being called (i.e _linkTo* sites).
1343   // Use callsite signature always.
1344   ciMethod* declared_method = kit.method()-&gt;get_method_at_bci(kit.bci());
1345   int nargs = declared_method-&gt;arg_size();
1346   kit.inc_sp(nargs);
1347   assert(nargs &lt;= kit.sp() &amp;&amp; kit.sp() &lt;= jvms-&gt;stk_size(), &quot;sane sp w/ args pushed&quot;);
1348   if (_reason == Deoptimization::Reason_class_check &amp;&amp;
1349       _action == Deoptimization::Action_maybe_recompile) {
1350     // Temp fix for 6529811
1351     // Don&#39;t allow uncommon_trap to override our decision to recompile in the event
1352     // of a class cast failure for a monomorphic call as it will never let us convert
1353     // the call to either bi-morphic or megamorphic and can lead to unc-trap loops
1354     bool keep_exact_action = true;
1355     kit.uncommon_trap(_reason, _action, NULL, &quot;monomorphic vcall checkcast&quot;, false, keep_exact_action);
1356   } else {
1357     kit.uncommon_trap(_reason, _action);
1358   }
1359   return kit.transfer_exceptions_into_jvms();
1360 }
1361 
1362 // (Note:  Moved hook_up_call to GraphKit::set_edges_for_java_call.)
1363 
1364 // (Node:  Merged hook_up_exits into ParseGenerator::generate.)
1365 
1366 #define NODES_OVERHEAD_PER_METHOD (30.0)
1367 #define NODES_PER_BYTECODE (9.5)
1368 
1369 void WarmCallInfo::init(JVMState* call_site, ciMethod* call_method, ciCallProfile&amp; profile, float prof_factor) {
1370   int call_count = profile.count();
1371   int code_size = call_method-&gt;code_size();
1372 
1373   // Expected execution count is based on the historical count:
1374   _count = call_count &lt; 0 ? 1 : call_site-&gt;method()-&gt;scale_count(call_count, prof_factor);
1375 
1376   // Expected profit from inlining, in units of simple call-overheads.
1377   _profit = 1.0;
1378 
1379   // Expected work performed by the call in units of call-overheads.
1380   // %%% need an empirical curve fit for &quot;work&quot; (time in call)
1381   float bytecodes_per_call = 3;
1382   _work = 1.0 + code_size / bytecodes_per_call;
1383 
1384   // Expected size of compilation graph:
1385   // -XX:+PrintParseStatistics once reported:
1386   //  Methods seen: 9184  Methods parsed: 9184  Nodes created: 1582391
1387   //  Histogram of 144298 parsed bytecodes:
1388   // %%% Need an better predictor for graph size.
1389   _size = NODES_OVERHEAD_PER_METHOD + (NODES_PER_BYTECODE * code_size);
1390 }
1391 
1392 // is_cold:  Return true if the node should never be inlined.
1393 // This is true if any of the key metrics are extreme.
1394 bool WarmCallInfo::is_cold() const {
1395   if (count()  &lt;  WarmCallMinCount)        return true;
1396   if (profit() &lt;  WarmCallMinProfit)       return true;
1397   if (work()   &gt;  WarmCallMaxWork)         return true;
1398   if (size()   &gt;  WarmCallMaxSize)         return true;
1399   return false;
1400 }
1401 
1402 // is_hot:  Return true if the node should be inlined immediately.
1403 // This is true if any of the key metrics are extreme.
1404 bool WarmCallInfo::is_hot() const {
1405   assert(!is_cold(), &quot;eliminate is_cold cases before testing is_hot&quot;);
1406   if (count()  &gt;= HotCallCountThreshold)   return true;
1407   if (profit() &gt;= HotCallProfitThreshold)  return true;
1408   if (work()   &lt;= HotCallTrivialWork)      return true;
1409   if (size()   &lt;= HotCallTrivialSize)      return true;
1410   return false;
1411 }
1412 
1413 // compute_heat:
1414 float WarmCallInfo::compute_heat() const {
1415   assert(!is_cold(), &quot;compute heat only on warm nodes&quot;);
1416   assert(!is_hot(),  &quot;compute heat only on warm nodes&quot;);
1417   int min_size = MAX2(0,   (int)HotCallTrivialSize);
1418   int max_size = MIN2(500, (int)WarmCallMaxSize);
1419   float method_size = (size() - min_size) / MAX2(1, max_size - min_size);
1420   float size_factor;
1421   if      (method_size &lt; 0.05)  size_factor = 4;   // 2 sigmas better than avg.
1422   else if (method_size &lt; 0.15)  size_factor = 2;   // 1 sigma better than avg.
1423   else if (method_size &lt; 0.5)   size_factor = 1;   // better than avg.
1424   else                          size_factor = 0.5; // worse than avg.
1425   return (count() * profit() * size_factor);
1426 }
1427 
1428 bool WarmCallInfo::warmer_than(WarmCallInfo* that) {
1429   assert(this != that, &quot;compare only different WCIs&quot;);
1430   assert(this-&gt;heat() != 0 &amp;&amp; that-&gt;heat() != 0, &quot;call compute_heat 1st&quot;);
1431   if (this-&gt;heat() &gt; that-&gt;heat())   return true;
1432   if (this-&gt;heat() &lt; that-&gt;heat())   return false;
1433   assert(this-&gt;heat() == that-&gt;heat(), &quot;no NaN heat allowed&quot;);
1434   // Equal heat.  Break the tie some other way.
1435   if (!this-&gt;call() || !that-&gt;call())  return (address)this &gt; (address)that;
1436   return this-&gt;call()-&gt;_idx &gt; that-&gt;call()-&gt;_idx;
1437 }
1438 
1439 //#define UNINIT_NEXT ((WarmCallInfo*)badAddress)
1440 #define UNINIT_NEXT ((WarmCallInfo*)NULL)
1441 
1442 WarmCallInfo* WarmCallInfo::insert_into(WarmCallInfo* head) {
1443   assert(next() == UNINIT_NEXT, &quot;not yet on any list&quot;);
1444   WarmCallInfo* prev_p = NULL;
1445   WarmCallInfo* next_p = head;
1446   while (next_p != NULL &amp;&amp; next_p-&gt;warmer_than(this)) {
1447     prev_p = next_p;
1448     next_p = prev_p-&gt;next();
1449   }
1450   // Install this between prev_p and next_p.
1451   this-&gt;set_next(next_p);
1452   if (prev_p == NULL)
1453     head = this;
1454   else
1455     prev_p-&gt;set_next(this);
1456   return head;
1457 }
1458 
1459 WarmCallInfo* WarmCallInfo::remove_from(WarmCallInfo* head) {
1460   WarmCallInfo* prev_p = NULL;
1461   WarmCallInfo* next_p = head;
1462   while (next_p != this) {
1463     assert(next_p != NULL, &quot;this must be in the list somewhere&quot;);
1464     prev_p = next_p;
1465     next_p = prev_p-&gt;next();
1466   }
1467   next_p = this-&gt;next();
1468   debug_only(this-&gt;set_next(UNINIT_NEXT));
1469   // Remove this from between prev_p and next_p.
1470   if (prev_p == NULL)
1471     head = next_p;
1472   else
1473     prev_p-&gt;set_next(next_p);
1474   return head;
1475 }
1476 
1477 WarmCallInfo WarmCallInfo::_always_hot(WarmCallInfo::MAX_VALUE(), WarmCallInfo::MAX_VALUE(),
1478                                        WarmCallInfo::MIN_VALUE(), WarmCallInfo::MIN_VALUE());
1479 WarmCallInfo WarmCallInfo::_always_cold(WarmCallInfo::MIN_VALUE(), WarmCallInfo::MIN_VALUE(),
1480                                         WarmCallInfo::MAX_VALUE(), WarmCallInfo::MAX_VALUE());
1481 
1482 WarmCallInfo* WarmCallInfo::always_hot() {
1483   assert(_always_hot.is_hot(), &quot;must always be hot&quot;);
1484   return &amp;_always_hot;
1485 }
1486 
1487 WarmCallInfo* WarmCallInfo::always_cold() {
1488   assert(_always_cold.is_cold(), &quot;must always be cold&quot;);
1489   return &amp;_always_cold;
1490 }
1491 
1492 
1493 #ifndef PRODUCT
1494 
1495 void WarmCallInfo::print() const {
1496   tty-&gt;print(&quot;%s : C=%6.1f P=%6.1f W=%6.1f S=%6.1f H=%6.1f -&gt; %p&quot;,
1497              is_cold() ? &quot;cold&quot; : is_hot() ? &quot;hot &quot; : &quot;warm&quot;,
1498              count(), profit(), work(), size(), compute_heat(), next());
1499   tty-&gt;cr();
1500   if (call() != NULL)  call()-&gt;dump();
1501 }
1502 
1503 void print_wci(WarmCallInfo* ci) {
1504   ci-&gt;print();
1505 }
1506 
1507 void WarmCallInfo::print_all() const {
1508   for (const WarmCallInfo* p = this; p != NULL; p = p-&gt;next())
1509     p-&gt;print();
1510 }
1511 
1512 int WarmCallInfo::count_all() const {
1513   int cnt = 0;
1514   for (const WarmCallInfo* p = this; p != NULL; p = p-&gt;next())
1515     cnt++;
1516   return cnt;
1517 }
1518 
1519 #endif //PRODUCT
    </pre>
  </body>
</html>