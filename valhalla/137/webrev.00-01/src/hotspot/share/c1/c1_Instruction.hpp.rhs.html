<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_INSTRUCTION_HPP
  26 #define SHARE_C1_C1_INSTRUCTION_HPP
  27 
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIR.hpp&quot;
  30 #include &quot;c1/c1_ValueType.hpp&quot;
  31 #include &quot;ci/ciField.hpp&quot;
  32 
  33 // Predefined classes
  34 class ciField;
  35 class ValueStack;
  36 class InstructionPrinter;
  37 class IRScope;
  38 class LIR_OprDesc;
  39 typedef LIR_OprDesc* LIR_Opr;
  40 
  41 
  42 // Instruction class hierarchy
  43 //
  44 // All leaf classes in the class hierarchy are concrete classes
  45 // (i.e., are instantiated). All other classes are abstract and
  46 // serve factoring.
  47 
  48 class Instruction;
  49 class   Phi;
  50 class   Local;
  51 class   Constant;
  52 class   AccessField;
  53 class     LoadField;
  54 class     StoreField;
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
  75 class     NewInlineTypeInstance;
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
  80 class     WithField;
  81 class     DefaultValue;
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
  96 class         LookupSwitch;
  97 class       Return;
  98 class       Throw;
  99 class       Base;
 100 class   RoundFP;
 101 class   UnsafeOp;
 102 class     UnsafeRawOp;
 103 class       UnsafeGetRaw;
 104 class       UnsafePutRaw;
 105 class     UnsafeObjectOp;
 106 class       UnsafeGetObject;
 107 class       UnsafePutObject;
 108 class         UnsafeGetAndSetObject;
 109 class   ProfileCall;
 110 class   ProfileReturnType;
 111 class   ProfileInvoke;
 112 class   RuntimeCall;
 113 class   MemBar;
 114 class   RangeCheckPredicate;
 115 #ifdef ASSERT
 116 class   Assert;
 117 #endif
 118 
 119 // A Value is a reference to the instruction creating the value
 120 typedef Instruction* Value;
 121 typedef GrowableArray&lt;Value&gt; Values;
 122 typedef GrowableArray&lt;ValueStack*&gt; ValueStackStack;
 123 
 124 // BlockClosure is the base class for block traversal/iteration.
 125 
 126 class BlockClosure: public CompilationResourceObj {
 127  public:
 128   virtual void block_do(BlockBegin* block)       = 0;
 129 };
 130 
 131 
 132 // A simple closure class for visiting the values of an Instruction
 133 class ValueVisitor: public StackObj {
 134  public:
 135   virtual void visit(Value* v) = 0;
 136 };
 137 
 138 
 139 // Some array and list classes
 140 typedef GrowableArray&lt;BlockBegin*&gt; BlockBeginArray;
 141 
 142 class BlockList: public GrowableArray&lt;BlockBegin*&gt; {
 143  public:
 144   BlockList(): GrowableArray&lt;BlockBegin*&gt;() {}
 145   BlockList(const int size): GrowableArray&lt;BlockBegin*&gt;(size) {}
 146   BlockList(const int size, BlockBegin* init): GrowableArray&lt;BlockBegin*&gt;(size, size, init) {}
 147 
 148   void iterate_forward(BlockClosure* closure);
 149   void iterate_backward(BlockClosure* closure);
 150   void blocks_do(void f(BlockBegin*));
 151   void values_do(ValueVisitor* f);
 152   void print(bool cfg_only = false, bool live_only = false) PRODUCT_RETURN;
 153 };
 154 
 155 
 156 // InstructionVisitors provide type-based dispatch for instructions.
 157 // For each concrete Instruction class X, a virtual function do_X is
 158 // provided. Functionality that needs to be implemented for all classes
 159 // (e.g., printing, code generation) is factored out into a specialised
 160 // visitor instead of added to the Instruction classes itself.
 161 
 162 class InstructionVisitor: public StackObj {
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
 183   virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x) = 0;
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 187   virtual void do_WithField      (WithField*       x) = 0;
 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 204   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 205   virtual void do_RoundFP        (RoundFP*         x) = 0;
 206   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 207   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 208   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 209   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 210   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 211   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 212   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 213   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 214   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 215   virtual void do_MemBar         (MemBar*          x) = 0;
 216   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 217 #ifdef ASSERT
 218   virtual void do_Assert         (Assert*          x) = 0;
 219 #endif
 220 };
 221 
 222 
 223 // Hashing support
 224 //
 225 // Note: This hash functions affect the performance
 226 //       of ValueMap - make changes carefully!
 227 
 228 #define HASH1(x1            )                    ((intx)(x1))
 229 #define HASH2(x1, x2        )                    ((HASH1(x1            ) &lt;&lt; 7) ^ HASH1(x2))
 230 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2        ) &lt;&lt; 7) ^ HASH1(x3))
 231 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3    ) &lt;&lt; 7) ^ HASH1(x4))
 232 #define HASH5(x1, x2, x3, x4, x5)                ((HASH4(x1, x2, x3, x4) &lt;&lt; 7) ^ HASH1(x5))
 233 
 234 
 235 // The following macros are used to implement instruction-specific hashing.
 236 // By default, each instruction implements hash() and is_equal(Value), used
 237 // for value numbering/common subexpression elimination. The default imple-
 238 // mentation disables value numbering. Each instruction which can be value-
 239 // numbered, should define corresponding hash() and is_equal(Value) functions
 240 // via the macros below. The f arguments specify all the values/op codes, etc.
 241 // that need to be identical for two instructions to be identical.
 242 //
 243 // Note: The default implementation of hash() returns 0 in order to indicate
 244 //       that the instruction should not be considered for value numbering.
 245 //       The currently used hash functions do not guarantee that never a 0
 246 //       is produced. While this is still correct, it may be a performance
 247 //       bug (no value numbering for that node). However, this situation is
 248 //       so unlikely, that we are not going to handle it specially.
 249 
 250 #define HASHING1(class_name, enabled, f1)             \
 251   virtual intx hash() const {                         \
 252     return (enabled) ? HASH2(name(), f1) : 0;         \
 253   }                                                   \
 254   virtual bool is_equal(Value v) const {              \
 255     if (!(enabled)  ) return false;                   \
 256     class_name* _v = v-&gt;as_##class_name();            \
 257     if (_v == NULL  ) return false;                   \
 258     if (f1 != _v-&gt;f1) return false;                   \
 259     return true;                                      \
 260   }                                                   \
 261 
 262 
 263 #define HASHING2(class_name, enabled, f1, f2)         \
 264   virtual intx hash() const {                         \
 265     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 266   }                                                   \
 267   virtual bool is_equal(Value v) const {              \
 268     if (!(enabled)  ) return false;                   \
 269     class_name* _v = v-&gt;as_##class_name();            \
 270     if (_v == NULL  ) return false;                   \
 271     if (f1 != _v-&gt;f1) return false;                   \
 272     if (f2 != _v-&gt;f2) return false;                   \
 273     return true;                                      \
 274   }                                                   \
 275 
 276 
 277 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 278   virtual intx hash() const {                         \
 279     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 280   }                                                   \
 281   virtual bool is_equal(Value v) const {              \
 282     if (!(enabled)  ) return false;                   \
 283     class_name* _v = v-&gt;as_##class_name();            \
 284     if (_v == NULL  ) return false;                   \
 285     if (f1 != _v-&gt;f1) return false;                   \
 286     if (f2 != _v-&gt;f2) return false;                   \
 287     if (f3 != _v-&gt;f3) return false;                   \
 288     return true;                                      \
 289   }                                                   \
 290 
 291 #define HASHING4(class_name, enabled, f1, f2, f3, f4) \
 292   virtual intx hash() const {                         \
 293     return (enabled) ? HASH5(name(), f1, f2, f3, f4) : 0; \
 294   }                                                   \
 295   virtual bool is_equal(Value v) const {              \
 296     if (!(enabled)  ) return false;                   \
 297     class_name* _v = v-&gt;as_##class_name();            \
 298     if (_v == NULL  ) return false;                   \
 299     if (f1 != _v-&gt;f1) return false;                   \
 300     if (f2 != _v-&gt;f2) return false;                   \
 301     if (f3 != _v-&gt;f3) return false;                   \
 302     if (f4 != _v-&gt;f4) return false;                   \
 303     return true;                                      \
 304   }                                                   \
 305 
 306 
 307 // The mother of all instructions...
 308 
 309 class Instruction: public CompilationResourceObj {
 310  private:
 311   int          _id;                              // the unique instruction id
 312 #ifndef PRODUCT
 313   int          _printable_bci;                   // the bci of the instruction for printing
 314 #endif
 315   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 316   int          _pin_state;                       // set of PinReason describing the reason for pinning
 317   ValueType*   _type;                            // the instruction value type
 318   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 319   Instruction* _subst;                           // the substitution instruction if any
 320   LIR_Opr      _operand;                         // LIR specific information
 321   unsigned int _flags;                           // Flag bits
 322 
 323   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 324   ValueStack*  _exception_state;                 // Copy of state for exception handling
 325   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 326 
 327   friend class UseCountComputer;
 328 
 329   void update_exception_state(ValueStack* state);
 330 
 331  protected:
 332   BlockBegin*  _block;                           // Block that contains this instruction
 333 
 334   void set_type(ValueType* type) {
 335     assert(type != NULL, &quot;type must exist&quot;);
 336     _type = type;
 337   }
 338 
 339   // Helper class to keep track of which arguments need a null check
 340   class ArgsNonNullState {
 341   private:
 342     int _nonnull_state; // mask identifying which args are nonnull
 343   public:
 344     ArgsNonNullState()
 345       : _nonnull_state(AllBits) {}
 346 
 347     // Does argument number i needs a null check?
 348     bool arg_needs_null_check(int i) const {
 349       // No data is kept for arguments starting at position 33 so
 350       // conservatively assume that they need a null check.
 351       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 352         return is_set_nth_bit(_nonnull_state, i);
 353       }
 354       return true;
 355     }
 356 
 357     // Set whether argument number i needs a null check or not
 358     void set_arg_needs_null_check(int i, bool check) {
 359       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 360         if (check) {
 361           _nonnull_state |= nth_bit(i);
 362         } else {
 363           _nonnull_state &amp;= ~(nth_bit(i));
 364         }
 365       }
 366     }
 367   };
 368 
 369  public:
 370   void* operator new(size_t size) throw() {
 371     Compilation* c = Compilation::current();
 372     void* res = c-&gt;arena()-&gt;Amalloc(size);
 373     return res;
 374   }
 375 
 376   static const int no_bci = -99;
 377 
 378   enum InstructionFlag {
 379     NeedsNullCheckFlag = 0,
 380     NeverNullFlag,          // For &quot;Q&quot; signatures
 381     CanTrapFlag,
 382     DirectCompareFlag,
 383     IsEliminatedFlag,
 384     IsSafepointFlag,
 385     IsStaticFlag,
 386     IsStrictfpFlag,
 387     NeedsStoreCheckFlag,
 388     NeedsWriteBarrierFlag,
 389     PreservesStateFlag,
 390     TargetIsFinalFlag,
 391     TargetIsLoadedFlag,
 392     TargetIsStrictfpFlag,
 393     UnorderedIsTrueFlag,
 394     NeedsPatchingFlag,
 395     ThrowIncompatibleClassChangeErrorFlag,
 396     InvokeSpecialReceiverCheckFlag,
 397     ProfileMDOFlag,
 398     IsLinkedInBlockFlag,
 399     NeedsRangeCheckFlag,
 400     InWorkListFlag,
 401     DeoptimizeOnException,
 402     InstructionLastFlag
 403   };
 404 
 405  public:
 406   bool check_flag(InstructionFlag id) const      { return (_flags &amp; (1 &lt;&lt; id)) != 0;    }
 407   void set_flag(InstructionFlag id, bool f)      { _flags = f ? (_flags | (1 &lt;&lt; id)) : (_flags &amp; ~(1 &lt;&lt; id)); };
 408 
 409   // &#39;globally&#39; used condition values
 410   enum Condition {
 411     eql, neq, lss, leq, gtr, geq, aeq, beq
 412   };
 413 
 414   // Instructions may be pinned for many reasons and under certain conditions
 415   // with enough knowledge it&#39;s possible to safely unpin them.
 416   enum PinReason {
 417       PinUnknown           = 1 &lt;&lt; 0
 418     , PinExplicitNullCheck = 1 &lt;&lt; 3
 419     , PinStackForStateSplit= 1 &lt;&lt; 12
 420     , PinStateSplitConstructor= 1 &lt;&lt; 13
 421     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 422   };
 423 
 424   static Condition mirror(Condition cond);
 425   static Condition negate(Condition cond);
 426 
 427   // initialization
 428   static int number_of_instructions() {
 429     return Compilation::current()-&gt;number_of_instructions();
 430   }
 431 
 432   // creation
 433   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
 434   : _id(Compilation::current()-&gt;get_next_id()),
 435 #ifndef PRODUCT
 436   _printable_bci(-99),
 437 #endif
 438     _use_count(0)
 439   , _pin_state(0)
 440   , _type(type)
 441   , _next(NULL)
 442   , _subst(NULL)
 443   , _operand(LIR_OprFact::illegalOpr)
 444   , _flags(0)
 445   , _state_before(state_before)
 446   , _exception_handlers(NULL)
 447   , _block(NULL)
 448   {
 449     check_state(state_before);
 450     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 451     update_exception_state(_state_before);
 452   }
 453 
 454   // accessors
 455   int id() const                                 { return _id; }
 456 #ifndef PRODUCT
 457   bool has_printable_bci() const                 { return _printable_bci != -99; }
 458   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 459   void set_printable_bci(int bci)                { _printable_bci = bci; }
 460 #endif
 461   int dominator_depth();
 462   int use_count() const                          { return _use_count; }
 463   int pin_state() const                          { return _pin_state; }
 464   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 465   ValueType* type() const                        { return _type; }
 466   BlockBegin *block() const                      { return _block; }
 467   Instruction* prev();                           // use carefully, expensive operation
 468   Instruction* next() const                      { return _next; }
 469   bool has_subst() const                         { return _subst != NULL; }
 470   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 471   LIR_Opr operand() const                        { return _operand; }
 472 
 473   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 474   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 475   void set_null_free(bool f)                    { set_flag(NeverNullFlag, f); }
 476   bool is_null_free() const                     { return check_flag(NeverNullFlag); }
 477   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 478   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 479 
 480   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 481 
 482   bool has_uses() const                          { return use_count() &gt; 0; }
 483   ValueStack* state_before() const               { return _state_before; }
 484   ValueStack* exception_state() const            { return _exception_state; }
 485   virtual bool needs_exception_state() const     { return true; }
 486   XHandlers* exception_handlers() const          { return _exception_handlers; }
 487   ciKlass* as_loaded_klass_or_null() const;
 488 
 489   // withfield optimization
 490   virtual void set_escaped()                     { }
 491   virtual void set_local_index(int index)        { }
 492   virtual bool is_optimizable_for_withfield() const { return false; }
 493 
 494 
 495   // manipulation
 496   void pin(PinReason reason)                     { _pin_state |= reason; }
 497   void pin()                                     { _pin_state |= PinUnknown; }
 498   // DANGEROUS: only used by EliminateStores
 499   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 500 
 501   Instruction* set_next(Instruction* next) {
 502     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 503     assert(next != NULL, &quot;must not be NULL&quot;);
 504     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 505     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 506 
 507     BlockBegin *block = this-&gt;block();
 508     next-&gt;_block = block;
 509 
 510     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 511     _next = next;
 512     return next;
 513   }
 514 
 515   Instruction* set_next(Instruction* next, int bci) {
 516 #ifndef PRODUCT
 517     next-&gt;set_printable_bci(bci);
 518 #endif
 519     return set_next(next);
 520   }
 521 
 522   // when blocks are merged
 523   void fixup_block_pointers() {
 524     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 525     while (cur &amp;&amp; cur-&gt;_block != block()) {
 526       cur-&gt;_block = block();
 527       cur = cur-&gt;next();
 528     }
 529   }
 530 
 531   Instruction *insert_after(Instruction *i) {
 532     Instruction* n = _next;
 533     set_next(i);
 534     i-&gt;set_next(n);
 535     return _next;
 536   }
 537 
 538   bool is_loaded_flattened_array() const;
 539   bool maybe_flattened_array();
 540   bool maybe_null_free_array();
 541 
 542   Instruction *insert_after_same_bci(Instruction *i) {
 543 #ifndef PRODUCT
 544     i-&gt;set_printable_bci(printable_bci());
 545 #endif
 546     return insert_after(i);
 547   }
 548 
 549   void set_subst(Instruction* subst)             {
 550     assert(subst == NULL ||
 551            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 552            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 553     _subst = subst;
 554   }
 555   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 556   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 557   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 558 
 559   // machine-specifics
 560   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 561   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
 562 
 563   // generic
 564   virtual Instruction*      as_Instruction()     { return this; } // to satisfy HASHING1 macro
 565   virtual Phi*              as_Phi()             { return NULL; }
 566   virtual Local*            as_Local()           { return NULL; }
 567   virtual Constant*         as_Constant()        { return NULL; }
 568   virtual AccessField*      as_AccessField()     { return NULL; }
 569   virtual LoadField*        as_LoadField()       { return NULL; }
 570   virtual StoreField*       as_StoreField()      { return NULL; }
 571   virtual AccessArray*      as_AccessArray()     { return NULL; }
 572   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 573   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 574   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 575   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 576   virtual NegateOp*         as_NegateOp()        { return NULL; }
 577   virtual Op2*              as_Op2()             { return NULL; }
 578   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 579   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 580   virtual LogicOp*          as_LogicOp()         { return NULL; }
 581   virtual CompareOp*        as_CompareOp()       { return NULL; }
 582   virtual IfOp*             as_IfOp()            { return NULL; }
 583   virtual Convert*          as_Convert()         { return NULL; }
 584   virtual NullCheck*        as_NullCheck()       { return NULL; }
 585   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 586   virtual StateSplit*       as_StateSplit()      { return NULL; }
 587   virtual Invoke*           as_Invoke()          { return NULL; }
 588   virtual NewInstance*      as_NewInstance()     { return NULL; }
 589   virtual NewInlineTypeInstance* as_NewInlineTypeInstance() { return NULL; }
 590   virtual NewArray*         as_NewArray()        { return NULL; }
 591   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 592   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 593   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 594   virtual WithField*        as_WithField()       { return NULL; }
 595   virtual DefaultValue*     as_DefaultValue()    { return NULL; }
 596   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 597   virtual CheckCast*        as_CheckCast()       { return NULL; }
 598   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 599   virtual TypeCast*         as_TypeCast()        { return NULL; }
 600   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 601   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 602   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 603   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 604   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 605   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 606   virtual Goto*             as_Goto()            { return NULL; }
 607   virtual If*               as_If()              { return NULL; }
 608   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 609   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 610   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 611   virtual Return*           as_Return()          { return NULL; }
 612   virtual Throw*            as_Throw()           { return NULL; }
 613   virtual Base*             as_Base()            { return NULL; }
 614   virtual RoundFP*          as_RoundFP()         { return NULL; }
 615   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
 616   virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }
 617   virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }
 618   virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }
 619 
 620 #ifdef ASSERT
 621   virtual Assert*           as_Assert()          { return NULL; }
 622 #endif
 623 
 624   virtual void visit(InstructionVisitor* v)      = 0;
 625 
 626   virtual bool can_trap() const                  { return false; }
 627 
 628   virtual void input_values_do(ValueVisitor* f)   = 0;
 629   virtual void state_values_do(ValueVisitor* f);
 630   virtual void other_values_do(ValueVisitor* f)   { /* usually no other - override on demand */ }
 631           void       values_do(ValueVisitor* f)   { input_values_do(f); state_values_do(f); other_values_do(f); }
 632 
 633   virtual ciType* exact_type() const;
 634   virtual ciType* declared_type() const          { return NULL; }
 635 
 636   // hashing
 637   virtual const char* name() const               = 0;
 638   HASHING1(Instruction, false, id())             // hashing disabled by default
 639 
 640   // debugging
 641   static void check_state(ValueStack* state)     PRODUCT_RETURN;
 642   void print()                                   PRODUCT_RETURN;
 643   void print_line()                              PRODUCT_RETURN;
 644   void print(InstructionPrinter&amp; ip)             PRODUCT_RETURN;
 645 };
 646 
 647 
 648 // The following macros are used to define base (i.e., non-leaf)
 649 // and leaf instruction classes. They define class-name related
 650 // generic functionality in one place.
 651 
 652 #define BASE(class_name, super_class_name)       \
 653   class class_name: public super_class_name {    \
 654    public:                                       \
 655     virtual class_name* as_##class_name()        { return this; }              \
 656 
 657 
 658 #define LEAF(class_name, super_class_name)       \
 659   BASE(class_name, super_class_name)             \
 660    public:                                       \
 661     virtual const char* name() const             { return #class_name; }       \
 662     virtual void visit(InstructionVisitor* v)    { v-&gt;do_##class_name(this); } \
 663 
 664 
 665 // Debugging support
 666 
 667 
 668 #ifdef ASSERT
 669 class AssertValues: public ValueVisitor {
 670   void visit(Value* x)             { assert((*x) != NULL, &quot;value must exist&quot;); }
 671 };
 672   #define ASSERT_VALUES                          { AssertValues assert_value; values_do(&amp;assert_value); }
 673 #else
 674   #define ASSERT_VALUES
 675 #endif // ASSERT
 676 
 677 
 678 // A Phi is a phi function in the sense of SSA form. It stands for
 679 // the value of a local variable at the beginning of a join block.
 680 // A Phi consists of n operands, one for every incoming branch.
 681 
 682 LEAF(Phi, Instruction)
 683  private:
 684   int         _pf_flags; // the flags of the phi function
 685   int         _index;    // to value on operand stack (index &lt; 0) or to local
 686  public:
 687   // creation
 688   Phi(ValueType* type, BlockBegin* b, int index)
 689   : Instruction(type-&gt;base())
 690   , _pf_flags(0)
 691   , _index(index)
 692   {
 693     _block = b;
 694     NOT_PRODUCT(set_printable_bci(Value(b)-&gt;printable_bci()));
 695     if (type-&gt;is_illegal()) {
 696       make_illegal();
 697     }
 698   }
 699 
 700   // flags
 701   enum Flag {
 702     no_flag         = 0,
 703     visited         = 1 &lt;&lt; 0,
 704     cannot_simplify = 1 &lt;&lt; 1
 705   };
 706 
 707   // accessors
 708   bool  is_local() const          { return _index &gt;= 0; }
 709   bool  is_on_stack() const       { return !is_local(); }
 710   int   local_index() const       { assert(is_local(), &quot;&quot;); return _index; }
 711   int   stack_index() const       { assert(is_on_stack(), &quot;&quot;); return -(_index+1); }
 712 
 713   Value operand_at(int i) const;
 714   int   operand_count() const;
 715 
 716   void   set(Flag f)              { _pf_flags |=  f; }
 717   void   clear(Flag f)            { _pf_flags &amp;= ~f; }
 718   bool   is_set(Flag f) const     { return (_pf_flags &amp; f) != 0; }
 719 
 720   // Invalidates phis corresponding to merges of locals of two different types
 721   // (these should never be referenced, otherwise the bytecodes are illegal)
 722   void   make_illegal() {
 723     set(cannot_simplify);
 724     set_type(illegalType);
 725   }
 726 
 727   bool is_illegal() const {
 728     return type()-&gt;is_illegal();
 729   }
 730 
 731   // generic
 732   virtual void input_values_do(ValueVisitor* f) {
 733   }
 734 };
 735 
 736 
 737 // A local is a placeholder for an incoming argument to a function call.
 738 LEAF(Local, Instruction)
 739  private:
 740   int      _java_index;                          // the local index within the method to which the local belongs
 741   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 742   ciType*  _declared_type;
 743  public:
 744   // creation
 745   Local(ciType* declared, ValueType* type, int index, bool receiver, bool null_free)
 746     : Instruction(type)
 747     , _java_index(index)
 748     , _is_receiver(receiver)
 749     , _declared_type(declared)
 750   {
 751     set_null_free(null_free);
 752     NOT_PRODUCT(set_printable_bci(-1));
 753   }
 754 
 755   // accessors
 756   int java_index() const                         { return _java_index; }
 757   bool is_receiver() const                       { return _is_receiver; }
 758 
 759   virtual ciType* declared_type() const          { return _declared_type; }
 760 
 761   // generic
 762   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 763 };
 764 
 765 
 766 LEAF(Constant, Instruction)
 767  public:
 768   // creation
 769   Constant(ValueType* type):
 770       Instruction(type, NULL, /*type_is_constant*/ true)
 771   {
 772     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 773   }
 774 
 775   Constant(ValueType* type, ValueStack* state_before):
 776     Instruction(type, state_before, /*type_is_constant*/ true)
 777   {
 778     assert(state_before != NULL, &quot;only used for constants which need patching&quot;);
 779     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 780     // since it&#39;s patching it needs to be pinned
 781     pin();
 782   }
 783 
 784   // generic
 785   virtual bool can_trap() const                  { return state_before() != NULL; }
 786   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 787 
 788   virtual intx hash() const;
 789   virtual bool is_equal(Value v) const;
 790 
 791   virtual ciType* exact_type() const;
 792 
 793   enum CompareResult { not_comparable = -1, cond_false, cond_true };
 794 
 795   virtual CompareResult compare(Instruction::Condition condition, Value right) const;
 796   BlockBegin* compare(Instruction::Condition cond, Value right,
 797                       BlockBegin* true_sux, BlockBegin* false_sux) const {
 798     switch (compare(cond, right)) {
 799     case not_comparable:
 800       return NULL;
 801     case cond_false:
 802       return false_sux;
 803     case cond_true:
 804       return true_sux;
 805     default:
 806       ShouldNotReachHere();
 807       return NULL;
 808     }
 809   }
 810 };
 811 
 812 
 813 BASE(AccessField, Instruction)
 814  private:
 815   Value       _obj;
 816   int         _offset;
 817   ciField*    _field;
 818   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 819 
 820  public:
 821   // creation
 822   AccessField(Value obj, int offset, ciField* field, bool is_static,
 823               ValueStack* state_before, bool needs_patching)
 824   : Instruction(as_ValueType(field-&gt;type()-&gt;basic_type()), state_before)
 825   , _obj(obj)
 826   , _offset(offset)
 827   , _field(field)
 828   , _explicit_null_check(NULL)
 829   {
 830     set_needs_null_check(!is_static);
 831     set_flag(IsStaticFlag, is_static);
 832     set_flag(NeedsPatchingFlag, needs_patching);
 833     ASSERT_VALUES
 834     // pin of all instructions with memory access
 835     pin();
 836   }
 837 
 838   // accessors
 839   Value obj() const                              { return _obj; }
 840   int offset() const                             { return _offset; }
 841   ciField* field() const                         { return _field; }
 842   BasicType field_type() const                   { return _field-&gt;type()-&gt;basic_type(); }
 843   bool is_static() const                         { return check_flag(IsStaticFlag); }
 844   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 845   bool needs_patching() const                    { return check_flag(NeedsPatchingFlag); }
 846 
 847   // Unresolved getstatic and putstatic can cause initialization.
 848   // Technically it occurs at the Constant that materializes the base
 849   // of the static fields but it&#39;s simpler to model it here.
 850   bool is_init_point() const                     { return is_static() &amp;&amp; (needs_patching() || !_field-&gt;holder()-&gt;is_initialized()); }
 851 
 852   // manipulation
 853 
 854   // Under certain circumstances, if a previous NullCheck instruction
 855   // proved the target object non-null, we can eliminate the explicit
 856   // null check and do an implicit one, simply specifying the debug
 857   // information from the NullCheck. This field should only be consulted
 858   // if needs_null_check() is true.
 859   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 860 
 861   // generic
 862   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 863   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 864 };
 865 
 866 
 867 LEAF(LoadField, AccessField)
 868  public:
 869   // creation
 870   LoadField(Value obj, int offset, ciField* field, bool is_static,
 871             ValueStack* state_before, bool needs_patching,
 872             ciInlineKlass* inline_klass = NULL, Value default_value = NULL )
 873   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 874   {
 875     set_null_free(field-&gt;signature()-&gt;is_Q_signature());
 876   }
 877 
 878   ciType* declared_type() const;
 879 
 880   // generic; cannot be eliminated if needs patching or if volatile.
 881   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 882 };
 883 
 884 
 885 LEAF(StoreField, AccessField)
 886  private:
 887   Value _value;
 888 
 889  public:
 890   // creation
 891   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 892              ValueStack* state_before, bool needs_patching);
 893 
 894   // accessors
 895   Value value() const                            { return _value; }
 896   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 897 
 898   // generic
 899   virtual void input_values_do(ValueVisitor* f)   { AccessField::input_values_do(f); f-&gt;visit(&amp;_value); }
 900 };
 901 
 902 
 903 BASE(AccessArray, Instruction)
 904  private:
 905   Value       _array;
 906 
 907  public:
 908   // creation
 909   AccessArray(ValueType* type, Value array, ValueStack* state_before)
 910   : Instruction(type, state_before)
 911   , _array(array)
 912   {
 913     set_needs_null_check(true);
 914     ASSERT_VALUES
 915     pin(); // instruction with side effect (null exception or range check throwing)
 916   }
 917 
 918   Value array() const                            { return _array; }
 919 
 920   // generic
 921   virtual bool can_trap() const                  { return needs_null_check(); }
 922   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_array); }
 923 };
 924 
 925 
 926 LEAF(ArrayLength, AccessArray)
 927  private:
 928   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 929 
 930  public:
 931   // creation
 932   ArrayLength(Value array, ValueStack* state_before)
 933   : AccessArray(intType, array, state_before)
 934   , _explicit_null_check(NULL) {}
 935 
 936   // accessors
 937   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 938 
 939   // setters
 940   // See LoadField::set_explicit_null_check for documentation
 941   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 942 
 943   // generic
 944   HASHING1(ArrayLength, true, array()-&gt;subst())
 945 };
 946 
 947 
 948 BASE(AccessIndexed, AccessArray)
 949  private:
 950   Value     _index;
 951   Value     _length;
 952   BasicType _elt_type;
 953   bool      _mismatched;
 954   ciMethod* _profiled_method;
 955   int       _profiled_bci;
 956 
 957  public:
 958   // creation
 959   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 960   : AccessArray(as_ValueType(elt_type), array, state_before)
 961   , _index(index)
 962   , _length(length)
 963   , _elt_type(elt_type)
 964   , _mismatched(mismatched)
 965   , _profiled_method(NULL), _profiled_bci(0)
 966   {
 967     set_flag(Instruction::NeedsRangeCheckFlag, true);
 968     ASSERT_VALUES
 969   }
 970 
 971   // accessors
 972   Value index() const                            { return _index; }
 973   Value length() const                           { return _length; }
 974   BasicType elt_type() const                     { return _elt_type; }
 975   bool mismatched() const                        { return _mismatched; }
 976 
 977   void clear_length()                            { _length = NULL; }
 978   // perform elimination of range checks involving constants
 979   bool compute_needs_range_check();
 980 
 981   // Helpers for MethodData* profiling
 982   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
 983   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
 984   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
 985   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
 986   ciMethod* profiled_method() const                  { return _profiled_method;     }
 987   int       profiled_bci() const                     { return _profiled_bci;        }
 988 
 989 
 990 // generic
 991   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 992 };
 993 
 994 
 995 LEAF(LoadIndexed, AccessIndexed)
 996  private:
 997   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 998   NewInlineTypeInstance* _vt;
 999 
1000  public:
1001   // creation
1002   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
1003   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1004   , _explicit_null_check(NULL), _vt(NULL) {}
1005 
1006   // accessors
1007   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
1008 
1009   // setters
1010   // See LoadField::set_explicit_null_check for documentation
1011   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1012 
1013   ciType* exact_type() const;
1014   ciType* declared_type() const;
1015 
1016   NewInlineTypeInstance* vt() const { return _vt; }
1017   void set_vt(NewInlineTypeInstance* vt) { _vt = vt; }
1018 
1019   // generic
1020   HASHING4(LoadIndexed, !should_profile(), type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst(), vt())
1021 };
1022 
1023 
1024 LEAF(StoreIndexed, AccessIndexed)
1025  private:
1026   Value       _value;
1027 
1028   bool      _check_boolean;
1029 
1030  public:
1031   // creation
1032   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
1033                bool check_boolean, bool mismatched = false);
1034 
1035   // accessors
1036   Value value() const                            { return _value; }
1037   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
1038   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
1039   bool check_boolean() const                     { return _check_boolean; }
1040 
1041   // Flattened array support
1042   bool is_exact_flattened_array_store() const;
1043   // generic
1044   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1045 };
1046 
1047 
1048 LEAF(NegateOp, Instruction)
1049  private:
1050   Value _x;
1051 
1052  public:
1053   // creation
1054   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1055     ASSERT_VALUES
1056   }
1057 
1058   // accessors
1059   Value x() const                                { return _x; }
1060 
1061   // generic
1062   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
1063 };
1064 
1065 
1066 BASE(Op2, Instruction)
1067  private:
1068   Bytecodes::Code _op;
1069   Value           _x;
1070   Value           _y;
1071 
1072  public:
1073   // creation
1074   Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)
1075   : Instruction(type, state_before)
1076   , _op(op)
1077   , _x(x)
1078   , _y(y)
1079   {
1080     ASSERT_VALUES
1081   }
1082 
1083   // accessors
1084   Bytecodes::Code op() const                     { return _op; }
1085   Value x() const                                { return _x; }
1086   Value y() const                                { return _y; }
1087 
1088   // manipulators
1089   void swap_operands() {
1090     assert(is_commutative(), &quot;operation must be commutative&quot;);
1091     Value t = _x; _x = _y; _y = t;
1092   }
1093 
1094   // generic
1095   virtual bool is_commutative() const            { return false; }
1096   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1097 };
1098 
1099 
1100 LEAF(ArithmeticOp, Op2)
1101  public:
1102   // creation
1103   ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)
1104   : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y, state_before)
1105   {
1106     set_flag(IsStrictfpFlag, is_strictfp);
1107     if (can_trap()) pin();
1108   }
1109 
1110   // accessors
1111   bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }
1112 
1113   // generic
1114   virtual bool is_commutative() const;
1115   virtual bool can_trap() const;
1116   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1117 };
1118 
1119 
1120 LEAF(ShiftOp, Op2)
1121  public:
1122   // creation
1123   ShiftOp(Bytecodes::Code op, Value x, Value s) : Op2(x-&gt;type()-&gt;base(), op, x, s) {}
1124 
1125   // generic
1126   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1127 };
1128 
1129 
1130 LEAF(LogicOp, Op2)
1131  public:
1132   // creation
1133   LogicOp(Bytecodes::Code op, Value x, Value y) : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y) {}
1134 
1135   // generic
1136   virtual bool is_commutative() const;
1137   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1138 };
1139 
1140 
1141 LEAF(CompareOp, Op2)
1142  public:
1143   // creation
1144   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1145   : Op2(intType, op, x, y, state_before)
1146   {}
1147 
1148   // generic
1149   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1150 };
1151 
1152 
1153 LEAF(IfOp, Op2)
1154  private:
1155   Value _tval;
1156   Value _fval;
1157   bool _substitutability_check;
1158 
1159  public:
1160   // creation
1161   IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)
1162   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1163   , _tval(tval)
1164   , _fval(fval)
1165   , _substitutability_check(substitutability_check)
1166   {
1167     ASSERT_VALUES
1168     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1169     set_state_before(state_before);
1170   }
1171 
1172   // accessors
1173   virtual bool is_commutative() const;
1174   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1175   Condition cond() const                         { return (Condition)Op2::op(); }
1176   Value tval() const                             { return _tval; }
1177   Value fval() const                             { return _fval; }
1178   bool substitutability_check() const             { return _substitutability_check; }
1179   // generic
1180   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1181 };
1182 
1183 
1184 LEAF(Convert, Instruction)
1185  private:
1186   Bytecodes::Code _op;
1187   Value           _value;
1188 
1189  public:
1190   // creation
1191   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1192     ASSERT_VALUES
1193   }
1194 
1195   // accessors
1196   Bytecodes::Code op() const                     { return _op; }
1197   Value value() const                            { return _value; }
1198 
1199   // generic
1200   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_value); }
1201   HASHING2(Convert, true, op(), value()-&gt;subst())
1202 };
1203 
1204 
1205 LEAF(NullCheck, Instruction)
1206  private:
1207   Value       _obj;
1208 
1209  public:
1210   // creation
1211   NullCheck(Value obj, ValueStack* state_before)
1212   : Instruction(obj-&gt;type()-&gt;base(), state_before)
1213   , _obj(obj)
1214   {
1215     ASSERT_VALUES
1216     set_can_trap(true);
1217     assert(_obj-&gt;type()-&gt;is_object(), &quot;null check must be applied to objects only&quot;);
1218     pin(Instruction::PinExplicitNullCheck);
1219   }
1220 
1221   // accessors
1222   Value obj() const                              { return _obj; }
1223 
1224   // setters
1225   void set_can_trap(bool can_trap)               { set_flag(CanTrapFlag, can_trap); }
1226 
1227   // generic
1228   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); /* null-check elimination sets to false */ }
1229   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
1230   HASHING1(NullCheck, true, obj()-&gt;subst())
1231 };
1232 
1233 
1234 // This node is supposed to cast the type of another node to a more precise
1235 // declared type.
1236 LEAF(TypeCast, Instruction)
1237  private:
1238   ciType* _declared_type;
1239   Value   _obj;
1240 
1241  public:
1242   // The type of this node is the same type as the object type (and it might be constant).
1243   TypeCast(ciType* type, Value obj, ValueStack* state_before)
1244   : Instruction(obj-&gt;type(), state_before, obj-&gt;type()-&gt;is_constant()),
1245     _declared_type(type),
1246     _obj(obj) {}
1247 
1248   // accessors
1249   ciType* declared_type() const                  { return _declared_type; }
1250   Value   obj() const                            { return _obj; }
1251 
1252   // generic
1253   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_obj); }
1254 };
1255 
1256 
1257 BASE(StateSplit, Instruction)
1258  private:
1259   ValueStack* _state;
1260 
1261  protected:
1262   static void substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block);
1263 
1264  public:
1265   // creation
1266   StateSplit(ValueType* type, ValueStack* state_before = NULL)
1267   : Instruction(type, state_before)
1268   , _state(NULL)
1269   {
1270     pin(PinStateSplitConstructor);
1271   }
1272 
1273   // accessors
1274   ValueStack* state() const                      { return _state; }
1275   IRScope* scope() const;                        // the state&#39;s scope
1276 
1277   // manipulation
1278   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1279 
1280   // generic
1281   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1282   virtual void state_values_do(ValueVisitor* f);
1283 };
1284 
1285 
1286 LEAF(Invoke, StateSplit)
1287  private:
1288   Bytecodes::Code _code;
1289   Value           _recv;
1290   Values*         _args;
1291   BasicTypeList*  _signature;
1292   int             _vtable_index;
1293   ciMethod*       _target;
1294 
1295  public:
1296   // creation
1297   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
1298          int vtable_index, ciMethod* target, ValueStack* state_before, bool null_free);
1299 
1300   // accessors
1301   Bytecodes::Code code() const                   { return _code; }
1302   Value receiver() const                         { return _recv; }
1303   bool has_receiver() const                      { return receiver() != NULL; }
1304   int number_of_arguments() const                { return _args-&gt;length(); }
1305   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1306   int vtable_index() const                       { return _vtable_index; }
1307   BasicTypeList* signature() const               { return _signature; }
1308   ciMethod* target() const                       { return _target; }
1309 
1310   ciType* declared_type() const;
1311 
1312   // Returns false if target is not loaded
1313   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1314   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1315   // Returns false if target is not loaded
1316   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1317 
1318   // JSR 292 support
1319   bool is_invokedynamic() const                  { return code() == Bytecodes::_invokedynamic; }
1320   bool is_method_handle_intrinsic() const        { return target()-&gt;is_method_handle_intrinsic(); }
1321 
1322   virtual bool needs_exception_state() const     { return false; }
1323 
1324   // generic
1325   virtual bool can_trap() const                  { return true; }
1326   virtual void input_values_do(ValueVisitor* f) {
1327     StateSplit::input_values_do(f);
1328     if (has_receiver()) f-&gt;visit(&amp;_recv);
1329     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1330   }
1331   virtual void state_values_do(ValueVisitor *f);
1332 };
1333 
1334 
1335 LEAF(NewInstance, StateSplit)
1336  private:
1337   ciInstanceKlass* _klass;
1338   bool _is_unresolved;
1339 
1340  public:
1341   // creation
1342   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1343   : StateSplit(instanceType, state_before)
1344   , _klass(klass), _is_unresolved(is_unresolved)
1345   {}
1346 
1347   // accessors
1348   ciInstanceKlass* klass() const                 { return _klass; }
1349   bool is_unresolved() const                     { return _is_unresolved; }
1350 
1351   virtual bool needs_exception_state() const     { return false; }
1352 
1353   // generic
1354   virtual bool can_trap() const                  { return true; }
1355   ciType* exact_type() const;
1356   ciType* declared_type() const;
1357 };
1358 
1359 LEAF(NewInlineTypeInstance, StateSplit)
1360   bool _is_unresolved;
1361   ciInlineKlass* _klass;
1362   Value _depends_on;      // Link to instance on with withfield was called on
1363   bool _is_optimizable_for_withfield;
1364   bool _in_larval_state;
1365   int _first_local_index;
1366   int _on_stack_count;
1367 public:
1368 
1369   // Default creation, always allocated for now
1370   NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)
1371   : StateSplit(instanceType, state_before)
1372    , _is_unresolved(is_unresolved)
1373    , _klass(klass)
1374    , _is_optimizable_for_withfield(from_default_value)
1375    , _in_larval_state(true)
1376    , _first_local_index(-1)
1377    , _on_stack_count(1)
1378   {
1379     if (depends_on == NULL) {
1380       _depends_on = this;
1381     } else {
1382       _depends_on = depends_on;
1383     }
1384     set_null_free(true);
1385   }
1386 
1387   // accessors
1388   bool is_unresolved() const                     { return _is_unresolved; }
1389   Value depends_on();
1390 
1391   ciInlineKlass* klass() const { return _klass; }
1392 
1393   virtual bool needs_exception_state() const     { return false; }
1394 
1395   // generic
1396   virtual bool can_trap() const                  { return true; }
1397   ciType* exact_type() const;
1398   ciType* declared_type() const;
1399 
1400   // Only done in LIR Generator -&gt; map everything to object
1401   void set_to_object_type() { set_type(instanceType); }
1402 
1403   // withfield optimization
1404   virtual void set_escaped() {
1405     _is_optimizable_for_withfield = false;
1406   }
1407   virtual void set_local_index(int index) {
1408     if (_first_local_index != index) {
1409       if (_first_local_index == -1) {
1410         _first_local_index = index;
1411       } else {
1412         set_not_larva_anymore();
1413       }
1414     }
1415   }
1416 
1417   virtual bool in_larval_state() const { return _in_larval_state; }
<a name="1" id="anc1"></a><span class="line-modified">1418   virtual void set_not_larva_anymore() { _in_larval_state = false; }</span>

1419 
1420   virtual int on_stack_count() { return _on_stack_count; }
1421   virtual void increment_on_stack_count() { _on_stack_count++; }
1422   virtual void decrement_on_stack_count() { _on_stack_count--; }
1423 
<a name="2" id="anc2"></a><span class="line-modified">1424   void update_larval_state() {</span>
<span class="line-modified">1425     set_not_larva_anymore();</span>


1426   }
1427 
<a name="3" id="anc3"></a><span class="line-modified">1428   void update_stack_count() {</span>
<span class="line-modified">1429     if (in_larval_state()) {</span>
<span class="line-modified">1430       decrement_on_stack_count();</span>
1431     }
1432   }
1433 
1434 };
1435 
1436 BASE(NewArray, StateSplit)
1437  private:
1438   Value       _length;
1439 
1440  public:
1441   // creation
1442   NewArray(Value length, ValueStack* state_before)
1443   : StateSplit(objectType, state_before)
1444   , _length(length)
1445   {
1446     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1447   }
1448 
1449   // accessors
1450   Value length() const                           { return _length; }
1451 
1452   virtual bool needs_exception_state() const     { return false; }
1453 
1454   ciType* exact_type() const                     { return NULL; }
1455   ciType* declared_type() const;
1456 
1457   // generic
1458   virtual bool can_trap() const                  { return true; }
1459   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_length); }
1460 };
1461 
1462 
1463 LEAF(NewTypeArray, NewArray)
1464  private:
1465   BasicType _elt_type;
1466 
1467  public:
1468   // creation
1469   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1470   : NewArray(length, state_before)
1471   , _elt_type(elt_type)
1472   {}
1473 
1474   // accessors
1475   BasicType elt_type() const                     { return _elt_type; }
1476   ciType* exact_type() const;
1477 };
1478 
1479 
1480 LEAF(NewObjectArray, NewArray)
1481  private:
1482   ciKlass* _klass;
1483 
1484  public:
1485   // creation
1486   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool null_free)
1487   : NewArray(length, state_before), _klass(klass) {
1488     set_null_free(null_free);
1489   }
1490 
1491   // accessors
1492   ciKlass* klass() const                         { return _klass; }
1493   ciType* exact_type() const;
1494 };
1495 
1496 
1497 LEAF(NewMultiArray, NewArray)
1498  private:
1499   ciKlass* _klass;
1500   Values*  _dims;
1501 
1502  public:
1503   // creation
1504   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1505     ASSERT_VALUES
1506   }
1507 
1508   // accessors
1509   ciKlass* klass() const                         { return _klass; }
1510   Values* dims() const                           { return _dims; }
1511   int rank() const                               { return dims()-&gt;length(); }
1512 
1513   // generic
1514   virtual void input_values_do(ValueVisitor* f) {
1515     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1516     // is meaningless for a multi-dimensional array; passing the
1517     // zeroth element down to NewArray as its length is a bad idea
1518     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1519     // get updated, and the value must not be traversed twice. Was bug
1520     // - kbr 4/10/2001
1521     StateSplit::input_values_do(f);
1522     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1523   }
1524 
1525   ciType* exact_type() const;
1526 };
1527 
1528 LEAF(WithField, StateSplit)
1529  public:
1530   // creation
1531   WithField(ValueStack* state_before)
1532   : StateSplit(objectType, state_before) {}
1533 };
1534 
1535 LEAF(DefaultValue, StateSplit)
1536  public:
1537   // creation
1538   DefaultValue(ValueStack* state_before)
1539   : StateSplit(objectType, state_before) {}
1540 };
1541 
1542 BASE(TypeCheck, StateSplit)
1543  private:
1544   ciKlass*    _klass;
1545   Value       _obj;
1546 
1547   ciMethod* _profiled_method;
1548   int       _profiled_bci;
1549 
1550  public:
1551   // creation
1552   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1553   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1554     _profiled_method(NULL), _profiled_bci(0) {
1555     ASSERT_VALUES
1556     set_direct_compare(false);
1557   }
1558 
1559   // accessors
1560   ciKlass* klass() const                         { return _klass; }
1561   Value obj() const                              { return _obj; }
1562   bool is_loaded() const                         { return klass() != NULL; }
1563   bool direct_compare() const                    { return check_flag(DirectCompareFlag); }
1564 
1565   // manipulation
1566   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1567 
1568   // generic
1569   virtual bool can_trap() const                  { return true; }
1570   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1571 
1572   // Helpers for MethodData* profiling
1573   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1574   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1575   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1576   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1577   ciMethod* profiled_method() const                  { return _profiled_method;     }
1578   int       profiled_bci() const                     { return _profiled_bci;        }
1579 };
1580 
1581 
1582 LEAF(CheckCast, TypeCheck)
1583  public:
1584   // creation
1585   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool null_free = false)
1586   : TypeCheck(klass, obj, objectType, state_before) {
1587     set_null_free(null_free);
1588   }
1589 
1590   void set_incompatible_class_change_check() {
1591     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1592   }
1593   bool is_incompatible_class_change_check() const {
1594     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1595   }
1596   void set_invokespecial_receiver_check() {
1597     set_flag(InvokeSpecialReceiverCheckFlag, true);
1598   }
1599   bool is_invokespecial_receiver_check() const {
1600     return check_flag(InvokeSpecialReceiverCheckFlag);
1601   }
1602 
1603   virtual bool needs_exception_state() const {
1604     return !is_invokespecial_receiver_check();
1605   }
1606 
1607   ciType* declared_type() const;
1608 };
1609 
1610 
1611 LEAF(InstanceOf, TypeCheck)
1612  public:
1613   // creation
1614   InstanceOf(ciKlass* klass, Value obj, ValueStack* state_before) : TypeCheck(klass, obj, intType, state_before) {}
1615 
1616   virtual bool needs_exception_state() const     { return false; }
1617 };
1618 
1619 
1620 BASE(AccessMonitor, StateSplit)
1621  private:
1622   Value       _obj;
1623   int         _monitor_no;
1624 
1625  public:
1626   // creation
1627   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1628   : StateSplit(illegalType, state_before)
1629   , _obj(obj)
1630   , _monitor_no(monitor_no)
1631   {
1632     set_needs_null_check(true);
1633     ASSERT_VALUES
1634   }
1635 
1636   // accessors
1637   Value obj() const                              { return _obj; }
1638   int monitor_no() const                         { return _monitor_no; }
1639 
1640   // generic
1641   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1642 };
1643 
1644 
1645 LEAF(MonitorEnter, AccessMonitor)
1646   bool _maybe_inlinetype;
1647  public:
1648   // creation
1649   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_inlinetype)
1650   : AccessMonitor(obj, monitor_no, state_before)
1651   , _maybe_inlinetype(maybe_inlinetype)
1652   {
1653     ASSERT_VALUES
1654   }
1655 
1656   // accessors
1657   bool maybe_inlinetype() const                   { return _maybe_inlinetype; }
1658 
1659   // generic
1660   virtual bool can_trap() const                  { return true; }
1661 };
1662 
1663 
1664 LEAF(MonitorExit, AccessMonitor)
1665  public:
1666   // creation
1667   MonitorExit(Value obj, int monitor_no)
1668   : AccessMonitor(obj, monitor_no, NULL)
1669   {
1670     ASSERT_VALUES
1671   }
1672 };
1673 
1674 
1675 LEAF(Intrinsic, StateSplit)
1676  private:
1677   vmIntrinsics::ID _id;
1678   Values*          _args;
1679   Value            _recv;
1680   ArgsNonNullState _nonnull_state;
1681 
1682  public:
1683   // preserves_state can be set to true for Intrinsics
1684   // which are guaranteed to preserve register state across any slow
1685   // cases; setting it to true does not mean that the Intrinsic can
1686   // not trap, only that if we continue execution in the same basic
1687   // block after the Intrinsic, all of the registers are intact. This
1688   // allows load elimination and common expression elimination to be
1689   // performed across the Intrinsic.  The default value is false.
1690   Intrinsic(ValueType* type,
1691             vmIntrinsics::ID id,
1692             Values* args,
1693             bool has_receiver,
1694             ValueStack* state_before,
1695             bool preserves_state,
1696             bool cantrap = true)
1697   : StateSplit(type, state_before)
1698   , _id(id)
1699   , _args(args)
1700   , _recv(NULL)
1701   {
1702     assert(args != NULL, &quot;args must exist&quot;);
1703     ASSERT_VALUES
1704     set_flag(PreservesStateFlag, preserves_state);
1705     set_flag(CanTrapFlag,        cantrap);
1706     if (has_receiver) {
1707       _recv = argument_at(0);
1708     }
1709     set_needs_null_check(has_receiver);
1710 
1711     // some intrinsics can&#39;t trap, so don&#39;t force them to be pinned
1712     if (!can_trap() &amp;&amp; !vmIntrinsics::should_be_pinned(_id)) {
1713       unpin(PinStateSplitConstructor);
1714     }
1715   }
1716 
1717   // accessors
1718   vmIntrinsics::ID id() const                    { return _id; }
1719   int number_of_arguments() const                { return _args-&gt;length(); }
1720   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1721 
1722   bool has_receiver() const                      { return (_recv != NULL); }
1723   Value receiver() const                         { assert(has_receiver(), &quot;must have receiver&quot;); return _recv; }
1724   bool preserves_state() const                   { return check_flag(PreservesStateFlag); }
1725 
1726   bool arg_needs_null_check(int i) const {
1727     return _nonnull_state.arg_needs_null_check(i);
1728   }
1729 
1730   void set_arg_needs_null_check(int i, bool check) {
1731     _nonnull_state.set_arg_needs_null_check(i, check);
1732   }
1733 
1734   // generic
1735   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); }
1736   virtual void input_values_do(ValueVisitor* f) {
1737     StateSplit::input_values_do(f);
1738     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1739   }
1740 };
1741 
1742 
1743 class LIR_List;
1744 
1745 LEAF(BlockBegin, StateSplit)
1746  private:
1747   int        _block_id;                          // the unique block id
1748   int        _bci;                               // start-bci of block
1749   int        _depth_first_number;                // number of this block in a depth-first ordering
1750   int        _linear_scan_number;                // number of this block in linear-scan ordering
1751   int        _dominator_depth;
1752   int        _loop_depth;                        // the loop nesting level of this block
1753   int        _loop_index;                        // number of the innermost loop of this block
1754   int        _flags;                             // the flags associated with this block
1755 
1756   // fields used by BlockListBuilder
1757   int            _total_preds;                   // number of predecessors found by BlockListBuilder
1758   ResourceBitMap _stores_to_locals;              // bit is set when a local variable is stored in the block
1759 
1760   // SSA specific fields: (factor out later)
1761   BlockList   _successors;                       // the successors of this block
1762   BlockList   _predecessors;                     // the predecessors of this block
1763   BlockList   _dominates;                        // list of blocks that are dominated by this block
1764   BlockBegin* _dominator;                        // the dominator of this block
1765   // SSA specific ends
1766   BlockEnd*  _end;                               // the last instruction of this block
1767   BlockList  _exception_handlers;                // the exception handlers potentially invoked by this block
1768   ValueStackStack* _exception_states;            // only for xhandler entries: states of all instructions that have an edge to this xhandler
1769   int        _exception_handler_pco;             // if this block is the start of an exception handler,
1770                                                  // this records the PC offset in the assembly code of the
1771                                                  // first instruction in this block
1772   Label      _label;                             // the label associated with this block
1773   LIR_List*  _lir;                               // the low level intermediate representation for this block
1774 
1775   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1776   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1777   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1778   ResourceBitMap _live_kill;                     // set of registers defined in this block
1779 
1780   ResourceBitMap _fpu_register_usage;
1781   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1782   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1783   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1784 
1785   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1786   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1787 
1788   friend class SuxAndWeightAdjuster;
1789 
1790  public:
1791    void* operator new(size_t size) throw() {
1792     Compilation* c = Compilation::current();
1793     void* res = c-&gt;arena()-&gt;Amalloc(size);
1794     return res;
1795   }
1796 
1797   // initialization/counting
1798   static int  number_of_blocks() {
1799     return Compilation::current()-&gt;number_of_blocks();
1800   }
1801 
1802   // creation
1803   BlockBegin(int bci)
1804   : StateSplit(illegalType)
1805   , _block_id(Compilation::current()-&gt;get_next_block_id())
1806   , _bci(bci)
1807   , _depth_first_number(-1)
1808   , _linear_scan_number(-1)
1809   , _dominator_depth(-1)
1810   , _loop_depth(0)
1811   , _loop_index(-1)
1812   , _flags(0)
1813   , _total_preds(0)
1814   , _stores_to_locals()
1815   , _successors(2)
1816   , _predecessors(2)
1817   , _dominates(2)
1818   , _dominator(NULL)
1819   , _end(NULL)
1820   , _exception_handlers(1)
1821   , _exception_states(NULL)
1822   , _exception_handler_pco(-1)
1823   , _lir(NULL)
1824   , _live_in()
1825   , _live_out()
1826   , _live_gen()
1827   , _live_kill()
1828   , _fpu_register_usage()
1829   , _fpu_stack_state(NULL)
1830   , _first_lir_instruction_id(-1)
1831   , _last_lir_instruction_id(-1)
1832   {
1833     _block = this;
1834 #ifndef PRODUCT
1835     set_printable_bci(bci);
1836 #endif
1837   }
1838 
1839   // accessors
1840   int block_id() const                           { return _block_id; }
1841   int bci() const                                { return _bci; }
1842   BlockList* successors()                        { return &amp;_successors; }
1843   BlockList* dominates()                         { return &amp;_dominates; }
1844   BlockBegin* dominator() const                  { return _dominator; }
1845   int loop_depth() const                         { return _loop_depth; }
1846   int dominator_depth() const                    { return _dominator_depth; }
1847   int depth_first_number() const                 { return _depth_first_number; }
1848   int linear_scan_number() const                 { return _linear_scan_number; }
1849   BlockEnd* end() const                          { return _end; }
1850   Label* label()                                 { return &amp;_label; }
1851   LIR_List* lir() const                          { return _lir; }
1852   int exception_handler_pco() const              { return _exception_handler_pco; }
1853   ResourceBitMap&amp; live_in()                      { return _live_in;        }
1854   ResourceBitMap&amp; live_out()                     { return _live_out;       }
1855   ResourceBitMap&amp; live_gen()                     { return _live_gen;       }
1856   ResourceBitMap&amp; live_kill()                    { return _live_kill;      }
1857   ResourceBitMap&amp; fpu_register_usage()           { return _fpu_register_usage; }
1858   intArray* fpu_stack_state() const              { return _fpu_stack_state;    }
1859   int first_lir_instruction_id() const           { return _first_lir_instruction_id; }
1860   int last_lir_instruction_id() const            { return _last_lir_instruction_id; }
1861   int total_preds() const                        { return _total_preds; }
1862   BitMap&amp; stores_to_locals()                     { return _stores_to_locals; }
1863 
1864   // manipulation
1865   void set_dominator(BlockBegin* dom)            { _dominator = dom; }
1866   void set_loop_depth(int d)                     { _loop_depth = d; }
1867   void set_dominator_depth(int d)                { _dominator_depth = d; }
1868   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
1869   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
1870   void set_end(BlockEnd* end);
1871   void clear_end();
1872   void disconnect_from_graph();
1873   static void disconnect_edge(BlockBegin* from, BlockBegin* to);
1874   BlockBegin* insert_block_between(BlockBegin* sux);
1875   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1876   void set_lir(LIR_List* lir)                    { _lir = lir; }
1877   void set_exception_handler_pco(int pco)        { _exception_handler_pco = pco; }
1878   void set_live_in  (const ResourceBitMap&amp; map)  { _live_in = map;   }
1879   void set_live_out (const ResourceBitMap&amp; map)  { _live_out = map;  }
1880   void set_live_gen (const ResourceBitMap&amp; map)  { _live_gen = map;  }
1881   void set_live_kill(const ResourceBitMap&amp; map)  { _live_kill = map; }
1882   void set_fpu_register_usage(const ResourceBitMap&amp; map) { _fpu_register_usage = map; }
1883   void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }
1884   void set_first_lir_instruction_id(int id)      { _first_lir_instruction_id = id;  }
1885   void set_last_lir_instruction_id(int id)       { _last_lir_instruction_id = id;  }
1886   void increment_total_preds(int n = 1)          { _total_preds += n; }
1887   void init_stores_to_locals(int locals_count)   { _stores_to_locals.initialize(locals_count); }
1888 
1889   // generic
1890   virtual void state_values_do(ValueVisitor* f);
1891 
1892   // successors and predecessors
1893   int number_of_sux() const;
1894   BlockBegin* sux_at(int i) const;
1895   void add_successor(BlockBegin* sux);
1896   void remove_successor(BlockBegin* pred);
1897   bool is_successor(BlockBegin* sux) const       { return _successors.contains(sux); }
1898 
1899   void add_predecessor(BlockBegin* pred);
1900   void remove_predecessor(BlockBegin* pred);
1901   bool is_predecessor(BlockBegin* pred) const    { return _predecessors.contains(pred); }
1902   int number_of_preds() const                    { return _predecessors.length(); }
1903   BlockBegin* pred_at(int i) const               { return _predecessors.at(i); }
1904 
1905   // exception handlers potentially invoked by this block
1906   void add_exception_handler(BlockBegin* b);
1907   bool is_exception_handler(BlockBegin* b) const { return _exception_handlers.contains(b); }
1908   int  number_of_exception_handlers() const      { return _exception_handlers.length(); }
1909   BlockBegin* exception_handler_at(int i) const  { return _exception_handlers.at(i); }
1910 
1911   // states of the instructions that have an edge to this exception handler
1912   int number_of_exception_states()               { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states == NULL ? 0 : _exception_states-&gt;length(); }
1913   ValueStack* exception_state_at(int idx) const  { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states-&gt;at(idx); }
1914   int add_exception_state(ValueStack* state);
1915 
1916   // flags
1917   enum Flag {
1918     no_flag                       = 0,
1919     std_entry_flag                = 1 &lt;&lt; 0,
1920     osr_entry_flag                = 1 &lt;&lt; 1,
1921     exception_entry_flag          = 1 &lt;&lt; 2,
1922     subroutine_entry_flag         = 1 &lt;&lt; 3,
1923     backward_branch_target_flag   = 1 &lt;&lt; 4,
1924     is_on_work_list_flag          = 1 &lt;&lt; 5,
1925     was_visited_flag              = 1 &lt;&lt; 6,
1926     parser_loop_header_flag       = 1 &lt;&lt; 7,  // set by parser to identify blocks where phi functions can not be created on demand
1927     critical_edge_split_flag      = 1 &lt;&lt; 8, // set for all blocks that are introduced when critical edges are split
1928     linear_scan_loop_header_flag  = 1 &lt;&lt; 9, // set during loop-detection for LinearScan
1929     linear_scan_loop_end_flag     = 1 &lt;&lt; 10, // set during loop-detection for LinearScan
1930     donot_eliminate_range_checks  = 1 &lt;&lt; 11  // Should be try to eliminate range checks in this block
1931   };
1932 
1933   void set(Flag f)                               { _flags |= f; }
1934   void clear(Flag f)                             { _flags &amp;= ~f; }
1935   bool is_set(Flag f) const                      { return (_flags &amp; f) != 0; }
1936   bool is_entry_block() const {
1937     const int entry_mask = std_entry_flag | osr_entry_flag | exception_entry_flag;
1938     return (_flags &amp; entry_mask) != 0;
1939   }
1940 
1941   // iteration
1942   void iterate_preorder   (BlockClosure* closure);
1943   void iterate_postorder  (BlockClosure* closure);
1944 
1945   void block_values_do(ValueVisitor* f);
1946 
1947   // loops
1948   void set_loop_index(int ix)                    { _loop_index = ix;        }
1949   int  loop_index() const                        { return _loop_index;      }
1950 
1951   // merging
1952   bool try_merge(ValueStack* state);             // try to merge states at block begin
1953   void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, &quot;merge failed&quot;); }
1954 
1955   // debugging
1956   void print_block()                             PRODUCT_RETURN;
1957   void print_block(InstructionPrinter&amp; ip, bool live_only = false) PRODUCT_RETURN;
1958 };
1959 
1960 
1961 BASE(BlockEnd, StateSplit)
1962  private:
1963   BlockList*  _sux;
1964 
1965  protected:
1966   BlockList* sux() const                         { return _sux; }
1967 
1968   void set_sux(BlockList* sux) {
1969 #ifdef ASSERT
1970     assert(sux != NULL, &quot;sux must exist&quot;);
1971     for (int i = sux-&gt;length() - 1; i &gt;= 0; i--) assert(sux-&gt;at(i) != NULL, &quot;sux must exist&quot;);
1972 #endif
1973     _sux = sux;
1974   }
1975 
1976  public:
1977   // creation
1978   BlockEnd(ValueType* type, ValueStack* state_before, bool is_safepoint)
1979   : StateSplit(type, state_before)
1980   , _sux(NULL)
1981   {
1982     set_flag(IsSafepointFlag, is_safepoint);
1983   }
1984 
1985   // accessors
1986   bool is_safepoint() const                      { return check_flag(IsSafepointFlag); }
1987   // For compatibility with old code, for new code use block()
1988   BlockBegin* begin() const                      { return _block; }
1989 
1990   // manipulation
1991   void set_begin(BlockBegin* begin);
1992 
1993   // successors
1994   int number_of_sux() const                      { return _sux != NULL ? _sux-&gt;length() : 0; }
1995   BlockBegin* sux_at(int i) const                { return _sux-&gt;at(i); }
1996   BlockBegin* default_sux() const                { return sux_at(number_of_sux() - 1); }
1997   BlockBegin** addr_sux_at(int i) const          { return _sux-&gt;adr_at(i); }
1998   int sux_index(BlockBegin* sux) const           { return _sux-&gt;find(sux); }
1999   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
2000 };
2001 
2002 
2003 LEAF(Goto, BlockEnd)
2004  public:
2005   enum Direction {
2006     none,            // Just a regular goto
2007     taken, not_taken // Goto produced from If
2008   };
2009  private:
2010   ciMethod*   _profiled_method;
2011   int         _profiled_bci;
2012   Direction   _direction;
2013  public:
2014   // creation
2015   Goto(BlockBegin* sux, ValueStack* state_before, bool is_safepoint = false)
2016     : BlockEnd(illegalType, state_before, is_safepoint)
2017     , _profiled_method(NULL)
2018     , _profiled_bci(0)
2019     , _direction(none) {
2020     BlockList* s = new BlockList(1);
2021     s-&gt;append(sux);
2022     set_sux(s);
2023   }
2024 
2025   Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)
2026                                            , _profiled_method(NULL)
2027                                            , _profiled_bci(0)
2028                                            , _direction(none) {
2029     BlockList* s = new BlockList(1);
2030     s-&gt;append(sux);
2031     set_sux(s);
2032   }
2033 
2034   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2035   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2036   int profiled_bci() const                       { return _profiled_bci; }
2037   Direction direction() const                    { return _direction; }
2038 
2039   void set_should_profile(bool value)            { set_flag(ProfileMDOFlag, value); }
2040   void set_profiled_method(ciMethod* method)     { _profiled_method = method; }
2041   void set_profiled_bci(int bci)                 { _profiled_bci = bci; }
2042   void set_direction(Direction d)                { _direction = d; }
2043 };
2044 
2045 #ifdef ASSERT
2046 LEAF(Assert, Instruction)
2047   private:
2048   Value       _x;
2049   Condition   _cond;
2050   Value       _y;
2051   char        *_message;
2052 
2053  public:
2054   // creation
2055   // unordered_is_true is valid for float/double compares only
2056    Assert(Value x, Condition cond, bool unordered_is_true, Value y);
2057 
2058   // accessors
2059   Value x() const                                { return _x; }
2060   Condition cond() const                         { return _cond; }
2061   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2062   Value y() const                                { return _y; }
2063   const char *message() const                    { return _message; }
2064 
2065   // generic
2066   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2067 };
2068 #endif
2069 
2070 LEAF(RangeCheckPredicate, StateSplit)
2071  private:
2072   Value       _x;
2073   Condition   _cond;
2074   Value       _y;
2075 
2076   void check_state();
2077 
2078  public:
2079   // creation
2080   // unordered_is_true is valid for float/double compares only
2081    RangeCheckPredicate(Value x, Condition cond, bool unordered_is_true, Value y, ValueStack* state) : StateSplit(illegalType)
2082   , _x(x)
2083   , _cond(cond)
2084   , _y(y)
2085   {
2086     ASSERT_VALUES
2087     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2088     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2089     this-&gt;set_state(state);
2090     check_state();
2091   }
2092 
2093   // Always deoptimize
2094   RangeCheckPredicate(ValueStack* state) : StateSplit(illegalType)
2095   {
2096     this-&gt;set_state(state);
2097     _x = _y = NULL;
2098     check_state();
2099   }
2100 
2101   // accessors
2102   Value x() const                                { return _x; }
2103   Condition cond() const                         { return _cond; }
2104   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2105   Value y() const                                { return _y; }
2106 
2107   void always_fail()                             { _x = _y = NULL; }
2108 
2109   // generic
2110   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2111   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
2112 };
2113 
2114 LEAF(If, BlockEnd)
2115  private:
2116   Value       _x;
2117   Condition   _cond;
2118   Value       _y;
2119   ciMethod*   _profiled_method;
2120   int         _profiled_bci; // Canonicalizer may alter bci of If node
2121   bool        _swapped;      // Is the order reversed with respect to the original If in the
2122                              // bytecode stream?
2123   bool        _substitutability_check;
2124  public:
2125   // creation
2126   // unordered_is_true is valid for float/double compares only
2127   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)
2128     : BlockEnd(illegalType, state_before, is_safepoint)
2129   , _x(x)
2130   , _cond(cond)
2131   , _y(y)
2132   , _profiled_method(NULL)
2133   , _profiled_bci(0)
2134   , _swapped(false)
2135   , _substitutability_check(substitutability_check)
2136   {
2137     ASSERT_VALUES
2138     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2139     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2140     BlockList* s = new BlockList(2);
2141     s-&gt;append(tsux);
2142     s-&gt;append(fsux);
2143     set_sux(s);
2144     if (!_substitutability_check) {
2145       assert(x-&gt;as_NewInlineTypeInstance() == NULL || y-&gt;type() == objectNull, &quot;Sanity check&quot;);
2146       assert(y-&gt;as_NewInlineTypeInstance() == NULL || x-&gt;type() == objectNull, &quot;Sanity check&quot;);
2147     }
2148   }
2149 
2150   // accessors
2151   Value x() const                                { return _x; }
2152   Condition cond() const                         { return _cond; }
2153   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2154   Value y() const                                { return _y; }
2155   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2156   BlockBegin* tsux() const                       { return sux_for(true); }
2157   BlockBegin* fsux() const                       { return sux_for(false); }
2158   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2159   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2160   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2161   int profiled_bci() const                       { return _profiled_bci; }    // set for profiled branches and tiered
2162   bool is_swapped() const                        { return _swapped; }
2163 
2164   // manipulation
2165   void swap_operands() {
2166     Value t = _x; _x = _y; _y = t;
2167     _cond = mirror(_cond);
2168   }
2169 
2170   void swap_sux() {
2171     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2172     BlockList* s = sux();
2173     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2174     _cond = negate(_cond);
2175     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2176   }
2177 
2178   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2179   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2180   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2181   void set_swapped(bool value)                    { _swapped = value;         }
2182   bool substitutability_check() const              { return _substitutability_check; }
2183   // generic
2184   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2185 };
2186 
2187 
2188 LEAF(IfInstanceOf, BlockEnd)
2189  private:
2190   ciKlass* _klass;
2191   Value    _obj;
2192   bool     _test_is_instance;                    // jump if instance
2193   int      _instanceof_bci;
2194 
2195  public:
2196   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2197   : BlockEnd(illegalType, NULL, false) // temporary set to false
2198   , _klass(klass)
2199   , _obj(obj)
2200   , _test_is_instance(test_is_instance)
2201   , _instanceof_bci(instanceof_bci)
2202   {
2203     ASSERT_VALUES
2204     assert(instanceof_bci &gt;= 0, &quot;illegal bci&quot;);
2205     BlockList* s = new BlockList(2);
2206     s-&gt;append(tsux);
2207     s-&gt;append(fsux);
2208     set_sux(s);
2209   }
2210 
2211   // accessors
2212   //
2213   // Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an
2214   //         instance of klass; otherwise it tests if it is *not* and instance
2215   //         of klass.
2216   //
2217   // Note 2: IfInstanceOf instructions are created by combining an InstanceOf
2218   //         and an If instruction. The IfInstanceOf bci() corresponds to the
2219   //         bci that the If would have had; the (this-&gt;) instanceof_bci() is
2220   //         the bci of the original InstanceOf instruction.
2221   ciKlass* klass() const                         { return _klass; }
2222   Value obj() const                              { return _obj; }
2223   int instanceof_bci() const                     { return _instanceof_bci; }
2224   bool test_is_instance() const                  { return _test_is_instance; }
2225   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2226   BlockBegin* tsux() const                       { return sux_for(true); }
2227   BlockBegin* fsux() const                       { return sux_for(false); }
2228 
2229   // manipulation
2230   void swap_sux() {
2231     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2232     BlockList* s = sux();
2233     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2234     _test_is_instance = !_test_is_instance;
2235   }
2236 
2237   // generic
2238   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_obj); }
2239 };
2240 
2241 
2242 BASE(Switch, BlockEnd)
2243  private:
2244   Value       _tag;
2245 
2246  public:
2247   // creation
2248   Switch(Value tag, BlockList* sux, ValueStack* state_before, bool is_safepoint)
2249   : BlockEnd(illegalType, state_before, is_safepoint)
2250   , _tag(tag) {
2251     ASSERT_VALUES
2252     set_sux(sux);
2253   }
2254 
2255   // accessors
2256   Value tag() const                              { return _tag; }
2257   int length() const                             { return number_of_sux() - 1; }
2258 
2259   virtual bool needs_exception_state() const     { return false; }
2260 
2261   // generic
2262   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_tag); }
2263 };
2264 
2265 
2266 LEAF(TableSwitch, Switch)
2267  private:
2268   int _lo_key;
2269 
2270  public:
2271   // creation
2272   TableSwitch(Value tag, BlockList* sux, int lo_key, ValueStack* state_before, bool is_safepoint)
2273     : Switch(tag, sux, state_before, is_safepoint)
2274   , _lo_key(lo_key) { assert(_lo_key &lt;= hi_key(), &quot;integer overflow&quot;); }
2275 
2276   // accessors
2277   int lo_key() const                             { return _lo_key; }
2278   int hi_key() const                             { return _lo_key + (length() - 1); }
2279 };
2280 
2281 
2282 LEAF(LookupSwitch, Switch)
2283  private:
2284   intArray* _keys;
2285 
2286  public:
2287   // creation
2288   LookupSwitch(Value tag, BlockList* sux, intArray* keys, ValueStack* state_before, bool is_safepoint)
2289   : Switch(tag, sux, state_before, is_safepoint)
2290   , _keys(keys) {
2291     assert(keys != NULL, &quot;keys must exist&quot;);
2292     assert(keys-&gt;length() == length(), &quot;sux &amp; keys have incompatible lengths&quot;);
2293   }
2294 
2295   // accessors
2296   int key_at(int i) const                        { return _keys-&gt;at(i); }
2297 };
2298 
2299 
2300 LEAF(Return, BlockEnd)
2301  private:
2302   Value _result;
2303 
2304  public:
2305   // creation
2306   Return(Value result) :
2307     BlockEnd(result == NULL ? voidType : result-&gt;type()-&gt;base(), NULL, true),
2308     _result(result) {}
2309 
2310   // accessors
2311   Value result() const                           { return _result; }
2312   bool has_result() const                        { return result() != NULL; }
2313 
2314   // generic
2315   virtual void input_values_do(ValueVisitor* f) {
2316     BlockEnd::input_values_do(f);
2317     if (has_result()) f-&gt;visit(&amp;_result);
2318   }
2319 };
2320 
2321 
2322 LEAF(Throw, BlockEnd)
2323  private:
2324   Value _exception;
2325 
2326  public:
2327   // creation
2328   Throw(Value exception, ValueStack* state_before) : BlockEnd(illegalType, state_before, true), _exception(exception) {
2329     ASSERT_VALUES
2330   }
2331 
2332   // accessors
2333   Value exception() const                        { return _exception; }
2334 
2335   // generic
2336   virtual bool can_trap() const                  { return true; }
2337   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_exception); }
2338 };
2339 
2340 
2341 LEAF(Base, BlockEnd)
2342  public:
2343   // creation
2344   Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {
2345     assert(std_entry-&gt;is_set(BlockBegin::std_entry_flag), &quot;std entry must be flagged&quot;);
2346     assert(osr_entry == NULL || osr_entry-&gt;is_set(BlockBegin::osr_entry_flag), &quot;osr entry must be flagged&quot;);
2347     BlockList* s = new BlockList(2);
2348     if (osr_entry != NULL) s-&gt;append(osr_entry);
2349     s-&gt;append(std_entry); // must be default sux!
2350     set_sux(s);
2351   }
2352 
2353   // accessors
2354   BlockBegin* std_entry() const                  { return default_sux(); }
2355   BlockBegin* osr_entry() const                  { return number_of_sux() &lt; 2 ? NULL : sux_at(0); }
2356 };
2357 
2358 
2359 LEAF(OsrEntry, Instruction)
2360  public:
2361   // creation
2362 #ifdef _LP64
2363   OsrEntry() : Instruction(longType) { pin(); }
2364 #else
2365   OsrEntry() : Instruction(intType)  { pin(); }
2366 #endif
2367 
2368   // generic
2369   virtual void input_values_do(ValueVisitor* f)   { }
2370 };
2371 
2372 
2373 // Models the incoming exception at a catch site
2374 LEAF(ExceptionObject, Instruction)
2375  public:
2376   // creation
2377   ExceptionObject() : Instruction(objectType) {
2378     pin();
2379   }
2380 
2381   // generic
2382   virtual void input_values_do(ValueVisitor* f)   { }
2383 };
2384 
2385 
2386 // Models needed rounding for floating-point values on Intel.
2387 // Currently only used to represent rounding of double-precision
2388 // values stored into local variables, but could be used to model
2389 // intermediate rounding of single-precision values as well.
2390 LEAF(RoundFP, Instruction)
2391  private:
2392   Value _input;             // floating-point value to be rounded
2393 
2394  public:
2395   RoundFP(Value input)
2396   : Instruction(input-&gt;type()) // Note: should not be used for constants
2397   , _input(input)
2398   {
2399     ASSERT_VALUES
2400   }
2401 
2402   // accessors
2403   Value input() const                            { return _input; }
2404 
2405   // generic
2406   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_input); }
2407 };
2408 
2409 
2410 BASE(UnsafeOp, Instruction)
2411  private:
2412   BasicType _basic_type;    // ValueType can not express byte-sized integers
2413 
2414  protected:
2415   // creation
2416   UnsafeOp(BasicType basic_type, bool is_put)
2417   : Instruction(is_put ? voidType : as_ValueType(basic_type))
2418   , _basic_type(basic_type)
2419   {
2420     //Note:  Unsafe ops are not not guaranteed to throw NPE.
2421     // Convservatively, Unsafe operations must be pinned though we could be
2422     // looser about this if we wanted to..
2423     pin();
2424   }
2425 
2426  public:
2427   // accessors
2428   BasicType basic_type()                         { return _basic_type; }
2429 
2430   // generic
2431   virtual void input_values_do(ValueVisitor* f)   { }
2432 };
2433 
2434 
2435 BASE(UnsafeRawOp, UnsafeOp)
2436  private:
2437   Value _base;                                   // Base address (a Java long)
2438   Value _index;                                  // Index if computed by optimizer; initialized to NULL
2439   int   _log2_scale;                             // Scale factor: 0, 1, 2, or 3.
2440                                                  // Indicates log2 of number of bytes (1, 2, 4, or 8)
2441                                                  // to scale index by.
2442 
2443  protected:
2444   UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)
2445   : UnsafeOp(basic_type, is_put)
2446   , _base(addr)
2447   , _index(NULL)
2448   , _log2_scale(0)
2449   {
2450     // Can not use ASSERT_VALUES because index may be NULL
2451     assert(addr != NULL &amp;&amp; addr-&gt;type()-&gt;is_long(), &quot;just checking&quot;);
2452   }
2453 
2454   UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)
2455   : UnsafeOp(basic_type, is_put)
2456   , _base(base)
2457   , _index(index)
2458   , _log2_scale(log2_scale)
2459   {
2460   }
2461 
2462  public:
2463   // accessors
2464   Value base()                                   { return _base; }
2465   Value index()                                  { return _index; }
2466   bool  has_index()                              { return (_index != NULL); }
2467   int   log2_scale()                             { return _log2_scale; }
2468 
2469   // setters
2470   void set_base (Value base)                     { _base  = base; }
2471   void set_index(Value index)                    { _index = index; }
2472   void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }
2473 
2474   // generic
2475   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2476                                                    f-&gt;visit(&amp;_base);
2477                                                    if (has_index()) f-&gt;visit(&amp;_index); }
2478 };
2479 
2480 
2481 LEAF(UnsafeGetRaw, UnsafeRawOp)
2482  private:
2483  bool _may_be_unaligned, _is_wide;  // For OSREntry
2484 
2485  public:
2486  UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)
2487   : UnsafeRawOp(basic_type, addr, false) {
2488     _may_be_unaligned = may_be_unaligned;
2489     _is_wide = is_wide;
2490   }
2491 
2492  UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)
2493   : UnsafeRawOp(basic_type, base, index, log2_scale, false) {
2494     _may_be_unaligned = may_be_unaligned;
2495     _is_wide = is_wide;
2496   }
2497 
2498   bool may_be_unaligned()                         { return _may_be_unaligned; }
2499   bool is_wide()                                  { return _is_wide; }
2500 };
2501 
2502 
2503 LEAF(UnsafePutRaw, UnsafeRawOp)
2504  private:
2505   Value _value;                                  // Value to be stored
2506 
2507  public:
2508   UnsafePutRaw(BasicType basic_type, Value addr, Value value)
2509   : UnsafeRawOp(basic_type, addr, true)
2510   , _value(value)
2511   {
2512     assert(value != NULL, &quot;just checking&quot;);
2513     ASSERT_VALUES
2514   }
2515 
2516   UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)
2517   : UnsafeRawOp(basic_type, base, index, log2_scale, true)
2518   , _value(value)
2519   {
2520     assert(value != NULL, &quot;just checking&quot;);
2521     ASSERT_VALUES
2522   }
2523 
2524   // accessors
2525   Value value()                                  { return _value; }
2526 
2527   // generic
2528   virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);
2529                                                    f-&gt;visit(&amp;_value); }
2530 };
2531 
2532 
2533 BASE(UnsafeObjectOp, UnsafeOp)
2534  private:
2535   Value _object;                                 // Object to be fetched from or mutated
2536   Value _offset;                                 // Offset within object
2537   bool  _is_volatile;                            // true if volatile - dl/JSR166
2538  public:
2539   UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)
2540     : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)
2541   {
2542   }
2543 
2544   // accessors
2545   Value object()                                 { return _object; }
2546   Value offset()                                 { return _offset; }
2547   bool  is_volatile()                            { return _is_volatile; }
2548   // generic
2549   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2550                                                    f-&gt;visit(&amp;_object);
2551                                                    f-&gt;visit(&amp;_offset); }
2552 };
2553 
2554 
2555 LEAF(UnsafeGetObject, UnsafeObjectOp)
2556  public:
2557   UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)
2558   : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)
2559   {
2560     ASSERT_VALUES
2561   }
2562 };
2563 
2564 
2565 LEAF(UnsafePutObject, UnsafeObjectOp)
2566  private:
2567   Value _value;                                  // Value to be stored
2568  public:
2569   UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)
2570   : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)
2571     , _value(value)
2572   {
2573     ASSERT_VALUES
2574   }
2575 
2576   // accessors
2577   Value value()                                  { return _value; }
2578 
2579   // generic
2580   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2581                                                    f-&gt;visit(&amp;_value); }
2582 };
2583 
2584 LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)
2585  private:
2586   Value _value;                                  // Value to be stored
2587   bool  _is_add;
2588  public:
2589   UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)
2590   : UnsafeObjectOp(basic_type, object, offset, false, false)
2591     , _value(value)
2592     , _is_add(is_add)
2593   {
2594     ASSERT_VALUES
2595   }
2596 
2597   // accessors
2598   bool is_add() const                            { return _is_add; }
2599   Value value()                                  { return _value; }
2600 
2601   // generic
2602   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2603                                                    f-&gt;visit(&amp;_value); }
2604 };
2605 
2606 LEAF(ProfileCall, Instruction)
2607  private:
2608   ciMethod*        _method;
2609   int              _bci_of_invoke;
2610   ciMethod*        _callee;         // the method that is called at the given bci
2611   Value            _recv;
2612   ciKlass*         _known_holder;
2613   Values*          _obj_args;       // arguments for type profiling
2614   ArgsNonNullState _nonnull_state;  // Do we know whether some arguments are never null?
2615   bool             _inlined;        // Are we profiling a call that is inlined
2616 
2617  public:
2618   ProfileCall(ciMethod* method, int bci, ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined)
2619     : Instruction(voidType)
2620     , _method(method)
2621     , _bci_of_invoke(bci)
2622     , _callee(callee)
2623     , _recv(recv)
2624     , _known_holder(known_holder)
2625     , _obj_args(obj_args)
2626     , _inlined(inlined)
2627   {
2628     // The ProfileCall has side-effects and must occur precisely where located
2629     pin();
2630   }
2631 
2632   ciMethod* method()             const { return _method; }
2633   int bci_of_invoke()            const { return _bci_of_invoke; }
2634   ciMethod* callee()             const { return _callee; }
2635   Value recv()                   const { return _recv; }
2636   ciKlass* known_holder()        const { return _known_holder; }
2637   int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args-&gt;length(); }
2638   Value profiled_arg_at(int i)   const { return _obj_args-&gt;at(i); }
2639   bool arg_needs_null_check(int i) const {
2640     return _nonnull_state.arg_needs_null_check(i);
2641   }
2642   bool inlined()                 const { return _inlined; }
2643 
2644   void set_arg_needs_null_check(int i, bool check) {
2645     _nonnull_state.set_arg_needs_null_check(i, check);
2646   }
2647 
2648   virtual void input_values_do(ValueVisitor* f)   {
2649     if (_recv != NULL) {
2650       f-&gt;visit(&amp;_recv);
2651     }
2652     for (int i = 0; i &lt; nb_profiled_args(); i++) {
2653       f-&gt;visit(_obj_args-&gt;adr_at(i));
2654     }
2655   }
2656 };
2657 
2658 LEAF(ProfileReturnType, Instruction)
2659  private:
2660   ciMethod*        _method;
2661   ciMethod*        _callee;
2662   int              _bci_of_invoke;
2663   Value            _ret;
2664 
2665  public:
2666   ProfileReturnType(ciMethod* method, int bci, ciMethod* callee, Value ret)
2667     : Instruction(voidType)
2668     , _method(method)
2669     , _callee(callee)
2670     , _bci_of_invoke(bci)
2671     , _ret(ret)
2672   {
2673     set_needs_null_check(true);
2674     // The ProfileType has side-effects and must occur precisely where located
2675     pin();
2676   }
2677 
2678   ciMethod* method()             const { return _method; }
2679   ciMethod* callee()             const { return _callee; }
2680   int bci_of_invoke()            const { return _bci_of_invoke; }
2681   Value ret()                    const { return _ret; }
2682 
2683   virtual void input_values_do(ValueVisitor* f)   {
2684     if (_ret != NULL) {
2685       f-&gt;visit(&amp;_ret);
2686     }
2687   }
2688 };
2689 
2690 // Call some C runtime function that doesn&#39;t safepoint,
2691 // optionally passing the current thread as the first argument.
2692 LEAF(RuntimeCall, Instruction)
2693  private:
2694   const char* _entry_name;
2695   address     _entry;
2696   Values*     _args;
2697   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
2698 
2699  public:
2700   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
2701     : Instruction(type)
2702     , _entry_name(entry_name)
2703     , _entry(entry)
2704     , _args(args)
2705     , _pass_thread(pass_thread) {
2706     ASSERT_VALUES
2707     pin();
2708   }
2709 
2710   const char* entry_name() const  { return _entry_name; }
2711   address entry() const           { return _entry; }
2712   int number_of_arguments() const { return _args-&gt;length(); }
2713   Value argument_at(int i) const  { return _args-&gt;at(i); }
2714   bool pass_thread() const        { return _pass_thread; }
2715 
2716   virtual void input_values_do(ValueVisitor* f)   {
2717     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
2718   }
2719 };
2720 
2721 // Use to trip invocation counter of an inlined method
2722 
2723 LEAF(ProfileInvoke, Instruction)
2724  private:
2725   ciMethod*   _inlinee;
2726   ValueStack* _state;
2727 
2728  public:
2729   ProfileInvoke(ciMethod* inlinee,  ValueStack* state)
2730     : Instruction(voidType)
2731     , _inlinee(inlinee)
2732     , _state(state)
2733   {
2734     // The ProfileInvoke has side-effects and must occur precisely where located QQQ???
2735     pin();
2736   }
2737 
2738   ciMethod* inlinee()      { return _inlinee; }
2739   ValueStack* state()      { return _state; }
2740   virtual void input_values_do(ValueVisitor*)   {}
2741   virtual void state_values_do(ValueVisitor*);
2742 };
2743 
2744 LEAF(MemBar, Instruction)
2745  private:
2746   LIR_Code _code;
2747 
2748  public:
2749   MemBar(LIR_Code code)
2750     : Instruction(voidType)
2751     , _code(code)
2752   {
2753     pin();
2754   }
2755 
2756   LIR_Code code()           { return _code; }
2757 
2758   virtual void input_values_do(ValueVisitor*)   {}
2759 };
2760 
2761 class BlockPair: public CompilationResourceObj {
2762  private:
2763   BlockBegin* _from;
2764   BlockBegin* _to;
2765  public:
2766   BlockPair(BlockBegin* from, BlockBegin* to): _from(from), _to(to) {}
2767   BlockBegin* from() const { return _from; }
2768   BlockBegin* to() const   { return _to;   }
2769   bool is_same(BlockBegin* from, BlockBegin* to) const { return  _from == from &amp;&amp; _to == to; }
2770   bool is_same(BlockPair* p) const { return  _from == p-&gt;from() &amp;&amp; _to == p-&gt;to(); }
2771   void set_to(BlockBegin* b)   { _to = b; }
2772   void set_from(BlockBegin* b) { _from = b; }
2773 };
2774 
2775 typedef GrowableArray&lt;BlockPair*&gt; BlockPairList;
2776 
2777 inline int         BlockBegin::number_of_sux() const            { assert(_end == NULL || _end-&gt;number_of_sux() == _successors.length(), &quot;mismatch&quot;); return _successors.length(); }
2778 inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end == NULL || _end-&gt;sux_at(i) == _successors.at(i), &quot;mismatch&quot;);          return _successors.at(i); }
2779 inline void        BlockBegin::add_successor(BlockBegin* sux)   { assert(_end == NULL, &quot;Would create mismatch with successors of BlockEnd&quot;);         _successors.append(sux); }
2780 
2781 #undef ASSERT_VALUES
2782 
2783 #endif // SHARE_C1_C1_INSTRUCTION_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>