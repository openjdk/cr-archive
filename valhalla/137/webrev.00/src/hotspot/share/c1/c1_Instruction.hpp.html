<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_INSTRUCTION_HPP
  26 #define SHARE_C1_C1_INSTRUCTION_HPP
  27 
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIR.hpp&quot;
  30 #include &quot;c1/c1_ValueType.hpp&quot;
  31 #include &quot;ci/ciField.hpp&quot;
  32 
  33 // Predefined classes
  34 class ciField;
  35 class ValueStack;
  36 class InstructionPrinter;
  37 class IRScope;
  38 class LIR_OprDesc;
  39 typedef LIR_OprDesc* LIR_Opr;
  40 
  41 
  42 // Instruction class hierarchy
  43 //
  44 // All leaf classes in the class hierarchy are concrete classes
  45 // (i.e., are instantiated). All other classes are abstract and
  46 // serve factoring.
  47 
  48 class Instruction;
  49 class   Phi;
  50 class   Local;
  51 class   Constant;
  52 class   AccessField;
  53 class     LoadField;
  54 class     StoreField;
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
  75 class     NewInlineTypeInstance;
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
  80 class     WithField;
  81 class     DefaultValue;
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
  96 class         LookupSwitch;
  97 class       Return;
  98 class       Throw;
  99 class       Base;
 100 class   RoundFP;
 101 class   UnsafeOp;
 102 class     UnsafeRawOp;
 103 class       UnsafeGetRaw;
 104 class       UnsafePutRaw;
 105 class     UnsafeObjectOp;
 106 class       UnsafeGetObject;
 107 class       UnsafePutObject;
 108 class         UnsafeGetAndSetObject;
 109 class   ProfileCall;
 110 class   ProfileReturnType;
 111 class   ProfileInvoke;
 112 class   RuntimeCall;
 113 class   MemBar;
 114 class   RangeCheckPredicate;
 115 #ifdef ASSERT
 116 class   Assert;
 117 #endif
 118 
 119 // A Value is a reference to the instruction creating the value
 120 typedef Instruction* Value;
 121 typedef GrowableArray&lt;Value&gt; Values;
 122 typedef GrowableArray&lt;ValueStack*&gt; ValueStackStack;
 123 
 124 // BlockClosure is the base class for block traversal/iteration.
 125 
 126 class BlockClosure: public CompilationResourceObj {
 127  public:
 128   virtual void block_do(BlockBegin* block)       = 0;
 129 };
 130 
 131 
 132 // A simple closure class for visiting the values of an Instruction
 133 class ValueVisitor: public StackObj {
 134  public:
 135   virtual void visit(Value* v) = 0;
 136 };
 137 
 138 
 139 // Some array and list classes
 140 typedef GrowableArray&lt;BlockBegin*&gt; BlockBeginArray;
 141 
 142 class BlockList: public GrowableArray&lt;BlockBegin*&gt; {
 143  public:
 144   BlockList(): GrowableArray&lt;BlockBegin*&gt;() {}
 145   BlockList(const int size): GrowableArray&lt;BlockBegin*&gt;(size) {}
 146   BlockList(const int size, BlockBegin* init): GrowableArray&lt;BlockBegin*&gt;(size, size, init) {}
 147 
 148   void iterate_forward(BlockClosure* closure);
 149   void iterate_backward(BlockClosure* closure);
 150   void blocks_do(void f(BlockBegin*));
 151   void values_do(ValueVisitor* f);
 152   void print(bool cfg_only = false, bool live_only = false) PRODUCT_RETURN;
 153 };
 154 
 155 
 156 // InstructionVisitors provide type-based dispatch for instructions.
 157 // For each concrete Instruction class X, a virtual function do_X is
 158 // provided. Functionality that needs to be implemented for all classes
 159 // (e.g., printing, code generation) is factored out into a specialised
 160 // visitor instead of added to the Instruction classes itself.
 161 
 162 class InstructionVisitor: public StackObj {
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
 183   virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x) = 0;
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 187   virtual void do_WithField      (WithField*       x) = 0;
 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 204   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 205   virtual void do_RoundFP        (RoundFP*         x) = 0;
 206   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 207   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 208   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 209   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 210   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 211   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 212   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 213   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 214   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 215   virtual void do_MemBar         (MemBar*          x) = 0;
 216   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 217 #ifdef ASSERT
 218   virtual void do_Assert         (Assert*          x) = 0;
 219 #endif
 220 };
 221 
 222 
 223 // Hashing support
 224 //
 225 // Note: This hash functions affect the performance
 226 //       of ValueMap - make changes carefully!
 227 
 228 #define HASH1(x1            )                    ((intx)(x1))
 229 #define HASH2(x1, x2        )                    ((HASH1(x1            ) &lt;&lt; 7) ^ HASH1(x2))
 230 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2        ) &lt;&lt; 7) ^ HASH1(x3))
 231 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3    ) &lt;&lt; 7) ^ HASH1(x4))
 232 #define HASH5(x1, x2, x3, x4, x5)                ((HASH4(x1, x2, x3, x4) &lt;&lt; 7) ^ HASH1(x5))
 233 
 234 
 235 // The following macros are used to implement instruction-specific hashing.
 236 // By default, each instruction implements hash() and is_equal(Value), used
 237 // for value numbering/common subexpression elimination. The default imple-
 238 // mentation disables value numbering. Each instruction which can be value-
 239 // numbered, should define corresponding hash() and is_equal(Value) functions
 240 // via the macros below. The f arguments specify all the values/op codes, etc.
 241 // that need to be identical for two instructions to be identical.
 242 //
 243 // Note: The default implementation of hash() returns 0 in order to indicate
 244 //       that the instruction should not be considered for value numbering.
 245 //       The currently used hash functions do not guarantee that never a 0
 246 //       is produced. While this is still correct, it may be a performance
 247 //       bug (no value numbering for that node). However, this situation is
 248 //       so unlikely, that we are not going to handle it specially.
 249 
 250 #define HASHING1(class_name, enabled, f1)             \
 251   virtual intx hash() const {                         \
 252     return (enabled) ? HASH2(name(), f1) : 0;         \
 253   }                                                   \
 254   virtual bool is_equal(Value v) const {              \
 255     if (!(enabled)  ) return false;                   \
 256     class_name* _v = v-&gt;as_##class_name();            \
 257     if (_v == NULL  ) return false;                   \
 258     if (f1 != _v-&gt;f1) return false;                   \
 259     return true;                                      \
 260   }                                                   \
 261 
 262 
 263 #define HASHING2(class_name, enabled, f1, f2)         \
 264   virtual intx hash() const {                         \
 265     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 266   }                                                   \
 267   virtual bool is_equal(Value v) const {              \
 268     if (!(enabled)  ) return false;                   \
 269     class_name* _v = v-&gt;as_##class_name();            \
 270     if (_v == NULL  ) return false;                   \
 271     if (f1 != _v-&gt;f1) return false;                   \
 272     if (f2 != _v-&gt;f2) return false;                   \
 273     return true;                                      \
 274   }                                                   \
 275 
 276 
 277 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 278   virtual intx hash() const {                         \
 279     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 280   }                                                   \
 281   virtual bool is_equal(Value v) const {              \
 282     if (!(enabled)  ) return false;                   \
 283     class_name* _v = v-&gt;as_##class_name();            \
 284     if (_v == NULL  ) return false;                   \
 285     if (f1 != _v-&gt;f1) return false;                   \
 286     if (f2 != _v-&gt;f2) return false;                   \
 287     if (f3 != _v-&gt;f3) return false;                   \
 288     return true;                                      \
 289   }                                                   \
 290 
 291 #define HASHING4(class_name, enabled, f1, f2, f3, f4) \
 292   virtual intx hash() const {                         \
 293     return (enabled) ? HASH5(name(), f1, f2, f3, f4) : 0; \
 294   }                                                   \
 295   virtual bool is_equal(Value v) const {              \
 296     if (!(enabled)  ) return false;                   \
 297     class_name* _v = v-&gt;as_##class_name();            \
 298     if (_v == NULL  ) return false;                   \
 299     if (f1 != _v-&gt;f1) return false;                   \
 300     if (f2 != _v-&gt;f2) return false;                   \
 301     if (f3 != _v-&gt;f3) return false;                   \
 302     if (f4 != _v-&gt;f4) return false;                   \
 303     return true;                                      \
 304   }                                                   \
 305 
 306 
 307 // The mother of all instructions...
 308 
 309 class Instruction: public CompilationResourceObj {
 310  private:
 311   int          _id;                              // the unique instruction id
 312 #ifndef PRODUCT
 313   int          _printable_bci;                   // the bci of the instruction for printing
 314 #endif
 315   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 316   int          _pin_state;                       // set of PinReason describing the reason for pinning
 317   ValueType*   _type;                            // the instruction value type
 318   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 319   Instruction* _subst;                           // the substitution instruction if any
 320   LIR_Opr      _operand;                         // LIR specific information
 321   unsigned int _flags;                           // Flag bits
 322 
 323   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 324   ValueStack*  _exception_state;                 // Copy of state for exception handling
 325   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 326 
 327   friend class UseCountComputer;
 328 
 329   void update_exception_state(ValueStack* state);
 330 
 331  protected:
 332   BlockBegin*  _block;                           // Block that contains this instruction
 333 
 334   void set_type(ValueType* type) {
 335     assert(type != NULL, &quot;type must exist&quot;);
 336     _type = type;
 337   }
 338 
 339   // Helper class to keep track of which arguments need a null check
 340   class ArgsNonNullState {
 341   private:
 342     int _nonnull_state; // mask identifying which args are nonnull
 343   public:
 344     ArgsNonNullState()
 345       : _nonnull_state(AllBits) {}
 346 
 347     // Does argument number i needs a null check?
 348     bool arg_needs_null_check(int i) const {
 349       // No data is kept for arguments starting at position 33 so
 350       // conservatively assume that they need a null check.
 351       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 352         return is_set_nth_bit(_nonnull_state, i);
 353       }
 354       return true;
 355     }
 356 
 357     // Set whether argument number i needs a null check or not
 358     void set_arg_needs_null_check(int i, bool check) {
 359       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 360         if (check) {
 361           _nonnull_state |= nth_bit(i);
 362         } else {
 363           _nonnull_state &amp;= ~(nth_bit(i));
 364         }
 365       }
 366     }
 367   };
 368 
 369  public:
 370   void* operator new(size_t size) throw() {
 371     Compilation* c = Compilation::current();
 372     void* res = c-&gt;arena()-&gt;Amalloc(size);
 373     return res;
 374   }
 375 
 376   static const int no_bci = -99;
 377 
 378   enum InstructionFlag {
 379     NeedsNullCheckFlag = 0,
 380     NeverNullFlag,          // For &quot;Q&quot; signatures
 381     CanTrapFlag,
 382     DirectCompareFlag,
 383     IsEliminatedFlag,
 384     IsSafepointFlag,
 385     IsStaticFlag,
 386     IsStrictfpFlag,
 387     NeedsStoreCheckFlag,
 388     NeedsWriteBarrierFlag,
 389     PreservesStateFlag,
 390     TargetIsFinalFlag,
 391     TargetIsLoadedFlag,
 392     TargetIsStrictfpFlag,
 393     UnorderedIsTrueFlag,
 394     NeedsPatchingFlag,
 395     ThrowIncompatibleClassChangeErrorFlag,
 396     InvokeSpecialReceiverCheckFlag,
 397     ProfileMDOFlag,
 398     IsLinkedInBlockFlag,
 399     NeedsRangeCheckFlag,
 400     InWorkListFlag,
 401     DeoptimizeOnException,
 402     InstructionLastFlag
 403   };
 404 
 405  public:
 406   bool check_flag(InstructionFlag id) const      { return (_flags &amp; (1 &lt;&lt; id)) != 0;    }
 407   void set_flag(InstructionFlag id, bool f)      { _flags = f ? (_flags | (1 &lt;&lt; id)) : (_flags &amp; ~(1 &lt;&lt; id)); };
 408 
 409   // &#39;globally&#39; used condition values
 410   enum Condition {
 411     eql, neq, lss, leq, gtr, geq, aeq, beq
 412   };
 413 
 414   // Instructions may be pinned for many reasons and under certain conditions
 415   // with enough knowledge it&#39;s possible to safely unpin them.
 416   enum PinReason {
 417       PinUnknown           = 1 &lt;&lt; 0
 418     , PinExplicitNullCheck = 1 &lt;&lt; 3
 419     , PinStackForStateSplit= 1 &lt;&lt; 12
 420     , PinStateSplitConstructor= 1 &lt;&lt; 13
 421     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 422   };
 423 
 424   static Condition mirror(Condition cond);
 425   static Condition negate(Condition cond);
 426 
 427   // initialization
 428   static int number_of_instructions() {
 429     return Compilation::current()-&gt;number_of_instructions();
 430   }
 431 
 432   // creation
 433   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
 434   : _id(Compilation::current()-&gt;get_next_id()),
 435 #ifndef PRODUCT
 436   _printable_bci(-99),
 437 #endif
 438     _use_count(0)
 439   , _pin_state(0)
 440   , _type(type)
 441   , _next(NULL)
 442   , _subst(NULL)
 443   , _operand(LIR_OprFact::illegalOpr)
 444   , _flags(0)
 445   , _state_before(state_before)
 446   , _exception_handlers(NULL)
 447   , _block(NULL)
 448   {
 449     check_state(state_before);
 450     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 451     update_exception_state(_state_before);
 452   }
 453 
 454   // accessors
 455   int id() const                                 { return _id; }
 456 #ifndef PRODUCT
 457   bool has_printable_bci() const                 { return _printable_bci != -99; }
 458   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 459   void set_printable_bci(int bci)                { _printable_bci = bci; }
 460 #endif
 461   int dominator_depth();
 462   int use_count() const                          { return _use_count; }
 463   int pin_state() const                          { return _pin_state; }
 464   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 465   ValueType* type() const                        { return _type; }
 466   BlockBegin *block() const                      { return _block; }
 467   Instruction* prev();                           // use carefully, expensive operation
 468   Instruction* next() const                      { return _next; }
 469   bool has_subst() const                         { return _subst != NULL; }
 470   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 471   LIR_Opr operand() const                        { return _operand; }
 472 
 473   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 474   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 475   void set_null_free(bool f)                    { set_flag(NeverNullFlag, f); }
 476   bool is_null_free() const                     { return check_flag(NeverNullFlag); }
 477   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 478   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 479 
 480   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 481 
 482   bool has_uses() const                          { return use_count() &gt; 0; }
 483   ValueStack* state_before() const               { return _state_before; }
 484   ValueStack* exception_state() const            { return _exception_state; }
 485   virtual bool needs_exception_state() const     { return true; }
 486   XHandlers* exception_handlers() const          { return _exception_handlers; }
 487   ciKlass* as_loaded_klass_or_null() const;
 488 
 489   // withfield optimization
 490   virtual void set_escaped()                     { }
 491   virtual void set_local_index(int index)        { }
 492   virtual bool is_optimizable_for_withfield() const { return false; }
 493 
 494 
 495   // manipulation
 496   void pin(PinReason reason)                     { _pin_state |= reason; }
 497   void pin()                                     { _pin_state |= PinUnknown; }
 498   // DANGEROUS: only used by EliminateStores
 499   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 500 
 501   Instruction* set_next(Instruction* next) {
 502     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 503     assert(next != NULL, &quot;must not be NULL&quot;);
 504     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 505     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 506 
 507     BlockBegin *block = this-&gt;block();
 508     next-&gt;_block = block;
 509 
 510     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 511     _next = next;
 512     return next;
 513   }
 514 
 515   Instruction* set_next(Instruction* next, int bci) {
 516 #ifndef PRODUCT
 517     next-&gt;set_printable_bci(bci);
 518 #endif
 519     return set_next(next);
 520   }
 521 
 522   // when blocks are merged
 523   void fixup_block_pointers() {
 524     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 525     while (cur &amp;&amp; cur-&gt;_block != block()) {
 526       cur-&gt;_block = block();
 527       cur = cur-&gt;next();
 528     }
 529   }
 530 
 531   Instruction *insert_after(Instruction *i) {
 532     Instruction* n = _next;
 533     set_next(i);
 534     i-&gt;set_next(n);
 535     return _next;
 536   }
 537 
 538   bool is_loaded_flattened_array() const;
 539   bool maybe_flattened_array();
 540   bool maybe_null_free_array();
 541 
 542   Instruction *insert_after_same_bci(Instruction *i) {
 543 #ifndef PRODUCT
 544     i-&gt;set_printable_bci(printable_bci());
 545 #endif
 546     return insert_after(i);
 547   }
 548 
 549   void set_subst(Instruction* subst)             {
 550     assert(subst == NULL ||
 551            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 552            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 553     _subst = subst;
 554   }
 555   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 556   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 557   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 558 
 559   // machine-specifics
 560   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 561   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
 562 
 563   // generic
 564   virtual Instruction*      as_Instruction()     { return this; } // to satisfy HASHING1 macro
 565   virtual Phi*              as_Phi()             { return NULL; }
 566   virtual Local*            as_Local()           { return NULL; }
 567   virtual Constant*         as_Constant()        { return NULL; }
 568   virtual AccessField*      as_AccessField()     { return NULL; }
 569   virtual LoadField*        as_LoadField()       { return NULL; }
 570   virtual StoreField*       as_StoreField()      { return NULL; }
 571   virtual AccessArray*      as_AccessArray()     { return NULL; }
 572   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 573   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 574   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 575   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 576   virtual NegateOp*         as_NegateOp()        { return NULL; }
 577   virtual Op2*              as_Op2()             { return NULL; }
 578   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 579   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 580   virtual LogicOp*          as_LogicOp()         { return NULL; }
 581   virtual CompareOp*        as_CompareOp()       { return NULL; }
 582   virtual IfOp*             as_IfOp()            { return NULL; }
 583   virtual Convert*          as_Convert()         { return NULL; }
 584   virtual NullCheck*        as_NullCheck()       { return NULL; }
 585   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 586   virtual StateSplit*       as_StateSplit()      { return NULL; }
 587   virtual Invoke*           as_Invoke()          { return NULL; }
 588   virtual NewInstance*      as_NewInstance()     { return NULL; }
 589   virtual NewInlineTypeInstance* as_NewInlineTypeInstance() { return NULL; }
 590   virtual NewArray*         as_NewArray()        { return NULL; }
 591   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 592   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 593   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 594   virtual WithField*        as_WithField()       { return NULL; }
 595   virtual DefaultValue*     as_DefaultValue()    { return NULL; }
 596   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 597   virtual CheckCast*        as_CheckCast()       { return NULL; }
 598   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 599   virtual TypeCast*         as_TypeCast()        { return NULL; }
 600   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 601   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 602   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 603   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 604   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 605   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 606   virtual Goto*             as_Goto()            { return NULL; }
 607   virtual If*               as_If()              { return NULL; }
 608   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 609   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 610   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 611   virtual Return*           as_Return()          { return NULL; }
 612   virtual Throw*            as_Throw()           { return NULL; }
 613   virtual Base*             as_Base()            { return NULL; }
 614   virtual RoundFP*          as_RoundFP()         { return NULL; }
 615   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
 616   virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }
 617   virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }
 618   virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }
 619 
 620 #ifdef ASSERT
 621   virtual Assert*           as_Assert()          { return NULL; }
 622 #endif
 623 
 624   virtual void visit(InstructionVisitor* v)      = 0;
 625 
 626   virtual bool can_trap() const                  { return false; }
 627 
 628   virtual void input_values_do(ValueVisitor* f)   = 0;
 629   virtual void state_values_do(ValueVisitor* f);
 630   virtual void other_values_do(ValueVisitor* f)   { /* usually no other - override on demand */ }
 631           void       values_do(ValueVisitor* f)   { input_values_do(f); state_values_do(f); other_values_do(f); }
 632 
 633   virtual ciType* exact_type() const;
 634   virtual ciType* declared_type() const          { return NULL; }
 635 
 636   // hashing
 637   virtual const char* name() const               = 0;
 638   HASHING1(Instruction, false, id())             // hashing disabled by default
 639 
 640   // debugging
 641   static void check_state(ValueStack* state)     PRODUCT_RETURN;
 642   void print()                                   PRODUCT_RETURN;
 643   void print_line()                              PRODUCT_RETURN;
 644   void print(InstructionPrinter&amp; ip)             PRODUCT_RETURN;
 645 };
 646 
 647 
 648 // The following macros are used to define base (i.e., non-leaf)
 649 // and leaf instruction classes. They define class-name related
 650 // generic functionality in one place.
 651 
 652 #define BASE(class_name, super_class_name)       \
 653   class class_name: public super_class_name {    \
 654    public:                                       \
 655     virtual class_name* as_##class_name()        { return this; }              \
 656 
 657 
 658 #define LEAF(class_name, super_class_name)       \
 659   BASE(class_name, super_class_name)             \
 660    public:                                       \
 661     virtual const char* name() const             { return #class_name; }       \
 662     virtual void visit(InstructionVisitor* v)    { v-&gt;do_##class_name(this); } \
 663 
 664 
 665 // Debugging support
 666 
 667 
 668 #ifdef ASSERT
 669 class AssertValues: public ValueVisitor {
 670   void visit(Value* x)             { assert((*x) != NULL, &quot;value must exist&quot;); }
 671 };
 672   #define ASSERT_VALUES                          { AssertValues assert_value; values_do(&amp;assert_value); }
 673 #else
 674   #define ASSERT_VALUES
 675 #endif // ASSERT
 676 
 677 
 678 // A Phi is a phi function in the sense of SSA form. It stands for
 679 // the value of a local variable at the beginning of a join block.
 680 // A Phi consists of n operands, one for every incoming branch.
 681 
 682 LEAF(Phi, Instruction)
 683  private:
 684   int         _pf_flags; // the flags of the phi function
 685   int         _index;    // to value on operand stack (index &lt; 0) or to local
 686  public:
 687   // creation
 688   Phi(ValueType* type, BlockBegin* b, int index)
 689   : Instruction(type-&gt;base())
 690   , _pf_flags(0)
 691   , _index(index)
 692   {
 693     _block = b;
 694     NOT_PRODUCT(set_printable_bci(Value(b)-&gt;printable_bci()));
 695     if (type-&gt;is_illegal()) {
 696       make_illegal();
 697     }
 698   }
 699 
 700   // flags
 701   enum Flag {
 702     no_flag         = 0,
 703     visited         = 1 &lt;&lt; 0,
 704     cannot_simplify = 1 &lt;&lt; 1
 705   };
 706 
 707   // accessors
 708   bool  is_local() const          { return _index &gt;= 0; }
 709   bool  is_on_stack() const       { return !is_local(); }
 710   int   local_index() const       { assert(is_local(), &quot;&quot;); return _index; }
 711   int   stack_index() const       { assert(is_on_stack(), &quot;&quot;); return -(_index+1); }
 712 
 713   Value operand_at(int i) const;
 714   int   operand_count() const;
 715 
 716   void   set(Flag f)              { _pf_flags |=  f; }
 717   void   clear(Flag f)            { _pf_flags &amp;= ~f; }
 718   bool   is_set(Flag f) const     { return (_pf_flags &amp; f) != 0; }
 719 
 720   // Invalidates phis corresponding to merges of locals of two different types
 721   // (these should never be referenced, otherwise the bytecodes are illegal)
 722   void   make_illegal() {
 723     set(cannot_simplify);
 724     set_type(illegalType);
 725   }
 726 
 727   bool is_illegal() const {
 728     return type()-&gt;is_illegal();
 729   }
 730 
 731   // generic
 732   virtual void input_values_do(ValueVisitor* f) {
 733   }
 734 };
 735 
 736 
 737 // A local is a placeholder for an incoming argument to a function call.
 738 LEAF(Local, Instruction)
 739  private:
 740   int      _java_index;                          // the local index within the method to which the local belongs
 741   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 742   ciType*  _declared_type;
 743  public:
 744   // creation
 745   Local(ciType* declared, ValueType* type, int index, bool receiver, bool null_free)
 746     : Instruction(type)
 747     , _java_index(index)
 748     , _is_receiver(receiver)
 749     , _declared_type(declared)
 750   {
 751     set_null_free(null_free);
 752     NOT_PRODUCT(set_printable_bci(-1));
 753   }
 754 
 755   // accessors
 756   int java_index() const                         { return _java_index; }
 757   bool is_receiver() const                       { return _is_receiver; }
 758 
 759   virtual ciType* declared_type() const          { return _declared_type; }
 760 
 761   // generic
 762   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 763 };
 764 
 765 
 766 LEAF(Constant, Instruction)
 767  public:
 768   // creation
 769   Constant(ValueType* type):
 770       Instruction(type, NULL, /*type_is_constant*/ true)
 771   {
 772     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 773   }
 774 
 775   Constant(ValueType* type, ValueStack* state_before):
 776     Instruction(type, state_before, /*type_is_constant*/ true)
 777   {
 778     assert(state_before != NULL, &quot;only used for constants which need patching&quot;);
 779     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 780     // since it&#39;s patching it needs to be pinned
 781     pin();
 782   }
 783 
 784   // generic
 785   virtual bool can_trap() const                  { return state_before() != NULL; }
 786   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 787 
 788   virtual intx hash() const;
 789   virtual bool is_equal(Value v) const;
 790 
 791   virtual ciType* exact_type() const;
 792 
 793   enum CompareResult { not_comparable = -1, cond_false, cond_true };
 794 
 795   virtual CompareResult compare(Instruction::Condition condition, Value right) const;
 796   BlockBegin* compare(Instruction::Condition cond, Value right,
 797                       BlockBegin* true_sux, BlockBegin* false_sux) const {
 798     switch (compare(cond, right)) {
 799     case not_comparable:
 800       return NULL;
 801     case cond_false:
 802       return false_sux;
 803     case cond_true:
 804       return true_sux;
 805     default:
 806       ShouldNotReachHere();
 807       return NULL;
 808     }
 809   }
 810 };
 811 
 812 
 813 BASE(AccessField, Instruction)
 814  private:
 815   Value       _obj;
 816   int         _offset;
 817   ciField*    _field;
 818   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 819 
 820  public:
 821   // creation
 822   AccessField(Value obj, int offset, ciField* field, bool is_static,
 823               ValueStack* state_before, bool needs_patching)
 824   : Instruction(as_ValueType(field-&gt;type()-&gt;basic_type()), state_before)
 825   , _obj(obj)
 826   , _offset(offset)
 827   , _field(field)
 828   , _explicit_null_check(NULL)
 829   {
 830     set_needs_null_check(!is_static);
 831     set_flag(IsStaticFlag, is_static);
 832     set_flag(NeedsPatchingFlag, needs_patching);
 833     ASSERT_VALUES
 834     // pin of all instructions with memory access
 835     pin();
 836   }
 837 
 838   // accessors
 839   Value obj() const                              { return _obj; }
 840   int offset() const                             { return _offset; }
 841   ciField* field() const                         { return _field; }
 842   BasicType field_type() const                   { return _field-&gt;type()-&gt;basic_type(); }
 843   bool is_static() const                         { return check_flag(IsStaticFlag); }
 844   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 845   bool needs_patching() const                    { return check_flag(NeedsPatchingFlag); }
 846 
 847   // Unresolved getstatic and putstatic can cause initialization.
 848   // Technically it occurs at the Constant that materializes the base
 849   // of the static fields but it&#39;s simpler to model it here.
 850   bool is_init_point() const                     { return is_static() &amp;&amp; (needs_patching() || !_field-&gt;holder()-&gt;is_initialized()); }
 851 
 852   // manipulation
 853 
 854   // Under certain circumstances, if a previous NullCheck instruction
 855   // proved the target object non-null, we can eliminate the explicit
 856   // null check and do an implicit one, simply specifying the debug
 857   // information from the NullCheck. This field should only be consulted
 858   // if needs_null_check() is true.
 859   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 860 
 861   // generic
 862   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 863   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 864 };
 865 
 866 
 867 LEAF(LoadField, AccessField)
 868  public:
 869   // creation
 870   LoadField(Value obj, int offset, ciField* field, bool is_static,
 871             ValueStack* state_before, bool needs_patching,
 872             ciInlineKlass* inline_klass = NULL, Value default_value = NULL )
 873   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 874   {
 875     set_null_free(field-&gt;signature()-&gt;is_Q_signature());
 876   }
 877 
 878   ciType* declared_type() const;
 879 
 880   // generic; cannot be eliminated if needs patching or if volatile.
 881   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 882 };
 883 
 884 
 885 LEAF(StoreField, AccessField)
 886  private:
 887   Value _value;
 888 
 889  public:
 890   // creation
 891   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 892              ValueStack* state_before, bool needs_patching);
 893 
 894   // accessors
 895   Value value() const                            { return _value; }
 896   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 897 
 898   // generic
 899   virtual void input_values_do(ValueVisitor* f)   { AccessField::input_values_do(f); f-&gt;visit(&amp;_value); }
 900 };
 901 
 902 
 903 BASE(AccessArray, Instruction)
 904  private:
 905   Value       _array;
 906 
 907  public:
 908   // creation
 909   AccessArray(ValueType* type, Value array, ValueStack* state_before)
 910   : Instruction(type, state_before)
 911   , _array(array)
 912   {
 913     set_needs_null_check(true);
 914     ASSERT_VALUES
 915     pin(); // instruction with side effect (null exception or range check throwing)
 916   }
 917 
 918   Value array() const                            { return _array; }
 919 
 920   // generic
 921   virtual bool can_trap() const                  { return needs_null_check(); }
 922   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_array); }
 923 };
 924 
 925 
 926 LEAF(ArrayLength, AccessArray)
 927  private:
 928   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 929 
 930  public:
 931   // creation
 932   ArrayLength(Value array, ValueStack* state_before)
 933   : AccessArray(intType, array, state_before)
 934   , _explicit_null_check(NULL) {}
 935 
 936   // accessors
 937   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 938 
 939   // setters
 940   // See LoadField::set_explicit_null_check for documentation
 941   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 942 
 943   // generic
 944   HASHING1(ArrayLength, true, array()-&gt;subst())
 945 };
 946 
 947 
 948 BASE(AccessIndexed, AccessArray)
 949  private:
 950   Value     _index;
 951   Value     _length;
 952   BasicType _elt_type;
 953   bool      _mismatched;
 954   ciMethod* _profiled_method;
 955   int       _profiled_bci;
 956 
 957  public:
 958   // creation
 959   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 960   : AccessArray(as_ValueType(elt_type), array, state_before)
 961   , _index(index)
 962   , _length(length)
 963   , _elt_type(elt_type)
 964   , _mismatched(mismatched)
 965   , _profiled_method(NULL), _profiled_bci(0)
 966   {
 967     set_flag(Instruction::NeedsRangeCheckFlag, true);
 968     ASSERT_VALUES
 969   }
 970 
 971   // accessors
 972   Value index() const                            { return _index; }
 973   Value length() const                           { return _length; }
 974   BasicType elt_type() const                     { return _elt_type; }
 975   bool mismatched() const                        { return _mismatched; }
 976 
 977   void clear_length()                            { _length = NULL; }
 978   // perform elimination of range checks involving constants
 979   bool compute_needs_range_check();
 980 
 981   // Helpers for MethodData* profiling
 982   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
 983   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
 984   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
 985   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
 986   ciMethod* profiled_method() const                  { return _profiled_method;     }
 987   int       profiled_bci() const                     { return _profiled_bci;        }
 988 
 989 
 990 // generic
 991   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 992 };
 993 
 994 
 995 LEAF(LoadIndexed, AccessIndexed)
 996  private:
 997   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 998   NewInlineTypeInstance* _vt;
 999 
1000  public:
1001   // creation
1002   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
1003   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1004   , _explicit_null_check(NULL), _vt(NULL) {}
1005 
1006   // accessors
1007   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
1008 
1009   // setters
1010   // See LoadField::set_explicit_null_check for documentation
1011   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1012 
1013   ciType* exact_type() const;
1014   ciType* declared_type() const;
1015 
1016   NewInlineTypeInstance* vt() const { return _vt; }
1017   void set_vt(NewInlineTypeInstance* vt) { _vt = vt; }
1018 
1019   // generic
1020   HASHING4(LoadIndexed, !should_profile(), type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst(), vt())
1021 };
1022 
1023 
1024 LEAF(StoreIndexed, AccessIndexed)
1025  private:
1026   Value       _value;
1027 
1028   bool      _check_boolean;
1029 
1030  public:
1031   // creation
1032   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
1033                bool check_boolean, bool mismatched = false);
1034 
1035   // accessors
1036   Value value() const                            { return _value; }
1037   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
1038   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
1039   bool check_boolean() const                     { return _check_boolean; }
1040 
1041   // Flattened array support
1042   bool is_exact_flattened_array_store() const;
1043   // generic
1044   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1045 };
1046 
1047 
1048 LEAF(NegateOp, Instruction)
1049  private:
1050   Value _x;
1051 
1052  public:
1053   // creation
1054   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1055     ASSERT_VALUES
1056   }
1057 
1058   // accessors
1059   Value x() const                                { return _x; }
1060 
1061   // generic
1062   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
1063 };
1064 
1065 
1066 BASE(Op2, Instruction)
1067  private:
1068   Bytecodes::Code _op;
1069   Value           _x;
1070   Value           _y;
1071 
1072  public:
1073   // creation
1074   Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)
1075   : Instruction(type, state_before)
1076   , _op(op)
1077   , _x(x)
1078   , _y(y)
1079   {
1080     ASSERT_VALUES
1081   }
1082 
1083   // accessors
1084   Bytecodes::Code op() const                     { return _op; }
1085   Value x() const                                { return _x; }
1086   Value y() const                                { return _y; }
1087 
1088   // manipulators
1089   void swap_operands() {
1090     assert(is_commutative(), &quot;operation must be commutative&quot;);
1091     Value t = _x; _x = _y; _y = t;
1092   }
1093 
1094   // generic
1095   virtual bool is_commutative() const            { return false; }
1096   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1097 };
1098 
1099 
1100 LEAF(ArithmeticOp, Op2)
1101  public:
1102   // creation
1103   ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)
1104   : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y, state_before)
1105   {
1106     set_flag(IsStrictfpFlag, is_strictfp);
1107     if (can_trap()) pin();
1108   }
1109 
1110   // accessors
1111   bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }
1112 
1113   // generic
1114   virtual bool is_commutative() const;
1115   virtual bool can_trap() const;
1116   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1117 };
1118 
1119 
1120 LEAF(ShiftOp, Op2)
1121  public:
1122   // creation
1123   ShiftOp(Bytecodes::Code op, Value x, Value s) : Op2(x-&gt;type()-&gt;base(), op, x, s) {}
1124 
1125   // generic
1126   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1127 };
1128 
1129 
1130 LEAF(LogicOp, Op2)
1131  public:
1132   // creation
1133   LogicOp(Bytecodes::Code op, Value x, Value y) : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y) {}
1134 
1135   // generic
1136   virtual bool is_commutative() const;
1137   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1138 };
1139 
1140 
1141 LEAF(CompareOp, Op2)
1142  public:
1143   // creation
1144   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1145   : Op2(intType, op, x, y, state_before)
1146   {}
1147 
1148   // generic
1149   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1150 };
1151 
1152 
1153 LEAF(IfOp, Op2)
1154  private:
1155   Value _tval;
1156   Value _fval;
1157   bool _substitutability_check;
1158 
1159  public:
1160   // creation
1161   IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)
1162   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1163   , _tval(tval)
1164   , _fval(fval)
1165   , _substitutability_check(substitutability_check)
1166   {
1167     ASSERT_VALUES
1168     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1169     set_state_before(state_before);
1170   }
1171 
1172   // accessors
1173   virtual bool is_commutative() const;
1174   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1175   Condition cond() const                         { return (Condition)Op2::op(); }
1176   Value tval() const                             { return _tval; }
1177   Value fval() const                             { return _fval; }
1178   bool substitutability_check() const             { return _substitutability_check; }
1179   // generic
1180   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1181 };
1182 
1183 
1184 LEAF(Convert, Instruction)
1185  private:
1186   Bytecodes::Code _op;
1187   Value           _value;
1188 
1189  public:
1190   // creation
1191   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1192     ASSERT_VALUES
1193   }
1194 
1195   // accessors
1196   Bytecodes::Code op() const                     { return _op; }
1197   Value value() const                            { return _value; }
1198 
1199   // generic
1200   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_value); }
1201   HASHING2(Convert, true, op(), value()-&gt;subst())
1202 };
1203 
1204 
1205 LEAF(NullCheck, Instruction)
1206  private:
1207   Value       _obj;
1208 
1209  public:
1210   // creation
1211   NullCheck(Value obj, ValueStack* state_before)
1212   : Instruction(obj-&gt;type()-&gt;base(), state_before)
1213   , _obj(obj)
1214   {
1215     ASSERT_VALUES
1216     set_can_trap(true);
1217     assert(_obj-&gt;type()-&gt;is_object(), &quot;null check must be applied to objects only&quot;);
1218     pin(Instruction::PinExplicitNullCheck);
1219   }
1220 
1221   // accessors
1222   Value obj() const                              { return _obj; }
1223 
1224   // setters
1225   void set_can_trap(bool can_trap)               { set_flag(CanTrapFlag, can_trap); }
1226 
1227   // generic
1228   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); /* null-check elimination sets to false */ }
1229   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
1230   HASHING1(NullCheck, true, obj()-&gt;subst())
1231 };
1232 
1233 
1234 // This node is supposed to cast the type of another node to a more precise
1235 // declared type.
1236 LEAF(TypeCast, Instruction)
1237  private:
1238   ciType* _declared_type;
1239   Value   _obj;
1240 
1241  public:
1242   // The type of this node is the same type as the object type (and it might be constant).
1243   TypeCast(ciType* type, Value obj, ValueStack* state_before)
1244   : Instruction(obj-&gt;type(), state_before, obj-&gt;type()-&gt;is_constant()),
1245     _declared_type(type),
1246     _obj(obj) {}
1247 
1248   // accessors
1249   ciType* declared_type() const                  { return _declared_type; }
1250   Value   obj() const                            { return _obj; }
1251 
1252   // generic
1253   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_obj); }
1254 };
1255 
1256 
1257 BASE(StateSplit, Instruction)
1258  private:
1259   ValueStack* _state;
1260 
1261  protected:
1262   static void substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block);
1263 
1264  public:
1265   // creation
1266   StateSplit(ValueType* type, ValueStack* state_before = NULL)
1267   : Instruction(type, state_before)
1268   , _state(NULL)
1269   {
1270     pin(PinStateSplitConstructor);
1271   }
1272 
1273   // accessors
1274   ValueStack* state() const                      { return _state; }
1275   IRScope* scope() const;                        // the state&#39;s scope
1276 
1277   // manipulation
1278   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1279 
1280   // generic
1281   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1282   virtual void state_values_do(ValueVisitor* f);
1283 };
1284 
1285 
1286 LEAF(Invoke, StateSplit)
1287  private:
1288   Bytecodes::Code _code;
1289   Value           _recv;
1290   Values*         _args;
1291   BasicTypeList*  _signature;
1292   int             _vtable_index;
1293   ciMethod*       _target;
1294 
1295  public:
1296   // creation
1297   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
1298          int vtable_index, ciMethod* target, ValueStack* state_before, bool null_free);
1299 
1300   // accessors
1301   Bytecodes::Code code() const                   { return _code; }
1302   Value receiver() const                         { return _recv; }
1303   bool has_receiver() const                      { return receiver() != NULL; }
1304   int number_of_arguments() const                { return _args-&gt;length(); }
1305   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1306   int vtable_index() const                       { return _vtable_index; }
1307   BasicTypeList* signature() const               { return _signature; }
1308   ciMethod* target() const                       { return _target; }
1309 
1310   ciType* declared_type() const;
1311 
1312   // Returns false if target is not loaded
1313   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1314   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1315   // Returns false if target is not loaded
1316   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1317 
1318   // JSR 292 support
1319   bool is_invokedynamic() const                  { return code() == Bytecodes::_invokedynamic; }
1320   bool is_method_handle_intrinsic() const        { return target()-&gt;is_method_handle_intrinsic(); }
1321 
1322   virtual bool needs_exception_state() const     { return false; }
1323 
1324   // generic
1325   virtual bool can_trap() const                  { return true; }
1326   virtual void input_values_do(ValueVisitor* f) {
1327     StateSplit::input_values_do(f);
1328     if (has_receiver()) f-&gt;visit(&amp;_recv);
1329     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1330   }
1331   virtual void state_values_do(ValueVisitor *f);
1332 };
1333 
1334 
1335 LEAF(NewInstance, StateSplit)
1336  private:
1337   ciInstanceKlass* _klass;
1338   bool _is_unresolved;
1339 
1340  public:
1341   // creation
1342   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1343   : StateSplit(instanceType, state_before)
1344   , _klass(klass), _is_unresolved(is_unresolved)
1345   {}
1346 
1347   // accessors
1348   ciInstanceKlass* klass() const                 { return _klass; }
1349   bool is_unresolved() const                     { return _is_unresolved; }
1350 
1351   virtual bool needs_exception_state() const     { return false; }
1352 
1353   // generic
1354   virtual bool can_trap() const                  { return true; }
1355   ciType* exact_type() const;
1356   ciType* declared_type() const;
1357 };
1358 
1359 LEAF(NewInlineTypeInstance, StateSplit)
1360   bool _is_unresolved;
1361   ciInlineKlass* _klass;
1362   Value _depends_on;      // Link to instance on with withfield was called on
1363   bool _is_optimizable_for_withfield;
1364   bool _in_larval_state;
1365   int _first_local_index;
1366   int _on_stack_count;
1367 public:
1368 
1369   // Default creation, always allocated for now
1370   NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)
1371   : StateSplit(instanceType, state_before)
1372    , _is_unresolved(is_unresolved)
1373    , _klass(klass)
1374    , _is_optimizable_for_withfield(from_default_value)
1375    , _in_larval_state(true)
1376    , _first_local_index(-1)
1377    , _on_stack_count(1)
1378   {
1379     if (depends_on == NULL) {
1380       _depends_on = this;
1381     } else {
1382       _depends_on = depends_on;
1383     }
1384     set_null_free(true);
1385   }
1386 
1387   // accessors
1388   bool is_unresolved() const                     { return _is_unresolved; }
1389   Value depends_on();
1390 
1391   ciInlineKlass* klass() const { return _klass; }
1392 
1393   virtual bool needs_exception_state() const     { return false; }
1394 
1395   // generic
1396   virtual bool can_trap() const                  { return true; }
1397   ciType* exact_type() const;
1398   ciType* declared_type() const;
1399 
1400   // Only done in LIR Generator -&gt; map everything to object
1401   void set_to_object_type() { set_type(instanceType); }
1402 
1403   // withfield optimization
1404   virtual void set_escaped() {
1405     _is_optimizable_for_withfield = false;
1406   }
1407   virtual void set_local_index(int index) {
1408     if (_first_local_index != index) {
1409       if (_first_local_index == -1) {
1410         _first_local_index = index;
1411       } else {
1412         set_not_larva_anymore();
1413       }
1414     }
1415   }
1416 
1417   virtual bool in_larval_state() const { return _in_larval_state; }
1418   virtual void set_not_larva_anymore() {
1419     _in_larval_state = false; }
1420 
1421   virtual int on_stack_count() { return _on_stack_count; }
1422   virtual void increment_on_stack_count() { _on_stack_count++; }
1423   virtual void decrement_on_stack_count() { _on_stack_count--; }
1424 
1425   static void update_larval_state(Value v) {
1426     if (v != NULL &amp;&amp; v-&gt;as_NewInlineTypeInstance() != NULL) {
1427       v-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore();
1428     }
1429   }
1430 
1431   static void update_stack_count(Value v) {
1432     if (v != NULL &amp;&amp; v-&gt;as_NewInlineTypeInstance() != NULL &amp;&amp; v-&gt;as_NewInlineTypeInstance()-&gt;in_larval_state()) {
1433       v-&gt;as_NewInlineTypeInstance()-&gt;decrement_on_stack_count();
1434     }
1435   }
1436 
1437 };
1438 
1439 BASE(NewArray, StateSplit)
1440  private:
1441   Value       _length;
1442 
1443  public:
1444   // creation
1445   NewArray(Value length, ValueStack* state_before)
1446   : StateSplit(objectType, state_before)
1447   , _length(length)
1448   {
1449     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1450   }
1451 
1452   // accessors
1453   Value length() const                           { return _length; }
1454 
1455   virtual bool needs_exception_state() const     { return false; }
1456 
1457   ciType* exact_type() const                     { return NULL; }
1458   ciType* declared_type() const;
1459 
1460   // generic
1461   virtual bool can_trap() const                  { return true; }
1462   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_length); }
1463 };
1464 
1465 
1466 LEAF(NewTypeArray, NewArray)
1467  private:
1468   BasicType _elt_type;
1469 
1470  public:
1471   // creation
1472   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1473   : NewArray(length, state_before)
1474   , _elt_type(elt_type)
1475   {}
1476 
1477   // accessors
1478   BasicType elt_type() const                     { return _elt_type; }
1479   ciType* exact_type() const;
1480 };
1481 
1482 
1483 LEAF(NewObjectArray, NewArray)
1484  private:
1485   ciKlass* _klass;
1486 
1487  public:
1488   // creation
1489   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool null_free)
1490   : NewArray(length, state_before), _klass(klass) {
1491     set_null_free(null_free);
1492   }
1493 
1494   // accessors
1495   ciKlass* klass() const                         { return _klass; }
1496   ciType* exact_type() const;
1497 };
1498 
1499 
1500 LEAF(NewMultiArray, NewArray)
1501  private:
1502   ciKlass* _klass;
1503   Values*  _dims;
1504 
1505  public:
1506   // creation
1507   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1508     ASSERT_VALUES
1509   }
1510 
1511   // accessors
1512   ciKlass* klass() const                         { return _klass; }
1513   Values* dims() const                           { return _dims; }
1514   int rank() const                               { return dims()-&gt;length(); }
1515 
1516   // generic
1517   virtual void input_values_do(ValueVisitor* f) {
1518     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1519     // is meaningless for a multi-dimensional array; passing the
1520     // zeroth element down to NewArray as its length is a bad idea
1521     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1522     // get updated, and the value must not be traversed twice. Was bug
1523     // - kbr 4/10/2001
1524     StateSplit::input_values_do(f);
1525     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1526   }
1527 
1528   ciType* exact_type() const;
1529 };
1530 
1531 LEAF(WithField, StateSplit)
1532  public:
1533   // creation
1534   WithField(ValueStack* state_before)
1535   : StateSplit(objectType, state_before) {}
1536 };
1537 
1538 LEAF(DefaultValue, StateSplit)
1539  public:
1540   // creation
1541   DefaultValue(ValueStack* state_before)
1542   : StateSplit(objectType, state_before) {}
1543 };
1544 
1545 BASE(TypeCheck, StateSplit)
1546  private:
1547   ciKlass*    _klass;
1548   Value       _obj;
1549 
1550   ciMethod* _profiled_method;
1551   int       _profiled_bci;
1552 
1553  public:
1554   // creation
1555   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1556   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1557     _profiled_method(NULL), _profiled_bci(0) {
1558     ASSERT_VALUES
1559     set_direct_compare(false);
1560   }
1561 
1562   // accessors
1563   ciKlass* klass() const                         { return _klass; }
1564   Value obj() const                              { return _obj; }
1565   bool is_loaded() const                         { return klass() != NULL; }
1566   bool direct_compare() const                    { return check_flag(DirectCompareFlag); }
1567 
1568   // manipulation
1569   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1570 
1571   // generic
1572   virtual bool can_trap() const                  { return true; }
1573   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1574 
1575   // Helpers for MethodData* profiling
1576   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1577   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1578   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1579   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1580   ciMethod* profiled_method() const                  { return _profiled_method;     }
1581   int       profiled_bci() const                     { return _profiled_bci;        }
1582 };
1583 
1584 
1585 LEAF(CheckCast, TypeCheck)
1586  public:
1587   // creation
1588   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool null_free = false)
1589   : TypeCheck(klass, obj, objectType, state_before) {
1590     set_null_free(null_free);
1591   }
1592 
1593   void set_incompatible_class_change_check() {
1594     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1595   }
1596   bool is_incompatible_class_change_check() const {
1597     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1598   }
1599   void set_invokespecial_receiver_check() {
1600     set_flag(InvokeSpecialReceiverCheckFlag, true);
1601   }
1602   bool is_invokespecial_receiver_check() const {
1603     return check_flag(InvokeSpecialReceiverCheckFlag);
1604   }
1605 
1606   virtual bool needs_exception_state() const {
1607     return !is_invokespecial_receiver_check();
1608   }
1609 
1610   ciType* declared_type() const;
1611 };
1612 
1613 
1614 LEAF(InstanceOf, TypeCheck)
1615  public:
1616   // creation
1617   InstanceOf(ciKlass* klass, Value obj, ValueStack* state_before) : TypeCheck(klass, obj, intType, state_before) {}
1618 
1619   virtual bool needs_exception_state() const     { return false; }
1620 };
1621 
1622 
1623 BASE(AccessMonitor, StateSplit)
1624  private:
1625   Value       _obj;
1626   int         _monitor_no;
1627 
1628  public:
1629   // creation
1630   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1631   : StateSplit(illegalType, state_before)
1632   , _obj(obj)
1633   , _monitor_no(monitor_no)
1634   {
1635     set_needs_null_check(true);
1636     ASSERT_VALUES
1637   }
1638 
1639   // accessors
1640   Value obj() const                              { return _obj; }
1641   int monitor_no() const                         { return _monitor_no; }
1642 
1643   // generic
1644   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1645 };
1646 
1647 
1648 LEAF(MonitorEnter, AccessMonitor)
1649   bool _maybe_inlinetype;
1650  public:
1651   // creation
1652   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_inlinetype)
1653   : AccessMonitor(obj, monitor_no, state_before)
1654   , _maybe_inlinetype(maybe_inlinetype)
1655   {
1656     ASSERT_VALUES
1657   }
1658 
1659   // accessors
1660   bool maybe_inlinetype() const                   { return _maybe_inlinetype; }
1661 
1662   // generic
1663   virtual bool can_trap() const                  { return true; }
1664 };
1665 
1666 
1667 LEAF(MonitorExit, AccessMonitor)
1668  public:
1669   // creation
1670   MonitorExit(Value obj, int monitor_no)
1671   : AccessMonitor(obj, monitor_no, NULL)
1672   {
1673     ASSERT_VALUES
1674   }
1675 };
1676 
1677 
1678 LEAF(Intrinsic, StateSplit)
1679  private:
1680   vmIntrinsics::ID _id;
1681   Values*          _args;
1682   Value            _recv;
1683   ArgsNonNullState _nonnull_state;
1684 
1685  public:
1686   // preserves_state can be set to true for Intrinsics
1687   // which are guaranteed to preserve register state across any slow
1688   // cases; setting it to true does not mean that the Intrinsic can
1689   // not trap, only that if we continue execution in the same basic
1690   // block after the Intrinsic, all of the registers are intact. This
1691   // allows load elimination and common expression elimination to be
1692   // performed across the Intrinsic.  The default value is false.
1693   Intrinsic(ValueType* type,
1694             vmIntrinsics::ID id,
1695             Values* args,
1696             bool has_receiver,
1697             ValueStack* state_before,
1698             bool preserves_state,
1699             bool cantrap = true)
1700   : StateSplit(type, state_before)
1701   , _id(id)
1702   , _args(args)
1703   , _recv(NULL)
1704   {
1705     assert(args != NULL, &quot;args must exist&quot;);
1706     ASSERT_VALUES
1707     set_flag(PreservesStateFlag, preserves_state);
1708     set_flag(CanTrapFlag,        cantrap);
1709     if (has_receiver) {
1710       _recv = argument_at(0);
1711     }
1712     set_needs_null_check(has_receiver);
1713 
1714     // some intrinsics can&#39;t trap, so don&#39;t force them to be pinned
1715     if (!can_trap() &amp;&amp; !vmIntrinsics::should_be_pinned(_id)) {
1716       unpin(PinStateSplitConstructor);
1717     }
1718   }
1719 
1720   // accessors
1721   vmIntrinsics::ID id() const                    { return _id; }
1722   int number_of_arguments() const                { return _args-&gt;length(); }
1723   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1724 
1725   bool has_receiver() const                      { return (_recv != NULL); }
1726   Value receiver() const                         { assert(has_receiver(), &quot;must have receiver&quot;); return _recv; }
1727   bool preserves_state() const                   { return check_flag(PreservesStateFlag); }
1728 
1729   bool arg_needs_null_check(int i) const {
1730     return _nonnull_state.arg_needs_null_check(i);
1731   }
1732 
1733   void set_arg_needs_null_check(int i, bool check) {
1734     _nonnull_state.set_arg_needs_null_check(i, check);
1735   }
1736 
1737   // generic
1738   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); }
1739   virtual void input_values_do(ValueVisitor* f) {
1740     StateSplit::input_values_do(f);
1741     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1742   }
1743 };
1744 
1745 
1746 class LIR_List;
1747 
1748 LEAF(BlockBegin, StateSplit)
1749  private:
1750   int        _block_id;                          // the unique block id
1751   int        _bci;                               // start-bci of block
1752   int        _depth_first_number;                // number of this block in a depth-first ordering
1753   int        _linear_scan_number;                // number of this block in linear-scan ordering
1754   int        _dominator_depth;
1755   int        _loop_depth;                        // the loop nesting level of this block
1756   int        _loop_index;                        // number of the innermost loop of this block
1757   int        _flags;                             // the flags associated with this block
1758 
1759   // fields used by BlockListBuilder
1760   int            _total_preds;                   // number of predecessors found by BlockListBuilder
1761   ResourceBitMap _stores_to_locals;              // bit is set when a local variable is stored in the block
1762 
1763   // SSA specific fields: (factor out later)
1764   BlockList   _successors;                       // the successors of this block
1765   BlockList   _predecessors;                     // the predecessors of this block
1766   BlockList   _dominates;                        // list of blocks that are dominated by this block
1767   BlockBegin* _dominator;                        // the dominator of this block
1768   // SSA specific ends
1769   BlockEnd*  _end;                               // the last instruction of this block
1770   BlockList  _exception_handlers;                // the exception handlers potentially invoked by this block
1771   ValueStackStack* _exception_states;            // only for xhandler entries: states of all instructions that have an edge to this xhandler
1772   int        _exception_handler_pco;             // if this block is the start of an exception handler,
1773                                                  // this records the PC offset in the assembly code of the
1774                                                  // first instruction in this block
1775   Label      _label;                             // the label associated with this block
1776   LIR_List*  _lir;                               // the low level intermediate representation for this block
1777 
1778   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1779   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1780   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1781   ResourceBitMap _live_kill;                     // set of registers defined in this block
1782 
1783   ResourceBitMap _fpu_register_usage;
1784   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1785   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1786   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1787 
1788   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1789   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1790 
1791   friend class SuxAndWeightAdjuster;
1792 
1793  public:
1794    void* operator new(size_t size) throw() {
1795     Compilation* c = Compilation::current();
1796     void* res = c-&gt;arena()-&gt;Amalloc(size);
1797     return res;
1798   }
1799 
1800   // initialization/counting
1801   static int  number_of_blocks() {
1802     return Compilation::current()-&gt;number_of_blocks();
1803   }
1804 
1805   // creation
1806   BlockBegin(int bci)
1807   : StateSplit(illegalType)
1808   , _block_id(Compilation::current()-&gt;get_next_block_id())
1809   , _bci(bci)
1810   , _depth_first_number(-1)
1811   , _linear_scan_number(-1)
1812   , _dominator_depth(-1)
1813   , _loop_depth(0)
1814   , _loop_index(-1)
1815   , _flags(0)
1816   , _total_preds(0)
1817   , _stores_to_locals()
1818   , _successors(2)
1819   , _predecessors(2)
1820   , _dominates(2)
1821   , _dominator(NULL)
1822   , _end(NULL)
1823   , _exception_handlers(1)
1824   , _exception_states(NULL)
1825   , _exception_handler_pco(-1)
1826   , _lir(NULL)
1827   , _live_in()
1828   , _live_out()
1829   , _live_gen()
1830   , _live_kill()
1831   , _fpu_register_usage()
1832   , _fpu_stack_state(NULL)
1833   , _first_lir_instruction_id(-1)
1834   , _last_lir_instruction_id(-1)
1835   {
1836     _block = this;
1837 #ifndef PRODUCT
1838     set_printable_bci(bci);
1839 #endif
1840   }
1841 
1842   // accessors
1843   int block_id() const                           { return _block_id; }
1844   int bci() const                                { return _bci; }
1845   BlockList* successors()                        { return &amp;_successors; }
1846   BlockList* dominates()                         { return &amp;_dominates; }
1847   BlockBegin* dominator() const                  { return _dominator; }
1848   int loop_depth() const                         { return _loop_depth; }
1849   int dominator_depth() const                    { return _dominator_depth; }
1850   int depth_first_number() const                 { return _depth_first_number; }
1851   int linear_scan_number() const                 { return _linear_scan_number; }
1852   BlockEnd* end() const                          { return _end; }
1853   Label* label()                                 { return &amp;_label; }
1854   LIR_List* lir() const                          { return _lir; }
1855   int exception_handler_pco() const              { return _exception_handler_pco; }
1856   ResourceBitMap&amp; live_in()                      { return _live_in;        }
1857   ResourceBitMap&amp; live_out()                     { return _live_out;       }
1858   ResourceBitMap&amp; live_gen()                     { return _live_gen;       }
1859   ResourceBitMap&amp; live_kill()                    { return _live_kill;      }
1860   ResourceBitMap&amp; fpu_register_usage()           { return _fpu_register_usage; }
1861   intArray* fpu_stack_state() const              { return _fpu_stack_state;    }
1862   int first_lir_instruction_id() const           { return _first_lir_instruction_id; }
1863   int last_lir_instruction_id() const            { return _last_lir_instruction_id; }
1864   int total_preds() const                        { return _total_preds; }
1865   BitMap&amp; stores_to_locals()                     { return _stores_to_locals; }
1866 
1867   // manipulation
1868   void set_dominator(BlockBegin* dom)            { _dominator = dom; }
1869   void set_loop_depth(int d)                     { _loop_depth = d; }
1870   void set_dominator_depth(int d)                { _dominator_depth = d; }
1871   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
1872   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
1873   void set_end(BlockEnd* end);
1874   void clear_end();
1875   void disconnect_from_graph();
1876   static void disconnect_edge(BlockBegin* from, BlockBegin* to);
1877   BlockBegin* insert_block_between(BlockBegin* sux);
1878   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1879   void set_lir(LIR_List* lir)                    { _lir = lir; }
1880   void set_exception_handler_pco(int pco)        { _exception_handler_pco = pco; }
1881   void set_live_in  (const ResourceBitMap&amp; map)  { _live_in = map;   }
1882   void set_live_out (const ResourceBitMap&amp; map)  { _live_out = map;  }
1883   void set_live_gen (const ResourceBitMap&amp; map)  { _live_gen = map;  }
1884   void set_live_kill(const ResourceBitMap&amp; map)  { _live_kill = map; }
1885   void set_fpu_register_usage(const ResourceBitMap&amp; map) { _fpu_register_usage = map; }
1886   void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }
1887   void set_first_lir_instruction_id(int id)      { _first_lir_instruction_id = id;  }
1888   void set_last_lir_instruction_id(int id)       { _last_lir_instruction_id = id;  }
1889   void increment_total_preds(int n = 1)          { _total_preds += n; }
1890   void init_stores_to_locals(int locals_count)   { _stores_to_locals.initialize(locals_count); }
1891 
1892   // generic
1893   virtual void state_values_do(ValueVisitor* f);
1894 
1895   // successors and predecessors
1896   int number_of_sux() const;
1897   BlockBegin* sux_at(int i) const;
1898   void add_successor(BlockBegin* sux);
1899   void remove_successor(BlockBegin* pred);
1900   bool is_successor(BlockBegin* sux) const       { return _successors.contains(sux); }
1901 
1902   void add_predecessor(BlockBegin* pred);
1903   void remove_predecessor(BlockBegin* pred);
1904   bool is_predecessor(BlockBegin* pred) const    { return _predecessors.contains(pred); }
1905   int number_of_preds() const                    { return _predecessors.length(); }
1906   BlockBegin* pred_at(int i) const               { return _predecessors.at(i); }
1907 
1908   // exception handlers potentially invoked by this block
1909   void add_exception_handler(BlockBegin* b);
1910   bool is_exception_handler(BlockBegin* b) const { return _exception_handlers.contains(b); }
1911   int  number_of_exception_handlers() const      { return _exception_handlers.length(); }
1912   BlockBegin* exception_handler_at(int i) const  { return _exception_handlers.at(i); }
1913 
1914   // states of the instructions that have an edge to this exception handler
1915   int number_of_exception_states()               { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states == NULL ? 0 : _exception_states-&gt;length(); }
1916   ValueStack* exception_state_at(int idx) const  { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states-&gt;at(idx); }
1917   int add_exception_state(ValueStack* state);
1918 
1919   // flags
1920   enum Flag {
1921     no_flag                       = 0,
1922     std_entry_flag                = 1 &lt;&lt; 0,
1923     osr_entry_flag                = 1 &lt;&lt; 1,
1924     exception_entry_flag          = 1 &lt;&lt; 2,
1925     subroutine_entry_flag         = 1 &lt;&lt; 3,
1926     backward_branch_target_flag   = 1 &lt;&lt; 4,
1927     is_on_work_list_flag          = 1 &lt;&lt; 5,
1928     was_visited_flag              = 1 &lt;&lt; 6,
1929     parser_loop_header_flag       = 1 &lt;&lt; 7,  // set by parser to identify blocks where phi functions can not be created on demand
1930     critical_edge_split_flag      = 1 &lt;&lt; 8, // set for all blocks that are introduced when critical edges are split
1931     linear_scan_loop_header_flag  = 1 &lt;&lt; 9, // set during loop-detection for LinearScan
1932     linear_scan_loop_end_flag     = 1 &lt;&lt; 10, // set during loop-detection for LinearScan
1933     donot_eliminate_range_checks  = 1 &lt;&lt; 11  // Should be try to eliminate range checks in this block
1934   };
1935 
1936   void set(Flag f)                               { _flags |= f; }
1937   void clear(Flag f)                             { _flags &amp;= ~f; }
1938   bool is_set(Flag f) const                      { return (_flags &amp; f) != 0; }
1939   bool is_entry_block() const {
1940     const int entry_mask = std_entry_flag | osr_entry_flag | exception_entry_flag;
1941     return (_flags &amp; entry_mask) != 0;
1942   }
1943 
1944   // iteration
1945   void iterate_preorder   (BlockClosure* closure);
1946   void iterate_postorder  (BlockClosure* closure);
1947 
1948   void block_values_do(ValueVisitor* f);
1949 
1950   // loops
1951   void set_loop_index(int ix)                    { _loop_index = ix;        }
1952   int  loop_index() const                        { return _loop_index;      }
1953 
1954   // merging
1955   bool try_merge(ValueStack* state);             // try to merge states at block begin
1956   void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, &quot;merge failed&quot;); }
1957 
1958   // debugging
1959   void print_block()                             PRODUCT_RETURN;
1960   void print_block(InstructionPrinter&amp; ip, bool live_only = false) PRODUCT_RETURN;
1961 };
1962 
1963 
1964 BASE(BlockEnd, StateSplit)
1965  private:
1966   BlockList*  _sux;
1967 
1968  protected:
1969   BlockList* sux() const                         { return _sux; }
1970 
1971   void set_sux(BlockList* sux) {
1972 #ifdef ASSERT
1973     assert(sux != NULL, &quot;sux must exist&quot;);
1974     for (int i = sux-&gt;length() - 1; i &gt;= 0; i--) assert(sux-&gt;at(i) != NULL, &quot;sux must exist&quot;);
1975 #endif
1976     _sux = sux;
1977   }
1978 
1979  public:
1980   // creation
1981   BlockEnd(ValueType* type, ValueStack* state_before, bool is_safepoint)
1982   : StateSplit(type, state_before)
1983   , _sux(NULL)
1984   {
1985     set_flag(IsSafepointFlag, is_safepoint);
1986   }
1987 
1988   // accessors
1989   bool is_safepoint() const                      { return check_flag(IsSafepointFlag); }
1990   // For compatibility with old code, for new code use block()
1991   BlockBegin* begin() const                      { return _block; }
1992 
1993   // manipulation
1994   void set_begin(BlockBegin* begin);
1995 
1996   // successors
1997   int number_of_sux() const                      { return _sux != NULL ? _sux-&gt;length() : 0; }
1998   BlockBegin* sux_at(int i) const                { return _sux-&gt;at(i); }
1999   BlockBegin* default_sux() const                { return sux_at(number_of_sux() - 1); }
2000   BlockBegin** addr_sux_at(int i) const          { return _sux-&gt;adr_at(i); }
2001   int sux_index(BlockBegin* sux) const           { return _sux-&gt;find(sux); }
2002   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
2003 };
2004 
2005 
2006 LEAF(Goto, BlockEnd)
2007  public:
2008   enum Direction {
2009     none,            // Just a regular goto
2010     taken, not_taken // Goto produced from If
2011   };
2012  private:
2013   ciMethod*   _profiled_method;
2014   int         _profiled_bci;
2015   Direction   _direction;
2016  public:
2017   // creation
2018   Goto(BlockBegin* sux, ValueStack* state_before, bool is_safepoint = false)
2019     : BlockEnd(illegalType, state_before, is_safepoint)
2020     , _profiled_method(NULL)
2021     , _profiled_bci(0)
2022     , _direction(none) {
2023     BlockList* s = new BlockList(1);
2024     s-&gt;append(sux);
2025     set_sux(s);
2026   }
2027 
2028   Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)
2029                                            , _profiled_method(NULL)
2030                                            , _profiled_bci(0)
2031                                            , _direction(none) {
2032     BlockList* s = new BlockList(1);
2033     s-&gt;append(sux);
2034     set_sux(s);
2035   }
2036 
2037   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2038   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2039   int profiled_bci() const                       { return _profiled_bci; }
2040   Direction direction() const                    { return _direction; }
2041 
2042   void set_should_profile(bool value)            { set_flag(ProfileMDOFlag, value); }
2043   void set_profiled_method(ciMethod* method)     { _profiled_method = method; }
2044   void set_profiled_bci(int bci)                 { _profiled_bci = bci; }
2045   void set_direction(Direction d)                { _direction = d; }
2046 };
2047 
2048 #ifdef ASSERT
2049 LEAF(Assert, Instruction)
2050   private:
2051   Value       _x;
2052   Condition   _cond;
2053   Value       _y;
2054   char        *_message;
2055 
2056  public:
2057   // creation
2058   // unordered_is_true is valid for float/double compares only
2059    Assert(Value x, Condition cond, bool unordered_is_true, Value y);
2060 
2061   // accessors
2062   Value x() const                                { return _x; }
2063   Condition cond() const                         { return _cond; }
2064   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2065   Value y() const                                { return _y; }
2066   const char *message() const                    { return _message; }
2067 
2068   // generic
2069   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2070 };
2071 #endif
2072 
2073 LEAF(RangeCheckPredicate, StateSplit)
2074  private:
2075   Value       _x;
2076   Condition   _cond;
2077   Value       _y;
2078 
2079   void check_state();
2080 
2081  public:
2082   // creation
2083   // unordered_is_true is valid for float/double compares only
2084    RangeCheckPredicate(Value x, Condition cond, bool unordered_is_true, Value y, ValueStack* state) : StateSplit(illegalType)
2085   , _x(x)
2086   , _cond(cond)
2087   , _y(y)
2088   {
2089     ASSERT_VALUES
2090     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2091     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2092     this-&gt;set_state(state);
2093     check_state();
2094   }
2095 
2096   // Always deoptimize
2097   RangeCheckPredicate(ValueStack* state) : StateSplit(illegalType)
2098   {
2099     this-&gt;set_state(state);
2100     _x = _y = NULL;
2101     check_state();
2102   }
2103 
2104   // accessors
2105   Value x() const                                { return _x; }
2106   Condition cond() const                         { return _cond; }
2107   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2108   Value y() const                                { return _y; }
2109 
2110   void always_fail()                             { _x = _y = NULL; }
2111 
2112   // generic
2113   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2114   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
2115 };
2116 
2117 LEAF(If, BlockEnd)
2118  private:
2119   Value       _x;
2120   Condition   _cond;
2121   Value       _y;
2122   ciMethod*   _profiled_method;
2123   int         _profiled_bci; // Canonicalizer may alter bci of If node
2124   bool        _swapped;      // Is the order reversed with respect to the original If in the
2125                              // bytecode stream?
2126   bool        _substitutability_check;
2127  public:
2128   // creation
2129   // unordered_is_true is valid for float/double compares only
2130   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)
2131     : BlockEnd(illegalType, state_before, is_safepoint)
2132   , _x(x)
2133   , _cond(cond)
2134   , _y(y)
2135   , _profiled_method(NULL)
2136   , _profiled_bci(0)
2137   , _swapped(false)
2138   , _substitutability_check(substitutability_check)
2139   {
2140     ASSERT_VALUES
2141     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2142     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2143     BlockList* s = new BlockList(2);
2144     s-&gt;append(tsux);
2145     s-&gt;append(fsux);
2146     set_sux(s);
2147     if (!_substitutability_check) {
2148       assert(x-&gt;as_NewInlineTypeInstance() == NULL || y-&gt;type() == objectNull, &quot;Sanity check&quot;);
2149       assert(y-&gt;as_NewInlineTypeInstance() == NULL || x-&gt;type() == objectNull, &quot;Sanity check&quot;);
2150     }
2151   }
2152 
2153   // accessors
2154   Value x() const                                { return _x; }
2155   Condition cond() const                         { return _cond; }
2156   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2157   Value y() const                                { return _y; }
2158   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2159   BlockBegin* tsux() const                       { return sux_for(true); }
2160   BlockBegin* fsux() const                       { return sux_for(false); }
2161   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2162   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2163   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2164   int profiled_bci() const                       { return _profiled_bci; }    // set for profiled branches and tiered
2165   bool is_swapped() const                        { return _swapped; }
2166 
2167   // manipulation
2168   void swap_operands() {
2169     Value t = _x; _x = _y; _y = t;
2170     _cond = mirror(_cond);
2171   }
2172 
2173   void swap_sux() {
2174     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2175     BlockList* s = sux();
2176     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2177     _cond = negate(_cond);
2178     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2179   }
2180 
2181   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2182   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2183   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2184   void set_swapped(bool value)                    { _swapped = value;         }
2185   bool substitutability_check() const              { return _substitutability_check; }
2186   // generic
2187   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2188 };
2189 
2190 
2191 LEAF(IfInstanceOf, BlockEnd)
2192  private:
2193   ciKlass* _klass;
2194   Value    _obj;
2195   bool     _test_is_instance;                    // jump if instance
2196   int      _instanceof_bci;
2197 
2198  public:
2199   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2200   : BlockEnd(illegalType, NULL, false) // temporary set to false
2201   , _klass(klass)
2202   , _obj(obj)
2203   , _test_is_instance(test_is_instance)
2204   , _instanceof_bci(instanceof_bci)
2205   {
2206     ASSERT_VALUES
2207     assert(instanceof_bci &gt;= 0, &quot;illegal bci&quot;);
2208     BlockList* s = new BlockList(2);
2209     s-&gt;append(tsux);
2210     s-&gt;append(fsux);
2211     set_sux(s);
2212   }
2213 
2214   // accessors
2215   //
2216   // Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an
2217   //         instance of klass; otherwise it tests if it is *not* and instance
2218   //         of klass.
2219   //
2220   // Note 2: IfInstanceOf instructions are created by combining an InstanceOf
2221   //         and an If instruction. The IfInstanceOf bci() corresponds to the
2222   //         bci that the If would have had; the (this-&gt;) instanceof_bci() is
2223   //         the bci of the original InstanceOf instruction.
2224   ciKlass* klass() const                         { return _klass; }
2225   Value obj() const                              { return _obj; }
2226   int instanceof_bci() const                     { return _instanceof_bci; }
2227   bool test_is_instance() const                  { return _test_is_instance; }
2228   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2229   BlockBegin* tsux() const                       { return sux_for(true); }
2230   BlockBegin* fsux() const                       { return sux_for(false); }
2231 
2232   // manipulation
2233   void swap_sux() {
2234     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2235     BlockList* s = sux();
2236     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2237     _test_is_instance = !_test_is_instance;
2238   }
2239 
2240   // generic
2241   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_obj); }
2242 };
2243 
2244 
2245 BASE(Switch, BlockEnd)
2246  private:
2247   Value       _tag;
2248 
2249  public:
2250   // creation
2251   Switch(Value tag, BlockList* sux, ValueStack* state_before, bool is_safepoint)
2252   : BlockEnd(illegalType, state_before, is_safepoint)
2253   , _tag(tag) {
2254     ASSERT_VALUES
2255     set_sux(sux);
2256   }
2257 
2258   // accessors
2259   Value tag() const                              { return _tag; }
2260   int length() const                             { return number_of_sux() - 1; }
2261 
2262   virtual bool needs_exception_state() const     { return false; }
2263 
2264   // generic
2265   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_tag); }
2266 };
2267 
2268 
2269 LEAF(TableSwitch, Switch)
2270  private:
2271   int _lo_key;
2272 
2273  public:
2274   // creation
2275   TableSwitch(Value tag, BlockList* sux, int lo_key, ValueStack* state_before, bool is_safepoint)
2276     : Switch(tag, sux, state_before, is_safepoint)
2277   , _lo_key(lo_key) { assert(_lo_key &lt;= hi_key(), &quot;integer overflow&quot;); }
2278 
2279   // accessors
2280   int lo_key() const                             { return _lo_key; }
2281   int hi_key() const                             { return _lo_key + (length() - 1); }
2282 };
2283 
2284 
2285 LEAF(LookupSwitch, Switch)
2286  private:
2287   intArray* _keys;
2288 
2289  public:
2290   // creation
2291   LookupSwitch(Value tag, BlockList* sux, intArray* keys, ValueStack* state_before, bool is_safepoint)
2292   : Switch(tag, sux, state_before, is_safepoint)
2293   , _keys(keys) {
2294     assert(keys != NULL, &quot;keys must exist&quot;);
2295     assert(keys-&gt;length() == length(), &quot;sux &amp; keys have incompatible lengths&quot;);
2296   }
2297 
2298   // accessors
2299   int key_at(int i) const                        { return _keys-&gt;at(i); }
2300 };
2301 
2302 
2303 LEAF(Return, BlockEnd)
2304  private:
2305   Value _result;
2306 
2307  public:
2308   // creation
2309   Return(Value result) :
2310     BlockEnd(result == NULL ? voidType : result-&gt;type()-&gt;base(), NULL, true),
2311     _result(result) {}
2312 
2313   // accessors
2314   Value result() const                           { return _result; }
2315   bool has_result() const                        { return result() != NULL; }
2316 
2317   // generic
2318   virtual void input_values_do(ValueVisitor* f) {
2319     BlockEnd::input_values_do(f);
2320     if (has_result()) f-&gt;visit(&amp;_result);
2321   }
2322 };
2323 
2324 
2325 LEAF(Throw, BlockEnd)
2326  private:
2327   Value _exception;
2328 
2329  public:
2330   // creation
2331   Throw(Value exception, ValueStack* state_before) : BlockEnd(illegalType, state_before, true), _exception(exception) {
2332     ASSERT_VALUES
2333   }
2334 
2335   // accessors
2336   Value exception() const                        { return _exception; }
2337 
2338   // generic
2339   virtual bool can_trap() const                  { return true; }
2340   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_exception); }
2341 };
2342 
2343 
2344 LEAF(Base, BlockEnd)
2345  public:
2346   // creation
2347   Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {
2348     assert(std_entry-&gt;is_set(BlockBegin::std_entry_flag), &quot;std entry must be flagged&quot;);
2349     assert(osr_entry == NULL || osr_entry-&gt;is_set(BlockBegin::osr_entry_flag), &quot;osr entry must be flagged&quot;);
2350     BlockList* s = new BlockList(2);
2351     if (osr_entry != NULL) s-&gt;append(osr_entry);
2352     s-&gt;append(std_entry); // must be default sux!
2353     set_sux(s);
2354   }
2355 
2356   // accessors
2357   BlockBegin* std_entry() const                  { return default_sux(); }
2358   BlockBegin* osr_entry() const                  { return number_of_sux() &lt; 2 ? NULL : sux_at(0); }
2359 };
2360 
2361 
2362 LEAF(OsrEntry, Instruction)
2363  public:
2364   // creation
2365 #ifdef _LP64
2366   OsrEntry() : Instruction(longType) { pin(); }
2367 #else
2368   OsrEntry() : Instruction(intType)  { pin(); }
2369 #endif
2370 
2371   // generic
2372   virtual void input_values_do(ValueVisitor* f)   { }
2373 };
2374 
2375 
2376 // Models the incoming exception at a catch site
2377 LEAF(ExceptionObject, Instruction)
2378  public:
2379   // creation
2380   ExceptionObject() : Instruction(objectType) {
2381     pin();
2382   }
2383 
2384   // generic
2385   virtual void input_values_do(ValueVisitor* f)   { }
2386 };
2387 
2388 
2389 // Models needed rounding for floating-point values on Intel.
2390 // Currently only used to represent rounding of double-precision
2391 // values stored into local variables, but could be used to model
2392 // intermediate rounding of single-precision values as well.
2393 LEAF(RoundFP, Instruction)
2394  private:
2395   Value _input;             // floating-point value to be rounded
2396 
2397  public:
2398   RoundFP(Value input)
2399   : Instruction(input-&gt;type()) // Note: should not be used for constants
2400   , _input(input)
2401   {
2402     ASSERT_VALUES
2403   }
2404 
2405   // accessors
2406   Value input() const                            { return _input; }
2407 
2408   // generic
2409   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_input); }
2410 };
2411 
2412 
2413 BASE(UnsafeOp, Instruction)
2414  private:
2415   BasicType _basic_type;    // ValueType can not express byte-sized integers
2416 
2417  protected:
2418   // creation
2419   UnsafeOp(BasicType basic_type, bool is_put)
2420   : Instruction(is_put ? voidType : as_ValueType(basic_type))
2421   , _basic_type(basic_type)
2422   {
2423     //Note:  Unsafe ops are not not guaranteed to throw NPE.
2424     // Convservatively, Unsafe operations must be pinned though we could be
2425     // looser about this if we wanted to..
2426     pin();
2427   }
2428 
2429  public:
2430   // accessors
2431   BasicType basic_type()                         { return _basic_type; }
2432 
2433   // generic
2434   virtual void input_values_do(ValueVisitor* f)   { }
2435 };
2436 
2437 
2438 BASE(UnsafeRawOp, UnsafeOp)
2439  private:
2440   Value _base;                                   // Base address (a Java long)
2441   Value _index;                                  // Index if computed by optimizer; initialized to NULL
2442   int   _log2_scale;                             // Scale factor: 0, 1, 2, or 3.
2443                                                  // Indicates log2 of number of bytes (1, 2, 4, or 8)
2444                                                  // to scale index by.
2445 
2446  protected:
2447   UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)
2448   : UnsafeOp(basic_type, is_put)
2449   , _base(addr)
2450   , _index(NULL)
2451   , _log2_scale(0)
2452   {
2453     // Can not use ASSERT_VALUES because index may be NULL
2454     assert(addr != NULL &amp;&amp; addr-&gt;type()-&gt;is_long(), &quot;just checking&quot;);
2455   }
2456 
2457   UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)
2458   : UnsafeOp(basic_type, is_put)
2459   , _base(base)
2460   , _index(index)
2461   , _log2_scale(log2_scale)
2462   {
2463   }
2464 
2465  public:
2466   // accessors
2467   Value base()                                   { return _base; }
2468   Value index()                                  { return _index; }
2469   bool  has_index()                              { return (_index != NULL); }
2470   int   log2_scale()                             { return _log2_scale; }
2471 
2472   // setters
2473   void set_base (Value base)                     { _base  = base; }
2474   void set_index(Value index)                    { _index = index; }
2475   void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }
2476 
2477   // generic
2478   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2479                                                    f-&gt;visit(&amp;_base);
2480                                                    if (has_index()) f-&gt;visit(&amp;_index); }
2481 };
2482 
2483 
2484 LEAF(UnsafeGetRaw, UnsafeRawOp)
2485  private:
2486  bool _may_be_unaligned, _is_wide;  // For OSREntry
2487 
2488  public:
2489  UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)
2490   : UnsafeRawOp(basic_type, addr, false) {
2491     _may_be_unaligned = may_be_unaligned;
2492     _is_wide = is_wide;
2493   }
2494 
2495  UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)
2496   : UnsafeRawOp(basic_type, base, index, log2_scale, false) {
2497     _may_be_unaligned = may_be_unaligned;
2498     _is_wide = is_wide;
2499   }
2500 
2501   bool may_be_unaligned()                         { return _may_be_unaligned; }
2502   bool is_wide()                                  { return _is_wide; }
2503 };
2504 
2505 
2506 LEAF(UnsafePutRaw, UnsafeRawOp)
2507  private:
2508   Value _value;                                  // Value to be stored
2509 
2510  public:
2511   UnsafePutRaw(BasicType basic_type, Value addr, Value value)
2512   : UnsafeRawOp(basic_type, addr, true)
2513   , _value(value)
2514   {
2515     assert(value != NULL, &quot;just checking&quot;);
2516     ASSERT_VALUES
2517   }
2518 
2519   UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)
2520   : UnsafeRawOp(basic_type, base, index, log2_scale, true)
2521   , _value(value)
2522   {
2523     assert(value != NULL, &quot;just checking&quot;);
2524     ASSERT_VALUES
2525   }
2526 
2527   // accessors
2528   Value value()                                  { return _value; }
2529 
2530   // generic
2531   virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);
2532                                                    f-&gt;visit(&amp;_value); }
2533 };
2534 
2535 
2536 BASE(UnsafeObjectOp, UnsafeOp)
2537  private:
2538   Value _object;                                 // Object to be fetched from or mutated
2539   Value _offset;                                 // Offset within object
2540   bool  _is_volatile;                            // true if volatile - dl/JSR166
2541  public:
2542   UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)
2543     : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)
2544   {
2545   }
2546 
2547   // accessors
2548   Value object()                                 { return _object; }
2549   Value offset()                                 { return _offset; }
2550   bool  is_volatile()                            { return _is_volatile; }
2551   // generic
2552   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2553                                                    f-&gt;visit(&amp;_object);
2554                                                    f-&gt;visit(&amp;_offset); }
2555 };
2556 
2557 
2558 LEAF(UnsafeGetObject, UnsafeObjectOp)
2559  public:
2560   UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)
2561   : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)
2562   {
2563     ASSERT_VALUES
2564   }
2565 };
2566 
2567 
2568 LEAF(UnsafePutObject, UnsafeObjectOp)
2569  private:
2570   Value _value;                                  // Value to be stored
2571  public:
2572   UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)
2573   : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)
2574     , _value(value)
2575   {
2576     ASSERT_VALUES
2577   }
2578 
2579   // accessors
2580   Value value()                                  { return _value; }
2581 
2582   // generic
2583   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2584                                                    f-&gt;visit(&amp;_value); }
2585 };
2586 
2587 LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)
2588  private:
2589   Value _value;                                  // Value to be stored
2590   bool  _is_add;
2591  public:
2592   UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)
2593   : UnsafeObjectOp(basic_type, object, offset, false, false)
2594     , _value(value)
2595     , _is_add(is_add)
2596   {
2597     ASSERT_VALUES
2598   }
2599 
2600   // accessors
2601   bool is_add() const                            { return _is_add; }
2602   Value value()                                  { return _value; }
2603 
2604   // generic
2605   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2606                                                    f-&gt;visit(&amp;_value); }
2607 };
2608 
2609 LEAF(ProfileCall, Instruction)
2610  private:
2611   ciMethod*        _method;
2612   int              _bci_of_invoke;
2613   ciMethod*        _callee;         // the method that is called at the given bci
2614   Value            _recv;
2615   ciKlass*         _known_holder;
2616   Values*          _obj_args;       // arguments for type profiling
2617   ArgsNonNullState _nonnull_state;  // Do we know whether some arguments are never null?
2618   bool             _inlined;        // Are we profiling a call that is inlined
2619 
2620  public:
2621   ProfileCall(ciMethod* method, int bci, ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined)
2622     : Instruction(voidType)
2623     , _method(method)
2624     , _bci_of_invoke(bci)
2625     , _callee(callee)
2626     , _recv(recv)
2627     , _known_holder(known_holder)
2628     , _obj_args(obj_args)
2629     , _inlined(inlined)
2630   {
2631     // The ProfileCall has side-effects and must occur precisely where located
2632     pin();
2633   }
2634 
2635   ciMethod* method()             const { return _method; }
2636   int bci_of_invoke()            const { return _bci_of_invoke; }
2637   ciMethod* callee()             const { return _callee; }
2638   Value recv()                   const { return _recv; }
2639   ciKlass* known_holder()        const { return _known_holder; }
2640   int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args-&gt;length(); }
2641   Value profiled_arg_at(int i)   const { return _obj_args-&gt;at(i); }
2642   bool arg_needs_null_check(int i) const {
2643     return _nonnull_state.arg_needs_null_check(i);
2644   }
2645   bool inlined()                 const { return _inlined; }
2646 
2647   void set_arg_needs_null_check(int i, bool check) {
2648     _nonnull_state.set_arg_needs_null_check(i, check);
2649   }
2650 
2651   virtual void input_values_do(ValueVisitor* f)   {
2652     if (_recv != NULL) {
2653       f-&gt;visit(&amp;_recv);
2654     }
2655     for (int i = 0; i &lt; nb_profiled_args(); i++) {
2656       f-&gt;visit(_obj_args-&gt;adr_at(i));
2657     }
2658   }
2659 };
2660 
2661 LEAF(ProfileReturnType, Instruction)
2662  private:
2663   ciMethod*        _method;
2664   ciMethod*        _callee;
2665   int              _bci_of_invoke;
2666   Value            _ret;
2667 
2668  public:
2669   ProfileReturnType(ciMethod* method, int bci, ciMethod* callee, Value ret)
2670     : Instruction(voidType)
2671     , _method(method)
2672     , _callee(callee)
2673     , _bci_of_invoke(bci)
2674     , _ret(ret)
2675   {
2676     set_needs_null_check(true);
2677     // The ProfileType has side-effects and must occur precisely where located
2678     pin();
2679   }
2680 
2681   ciMethod* method()             const { return _method; }
2682   ciMethod* callee()             const { return _callee; }
2683   int bci_of_invoke()            const { return _bci_of_invoke; }
2684   Value ret()                    const { return _ret; }
2685 
2686   virtual void input_values_do(ValueVisitor* f)   {
2687     if (_ret != NULL) {
2688       f-&gt;visit(&amp;_ret);
2689     }
2690   }
2691 };
2692 
2693 // Call some C runtime function that doesn&#39;t safepoint,
2694 // optionally passing the current thread as the first argument.
2695 LEAF(RuntimeCall, Instruction)
2696  private:
2697   const char* _entry_name;
2698   address     _entry;
2699   Values*     _args;
2700   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
2701 
2702  public:
2703   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
2704     : Instruction(type)
2705     , _entry_name(entry_name)
2706     , _entry(entry)
2707     , _args(args)
2708     , _pass_thread(pass_thread) {
2709     ASSERT_VALUES
2710     pin();
2711   }
2712 
2713   const char* entry_name() const  { return _entry_name; }
2714   address entry() const           { return _entry; }
2715   int number_of_arguments() const { return _args-&gt;length(); }
2716   Value argument_at(int i) const  { return _args-&gt;at(i); }
2717   bool pass_thread() const        { return _pass_thread; }
2718 
2719   virtual void input_values_do(ValueVisitor* f)   {
2720     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
2721   }
2722 };
2723 
2724 // Use to trip invocation counter of an inlined method
2725 
2726 LEAF(ProfileInvoke, Instruction)
2727  private:
2728   ciMethod*   _inlinee;
2729   ValueStack* _state;
2730 
2731  public:
2732   ProfileInvoke(ciMethod* inlinee,  ValueStack* state)
2733     : Instruction(voidType)
2734     , _inlinee(inlinee)
2735     , _state(state)
2736   {
2737     // The ProfileInvoke has side-effects and must occur precisely where located QQQ???
2738     pin();
2739   }
2740 
2741   ciMethod* inlinee()      { return _inlinee; }
2742   ValueStack* state()      { return _state; }
2743   virtual void input_values_do(ValueVisitor*)   {}
2744   virtual void state_values_do(ValueVisitor*);
2745 };
2746 
2747 LEAF(MemBar, Instruction)
2748  private:
2749   LIR_Code _code;
2750 
2751  public:
2752   MemBar(LIR_Code code)
2753     : Instruction(voidType)
2754     , _code(code)
2755   {
2756     pin();
2757   }
2758 
2759   LIR_Code code()           { return _code; }
2760 
2761   virtual void input_values_do(ValueVisitor*)   {}
2762 };
2763 
2764 class BlockPair: public CompilationResourceObj {
2765  private:
2766   BlockBegin* _from;
2767   BlockBegin* _to;
2768  public:
2769   BlockPair(BlockBegin* from, BlockBegin* to): _from(from), _to(to) {}
2770   BlockBegin* from() const { return _from; }
2771   BlockBegin* to() const   { return _to;   }
2772   bool is_same(BlockBegin* from, BlockBegin* to) const { return  _from == from &amp;&amp; _to == to; }
2773   bool is_same(BlockPair* p) const { return  _from == p-&gt;from() &amp;&amp; _to == p-&gt;to(); }
2774   void set_to(BlockBegin* b)   { _to = b; }
2775   void set_from(BlockBegin* b) { _from = b; }
2776 };
2777 
2778 typedef GrowableArray&lt;BlockPair*&gt; BlockPairList;
2779 
2780 inline int         BlockBegin::number_of_sux() const            { assert(_end == NULL || _end-&gt;number_of_sux() == _successors.length(), &quot;mismatch&quot;); return _successors.length(); }
2781 inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end == NULL || _end-&gt;sux_at(i) == _successors.at(i), &quot;mismatch&quot;);          return _successors.at(i); }
2782 inline void        BlockBegin::add_successor(BlockBegin* sux)   { assert(_end == NULL, &quot;Would create mismatch with successors of BlockEnd&quot;);         _successors.append(sux); }
2783 
2784 #undef ASSERT_VALUES
2785 
2786 #endif // SHARE_C1_C1_INSTRUCTION_HPP
    </pre>
  </body>
</html>