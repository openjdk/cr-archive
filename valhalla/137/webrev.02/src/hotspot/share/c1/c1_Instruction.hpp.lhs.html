<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_INSTRUCTION_HPP
  26 #define SHARE_C1_C1_INSTRUCTION_HPP
  27 
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIR.hpp&quot;
  30 #include &quot;c1/c1_ValueType.hpp&quot;
  31 #include &quot;ci/ciField.hpp&quot;
  32 
  33 // Predefined classes
  34 class ciField;
  35 class ValueStack;
  36 class InstructionPrinter;
  37 class IRScope;
  38 class LIR_OprDesc;
  39 typedef LIR_OprDesc* LIR_Opr;
  40 
  41 
  42 // Instruction class hierarchy
  43 //
  44 // All leaf classes in the class hierarchy are concrete classes
  45 // (i.e., are instantiated). All other classes are abstract and
  46 // serve factoring.
  47 
  48 class Instruction;
  49 class   Phi;
  50 class   Local;
  51 class   Constant;
  52 class   AccessField;
  53 class     LoadField;
  54 class     StoreField;
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
  75 class     NewInlineTypeInstance;
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
  80 class     WithField;
  81 class     DefaultValue;
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
  96 class         LookupSwitch;
  97 class       Return;
  98 class       Throw;
  99 class       Base;
 100 class   RoundFP;
 101 class   UnsafeOp;
 102 class     UnsafeRawOp;
 103 class       UnsafeGetRaw;
 104 class       UnsafePutRaw;
 105 class     UnsafeObjectOp;
 106 class       UnsafeGetObject;
 107 class       UnsafePutObject;
 108 class         UnsafeGetAndSetObject;
 109 class   ProfileCall;
 110 class   ProfileReturnType;
 111 class   ProfileInvoke;
 112 class   RuntimeCall;
 113 class   MemBar;
 114 class   RangeCheckPredicate;
 115 #ifdef ASSERT
 116 class   Assert;
 117 #endif
 118 
 119 // A Value is a reference to the instruction creating the value
 120 typedef Instruction* Value;
 121 typedef GrowableArray&lt;Value&gt; Values;
 122 typedef GrowableArray&lt;ValueStack*&gt; ValueStackStack;
 123 
 124 // BlockClosure is the base class for block traversal/iteration.
 125 
 126 class BlockClosure: public CompilationResourceObj {
 127  public:
 128   virtual void block_do(BlockBegin* block)       = 0;
 129 };
 130 
 131 
 132 // A simple closure class for visiting the values of an Instruction
 133 class ValueVisitor: public StackObj {
 134  public:
 135   virtual void visit(Value* v) = 0;
 136 };
 137 
 138 
 139 // Some array and list classes
 140 typedef GrowableArray&lt;BlockBegin*&gt; BlockBeginArray;
 141 
 142 class BlockList: public GrowableArray&lt;BlockBegin*&gt; {
 143  public:
 144   BlockList(): GrowableArray&lt;BlockBegin*&gt;() {}
 145   BlockList(const int size): GrowableArray&lt;BlockBegin*&gt;(size) {}
 146   BlockList(const int size, BlockBegin* init): GrowableArray&lt;BlockBegin*&gt;(size, size, init) {}
 147 
 148   void iterate_forward(BlockClosure* closure);
 149   void iterate_backward(BlockClosure* closure);
 150   void blocks_do(void f(BlockBegin*));
 151   void values_do(ValueVisitor* f);
 152   void print(bool cfg_only = false, bool live_only = false) PRODUCT_RETURN;
 153 };
 154 
 155 
 156 // InstructionVisitors provide type-based dispatch for instructions.
 157 // For each concrete Instruction class X, a virtual function do_X is
 158 // provided. Functionality that needs to be implemented for all classes
 159 // (e.g., printing, code generation) is factored out into a specialised
 160 // visitor instead of added to the Instruction classes itself.
 161 
 162 class InstructionVisitor: public StackObj {
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
 183   virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x) = 0;
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 187   virtual void do_WithField      (WithField*       x) = 0;
 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 204   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 205   virtual void do_RoundFP        (RoundFP*         x) = 0;
 206   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 207   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 208   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 209   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 210   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 211   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 212   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 213   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 214   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 215   virtual void do_MemBar         (MemBar*          x) = 0;
 216   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 217 #ifdef ASSERT
 218   virtual void do_Assert         (Assert*          x) = 0;
 219 #endif
 220 };
 221 
 222 
 223 // Hashing support
 224 //
 225 // Note: This hash functions affect the performance
 226 //       of ValueMap - make changes carefully!
 227 
 228 #define HASH1(x1            )                    ((intx)(x1))
 229 #define HASH2(x1, x2        )                    ((HASH1(x1            ) &lt;&lt; 7) ^ HASH1(x2))
 230 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2        ) &lt;&lt; 7) ^ HASH1(x3))
 231 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3    ) &lt;&lt; 7) ^ HASH1(x4))
 232 #define HASH5(x1, x2, x3, x4, x5)                ((HASH4(x1, x2, x3, x4) &lt;&lt; 7) ^ HASH1(x5))
 233 
 234 
 235 // The following macros are used to implement instruction-specific hashing.
 236 // By default, each instruction implements hash() and is_equal(Value), used
 237 // for value numbering/common subexpression elimination. The default imple-
 238 // mentation disables value numbering. Each instruction which can be value-
 239 // numbered, should define corresponding hash() and is_equal(Value) functions
 240 // via the macros below. The f arguments specify all the values/op codes, etc.
 241 // that need to be identical for two instructions to be identical.
 242 //
 243 // Note: The default implementation of hash() returns 0 in order to indicate
 244 //       that the instruction should not be considered for value numbering.
 245 //       The currently used hash functions do not guarantee that never a 0
 246 //       is produced. While this is still correct, it may be a performance
 247 //       bug (no value numbering for that node). However, this situation is
 248 //       so unlikely, that we are not going to handle it specially.
 249 
 250 #define HASHING1(class_name, enabled, f1)             \
 251   virtual intx hash() const {                         \
 252     return (enabled) ? HASH2(name(), f1) : 0;         \
 253   }                                                   \
 254   virtual bool is_equal(Value v) const {              \
 255     if (!(enabled)  ) return false;                   \
 256     class_name* _v = v-&gt;as_##class_name();            \
 257     if (_v == NULL  ) return false;                   \
 258     if (f1 != _v-&gt;f1) return false;                   \
 259     return true;                                      \
 260   }                                                   \
 261 
 262 
 263 #define HASHING2(class_name, enabled, f1, f2)         \
 264   virtual intx hash() const {                         \
 265     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 266   }                                                   \
 267   virtual bool is_equal(Value v) const {              \
 268     if (!(enabled)  ) return false;                   \
 269     class_name* _v = v-&gt;as_##class_name();            \
 270     if (_v == NULL  ) return false;                   \
 271     if (f1 != _v-&gt;f1) return false;                   \
 272     if (f2 != _v-&gt;f2) return false;                   \
 273     return true;                                      \
 274   }                                                   \
 275 
 276 
 277 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 278   virtual intx hash() const {                         \
 279     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 280   }                                                   \
 281   virtual bool is_equal(Value v) const {              \
 282     if (!(enabled)  ) return false;                   \
 283     class_name* _v = v-&gt;as_##class_name();            \
 284     if (_v == NULL  ) return false;                   \
 285     if (f1 != _v-&gt;f1) return false;                   \
 286     if (f2 != _v-&gt;f2) return false;                   \
 287     if (f3 != _v-&gt;f3) return false;                   \
 288     return true;                                      \
 289   }                                                   \
 290 
 291 #define HASHING4(class_name, enabled, f1, f2, f3, f4) \
 292   virtual intx hash() const {                         \
 293     return (enabled) ? HASH5(name(), f1, f2, f3, f4) : 0; \
 294   }                                                   \
 295   virtual bool is_equal(Value v) const {              \
 296     if (!(enabled)  ) return false;                   \
 297     class_name* _v = v-&gt;as_##class_name();            \
 298     if (_v == NULL  ) return false;                   \
 299     if (f1 != _v-&gt;f1) return false;                   \
 300     if (f2 != _v-&gt;f2) return false;                   \
 301     if (f3 != _v-&gt;f3) return false;                   \
 302     if (f4 != _v-&gt;f4) return false;                   \
 303     return true;                                      \
 304   }                                                   \
 305 
 306 
 307 // The mother of all instructions...
 308 
 309 class Instruction: public CompilationResourceObj {
 310  private:
 311   int          _id;                              // the unique instruction id
 312 #ifndef PRODUCT
 313   int          _printable_bci;                   // the bci of the instruction for printing
 314 #endif
 315   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 316   int          _pin_state;                       // set of PinReason describing the reason for pinning
 317   ValueType*   _type;                            // the instruction value type
 318   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 319   Instruction* _subst;                           // the substitution instruction if any
 320   LIR_Opr      _operand;                         // LIR specific information
 321   unsigned int _flags;                           // Flag bits
 322 
 323   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 324   ValueStack*  _exception_state;                 // Copy of state for exception handling
 325   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 326 
 327   friend class UseCountComputer;
 328 
 329   void update_exception_state(ValueStack* state);
 330 
 331  protected:
 332   BlockBegin*  _block;                           // Block that contains this instruction
 333 
 334   void set_type(ValueType* type) {
 335     assert(type != NULL, &quot;type must exist&quot;);
 336     _type = type;
 337   }
 338 
 339   // Helper class to keep track of which arguments need a null check
 340   class ArgsNonNullState {
 341   private:
 342     int _nonnull_state; // mask identifying which args are nonnull
 343   public:
 344     ArgsNonNullState()
 345       : _nonnull_state(AllBits) {}
 346 
 347     // Does argument number i needs a null check?
 348     bool arg_needs_null_check(int i) const {
 349       // No data is kept for arguments starting at position 33 so
 350       // conservatively assume that they need a null check.
 351       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 352         return is_set_nth_bit(_nonnull_state, i);
 353       }
 354       return true;
 355     }
 356 
 357     // Set whether argument number i needs a null check or not
 358     void set_arg_needs_null_check(int i, bool check) {
 359       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 360         if (check) {
 361           _nonnull_state |= nth_bit(i);
 362         } else {
 363           _nonnull_state &amp;= ~(nth_bit(i));
 364         }
 365       }
 366     }
 367   };
 368 
 369  public:
 370   void* operator new(size_t size) throw() {
 371     Compilation* c = Compilation::current();
 372     void* res = c-&gt;arena()-&gt;Amalloc(size);
 373     return res;
 374   }
 375 
 376   static const int no_bci = -99;
 377 
 378   enum InstructionFlag {
 379     NeedsNullCheckFlag = 0,
 380     NeverNullFlag,          // For &quot;Q&quot; signatures
 381     CanTrapFlag,
 382     DirectCompareFlag,
 383     IsEliminatedFlag,
 384     IsSafepointFlag,
 385     IsStaticFlag,
 386     IsStrictfpFlag,
 387     NeedsStoreCheckFlag,
 388     NeedsWriteBarrierFlag,
 389     PreservesStateFlag,
 390     TargetIsFinalFlag,
 391     TargetIsLoadedFlag,
 392     TargetIsStrictfpFlag,
 393     UnorderedIsTrueFlag,
 394     NeedsPatchingFlag,
 395     ThrowIncompatibleClassChangeErrorFlag,
 396     InvokeSpecialReceiverCheckFlag,
 397     ProfileMDOFlag,
 398     IsLinkedInBlockFlag,
 399     NeedsRangeCheckFlag,
 400     InWorkListFlag,
 401     DeoptimizeOnException,
 402     InstructionLastFlag
 403   };
 404 
 405  public:
 406   bool check_flag(InstructionFlag id) const      { return (_flags &amp; (1 &lt;&lt; id)) != 0;    }
 407   void set_flag(InstructionFlag id, bool f)      { _flags = f ? (_flags | (1 &lt;&lt; id)) : (_flags &amp; ~(1 &lt;&lt; id)); };
 408 
 409   // &#39;globally&#39; used condition values
 410   enum Condition {
 411     eql, neq, lss, leq, gtr, geq, aeq, beq
 412   };
 413 
 414   // Instructions may be pinned for many reasons and under certain conditions
 415   // with enough knowledge it&#39;s possible to safely unpin them.
 416   enum PinReason {
 417       PinUnknown           = 1 &lt;&lt; 0
 418     , PinExplicitNullCheck = 1 &lt;&lt; 3
 419     , PinStackForStateSplit= 1 &lt;&lt; 12
 420     , PinStateSplitConstructor= 1 &lt;&lt; 13
 421     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 422   };
 423 
 424   static Condition mirror(Condition cond);
 425   static Condition negate(Condition cond);
 426 
 427   // initialization
 428   static int number_of_instructions() {
 429     return Compilation::current()-&gt;number_of_instructions();
 430   }
 431 
 432   // creation
 433   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
 434   : _id(Compilation::current()-&gt;get_next_id()),
 435 #ifndef PRODUCT
 436   _printable_bci(-99),
 437 #endif
 438     _use_count(0)
 439   , _pin_state(0)
 440   , _type(type)
 441   , _next(NULL)
 442   , _subst(NULL)
 443   , _operand(LIR_OprFact::illegalOpr)
 444   , _flags(0)
 445   , _state_before(state_before)
 446   , _exception_handlers(NULL)
 447   , _block(NULL)
 448   {
 449     check_state(state_before);
 450     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 451     update_exception_state(_state_before);
 452   }
 453 
 454   // accessors
 455   int id() const                                 { return _id; }
 456 #ifndef PRODUCT
 457   bool has_printable_bci() const                 { return _printable_bci != -99; }
 458   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 459   void set_printable_bci(int bci)                { _printable_bci = bci; }
 460 #endif
 461   int dominator_depth();
 462   int use_count() const                          { return _use_count; }
 463   int pin_state() const                          { return _pin_state; }
 464   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 465   ValueType* type() const                        { return _type; }
 466   BlockBegin *block() const                      { return _block; }
 467   Instruction* prev();                           // use carefully, expensive operation
 468   Instruction* next() const                      { return _next; }
 469   bool has_subst() const                         { return _subst != NULL; }
 470   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 471   LIR_Opr operand() const                        { return _operand; }
 472 
 473   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 474   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 475   void set_null_free(bool f)                    { set_flag(NeverNullFlag, f); }
 476   bool is_null_free() const                     { return check_flag(NeverNullFlag); }
 477   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 478   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 479 
 480   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 481 
 482   bool has_uses() const                          { return use_count() &gt; 0; }
 483   ValueStack* state_before() const               { return _state_before; }
 484   ValueStack* exception_state() const            { return _exception_state; }
 485   virtual bool needs_exception_state() const     { return true; }
 486   XHandlers* exception_handlers() const          { return _exception_handlers; }
 487   ciKlass* as_loaded_klass_or_null() const;
 488 
 489   // withfield optimization
 490   virtual void set_escaped()                     { }
 491   virtual void set_local_index(int index)        { }
 492   virtual bool is_optimizable_for_withfield() const { return false; }
 493 
 494 
 495   // manipulation
 496   void pin(PinReason reason)                     { _pin_state |= reason; }
 497   void pin()                                     { _pin_state |= PinUnknown; }
 498   // DANGEROUS: only used by EliminateStores
 499   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 500 
 501   Instruction* set_next(Instruction* next) {
 502     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 503     assert(next != NULL, &quot;must not be NULL&quot;);
 504     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 505     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 506 
 507     BlockBegin *block = this-&gt;block();
 508     next-&gt;_block = block;
 509 
 510     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 511     _next = next;
 512     return next;
 513   }
 514 
 515   Instruction* set_next(Instruction* next, int bci) {
 516 #ifndef PRODUCT
 517     next-&gt;set_printable_bci(bci);
 518 #endif
 519     return set_next(next);
 520   }
 521 
 522   // when blocks are merged
 523   void fixup_block_pointers() {
 524     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 525     while (cur &amp;&amp; cur-&gt;_block != block()) {
 526       cur-&gt;_block = block();
 527       cur = cur-&gt;next();
 528     }
 529   }
 530 
 531   Instruction *insert_after(Instruction *i) {
 532     Instruction* n = _next;
 533     set_next(i);
 534     i-&gt;set_next(n);
 535     return _next;
 536   }
 537 
 538   bool is_loaded_flattened_array() const;
 539   bool maybe_flattened_array();
 540   bool maybe_null_free_array();
 541 
 542   Instruction *insert_after_same_bci(Instruction *i) {
 543 #ifndef PRODUCT
 544     i-&gt;set_printable_bci(printable_bci());
 545 #endif
 546     return insert_after(i);
 547   }
 548 
 549   void set_subst(Instruction* subst)             {
 550     assert(subst == NULL ||
 551            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 552            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 553     _subst = subst;
 554   }
 555   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 556   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 557   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 558 
 559   // machine-specifics
 560   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 561   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
 562 
 563   // generic
 564   virtual Instruction*      as_Instruction()     { return this; } // to satisfy HASHING1 macro
 565   virtual Phi*              as_Phi()             { return NULL; }
 566   virtual Local*            as_Local()           { return NULL; }
 567   virtual Constant*         as_Constant()        { return NULL; }
 568   virtual AccessField*      as_AccessField()     { return NULL; }
 569   virtual LoadField*        as_LoadField()       { return NULL; }
 570   virtual StoreField*       as_StoreField()      { return NULL; }
 571   virtual AccessArray*      as_AccessArray()     { return NULL; }
 572   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 573   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 574   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 575   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 576   virtual NegateOp*         as_NegateOp()        { return NULL; }
 577   virtual Op2*              as_Op2()             { return NULL; }
 578   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 579   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 580   virtual LogicOp*          as_LogicOp()         { return NULL; }
 581   virtual CompareOp*        as_CompareOp()       { return NULL; }
 582   virtual IfOp*             as_IfOp()            { return NULL; }
 583   virtual Convert*          as_Convert()         { return NULL; }
 584   virtual NullCheck*        as_NullCheck()       { return NULL; }
 585   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 586   virtual StateSplit*       as_StateSplit()      { return NULL; }
 587   virtual Invoke*           as_Invoke()          { return NULL; }
 588   virtual NewInstance*      as_NewInstance()     { return NULL; }
 589   virtual NewInlineTypeInstance* as_NewInlineTypeInstance() { return NULL; }
 590   virtual NewArray*         as_NewArray()        { return NULL; }
 591   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 592   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 593   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 594   virtual WithField*        as_WithField()       { return NULL; }
 595   virtual DefaultValue*     as_DefaultValue()    { return NULL; }
 596   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 597   virtual CheckCast*        as_CheckCast()       { return NULL; }
 598   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 599   virtual TypeCast*         as_TypeCast()        { return NULL; }
 600   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 601   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 602   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 603   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 604   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 605   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 606   virtual Goto*             as_Goto()            { return NULL; }
 607   virtual If*               as_If()              { return NULL; }
 608   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 609   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 610   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 611   virtual Return*           as_Return()          { return NULL; }
 612   virtual Throw*            as_Throw()           { return NULL; }
 613   virtual Base*             as_Base()            { return NULL; }
 614   virtual RoundFP*          as_RoundFP()         { return NULL; }
 615   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
 616   virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }
 617   virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }
 618   virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }
 619 
 620 #ifdef ASSERT
 621   virtual Assert*           as_Assert()          { return NULL; }
 622 #endif
 623 
 624   virtual void visit(InstructionVisitor* v)      = 0;
 625 
 626   virtual bool can_trap() const                  { return false; }
 627 
 628   virtual void input_values_do(ValueVisitor* f)   = 0;
 629   virtual void state_values_do(ValueVisitor* f);
 630   virtual void other_values_do(ValueVisitor* f)   { /* usually no other - override on demand */ }
 631           void       values_do(ValueVisitor* f)   { input_values_do(f); state_values_do(f); other_values_do(f); }
 632 
 633   virtual ciType* exact_type() const;
 634   virtual ciType* declared_type() const          { return NULL; }
 635 
 636   // hashing
 637   virtual const char* name() const               = 0;
 638   HASHING1(Instruction, false, id())             // hashing disabled by default
 639 
 640   // debugging
 641   static void check_state(ValueStack* state)     PRODUCT_RETURN;
 642   void print()                                   PRODUCT_RETURN;
 643   void print_line()                              PRODUCT_RETURN;
 644   void print(InstructionPrinter&amp; ip)             PRODUCT_RETURN;
 645 };
 646 
 647 
 648 // The following macros are used to define base (i.e., non-leaf)
 649 // and leaf instruction classes. They define class-name related
 650 // generic functionality in one place.
 651 
 652 #define BASE(class_name, super_class_name)       \
 653   class class_name: public super_class_name {    \
 654    public:                                       \
 655     virtual class_name* as_##class_name()        { return this; }              \
 656 
 657 
 658 #define LEAF(class_name, super_class_name)       \
 659   BASE(class_name, super_class_name)             \
 660    public:                                       \
 661     virtual const char* name() const             { return #class_name; }       \
 662     virtual void visit(InstructionVisitor* v)    { v-&gt;do_##class_name(this); } \
 663 
 664 
 665 // Debugging support
 666 
 667 
 668 #ifdef ASSERT
 669 class AssertValues: public ValueVisitor {
 670   void visit(Value* x)             { assert((*x) != NULL, &quot;value must exist&quot;); }
 671 };
 672   #define ASSERT_VALUES                          { AssertValues assert_value; values_do(&amp;assert_value); }
 673 #else
 674   #define ASSERT_VALUES
 675 #endif // ASSERT
 676 
 677 
 678 // A Phi is a phi function in the sense of SSA form. It stands for
 679 // the value of a local variable at the beginning of a join block.
 680 // A Phi consists of n operands, one for every incoming branch.
 681 
 682 LEAF(Phi, Instruction)
 683  private:
 684   int         _pf_flags; // the flags of the phi function
 685   int         _index;    // to value on operand stack (index &lt; 0) or to local
 686  public:
 687   // creation
 688   Phi(ValueType* type, BlockBegin* b, int index)
 689   : Instruction(type-&gt;base())
 690   , _pf_flags(0)
 691   , _index(index)
 692   {
 693     _block = b;
 694     NOT_PRODUCT(set_printable_bci(Value(b)-&gt;printable_bci()));
 695     if (type-&gt;is_illegal()) {
 696       make_illegal();
 697     }
 698   }
 699 
 700   // flags
 701   enum Flag {
 702     no_flag         = 0,
 703     visited         = 1 &lt;&lt; 0,
 704     cannot_simplify = 1 &lt;&lt; 1
 705   };
 706 
 707   // accessors
 708   bool  is_local() const          { return _index &gt;= 0; }
 709   bool  is_on_stack() const       { return !is_local(); }
 710   int   local_index() const       { assert(is_local(), &quot;&quot;); return _index; }
 711   int   stack_index() const       { assert(is_on_stack(), &quot;&quot;); return -(_index+1); }
 712 
 713   Value operand_at(int i) const;
 714   int   operand_count() const;
 715 
 716   void   set(Flag f)              { _pf_flags |=  f; }
 717   void   clear(Flag f)            { _pf_flags &amp;= ~f; }
 718   bool   is_set(Flag f) const     { return (_pf_flags &amp; f) != 0; }
 719 
 720   // Invalidates phis corresponding to merges of locals of two different types
 721   // (these should never be referenced, otherwise the bytecodes are illegal)
 722   void   make_illegal() {
 723     set(cannot_simplify);
 724     set_type(illegalType);
 725   }
 726 
 727   bool is_illegal() const {
 728     return type()-&gt;is_illegal();
 729   }
 730 
 731   // generic
 732   virtual void input_values_do(ValueVisitor* f) {
 733   }
 734 };
 735 
 736 
 737 // A local is a placeholder for an incoming argument to a function call.
 738 LEAF(Local, Instruction)
 739  private:
 740   int      _java_index;                          // the local index within the method to which the local belongs
 741   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 742   ciType*  _declared_type;
 743  public:
 744   // creation
 745   Local(ciType* declared, ValueType* type, int index, bool receiver, bool null_free)
 746     : Instruction(type)
 747     , _java_index(index)
 748     , _is_receiver(receiver)
 749     , _declared_type(declared)
 750   {
 751     set_null_free(null_free);
 752     NOT_PRODUCT(set_printable_bci(-1));
 753   }
 754 
 755   // accessors
 756   int java_index() const                         { return _java_index; }
 757   bool is_receiver() const                       { return _is_receiver; }
 758 
 759   virtual ciType* declared_type() const          { return _declared_type; }
 760 
 761   // generic
 762   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 763 };
 764 
 765 
 766 LEAF(Constant, Instruction)
 767  public:
 768   // creation
 769   Constant(ValueType* type):
 770       Instruction(type, NULL, /*type_is_constant*/ true)
 771   {
 772     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 773   }
 774 
 775   Constant(ValueType* type, ValueStack* state_before):
 776     Instruction(type, state_before, /*type_is_constant*/ true)
 777   {
 778     assert(state_before != NULL, &quot;only used for constants which need patching&quot;);
 779     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 780     // since it&#39;s patching it needs to be pinned
 781     pin();
 782   }
 783 
 784   // generic
 785   virtual bool can_trap() const                  { return state_before() != NULL; }
 786   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 787 
 788   virtual intx hash() const;
 789   virtual bool is_equal(Value v) const;
 790 
 791   virtual ciType* exact_type() const;
 792 
 793   enum CompareResult { not_comparable = -1, cond_false, cond_true };
 794 
 795   virtual CompareResult compare(Instruction::Condition condition, Value right) const;
 796   BlockBegin* compare(Instruction::Condition cond, Value right,
 797                       BlockBegin* true_sux, BlockBegin* false_sux) const {
 798     switch (compare(cond, right)) {
 799     case not_comparable:
 800       return NULL;
 801     case cond_false:
 802       return false_sux;
 803     case cond_true:
 804       return true_sux;
 805     default:
 806       ShouldNotReachHere();
 807       return NULL;
 808     }
 809   }
 810 };
 811 
 812 
 813 BASE(AccessField, Instruction)
 814  private:
 815   Value       _obj;
 816   int         _offset;
 817   ciField*    _field;
 818   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 819 
 820  public:
 821   // creation
 822   AccessField(Value obj, int offset, ciField* field, bool is_static,
 823               ValueStack* state_before, bool needs_patching)
 824   : Instruction(as_ValueType(field-&gt;type()-&gt;basic_type()), state_before)
 825   , _obj(obj)
 826   , _offset(offset)
 827   , _field(field)
 828   , _explicit_null_check(NULL)
 829   {
 830     set_needs_null_check(!is_static);
 831     set_flag(IsStaticFlag, is_static);
 832     set_flag(NeedsPatchingFlag, needs_patching);
 833     ASSERT_VALUES
 834     // pin of all instructions with memory access
 835     pin();
 836   }
 837 
 838   // accessors
 839   Value obj() const                              { return _obj; }
 840   int offset() const                             { return _offset; }
 841   ciField* field() const                         { return _field; }
 842   BasicType field_type() const                   { return _field-&gt;type()-&gt;basic_type(); }
 843   bool is_static() const                         { return check_flag(IsStaticFlag); }
 844   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 845   bool needs_patching() const                    { return check_flag(NeedsPatchingFlag); }
 846 
 847   // Unresolved getstatic and putstatic can cause initialization.
 848   // Technically it occurs at the Constant that materializes the base
 849   // of the static fields but it&#39;s simpler to model it here.
 850   bool is_init_point() const                     { return is_static() &amp;&amp; (needs_patching() || !_field-&gt;holder()-&gt;is_initialized()); }
 851 
 852   // manipulation
 853 
 854   // Under certain circumstances, if a previous NullCheck instruction
 855   // proved the target object non-null, we can eliminate the explicit
 856   // null check and do an implicit one, simply specifying the debug
 857   // information from the NullCheck. This field should only be consulted
 858   // if needs_null_check() is true.
 859   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 860 
 861   // generic
 862   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 863   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 864 };
 865 
 866 
 867 LEAF(LoadField, AccessField)
 868  public:
 869   // creation
 870   LoadField(Value obj, int offset, ciField* field, bool is_static,
 871             ValueStack* state_before, bool needs_patching,
 872             ciInlineKlass* inline_klass = NULL, Value default_value = NULL )
 873   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 874   {
 875     set_null_free(field-&gt;signature()-&gt;is_Q_signature());
 876   }
 877 
 878   ciType* declared_type() const;
 879 
 880   // generic; cannot be eliminated if needs patching or if volatile.
 881   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 882 };
 883 
 884 
 885 LEAF(StoreField, AccessField)
 886  private:
 887   Value _value;
 888 
 889  public:
 890   // creation
 891   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
<a name="1" id="anc1"></a><span class="line-modified"> 892              ValueStack* state_before, bool needs_patching)</span>
<span class="line-removed"> 893   : AccessField(obj, offset, field, is_static, state_before, needs_patching)</span>
<span class="line-removed"> 894   , _value(value)</span>
<span class="line-removed"> 895   {</span>
<span class="line-removed"> 896     set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());</span>
<span class="line-removed"> 897     ASSERT_VALUES</span>
<span class="line-removed"> 898     pin();</span>
<span class="line-removed"> 899   }</span>
 900 
 901   // accessors
 902   Value value() const                            { return _value; }
 903   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 904 
 905   // generic
 906   virtual void input_values_do(ValueVisitor* f)   { AccessField::input_values_do(f); f-&gt;visit(&amp;_value); }
 907 };
 908 
 909 
 910 BASE(AccessArray, Instruction)
 911  private:
 912   Value       _array;
 913 
 914  public:
 915   // creation
 916   AccessArray(ValueType* type, Value array, ValueStack* state_before)
 917   : Instruction(type, state_before)
 918   , _array(array)
 919   {
 920     set_needs_null_check(true);
 921     ASSERT_VALUES
 922     pin(); // instruction with side effect (null exception or range check throwing)
 923   }
 924 
 925   Value array() const                            { return _array; }
 926 
 927   // generic
 928   virtual bool can_trap() const                  { return needs_null_check(); }
 929   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_array); }
 930 };
 931 
 932 
 933 LEAF(ArrayLength, AccessArray)
 934  private:
 935   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 936 
 937  public:
 938   // creation
 939   ArrayLength(Value array, ValueStack* state_before)
 940   : AccessArray(intType, array, state_before)
 941   , _explicit_null_check(NULL) {}
 942 
 943   // accessors
 944   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 945 
 946   // setters
 947   // See LoadField::set_explicit_null_check for documentation
 948   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 949 
 950   // generic
 951   HASHING1(ArrayLength, true, array()-&gt;subst())
 952 };
 953 
 954 
 955 BASE(AccessIndexed, AccessArray)
 956  private:
 957   Value     _index;
 958   Value     _length;
 959   BasicType _elt_type;
 960   bool      _mismatched;
 961   ciMethod* _profiled_method;
 962   int       _profiled_bci;
 963 
 964  public:
 965   // creation
 966   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 967   : AccessArray(as_ValueType(elt_type), array, state_before)
 968   , _index(index)
 969   , _length(length)
 970   , _elt_type(elt_type)
 971   , _mismatched(mismatched)
 972   , _profiled_method(NULL), _profiled_bci(0)
 973   {
 974     set_flag(Instruction::NeedsRangeCheckFlag, true);
 975     ASSERT_VALUES
 976   }
 977 
 978   // accessors
 979   Value index() const                            { return _index; }
 980   Value length() const                           { return _length; }
 981   BasicType elt_type() const                     { return _elt_type; }
 982   bool mismatched() const                        { return _mismatched; }
 983 
 984   void clear_length()                            { _length = NULL; }
 985   // perform elimination of range checks involving constants
 986   bool compute_needs_range_check();
 987 
 988   // Helpers for MethodData* profiling
 989   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
 990   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
 991   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
 992   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
 993   ciMethod* profiled_method() const                  { return _profiled_method;     }
 994   int       profiled_bci() const                     { return _profiled_bci;        }
 995 
 996 
 997 // generic
 998   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 999 };
1000 
1001 
1002 LEAF(LoadIndexed, AccessIndexed)
1003  private:
1004   NullCheck*  _explicit_null_check;              // For explicit null check elimination
1005   NewInlineTypeInstance* _vt;
1006 
1007  public:
1008   // creation
1009   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
1010   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
1011   , _explicit_null_check(NULL), _vt(NULL) {}
1012 
1013   // accessors
1014   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
1015 
1016   // setters
1017   // See LoadField::set_explicit_null_check for documentation
1018   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1019 
1020   ciType* exact_type() const;
1021   ciType* declared_type() const;
1022 
1023   NewInlineTypeInstance* vt() const { return _vt; }
1024   void set_vt(NewInlineTypeInstance* vt) { _vt = vt; }
1025 
1026   // generic
1027   HASHING4(LoadIndexed, !should_profile(), type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst(), vt())
1028 };
1029 
1030 
1031 LEAF(StoreIndexed, AccessIndexed)
1032  private:
1033   Value       _value;
1034 
1035   bool      _check_boolean;
1036 
1037  public:
1038   // creation
1039   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
<a name="2" id="anc2"></a><span class="line-modified">1040                bool check_boolean, bool mismatched = false)</span>
<span class="line-removed">1041   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)</span>
<span class="line-removed">1042   , _value(value), _check_boolean(check_boolean)</span>
<span class="line-removed">1043   {</span>
<span class="line-removed">1044     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));</span>
<span class="line-removed">1045     set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));</span>
<span class="line-removed">1046     ASSERT_VALUES</span>
<span class="line-removed">1047     pin();</span>
<span class="line-removed">1048   }</span>
1049 
1050   // accessors
1051   Value value() const                            { return _value; }
1052   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
1053   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
1054   bool check_boolean() const                     { return _check_boolean; }
1055 
1056   // Flattened array support
1057   bool is_exact_flattened_array_store() const;
1058   // generic
1059   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1060 };
1061 
1062 
1063 LEAF(NegateOp, Instruction)
1064  private:
1065   Value _x;
1066 
1067  public:
1068   // creation
1069   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1070     ASSERT_VALUES
1071   }
1072 
1073   // accessors
1074   Value x() const                                { return _x; }
1075 
1076   // generic
1077   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
1078 };
1079 
1080 
1081 BASE(Op2, Instruction)
1082  private:
1083   Bytecodes::Code _op;
1084   Value           _x;
1085   Value           _y;
1086 
1087  public:
1088   // creation
1089   Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)
1090   : Instruction(type, state_before)
1091   , _op(op)
1092   , _x(x)
1093   , _y(y)
1094   {
1095     ASSERT_VALUES
1096   }
1097 
1098   // accessors
1099   Bytecodes::Code op() const                     { return _op; }
1100   Value x() const                                { return _x; }
1101   Value y() const                                { return _y; }
1102 
1103   // manipulators
1104   void swap_operands() {
1105     assert(is_commutative(), &quot;operation must be commutative&quot;);
1106     Value t = _x; _x = _y; _y = t;
1107   }
1108 
1109   // generic
1110   virtual bool is_commutative() const            { return false; }
1111   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1112 };
1113 
1114 
1115 LEAF(ArithmeticOp, Op2)
1116  public:
1117   // creation
1118   ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)
1119   : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y, state_before)
1120   {
1121     set_flag(IsStrictfpFlag, is_strictfp);
1122     if (can_trap()) pin();
1123   }
1124 
1125   // accessors
1126   bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }
1127 
1128   // generic
1129   virtual bool is_commutative() const;
1130   virtual bool can_trap() const;
1131   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1132 };
1133 
1134 
1135 LEAF(ShiftOp, Op2)
1136  public:
1137   // creation
1138   ShiftOp(Bytecodes::Code op, Value x, Value s) : Op2(x-&gt;type()-&gt;base(), op, x, s) {}
1139 
1140   // generic
1141   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1142 };
1143 
1144 
1145 LEAF(LogicOp, Op2)
1146  public:
1147   // creation
1148   LogicOp(Bytecodes::Code op, Value x, Value y) : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y) {}
1149 
1150   // generic
1151   virtual bool is_commutative() const;
1152   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1153 };
1154 
1155 
1156 LEAF(CompareOp, Op2)
1157  public:
1158   // creation
1159   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1160   : Op2(intType, op, x, y, state_before)
1161   {}
1162 
1163   // generic
1164   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1165 };
1166 
1167 
1168 LEAF(IfOp, Op2)
1169  private:
1170   Value _tval;
1171   Value _fval;
1172   bool _substitutability_check;
1173 
1174  public:
1175   // creation
1176   IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)
1177   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1178   , _tval(tval)
1179   , _fval(fval)
1180   , _substitutability_check(substitutability_check)
1181   {
1182     ASSERT_VALUES
1183     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1184     set_state_before(state_before);
1185   }
1186 
1187   // accessors
1188   virtual bool is_commutative() const;
1189   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1190   Condition cond() const                         { return (Condition)Op2::op(); }
1191   Value tval() const                             { return _tval; }
1192   Value fval() const                             { return _fval; }
1193   bool substitutability_check() const             { return _substitutability_check; }
1194   // generic
1195   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1196 };
1197 
1198 
1199 LEAF(Convert, Instruction)
1200  private:
1201   Bytecodes::Code _op;
1202   Value           _value;
1203 
1204  public:
1205   // creation
1206   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1207     ASSERT_VALUES
1208   }
1209 
1210   // accessors
1211   Bytecodes::Code op() const                     { return _op; }
1212   Value value() const                            { return _value; }
1213 
1214   // generic
1215   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_value); }
1216   HASHING2(Convert, true, op(), value()-&gt;subst())
1217 };
1218 
1219 
1220 LEAF(NullCheck, Instruction)
1221  private:
1222   Value       _obj;
1223 
1224  public:
1225   // creation
1226   NullCheck(Value obj, ValueStack* state_before)
1227   : Instruction(obj-&gt;type()-&gt;base(), state_before)
1228   , _obj(obj)
1229   {
1230     ASSERT_VALUES
1231     set_can_trap(true);
1232     assert(_obj-&gt;type()-&gt;is_object(), &quot;null check must be applied to objects only&quot;);
1233     pin(Instruction::PinExplicitNullCheck);
1234   }
1235 
1236   // accessors
1237   Value obj() const                              { return _obj; }
1238 
1239   // setters
1240   void set_can_trap(bool can_trap)               { set_flag(CanTrapFlag, can_trap); }
1241 
1242   // generic
1243   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); /* null-check elimination sets to false */ }
1244   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
1245   HASHING1(NullCheck, true, obj()-&gt;subst())
1246 };
1247 
1248 
1249 // This node is supposed to cast the type of another node to a more precise
1250 // declared type.
1251 LEAF(TypeCast, Instruction)
1252  private:
1253   ciType* _declared_type;
1254   Value   _obj;
1255 
1256  public:
1257   // The type of this node is the same type as the object type (and it might be constant).
1258   TypeCast(ciType* type, Value obj, ValueStack* state_before)
1259   : Instruction(obj-&gt;type(), state_before, obj-&gt;type()-&gt;is_constant()),
1260     _declared_type(type),
1261     _obj(obj) {}
1262 
1263   // accessors
1264   ciType* declared_type() const                  { return _declared_type; }
1265   Value   obj() const                            { return _obj; }
1266 
1267   // generic
1268   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_obj); }
1269 };
1270 
1271 
1272 BASE(StateSplit, Instruction)
1273  private:
1274   ValueStack* _state;
1275 
1276  protected:
1277   static void substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block);
1278 
1279  public:
1280   // creation
1281   StateSplit(ValueType* type, ValueStack* state_before = NULL)
1282   : Instruction(type, state_before)
1283   , _state(NULL)
1284   {
1285     pin(PinStateSplitConstructor);
1286   }
1287 
1288   // accessors
1289   ValueStack* state() const                      { return _state; }
1290   IRScope* scope() const;                        // the state&#39;s scope
1291 
1292   // manipulation
1293   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1294 
1295   // generic
1296   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1297   virtual void state_values_do(ValueVisitor* f);
1298 };
1299 
1300 
1301 LEAF(Invoke, StateSplit)
1302  private:
1303   Bytecodes::Code _code;
1304   Value           _recv;
1305   Values*         _args;
1306   BasicTypeList*  _signature;
1307   int             _vtable_index;
1308   ciMethod*       _target;
1309 
1310  public:
1311   // creation
1312   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
1313          int vtable_index, ciMethod* target, ValueStack* state_before, bool null_free);
1314 
1315   // accessors
1316   Bytecodes::Code code() const                   { return _code; }
1317   Value receiver() const                         { return _recv; }
1318   bool has_receiver() const                      { return receiver() != NULL; }
1319   int number_of_arguments() const                { return _args-&gt;length(); }
1320   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1321   int vtable_index() const                       { return _vtable_index; }
1322   BasicTypeList* signature() const               { return _signature; }
1323   ciMethod* target() const                       { return _target; }
1324 
1325   ciType* declared_type() const;
1326 
1327   // Returns false if target is not loaded
1328   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1329   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1330   // Returns false if target is not loaded
1331   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1332 
1333   // JSR 292 support
1334   bool is_invokedynamic() const                  { return code() == Bytecodes::_invokedynamic; }
1335   bool is_method_handle_intrinsic() const        { return target()-&gt;is_method_handle_intrinsic(); }
1336 
1337   virtual bool needs_exception_state() const     { return false; }
1338 
1339   // generic
1340   virtual bool can_trap() const                  { return true; }
1341   virtual void input_values_do(ValueVisitor* f) {
1342     StateSplit::input_values_do(f);
1343     if (has_receiver()) f-&gt;visit(&amp;_recv);
1344     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1345   }
1346   virtual void state_values_do(ValueVisitor *f);
1347 };
1348 
1349 
1350 LEAF(NewInstance, StateSplit)
1351  private:
1352   ciInstanceKlass* _klass;
1353   bool _is_unresolved;
1354 
1355  public:
1356   // creation
1357   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1358   : StateSplit(instanceType, state_before)
1359   , _klass(klass), _is_unresolved(is_unresolved)
1360   {}
1361 
1362   // accessors
1363   ciInstanceKlass* klass() const                 { return _klass; }
1364   bool is_unresolved() const                     { return _is_unresolved; }
1365 
1366   virtual bool needs_exception_state() const     { return false; }
1367 
1368   // generic
1369   virtual bool can_trap() const                  { return true; }
1370   ciType* exact_type() const;
1371   ciType* declared_type() const;
1372 };
1373 
1374 LEAF(NewInlineTypeInstance, StateSplit)
1375   bool _is_unresolved;
1376   ciInlineKlass* _klass;
1377   Value _depends_on;      // Link to instance on with withfield was called on
1378   bool _is_optimizable_for_withfield;
<a name="3" id="anc3"></a>
1379   int _first_local_index;
<a name="4" id="anc4"></a>
1380 public:
1381 
1382   // Default creation, always allocated for now
1383   NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)
1384   : StateSplit(instanceType, state_before)
1385    , _is_unresolved(is_unresolved)
1386    , _klass(klass)
1387    , _is_optimizable_for_withfield(from_default_value)
<a name="5" id="anc5"></a>
1388    , _first_local_index(-1)
<a name="6" id="anc6"></a>
1389   {
1390     if (depends_on == NULL) {
1391       _depends_on = this;
1392     } else {
1393       _depends_on = depends_on;
1394     }
1395     set_null_free(true);
1396   }
1397 
1398   // accessors
1399   bool is_unresolved() const                     { return _is_unresolved; }
1400   Value depends_on();
1401 
1402   ciInlineKlass* klass() const { return _klass; }
1403 
1404   virtual bool needs_exception_state() const     { return false; }
1405 
1406   // generic
1407   virtual bool can_trap() const                  { return true; }
1408   ciType* exact_type() const;
1409   ciType* declared_type() const;
1410 
1411   // Only done in LIR Generator -&gt; map everything to object
1412   void set_to_object_type() { set_type(instanceType); }
1413 
1414   // withfield optimization
1415   virtual void set_escaped() {
1416     _is_optimizable_for_withfield = false;
1417   }
1418   virtual void set_local_index(int index) {
1419     if (_first_local_index != index) {
1420       if (_first_local_index == -1) {
1421         _first_local_index = index;
1422       } else {
<a name="7" id="anc7"></a><span class="line-modified">1423         _is_optimizable_for_withfield = false;</span>
1424       }
1425     }
1426   }
<a name="8" id="anc8"></a><span class="line-modified">1427   virtual bool is_optimizable_for_withfield() const {  return _is_optimizable_for_withfield; }</span>

















1428 };
1429 
1430 BASE(NewArray, StateSplit)
1431  private:
1432   Value       _length;
1433 
1434  public:
1435   // creation
1436   NewArray(Value length, ValueStack* state_before)
1437   : StateSplit(objectType, state_before)
1438   , _length(length)
1439   {
1440     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1441   }
1442 
1443   // accessors
1444   Value length() const                           { return _length; }
1445 
1446   virtual bool needs_exception_state() const     { return false; }
1447 
1448   ciType* exact_type() const                     { return NULL; }
1449   ciType* declared_type() const;
1450 
1451   // generic
1452   virtual bool can_trap() const                  { return true; }
1453   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_length); }
1454 };
1455 
1456 
1457 LEAF(NewTypeArray, NewArray)
1458  private:
1459   BasicType _elt_type;
1460 
1461  public:
1462   // creation
1463   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1464   : NewArray(length, state_before)
1465   , _elt_type(elt_type)
1466   {}
1467 
1468   // accessors
1469   BasicType elt_type() const                     { return _elt_type; }
1470   ciType* exact_type() const;
1471 };
1472 
1473 
1474 LEAF(NewObjectArray, NewArray)
1475  private:
1476   ciKlass* _klass;
1477 
1478  public:
1479   // creation
1480   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool null_free)
1481   : NewArray(length, state_before), _klass(klass) {
1482     set_null_free(null_free);
1483   }
1484 
1485   // accessors
1486   ciKlass* klass() const                         { return _klass; }
1487   ciType* exact_type() const;
1488 };
1489 
1490 
1491 LEAF(NewMultiArray, NewArray)
1492  private:
1493   ciKlass* _klass;
1494   Values*  _dims;
1495 
1496  public:
1497   // creation
1498   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1499     ASSERT_VALUES
1500   }
1501 
1502   // accessors
1503   ciKlass* klass() const                         { return _klass; }
1504   Values* dims() const                           { return _dims; }
1505   int rank() const                               { return dims()-&gt;length(); }
1506 
1507   // generic
1508   virtual void input_values_do(ValueVisitor* f) {
1509     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1510     // is meaningless for a multi-dimensional array; passing the
1511     // zeroth element down to NewArray as its length is a bad idea
1512     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1513     // get updated, and the value must not be traversed twice. Was bug
1514     // - kbr 4/10/2001
1515     StateSplit::input_values_do(f);
1516     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1517   }
1518 
1519   ciType* exact_type() const;
1520 };
1521 
1522 LEAF(WithField, StateSplit)
1523  public:
1524   // creation
1525   WithField(ValueStack* state_before)
1526   : StateSplit(objectType, state_before) {}
1527 };
1528 
1529 LEAF(DefaultValue, StateSplit)
1530  public:
1531   // creation
1532   DefaultValue(ValueStack* state_before)
1533   : StateSplit(objectType, state_before) {}
1534 };
1535 
1536 BASE(TypeCheck, StateSplit)
1537  private:
1538   ciKlass*    _klass;
1539   Value       _obj;
1540 
1541   ciMethod* _profiled_method;
1542   int       _profiled_bci;
1543 
1544  public:
1545   // creation
1546   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1547   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1548     _profiled_method(NULL), _profiled_bci(0) {
1549     ASSERT_VALUES
1550     set_direct_compare(false);
1551   }
1552 
1553   // accessors
1554   ciKlass* klass() const                         { return _klass; }
1555   Value obj() const                              { return _obj; }
1556   bool is_loaded() const                         { return klass() != NULL; }
1557   bool direct_compare() const                    { return check_flag(DirectCompareFlag); }
1558 
1559   // manipulation
1560   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1561 
1562   // generic
1563   virtual bool can_trap() const                  { return true; }
1564   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1565 
1566   // Helpers for MethodData* profiling
1567   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1568   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1569   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1570   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1571   ciMethod* profiled_method() const                  { return _profiled_method;     }
1572   int       profiled_bci() const                     { return _profiled_bci;        }
1573 };
1574 
1575 
1576 LEAF(CheckCast, TypeCheck)
1577  public:
1578   // creation
1579   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool null_free = false)
1580   : TypeCheck(klass, obj, objectType, state_before) {
1581     set_null_free(null_free);
1582   }
1583 
1584   void set_incompatible_class_change_check() {
1585     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1586   }
1587   bool is_incompatible_class_change_check() const {
1588     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1589   }
1590   void set_invokespecial_receiver_check() {
1591     set_flag(InvokeSpecialReceiverCheckFlag, true);
1592   }
1593   bool is_invokespecial_receiver_check() const {
1594     return check_flag(InvokeSpecialReceiverCheckFlag);
1595   }
1596 
1597   virtual bool needs_exception_state() const {
1598     return !is_invokespecial_receiver_check();
1599   }
1600 
1601   ciType* declared_type() const;
1602 };
1603 
1604 
1605 LEAF(InstanceOf, TypeCheck)
1606  public:
1607   // creation
1608   InstanceOf(ciKlass* klass, Value obj, ValueStack* state_before) : TypeCheck(klass, obj, intType, state_before) {}
1609 
1610   virtual bool needs_exception_state() const     { return false; }
1611 };
1612 
1613 
1614 BASE(AccessMonitor, StateSplit)
1615  private:
1616   Value       _obj;
1617   int         _monitor_no;
1618 
1619  public:
1620   // creation
1621   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1622   : StateSplit(illegalType, state_before)
1623   , _obj(obj)
1624   , _monitor_no(monitor_no)
1625   {
1626     set_needs_null_check(true);
1627     ASSERT_VALUES
1628   }
1629 
1630   // accessors
1631   Value obj() const                              { return _obj; }
1632   int monitor_no() const                         { return _monitor_no; }
1633 
1634   // generic
1635   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1636 };
1637 
1638 
1639 LEAF(MonitorEnter, AccessMonitor)
1640   bool _maybe_inlinetype;
1641  public:
1642   // creation
1643   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_inlinetype)
1644   : AccessMonitor(obj, monitor_no, state_before)
1645   , _maybe_inlinetype(maybe_inlinetype)
1646   {
1647     ASSERT_VALUES
1648   }
1649 
1650   // accessors
1651   bool maybe_inlinetype() const                   { return _maybe_inlinetype; }
1652 
1653   // generic
1654   virtual bool can_trap() const                  { return true; }
1655 };
1656 
1657 
1658 LEAF(MonitorExit, AccessMonitor)
1659  public:
1660   // creation
1661   MonitorExit(Value obj, int monitor_no)
1662   : AccessMonitor(obj, monitor_no, NULL)
1663   {
1664     ASSERT_VALUES
1665   }
1666 };
1667 
1668 
1669 LEAF(Intrinsic, StateSplit)
1670  private:
1671   vmIntrinsics::ID _id;
1672   Values*          _args;
1673   Value            _recv;
1674   ArgsNonNullState _nonnull_state;
1675 
1676  public:
1677   // preserves_state can be set to true for Intrinsics
1678   // which are guaranteed to preserve register state across any slow
1679   // cases; setting it to true does not mean that the Intrinsic can
1680   // not trap, only that if we continue execution in the same basic
1681   // block after the Intrinsic, all of the registers are intact. This
1682   // allows load elimination and common expression elimination to be
1683   // performed across the Intrinsic.  The default value is false.
1684   Intrinsic(ValueType* type,
1685             vmIntrinsics::ID id,
1686             Values* args,
1687             bool has_receiver,
1688             ValueStack* state_before,
1689             bool preserves_state,
1690             bool cantrap = true)
1691   : StateSplit(type, state_before)
1692   , _id(id)
1693   , _args(args)
1694   , _recv(NULL)
1695   {
1696     assert(args != NULL, &quot;args must exist&quot;);
1697     ASSERT_VALUES
1698     set_flag(PreservesStateFlag, preserves_state);
1699     set_flag(CanTrapFlag,        cantrap);
1700     if (has_receiver) {
1701       _recv = argument_at(0);
1702     }
1703     set_needs_null_check(has_receiver);
1704 
1705     // some intrinsics can&#39;t trap, so don&#39;t force them to be pinned
1706     if (!can_trap() &amp;&amp; !vmIntrinsics::should_be_pinned(_id)) {
1707       unpin(PinStateSplitConstructor);
1708     }
1709   }
1710 
1711   // accessors
1712   vmIntrinsics::ID id() const                    { return _id; }
1713   int number_of_arguments() const                { return _args-&gt;length(); }
1714   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1715 
1716   bool has_receiver() const                      { return (_recv != NULL); }
1717   Value receiver() const                         { assert(has_receiver(), &quot;must have receiver&quot;); return _recv; }
1718   bool preserves_state() const                   { return check_flag(PreservesStateFlag); }
1719 
1720   bool arg_needs_null_check(int i) const {
1721     return _nonnull_state.arg_needs_null_check(i);
1722   }
1723 
1724   void set_arg_needs_null_check(int i, bool check) {
1725     _nonnull_state.set_arg_needs_null_check(i, check);
1726   }
1727 
1728   // generic
1729   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); }
1730   virtual void input_values_do(ValueVisitor* f) {
1731     StateSplit::input_values_do(f);
1732     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1733   }
1734 };
1735 
1736 
1737 class LIR_List;
1738 
1739 LEAF(BlockBegin, StateSplit)
1740  private:
1741   int        _block_id;                          // the unique block id
1742   int        _bci;                               // start-bci of block
1743   int        _depth_first_number;                // number of this block in a depth-first ordering
1744   int        _linear_scan_number;                // number of this block in linear-scan ordering
1745   int        _dominator_depth;
1746   int        _loop_depth;                        // the loop nesting level of this block
1747   int        _loop_index;                        // number of the innermost loop of this block
1748   int        _flags;                             // the flags associated with this block
1749 
1750   // fields used by BlockListBuilder
1751   int            _total_preds;                   // number of predecessors found by BlockListBuilder
1752   ResourceBitMap _stores_to_locals;              // bit is set when a local variable is stored in the block
1753 
1754   // SSA specific fields: (factor out later)
1755   BlockList   _successors;                       // the successors of this block
1756   BlockList   _predecessors;                     // the predecessors of this block
1757   BlockList   _dominates;                        // list of blocks that are dominated by this block
1758   BlockBegin* _dominator;                        // the dominator of this block
1759   // SSA specific ends
1760   BlockEnd*  _end;                               // the last instruction of this block
1761   BlockList  _exception_handlers;                // the exception handlers potentially invoked by this block
1762   ValueStackStack* _exception_states;            // only for xhandler entries: states of all instructions that have an edge to this xhandler
1763   int        _exception_handler_pco;             // if this block is the start of an exception handler,
1764                                                  // this records the PC offset in the assembly code of the
1765                                                  // first instruction in this block
1766   Label      _label;                             // the label associated with this block
1767   LIR_List*  _lir;                               // the low level intermediate representation for this block
1768 
1769   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1770   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1771   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1772   ResourceBitMap _live_kill;                     // set of registers defined in this block
1773 
1774   ResourceBitMap _fpu_register_usage;
1775   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1776   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1777   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1778 
1779   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1780   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1781 
1782   friend class SuxAndWeightAdjuster;
1783 
1784  public:
1785    void* operator new(size_t size) throw() {
1786     Compilation* c = Compilation::current();
1787     void* res = c-&gt;arena()-&gt;Amalloc(size);
1788     return res;
1789   }
1790 
1791   // initialization/counting
1792   static int  number_of_blocks() {
1793     return Compilation::current()-&gt;number_of_blocks();
1794   }
1795 
1796   // creation
1797   BlockBegin(int bci)
1798   : StateSplit(illegalType)
1799   , _block_id(Compilation::current()-&gt;get_next_block_id())
1800   , _bci(bci)
1801   , _depth_first_number(-1)
1802   , _linear_scan_number(-1)
1803   , _dominator_depth(-1)
1804   , _loop_depth(0)
1805   , _loop_index(-1)
1806   , _flags(0)
1807   , _total_preds(0)
1808   , _stores_to_locals()
1809   , _successors(2)
1810   , _predecessors(2)
1811   , _dominates(2)
1812   , _dominator(NULL)
1813   , _end(NULL)
1814   , _exception_handlers(1)
1815   , _exception_states(NULL)
1816   , _exception_handler_pco(-1)
1817   , _lir(NULL)
1818   , _live_in()
1819   , _live_out()
1820   , _live_gen()
1821   , _live_kill()
1822   , _fpu_register_usage()
1823   , _fpu_stack_state(NULL)
1824   , _first_lir_instruction_id(-1)
1825   , _last_lir_instruction_id(-1)
1826   {
1827     _block = this;
1828 #ifndef PRODUCT
1829     set_printable_bci(bci);
1830 #endif
1831   }
1832 
1833   // accessors
1834   int block_id() const                           { return _block_id; }
1835   int bci() const                                { return _bci; }
1836   BlockList* successors()                        { return &amp;_successors; }
1837   BlockList* dominates()                         { return &amp;_dominates; }
1838   BlockBegin* dominator() const                  { return _dominator; }
1839   int loop_depth() const                         { return _loop_depth; }
1840   int dominator_depth() const                    { return _dominator_depth; }
1841   int depth_first_number() const                 { return _depth_first_number; }
1842   int linear_scan_number() const                 { return _linear_scan_number; }
1843   BlockEnd* end() const                          { return _end; }
1844   Label* label()                                 { return &amp;_label; }
1845   LIR_List* lir() const                          { return _lir; }
1846   int exception_handler_pco() const              { return _exception_handler_pco; }
1847   ResourceBitMap&amp; live_in()                      { return _live_in;        }
1848   ResourceBitMap&amp; live_out()                     { return _live_out;       }
1849   ResourceBitMap&amp; live_gen()                     { return _live_gen;       }
1850   ResourceBitMap&amp; live_kill()                    { return _live_kill;      }
1851   ResourceBitMap&amp; fpu_register_usage()           { return _fpu_register_usage; }
1852   intArray* fpu_stack_state() const              { return _fpu_stack_state;    }
1853   int first_lir_instruction_id() const           { return _first_lir_instruction_id; }
1854   int last_lir_instruction_id() const            { return _last_lir_instruction_id; }
1855   int total_preds() const                        { return _total_preds; }
1856   BitMap&amp; stores_to_locals()                     { return _stores_to_locals; }
1857 
1858   // manipulation
1859   void set_dominator(BlockBegin* dom)            { _dominator = dom; }
1860   void set_loop_depth(int d)                     { _loop_depth = d; }
1861   void set_dominator_depth(int d)                { _dominator_depth = d; }
1862   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
1863   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
1864   void set_end(BlockEnd* end);
1865   void clear_end();
1866   void disconnect_from_graph();
1867   static void disconnect_edge(BlockBegin* from, BlockBegin* to);
1868   BlockBegin* insert_block_between(BlockBegin* sux);
1869   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1870   void set_lir(LIR_List* lir)                    { _lir = lir; }
1871   void set_exception_handler_pco(int pco)        { _exception_handler_pco = pco; }
1872   void set_live_in  (const ResourceBitMap&amp; map)  { _live_in = map;   }
1873   void set_live_out (const ResourceBitMap&amp; map)  { _live_out = map;  }
1874   void set_live_gen (const ResourceBitMap&amp; map)  { _live_gen = map;  }
1875   void set_live_kill(const ResourceBitMap&amp; map)  { _live_kill = map; }
1876   void set_fpu_register_usage(const ResourceBitMap&amp; map) { _fpu_register_usage = map; }
1877   void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }
1878   void set_first_lir_instruction_id(int id)      { _first_lir_instruction_id = id;  }
1879   void set_last_lir_instruction_id(int id)       { _last_lir_instruction_id = id;  }
1880   void increment_total_preds(int n = 1)          { _total_preds += n; }
1881   void init_stores_to_locals(int locals_count)   { _stores_to_locals.initialize(locals_count); }
1882 
1883   // generic
1884   virtual void state_values_do(ValueVisitor* f);
1885 
1886   // successors and predecessors
1887   int number_of_sux() const;
1888   BlockBegin* sux_at(int i) const;
1889   void add_successor(BlockBegin* sux);
1890   void remove_successor(BlockBegin* pred);
1891   bool is_successor(BlockBegin* sux) const       { return _successors.contains(sux); }
1892 
1893   void add_predecessor(BlockBegin* pred);
1894   void remove_predecessor(BlockBegin* pred);
1895   bool is_predecessor(BlockBegin* pred) const    { return _predecessors.contains(pred); }
1896   int number_of_preds() const                    { return _predecessors.length(); }
1897   BlockBegin* pred_at(int i) const               { return _predecessors.at(i); }
1898 
1899   // exception handlers potentially invoked by this block
1900   void add_exception_handler(BlockBegin* b);
1901   bool is_exception_handler(BlockBegin* b) const { return _exception_handlers.contains(b); }
1902   int  number_of_exception_handlers() const      { return _exception_handlers.length(); }
1903   BlockBegin* exception_handler_at(int i) const  { return _exception_handlers.at(i); }
1904 
1905   // states of the instructions that have an edge to this exception handler
1906   int number_of_exception_states()               { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states == NULL ? 0 : _exception_states-&gt;length(); }
1907   ValueStack* exception_state_at(int idx) const  { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states-&gt;at(idx); }
1908   int add_exception_state(ValueStack* state);
1909 
1910   // flags
1911   enum Flag {
1912     no_flag                       = 0,
1913     std_entry_flag                = 1 &lt;&lt; 0,
1914     osr_entry_flag                = 1 &lt;&lt; 1,
1915     exception_entry_flag          = 1 &lt;&lt; 2,
1916     subroutine_entry_flag         = 1 &lt;&lt; 3,
1917     backward_branch_target_flag   = 1 &lt;&lt; 4,
1918     is_on_work_list_flag          = 1 &lt;&lt; 5,
1919     was_visited_flag              = 1 &lt;&lt; 6,
1920     parser_loop_header_flag       = 1 &lt;&lt; 7,  // set by parser to identify blocks where phi functions can not be created on demand
1921     critical_edge_split_flag      = 1 &lt;&lt; 8, // set for all blocks that are introduced when critical edges are split
1922     linear_scan_loop_header_flag  = 1 &lt;&lt; 9, // set during loop-detection for LinearScan
1923     linear_scan_loop_end_flag     = 1 &lt;&lt; 10, // set during loop-detection for LinearScan
1924     donot_eliminate_range_checks  = 1 &lt;&lt; 11  // Should be try to eliminate range checks in this block
1925   };
1926 
1927   void set(Flag f)                               { _flags |= f; }
1928   void clear(Flag f)                             { _flags &amp;= ~f; }
1929   bool is_set(Flag f) const                      { return (_flags &amp; f) != 0; }
1930   bool is_entry_block() const {
1931     const int entry_mask = std_entry_flag | osr_entry_flag | exception_entry_flag;
1932     return (_flags &amp; entry_mask) != 0;
1933   }
1934 
1935   // iteration
1936   void iterate_preorder   (BlockClosure* closure);
1937   void iterate_postorder  (BlockClosure* closure);
1938 
1939   void block_values_do(ValueVisitor* f);
1940 
1941   // loops
1942   void set_loop_index(int ix)                    { _loop_index = ix;        }
1943   int  loop_index() const                        { return _loop_index;      }
1944 
1945   // merging
1946   bool try_merge(ValueStack* state);             // try to merge states at block begin
1947   void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, &quot;merge failed&quot;); }
1948 
1949   // debugging
1950   void print_block()                             PRODUCT_RETURN;
1951   void print_block(InstructionPrinter&amp; ip, bool live_only = false) PRODUCT_RETURN;
1952 };
1953 
1954 
1955 BASE(BlockEnd, StateSplit)
1956  private:
1957   BlockList*  _sux;
1958 
1959  protected:
1960   BlockList* sux() const                         { return _sux; }
1961 
1962   void set_sux(BlockList* sux) {
1963 #ifdef ASSERT
1964     assert(sux != NULL, &quot;sux must exist&quot;);
1965     for (int i = sux-&gt;length() - 1; i &gt;= 0; i--) assert(sux-&gt;at(i) != NULL, &quot;sux must exist&quot;);
1966 #endif
1967     _sux = sux;
1968   }
1969 
1970  public:
1971   // creation
1972   BlockEnd(ValueType* type, ValueStack* state_before, bool is_safepoint)
1973   : StateSplit(type, state_before)
1974   , _sux(NULL)
1975   {
1976     set_flag(IsSafepointFlag, is_safepoint);
1977   }
1978 
1979   // accessors
1980   bool is_safepoint() const                      { return check_flag(IsSafepointFlag); }
1981   // For compatibility with old code, for new code use block()
1982   BlockBegin* begin() const                      { return _block; }
1983 
1984   // manipulation
1985   void set_begin(BlockBegin* begin);
1986 
1987   // successors
1988   int number_of_sux() const                      { return _sux != NULL ? _sux-&gt;length() : 0; }
1989   BlockBegin* sux_at(int i) const                { return _sux-&gt;at(i); }
1990   BlockBegin* default_sux() const                { return sux_at(number_of_sux() - 1); }
1991   BlockBegin** addr_sux_at(int i) const          { return _sux-&gt;adr_at(i); }
1992   int sux_index(BlockBegin* sux) const           { return _sux-&gt;find(sux); }
1993   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1994 };
1995 
1996 
1997 LEAF(Goto, BlockEnd)
1998  public:
1999   enum Direction {
2000     none,            // Just a regular goto
2001     taken, not_taken // Goto produced from If
2002   };
2003  private:
2004   ciMethod*   _profiled_method;
2005   int         _profiled_bci;
2006   Direction   _direction;
2007  public:
2008   // creation
2009   Goto(BlockBegin* sux, ValueStack* state_before, bool is_safepoint = false)
2010     : BlockEnd(illegalType, state_before, is_safepoint)
2011     , _profiled_method(NULL)
2012     , _profiled_bci(0)
2013     , _direction(none) {
2014     BlockList* s = new BlockList(1);
2015     s-&gt;append(sux);
2016     set_sux(s);
2017   }
2018 
2019   Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)
2020                                            , _profiled_method(NULL)
2021                                            , _profiled_bci(0)
2022                                            , _direction(none) {
2023     BlockList* s = new BlockList(1);
2024     s-&gt;append(sux);
2025     set_sux(s);
2026   }
2027 
2028   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2029   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2030   int profiled_bci() const                       { return _profiled_bci; }
2031   Direction direction() const                    { return _direction; }
2032 
2033   void set_should_profile(bool value)            { set_flag(ProfileMDOFlag, value); }
2034   void set_profiled_method(ciMethod* method)     { _profiled_method = method; }
2035   void set_profiled_bci(int bci)                 { _profiled_bci = bci; }
2036   void set_direction(Direction d)                { _direction = d; }
2037 };
2038 
2039 #ifdef ASSERT
2040 LEAF(Assert, Instruction)
2041   private:
2042   Value       _x;
2043   Condition   _cond;
2044   Value       _y;
2045   char        *_message;
2046 
2047  public:
2048   // creation
2049   // unordered_is_true is valid for float/double compares only
2050    Assert(Value x, Condition cond, bool unordered_is_true, Value y);
2051 
2052   // accessors
2053   Value x() const                                { return _x; }
2054   Condition cond() const                         { return _cond; }
2055   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2056   Value y() const                                { return _y; }
2057   const char *message() const                    { return _message; }
2058 
2059   // generic
2060   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2061 };
2062 #endif
2063 
2064 LEAF(RangeCheckPredicate, StateSplit)
2065  private:
2066   Value       _x;
2067   Condition   _cond;
2068   Value       _y;
2069 
2070   void check_state();
2071 
2072  public:
2073   // creation
2074   // unordered_is_true is valid for float/double compares only
2075    RangeCheckPredicate(Value x, Condition cond, bool unordered_is_true, Value y, ValueStack* state) : StateSplit(illegalType)
2076   , _x(x)
2077   , _cond(cond)
2078   , _y(y)
2079   {
2080     ASSERT_VALUES
2081     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2082     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2083     this-&gt;set_state(state);
2084     check_state();
2085   }
2086 
2087   // Always deoptimize
2088   RangeCheckPredicate(ValueStack* state) : StateSplit(illegalType)
2089   {
2090     this-&gt;set_state(state);
2091     _x = _y = NULL;
2092     check_state();
2093   }
2094 
2095   // accessors
2096   Value x() const                                { return _x; }
2097   Condition cond() const                         { return _cond; }
2098   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2099   Value y() const                                { return _y; }
2100 
2101   void always_fail()                             { _x = _y = NULL; }
2102 
2103   // generic
2104   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2105   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
2106 };
2107 
2108 LEAF(If, BlockEnd)
2109  private:
2110   Value       _x;
2111   Condition   _cond;
2112   Value       _y;
2113   ciMethod*   _profiled_method;
2114   int         _profiled_bci; // Canonicalizer may alter bci of If node
2115   bool        _swapped;      // Is the order reversed with respect to the original If in the
2116                              // bytecode stream?
2117   bool        _substitutability_check;
2118  public:
2119   // creation
2120   // unordered_is_true is valid for float/double compares only
2121   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)
2122     : BlockEnd(illegalType, state_before, is_safepoint)
2123   , _x(x)
2124   , _cond(cond)
2125   , _y(y)
2126   , _profiled_method(NULL)
2127   , _profiled_bci(0)
2128   , _swapped(false)
2129   , _substitutability_check(substitutability_check)
2130   {
2131     ASSERT_VALUES
2132     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2133     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2134     BlockList* s = new BlockList(2);
2135     s-&gt;append(tsux);
2136     s-&gt;append(fsux);
2137     set_sux(s);
2138     if (!_substitutability_check) {
2139       assert(x-&gt;as_NewInlineTypeInstance() == NULL || y-&gt;type() == objectNull, &quot;Sanity check&quot;);
2140       assert(y-&gt;as_NewInlineTypeInstance() == NULL || x-&gt;type() == objectNull, &quot;Sanity check&quot;);
2141     }
2142   }
2143 
2144   // accessors
2145   Value x() const                                { return _x; }
2146   Condition cond() const                         { return _cond; }
2147   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2148   Value y() const                                { return _y; }
2149   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2150   BlockBegin* tsux() const                       { return sux_for(true); }
2151   BlockBegin* fsux() const                       { return sux_for(false); }
2152   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2153   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2154   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2155   int profiled_bci() const                       { return _profiled_bci; }    // set for profiled branches and tiered
2156   bool is_swapped() const                        { return _swapped; }
2157 
2158   // manipulation
2159   void swap_operands() {
2160     Value t = _x; _x = _y; _y = t;
2161     _cond = mirror(_cond);
2162   }
2163 
2164   void swap_sux() {
2165     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2166     BlockList* s = sux();
2167     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2168     _cond = negate(_cond);
2169     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2170   }
2171 
2172   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2173   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2174   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2175   void set_swapped(bool value)                    { _swapped = value;         }
2176   bool substitutability_check() const              { return _substitutability_check; }
2177   // generic
2178   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2179 };
2180 
2181 
2182 LEAF(IfInstanceOf, BlockEnd)
2183  private:
2184   ciKlass* _klass;
2185   Value    _obj;
2186   bool     _test_is_instance;                    // jump if instance
2187   int      _instanceof_bci;
2188 
2189  public:
2190   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2191   : BlockEnd(illegalType, NULL, false) // temporary set to false
2192   , _klass(klass)
2193   , _obj(obj)
2194   , _test_is_instance(test_is_instance)
2195   , _instanceof_bci(instanceof_bci)
2196   {
2197     ASSERT_VALUES
2198     assert(instanceof_bci &gt;= 0, &quot;illegal bci&quot;);
2199     BlockList* s = new BlockList(2);
2200     s-&gt;append(tsux);
2201     s-&gt;append(fsux);
2202     set_sux(s);
2203   }
2204 
2205   // accessors
2206   //
2207   // Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an
2208   //         instance of klass; otherwise it tests if it is *not* and instance
2209   //         of klass.
2210   //
2211   // Note 2: IfInstanceOf instructions are created by combining an InstanceOf
2212   //         and an If instruction. The IfInstanceOf bci() corresponds to the
2213   //         bci that the If would have had; the (this-&gt;) instanceof_bci() is
2214   //         the bci of the original InstanceOf instruction.
2215   ciKlass* klass() const                         { return _klass; }
2216   Value obj() const                              { return _obj; }
2217   int instanceof_bci() const                     { return _instanceof_bci; }
2218   bool test_is_instance() const                  { return _test_is_instance; }
2219   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2220   BlockBegin* tsux() const                       { return sux_for(true); }
2221   BlockBegin* fsux() const                       { return sux_for(false); }
2222 
2223   // manipulation
2224   void swap_sux() {
2225     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2226     BlockList* s = sux();
2227     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2228     _test_is_instance = !_test_is_instance;
2229   }
2230 
2231   // generic
2232   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_obj); }
2233 };
2234 
2235 
2236 BASE(Switch, BlockEnd)
2237  private:
2238   Value       _tag;
2239 
2240  public:
2241   // creation
2242   Switch(Value tag, BlockList* sux, ValueStack* state_before, bool is_safepoint)
2243   : BlockEnd(illegalType, state_before, is_safepoint)
2244   , _tag(tag) {
2245     ASSERT_VALUES
2246     set_sux(sux);
2247   }
2248 
2249   // accessors
2250   Value tag() const                              { return _tag; }
2251   int length() const                             { return number_of_sux() - 1; }
2252 
2253   virtual bool needs_exception_state() const     { return false; }
2254 
2255   // generic
2256   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_tag); }
2257 };
2258 
2259 
2260 LEAF(TableSwitch, Switch)
2261  private:
2262   int _lo_key;
2263 
2264  public:
2265   // creation
2266   TableSwitch(Value tag, BlockList* sux, int lo_key, ValueStack* state_before, bool is_safepoint)
2267     : Switch(tag, sux, state_before, is_safepoint)
2268   , _lo_key(lo_key) { assert(_lo_key &lt;= hi_key(), &quot;integer overflow&quot;); }
2269 
2270   // accessors
2271   int lo_key() const                             { return _lo_key; }
2272   int hi_key() const                             { return _lo_key + (length() - 1); }
2273 };
2274 
2275 
2276 LEAF(LookupSwitch, Switch)
2277  private:
2278   intArray* _keys;
2279 
2280  public:
2281   // creation
2282   LookupSwitch(Value tag, BlockList* sux, intArray* keys, ValueStack* state_before, bool is_safepoint)
2283   : Switch(tag, sux, state_before, is_safepoint)
2284   , _keys(keys) {
2285     assert(keys != NULL, &quot;keys must exist&quot;);
2286     assert(keys-&gt;length() == length(), &quot;sux &amp; keys have incompatible lengths&quot;);
2287   }
2288 
2289   // accessors
2290   int key_at(int i) const                        { return _keys-&gt;at(i); }
2291 };
2292 
2293 
2294 LEAF(Return, BlockEnd)
2295  private:
2296   Value _result;
2297 
2298  public:
2299   // creation
2300   Return(Value result) :
2301     BlockEnd(result == NULL ? voidType : result-&gt;type()-&gt;base(), NULL, true),
2302     _result(result) {}
2303 
2304   // accessors
2305   Value result() const                           { return _result; }
2306   bool has_result() const                        { return result() != NULL; }
2307 
2308   // generic
2309   virtual void input_values_do(ValueVisitor* f) {
2310     BlockEnd::input_values_do(f);
2311     if (has_result()) f-&gt;visit(&amp;_result);
2312   }
2313 };
2314 
2315 
2316 LEAF(Throw, BlockEnd)
2317  private:
2318   Value _exception;
2319 
2320  public:
2321   // creation
2322   Throw(Value exception, ValueStack* state_before) : BlockEnd(illegalType, state_before, true), _exception(exception) {
2323     ASSERT_VALUES
2324   }
2325 
2326   // accessors
2327   Value exception() const                        { return _exception; }
2328 
2329   // generic
2330   virtual bool can_trap() const                  { return true; }
2331   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_exception); }
2332 };
2333 
2334 
2335 LEAF(Base, BlockEnd)
2336  public:
2337   // creation
2338   Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {
2339     assert(std_entry-&gt;is_set(BlockBegin::std_entry_flag), &quot;std entry must be flagged&quot;);
2340     assert(osr_entry == NULL || osr_entry-&gt;is_set(BlockBegin::osr_entry_flag), &quot;osr entry must be flagged&quot;);
2341     BlockList* s = new BlockList(2);
2342     if (osr_entry != NULL) s-&gt;append(osr_entry);
2343     s-&gt;append(std_entry); // must be default sux!
2344     set_sux(s);
2345   }
2346 
2347   // accessors
2348   BlockBegin* std_entry() const                  { return default_sux(); }
2349   BlockBegin* osr_entry() const                  { return number_of_sux() &lt; 2 ? NULL : sux_at(0); }
2350 };
2351 
2352 
2353 LEAF(OsrEntry, Instruction)
2354  public:
2355   // creation
2356 #ifdef _LP64
2357   OsrEntry() : Instruction(longType) { pin(); }
2358 #else
2359   OsrEntry() : Instruction(intType)  { pin(); }
2360 #endif
2361 
2362   // generic
2363   virtual void input_values_do(ValueVisitor* f)   { }
2364 };
2365 
2366 
2367 // Models the incoming exception at a catch site
2368 LEAF(ExceptionObject, Instruction)
2369  public:
2370   // creation
2371   ExceptionObject() : Instruction(objectType) {
2372     pin();
2373   }
2374 
2375   // generic
2376   virtual void input_values_do(ValueVisitor* f)   { }
2377 };
2378 
2379 
2380 // Models needed rounding for floating-point values on Intel.
2381 // Currently only used to represent rounding of double-precision
2382 // values stored into local variables, but could be used to model
2383 // intermediate rounding of single-precision values as well.
2384 LEAF(RoundFP, Instruction)
2385  private:
2386   Value _input;             // floating-point value to be rounded
2387 
2388  public:
2389   RoundFP(Value input)
2390   : Instruction(input-&gt;type()) // Note: should not be used for constants
2391   , _input(input)
2392   {
2393     ASSERT_VALUES
2394   }
2395 
2396   // accessors
2397   Value input() const                            { return _input; }
2398 
2399   // generic
2400   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_input); }
2401 };
2402 
2403 
2404 BASE(UnsafeOp, Instruction)
2405  private:
2406   BasicType _basic_type;    // ValueType can not express byte-sized integers
2407 
2408  protected:
2409   // creation
2410   UnsafeOp(BasicType basic_type, bool is_put)
2411   : Instruction(is_put ? voidType : as_ValueType(basic_type))
2412   , _basic_type(basic_type)
2413   {
2414     //Note:  Unsafe ops are not not guaranteed to throw NPE.
2415     // Convservatively, Unsafe operations must be pinned though we could be
2416     // looser about this if we wanted to..
2417     pin();
2418   }
2419 
2420  public:
2421   // accessors
2422   BasicType basic_type()                         { return _basic_type; }
2423 
2424   // generic
2425   virtual void input_values_do(ValueVisitor* f)   { }
2426 };
2427 
2428 
2429 BASE(UnsafeRawOp, UnsafeOp)
2430  private:
2431   Value _base;                                   // Base address (a Java long)
2432   Value _index;                                  // Index if computed by optimizer; initialized to NULL
2433   int   _log2_scale;                             // Scale factor: 0, 1, 2, or 3.
2434                                                  // Indicates log2 of number of bytes (1, 2, 4, or 8)
2435                                                  // to scale index by.
2436 
2437  protected:
2438   UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)
2439   : UnsafeOp(basic_type, is_put)
2440   , _base(addr)
2441   , _index(NULL)
2442   , _log2_scale(0)
2443   {
2444     // Can not use ASSERT_VALUES because index may be NULL
2445     assert(addr != NULL &amp;&amp; addr-&gt;type()-&gt;is_long(), &quot;just checking&quot;);
2446   }
2447 
2448   UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)
2449   : UnsafeOp(basic_type, is_put)
2450   , _base(base)
2451   , _index(index)
2452   , _log2_scale(log2_scale)
2453   {
2454   }
2455 
2456  public:
2457   // accessors
2458   Value base()                                   { return _base; }
2459   Value index()                                  { return _index; }
2460   bool  has_index()                              { return (_index != NULL); }
2461   int   log2_scale()                             { return _log2_scale; }
2462 
2463   // setters
2464   void set_base (Value base)                     { _base  = base; }
2465   void set_index(Value index)                    { _index = index; }
2466   void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }
2467 
2468   // generic
2469   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2470                                                    f-&gt;visit(&amp;_base);
2471                                                    if (has_index()) f-&gt;visit(&amp;_index); }
2472 };
2473 
2474 
2475 LEAF(UnsafeGetRaw, UnsafeRawOp)
2476  private:
2477  bool _may_be_unaligned, _is_wide;  // For OSREntry
2478 
2479  public:
2480  UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)
2481   : UnsafeRawOp(basic_type, addr, false) {
2482     _may_be_unaligned = may_be_unaligned;
2483     _is_wide = is_wide;
2484   }
2485 
2486  UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)
2487   : UnsafeRawOp(basic_type, base, index, log2_scale, false) {
2488     _may_be_unaligned = may_be_unaligned;
2489     _is_wide = is_wide;
2490   }
2491 
2492   bool may_be_unaligned()                         { return _may_be_unaligned; }
2493   bool is_wide()                                  { return _is_wide; }
2494 };
2495 
2496 
2497 LEAF(UnsafePutRaw, UnsafeRawOp)
2498  private:
2499   Value _value;                                  // Value to be stored
2500 
2501  public:
2502   UnsafePutRaw(BasicType basic_type, Value addr, Value value)
2503   : UnsafeRawOp(basic_type, addr, true)
2504   , _value(value)
2505   {
2506     assert(value != NULL, &quot;just checking&quot;);
2507     ASSERT_VALUES
2508   }
2509 
2510   UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)
2511   : UnsafeRawOp(basic_type, base, index, log2_scale, true)
2512   , _value(value)
2513   {
2514     assert(value != NULL, &quot;just checking&quot;);
2515     ASSERT_VALUES
2516   }
2517 
2518   // accessors
2519   Value value()                                  { return _value; }
2520 
2521   // generic
2522   virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);
2523                                                    f-&gt;visit(&amp;_value); }
2524 };
2525 
2526 
2527 BASE(UnsafeObjectOp, UnsafeOp)
2528  private:
2529   Value _object;                                 // Object to be fetched from or mutated
2530   Value _offset;                                 // Offset within object
2531   bool  _is_volatile;                            // true if volatile - dl/JSR166
2532  public:
2533   UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)
2534     : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)
2535   {
2536   }
2537 
2538   // accessors
2539   Value object()                                 { return _object; }
2540   Value offset()                                 { return _offset; }
2541   bool  is_volatile()                            { return _is_volatile; }
2542   // generic
2543   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2544                                                    f-&gt;visit(&amp;_object);
2545                                                    f-&gt;visit(&amp;_offset); }
2546 };
2547 
2548 
2549 LEAF(UnsafeGetObject, UnsafeObjectOp)
2550  public:
2551   UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)
2552   : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)
2553   {
2554     ASSERT_VALUES
2555   }
2556 };
2557 
2558 
2559 LEAF(UnsafePutObject, UnsafeObjectOp)
2560  private:
2561   Value _value;                                  // Value to be stored
2562  public:
2563   UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)
2564   : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)
2565     , _value(value)
2566   {
2567     ASSERT_VALUES
2568   }
2569 
2570   // accessors
2571   Value value()                                  { return _value; }
2572 
2573   // generic
2574   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2575                                                    f-&gt;visit(&amp;_value); }
2576 };
2577 
2578 LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)
2579  private:
2580   Value _value;                                  // Value to be stored
2581   bool  _is_add;
2582  public:
2583   UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)
2584   : UnsafeObjectOp(basic_type, object, offset, false, false)
2585     , _value(value)
2586     , _is_add(is_add)
2587   {
2588     ASSERT_VALUES
2589   }
2590 
2591   // accessors
2592   bool is_add() const                            { return _is_add; }
2593   Value value()                                  { return _value; }
2594 
2595   // generic
2596   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2597                                                    f-&gt;visit(&amp;_value); }
2598 };
2599 
2600 LEAF(ProfileCall, Instruction)
2601  private:
2602   ciMethod*        _method;
2603   int              _bci_of_invoke;
2604   ciMethod*        _callee;         // the method that is called at the given bci
2605   Value            _recv;
2606   ciKlass*         _known_holder;
2607   Values*          _obj_args;       // arguments for type profiling
2608   ArgsNonNullState _nonnull_state;  // Do we know whether some arguments are never null?
2609   bool             _inlined;        // Are we profiling a call that is inlined
2610 
2611  public:
2612   ProfileCall(ciMethod* method, int bci, ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined)
2613     : Instruction(voidType)
2614     , _method(method)
2615     , _bci_of_invoke(bci)
2616     , _callee(callee)
2617     , _recv(recv)
2618     , _known_holder(known_holder)
2619     , _obj_args(obj_args)
2620     , _inlined(inlined)
2621   {
2622     // The ProfileCall has side-effects and must occur precisely where located
2623     pin();
2624   }
2625 
2626   ciMethod* method()             const { return _method; }
2627   int bci_of_invoke()            const { return _bci_of_invoke; }
2628   ciMethod* callee()             const { return _callee; }
2629   Value recv()                   const { return _recv; }
2630   ciKlass* known_holder()        const { return _known_holder; }
2631   int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args-&gt;length(); }
2632   Value profiled_arg_at(int i)   const { return _obj_args-&gt;at(i); }
2633   bool arg_needs_null_check(int i) const {
2634     return _nonnull_state.arg_needs_null_check(i);
2635   }
2636   bool inlined()                 const { return _inlined; }
2637 
2638   void set_arg_needs_null_check(int i, bool check) {
2639     _nonnull_state.set_arg_needs_null_check(i, check);
2640   }
2641 
2642   virtual void input_values_do(ValueVisitor* f)   {
2643     if (_recv != NULL) {
2644       f-&gt;visit(&amp;_recv);
2645     }
2646     for (int i = 0; i &lt; nb_profiled_args(); i++) {
2647       f-&gt;visit(_obj_args-&gt;adr_at(i));
2648     }
2649   }
2650 };
2651 
2652 LEAF(ProfileReturnType, Instruction)
2653  private:
2654   ciMethod*        _method;
2655   ciMethod*        _callee;
2656   int              _bci_of_invoke;
2657   Value            _ret;
2658 
2659  public:
2660   ProfileReturnType(ciMethod* method, int bci, ciMethod* callee, Value ret)
2661     : Instruction(voidType)
2662     , _method(method)
2663     , _callee(callee)
2664     , _bci_of_invoke(bci)
2665     , _ret(ret)
2666   {
2667     set_needs_null_check(true);
2668     // The ProfileType has side-effects and must occur precisely where located
2669     pin();
2670   }
2671 
2672   ciMethod* method()             const { return _method; }
2673   ciMethod* callee()             const { return _callee; }
2674   int bci_of_invoke()            const { return _bci_of_invoke; }
2675   Value ret()                    const { return _ret; }
2676 
2677   virtual void input_values_do(ValueVisitor* f)   {
2678     if (_ret != NULL) {
2679       f-&gt;visit(&amp;_ret);
2680     }
2681   }
2682 };
2683 
2684 // Call some C runtime function that doesn&#39;t safepoint,
2685 // optionally passing the current thread as the first argument.
2686 LEAF(RuntimeCall, Instruction)
2687  private:
2688   const char* _entry_name;
2689   address     _entry;
2690   Values*     _args;
2691   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
2692 
2693  public:
2694   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
2695     : Instruction(type)
2696     , _entry_name(entry_name)
2697     , _entry(entry)
2698     , _args(args)
2699     , _pass_thread(pass_thread) {
2700     ASSERT_VALUES
2701     pin();
2702   }
2703 
2704   const char* entry_name() const  { return _entry_name; }
2705   address entry() const           { return _entry; }
2706   int number_of_arguments() const { return _args-&gt;length(); }
2707   Value argument_at(int i) const  { return _args-&gt;at(i); }
2708   bool pass_thread() const        { return _pass_thread; }
2709 
2710   virtual void input_values_do(ValueVisitor* f)   {
2711     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
2712   }
2713 };
2714 
2715 // Use to trip invocation counter of an inlined method
2716 
2717 LEAF(ProfileInvoke, Instruction)
2718  private:
2719   ciMethod*   _inlinee;
2720   ValueStack* _state;
2721 
2722  public:
2723   ProfileInvoke(ciMethod* inlinee,  ValueStack* state)
2724     : Instruction(voidType)
2725     , _inlinee(inlinee)
2726     , _state(state)
2727   {
2728     // The ProfileInvoke has side-effects and must occur precisely where located QQQ???
2729     pin();
2730   }
2731 
2732   ciMethod* inlinee()      { return _inlinee; }
2733   ValueStack* state()      { return _state; }
2734   virtual void input_values_do(ValueVisitor*)   {}
2735   virtual void state_values_do(ValueVisitor*);
2736 };
2737 
2738 LEAF(MemBar, Instruction)
2739  private:
2740   LIR_Code _code;
2741 
2742  public:
2743   MemBar(LIR_Code code)
2744     : Instruction(voidType)
2745     , _code(code)
2746   {
2747     pin();
2748   }
2749 
2750   LIR_Code code()           { return _code; }
2751 
2752   virtual void input_values_do(ValueVisitor*)   {}
2753 };
2754 
2755 class BlockPair: public CompilationResourceObj {
2756  private:
2757   BlockBegin* _from;
2758   BlockBegin* _to;
2759  public:
2760   BlockPair(BlockBegin* from, BlockBegin* to): _from(from), _to(to) {}
2761   BlockBegin* from() const { return _from; }
2762   BlockBegin* to() const   { return _to;   }
2763   bool is_same(BlockBegin* from, BlockBegin* to) const { return  _from == from &amp;&amp; _to == to; }
2764   bool is_same(BlockPair* p) const { return  _from == p-&gt;from() &amp;&amp; _to == p-&gt;to(); }
2765   void set_to(BlockBegin* b)   { _to = b; }
2766   void set_from(BlockBegin* b) { _from = b; }
2767 };
2768 
2769 typedef GrowableArray&lt;BlockPair*&gt; BlockPairList;
2770 
2771 inline int         BlockBegin::number_of_sux() const            { assert(_end == NULL || _end-&gt;number_of_sux() == _successors.length(), &quot;mismatch&quot;); return _successors.length(); }
2772 inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end == NULL || _end-&gt;sux_at(i) == _successors.at(i), &quot;mismatch&quot;);          return _successors.at(i); }
2773 inline void        BlockBegin::add_successor(BlockBegin* sux)   { assert(_end == NULL, &quot;Would create mismatch with successors of BlockEnd&quot;);         _successors.append(sux); }
2774 
2775 #undef ASSERT_VALUES
2776 
2777 #endif // SHARE_C1_C1_INSTRUCTION_HPP
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>