<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangInvokeAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.org.objectweb.asm.ClassWriter;
  31 import jdk.internal.org.objectweb.asm.MethodVisitor;
  32 import jdk.internal.reflect.CallerSensitive;
  33 import jdk.internal.reflect.Reflection;
  34 import jdk.internal.vm.annotation.ForceInline;
  35 import jdk.internal.vm.annotation.Hidden;
  36 import jdk.internal.vm.annotation.Stable;
  37 import sun.invoke.empty.Empty;
  38 import sun.invoke.util.ValueConversions;
  39 import sun.invoke.util.VerifyType;
  40 import sun.invoke.util.Wrapper;
  41 
  42 import java.lang.invoke.MethodHandles.Lookup;
  43 import java.lang.reflect.Array;
  44 import java.nio.ByteOrder;
  45 import java.util.Arrays;
  46 import java.util.Collections;
  47 import java.util.HashMap;
  48 import java.util.Iterator;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.function.Function;
  52 import java.util.stream.Stream;
  53 
  54 import static java.lang.invoke.LambdaForm.*;
  55 import static java.lang.invoke.MethodHandleStatics.*;
  56 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  57 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  58 
  59 /**
  60  * Trusted implementation code for MethodHandle.
  61  * @author jrose
  62  */
  63 /*non-public*/
  64 abstract class MethodHandleImpl {
  65 
  66     /// Factory methods to create method handles:
  67 
  68     static MethodHandle makeArrayElementAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
  69         if (arrayClass == Object[].class) {
  70             return ArrayAccess.objectAccessor(access);
  71         }
  72         if (!arrayClass.isArray())
  73             throw newIllegalArgumentException(&quot;not an array: &quot;+arrayClass);
  74         MethodHandle[] cache = ArrayAccessor.TYPED_ACCESSORS.get(arrayClass);
  75         int cacheIndex = ArrayAccess.cacheIndex(access);
  76         MethodHandle mh = cache[cacheIndex];
  77         if (mh != null)  return mh;
  78         mh = ArrayAccessor.getAccessor(arrayClass, access);
  79         MethodType correctType = ArrayAccessor.correctType(arrayClass, access);
  80         if (mh.type() != correctType) {
  81             assert(mh.type().parameterType(0) == Object[].class);
  82             /* if access == SET */ assert(access != ArrayAccess.SET || mh.type().parameterType(2) == Object.class);
  83             /* if access == GET */ assert(access != ArrayAccess.GET ||
  84                     (mh.type().returnType() == Object.class &amp;&amp;
  85                      correctType.parameterType(0).getComponentType() == correctType.returnType()));
  86             // safe to view non-strictly, because element type follows from array type
  87             mh = mh.viewAsType(correctType, false);
  88         }
  89         mh = makeIntrinsic(mh, ArrayAccess.intrinsic(access));
  90         // Atomically update accessor cache.
  91         synchronized(cache) {
  92             if (cache[cacheIndex] == null) {
  93                 cache[cacheIndex] = mh;
  94             } else {
  95                 // Throw away newly constructed accessor and use cached version.
  96                 mh = cache[cacheIndex];
  97             }
  98         }
  99         return mh;
 100     }
 101 
 102     enum ArrayAccess {
 103         GET, SET, LENGTH;
 104 
 105         // As ArrayAccess and ArrayAccessor have a circular dependency, the ArrayAccess properties cannot be stored in
 106         // final fields.
 107 
 108         static String opName(ArrayAccess a) {
 109             switch (a) {
 110                 case GET: return &quot;getElement&quot;;
 111                 case SET: return &quot;setElement&quot;;
 112                 case LENGTH: return &quot;length&quot;;
 113             }
 114             throw unmatchedArrayAccess(a);
 115         }
 116 
 117         static MethodHandle objectAccessor(ArrayAccess a) {
 118             switch (a) {
 119                 case GET: return ArrayAccessor.OBJECT_ARRAY_GETTER;
 120                 case SET: return ArrayAccessor.OBJECT_ARRAY_SETTER;
 121                 case LENGTH: return ArrayAccessor.OBJECT_ARRAY_LENGTH;
 122             }
 123             throw unmatchedArrayAccess(a);
 124         }
 125 
 126         static int cacheIndex(ArrayAccess a) {
 127             switch (a) {
 128                 case GET: return ArrayAccessor.GETTER_INDEX;
 129                 case SET: return ArrayAccessor.SETTER_INDEX;
 130                 case LENGTH: return ArrayAccessor.LENGTH_INDEX;
 131             }
 132             throw unmatchedArrayAccess(a);
 133         }
 134 
 135         static Intrinsic intrinsic(ArrayAccess a) {
 136             switch (a) {
 137                 case GET: return Intrinsic.ARRAY_LOAD;
 138                 case SET: return Intrinsic.ARRAY_STORE;
 139                 case LENGTH: return Intrinsic.ARRAY_LENGTH;
 140             }
 141             throw unmatchedArrayAccess(a);
 142         }
 143     }
 144 
 145     static InternalError unmatchedArrayAccess(ArrayAccess a) {
 146         return newInternalError(&quot;should not reach here (unmatched ArrayAccess: &quot; + a + &quot;)&quot;);
 147     }
 148 
 149     static final class ArrayAccessor {
 150         /// Support for array element and length access
 151         static final int GETTER_INDEX = 0, SETTER_INDEX = 1, LENGTH_INDEX = 2, INDEX_LIMIT = 3;
 152         static final ClassValue&lt;MethodHandle[]&gt; TYPED_ACCESSORS
 153                 = new ClassValue&lt;MethodHandle[]&gt;() {
 154                     @Override
 155                     protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
 156                         return new MethodHandle[INDEX_LIMIT];
 157                     }
 158                 };
 159         static final MethodHandle OBJECT_ARRAY_GETTER, OBJECT_ARRAY_SETTER, OBJECT_ARRAY_LENGTH;
 160         static {
 161             MethodHandle[] cache = TYPED_ACCESSORS.get(Object[].class);
 162             cache[GETTER_INDEX] = OBJECT_ARRAY_GETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.GET),    Intrinsic.ARRAY_LOAD);
 163             cache[SETTER_INDEX] = OBJECT_ARRAY_SETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.SET),    Intrinsic.ARRAY_STORE);
 164             cache[LENGTH_INDEX] = OBJECT_ARRAY_LENGTH = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.LENGTH), Intrinsic.ARRAY_LENGTH);
 165 
 166             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_GETTER.internalMemberName()));
 167             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_SETTER.internalMemberName()));
 168             assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_LENGTH.internalMemberName()));
 169         }
 170 
 171         static int     getElementI(int[]     a, int i)            { return              a[i]; }
 172         static long    getElementJ(long[]    a, int i)            { return              a[i]; }
 173         static float   getElementF(float[]   a, int i)            { return              a[i]; }
 174         static double  getElementD(double[]  a, int i)            { return              a[i]; }
 175         static boolean getElementZ(boolean[] a, int i)            { return              a[i]; }
 176         static byte    getElementB(byte[]    a, int i)            { return              a[i]; }
 177         static short   getElementS(short[]   a, int i)            { return              a[i]; }
 178         static char    getElementC(char[]    a, int i)            { return              a[i]; }
 179         static Object  getElementL(Object[]  a, int i)            { return              a[i]; }
 180 
 181         static void    setElementI(int[]     a, int i, int     x) {              a[i] = x; }
 182         static void    setElementJ(long[]    a, int i, long    x) {              a[i] = x; }
 183         static void    setElementF(float[]   a, int i, float   x) {              a[i] = x; }
 184         static void    setElementD(double[]  a, int i, double  x) {              a[i] = x; }
 185         static void    setElementZ(boolean[] a, int i, boolean x) {              a[i] = x; }
 186         static void    setElementB(byte[]    a, int i, byte    x) {              a[i] = x; }
 187         static void    setElementS(short[]   a, int i, short   x) {              a[i] = x; }
 188         static void    setElementC(char[]    a, int i, char    x) {              a[i] = x; }
 189         static void    setElementL(Object[]  a, int i, Object  x) {              a[i] = x; }
 190 
 191         static int     lengthI(int[]     a)                       { return a.length; }
 192         static int     lengthJ(long[]    a)                       { return a.length; }
 193         static int     lengthF(float[]   a)                       { return a.length; }
 194         static int     lengthD(double[]  a)                       { return a.length; }
 195         static int     lengthZ(boolean[] a)                       { return a.length; }
 196         static int     lengthB(byte[]    a)                       { return a.length; }
 197         static int     lengthS(short[]   a)                       { return a.length; }
 198         static int     lengthC(char[]    a)                       { return a.length; }
 199         static int     lengthL(Object[]  a)                       { return a.length; }
 200 
 201         static String name(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 202             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 203             if (elemClass == null)  throw newIllegalArgumentException(&quot;not an array&quot;, arrayClass);
 204             return ArrayAccess.opName(access) + Wrapper.basicTypeChar(elemClass);
 205         }
 206         static MethodType type(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 207             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 208             Class&lt;?&gt; arrayArgClass = arrayClass;
 209             if (!elemClass.isPrimitive()) {
 210                 arrayArgClass = Object[].class;
 211                 elemClass = Object.class;
 212             }
 213             switch (access) {
 214                 case GET:    return MethodType.methodType(elemClass,  arrayArgClass, int.class);
 215                 case SET:    return MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);
 216                 case LENGTH: return MethodType.methodType(int.class,  arrayArgClass);
 217             }
 218             throw unmatchedArrayAccess(access);
 219         }
 220         static MethodType correctType(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 221             Class&lt;?&gt; elemClass = arrayClass.getComponentType();
 222             switch (access) {
 223                 case GET:    return MethodType.methodType(elemClass,  arrayClass, int.class);
 224                 case SET:    return MethodType.methodType(void.class, arrayClass, int.class, elemClass);
 225                 case LENGTH: return MethodType.methodType(int.class,  arrayClass);
 226             }
 227             throw unmatchedArrayAccess(access);
 228         }
 229         static MethodHandle getAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
 230             String     name = name(arrayClass, access);
 231             MethodType type = type(arrayClass, access);
 232             try {
 233                 return IMPL_LOOKUP.findStatic(ArrayAccessor.class, name, type);
 234             } catch (ReflectiveOperationException ex) {
 235                 throw uncaughtException(ex);
 236             }
 237         }
 238     }
 239 
 240     /**
 241      * Create a JVM-level adapter method handle to conform the given method
 242      * handle to the similar newType, using only pairwise argument conversions.
 243      * For each argument, convert incoming argument to the exact type needed.
 244      * The argument conversions allowed are casting, boxing and unboxing,
 245      * integral widening or narrowing, and floating point widening or narrowing.
 246      * @param srcType required call type
 247      * @param target original method handle
 248      * @param strict if true, only asType conversions are allowed; if false, explicitCastArguments conversions allowed
 249      * @param monobox if true, unboxing conversions are assumed to be exactly typed (Integer to int only, not long or double)
 250      * @return an adapter to the original handle with the desired new type,
 251      *          or the original target if the types are already identical
 252      *          or null if the adaptation cannot be made
 253      */
 254     static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,
 255                                             boolean strict, boolean monobox) {
 256         MethodType dstType = target.type();
 257         if (srcType == dstType)
 258             return target;
 259         return makePairwiseConvertByEditor(target, srcType, strict, monobox);
 260     }
 261 
 262     private static int countNonNull(Object[] array) {
 263         int count = 0;
 264         if (array != null) {
 265             for (Object x : array) {
 266                 if (x != null) ++count;
 267             }
 268         }
 269         return count;
 270     }
 271 
 272     static MethodHandle makePairwiseConvertByEditor(MethodHandle target, MethodType srcType,
 273                                                     boolean strict, boolean monobox) {
 274         // In method types arguments start at index 0, while the LF
 275         // editor have the MH receiver at position 0 - adjust appropriately.
 276         final int MH_RECEIVER_OFFSET = 1;
 277         Object[] convSpecs = computeValueConversions(srcType, target.type(), strict, monobox);
 278         int convCount = countNonNull(convSpecs);
 279         if (convCount == 0)
 280             return target.viewAsType(srcType, strict);
 281         MethodType basicSrcType = srcType.basicType();
 282         MethodType midType = target.type().basicType();
 283         BoundMethodHandle mh = target.rebind();
 284 
 285         // Match each unique conversion to the positions at which it is to be applied
 286         var convSpecMap = new HashMap&lt;Object, int[]&gt;(((4 * convCount) / 3) + 1);
 287         for (int i = 0; i &lt; convSpecs.length - MH_RECEIVER_OFFSET; i++) {
 288             Object convSpec = convSpecs[i];
 289             if (convSpec == null) continue;
 290             int[] positions = convSpecMap.get(convSpec);
 291             if (positions == null) {
 292                 positions = new int[] { i + MH_RECEIVER_OFFSET };
 293             } else {
 294                 positions = Arrays.copyOf(positions, positions.length + 1);
 295                 positions[positions.length - 1] = i + MH_RECEIVER_OFFSET;
 296             }
 297             convSpecMap.put(convSpec, positions);
 298         }
 299         for (var entry : convSpecMap.entrySet()) {
 300             Object convSpec = entry.getKey();
 301 
 302             MethodHandle fn;
 303             if (convSpec instanceof Class) {
 304                 fn = getConstantHandle(MH_cast).bindTo(convSpec);
 305             } else {
 306                 fn = (MethodHandle) convSpec;
 307             }
 308             int[] positions = entry.getValue();
 309             Class&lt;?&gt; newType = basicSrcType.parameterType(positions[0] - MH_RECEIVER_OFFSET);
 310             BasicType newBasicType = BasicType.basicType(newType);
 311             convCount -= positions.length;
 312             if (convCount == 0) {
 313                 midType = srcType;
 314             } else {
 315                 Class&lt;?&gt;[] ptypes = midType.ptypes().clone();
 316                 for (int pos : positions) {
 317                     ptypes[pos - 1] = newType;
 318                 }
 319                 midType = MethodType.makeImpl(midType.rtype(), ptypes, true);
 320             }
 321             LambdaForm form2;
 322             if (positions.length &gt; 1) {
 323                 form2 = mh.editor().filterRepeatedArgumentForm(newBasicType, positions);
 324             } else {
 325                 form2 = mh.editor().filterArgumentForm(positions[0], newBasicType);
 326             }
 327             mh = mh.copyWithExtendL(midType, form2, fn);
 328         }
 329         Object convSpec = convSpecs[convSpecs.length - 1];
 330         if (convSpec != null) {
 331             MethodHandle fn;
 332             if (convSpec instanceof Class) {
 333                 if (convSpec == void.class)
 334                     fn = null;
 335                 else
 336                     fn = getConstantHandle(MH_cast).bindTo(convSpec);
 337             } else {
 338                 fn = (MethodHandle) convSpec;
 339             }
 340             Class&lt;?&gt; newType = basicSrcType.returnType();
 341             assert(--convCount == 0);
 342             midType = srcType;
 343             if (fn != null) {
 344                 mh = mh.rebind();  // rebind if too complex
 345                 LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), false);
 346                 mh = mh.copyWithExtendL(midType, form2, fn);
 347             } else {
 348                 LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), true);
 349                 mh = mh.copyWith(midType, form2);
 350             }
 351         }
 352         assert(convCount == 0);
 353         assert(mh.type().equals(srcType));
 354         return mh;
 355     }
 356 
 357     static Object[] computeValueConversions(MethodType srcType, MethodType dstType,
 358                                             boolean strict, boolean monobox) {
 359         final int INARG_COUNT = srcType.parameterCount();
 360         Object[] convSpecs = null;
 361         for (int i = 0; i &lt;= INARG_COUNT; i++) {
 362             boolean isRet = (i == INARG_COUNT);
 363             Class&lt;?&gt; src = isRet ? dstType.returnType() : srcType.parameterType(i);
 364             Class&lt;?&gt; dst = isRet ? srcType.returnType() : dstType.parameterType(i);
 365             if (!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict)) {
 366                 if (convSpecs == null) {
 367                     convSpecs = new Object[INARG_COUNT + 1];
 368                 }
 369                 convSpecs[i] = valueConversion(src, dst, strict, monobox);
 370             }
 371         }
 372         return convSpecs;
 373     }
 374     static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,
 375                                             boolean strict) {
 376         return makePairwiseConvert(target, srcType, strict, /*monobox=*/ false);
 377     }
 378 
 379     /**
 380      * Find a conversion function from the given source to the given destination.
 381      * This conversion function will be used as a LF NamedFunction.
 382      * Return a Class object if a simple cast is needed.
 383      * Return void.class if void is involved.
 384      */
 385     static Object valueConversion(Class&lt;?&gt; src, Class&lt;?&gt; dst, boolean strict, boolean monobox) {
 386         assert(!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict));  // caller responsibility
 387         if (dst == void.class)
 388             return dst;
 389         MethodHandle fn;
 390         if (src.isPrimitive()) {
 391             if (src == void.class) {
 392                 return void.class;  // caller must recognize this specially
 393             } else if (dst.isPrimitive()) {
 394                 // Examples: int-&gt;byte, byte-&gt;int, boolean-&gt;int (!strict)
 395                 fn = ValueConversions.convertPrimitive(src, dst);
 396             } else {
 397                 // Examples: int-&gt;Integer, boolean-&gt;Object, float-&gt;Number
 398                 Wrapper wsrc = Wrapper.forPrimitiveType(src);
 399                 fn = ValueConversions.boxExact(wsrc);
 400                 assert(fn.type().parameterType(0) == wsrc.primitiveType());
 401                 assert(fn.type().returnType() == wsrc.wrapperType());
 402                 if (!VerifyType.isNullConversion(wsrc.wrapperType(), dst, strict)) {
 403                     // Corner case, such as int-&gt;Long, which will probably fail.
 404                     MethodType mt = MethodType.methodType(dst, src);
 405                     if (strict)
 406                         fn = fn.asType(mt);
 407                     else
 408                         fn = MethodHandleImpl.makePairwiseConvert(fn, mt, /*strict=*/ false);
 409                 }
 410             }
 411         } else if (dst.isPrimitive()) {
 412             Wrapper wdst = Wrapper.forPrimitiveType(dst);
 413             if (monobox || src == wdst.wrapperType()) {
 414                 // Use a strongly-typed unboxer, if possible.
 415                 fn = ValueConversions.unboxExact(wdst, strict);
 416             } else {
 417                 // Examples:  Object-&gt;int, Number-&gt;int, Comparable-&gt;int, Byte-&gt;int
 418                 // must include additional conversions
 419                 // src must be examined at runtime, to detect Byte, Character, etc.
 420                 fn = (strict
 421                         ? ValueConversions.unboxWiden(wdst)
 422                         : ValueConversions.unboxCast(wdst));
 423             }
 424         } else {
 425             // Simple reference conversion.
 426             // Note:  Do not check for a class hierarchy relation
 427             // between src and dst.  In all cases a &#39;null&#39; argument
 428             // will pass the cast conversion.
 429             return dst;
 430         }
 431         assert(fn.type().parameterCount() &lt;= 1) : &quot;pc&quot;+Arrays.asList(src.getSimpleName(), dst.getSimpleName(), fn);
 432         return fn;
 433     }
 434 
 435     static MethodHandle makeVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {
 436         MethodType type = target.type();
 437         int last = type.parameterCount() - 1;
 438         if (type.parameterType(last) != arrayType)
 439             target = target.asType(type.changeParameterType(last, arrayType));
 440         target = target.asFixedArity();  // make sure this attribute is turned off
 441         return new AsVarargsCollector(target, arrayType);
 442     }
 443 
 444     private static final class AsVarargsCollector extends DelegatingMethodHandle {
 445         private final MethodHandle target;
 446         private final Class&lt;?&gt; arrayType;
 447         private @Stable MethodHandle asCollectorCache;
 448 
 449         AsVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {
 450             this(target.type(), target, arrayType);
 451         }
 452         AsVarargsCollector(MethodType type, MethodHandle target, Class&lt;?&gt; arrayType) {
 453             super(type, target);
 454             this.target = target;
 455             this.arrayType = arrayType;
 456         }
 457 
 458         @Override
 459         public boolean isVarargsCollector() {
 460             return true;
 461         }
 462 
 463         @Override
 464         protected MethodHandle getTarget() {
 465             return target;
 466         }
 467 
 468         @Override
 469         public MethodHandle asFixedArity() {
 470             return target;
 471         }
 472 
 473         @Override
 474         MethodHandle setVarargs(MemberName member) {
 475             if (member.isVarargs())  return this;
 476             return asFixedArity();
 477         }
 478 
 479         @Override
 480         public MethodHandle withVarargs(boolean makeVarargs) {
 481             if (makeVarargs)  return this;
 482             return asFixedArity();
 483         }
 484 
 485         @Override
 486         public MethodHandle asTypeUncached(MethodType newType) {
 487             MethodType type = this.type();
 488             int collectArg = type.parameterCount() - 1;
 489             int newArity = newType.parameterCount();
 490             if (newArity == collectArg+1 &amp;&amp;
 491                 type.parameterType(collectArg).isAssignableFrom(newType.parameterType(collectArg))) {
 492                 // if arity and trailing parameter are compatible, do normal thing
 493                 return asTypeCache = asFixedArity().asType(newType);
 494             }
 495             // check cache
 496             MethodHandle acc = asCollectorCache;
 497             if (acc != null &amp;&amp; acc.type().parameterCount() == newArity)
 498                 return asTypeCache = acc.asType(newType);
 499             // build and cache a collector
 500             int arrayLength = newArity - collectArg;
 501             MethodHandle collector;
 502             try {
 503                 collector = asFixedArity().asCollector(arrayType, arrayLength);
 504                 assert(collector.type().parameterCount() == newArity) : &quot;newArity=&quot;+newArity+&quot; but collector=&quot;+collector;
 505             } catch (IllegalArgumentException ex) {
 506                 throw new WrongMethodTypeException(&quot;cannot build collector&quot;, ex);
 507             }
 508             asCollectorCache = collector;
 509             return asTypeCache = collector.asType(newType);
 510         }
 511 
 512         @Override
 513         boolean viewAsTypeChecks(MethodType newType, boolean strict) {
 514             super.viewAsTypeChecks(newType, true);
 515             if (strict) return true;
 516             // extra assertion for non-strict checks:
 517             assert (type().lastParameterType().getComponentType()
 518                     .isAssignableFrom(
 519                             newType.lastParameterType().getComponentType()))
 520                     : Arrays.asList(this, newType);
 521             return true;
 522         }
 523 
 524         @Override
 525         public Object invokeWithArguments(Object... arguments) throws Throwable {
 526             MethodType type = this.type();
 527             int argc;
 528             final int MAX_SAFE = 127;  // 127 longs require 254 slots, which is safe to spread
 529             if (arguments == null
 530                     || (argc = arguments.length) &lt;= MAX_SAFE
 531                     || argc &lt; type.parameterCount()) {
 532                 return super.invokeWithArguments(arguments);
 533             }
 534 
 535             // a jumbo invocation requires more explicit reboxing of the trailing arguments
 536             int uncollected = type.parameterCount() - 1;
 537             Class&lt;?&gt; elemType = arrayType.getComponentType();
 538             int collected = argc - uncollected;
 539             Object collArgs = (elemType == Object.class)
 540                 ? new Object[collected] : Array.newInstance(elemType, collected);
 541             if (!elemType.isPrimitive()) {
 542                 // simple cast:  just do some casting
 543                 try {
 544                     System.arraycopy(arguments, uncollected, collArgs, 0, collected);
 545                 } catch (ArrayStoreException ex) {
 546                     return super.invokeWithArguments(arguments);
 547                 }
 548             } else {
 549                 // corner case of flat array requires reflection (or specialized copy loop)
 550                 MethodHandle arraySetter = MethodHandles.arrayElementSetter(arrayType);
 551                 try {
 552                     for (int i = 0; i &lt; collected; i++) {
 553                         arraySetter.invoke(collArgs, i, arguments[uncollected + i]);
 554                     }
 555                 } catch (WrongMethodTypeException|ClassCastException ex) {
 556                     return super.invokeWithArguments(arguments);
 557                 }
 558             }
 559 
 560             // chop the jumbo list down to size and call in non-varargs mode
 561             Object[] newArgs = new Object[uncollected + 1];
 562             System.arraycopy(arguments, 0, newArgs, 0, uncollected);
 563             newArgs[uncollected] = collArgs;
 564             return asFixedArity().invokeWithArguments(newArgs);
 565         }
 566     }
 567 
 568     /** Factory method:  Spread selected argument. */
 569     static MethodHandle makeSpreadArguments(MethodHandle target,
 570                                             Class&lt;?&gt; spreadArgType, int spreadArgPos, int spreadArgCount) {
 571         MethodType targetType = target.type();
 572 
 573         for (int i = 0; i &lt; spreadArgCount; i++) {
 574             Class&lt;?&gt; arg = VerifyType.spreadArgElementType(spreadArgType, i);
 575             if (arg == null)  arg = Object.class;
 576             targetType = targetType.changeParameterType(spreadArgPos + i, arg);
 577         }
 578         target = target.asType(targetType);
 579 
 580         MethodType srcType = targetType
 581                 .replaceParameterTypes(spreadArgPos, spreadArgPos + spreadArgCount, spreadArgType);
 582         // Now build a LambdaForm.
 583         MethodType lambdaType = srcType.invokerType();
 584         Name[] names = arguments(spreadArgCount + 2, lambdaType);
 585         int nameCursor = lambdaType.parameterCount();
 586         int[] indexes = new int[targetType.parameterCount()];
 587 
 588         for (int i = 0, argIndex = 1; i &lt; targetType.parameterCount() + 1; i++, argIndex++) {
 589             Class&lt;?&gt; src = lambdaType.parameterType(i);
 590             if (i == spreadArgPos) {
 591                 // Spread the array.
 592                 MethodHandle aload = MethodHandles.arrayElementGetter(spreadArgType);
 593                 Name array = names[argIndex];
 594                 names[nameCursor++] = new Name(getFunction(NF_checkSpreadArgument), array, spreadArgCount);
 595                 for (int j = 0; j &lt; spreadArgCount; i++, j++) {
 596                     indexes[i] = nameCursor;
 597                     names[nameCursor++] = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), array, j);
 598                 }
 599             } else if (i &lt; indexes.length) {
 600                 indexes[i] = argIndex;
 601             }
 602         }
 603         assert(nameCursor == names.length-1);  // leave room for the final call
 604 
 605         // Build argument array for the call.
 606         Name[] targetArgs = new Name[targetType.parameterCount()];
 607         for (int i = 0; i &lt; targetType.parameterCount(); i++) {
 608             int idx = indexes[i];
 609             targetArgs[i] = names[idx];
 610         }
 611         names[names.length - 1] = new Name(target, (Object[]) targetArgs);
 612 
 613         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.SPREAD);
 614         return SimpleMethodHandle.make(srcType, form);
 615     }
 616 
 617     static void checkSpreadArgument(Object av, int n) {
 618         if (av == null &amp;&amp; n == 0) {
 619             return;
 620         } else if (av == null) {
 621             throw new NullPointerException(&quot;null array reference&quot;);
 622         } else if (av instanceof Object[]) {
 623             int len = ((Object[])av).length;
 624             if (len == n)  return;
 625         } else {
 626             int len = java.lang.reflect.Array.getLength(av);
 627             if (len == n)  return;
 628         }
 629         // fall through to error:
 630         throw newIllegalArgumentException(&quot;array is not of length &quot;+n);
 631     }
 632 
 633     /** Factory method:  Collect or filter selected argument(s). */
 634     static MethodHandle makeCollectArguments(MethodHandle target,
 635                 MethodHandle collector, int collectArgPos, boolean retainOriginalArgs) {
 636         MethodType targetType = target.type();          // (a..., c, [b...])=&gt;r
 637         MethodType collectorType = collector.type();    // (b...)=&gt;c
 638         int collectArgCount = collectorType.parameterCount();
 639         Class&lt;?&gt; collectValType = collectorType.returnType();
 640         int collectValCount = (collectValType == void.class ? 0 : 1);
 641         MethodType srcType = targetType                 // (a..., [b...])=&gt;r
 642                 .dropParameterTypes(collectArgPos, collectArgPos+collectValCount);
 643         if (!retainOriginalArgs) {                      // (a..., b...)=&gt;r
 644             srcType = srcType.insertParameterTypes(collectArgPos, collectorType.parameterArray());
 645         }
 646         // in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]
 647         // out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]
 648         // out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]
 649 
 650         // Now build a LambdaForm.
 651         MethodType lambdaType = srcType.invokerType();
 652         Name[] names = arguments(2, lambdaType);
 653         final int collectNamePos = names.length - 2;
 654         final int targetNamePos  = names.length - 1;
 655 
 656         Name[] collectorArgs = Arrays.copyOfRange(names, 1 + collectArgPos, 1 + collectArgPos + collectArgCount);
 657         names[collectNamePos] = new Name(collector, (Object[]) collectorArgs);
 658 
 659         // Build argument array for the target.
 660         // Incoming LF args to copy are: [ (mh) headArgs collectArgs tailArgs ].
 661         // Output argument array is [ headArgs (collectVal)? (collectArgs)? tailArgs ].
 662         Name[] targetArgs = new Name[targetType.parameterCount()];
 663         int inputArgPos  = 1;  // incoming LF args to copy to target
 664         int targetArgPos = 0;  // fill pointer for targetArgs
 665         int chunk = collectArgPos;  // |headArgs|
 666         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 667         inputArgPos  += chunk;
 668         targetArgPos += chunk;
 669         if (collectValType != void.class) {
 670             targetArgs[targetArgPos++] = names[collectNamePos];
 671         }
 672         chunk = collectArgCount;
 673         if (retainOriginalArgs) {
 674             System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 675             targetArgPos += chunk;   // optionally pass on the collected chunk
 676         }
 677         inputArgPos += chunk;
 678         chunk = targetArgs.length - targetArgPos;  // all the rest
 679         System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
 680         assert(inputArgPos + chunk == collectNamePos);  // use of rest of input args also
 681         names[targetNamePos] = new Name(target, (Object[]) targetArgs);
 682 
 683         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);
 684         return SimpleMethodHandle.make(srcType, form);
 685     }
 686 
 687     @Hidden
 688     static MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {
 689         if (testResult) {
 690             return target;
 691         } else {
 692             return fallback;
 693         }
 694     }
 695 
 696     // Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.
 697     @Hidden
 698     @jdk.internal.HotSpotIntrinsicCandidate
 699     static boolean profileBoolean(boolean result, int[] counters) {
 700         // Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.
 701         int idx = result ? 1 : 0;
 702         try {
 703             counters[idx] = Math.addExact(counters[idx], 1);
 704         } catch (ArithmeticException e) {
 705             // Avoid continuous overflow by halving the problematic count.
 706             counters[idx] = counters[idx] / 2;
 707         }
 708         return result;
 709     }
 710 
 711     // Intrinsified by C2. Returns true if obj is a compile-time constant.
 712     @Hidden
 713     @jdk.internal.HotSpotIntrinsicCandidate
 714     static boolean isCompileConstant(Object obj) {
 715         return false;
 716     }
 717 
 718     static MethodHandle makeGuardWithTest(MethodHandle test,
 719                                    MethodHandle target,
 720                                    MethodHandle fallback) {
 721         MethodType type = target.type();
 722         assert(test.type().equals(type.changeReturnType(boolean.class)) &amp;&amp; fallback.type().equals(type));
 723         MethodType basicType = type.basicType();
 724         LambdaForm form = makeGuardWithTestForm(basicType);
 725         BoundMethodHandle mh;
 726         try {
 727             if (PROFILE_GWT) {
 728                 int[] counts = new int[2];
 729                 mh = (BoundMethodHandle)
 730                         BoundMethodHandle.speciesData_LLLL().factory().invokeBasic(type, form,
 731                                 (Object) test, (Object) profile(target), (Object) profile(fallback), counts);
 732             } else {
 733                 mh = (BoundMethodHandle)
 734                         BoundMethodHandle.speciesData_LLL().factory().invokeBasic(type, form,
 735                                 (Object) test, (Object) profile(target), (Object) profile(fallback));
 736             }
 737         } catch (Throwable ex) {
 738             throw uncaughtException(ex);
 739         }
 740         assert(mh.type() == type);
 741         return mh;
 742     }
 743 
 744 
 745     static MethodHandle profile(MethodHandle target) {
 746         if (DONT_INLINE_THRESHOLD &gt;= 0) {
 747             return makeBlockInliningWrapper(target);
 748         } else {
 749             return target;
 750         }
 751     }
 752 
 753     /**
 754      * Block inlining during JIT-compilation of a target method handle if it hasn&#39;t been invoked enough times.
 755      * Corresponding LambdaForm has @DontInline when compiled into bytecode.
 756      */
 757     static MethodHandle makeBlockInliningWrapper(MethodHandle target) {
 758         LambdaForm lform;
 759         if (DONT_INLINE_THRESHOLD &gt; 0) {
 760             lform = Makers.PRODUCE_BLOCK_INLINING_FORM.apply(target);
 761         } else {
 762             lform = Makers.PRODUCE_REINVOKER_FORM.apply(target);
 763         }
 764         return new CountingWrapper(target, lform,
 765                 Makers.PRODUCE_BLOCK_INLINING_FORM, Makers.PRODUCE_REINVOKER_FORM,
 766                                    DONT_INLINE_THRESHOLD);
 767     }
 768 
 769     private final static class Makers {
 770         /** Constructs reinvoker lambda form which block inlining during JIT-compilation for a particular method handle */
 771         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_BLOCK_INLINING_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 772             @Override
 773             public LambdaForm apply(MethodHandle target) {
 774                 return DelegatingMethodHandle.makeReinvokerForm(target,
 775                                    MethodTypeForm.LF_DELEGATE_BLOCK_INLINING, CountingWrapper.class, false,
 776                                    DelegatingMethodHandle.NF_getTarget, CountingWrapper.NF_maybeStopCounting);
 777             }
 778         };
 779 
 780         /** Constructs simple reinvoker lambda form for a particular method handle */
 781         static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_REINVOKER_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
 782             @Override
 783             public LambdaForm apply(MethodHandle target) {
 784                 return DelegatingMethodHandle.makeReinvokerForm(target,
 785                         MethodTypeForm.LF_DELEGATE, DelegatingMethodHandle.class, DelegatingMethodHandle.NF_getTarget);
 786             }
 787         };
 788 
 789         /** Maker of type-polymorphic varargs */
 790         static final ClassValue&lt;MethodHandle[]&gt; TYPED_COLLECTORS = new ClassValue&lt;MethodHandle[]&gt;() {
 791             @Override
 792             protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
 793                 return new MethodHandle[MAX_JVM_ARITY + 1];
 794             }
 795         };
 796     }
 797 
 798     /**
 799      * Counting method handle. It has 2 states: counting and non-counting.
 800      * It is in counting state for the first n invocations and then transitions to non-counting state.
 801      * Behavior in counting and non-counting states is determined by lambda forms produced by
 802      * countingFormProducer &amp; nonCountingFormProducer respectively.
 803      */
 804     static class CountingWrapper extends DelegatingMethodHandle {
 805         private final MethodHandle target;
 806         private int count;
 807         private Function&lt;MethodHandle, LambdaForm&gt; countingFormProducer;
 808         private Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer;
 809         private volatile boolean isCounting;
 810 
 811         private CountingWrapper(MethodHandle target, LambdaForm lform,
 812                                 Function&lt;MethodHandle, LambdaForm&gt; countingFromProducer,
 813                                 Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer,
 814                                 int count) {
 815             super(target.type(), lform);
 816             this.target = target;
 817             this.count = count;
 818             this.countingFormProducer = countingFromProducer;
 819             this.nonCountingFormProducer = nonCountingFormProducer;
 820             this.isCounting = (count &gt; 0);
 821         }
 822 
 823         @Hidden
 824         @Override
 825         protected MethodHandle getTarget() {
 826             return target;
 827         }
 828 
 829         @Override
 830         public MethodHandle asTypeUncached(MethodType newType) {
 831             MethodHandle newTarget = target.asType(newType);
 832             MethodHandle wrapper;
 833             if (isCounting) {
 834                 LambdaForm lform;
 835                 lform = countingFormProducer.apply(newTarget);
 836                 wrapper = new CountingWrapper(newTarget, lform, countingFormProducer, nonCountingFormProducer, DONT_INLINE_THRESHOLD);
 837             } else {
 838                 wrapper = newTarget; // no need for a counting wrapper anymore
 839             }
 840             return (asTypeCache = wrapper);
 841         }
 842 
 843         // Customize target if counting happens for too long.
 844         private int invocations = CUSTOMIZE_THRESHOLD;
 845         private void maybeCustomizeTarget() {
 846             int c = invocations;
 847             if (c &gt;= 0) {
 848                 if (c == 1) {
 849                     target.customize();
 850                 }
 851                 invocations = c - 1;
 852             }
 853         }
 854 
 855         boolean countDown() {
 856             int c = count;
 857             maybeCustomizeTarget();
 858             if (c &lt;= 1) {
 859                 // Try to limit number of updates. MethodHandle.updateForm() doesn&#39;t guarantee LF update visibility.
 860                 if (isCounting) {
 861                     isCounting = false;
 862                     return true;
 863                 } else {
 864                     return false;
 865                 }
 866             } else {
 867                 count = c - 1;
 868                 return false;
 869             }
 870         }
 871 
 872         @Hidden
 873         static void maybeStopCounting(Object o1) {
 874              CountingWrapper wrapper = (CountingWrapper) o1;
 875              if (wrapper.countDown()) {
 876                  // Reached invocation threshold. Replace counting behavior with a non-counting one.
 877                  LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);
 878                  lform.compileToBytecode(); // speed up warmup by avoiding LF interpretation again after transition
 879                  wrapper.updateForm(lform);
 880              }
 881         }
 882 
 883         static final NamedFunction NF_maybeStopCounting;
 884         static {
 885             Class&lt;?&gt; THIS_CLASS = CountingWrapper.class;
 886             try {
 887                 NF_maybeStopCounting = new NamedFunction(THIS_CLASS.getDeclaredMethod(&quot;maybeStopCounting&quot;, Object.class));
 888             } catch (ReflectiveOperationException ex) {
 889                 throw newInternalError(ex);
 890             }
 891         }
 892     }
 893 
 894     static LambdaForm makeGuardWithTestForm(MethodType basicType) {
 895         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWT);
 896         if (lform != null)  return lform;
 897         final int THIS_MH      = 0;  // the BMH_LLL
 898         final int ARG_BASE     = 1;  // start of incoming arguments
 899         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 900         int nameCursor = ARG_LIMIT;
 901         final int GET_TEST     = nameCursor++;
 902         final int GET_TARGET   = nameCursor++;
 903         final int GET_FALLBACK = nameCursor++;
 904         final int GET_COUNTERS = PROFILE_GWT ? nameCursor++ : -1;
 905         final int CALL_TEST    = nameCursor++;
 906         final int PROFILE      = (GET_COUNTERS != -1) ? nameCursor++ : -1;
 907         final int TEST         = nameCursor-1; // previous statement: either PROFILE or CALL_TEST
 908         final int SELECT_ALT   = nameCursor++;
 909         final int CALL_TARGET  = nameCursor++;
 910         assert(CALL_TARGET == SELECT_ALT+1);  // must be true to trigger IBG.emitSelectAlternative
 911 
 912         MethodType lambdaType = basicType.invokerType();
 913         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 914 
 915         BoundMethodHandle.SpeciesData data =
 916                 (GET_COUNTERS != -1) ? BoundMethodHandle.speciesData_LLLL()
 917                                      : BoundMethodHandle.speciesData_LLL();
 918         names[THIS_MH] = names[THIS_MH].withConstraint(data);
 919         names[GET_TEST]     = new Name(data.getterFunction(0), names[THIS_MH]);
 920         names[GET_TARGET]   = new Name(data.getterFunction(1), names[THIS_MH]);
 921         names[GET_FALLBACK] = new Name(data.getterFunction(2), names[THIS_MH]);
 922         if (GET_COUNTERS != -1) {
 923             names[GET_COUNTERS] = new Name(data.getterFunction(3), names[THIS_MH]);
 924         }
 925         Object[] invokeArgs = Arrays.copyOfRange(names, 0, ARG_LIMIT, Object[].class);
 926 
 927         // call test
 928         MethodType testType = basicType.changeReturnType(boolean.class).basicType();
 929         invokeArgs[0] = names[GET_TEST];
 930         names[CALL_TEST] = new Name(testType, invokeArgs);
 931 
 932         // profile branch
 933         if (PROFILE != -1) {
 934             names[PROFILE] = new Name(getFunction(NF_profileBoolean), names[CALL_TEST], names[GET_COUNTERS]);
 935         }
 936         // call selectAlternative
 937         names[SELECT_ALT] = new Name(new NamedFunction(getConstantHandle(MH_selectAlternative), Intrinsic.SELECT_ALTERNATIVE), names[TEST], names[GET_TARGET], names[GET_FALLBACK]);
 938 
 939         // call target or fallback
 940         invokeArgs[0] = names[SELECT_ALT];
 941         names[CALL_TARGET] = new Name(basicType, invokeArgs);
 942 
 943         lform = new LambdaForm(lambdaType.parameterCount(), names, /*forceInline=*/true, Kind.GUARD);
 944 
 945         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWT, lform);
 946     }
 947 
 948     /**
 949      * The LambdaForm shape for catchException combinator is the following:
 950      * &lt;blockquote&gt;&lt;pre&gt;{@code
 951      *  guardWithCatch=Lambda(a0:L,a1:L,a2:L)=&gt;{
 952      *    t3:L=BoundMethodHandle$Species_LLLLL.argL0(a0:L);
 953      *    t4:L=BoundMethodHandle$Species_LLLLL.argL1(a0:L);
 954      *    t5:L=BoundMethodHandle$Species_LLLLL.argL2(a0:L);
 955      *    t6:L=BoundMethodHandle$Species_LLLLL.argL3(a0:L);
 956      *    t7:L=BoundMethodHandle$Species_LLLLL.argL4(a0:L);
 957      *    t8:L=MethodHandle.invokeBasic(t6:L,a1:L,a2:L);
 958      *    t9:L=MethodHandleImpl.guardWithCatch(t3:L,t4:L,t5:L,t8:L);
 959      *   t10:I=MethodHandle.invokeBasic(t7:L,t9:L);t10:I}
 960      * }&lt;/pre&gt;&lt;/blockquote&gt;
 961      *
 962      * argL0 and argL2 are target and catcher method handles. argL1 is exception class.
 963      * argL3 and argL4 are auxiliary method handles: argL3 boxes arguments and wraps them into Object[]
 964      * (ValueConversions.array()) and argL4 unboxes result if necessary (ValueConversions.unbox()).
 965      *
 966      * Having t8 and t10 passed outside and not hardcoded into a lambda form allows to share lambda forms
 967      * among catchException combinators with the same basic type.
 968      */
 969     private static LambdaForm makeGuardWithCatchForm(MethodType basicType) {
 970         MethodType lambdaType = basicType.invokerType();
 971 
 972         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWC);
 973         if (lform != null) {
 974             return lform;
 975         }
 976         final int THIS_MH      = 0;  // the BMH_LLLLL
 977         final int ARG_BASE     = 1;  // start of incoming arguments
 978         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
 979 
 980         int nameCursor = ARG_LIMIT;
 981         final int GET_TARGET       = nameCursor++;
 982         final int GET_CLASS        = nameCursor++;
 983         final int GET_CATCHER      = nameCursor++;
 984         final int GET_COLLECT_ARGS = nameCursor++;
 985         final int GET_UNBOX_RESULT = nameCursor++;
 986         final int BOXED_ARGS       = nameCursor++;
 987         final int TRY_CATCH        = nameCursor++;
 988         final int UNBOX_RESULT     = nameCursor++;
 989 
 990         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
 991 
 992         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
 993         names[THIS_MH]          = names[THIS_MH].withConstraint(data);
 994         names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
 995         names[GET_CLASS]        = new Name(data.getterFunction(1), names[THIS_MH]);
 996         names[GET_CATCHER]      = new Name(data.getterFunction(2), names[THIS_MH]);
 997         names[GET_COLLECT_ARGS] = new Name(data.getterFunction(3), names[THIS_MH]);
 998         names[GET_UNBOX_RESULT] = new Name(data.getterFunction(4), names[THIS_MH]);
 999 
1000         // FIXME: rework argument boxing/result unboxing logic for LF interpretation
1001 
1002         // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
1003         MethodType collectArgsType = basicType.changeReturnType(Object.class);
1004         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
1005         Object[] args = new Object[invokeBasic.type().parameterCount()];
1006         args[0] = names[GET_COLLECT_ARGS];
1007         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
1008         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.GUARD_WITH_CATCH), args);
1009 
1010         // t_{i+1}:L=MethodHandleImpl.guardWithCatch(target:L,exType:L,catcher:L,t_{i}:L);
1011         Object[] gwcArgs = new Object[] {names[GET_TARGET], names[GET_CLASS], names[GET_CATCHER], names[BOXED_ARGS]};
1012         names[TRY_CATCH] = new Name(getFunction(NF_guardWithCatch), gwcArgs);
1013 
1014         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
1015         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
1016         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_CATCH]};
1017         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
1018 
1019         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);
1020 
1021         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWC, lform);
1022     }
1023 
1024     static MethodHandle makeGuardWithCatch(MethodHandle target,
1025                                     Class&lt;? extends Throwable&gt; exType,
1026                                     MethodHandle catcher) {
1027         MethodType type = target.type();
1028         LambdaForm form = makeGuardWithCatchForm(type.basicType());
1029 
1030         // Prepare auxiliary method handles used during LambdaForm interpretation.
1031         // Box arguments and wrap them into Object[]: ValueConversions.array().
1032         MethodType varargsType = type.changeReturnType(Object[].class);
1033         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1034         MethodHandle unboxResult = unboxResultHandle(type.returnType());
1035 
1036         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
1037         BoundMethodHandle mh;
1038         try {
1039             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) exType,
1040                     (Object) catcher, (Object) collectArgs, (Object) unboxResult);
1041         } catch (Throwable ex) {
1042             throw uncaughtException(ex);
1043         }
1044         assert(mh.type() == type);
1045         return mh;
1046     }
1047 
1048     /**
1049      * Intrinsified during LambdaForm compilation
1050      * (see {@link InvokerBytecodeGenerator#emitGuardWithCatch emitGuardWithCatch}).
1051      */
1052     @Hidden
1053     static Object guardWithCatch(MethodHandle target, Class&lt;? extends Throwable&gt; exType, MethodHandle catcher,
1054                                  Object... av) throws Throwable {
1055         // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
1056         try {
1057             return target.asFixedArity().invokeWithArguments(av);
1058         } catch (Throwable t) {
1059             if (!exType.isInstance(t)) throw t;
1060             return catcher.asFixedArity().invokeWithArguments(prepend(av, t));
1061         }
1062     }
1063 
1064     /** Prepend elements to an array. */
1065     @Hidden
1066     private static Object[] prepend(Object[] array, Object... elems) {
1067         int nArray = array.length;
1068         int nElems = elems.length;
1069         Object[] newArray = new Object[nArray + nElems];
1070         System.arraycopy(elems, 0, newArray, 0, nElems);
1071         System.arraycopy(array, 0, newArray, nElems, nArray);
1072         return newArray;
1073     }
1074 
1075     static MethodHandle throwException(MethodType type) {
1076         assert(Throwable.class.isAssignableFrom(type.parameterType(0)));
1077         int arity = type.parameterCount();
1078         if (arity &gt; 1) {
1079             MethodHandle mh = throwException(type.dropParameterTypes(1, arity));
1080             mh = MethodHandles.dropArguments(mh, 1, Arrays.copyOfRange(type.parameterArray(), 1, arity));
1081             return mh;
1082         }
1083         return makePairwiseConvert(getFunction(NF_throwException).resolvedHandle(), type, false, true);
1084     }
1085 
1086     static &lt;T extends Throwable&gt; Empty throwException(T t) throws T { throw t; }
1087 
1088     static MethodHandle[] FAKE_METHOD_HANDLE_INVOKE = new MethodHandle[2];
1089     static MethodHandle fakeMethodHandleInvoke(MemberName method) {
1090         int idx;
1091         assert(method.isMethodHandleInvoke());
1092         switch (method.getName()) {
1093         case &quot;invoke&quot;:       idx = 0; break;
1094         case &quot;invokeExact&quot;:  idx = 1; break;
1095         default:             throw new InternalError(method.getName());
1096         }
1097         MethodHandle mh = FAKE_METHOD_HANDLE_INVOKE[idx];
1098         if (mh != null)  return mh;
1099         MethodType type = MethodType.methodType(Object.class, UnsupportedOperationException.class,
1100                                                 MethodHandle.class, Object[].class);
1101         mh = throwException(type);
1102         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke MethodHandle&quot;));
1103         if (!method.getInvocationType().equals(mh.type()))
1104             throw new InternalError(method.toString());
1105         mh = mh.withInternalMemberName(method, false);
1106         mh = mh.withVarargs(true);
1107         assert(method.isVarargs());
1108         FAKE_METHOD_HANDLE_INVOKE[idx] = mh;
1109         return mh;
1110     }
1111     static MethodHandle fakeVarHandleInvoke(MemberName method) {
1112         // TODO caching, is it necessary?
1113         MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,
1114                                                 VarHandle.class, Object[].class);
1115         MethodHandle mh = throwException(type);
1116         mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke VarHandle&quot;));
1117         if (!method.getInvocationType().equals(mh.type()))
1118             throw new InternalError(method.toString());
1119         mh = mh.withInternalMemberName(method, false);
1120         mh = mh.asVarargsCollector(Object[].class);
1121         assert(method.isVarargs());
1122         return mh;
1123     }
1124 
1125     /**
1126      * Create an alias for the method handle which, when called,
1127      * appears to be called from the same class loader and protection domain
1128      * as hostClass.
1129      * This is an expensive no-op unless the method which is called
1130      * is sensitive to its caller.  A small number of system methods
1131      * are in this category, including Class.forName and Method.invoke.
1132      */
1133     static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
1134         return BindCaller.bindCaller(mh, hostClass);
1135     }
1136 
1137     // Put the whole mess into its own nested class.
1138     // That way we can lazily load the code and set up the constants.
1139     private static class BindCaller {
1140         private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
1141 
1142         static MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
1143             // Code in the boot layer should now be careful while creating method handles or
1144             // functional interface instances created from method references to @CallerSensitive  methods,
1145             // it needs to be ensured the handles or interface instances are kept safe and are not passed
1146             // from the boot layer to untrusted code.
1147             if (hostClass == null
1148                 ||    (hostClass.isArray() ||
1149                        hostClass.isPrimitive() ||
1150                        hostClass.getName().startsWith(&quot;java.lang.invoke.&quot;))) {
1151                 throw new InternalError();  // does not happen, and should not anyway
1152             }
1153             // For simplicity, convert mh to a varargs-like method.
1154             MethodHandle vamh = prepareForInvoker(mh);
1155             // Cache the result of makeInjectedInvoker once per argument class.
1156             MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);
1157             return restoreToType(bccInvoker.bindTo(vamh), mh, hostClass);
1158         }
1159 
1160         private static MethodHandle makeInjectedInvoker(Class&lt;?&gt; targetClass) {
1161             try {
1162                 /*
1163                  * The invoker class defined to the same class loader as the lookup class
1164                  * but in an unnamed package so that the class bytes can be cached and
1165                  * reused for any @CSM.
1166                  *
1167                  * @CSM must be public and exported if called by any module.
1168                  */
1169                 String name = targetClass.getName() + &quot;$$InjectedInvoker&quot;;
1170                 if (targetClass.isHidden()) {
1171                     // use the original class name
1172                     name = name.replace(&#39;/&#39;, &#39;_&#39;);
1173                 }
1174                 Class&lt;?&gt; invokerClass = new Lookup(targetClass)
1175                         .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE)
1176                         .defineClass(true);
1177                 assert checkInjectedInvoker(targetClass, invokerClass);
1178                 return IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);
1179             } catch (ReflectiveOperationException ex) {
1180                 throw uncaughtException(ex);
1181             }
1182         }
1183 
1184         private static ClassValue&lt;MethodHandle&gt; CV_makeInjectedInvoker = new ClassValue&lt;MethodHandle&gt;() {
1185             @Override protected MethodHandle computeValue(Class&lt;?&gt; hostClass) {
1186                 return makeInjectedInvoker(hostClass);
1187             }
1188         };
1189 
1190         // Adapt mh so that it can be called directly from an injected invoker:
1191         private static MethodHandle prepareForInvoker(MethodHandle mh) {
1192             mh = mh.asFixedArity();
1193             MethodType mt = mh.type();
1194             int arity = mt.parameterCount();
1195             MethodHandle vamh = mh.asType(mt.generic());
1196             vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames
1197             vamh = vamh.asSpreader(Object[].class, arity);
1198             vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames
1199             return vamh;
1200         }
1201 
1202         // Undo the adapter effect of prepareForInvoker:
1203         private static MethodHandle restoreToType(MethodHandle vamh,
1204                                                   MethodHandle original,
1205                                                   Class&lt;?&gt; hostClass) {
1206             MethodType type = original.type();
1207             MethodHandle mh = vamh.asCollector(Object[].class, type.parameterCount());
1208             MemberName member = original.internalMemberName();
1209             mh = mh.asType(type);
1210             mh = new WrappedMember(mh, type, member, original.isInvokeSpecial(), hostClass);
1211             return mh;
1212         }
1213 
1214         private static boolean checkInjectedInvoker(Class&lt;?&gt; hostClass, Class&lt;?&gt; invokerClass) {
1215             assert (hostClass.getClassLoader() == invokerClass.getClassLoader()) : hostClass.getName()+&quot; (CL)&quot;;
1216             try {
1217                 assert (hostClass.getProtectionDomain() == invokerClass.getProtectionDomain()) : hostClass.getName()+&quot; (PD)&quot;;
1218             } catch (SecurityException ex) {
1219                 // Self-check was blocked by security manager. This is OK.
1220             }
1221             try {
1222                 // Test the invoker to ensure that it really injects into the right place.
1223                 MethodHandle invoker = IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);
1224                 MethodHandle vamh = prepareForInvoker(MH_checkCallerClass);
1225                 return (boolean)invoker.invoke(vamh, new Object[]{ invokerClass });
1226             } catch (Throwable ex) {
1227                 throw new InternalError(ex);
1228             }
1229         }
1230 
1231         private static final MethodHandle MH_checkCallerClass;
1232         static {
1233             final Class&lt;?&gt; THIS_CLASS = BindCaller.class;
1234             assert(checkCallerClass(THIS_CLASS));
1235             try {
1236                 MH_checkCallerClass = IMPL_LOOKUP
1237                     .findStatic(THIS_CLASS, &quot;checkCallerClass&quot;,
1238                                 MethodType.methodType(boolean.class, Class.class));
1239                 assert((boolean) MH_checkCallerClass.invokeExact(THIS_CLASS));
1240             } catch (Throwable ex) {
1241                 throw new InternalError(ex);
1242             }
1243         }
1244 
1245         @CallerSensitive
1246         @ForceInline // to ensure Reflection.getCallerClass optimization
1247         private static boolean checkCallerClass(Class&lt;?&gt; expected) {
1248             // This method is called via MH_checkCallerClass and so it&#39;s correct to ask for the immediate caller here.
1249             Class&lt;?&gt; actual = Reflection.getCallerClass();
1250             if (actual != expected)
1251                 throw new InternalError(&quot;found &quot; + actual.getName() + &quot;, expected &quot; + expected.getName());
1252             return true;
1253         }
1254 
1255         private static final byte[] INJECTED_INVOKER_TEMPLATE = generateInvokerTemplate();
1256 
1257         /** Produces byte code for a class that is used as an injected invoker. */
1258         private static byte[] generateInvokerTemplate() {
1259             ClassWriter cw = new ClassWriter(0);
1260 
1261             // private static class InjectedInvoker {
1262             //     @Hidden
1263             //     static Object invoke_V(MethodHandle vamh, Object[] args) throws Throwable {
1264             //        return vamh.invokeExact(args);
1265             //     }
1266             // }
1267             cw.visit(52, ACC_PRIVATE | ACC_SUPER, &quot;InjectedInvoker&quot;, null, &quot;java/lang/Object&quot;, null);
1268 
1269             MethodVisitor mv = cw.visitMethod(ACC_STATIC, &quot;invoke_V&quot;,
1270                           &quot;(Ljava/lang/invoke/MethodHandle;[Ljava/lang/Object;)Ljava/lang/Object;&quot;,
1271                           null, null);
1272 
1273             mv.visitCode();
1274             mv.visitVarInsn(ALOAD, 0);
1275             mv.visitVarInsn(ALOAD, 1);
1276             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandle&quot;, &quot;invokeExact&quot;,
1277                                &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
1278             mv.visitInsn(ARETURN);
1279             mv.visitMaxs(2, 2);
1280             mv.visitEnd();
1281 
1282             cw.visitEnd();
1283             return cw.toByteArray();
1284         }
1285     }
1286 
1287     /** This subclass allows a wrapped method handle to be re-associated with an arbitrary member name. */
1288     private static final class WrappedMember extends DelegatingMethodHandle {
1289         private final MethodHandle target;
1290         private final MemberName member;
1291         private final Class&lt;?&gt; callerClass;
1292         private final boolean isInvokeSpecial;
1293 
1294         private WrappedMember(MethodHandle target, MethodType type,
1295                               MemberName member, boolean isInvokeSpecial,
1296                               Class&lt;?&gt; callerClass) {
1297             super(type, target);
1298             this.target = target;
1299             this.member = member;
1300             this.callerClass = callerClass;
1301             this.isInvokeSpecial = isInvokeSpecial;
1302         }
1303 
1304         @Override
1305         MemberName internalMemberName() {
1306             return member;
1307         }
1308         @Override
1309         Class&lt;?&gt; internalCallerClass() {
1310             return callerClass;
1311         }
1312         @Override
1313         boolean isInvokeSpecial() {
1314             return isInvokeSpecial;
1315         }
1316         @Override
1317         protected MethodHandle getTarget() {
1318             return target;
1319         }
1320         @Override
1321         public MethodHandle asTypeUncached(MethodType newType) {
1322             // This MH is an alias for target, except for the MemberName
1323             // Drop the MemberName if there is any conversion.
1324             return asTypeCache = target.asType(newType);
1325         }
1326     }
1327 
1328     static MethodHandle makeWrappedMember(MethodHandle target, MemberName member, boolean isInvokeSpecial) {
1329         if (member.equals(target.internalMemberName()) &amp;&amp; isInvokeSpecial == target.isInvokeSpecial())
1330             return target;
1331         return new WrappedMember(target, target.type(), member, isInvokeSpecial, null);
1332     }
1333 
1334     /** Intrinsic IDs */
1335     /*non-public*/
1336     enum Intrinsic {
1337         SELECT_ALTERNATIVE,
1338         GUARD_WITH_CATCH,
1339         TRY_FINALLY,
1340         LOOP,
1341         NEW_ARRAY,
1342         ARRAY_LOAD,
1343         ARRAY_STORE,
1344         ARRAY_LENGTH,
1345         IDENTITY,
1346         ZERO,
1347         NONE // no intrinsic associated
1348     }
1349 
1350     /** Mark arbitrary method handle as intrinsic.
1351      * InvokerBytecodeGenerator uses this info to produce more efficient bytecode shape. */
1352     static final class IntrinsicMethodHandle extends DelegatingMethodHandle {
1353         private final MethodHandle target;
1354         private final Intrinsic intrinsicName;
1355 
1356         IntrinsicMethodHandle(MethodHandle target, Intrinsic intrinsicName) {
1357             super(target.type(), target);
1358             this.target = target;
1359             this.intrinsicName = intrinsicName;
1360         }
1361 
1362         @Override
1363         protected MethodHandle getTarget() {
1364             return target;
1365         }
1366 
1367         @Override
1368         Intrinsic intrinsicName() {
1369             return intrinsicName;
1370         }
1371 
1372         @Override
1373         public MethodHandle asTypeUncached(MethodType newType) {
1374             // This MH is an alias for target, except for the intrinsic name
1375             // Drop the name if there is any conversion.
1376             return asTypeCache = target.asType(newType);
1377         }
1378 
1379         @Override
1380         String internalProperties() {
1381             return super.internalProperties() +
1382                     &quot;\n&amp; Intrinsic=&quot;+intrinsicName;
1383         }
1384 
1385         @Override
1386         public MethodHandle asCollector(Class&lt;?&gt; arrayType, int arrayLength) {
1387             if (intrinsicName == Intrinsic.IDENTITY) {
1388                 MethodType resultType = type().asCollectorType(arrayType, type().parameterCount() - 1, arrayLength);
1389                 MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);
1390                 return newArray.asType(resultType);
1391             }
1392             return super.asCollector(arrayType, arrayLength);
1393         }
1394     }
1395 
1396     static MethodHandle makeIntrinsic(MethodHandle target, Intrinsic intrinsicName) {
1397         if (intrinsicName == target.intrinsicName())
1398             return target;
1399         return new IntrinsicMethodHandle(target, intrinsicName);
1400     }
1401 
1402     static MethodHandle makeIntrinsic(MethodType type, LambdaForm form, Intrinsic intrinsicName) {
1403         return new IntrinsicMethodHandle(SimpleMethodHandle.make(type, form), intrinsicName);
1404     }
1405 
1406     /// Collection of multiple arguments.
1407 
1408     private static MethodHandle findCollector(String name, int nargs, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1409         MethodType type = MethodType.genericMethodType(nargs)
1410                 .changeReturnType(rtype)
1411                 .insertParameterTypes(0, ptypes);
1412         try {
1413             return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, name, type);
1414         } catch (ReflectiveOperationException ex) {
1415             return null;
1416         }
1417     }
1418 
1419     private static final Object[] NO_ARGS_ARRAY = {};
1420     private static Object[] makeArray(Object... args) { return args; }
1421     private static Object[] array() { return NO_ARGS_ARRAY; }
1422     private static Object[] array(Object a0)
1423                 { return makeArray(a0); }
1424     private static Object[] array(Object a0, Object a1)
1425                 { return makeArray(a0, a1); }
1426     private static Object[] array(Object a0, Object a1, Object a2)
1427                 { return makeArray(a0, a1, a2); }
1428     private static Object[] array(Object a0, Object a1, Object a2, Object a3)
1429                 { return makeArray(a0, a1, a2, a3); }
1430     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1431                                   Object a4)
1432                 { return makeArray(a0, a1, a2, a3, a4); }
1433     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1434                                   Object a4, Object a5)
1435                 { return makeArray(a0, a1, a2, a3, a4, a5); }
1436     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1437                                   Object a4, Object a5, Object a6)
1438                 { return makeArray(a0, a1, a2, a3, a4, a5, a6); }
1439     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1440                                   Object a4, Object a5, Object a6, Object a7)
1441                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7); }
1442     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1443                                   Object a4, Object a5, Object a6, Object a7,
1444                                   Object a8)
1445                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8); }
1446     private static Object[] array(Object a0, Object a1, Object a2, Object a3,
1447                                   Object a4, Object a5, Object a6, Object a7,
1448                                   Object a8, Object a9)
1449                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
1450 
1451     private static final int ARRAYS_COUNT = 11;
1452     private static final @Stable MethodHandle[] ARRAYS = new MethodHandle[MAX_ARITY + 1];
1453 
1454     // filling versions of the above:
1455     // using Integer len instead of int len and no varargs to avoid bootstrapping problems
1456     private static Object[] fillNewArray(Integer len, Object[] /*not ...*/ args) {
1457         Object[] a = new Object[len];
1458         fillWithArguments(a, 0, args);
1459         return a;
1460     }
1461     private static Object[] fillNewTypedArray(Object[] example, Integer len, Object[] /*not ...*/ args) {
1462         Object[] a = Arrays.copyOf(example, len);
1463         assert(a.getClass() != Object[].class);
1464         fillWithArguments(a, 0, args);
1465         return a;
1466     }
1467     private static void fillWithArguments(Object[] a, int pos, Object... args) {
1468         System.arraycopy(args, 0, a, pos, args.length);
1469     }
1470     // using Integer pos instead of int pos to avoid bootstrapping problems
1471     private static Object[] fillArray(Integer pos, Object[] a, Object a0)
1472                 { fillWithArguments(a, pos, a0); return a; }
1473     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1)
1474                 { fillWithArguments(a, pos, a0, a1); return a; }
1475     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2)
1476                 { fillWithArguments(a, pos, a0, a1, a2); return a; }
1477     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3)
1478                 { fillWithArguments(a, pos, a0, a1, a2, a3); return a; }
1479     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1480                                   Object a4)
1481                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4); return a; }
1482     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1483                                   Object a4, Object a5)
1484                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5); return a; }
1485     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1486                                   Object a4, Object a5, Object a6)
1487                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6); return a; }
1488     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1489                                   Object a4, Object a5, Object a6, Object a7)
1490                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7); return a; }
1491     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1492                                   Object a4, Object a5, Object a6, Object a7,
1493                                   Object a8)
1494                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8); return a; }
1495     private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
1496                                   Object a4, Object a5, Object a6, Object a7,
1497                                   Object a8, Object a9)
1498                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }
1499 
1500     private static final int FILL_ARRAYS_COUNT = 11; // current number of fillArray methods
1501     private static final @Stable MethodHandle[] FILL_ARRAYS = new MethodHandle[FILL_ARRAYS_COUNT];
1502 
1503     private static MethodHandle getFillArray(int count) {
1504         assert (count &gt; 0 &amp;&amp; count &lt; FILL_ARRAYS_COUNT);
1505         MethodHandle mh = FILL_ARRAYS[count];
1506         if (mh != null) {
1507             return mh;
1508         }
1509         mh = findCollector(&quot;fillArray&quot;, count, Object[].class, Integer.class, Object[].class);
1510         FILL_ARRAYS[count] = mh;
1511         return mh;
1512     }
1513 
1514     private static Object copyAsPrimitiveArray(Wrapper w, Object... boxes) {
1515         Object a = w.makeArray(boxes.length);
1516         w.copyArrayUnboxing(boxes, 0, a, 0, boxes.length);
1517         return a;
1518     }
1519 
1520     /** Return a method handle that takes the indicated number of Object
1521      *  arguments and returns an Object array of them, as if for varargs.
1522      */
1523     static MethodHandle varargsArray(int nargs) {
1524         MethodHandle mh = ARRAYS[nargs];
1525         if (mh != null) {
1526             return mh;
1527         }
1528         if (nargs &lt; ARRAYS_COUNT) {
1529             mh = findCollector(&quot;array&quot;, nargs, Object[].class);
1530         } else {
1531             mh = buildVarargsArray(getConstantHandle(MH_fillNewArray),
1532                     getConstantHandle(MH_arrayIdentity), nargs);
1533         }
1534         assert(assertCorrectArity(mh, nargs));
1535         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1536         return ARRAYS[nargs] = mh;
1537     }
1538 
1539     private static boolean assertCorrectArity(MethodHandle mh, int arity) {
1540         assert(mh.type().parameterCount() == arity) : &quot;arity != &quot;+arity+&quot;: &quot;+mh;
1541         return true;
1542     }
1543 
1544     // Array identity function (used as getConstantHandle(MH_arrayIdentity)).
1545     static &lt;T&gt; T[] identity(T[] x) {
1546         return x;
1547     }
1548 
1549     private static MethodHandle buildVarargsArray(MethodHandle newArray, MethodHandle finisher, int nargs) {
1550         // Build up the result mh as a sequence of fills like this:
1551         //   finisher(fill(fill(newArrayWA(23,x1..x10),10,x11..x20),20,x21..x23))
1552         // The various fill(_,10*I,___*[J]) are reusable.
1553         int leftLen = Math.min(nargs, LEFT_ARGS);  // absorb some arguments immediately
1554         int rightLen = nargs - leftLen;
1555         MethodHandle leftCollector = newArray.bindTo(nargs);
1556         leftCollector = leftCollector.asCollector(Object[].class, leftLen);
1557         MethodHandle mh = finisher;
1558         if (rightLen &gt; 0) {
1559             MethodHandle rightFiller = fillToRight(LEFT_ARGS + rightLen);
1560             if (mh.equals(getConstantHandle(MH_arrayIdentity)))
1561                 mh = rightFiller;
1562             else
1563                 mh = MethodHandles.collectArguments(mh, 0, rightFiller);
1564         }
1565         if (mh.equals(getConstantHandle(MH_arrayIdentity)))
1566             mh = leftCollector;
1567         else
1568             mh = MethodHandles.collectArguments(mh, 0, leftCollector);
1569         return mh;
1570     }
1571 
1572     private static final int LEFT_ARGS = FILL_ARRAYS_COUNT - 1;
1573     private static final @Stable MethodHandle[] FILL_ARRAY_TO_RIGHT = new MethodHandle[MAX_ARITY + 1];
1574     /** fill_array_to_right(N).invoke(a, argL..arg[N-1])
1575      *  fills a[L]..a[N-1] with corresponding arguments,
1576      *  and then returns a.  The value L is a global constant (LEFT_ARGS).
1577      */
1578     private static MethodHandle fillToRight(int nargs) {
1579         MethodHandle filler = FILL_ARRAY_TO_RIGHT[nargs];
1580         if (filler != null)  return filler;
1581         filler = buildFiller(nargs);
1582         assert(assertCorrectArity(filler, nargs - LEFT_ARGS + 1));
1583         return FILL_ARRAY_TO_RIGHT[nargs] = filler;
1584     }
1585     private static MethodHandle buildFiller(int nargs) {
1586         if (nargs &lt;= LEFT_ARGS)
1587             return getConstantHandle(MH_arrayIdentity);  // no args to fill; return the array unchanged
1588         // we need room for both mh and a in mh.invoke(a, arg*[nargs])
1589         final int CHUNK = LEFT_ARGS;
1590         int rightLen = nargs % CHUNK;
1591         int midLen = nargs - rightLen;
1592         if (rightLen == 0) {
1593             midLen = nargs - (rightLen = CHUNK);
1594             if (FILL_ARRAY_TO_RIGHT[midLen] == null) {
1595                 // build some precursors from left to right
1596                 for (int j = LEFT_ARGS % CHUNK; j &lt; midLen; j += CHUNK)
1597                     if (j &gt; LEFT_ARGS)  fillToRight(j);
1598             }
1599         }
1600         if (midLen &lt; LEFT_ARGS) rightLen = nargs - (midLen = LEFT_ARGS);
1601         assert(rightLen &gt; 0);
1602         MethodHandle midFill = fillToRight(midLen);  // recursive fill
1603         MethodHandle rightFill = getFillArray(rightLen).bindTo(midLen);  // [midLen..nargs-1]
1604         assert(midFill.type().parameterCount()   == 1 + midLen - LEFT_ARGS);
1605         assert(rightFill.type().parameterCount() == 1 + rightLen);
1606 
1607         // Combine the two fills:
1608         //   right(mid(a, x10..x19), x20..x23)
1609         // The final product will look like this:
1610         //   right(mid(newArrayLeft(24, x0..x9), x10..x19), x20..x23)
1611         if (midLen == LEFT_ARGS)
1612             return rightFill;
1613         else
1614             return MethodHandles.collectArguments(rightFill, 0, midFill);
1615     }
1616 
1617     static final int MAX_JVM_ARITY = 255;  // limit imposed by the JVM
1618 
1619     /** Return a method handle that takes the indicated number of
1620      *  typed arguments and returns an array of them.
1621      *  The type argument is the array type.
1622      */
1623     static MethodHandle varargsArray(Class&lt;?&gt; arrayType, int nargs) {
1624         Class&lt;?&gt; elemType = arrayType.getComponentType();
1625         if (elemType == null)  throw new IllegalArgumentException(&quot;not an array: &quot;+arrayType);
1626         // FIXME: Need more special casing and caching here.
1627         if (nargs &gt;= MAX_JVM_ARITY/2 - 1) {
1628             int slots = nargs;
1629             final int MAX_ARRAY_SLOTS = MAX_JVM_ARITY - 1;  // 1 for receiver MH
1630             if (slots &lt;= MAX_ARRAY_SLOTS &amp;&amp; elemType.isPrimitive())
1631                 slots *= Wrapper.forPrimitiveType(elemType).stackSlots();
1632             if (slots &gt; MAX_ARRAY_SLOTS)
1633                 throw new IllegalArgumentException(&quot;too many arguments: &quot;+arrayType.getSimpleName()+&quot;, length &quot;+nargs);
1634         }
1635         if (elemType == Object.class)
1636             return varargsArray(nargs);
1637         // other cases:  primitive arrays, subtypes of Object[]
1638         MethodHandle cache[] = Makers.TYPED_COLLECTORS.get(elemType);
1639         MethodHandle mh = nargs &lt; cache.length ? cache[nargs] : null;
1640         if (mh != null)  return mh;
1641         if (nargs == 0) {
1642             Object example = java.lang.reflect.Array.newInstance(arrayType.getComponentType(), 0);
1643             mh = MethodHandles.constant(arrayType, example);
1644         } else if (elemType.isPrimitive()) {
1645             MethodHandle builder = getConstantHandle(MH_fillNewArray);
1646             MethodHandle producer = buildArrayProducer(arrayType);
1647             mh = buildVarargsArray(builder, producer, nargs);
1648         } else {
1649             Class&lt;? extends Object[]&gt; objArrayType = arrayType.asSubclass(Object[].class);
1650             Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);
1651             MethodHandle builder = getConstantHandle(MH_fillNewTypedArray).bindTo(example);
1652             MethodHandle producer = getConstantHandle(MH_arrayIdentity); // must be weakly typed
1653             mh = buildVarargsArray(builder, producer, nargs);
1654         }
1655         mh = mh.asType(MethodType.methodType(arrayType, Collections.&lt;Class&lt;?&gt;&gt;nCopies(nargs, elemType)));
1656         mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
1657         assert(assertCorrectArity(mh, nargs));
1658         if (nargs &lt; cache.length)
1659             cache[nargs] = mh;
1660         return mh;
1661     }
1662 
1663     private static MethodHandle buildArrayProducer(Class&lt;?&gt; arrayType) {
1664         Class&lt;?&gt; elemType = arrayType.getComponentType();
1665         assert(elemType.isPrimitive());
1666         return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));
1667     }
1668 
1669     /*non-public*/
1670     static void assertSame(Object mh1, Object mh2) {
1671         if (mh1 != mh2) {
1672             String msg = String.format(&quot;mh1 != mh2: mh1 = %s (form: %s); mh2 = %s (form: %s)&quot;,
1673                     mh1, ((MethodHandle)mh1).form,
1674                     mh2, ((MethodHandle)mh2).form);
1675             throw newInternalError(msg);
1676         }
1677     }
1678 
1679     // Local constant functions:
1680 
1681     /* non-public */
1682     static final byte NF_checkSpreadArgument = 0,
1683             NF_guardWithCatch = 1,
1684             NF_throwException = 2,
1685             NF_tryFinally = 3,
1686             NF_loop = 4,
1687             NF_profileBoolean = 5,
1688             NF_LIMIT = 6;
1689 
1690     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
1691 
1692     static NamedFunction getFunction(byte func) {
1693         NamedFunction nf = NFS[func];
1694         if (nf != null) {
1695             return nf;
1696         }
1697         return NFS[func] = createFunction(func);
1698     }
1699 
1700     private static NamedFunction createFunction(byte func) {
1701         try {
1702             switch (func) {
1703                 case NF_checkSpreadArgument:
1704                     return new NamedFunction(MethodHandleImpl.class
1705                             .getDeclaredMethod(&quot;checkSpreadArgument&quot;, Object.class, int.class));
1706                 case NF_guardWithCatch:
1707                     return new NamedFunction(MethodHandleImpl.class
1708                             .getDeclaredMethod(&quot;guardWithCatch&quot;, MethodHandle.class, Class.class,
1709                                     MethodHandle.class, Object[].class));
1710                 case NF_tryFinally:
1711                     return new NamedFunction(MethodHandleImpl.class
1712                             .getDeclaredMethod(&quot;tryFinally&quot;, MethodHandle.class, MethodHandle.class, Object[].class));
1713                 case NF_loop:
1714                     return new NamedFunction(MethodHandleImpl.class
1715                             .getDeclaredMethod(&quot;loop&quot;, BasicType[].class, LoopClauses.class, Object[].class));
1716                 case NF_throwException:
1717                     return new NamedFunction(MethodHandleImpl.class
1718                             .getDeclaredMethod(&quot;throwException&quot;, Throwable.class));
1719                 case NF_profileBoolean:
1720                     return new NamedFunction(MethodHandleImpl.class
1721                             .getDeclaredMethod(&quot;profileBoolean&quot;, boolean.class, int[].class));
1722                 default:
1723                     throw new InternalError(&quot;Undefined function: &quot; + func);
1724             }
1725         } catch (ReflectiveOperationException ex) {
1726             throw newInternalError(ex);
1727         }
1728     }
1729 
1730     static {
1731         SharedSecrets.setJavaLangInvokeAccess(new JavaLangInvokeAccess() {
1732             @Override
1733             public Object newMemberName() {
1734                 return new MemberName();
1735             }
1736 
1737             @Override
1738             public String getName(Object mname) {
1739                 MemberName memberName = (MemberName)mname;
1740                 return memberName.getName();
1741             }
1742             @Override
1743             public Class&lt;?&gt; getDeclaringClass(Object mname) {
1744                 MemberName memberName = (MemberName)mname;
1745                 return memberName.getDeclaringClass();
1746             }
1747 
1748             @Override
1749             public MethodType getMethodType(Object mname) {
1750                 MemberName memberName = (MemberName)mname;
1751                 return memberName.getMethodType();
1752             }
1753 
1754             @Override
1755             public String getMethodDescriptor(Object mname) {
1756                 MemberName memberName = (MemberName)mname;
1757                 return memberName.getMethodDescriptor();
1758             }
1759 
1760             @Override
1761             public boolean isNative(Object mname) {
1762                 MemberName memberName = (MemberName)mname;
1763                 return memberName.isNative();
1764             }
1765 
1766             @Override
1767             public byte[] generateDirectMethodHandleHolderClassBytes(
1768                     String className, MethodType[] methodTypes, int[] types) {
1769                 return GenerateJLIClassesHelper
1770                         .generateDirectMethodHandleHolderClassBytes(
1771                                 className, methodTypes, types);
1772             }
1773 
1774             @Override
1775             public byte[] generateDelegatingMethodHandleHolderClassBytes(
1776                     String className, MethodType[] methodTypes) {
1777                 return GenerateJLIClassesHelper
1778                         .generateDelegatingMethodHandleHolderClassBytes(
1779                                 className, methodTypes);
1780             }
1781 
1782             @Override
1783             public Map.Entry&lt;String, byte[]&gt; generateConcreteBMHClassBytes(
1784                     final String types) {
1785                 return GenerateJLIClassesHelper
1786                         .generateConcreteBMHClassBytes(types);
1787             }
1788 
1789             @Override
1790             public byte[] generateBasicFormsClassBytes(final String className) {
1791                 return GenerateJLIClassesHelper
1792                         .generateBasicFormsClassBytes(className);
1793             }
1794 
1795             @Override
1796             public byte[] generateInvokersHolderClassBytes(final String className,
1797                     MethodType[] invokerMethodTypes,
1798                     MethodType[] callSiteMethodTypes) {
1799                 return GenerateJLIClassesHelper
1800                         .generateInvokersHolderClassBytes(className,
1801                                 invokerMethodTypes, callSiteMethodTypes);
1802             }
1803 
1804             @Override
1805             public VarHandle memoryAccessVarHandle(Class&lt;?&gt; carrier, long alignmentMask,
1806                                                    ByteOrder order, long offset, long[] strides) {
1807                 return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);
1808             }
1809 
1810             @Override
1811             public Class&lt;?&gt; memoryAddressCarrier(VarHandle handle) {
1812                 return checkMemoryAccessHandle(handle).carrier();
1813             }
1814 
1815             @Override
1816             public long memoryAddressAlignmentMask(VarHandle handle) {
1817                 return checkMemoryAccessHandle(handle).alignmentMask;
1818             }
1819 
1820             @Override
1821             public ByteOrder memoryAddressByteOrder(VarHandle handle) {
1822                 return checkMemoryAccessHandle(handle).be ?
1823                         ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
1824             }
1825 
1826             @Override
1827             public long memoryAddressOffset(VarHandle handle) {
1828                 return checkMemoryAccessHandle(handle).offset;
1829             }
1830 
1831             @Override
1832             public long[] memoryAddressStrides(VarHandle handle) {
1833                 return checkMemoryAccessHandle(handle).strides();
1834             }
1835 
1836             @Override
1837             public boolean isMemoryAccessVarHandle(VarHandle handle) {
1838                 return asMemoryAccessVarHandle(handle) != null;
1839             }
1840 
1841             @Override
1842             public VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {
1843                 return VarHandles.filterValue(target, filterToTarget, filterFromTarget);
1844             }
1845 
1846             @Override
1847             public VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
1848                 return VarHandles.filterCoordinates(target, pos, filters);
1849             }
1850 
1851             @Override
1852             public VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes) {
1853                 return VarHandles.dropCoordinates(target, pos, valueTypes);
1854             }
1855 
1856             @Override
1857             public VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {
1858                 return VarHandles.permuteCoordinates(target, newCoordinates, reorder);
1859             }
1860 
1861             @Override
1862             public VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {
1863                 return VarHandles.collectCoordinates(target, pos, filter);
1864             }
1865 
1866             @Override
1867             public VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
1868                 return VarHandles.insertCoordinates(target, pos, values);
1869             }
1870 
1871             private MemoryAccessVarHandleBase asMemoryAccessVarHandle(VarHandle handle) {
1872                 if (handle instanceof MemoryAccessVarHandleBase) {
1873                     return (MemoryAccessVarHandleBase)handle;
1874                 } else if (handle.target() instanceof MemoryAccessVarHandleBase) {
1875                     // skip first adaptation, since we have to step over MemoryAddressProxy
1876                     // see JDK-8237349
1877                     return (MemoryAccessVarHandleBase)handle.target();
1878                 } else {
1879                     return null;
1880                 }
1881             }
1882 
1883             private MemoryAccessVarHandleBase checkMemoryAccessHandle(VarHandle handle) {
1884                 MemoryAccessVarHandleBase base = asMemoryAccessVarHandle(handle);
1885                 if (base == null) {
1886                     throw new IllegalArgumentException(&quot;Not a memory access varhandle: &quot; + handle);
1887                 }
1888                 return base;
1889             }
<a name="1" id="anc1"></a>




1890         });
1891     }
1892 
1893     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
1894     private static MethodHandle unboxResultHandle(Class&lt;?&gt; returnType) {
1895         if (returnType.isPrimitive()) {
1896             if (returnType == void.class) {
1897                 return ValueConversions.ignore();
1898             } else {
1899                 Wrapper w = Wrapper.forPrimitiveType(returnType);
1900                 return ValueConversions.unboxExact(w);
1901             }
1902         } else {
1903             return MethodHandles.identity(Object.class);
1904         }
1905     }
1906 
1907     /**
1908      * Assembles a loop method handle from the given handles and type information.
1909      *
1910      * @param tloop the return type of the loop.
1911      * @param targs types of the arguments to be passed to the loop.
1912      * @param init sanitized array of initializers for loop-local variables.
1913      * @param step sanitited array of loop bodies.
1914      * @param pred sanitized array of predicates.
1915      * @param fini sanitized array of loop finalizers.
1916      *
1917      * @return a handle that, when invoked, will execute the loop.
1918      */
1919     static MethodHandle makeLoop(Class&lt;?&gt; tloop, List&lt;Class&lt;?&gt;&gt; targs, List&lt;MethodHandle&gt; init, List&lt;MethodHandle&gt; step,
1920                                  List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini) {
1921         MethodType type = MethodType.methodType(tloop, targs);
1922         BasicType[] initClauseTypes =
1923                 init.stream().map(h -&gt; h.type().returnType()).map(BasicType::basicType).toArray(BasicType[]::new);
1924         LambdaForm form = makeLoopForm(type.basicType(), initClauseTypes);
1925 
1926         // Prepare auxiliary method handles used during LambdaForm interpretation.
1927         // Box arguments and wrap them into Object[]: ValueConversions.array().
1928         MethodType varargsType = type.changeReturnType(Object[].class);
1929         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
1930         MethodHandle unboxResult = unboxResultHandle(tloop);
1931 
1932         LoopClauses clauseData =
1933                 new LoopClauses(new MethodHandle[][]{toArray(init), toArray(step), toArray(pred), toArray(fini)});
1934         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
1935         BoundMethodHandle mh;
1936         try {
1937             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) clauseData,
1938                     (Object) collectArgs, (Object) unboxResult);
1939         } catch (Throwable ex) {
1940             throw uncaughtException(ex);
1941         }
1942         assert(mh.type() == type);
1943         return mh;
1944     }
1945 
1946     private static MethodHandle[] toArray(List&lt;MethodHandle&gt; l) {
1947         return l.toArray(new MethodHandle[0]);
1948     }
1949 
1950     /**
1951      * Loops introduce some complexity as they can have additional local state. Hence, LambdaForms for loops are
1952      * generated from a template. The LambdaForm template shape for the loop combinator is as follows (assuming one
1953      * reference parameter passed in {@code a1}, and a reference return type, with the return value represented by
1954      * {@code t12}):
1955      * &lt;blockquote&gt;&lt;pre&gt;{@code
1956      *  loop=Lambda(a0:L,a1:L)=&gt;{
1957      *    t2:L=BoundMethodHandle$Species_L3.argL0(a0:L);    // LoopClauses holding init, step, pred, fini handles
1958      *    t3:L=BoundMethodHandle$Species_L3.argL1(a0:L);    // helper handle to box the arguments into an Object[]
1959      *    t4:L=BoundMethodHandle$Species_L3.argL2(a0:L);    // helper handle to unbox the result
1960      *    t5:L=MethodHandle.invokeBasic(t3:L,a1:L);         // box the arguments into an Object[]
1961      *    t6:L=MethodHandleImpl.loop(null,t2:L,t3:L);       // call the loop executor
1962      *    t7:L=MethodHandle.invokeBasic(t4:L,t6:L);t7:L}    // unbox the result; return the result
1963      * }&lt;/pre&gt;&lt;/blockquote&gt;
1964      * &lt;p&gt;
1965      * {@code argL0} is a LoopClauses instance holding, in a 2-dimensional array, the init, step, pred, and fini method
1966      * handles. {@code argL1} and {@code argL2} are auxiliary method handles: {@code argL1} boxes arguments and wraps
1967      * them into {@code Object[]} ({@code ValueConversions.array()}), and {@code argL2} unboxes the result if necessary
1968      * ({@code ValueConversions.unbox()}).
1969      * &lt;p&gt;
1970      * Having {@code t3} and {@code t4} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
1971      * forms among loop combinators with the same basic type.
1972      * &lt;p&gt;
1973      * The above template is instantiated by using the {@link LambdaFormEditor} to replace the {@code null} argument to
1974      * the {@code loop} invocation with the {@code BasicType} array describing the loop clause types. This argument is
1975      * ignored in the loop invoker, but will be extracted and used in {@linkplain InvokerBytecodeGenerator#emitLoop(int)
1976      * bytecode generation}.
1977      */
1978     private static LambdaForm makeLoopForm(MethodType basicType, BasicType[] localVarTypes) {
1979         MethodType lambdaType = basicType.invokerType();
1980 
1981         final int THIS_MH = 0;  // the BMH_LLL
1982         final int ARG_BASE = 1; // start of incoming arguments
1983         final int ARG_LIMIT = ARG_BASE + basicType.parameterCount();
1984 
1985         int nameCursor = ARG_LIMIT;
1986         final int GET_CLAUSE_DATA = nameCursor++;
1987         final int GET_COLLECT_ARGS = nameCursor++;
1988         final int GET_UNBOX_RESULT = nameCursor++;
1989         final int BOXED_ARGS = nameCursor++;
1990         final int LOOP = nameCursor++;
1991         final int UNBOX_RESULT = nameCursor++;
1992 
1993         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_LOOP);
1994         if (lform == null) {
1995             Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
1996 
1997             BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
1998             names[THIS_MH] = names[THIS_MH].withConstraint(data);
1999             names[GET_CLAUSE_DATA] = new Name(data.getterFunction(0), names[THIS_MH]);
2000             names[GET_COLLECT_ARGS] = new Name(data.getterFunction(1), names[THIS_MH]);
2001             names[GET_UNBOX_RESULT] = new Name(data.getterFunction(2), names[THIS_MH]);
2002 
2003             // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
2004             MethodType collectArgsType = basicType.changeReturnType(Object.class);
2005             MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
2006             Object[] args = new Object[invokeBasic.type().parameterCount()];
2007             args[0] = names[GET_COLLECT_ARGS];
2008             System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT - ARG_BASE);
2009             names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.LOOP), args);
2010 
2011             // t_{i+1}:L=MethodHandleImpl.loop(localTypes:L,clauses:L,t_{i}:L);
2012             Object[] lArgs =
2013                     new Object[]{null, // placeholder for BasicType[] localTypes - will be added by LambdaFormEditor
2014                             names[GET_CLAUSE_DATA], names[BOXED_ARGS]};
2015             names[LOOP] = new Name(getFunction(NF_loop), lArgs);
2016 
2017             // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
2018             MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
2019             Object[] unboxArgs = new Object[]{names[GET_UNBOX_RESULT], names[LOOP]};
2020             names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
2021 
2022             lform = basicType.form().setCachedLambdaForm(MethodTypeForm.LF_LOOP,
2023                     new LambdaForm(lambdaType.parameterCount(), names, Kind.LOOP));
2024         }
2025 
2026         // BOXED_ARGS is the index into the names array where the loop idiom starts
2027         return lform.editor().noteLoopLocalTypesForm(BOXED_ARGS, localVarTypes);
2028     }
2029 
2030     static class LoopClauses {
2031         @Stable final MethodHandle[][] clauses;
2032         LoopClauses(MethodHandle[][] clauses) {
2033             assert clauses.length == 4;
2034             this.clauses = clauses;
2035         }
2036         @Override
2037         public String toString() {
2038             StringBuffer sb = new StringBuffer(&quot;LoopClauses -- &quot;);
2039             for (int i = 0; i &lt; 4; ++i) {
2040                 if (i &gt; 0) {
2041                     sb.append(&quot;       &quot;);
2042                 }
2043                 sb.append(&#39;&lt;&#39;).append(i).append(&quot;&gt;: &quot;);
2044                 MethodHandle[] hs = clauses[i];
2045                 for (int j = 0; j &lt; hs.length; ++j) {
2046                     if (j &gt; 0) {
2047                         sb.append(&quot;          &quot;);
2048                     }
2049                     sb.append(&#39;*&#39;).append(j).append(&quot;: &quot;).append(hs[j]).append(&#39;\n&#39;);
2050                 }
2051             }
2052             sb.append(&quot; --\n&quot;);
2053             return sb.toString();
2054         }
2055     }
2056 
2057     /**
2058      * Intrinsified during LambdaForm compilation
2059      * (see {@link InvokerBytecodeGenerator#emitLoop(int)}).
2060      */
2061     @Hidden
2062     static Object loop(BasicType[] localTypes, LoopClauses clauseData, Object... av) throws Throwable {
2063         final MethodHandle[] init = clauseData.clauses[0];
2064         final MethodHandle[] step = clauseData.clauses[1];
2065         final MethodHandle[] pred = clauseData.clauses[2];
2066         final MethodHandle[] fini = clauseData.clauses[3];
2067         int varSize = (int) Stream.of(init).filter(h -&gt; h.type().returnType() != void.class).count();
2068         int nArgs = init[0].type().parameterCount();
2069         Object[] varsAndArgs = new Object[varSize + nArgs];
2070         for (int i = 0, v = 0; i &lt; init.length; ++i) {
2071             MethodHandle ih = init[i];
2072             if (ih.type().returnType() == void.class) {
2073                 ih.invokeWithArguments(av);
2074             } else {
2075                 varsAndArgs[v++] = ih.invokeWithArguments(av);
2076             }
2077         }
2078         System.arraycopy(av, 0, varsAndArgs, varSize, nArgs);
2079         final int nSteps = step.length;
2080         for (; ; ) {
2081             for (int i = 0, v = 0; i &lt; nSteps; ++i) {
2082                 MethodHandle p = pred[i];
2083                 MethodHandle s = step[i];
2084                 MethodHandle f = fini[i];
2085                 if (s.type().returnType() == void.class) {
2086                     s.invokeWithArguments(varsAndArgs);
2087                 } else {
2088                     varsAndArgs[v++] = s.invokeWithArguments(varsAndArgs);
2089                 }
2090                 if (!(boolean) p.invokeWithArguments(varsAndArgs)) {
2091                     return f.invokeWithArguments(varsAndArgs);
2092                 }
2093             }
2094         }
2095     }
2096 
2097     /**
2098      * This method is bound as the predicate in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
2099      * MethodHandle) counting loops}.
2100      *
2101      * @param limit the upper bound of the parameter, statically bound at loop creation time.
2102      * @param counter the counter parameter, passed in during loop execution.
2103      *
2104      * @return whether the counter has reached the limit.
2105      */
2106     static boolean countedLoopPredicate(int limit, int counter) {
2107         return counter &lt; limit;
2108     }
2109 
2110     /**
2111      * This method is bound as the step function in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
2112      * MethodHandle) counting loops} to increment the counter.
2113      *
2114      * @param limit the upper bound of the loop counter (ignored).
2115      * @param counter the loop counter.
2116      *
2117      * @return the loop counter incremented by 1.
2118      */
2119     static int countedLoopStep(int limit, int counter) {
2120         return counter + 1;
2121     }
2122 
2123     /**
2124      * This is bound to initialize the loop-local iterator in {@linkplain MethodHandles#iteratedLoop iterating loops}.
2125      *
2126      * @param it the {@link Iterable} over which the loop iterates.
2127      *
2128      * @return an {@link Iterator} over the argument&#39;s elements.
2129      */
2130     static Iterator&lt;?&gt; initIterator(Iterable&lt;?&gt; it) {
2131         return it.iterator();
2132     }
2133 
2134     /**
2135      * This method is bound as the predicate in {@linkplain MethodHandles#iteratedLoop iterating loops}.
2136      *
2137      * @param it the iterator to be checked.
2138      *
2139      * @return {@code true} iff there are more elements to iterate over.
2140      */
2141     static boolean iteratePredicate(Iterator&lt;?&gt; it) {
2142         return it.hasNext();
2143     }
2144 
2145     /**
2146      * This method is bound as the step for retrieving the current value from the iterator in {@linkplain
2147      * MethodHandles#iteratedLoop iterating loops}.
2148      *
2149      * @param it the iterator.
2150      *
2151      * @return the next element from the iterator.
2152      */
2153     static Object iterateNext(Iterator&lt;?&gt; it) {
2154         return it.next();
2155     }
2156 
2157     /**
2158      * Makes a {@code try-finally} handle that conforms to the type constraints.
2159      *
2160      * @param target the target to execute in a {@code try-finally} block.
2161      * @param cleanup the cleanup to execute in the {@code finally} block.
2162      * @param rtype the result type of the entire construct.
2163      * @param argTypes the types of the arguments.
2164      *
2165      * @return a handle on the constructed {@code try-finally} block.
2166      */
2167     static MethodHandle makeTryFinally(MethodHandle target, MethodHandle cleanup, Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; argTypes) {
2168         MethodType type = MethodType.methodType(rtype, argTypes);
2169         LambdaForm form = makeTryFinallyForm(type.basicType());
2170 
2171         // Prepare auxiliary method handles used during LambdaForm interpretation.
2172         // Box arguments and wrap them into Object[]: ValueConversions.array().
2173         MethodType varargsType = type.changeReturnType(Object[].class);
2174         MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
2175         MethodHandle unboxResult = unboxResultHandle(rtype);
2176 
2177         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
2178         BoundMethodHandle mh;
2179         try {
2180             mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) cleanup,
2181                     (Object) collectArgs, (Object) unboxResult);
2182         } catch (Throwable ex) {
2183             throw uncaughtException(ex);
2184         }
2185         assert(mh.type() == type);
2186         return mh;
2187     }
2188 
2189     /**
2190      * The LambdaForm shape for the tryFinally combinator is as follows (assuming one reference parameter passed in
2191      * {@code a1}, and a reference return type, with the return value represented by {@code t8}):
2192      * &lt;blockquote&gt;&lt;pre&gt;{@code
2193      *  tryFinally=Lambda(a0:L,a1:L)=&gt;{
2194      *    t2:L=BoundMethodHandle$Species_LLLL.argL0(a0:L);  // target method handle
2195      *    t3:L=BoundMethodHandle$Species_LLLL.argL1(a0:L);  // cleanup method handle
2196      *    t4:L=BoundMethodHandle$Species_LLLL.argL2(a0:L);  // helper handle to box the arguments into an Object[]
2197      *    t5:L=BoundMethodHandle$Species_LLLL.argL3(a0:L);  // helper handle to unbox the result
2198      *    t6:L=MethodHandle.invokeBasic(t4:L,a1:L);         // box the arguments into an Object[]
2199      *    t7:L=MethodHandleImpl.tryFinally(t2:L,t3:L,t6:L); // call the tryFinally executor
2200      *    t8:L=MethodHandle.invokeBasic(t5:L,t7:L);t8:L}    // unbox the result; return the result
2201      * }&lt;/pre&gt;&lt;/blockquote&gt;
2202      * &lt;p&gt;
2203      * {@code argL0} and {@code argL1} are the target and cleanup method handles.
2204      * {@code argL2} and {@code argL3} are auxiliary method handles: {@code argL2} boxes arguments and wraps them into
2205      * {@code Object[]} ({@code ValueConversions.array()}), and {@code argL3} unboxes the result if necessary
2206      * ({@code ValueConversions.unbox()}).
2207      * &lt;p&gt;
2208      * Having {@code t4} and {@code t5} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
2209      * forms among tryFinally combinators with the same basic type.
2210      */
2211     private static LambdaForm makeTryFinallyForm(MethodType basicType) {
2212         MethodType lambdaType = basicType.invokerType();
2213 
2214         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_TF);
2215         if (lform != null) {
2216             return lform;
2217         }
2218         final int THIS_MH      = 0;  // the BMH_LLLL
2219         final int ARG_BASE     = 1;  // start of incoming arguments
2220         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
2221 
2222         int nameCursor = ARG_LIMIT;
2223         final int GET_TARGET       = nameCursor++;
2224         final int GET_CLEANUP      = nameCursor++;
2225         final int GET_COLLECT_ARGS = nameCursor++;
2226         final int GET_UNBOX_RESULT = nameCursor++;
2227         final int BOXED_ARGS       = nameCursor++;
2228         final int TRY_FINALLY      = nameCursor++;
2229         final int UNBOX_RESULT     = nameCursor++;
2230 
2231         Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
2232 
2233         BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
2234         names[THIS_MH]          = names[THIS_MH].withConstraint(data);
2235         names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
2236         names[GET_CLEANUP]      = new Name(data.getterFunction(1), names[THIS_MH]);
2237         names[GET_COLLECT_ARGS] = new Name(data.getterFunction(2), names[THIS_MH]);
2238         names[GET_UNBOX_RESULT] = new Name(data.getterFunction(3), names[THIS_MH]);
2239 
2240         // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
2241         MethodType collectArgsType = basicType.changeReturnType(Object.class);
2242         MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
2243         Object[] args = new Object[invokeBasic.type().parameterCount()];
2244         args[0] = names[GET_COLLECT_ARGS];
2245         System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
2246         names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.TRY_FINALLY), args);
2247 
2248         // t_{i+1}:L=MethodHandleImpl.tryFinally(target:L,exType:L,catcher:L,t_{i}:L);
2249         Object[] tfArgs = new Object[] {names[GET_TARGET], names[GET_CLEANUP], names[BOXED_ARGS]};
2250         names[TRY_FINALLY] = new Name(getFunction(NF_tryFinally), tfArgs);
2251 
2252         // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
2253         MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
2254         Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_FINALLY]};
2255         names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
2256 
2257         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.TRY_FINALLY);
2258 
2259         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_TF, lform);
2260     }
2261 
2262     /**
2263      * Intrinsified during LambdaForm compilation
2264      * (see {@link InvokerBytecodeGenerator#emitTryFinally emitTryFinally}).
2265      */
2266     @Hidden
2267     static Object tryFinally(MethodHandle target, MethodHandle cleanup, Object... av) throws Throwable {
2268         Throwable t = null;
2269         Object r = null;
2270         try {
2271             r = target.invokeWithArguments(av);
2272         } catch (Throwable thrown) {
2273             t = thrown;
2274             throw t;
2275         } finally {
2276             Object[] args = target.type().returnType() == void.class ? prepend(av, t) : prepend(av, t, r);
2277             r = cleanup.invokeWithArguments(args);
2278         }
2279         return r;
2280     }
2281 
2282     // Indexes into constant method handles:
2283     static final int
2284             MH_cast                  =  0,
2285             MH_selectAlternative     =  1,
2286             MH_copyAsPrimitiveArray  =  2,
2287             MH_fillNewTypedArray     =  3,
2288             MH_fillNewArray          =  4,
2289             MH_arrayIdentity         =  5,
2290             MH_countedLoopPred       =  6,
2291             MH_countedLoopStep       =  7,
2292             MH_initIterator          =  8,
2293             MH_iteratePred           =  9,
2294             MH_iterateNext           = 10,
2295             MH_Array_newInstance     = 11,
2296             MH_LIMIT                 = 12;
2297 
2298     static MethodHandle getConstantHandle(int idx) {
2299         MethodHandle handle = HANDLES[idx];
2300         if (handle != null) {
2301             return handle;
2302         }
2303         return setCachedHandle(idx, makeConstantHandle(idx));
2304     }
2305 
2306     private static synchronized MethodHandle setCachedHandle(int idx, final MethodHandle method) {
2307         // Simulate a CAS, to avoid racy duplication of results.
2308         MethodHandle prev = HANDLES[idx];
2309         if (prev != null) {
2310             return prev;
2311         }
2312         HANDLES[idx] = method;
2313         return method;
2314     }
2315 
2316     // Local constant method handles:
2317     private static final @Stable MethodHandle[] HANDLES = new MethodHandle[MH_LIMIT];
2318 
2319     private static MethodHandle makeConstantHandle(int idx) {
2320         try {
2321             switch (idx) {
2322                 case MH_cast:
2323                     return IMPL_LOOKUP.findVirtual(Class.class, &quot;cast&quot;,
2324                             MethodType.methodType(Object.class, Object.class));
2325                 case MH_copyAsPrimitiveArray:
2326                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;copyAsPrimitiveArray&quot;,
2327                             MethodType.methodType(Object.class, Wrapper.class, Object[].class));
2328                 case MH_arrayIdentity:
2329                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;identity&quot;,
2330                             MethodType.methodType(Object[].class, Object[].class));
2331                 case MH_fillNewArray:
2332                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewArray&quot;,
2333                             MethodType.methodType(Object[].class, Integer.class, Object[].class));
2334                 case MH_fillNewTypedArray:
2335                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewTypedArray&quot;,
2336                             MethodType.methodType(Object[].class, Object[].class, Integer.class, Object[].class));
2337                 case MH_selectAlternative:
2338                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;selectAlternative&quot;,
2339                             MethodType.methodType(MethodHandle.class, boolean.class, MethodHandle.class, MethodHandle.class));
2340                 case MH_countedLoopPred:
2341                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopPredicate&quot;,
2342                             MethodType.methodType(boolean.class, int.class, int.class));
2343                 case MH_countedLoopStep:
2344                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopStep&quot;,
2345                             MethodType.methodType(int.class, int.class, int.class));
2346                 case MH_initIterator:
2347                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;initIterator&quot;,
2348                             MethodType.methodType(Iterator.class, Iterable.class));
2349                 case MH_iteratePred:
2350                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iteratePredicate&quot;,
2351                             MethodType.methodType(boolean.class, Iterator.class));
2352                 case MH_iterateNext:
2353                     return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iterateNext&quot;,
2354                             MethodType.methodType(Object.class, Iterator.class));
2355                 case MH_Array_newInstance:
2356                     return IMPL_LOOKUP.findStatic(Array.class, &quot;newInstance&quot;,
2357                             MethodType.methodType(Object.class, Class.class, int.class));
2358             }
2359         } catch (ReflectiveOperationException ex) {
2360             throw newInternalError(ex);
2361         }
2362         throw newInternalError(&quot;Unknown function index: &quot; + idx);
2363     }
2364 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>