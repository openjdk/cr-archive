<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import com.sun.tools.javac.code.Types.UniqueType;
  29 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  30 import com.sun.tools.javac.tree.TreeInfo.PosKind;
  31 import com.sun.tools.javac.util.*;
  32 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  33 import com.sun.tools.javac.util.List;
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.TypeCompound;
  36 import com.sun.tools.javac.code.Symbol.VarSymbol;
  37 import com.sun.tools.javac.comp.*;
  38 import com.sun.tools.javac.tree.*;
  39 
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.code.Type.*;
  42 import com.sun.tools.javac.jvm.Code.*;
  43 import com.sun.tools.javac.jvm.Items.*;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.tree.EndPosTable;
  46 import com.sun.tools.javac.tree.JCTree.*;
  47 
  48 import static com.sun.tools.javac.code.Flags.*;
  49 import static com.sun.tools.javac.code.Kinds.Kind.*;
  50 import static com.sun.tools.javac.code.TypeTag.*;
  51 import static com.sun.tools.javac.jvm.ByteCodes.*;
  52 import static com.sun.tools.javac.jvm.CRTFlags.*;
  53 import static com.sun.tools.javac.main.Option.*;
  54 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  55 
  56 /** This pass maps flat Java (i.e. without inner classes) to bytecodes.
  57  *
  58  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  59  *  If you write code that depends on this, you do so at your own risk.
  60  *  This code and its internal interfaces are subject to change or
  61  *  deletion without notice.&lt;/b&gt;
  62  */
  63 public class Gen extends JCTree.Visitor {
  64     private static final Object[] NO_STATIC_ARGS = new Object[0];
  65     protected static final Context.Key&lt;Gen&gt; genKey = new Context.Key&lt;&gt;();
  66 
  67     private final Log log;
  68     private final Symtab syms;
  69     private final Check chk;
  70     private final Resolve rs;
  71     private final TreeMaker make;
  72     private final Names names;
  73     private final Target target;
  74     private final Name accessDollar;
  75     private final Types types;
  76     private final Lower lower;
  77     private final Annotate annotate;
  78     private final StringConcat concat;
  79     private final TransValues transValues;
  80 
  81     /** Format of stackmap tables to be generated. */
  82     private final Code.StackMapFormat stackMap;
  83 
  84     /** A type that serves as the expected type for all method expressions.
  85      */
  86     private final Type methodType;
  87 
  88     public static Gen instance(Context context) {
  89         Gen instance = context.get(genKey);
  90         if (instance == null)
  91             instance = new Gen(context);
  92         return instance;
  93     }
  94 
  95     /** Constant pool writer, set by genClass.
  96      */
  97     final PoolWriter poolWriter;
  98 
  99     protected Gen(Context context) {
 100         context.put(genKey, this);
 101 
 102         names = Names.instance(context);
 103         log = Log.instance(context);
 104         syms = Symtab.instance(context);
 105         chk = Check.instance(context);
 106         rs = Resolve.instance(context);
 107         make = TreeMaker.instance(context);
 108         target = Target.instance(context);
 109         types = Types.instance(context);
 110         concat = StringConcat.instance(context);
 111 
 112         methodType = new MethodType(null, null, null, syms.methodClass);
 113         accessDollar = names.
 114             fromString(&quot;access&quot; + target.syntheticNameChar());
 115         lower = Lower.instance(context);
 116         transValues = TransValues.instance(context);
 117 
 118         Options options = Options.instance(context);
 119         lineDebugInfo =
 120             options.isUnset(G_CUSTOM) ||
 121             options.isSet(G_CUSTOM, &quot;lines&quot;);
 122         varDebugInfo =
 123             options.isUnset(G_CUSTOM)
 124             ? options.isSet(G)
 125             : options.isSet(G_CUSTOM, &quot;vars&quot;);
 126         genCrt = options.isSet(XJCOV);
 127         debugCode = options.isSet(&quot;debug.code&quot;);
 128         disableVirtualizedPrivateInvoke = options.isSet(&quot;disableVirtualizedPrivateInvoke&quot;);
 129         poolWriter = new PoolWriter(types, names);
 130 
 131         // ignore cldc because we cannot have both stackmap formats
 132         this.stackMap = StackMapFormat.JSR202;
 133         annotate = Annotate.instance(context);
 134     }
 135 
 136     /** Switches
 137      */
 138     private final boolean lineDebugInfo;
 139     private final boolean varDebugInfo;
 140     private final boolean genCrt;
 141     private final boolean debugCode;
 142     private boolean disableVirtualizedPrivateInvoke;
 143 
 144     /** Code buffer, set by genMethod.
 145      */
 146     private Code code;
 147 
 148     /** Items structure, set by genMethod.
 149      */
 150     private Items items;
 151 
 152     /** Environment for symbol lookup, set by genClass
 153      */
 154     private Env&lt;AttrContext&gt; attrEnv;
 155 
 156     /** The top level tree.
 157      */
 158     private JCCompilationUnit toplevel;
 159 
 160     /** The number of code-gen errors in this class.
 161      */
 162     private int nerrs = 0;
 163 
 164     /** An object containing mappings of syntax trees to their
 165      *  ending source positions.
 166      */
 167     EndPosTable endPosTable;
 168 
 169     boolean inCondSwitchExpression;
 170     Chain switchExpressionTrueChain;
 171     Chain switchExpressionFalseChain;
 172     List&lt;LocalItem&gt; stackBeforeSwitchExpression;
 173     LocalItem switchResult;
 174 
 175     /** Generate code to load an integer constant.
 176      *  @param n     The integer to be loaded.
 177      */
 178     void loadIntConst(int n) {
 179         items.makeImmediateItem(syms.intType, n).load();
 180     }
 181 
 182     /** The opcode that loads a zero constant of a given type code.
 183      *  @param tc   The given type code (@see ByteCode).
 184      */
 185     public static int zero(int tc) {
 186         switch(tc) {
 187         case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
 188             return iconst_0;
 189         case LONGcode:
 190             return lconst_0;
 191         case FLOATcode:
 192             return fconst_0;
 193         case DOUBLEcode:
 194             return dconst_0;
 195         default:
 196             throw new AssertionError(&quot;zero&quot;);
 197         }
 198     }
 199 
 200     /** The opcode that loads a one constant of a given type code.
 201      *  @param tc   The given type code (@see ByteCode).
 202      */
 203     public static int one(int tc) {
 204         return zero(tc) + 1;
 205     }
 206 
 207     /** Generate code to load -1 of the given type code (either int or long).
 208      *  @param tc   The given type code (@see ByteCode).
 209      */
 210     void emitMinusOne(int tc) {
 211         if (tc == LONGcode) {
 212             items.makeImmediateItem(syms.longType, Long.valueOf(-1)).load();
 213         } else {
 214             code.emitop0(iconst_m1);
 215         }
 216     }
 217 
 218     /** Construct a symbol to reflect the qualifying type that should
 219      *  appear in the byte code as per JLS 13.1.
 220      *
 221      *  For {@literal target &gt;= 1.2}: Clone a method with the qualifier as owner (except
 222      *  for those cases where we need to work around VM bugs).
 223      *
 224      *  For {@literal target &lt;= 1.1}: If qualified variable or method is defined in a
 225      *  non-accessible class, clone it with the qualifier class as owner.
 226      *
 227      *  @param sym    The accessed symbol
 228      *  @param site   The qualifier&#39;s type.
 229      */
 230     Symbol binaryQualifier(Symbol sym, Type site) {
 231 
 232         if (site.hasTag(ARRAY)) {
 233             if (sym == syms.lengthVar ||
 234                 sym.owner != syms.arrayClass)
 235                 return sym;
 236             // array clone can be qualified by the array type in later targets
 237             Symbol qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name,
 238                                                site, syms.noSymbol);
 239             return sym.clone(qualifier);
 240         }
 241 
 242         if (sym.owner == site.tsym ||
 243             (sym.flags() &amp; (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {
 244             return sym;
 245         }
 246 
 247         // leave alone methods inherited from Object
 248         // JLS 13.1.
 249         if (sym.owner == syms.objectType.tsym)
 250             return sym;
 251 
 252         return sym.clone(site.tsym);
 253     }
 254 
 255     /** Insert a reference to given type in the constant pool,
 256      *  checking for an array with too many dimensions;
 257      *  return the reference&#39;s index.
 258      *  @param type   The type for which a reference is inserted.
 259      */
 260     int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {
 261         checkDimension(pos, type);
 262         if (emitQtype) {
 263             return poolWriter.putClass(new ConstantPoolQType(type, types));
 264         } else {
 265             return poolWriter.putClass(type);
 266         }
 267     }
 268 
 269     /** Insert a reference to given type in the constant pool,
 270      *  checking for an array with too many dimensions;
 271      *  return the reference&#39;s index.
 272      *  @param type   The type for which a reference is inserted.
 273      */
 274     int makeRef(DiagnosticPosition pos, Type type) {
 275         return makeRef(pos, type, false);
 276     }
 277 
 278     /** Check if the given type is an array with too many dimensions.
 279      */
 280     private Type checkDimension(DiagnosticPosition pos, Type t) {
 281         checkDimensionInternal(pos, t);
 282         return t;
 283     }
 284 
 285     private void checkDimensionInternal(DiagnosticPosition pos, Type t) {
 286         switch (t.getTag()) {
 287         case METHOD:
 288             checkDimension(pos, t.getReturnType());
 289             for (List&lt;Type&gt; args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
 290                 checkDimension(pos, args.head);
 291             break;
 292         case ARRAY:
 293             if (types.dimensions(t) &gt; ClassFile.MAX_DIMENSIONS) {
 294                 log.error(pos, Errors.LimitDimensions);
 295                 nerrs++;
 296             }
 297             break;
 298         default:
 299             break;
 300         }
 301     }
 302 
 303     /** Create a temporary variable.
 304      *  @param type   The variable&#39;s type.
 305      */
 306     LocalItem makeTemp(Type type) {
 307         VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
 308                                     names.empty,
 309                                     type,
 310                                     env.enclMethod.sym);
 311         code.newLocal(v);
 312         return items.makeLocalItem(v);
 313     }
 314 
 315     /** Generate code to call a non-private method or constructor.
 316      *  @param pos         Position to be used for error reporting.
 317      *  @param site        The type of which the method is a member.
 318      *  @param name        The method&#39;s name.
 319      *  @param argtypes    The method&#39;s argument types.
 320      *  @param isStatic    A flag that indicates whether we call a
 321      *                     static or instance method.
 322      */
 323     void callMethod(DiagnosticPosition pos,
 324                     Type site, Name name, List&lt;Type&gt; argtypes,
 325                     boolean isStatic) {
 326         Symbol msym = rs.
 327             resolveInternalMethod(pos, attrEnv, site, name, argtypes, null);
 328         if (isStatic) items.makeStaticItem(msym).invoke();
 329         else items.makeMemberItem(msym, name == names.init).invoke();
 330     }
 331 
 332     /** Is the given method definition an access method
 333      *  resulting from a qualified super? This is signified by an odd
 334      *  access code.
 335      */
 336     private boolean isAccessSuper(JCMethodDecl enclMethod) {
 337         return
 338             (enclMethod.mods.flags &amp; SYNTHETIC) != 0 &amp;&amp;
 339             isOddAccessName(enclMethod.name);
 340     }
 341 
 342     /** Does given name start with &quot;access$&quot; and end in an odd digit?
 343      */
 344     private boolean isOddAccessName(Name name) {
 345         return
 346             name.startsWith(accessDollar) &amp;&amp;
 347             (name.getByteAt(name.getByteLength() - 1) &amp; 1) == 1;
 348     }
 349 
 350 /* ************************************************************************
 351  * Non-local exits
 352  *************************************************************************/
 353 
 354     /** Generate code to invoke the finalizer associated with given
 355      *  environment.
 356      *  Any calls to finalizers are appended to the environments `cont&#39; chain.
 357      *  Mark beginning of gap in catch all range for finalizer.
 358      */
 359     void genFinalizer(Env&lt;GenContext&gt; env) {
 360         if (code.isAlive() &amp;&amp; env.info.finalize != null)
 361             env.info.finalize.gen();
 362     }
 363 
 364     /** Generate code to call all finalizers of structures aborted by
 365      *  a non-local
 366      *  exit.  Return target environment of the non-local exit.
 367      *  @param target      The tree representing the structure that&#39;s aborted
 368      *  @param env         The environment current at the non-local exit.
 369      */
 370     Env&lt;GenContext&gt; unwind(JCTree target, Env&lt;GenContext&gt; env) {
 371         Env&lt;GenContext&gt; env1 = env;
 372         while (true) {
 373             genFinalizer(env1);
 374             if (env1.tree == target) break;
 375             env1 = env1.next;
 376         }
 377         return env1;
 378     }
 379 
 380     /** Mark end of gap in catch-all range for finalizer.
 381      *  @param env   the environment which might contain the finalizer
 382      *               (if it does, env.info.gaps != null).
 383      */
 384     void endFinalizerGap(Env&lt;GenContext&gt; env) {
 385         if (env.info.gaps != null &amp;&amp; env.info.gaps.length() % 2 == 1)
 386             env.info.gaps.append(code.curCP());
 387     }
 388 
 389     /** Mark end of all gaps in catch-all ranges for finalizers of environments
 390      *  lying between, and including to two environments.
 391      *  @param from    the most deeply nested environment to mark
 392      *  @param to      the least deeply nested environment to mark
 393      */
 394     void endFinalizerGaps(Env&lt;GenContext&gt; from, Env&lt;GenContext&gt; to) {
 395         Env&lt;GenContext&gt; last = null;
 396         while (last != to) {
 397             endFinalizerGap(from);
 398             last = from;
 399             from = from.next;
 400         }
 401     }
 402 
 403     /** Do any of the structures aborted by a non-local exit have
 404      *  finalizers that require an empty stack?
 405      *  @param target      The tree representing the structure that&#39;s aborted
 406      *  @param env         The environment current at the non-local exit.
 407      */
 408     boolean hasFinally(JCTree target, Env&lt;GenContext&gt; env) {
 409         while (env.tree != target) {
 410             if (env.tree.hasTag(TRY) &amp;&amp; env.info.finalize.hasFinalizer())
 411                 return true;
 412             env = env.next;
 413         }
 414         return false;
 415     }
 416 
 417 /* ************************************************************************
 418  * Normalizing class-members.
 419  *************************************************************************/
 420 
 421     /** Distribute member initializer code into constructors and {@code &lt;clinit&gt;}
 422      *  method.
 423      *  @param defs         The list of class member declarations.
 424      *  @param c            The enclosing class.
 425      */
 426     List&lt;JCTree&gt; normalizeDefs(List&lt;JCTree&gt; defs, ClassSymbol c) {
 427         ListBuffer&lt;JCStatement&gt; initCode = new ListBuffer&lt;&gt;();
 428         ListBuffer&lt;Attribute.TypeCompound&gt; initTAs = new ListBuffer&lt;&gt;();
 429         ListBuffer&lt;JCStatement&gt; clinitCode = new ListBuffer&lt;&gt;();
 430         ListBuffer&lt;Attribute.TypeCompound&gt; clinitTAs = new ListBuffer&lt;&gt;();
 431         ListBuffer&lt;JCTree&gt; methodDefs = new ListBuffer&lt;&gt;();
 432         // Sort definitions into three listbuffers:
 433         //  - initCode for instance initializers
 434         //  - clinitCode for class initializers
 435         //  - methodDefs for method definitions
 436         for (List&lt;JCTree&gt; l = defs; l.nonEmpty(); l = l.tail) {
 437             JCTree def = l.head;
 438             switch (def.getTag()) {
 439             case BLOCK:
 440                 JCBlock block = (JCBlock)def;
 441                 if ((block.flags &amp; STATIC) != 0)
 442                     clinitCode.append(block);
 443                 else if ((block.flags &amp; SYNTHETIC) == 0)
 444                     initCode.append(block);
 445                 break;
 446             case METHODDEF:
 447                 methodDefs.append(def);
 448                 break;
 449             case VARDEF:
 450                 JCVariableDecl vdef = (JCVariableDecl) def;
 451                 VarSymbol sym = vdef.sym;
 452                 checkDimension(vdef.pos(), sym.type);
 453                 if (vdef.init != null) {
 454                     if ((sym.flags() &amp; STATIC) == 0) {
 455                         // Always initialize instance variables.
 456                         JCStatement init = make.at(vdef.pos()).
 457                             Assignment(sym, vdef.init);
 458                         initCode.append(init);
 459                         endPosTable.replaceTree(vdef, init);
 460                         initTAs.addAll(getAndRemoveNonFieldTAs(sym));
 461                     } else if (sym.getConstValue() == null) {
 462                         // Initialize class (static) variables only if
 463                         // they are not compile-time constants.
 464                         JCStatement init = make.at(vdef.pos).
 465                             Assignment(sym, vdef.init);
 466                         clinitCode.append(init);
 467                         endPosTable.replaceTree(vdef, init);
 468                         clinitTAs.addAll(getAndRemoveNonFieldTAs(sym));
 469                     } else {
 470                         checkStringConstant(vdef.init.pos(), sym.getConstValue());
 471                         /* if the init contains a reference to an external class, add it to the
 472                          * constant&#39;s pool
 473                          */
 474                         vdef.init.accept(classReferenceVisitor);
 475                     }
 476                 }
 477                 break;
 478             default:
 479                 Assert.error();
 480             }
 481         }
 482         // Insert any instance initializers into all constructors.
 483         if (initCode.length() != 0) {
 484             List&lt;JCStatement&gt; inits = initCode.toList();
 485             initTAs.addAll(c.getInitTypeAttributes());
 486             List&lt;Attribute.TypeCompound&gt; initTAlist = initTAs.toList();
 487             for (JCTree t : methodDefs) {
 488                 normalizeMethod((JCMethodDecl)t, inits, initTAlist);
 489             }
 490         }
 491         // If there are class initializers, create a &lt;clinit&gt; method
 492         // that contains them as its body.
 493         if (clinitCode.length() != 0) {
 494             MethodSymbol clinit = new MethodSymbol(
 495                 STATIC | (c.flags() &amp; STRICTFP),
 496                 names.clinit,
 497                 new MethodType(
 498                     List.nil(), syms.voidType,
 499                     List.nil(), syms.methodClass),
 500                 c);
 501             c.members().enter(clinit);
 502             List&lt;JCStatement&gt; clinitStats = clinitCode.toList();
 503             JCBlock block = make.at(clinitStats.head.pos()).Block(0, clinitStats);
 504             block.endpos = TreeInfo.endPos(clinitStats.last());
 505             methodDefs.append(make.MethodDef(clinit, block));
 506 
 507             if (!clinitTAs.isEmpty())
 508                 clinit.appendUniqueTypeAttributes(clinitTAs.toList());
 509             if (!c.getClassInitTypeAttributes().isEmpty())
 510                 clinit.appendUniqueTypeAttributes(c.getClassInitTypeAttributes());
 511         }
 512         // Return all method definitions.
 513         return methodDefs.toList();
 514     }
 515 
 516     private List&lt;Attribute.TypeCompound&gt; getAndRemoveNonFieldTAs(VarSymbol sym) {
 517         List&lt;TypeCompound&gt; tas = sym.getRawTypeAttributes();
 518         ListBuffer&lt;Attribute.TypeCompound&gt; fieldTAs = new ListBuffer&lt;&gt;();
 519         ListBuffer&lt;Attribute.TypeCompound&gt; nonfieldTAs = new ListBuffer&lt;&gt;();
 520         for (TypeCompound ta : tas) {
 521             Assert.check(ta.getPosition().type != TargetType.UNKNOWN);
 522             if (ta.getPosition().type == TargetType.FIELD) {
 523                 fieldTAs.add(ta);
 524             } else {
 525                 nonfieldTAs.add(ta);
 526             }
 527         }
 528         sym.setTypeAttributes(fieldTAs.toList());
 529         return nonfieldTAs.toList();
 530     }
 531 
 532     /** Check a constant value and report if it is a string that is
 533      *  too large.
 534      */
 535     private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
 536         if (nerrs != 0 || // only complain about a long string once
 537             constValue == null ||
 538             !(constValue instanceof String) ||
 539             ((String)constValue).length() &lt; PoolWriter.MAX_STRING_LENGTH)
 540             return;
 541         log.error(pos, Errors.LimitString);
 542         nerrs++;
 543     }
 544 
 545     /** Insert instance initializer code into initial constructor.
 546      *  @param md        The tree potentially representing a
 547      *                   constructor&#39;s definition.
 548      *  @param initCode  The list of instance initializer statements.
 549      *  @param initTAs  Type annotations from the initializer expression.
 550      */
 551     void normalizeMethod(JCMethodDecl md, List&lt;JCStatement&gt; initCode, List&lt;TypeCompound&gt; initTAs) {
 552         if (md.name == names.init &amp;&amp; TreeInfo.isInitialConstructor(md)) {
 553             // We are seeing a constructor that does not call another
 554             // constructor of the same class.
 555             List&lt;JCStatement&gt; stats = md.body.stats;
 556             ListBuffer&lt;JCStatement&gt; newstats = new ListBuffer&lt;&gt;();
 557 
 558             if (stats.nonEmpty()) {
 559                 // Copy initializers of synthetic variables generated in
 560                 // the translation of inner classes.
 561                 while (TreeInfo.isSyntheticInit(stats.head)) {
 562                     newstats.append(stats.head);
 563                     stats = stats.tail;
 564                 }
 565                 // Copy superclass constructor call
 566                 newstats.append(stats.head);
 567                 stats = stats.tail;
 568                 // Copy remaining synthetic initializers.
 569                 while (stats.nonEmpty() &amp;&amp;
 570                        TreeInfo.isSyntheticInit(stats.head)) {
 571                     newstats.append(stats.head);
 572                     stats = stats.tail;
 573                 }
 574                 // Now insert the initializer code.
 575                 newstats.appendList(initCode);
 576                 // And copy all remaining statements.
 577                 while (stats.nonEmpty()) {
 578                     newstats.append(stats.head);
 579                     stats = stats.tail;
 580                 }
 581             }
 582             md.body.stats = newstats.toList();
 583             if (md.body.endpos == Position.NOPOS)
 584                 md.body.endpos = TreeInfo.endPos(md.body.stats.last());
 585 
 586             md.sym.appendUniqueTypeAttributes(initTAs);
 587         }
 588     }
 589 
 590 /* ************************************************************************
 591  * Traversal methods
 592  *************************************************************************/
 593 
 594     /** Visitor argument: The current environment.
 595      */
 596     Env&lt;GenContext&gt; env;
 597 
 598     /** Visitor argument: The expected type (prototype).
 599      */
 600     Type pt;
 601 
 602     /** Visitor result: The item representing the computed value.
 603      */
 604     Item result;
 605 
 606     /** Visitor method: generate code for a definition, catching and reporting
 607      *  any completion failures.
 608      *  @param tree    The definition to be visited.
 609      *  @param env     The environment current at the definition.
 610      */
 611     public void genDef(JCTree tree, Env&lt;GenContext&gt; env) {
 612         Env&lt;GenContext&gt; prevEnv = this.env;
 613         try {
 614             this.env = env;
 615             tree.accept(this);
 616         } catch (CompletionFailure ex) {
 617             chk.completionError(tree.pos(), ex);
 618         } finally {
 619             this.env = prevEnv;
 620         }
 621     }
 622 
 623     /** Derived visitor method: check whether CharacterRangeTable
 624      *  should be emitted, if so, put a new entry into CRTable
 625      *  and call method to generate bytecode.
 626      *  If not, just call method to generate bytecode.
 627      *  @see    #genStat(JCTree, Env)
 628      *
 629      *  @param  tree     The tree to be visited.
 630      *  @param  env      The environment to use.
 631      *  @param  crtFlags The CharacterRangeTable flags
 632      *                   indicating type of the entry.
 633      */
 634     public void genStat(JCTree tree, Env&lt;GenContext&gt; env, int crtFlags) {
 635         if (!genCrt) {
 636             genStat(tree, env);
 637             return;
 638         }
 639         int startpc = code.curCP();
 640         genStat(tree, env);
 641         if (tree.hasTag(Tag.BLOCK)) crtFlags |= CRT_BLOCK;
 642         code.crt.put(tree, crtFlags, startpc, code.curCP());
 643     }
 644 
 645     /** Derived visitor method: generate code for a statement.
 646      */
 647     public void genStat(JCTree tree, Env&lt;GenContext&gt; env) {
 648         if (code.isAlive()) {
 649             code.statBegin(tree.pos);
 650             genDef(tree, env);
 651         } else if (env.info.isSwitch &amp;&amp; tree.hasTag(VARDEF)) {
 652             // variables whose declarations are in a switch
 653             // can be used even if the decl is unreachable.
 654             code.newLocal(((JCVariableDecl) tree).sym);
 655         }
 656     }
 657 
 658     /** Derived visitor method: check whether CharacterRangeTable
 659      *  should be emitted, if so, put a new entry into CRTable
 660      *  and call method to generate bytecode.
 661      *  If not, just call method to generate bytecode.
 662      *  @see    #genStats(List, Env)
 663      *
 664      *  @param  trees    The list of trees to be visited.
 665      *  @param  env      The environment to use.
 666      *  @param  crtFlags The CharacterRangeTable flags
 667      *                   indicating type of the entry.
 668      */
 669     public void genStats(List&lt;JCStatement&gt; trees, Env&lt;GenContext&gt; env, int crtFlags) {
 670         if (!genCrt) {
 671             genStats(trees, env);
 672             return;
 673         }
 674         if (trees.length() == 1) {        // mark one statement with the flags
 675             genStat(trees.head, env, crtFlags | CRT_STATEMENT);
 676         } else {
 677             int startpc = code.curCP();
 678             genStats(trees, env);
 679             code.crt.put(trees, crtFlags, startpc, code.curCP());
 680         }
 681     }
 682 
 683     /** Derived visitor method: generate code for a list of statements.
 684      */
 685     public void genStats(List&lt;? extends JCTree&gt; trees, Env&lt;GenContext&gt; env) {
 686         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 687             genStat(l.head, env, CRT_STATEMENT);
 688     }
 689 
 690     /** Derived visitor method: check whether CharacterRangeTable
 691      *  should be emitted, if so, put a new entry into CRTable
 692      *  and call method to generate bytecode.
 693      *  If not, just call method to generate bytecode.
 694      *  @see    #genCond(JCTree,boolean)
 695      *
 696      *  @param  tree     The tree to be visited.
 697      *  @param  crtFlags The CharacterRangeTable flags
 698      *                   indicating type of the entry.
 699      */
 700     public CondItem genCond(JCTree tree, int crtFlags) {
 701         if (!genCrt) return genCond(tree, false);
 702         int startpc = code.curCP();
 703         CondItem item = genCond(tree, (crtFlags &amp; CRT_FLOW_CONTROLLER) != 0);
 704         code.crt.put(tree, crtFlags, startpc, code.curCP());
 705         return item;
 706     }
 707 
 708     /** Derived visitor method: generate code for a boolean
 709      *  expression in a control-flow context.
 710      *  @param _tree         The expression to be visited.
 711      *  @param markBranches The flag to indicate that the condition is
 712      *                      a flow controller so produced conditions
 713      *                      should contain a proper tree to generate
 714      *                      CharacterRangeTable branches for them.
 715      */
 716     public CondItem genCond(JCTree _tree, boolean markBranches) {
 717         JCTree inner_tree = TreeInfo.skipParens(_tree);
 718         if (inner_tree.hasTag(CONDEXPR)) {
 719             JCConditional tree = (JCConditional)inner_tree;
 720             CondItem cond = genCond(tree.cond, CRT_FLOW_CONTROLLER);
 721             if (cond.isTrue()) {
 722                 code.resolve(cond.trueJumps);
 723                 CondItem result = genCond(tree.truepart, CRT_FLOW_TARGET);
 724                 if (markBranches) result.tree = tree.truepart;
 725                 return result;
 726             }
 727             if (cond.isFalse()) {
 728                 code.resolve(cond.falseJumps);
 729                 CondItem result = genCond(tree.falsepart, CRT_FLOW_TARGET);
 730                 if (markBranches) result.tree = tree.falsepart;
 731                 return result;
 732             }
 733             Chain secondJumps = cond.jumpFalse();
 734             code.resolve(cond.trueJumps);
 735             CondItem first = genCond(tree.truepart, CRT_FLOW_TARGET);
 736             if (markBranches) first.tree = tree.truepart;
 737             Chain falseJumps = first.jumpFalse();
 738             code.resolve(first.trueJumps);
 739             Chain trueJumps = code.branch(goto_);
 740             code.resolve(secondJumps);
 741             CondItem second = genCond(tree.falsepart, CRT_FLOW_TARGET);
 742             CondItem result = items.makeCondItem(second.opcode,
 743                                       Code.mergeChains(trueJumps, second.trueJumps),
 744                                       Code.mergeChains(falseJumps, second.falseJumps));
 745             if (markBranches) result.tree = tree.falsepart;
 746             return result;
 747         } else if (inner_tree.hasTag(SWITCH_EXPRESSION)) {
 748             code.resolvePending();
 749 
 750             boolean prevInCondSwitchExpression = inCondSwitchExpression;
 751             Chain prevSwitchExpressionTrueChain = switchExpressionTrueChain;
 752             Chain prevSwitchExpressionFalseChain = switchExpressionFalseChain;
 753             try {
 754                 inCondSwitchExpression = true;
 755                 switchExpressionTrueChain = null;
 756                 switchExpressionFalseChain = null;
 757                 try {
 758                     doHandleSwitchExpression((JCSwitchExpression) inner_tree);
 759                 } catch (CompletionFailure ex) {
 760                     chk.completionError(_tree.pos(), ex);
 761                     code.state.stacksize = 1;
 762                 }
 763                 CondItem result = items.makeCondItem(goto_,
 764                                                      switchExpressionTrueChain,
 765                                                      switchExpressionFalseChain);
 766                 if (markBranches) result.tree = _tree;
 767                 return result;
 768             } finally {
 769                 inCondSwitchExpression = prevInCondSwitchExpression;
 770                 switchExpressionTrueChain = prevSwitchExpressionTrueChain;
 771                 switchExpressionFalseChain = prevSwitchExpressionFalseChain;
 772             }
 773         } else if (inner_tree.hasTag(LETEXPR) &amp;&amp; ((LetExpr) inner_tree).needsCond) {
 774             code.resolvePending();
 775 
 776             LetExpr tree = (LetExpr) inner_tree;
 777             int limit = code.nextreg;
 778             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
 779             try {
 780                 genStats(tree.defs, env);
 781             } finally {
 782                 code.setLetExprStackPos(prevLetExprStart);
 783             }
 784             CondItem result = genCond(tree.expr, markBranches);
 785             code.endScopes(limit);
 786             return result;
 787         } else {
 788             CondItem result = genExpr(_tree, syms.booleanType).mkCond();
 789             if (markBranches) result.tree = _tree;
 790             return result;
 791         }
 792     }
 793 
 794     public Code getCode() {
 795         return code;
 796     }
 797 
 798     public Items getItems() {
 799         return items;
 800     }
 801 
 802     public Env&lt;AttrContext&gt; getAttrEnv() {
 803         return attrEnv;
 804     }
 805 
 806     /** Visitor class for expressions which might be constant expressions.
 807      *  This class is a subset of TreeScanner. Intended to visit trees pruned by
 808      *  Lower as long as constant expressions looking for references to any
 809      *  ClassSymbol. Any such reference will be added to the constant pool so
 810      *  automated tools can detect class dependencies better.
 811      */
 812     class ClassReferenceVisitor extends JCTree.Visitor {
 813 
 814         @Override
 815         public void visitTree(JCTree tree) {}
 816 
 817         @Override
 818         public void visitBinary(JCBinary tree) {
 819             tree.lhs.accept(this);
 820             tree.rhs.accept(this);
 821         }
 822 
 823         @Override
 824         public void visitSelect(JCFieldAccess tree) {
 825             if (tree.selected.type.hasTag(CLASS)) {
 826                 makeRef(tree.selected.pos(), tree.selected.type);
 827             }
 828         }
 829 
 830         @Override
 831         public void visitIdent(JCIdent tree) {
 832             if (tree.sym.owner instanceof ClassSymbol) {
 833                 poolWriter.putClass((ClassSymbol)tree.sym.owner);
 834             }
 835         }
 836 
 837         @Override
 838         public void visitConditional(JCConditional tree) {
 839             tree.cond.accept(this);
 840             tree.truepart.accept(this);
 841             tree.falsepart.accept(this);
 842         }
 843 
 844         @Override
 845         public void visitUnary(JCUnary tree) {
 846             tree.arg.accept(this);
 847         }
 848 
 849         @Override
 850         public void visitParens(JCParens tree) {
 851             tree.expr.accept(this);
 852         }
 853 
 854         @Override
 855         public void visitTypeCast(JCTypeCast tree) {
 856             tree.expr.accept(this);
 857         }
 858     }
 859 
 860     private ClassReferenceVisitor classReferenceVisitor = new ClassReferenceVisitor();
 861 
 862     /** Visitor method: generate code for an expression, catching and reporting
 863      *  any completion failures.
 864      *  @param tree    The expression to be visited.
 865      *  @param pt      The expression&#39;s expected type (proto-type).
 866      */
 867     public Item genExpr(JCTree tree, Type pt) {
 868         Type prevPt = this.pt;
 869         try {
 870             if (tree.type.constValue() != null) {
 871                 // Short circuit any expressions which are constants
 872                 tree.accept(classReferenceVisitor);
 873                 checkStringConstant(tree.pos(), tree.type.constValue());
 874                 Symbol sym = TreeInfo.symbol(tree);
 875                 if (sym != null &amp;&amp; isConstantDynamic(sym)) {
 876                     result = items.makeDynamicItem(sym);
 877                 } else {
 878                     result = items.makeImmediateItem(tree.type, tree.type.constValue());
 879                 }
 880             } else {
 881                 this.pt = pt;
 882                 tree.accept(this);
 883             }
 884             return result.coerce(pt);
 885         } catch (CompletionFailure ex) {
 886             chk.completionError(tree.pos(), ex);
 887             code.state.stacksize = 1;
 888             return items.makeStackItem(pt);
 889         } finally {
 890             this.pt = prevPt;
 891         }
 892     }
 893 
 894     public boolean isConstantDynamic(Symbol sym) {
 895         return sym.kind == VAR &amp;&amp;
 896                 sym instanceof DynamicVarSymbol &amp;&amp;
 897                 ((DynamicVarSymbol)sym).isDynamic();
 898     }
 899 
 900     /** Derived visitor method: generate code for a list of method arguments.
 901      *  @param trees    The argument expressions to be visited.
 902      *  @param pts      The expression&#39;s expected types (i.e. the formal parameter
 903      *                  types of the invoked method).
 904      */
 905     public void genArgs(List&lt;JCExpression&gt; trees, List&lt;Type&gt; pts) {
 906         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail) {
 907             genExpr(l.head, pts.head).load();
 908             pts = pts.tail;
 909         }
 910         // require lists be of same length
 911         Assert.check(pts.isEmpty());
 912     }
 913 
 914 /* ************************************************************************
 915  * Visitor methods for statements and definitions
 916  *************************************************************************/
 917 
 918     /** Thrown when the byte code size exceeds limit.
 919      */
 920     public static class CodeSizeOverflow extends RuntimeException {
 921         private static final long serialVersionUID = 0;
 922         public CodeSizeOverflow() {}
 923     }
 924 
 925     public void visitMethodDef(JCMethodDecl tree) {
 926         // Create a new local environment that points pack at method
 927         // definition.
 928         Env&lt;GenContext&gt; localEnv = env.dup(tree);
 929         localEnv.enclMethod = tree;
 930         // The expected type of every return statement in this method
 931         // is the method&#39;s return type.
 932         this.pt = tree.sym.erasure(types).getReturnType();
 933 
 934         checkDimension(tree.pos(), tree.sym.erasure(types));
 935         genMethod(tree, localEnv, false);
 936     }
 937 //where
 938         /** Generate code for a method.
 939          *  @param tree     The tree representing the method definition.
 940          *  @param env      The environment current for the method body.
 941          *  @param fatcode  A flag that indicates whether all jumps are
 942          *                  within 32K.  We first invoke this method under
 943          *                  the assumption that fatcode == false, i.e. all
 944          *                  jumps are within 32K.  If this fails, fatcode
 945          *                  is set to true and we try again.
 946          */
 947         void genMethod(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
 948             MethodSymbol meth = tree.sym;
 949             int extras = 0;
 950             // Count up extra parameters
 951             if (meth.isConstructor()) {
 952                 extras++;
 953                 if (meth.enclClass().isInner() &amp;&amp;
 954                     !meth.enclClass().isStatic()) {
 955                     extras++;
 956                 }
 957             } else if ((tree.mods.flags &amp; STATIC) == 0) {
 958                 extras++;
 959             }
 960             //      System.err.println(&quot;Generating &quot; + meth + &quot; in &quot; + meth.owner); //DEBUG
 961             if (Code.width(types.erasure(env.enclMethod.sym.type).getParameterTypes()) + extras &gt;
 962                 ClassFile.MAX_PARAMETERS) {
 963                 log.error(tree.pos(), Errors.LimitParameters);
 964                 nerrs++;
 965             }
 966 
 967             else if (tree.body != null) {
 968                 // Create a new code structure and initialize it.
 969                 int startpcCrt = initCode(tree, env, fatcode);
 970 
 971                 try {
 972                     genStat(tree.body, env);
 973                 } catch (CodeSizeOverflow e) {
 974                     // Failed due to code limit, try again with jsr/ret
 975                     startpcCrt = initCode(tree, env, fatcode);
 976                     genStat(tree.body, env);
 977                 }
 978 
 979                 if (code.state.stacksize != 0) {
 980                     log.error(tree.body.pos(), Errors.StackSimError(tree.sym));
 981                     throw new AssertionError();
 982                 }
 983 
 984                 // If last statement could complete normally, insert a
 985                 // return at the end.
 986                 if (code.isAlive()) {
 987                     code.statBegin(TreeInfo.endPos(tree.body));
 988                     if (env.enclMethod == null ||
 989                         env.enclMethod.sym.type.getReturnType().hasTag(VOID)) {
 990                         code.emitop0(return_);
 991                     } else if (env.enclMethod.sym.isValueFactory()) {
 992                         items.makeLocalItem(env.enclMethod.factoryProduct).load();
 993                         code.emitop0(areturn);
 994                     } else {
 995                         // sometime dead code seems alive (4415991);
 996                         // generate a small loop instead
 997                         int startpc = code.entryPoint();
 998                         CondItem c = items.makeCondItem(goto_);
 999                         code.resolve(c.jumpTrue(), startpc);
1000                     }
1001                 }
1002                 if (genCrt)
1003                     code.crt.put(tree.body,
1004                                  CRT_BLOCK,
1005                                  startpcCrt,
1006                                  code.curCP());
1007 
1008                 code.endScopes(0);
1009 
1010                 // If we exceeded limits, panic
1011                 if (code.checkLimits(tree.pos(), log)) {
1012                     nerrs++;
1013                     return;
1014                 }
1015 
1016                 // If we generated short code but got a long jump, do it again
1017                 // with fatCode = true.
1018                 if (!fatcode &amp;&amp; code.fatcode) genMethod(tree, env, true);
1019 
1020                 // Clean up
1021                 if(stackMap == StackMapFormat.JSR202) {
1022                     code.lastFrame = null;
1023                     code.frameBeforeLast = null;
1024                 }
1025 
1026                 // Compress exception table
1027                 code.compressCatchTable();
1028 
1029                 // Fill in type annotation positions for exception parameters
1030                 code.fillExceptionParameterPositions();
1031             }
1032         }
1033 
1034         private int initCode(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
1035             MethodSymbol meth = tree.sym;
1036 
1037             // Create a new code structure.
1038             meth.code = code = new Code(meth,
1039                                         fatcode,
1040                                         lineDebugInfo ? toplevel.lineMap : null,
1041                                         varDebugInfo,
1042                                         stackMap,
1043                                         debugCode,
1044                                         genCrt ? new CRTable(tree, env.toplevel.endPositions)
1045                                                : null,
1046                                         syms,
1047                                         types,
1048                                         poolWriter);
1049             items = new Items(poolWriter, code, syms, types);
1050             if (code.debugCode) {
1051                 System.err.println(meth + &quot; for body &quot; + tree);
1052             }
1053 
1054             // If method is not static, create a new local variable address
1055             // for `this&#39;.
1056             if ((tree.mods.flags &amp; STATIC) == 0) {
1057                 Type selfType = meth.owner.type;
1058                 if (meth.isConstructor() &amp;&amp; selfType != syms.objectType)
1059                     selfType = UninitializedType.uninitializedThis(selfType);
1060                 code.setDefined(
1061                         code.newLocal(
1062                             new VarSymbol(FINAL, names._this, selfType, meth.owner)));
1063             }
1064 
1065             // Mark all parameters as defined from the beginning of
1066             // the method.
1067             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1068                 checkDimension(l.head.pos(), l.head.sym.type);
1069                 code.setDefined(code.newLocal(l.head.sym));
1070             }
1071 
1072             // Get ready to generate code for method body.
1073             int startpcCrt = genCrt ? code.curCP() : 0;
1074             code.entryPoint();
1075 
1076             // Suppress initial stackmap
1077             code.pendingStackMap = false;
1078 
1079             return startpcCrt;
1080         }
1081 
1082     public void visitVarDef(JCVariableDecl tree) {
1083         VarSymbol v = tree.sym;
1084         if (tree.init != null) {
1085             checkStringConstant(tree.init.pos(), v.getConstValue());
1086             if (v.getConstValue() == null || varDebugInfo) {
1087                 Assert.check(code.isStatementStart());
1088                 code.newLocal(v);
1089                 genExpr(tree.init, v.erasure(types)).load();
1090                 items.makeLocalItem(v).store();
1091                 Assert.check(code.isStatementStart());
1092             }
1093         } else {
1094             code.newLocal(v);
1095         }
1096         checkDimension(tree.pos(), v.type);
1097     }
1098 
1099     public void visitSkip(JCSkip tree) {
1100     }
1101 
1102     public void visitBlock(JCBlock tree) {
1103         int limit = code.nextreg;
1104         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1105         genStats(tree.stats, localEnv);
1106         // End the scope of all block-local variables in variable info.
1107         if (!env.tree.hasTag(METHODDEF)) {
1108             code.statBegin(tree.endpos);
1109             code.endScopes(limit);
1110             code.pendingStatPos = Position.NOPOS;
1111         }
1112     }
1113 
1114     public void visitDoLoop(JCDoWhileLoop tree) {
1115         genLoop(tree, tree.body, tree.cond, List.nil(), false);
1116     }
1117 
1118     public void visitWhileLoop(JCWhileLoop tree) {
1119         genLoop(tree, tree.body, tree.cond, List.nil(), true);
1120     }
1121 
1122     public void visitWithField(JCWithField tree) {
1123         switch(tree.field.getTag()) {
1124             case IDENT:
1125                 Symbol sym = ((JCIdent) tree.field).sym;
1126                 items.makeThisItem().load();
1127                 genExpr(tree.value, tree.field.type).load();
1128                 sym = binaryQualifier(sym, env.enclClass.type);
1129                 code.emitop2(withfield, sym, PoolWriter::putMember);
1130                 result = items.makeStackItem(tree.type);
1131                 break;
1132             case SELECT:
1133                 JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;
1134                 sym = TreeInfo.symbol(fieldAccess);
1135                 // JDK-8207332: To maintain the order of side effects, must compute value ahead of field
1136                 genExpr(tree.value, tree.field.type).load();
1137                 genExpr(fieldAccess.selected, fieldAccess.selected.type).load();
1138                 if (Code.width(tree.field.type) == 2) {
1139                     code.emitop0(dup_x2);
1140                     code.emitop0(pop);
1141                 } else {
1142                     code.emitop0(swap);
1143                 }
1144                 sym = binaryQualifier(sym, fieldAccess.selected.type);
1145                 code.emitop2(withfield, sym, PoolWriter::putMember);
1146                 result = items.makeStackItem(tree.type);
1147                 break;
1148             default:
1149                 Assert.check(false);
1150         }
1151     }
1152 
1153     public void visitForLoop(JCForLoop tree) {
1154         int limit = code.nextreg;
1155         genStats(tree.init, env);
1156         genLoop(tree, tree.body, tree.cond, tree.step, true);
1157         code.endScopes(limit);
1158     }
1159     //where
1160         /** Generate code for a loop.
1161          *  @param loop       The tree representing the loop.
1162          *  @param body       The loop&#39;s body.
1163          *  @param cond       The loop&#39;s controlling condition.
1164          *  @param step       &quot;Step&quot; statements to be inserted at end of
1165          *                    each iteration.
1166          *  @param testFirst  True if the loop test belongs before the body.
1167          */
1168         private void genLoop(JCStatement loop,
1169                              JCStatement body,
1170                              JCExpression cond,
1171                              List&lt;JCExpressionStatement&gt; step,
1172                              boolean testFirst) {
1173             Env&lt;GenContext&gt; loopEnv = env.dup(loop, new GenContext());
1174             int startpc = code.entryPoint();
1175             if (testFirst) { //while or for loop
1176                 CondItem c;
1177                 if (cond != null) {
1178                     code.statBegin(cond.pos);
1179                     Assert.check(code.isStatementStart());
1180                     c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1181                 } else {
1182                     c = items.makeCondItem(goto_);
1183                 }
1184                 Chain loopDone = c.jumpFalse();
1185                 code.resolve(c.trueJumps);
1186                 Assert.check(code.isStatementStart());
1187                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1188                 code.resolve(loopEnv.info.cont);
1189                 genStats(step, loopEnv);
1190                 code.resolve(code.branch(goto_), startpc);
1191                 code.resolve(loopDone);
1192             } else {
1193                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1194                 code.resolve(loopEnv.info.cont);
1195                 genStats(step, loopEnv);
1196                 if (code.isAlive()) {
1197                     CondItem c;
1198                     if (cond != null) {
1199                         code.statBegin(cond.pos);
1200                         Assert.check(code.isStatementStart());
1201                         c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1202                     } else {
1203                         c = items.makeCondItem(goto_);
1204                     }
1205                     code.resolve(c.jumpTrue(), startpc);
1206                     Assert.check(code.isStatementStart());
1207                     code.resolve(c.falseJumps);
1208                 }
1209             }
1210             Chain exit = loopEnv.info.exit;
1211             if (exit != null) {
1212                 code.resolve(exit);
1213                 exit.state.defined.excludeFrom(code.nextreg);
1214             }
1215         }
1216 
1217     public void visitForeachLoop(JCEnhancedForLoop tree) {
1218         throw new AssertionError(); // should have been removed by Lower.
1219     }
1220 
1221     public void visitLabelled(JCLabeledStatement tree) {
1222         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1223         genStat(tree.body, localEnv, CRT_STATEMENT);
1224         Chain exit = localEnv.info.exit;
1225         if (exit != null) {
1226             code.resolve(exit);
1227             exit.state.defined.excludeFrom(code.nextreg);
1228         }
1229     }
1230 
1231     public void visitSwitch(JCSwitch tree) {
1232         handleSwitch(tree, tree.selector, tree.cases);
1233     }
1234 
1235     @Override
1236     public void visitSwitchExpression(JCSwitchExpression tree) {
1237         code.resolvePending();
1238         boolean prevInCondSwitchExpression = inCondSwitchExpression;
1239         try {
1240             inCondSwitchExpression = false;
1241             doHandleSwitchExpression(tree);
1242         } finally {
1243             inCondSwitchExpression = prevInCondSwitchExpression;
1244         }
1245         result = items.makeStackItem(pt);
1246     }
1247 
1248     private void doHandleSwitchExpression(JCSwitchExpression tree) {
1249         List&lt;LocalItem&gt; prevStackBeforeSwitchExpression = stackBeforeSwitchExpression;
1250         LocalItem prevSwitchResult = switchResult;
1251         int limit = code.nextreg;
1252         try {
1253             stackBeforeSwitchExpression = List.nil();
1254             switchResult = null;
1255             if (hasTry(tree)) {
1256                 //if the switch expression contains try-catch, the catch handlers need to have
1257                 //an empty stack. So stash whole stack to local variables, and restore it before
1258                 //breaks:
1259                 while (code.state.stacksize &gt; 0) {
1260                     Type type = code.state.peek();
1261                     Name varName = names.fromString(target.syntheticNameChar() +
1262                                                     &quot;stack&quot; +
1263                                                     target.syntheticNameChar() +
1264                                                     tree.pos +
1265                                                     target.syntheticNameChar() +
1266                                                     code.state.stacksize);
1267                     VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,
1268                                                   this.env.enclMethod.sym);
1269                     LocalItem item = items.new LocalItem(type, code.newLocal(var));
1270                     stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);
1271                     item.store();
1272                 }
1273                 switchResult = makeTemp(tree.type);
1274             }
1275             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
1276             try {
1277                 handleSwitch(tree, tree.selector, tree.cases);
1278             } finally {
1279                 code.setLetExprStackPos(prevLetExprStart);
1280             }
1281         } finally {
1282             stackBeforeSwitchExpression = prevStackBeforeSwitchExpression;
1283             switchResult = prevSwitchResult;
1284             code.endScopes(limit);
1285         }
1286     }
1287     //where:
1288         private boolean hasTry(JCSwitchExpression tree) {
1289             boolean[] hasTry = new boolean[1];
1290             new TreeScanner() {
1291                 @Override
1292                 public void visitTry(JCTry tree) {
1293                     hasTry[0] = true;
1294                 }
1295 
1296                 @Override
1297                 public void visitClassDef(JCClassDecl tree) {
1298                 }
1299 
1300                 @Override
1301                 public void visitLambda(JCLambda tree) {
1302                 }
1303             }.scan(tree);
1304             return hasTry[0];
1305         }
1306 
1307     private void handleSwitch(JCTree swtch, JCExpression selector, List&lt;JCCase&gt; cases) {
1308         int limit = code.nextreg;
1309         Assert.check(!selector.type.hasTag(CLASS));
1310         int startpcCrt = genCrt ? code.curCP() : 0;
1311         Assert.check(code.isStatementStart());
1312         Item sel = genExpr(selector, syms.intType);
1313         if (cases.isEmpty()) {
1314             // We are seeing:  switch &lt;sel&gt; {}
1315             sel.load().drop();
1316             if (genCrt)
1317                 code.crt.put(TreeInfo.skipParens(selector),
1318                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1319         } else {
1320             // We are seeing a nonempty switch.
1321             sel.load();
1322             if (genCrt)
1323                 code.crt.put(TreeInfo.skipParens(selector),
1324                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1325             Env&lt;GenContext&gt; switchEnv = env.dup(swtch, new GenContext());
1326             switchEnv.info.isSwitch = true;
1327 
1328             // Compute number of labels and minimum and maximum label values.
1329             // For each case, store its label in an array.
1330             int lo = Integer.MAX_VALUE;  // minimum label.
1331             int hi = Integer.MIN_VALUE;  // maximum label.
1332             int nlabels = 0;               // number of labels.
1333 
1334             int[] labels = new int[cases.length()];  // the label array.
1335             int defaultIndex = -1;     // the index of the default clause.
1336 
1337             List&lt;JCCase&gt; l = cases;
1338             for (int i = 0; i &lt; labels.length; i++) {
1339                 if (l.head.pats.nonEmpty()) {
1340                     Assert.check(l.head.pats.size() == 1);
1341                     int val = ((Number)l.head.pats.head.type.constValue()).intValue();
1342                     labels[i] = val;
1343                     if (val &lt; lo) lo = val;
1344                     if (hi &lt; val) hi = val;
1345                     nlabels++;
1346                 } else {
1347                     Assert.check(defaultIndex == -1);
1348                     defaultIndex = i;
1349                 }
1350                 l = l.tail;
1351             }
1352 
1353             // Determine whether to issue a tableswitch or a lookupswitch
1354             // instruction.
1355             long table_space_cost = 4 + ((long) hi - lo + 1); // words
1356             long table_time_cost = 3; // comparisons
1357             long lookup_space_cost = 3 + 2 * (long) nlabels;
1358             long lookup_time_cost = nlabels;
1359             int opcode =
1360                 nlabels &gt; 0 &amp;&amp;
1361                 table_space_cost + 3 * table_time_cost &lt;=
1362                 lookup_space_cost + 3 * lookup_time_cost
1363                 ?
1364                 tableswitch : lookupswitch;
1365 
1366             int startpc = code.curCP();    // the position of the selector operation
1367             code.emitop0(opcode);
1368             code.align(4);
1369             int tableBase = code.curCP();  // the start of the jump table
1370             int[] offsets = null;          // a table of offsets for a lookupswitch
1371             code.emit4(-1);                // leave space for default offset
1372             if (opcode == tableswitch) {
1373                 code.emit4(lo);            // minimum label
1374                 code.emit4(hi);            // maximum label
1375                 for (long i = lo; i &lt;= hi; i++) {  // leave space for jump table
1376                     code.emit4(-1);
1377                 }
1378             } else {
1379                 code.emit4(nlabels);    // number of labels
1380                 for (int i = 0; i &lt; nlabels; i++) {
1381                     code.emit4(-1); code.emit4(-1); // leave space for lookup table
1382                 }
1383                 offsets = new int[labels.length];
1384             }
1385             Code.State stateSwitch = code.state.dup();
1386             code.markDead();
1387 
1388             // For each case do:
1389             l = cases;
1390             for (int i = 0; i &lt; labels.length; i++) {
1391                 JCCase c = l.head;
1392                 l = l.tail;
1393 
1394                 int pc = code.entryPoint(stateSwitch);
1395                 // Insert offset directly into code or else into the
1396                 // offsets table.
1397                 if (i != defaultIndex) {
1398                     if (opcode == tableswitch) {
1399                         code.put4(
1400                             tableBase + 4 * (labels[i] - lo + 3),
1401                             pc - startpc);
1402                     } else {
1403                         offsets[i] = pc - startpc;
1404                     }
1405                 } else {
1406                     code.put4(tableBase, pc - startpc);
1407                 }
1408 
1409                 // Generate code for the statements in this case.
1410                 genStats(c.stats, switchEnv, CRT_FLOW_TARGET);
1411             }
1412 
1413             // Resolve all breaks.
1414             Chain exit = switchEnv.info.exit;
1415             if  (exit != null) {
1416                 code.resolve(exit);
1417                 exit.state.defined.excludeFrom(limit);
1418             }
1419 
1420             // If we have not set the default offset, we do so now.
1421             if (code.get4(tableBase) == -1) {
1422                 code.put4(tableBase, code.entryPoint(stateSwitch) - startpc);
1423             }
1424 
1425             if (opcode == tableswitch) {
1426                 // Let any unfilled slots point to the default case.
1427                 int defaultOffset = code.get4(tableBase);
1428                 for (long i = lo; i &lt;= hi; i++) {
1429                     int t = (int)(tableBase + 4 * (i - lo + 3));
1430                     if (code.get4(t) == -1)
1431                         code.put4(t, defaultOffset);
1432                 }
1433             } else {
1434                 // Sort non-default offsets and copy into lookup table.
1435                 if (defaultIndex &gt;= 0)
1436                     for (int i = defaultIndex; i &lt; labels.length - 1; i++) {
1437                         labels[i] = labels[i+1];
1438                         offsets[i] = offsets[i+1];
1439                     }
1440                 if (nlabels &gt; 0)
1441                     qsort2(labels, offsets, 0, nlabels - 1);
1442                 for (int i = 0; i &lt; nlabels; i++) {
1443                     int caseidx = tableBase + 8 * (i + 1);
1444                     code.put4(caseidx, labels[i]);
1445                     code.put4(caseidx + 4, offsets[i]);
1446                 }
1447             }
1448         }
1449         code.endScopes(limit);
1450     }
1451 //where
1452         /** Sort (int) arrays of keys and values
1453          */
1454        static void qsort2(int[] keys, int[] values, int lo, int hi) {
1455             int i = lo;
1456             int j = hi;
1457             int pivot = keys[(i+j)/2];
1458             do {
1459                 while (keys[i] &lt; pivot) i++;
1460                 while (pivot &lt; keys[j]) j--;
1461                 if (i &lt;= j) {
1462                     int temp1 = keys[i];
1463                     keys[i] = keys[j];
1464                     keys[j] = temp1;
1465                     int temp2 = values[i];
1466                     values[i] = values[j];
1467                     values[j] = temp2;
1468                     i++;
1469                     j--;
1470                 }
1471             } while (i &lt;= j);
1472             if (lo &lt; j) qsort2(keys, values, lo, j);
1473             if (i &lt; hi) qsort2(keys, values, i, hi);
1474         }
1475 
1476     public void visitSynchronized(JCSynchronized tree) {
1477         int limit = code.nextreg;
1478         // Generate code to evaluate lock and save in temporary variable.
1479         final LocalItem lockVar = makeTemp(syms.objectType);
1480         Assert.check(code.isStatementStart());
1481         genExpr(tree.lock, tree.lock.type).load().duplicate();
1482         lockVar.store();
1483 
1484         // Generate code to enter monitor.
1485         code.emitop0(monitorenter);
1486         code.state.lock(lockVar.reg);
1487 
1488         // Generate code for a try statement with given body, no catch clauses
1489         // in a new environment with the &quot;exit-monitor&quot; operation as finalizer.
1490         final Env&lt;GenContext&gt; syncEnv = env.dup(tree, new GenContext());
1491         syncEnv.info.finalize = new GenFinalizer() {
1492             void gen() {
1493                 genLast();
1494                 Assert.check(syncEnv.info.gaps.length() % 2 == 0);
1495                 syncEnv.info.gaps.append(code.curCP());
1496             }
1497             void genLast() {
1498                 if (code.isAlive()) {
1499                     lockVar.load();
1500                     code.emitop0(monitorexit);
1501                     code.state.unlock(lockVar.reg);
1502                 }
1503             }
1504         };
1505         syncEnv.info.gaps = new ListBuffer&lt;&gt;();
1506         genTry(tree.body, List.nil(), syncEnv);
1507         code.endScopes(limit);
1508     }
1509 
1510     public void visitTry(final JCTry tree) {
1511         // Generate code for a try statement with given body and catch clauses,
1512         // in a new environment which calls the finally block if there is one.
1513         final Env&lt;GenContext&gt; tryEnv = env.dup(tree, new GenContext());
1514         final Env&lt;GenContext&gt; oldEnv = env;
1515         tryEnv.info.finalize = new GenFinalizer() {
1516             void gen() {
1517                 Assert.check(tryEnv.info.gaps.length() % 2 == 0);
1518                 tryEnv.info.gaps.append(code.curCP());
1519                 genLast();
1520             }
1521             void genLast() {
1522                 if (tree.finalizer != null)
1523                     genStat(tree.finalizer, oldEnv, CRT_BLOCK);
1524             }
1525             boolean hasFinalizer() {
1526                 return tree.finalizer != null;
1527             }
1528 
1529             @Override
1530             void afterBody() {
1531                 if (tree.finalizer != null &amp;&amp; (tree.finalizer.flags &amp; BODY_ONLY_FINALIZE) != 0) {
1532                     //for body-only finally, remove the GenFinalizer after try body
1533                     //so that the finally is not generated to catch bodies:
1534                     tryEnv.info.finalize = null;
1535                 }
1536             }
1537 
1538         };
1539         tryEnv.info.gaps = new ListBuffer&lt;&gt;();
1540         genTry(tree.body, tree.catchers, tryEnv);
1541     }
1542     //where
1543         /** Generate code for a try or synchronized statement
1544          *  @param body      The body of the try or synchronized statement.
1545          *  @param catchers  The lis of catch clauses.
1546          *  @param env       the environment current for the body.
1547          */
1548         void genTry(JCTree body, List&lt;JCCatch&gt; catchers, Env&lt;GenContext&gt; env) {
1549             int limit = code.nextreg;
1550             int startpc = code.curCP();
1551             Code.State stateTry = code.state.dup();
1552             genStat(body, env, CRT_BLOCK);
1553             int endpc = code.curCP();
1554             List&lt;Integer&gt; gaps = env.info.gaps.toList();
1555             code.statBegin(TreeInfo.endPos(body));
1556             genFinalizer(env);
1557             code.statBegin(TreeInfo.endPos(env.tree));
1558             Chain exitChain = code.branch(goto_);
1559             endFinalizerGap(env);
1560             env.info.finalize.afterBody();
1561             boolean hasFinalizer =
1562                 env.info.finalize != null &amp;&amp;
1563                 env.info.finalize.hasFinalizer();
1564             if (startpc != endpc) for (List&lt;JCCatch&gt; l = catchers; l.nonEmpty(); l = l.tail) {
1565                 // start off with exception on stack
1566                 code.entryPoint(stateTry, l.head.param.sym.type);
1567                 genCatch(l.head, env, startpc, endpc, gaps);
1568                 genFinalizer(env);
1569                 if (hasFinalizer || l.tail.nonEmpty()) {
1570                     code.statBegin(TreeInfo.endPos(env.tree));
1571                     exitChain = Code.mergeChains(exitChain,
1572                                                  code.branch(goto_));
1573                 }
1574                 endFinalizerGap(env);
1575             }
1576             if (hasFinalizer) {
1577                 // Create a new register segment to avoid allocating
1578                 // the same variables in finalizers and other statements.
1579                 code.newRegSegment();
1580 
1581                 // Add a catch-all clause.
1582 
1583                 // start off with exception on stack
1584                 int catchallpc = code.entryPoint(stateTry, syms.throwableType);
1585 
1586                 // Register all exception ranges for catch all clause.
1587                 // The range of the catch all clause is from the beginning
1588                 // of the try or synchronized block until the present
1589                 // code pointer excluding all gaps in the current
1590                 // environment&#39;s GenContext.
1591                 int startseg = startpc;
1592                 while (env.info.gaps.nonEmpty()) {
1593                     int endseg = env.info.gaps.next().intValue();
1594                     registerCatch(body.pos(), startseg, endseg,
1595                                   catchallpc, 0);
1596                     startseg = env.info.gaps.next().intValue();
1597                 }
1598                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1599                 code.markStatBegin();
1600 
1601                 Item excVar = makeTemp(syms.throwableType);
1602                 excVar.store();
1603                 genFinalizer(env);
1604                 code.resolvePending();
1605                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.END_POS));
1606                 code.markStatBegin();
1607 
1608                 excVar.load();
1609                 registerCatch(body.pos(), startseg,
1610                               env.info.gaps.next().intValue(),
1611                               catchallpc, 0);
1612                 code.emitop0(athrow);
1613                 code.markDead();
1614 
1615                 // If there are jsr&#39;s to this finalizer, ...
1616                 if (env.info.cont != null) {
1617                     // Resolve all jsr&#39;s.
1618                     code.resolve(env.info.cont);
1619 
1620                     // Mark statement line number
1621                     code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1622                     code.markStatBegin();
1623 
1624                     // Save return address.
1625                     LocalItem retVar = makeTemp(syms.throwableType);
1626                     retVar.store();
1627 
1628                     // Generate finalizer code.
1629                     env.info.finalize.genLast();
1630 
1631                     // Return.
1632                     code.emitop1w(ret, retVar.reg);
1633                     code.markDead();
1634                 }
1635             }
1636             // Resolve all breaks.
1637             code.resolve(exitChain);
1638 
1639             code.endScopes(limit);
1640         }
1641 
1642         /** Generate code for a catch clause.
1643          *  @param tree     The catch clause.
1644          *  @param env      The environment current in the enclosing try.
1645          *  @param startpc  Start pc of try-block.
1646          *  @param endpc    End pc of try-block.
1647          */
1648         void genCatch(JCCatch tree,
1649                       Env&lt;GenContext&gt; env,
1650                       int startpc, int endpc,
1651                       List&lt;Integer&gt; gaps) {
1652             if (startpc != endpc) {
1653                 List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypeExprs
1654                         = catchTypesWithAnnotations(tree);
1655                 while (gaps.nonEmpty()) {
1656                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1657                         JCExpression subCatch = subCatch1.snd;
1658                         int catchType = makeRef(tree.pos(), subCatch.type);
1659                         int end = gaps.head.intValue();
1660                         registerCatch(tree.pos(),
1661                                       startpc,  end, code.curCP(),
1662                                       catchType);
1663                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1664                                 tc.position.setCatchInfo(catchType, startpc);
1665                         }
1666                     }
1667                     gaps = gaps.tail;
1668                     startpc = gaps.head.intValue();
1669                     gaps = gaps.tail;
1670                 }
1671                 if (startpc &lt; endpc) {
1672                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1673                         JCExpression subCatch = subCatch1.snd;
1674                         int catchType = makeRef(tree.pos(), subCatch.type);
1675                         registerCatch(tree.pos(),
1676                                       startpc, endpc, code.curCP(),
1677                                       catchType);
1678                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1679                             tc.position.setCatchInfo(catchType, startpc);
1680                         }
1681                     }
1682                 }
1683                 VarSymbol exparam = tree.param.sym;
1684                 code.statBegin(tree.pos);
1685                 code.markStatBegin();
1686                 int limit = code.nextreg;
1687                 code.newLocal(exparam);
1688                 items.makeLocalItem(exparam).store();
1689                 code.statBegin(TreeInfo.firstStatPos(tree.body));
1690                 genStat(tree.body, env, CRT_BLOCK);
1691                 code.endScopes(limit);
1692                 code.statBegin(TreeInfo.endPos(tree.body));
1693             }
1694         }
1695         // where
1696         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotations(JCCatch tree) {
1697             return TreeInfo.isMultiCatch(tree) ?
1698                     catchTypesWithAnnotationsFromMulticatch((JCTypeUnion)tree.param.vartype, tree.param.sym.getRawTypeAttributes()) :
1699                     List.of(new Pair&lt;&gt;(tree.param.sym.getRawTypeAttributes(), tree.param.vartype));
1700         }
1701         // where
1702         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotationsFromMulticatch(JCTypeUnion tree, List&lt;TypeCompound&gt; first) {
1703             List&lt;JCExpression&gt; alts = tree.alternatives;
1704             List&lt;Pair&lt;List&lt;TypeCompound&gt;, JCExpression&gt;&gt; res = List.of(new Pair&lt;&gt;(first, alts.head));
1705             alts = alts.tail;
1706 
1707             while(alts != null &amp;&amp; alts.head != null) {
1708                 JCExpression alt = alts.head;
1709                 if (alt instanceof JCAnnotatedType) {
1710                     JCAnnotatedType a = (JCAnnotatedType)alt;
1711                     res = res.prepend(new Pair&lt;&gt;(annotate.fromAnnotations(a.annotations), alt));
1712                 } else {
1713                     res = res.prepend(new Pair&lt;&gt;(List.nil(), alt));
1714                 }
1715                 alts = alts.tail;
1716             }
1717             return res.reverse();
1718         }
1719 
1720         /** Register a catch clause in the &quot;Exceptions&quot; code-attribute.
1721          */
1722         void registerCatch(DiagnosticPosition pos,
1723                            int startpc, int endpc,
1724                            int handler_pc, int catch_type) {
1725             char startpc1 = (char)startpc;
1726             char endpc1 = (char)endpc;
1727             char handler_pc1 = (char)handler_pc;
1728             if (startpc1 == startpc &amp;&amp;
1729                 endpc1 == endpc &amp;&amp;
1730                 handler_pc1 == handler_pc) {
1731                 code.addCatch(startpc1, endpc1, handler_pc1,
1732                               (char)catch_type);
1733             } else {
1734                 log.error(pos, Errors.LimitCodeTooLargeForTryStmt);
1735                 nerrs++;
1736             }
1737         }
1738 
1739     public void visitIf(JCIf tree) {
1740         int limit = code.nextreg;
1741         Chain thenExit = null;
1742         Assert.check(code.isStatementStart());
1743         CondItem c = genCond(TreeInfo.skipParens(tree.cond),
1744                              CRT_FLOW_CONTROLLER);
1745         Chain elseChain = c.jumpFalse();
1746         Assert.check(code.isStatementStart());
1747         if (!c.isFalse()) {
1748             code.resolve(c.trueJumps);
1749             genStat(tree.thenpart, env, CRT_STATEMENT | CRT_FLOW_TARGET);
1750             thenExit = code.branch(goto_);
1751         }
1752         if (elseChain != null) {
1753             code.resolve(elseChain);
1754             if (tree.elsepart != null) {
1755                 genStat(tree.elsepart, env,CRT_STATEMENT | CRT_FLOW_TARGET);
1756             }
1757         }
1758         code.resolve(thenExit);
1759         code.endScopes(limit);
1760         Assert.check(code.isStatementStart());
1761     }
1762 
1763     public void visitExec(JCExpressionStatement tree) {
1764         // Optimize x++ to ++x and x-- to --x.
1765         JCExpression e = tree.expr;
1766         switch (e.getTag()) {
1767             case POSTINC:
1768                 ((JCUnary) e).setTag(PREINC);
1769                 break;
1770             case POSTDEC:
1771                 ((JCUnary) e).setTag(PREDEC);
1772                 break;
1773         }
1774         Assert.check(code.isStatementStart());
1775         genExpr(tree.expr, tree.expr.type).drop();
1776         Assert.check(code.isStatementStart());
1777     }
1778 
1779     public void visitBreak(JCBreak tree) {
1780         Assert.check(code.isStatementStart());
1781         final Env&lt;GenContext&gt; targetEnv = unwindBreak(tree.target);
1782         targetEnv.info.addExit(code.branch(goto_));
1783         endFinalizerGaps(env, targetEnv);
1784     }
1785 
1786     public void visitYield(JCYield tree) {
1787         Assert.check(code.isStatementStart());
1788         final Env&lt;GenContext&gt; targetEnv;
1789         if (inCondSwitchExpression) {
1790             CondItem value = genCond(tree.value, CRT_FLOW_TARGET);
1791             Chain falseJumps = value.jumpFalse();
1792 
1793             code.resolve(value.trueJumps);
1794             Env&lt;GenContext&gt; localEnv = unwindBreak(tree.target);
1795             reloadStackBeforeSwitchExpr();
1796             Chain trueJumps = code.branch(goto_);
1797 
1798             endFinalizerGaps(env, localEnv);
1799 
1800             code.resolve(falseJumps);
1801             targetEnv = unwindBreak(tree.target);
1802             reloadStackBeforeSwitchExpr();
1803             falseJumps = code.branch(goto_);
1804 
1805             if (switchExpressionTrueChain == null) {
1806                 switchExpressionTrueChain = trueJumps;
1807             } else {
1808                 switchExpressionTrueChain =
1809                         Code.mergeChains(switchExpressionTrueChain, trueJumps);
1810             }
1811             if (switchExpressionFalseChain == null) {
1812                 switchExpressionFalseChain = falseJumps;
1813             } else {
1814                 switchExpressionFalseChain =
1815                         Code.mergeChains(switchExpressionFalseChain, falseJumps);
1816             }
1817         } else {
1818             genExpr(tree.value, pt).load();
1819             if (switchResult != null)
1820                 switchResult.store();
1821 
1822             targetEnv = unwindBreak(tree.target);
1823 
1824             if (code.isAlive()) {
1825                 reloadStackBeforeSwitchExpr();
1826                 if (switchResult != null)
1827                     switchResult.load();
1828 
1829                 code.state.forceStackTop(tree.target.type);
1830                 targetEnv.info.addExit(code.branch(goto_));
1831                 code.markDead();
1832             }
1833         }
1834         endFinalizerGaps(env, targetEnv);
1835     }
1836     //where:
1837         /** As side-effect, might mark code as dead disabling any further emission.
1838          */
1839         private Env&lt;GenContext&gt; unwindBreak(JCTree target) {
1840             int tmpPos = code.pendingStatPos;
1841             Env&lt;GenContext&gt; targetEnv = unwind(target, env);
1842             code.pendingStatPos = tmpPos;
1843             return targetEnv;
1844         }
1845 
1846         private void reloadStackBeforeSwitchExpr() {
1847             for (LocalItem li : stackBeforeSwitchExpression)
1848                 li.load();
1849         }
1850 
1851     public void visitContinue(JCContinue tree) {
1852         int tmpPos = code.pendingStatPos;
1853         Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);
1854         code.pendingStatPos = tmpPos;
1855         Assert.check(code.isStatementStart());
1856         targetEnv.info.addCont(code.branch(goto_));
1857         endFinalizerGaps(env, targetEnv);
1858     }
1859 
1860     public void visitReturn(JCReturn tree) {
1861         int limit = code.nextreg;
1862         final Env&lt;GenContext&gt; targetEnv;
1863 
1864         /* Save and then restore the location of the return in case a finally
1865          * is expanded (with unwind()) in the middle of our bytecodes.
1866          */
1867         int tmpPos = code.pendingStatPos;
1868         if (tree.expr != null) {
1869             Assert.check(code.isStatementStart());
1870             Item r = genExpr(tree.expr, pt).load();
1871             if (hasFinally(env.enclMethod, env)) {
1872                 r = makeTemp(pt);
1873                 r.store();
1874             }
1875             targetEnv = unwind(env.enclMethod, env);
1876             code.pendingStatPos = tmpPos;
1877             r.load();
1878             code.emitop0(ireturn + Code.truncate(Code.typecode(pt)));
1879         } else {
1880             targetEnv = unwind(env.enclMethod, env);
1881             code.pendingStatPos = tmpPos;
1882             code.emitop0(return_);
1883         }
1884         endFinalizerGaps(env, targetEnv);
1885         code.endScopes(limit);
1886     }
1887 
1888     public void visitThrow(JCThrow tree) {
1889         Assert.check(code.isStatementStart());
1890         genExpr(tree.expr, tree.expr.type).load();
1891         code.emitop0(athrow);
1892         Assert.check(code.isStatementStart());
1893     }
1894 
1895 /* ************************************************************************
1896  * Visitor methods for expressions
1897  *************************************************************************/
1898 
1899     public void visitApply(JCMethodInvocation tree) {
1900         setTypeAnnotationPositions(tree.pos);
1901         // Generate code for method.
1902         Item m = genExpr(tree.meth, methodType);
1903         // Generate code for all arguments, where the expected types are
1904         // the parameters of the method&#39;s external type (that is, any implicit
1905         // outer instance of a super(...) call appears as first parameter).
1906         MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(tree.meth);
1907         genArgs(tree.args,
1908                 msym.externalType(types).getParameterTypes());
1909         if (!msym.isDynamic()) {
1910             code.statBegin(tree.pos);
1911         }
1912         result = m.invoke();
1913     }
1914 
1915     public void visitConditional(JCConditional tree) {
1916         Chain thenExit = null;
1917         code.statBegin(tree.cond.pos);
1918         CondItem c = genCond(tree.cond, CRT_FLOW_CONTROLLER);
1919         Chain elseChain = c.jumpFalse();
1920         if (!c.isFalse()) {
1921             code.resolve(c.trueJumps);
1922             int startpc = genCrt ? code.curCP() : 0;
1923             code.statBegin(tree.truepart.pos);
1924             genExpr(tree.truepart, pt).load();
1925             code.state.forceStackTop(tree.type);
1926             if (genCrt) code.crt.put(tree.truepart, CRT_FLOW_TARGET,
1927                                      startpc, code.curCP());
1928             thenExit = code.branch(goto_);
1929         }
1930         if (elseChain != null) {
1931             code.resolve(elseChain);
1932             int startpc = genCrt ? code.curCP() : 0;
1933             code.statBegin(tree.falsepart.pos);
1934             genExpr(tree.falsepart, pt).load();
1935             code.state.forceStackTop(tree.type);
1936             if (genCrt) code.crt.put(tree.falsepart, CRT_FLOW_TARGET,
1937                                      startpc, code.curCP());
1938         }
1939         code.resolve(thenExit);
1940         result = items.makeStackItem(pt);
1941     }
1942 
1943     private void setTypeAnnotationPositions(int treePos) {
1944         MethodSymbol meth = code.meth;
1945         boolean initOrClinit = code.meth.getKind() == javax.lang.model.element.ElementKind.CONSTRUCTOR
1946                 || code.meth.getKind() == javax.lang.model.element.ElementKind.STATIC_INIT;
1947 
1948         for (Attribute.TypeCompound ta : meth.getRawTypeAttributes()) {
1949             if (ta.hasUnknownPosition())
1950                 ta.tryFixPosition();
1951 
1952             if (ta.position.matchesPos(treePos))
1953                 ta.position.updatePosOffset(code.cp);
1954         }
1955 
1956         if (!initOrClinit)
1957             return;
1958 
1959         for (Attribute.TypeCompound ta : meth.owner.getRawTypeAttributes()) {
1960             if (ta.hasUnknownPosition())
1961                 ta.tryFixPosition();
1962 
1963             if (ta.position.matchesPos(treePos))
1964                 ta.position.updatePosOffset(code.cp);
1965         }
1966 
1967         ClassSymbol clazz = meth.enclClass();
1968         for (Symbol s : new com.sun.tools.javac.model.FilteredMemberList(clazz.members())) {
1969             if (!s.getKind().isField())
1970                 continue;
1971 
1972             for (Attribute.TypeCompound ta : s.getRawTypeAttributes()) {
1973                 if (ta.hasUnknownPosition())
1974                     ta.tryFixPosition();
1975 
1976                 if (ta.position.matchesPos(treePos))
1977                     ta.position.updatePosOffset(code.cp);
1978             }
1979         }
1980     }
1981 
1982     public void visitNewClass(JCNewClass tree) {
1983         // Enclosing instances or anonymous classes should have been eliminated
1984         // by now.
1985         Assert.check(tree.encl == null &amp;&amp; tree.def == null);
1986         setTypeAnnotationPositions(tree.pos);
1987 
1988         code.emitop2(new_, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
1989         code.emitop0(dup);
1990 
1991         // Generate code for all arguments, where the expected types are
1992         // the parameters of the constructor&#39;s external type (that is,
1993         // any implicit outer instance appears as first parameter).
1994         genArgs(tree.args, tree.constructor.externalType(types).getParameterTypes());
1995 
1996         items.makeMemberItem(tree.constructor, true).invoke();
1997 
1998         result = items.makeStackItem(tree.type);
1999     }
2000 
2001     public void visitNewArray(JCNewArray tree) {
2002         setTypeAnnotationPositions(tree.pos);
2003 
2004         if (tree.elems != null) {
2005             Type elemtype = types.elemtype(tree.type);
2006             loadIntConst(tree.elems.length());
2007             Item arr = makeNewArray(tree.pos(), tree.type, 1);
2008             int i = 0;
2009             for (List&lt;JCExpression&gt; l = tree.elems; l.nonEmpty(); l = l.tail) {
2010                 arr.duplicate();
2011                 loadIntConst(i);
2012                 i++;
2013                 genExpr(l.head, elemtype).load();
2014                 items.makeIndexedItem(elemtype).store();
2015             }
2016             result = arr;
2017         } else {
2018             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2019                 genExpr(l.head, syms.intType).load();
2020             }
2021             result = makeNewArray(tree.pos(), tree.type, tree.dims.length());
2022         }
2023     }
2024 //where
2025         /** Generate code to create an array with given element type and number
2026          *  of dimensions.
2027          */
2028         Item makeNewArray(DiagnosticPosition pos, Type type, int ndims) {
2029             Type elemtype = types.elemtype(type);
2030             if (types.dimensions(type) &gt; ClassFile.MAX_DIMENSIONS) {
2031                 log.error(pos, Errors.LimitDimensions);
2032                 nerrs++;
2033             }
2034             int elemcode = Code.arraycode(elemtype);
2035             if (elemcode == 0 || (elemcode == 1 &amp;&amp; ndims == 1)) {
2036                 code.emitAnewarray(makeRef(pos, elemtype, types.isValue(elemtype)), type);
2037             } else if (elemcode == 1) {
2038                 code.emitMultianewarray(ndims, makeRef(pos, type), type);
2039             } else {
2040                 code.emitNewarray(elemcode, type);
2041             }
2042             return items.makeStackItem(type);
2043         }
2044 
2045     public void visitParens(JCParens tree) {
2046         result = genExpr(tree.expr, tree.expr.type);
2047     }
2048 
2049     public void visitAssign(JCAssign tree) {
2050         Item l = genExpr(tree.lhs, tree.lhs.type);
2051         genExpr(tree.rhs, tree.lhs.type).load();
2052         if (tree.rhs.type.hasTag(BOT)) {
2053             /* This is just a case of widening reference conversion that per 5.1.5 simply calls
2054                for &quot;regarding a reference as having some other type in a manner that can be proved
2055                correct at compile time.&quot;
2056             */
2057             code.state.forceStackTop(tree.lhs.type);
2058         }
2059         result = items.makeAssignItem(l);
2060     }
2061 
2062     public void visitAssignop(JCAssignOp tree) {
2063         OperatorSymbol operator = tree.operator;
2064         Item l;
2065         if (operator.opcode == string_add) {
2066             l = concat.makeConcat(tree);
2067         } else {
2068             // Generate code for first expression
2069             l = genExpr(tree.lhs, tree.lhs.type);
2070 
2071             // If we have an increment of -32768 to +32767 of a local
2072             // int variable we can use an incr instruction instead of
2073             // proceeding further.
2074             if ((tree.hasTag(PLUS_ASG) || tree.hasTag(MINUS_ASG)) &amp;&amp;
2075                 l instanceof LocalItem &amp;&amp;
2076                 tree.lhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2077                 tree.rhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2078                 tree.rhs.type.constValue() != null) {
2079                 int ival = ((Number) tree.rhs.type.constValue()).intValue();
2080                 if (tree.hasTag(MINUS_ASG)) ival = -ival;
2081                 ((LocalItem)l).incr(ival);
2082                 result = l;
2083                 return;
2084             }
2085             // Otherwise, duplicate expression, load one copy
2086             // and complete binary operation.
2087             l.duplicate();
2088             l.coerce(operator.type.getParameterTypes().head).load();
2089             completeBinop(tree.lhs, tree.rhs, operator).coerce(tree.lhs.type);
2090         }
2091         result = items.makeAssignItem(l);
2092     }
2093 
2094     public void visitUnary(JCUnary tree) {
2095         OperatorSymbol operator = tree.operator;
2096         if (tree.hasTag(NOT)) {
2097             CondItem od = genCond(tree.arg, false);
2098             result = od.negate();
2099         } else {
2100             Item od = genExpr(tree.arg, operator.type.getParameterTypes().head);
2101             switch (tree.getTag()) {
2102             case POS:
2103                 result = od.load();
2104                 break;
2105             case NEG:
2106                 result = od.load();
2107                 code.emitop0(operator.opcode);
2108                 break;
2109             case COMPL:
2110                 result = od.load();
2111                 emitMinusOne(od.typecode);
2112                 code.emitop0(operator.opcode);
2113                 break;
2114             case PREINC: case PREDEC:
2115                 od.duplicate();
2116                 if (od instanceof LocalItem &amp;&amp;
2117                     (operator.opcode == iadd || operator.opcode == isub)) {
2118                     ((LocalItem)od).incr(tree.hasTag(PREINC) ? 1 : -1);
2119                     result = od;
2120                 } else {
2121                     od.load();
2122                     code.emitop0(one(od.typecode));
2123                     code.emitop0(operator.opcode);
2124                     // Perform narrowing primitive conversion if byte,
2125                     // char, or short.  Fix for 4304655.
2126                     if (od.typecode != INTcode &amp;&amp;
2127                         Code.truncate(od.typecode) == INTcode)
2128                       code.emitop0(int2byte + od.typecode - BYTEcode);
2129                     result = items.makeAssignItem(od);
2130                 }
2131                 break;
2132             case POSTINC: case POSTDEC:
2133                 od.duplicate();
2134                 if (od instanceof LocalItem &amp;&amp;
2135                     (operator.opcode == iadd || operator.opcode == isub)) {
2136                     Item res = od.load();
2137                     ((LocalItem)od).incr(tree.hasTag(POSTINC) ? 1 : -1);
2138                     result = res;
2139                 } else {
2140                     Item res = od.load();
2141                     od.stash(od.typecode);
2142                     code.emitop0(one(od.typecode));
2143                     code.emitop0(operator.opcode);
2144                     // Perform narrowing primitive conversion if byte,
2145                     // char, or short.  Fix for 4304655.
2146                     if (od.typecode != INTcode &amp;&amp;
2147                         Code.truncate(od.typecode) == INTcode)
2148                       code.emitop0(int2byte + od.typecode - BYTEcode);
2149                     od.store();
2150                     result = res;
2151                 }
2152                 break;
2153             case NULLCHK:
2154                 result = od.load();
2155                 code.emitop0(dup);
2156                 genNullCheck(tree);
2157                 break;
2158             default:
2159                 Assert.error();
2160             }
2161         }
2162     }
2163 
2164     /** Generate a null check from the object value at stack top. */
2165     private void genNullCheck(JCTree tree) {
2166         code.statBegin(tree.pos);
2167         callMethod(tree.pos(), syms.objectsType, names.requireNonNull,
2168                    List.of(syms.objectType), true);
2169         code.emitop0(pop);
2170     }
2171 
2172     public void visitBinary(JCBinary tree) {
2173         OperatorSymbol operator = tree.operator;
2174         if (operator.opcode == string_add) {
2175             result = concat.makeConcat(tree);
2176         } else if (tree.hasTag(AND)) {
2177             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2178             if (!lcond.isFalse()) {
2179                 Chain falseJumps = lcond.jumpFalse();
2180                 code.resolve(lcond.trueJumps);
2181                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2182                 result = items.
2183                     makeCondItem(rcond.opcode,
2184                                  rcond.trueJumps,
2185                                  Code.mergeChains(falseJumps,
2186                                                   rcond.falseJumps));
2187             } else {
2188                 result = lcond;
2189             }
2190         } else if (tree.hasTag(OR)) {
2191             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2192             if (!lcond.isTrue()) {
2193                 Chain trueJumps = lcond.jumpTrue();
2194                 code.resolve(lcond.falseJumps);
2195                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2196                 result = items.
2197                     makeCondItem(rcond.opcode,
2198                                  Code.mergeChains(trueJumps, rcond.trueJumps),
2199                                  rcond.falseJumps);
2200             } else {
2201                 result = lcond;
2202             }
2203         } else {
2204             Item od = genExpr(tree.lhs, operator.type.getParameterTypes().head);
2205             od.load();
2206             result = completeBinop(tree.lhs, tree.rhs, operator);
2207         }
2208     }
2209 
2210 
2211         /** Complete generating code for operation, with left operand
2212          *  already on stack.
2213          *  @param lhs       The tree representing the left operand.
2214          *  @param rhs       The tree representing the right operand.
2215          *  @param operator  The operator symbol.
2216          */
2217         Item completeBinop(JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2218             MethodType optype = (MethodType)operator.type;
2219             int opcode = operator.opcode;
2220             if (opcode &gt;= if_icmpeq &amp;&amp; opcode &lt;= if_icmple &amp;&amp;
2221                 rhs.type.constValue() instanceof Number &amp;&amp;
2222                 ((Number) rhs.type.constValue()).intValue() == 0) {
2223                 opcode = opcode + (ifeq - if_icmpeq);
2224             } else if (opcode &gt;= if_acmpeq &amp;&amp; opcode &lt;= if_acmpne &amp;&amp;
2225                        TreeInfo.isNull(rhs)) {
2226                 opcode = opcode + (if_acmp_null - if_acmpeq);
2227             } else {
2228                 // The expected type of the right operand is
2229                 // the second parameter type of the operator, except for
2230                 // shifts with long shiftcount, where we convert the opcode
2231                 // to a short shift and the expected type to int.
2232                 Type rtype = operator.erasure(types).getParameterTypes().tail.head;
2233                 if (opcode &gt;= ishll &amp;&amp; opcode &lt;= lushrl) {
2234                     opcode = opcode + (ishl - ishll);
2235                     rtype = syms.intType;
2236                 }
2237                 // Generate code for right operand and load.
2238                 genExpr(rhs, rtype).load();
2239                 // If there are two consecutive opcode instructions,
2240                 // emit the first now.
2241                 if (opcode &gt;= (1 &lt;&lt; preShift)) {
2242                     code.emitop0(opcode &gt;&gt; preShift);
2243                     opcode = opcode &amp; 0xFF;
2244                 }
2245             }
2246             if (opcode &gt;= ifeq &amp;&amp; opcode &lt;= if_acmpne ||
2247                 opcode == if_acmp_null || opcode == if_acmp_nonnull) {
2248                 return items.makeCondItem(opcode);
2249             } else {
2250                 code.emitop0(opcode);
2251                 return items.makeStackItem(optype.restype);
2252             }
2253         }
2254 
2255     public void visitTypeCast(JCTypeCast tree) {
2256         result = genExpr(tree.expr, tree.clazz.type).load();
2257         setTypeAnnotationPositions(tree.pos);
2258         // Additional code is only needed if we cast to a reference type
2259         // which is not statically a supertype of the expression&#39;s type.
2260         // For basic types, the coerce(...) in genExpr(...) will do
2261         // the conversion.
2262         // inline widening conversion is a nop, as the VM sees a subtyping relationship.
2263         if (!tree.clazz.type.isPrimitive() &amp;&amp;
2264            !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
2265             (!tree.clazz.type.tsym.isReferenceProjection() || tree.clazz.type.tsym.valueProjection() != tree.expr.type.tsym) &amp;&amp;
2266            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
2267             checkDimension(tree.pos(), tree.clazz.type);
2268             if (types.isValue(tree.clazz.type)) {
2269                 code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);
2270             } else {
2271                 code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);
2272             }
2273 
2274         }
2275     }
2276 
2277     public void visitWildcard(JCWildcard tree) {
2278         throw new AssertionError(this.getClass().getName());
2279     }
2280 
2281     public void visitTypeTest(JCInstanceOf tree) {
2282         genExpr(tree.expr, tree.expr.type).load();
2283         setTypeAnnotationPositions(tree.pos);
2284         code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));
2285         result = items.makeStackItem(syms.booleanType);
2286     }
2287 
2288     public void visitIndexed(JCArrayAccess tree) {
2289         genExpr(tree.indexed, tree.indexed.type).load();
2290         genExpr(tree.index, syms.intType).load();
2291         result = items.makeIndexedItem(tree.type);
2292     }
2293 
2294     public void visitIdent(JCIdent tree) {
2295         Symbol sym = tree.sym;
2296         if (tree.name == names._this || tree.name == names._super) {
2297             Item res = tree.name == names._this
2298                 ? items.makeThisItem()
2299                 : items.makeSuperItem();
2300             if (sym.kind == MTH) {
2301                 // Generate code to address the constructor.
2302                 res.load();
2303                 res = items.makeMemberItem(sym, true);
2304             }
2305             result = res;
2306        } else if (isInvokeDynamic(sym) || isConstantDynamic(sym)) {
2307             if (isConstantDynamic(sym)) {
2308                 setTypeAnnotationPositions(tree.pos);
2309             }
2310             result = items.makeDynamicItem(sym);
2311         } else if (sym.kind == VAR &amp;&amp; (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
2312             result = items.makeLocalItem((VarSymbol)sym);
2313         } else if ((sym.flags() &amp; STATIC) != 0) {
2314             if (!isAccessSuper(env.enclMethod))
2315                 sym = binaryQualifier(sym, env.enclClass.type);
2316             result = items.makeStaticItem(sym);
2317         } else {
2318             items.makeThisItem().load();
2319             sym = binaryQualifier(sym, env.enclClass.type);
2320             result = items.makeMemberItem(sym, nonVirtualForPrivateAccess(sym));
2321         }
2322     }
2323 
2324     //where
2325     private boolean nonVirtualForPrivateAccess(Symbol sym) {
2326         boolean useVirtual = target.hasVirtualPrivateInvoke() &amp;&amp;
2327                              !disableVirtualizedPrivateInvoke;
2328         return !useVirtual &amp;&amp; ((sym.flags() &amp; PRIVATE) != 0);
2329     }
2330 
2331     public void visitSelect(JCFieldAccess tree) {
2332         Symbol sym = tree.sym;
2333 
2334         if (tree.name == names._class) {
2335             code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));
2336             result = items.makeStackItem(pt);
2337             return;
2338         } else if (tree.name == names._default) {
2339             if (tree.type.asElement().isValue()) {
2340                 code.emitop2(defaultvalue, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
2341             } else if (tree.type.isReference()) {
2342                 code.emitop0(aconst_null);
2343             } else {
2344                 code.emitop0(zero(Code.typecode(tree.type)));
2345             }
2346             result = items.makeStackItem(tree.type);
2347             return;
2348         }
2349 
2350         Symbol ssym = TreeInfo.symbol(tree.selected);
2351 
2352         // Are we selecting via super?
2353         boolean selectSuper =
2354             ssym != null &amp;&amp; (ssym.kind == TYP || ssym.name == names._super);
2355 
2356         // Are we accessing a member of the superclass in an access method
2357         // resulting from a qualified super?
2358         boolean accessSuper = isAccessSuper(env.enclMethod);
2359 
2360         Item base = (selectSuper)
2361             ? items.makeSuperItem()
2362             : genExpr(tree.selected, tree.selected.type);
2363 
2364         if (sym.kind == VAR &amp;&amp; ((VarSymbol) sym).getConstValue() != null) {
2365             // We are seeing a variable that is constant but its selecting
2366             // expression is not.
2367             if ((sym.flags() &amp; STATIC) != 0) {
2368                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2369                     base = base.load();
2370                 base.drop();
2371             } else {
2372                 base.load();
2373                 genNullCheck(tree.selected);
2374             }
2375             result = items.
2376                 makeImmediateItem(sym.type, ((VarSymbol) sym).getConstValue());
2377         } else {
2378             if (isInvokeDynamic(sym)) {
2379                 result = items.makeDynamicItem(sym);
2380                 return;
2381             } else {
2382                 sym = binaryQualifier(sym, tree.selected.type);
2383             }
2384             if ((sym.flags() &amp; STATIC) != 0) {
2385                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2386                     base = base.load();
2387                 base.drop();
2388                 result = items.makeStaticItem(sym);
2389             } else {
2390                 base.load();
2391                 if (sym == syms.lengthVar) {
2392                     code.emitop0(arraylength);
2393                     result = items.makeStackItem(syms.intType);
2394                 } else {
2395                     result = items.
2396                         makeMemberItem(sym,
2397                                        nonVirtualForPrivateAccess(sym) ||
2398                                        selectSuper || accessSuper);
2399                 }
2400             }
2401         }
2402     }
2403 
2404     public boolean isInvokeDynamic(Symbol sym) {
2405         return sym.kind == MTH &amp;&amp; ((MethodSymbol)sym).isDynamic();
2406     }
2407 
2408     public void visitLiteral(JCLiteral tree) {
2409         if (tree.type.hasTag(BOT)) {
2410             code.emitop0(aconst_null);
2411             result = items.makeStackItem(tree.type);
2412         }
2413         else
2414             result = items.makeImmediateItem(tree.type, tree.value);
2415     }
2416 
2417     public void visitLetExpr(LetExpr tree) {
2418         code.resolvePending();
2419 
2420         int limit = code.nextreg;
2421         int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
2422         try {
2423             genStats(tree.defs, env);
2424         } finally {
2425             code.setLetExprStackPos(prevLetExprStart);
2426         }
2427         result = genExpr(tree.expr, tree.expr.type).load();
2428         code.endScopes(limit);
2429     }
2430 
2431     private void generateReferencesToPrunedTree(ClassSymbol classSymbol) {
2432         List&lt;JCTree&gt; prunedInfo = lower.prunedTree.get(classSymbol);
2433         if (prunedInfo != null) {
2434             for (JCTree prunedTree: prunedInfo) {
2435                 prunedTree.accept(classReferenceVisitor);
2436             }
2437         }
2438     }
2439 
2440 /* ************************************************************************
2441  * main method
2442  *************************************************************************/
2443 
2444     /** Generate code for a class definition.
2445      *  @param env   The attribution environment that belongs to the
2446      *               outermost class containing this class definition.
2447      *               We need this for resolving some additional symbols.
2448      *  @param cdef  The tree representing the class definition.
2449      *  @return      True if code is generated with no errors.
2450      */
2451     public boolean genClass(Env&lt;AttrContext&gt; env, JCClassDecl cdef) {
2452         try {
2453             attrEnv = env;
2454             ClassSymbol c = cdef.sym;
2455             this.toplevel = env.toplevel;
2456             this.endPosTable = toplevel.endPositions;
2457             /* method normalizeDefs() can add references to external classes into the constant pool
2458              */
2459             cdef.defs = normalizeDefs(cdef.defs, c);
2460             cdef = transValues.translateTopLevelClass(cdef, make);
2461             generateReferencesToPrunedTree(c);
2462             Env&lt;GenContext&gt; localEnv = new Env&lt;&gt;(cdef, new GenContext());
2463             localEnv.toplevel = env.toplevel;
2464             localEnv.enclClass = cdef;
2465 
2466             for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2467                 genDef(l.head, localEnv);
2468             }
2469             if (poolWriter.size() &gt; PoolWriter.MAX_ENTRIES) {
2470                 log.error(cdef.pos(), Errors.LimitPool);
2471                 nerrs++;
2472             }
2473             if (nerrs != 0) {
2474                 // if errors, discard code
2475                 for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2476                     if (l.head.hasTag(METHODDEF))
2477                         ((JCMethodDecl) l.head).sym.code = null;
2478                 }
2479             }
2480             cdef.defs = List.nil(); // discard trees
2481             return nerrs == 0;
2482         } finally {
2483             // note: this method does NOT support recursion.
2484             attrEnv = null;
2485             this.env = null;
2486             toplevel = null;
2487             endPosTable = null;
2488             nerrs = 0;
2489         }
2490     }
2491 
2492 /* ************************************************************************
2493  * Auxiliary classes
2494  *************************************************************************/
2495 
2496     /** An abstract class for finalizer generation.
2497      */
2498     abstract class GenFinalizer {
2499         /** Generate code to clean up when unwinding. */
2500         abstract void gen();
2501 
2502         /** Generate code to clean up at last. */
2503         abstract void genLast();
2504 
2505         /** Does this finalizer have some nontrivial cleanup to perform? */
2506         boolean hasFinalizer() { return true; }
2507 
2508         /** Should be invoked after the try&#39;s body has been visited. */
2509         void afterBody() {}
2510     }
2511 
2512     /** code generation contexts,
2513      *  to be used as type parameter for environments.
2514      */
2515     static class GenContext {
2516 
2517         /** A chain for all unresolved jumps that exit the current environment.
2518          */
2519         Chain exit = null;
2520 
2521         /** A chain for all unresolved jumps that continue in the
2522          *  current environment.
2523          */
2524         Chain cont = null;
2525 
2526         /** A closure that generates the finalizer of the current environment.
2527          *  Only set for Synchronized and Try contexts.
2528          */
2529         GenFinalizer finalize = null;
2530 
2531         /** Is this a switch statement?  If so, allocate registers
2532          * even when the variable declaration is unreachable.
2533          */
2534         boolean isSwitch = false;
2535 
2536         /** A list buffer containing all gaps in the finalizer range,
2537          *  where a catch all exception should not apply.
2538          */
2539         ListBuffer&lt;Integer&gt; gaps = null;
2540 
2541         /** Add given chain to exit chain.
2542          */
2543         void addExit(Chain c)  {
2544             exit = Code.mergeChains(c, exit);
2545         }
2546 
2547         /** Add given chain to cont chain.
2548          */
2549         void addCont(Chain c) {
2550             cont = Code.mergeChains(c, cont);
2551         }
2552     }
2553 
2554 }
    </pre>
  </body>
</html>