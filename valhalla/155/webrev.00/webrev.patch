diff a/src/hotspot/share/classfile/vmSymbols.hpp b/src/hotspot/share/classfile/vmSymbols.hpp
--- a/src/hotspot/share/classfile/vmSymbols.hpp
+++ b/src/hotspot/share/classfile/vmSymbols.hpp
@@ -673,11 +673,11 @@
   template(toFileURL_name,                         "toFileURL")                                                   \
   template(toFileURL_signature,                    "(Ljava/lang/String;)Ljava/net/URL;")                          \
   template(url_void_signature,                     "(Ljava/net/URL;)V")                                           \
                                                                                                                   \
   template(java_lang_invoke_ValueBootstrapMethods, "java/lang/invoke/ValueBootstrapMethods")                      \
-  template(isSubstitutable_name,                   "isSubstitutable0")                                            \
+  template(isSubstitutable_name,                   "isSubstitutable")                                             \
   template(inlineObjectHashCode_name,              "inlineObjectHashCode")                                        \
                                                                                                                   \
   template(jdk_internal_vm_jni_SubElementSelector, "jdk/internal/vm/jni/SubElementSelector")                      \
   /*end*/
 
diff a/src/java.base/share/classes/java/lang/Object.java b/src/java.base/share/classes/java/lang/Object.java
--- a/src/java.base/share/classes/java/lang/Object.java
+++ b/src/java.base/share/classes/java/lang/Object.java
@@ -24,11 +24,13 @@
  */
 
 package java.lang;
 
 import jdk.internal.HotSpotIntrinsicCandidate;
+import jdk.internal.access.SharedSecrets;
 
+import java.lang.invoke.ValueBootstrapMethods;
 import java.util.Objects;
 
 /**
  * Class {@code Object} is the root of the class hierarchy.
  * Every class has {@code Object} as a superclass. All objects,
@@ -225,25 +227,35 @@
      * "textually represents" this object. The result should
      * be a concise but informative representation that is easy for a
      * person to read.
      * It is recommended that all subclasses override this method.
      * <p>
-     * The {@code toString} method for class {@code Object}
-     * returns a string consisting of the name of the class of which the
-     * object is an instance, the at-sign character `{@code @}', and
-     * the unsigned hexadecimal representation of the hash code of the
-     * object. In other words, this method returns a string equal to the
+     * If this object is an instance of an identity class, then
+     * the {@code toString} method returns a string consisting of the name
+     * of the class of which the object is an instance, the at-sign character
+     * `{@code @}', and the unsigned hexadecimal representation of the hash code
+     * of the object. In other words, this method returns a string equal to the
      * value of:
      * <blockquote>
      * <pre>
      * getClass().getName() + '@' + Integer.toHexString(hashCode())
      * </pre></blockquote>
+     * <p>
+     * If this object is an instance of an inline class, then
+     * the {@code toString} method returns a string which contains
+     * the name of the inline class, and string representations of
+     * all its fields.  The precise format produced by this method
+     * is unspecified and subject to change.
      *
      * @return  a string representation of the object.
      */
     public String toString() {
-        return getClass().getName() + "@" + Integer.toHexString(hashCode());
+        if (getClass().isInlineClass()) {
+            return SharedSecrets.getJavaLangInvokeAccess().inlineObjectToString(this);
+        } else {
+            return getClass().getName() + "@" + Integer.toHexString(hashCode());
+        }
     }
 
     /**
      * Wakes up a single thread that is waiting on this object's
      * monitor. If any threads are waiting on this object, one of them
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
@@ -1885,10 +1885,15 @@
                 if (base == null) {
                     throw new IllegalArgumentException("Not a memory access varhandle: " + handle);
                 }
                 return base;
             }
+
+            @Override
+            public String inlineObjectToString(Object o) {
+                return ValueBootstrapMethods.inlineObjectToString(o);
+            }
         });
     }
 
     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
     private static MethodHandle unboxResultHandle(Class<?> returnType) {
diff a/src/java.base/share/classes/java/lang/invoke/ValueBootstrapMethods.java b/src/java.base/share/classes/java/lang/invoke/ValueBootstrapMethods.java
--- a/src/java.base/share/classes/java/lang/invoke/ValueBootstrapMethods.java
+++ b/src/java.base/share/classes/java/lang/invoke/ValueBootstrapMethods.java
@@ -89,27 +89,27 @@
         if (VERBOSE) {
             System.out.println("generate BSM for " + lookup + "::" + name);
         }
         switch (name) {
             case "hashCode":
-                return hashCodeInvoker(lookup, name, methodType);
+                return inlineTypeHashCode(lookup.lookupClass());
             case "equals":
-                return equalsInvoker(lookup, name, methodType);
+                return substitutableInvoker(lookup.lookupClass()).asType(methodType);
             case "toString":
-                return toStringInvoker(lookup, name, methodType);
+                return inlineTypeToString(lookup.lookupClass());
             default:
                 throw new IllegalArgumentException(name + " not valid method name");
         }
     }
 
     static class MethodHandleBuilder {
-        static MethodHandle[] getters(Lookup lookup) {
-            return getters(lookup, null);
+        static MethodHandle[] getters(Class<?> type) {
+            return getters(type, null);
         }
 
-        static MethodHandle[] getters(Lookup lookup, Comparator<MethodHandle> comparator) {
-            Class<?> type = lookup.lookupClass();
+        static MethodHandle[] getters(Class<?> type, Comparator<MethodHandle> comparator) {
+            Lookup lookup = new MethodHandles.Lookup(type);
             // filter static fields and synthetic fields
             Stream<MethodHandle> s = Arrays.stream(type.getDeclaredFields())
                 .filter(f -> !Modifier.isStatic(f.getModifiers()) && !f.isSynthetic())
                 .map(f -> {
                     try {
@@ -136,34 +136,22 @@
             } else {
                 return HASHCODE[Wrapper.OBJECT.ordinal()].asType(methodType(int.class, type));
             }
         }
 
-        /*
-         * For primitive types: a == b
-         * For indirect or inline class: a == b || (a != null && a.equals(b))
-         */
-        static MethodHandle equalsForType(Class<?> type) {
-            if (type.isPrimitive()) {
-                return primitiveEquals(type);
-            } else {
-                return OBJECTS_EQUALS.asType(methodType(boolean.class, type, type));
-            }
-        }
-
         /*
          * Produces a MethodHandle that returns boolean if two instances
-         * of the given indirect interface/class are substitutable.
+         * of the given reference type are substitutable.
          *
-         * Two values of indirect interface/class are substitutable i== iff
+         * Two values of reference type are substitutable i== iff
          * 1. if o1 and o2 are both reference objects then o1 r== o2; or
          * 2. if o1 and o2 are both values then o1 v== o2
          *
          * At invocation time, it needs a dynamic check on the objects and
          * do the substitutability test if they are of an inline type.
          */
-        static MethodHandle indirectTypeEquals(Class<?> type) {
+        static MethodHandle referenceTypeEquals(Class<?> type) {
             return EQUALS[Wrapper.OBJECT.ordinal()].asType(methodType(boolean.class, type, type));
         }
 
 
         /*
@@ -171,12 +159,11 @@
          * of the given inline class are substitutable.
          */
         static MethodHandle inlineTypeEquals(Class<?> type) {
             assert type.isInlineClass();
             MethodType mt = methodType(boolean.class, type, type);
-            MethodHandles.Lookup lookup = new MethodHandles.Lookup(type);
-            MethodHandle[] getters = getters(lookup, TYPE_SORTER);
+            MethodHandle[] getters = getters(type, TYPE_SORTER);
             MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);
             MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);
             MethodHandle accumulator = dropArguments(TRUE, 0, type, type);
             for (MethodHandle getter : getters) {
                 Class<?> ftype = getter.type().returnType();
@@ -185,11 +172,11 @@
                 accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);
             }
             // if both arguments are null, return true;
             // otherwise return accumulator;
             return guardWithTest(IS_NULL.asType(mt),
-                                 instanceTrue.asType(mt),
+                                 instanceTrue,
                                  guardWithTest(IS_SAME_INLINE_CLASS.asType(mt),
                                                accumulator,
                                                instanceFalse));
         }
 
@@ -199,12 +186,11 @@
             MethodHandle cls = dropArguments(constant(Class.class, type),0, type);
             MethodHandle classHashCode = filterReturnValue(cls, hashCodeForType(Class.class));
             MethodHandle combiner = filterArguments(HASH_COMBINER, 0, target, classHashCode);
             // int v = SALT * 31 + type.hashCode();
             MethodHandle init = permuteArguments(combiner, target.type(), 0, 0);
-            MethodHandles.Lookup lookup = new MethodHandles.Lookup(type);
-            MethodHandle[] getters = MethodHandleBuilder.getters(lookup);
+            MethodHandle[] getters = MethodHandleBuilder.getters(type);
             MethodHandle iterations = dropArguments(constant(int.class, getters.length), 0, type);
             MethodHandle[] hashers = new MethodHandle[getters.length];
             for (int i=0; i < getters.length; i++) {
                 MethodHandle getter = getters[i];
                 // For inline type or reference type, this calls Objects::hashCode.
@@ -221,10 +207,44 @@
             MethodHandle body = COMPUTE_HASH.bindTo(hashers)
                     .asType(methodType(int.class, int.class, int.class, type));
             return countedLoop(iterations, init, body);
         }
 
+        static MethodHandle inlineTypeToString(Class<?> type) {
+            assert type.isInlineClass();
+            MethodHandle[] getters = MethodHandleBuilder.getters(type);
+            int length = getters.length;
+            StringBuilder format = new StringBuilder();
+            Class<?>[] parameterTypes = new Class<?>[length];
+            // append the value class name
+            format.append("[").append(type.getName());
+            String separator = " ";
+            Lookup lookup = new MethodHandles.Lookup(type);
+            for (int i = 0; i < length; i++) {
+                MethodHandle getter = getters[i];
+                MethodHandleInfo fieldInfo = lookup.revealDirect(getter);
+                Class<?> ftype = fieldInfo.getMethodType().returnType();
+                format.append(separator)
+                      .append(fieldInfo.getName())
+                      .append("=\1");
+                getters[i]= filterReturnValue(getter, MethodHandleBuilder.toString(ftype));
+                parameterTypes[i] = String.class;
+            }
+            format.append("]");
+            try {
+                MethodHandle target = StringConcatFactory.makeConcatWithConstants(lookup, "toString",
+                        methodType(String.class, parameterTypes), format.toString()).dynamicInvoker();
+                // apply getters
+                target = filterArguments(target, 0, getters);
+                // duplicate "this" argument from o::toString for each getter invocation
+                target = permuteArguments(target, methodType(String.class, type), new int[length]);
+                return target;
+            } catch (StringConcatException e) {
+                throw newLinkageError(e);
+            }
+
+        }
         // ------ utility methods ------
         private static boolean eq(byte a, byte b)       { return a == b; }
         private static boolean eq(short a, short b)     { return a == b; }
         private static boolean eq(char a, char b)       { return a == b; }
         private static boolean eq(int a, int b)         { return a == b; }
@@ -237,17 +257,10 @@
             if (a == null || b == null) return false;
             if (a.getClass() != b.getClass()) return false;
             return a.getClass().isInlineClass() ? inlineValueEq(a, b) : (a == b);
         }
 
-        private static boolean objectsEquals(Object a, Object b)   {
-            if (a == null && b == null) return true;
-            if (a == null || b == null) return false;
-            if (a.getClass() != b.getClass()) return false;
-            return eq(a, b) || a.equals(b);
-        }
-
         /*
          * Returns true if two values are substitutable.
          */
         private static boolean inlineValueEq(Object a, Object b) {
             assert a != null && b != null && isSameInlineClass(a, b);
@@ -322,12 +335,10 @@
             findStatic("isSameInlineClass", methodType(boolean.class, Object.class, Object.class));
         static final MethodHandle IS_NULL =
             findStatic("isNull", methodType(boolean.class, Object.class, Object.class));
         static final MethodHandle TO_STRING =
             findStatic("toString", methodType(String.class, Object.class));
-        static final MethodHandle OBJECTS_EQUALS =
-            findStatic("objectsEquals", methodType(boolean.class, Object.class, Object.class));
 
         static final MethodHandle FALSE = constant(boolean.class, false);
         static final MethodHandle TRUE = constant(boolean.class, true);
         static final MethodHandle HASH_COMBINER =
             findStatic("hashCombiner", methodType(int.class, int.class, int.class));
@@ -389,113 +400,14 @@
             int value = (int)((nt >>> 32) ^ nt);
             SALT = GetIntegerAction.privilegedGetProperty("value.bsm.salt", value);
         }
     }
 
-    /*
-     * Produces a method handle that computes the hashcode
-     */
-    private static MethodHandle hashCodeInvoker(Lookup lookup, String name, MethodType mt) {
-        return inlineTypeHashCode(lookup.lookupClass());
-    }
-
-    /*
-     * Produces a method handle that invokes the toString method of a value object.
-     */
-    private static MethodHandle toStringInvoker(Lookup lookup, String name, MethodType mt) {
-        Class<?> type = lookup.lookupClass();
-        MethodHandle[] getters = MethodHandleBuilder.getters(lookup);
-        int length = getters.length;
-        StringBuilder format = new StringBuilder();
-        Class<?>[] parameterTypes = new Class<?>[length];
-        // append the value class name
-        format.append("[").append(type.getName());
-        String separator = " ";
-        for (int i = 0; i < length; i++) {
-            MethodHandle getter = getters[i];
-            MethodHandleInfo fieldInfo = lookup.revealDirect(getter);
-            Class<?> ftype = fieldInfo.getMethodType().returnType();
-            format.append(separator)
-                  .append(fieldInfo.getName())
-                  .append("=\1");
-            getters[i]= filterReturnValue(getter, MethodHandleBuilder.toString(ftype));
-            parameterTypes[i] = String.class;
-        }
-        format.append("]");
-        try {
-            MethodHandle target = StringConcatFactory.makeConcatWithConstants(lookup, "toString",
-                    methodType(String.class, parameterTypes), format.toString()).dynamicInvoker();
-            // apply getters
-            target = filterArguments(target, 0, getters);
-            // duplicate "this" argument from o::toString for each getter invocation
-            target = permuteArguments(target, methodType(String.class, type), new int[length]);
-            return target;
-        } catch (StringConcatException e) {
-            throw newLinkageError(e);
-        }
-    }
-
-    /*
-     * Produces a method handle that tests if two arguments are equals.
-     */
-    private static MethodHandle equalsInvoker(Lookup lookup, String name, MethodType mt) {
-        Class<?> type = lookup.lookupClass();
-        // MethodHandle to compare all fields of two value objects
-        MethodHandle[] getters = MethodHandleBuilder.getters(lookup, TYPE_SORTER);
-        MethodHandle accumulator = dropArguments(TRUE, 0, type, type);
-        MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class)
-                                        .asType(methodType(boolean.class, type, type));
-        for (MethodHandle getter : getters) {
-            // for primitive types, a == b
-            // for indirect types, a == b || (a != null && a.equals(b))
-            MethodHandle eq = equalsForType(getter.type().returnType());
-            MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);
-            accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);
-        }
-
-        // if a == null && b == null then true
-        // if a and b are not-null and of the same inline class
-        // then field-to-field comparison else false
-        MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);
-        return guardWithTest(IS_NULL.asType(mt),
-                             instanceTrue.asType(mt),
-                             guardWithTest(IS_SAME_INLINE_CLASS.asType(mt),
-                                           accumulator.asType(mt),
-                                           dropArguments(FALSE, 0, type, Object.class)));
-    }
-
     private static LinkageError newLinkageError(Throwable e) {
         return (LinkageError) new LinkageError().initCause(e);
     }
 
-    /**
-     * Invoke the bootstrap methods hashCode for the given instance.
-     * @param o the instance to hash.
-     * @return the hash code of the given instance {code o}.
-     */
-    private static int inlineObjectHashCode(Object o) {
-        try {
-            Class<?> type = o.getClass();
-            // Note: javac disallows user to call super.hashCode if user implementated
-            // risk for recursion for experts crafting byte-code
-            if (!type.isInlineClass())
-                throw new InternalError("must be inline type: " + type.getName());
-            return (int) HASHCODE_METHOD_HANDLES.get(type).invoke(o);
-        } catch (Error|RuntimeException e) {
-            throw e;
-        } catch (Throwable e) {
-            if (VERBOSE) e.printStackTrace();
-            throw new InternalError(e);
-        }
-    }
-
-    private static ClassValue<MethodHandle> HASHCODE_METHOD_HANDLES = new ClassValue<>() {
-        @Override protected MethodHandle computeValue(Class<?> type) {
-            return MethodHandleBuilder.inlineTypeHashCode(type);
-        }
-    };
-
     /**
      * Returns {@code true} if the arguments are <em>substitutable</em> to each
      * other and {@code false} otherwise.
      * <em>Substitutability</em> means that they cannot be distinguished from
      * each other in any data-dependent way, meaning that it is safe to substitute
@@ -566,33 +478,19 @@
      * @param <T> type
      * @see Float#equals(Object)
      * @see Double#equals(Object)
      */
     public static <T> boolean isSubstitutable(T a, Object b) {
-        if (a == b) return true;
-        if (a == null || b == null) return false;
-        if (a.getClass() != b.getClass()) return false;
-        return isSubstitutable0(a, b);
-    }
-
-    /**
-     * Called directly from the VM.
-     *
-     * DO NOT: Use "==" or "!=" on args "a" and "b", with this code or any of
-     * its callees. Could be inside of if_acmp<eq|ne> bytecode implementation.
-     *
-     * @param a an object
-     * @param b an object to be compared with {@code a} for substitutability
-     * @return {@code true} if the arguments are substitutable to each other;
-     *         {@code false} otherwise.
-     * @param <T> type
-     */
-    private static <T> boolean isSubstitutable0(T a, Object b) {
         if (VERBOSE) {
             System.out.println("substitutable " + a + " vs " + b);
         }
 
+        // Called directly from the VM.
+        //
+        // DO NOT use "==" or "!=" on args "a" and "b", with this code or any of
+        // its callees. Could be inside of if_acmp<eq|ne> bytecode implementation.
+
         if (a == null && b == null) return true;
         if (a == null || b == null) return false;
         if (a.getClass() != b.getClass()) return false;
 
         try {
@@ -641,20 +539,74 @@
             return MethodHandleBuilder.primitiveEquals(type);
 
         if (type.isInlineClass())
             return SUBST_TEST_METHOD_HANDLES.get(type);
 
-        return MethodHandleBuilder.indirectTypeEquals(type);
+        return MethodHandleBuilder.referenceTypeEquals(type);
     }
 
     // store the method handle for value types in ClassValue
     private static ClassValue<MethodHandle> SUBST_TEST_METHOD_HANDLES = new ClassValue<>() {
         @Override protected MethodHandle computeValue(Class<?> type) {
             return MethodHandleBuilder.inlineTypeEquals(type);
         }
     };
 
+    /**
+     * Invoke the bootstrap methods hashCode for the given inline object.
+     * @param o the instance to hash.
+     * @return the hash code of the given inline object.
+     */
+    private static int inlineObjectHashCode(Object o) {
+        try {
+            Class<?> type = o.getClass();
+            // Note: javac disallows user to call super.hashCode if user implementated
+            // risk for recursion for experts crafting byte-code
+            if (!type.isInlineClass())
+                throw new InternalError("must be inline type: " + type.getName());
+            return (int) HASHCODE_METHOD_HANDLES.get(type).invoke(o);
+        } catch (Error|RuntimeException e) {
+            throw e;
+        } catch (Throwable e) {
+            if (VERBOSE) e.printStackTrace();
+            throw new InternalError(e);
+        }
+    }
+
+    private static ClassValue<MethodHandle> HASHCODE_METHOD_HANDLES = new ClassValue<>() {
+        @Override protected MethodHandle computeValue(Class<?> type) {
+            return MethodHandleBuilder.inlineTypeHashCode(type);
+        }
+    };
+
+    /**
+     * Invoke the bootstrap methods hashCode for the given inline object.
+     * @param o the instance to hash.
+     * @return the string representation of the given inline object.
+     */
+    static String inlineObjectToString(Object o) {
+        try {
+            Class<?> type = o.getClass();
+            // Note: javac disallows user to call super.hashCode if user implementated
+            // risk for recursion for experts crafting byte-code
+            if (!type.isInlineClass())
+                throw new InternalError("must be inline type: " + type.getName());
+            return (String) TOSTRING_METHOD_HANDLES.get(type).invoke(o);
+        } catch (Error|RuntimeException e) {
+            throw e;
+        } catch (Throwable e) {
+            if (VERBOSE) e.printStackTrace();
+            throw new InternalError(e);
+        }
+    }
+
+    private static ClassValue<MethodHandle> TOSTRING_METHOD_HANDLES = new ClassValue<>() {
+        @Override protected MethodHandle computeValue(Class<?> type) {
+            return MethodHandleBuilder.inlineTypeToString(type);
+        }
+    };
+
     private static final Comparator<MethodHandle> TYPE_SORTER = (mh1, mh2) -> {
         // sort the getters with the return type
         Class<?> t1 = mh1.type().returnType();
         Class<?> t2 = mh2.type().returnType();
         if (t1.isPrimitive()) {
diff a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
@@ -187,6 +187,8 @@
     /**
      * Var handle insert coordinates combinator.
      * Used by {@code jdk.incubator.foreign.MemoryHandles}.
      */
     VarHandle insertCoordinates(VarHandle target, int pos, Object... values);
+
+    String inlineObjectToString(Object o);
 }
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java
@@ -212,11 +212,10 @@
     public final Type systemType;
     public final Type autoCloseableType;
     public final Type trustMeType;
     public final Type lambdaMetafactory;
     public final Type stringConcatFactory;
-    public final Type valueBootstrapMethods;
     public final Type repeatableType;
     public final Type documentedType;
     public final Type elementTypeType;
     public final Type functionalInterfaceType;
     public final Type previewFeatureType;
@@ -591,11 +590,10 @@
                              autoCloseableType.tsym);
         trustMeType = enterClass("java.lang.SafeVarargs");
         nativeHeaderType = enterClass("java.lang.annotation.Native");
         lambdaMetafactory = enterClass("java.lang.invoke.LambdaMetafactory");
         stringConcatFactory = enterClass("java.lang.invoke.StringConcatFactory");
-        valueBootstrapMethods = enterClass("java.lang.invoke.ValueBootstrapMethods");
         functionalInterfaceType = enterClass("java.lang.FunctionalInterface");
         previewFeatureType = enterClass("jdk.internal.PreviewFeature");
         previewFeatureInternalType = enterSyntheticAnnotation("jdk.internal.PreviewFeature+Annotation");
         typeDescriptorType = enterClass("java.lang.invoke.TypeDescriptor");
         recordType = enterClass("java.lang.Record");
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
@@ -1082,13 +1082,10 @@
                     tree.defs.diff(alreadyEntered) : tree.defs;
             memberEnter.memberEnter(defsToEnter, env);
             if (isRecord) {
                 addRecordMembersIfNeeded(tree, env);
             }
-            if ((tree.mods.flags & (Flags.VALUE | Flags.INTERFACE)) == Flags.VALUE && !tree.sym.type.hasTag(ERROR)) {
-                addValueMembers(tree, env);
-            }
             if (tree.sym.isAnnotationType()) {
                 Assert.check(tree.sym.isCompleted());
                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
             }
         }
@@ -1157,59 +1154,10 @@
                           null,
                           null);
             memberEnter.memberEnter(valueOf, env);
         }
 
-        /** Add the implicit members for a value type to the parse tree and the symbol table.
-         */
-        private void addValueMembers(JCClassDecl tree, Env<AttrContext> env) {
-
-            boolean requireToString = true;
-
-            for (JCTree def : tree.defs) {
-                if (def.getTag() == METHODDEF) {
-                    JCMethodDecl methodDecl = (JCMethodDecl)def;
-                    if (methodDecl.sym != null
-                            && methodDecl.sym.type != null
-                            && !methodDecl.sym.type.isErroneous()
-                            && (methodDecl.sym.flags() & STATIC) == 0) {
-                        final List<Type> parameterTypes = methodDecl.sym.type.getParameterTypes();
-                        if (parameterTypes.size() == 0) {
-                            String name = methodDecl.name.toString();
-                            if (name.equals("toString")) {
-                                requireToString = false;
-                            }
-                        }
-                    }
-                }
-            }
-
-            if (requireToString) {
-                make.at(tree.pos);
-                // Make a body comprising { throw new RuntimeException(""Internal error: This method must have been replaced by javac"); }
-                JCBlock body = make.Block(Flags.SYNTHETIC, List.of(make.Throw(
-                        make.NewClass(null,
-                                null,
-                                make.Ident(names.fromString("RuntimeException")),
-                                List.of(make.Literal(CLASS, "Internal error: This method must have been replaced by javac")),
-                                null))));
-                // public String toString() { throw new RuntimeException(message); }
-                JCMethodDecl toString = make.
-                        MethodDef(make.Modifiers(Flags.PUBLIC | Flags.FINAL),
-                                names.toString,
-                                make.Ident(names.fromString("String")),
-                                List.nil(),
-                                List.nil(),
-                                List.nil(), // thrown
-                                body,
-                                null);
-                memberEnter.memberEnter(toString, env);
-                tree.defs = tree.defs.append(toString);
-            }
-
-        }
-
         JCMethodDecl getCanonicalConstructorDecl(JCClassDecl tree) {
             // let's check if there is a constructor with exactly the same arguments as the record components
             List<Type> recordComponentErasedTypes = types.erasure(TreeInfo.recordFields(tree).map(vd -> vd.sym.type));
             JCMethodDecl canonicalDecl = null;
             for (JCTree def : tree.defs) {
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java
@@ -1077,46 +1077,10 @@
             code.pendingStackMap = false;
 
             return startpcCrt;
         }
 
-        private void synthesizeValueMethod(JCMethodDecl methodDecl) {
-            if (!methodDecl.name.toString().equals("toString")) {
-                throw new AssertionError("Unexpected synthetic method body");
-            }
-
-            Name name = names.toString;
-            List<Type> argTypes = List.of(methodDecl.sym.owner.type);
-            Type resType = methodDecl.restype.type;
-
-            Type.MethodType indyType = new Type.MethodType(argTypes,
-                    resType,
-                    List.nil(),
-                    syms.methodClass);
-
-            List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,
-                                                syms.stringType,
-                                                syms.methodTypeType);
-
-            Symbol bsm = rs.resolveInternalMethod(methodDecl.pos(),
-                    getAttrEnv(),
-                    syms.valueBootstrapMethods,
-                    names.fromString("makeBootstrapMethod"),
-                    bsm_staticArgs,
-                    null);
-
-            Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(name,
-                    syms.noSymbol,
-                    ((MethodSymbol)bsm).asHandle(),
-                    indyType,
-                    List.nil().toArray(new LoadableConstant[0]));
-
-            code.emitop0(aload_0);
-            items.makeDynamicItem(dynSym).invoke();
-            code.emitop0(areturn);
-        }
-
     public void visitVarDef(JCVariableDecl tree) {
         VarSymbol v = tree.sym;
         if (tree.init != null) {
             checkStringConstant(tree.init.pos(), v.getConstValue());
             if (v.getConstValue() == null || varDebugInfo) {
@@ -1134,14 +1098,10 @@
 
     public void visitSkip(JCSkip tree) {
     }
 
     public void visitBlock(JCBlock tree) {
-        if ((tree.flags & SYNTHETIC) != 0 && env.tree.hasTag(METHODDEF) && (((JCMethodDecl) env.tree).sym.owner.flags() & VALUE) != 0) {
-            synthesizeValueMethod((JCMethodDecl) env.tree);
-            return;
-        }
         int limit = code.nextreg;
         Env<GenContext> localEnv = env.dup(tree, new GenContext());
         genStats(tree.stats, localEnv);
         // End the scope of all block-local variables in variable info.
         if (!env.tree.hasTag(METHODDEF)) {
diff a/test/jdk/valhalla/valuetypes/ObjectMethods.java b/test/jdk/valhalla/valuetypes/ObjectMethods.java
--- a/test/jdk/valhalla/valuetypes/ObjectMethods.java
+++ b/test/jdk/valhalla/valuetypes/ObjectMethods.java
@@ -55,11 +55,20 @@
                                         .setByte((byte)0x1)
                                         .setShort((short)3)
                                         .setLong(4L)
                                         .setPoint(Point.makePoint(200, 200))
                                         .setNumber(Value.Number.intValue(10)).build();
-
+    static final Value VALUE1 = new Value.Builder()
+                                        .setChar('z')
+                                        .setBoolean(false)
+                                        .setByte((byte)0x1)
+                                        .setShort((short)3)
+                                        .setLong(4L)
+                                        .setPoint(Point.makePoint(100, 100))
+                                        .setPointRef(Point.makePoint(200, 200))
+                                        .setReference(Point.makePoint(300, 300))
+                                        .setNumber(Value.Number.intValue(20)).build();
     @DataProvider(name="equalsTests")
     Object[][] equalsTests() {
         return new Object[][]{
             { P1, P1, true},
             { P1, Point.makePoint(1, 2), true},
@@ -124,25 +133,22 @@
     @DataProvider(name="toStringTests")
     Object[][] toStringTests() {
         return new Object[][] {
             { Point.makePoint(100, 200), "[Point x=100 y=200]" },
             { Line.makeLine(1, 2, 3, 4), "[Line p1=[Point x=1 y=2] p2=[Point x=3 y=4]]"},
-            { new Value.Builder()
-                       .setChar('z')
-                       .setBoolean(false)
-                       .setByte((byte)0x1)
-                       .setShort((short)3)
-                       .setLong(4L)
-                       .setPoint(Point.makePoint(200, 200))
-                       .setNumber(Value.Number.intValue(10)).build(),
+            { VALUE,
+              "[Value char_v=z byte_v=1 boolean_v=false int_v=0 short_v=3 long_v=4 double_v=0.0 " +
+              "float_v=0.0 number_v=[Value$IntValue i=10] point_v=[Point x=200 y=200] point_ref=null ref_v=null]" },
+            { VALUE1,
               "[Value char_v=z byte_v=1 boolean_v=false int_v=0 short_v=3 long_v=4 double_v=0.0 " +
-              "float_v=0.0 number_v=[Value$IntValue i=10] point_v=[Point x=200 y=200] ref_v=null]" },
+              "float_v=0.0 number_v=[Value$IntValue i=20] point_v=[Point x=100 y=100] " +
+              "point_ref=[Point x=200 y=200] ref_v=[Point x=300 y=300]]" },
             { new Value.Builder()
-                .setReference(List.of("ref"))
-                .setNumber(new Value.IntNumber(99)).build(),
+                        .setReference(List.of("ref"))
+                        .setNumber(new Value.IntNumber(99)).build(),
               "[Value char_v=\u0000 byte_v=0 boolean_v=false int_v=0 short_v=0 long_v=0 double_v=0.0 " +
-              "float_v=0.0 number_v=99 point_v=[Point x=0 y=0] ref_v=[ref]]" },
+              "float_v=0.0 number_v=99 point_v=[Point x=0 y=0] point_ref=null ref_v=[ref]]" },
             // enclosing instance field `this$0` should be filtered
             { MyValue1.default, "[ObjectMethods$MyValue1 p=[Point x=0 y=0] np=null]" },
             { new MyValue1(0,0, null), "[ObjectMethods$MyValue1 p=[Point x=0 y=0] np=null]" },
             { new MyValue1(0,0, P1), "[ObjectMethods$MyValue1 p=[Point x=0 y=0] np=[Point x=1 y=2]]" },
         };
@@ -153,26 +159,16 @@
         assertTrue(o.toString().equals(s), o.toString());
     }
 
     @DataProvider(name="hashcodeTests")
     Object[][] hashcodeTests() {
-        Value v = new Value.Builder()
-                           .setChar('z')
-                           .setBoolean(false)
-                           .setByte((byte)0x1)
-                           .setShort((short)3)
-                           .setLong(4L)
-                           .setFloat(1.2f)
-                           .setDouble(0.5)
-                           .setPoint(Point.makePoint(200, 200))
-                           .setNumber(Value.Number.intValue(10))
-                           .setReference(new Object()).build();
         // this is sensitive to the order of the returned fields from Class::getDeclaredFields
         return new Object[][]{
             { P1,                   hash(Point.class, 1, 2) },
             { LINE1,                hash(Line.class, Point.makePoint(1, 2), Point.makePoint(3, 4)) },
-            { v,                    hash(hashCodeComponents(v))},
+            { VALUE,                hash(hashCodeComponents(VALUE))},
+            { VALUE1,                hash(hashCodeComponents(VALUE1))},
             { Point.makePoint(0,0), hash(Point.class, 0, 0) },
             { Point.default,        hash(Point.class, 0, 0) },
             { MyValue1.default,     hash(MyValue1.class, Point.default, null) },
             { new MyValue1(0, 0, null), hash(MyValue1.class, Point.makePoint(0,0), null) },
         };
diff a/test/jdk/valhalla/valuetypes/SubstitutabilityTest.java b/test/jdk/valhalla/valuetypes/SubstitutabilityTest.java
--- a/test/jdk/valhalla/valuetypes/SubstitutabilityTest.java
+++ b/test/jdk/valhalla/valuetypes/SubstitutabilityTest.java
@@ -55,10 +55,14 @@
             new Object[] { box1, Point.makePoint(10, 10) },
             new Object[] { mpath, mpath},
             new Object[] { mixedValues, mixedValues},
             new Object[] { valueBuilder().setPoint(p1).build(),
                            valueBuilder().setPoint(Point.makePoint(10, 10)).build() },
+            new Object[] { valueBuilder().setPointRef(p2).build(),
+                           valueBuilder().setPointRef(Point.makePoint(20, 20)).build() },
+            new Object[] { valueBuilder().setReference(p2).build(),
+                           valueBuilder().setReference(Point.makePoint(20, 20)).build() },
             new Object[] { valueBuilder().setFloat(Float.NaN).setDouble(Double.NaN).setPoint(p1).build(),
                            valueBuilder().setFloat(Float.NaN).setDouble(Double.NaN).setPoint(l1.p1).build() },
             new Object[] { valueBuilder().setFloat(Float.NaN).setDouble(Double.NaN).setNumber(number).build(),
                            valueBuilder().setFloat(Float.NaN).setDouble(Double.NaN).setNumber(Value.Number.intValue(99)).build() },
             new Object[] { valueBuilder().setFloat(+0.0f).setDouble(+0.0).setReference(list).build(),
@@ -88,10 +92,12 @@
                            valueBuilder().setFloat(-0.0f).setDouble(+0.0).build() },
             new Object[] { valueBuilder().setFloat(+0.0f).setDouble(+0.0).build(),
                            valueBuilder().setFloat(+0.0f).setDouble(-0.0).build() },
             new Object[] { valueBuilder().setPoint(point).build(),
                            valueBuilder().setPoint(Point.makePoint(20, 20)).build() },
+            new Object[] { valueBuilder().setPointRef(point).build(),
+                           valueBuilder().setPointRef(Point.makePoint(20, 20)).build() },
             new Object[] { valueBuilder().setNumber(number).build(),
                            valueBuilder().setNumber(new Value.IntNumber(99)).build() },
             new Object[] { valueBuilder().setNumber(Value.Number.intValue(1)).build(),
                            valueBuilder().setNumber(Value.Number.shortValue((short)1)).build() },
             new Object[] { valueBuilder().setNumber(new Value.IntNumber(99)).build(),
@@ -191,20 +197,20 @@
 
     private static Object zerothElement(Object[] oa) {
         return oa[0];
     }
 
-    private static final Method IS_SUBSTITUTABLE0;
+    private static final Method IS_SUBSTITUTABLE;
     static {
         Method m = null;
         try {
-            m = ValueBootstrapMethods.class.getDeclaredMethod("isSubstitutable0", Object.class, Object.class);
+            m = ValueBootstrapMethods.class.getDeclaredMethod("isSubstitutable", Object.class, Object.class);
             m.setAccessible(true);
         } catch (ReflectiveOperationException e) {
             throw new RuntimeException(e);
         }
-        IS_SUBSTITUTABLE0 = m;
+        IS_SUBSTITUTABLE = m;
     }
     private static boolean isSubstitutable(Object a, Object b) throws ReflectiveOperationException {
-        return (boolean) IS_SUBSTITUTABLE0.invoke(null, a, b);
+        return (boolean) IS_SUBSTITUTABLE.invoke(null, a, b);
     }
 }
diff a/test/jdk/valhalla/valuetypes/Value.java b/test/jdk/valhalla/valuetypes/Value.java
--- a/test/jdk/valhalla/valuetypes/Value.java
+++ b/test/jdk/valhalla/valuetypes/Value.java
@@ -30,25 +30,13 @@
     long long_v;
     double double_v;
     float float_v;
     Number number_v;
     Point point_v;
+    Point.ref point_ref;
     Object ref_v;
 
-    Value() {
-        char_v = 'z';
-        byte_v = 0;
-        boolean_v = true;
-        int_v = 1;
-        short_v = 2;
-        long_v = 3;
-        float_v = 0.1f;
-        double_v = 0.2d;
-        number_v = null;
-        point_v = Point.makePoint(0,0);
-        ref_v = null;
-    }
     Value(char c, boolean z, byte b, int x, short y, long l, float f, double d, Number number, Point p, Object o) {
         char_v = c;
         byte_v = b;
         boolean_v = z;
         int_v = x;
@@ -56,13 +44,27 @@
         long_v = l;
         float_v = f;
         double_v = d;
         number_v = number;
         point_v = p;
+        point_ref = null;
+        ref_v = o;
+    }
+    Value(char c, boolean z, byte b, int x, short y, long l, float f, double d, Number number, Point p, Point.ref pref, Object o) {
+        char_v = c;
+        byte_v = b;
+        boolean_v = z;
+        int_v = x;
+        short_v = y;
+        long_v = l;
+        float_v = f;
+        double_v = d;
+        number_v = number;
+        point_v = p;
+        point_ref = pref;
         ref_v = o;
     }
-
     static class Builder {
         private char c;
         private byte b;
         private boolean z;
         private int i;
@@ -70,10 +72,11 @@
         private long l;
         private double d;
         private float f;
         private Number n;
         private Point p = Point.makePoint(0,0);
+        private Point.ref pref;
         private Object ref;
 
         public Builder() {}
         Builder setChar(char c) {
             this.c = c;
@@ -113,16 +116,20 @@
         }
         Builder setPoint(Point p) {
             this.p = p;
             return this;
         }
+        Builder setPointRef(Point p) {
+            this.pref = p;
+            return this;
+        }
         Builder setReference(Object o) {
             this.ref = o;
             return this;
         }
         Value build() {
-            return new Value(c, z, b, i, s, l, f, d, n, p, ref);
+            return new Value(c, z, b, i, s, l, f, d, n, p, pref, ref);
         }
     }
 
     interface Number {
         default int intValue() {
diff a/test/langtools/tools/javac/valhalla/lworld-values/ValueModifierTest.out b/test/langtools/tools/javac/valhalla/lworld-values/ValueModifierTest.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/ValueModifierTest.out
+++ b/test/langtools/tools/javac/valhalla/lworld-values/ValueModifierTest.out
@@ -1,5 +1,5 @@
 ValueModifierTest.java:15:13: compiler.err.cant.inherit.from.final: value
 ValueModifierTest.java:15:21: compiler.err.concrete.supertype.for.inline.class: compiler.misc.anonymous.class: ValueModifierTest$2, value
 ValueModifierTest.java:16:20: compiler.err.cant.inherit.from.final: value
-ValueModifierTest.java:16:28: compiler.err.override.meth: (compiler.misc.cant.override: toString(), compiler.misc.anonymous.class: ValueModifierTest$3, toString(), value), final
+ValueModifierTest.java:16:28: compiler.err.concrete.supertype.for.inline.class: compiler.misc.anonymous.class: ValueModifierTest$3, value
 4 errors
