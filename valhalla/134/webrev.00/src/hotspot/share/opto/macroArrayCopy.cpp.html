<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/macroArrayCopy.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciFlatArrayKlass.hpp&quot;
  27 #include &quot;gc/shared/barrierSet.hpp&quot;
  28 #include &quot;opto/arraycopynode.hpp&quot;
  29 #include &quot;oops/objArrayKlass.hpp&quot;
  30 #include &quot;opto/convertnode.hpp&quot;
  31 #include &quot;opto/graphKit.hpp&quot;
  32 #include &quot;opto/macro.hpp&quot;
  33 #include &quot;opto/runtime.hpp&quot;
  34 #include &quot;utilities/align.hpp&quot;
  35 #include &quot;utilities/powerOfTwo.hpp&quot;
  36 
  37 void PhaseMacroExpand::insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent) {
  38   MemBarNode* mb = MemBarNode::make(C, opcode, Compile::AliasIdxBot, precedent);
  39   mb-&gt;init_req(TypeFunc::Control, *ctrl);
  40   mb-&gt;init_req(TypeFunc::Memory, *mem);
  41   transform_later(mb);
  42   *ctrl = new ProjNode(mb,TypeFunc::Control);
  43   transform_later(*ctrl);
  44   Node* mem_proj = new ProjNode(mb,TypeFunc::Memory);
  45   transform_later(mem_proj);
  46   *mem = mem_proj;
  47 }
  48 
  49 Node* PhaseMacroExpand::array_element_address(Node* ary, Node* idx, BasicType elembt) {
  50   uint shift  = exact_log2(type2aelembytes(elembt));
  51   uint header = arrayOopDesc::base_offset_in_bytes(elembt);
  52   Node* base =  basic_plus_adr(ary, header);
  53 #ifdef _LP64
  54   // see comment in GraphKit::array_element_address
  55   int index_max = max_jint - 1;  // array size is max_jint, index is one less
  56   const TypeLong* lidxtype = TypeLong::make(CONST64(0), index_max, Type::WidenMax);
  57   idx = transform_later( new ConvI2LNode(idx, lidxtype) );
  58 #endif
  59   Node* scale = new LShiftXNode(idx, intcon(shift));
  60   transform_later(scale);
  61   return basic_plus_adr(ary, base, scale);
  62 }
  63 
  64 Node* PhaseMacroExpand::ConvI2L(Node* offset) {
  65   return transform_later(new ConvI2LNode(offset));
  66 }
  67 
  68 Node* PhaseMacroExpand::make_leaf_call(Node* ctrl, Node* mem,
  69                                        const TypeFunc* call_type, address call_addr,
  70                                        const char* call_name,
  71                                        const TypePtr* adr_type,
  72                                        Node* parm0, Node* parm1,
  73                                        Node* parm2, Node* parm3,
  74                                        Node* parm4, Node* parm5,
  75                                        Node* parm6, Node* parm7) {
  76   Node* call = new CallLeafNoFPNode(call_type, call_addr, call_name, adr_type);
  77   call-&gt;init_req(TypeFunc::Control, ctrl);
  78   call-&gt;init_req(TypeFunc::I_O    , top());
  79   call-&gt;init_req(TypeFunc::Memory , mem);
  80   call-&gt;init_req(TypeFunc::ReturnAdr, top());
  81   call-&gt;init_req(TypeFunc::FramePtr, top());
  82 
  83   // Hook each parm in order.  Stop looking at the first NULL.
  84   if (parm0 != NULL) { call-&gt;init_req(TypeFunc::Parms+0, parm0);
  85   if (parm1 != NULL) { call-&gt;init_req(TypeFunc::Parms+1, parm1);
  86   if (parm2 != NULL) { call-&gt;init_req(TypeFunc::Parms+2, parm2);
  87   if (parm3 != NULL) { call-&gt;init_req(TypeFunc::Parms+3, parm3);
  88   if (parm4 != NULL) { call-&gt;init_req(TypeFunc::Parms+4, parm4);
  89   if (parm5 != NULL) { call-&gt;init_req(TypeFunc::Parms+5, parm5);
  90   if (parm6 != NULL) { call-&gt;init_req(TypeFunc::Parms+6, parm6);
  91   if (parm7 != NULL) { call-&gt;init_req(TypeFunc::Parms+7, parm7);
  92     /* close each nested if ===&gt; */  } } } } } } } }
  93   assert(call-&gt;in(call-&gt;req()-1) != NULL, &quot;must initialize all parms&quot;);
  94 
  95   return call;
  96 }
  97 
  98 
  99 //------------------------------generate_guard---------------------------
 100 // Helper function for generating guarded fast-slow graph structures.
 101 // The given &#39;test&#39;, if true, guards a slow path.  If the test fails
 102 // then a fast path can be taken.  (We generally hope it fails.)
 103 // In all cases, GraphKit::control() is updated to the fast path.
 104 // The returned value represents the control for the slow path.
 105 // The return value is never &#39;top&#39;; it is either a valid control
 106 // or NULL if it is obvious that the slow path can never be taken.
 107 // Also, if region and the slow control are not NULL, the slow edge
 108 // is appended to the region.
 109 Node* PhaseMacroExpand::generate_guard(Node** ctrl, Node* test, RegionNode* region, float true_prob) {
 110   if ((*ctrl)-&gt;is_top()) {
 111     // Already short circuited.
 112     return NULL;
 113   }
 114   // Build an if node and its projections.
 115   // If test is true we take the slow path, which we assume is uncommon.
 116   if (_igvn.type(test) == TypeInt::ZERO) {
 117     // The slow branch is never taken.  No need to build this guard.
 118     return NULL;
 119   }
 120 
 121   IfNode* iff = new IfNode(*ctrl, test, true_prob, COUNT_UNKNOWN);
 122   transform_later(iff);
 123 
 124   Node* if_slow = new IfTrueNode(iff);
 125   transform_later(if_slow);
 126 
 127   if (region != NULL) {
 128     region-&gt;add_req(if_slow);
 129   }
 130 
 131   Node* if_fast = new IfFalseNode(iff);
 132   transform_later(if_fast);
 133 
 134   *ctrl = if_fast;
 135 
 136   return if_slow;
 137 }
 138 
 139 Node* PhaseMacroExpand::generate_slow_guard(Node** ctrl, Node* test, RegionNode* region) {
 140   return generate_guard(ctrl, test, region, PROB_UNLIKELY_MAG(3));
 141 }
 142 
 143 inline Node* PhaseMacroExpand::generate_fair_guard(Node** ctrl, Node* test, RegionNode* region) {
 144   return generate_guard(ctrl, test, region, PROB_FAIR);
 145 }
 146 
 147 void PhaseMacroExpand::generate_negative_guard(Node** ctrl, Node* index, RegionNode* region) {
 148   if ((*ctrl)-&gt;is_top())
 149     return;                // already stopped
 150   if (_igvn.type(index)-&gt;higher_equal(TypeInt::POS)) // [0,maxint]
 151     return;                // index is already adequately typed
 152   Node* cmp_lt = new CmpINode(index, intcon(0));
 153   transform_later(cmp_lt);
 154   Node* bol_lt = new BoolNode(cmp_lt, BoolTest::lt);
 155   transform_later(bol_lt);
 156   generate_guard(ctrl, bol_lt, region, PROB_MIN);
 157 }
 158 
 159 void PhaseMacroExpand::generate_limit_guard(Node** ctrl, Node* offset, Node* subseq_length, Node* array_length, RegionNode* region) {
 160   if ((*ctrl)-&gt;is_top())
 161     return;                // already stopped
 162   bool zero_offset = _igvn.type(offset) == TypeInt::ZERO;
 163   if (zero_offset &amp;&amp; subseq_length-&gt;eqv_uncast(array_length))
 164     return;                // common case of whole-array copy
 165   Node* last = subseq_length;
 166   if (!zero_offset) {            // last += offset
 167     last = new AddINode(last, offset);
 168     transform_later(last);
 169   }
 170   Node* cmp_lt = new CmpUNode(array_length, last);
 171   transform_later(cmp_lt);
 172   Node* bol_lt = new BoolNode(cmp_lt, BoolTest::lt);
 173   transform_later(bol_lt);
 174   generate_guard(ctrl, bol_lt, region, PROB_MIN);
 175 }
 176 
 177 Node* PhaseMacroExpand::generate_nonpositive_guard(Node** ctrl, Node* index, bool never_negative) {
 178   if ((*ctrl)-&gt;is_top())  return NULL;
 179 
 180   if (_igvn.type(index)-&gt;higher_equal(TypeInt::POS1)) // [1,maxint]
 181     return NULL;                // index is already adequately typed
 182   Node* cmp_le = new CmpINode(index, intcon(0));
 183   transform_later(cmp_le);
 184   BoolTest::mask le_or_eq = (never_negative ? BoolTest::eq : BoolTest::le);
 185   Node* bol_le = new BoolNode(cmp_le, le_or_eq);
 186   transform_later(bol_le);
 187   Node* is_notp = generate_guard(ctrl, bol_le, NULL, PROB_MIN);
 188 
 189   return is_notp;
 190 }
 191 
 192 Node* PhaseMacroExpand::generate_flattened_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
 193   assert(UseFlatArray, &quot;can never be flattened&quot;);
 194   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_vt_value);
 195 }
 196 
 197 Node* PhaseMacroExpand::generate_object_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region) {
 198   return generate_array_guard(ctrl, mem, obj_or_klass, region, Klass::_lh_array_tag_obj_value);
 199 }
 200 
 201 Node* PhaseMacroExpand::generate_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region, jint lh_con) {
 202   if ((*ctrl)-&gt;is_top())  return NULL;
 203 
 204   Node* kls = NULL;
 205   if (_igvn.type(obj_or_klass)-&gt;isa_oopptr()) {
 206     Node* k_adr = basic_plus_adr(obj_or_klass, oopDesc::klass_offset_in_bytes());
 207     kls = transform_later(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));
 208   } else {
 209     assert(_igvn.type(obj_or_klass)-&gt;isa_klassptr(), &quot;what else?&quot;);
 210     kls = obj_or_klass;
 211   }
 212   Node* layout_val = make_load(NULL, mem, kls, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);
 213 
 214   layout_val = transform_later(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
 215   Node* cmp = transform_later(new CmpINode(layout_val, intcon(lh_con)));
 216   Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));
 217 
 218   return generate_fair_guard(ctrl, bol, region);
 219 }
 220 
 221 void PhaseMacroExpand::finish_arraycopy_call(Node* call, Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type) {
 222   transform_later(call);
 223 
 224   *ctrl = new ProjNode(call,TypeFunc::Control);
 225   transform_later(*ctrl);
 226   Node* newmem = new ProjNode(call, TypeFunc::Memory);
 227   transform_later(newmem);
 228 
 229   uint alias_idx = C-&gt;get_alias_index(adr_type);
 230   if (alias_idx != Compile::AliasIdxBot) {
 231     *mem = MergeMemNode::make(*mem);
 232     (*mem)-&gt;set_memory_at(alias_idx, newmem);
 233   } else {
 234     *mem = MergeMemNode::make(newmem);
 235   }
 236   transform_later(*mem);
 237 }
 238 
 239 address PhaseMacroExpand::basictype2arraycopy(BasicType t,
 240                                               Node* src_offset,
 241                                               Node* dest_offset,
 242                                               bool disjoint_bases,
 243                                               const char* &amp;name,
 244                                               bool dest_uninitialized) {
 245   const TypeInt* src_offset_inttype  = _igvn.find_int_type(src_offset);;
 246   const TypeInt* dest_offset_inttype = _igvn.find_int_type(dest_offset);;
 247 
 248   bool aligned = false;
 249   bool disjoint = disjoint_bases;
 250 
 251   // if the offsets are the same, we can treat the memory regions as
 252   // disjoint, because either the memory regions are in different arrays,
 253   // or they are identical (which we can treat as disjoint.)  We can also
 254   // treat a copy with a destination index  less that the source index
 255   // as disjoint since a low-&gt;high copy will work correctly in this case.
 256   if (src_offset_inttype != NULL &amp;&amp; src_offset_inttype-&gt;is_con() &amp;&amp;
 257       dest_offset_inttype != NULL &amp;&amp; dest_offset_inttype-&gt;is_con()) {
 258     // both indices are constants
 259     int s_offs = src_offset_inttype-&gt;get_con();
 260     int d_offs = dest_offset_inttype-&gt;get_con();
 261     int element_size = type2aelembytes(t);
 262     aligned = ((arrayOopDesc::base_offset_in_bytes(t) + s_offs * element_size) % HeapWordSize == 0) &amp;&amp;
 263               ((arrayOopDesc::base_offset_in_bytes(t) + d_offs * element_size) % HeapWordSize == 0);
 264     if (s_offs &gt;= d_offs)  disjoint = true;
 265   } else if (src_offset == dest_offset &amp;&amp; src_offset != NULL) {
 266     // This can occur if the offsets are identical non-constants.
 267     disjoint = true;
 268   }
 269 
 270   return StubRoutines::select_arraycopy_function(t, aligned, disjoint, name, dest_uninitialized);
 271 }
 272 
 273 bool PhaseMacroExpand::can_try_zeroing_elimination(AllocateArrayNode* alloc,
 274                                                    Node* src,
 275                                                    Node* dest) const {
 276   const TypeAryPtr* top_dest = _igvn.type(dest)-&gt;isa_aryptr();
 277 
 278   if (top_dest != NULL) {
 279     if (top_dest-&gt;klass() == NULL) {
 280       return false;
 281     }
 282   }
 283 
 284   return ReduceBulkZeroing
 285     &amp;&amp; !(UseTLAB &amp;&amp; ZeroTLAB) // pointless if already zeroed
 286     &amp;&amp; !src-&gt;eqv_uncast(dest)
 287     &amp;&amp; alloc != NULL
 288     &amp;&amp; _igvn.find_int_con(alloc-&gt;in(AllocateNode::ALength), 1) &gt; 0
 289     &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_igvn);
 290 }
 291 
 292 #define XTOP LP64_ONLY(COMMA top())
 293 
 294 // Generate an optimized call to arraycopy.
 295 // Caller must guard against non-arrays.
 296 // Caller must determine a common array basic-type for both arrays.
 297 // Caller must validate offsets against array bounds.
 298 // The slow_region has already collected guard failure paths
 299 // (such as out of bounds length or non-conformable array types).
 300 // The generated code has this shape, in general:
 301 //
 302 //     if (length == 0)  return   // via zero_path
 303 //     slowval = -1
 304 //     if (types unknown) {
 305 //       slowval = call generic copy loop
 306 //       if (slowval == 0)  return  // via checked_path
 307 //     } else if (indexes in bounds) {
 308 //       if ((is object array) &amp;&amp; !(array type check)) {
 309 //         slowval = call checked copy loop
 310 //         if (slowval == 0)  return  // via checked_path
 311 //       } else {
 312 //         call bulk copy loop
 313 //         return  // via fast_path
 314 //       }
 315 //     }
 316 //     // adjust params for remaining work:
 317 //     if (slowval != -1) {
 318 //       n = -1^slowval; src_offset += n; dest_offset += n; length -= n
 319 //     }
 320 //   slow_region:
 321 //     call slow arraycopy(src, src_offset, dest, dest_offset, length)
 322 //     return  // via slow_call_path
 323 //
 324 // This routine is used from several intrinsics:  System.arraycopy,
 325 // Object.clone (the array subcase), and Arrays.copyOf[Range].
 326 //
 327 Node* PhaseMacroExpand::generate_arraycopy(ArrayCopyNode *ac, AllocateArrayNode* alloc,
 328                                            Node** ctrl, MergeMemNode* mem, Node** io,
 329                                            const TypePtr* adr_type,
 330                                            BasicType basic_elem_type,
 331                                            Node* src,  Node* src_offset,
 332                                            Node* dest, Node* dest_offset,
 333                                            Node* copy_length,
 334                                            Node* dest_length,
 335                                            bool disjoint_bases,
 336                                            bool length_never_negative,
 337                                            RegionNode* slow_region) {
 338   if (slow_region == NULL) {
 339     slow_region = new RegionNode(1);
 340     transform_later(slow_region);
 341   }
 342 
 343   bool  dest_uninitialized = false;
 344   Node* default_value = NULL;
 345   Node* raw_default_value = NULL;
 346 
 347   // See if this is the initialization of a newly-allocated array.
 348   // If so, we will take responsibility here for initializing it to zero.
 349   // (Note:  Because tightly_coupled_allocation performs checks on the
 350   // out-edges of the dest, we need to avoid making derived pointers
 351   // from it until we have checked its uses.)
 352   if (can_try_zeroing_elimination(alloc, src, dest) &amp;&amp;
 353       basic_elem_type != T_CONFLICT /* avoid corner case */) {
 354     // &quot;You break it, you buy it.&quot;
 355     InitializeNode* init = alloc-&gt;initialization();
 356     assert(init-&gt;is_complete(), &quot;we just did this&quot;);
 357     init-&gt;set_complete_with_arraycopy();
 358     assert(dest-&gt;is_CheckCastPP(), &quot;sanity&quot;);
 359     assert(dest-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
 360     adr_type = TypeRawPtr::BOTTOM;  // all initializations are into raw memory
 361     // From this point on, every exit path is responsible for
 362     // initializing any non-copied parts of the object to zero.
 363     // Also, if this flag is set we make sure that arraycopy interacts properly
 364     // with G1, eliding pre-barriers. See CR 6627983.
 365     dest_uninitialized = true;
 366     default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 367     raw_default_value = alloc-&gt;in(AllocateNode::RawDefaultValue);
 368   } else {
 369     // No zeroing elimination here.
 370     alloc             = NULL;
 371   }
 372 
 373   uint alias_idx = C-&gt;get_alias_index(adr_type);
 374 
 375   // Results are placed here:
 376   enum { fast_path        = 1,  // normal void-returning assembly stub
 377          checked_path     = 2,  // special assembly stub with cleanup
 378          slow_call_path   = 3,  // something went wrong; call the VM
 379          zero_path        = 4,  // bypass when length of copy is zero
 380          bcopy_path       = 5,  // copy primitive array by 64-bit blocks
 381          PATH_LIMIT       = 6
 382   };
 383   RegionNode* result_region = new RegionNode(PATH_LIMIT);
 384   PhiNode*    result_i_o    = new PhiNode(result_region, Type::ABIO);
 385   PhiNode*    result_memory = new PhiNode(result_region, Type::MEMORY, adr_type);
 386   assert(adr_type != TypePtr::BOTTOM, &quot;must be RawMem or a T[] slice&quot;);
 387   transform_later(result_region);
 388   transform_later(result_i_o);
 389   transform_later(result_memory);
 390 
 391   // The slow_control path:
 392   Node* slow_control;
 393   Node* slow_i_o = *io;
 394   Node* slow_mem = mem-&gt;memory_at(alias_idx);
 395   DEBUG_ONLY(slow_control = (Node*) badAddress);
 396 
 397   // Checked control path:
 398   Node* checked_control = top();
 399   Node* checked_mem     = NULL;
 400   Node* checked_i_o     = NULL;
 401   Node* checked_value   = NULL;
 402 
 403   if (basic_elem_type == T_CONFLICT) {
 404     assert(!dest_uninitialized, &quot;&quot;);
 405     Node* cv = generate_generic_arraycopy(ctrl, &amp;mem,
 406                                           adr_type,
 407                                           src, src_offset, dest, dest_offset,
 408                                           copy_length, dest_uninitialized);
 409     if (cv == NULL)  cv = intcon(-1);  // failure (no stub available)
 410     checked_control = *ctrl;
 411     checked_i_o     = *io;
 412     checked_mem     = mem-&gt;memory_at(alias_idx);
 413     checked_value   = cv;
 414     *ctrl = top();
 415   }
 416 
 417   Node* not_pos = generate_nonpositive_guard(ctrl, copy_length, length_never_negative);
 418   if (not_pos != NULL) {
 419     Node* local_ctrl = not_pos, *local_io = *io;
 420     MergeMemNode* local_mem = MergeMemNode::make(mem);
 421     transform_later(local_mem);
 422 
 423     // (6) length must not be negative.
 424     if (!length_never_negative) {
 425       generate_negative_guard(&amp;local_ctrl, copy_length, slow_region);
 426     }
 427 
 428     // copy_length is 0.
 429     if (dest_uninitialized) {
 430       assert(!local_ctrl-&gt;is_top(), &quot;no ctrl?&quot;);
 431       if (copy_length-&gt;eqv_uncast(dest_length)
 432           || _igvn.find_int_con(dest_length, 1) &lt;= 0) {
 433         // There is no zeroing to do. No need for a secondary raw memory barrier.
 434       } else {
 435         // Clear the whole thing since there are no source elements to copy.
 436         generate_clear_array(local_ctrl, local_mem,
 437                              adr_type, dest,
 438                              default_value, raw_default_value,
 439                              basic_elem_type,
 440                              intcon(0), NULL,
 441                              alloc-&gt;in(AllocateNode::AllocSize));
 442         // Use a secondary InitializeNode as raw memory barrier.
 443         // Currently it is needed only on this path since other
 444         // paths have stub or runtime calls as raw memory barriers.
 445         MemBarNode* mb = MemBarNode::make(C, Op_Initialize,
 446                                           Compile::AliasIdxRaw,
 447                                           top());
 448         transform_later(mb);
 449         mb-&gt;set_req(TypeFunc::Control,local_ctrl);
 450         mb-&gt;set_req(TypeFunc::Memory, local_mem-&gt;memory_at(Compile::AliasIdxRaw));
 451         local_ctrl = transform_later(new ProjNode(mb, TypeFunc::Control));
 452         local_mem-&gt;set_memory_at(Compile::AliasIdxRaw, transform_later(new ProjNode(mb, TypeFunc::Memory)));
 453 
 454         InitializeNode* init = mb-&gt;as_Initialize();
 455         init-&gt;set_complete(&amp;_igvn);  // (there is no corresponding AllocateNode)
 456       }
 457     }
 458 
 459     // Present the results of the fast call.
 460     result_region-&gt;init_req(zero_path, local_ctrl);
 461     result_i_o   -&gt;init_req(zero_path, local_io);
 462     result_memory-&gt;init_req(zero_path, local_mem-&gt;memory_at(alias_idx));
 463   }
 464 
 465   if (!(*ctrl)-&gt;is_top() &amp;&amp; dest_uninitialized) {
 466     // We have to initialize the *uncopied* part of the array to zero.
 467     // The copy destination is the slice dest[off..off+len].  The other slices
 468     // are dest_head = dest[0..off] and dest_tail = dest[off+len..dest.length].
 469     Node* dest_size   = alloc-&gt;in(AllocateNode::AllocSize);
 470     Node* dest_tail   = transform_later( new AddINode(dest_offset, copy_length));
 471 
 472     // If there is a head section that needs zeroing, do it now.
 473     if (_igvn.find_int_con(dest_offset, -1) != 0) {
 474       generate_clear_array(*ctrl, mem,
 475                            adr_type, dest,
 476                            default_value, raw_default_value,
 477                            basic_elem_type,
 478                            intcon(0), dest_offset,
 479                            NULL);
 480     }
 481 
 482     // Next, perform a dynamic check on the tail length.
 483     // It is often zero, and we can win big if we prove this.
 484     // There are two wins:  Avoid generating the ClearArray
 485     // with its attendant messy index arithmetic, and upgrade
 486     // the copy to a more hardware-friendly word size of 64 bits.
 487     Node* tail_ctl = NULL;
 488     if (!(*ctrl)-&gt;is_top() &amp;&amp; !dest_tail-&gt;eqv_uncast(dest_length)) {
 489       Node* cmp_lt   = transform_later( new CmpINode(dest_tail, dest_length) );
 490       Node* bol_lt   = transform_later( new BoolNode(cmp_lt, BoolTest::lt) );
 491       tail_ctl = generate_slow_guard(ctrl, bol_lt, NULL);
 492       assert(tail_ctl != NULL || !(*ctrl)-&gt;is_top(), &quot;must be an outcome&quot;);
 493     }
 494 
 495     // At this point, let&#39;s assume there is no tail.
 496     if (!(*ctrl)-&gt;is_top() &amp;&amp; alloc != NULL &amp;&amp; basic_elem_type != T_OBJECT) {
 497       // There is no tail.  Try an upgrade to a 64-bit copy.
 498       bool didit = false;
 499       {
 500         Node* local_ctrl = *ctrl, *local_io = *io;
 501         MergeMemNode* local_mem = MergeMemNode::make(mem);
 502         transform_later(local_mem);
 503 
 504         didit = generate_block_arraycopy(&amp;local_ctrl, &amp;local_mem, local_io,
 505                                          adr_type, basic_elem_type, alloc,
 506                                          src, src_offset, dest, dest_offset,
 507                                          dest_size, dest_uninitialized);
 508         if (didit) {
 509           // Present the results of the block-copying fast call.
 510           result_region-&gt;init_req(bcopy_path, local_ctrl);
 511           result_i_o   -&gt;init_req(bcopy_path, local_io);
 512           result_memory-&gt;init_req(bcopy_path, local_mem-&gt;memory_at(alias_idx));
 513         }
 514       }
 515       if (didit) {
 516         *ctrl = top();     // no regular fast path
 517       }
 518     }
 519 
 520     // Clear the tail, if any.
 521     if (tail_ctl != NULL) {
 522       Node* notail_ctl = (*ctrl)-&gt;is_top() ? NULL : *ctrl;
 523       *ctrl = tail_ctl;
 524       if (notail_ctl == NULL) {
 525         generate_clear_array(*ctrl, mem,
 526                              adr_type, dest,
 527                              default_value, raw_default_value,
 528                              basic_elem_type,
 529                              dest_tail, NULL,
 530                              dest_size);
 531       } else {
 532         // Make a local merge.
 533         Node* done_ctl = transform_later(new RegionNode(3));
 534         Node* done_mem = transform_later(new PhiNode(done_ctl, Type::MEMORY, adr_type));
 535         done_ctl-&gt;init_req(1, notail_ctl);
 536         done_mem-&gt;init_req(1, mem-&gt;memory_at(alias_idx));
 537         generate_clear_array(*ctrl, mem,
 538                              adr_type, dest,
 539                              default_value, raw_default_value,
 540                              basic_elem_type,
 541                              dest_tail, NULL,
 542                              dest_size);
 543         done_ctl-&gt;init_req(2, *ctrl);
 544         done_mem-&gt;init_req(2, mem-&gt;memory_at(alias_idx));
 545         *ctrl = done_ctl;
 546         mem-&gt;set_memory_at(alias_idx, done_mem);
 547       }
 548     }
 549   }
 550 
 551   BasicType copy_type = basic_elem_type;
 552   assert(basic_elem_type != T_ARRAY, &quot;caller must fix this&quot;);
 553   if (!(*ctrl)-&gt;is_top() &amp;&amp; copy_type == T_OBJECT) {
 554     // If src and dest have compatible element types, we can copy bits.
 555     // Types S[] and D[] are compatible if D is a supertype of S.
 556     //
 557     // If they are not, we will use checked_oop_disjoint_arraycopy,
 558     // which performs a fast optimistic per-oop check, and backs off
 559     // further to JVM_ArrayCopy on the first per-oop check that fails.
 560     // (Actually, we don&#39;t move raw bits only; the GC requires card marks.)
 561 
 562     // We don&#39;t need a subtype check for validated copies and Object[].clone()
 563     bool skip_subtype_check = ac-&gt;is_arraycopy_validated() || ac-&gt;is_copyof_validated() ||
 564                               ac-&gt;is_copyofrange_validated() || ac-&gt;is_clone_oop_array();
 565     if (!skip_subtype_check) {
 566       // Get the klass* for both src and dest
 567       Node* src_klass  = ac-&gt;in(ArrayCopyNode::SrcKlass);
 568       Node* dest_klass = ac-&gt;in(ArrayCopyNode::DestKlass);
 569 
 570       assert(src_klass != NULL &amp;&amp; dest_klass != NULL, &quot;should have klasses&quot;);
 571 
 572       // Generate the subtype check.
 573       // This might fold up statically, or then again it might not.
 574       //
 575       // Non-static example:  Copying List&lt;String&gt;.elements to a new String[].
 576       // The backing store for a List&lt;String&gt; is always an Object[],
 577       // but its elements are always type String, if the generic types
 578       // are correct at the source level.
 579       //
 580       // Test S[] against D[], not S against D, because (probably)
 581       // the secondary supertype cache is less busy for S[] than S.
 582       // This usually only matters when D is an interface.
 583       Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn);
 584       // Plug failing path into checked_oop_disjoint_arraycopy
 585       if (not_subtype_ctrl != top()) {
 586         Node* local_ctrl = not_subtype_ctrl;
 587         MergeMemNode* local_mem = MergeMemNode::make(mem);
 588         transform_later(local_mem);
 589 
 590         // (At this point we can assume disjoint_bases, since types differ.)
 591         int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
 592         Node* p1 = basic_plus_adr(dest_klass, ek_offset);
 593         Node* n1 = LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), p1, TypeRawPtr::BOTTOM);
 594         Node* dest_elem_klass = transform_later(n1);
 595         Node* cv = generate_checkcast_arraycopy(&amp;local_ctrl, &amp;local_mem,
 596                                                 adr_type,
 597                                                 dest_elem_klass,
 598                                                 src, src_offset, dest, dest_offset,
 599                                                 ConvI2X(copy_length), dest_uninitialized);
 600         if (cv == NULL)  cv = intcon(-1);  // failure (no stub available)
 601         checked_control = local_ctrl;
 602         checked_i_o     = *io;
 603         checked_mem     = local_mem-&gt;memory_at(alias_idx);
 604         checked_value   = cv;
 605       }
 606     }
 607     // At this point we know we do not need type checks on oop stores.
 608 
 609     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 610     if (!bs-&gt;array_copy_requires_gc_barriers(alloc != NULL, copy_type, false, BarrierSetC2::Expansion)) {
 611       // If we do not need gc barriers, copy using the jint or jlong stub.
 612       copy_type = LP64_ONLY(UseCompressedOops ? T_INT : T_LONG) NOT_LP64(T_INT);
 613       assert(type2aelembytes(basic_elem_type) == type2aelembytes(copy_type),
 614              &quot;sizes agree&quot;);
 615     }
 616   }
 617 
 618   if (!(*ctrl)-&gt;is_top()) {
 619     // Generate the fast path, if possible.
 620     Node* local_ctrl = *ctrl;
 621     MergeMemNode* local_mem = MergeMemNode::make(mem);
 622     transform_later(local_mem);
 623 
 624     generate_unchecked_arraycopy(&amp;local_ctrl, &amp;local_mem,
 625                                  adr_type, copy_type, disjoint_bases,
 626                                  src, src_offset, dest, dest_offset,
 627                                  ConvI2X(copy_length), dest_uninitialized);
 628 
 629     // Present the results of the fast call.
 630     result_region-&gt;init_req(fast_path, local_ctrl);
 631     result_i_o   -&gt;init_req(fast_path, *io);
 632     result_memory-&gt;init_req(fast_path, local_mem-&gt;memory_at(alias_idx));
 633   }
 634 
 635   // Here are all the slow paths up to this point, in one bundle:
 636   assert(slow_region != NULL, &quot;allocated on entry&quot;);
 637   slow_control = slow_region;
 638   DEBUG_ONLY(slow_region = (RegionNode*)badAddress);
 639 
 640   *ctrl = checked_control;
 641   if (!(*ctrl)-&gt;is_top()) {
 642     // Clean up after the checked call.
 643     // The returned value is either 0 or -1^K,
 644     // where K = number of partially transferred array elements.
 645     Node* cmp = new CmpINode(checked_value, intcon(0));
 646     transform_later(cmp);
 647     Node* bol = new BoolNode(cmp, BoolTest::eq);
 648     transform_later(bol);
 649     IfNode* iff = new IfNode(*ctrl, bol, PROB_MAX, COUNT_UNKNOWN);
 650     transform_later(iff);
 651 
 652     // If it is 0, we are done, so transfer to the end.
 653     Node* checks_done = new IfTrueNode(iff);
 654     transform_later(checks_done);
 655     result_region-&gt;init_req(checked_path, checks_done);
 656     result_i_o   -&gt;init_req(checked_path, checked_i_o);
 657     result_memory-&gt;init_req(checked_path, checked_mem);
 658 
 659     // If it is not zero, merge into the slow call.
 660     *ctrl = new IfFalseNode(iff);
 661     transform_later(*ctrl);
 662     RegionNode* slow_reg2 = new RegionNode(3);
 663     PhiNode*    slow_i_o2 = new PhiNode(slow_reg2, Type::ABIO);
 664     PhiNode*    slow_mem2 = new PhiNode(slow_reg2, Type::MEMORY, adr_type);
 665     transform_later(slow_reg2);
 666     transform_later(slow_i_o2);
 667     transform_later(slow_mem2);
 668     slow_reg2  -&gt;init_req(1, slow_control);
 669     slow_i_o2  -&gt;init_req(1, slow_i_o);
 670     slow_mem2  -&gt;init_req(1, slow_mem);
 671     slow_reg2  -&gt;init_req(2, *ctrl);
 672     slow_i_o2  -&gt;init_req(2, checked_i_o);
 673     slow_mem2  -&gt;init_req(2, checked_mem);
 674 
 675     slow_control = slow_reg2;
 676     slow_i_o     = slow_i_o2;
 677     slow_mem     = slow_mem2;
 678 
 679     if (alloc != NULL) {
 680       // We&#39;ll restart from the very beginning, after zeroing the whole thing.
 681       // This can cause double writes, but that&#39;s OK since dest is brand new.
 682       // So we ignore the low 31 bits of the value returned from the stub.
 683     } else {
 684       // We must continue the copy exactly where it failed, or else
 685       // another thread might see the wrong number of writes to dest.
 686       Node* checked_offset = new XorINode(checked_value, intcon(-1));
 687       Node* slow_offset    = new PhiNode(slow_reg2, TypeInt::INT);
 688       transform_later(checked_offset);
 689       transform_later(slow_offset);
 690       slow_offset-&gt;init_req(1, intcon(0));
 691       slow_offset-&gt;init_req(2, checked_offset);
 692 
 693       // Adjust the arguments by the conditionally incoming offset.
 694       Node* src_off_plus  = new AddINode(src_offset,  slow_offset);
 695       transform_later(src_off_plus);
 696       Node* dest_off_plus = new AddINode(dest_offset, slow_offset);
 697       transform_later(dest_off_plus);
 698       Node* length_minus  = new SubINode(copy_length, slow_offset);
 699       transform_later(length_minus);
 700 
 701       // Tweak the node variables to adjust the code produced below:
 702       src_offset  = src_off_plus;
 703       dest_offset = dest_off_plus;
 704       copy_length = length_minus;
 705     }
 706   }
 707   *ctrl = slow_control;
 708   if (!(*ctrl)-&gt;is_top()) {
 709     Node* local_ctrl = *ctrl, *local_io = slow_i_o;
 710     MergeMemNode* local_mem = MergeMemNode::make(mem);
 711     transform_later(local_mem);
 712 
 713     // Generate the slow path, if needed.
 714     local_mem-&gt;set_memory_at(alias_idx, slow_mem);
 715 
 716     if (dest_uninitialized) {
 717       generate_clear_array(local_ctrl, local_mem,
 718                            adr_type, dest,
 719                            default_value, raw_default_value,
 720                            basic_elem_type,
 721                            intcon(0), NULL,
 722                            alloc-&gt;in(AllocateNode::AllocSize));
 723     }
 724 
 725     local_mem = generate_slow_arraycopy(ac,
 726                                         &amp;local_ctrl, local_mem, &amp;local_io,
 727                                         adr_type,
 728                                         src, src_offset, dest, dest_offset,
 729                                         copy_length, /*dest_uninitialized*/false);
 730 
 731     result_region-&gt;init_req(slow_call_path, local_ctrl);
 732     result_i_o   -&gt;init_req(slow_call_path, local_io);
 733     result_memory-&gt;init_req(slow_call_path, local_mem-&gt;memory_at(alias_idx));
 734   } else {
 735     ShouldNotReachHere(); // no call to generate_slow_arraycopy:
 736                           // projections were not extracted
 737   }
 738 
 739   // Remove unused edges.
 740   for (uint i = 1; i &lt; result_region-&gt;req(); i++) {
 741     if (result_region-&gt;in(i) == NULL) {
 742       result_region-&gt;init_req(i, top());
 743     }
 744   }
 745 
 746   // Finished; return the combined state.
 747   *ctrl = result_region;
 748   *io = result_i_o;
 749   mem-&gt;set_memory_at(alias_idx, result_memory);
 750 
 751   // mem no longer guaranteed to stay a MergeMemNode
 752   Node* out_mem = mem;
 753   DEBUG_ONLY(mem = NULL);
 754 
 755   // The memory edges above are precise in order to model effects around
 756   // array copies accurately to allow value numbering of field loads around
 757   // arraycopy.  Such field loads, both before and after, are common in Java
 758   // collections and similar classes involving header/array data structures.
 759   //
 760   // But with low number of register or when some registers are used or killed
 761   // by arraycopy calls it causes registers spilling on stack. See 6544710.
 762   // The next memory barrier is added to avoid it. If the arraycopy can be
 763   // optimized away (which it can, sometimes) then we can manually remove
 764   // the membar also.
 765   //
 766   // Do not let reads from the cloned object float above the arraycopy.
 767   if (alloc != NULL &amp;&amp; !alloc-&gt;initialization()-&gt;does_not_escape()) {
 768     // Do not let stores that initialize this object be reordered with
 769     // a subsequent store that would make this object accessible by
 770     // other threads.
 771     insert_mem_bar(ctrl, &amp;out_mem, Op_MemBarStoreStore);
 772   } else if (InsertMemBarAfterArraycopy) {
 773     insert_mem_bar(ctrl, &amp;out_mem, Op_MemBarCPUOrder);
 774   } else if (adr_type == TypeRawPtr::BOTTOM) {
 775     // Do not let reads from the destination float above the arraycopy.
 776     // Since we cannot type the arrays, we don&#39;t know which slices
 777     // might be affected.  We could restrict this barrier only to those
 778     // memory slices which pertain to array elements--but don&#39;t bother.
 779     insert_mem_bar(ctrl, &amp;out_mem, Op_MemBarCPUOrder);
 780   }
 781 
 782   _igvn.replace_node(_memproj_fallthrough, out_mem);
 783   _igvn.replace_node(_ioproj_fallthrough, *io);
 784   _igvn.replace_node(_fallthroughcatchproj, *ctrl);
 785 
 786 #ifdef ASSERT
 787   const TypeOopPtr* dest_t = _igvn.type(dest)-&gt;is_oopptr();
 788   if (dest_t-&gt;is_known_instance()) {
 789     ArrayCopyNode* ac = NULL;
 790     assert(ArrayCopyNode::may_modify(dest_t, (*ctrl)-&gt;in(0)-&gt;as_MemBar(), &amp;_igvn, ac), &quot;dependency on arraycopy lost&quot;);
 791     assert(ac == NULL, &quot;no arraycopy anymore&quot;);
 792   }
 793 #endif
 794 
 795   return out_mem;
 796 }
 797 
 798 // Helper for initialization of arrays, creating a ClearArray.
 799 // It writes zero bits in [start..end), within the body of an array object.
 800 // The memory effects are all chained onto the &#39;adr_type&#39; alias category.
 801 //
 802 // Since the object is otherwise uninitialized, we are free
 803 // to put a little &quot;slop&quot; around the edges of the cleared area,
 804 // as long as it does not go back into the array&#39;s header,
 805 // or beyond the array end within the heap.
 806 //
 807 // The lower edge can be rounded down to the nearest jint and the
 808 // upper edge can be rounded up to the nearest MinObjAlignmentInBytes.
 809 //
 810 // Arguments:
 811 //   adr_type           memory slice where writes are generated
 812 //   dest               oop of the destination array
 813 //   basic_elem_type    element type of the destination
 814 //   slice_idx          array index of first element to store
 815 //   slice_len          number of elements to store (or NULL)
 816 //   dest_size          total size in bytes of the array object
 817 //
 818 // Exactly one of slice_len or dest_size must be non-NULL.
 819 // If dest_size is non-NULL, zeroing extends to the end of the object.
 820 // If slice_len is non-NULL, the slice_idx value must be a constant.
 821 void PhaseMacroExpand::generate_clear_array(Node* ctrl, MergeMemNode* merge_mem,
 822                                             const TypePtr* adr_type,
 823                                             Node* dest,
 824                                             Node* val,
 825                                             Node* raw_val,
 826                                             BasicType basic_elem_type,
 827                                             Node* slice_idx,
 828                                             Node* slice_len,
 829                                             Node* dest_size) {
 830   // one or the other but not both of slice_len and dest_size:
 831   assert((slice_len != NULL? 1: 0) + (dest_size != NULL? 1: 0) == 1, &quot;&quot;);
 832   if (slice_len == NULL)  slice_len = top();
 833   if (dest_size == NULL)  dest_size = top();
 834 
 835   uint alias_idx = C-&gt;get_alias_index(adr_type);
 836 
 837   // operate on this memory slice:
 838   Node* mem = merge_mem-&gt;memory_at(alias_idx); // memory slice to operate on
 839 
 840   // scaling and rounding of indexes:
 841   assert(basic_elem_type != T_INLINE_TYPE, &quot;should have been converted to a basic type copy&quot;);
 842   int scale = exact_log2(type2aelembytes(basic_elem_type));
 843   int abase = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 844   int clear_low = (-1 &lt;&lt; scale) &amp; (BytesPerInt  - 1);
 845   int bump_bit  = (-1 &lt;&lt; scale) &amp; BytesPerInt;
 846 
 847   // determine constant starts and ends
 848   const intptr_t BIG_NEG = -128;
 849   assert(BIG_NEG + 2*abase &lt; 0, &quot;neg enough&quot;);
 850   intptr_t slice_idx_con = (intptr_t) _igvn.find_int_con(slice_idx, BIG_NEG);
 851   intptr_t slice_len_con = (intptr_t) _igvn.find_int_con(slice_len, BIG_NEG);
 852   if (slice_len_con == 0) {
 853     return;                     // nothing to do here
 854   }
 855   intptr_t start_con = (abase + (slice_idx_con &lt;&lt; scale)) &amp; ~clear_low;
 856   intptr_t end_con   = _igvn.find_intptr_t_con(dest_size, -1);
 857   if (slice_idx_con &gt;= 0 &amp;&amp; slice_len_con &gt;= 0) {
 858     assert(end_con &lt; 0, &quot;not two cons&quot;);
 859     end_con = align_up(abase + ((slice_idx_con + slice_len_con) &lt;&lt; scale),
 860                        BytesPerLong);
 861   }
 862 
 863   if (start_con &gt;= 0 &amp;&amp; end_con &gt;= 0) {
 864     // Constant start and end.  Simple.
 865     mem = ClearArrayNode::clear_memory(ctrl, mem, dest, val, raw_val,
 866                                        start_con, end_con, &amp;_igvn);
 867   } else if (start_con &gt;= 0 &amp;&amp; dest_size != top()) {
 868     // Constant start, pre-rounded end after the tail of the array.
 869     Node* end = dest_size;
 870     mem = ClearArrayNode::clear_memory(ctrl, mem, dest, val, raw_val,
 871                                        start_con, end, &amp;_igvn);
 872   } else if (start_con &gt;= 0 &amp;&amp; slice_len != top()) {
 873     // Constant start, non-constant end.  End needs rounding up.
 874     // End offset = round_up(abase + ((slice_idx_con + slice_len) &lt;&lt; scale), 8)
 875     intptr_t end_base  = abase + (slice_idx_con &lt;&lt; scale);
 876     int      end_round = (-1 &lt;&lt; scale) &amp; (BytesPerLong  - 1);
 877     Node*    end       = ConvI2X(slice_len);
 878     if (scale != 0)
 879       end = transform_later(new LShiftXNode(end, intcon(scale) ));
 880     end_base += end_round;
 881     end = transform_later(new AddXNode(end, MakeConX(end_base)) );
 882     end = transform_later(new AndXNode(end, MakeConX(~end_round)) );
 883     mem = ClearArrayNode::clear_memory(ctrl, mem, dest, val, raw_val,
 884                                        start_con, end, &amp;_igvn);
 885   } else if (start_con &lt; 0 &amp;&amp; dest_size != top()) {
 886     // Non-constant start, pre-rounded end after the tail of the array.
 887     // This is almost certainly a &quot;round-to-end&quot; operation.
 888     Node* start = slice_idx;
 889     start = ConvI2X(start);
 890     if (scale != 0)
 891       start = transform_later(new LShiftXNode( start, intcon(scale) ));
 892     start = transform_later(new AddXNode(start, MakeConX(abase)) );
 893     if ((bump_bit | clear_low) != 0) {
 894       int to_clear = (bump_bit | clear_low);
 895       // Align up mod 8, then store a jint zero unconditionally
 896       // just before the mod-8 boundary.
 897       if (((abase + bump_bit) &amp; ~to_clear) - bump_bit
 898           &lt; arrayOopDesc::length_offset_in_bytes() + BytesPerInt) {
 899         bump_bit = 0;
 900         assert((abase &amp; to_clear) == 0, &quot;array base must be long-aligned&quot;);
 901       } else {
 902         // Bump &#39;start&#39; up to (or past) the next jint boundary:
 903         start = transform_later( new AddXNode(start, MakeConX(bump_bit)) );
 904         assert((abase &amp; clear_low) == 0, &quot;array base must be int-aligned&quot;);
 905       }
 906       // Round bumped &#39;start&#39; down to jlong boundary in body of array.
 907       start = transform_later(new AndXNode(start, MakeConX(~to_clear)) );
 908       if (bump_bit != 0) {
 909         // Store a zero to the immediately preceding jint:
 910         Node* x1 = transform_later(new AddXNode(start, MakeConX(-bump_bit)) );
 911         Node* p1 = basic_plus_adr(dest, x1);
 912         if (val == NULL) {
 913           assert(raw_val == NULL, &quot;val may not be null&quot;);
 914           mem = StoreNode::make(_igvn, ctrl, mem, p1, adr_type, intcon(0), T_INT, MemNode::unordered);
 915         } else {
 916           assert(_igvn.type(val)-&gt;isa_narrowoop(), &quot;should be narrow oop&quot;);
 917           mem = new StoreNNode(ctrl, mem, p1, adr_type, val, MemNode::unordered);
 918         }
 919         mem = transform_later(mem);
 920       }
 921     }
 922     Node* end = dest_size; // pre-rounded
 923     mem = ClearArrayNode::clear_memory(ctrl, mem, dest, raw_val,
 924                                        start, end, &amp;_igvn);
 925   } else {
 926     // Non-constant start, unrounded non-constant end.
 927     // (Nobody zeroes a random midsection of an array using this routine.)
 928     ShouldNotReachHere();       // fix caller
 929   }
 930 
 931   // Done.
 932   merge_mem-&gt;set_memory_at(alias_idx, mem);
 933 }
 934 
 935 bool PhaseMacroExpand::generate_block_arraycopy(Node** ctrl, MergeMemNode** mem, Node* io,
 936                                                 const TypePtr* adr_type,
 937                                                 BasicType basic_elem_type,
 938                                                 AllocateNode* alloc,
 939                                                 Node* src,  Node* src_offset,
 940                                                 Node* dest, Node* dest_offset,
 941                                                 Node* dest_size, bool dest_uninitialized) {
 942   // See if there is an advantage from block transfer.
 943   int scale = exact_log2(type2aelembytes(basic_elem_type));
 944   if (scale &gt;= LogBytesPerLong)
 945     return false;               // it is already a block transfer
 946 
 947   // Look at the alignment of the starting offsets.
 948   int abase = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 949 
 950   intptr_t src_off_con  = (intptr_t) _igvn.find_int_con(src_offset, -1);
 951   intptr_t dest_off_con = (intptr_t) _igvn.find_int_con(dest_offset, -1);
 952   if (src_off_con &lt; 0 || dest_off_con &lt; 0) {
 953     // At present, we can only understand constants.
 954     return false;
 955   }
 956 
 957   intptr_t src_off  = abase + (src_off_con  &lt;&lt; scale);
 958   intptr_t dest_off = abase + (dest_off_con &lt;&lt; scale);
 959 
 960   if (((src_off | dest_off) &amp; (BytesPerLong-1)) != 0) {
 961     // Non-aligned; too bad.
 962     // One more chance:  Pick off an initial 32-bit word.
 963     // This is a common case, since abase can be odd mod 8.
 964     if (((src_off | dest_off) &amp; (BytesPerLong-1)) == BytesPerInt &amp;&amp;
 965         ((src_off ^ dest_off) &amp; (BytesPerLong-1)) == 0) {
 966       Node* sptr = basic_plus_adr(src,  src_off);
 967       Node* dptr = basic_plus_adr(dest, dest_off);
 968       const TypePtr* s_adr_type = _igvn.type(sptr)-&gt;is_ptr();
 969       assert(s_adr_type-&gt;isa_aryptr(), &quot;impossible slice&quot;);
 970       uint s_alias_idx = C-&gt;get_alias_index(s_adr_type);
 971       uint d_alias_idx = C-&gt;get_alias_index(adr_type);
 972       bool is_mismatched = (basic_elem_type != T_INT);
 973       Node* sval = transform_later(
 974           LoadNode::make(_igvn, *ctrl, (*mem)-&gt;memory_at(s_alias_idx), sptr, s_adr_type,
 975                          TypeInt::INT, T_INT, MemNode::unordered, LoadNode::DependsOnlyOnTest,
 976                          false /*unaligned*/, is_mismatched));
 977       Node* st = transform_later(
 978           StoreNode::make(_igvn, *ctrl, (*mem)-&gt;memory_at(d_alias_idx), dptr, adr_type,
 979                           sval, T_INT, MemNode::unordered));
 980       if (is_mismatched) {
 981         st-&gt;as_Store()-&gt;set_mismatched_access();
 982       }
 983       (*mem)-&gt;set_memory_at(d_alias_idx, st);
 984       src_off += BytesPerInt;
 985       dest_off += BytesPerInt;
 986     } else {
 987       return false;
 988     }
 989   }
 990   assert(src_off % BytesPerLong == 0, &quot;&quot;);
 991   assert(dest_off % BytesPerLong == 0, &quot;&quot;);
 992 
 993   // Do this copy by giant steps.
 994   Node* sptr  = basic_plus_adr(src,  src_off);
 995   Node* dptr  = basic_plus_adr(dest, dest_off);
 996   Node* countx = dest_size;
 997   countx = transform_later(new SubXNode(countx, MakeConX(dest_off)));
 998   countx = transform_later(new URShiftXNode(countx, intcon(LogBytesPerLong)));
 999 
1000   bool disjoint_bases = true;   // since alloc != NULL
1001   generate_unchecked_arraycopy(ctrl, mem,
1002                                adr_type, T_LONG, disjoint_bases,
1003                                sptr, NULL, dptr, NULL, countx, dest_uninitialized);
1004 
1005   return true;
1006 }
1007 
1008 // Helper function; generates code for the slow case.
1009 // We make a call to a runtime method which emulates the native method,
1010 // but without the native wrapper overhead.
1011 MergeMemNode* PhaseMacroExpand::generate_slow_arraycopy(ArrayCopyNode *ac,
1012                                                         Node** ctrl, Node* mem, Node** io,
1013                                                         const TypePtr* adr_type,
1014                                                         Node* src,  Node* src_offset,
1015                                                         Node* dest, Node* dest_offset,
1016                                                         Node* copy_length, bool dest_uninitialized) {
1017   assert(!dest_uninitialized, &quot;Invariant&quot;);
1018 
1019   const TypeFunc* call_type = OptoRuntime::slow_arraycopy_Type();
1020   CallNode* call = new CallStaticJavaNode(call_type, OptoRuntime::slow_arraycopy_Java(),
1021                                           &quot;slow_arraycopy&quot;,
1022                                           ac-&gt;jvms()-&gt;bci(), TypePtr::BOTTOM);
1023 
1024   call-&gt;init_req(TypeFunc::Control, *ctrl);
1025   call-&gt;init_req(TypeFunc::I_O    , *io);
1026   call-&gt;init_req(TypeFunc::Memory , mem);
1027   call-&gt;init_req(TypeFunc::ReturnAdr, top());
1028   call-&gt;init_req(TypeFunc::FramePtr, top());
1029   call-&gt;init_req(TypeFunc::Parms+0, src);
1030   call-&gt;init_req(TypeFunc::Parms+1, src_offset);
1031   call-&gt;init_req(TypeFunc::Parms+2, dest);
1032   call-&gt;init_req(TypeFunc::Parms+3, dest_offset);
1033   call-&gt;init_req(TypeFunc::Parms+4, copy_length);
1034   call-&gt;copy_call_debug_info(&amp;_igvn, ac);
1035 
1036   call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
1037   _igvn.replace_node(ac, call);
1038   transform_later(call);
1039 
1040   extract_call_projections(call);
1041   *ctrl = _fallthroughcatchproj-&gt;clone();
1042   transform_later(*ctrl);
1043 
1044   Node* m = _memproj_fallthrough-&gt;clone();
1045   transform_later(m);
1046 
1047   uint alias_idx = C-&gt;get_alias_index(adr_type);
1048   MergeMemNode* out_mem;
1049   if (alias_idx != Compile::AliasIdxBot) {
1050     out_mem = MergeMemNode::make(mem);
1051     out_mem-&gt;set_memory_at(alias_idx, m);
1052   } else {
1053     out_mem = MergeMemNode::make(m);
1054   }
1055   transform_later(out_mem);
1056 
1057   *io = _ioproj_fallthrough-&gt;clone();
1058   transform_later(*io);
1059 
1060   return out_mem;
1061 }
1062 
1063 // Helper function; generates code for cases requiring runtime checks.
1064 Node* PhaseMacroExpand::generate_checkcast_arraycopy(Node** ctrl, MergeMemNode** mem,
1065                                                      const TypePtr* adr_type,
1066                                                      Node* dest_elem_klass,
1067                                                      Node* src,  Node* src_offset,
1068                                                      Node* dest, Node* dest_offset,
1069                                                      Node* copy_length, bool dest_uninitialized) {
1070   if ((*ctrl)-&gt;is_top())  return NULL;
1071 
1072   address copyfunc_addr = StubRoutines::checkcast_arraycopy(dest_uninitialized);
1073   if (copyfunc_addr == NULL) { // Stub was not generated, go slow path.
1074     return NULL;
1075   }
1076 
1077   // Pick out the parameters required to perform a store-check
1078   // for the target array.  This is an optimistic check.  It will
1079   // look in each non-null element&#39;s class, at the desired klass&#39;s
1080   // super_check_offset, for the desired klass.
1081   int sco_offset = in_bytes(Klass::super_check_offset_offset());
1082   Node* p3 = basic_plus_adr(dest_elem_klass, sco_offset);
1083   Node* n3 = new LoadINode(NULL, *mem /*memory(p3)*/, p3, _igvn.type(p3)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered);
1084   Node* check_offset = ConvI2X(transform_later(n3));
1085   Node* check_value  = dest_elem_klass;
1086 
1087   Node* src_start  = array_element_address(src,  src_offset,  T_OBJECT);
1088   Node* dest_start = array_element_address(dest, dest_offset, T_OBJECT);
1089 
1090   const TypeFunc* call_type = OptoRuntime::checkcast_arraycopy_Type();
1091   Node* call = make_leaf_call(*ctrl, *mem, call_type, copyfunc_addr, &quot;checkcast_arraycopy&quot;, adr_type,
1092                               src_start, dest_start, copy_length XTOP, check_offset XTOP, check_value);
1093 
1094   finish_arraycopy_call(call, ctrl, mem, adr_type);
1095 
1096   Node* proj =  new ProjNode(call, TypeFunc::Parms);
1097   transform_later(proj);
1098 
1099   return proj;
1100 }
1101 
1102 // Helper function; generates code for cases requiring runtime checks.
1103 Node* PhaseMacroExpand::generate_generic_arraycopy(Node** ctrl, MergeMemNode** mem,
1104                                                    const TypePtr* adr_type,
1105                                                    Node* src,  Node* src_offset,
1106                                                    Node* dest, Node* dest_offset,
1107                                                    Node* copy_length, bool dest_uninitialized) {
1108   if ((*ctrl)-&gt;is_top()) return NULL;
1109   assert(!dest_uninitialized, &quot;Invariant&quot;);
1110 
1111   address copyfunc_addr = StubRoutines::generic_arraycopy();
1112   if (copyfunc_addr == NULL) { // Stub was not generated, go slow path.
1113     return NULL;
1114   }
1115 
1116   const TypeFunc* call_type = OptoRuntime::generic_arraycopy_Type();
1117   Node* call = make_leaf_call(*ctrl, *mem, call_type, copyfunc_addr, &quot;generic_arraycopy&quot;, adr_type,
1118                               src, src_offset, dest, dest_offset, copy_length);
1119 
1120   finish_arraycopy_call(call, ctrl, mem, adr_type);
1121 
1122   Node* proj =  new ProjNode(call, TypeFunc::Parms);
1123   transform_later(proj);
1124 
1125   return proj;
1126 }
1127 
1128 // Helper function; generates the fast out-of-line call to an arraycopy stub.
1129 void PhaseMacroExpand::generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,
1130                                                     const TypePtr* adr_type,
1131                                                     BasicType basic_elem_type,
1132                                                     bool disjoint_bases,
1133                                                     Node* src,  Node* src_offset,
1134                                                     Node* dest, Node* dest_offset,
1135                                                     Node* copy_length, bool dest_uninitialized) {
1136   if ((*ctrl)-&gt;is_top()) return;
1137 
1138   Node* src_start  = src;
1139   Node* dest_start = dest;
1140   if (src_offset != NULL || dest_offset != NULL) {
1141     src_start =  array_element_address(src, src_offset, basic_elem_type);
1142     dest_start = array_element_address(dest, dest_offset, basic_elem_type);
1143   }
1144 
1145   // Figure out which arraycopy runtime method to call.
1146   const char* copyfunc_name = &quot;arraycopy&quot;;
1147   address     copyfunc_addr =
1148       basictype2arraycopy(basic_elem_type, src_offset, dest_offset,
1149                           disjoint_bases, copyfunc_name, dest_uninitialized);
1150 
1151   const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();
1152   Node* call = make_leaf_call(*ctrl, *mem, call_type, copyfunc_addr, copyfunc_name, adr_type,
1153                               src_start, dest_start, copy_length XTOP);
1154 
1155   finish_arraycopy_call(call, ctrl, mem, adr_type);
1156 }
1157 
1158 const TypePtr* PhaseMacroExpand::adjust_for_flat_array(const TypeAryPtr* top_dest, Node*&amp; src_offset,
1159                                                        Node*&amp; dest_offset, Node*&amp; length, BasicType&amp; dest_elem,
1160                                                        Node*&amp; dest_length) {
1161   assert(top_dest-&gt;klass()-&gt;is_flat_array_klass(), &quot;inconsistent&quot;);
1162   int elem_size = ((ciFlatArrayKlass*)top_dest-&gt;klass())-&gt;element_byte_size();
1163   if (elem_size &gt;= 8) {
1164     if (elem_size &gt; 8) {
1165       // treat as array of long but scale length, src offset and dest offset
1166       assert((elem_size % 8) == 0, &quot;not a power of 2?&quot;);
1167       int factor = elem_size / 8;
1168       length = transform_later(new MulINode(length, intcon(factor)));
1169       src_offset = transform_later(new MulINode(src_offset, intcon(factor)));
1170       dest_offset = transform_later(new MulINode(dest_offset, intcon(factor)));
1171       if (dest_length != NULL) {
1172         dest_length = transform_later(new MulINode(dest_length, intcon(factor)));
1173       }
1174       elem_size = 8;
1175     }
1176     dest_elem = T_LONG;
1177   } else if (elem_size == 4) {
1178     dest_elem = T_INT;
1179   } else if (elem_size == 2) {
1180     dest_elem = T_CHAR;
1181   } else if (elem_size == 1) {
1182     dest_elem = T_BYTE;
1183   } else {
1184     ShouldNotReachHere();
1185   }
1186   return TypeRawPtr::BOTTOM;
1187 }
1188 
1189 void PhaseMacroExpand::expand_arraycopy_node(ArrayCopyNode *ac) {
1190   Node* ctrl = ac-&gt;in(TypeFunc::Control);
1191   Node* io = ac-&gt;in(TypeFunc::I_O);
1192   Node* src = ac-&gt;in(ArrayCopyNode::Src);
1193   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
1194   Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
1195   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
1196   Node* length = ac-&gt;in(ArrayCopyNode::Length);
1197   MergeMemNode* merge_mem = NULL;
1198 
1199   if (ac-&gt;is_clonebasic()) {
1200     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1201     bs-&gt;clone_at_expansion(this, ac);
1202     return;
1203   } else if (ac-&gt;is_copyof() || ac-&gt;is_copyofrange() || ac-&gt;is_clone_oop_array()) {
1204     const Type* dest_type = _igvn.type(dest);
1205     const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
1206     BasicType dest_elem = T_OBJECT;
1207     if (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL) {
1208       dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1209     }
1210     if (dest_elem == T_ARRAY || (dest_elem == T_INLINE_TYPE &amp;&amp; top_dest-&gt;klass()-&gt;is_obj_array_klass())) {
1211       dest_elem = T_OBJECT;
1212     }
1213 
1214     Node* mem = ac-&gt;in(TypeFunc::Memory);
1215     merge_mem = MergeMemNode::make(mem);
1216     transform_later(merge_mem);
1217 
1218     AllocateArrayNode* alloc = NULL;
1219     if (ac-&gt;is_alloc_tightly_coupled()) {
1220       alloc = AllocateArrayNode::Ideal_array_allocation(dest, &amp;_igvn);
1221       assert(alloc != NULL, &quot;expect alloc&quot;);
1222     }
1223     assert(dest_elem != T_INLINE_TYPE || alloc != NULL, &quot;unsupported&quot;);
1224     Node* dest_length = (alloc != NULL) ? alloc-&gt;in(AllocateNode::ALength) : NULL;
1225 
1226     const TypePtr* adr_type = NULL;
1227     if (dest_elem == T_INLINE_TYPE) {
1228       adr_type = adjust_for_flat_array(top_dest, src_offset, dest_offset, length, dest_elem, dest_length);
1229     } else {
1230       adr_type = dest_type-&gt;is_oopptr()-&gt;add_offset(Type::OffsetBot);
1231       if (ac-&gt;_dest_type != TypeOopPtr::BOTTOM) {
1232         adr_type = ac-&gt;_dest_type-&gt;add_offset(Type::OffsetBot)-&gt;is_ptr();
1233       }
1234       if (ac-&gt;_src_type != ac-&gt;_dest_type) {
1235         adr_type = TypeRawPtr::BOTTOM;
1236       }
1237     }
1238     generate_arraycopy(ac, alloc, &amp;ctrl, merge_mem, &amp;io,
1239                        adr_type, dest_elem,
1240                        src, src_offset, dest, dest_offset, length,
1241                        dest_length,
1242                        true, !ac-&gt;is_copyofrange());
1243 
1244     return;
1245   }
1246 
1247   AllocateArrayNode* alloc = NULL;
1248   if (ac-&gt;is_alloc_tightly_coupled()) {
1249     alloc = AllocateArrayNode::Ideal_array_allocation(dest, &amp;_igvn);
1250     assert(alloc != NULL, &quot;expect alloc&quot;);
1251   }
1252 
1253   assert(ac-&gt;is_arraycopy() || ac-&gt;is_arraycopy_validated(), &quot;should be an arraycopy&quot;);
1254 
1255   // Compile time checks.  If any of these checks cannot be verified at compile time,
1256   // we do not make a fast path for this call.  Instead, we let the call remain as it
1257   // is.  The checks we choose to mandate at compile time are:
1258   //
1259   // (1) src and dest are arrays.
1260   const Type* src_type = src-&gt;Value(&amp;_igvn);
1261   const Type* dest_type = dest-&gt;Value(&amp;_igvn);
1262   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
1263   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
1264 
1265   BasicType src_elem = T_CONFLICT;
1266   BasicType dest_elem = T_CONFLICT;
1267 
1268   if (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL) {
1269     dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1270   }
1271   if (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL) {
1272     src_elem = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1273   }
1274   if (src_elem == T_ARRAY) {
1275     src_elem = T_OBJECT;
1276   } else if (src_elem == T_INLINE_TYPE &amp;&amp; top_src-&gt;klass()-&gt;is_obj_array_klass()) {
1277     if (top_src-&gt;klass_is_exact()) {
1278       src_elem = T_OBJECT;
1279     } else {
1280       assert(!top_src-&gt;klass()-&gt;is_inlinetype(), &quot;klass should be exact&quot;);
1281       src_elem = T_CONFLICT; // either flattened or not
1282     }
1283   }
1284   if (dest_elem == T_ARRAY) {
1285     dest_elem = T_OBJECT;
1286   } else if (dest_elem == T_INLINE_TYPE &amp;&amp; top_dest-&gt;klass()-&gt;is_obj_array_klass()) {
1287     if (top_dest-&gt;klass_is_exact()) {
1288       dest_elem = T_OBJECT;
1289     } else {
1290       assert(!top_dest-&gt;klass()-&gt;is_inlinetype(), &quot;klass should be exact&quot;);
1291       dest_elem = T_CONFLICT; // either flattened or not
1292     }
1293   }
1294 
1295   if (ac-&gt;is_arraycopy_validated() &amp;&amp;
1296       dest_elem != T_CONFLICT &amp;&amp;
1297       src_elem == T_CONFLICT) {
1298     src_elem = dest_elem;
1299   }
1300 
1301   if (src_elem == T_CONFLICT || dest_elem == T_CONFLICT) {
1302     // Conservatively insert a memory barrier on all memory slices.
1303     // Do not let writes into the source float below the arraycopy.
1304     {
1305       Node* mem = ac-&gt;in(TypeFunc::Memory);
1306       insert_mem_bar(&amp;ctrl, &amp;mem, Op_MemBarCPUOrder);
1307 
1308       merge_mem = MergeMemNode::make(mem);
1309       transform_later(merge_mem);
1310     }
1311 
1312     RegionNode* slow_region = new RegionNode(1);
1313     transform_later(slow_region);
1314 
1315     if (UseFlatArray &amp;&amp; (top_dest == NULL || !top_dest-&gt;is_not_flat())) {
1316       generate_flattened_array_guard(&amp;ctrl, merge_mem, dest, slow_region);
1317     }
1318 
1319     // Call StubRoutines::generic_arraycopy stub.
1320     Node* mem = generate_arraycopy(ac, NULL, &amp;ctrl, merge_mem, &amp;io,
1321                                    TypeRawPtr::BOTTOM, T_CONFLICT,
1322                                    src, src_offset, dest, dest_offset, length,
1323                                    NULL,
1324                                    // If a  negative length guard was generated for the ArrayCopyNode,
1325                                    // the length of the array can never be negative.
1326                                    false, ac-&gt;has_negative_length_guard(),
1327                                    slow_region);
1328 
1329     return;
1330   }
1331 
1332   assert(!ac-&gt;is_arraycopy_validated() || (src_elem == dest_elem &amp;&amp; dest_elem != T_VOID), &quot;validated but different basic types&quot;);
1333 
1334   // (2) src and dest arrays must have elements of the same BasicType
1335   // Figure out the size and type of the elements we will be copying.
1336   //
1337   // We have no stub to copy flattened inline type arrays with oop
1338   // fields if we need to emit write barriers.
1339   //
1340   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1341   if (src_elem != dest_elem || dest_elem == T_VOID) {
1342     // The component types are not the same or are not recognized.  Punt.
1343     // (But, avoid the native method wrapper to JVM_ArrayCopy.)
1344     {
1345       Node* mem = ac-&gt;in(TypeFunc::Memory);
1346       merge_mem = generate_slow_arraycopy(ac, &amp;ctrl, mem, &amp;io, TypePtr::BOTTOM, src, src_offset, dest, dest_offset, length, false);
1347     }
1348 
1349     _igvn.replace_node(_memproj_fallthrough, merge_mem);
1350     _igvn.replace_node(_ioproj_fallthrough, io);
1351     _igvn.replace_node(_fallthroughcatchproj, ctrl);
1352     return;
1353   }
1354 
1355   //---------------------------------------------------------------------------
1356   // We will make a fast path for this call to arraycopy.
1357 
1358   // We have the following tests left to perform:
1359   //
1360   // (3) src and dest must not be null.
1361   // (4) src_offset must not be negative.
1362   // (5) dest_offset must not be negative.
1363   // (6) length must not be negative.
1364   // (7) src_offset + length must not exceed length of src.
1365   // (8) dest_offset + length must not exceed length of dest.
1366   // (9) each element of an oop array must be assignable
1367 
1368   Node* mem = ac-&gt;in(TypeFunc::Memory);
1369   if (dest_elem == T_INLINE_TYPE) {
1370     // copy modifies more than 1 slice
1371     insert_mem_bar(&amp;ctrl, &amp;mem, Op_MemBarCPUOrder);
1372   }
1373 
1374   merge_mem = MergeMemNode::make(mem);
1375   transform_later(merge_mem);
1376 
1377   RegionNode* slow_region = new RegionNode(1);
1378   transform_later(slow_region);
1379 
1380   if (!ac-&gt;is_arraycopy_validated()) {
1381     // (3) operands must not be null
1382     // We currently perform our null checks with the null_check routine.
1383     // This means that the null exceptions will be reported in the caller
1384     // rather than (correctly) reported inside of the native arraycopy call.
1385     // This should be corrected, given time.  We do our null check with the
1386     // stack pointer restored.
1387     // null checks done library_call.cpp
1388 
1389     // (4) src_offset must not be negative.
1390     generate_negative_guard(&amp;ctrl, src_offset, slow_region);
1391 
1392     // (5) dest_offset must not be negative.
1393     generate_negative_guard(&amp;ctrl, dest_offset, slow_region);
1394 
1395     // (6) length must not be negative (moved to generate_arraycopy()).
1396     // generate_negative_guard(length, slow_region);
1397 
1398     // (7) src_offset + length must not exceed length of src.
1399     Node* alen = ac-&gt;in(ArrayCopyNode::SrcLen);
1400     assert(alen != NULL, &quot;need src len&quot;);
1401     generate_limit_guard(&amp;ctrl,
1402                          src_offset, length,
1403                          alen,
1404                          slow_region);
1405 
1406     // (8) dest_offset + length must not exceed length of dest.
1407     alen = ac-&gt;in(ArrayCopyNode::DestLen);
1408     assert(alen != NULL, &quot;need dest len&quot;);
1409     generate_limit_guard(&amp;ctrl,
1410                          dest_offset, length,
1411                          alen,
1412                          slow_region);
1413 
1414     // (9) each element of an oop array must be assignable
1415     // The generate_arraycopy subroutine checks this.
1416 
1417     if (dest_elem == T_OBJECT &amp;&amp; !top_dest-&gt;elem()-&gt;isa_inlinetype() &amp;&amp; !top_dest-&gt;is_not_flat()) {
1418       generate_flattened_array_guard(&amp;ctrl, merge_mem, dest, slow_region);
1419     }
1420 
1421     if (src_elem == T_OBJECT &amp;&amp; !top_src-&gt;elem()-&gt;isa_inlinetype() &amp;&amp; !top_src-&gt;is_not_flat()) {
1422       generate_flattened_array_guard(&amp;ctrl, merge_mem, src, slow_region);
1423     }
1424   }
1425 
1426   // This is where the memory effects are placed:
1427   const TypePtr* adr_type = NULL;
1428 
1429   Node* dest_length = alloc != NULL ? alloc-&gt;in(AllocateNode::ALength) : NULL;
1430 
1431   if (dest_elem == T_INLINE_TYPE) {
1432     adr_type = adjust_for_flat_array(top_dest, src_offset, dest_offset, length, dest_elem, dest_length);
1433   } else if (ac-&gt;_dest_type != TypeOopPtr::BOTTOM) {
1434     adr_type = ac-&gt;_dest_type-&gt;add_offset(Type::OffsetBot)-&gt;is_ptr();
1435   } else {
1436     adr_type = TypeAryPtr::get_array_body_type(dest_elem);
1437   }
1438 
1439   generate_arraycopy(ac, alloc, &amp;ctrl, merge_mem, &amp;io,
1440                      adr_type, dest_elem,
1441                      src, src_offset, dest, dest_offset, length,
1442                      dest_length,
1443                      // If a  negative length guard was generated for the ArrayCopyNode,
1444                      // the length of the array can never be negative.
1445                      false, ac-&gt;has_negative_length_guard(),
1446                      slow_region);
1447 }
    </pre>
  </body>
</html>