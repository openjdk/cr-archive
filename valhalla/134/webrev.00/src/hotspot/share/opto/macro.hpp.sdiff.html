<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroArrayCopy.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
174                                         Node* dest, Node* dest_offset,
175                                         Node* copy_length, bool dest_uninitialized);
176   Node* generate_checkcast_arraycopy(Node** ctrl, MergeMemNode** mem,
177                                      const TypePtr* adr_type,
178                                      Node* dest_elem_klass,
179                                      Node* src,  Node* src_offset,
180                                      Node* dest, Node* dest_offset,
181                                      Node* copy_length, bool dest_uninitialized);
182   Node* generate_generic_arraycopy(Node** ctrl, MergeMemNode** mem,
183                                    const TypePtr* adr_type,
184                                    Node* src,  Node* src_offset,
185                                    Node* dest, Node* dest_offset,
186                                    Node* copy_length, bool dest_uninitialized);
187   void generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,
188                                     const TypePtr* adr_type,
189                                     BasicType basic_elem_type,
190                                     bool disjoint_bases,
191                                     Node* src,  Node* src_offset,
192                                     Node* dest, Node* dest_offset,
193                                     Node* copy_length, bool dest_uninitialized);
<span class="line-modified">194   const TypePtr* adjust_parameters_for_vt(const TypeAryPtr* top_dest, Node*&amp; src_offset,</span>
<span class="line-modified">195                                           Node*&amp; dest_offset, Node*&amp; length, BasicType&amp; dest_elem,</span>
<span class="line-modified">196                                           Node*&amp; dest_length);</span>
197   void expand_arraycopy_node(ArrayCopyNode *ac);
198 
199   void expand_subtypecheck_node(SubTypeCheckNode *check);
200 
201   int replace_input(Node *use, Node *oldref, Node *newref);
202   Node* opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path = false);
203   void copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call);
204   CallNode* make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type, address slow_call,
205                            const char* leaf_name, Node* slow_path, Node* parm0, Node* parm1,
206                            Node* parm2);
207   void extract_call_projections(CallNode *call);
208 
209   Node* initialize_object(AllocateNode* alloc,
210                           Node* control, Node* rawmem, Node* object,
211                           Node* klass_node, Node* length,
212                           Node* size_in_bytes);
213 
214   Node* make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc);
215 
216   bool can_try_zeroing_elimination(AllocateArrayNode* alloc, Node* src, Node* dest) const;
</pre>
</td>
<td>
<hr />
<pre>
174                                         Node* dest, Node* dest_offset,
175                                         Node* copy_length, bool dest_uninitialized);
176   Node* generate_checkcast_arraycopy(Node** ctrl, MergeMemNode** mem,
177                                      const TypePtr* adr_type,
178                                      Node* dest_elem_klass,
179                                      Node* src,  Node* src_offset,
180                                      Node* dest, Node* dest_offset,
181                                      Node* copy_length, bool dest_uninitialized);
182   Node* generate_generic_arraycopy(Node** ctrl, MergeMemNode** mem,
183                                    const TypePtr* adr_type,
184                                    Node* src,  Node* src_offset,
185                                    Node* dest, Node* dest_offset,
186                                    Node* copy_length, bool dest_uninitialized);
187   void generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,
188                                     const TypePtr* adr_type,
189                                     BasicType basic_elem_type,
190                                     bool disjoint_bases,
191                                     Node* src,  Node* src_offset,
192                                     Node* dest, Node* dest_offset,
193                                     Node* copy_length, bool dest_uninitialized);
<span class="line-modified">194   const TypePtr* adjust_for_flat_array(const TypeAryPtr* top_dest, Node*&amp; src_offset,</span>
<span class="line-modified">195                                        Node*&amp; dest_offset, Node*&amp; length, BasicType&amp; dest_elem,</span>
<span class="line-modified">196                                        Node*&amp; dest_length);</span>
197   void expand_arraycopy_node(ArrayCopyNode *ac);
198 
199   void expand_subtypecheck_node(SubTypeCheckNode *check);
200 
201   int replace_input(Node *use, Node *oldref, Node *newref);
202   Node* opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path = false);
203   void copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call);
204   CallNode* make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type, address slow_call,
205                            const char* leaf_name, Node* slow_path, Node* parm0, Node* parm1,
206                            Node* parm2);
207   void extract_call_projections(CallNode *call);
208 
209   Node* initialize_object(AllocateNode* alloc,
210                           Node* control, Node* rawmem, Node* object,
211                           Node* klass_node, Node* length,
212                           Node* size_in_bytes);
213 
214   Node* make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc);
215 
216   bool can_try_zeroing_elimination(AllocateArrayNode* alloc, Node* src, Node* dest) const;
</pre>
</td>
</tr>
</table>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroArrayCopy.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>