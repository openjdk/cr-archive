<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.annotation.Inherited;
  30 import java.util.Collections;
  31 import java.util.EnumSet;
  32 import java.util.HashMap;
  33 import java.util.Map;
  34 import java.util.Set;
  35 import java.util.concurrent.Callable;
  36 import java.util.function.Supplier;
  37 
  38 import javax.lang.model.element.Element;
  39 import javax.lang.model.element.ElementKind;
  40 import javax.lang.model.element.ElementVisitor;
  41 import javax.lang.model.element.ExecutableElement;
  42 import javax.lang.model.element.Modifier;
  43 import javax.lang.model.element.ModuleElement;
  44 import javax.lang.model.element.NestingKind;
  45 import javax.lang.model.element.PackageElement;
  46 import javax.lang.model.element.RecordComponentElement;
  47 import javax.lang.model.element.TypeElement;
  48 import javax.lang.model.element.TypeParameterElement;
  49 import javax.lang.model.element.VariableElement;
  50 import javax.tools.JavaFileManager;
  51 import javax.tools.JavaFileObject;
  52 
  53 import com.sun.tools.javac.code.Kinds.Kind;
  54 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Attr;
  57 import com.sun.tools.javac.comp.AttrContext;
  58 import com.sun.tools.javac.comp.Env;
  59 import com.sun.tools.javac.jvm.*;
  60 import com.sun.tools.javac.jvm.PoolConstant;
  61 import com.sun.tools.javac.tree.JCTree;
  62 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
  63 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
  64 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  65 import com.sun.tools.javac.tree.JCTree.Tag;
  66 import com.sun.tools.javac.util.*;
  67 import com.sun.tools.javac.util.DefinedBy.Api;
  68 import com.sun.tools.javac.util.List;
  69 import com.sun.tools.javac.util.Name;
  70 
  71 import static com.sun.tools.javac.code.Flags.*;
  72 import static com.sun.tools.javac.code.Kinds.*;
  73 import static com.sun.tools.javac.code.Kinds.Kind.*;
  74 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  75 import com.sun.tools.javac.code.Scope.WriteableScope;
  76 import static com.sun.tools.javac.code.TypeTag.CLASS;
  77 import static com.sun.tools.javac.code.TypeTag.FORALL;
  78 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  79 import static com.sun.tools.javac.jvm.ByteCodes.iadd;
  80 import static com.sun.tools.javac.jvm.ByteCodes.ishll;
  81 import static com.sun.tools.javac.jvm.ByteCodes.lushrl;
  82 import static com.sun.tools.javac.jvm.ByteCodes.lxor;
  83 import static com.sun.tools.javac.jvm.ByteCodes.string_add;
  84 
  85 /** Root class for Java symbols. It contains subclasses
  86  *  for specific sorts of symbols, such as variables, methods and operators,
  87  *  types, packages. Each subclass is represented as a static inner class
  88  *  inside Symbol.
  89  *
  90  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  91  *  If you write code that depends on this, you do so at your own risk.
  92  *  This code and its internal interfaces are subject to change or
  93  *  deletion without notice.&lt;/b&gt;
  94  */
  95 public abstract class Symbol extends AnnoConstruct implements PoolConstant, Element {
  96 
  97     /** The kind of this symbol.
  98      *  @see Kinds
  99      */
 100     public Kind kind;
 101 
 102     /** The flags of this symbol.
 103      */
 104     public long flags_field;
 105 
 106     /** An accessor method for the flags of this symbol.
 107      *  Flags of class symbols should be accessed through the accessor
 108      *  method to make sure that the class symbol is loaded.
 109      */
 110     public long flags() { return flags_field; }
 111 
 112     /** The name of this symbol in Utf8 representation.
 113      */
 114     public Name name;
 115 
 116     /** The type of this symbol.
 117      */
 118     public Type type;
 119 
 120     /** The owner of this symbol.
 121      */
 122     public Symbol owner;
 123 
 124     /** The completer of this symbol.
 125      * This should never equal null (NULL_COMPLETER should be used instead).
 126      */
 127     public Completer completer;
 128 
 129     /** A cache for the type erasure of this symbol.
 130      */
 131     public Type erasure_field;
 132 
 133     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;annotations&quot;&gt;
 134 
 135     /** The attributes of this symbol are contained in this
 136      * SymbolMetadata. The SymbolMetadata instance is NOT immutable.
 137      */
 138     protected SymbolMetadata metadata;
 139 
 140 
 141     /** An accessor method for the attributes of this symbol.
 142      *  Attributes of class symbols should be accessed through the accessor
 143      *  method to make sure that the class symbol is loaded.
 144      */
 145     public List&lt;Attribute.Compound&gt; getRawAttributes() {
 146         return (metadata == null)
 147                 ? List.nil()
 148                 : metadata.getDeclarationAttributes();
 149     }
 150 
 151     /** An accessor method for the type attributes of this symbol.
 152      *  Attributes of class symbols should be accessed through the accessor
 153      *  method to make sure that the class symbol is loaded.
 154      */
 155     public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
 156         return (metadata == null)
 157                 ? List.nil()
 158                 : metadata.getTypeAttributes();
 159     }
 160 
 161     /** Fetch a particular annotation from a symbol. */
 162     public Attribute.Compound attribute(Symbol anno) {
 163         for (Attribute.Compound a : getRawAttributes()) {
 164             if (a.type.tsym == anno) return a;
 165         }
 166         return null;
 167     }
 168 
 169     public boolean annotationsPendingCompletion() {
 170         return metadata == null ? false : metadata.pendingCompletion();
 171     }
 172 
 173     public void appendAttributes(List&lt;Attribute.Compound&gt; l) {
 174         if (l.nonEmpty()) {
 175             initedMetadata().append(l);
 176         }
 177     }
 178 
 179     public void appendClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 180         if (l.nonEmpty()) {
 181             initedMetadata().appendClassInitTypeAttributes(l);
 182         }
 183     }
 184 
 185     public void appendInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 186         if (l.nonEmpty()) {
 187             initedMetadata().appendInitTypeAttributes(l);
 188         }
 189     }
 190 
 191     public void appendUniqueTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 192         if (l.nonEmpty()) {
 193             initedMetadata().appendUniqueTypes(l);
 194         }
 195     }
 196 
 197     public List&lt;Attribute.TypeCompound&gt; getClassInitTypeAttributes() {
 198         return (metadata == null)
 199                 ? List.nil()
 200                 : metadata.getClassInitTypeAttributes();
 201     }
 202 
 203     public List&lt;Attribute.TypeCompound&gt; getInitTypeAttributes() {
 204         return (metadata == null)
 205                 ? List.nil()
 206                 : metadata.getInitTypeAttributes();
 207     }
 208 
 209     public void setInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 210         initedMetadata().setInitTypeAttributes(l);
 211     }
 212 
 213     public void setClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 214         initedMetadata().setClassInitTypeAttributes(l);
 215     }
 216 
 217     public List&lt;Attribute.Compound&gt; getDeclarationAttributes() {
 218         return (metadata == null)
 219                 ? List.nil()
 220                 : metadata.getDeclarationAttributes();
 221     }
 222 
 223     public boolean hasAnnotations() {
 224         return (metadata != null &amp;&amp; !metadata.isEmpty());
 225     }
 226 
 227     public boolean hasTypeAnnotations() {
 228         return (metadata != null &amp;&amp; !metadata.isTypesEmpty());
 229     }
 230 
 231     public boolean isCompleted() {
 232         return completer.isTerminal();
 233     }
 234 
 235     public void prependAttributes(List&lt;Attribute.Compound&gt; l) {
 236         if (l.nonEmpty()) {
 237             initedMetadata().prepend(l);
 238         }
 239     }
 240 
 241     public void resetAnnotations() {
 242         initedMetadata().reset();
 243     }
 244 
 245     public void setAttributes(Symbol other) {
 246         if (metadata != null || other.metadata != null) {
 247             initedMetadata().setAttributes(other.metadata);
 248         }
 249     }
 250 
 251     public void setDeclarationAttributes(List&lt;Attribute.Compound&gt; a) {
 252         if (metadata != null || a.nonEmpty()) {
 253             initedMetadata().setDeclarationAttributes(a);
 254         }
 255     }
 256 
 257     public void setTypeAttributes(List&lt;Attribute.TypeCompound&gt; a) {
 258         if (metadata != null || a.nonEmpty()) {
 259             if (metadata == null)
 260                 metadata = new SymbolMetadata(this);
 261             metadata.setTypeAttributes(a);
 262         }
 263     }
 264 
 265     private SymbolMetadata initedMetadata() {
 266         if (metadata == null)
 267             metadata = new SymbolMetadata(this);
 268         return metadata;
 269     }
 270 
 271     /** This method is intended for debugging only. */
 272     public SymbolMetadata getMetadata() {
 273         return metadata;
 274     }
 275 
 276     // &lt;/editor-fold&gt;
 277 
 278     /** Construct a symbol with given kind, flags, name, type and owner.
 279      */
 280     public Symbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 281         this.kind = kind;
 282         this.flags_field = flags;
 283         this.type = type;
 284         this.owner = owner;
 285         this.completer = Completer.NULL_COMPLETER;
 286         this.erasure_field = null;
 287         this.name = name;
 288     }
 289 
 290     @Override
 291     public int poolTag() {
 292         throw new AssertionError(&quot;Invalid pool entry&quot;);
 293     }
 294 
 295     /** Clone this symbol with new owner.
 296      *  Legal only for fields and methods.
 297      */
 298     public Symbol clone(Symbol newOwner) {
 299         throw new AssertionError();
 300     }
 301 
 302     public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 303         return v.visitSymbol(this, p);
 304     }
 305 
 306     /** The Java source which this symbol represents.
 307      *  A description of this symbol; overrides Object.
 308      */
 309     public String toString() {
 310         return name.toString();
 311     }
 312 
 313     /** A Java source description of the location of this symbol; used for
 314      *  error reporting.
 315      *
 316      * @return null if the symbol is a package or a toplevel class defined in
 317      * the default package; otherwise, the owner symbol is returned
 318      */
 319     public Symbol location() {
 320         if (owner.name == null || (owner.name.isEmpty() &amp;&amp;
 321                                    (owner.flags() &amp; BLOCK) == 0 &amp;&amp;
 322                                    owner.kind != PCK &amp;&amp;
 323                                    owner.kind != TYP)) {
 324             return null;
 325         }
 326         return owner;
 327     }
 328 
 329     public Symbol location(Type site, Types types) {
 330         if (owner.name == null || owner.name.isEmpty()) {
 331             return location();
 332         }
 333         if (owner.type.hasTag(CLASS)) {
 334             Type ownertype = types.asOuterSuper(site, owner);
 335             if (ownertype != null) return ownertype.tsym;
 336         }
 337         return owner;
 338     }
 339 
 340     public Symbol baseSymbol() {
 341         return this;
 342     }
 343 
 344     /** The symbol&#39;s erased type.
 345      */
 346     public Type erasure(Types types) {
 347         if (erasure_field == null)
 348             erasure_field = types.erasure(type);
 349         return erasure_field;
 350     }
 351 
 352     /** The external type of a symbol. This is the symbol&#39;s erased type
 353      *  except for constructors of inner classes which get the enclosing
 354      *  instance class added as first argument.
 355      */
 356     public Type externalType(Types types) {
 357         Type t = erasure(types);
 358         if (name == name.table.names.init &amp;&amp; owner.hasOuterInstance()) {
 359             Type outerThisType = types.erasure(owner.type.getEnclosingType());
 360             return new MethodType(t.getParameterTypes().prepend(outerThisType),
 361                                   t.getReturnType(),
 362                                   t.getThrownTypes(),
 363                                   t.tsym);
 364         } else {
 365             return t;
 366         }
 367     }
 368 
 369     public boolean isDeprecated() {
 370         return (flags_field &amp; DEPRECATED) != 0;
 371     }
 372 
 373     public boolean hasDeprecatedAnnotation() {
 374         return (flags_field &amp; DEPRECATED_ANNOTATION) != 0;
 375     }
 376 
 377     public boolean isDeprecatedForRemoval() {
 378         return (flags_field &amp; DEPRECATED_REMOVAL) != 0;
 379     }
 380 
 381     public boolean isPreviewApi() {
 382         return (flags_field &amp; PREVIEW_API) != 0;
 383     }
 384 
 385     public boolean isDeprecatableViaAnnotation() {
 386         switch (getKind()) {
 387             case LOCAL_VARIABLE:
 388             case PACKAGE:
 389             case PARAMETER:
 390             case RESOURCE_VARIABLE:
 391             case EXCEPTION_PARAMETER:
 392                 return false;
 393             default:
 394                 return true;
 395         }
 396     }
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
 417     public boolean isValue() {
 418         return (flags() &amp; VALUE) != 0;
 419     }
 420 
 421     /**
 422      * Is this a *derived* reference projection symbol ??
 423      */
 424     public boolean isReferenceProjection() {
 425         return false;
 426     }
 427 
 428     /**
 429      * Return the value projection IFF &#39;this&#39; happens to be derived reference projection, null
 430      * otherwise.
 431      */
 432     public Symbol valueProjection() {
 433         return null;
 434     }
 435 
 436     /**
<a name="1" id="anc1"></a><span class="line-modified"> 437      * Return the reference projection IFF &#39;this&#39; happens to be inline class, null</span>
 438      * otherwise.
 439      */
 440     public Symbol referenceProjection() {
 441         return null;
 442     }
 443 
 444     public boolean isPublic() {
 445         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 446     }
 447 
 448     public boolean isEnum() {
 449         return (flags() &amp; ENUM) != 0;
 450     }
 451 
 452     public boolean isSealed() {
 453         return (flags_field &amp; SEALED) != 0;
 454     }
 455 
 456     public boolean isNonSealed() {
 457         return (flags_field &amp; NON_SEALED) != 0;
 458     }
 459 
 460     public boolean isFinal() {
 461         return (flags_field &amp; FINAL) != 0;
 462     }
 463 
 464    /** Is this symbol declared (directly or indirectly) local
 465      *  to a method or variable initializer?
 466      *  Also includes fields of inner classes which are in
 467      *  turn local to a method or variable initializer.
 468      */
 469     public boolean isLocal() {
 470         return
 471             (owner.kind.matches(KindSelector.VAL_MTH) ||
 472              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 473     }
 474 
 475     /** Has this symbol an empty name? This includes anonymous
 476      *  inner classes.
 477      */
 478     public boolean isAnonymous() {
 479         return name.isEmpty();
 480     }
 481 
 482     /** Is this symbol a constructor?
 483      */
 484     public boolean isConstructor() {
 485         return name == name.table.names.init &amp;&amp; (flags() &amp; STATIC) == 0;
 486     }
 487 
 488     /** Is this symbol a value factory?
 489      */
 490     public boolean isValueFactory() {
 491         return ((name == name.table.names.init &amp;&amp; this.type.getReturnType().tsym == this.owner));
 492     }
 493 
 494     public boolean isDynamic() {
 495         return false;
 496     }
 497 
 498     /** The fully qualified name of this symbol.
 499      *  This is the same as the symbol&#39;s name except for class symbols,
 500      *  which are handled separately.
 501      */
 502     public Name getQualifiedName() {
 503         return name;
 504     }
 505 
 506     /** The fully qualified name of this symbol after converting to flat
 507      *  representation. This is the same as the symbol&#39;s name except for
 508      *  class symbols, which are handled separately.
 509      */
 510     public Name flatName() {
 511         return getQualifiedName();
 512     }
 513 
 514     /** If this is a class or package, its members, otherwise null.
 515      */
 516     public WriteableScope members() {
 517         return null;
 518     }
 519 
 520     /** A class is an inner class if it it has an enclosing instance class.
 521      */
 522     public boolean isInner() {
 523         return kind == TYP &amp;&amp; type.getEnclosingType().hasTag(CLASS);
 524     }
 525 
 526     /** An inner class has an outer instance if it is not an interface
 527      *  it has an enclosing instance class which might be referenced from the class.
 528      *  Nested classes can see instance members of their enclosing class.
 529      *  Their constructors carry an additional this$n parameter, inserted
 530      *  implicitly by the compiler.
 531      *
 532      *  @see #isInner
 533      */
 534     public boolean hasOuterInstance() {
 535         return
 536             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 537     }
 538 
 539     /** The closest enclosing class of this symbol&#39;s declaration.
 540      *  Warning: this (misnamed) method returns the receiver itself
 541      *  when the receiver is a class (as opposed to its enclosing
 542      *  class as one may be misled to believe.)
 543      */
 544     public ClassSymbol enclClass() {
 545         Symbol c = this;
 546         while (c != null &amp;&amp;
 547                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 548             c = c.owner;
 549         }
 550         return (ClassSymbol)c;
 551     }
 552 
 553     /** The outermost class which indirectly owns this symbol.
 554      * &#39;outermost&#39; being a lexical construct, should transcend
 555      *  projections
 556      */
 557     public ClassSymbol outermostClass() {
 558         Symbol sym = this;
 559         Symbol prev = null;
 560         while (sym.kind != PCK) {
 561             prev = sym;
 562             sym = sym.owner;
 563         }
 564         return (ClassSymbol) (prev!= null &amp;&amp; prev.isReferenceProjection() ? prev.valueProjection() : prev);
 565     }
 566 
 567     /** The package which indirectly owns this symbol.
 568      */
 569     public PackageSymbol packge() {
 570         Symbol sym = this;
 571         while (sym.kind != PCK) {
 572             sym = sym.owner;
 573         }
 574         return (PackageSymbol) sym;
 575     }
 576 
 577     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 578      */
 579     public boolean isSubClass(Symbol base, Types types) {
 580         throw new AssertionError(&quot;isSubClass &quot; + this);
 581     }
 582 
 583     /** Fully check membership: hierarchy, protection, and hiding.
 584      *  Does not exclude methods not inherited due to overriding.
 585      */
 586     public boolean isMemberOf(TypeSymbol clazz, Types types) {
 587         return
 588             owner == clazz ||
 589             clazz.isSubClass(owner, types) &amp;&amp;
 590             isInheritedIn(clazz, types) &amp;&amp;
 591             !hiddenIn((ClassSymbol)clazz, types);
 592     }
 593 
 594     /** Is this symbol the same as or enclosed by the given class? */
 595     public boolean isEnclosedBy(ClassSymbol clazz) {
 596         for (Symbol sym = this; sym.kind != PCK; sym = sym.owner)
 597             if (sym == clazz) return true;
 598         return false;
 599     }
 600 
 601     private boolean hiddenIn(ClassSymbol clazz, Types types) {
 602         Symbol sym = hiddenInInternal(clazz, types);
 603         Assert.check(sym != null, &quot;the result of hiddenInInternal() can&#39;t be null&quot;);
 604         /* If we find the current symbol then there is no symbol hiding it
 605          */
 606         return sym != this;
 607     }
 608 
 609     /** This method looks in the supertypes graph that has the current class as the
 610      * initial node, till it finds the current symbol or another symbol that hides it.
 611      * If the current class has more than one supertype (extends one class and
 612      * implements one or more interfaces) then null can be returned, meaning that
 613      * a wrong path in the supertypes graph was selected. Null can only be returned
 614      * as a temporary value, as a result of the recursive call.
 615      */
 616     private Symbol hiddenInInternal(ClassSymbol currentClass, Types types) {
 617         if (currentClass == owner) {
 618             return this;
 619         }
 620         for (Symbol sym : currentClass.members().getSymbolsByName(name)) {
 621             if (sym.kind == kind &amp;&amp;
 622                     (kind != MTH ||
 623                     (sym.flags() &amp; STATIC) != 0 &amp;&amp;
 624                     types.isSubSignature(sym.type, type))) {
 625                 return sym;
 626             }
 627         }
 628         Symbol hiddenSym = null;
 629         for (Type st : types.interfaces(currentClass.type)
 630                 .prepend(types.supertype(currentClass.type))) {
 631             if (st != null &amp;&amp; (st.hasTag(CLASS))) {
 632                 Symbol sym = hiddenInInternal((ClassSymbol)st.tsym, types);
 633                 if (sym == this) {
 634                     return this;
 635                 } else if (sym != null) {
 636                     hiddenSym = sym;
 637                 }
 638             }
 639         }
 640         return hiddenSym;
 641     }
 642 
 643     /** Is this symbol accessible in a given class?
 644      *  PRE: If symbol&#39;s owner is a interface,
 645      *       it is already assumed that the interface is a superinterface
 646      *       the given class.
 647      *  @param clazz  The class for which we want to establish membership.
 648      *                This must be a subclass of the member&#39;s owner.
 649      */
 650     public final boolean isAccessibleIn(Symbol clazz, Types types) {
 651         switch ((int)(flags_field &amp; Flags.AccessFlags)) {
 652         default: // error recovery
 653         case PUBLIC:
 654             return true;
 655         case PRIVATE:
 656             return this.owner == clazz;
 657         case PROTECTED:
 658             // we model interfaces as extending Object
 659             return (clazz.flags() &amp; INTERFACE) == 0;
 660         case 0:
 661             PackageSymbol thisPackage = this.packge();
 662             for (Symbol sup = clazz;
 663                  sup != null &amp;&amp; sup != this.owner;
 664                  sup = types.supertype(sup.type).tsym) {
 665                 while (sup.type.hasTag(TYPEVAR))
 666                     sup = sup.type.getUpperBound().tsym;
 667                 if (sup.type.isErroneous())
 668                     return true; // error recovery
 669                 if ((sup.flags() &amp; COMPOUND) != 0)
 670                     continue;
 671                 if (sup.packge() != thisPackage)
 672                     return false;
 673             }
 674             return (clazz.flags() &amp; INTERFACE) == 0;
 675         }
 676     }
 677 
 678     /** Is this symbol inherited into a given class?
 679      *  PRE: If symbol&#39;s owner is a interface,
 680      *       it is already assumed that the interface is a superinterface
 681      *       of the given class.
 682      *  @param clazz  The class for which we want to establish membership.
 683      *                This must be a subclass of the member&#39;s owner.
 684      */
 685     public boolean isInheritedIn(Symbol clazz, Types types) {
 686         return isAccessibleIn(clazz, types);
 687     }
 688 
 689     /** The (variable or method) symbol seen as a member of given
 690      *  class type`site&#39; (this might change the symbol&#39;s type).
 691      *  This is used exclusively for producing diagnostics.
 692      */
 693     public Symbol asMemberOf(Type site, Types types) {
 694         throw new AssertionError();
 695     }
 696 
 697     /** Does this method symbol override `other&#39; symbol, when both are seen as
 698      *  members of class `origin&#39;?  It is assumed that _other is a member
 699      *  of origin.
 700      *
 701      *  It is assumed that both symbols have the same name.  The static
 702      *  modifier is ignored for this test.
 703      *
 704      *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
 705      */
 706     public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult) {
 707         return false;
 708     }
 709 
 710     /** Complete the elaboration of this symbol&#39;s definition.
 711      */
 712     public void complete() throws CompletionFailure {
 713         if (completer != Completer.NULL_COMPLETER) {
 714             Completer c = completer;
 715             completer = Completer.NULL_COMPLETER;
 716             c.complete(this);
 717         }
 718     }
 719 
 720     public void apiComplete() throws CompletionFailure {
 721         try {
 722             complete();
 723         } catch (CompletionFailure cf) {
 724             cf.dcfh.handleAPICompletionFailure(cf);
 725         }
 726     }
 727 
 728     /** True if the symbol represents an entity that exists.
 729      */
 730     public boolean exists() {
 731         return true;
 732     }
 733 
 734     @DefinedBy(Api.LANGUAGE_MODEL)
 735     public Type asType() {
 736         return type;
 737     }
 738 
 739     @DefinedBy(Api.LANGUAGE_MODEL)
 740     public Symbol getEnclosingElement() {
 741         return owner;
 742     }
 743 
 744     @DefinedBy(Api.LANGUAGE_MODEL)
 745     public ElementKind getKind() {
 746         return ElementKind.OTHER;       // most unkind
 747     }
 748 
 749     @DefinedBy(Api.LANGUAGE_MODEL)
 750     public Set&lt;Modifier&gt; getModifiers() {
 751         apiComplete();
 752         return Flags.asModifierSet(flags());
 753     }
 754 
 755     @DefinedBy(Api.LANGUAGE_MODEL)
 756     public Name getSimpleName() {
 757         return name;
 758     }
 759 
 760     /**
 761      * This is the implementation for {@code
 762      * javax.lang.model.element.Element.getAnnotationMirrors()}.
 763      */
 764     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 765     public List&lt;Attribute.Compound&gt; getAnnotationMirrors() {
 766         apiComplete();
 767         return getRawAttributes();
 768     }
 769 
 770 
 771     // TODO: getEnclosedElements should return a javac List, fix in FilteredMemberList
 772     @DefinedBy(Api.LANGUAGE_MODEL)
 773     public java.util.List&lt;Symbol&gt; getEnclosedElements() {
 774         return List.nil();
 775     }
 776 
 777     public List&lt;TypeVariableSymbol&gt; getTypeParameters() {
 778         ListBuffer&lt;TypeVariableSymbol&gt; l = new ListBuffer&lt;&gt;();
 779         for (Type t : type.getTypeArguments()) {
 780             Assert.check(t.tsym.getKind() == ElementKind.TYPE_PARAMETER);
 781             l.append((TypeVariableSymbol)t.tsym);
 782         }
 783         return l.toList();
 784     }
 785 
 786     public static class DelegatedSymbol&lt;T extends Symbol&gt; extends Symbol {
 787         protected T other;
 788         public DelegatedSymbol(T other) {
 789             super(other.kind, other.flags_field, other.name, other.type, other.owner);
 790             this.other = other;
 791         }
 792         public String toString() { return other.toString(); }
 793         public Symbol location() { return other.location(); }
 794         public Symbol location(Type site, Types types) { return other.location(site, types); }
 795         public Symbol baseSymbol() { return other; }
 796         public Type erasure(Types types) { return other.erasure(types); }
 797         public Type externalType(Types types) { return other.externalType(types); }
 798         public boolean isLocal() { return other.isLocal(); }
 799         public boolean isConstructor() { return other.isConstructor(); }
 800         public Name getQualifiedName() { return other.getQualifiedName(); }
 801         public Name flatName() { return other.flatName(); }
 802         public WriteableScope members() { return other.members(); }
 803         public boolean isInner() { return other.isInner(); }
 804         public boolean hasOuterInstance() { return other.hasOuterInstance(); }
 805         public ClassSymbol enclClass() { return other.enclClass(); }
 806         public ClassSymbol outermostClass() { return other.outermostClass(); }
 807         public PackageSymbol packge() { return other.packge(); }
 808         public boolean isSubClass(Symbol base, Types types) { return other.isSubClass(base, types); }
 809         public boolean isMemberOf(TypeSymbol clazz, Types types) { return other.isMemberOf(clazz, types); }
 810         public boolean isEnclosedBy(ClassSymbol clazz) { return other.isEnclosedBy(clazz); }
 811         public boolean isInheritedIn(Symbol clazz, Types types) { return other.isInheritedIn(clazz, types); }
 812         public Symbol asMemberOf(Type site, Types types) { return other.asMemberOf(site, types); }
 813         public void complete() throws CompletionFailure { other.complete(); }
 814 
 815         @DefinedBy(Api.LANGUAGE_MODEL)
 816         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 817             return other.accept(v, p);
 818         }
 819 
 820         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 821             return v.visitSymbol(other, p);
 822         }
 823 
 824         public T getUnderlyingSymbol() {
 825             return other;
 826         }
 827     }
 828 
 829     /** A base class for Symbols representing types.
 830      */
 831     public static abstract class TypeSymbol extends Symbol {
 832         public TypeSymbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 833             super(kind, flags, name, type, owner);
 834         }
 835         /** form a fully qualified name from a name and an owner
 836          */
 837         static public Name formFullName(Name name, Symbol owner) {
 838             if (owner == null) return name;
 839             if ((owner.kind != ERR) &amp;&amp;
 840                 (owner.kind.matches(KindSelector.VAL_MTH) ||
 841                  (owner.kind == TYP &amp;&amp; owner.type.hasTag(TYPEVAR))
 842                  )) return name;
 843             Name prefix = owner.getQualifiedName();
 844             if (prefix == null || prefix == prefix.table.names.empty)
 845                 return name;
 846             else return prefix.append(&#39;.&#39;, name);
 847         }
 848 
 849         /** form a fully qualified name from a name and an owner, after
 850          *  converting to flat representation
 851          */
 852         static public Name formFlatName(Name name, Symbol owner) {
 853             if (owner == null || owner.kind.matches(KindSelector.VAL_MTH) ||
 854                 (owner.kind == TYP &amp;&amp; owner.type.hasTag(TYPEVAR))
 855                 ) return name;
 856             char sep = owner.kind == TYP ? &#39;$&#39; : &#39;.&#39;;
 857             Name prefix = owner.flatName();
 858             if (prefix == null || prefix == prefix.table.names.empty)
 859                 return name;
 860             else return prefix.append(sep, name);
 861         }
 862 
 863         /**
 864          * A partial ordering between type symbols that refines the
 865          * class inheritance graph.
 866          *
 867          * Type variables always precede other kinds of symbols.
 868          */
 869         public final boolean precedes(TypeSymbol that, Types types) {
 870             if (this == that)
 871                 return false;
 872             if (type.hasTag(that.type.getTag())) {
 873                 if (type.hasTag(CLASS)) {
 874                     return
 875                         types.rank(that.type) &lt; types.rank(this.type) ||
 876                         types.rank(that.type) == types.rank(this.type) &amp;&amp;
 877                         that.getQualifiedName().compareTo(this.getQualifiedName()) &lt; 0;
 878                 } else if (type.hasTag(TYPEVAR)) {
 879                     return types.isSubtype(this.type, that.type);
 880                 }
 881             }
 882             return type.hasTag(TYPEVAR);
 883         }
 884 
 885         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 886         public List&lt;Symbol&gt; getEnclosedElements() {
 887             List&lt;Symbol&gt; list = List.nil();
 888             if (kind == TYP &amp;&amp; type.hasTag(TYPEVAR)) {
 889                 return list;
 890             }
 891             apiComplete();
 892             for (Symbol sym : members().getSymbols(NON_RECURSIVE)) {
 893                 sym.apiComplete();
 894                 if ((sym.flags() &amp; SYNTHETIC) == 0 &amp;&amp; sym.owner == this &amp;&amp; sym.kind != ERR) {
 895                     list = list.prepend(sym);
 896                 }
 897             }
 898             return list;
 899         }
 900 
 901         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
 902             Assert.error(&quot;Only on ClassSymbol&quot;);
 903             return null; //unreachable
 904         }
 905 
 906         public boolean isAnnotationType() { return false; }
 907 
 908         @Override
 909         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 910             return v.visitTypeSymbol(this, p);
 911         }
 912     }
 913 
 914     /**
 915      * Type variables are represented by instances of this class.
 916      */
 917     public static class TypeVariableSymbol
 918             extends TypeSymbol implements TypeParameterElement {
 919 
 920         public TypeVariableSymbol(long flags, Name name, Type type, Symbol owner) {
 921             super(TYP, flags, name, type, owner);
 922         }
 923 
 924         @DefinedBy(Api.LANGUAGE_MODEL)
 925         public ElementKind getKind() {
 926             return ElementKind.TYPE_PARAMETER;
 927         }
 928 
 929         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 930         public Symbol getGenericElement() {
 931             return owner;
 932         }
 933 
 934         @DefinedBy(Api.LANGUAGE_MODEL)
 935         public List&lt;Type&gt; getBounds() {
 936             TypeVar t = (TypeVar)type;
 937             Type bound = t.getUpperBound();
 938             if (!bound.isCompound())
 939                 return List.of(bound);
 940             ClassType ct = (ClassType)bound;
 941             if (!ct.tsym.erasure_field.isInterface()) {
 942                 return ct.interfaces_field.prepend(ct.supertype_field);
 943             } else {
 944                 // No superclass was given in bounds.
 945                 // In this case, supertype is Object, erasure is first interface.
 946                 return ct.interfaces_field;
 947             }
 948         }
 949 
 950         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 951         public List&lt;Attribute.Compound&gt; getAnnotationMirrors() {
 952             // Declaration annotations on type variables are stored in type attributes
 953             // on the owner of the TypeVariableSymbol
 954             List&lt;Attribute.TypeCompound&gt; candidates = owner.getRawTypeAttributes();
 955             int index = owner.getTypeParameters().indexOf(this);
 956             List&lt;Attribute.Compound&gt; res = List.nil();
 957             for (Attribute.TypeCompound a : candidates) {
 958                 if (isCurrentSymbolsAnnotation(a, index))
 959                     res = res.prepend(a);
 960             }
 961 
 962             return res.reverse();
 963         }
 964 
 965         // Helper to getAnnotation[s]
 966         @Override
 967         public &lt;A extends Annotation&gt; Attribute.Compound getAttribute(Class&lt;A&gt; annoType) {
 968             String name = annoType.getName();
 969 
 970             // Declaration annotations on type variables are stored in type attributes
 971             // on the owner of the TypeVariableSymbol
 972             List&lt;Attribute.TypeCompound&gt; candidates = owner.getRawTypeAttributes();
 973             int index = owner.getTypeParameters().indexOf(this);
 974             for (Attribute.TypeCompound anno : candidates)
 975                 if (isCurrentSymbolsAnnotation(anno, index) &amp;&amp;
 976                     name.contentEquals(anno.type.tsym.flatName()))
 977                     return anno;
 978 
 979             return null;
 980         }
 981             //where:
 982             boolean isCurrentSymbolsAnnotation(Attribute.TypeCompound anno, int index) {
 983                 return (anno.position.type == TargetType.CLASS_TYPE_PARAMETER ||
 984                         anno.position.type == TargetType.METHOD_TYPE_PARAMETER) &amp;&amp;
 985                         anno.position.parameter_index == index;
 986             }
 987 
 988 
 989         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 990         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 991             return v.visitTypeParameter(this, p);
 992         }
 993     }
 994     /** A class for module symbols.
 995      */
 996     public static class ModuleSymbol extends TypeSymbol
 997             implements ModuleElement {
 998 
 999         public Name version;
1000         public JavaFileManager.Location sourceLocation;
1001         public JavaFileManager.Location classLocation;
1002         public JavaFileManager.Location patchLocation;
1003         public JavaFileManager.Location patchOutputLocation;
1004 
1005         /** All directives, in natural order. */
1006         public List&lt;com.sun.tools.javac.code.Directive&gt; directives;
1007         public List&lt;com.sun.tools.javac.code.Directive.RequiresDirective&gt; requires;
1008         public List&lt;com.sun.tools.javac.code.Directive.ExportsDirective&gt; exports;
1009         public List&lt;com.sun.tools.javac.code.Directive.OpensDirective&gt; opens;
1010         public List&lt;com.sun.tools.javac.code.Directive.ProvidesDirective&gt; provides;
1011         public List&lt;com.sun.tools.javac.code.Directive.UsesDirective&gt; uses;
1012 
1013         public ClassSymbol module_info;
1014 
1015         public PackageSymbol unnamedPackage;
1016         public Map&lt;Name, PackageSymbol&gt; visiblePackages;
1017         public Set&lt;ModuleSymbol&gt; readModules;
1018         public List&lt;Symbol&gt; enclosedPackages = List.nil();
1019 
1020         public Completer usesProvidesCompleter = Completer.NULL_COMPLETER;
1021         public final Set&lt;ModuleFlags&gt; flags = EnumSet.noneOf(ModuleFlags.class);
1022         public final Set&lt;ModuleResolutionFlags&gt; resolutionFlags = EnumSet.noneOf(ModuleResolutionFlags.class);
1023 
1024         /**
1025          * Create a ModuleSymbol with an associated module-info ClassSymbol.
1026          */
1027         public static ModuleSymbol create(Name name, Name module_info) {
1028             ModuleSymbol msym = new ModuleSymbol(name, null);
1029             ClassSymbol info = new ClassSymbol(Flags.MODULE, module_info, msym);
1030             info.fullname = formFullName(module_info, msym);
1031             info.flatname = info.fullname;
1032             info.members_field = WriteableScope.create(info);
1033             msym.module_info = info;
1034             return msym;
1035         }
1036 
1037         public ModuleSymbol(Name name, Symbol owner) {
1038             super(MDL, 0, name, null, owner);
1039             Assert.checkNonNull(name);
1040             this.type = new ModuleType(this);
1041         }
1042 
1043         @Override
1044         public int poolTag() {
1045             return ClassFile.CONSTANT_Module;
1046         }
1047 
1048         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1049         public Name getSimpleName() {
1050             return Convert.shortName(name);
1051         }
1052 
1053         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1054         public boolean isOpen() {
1055             return flags.contains(ModuleFlags.OPEN);
1056         }
1057 
1058         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1059         public boolean isUnnamed() {
1060             return name.isEmpty() &amp;&amp; owner == null;
1061         }
1062 
1063         @Override
1064         public boolean isDeprecated() {
1065             return hasDeprecatedAnnotation();
1066         }
1067 
1068         public boolean isNoModule() {
1069             return false;
1070         }
1071 
1072         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1073         public ElementKind getKind() {
1074             return ElementKind.MODULE;
1075         }
1076 
1077         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1078         public java.util.List&lt;Directive&gt; getDirectives() {
1079             apiComplete();
1080             completeUsesProvides();
1081             return Collections.unmodifiableList(directives);
1082         }
1083 
1084         public void completeUsesProvides() {
1085             if (usesProvidesCompleter != Completer.NULL_COMPLETER) {
1086                 Completer c = usesProvidesCompleter;
1087                 usesProvidesCompleter = Completer.NULL_COMPLETER;
1088                 c.complete(this);
1089             }
1090         }
1091 
1092         @Override
1093         public ClassSymbol outermostClass() {
1094             return null;
1095         }
1096 
1097         @Override
1098         public String toString() {
1099             // TODO: the following strings should be localized
1100             // Do this with custom anon subtypes in Symtab
1101             String n = (name == null) ? &quot;&lt;unknown&gt;&quot;
1102                     : (name.isEmpty()) ? &quot;&lt;unnamed&gt;&quot;
1103                     : String.valueOf(name);
1104             return n;
1105         }
1106 
1107         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1108         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1109             return v.visitModule(this, p);
1110         }
1111 
1112         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1113         public List&lt;Symbol&gt; getEnclosedElements() {
1114             List&lt;Symbol&gt; list = List.nil();
1115             for (Symbol sym : enclosedPackages) {
1116                 if (sym.members().anyMatch(m -&gt; m.kind == TYP))
1117                     list = list.prepend(sym);
1118             }
1119             return list;
1120         }
1121 
1122         public void reset() {
1123             this.directives = null;
1124             this.requires = null;
1125             this.exports = null;
1126             this.provides = null;
1127             this.uses = null;
1128             this.visiblePackages = null;
1129         }
1130 
1131     }
1132 
1133     public enum ModuleFlags {
1134         OPEN(0x0020),
1135         SYNTHETIC(0x1000),
1136         MANDATED(0x8000);
1137 
1138         public static int value(Set&lt;ModuleFlags&gt; s) {
1139             int v = 0;
1140             for (ModuleFlags f: s)
1141                 v |= f.value;
1142             return v;
1143         }
1144 
1145         private ModuleFlags(int value) {
1146             this.value = value;
1147         }
1148 
1149         public final int value;
1150     }
1151 
1152     public enum ModuleResolutionFlags {
1153         DO_NOT_RESOLVE_BY_DEFAULT(0x0001),
1154         WARN_DEPRECATED(0x0002),
1155         WARN_DEPRECATED_REMOVAL(0x0004),
1156         WARN_INCUBATING(0x0008);
1157 
1158         public static int value(Set&lt;ModuleResolutionFlags&gt; s) {
1159             int v = 0;
1160             for (ModuleResolutionFlags f: s)
1161                 v |= f.value;
1162             return v;
1163         }
1164 
1165         private ModuleResolutionFlags(int value) {
1166             this.value = value;
1167         }
1168 
1169         public final int value;
1170     }
1171 
1172     /** A class for package symbols
1173      */
1174     public static class PackageSymbol extends TypeSymbol
1175         implements PackageElement {
1176 
1177         public WriteableScope members_field;
1178         public Name fullname;
1179         public ClassSymbol package_info; // see bug 6443073
1180         public ModuleSymbol modle;
1181         // the file containing the documentation comments for the package
1182         public JavaFileObject sourcefile;
1183 
1184         public PackageSymbol(Name name, Type type, Symbol owner) {
1185             super(PCK, 0, name, type, owner);
1186             this.members_field = null;
1187             this.fullname = formFullName(name, owner);
1188         }
1189 
1190         public PackageSymbol(Name name, Symbol owner) {
1191             this(name, null, owner);
1192             this.type = new PackageType(this);
1193         }
1194 
1195         public String toString() {
1196             return fullname.toString();
1197         }
1198 
1199         @DefinedBy(Api.LANGUAGE_MODEL)
1200         public Name getQualifiedName() {
1201             return fullname;
1202         }
1203 
1204         @DefinedBy(Api.LANGUAGE_MODEL)
1205         public boolean isUnnamed() {
1206             return name.isEmpty() &amp;&amp; owner != null;
1207         }
1208 
1209         public WriteableScope members() {
1210             complete();
1211             return members_field;
1212         }
1213 
1214         @Override
1215         public int poolTag() {
1216             return ClassFile.CONSTANT_Package;
1217         }
1218 
1219         public long flags() {
1220             complete();
1221             return flags_field;
1222         }
1223 
1224         @Override
1225         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1226             complete();
1227             if (package_info != null) {
1228                 package_info.complete();
1229                 mergeAttributes();
1230             }
1231             return super.getRawAttributes();
1232         }
1233 
1234         private void mergeAttributes() {
1235             if (metadata == null &amp;&amp;
1236                 package_info.metadata != null) {
1237                 metadata = new SymbolMetadata(this);
1238                 metadata.setAttributes(package_info.metadata);
1239             }
1240         }
1241 
1242         /** A package &quot;exists&quot; if a type or package that exists has
1243          *  been seen within it.
1244          */
1245         public boolean exists() {
1246             return (flags_field &amp; EXISTS) != 0;
1247         }
1248 
1249         @DefinedBy(Api.LANGUAGE_MODEL)
1250         public ElementKind getKind() {
1251             return ElementKind.PACKAGE;
1252         }
1253 
1254         @DefinedBy(Api.LANGUAGE_MODEL)
1255         public Symbol getEnclosingElement() {
1256             return modle != null &amp;&amp; !modle.isNoModule() ? modle : null;
1257         }
1258 
1259         @DefinedBy(Api.LANGUAGE_MODEL)
1260         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1261             return v.visitPackage(this, p);
1262         }
1263 
1264         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1265             return v.visitPackageSymbol(this, p);
1266         }
1267 
1268         /**Resets the Symbol into the state good for next round of annotation processing.*/
1269         public void reset() {
1270             metadata = null;
1271         }
1272 
1273     }
1274 
1275     public static class RootPackageSymbol extends PackageSymbol {
1276         public final MissingInfoHandler missingInfoHandler;
1277         public final boolean allowPrivateInvokeVirtual;
1278 
1279         public RootPackageSymbol(Name name, Symbol owner,
1280                                  MissingInfoHandler missingInfoHandler,
1281                                  boolean allowPrivateInvokeVirtual) {
1282             super(name, owner);
1283             this.missingInfoHandler = missingInfoHandler;
1284             this.allowPrivateInvokeVirtual = allowPrivateInvokeVirtual;
1285         }
1286 
1287     }
1288 
1289     /** A class for class symbols
1290      */
1291     public static class ClassSymbol extends TypeSymbol implements TypeElement {
1292 
1293         /** a scope for all class members; variables, methods and inner classes
1294          *  type parameters are not part of this scope
1295          */
1296         public WriteableScope members_field;
1297 
1298         /** the fully qualified name of the class, i.e. pck.outer.inner.
1299          *  null for anonymous classes
1300          */
1301         public Name fullname;
1302 
1303         /** the fully qualified name of the class after converting to flat
1304          *  representation, i.e. pck.outer$inner,
1305          *  set externally for local and anonymous classes
1306          */
1307         public Name flatname;
1308 
1309         /** the sourcefile where the class came from
1310          */
1311         public JavaFileObject sourcefile;
1312 
1313         /** the classfile from where to load this class
1314          *  this will have extension .class or .java
1315          */
1316         public JavaFileObject classfile;
1317 
1318         /** the list of translated local classes (used for generating
1319          * InnerClasses attribute)
1320          */
1321         public List&lt;ClassSymbol&gt; trans_local;
1322 
1323         /** the annotation metadata attached to this class */
1324         private AnnotationTypeMetadata annotationTypeMetadata;
1325 
1326         /* the list of any of record components, only non empty if the class is a record
1327          * and it has at least one record component
1328          */
1329         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1330 
1331         /* the &#39;other&#39; projection: If &#39;this&#39; is an inline class then &#39;projection&#39; is its reference projection
1332            and vice versa.
1333          */
1334         public ClassSymbol projection;
1335 
1336 
1337         // sealed classes related fields
1338         /** The classes, or interfaces, permitted to extend this class, or interface
1339          */
1340         public List&lt;Symbol&gt; permitted;
1341 
1342         public boolean isPermittedExplicit = false;
1343 
1344         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1345             super(TYP, flags, name, type, owner);
1346             this.members_field = null;
1347             this.fullname = formFullName(name, owner);
1348             this.flatname = formFlatName(name, owner);
1349             this.sourcefile = null;
1350             this.classfile = null;
1351             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1352             this.permitted = List.nil();
1353         }
1354 
1355         public ClassSymbol(long flags, Name name, Symbol owner) {
1356             this(
1357                 flags,
1358                 name,
1359                 new ClassType(Type.noType, null, null),
1360                 owner);
1361             this.type.tsym = this;
1362         }
1363 
1364         /** The Java source which this symbol represents.
1365          */
1366         public String toString() {
1367             return className();
1368         }
1369 
1370         public long flags() {
1371             complete();
1372             return flags_field;
1373         }
1374 
1375         public WriteableScope members() {
1376             complete();
1377             return members_field;
1378         }
1379 
1380         @Override
1381         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1382             complete();
1383             return super.getRawAttributes();
1384         }
1385 
1386         @Override
1387         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1388             complete();
1389             return super.getRawTypeAttributes();
1390         }
1391 
1392         public Type erasure(Types types) {
1393             if (erasure_field == null)
1394                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1395                                               List.nil(), this,
1396                                               type.getMetadata());
1397             return erasure_field;
1398         }
1399 
1400         public String className() {
1401             if (name.isEmpty())
1402                 return
1403                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
1404 
1405                 return fullname.toString();
1406         }
1407 
1408         @DefinedBy(Api.LANGUAGE_MODEL)
1409         public Name getQualifiedName() {
1410             return fullname;
1411         }
1412 
1413         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1414         public List&lt;Symbol&gt; getEnclosedElements() {
1415             List&lt;Symbol&gt; result = super.getEnclosedElements();
1416             if (!recordComponents.isEmpty()) {
1417                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1418                 for (RecordComponent rc : reversed) {
1419                     result = result.prepend(rc);
1420                 }
1421             }
1422             return result;
1423         }
1424 
1425         public Name flatName() {
1426             return flatname;
1427         }
1428 
1429         public boolean isSubClass(Symbol base, Types types) {
1430             if (this == base) {
1431                 return true;
1432             } else if ((base.flags() &amp; INTERFACE) != 0) {
1433                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1434                     for (List&lt;Type&gt; is = types.interfaces(t);
1435                          is.nonEmpty();
1436                          is = is.tail)
1437                         if (is.head.tsym.isSubClass(base, types)) return true;
1438             } else {
1439                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1440                     if (t.tsym == base) return true;
1441             }
1442             return false;
1443         }
1444 
1445         /** Complete the elaboration of this symbol&#39;s definition.
1446          */
1447         public void complete() throws CompletionFailure {
1448             Completer origCompleter = completer;
1449             try {
1450                 super.complete();
1451             } catch (CompletionFailure ex) {
1452                 ex.dcfh.classSymbolCompleteFailed(this, origCompleter);
1453                 // quiet error recovery
1454                 flags_field |= (PUBLIC|STATIC);
1455                 this.type = new ErrorType(this, Type.noType);
1456                 throw ex;
1457             }
1458         }
1459 
1460         @DefinedBy(Api.LANGUAGE_MODEL)
1461         public List&lt;Type&gt; getInterfaces() {
1462             apiComplete();
1463             if (type instanceof ClassType) {
1464                 ClassType t = (ClassType)type;
1465                 if (t.interfaces_field == null) // FIXME: shouldn&#39;t be null
1466                     t.interfaces_field = List.nil();
1467                 if (t.all_interfaces_field != null)
1468                     return Type.getModelTypes(t.all_interfaces_field);
1469                 return t.interfaces_field;
1470             } else {
1471                 return List.nil();
1472             }
1473         }
1474 
1475         @DefinedBy(Api.LANGUAGE_MODEL)
1476         public Type getSuperclass() {
1477             apiComplete();
1478             if (type instanceof ClassType) {
1479                 ClassType t = (ClassType)type;
1480                 if (t.supertype_field == null) // FIXME: shouldn&#39;t be null
1481                     t.supertype_field = Type.noType;
1482                 // An interface has no superclass; its supertype is Object.
1483                 return t.isInterface()
1484                     ? Type.noType
1485                     : t.supertype_field.getModelType();
1486             } else {
1487                 return Type.noType;
1488             }
1489         }
1490 
1491         /**
1492          * Returns the next class to search for inherited annotations or {@code null}
1493          * if the next class can&#39;t be found.
1494          */
1495         private ClassSymbol getSuperClassToSearchForAnnotations() {
1496 
1497             Type sup = getSuperclass();
1498 
1499             if (!sup.hasTag(CLASS) || sup.isErroneous())
1500                 return null;
1501 
1502             return (ClassSymbol) sup.tsym;
1503         }
1504 
1505 
1506         @Override
1507         protected &lt;A extends Annotation&gt; A[] getInheritedAnnotations(Class&lt;A&gt; annoType) {
1508 
1509             ClassSymbol sup = getSuperClassToSearchForAnnotations();
1510 
1511             return sup == null ? super.getInheritedAnnotations(annoType)
1512                                : sup.getAnnotationsByType(annoType);
1513         }
1514 
1515 
1516         @DefinedBy(Api.LANGUAGE_MODEL)
1517         @SuppressWarnings(&quot;preview&quot;)
1518         public ElementKind getKind() {
1519             apiComplete();
1520             long flags = flags();
1521             if ((flags &amp; ANNOTATION) != 0)
1522                 return ElementKind.ANNOTATION_TYPE;
1523             else if ((flags &amp; INTERFACE) != 0)
1524                 return ElementKind.INTERFACE;
1525             else if ((flags &amp; ENUM) != 0)
1526                 return ElementKind.ENUM;
1527             else if ((flags &amp; RECORD) != 0)
1528                 return ElementKind.RECORD;
1529             else
1530                 return ElementKind.CLASS;
1531         }
1532 
1533         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1534         public Set&lt;Modifier&gt; getModifiers() {
1535             apiComplete();
1536             long flags = flags();
1537             return Flags.asModifierSet(flags &amp; ~DEFAULT);
1538         }
1539 
1540         public RecordComponent getRecordComponent(VarSymbol field) {
1541             for (RecordComponent rc : recordComponents) {
1542                 if (rc.name == field.name) {
1543                     return rc;
1544                 }
1545             }
1546             return null;
1547         }
1548 
1549         public RecordComponent getRecordComponent(JCVariableDecl var, boolean addIfMissing, List&lt;JCAnnotation&gt; annotations) {
1550             for (RecordComponent rc : recordComponents) {
1551                 /* it could be that a record erroneously declares two record components with the same name, in that
1552                  * case we need to use the position to disambiguate
1553                  */
1554                 if (rc.name == var.name &amp;&amp; var.pos == rc.pos) {
1555                     return rc;
1556                 }
1557             }
1558             RecordComponent rc = null;
1559             if (addIfMissing) {
1560                 recordComponents = recordComponents.append(rc = new RecordComponent(var, annotations));
1561             }
1562             return rc;
1563         }
1564 
1565         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1566         @SuppressWarnings(&quot;preview&quot;)
1567         public List&lt;? extends RecordComponent&gt; getRecordComponents() {
1568             return recordComponents;
1569         }
1570 
1571         @DefinedBy(Api.LANGUAGE_MODEL)
1572         public NestingKind getNestingKind() {
1573             apiComplete();
1574             if (owner.kind == PCK)
1575                 return NestingKind.TOP_LEVEL;
1576             else if (name.isEmpty())
1577                 return NestingKind.ANONYMOUS;
1578             else if (owner.kind == MTH)
1579                 return NestingKind.LOCAL;
1580             else
1581                 return NestingKind.MEMBER;
1582         }
1583 
1584         @Override
1585         protected &lt;A extends Annotation&gt; Attribute.Compound getAttribute(final Class&lt;A&gt; annoType) {
1586 
1587             Attribute.Compound attrib = super.getAttribute(annoType);
1588 
1589             boolean inherited = annoType.isAnnotationPresent(Inherited.class);
1590             if (attrib != null || !inherited)
1591                 return attrib;
1592 
1593             // Search supertypes
1594             ClassSymbol superType = getSuperClassToSearchForAnnotations();
1595             return superType == null ? null
1596                                      : superType.getAttribute(annoType);
1597         }
1598 
1599         @DefinedBy(Api.LANGUAGE_MODEL)
1600         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1601             return v.visitType(this, p);
1602         }
1603 
1604         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1605             return v.visitClassSymbol(this, p);
1606         }
1607 
1608         public void markAbstractIfNeeded(Types types) {
1609             if (types.enter.getEnv(this) != null &amp;&amp;
1610                 (flags() &amp; ENUM) != 0 &amp;&amp; types.supertype(type).tsym == types.syms.enumSym &amp;&amp;
1611                 (flags() &amp; (FINAL | ABSTRACT)) == 0) {
1612                 if (types.firstUnimplementedAbstract(this) != null)
1613                     // add the ABSTRACT flag to an enum
1614                     flags_field |= ABSTRACT;
1615             }
1616         }
1617 
1618         /**Resets the Symbol into the state good for next round of annotation processing.*/
1619         public void reset() {
1620             kind = TYP;
1621             erasure_field = null;
1622             members_field = null;
1623             flags_field = 0;
1624             if (type instanceof ClassType) {
1625                 ClassType t = (ClassType)type;
1626                 t.setEnclosingType(Type.noType);
1627                 t.rank_field = -1;
1628                 t.typarams_field = null;
1629                 t.allparams_field = null;
1630                 t.supertype_field = null;
1631                 t.interfaces_field = null;
1632                 t.all_interfaces_field = null;
1633             }
1634             clearAnnotationMetadata();
1635         }
1636 
1637         public void clearAnnotationMetadata() {
1638             metadata = null;
1639             annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1640         }
1641 
1642         @Override
1643         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1644             return annotationTypeMetadata;
1645         }
1646 
1647         @Override
1648         public boolean isAnnotationType() {
1649             return (flags_field &amp; Flags.ANNOTATION) != 0;
1650         }
1651 
1652         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1653             Assert.checkNonNull(a);
1654             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1655             this.annotationTypeMetadata = a;
1656         }
1657 
1658         public boolean isRecord() {
1659             return (flags_field &amp; RECORD) != 0;
1660         }
1661 
1662         @Override
1663         public boolean isReferenceProjection() {
1664             return projection != null &amp;&amp; projection.isValue();
1665         }
1666 
1667         @Override
1668         public ClassSymbol valueProjection() {
1669             return isReferenceProjection() ? projection : null;
1670         }
1671 
1672         @Override
1673         public ClassSymbol referenceProjection() {
<a name="2" id="anc2"></a><span class="line-modified">1674             if (!isValue())</span>
<span class="line-added">1675                 return null;</span>
<span class="line-added">1676 </span>
<span class="line-added">1677             if (projection != null)</span>
1678                 return projection;
1679 
1680             ClassType ct = (ClassType) this.type;
1681             ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);
1682             projectedType.allparams_field = ct.allparams_field;
1683             projectedType.supertype_field = ct.supertype_field;
1684 
1685             projectedType.interfaces_field = ct.interfaces_field;
1686             projectedType.all_interfaces_field = ct.all_interfaces_field;
1687             projectedType.projection = ct;
1688             ct.projection = projectedType;
1689 
1690             Name projectionName = this.name.append(&#39;$&#39;, this.name.table.names.ref);
1691             long projectionFlags = (this.flags() &amp; ~(VALUE | UNATTRIBUTED | FINAL)) | SEALED;
1692 
1693             projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);
1694             projection.members_field = WriteableScope.create(projection);
1695             for (Symbol s : this.members().getSymbols(s-&gt;(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {
1696                 Symbol clone = null;
1697                 if (s.kind == MTH) {
1698                     MethodSymbol valMethod = (MethodSymbol)s;
1699                     MethodSymbol refMethod = valMethod.clone(projection);
1700                     valMethod.projection = refMethod;
1701                     refMethod.projection = valMethod;
1702                     clone = refMethod;
1703                 } else if (s.kind == VAR) {
1704                     VarSymbol valVar = (VarSymbol)s;
1705                     VarSymbol refVar = valVar.clone(projection);
1706                     valVar.projection = refVar;
1707                     refVar.projection = valVar;
1708                     clone = refVar;
1709                 }
1710                 projection.members_field.enter(clone);
1711             }
1712             projection.completer = Completer.NULL_COMPLETER;
1713             projection.sourcefile = this.sourcefile;
1714             projection.flatname = this.flatname.append(&#39;$&#39;, this.name.table.names.ref);
1715             projection.permitted = List.of(this);
1716             projection.projection = this;
1717             projectedType.tsym = projection;
1718             return projection;
1719         }
1720 
1721         @DefinedBy(Api.LANGUAGE_MODEL)
1722         public List&lt;Type&gt; getPermittedSubclasses() {
1723             return permitted.map(s -&gt; s.type);
1724         }
1725     }
1726 
1727 
1728     /** A class for variable symbols
1729      */
1730     public static class VarSymbol extends Symbol implements VariableElement {
1731 
1732         /** The variable&#39;s declaration position.
1733          */
1734         public int pos = Position.NOPOS;
1735 
1736         /** The variable&#39;s address. Used for different purposes during
1737          *  flow analysis, translation and code generation.
1738          *  Flow analysis:
1739          *    If this is a blank final or local variable, its sequence number.
1740          *  Translation:
1741          *    If this is a private field, its access number.
1742          *  Code generation:
1743          *    If this is a local variable, its logical slot number.
1744          */
1745         public int adr = -1;
1746 
1747         /* The &#39;other&#39; projection: If &#39;this&#39; is a field of an inline class, then &#39;projection&#39; is the
1748            its doppleganger in its referene projection class and vice versa.
1749         */
1750         public VarSymbol projection;
1751 
1752         /** Construct a variable symbol, given its flags, name, type and owner.
1753          */
1754         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1755             super(VAR, flags, name, type, owner);
1756         }
1757 
1758         @Override
1759         public int poolTag() {
1760             return ClassFile.CONSTANT_Fieldref;
1761         }
1762 
1763         public MethodHandleSymbol asMethodHandle(boolean getter) {
1764             return new MethodHandleSymbol(this, getter);
1765         }
1766 
1767         /** Clone this symbol with new owner.
1768          */
1769         public VarSymbol clone(Symbol newOwner) {
1770             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1771                 @Override
1772                 public Symbol baseSymbol() {
1773                     return VarSymbol.this;
1774                 }
1775 
1776                 @Override
1777                 public Object poolKey(Types types) {
1778                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1779                 }
1780             };
1781             v.pos = pos;
1782             v.adr = adr;
1783             v.data = data;
1784             v.projection = projection;
1785 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1786             return v;
1787         }
1788 
1789         public String toString() {
1790             return name.toString();
1791         }
1792 
1793         public Symbol asMemberOf(Type site, Types types) {
1794             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1795         }
1796 
1797         @DefinedBy(Api.LANGUAGE_MODEL)
1798         public ElementKind getKind() {
1799             long flags = flags();
1800             if ((flags &amp; PARAMETER) != 0) {
1801                 if (isExceptionParameter())
1802                     return ElementKind.EXCEPTION_PARAMETER;
1803                 else
1804                     return ElementKind.PARAMETER;
1805             } else if ((flags &amp; ENUM) != 0) {
1806                 return ElementKind.ENUM_CONSTANT;
1807             } else if (owner.kind == TYP || owner.kind == ERR) {
1808                 return ElementKind.FIELD;
1809             } else if (isResourceVariable()) {
1810                 return ElementKind.RESOURCE_VARIABLE;
1811             } else if ((flags &amp; MATCH_BINDING) != 0) {
1812                 @SuppressWarnings(&quot;preview&quot;)
1813                 ElementKind kind = ElementKind.BINDING_VARIABLE;
1814                 return kind;
1815             } else {
1816                 return ElementKind.LOCAL_VARIABLE;
1817             }
1818         }
1819 
1820         @DefinedBy(Api.LANGUAGE_MODEL)
1821         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1822             return v.visitVariable(this, p);
1823         }
1824 
1825         @DefinedBy(Api.LANGUAGE_MODEL)
1826         public Object getConstantValue() { // Mirror API
1827             return Constants.decode(getConstValue(), type);
1828         }
1829 
1830         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1831                                       final Attr attr,
1832                                       final JCVariableDecl variable)
1833         {
1834             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1835         }
1836 
1837         @Override
1838         public VarSymbol referenceProjection() {
1839             return this.owner.isValue() ?
1840                     this.owner.referenceProjection() != null ? projection : null
1841                                : null;
1842         }
1843 
1844         @Override
1845         public VarSymbol valueProjection() {
1846             return  projection != null ? projection.owner.isValue() ? projection : null: null;
1847         }
1848 
1849         /**
1850          * The variable&#39;s constant value, if this is a constant.
1851          * Before the constant value is evaluated, it points to an
1852          * initializer environment.  If this is not a constant, it can
1853          * be used for other stuff.
1854          */
1855         private Object data;
1856 
1857         public boolean isExceptionParameter() {
1858             return data == ElementKind.EXCEPTION_PARAMETER;
1859         }
1860 
1861         public boolean isResourceVariable() {
1862             return data == ElementKind.RESOURCE_VARIABLE;
1863         }
1864 
1865         public Object getConstValue() {
1866             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1867             if (data == ElementKind.EXCEPTION_PARAMETER ||
1868                 data == ElementKind.RESOURCE_VARIABLE) {
1869                 return null;
1870             } else if (data instanceof Callable&lt;?&gt;) {
1871                 // In this case, this is a final variable, with an as
1872                 // yet unevaluated initializer.
1873                 Callable&lt;?&gt; eval = (Callable&lt;?&gt;)data;
1874                 data = null; // to make sure we don&#39;t evaluate this twice.
1875                 try {
1876                     data = eval.call();
1877                 } catch (Exception ex) {
1878                     throw new AssertionError(ex);
1879                 }
1880             }
1881             return data;
1882         }
1883 
1884         public void setData(Object data) {
1885             Assert.check(!(data instanceof Env&lt;?&gt;), this);
1886             this.data = data;
1887         }
1888 
1889         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1890             return v.visitVarSymbol(this, p);
1891         }
1892     }
1893 
1894     @SuppressWarnings(&quot;preview&quot;)
1895     public static class RecordComponent extends VarSymbol implements RecordComponentElement {
1896         public MethodSymbol accessor;
1897         public JCTree.JCMethodDecl accessorMeth;
1898         /* the original annotations applied to the record component
1899          */
1900         private final List&lt;JCAnnotation&gt; originalAnnos;
1901         /* if the user happens to erroneously declare two components with the same name, we need a way to differentiate
1902          * them, the code will fail anyway but we need to keep the information for better error recovery
1903          */
1904         private final int pos;
1905 
1906         /**
1907          * Construct a record component, given its flags, name, type and owner.
1908          */
1909         public RecordComponent(JCVariableDecl fieldDecl, List&lt;JCAnnotation&gt; annotations) {
1910             super(PUBLIC, fieldDecl.sym.name, fieldDecl.sym.type, fieldDecl.sym.owner);
1911             this.originalAnnos = annotations;
1912             this.pos = fieldDecl.pos;
1913         }
1914 
1915         public List&lt;JCAnnotation&gt; getOriginalAnnos() { return originalAnnos; }
1916 
1917         public boolean isVarargs() {
1918             return type.hasTag(TypeTag.ARRAY) &amp;&amp; ((ArrayType)type).isVarargs();
1919         }
1920 
1921         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1922         @SuppressWarnings(&quot;preview&quot;)
1923         public ElementKind getKind() {
1924             return ElementKind.RECORD_COMPONENT;
1925         }
1926 
1927         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1928         public ExecutableElement getAccessor() {
1929             return accessor;
1930         }
1931 
1932         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1933         @SuppressWarnings(&quot;preview&quot;)
1934         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1935             return v.visitRecordComponent(this, p);
1936         }
1937     }
1938 
1939     public static class ParamSymbol extends VarSymbol {
1940         public ParamSymbol(long flags, Name name, Type type, Symbol owner) {
1941             super(flags, name, type, owner);
1942         }
1943 
1944         @Override
1945         public Name getSimpleName() {
1946             if ((flags_field &amp; NAME_FILLED) == 0) {
1947                 flags_field |= NAME_FILLED;
1948                 Symbol rootPack = this;
1949                 while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {
1950                     rootPack = rootPack.owner;
1951                 }
1952                 if (rootPack != null) {
1953                     Name inferredName =
1954                             ((RootPackageSymbol) rootPack).missingInfoHandler.getParameterName(this);
1955                     if (inferredName != null) {
1956                         this.name = inferredName;
1957                     }
1958                 }
1959             }
1960             return super.getSimpleName();
1961         }
1962 
1963     }
1964 
1965     public static class BindingSymbol extends VarSymbol {
1966 
1967         public BindingSymbol(Name name, Type type, Symbol owner) {
1968             super(Flags.FINAL | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);
1969         }
1970 
1971         public boolean isAliasFor(BindingSymbol b) {
1972             return aliases().containsAll(b.aliases());
1973         }
1974 
1975         List&lt;BindingSymbol&gt; aliases() {
1976             return List.of(this);
1977         }
1978 
1979         public void preserveBinding() {
1980             flags_field |= Flags.MATCH_BINDING_TO_OUTER;
1981         }
1982 
1983         public boolean isPreserved() {
1984             return (flags_field &amp; Flags.MATCH_BINDING_TO_OUTER) != 0;
1985         }
1986     }
1987 
1988     /** A class for method symbols.
1989      */
1990     public static class MethodSymbol extends Symbol implements ExecutableElement {
1991 
1992         /** The code of the method. */
1993         public Code code = null;
1994 
1995         /** The extra (synthetic/mandated) parameters of the method. */
1996         public List&lt;VarSymbol&gt; extraParams = List.nil();
1997 
1998         /** The captured local variables in an anonymous class */
1999         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
2000 
2001         /** The parameters of the method. */
2002         public List&lt;VarSymbol&gt; params = null;
2003 
2004         /** For an annotation type element, its default value if any.
2005          *  The value is null if none appeared in the method
2006          *  declaration.
2007          */
2008         public Attribute defaultValue = null;
2009 
2010         /* The &#39;other&#39; projection: If &#39;this&#39; is a method of an inline class, then &#39;projection&#39; is the
2011            its doppleganger in its referene projection class and vice versa.
2012         */
2013         public MethodSymbol projection;
2014 
2015         /** Construct a method symbol, given its flags, name, type and owner.
2016          */
2017         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
2018             super(MTH, flags, name, type, owner);
2019             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
2020         }
2021 
2022         /** Clone this symbol with new owner.
2023          */
2024         public MethodSymbol clone(Symbol newOwner) {
2025             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
2026                 @Override
2027                 public Symbol baseSymbol() {
2028                     return MethodSymbol.this;
2029                 }
2030 
2031                 @Override
2032                 public Object poolKey(Types types) {
2033                     return new Pair&lt;&gt;(newOwner, baseSymbol());
2034                 }
2035             };
2036             m.code = code;
2037             m.projection = projection;
2038             return m;
2039         }
2040 
2041         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2042         public Set&lt;Modifier&gt; getModifiers() {
2043             long flags = flags();
2044             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
2045         }
2046 
2047         /** The Java source which this symbol represents.
2048          */
2049         public String toString() {
2050             if ((flags() &amp; BLOCK) != 0) {
2051                 return owner.name.toString();
2052             } else {
2053                 String s = (name == name.table.names.init)
2054                     ? owner.name.toString()
2055                     : name.toString();
2056                 if (type != null) {
2057                     if (type.hasTag(FORALL))
2058                         s = &quot;&lt;&quot; + ((ForAll)type).getTypeArguments() + &quot;&gt;&quot; + s;
2059                     s += &quot;(&quot; + type.argtypes((flags() &amp; VARARGS) != 0) + &quot;)&quot;;
2060                 }
2061                 return s;
2062             }
2063         }
2064 
2065         @Override
2066         public int poolTag() {
2067             return owner.isInterface() ?
2068                     ClassFile.CONSTANT_InterfaceMethodref : ClassFile.CONSTANT_Methodref;
2069         }
2070 
2071         public boolean isHandle() {
2072             return false;
2073         }
2074 
2075 
2076         public MethodHandleSymbol asHandle() {
2077             return new MethodHandleSymbol(this);
2078         }
2079 
2080         /** find a symbol that this (proxy method) symbol implements.
2081          *  @param    c       The class whose members are searched for
2082          *                    implementations
2083          */
2084         public Symbol implemented(TypeSymbol c, Types types) {
2085             Symbol impl = null;
2086             for (List&lt;Type&gt; is = types.interfaces(c.type);
2087                  impl == null &amp;&amp; is.nonEmpty();
2088                  is = is.tail) {
2089                 TypeSymbol i = is.head.tsym;
2090                 impl = implementedIn(i, types);
2091                 if (impl == null)
2092                     impl = implemented(i, types);
2093             }
2094             return impl;
2095         }
2096 
2097         public Symbol implementedIn(TypeSymbol c, Types types) {
2098             Symbol impl = null;
2099             for (Symbol sym : c.members().getSymbolsByName(name)) {
2100                 if (this.overrides(sym, (TypeSymbol)owner, types, true) &amp;&amp;
2101                     // FIXME: I suspect the following requires a
2102                     // subst() for a parametric return type.
2103                     types.isSameType(type.getReturnType(),
2104                                      types.memberType(owner.type, sym).getReturnType())) {
2105                     impl = sym;
2106                 }
2107             }
2108             return impl;
2109         }
2110 
2111         /** Will the erasure of this method be considered by the VM to
2112          *  override the erasure of the other when seen from class `origin&#39;?
2113          */
2114         public boolean binaryOverrides(Symbol _other, TypeSymbol origin, Types types) {
2115             if (isConstructor() || _other.kind != MTH) return false;
2116 
2117             if (this == _other) return true;
2118             MethodSymbol other = (MethodSymbol)_other;
2119 
2120             // check for a direct implementation
2121             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2122                 types.asSuper(owner.type, other.owner) != null &amp;&amp;
2123                 types.isSameType(erasure(types), other.erasure(types)))
2124                 return true;
2125 
2126             // check for an inherited implementation
2127             return
2128                 (flags() &amp; ABSTRACT) == 0 &amp;&amp;
2129                 other.isOverridableIn(origin) &amp;&amp;
2130                 this.isMemberOf(origin, types) &amp;&amp;
2131                 types.isSameType(erasure(types), other.erasure(types));
2132         }
2133 
2134         /** The implementation of this (abstract) symbol in class origin,
2135          *  from the VM&#39;s point of view, null if method does not have an
2136          *  implementation in class.
2137          *  @param origin   The class of which the implementation is a member.
2138          */
2139         public MethodSymbol binaryImplementation(ClassSymbol origin, Types types) {
2140             for (TypeSymbol c = origin; c != null; c = types.supertype(c.type).tsym) {
2141                 for (Symbol sym : c.members().getSymbolsByName(name)) {
2142                     if (sym.kind == MTH &amp;&amp;
2143                         ((MethodSymbol)sym).binaryOverrides(this, origin, types))
2144                         return (MethodSymbol)sym;
2145                 }
2146             }
2147             return null;
2148         }
2149 
2150         /** Does this symbol override `other&#39; symbol, when both are seen as
2151          *  members of class `origin&#39;?  It is assumed that _other is a member
2152          *  of origin.
2153          *
2154          *  It is assumed that both symbols have the same name.  The static
2155          *  modifier is ignored for this test.
2156          *
2157          *  A quirk in the works is that if the receiver is a method symbol for
2158          *  an inherited abstract method we answer false summarily all else being
2159          *  immaterial. Abstract &quot;own&quot; methods (i.e `this&#39; is a direct member of
2160          *  origin) don&#39;t get rejected as summarily and are put to test against the
2161          *  suitable criteria.
2162          *
2163          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2164          */
2165         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult) {
2166             return overrides(_other, origin, types, checkResult, true);
2167         }
2168 
2169         /** Does this symbol override `other&#39; symbol, when both are seen as
2170          *  members of class `origin&#39;?  It is assumed that _other is a member
2171          *  of origin.
2172          *
2173          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2174          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2175          *  is false.
2176          *
2177          *  It is assumed that both symbols have the same name.  The static
2178          *  modifier is ignored for this test.
2179          *
2180          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2181          */
2182         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2183                                             boolean requireConcreteIfInherited) {
2184             if (isConstructor() || _other.kind != MTH) return false;
2185 
2186 
2187             /* If any inline types are involved, ask the same question in the reference universe,
2188                where the hierarchy is navigable
2189             */
2190             if (origin.isValue())
2191                 origin = (TypeSymbol) origin.referenceProjection();
2192 
2193             if (this.owner.isValue()) {
2194                 return this.projection != null &amp;&amp;
2195                         this.projection.overrides(_other, origin, types, checkResult, requireConcreteIfInherited);
2196             }
2197 
2198             if (this == _other) return true;
2199             MethodSymbol other = (MethodSymbol)_other;
2200 
2201             // check for a direct implementation
2202             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2203                 types.asSuper(owner.type, other.owner) != null) {
2204                 Type mt = types.memberType(owner.type, this);
2205                 Type ot = types.memberType(owner.type, other);
2206                 if (types.isSubSignature(mt, ot)) {
2207                     if (!checkResult)
2208                         return true;
2209                     if (types.returnTypeSubstitutable(mt, ot))
2210                         return true;
2211                 }
2212             }
2213 
2214             // check for an inherited implementation
2215             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2216                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2217                     !other.isOverridableIn(origin) ||
2218                     !this.isMemberOf(origin, types))
2219                 return false;
2220 
2221             // assert types.asSuper(origin.type, other.owner) != null;
2222             Type mt = types.memberType(origin.type, this);
2223             Type ot = types.memberType(origin.type, other);
2224             return
2225                 types.isSubSignature(mt, ot) &amp;&amp;
2226                 (!checkResult || types.resultSubtype(mt, ot, types.noWarnings));
2227         }
2228 
2229         private boolean isOverridableIn(TypeSymbol origin) {
2230             // JLS 8.4.6.1
2231             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2232             case Flags.PRIVATE:
2233                 return false;
2234             case Flags.PUBLIC:
2235                 return !this.owner.isInterface() ||
2236                         (flags_field &amp; STATIC) == 0;
2237             case Flags.PROTECTED:
2238                 return (origin.flags() &amp; INTERFACE) == 0;
2239             case 0:
2240                 // for package private: can only override in the same
2241                 // package
2242                 return
2243                     this.packge() == origin.packge() &amp;&amp;
2244                     (origin.flags() &amp; INTERFACE) == 0;
2245             default:
2246                 return false;
2247             }
2248         }
2249 
2250         @Override
2251         public boolean isInheritedIn(Symbol clazz, Types types) {
2252 
2253             /* If any inline types are involved, ask the same question in the reference universe,
2254                where the hierarchy is navigable
2255             */
2256             if (clazz.isValue())
2257                 clazz = clazz.referenceProjection();
2258             if (this.owner.isValue())
2259                 return this.projection.isInheritedIn(clazz, types);
2260 
2261             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2262                 case PUBLIC:
2263                     return !this.owner.isInterface() ||
2264                             clazz == owner ||
2265                             (flags_field &amp; STATIC) == 0;
2266                 default:
2267                     return super.isInheritedIn(clazz, types);
2268             }
2269         }
2270 
2271         public boolean isLambdaMethod() {
2272             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2273         }
2274 
2275         @Override
2276         public MethodSymbol referenceProjection() {
2277             return this.owner.isValue() ?
2278                     this.owner.referenceProjection() != null ? projection : null
2279                     : null;
2280         }
2281 
2282         @Override
2283         public MethodSymbol valueProjection() {
2284             return  projection != null ? projection.owner.isValue() ? projection : null : null;
2285         }
2286 
2287         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2288          *  lambda method
2289          */
2290         public MethodSymbol originalEnclosingMethod() {
2291             return this;
2292         }
2293 
2294         /** The implementation of this (abstract) symbol in class origin;
2295          *  null if none exists. Synthetic methods are not considered
2296          *  as possible implementations.
2297          */
2298         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2299             return implementation(origin, types, checkResult, implementation_filter);
2300         }
2301         // where
2302             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2303                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2304 
2305         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2306             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
2307             if (res != null)
2308                 return res;
2309             // if origin is derived from a raw type, we might have missed
2310             // an implementation because we do not know enough about instantiations.
2311             // in this case continue with the supertype as origin.
2312             if (types.isDerivedRaw(origin.type) &amp;&amp; !origin.isInterface())
2313                 return implementation(types.supertype(origin.type).tsym, types, checkResult);
2314             else
2315                 return null;
2316         }
2317 
2318         public List&lt;VarSymbol&gt; params() {
2319             owner.complete();
2320             if (params == null) {
2321                 ListBuffer&lt;VarSymbol&gt; newParams = new ListBuffer&lt;&gt;();
2322                 int i = 0;
2323                 for (Type t : type.getParameterTypes()) {
2324                     Name paramName = name.table.fromString(&quot;arg&quot; + i);
2325                     VarSymbol param = new VarSymbol(PARAMETER, paramName, t, this);
2326                     newParams.append(param);
2327                     i++;
2328                 }
2329                 params = newParams.toList();
2330             }
2331             Assert.checkNonNull(params);
2332             return params;
2333         }
2334 
2335         public Symbol asMemberOf(Type site, Types types) {
2336             return new MethodSymbol(flags_field, name, types.memberType(site, this), owner);
2337         }
2338 
2339         @DefinedBy(Api.LANGUAGE_MODEL)
2340         public ElementKind getKind() {
2341             if (name == name.table.names.init)
2342                 return ElementKind.CONSTRUCTOR;
2343             else if (name == name.table.names.clinit)
2344                 return ElementKind.STATIC_INIT;
2345             else if ((flags() &amp; BLOCK) != 0)
2346                 return isStatic() ? ElementKind.STATIC_INIT : ElementKind.INSTANCE_INIT;
2347             else
2348                 return ElementKind.METHOD;
2349         }
2350 
2351         public boolean isStaticOrInstanceInit() {
2352             return getKind() == ElementKind.STATIC_INIT ||
2353                     getKind() == ElementKind.INSTANCE_INIT;
2354         }
2355 
2356         @DefinedBy(Api.LANGUAGE_MODEL)
2357         public Attribute getDefaultValue() {
2358             return defaultValue;
2359         }
2360 
2361         @DefinedBy(Api.LANGUAGE_MODEL)
2362         public List&lt;VarSymbol&gt; getParameters() {
2363             return params();
2364         }
2365 
2366         @DefinedBy(Api.LANGUAGE_MODEL)
2367         public boolean isVarArgs() {
2368             return (flags() &amp; VARARGS) != 0;
2369         }
2370 
2371         @DefinedBy(Api.LANGUAGE_MODEL)
2372         public boolean isDefault() {
2373             return (flags() &amp; DEFAULT) != 0;
2374         }
2375 
2376         @DefinedBy(Api.LANGUAGE_MODEL)
2377         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
2378             return v.visitExecutable(this, p);
2379         }
2380 
2381         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2382             return v.visitMethodSymbol(this, p);
2383         }
2384 
2385         @DefinedBy(Api.LANGUAGE_MODEL)
2386         public Type getReceiverType() {
2387             Type result = asType().getReceiverType();
2388             return (result == null) ? Type.noType : result;
2389         }
2390 
2391         @DefinedBy(Api.LANGUAGE_MODEL)
2392         public Type getReturnType() {
2393             return asType().getReturnType();
2394         }
2395 
2396         @DefinedBy(Api.LANGUAGE_MODEL)
2397         public List&lt;Type&gt; getThrownTypes() {
2398             return asType().getThrownTypes();
2399         }
2400     }
2401 
2402     /** A class for invokedynamic method calls.
2403      */
2404     public static class DynamicMethodSymbol extends MethodSymbol implements Dynamic {
2405 
2406         public LoadableConstant[] staticArgs;
2407         public MethodHandleSymbol bsm;
2408 
2409         public DynamicMethodSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
2410             super(0, name, type, owner);
2411             this.bsm = bsm;
2412             this.staticArgs = staticArgs;
2413         }
2414 
2415         @Override
2416         public boolean isDynamic() {
2417             return true;
2418         }
2419 
2420         @Override
2421         public LoadableConstant[] staticArgs() {
2422             return staticArgs;
2423         }
2424 
2425         @Override
2426         public MethodHandleSymbol bootstrapMethod() {
2427             return bsm;
2428         }
2429 
2430         @Override
2431         public int poolTag() {
2432             return ClassFile.CONSTANT_InvokeDynamic;
2433         }
2434 
2435         @Override
2436         public Type dynamicType() {
2437             return type;
2438         }
2439     }
2440 
2441     /** A class for condy.
2442      */
2443     public static class DynamicVarSymbol extends VarSymbol implements Dynamic, LoadableConstant {
2444         public LoadableConstant[] staticArgs;
2445         public MethodHandleSymbol bsm;
2446 
2447         public DynamicVarSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
2448             super(0, name, type, owner);
2449             this.bsm = bsm;
2450             this.staticArgs = staticArgs;
2451         }
2452 
2453         @Override
2454         public boolean isDynamic() {
2455             return true;
2456         }
2457 
2458         @Override
2459         public PoolConstant dynamicType() {
2460             return type;
2461         }
2462 
2463         @Override
2464         public LoadableConstant[] staticArgs() {
2465             return staticArgs;
2466         }
2467 
2468         @Override
2469         public LoadableConstant bootstrapMethod() {
2470             return bsm;
2471         }
2472 
2473         @Override
2474         public int poolTag() {
2475             return ClassFile.CONSTANT_Dynamic;
2476         }
2477     }
2478 
2479     /** A class for method handles.
2480      */
2481     public static class MethodHandleSymbol extends MethodSymbol implements LoadableConstant {
2482 
2483         private Symbol refSym;
2484         private boolean getter;
2485 
2486         public MethodHandleSymbol(Symbol msym) {
2487             this(msym, false);
2488         }
2489 
2490         public MethodHandleSymbol(Symbol msym, boolean getter) {
2491             super(msym.flags_field, msym.name, msym.type, msym.owner);
2492             this.refSym = msym;
2493             this.getter = getter;
2494         }
2495 
2496         /**
2497          * Returns the kind associated with this method handle.
2498          */
2499         public int referenceKind() {
2500             if (refSym.kind == VAR) {
2501                 return getter ?
2502                         refSym.isStatic() ? ClassFile.REF_getStatic : ClassFile.REF_getField :
2503                         refSym.isStatic() ? ClassFile.REF_putStatic : ClassFile.REF_putField;
2504             } else {
2505                 if (refSym.isConstructor()) {
2506                     return ClassFile.REF_newInvokeSpecial;
2507                 } else {
2508                     if (refSym.isStatic()) {
2509                         return ClassFile.REF_invokeStatic;
2510                     } else if ((refSym.flags() &amp; PRIVATE) != 0 &amp;&amp; !allowPrivateInvokeVirtual()) {
2511                         return ClassFile.REF_invokeSpecial;
2512                     } else if (refSym.enclClass().isInterface()) {
2513                         return ClassFile.REF_invokeInterface;
2514                     } else {
2515                         return ClassFile.REF_invokeVirtual;
2516                     }
2517                 }
2518             }
2519         }
2520 
2521         private boolean allowPrivateInvokeVirtual() {
2522             Symbol rootPack = this;
2523             while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {
2524                 rootPack = rootPack.owner;
2525             }
2526             return rootPack != null &amp;&amp; ((RootPackageSymbol) rootPack).allowPrivateInvokeVirtual;
2527         }
2528         @Override
2529         public int poolTag() {
2530             return ClassFile.CONSTANT_MethodHandle;
2531         }
2532 
2533         @Override
2534         public Object poolKey(Types types) {
2535             return new Pair&lt;&gt;(baseSymbol(), referenceKind());
2536         }
2537 
2538         @Override
2539         public MethodHandleSymbol asHandle() {
2540             return this;
2541         }
2542 
2543         @Override
2544         public Symbol baseSymbol() {
2545             return refSym;
2546         }
2547 
2548 
2549         @Override
2550         public boolean isHandle() {
2551             return true;
2552         }
2553     }
2554 
2555     /** A class for predefined operators.
2556      */
2557     public static class OperatorSymbol extends MethodSymbol {
2558 
2559         public int opcode;
2560         private int accessCode = Integer.MIN_VALUE;
2561 
2562         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2563             super(PUBLIC | STATIC, name, type, owner);
2564             this.opcode = opcode;
2565         }
2566 
2567         @Override
2568         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2569             return v.visitOperatorSymbol(this, p);
2570         }
2571 
2572         public int getAccessCode(Tag tag) {
2573             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2574                 return accessCode;
2575             }
2576             accessCode = AccessCode.from(tag, opcode);
2577             return accessCode;
2578         }
2579 
2580         /** Access codes for dereferencing, assignment, withfield
2581          *  and pre/post increment/decrement.
2582 
2583          *  All access codes for accesses to the current class are even.
2584          *  If a member of the superclass should be accessed instead (because
2585          *  access was via a qualified super), add one to the corresponding code
2586          *  for the current class, making the number odd.
2587          *  This numbering scheme is used by the backend to decide whether
2588          *  to issue an invokevirtual or invokespecial call.
2589          *
2590          *  @see Gen#visitSelect(JCFieldAccess tree)
2591          */
2592         public enum AccessCode {
2593             UNKNOWN(-1, Tag.NO_TAG),
2594             DEREF(0, Tag.NO_TAG),
2595             ASSIGN(2, Tag.ASSIGN),
2596             PREINC(4, Tag.PREINC),
2597             PREDEC(6, Tag.PREDEC),
2598             POSTINC(8, Tag.POSTINC),
2599             POSTDEC(10, Tag.POSTDEC),
2600             WITHFIELD(12, Tag.WITHFIELD),
2601             FIRSTASGOP(14, Tag.NO_TAG);
2602 
2603             public final int code;
2604             public final Tag tag;
2605             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2606 
2607             AccessCode(int code, Tag tag) {
2608                 this.code = code;
2609                 this.tag = tag;
2610             }
2611 
2612             static public AccessCode getFromCode(int code) {
2613                 for (AccessCode aCodes : AccessCode.values()) {
2614                     if (aCodes.code == code) {
2615                         return aCodes;
2616                     }
2617                 }
2618                 return UNKNOWN;
2619             }
2620 
2621             static int from(Tag tag, int opcode) {
2622                 /** Map bytecode of binary operation to access code of corresponding
2623                 *  assignment operation. This is always an even number.
2624                 */
2625                 switch (tag) {
2626                     case PREINC:
2627                         return AccessCode.PREINC.code;
2628                     case PREDEC:
2629                         return AccessCode.PREDEC.code;
2630                     case POSTINC:
2631                         return AccessCode.POSTINC.code;
2632                     case POSTDEC:
2633                         return AccessCode.POSTDEC.code;
2634                     case WITHFIELD:
2635                         return AccessCode.WITHFIELD.code;
2636                 }
2637                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2638                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2639                 } else if (opcode == string_add) {
2640                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2641                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2642                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2643                 }
2644                 return -1;
2645             }
2646         }
2647     }
2648 
2649     /** Symbol completer interface.
2650      */
2651     public static interface Completer {
2652 
2653         /** Dummy completer to be used when the symbol has been completed or
2654          * does not need completion.
2655          */
2656         public final static Completer NULL_COMPLETER = new Completer() {
2657             public void complete(Symbol sym) { }
2658             public boolean isTerminal() { return true; }
2659         };
2660 
2661         void complete(Symbol sym) throws CompletionFailure;
2662 
2663         /** Returns true if this completer is &lt;em&gt;terminal&lt;/em&gt;. A terminal
2664          * completer is used as a place holder when the symbol is completed.
2665          * Calling complete on a terminal completer will not affect the symbol.
2666          *
2667          * The dummy NULL_COMPLETER and the GraphDependencies completer are
2668          * examples of terminal completers.
2669          *
2670          * @return true iff this completer is terminal
2671          */
2672         default boolean isTerminal() {
2673             return false;
2674         }
2675     }
2676 
2677     public static class CompletionFailure extends RuntimeException {
2678         private static final long serialVersionUID = 0;
2679         public final transient DeferredCompletionFailureHandler dcfh;
2680         public transient Symbol sym;
2681 
2682         /** A diagnostic object describing the failure
2683          */
2684         private transient JCDiagnostic diag;
2685 
2686         private transient Supplier&lt;JCDiagnostic&gt; diagSupplier;
2687 
2688         public CompletionFailure(Symbol sym, Supplier&lt;JCDiagnostic&gt; diagSupplier, DeferredCompletionFailureHandler dcfh) {
2689             this.dcfh = dcfh;
2690             this.sym = sym;
2691             this.diagSupplier = diagSupplier;
2692 //          this.printStackTrace();//DEBUG
2693         }
2694 
2695         public JCDiagnostic getDiagnostic() {
2696             if (diag == null &amp;&amp; diagSupplier != null) {
2697                 diag = diagSupplier.get();
2698             }
2699             return diag;
2700         }
2701 
2702         @Override
2703         public String getMessage() {
2704             return getDiagnostic().getMessage(null);
2705         }
2706 
2707         public JCDiagnostic getDetailValue() {
2708             return getDiagnostic();
2709         }
2710 
2711         @Override
2712         public CompletionFailure initCause(Throwable cause) {
2713             super.initCause(cause);
2714             return this;
2715         }
2716 
2717         public void resetDiagnostic(Supplier&lt;JCDiagnostic&gt; diagSupplier) {
2718             this.diagSupplier = diagSupplier;
2719             this.diag = null;
2720         }
2721 
2722     }
2723 
2724     /**
2725      * A visitor for symbols.  A visitor is used to implement operations
2726      * (or relations) on symbols.  Most common operations on types are
2727      * binary relations and this interface is designed for binary
2728      * relations, that is, operations on the form
2729      * Symbol&amp;nbsp;&amp;times;&amp;nbsp;P&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2730      * &lt;!-- In plain text: Type x P -&gt; R --&gt;
2731      *
2732      * @param &lt;R&gt; the return type of the operation implemented by this
2733      * visitor; use Void if no return type is needed.
2734      * @param &lt;P&gt; the type of the second argument (the first being the
2735      * symbol itself) of the operation implemented by this visitor; use
2736      * Void if a second argument is not needed.
2737      */
2738     public interface Visitor&lt;R,P&gt; {
2739         R visitClassSymbol(ClassSymbol s, P arg);
2740         R visitMethodSymbol(MethodSymbol s, P arg);
2741         R visitPackageSymbol(PackageSymbol s, P arg);
2742         R visitOperatorSymbol(OperatorSymbol s, P arg);
2743         R visitVarSymbol(VarSymbol s, P arg);
2744         R visitTypeSymbol(TypeSymbol s, P arg);
2745         R visitSymbol(Symbol s, P arg);
2746     }
2747 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>