<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.util.ArrayDeque;
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.Map;
  33 
  34 import javax.lang.model.type.*;
  35 
  36 import com.sun.tools.javac.code.Symbol.*;
  37 import com.sun.tools.javac.code.TypeMetadata.Entry;
  38 import com.sun.tools.javac.code.Types.TypeMapping;
  39 import com.sun.tools.javac.code.Types.UniqueType;
  40 import com.sun.tools.javac.comp.Infer.IncorporationAction;
  41 import com.sun.tools.javac.jvm.ClassFile;
  42 import com.sun.tools.javac.jvm.PoolConstant;
  43 import com.sun.tools.javac.util.*;
  44 import com.sun.tools.javac.util.DefinedBy.Api;
  45 
  46 import static com.sun.tools.javac.code.BoundKind.*;
  47 import static com.sun.tools.javac.code.Flags.*;
  48 import static com.sun.tools.javac.code.Kinds.Kind.*;
  49 import static com.sun.tools.javac.code.TypeTag.*;
  50 
  51 /** This class represents Java types. The class itself defines the behavior of
  52  *  the following types:
  53  *  &lt;pre&gt;
  54  *  base types (tags: BYTE, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, BOOLEAN),
  55  *  type `void&#39; (tag: VOID),
  56  *  the bottom type (tag: BOT),
  57  *  the missing type (tag: NONE).
  58  *  &lt;/pre&gt;
  59  *  &lt;p&gt;The behavior of the following types is defined in subclasses, which are
  60  *  all static inner classes of this class:
  61  *  &lt;pre&gt;
  62  *  class types (tag: CLASS, class: ClassType),
  63  *  array types (tag: ARRAY, class: ArrayType),
  64  *  method types (tag: METHOD, class: MethodType),
  65  *  package types (tag: PACKAGE, class: PackageType),
  66  *  type variables (tag: TYPEVAR, class: TypeVar),
  67  *  type arguments (tag: WILDCARD, class: WildcardType),
  68  *  generic method types (tag: FORALL, class: ForAll),
  69  *  the error type (tag: ERROR, class: ErrorType).
  70  *  &lt;/pre&gt;
  71  *
  72  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  73  *  If you write code that depends on this, you do so at your own risk.
  74  *  This code and its internal interfaces are subject to change or
  75  *  deletion without notice.&lt;/b&gt;
  76  *
  77  *  @see TypeTag
  78  */
  79 public abstract class Type extends AnnoConstruct implements TypeMirror, PoolConstant {
  80 
  81     /**
  82      * Type metadata,  Should be {@code null} for the default value.
  83      *
  84      * Note: it is an invariant that for any {@code TypeMetadata}
  85      * class, a given {@code Type} may have at most one metadata array
  86      * entry of that class.
  87      */
  88     protected final TypeMetadata metadata;
  89 
  90     public TypeMetadata getMetadata() {
  91         return metadata;
  92     }
  93 
  94     public Entry getMetadataOfKind(final Entry.Kind kind) {
  95         return metadata != null ? metadata.get(kind) : null;
  96     }
  97 
  98     /** Constant type: no type at all. */
  99     public static final JCNoType noType = new JCNoType() {
 100         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 101         public String toString() {
 102             return &quot;none&quot;;
 103         }
 104     };
 105 
 106     /** Constant type: special type to be used during recovery of deferred expressions. */
 107     public static final JCNoType recoveryType = new JCNoType(){
 108         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 109         public String toString() {
 110             return &quot;recovery&quot;;
 111         }
 112     };
 113 
 114     /** Constant type: special type to be used for marking stuck trees. */
 115     public static final JCNoType stuckType = new JCNoType() {
 116         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 117         public String toString() {
 118             return &quot;stuck&quot;;
 119         }
 120     };
 121 
 122     /** If this switch is turned on, the names of type variables
 123      *  and anonymous classes are printed with hashcodes appended.
 124      */
 125     public static boolean moreInfo = false;
 126 
 127     /** The defining class / interface / package / type variable.
 128      */
 129     public TypeSymbol tsym;
 130 
 131     @Override
 132     public int poolTag() {
 133         throw new AssertionError(&quot;Invalid pool entry&quot;);
 134     }
 135 
 136     @Override
 137     public Object poolKey(Types types) {
 138         return new UniqueType(this, types);
 139     }
 140 
 141     /**
 142      * Checks if the current type tag is equal to the given tag.
 143      * @return true if tag is equal to the current type tag.
 144      */
 145     public boolean hasTag(TypeTag tag) {
 146         return tag == getTag();
 147     }
 148 
 149     /**
 150      * Returns the current type tag.
 151      * @return the value of the current type tag.
 152      */
 153     public abstract TypeTag getTag();
 154 
 155     public boolean isNumeric() {
 156         return false;
 157     }
 158 
 159     public boolean isIntegral() {
 160         return false;
 161     }
 162 
 163     public boolean isPrimitive() {
 164         return false;
 165     }
 166 
 167     public boolean isPrimitiveOrVoid() {
 168         return false;
 169     }
 170 
 171     public boolean isReference() {
 172         return false;
 173     }
 174 
 175     public boolean isNullOrReference() {
 176         return false;
 177     }
 178 
 179     public boolean isPartial() {
 180         return false;
 181     }
 182 
 183     /**
 184      * The constant value of this type, null if this type does not
 185      * have a constant value attribute. Only primitive types and
 186      * strings (ClassType) can have a constant value attribute.
 187      * @return the constant value attribute of this type
 188      */
 189     public Object constValue() {
 190         return null;
 191     }
 192 
 193     /** Is this a constant type whose value is false?
 194      */
 195     public boolean isFalse() {
 196         return false;
 197     }
 198 
 199     /** Is this a constant type whose value is true?
 200      */
 201     public boolean isTrue() {
 202         return false;
 203     }
 204 
 205     /**
 206      * Get the representation of this type used for modelling purposes.
 207      * By default, this is itself. For ErrorType, a different value
 208      * may be provided.
 209      */
 210     public Type getModelType() {
 211         return this;
 212     }
 213 
 214     public static List&lt;Type&gt; getModelTypes(List&lt;Type&gt; ts) {
 215         ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 216         for (Type t: ts)
 217             lb.append(t.getModelType());
 218         return lb.toList();
 219     }
 220 
 221     /**For ErrorType, returns the original type, otherwise returns the type itself.
 222      */
 223     public Type getOriginalType() {
 224         return this;
 225     }
 226 
 227     public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) { return v.visitType(this, s); }
 228 
 229     /** Define a type given its tag, type symbol, and type annotations
 230      */
 231 
 232     public Type(TypeSymbol tsym, TypeMetadata metadata) {
 233         Assert.checkNonNull(metadata);
 234         this.tsym = tsym;
 235         this.metadata = metadata;
 236     }
 237 
 238     public boolean isValue() {
 239         return false;
 240     }
 241 
 242     /**
 243      * @return true IFF the receiver is a reference projection of an inline type and false
 244      * for primitives or plain references
 245      */
 246     public boolean isReferenceProjection() {
 247         return false;
 248     }
 249 
 250     /**
 251      * @return the value projection type IFF the receiver is a reference projection of an inline type
 252      * and null otherwise
 253      */
 254     public Type valueProjection() {
 255         return null;
 256     }
 257 
 258     /**
 259      * @return the reference projection type IFF the receiver is an inline type
 260      * and null otherwise
 261      */
 262     public Type referenceProjection() {
 263         return null;
 264     }
 265 
 266     /**
 267      * A subclass of {@link Types.TypeMapping} which applies a mapping recursively to the subterms
 268      * of a given type expression. This mapping returns the original type is no changes occurred
 269      * when recursively mapping the original type&#39;s subterms.
 270      */
 271     public static abstract class StructuralTypeMapping&lt;S&gt; extends Types.TypeMapping&lt;S&gt; {
 272 
 273         @Override
 274         public Type visitClassType(ClassType t, S s) {
 275             Type outer = t.getEnclosingType();
 276             Type outer1 = visit(outer, s);
 277             List&lt;Type&gt; typarams = t.getTypeArguments();
 278             List&lt;Type&gt; typarams1 = visit(typarams, s);
 279             if (outer1 == outer &amp;&amp; typarams1 == typarams) return t;
 280             else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {
 281                 @Override
 282                 protected boolean needsStripping() {
 283                     return true;
 284                 }
 285             };
 286         }
 287 
 288         @Override
 289         public Type visitWildcardType(WildcardType wt, S s) {
 290             Type t = wt.type;
 291             if (t != null)
 292                 t = visit(t, s);
 293             if (t == wt.type)
 294                 return wt;
 295             else
 296                 return new WildcardType(t, wt.kind, wt.tsym, wt.bound, wt.metadata) {
 297                     @Override
 298                     protected boolean needsStripping() {
 299                         return true;
 300                     }
 301                 };
 302         }
 303 
 304         @Override
 305         public Type visitArrayType(ArrayType t, S s) {
 306             Type elemtype = t.elemtype;
 307             Type elemtype1 = visit(elemtype, s);
 308             if (elemtype1 == elemtype) return t;
 309             else return new ArrayType(elemtype1, t.tsym, t.metadata) {
 310                 @Override
 311                 protected boolean needsStripping() {
 312                     return true;
 313                 }
 314             };
 315         }
 316 
 317         @Override
 318         public Type visitMethodType(MethodType t, S s) {
 319             List&lt;Type&gt; argtypes = t.argtypes;
 320             Type restype = t.restype;
 321             List&lt;Type&gt; thrown = t.thrown;
 322             List&lt;Type&gt; argtypes1 = visit(argtypes, s);
 323             Type restype1 = visit(restype, s);
 324             List&lt;Type&gt; thrown1 = visit(thrown, s);
 325             if (argtypes1 == argtypes &amp;&amp;
 326                 restype1 == restype &amp;&amp;
 327                 thrown1 == thrown) return t;
 328             else return new MethodType(argtypes1, restype1, thrown1, t.tsym) {
 329                 @Override
 330                 protected boolean needsStripping() {
 331                     return true;
 332                 }
 333             };
 334         }
 335 
 336         @Override
 337         public Type visitForAll(ForAll t, S s) {
 338             return visit(t.qtype, s);
 339         }
 340     }
 341 
 342     /** map a type function over all immediate descendants of this type
 343      */
 344     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping, Z arg) {
 345         return mapping.visit(this, arg);
 346     }
 347 
 348     /** map a type function over all immediate descendants of this type (no arg version)
 349      */
 350     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping) {
 351         return mapping.visit(this, null);
 352     }
 353 
 354     /** Define a constant type, of the same kind as this type
 355      *  and with given constant value
 356      */
 357     public Type constType(Object constValue) {
 358         throw new AssertionError();
 359     }
 360 
 361     /**
 362      * If this is a constant type, return its underlying type.
 363      * Otherwise, return the type itself.
 364      */
 365     public Type baseType() {
 366         return this;
 367     }
 368 
 369     /**
 370      * Returns the original version of this type, before metadata were added. This routine is meant
 371      * for internal use only (i.e. {@link Type#equalsIgnoreMetadata(Type)}, {@link Type#stripMetadata});
 372      * it should not be used outside this class.
 373      */
 374     protected Type typeNoMetadata() {
 375         return metadata == TypeMetadata.EMPTY ? this : baseType();
 376     }
 377 
 378     /**
 379      * Create a new copy of this type but with the specified TypeMetadata.
 380      */
 381     public abstract Type cloneWithMetadata(TypeMetadata metadata);
 382 
 383     /**
 384      * Does this type require annotation stripping for API clients?
 385      */
 386     protected boolean needsStripping() {
 387         return false;
 388     }
 389 
 390     /**
 391      * Strip all metadata associated with this type - this could return a new clone of the type.
 392      * This routine is only used to present the correct annotated types back to the users when types
 393      * are accessed through compiler APIs; it should not be used anywhere in the compiler internals
 394      * as doing so might result in performance penalties.
 395      */
 396     public Type stripMetadataIfNeeded() {
 397         return needsStripping() ?
 398                 accept(stripMetadata, null) :
 399                 this;
 400     }
 401 
 402     public Type stripMetadata() {
 403         return accept(stripMetadata, null);
 404     }
 405     //where
 406         private final static TypeMapping&lt;Void&gt; stripMetadata = new StructuralTypeMapping&lt;Void&gt;() {
 407             @Override
 408             public Type visitClassType(ClassType t, Void aVoid) {
 409                 return super.visitClassType((ClassType)t.typeNoMetadata(), aVoid);
 410             }
 411 
 412             @Override
 413             public Type visitArrayType(ArrayType t, Void aVoid) {
 414                 return super.visitArrayType((ArrayType)t.typeNoMetadata(), aVoid);
 415             }
 416 
 417             @Override
 418             public Type visitTypeVar(TypeVar t, Void aVoid) {
 419                 return super.visitTypeVar((TypeVar)t.typeNoMetadata(), aVoid);
 420             }
 421 
 422             @Override
 423             public Type visitWildcardType(WildcardType wt, Void aVoid) {
 424                 return super.visitWildcardType((WildcardType)wt.typeNoMetadata(), aVoid);
 425             }
 426         };
 427 
 428     public Type annotatedType(final List&lt;Attribute.TypeCompound&gt; annos) {
 429         final Entry annoMetadata = new TypeMetadata.Annotations(annos);
 430         return cloneWithMetadata(metadata.combine(annoMetadata));
 431     }
 432 
 433     public boolean isAnnotated() {
 434         final TypeMetadata.Annotations metadata =
 435             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 436 
 437         return null != metadata &amp;&amp; !metadata.getAnnotations().isEmpty();
 438     }
 439 
 440     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 441     public List&lt;Attribute.TypeCompound&gt; getAnnotationMirrors() {
 442         final TypeMetadata.Annotations metadata =
 443             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 444 
 445         return metadata == null ? List.nil() : metadata.getAnnotations();
 446     }
 447 
 448 
 449     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 450     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType) {
 451         return null;
 452     }
 453 
 454 
 455     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 456     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationType) {
 457         @SuppressWarnings(&quot;unchecked&quot;)
 458         A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);
 459         return tmp;
 460     }
 461 
 462     /** Return the base types of a list of types.
 463      */
 464     public static List&lt;Type&gt; baseTypes(List&lt;Type&gt; ts) {
 465         if (ts.nonEmpty()) {
 466             Type t = ts.head.baseType();
 467             List&lt;Type&gt; baseTypes = baseTypes(ts.tail);
 468             if (t != ts.head || baseTypes != ts.tail)
 469                 return baseTypes.prepend(t);
 470         }
 471         return ts;
 472     }
 473 
 474     protected void appendAnnotationsString(StringBuilder sb,
 475                                          boolean prefix) {
 476         if (isAnnotated()) {
 477             if (prefix) {
 478                 sb.append(&quot; &quot;);
 479             }
 480             sb.append(getAnnotationMirrors());
 481             sb.append(&quot; &quot;);
 482         }
 483     }
 484 
 485     protected void appendAnnotationsString(StringBuilder sb) {
 486         appendAnnotationsString(sb, false);
 487     }
 488 
 489     /** The Java source which this type represents.
 490      */
 491     @DefinedBy(Api.LANGUAGE_MODEL)
 492     public String toString() {
 493         StringBuilder sb = new StringBuilder();
 494         appendAnnotationsString(sb);
 495         if (tsym == null || tsym.name == null) {
 496             sb.append(&quot;&lt;none&gt;&quot;);
 497         } else {
 498             sb.append(tsym.name);
 499         }
 500         if (moreInfo &amp;&amp; hasTag(TYPEVAR)) {
 501             sb.append(hashCode());
 502         }
 503         return sb.toString();
 504     }
 505 
 506     /**
 507      * The Java source which this type list represents.  A List is
 508      * represented as a comma-separated listing of the elements in
 509      * that list.
 510      */
 511     public static String toString(List&lt;Type&gt; ts) {
 512         if (ts.isEmpty()) {
 513             return &quot;&quot;;
 514         } else {
 515             StringBuilder buf = new StringBuilder();
 516             buf.append(ts.head.toString());
 517             for (List&lt;Type&gt; l = ts.tail; l.nonEmpty(); l = l.tail)
 518                 buf.append(&quot;,&quot;).append(l.head.toString());
 519             return buf.toString();
 520         }
 521     }
 522 
 523     /**
 524      * The constant value of this type, converted to String
 525      */
 526     public String stringValue() {
 527         Object cv = Assert.checkNonNull(constValue());
 528         return cv.toString();
 529     }
 530 
 531     /**
 532      * Override this method with care. For most Type instances this should behave as ==.
 533      */
 534     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 535     public boolean equals(Object t) {
 536         return this == t;
 537     }
 538 
 539     public boolean equalsIgnoreMetadata(Type t) {
 540         return typeNoMetadata().equals(t.typeNoMetadata());
 541     }
 542 
 543     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 544     public int hashCode() {
 545         return super.hashCode();
 546     }
 547 
 548     public String argtypes(boolean varargs) {
 549         List&lt;Type&gt; args = getParameterTypes();
 550         if (!varargs) return args.toString();
 551         StringBuilder buf = new StringBuilder();
 552         while (args.tail.nonEmpty()) {
 553             buf.append(args.head);
 554             args = args.tail;
 555             buf.append(&#39;,&#39;);
 556         }
 557         if (args.head.hasTag(ARRAY)) {
 558             buf.append(((ArrayType)args.head).elemtype);
 559             if (args.head.getAnnotationMirrors().nonEmpty()) {
 560                 buf.append(args.head.getAnnotationMirrors());
 561             }
 562             buf.append(&quot;...&quot;);
 563         } else {
 564             buf.append(args.head);
 565         }
 566         return buf.toString();
 567     }
 568 
 569     /** Access methods.
 570      */
 571     public List&lt;Type&gt;        getTypeArguments()  { return List.nil(); }
 572     public Type              getEnclosingType()  { return null; }
 573     public List&lt;Type&gt;        getParameterTypes() { return List.nil(); }
 574     public Type              getReturnType()     { return null; }
 575     public Type              getReceiverType()   { return null; }
 576     public List&lt;Type&gt;        getThrownTypes()    { return List.nil(); }
 577     public Type              getUpperBound()     { return null; }
 578     public Type              getLowerBound()     { return null; }
 579 
 580     /** Navigation methods, these will work for classes, type variables,
 581      *  foralls, but will return null for arrays and methods.
 582      */
 583 
 584    /** Return all parameters of this type and all its outer types in order
 585     *  outer (first) to inner (last).
 586     */
 587     public List&lt;Type&gt; allparams() { return List.nil(); }
 588 
 589     /** Does this type contain &quot;error&quot; elements?
 590      */
 591     public boolean isErroneous() {
 592         return false;
 593     }
 594 
 595     public static boolean isErroneous(List&lt;Type&gt; ts) {
 596         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
 597             if (l.head.isErroneous()) return true;
 598         return false;
 599     }
 600 
 601     /** Is this type parameterized?
 602      *  A class type is parameterized if it has some parameters.
 603      *  An array type is parameterized if its element type is parameterized.
 604      *  All other types are not parameterized.
 605      */
 606     public boolean isParameterized() {
 607         return false;
 608     }
 609 
 610     /** Is this type a raw type?
 611      *  A class type is a raw type if it misses some of its parameters.
 612      *  An array type is a raw type if its element type is raw.
 613      *  All other types are not raw.
 614      *  Type validation will ensure that the only raw types
 615      *  in a program are types that miss all their type variables.
 616      */
 617     public boolean isRaw() {
 618         return false;
 619     }
 620 
 621     /**
 622      * A compound type is a special class type whose supertypes are used to store a list
 623      * of component types. There are two kinds of compound types: (i) intersection types
 624      * {@see IntersectionClassType} and (ii) union types {@see UnionClassType}.
 625      */
 626     public boolean isCompound() {
 627         return false;
 628     }
 629 
 630     public boolean isIntersection() {
 631         return false;
 632     }
 633 
 634     public boolean isUnion() {
 635         return false;
 636     }
 637 
 638     public boolean isInterface() {
 639         return (tsym.flags() &amp; INTERFACE) != 0;
 640     }
 641 
 642     public boolean isFinal() {
 643         return (tsym.flags() &amp; FINAL) != 0;
 644     }
 645 
 646     /**
 647      * Does this type contain occurrences of type t?
 648      */
 649     public boolean contains(Type t) {
 650         return t.equalsIgnoreMetadata(this);
 651     }
 652 
 653     public static boolean contains(List&lt;Type&gt; ts, Type t) {
 654         for (List&lt;Type&gt; l = ts;
 655              l.tail != null /*inlined: l.nonEmpty()*/;
 656              l = l.tail)
 657             if (l.head.contains(t)) return true;
 658         return false;
 659     }
 660 
 661     /** Does this type contain an occurrence of some type in &#39;ts&#39;?
 662      */
 663     public boolean containsAny(List&lt;Type&gt; ts) {
 664         for (Type t : ts)
 665             if (this.contains(t)) return true;
 666         return false;
 667     }
 668 
 669     public static boolean containsAny(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
 670         for (Type t : ts1)
 671             if (t.containsAny(ts2)) return true;
 672         return false;
 673     }
 674 
 675     public static List&lt;Type&gt; filter(List&lt;Type&gt; ts, Filter&lt;Type&gt; tf) {
 676         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 677         for (Type t : ts) {
 678             if (tf.accepts(t)) {
 679                 buf.append(t);
 680             }
 681         }
 682         return buf.toList();
 683     }
 684 
 685     public boolean isSuperBound() { return false; }
 686     public boolean isExtendsBound() { return false; }
 687     public boolean isUnbound() { return false; }
 688     public Type withTypeVar(Type t) { return this; }
 689 
 690     /** The underlying method type of this type.
 691      */
 692     public MethodType asMethodType() { throw new AssertionError(); }
 693 
 694     /** Complete loading all classes in this type.
 695      */
 696     public void complete() {}
 697 
 698     public TypeSymbol asElement() {
 699         return tsym;
 700     }
 701 
 702     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 703     public TypeKind getKind() {
 704         return TypeKind.OTHER;
 705     }
 706 
 707     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 708     public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 709         throw new AssertionError();
 710     }
 711 
 712     public static class JCPrimitiveType extends Type
 713             implements javax.lang.model.type.PrimitiveType {
 714 
 715         TypeTag tag;
 716 
 717         public JCPrimitiveType(TypeTag tag, TypeSymbol tsym) {
 718             this(tag, tsym, TypeMetadata.EMPTY);
 719         }
 720 
 721         private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, TypeMetadata metadata) {
 722             super(tsym, metadata);
 723             this.tag = tag;
 724             Assert.check(tag.isPrimitive);
 725         }
 726 
 727         @Override
 728         public JCPrimitiveType cloneWithMetadata(TypeMetadata md) {
 729             return new JCPrimitiveType(tag, tsym, md) {
 730                 @Override
 731                 public Type baseType() { return JCPrimitiveType.this.baseType(); }
 732             };
 733         }
 734 
 735         @Override
 736         public boolean isNumeric() {
 737             return tag != BOOLEAN;
 738         }
 739 
 740         @Override
 741         public boolean isIntegral() {
 742             switch (tag) {
 743                 case CHAR:
 744                 case BYTE:
 745                 case SHORT:
 746                 case INT:
 747                 case LONG:
 748                     return true;
 749                 default:
 750                     return false;
 751             }
 752         }
 753 
 754         @Override
 755         public boolean isPrimitive() {
 756             return true;
 757         }
 758 
 759         @Override
 760         public TypeTag getTag() {
 761             return tag;
 762         }
 763 
 764         @Override
 765         public boolean isPrimitiveOrVoid() {
 766             return true;
 767         }
 768 
 769         /** Define a constant type, of the same kind as this type
 770          *  and with given constant value
 771          */
 772         @Override
 773         public Type constType(Object constValue) {
 774             final Object value = constValue;
 775             return new JCPrimitiveType(tag, tsym, metadata) {
 776                     @Override
 777                     public Object constValue() {
 778                         return value;
 779                     }
 780                     @Override
 781                     public Type baseType() {
 782                         return tsym.type;
 783                     }
 784                 };
 785         }
 786 
 787         /**
 788          * The constant value of this type, converted to String
 789          */
 790         @Override
 791         public String stringValue() {
 792             Object cv = Assert.checkNonNull(constValue());
 793             if (tag == BOOLEAN) {
 794                 return ((Integer) cv).intValue() == 0 ? &quot;false&quot; : &quot;true&quot;;
 795             }
 796             else if (tag == CHAR) {
 797                 return String.valueOf((char) ((Integer) cv).intValue());
 798             }
 799             else {
 800                 return cv.toString();
 801             }
 802         }
 803 
 804         /** Is this a constant type whose value is false?
 805          */
 806         @Override
 807         public boolean isFalse() {
 808             return
 809                 tag == BOOLEAN &amp;&amp;
 810                 constValue() != null &amp;&amp;
 811                 ((Integer)constValue()).intValue() == 0;
 812         }
 813 
 814         /** Is this a constant type whose value is true?
 815          */
 816         @Override
 817         public boolean isTrue() {
 818             return
 819                 tag == BOOLEAN &amp;&amp;
 820                 constValue() != null &amp;&amp;
 821                 ((Integer)constValue()).intValue() != 0;
 822         }
 823 
 824         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 825         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 826             return v.visitPrimitive(this, p);
 827         }
 828 
 829         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 830         public TypeKind getKind() {
 831             switch (tag) {
 832                 case BYTE:      return TypeKind.BYTE;
 833                 case CHAR:      return TypeKind.CHAR;
 834                 case SHORT:     return TypeKind.SHORT;
 835                 case INT:       return TypeKind.INT;
 836                 case LONG:      return TypeKind.LONG;
 837                 case FLOAT:     return TypeKind.FLOAT;
 838                 case DOUBLE:    return TypeKind.DOUBLE;
 839                 case BOOLEAN:   return TypeKind.BOOLEAN;
 840             }
 841             throw new AssertionError();
 842         }
 843 
 844     }
 845 
 846     public static class WildcardType extends Type
 847             implements javax.lang.model.type.WildcardType {
 848 
 849         public Type type;
 850         public BoundKind kind;
 851         public TypeVar bound;
 852 
 853         @Override
 854         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
 855             return v.visitWildcardType(this, s);
 856         }
 857 
 858         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym) {
 859             this(type, kind, tsym, null, TypeMetadata.EMPTY);
 860         }
 861 
 862         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 863                             TypeMetadata metadata) {
 864             this(type, kind, tsym, null, metadata);
 865         }
 866 
 867         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 868                             TypeVar bound) {
 869             this(type, kind, tsym, bound, TypeMetadata.EMPTY);
 870         }
 871 
 872         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 873                             TypeVar bound, TypeMetadata metadata) {
 874             super(tsym, metadata);
 875             this.type = Assert.checkNonNull(type);
 876             this.kind = kind;
 877             this.bound = bound;
 878         }
 879 
 880         @Override
 881         public WildcardType cloneWithMetadata(TypeMetadata md) {
 882             return new WildcardType(type, kind, tsym, bound, md) {
 883                 @Override
 884                 public Type baseType() { return WildcardType.this.baseType(); }
 885             };
 886         }
 887 
 888         @Override
 889         public TypeTag getTag() {
 890             return WILDCARD;
 891         }
 892 
 893         @Override
 894         public boolean contains(Type t) {
 895             return kind != UNBOUND &amp;&amp; type.contains(t);
 896         }
 897 
 898         public boolean isSuperBound() {
 899             return kind == SUPER ||
 900                 kind == UNBOUND;
 901         }
 902         public boolean isExtendsBound() {
 903             return kind == EXTENDS ||
 904                 kind == UNBOUND;
 905         }
 906         public boolean isUnbound() {
 907             return kind == UNBOUND;
 908         }
 909 
 910         @Override
 911         public boolean isReference() {
 912             return true;
 913         }
 914 
 915         @Override
 916         public boolean isNullOrReference() {
 917             return true;
 918         }
 919 
 920         @Override
 921         public Type withTypeVar(Type t) {
 922             //-System.err.println(this+&quot;.withTypeVar(&quot;+t+&quot;);&quot;);//DEBUG
 923             if (bound == t)
 924                 return this;
 925             bound = (TypeVar)t;
 926             return this;
 927         }
 928 
 929         boolean isPrintingBound = false;
 930         @DefinedBy(Api.LANGUAGE_MODEL)
 931         public String toString() {
 932             StringBuilder s = new StringBuilder();
 933             appendAnnotationsString(s);
 934             s.append(kind.toString());
 935             if (kind != UNBOUND)
 936                 s.append(type);
 937             if (moreInfo &amp;&amp; bound != null &amp;&amp; !isPrintingBound)
 938                 try {
 939                     isPrintingBound = true;
 940                     s.append(&quot;{:&quot;).append(bound.getUpperBound()).append(&quot;:}&quot;);
 941                 } finally {
 942                     isPrintingBound = false;
 943                 }
 944             return s.toString();
 945         }
 946 
 947         @DefinedBy(Api.LANGUAGE_MODEL)
 948         public Type getExtendsBound() {
 949             if (kind == EXTENDS)
 950                 return type;
 951             else
 952                 return null;
 953         }
 954 
 955         @DefinedBy(Api.LANGUAGE_MODEL)
 956         public Type getSuperBound() {
 957             if (kind == SUPER)
 958                 return type;
 959             else
 960                 return null;
 961         }
 962 
 963         @DefinedBy(Api.LANGUAGE_MODEL)
 964         public TypeKind getKind() {
 965             return TypeKind.WILDCARD;
 966         }
 967 
 968         @DefinedBy(Api.LANGUAGE_MODEL)
 969         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 970             return v.visitWildcard(this, p);
 971         }
 972     }
 973 
 974     public static class ConstantPoolQType implements PoolConstant {
 975 
 976         public final Type type;
 977         final Types types;
 978 
 979         public ConstantPoolQType(Type type, Types types) {
 980             this.type = type;
 981             this.types = types;
 982         }
 983 
 984         @Override
 985         public Object poolKey(Types types) {
 986             return this;
 987         }
 988 
 989         @Override
 990         public int poolTag() {
 991             return ClassFile.CONSTANT_Class;
 992         }
 993 
 994         public int hashCode() {
 995             return types.hashCode(type);
 996         }
 997 
 998         public boolean equals(Object obj) {
 999             return (obj instanceof ConstantPoolQType) &amp;&amp;
1000                     types.isSameType(type, ((ConstantPoolQType)obj).type);
1001         }
1002 
1003         public String toString() {
1004             return type.toString();
1005         }
1006     }
1007 
1008     public static class ClassType extends Type implements DeclaredType, LoadableConstant,
1009                                                           javax.lang.model.type.ErrorType {
1010 
1011         /** The enclosing type of this type. If this is the type of an inner
1012          *  class, outer_field refers to the type of its enclosing
1013          *  instance class, in all other cases it refers to noType.
1014          */
1015         private Type outer_field;
1016 
1017         /** The type parameters of this type (to be set once class is loaded).
1018          */
1019         public List&lt;Type&gt; typarams_field;
1020 
1021         /** A cache variable for the type parameters of this type,
1022          *  appended to all parameters of its enclosing class.
1023          *  @see #allparams
1024          */
1025         public List&lt;Type&gt; allparams_field;
1026 
1027         /** The supertype of this class (to be set once class is loaded).
1028          */
1029         public Type supertype_field;
1030 
1031         /** The interfaces of this class (to be set once class is loaded).
1032          */
1033         public List&lt;Type&gt; interfaces_field;
1034 
1035         /** All the interfaces of this class, including missing ones.
1036          */
1037         public List&lt;Type&gt; all_interfaces_field;
1038 
1039         /* The &#39;other&#39; projection: If &#39;this&#39; is type of an inline class, then &#39;projection&#39; is the
1040            its doppleganger in its referene projection world and vice versa.
1041         */
1042         public ClassType projection;
1043 
1044         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym) {
1045             this(outer, typarams, tsym, TypeMetadata.EMPTY);
1046         }
1047 
1048         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym,
1049                          TypeMetadata metadata) {
1050             super(tsym, metadata);
1051             this.outer_field = outer;
1052             this.typarams_field = typarams;
1053             this.allparams_field = null;
1054             this.supertype_field = null;
1055             this.interfaces_field = null;
1056         }
1057 
1058         public int poolTag() {
1059             return ClassFile.CONSTANT_Class;
1060         }
1061 
1062         @Override
1063         public ClassType cloneWithMetadata(TypeMetadata md) {
1064             return new ClassType(outer_field, typarams_field, tsym, md) {
1065                 @Override
1066                 public Type baseType() { return ClassType.this.baseType(); }
1067             };
1068         }
1069 
1070         @Override
1071         public TypeTag getTag() {
1072             return CLASS;
1073         }
1074 
1075         @Override
1076         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1077             return v.visitClassType(this, s);
1078         }
1079 
1080         public Type constType(Object constValue) {
1081             final Object value = constValue;
1082             return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {
1083                     @Override
1084                     public Object constValue() {
1085                         return value;
1086                     }
1087                     @Override
1088                     public Type baseType() {
1089                         return tsym.type;
1090                     }
1091                 };
1092         }
1093 
1094         /** The Java source which this type represents.
1095          */
1096         @DefinedBy(Api.LANGUAGE_MODEL)
1097         public String toString() {
1098             StringBuilder buf = new StringBuilder();
1099             if (getEnclosingType().hasTag(CLASS) &amp;&amp; tsym.owner.kind == TYP) {
1100                 buf.append(getEnclosingType().toString());
1101                 buf.append(&quot;.&quot;);
1102                 appendAnnotationsString(buf);
1103                 buf.append(className(tsym, false));
1104             } else {
1105                 appendAnnotationsString(buf);
1106                 buf.append(className(tsym, true));
1107             }
1108 
1109             if (getTypeArguments().nonEmpty()) {
1110                 buf.append(&#39;&lt;&#39;);
1111                 buf.append(getTypeArguments().toString());
1112                 buf.append(&quot;&gt;&quot;);
1113             }
1114             return buf.toString();
1115         }
1116 //where
1117             private String className(Symbol sym, boolean longform) {
1118                 if (sym.name.isEmpty() &amp;&amp; (sym.flags() &amp; COMPOUND) != 0) {
1119                     StringBuilder s = new StringBuilder(supertype_field.toString());
1120                     for (List&lt;Type&gt; is=interfaces_field; is.nonEmpty(); is = is.tail) {
1121                         s.append(&quot;&amp;&quot;);
1122                         s.append(is.head.toString());
1123                     }
1124                     return s.toString();
1125                 } else if (sym.name.isEmpty()) {
1126                     String s;
1127                     ClassType norm = (ClassType) tsym.type;
1128                     if (norm == null) {
1129                         s = Log.getLocalizedString(&quot;anonymous.class&quot;, (Object)null);
1130                     } else if (norm.interfaces_field != null &amp;&amp; norm.interfaces_field.nonEmpty()) {
1131                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1132                                                    norm.interfaces_field.head);
1133                     } else {
1134                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1135                                                    norm.supertype_field);
1136                     }
1137                     if (moreInfo)
1138                         s += String.valueOf(sym.hashCode());
1139                     return s;
1140                 }
1141                 String s;
1142                 if (longform) {
1143                     s =  sym.getQualifiedName().toString();
1144                 } else {
1145                     s = sym.name.toString();
1146                 }
1147                 return s;
1148             }
1149 
1150         @DefinedBy(Api.LANGUAGE_MODEL)
1151         public List&lt;Type&gt; getTypeArguments() {
1152             if (typarams_field == null) {
1153                 complete();
1154                 if (typarams_field == null)
1155                     typarams_field = List.nil();
1156             }
1157             return typarams_field;
1158         }
1159 
1160         public boolean hasErasedSupertypes() {
1161             return isRaw();
1162         }
1163 
1164         @DefinedBy(Api.LANGUAGE_MODEL)
1165         public Type getEnclosingType() {
1166             return outer_field;
1167         }
1168 
1169         public void setEnclosingType(Type outer) {
1170             outer_field = outer;
1171         }
1172 
1173         public List&lt;Type&gt; allparams() {
1174             if (allparams_field == null) {
1175                 allparams_field = getTypeArguments().prependList(getEnclosingType().allparams());
1176             }
1177             return allparams_field;
1178         }
1179 
1180         public boolean isErroneous() {
1181             return
1182                 getEnclosingType().isErroneous() ||
1183                 isErroneous(getTypeArguments()) ||
1184                 this != tsym.type &amp;&amp; tsym.type.isErroneous();
1185         }
1186 
1187         public boolean isParameterized() {
1188             return allparams().tail != null;
1189             // optimization, was: allparams().nonEmpty();
1190         }
1191 
1192         @Override
1193         public boolean isReference() {
1194             return true;
1195         }
1196 
1197         @Override
1198         public boolean isValue() {
1199             return tsym != null &amp;&amp; tsym.isValue();
1200         }
1201 
1202         @Override
1203         public boolean isReferenceProjection() {
1204             return tsym != null &amp;&amp; tsym.isReferenceProjection();
1205         }
1206 
1207         @Override
1208         public Type valueProjection() {
1209             if (!isReferenceProjection())
1210                 return null;
1211 
1212             if (projection !=  null)
1213                 return projection;
1214 
1215             // Make a best case effort to cache the other projection.
1216             ClassSymbol valueClass = (ClassSymbol) tsym.valueProjection();
1217 
1218             projection = new ClassType(outer_field, typarams_field, valueClass);
1219             projection.allparams_field = allparams_field;
1220             projection.supertype_field = supertype_field;
1221 
1222             projection.interfaces_field = interfaces_field;
1223             projection.all_interfaces_field = all_interfaces_field;
1224             projection.projection = this;
1225             return projection;
1226         }
1227 
1228         // return the reference projection type preserving parameterizations
1229         @Override
1230         public ClassType referenceProjection() {
1231 
1232             if (!isValue() || projection != null)
1233                 return projection;
1234 
1235             // make a best case effort to cache the other projection.
1236             ClassSymbol refClass = (ClassSymbol) tsym.referenceProjection();
1237 
1238             projection = new ClassType(outer_field, typarams_field, refClass);
1239             projection.allparams_field = allparams_field;
1240             projection.supertype_field = supertype_field;
1241 
1242             projection.interfaces_field = interfaces_field;
1243             projection.all_interfaces_field = all_interfaces_field;
1244             projection.projection = this;
1245             return projection;
1246         }
1247 
1248         @Override
1249         public boolean isNullOrReference() {
1250             return true;
1251         }
1252 
1253         /** A cache for the rank. */
1254         int rank_field = -1;
1255 
1256         /** A class type is raw if it misses some
1257          *  of its type parameter sections.
1258          *  After validation, this is equivalent to:
1259          *  {@code allparams.isEmpty() &amp;&amp; tsym.type.allparams.nonEmpty(); }
1260          */
1261         public boolean isRaw() {
1262             return
1263                 this != tsym.type &amp;&amp; // necessary, but not sufficient condition
1264                 tsym.type.allparams().nonEmpty() &amp;&amp;
1265                 allparams().isEmpty();
1266         }
1267 
1268         public boolean contains(Type elem) {
1269             return
1270                 elem.equalsIgnoreMetadata(this)
1271                 || (isParameterized()
1272                     &amp;&amp; (getEnclosingType().contains(elem) || contains(getTypeArguments(), elem)))
1273                 || (isCompound()
1274                     &amp;&amp; (supertype_field.contains(elem) || contains(interfaces_field, elem)));
1275         }
1276 
1277         public void complete() {
1278             tsym.complete();
1279         }
1280 
1281         @DefinedBy(Api.LANGUAGE_MODEL)
1282         public TypeKind getKind() {
1283             tsym.apiComplete();
1284             return tsym.kind == TYP ? TypeKind.DECLARED : TypeKind.ERROR;
1285         }
1286 
1287         @DefinedBy(Api.LANGUAGE_MODEL)
1288         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1289             return v.visitDeclared(this, p);
1290         }
1291     }
1292 
1293     public static class ErasedClassType extends ClassType {
1294         public ErasedClassType(Type outer, TypeSymbol tsym,
1295                                TypeMetadata metadata) {
1296             super(outer, List.nil(), tsym, metadata);
1297         }
1298 
1299         @Override
1300         public boolean hasErasedSupertypes() {
1301             return true;
1302         }
1303     }
1304 
1305     // a clone of a ClassType that knows about the alternatives of a union type.
1306     public static class UnionClassType extends ClassType implements UnionType {
1307         final List&lt;? extends Type&gt; alternatives_field;
1308 
1309         public UnionClassType(ClassType ct, List&lt;? extends Type&gt; alternatives) {
1310             // Presently no way to refer to this type directly, so we
1311             // cannot put annotations directly on it.
1312             super(ct.outer_field, ct.typarams_field, ct.tsym);
1313             allparams_field = ct.allparams_field;
1314             supertype_field = ct.supertype_field;
1315             interfaces_field = ct.interfaces_field;
1316             all_interfaces_field = ct.interfaces_field;
1317             alternatives_field = alternatives;
1318         }
1319 
1320         @Override
1321         public UnionClassType cloneWithMetadata(TypeMetadata md) {
1322             throw new AssertionError(&quot;Cannot add metadata to a union type&quot;);
1323         }
1324 
1325         public Type getLub() {
1326             return tsym.type;
1327         }
1328 
1329         @DefinedBy(Api.LANGUAGE_MODEL)
1330         public java.util.List&lt;? extends TypeMirror&gt; getAlternatives() {
1331             return Collections.unmodifiableList(alternatives_field);
1332         }
1333 
1334         @Override
1335         public boolean isUnion() {
1336             return true;
1337         }
1338 
1339         @Override
1340         public boolean isCompound() {
1341             return getLub().isCompound();
1342         }
1343 
1344         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1345         public TypeKind getKind() {
1346             return TypeKind.UNION;
1347         }
1348 
1349         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1350         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1351             return v.visitUnion(this, p);
1352         }
1353 
1354         public Iterable&lt;? extends Type&gt; getAlternativeTypes() {
1355             return alternatives_field;
1356         }
1357     }
1358 
1359     // a clone of a ClassType that knows about the bounds of an intersection type.
1360     public static class IntersectionClassType extends ClassType implements IntersectionType {
1361 
1362         public boolean allInterfaces;
1363 
1364         public IntersectionClassType(List&lt;Type&gt; bounds, ClassSymbol csym, boolean allInterfaces) {
1365             // Presently no way to refer to this type directly, so we
1366             // cannot put annotations directly on it.
1367             super(Type.noType, List.nil(), csym);
1368             this.allInterfaces = allInterfaces;
1369             Assert.check((csym.flags() &amp; COMPOUND) != 0);
1370             supertype_field = bounds.head;
1371             interfaces_field = bounds.tail;
1372             Assert.check(!supertype_field.tsym.isCompleted() ||
1373                     !supertype_field.isInterface(), supertype_field);
1374         }
1375 
1376         @Override
1377         public IntersectionClassType cloneWithMetadata(TypeMetadata md) {
1378             throw new AssertionError(&quot;Cannot add metadata to an intersection type&quot;);
1379         }
1380 
1381         @DefinedBy(Api.LANGUAGE_MODEL)
1382         public java.util.List&lt;? extends TypeMirror&gt; getBounds() {
1383             return Collections.unmodifiableList(getExplicitComponents());
1384         }
1385 
1386         @Override
1387         public boolean isCompound() {
1388             return true;
1389         }
1390 
1391         public List&lt;Type&gt; getComponents() {
1392             return interfaces_field.prepend(supertype_field);
1393         }
1394 
1395         @Override
1396         public boolean isIntersection() {
1397             return true;
1398         }
1399 
1400         public List&lt;Type&gt; getExplicitComponents() {
1401             return allInterfaces ?
1402                     interfaces_field :
1403                     getComponents();
1404         }
1405 
1406         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1407         public TypeKind getKind() {
1408             return TypeKind.INTERSECTION;
1409         }
1410 
1411         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1412         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1413             return v.visitIntersection(this, p);
1414         }
1415     }
1416 
1417     public static class ArrayType extends Type
1418             implements LoadableConstant, javax.lang.model.type.ArrayType {
1419 
1420         public Type elemtype;
1421 
1422         public ArrayType(Type elemtype, TypeSymbol arrayClass) {
1423             this(elemtype, arrayClass, TypeMetadata.EMPTY);
1424         }
1425 
1426         public ArrayType(Type elemtype, TypeSymbol arrayClass,
1427                          TypeMetadata metadata) {
1428             super(arrayClass, metadata);
1429             this.elemtype = elemtype;
1430         }
1431 
1432         public ArrayType(ArrayType that) {
1433             //note: type metadata is deliberately shared here, as we want side-effects from annotation
1434             //processing to flow from original array to the cloned array.
1435             this(that.elemtype, that.tsym, that.getMetadata());
1436         }
1437 
1438         public int poolTag() {
1439             return ClassFile.CONSTANT_Class;
1440         }
1441 
1442         @Override
1443         public ArrayType cloneWithMetadata(TypeMetadata md) {
1444             return new ArrayType(elemtype, tsym, md) {
1445                 @Override
1446                 public Type baseType() { return ArrayType.this.baseType(); }
1447             };
1448         }
1449 
1450         @Override
1451         public TypeTag getTag() {
1452             return ARRAY;
1453         }
1454 
1455         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1456             return v.visitArrayType(this, s);
1457         }
1458 
1459         @DefinedBy(Api.LANGUAGE_MODEL)
1460         public String toString() {
1461             StringBuilder sb = new StringBuilder();
1462 
1463             // First append root component type
1464             Type t = elemtype;
1465             while (t.getKind() == TypeKind.ARRAY)
1466                 t = ((ArrayType) t).getComponentType();
1467             sb.append(t);
1468 
1469             // then append @Anno[] @Anno[] ... @Anno[]
1470             t = this;
1471             do {
1472                 t.appendAnnotationsString(sb, true);
1473                 sb.append(&quot;[]&quot;);
1474                 t = ((ArrayType) t).getComponentType();
1475             } while (t.getKind() == TypeKind.ARRAY);
1476 
1477             return sb.toString();
1478         }
1479 
1480         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1481         public boolean equals(Object obj) {
1482             if (obj instanceof ArrayType) {
1483                 ArrayType that = (ArrayType)obj;
1484                 return this == that ||
1485                         elemtype.equals(that.elemtype);
1486             }
1487 
1488             return false;
1489         }
1490 
1491         @DefinedBy(Api.LANGUAGE_MODEL)
1492         public int hashCode() {
1493             return (ARRAY.ordinal() &lt;&lt; 5) + elemtype.hashCode();
1494         }
1495 
1496         public boolean isVarargs() {
1497             return false;
1498         }
1499 
1500         public List&lt;Type&gt; allparams() { return elemtype.allparams(); }
1501 
1502         public boolean isErroneous() {
1503             return elemtype.isErroneous();
1504         }
1505 
1506         public boolean isParameterized() {
1507             return elemtype.isParameterized();
1508         }
1509 
1510         @Override
1511         public boolean isReference() {
1512             return true;
1513         }
1514 
1515         @Override
1516         public boolean isNullOrReference() {
1517             return true;
1518         }
1519 
1520         public boolean isRaw() {
1521             return elemtype.isRaw();
1522         }
1523 
1524         public ArrayType makeVarargs() {
1525             return new ArrayType(elemtype, tsym, metadata) {
1526                 @Override
1527                 public boolean isVarargs() {
1528                     return true;
1529                 }
1530             };
1531         }
1532 
1533         public boolean contains(Type elem) {
1534             return elem.equalsIgnoreMetadata(this) || elemtype.contains(elem);
1535         }
1536 
1537         public void complete() {
1538             elemtype.complete();
1539         }
1540 
1541         @DefinedBy(Api.LANGUAGE_MODEL)
1542         public Type getComponentType() {
1543             return elemtype;
1544         }
1545 
1546         @DefinedBy(Api.LANGUAGE_MODEL)
1547         public TypeKind getKind() {
1548             return TypeKind.ARRAY;
1549         }
1550 
1551         @DefinedBy(Api.LANGUAGE_MODEL)
1552         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1553             return v.visitArray(this, p);
1554         }
1555     }
1556 
1557     public static class MethodType extends Type implements ExecutableType, LoadableConstant {
1558 
1559         public List&lt;Type&gt; argtypes;
1560         public Type restype;
1561         public List&lt;Type&gt; thrown;
1562 
1563         /** The type annotations on the method receiver.
1564          */
1565         public Type recvtype;
1566 
1567         public MethodType(List&lt;Type&gt; argtypes,
1568                           Type restype,
1569                           List&lt;Type&gt; thrown,
1570                           TypeSymbol methodClass) {
1571             // Presently no way to refer to a method type directly, so
1572             // we cannot put type annotations on it.
1573             super(methodClass, TypeMetadata.EMPTY);
1574             this.argtypes = argtypes;
1575             this.restype = restype;
1576             this.thrown = thrown;
1577         }
1578 
1579         @Override
1580         public MethodType cloneWithMetadata(TypeMetadata md) {
1581             throw new AssertionError(&quot;Cannot add metadata to a method type&quot;);
1582         }
1583 
1584         @Override
1585         public TypeTag getTag() {
1586             return METHOD;
1587         }
1588 
1589         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1590             return v.visitMethodType(this, s);
1591         }
1592 
1593         /** The Java source which this type represents.
1594          *
1595          *  XXX 06/09/99 iris This isn&#39;t correct Java syntax, but it probably
1596          *  should be.
1597          */
1598         @DefinedBy(Api.LANGUAGE_MODEL)
1599         public String toString() {
1600             StringBuilder sb = new StringBuilder();
1601             appendAnnotationsString(sb);
1602             sb.append(&#39;(&#39;);
1603             sb.append(argtypes);
1604             sb.append(&#39;)&#39;);
1605             sb.append(restype);
1606             return sb.toString();
1607         }
1608 
1609         @DefinedBy(Api.LANGUAGE_MODEL)
1610         public List&lt;Type&gt;        getParameterTypes() { return argtypes; }
1611         @DefinedBy(Api.LANGUAGE_MODEL)
1612         public Type              getReturnType()     { return restype; }
1613         @DefinedBy(Api.LANGUAGE_MODEL)
1614         public Type              getReceiverType()   { return recvtype; }
1615         @DefinedBy(Api.LANGUAGE_MODEL)
1616         public List&lt;Type&gt;        getThrownTypes()    { return thrown; }
1617 
1618         public boolean isErroneous() {
1619             return
1620                 isErroneous(argtypes) ||
1621                 restype != null &amp;&amp; restype.isErroneous();
1622         }
1623 
1624         @Override
1625         public int poolTag() {
1626             return ClassFile.CONSTANT_MethodType;
1627         }
1628 
1629         public boolean contains(Type elem) {
1630             return elem.equalsIgnoreMetadata(this) || contains(argtypes, elem) || restype.contains(elem) || contains(thrown, elem);
1631         }
1632 
1633         public MethodType asMethodType() { return this; }
1634 
1635         public void complete() {
1636             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1637                 l.head.complete();
1638             restype.complete();
1639             recvtype.complete();
1640             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1641                 l.head.complete();
1642         }
1643 
1644         @DefinedBy(Api.LANGUAGE_MODEL)
1645         public List&lt;TypeVar&gt; getTypeVariables() {
1646             return List.nil();
1647         }
1648 
1649         public TypeSymbol asElement() {
1650             return null;
1651         }
1652 
1653         @DefinedBy(Api.LANGUAGE_MODEL)
1654         public TypeKind getKind() {
1655             return TypeKind.EXECUTABLE;
1656         }
1657 
1658         @DefinedBy(Api.LANGUAGE_MODEL)
1659         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1660             return v.visitExecutable(this, p);
1661         }
1662     }
1663 
1664     public static class PackageType extends Type implements NoType {
1665 
1666         PackageType(PackageSymbol tsym) {
1667             // Package types cannot be annotated
1668             super(tsym, TypeMetadata.EMPTY);
1669         }
1670 
1671         @Override
1672         public PackageType cloneWithMetadata(TypeMetadata md) {
1673             throw new AssertionError(&quot;Cannot add metadata to a package type&quot;);
1674         }
1675 
1676         @Override
1677         public TypeTag getTag() {
1678             return PACKAGE;
1679         }
1680 
1681         @Override
1682         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1683             return v.visitPackageType(this, s);
1684         }
1685 
1686         @DefinedBy(Api.LANGUAGE_MODEL)
1687         public String toString() {
1688             return tsym.getQualifiedName().toString();
1689         }
1690 
1691         @DefinedBy(Api.LANGUAGE_MODEL)
1692         public TypeKind getKind() {
1693             return TypeKind.PACKAGE;
1694         }
1695 
1696         @DefinedBy(Api.LANGUAGE_MODEL)
1697         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1698             return v.visitNoType(this, p);
1699         }
1700     }
1701 
1702     public static class ModuleType extends Type implements NoType {
1703 
1704         ModuleType(ModuleSymbol tsym) {
1705             // Module types cannot be annotated
1706             super(tsym, TypeMetadata.EMPTY);
1707         }
1708 
1709         @Override
1710         public ModuleType cloneWithMetadata(TypeMetadata md) {
1711             throw new AssertionError(&quot;Cannot add metadata to a module type&quot;);
1712         }
1713 
1714         @Override
1715         public ModuleType annotatedType(List&lt;Attribute.TypeCompound&gt; annos) {
1716             throw new AssertionError(&quot;Cannot annotate a module type&quot;);
1717         }
1718 
1719         @Override
1720         public TypeTag getTag() {
1721             return TypeTag.MODULE;
1722         }
1723 
1724         @Override
1725         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1726             return v.visitModuleType(this, s);
1727         }
1728 
1729         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1730         public String toString() {
1731             return tsym.getQualifiedName().toString();
1732         }
1733 
1734         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1735         public TypeKind getKind() {
1736             return TypeKind.MODULE;
1737         }
1738 
1739         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1740         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1741             return v.visitNoType(this, p);
1742         }
1743     }
1744 
1745     public static class TypeVar extends Type implements TypeVariable {
1746 
1747         /** The upper bound of this type variable; set from outside.
1748          *  Must be nonempty once it is set.
1749          *  For a bound, `bound&#39; is the bound type itself.
1750          *  Multiple bounds are expressed as a single class type which has the
1751          *  individual bounds as superclass, respectively interfaces.
1752          *  The class type then has as `tsym&#39; a compiler generated class `c&#39;,
1753          *  which has a flag COMPOUND and whose owner is the type variable
1754          *  itself. Furthermore, the erasure_field of the class
1755          *  points to the first class or interface bound.
1756          */
1757         private Type _bound = null;
1758 
1759         /** The lower bound of this type variable.
1760          *  TypeVars don&#39;t normally have a lower bound, so it is normally set
1761          *  to syms.botType.
1762          *  Subtypes, such as CapturedType, may provide a different value.
1763          */
1764         public Type lower;
1765 
1766         public TypeVar(Name name, Symbol owner, Type lower) {
1767             super(null, TypeMetadata.EMPTY);
1768             Assert.checkNonNull(lower);
1769             tsym = new TypeVariableSymbol(0, name, this, owner);
1770             this.setUpperBound(null);
1771             this.lower = lower;
1772         }
1773 
1774         public TypeVar(TypeSymbol tsym, Type bound, Type lower) {
1775             this(tsym, bound, lower, TypeMetadata.EMPTY);
1776         }
1777 
1778         public TypeVar(TypeSymbol tsym, Type bound, Type lower,
1779                        TypeMetadata metadata) {
1780             super(tsym, metadata);
1781             Assert.checkNonNull(lower);
1782             this.setUpperBound(bound);
1783             this.lower = lower;
1784         }
1785 
1786         @Override
1787         public TypeVar cloneWithMetadata(TypeMetadata md) {
1788             return new TypeVar(tsym, getUpperBound(), lower, md) {
1789                 @Override
1790                 public Type baseType() { return TypeVar.this.baseType(); }
1791 
1792                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1793                 public Type getUpperBound() { return TypeVar.this.getUpperBound(); }
1794 
1795                 public void setUpperBound(Type bound) { TypeVar.this.setUpperBound(bound); }
1796             };
1797         }
1798 
1799         @Override
1800         public TypeTag getTag() {
1801             return TYPEVAR;
1802         }
1803 
1804         @Override
1805         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1806             return v.visitTypeVar(this, s);
1807         }
1808 
1809         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1810         public Type getUpperBound() { return _bound; }
1811 
1812         public void setUpperBound(Type bound) { this._bound = bound; }
1813 
1814         int rank_field = -1;
1815 
1816         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1817         public Type getLowerBound() {
1818             return lower;
1819         }
1820 
1821         @DefinedBy(Api.LANGUAGE_MODEL)
1822         public TypeKind getKind() {
1823             return TypeKind.TYPEVAR;
1824         }
1825 
1826         public boolean isCaptured() {
1827             return false;
1828         }
1829 
1830         @Override
1831         public boolean isReference() {
1832             return true;
1833         }
1834 
1835         @Override
1836         public boolean isNullOrReference() {
1837             return true;
1838         }
1839 
1840         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1841         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1842             return v.visitTypeVariable(this, p);
1843         }
1844     }
1845 
1846     /** A captured type variable comes from wildcards which can have
1847      *  both upper and lower bound.  CapturedType extends TypeVar with
1848      *  a lower bound.
1849      */
1850     public static class CapturedType extends TypeVar {
1851 
1852         public WildcardType wildcard;
1853 
1854         public CapturedType(Name name,
1855                             Symbol owner,
1856                             Type upper,
1857                             Type lower,
1858                             WildcardType wildcard) {
1859             super(name, owner, lower);
1860             this.lower = Assert.checkNonNull(lower);
1861             this.setUpperBound(upper);
1862             this.wildcard = wildcard;
1863         }
1864 
1865         public CapturedType(TypeSymbol tsym,
1866                             Type bound,
1867                             Type upper,
1868                             Type lower,
1869                             WildcardType wildcard,
1870                             TypeMetadata metadata) {
1871             super(tsym, bound, lower, metadata);
1872             this.wildcard = wildcard;
1873         }
1874 
1875         @Override
1876         public CapturedType cloneWithMetadata(TypeMetadata md) {
1877             return new CapturedType(tsym, getUpperBound(), getUpperBound(), lower, wildcard, md) {
1878                 @Override
1879                 public Type baseType() { return CapturedType.this.baseType(); }
1880 
1881                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1882                 public Type getUpperBound() { return CapturedType.this.getUpperBound(); }
1883 
1884                 public void setUpperBound(Type bound) { CapturedType.this.setUpperBound(bound); }
1885             };
1886         }
1887 
1888         @Override
1889         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1890             return v.visitCapturedType(this, s);
1891         }
1892 
1893         @Override
1894         public boolean isCaptured() {
1895             return true;
1896         }
1897 
1898         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1899         public String toString() {
1900             StringBuilder sb = new StringBuilder();
1901             appendAnnotationsString(sb);
1902             sb.append(&quot;capture#&quot;);
1903             sb.append((hashCode() &amp; 0xFFFFFFFFL) % Printer.PRIME);
1904             sb.append(&quot; of &quot;);
1905             sb.append(wildcard);
1906             return sb.toString();
1907         }
1908     }
1909 
1910     public static abstract class DelegatedType extends Type {
1911         public Type qtype;
1912         public TypeTag tag;
1913 
1914         public DelegatedType(TypeTag tag, Type qtype) {
1915             this(tag, qtype, TypeMetadata.EMPTY);
1916         }
1917 
1918         public DelegatedType(TypeTag tag, Type qtype,
1919                              TypeMetadata metadata) {
1920             super(qtype.tsym, metadata);
1921             this.tag = tag;
1922             this.qtype = qtype;
1923         }
1924 
1925         public TypeTag getTag() { return tag; }
1926         @DefinedBy(Api.LANGUAGE_MODEL)
1927         public String toString() { return qtype.toString(); }
1928         public List&lt;Type&gt; getTypeArguments() { return qtype.getTypeArguments(); }
1929         public Type getEnclosingType() { return qtype.getEnclosingType(); }
1930         public List&lt;Type&gt; getParameterTypes() { return qtype.getParameterTypes(); }
1931         public Type getReturnType() { return qtype.getReturnType(); }
1932         public Type getReceiverType() { return qtype.getReceiverType(); }
1933         public List&lt;Type&gt; getThrownTypes() { return qtype.getThrownTypes(); }
1934         public List&lt;Type&gt; allparams() { return qtype.allparams(); }
1935         public Type getUpperBound() { return qtype.getUpperBound(); }
1936         public boolean isErroneous() { return qtype.isErroneous(); }
1937     }
1938 
1939     /**
1940      * The type of a generic method type. It consists of a method type and
1941      * a list of method type-parameters that are used within the method
1942      * type.
1943      */
1944     public static class ForAll extends DelegatedType implements ExecutableType {
1945         public List&lt;Type&gt; tvars;
1946 
1947         public ForAll(List&lt;Type&gt; tvars, Type qtype) {
1948             super(FORALL, (MethodType)qtype);
1949             this.tvars = tvars;
1950         }
1951 
1952         @Override
1953         public ForAll cloneWithMetadata(TypeMetadata md) {
1954             throw new AssertionError(&quot;Cannot add metadata to a forall type&quot;);
1955         }
1956 
1957         @Override
1958         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1959             return v.visitForAll(this, s);
1960         }
1961 
1962         @DefinedBy(Api.LANGUAGE_MODEL)
1963         public String toString() {
1964             StringBuilder sb = new StringBuilder();
1965             appendAnnotationsString(sb);
1966             sb.append(&#39;&lt;&#39;);
1967             sb.append(tvars);
1968             sb.append(&#39;&gt;&#39;);
1969             sb.append(qtype);
1970             return sb.toString();
1971         }
1972 
1973         public List&lt;Type&gt; getTypeArguments()   { return tvars; }
1974 
1975         public boolean isErroneous()  {
1976             return qtype.isErroneous();
1977         }
1978 
1979         public boolean contains(Type elem) {
1980             return qtype.contains(elem);
1981         }
1982 
1983         public MethodType asMethodType() {
1984             return (MethodType)qtype;
1985         }
1986 
1987         public void complete() {
1988             for (List&lt;Type&gt; l = tvars; l.nonEmpty(); l = l.tail) {
1989                 ((TypeVar)l.head).getUpperBound().complete();
1990             }
1991             qtype.complete();
1992         }
1993 
1994         @DefinedBy(Api.LANGUAGE_MODEL)
1995         public List&lt;TypeVar&gt; getTypeVariables() {
1996             return List.convert(TypeVar.class, getTypeArguments());
1997         }
1998 
1999         @DefinedBy(Api.LANGUAGE_MODEL)
2000         public TypeKind getKind() {
2001             return TypeKind.EXECUTABLE;
2002         }
2003 
2004         @DefinedBy(Api.LANGUAGE_MODEL)
2005         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2006             return v.visitExecutable(this, p);
2007         }
2008     }
2009 
2010     /** A class for inference variables, for use during method/diamond type
2011      *  inference. An inference variable has upper/lower bounds and a set
2012      *  of equality constraints. Such bounds are set during subtyping, type-containment,
2013      *  type-equality checks, when the types being tested contain inference variables.
2014      *  A change listener can be attached to an inference variable, to receive notifications
2015      *  whenever the bounds of an inference variable change.
2016      */
2017     public static class UndetVar extends DelegatedType {
2018 
2019         enum Kind {
2020             NORMAL,
2021             CAPTURED,
2022             THROWS;
2023         }
2024 
2025         /** Inference variable change listener. The listener method is called
2026          *  whenever a change to the inference variable&#39;s bounds occurs
2027          */
2028         public interface UndetVarListener {
2029             /** called when some inference variable bounds (of given kinds ibs) change */
2030             void varBoundChanged(UndetVar uv, InferenceBound ib, Type bound, boolean update);
2031             /** called when the inferred type is set on some inference variable */
2032             default void varInstantiated(UndetVar uv) { Assert.error(); }
2033         }
2034 
2035         /**
2036          * Inference variable bound kinds
2037          */
2038         public enum InferenceBound {
2039             /** lower bounds */
2040             LOWER {
2041                 public InferenceBound complement() { return UPPER; }
2042             },
2043             /** equality constraints */
2044             EQ {
2045                 public InferenceBound complement() { return EQ; }
2046             },
2047             /** upper bounds */
2048             UPPER {
2049                 public InferenceBound complement() { return LOWER; }
2050             };
2051 
2052             public abstract InferenceBound complement();
2053 
2054             public boolean lessThan(InferenceBound that) {
2055                 if (that == this) {
2056                     return false;
2057                 } else {
2058                     switch (that) {
2059                         case UPPER: return true;
2060                         case LOWER: return false;
2061                         case EQ: return (this != UPPER);
2062                         default:
2063                             Assert.error(&quot;Cannot get here!&quot;);
2064                             return false;
2065                     }
2066                 }
2067             }
2068         }
2069 
2070         /** list of incorporation actions (used by the incorporation engine). */
2071         public ArrayDeque&lt;IncorporationAction&gt; incorporationActions = new ArrayDeque&lt;&gt;();
2072 
2073         /** inference variable bounds */
2074         protected Map&lt;InferenceBound, List&lt;Type&gt;&gt; bounds;
2075 
2076         /** inference variable&#39;s inferred type (set from Infer.java) */
2077         private Type inst = null;
2078 
2079         /** number of declared (upper) bounds */
2080         public int declaredCount;
2081 
2082         /** inference variable&#39;s change listener */
2083         public UndetVarListener listener = null;
2084 
2085         Kind kind;
2086 
2087         @Override
2088         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
2089             return v.visitUndetVar(this, s);
2090         }
2091 
2092         public UndetVar(TypeVar origin, UndetVarListener listener, Types types) {
2093             // This is a synthesized internal type, so we cannot annotate it.
2094             super(UNDETVAR, origin);
2095             this.kind = origin.isCaptured() ?
2096                     Kind.CAPTURED :
2097                     Kind.NORMAL;
2098             this.listener = listener;
2099             bounds = new EnumMap&lt;&gt;(InferenceBound.class);
2100             List&lt;Type&gt; declaredBounds = types.getBounds(origin);
2101             declaredCount = declaredBounds.length();
2102             bounds.put(InferenceBound.UPPER, List.nil());
2103             bounds.put(InferenceBound.LOWER, List.nil());
2104             bounds.put(InferenceBound.EQ, List.nil());
2105             for (Type t : declaredBounds.reverse()) {
2106                 //add bound works in reverse order
2107                 addBound(InferenceBound.UPPER, t, types, true);
2108             }
2109             if (origin.isCaptured() &amp;&amp; !origin.lower.hasTag(BOT)) {
2110                 //add lower bound if needed
2111                 addBound(InferenceBound.LOWER, origin.lower, types, true);
2112             }
2113         }
2114 
2115         @DefinedBy(Api.LANGUAGE_MODEL)
2116         public String toString() {
2117             StringBuilder sb = new StringBuilder();
2118             appendAnnotationsString(sb);
2119             if (inst == null) {
2120                 sb.append(qtype);
2121                 sb.append(&#39;?&#39;);
2122             } else {
2123                 sb.append(inst);
2124             }
2125             return sb.toString();
2126         }
2127 
2128         public String debugString() {
2129             String result = &quot;inference var = &quot; + qtype + &quot;\n&quot;;
2130             if (inst != null) {
2131                 result += &quot;inst = &quot; + inst + &#39;\n&#39;;
2132             }
2133             for (InferenceBound bound: InferenceBound.values()) {
2134                 List&lt;Type&gt; aboundList = bounds.get(bound);
2135                 if (aboundList != null &amp;&amp; aboundList.size() &gt; 0) {
2136                     result += bound + &quot; = &quot; + aboundList + &#39;\n&#39;;
2137                 }
2138             }
2139             return result;
2140         }
2141 
2142         public void setThrow() {
2143             if (this.kind == Kind.CAPTURED) {
2144                 //invalid state transition
2145                 throw new IllegalStateException();
2146             }
2147             this.kind = Kind.THROWS;
2148         }
2149 
2150         /**
2151          * Returns a new copy of this undet var.
2152          */
2153         public UndetVar dup(Types types) {
2154             UndetVar uv2 = new UndetVar((TypeVar)qtype, listener, types);
2155             dupTo(uv2, types);
2156             return uv2;
2157         }
2158 
2159         /**
2160          * Dumps the contents of this undet var on another undet var.
2161          */
2162         public void dupTo(UndetVar uv2, Types types) {
2163             uv2.listener = null;
2164             uv2.bounds.clear();
2165             for (InferenceBound ib : InferenceBound.values()) {
2166                 uv2.bounds.put(ib, List.nil());
2167                 for (Type t : getBounds(ib)) {
2168                     uv2.addBound(ib, t, types, true);
2169                 }
2170             }
2171             uv2.inst = inst;
2172             uv2.listener = listener;
2173             uv2.incorporationActions = new ArrayDeque&lt;&gt;();
2174             for (IncorporationAction action : incorporationActions) {
2175                 uv2.incorporationActions.add(action.dup(uv2));
2176             }
2177             uv2.kind = kind;
2178         }
2179 
2180         @Override
2181         public UndetVar cloneWithMetadata(TypeMetadata md) {
2182             throw new AssertionError(&quot;Cannot add metadata to an UndetVar type&quot;);
2183         }
2184 
2185         @Override
2186         public boolean isPartial() {
2187             return true;
2188         }
2189 
2190         @Override
2191         public Type baseType() {
2192             return (inst == null) ? this : inst.baseType();
2193         }
2194 
2195         public Type getInst() {
2196             return inst;
2197         }
2198 
2199         public void setInst(Type inst) {
2200             this.inst = inst;
2201             if (listener != null) {
2202                 listener.varInstantiated(this);
2203             }
2204         }
2205 
2206         /** get all bounds of a given kind */
2207         public List&lt;Type&gt; getBounds(InferenceBound... ibs) {
2208             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2209             for (InferenceBound ib : ibs) {
2210                 buf.appendList(bounds.get(ib));
2211             }
2212             return buf.toList();
2213         }
2214 
2215         /** get the list of declared (upper) bounds */
2216         public List&lt;Type&gt; getDeclaredBounds() {
2217             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2218             int count = 0;
2219             for (Type b : getBounds(InferenceBound.UPPER)) {
2220                 if (count++ == declaredCount) break;
2221                 buf.append(b);
2222             }
2223             return buf.toList();
2224         }
2225 
2226         /** internal method used to override an undetvar bounds */
2227         public void setBounds(InferenceBound ib, List&lt;Type&gt; newBounds) {
2228             bounds.put(ib, newBounds);
2229         }
2230 
2231         /** add a bound of a given kind - this might trigger listener notification */
2232         public final void addBound(InferenceBound ib, Type bound, Types types) {
2233             // Per JDK-8075793: in pre-8 sources, follow legacy javac behavior
2234             // when capture variables are inferred as bounds: for lower bounds,
2235             // map to the capture variable&#39;s upper bound; for upper bounds,
2236             // if the capture variable has a lower bound, map to that type
2237             if (types.mapCapturesToBounds) {
2238                 switch (ib) {
2239                     case LOWER:
2240                         bound = types.cvarUpperBound(bound);
2241                         break;
2242                     case UPPER:
2243                         Type altBound = types.cvarLowerBound(bound);
2244                         if (!altBound.hasTag(TypeTag.BOT)) bound = altBound;
2245                         break;
2246                 }
2247             }
2248             addBound(ib, bound, types, false);
2249         }
2250 
2251         @SuppressWarnings(&quot;fallthrough&quot;)
2252         private void addBound(InferenceBound ib, Type bound, Types types, boolean update) {
2253             if (kind == Kind.CAPTURED &amp;&amp; !update) {
2254                 //Captured inference variables bounds must not be updated during incorporation,
2255                 //except when some inference variable (beta) has been instantiated in the
2256                 //right-hand-side of a &#39;C&lt;alpha&gt; = capture(C&lt;? extends/super beta&gt;) constraint.
2257                 if (bound.hasTag(UNDETVAR) &amp;&amp; !((UndetVar)bound).isCaptured()) {
2258                     //If the new incoming bound is itself a (regular) inference variable,
2259                     //then we are allowed to propagate this inference variable bounds to it.
2260                     ((UndetVar)bound).addBound(ib.complement(), this, types, false);
2261                 }
2262             } else {
2263                 Type bound2 = bound.map(toTypeVarMap).baseType();
2264                 List&lt;Type&gt; prevBounds = bounds.get(ib);
2265                 if (bound == qtype) return;
2266                 for (Type b : prevBounds) {
2267                     //check for redundancy - do not add same bound twice
2268                     if (types.isSameType(b, bound2)) return;
2269                 }
2270                 bounds.put(ib, prevBounds.prepend(bound2));
2271                 notifyBoundChange(ib, bound2, false);
2272             }
2273         }
2274         //where
2275             TypeMapping&lt;Void&gt; toTypeVarMap = new StructuralTypeMapping&lt;Void&gt;() {
2276                 @Override
2277                 public Type visitUndetVar(UndetVar uv, Void _unused) {
2278                     return uv.inst != null ? uv.inst : uv.qtype;
2279                 }
2280             };
2281 
2282         /** replace types in all bounds - this might trigger listener notification */
2283         public void substBounds(List&lt;Type&gt; from, List&lt;Type&gt; to, Types types) {
2284             final ListBuffer&lt;Pair&lt;InferenceBound, Type&gt;&gt;  boundsChanged = new ListBuffer&lt;&gt;();
2285             UndetVarListener prevListener = listener;
2286             try {
2287                 //setup new listener for keeping track of changed bounds
2288                 listener = (uv, ib, t, _ignored) -&gt; {
2289                     Assert.check(uv == UndetVar.this);
2290                     boundsChanged.add(new Pair&lt;&gt;(ib, t));
2291                 };
2292                 for (Map.Entry&lt;InferenceBound, List&lt;Type&gt;&gt; _entry : bounds.entrySet()) {
2293                     InferenceBound ib = _entry.getKey();
2294                     List&lt;Type&gt; prevBounds = _entry.getValue();
2295                     ListBuffer&lt;Type&gt; newBounds = new ListBuffer&lt;&gt;();
2296                     ListBuffer&lt;Type&gt; deps = new ListBuffer&lt;&gt;();
2297                     //step 1 - re-add bounds that are not dependent on ivars
2298                     for (Type t : prevBounds) {
2299                         if (!t.containsAny(from)) {
2300                             newBounds.append(t);
2301                         } else {
2302                             deps.append(t);
2303                         }
2304                     }
2305                     //step 2 - replace bounds
2306                     bounds.put(ib, newBounds.toList());
2307                     //step 3 - for each dependency, add new replaced bound
2308                     for (Type dep : deps) {
2309                         addBound(ib, types.subst(dep, from, to), types, true);
2310                     }
2311                 }
2312             } finally {
2313                 listener = prevListener;
2314                 for (Pair&lt;InferenceBound, Type&gt; boundUpdate : boundsChanged) {
2315                     notifyBoundChange(boundUpdate.fst, boundUpdate.snd, true);
2316                 }
2317             }
2318         }
2319 
2320         private void notifyBoundChange(InferenceBound ib, Type bound, boolean update) {
2321             if (listener != null) {
2322                 listener.varBoundChanged(this, ib, bound, update);
2323             }
2324         }
2325 
2326         public final boolean isCaptured() {
2327             return kind == Kind.CAPTURED;
2328         }
2329 
2330         public final boolean isThrows() {
2331             return kind == Kind.THROWS;
2332         }
2333     }
2334 
2335     /** Represents NONE.
2336      */
2337     public static class JCNoType extends Type implements NoType {
2338         public JCNoType() {
2339             // Need to use List.nil(), because JCNoType constructor
2340             // gets called in static initializers in Type, where
2341             // noAnnotations is also defined.
2342             super(null, TypeMetadata.EMPTY);
2343         }
2344 
2345         @Override
2346         public JCNoType cloneWithMetadata(TypeMetadata md) {
2347             throw new AssertionError(&quot;Cannot add metadata to a JCNoType&quot;);
2348         }
2349 
2350         @Override
2351         public TypeTag getTag() {
2352             return NONE;
2353         }
2354 
2355         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2356         public TypeKind getKind() {
2357             return TypeKind.NONE;
2358         }
2359 
2360         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2361         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2362             return v.visitNoType(this, p);
2363         }
2364 
2365         @Override
2366         public boolean isCompound() { return false; }
2367     }
2368 
2369     /** Represents VOID.
2370      */
2371     public static class JCVoidType extends Type implements NoType {
2372 
2373         public JCVoidType() {
2374             // Void cannot be annotated
2375             super(null, TypeMetadata.EMPTY);
2376         }
2377 
2378         @Override
2379         public JCVoidType cloneWithMetadata(TypeMetadata md) {
2380             throw new AssertionError(&quot;Cannot add metadata to a void type&quot;);
2381         }
2382 
2383         @Override
2384         public TypeTag getTag() {
2385             return VOID;
2386         }
2387 
2388         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2389         public TypeKind getKind() {
2390             return TypeKind.VOID;
2391         }
2392 
2393         @Override
2394         public boolean isCompound() { return false; }
2395 
2396         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2397         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2398             return v.visitNoType(this, p);
2399         }
2400 
2401         @Override
2402         public boolean isPrimitiveOrVoid() {
2403             return true;
2404         }
2405     }
2406 
2407     static class BottomType extends Type implements NullType {
2408         public BottomType() {
2409             // Bottom is a synthesized internal type, so it cannot be annotated
2410             super(null, TypeMetadata.EMPTY);
2411         }
2412 
2413         @Override
2414         public BottomType cloneWithMetadata(TypeMetadata md) {
2415             throw new AssertionError(&quot;Cannot add metadata to a bottom type&quot;);
2416         }
2417 
2418         @Override
2419         public TypeTag getTag() {
2420             return BOT;
2421         }
2422 
2423         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2424         public TypeKind getKind() {
2425             return TypeKind.NULL;
2426         }
2427 
2428         @Override
2429         public boolean isCompound() { return false; }
2430 
2431         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2432         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2433             return v.visitNull(this, p);
2434         }
2435 
2436         @Override
2437         public Type constType(Object value) {
2438             return this;
2439         }
2440 
2441         @Override
2442         public String stringValue() {
2443             return &quot;null&quot;;
2444         }
2445 
2446         @Override
2447         public boolean isNullOrReference() {
2448             return true;
2449         }
2450 
2451     }
2452 
2453     public static class ErrorType extends ClassType
2454             implements javax.lang.model.type.ErrorType {
2455 
2456         private Type originalType = null;
2457 
2458         public ErrorType(ClassSymbol c, Type originalType) {
2459             this(originalType, c);
2460             c.type = this;
2461             c.kind = ERR;
2462             c.members_field = new Scope.ErrorScope(c);
2463         }
2464 
2465         public ErrorType(Type originalType, TypeSymbol tsym) {
2466             super(noType, List.nil(), null);
2467             this.tsym = tsym;
2468             this.originalType = (originalType == null ? noType : originalType);
2469         }
2470 
2471         private ErrorType(Type originalType, TypeSymbol tsym,
2472                           TypeMetadata metadata) {
2473             super(noType, List.nil(), null, metadata);
2474             this.tsym = tsym;
2475             this.originalType = (originalType == null ? noType : originalType);
2476         }
2477 
2478         @Override
2479         public ErrorType cloneWithMetadata(TypeMetadata md) {
2480             return new ErrorType(originalType, tsym, md) {
2481                 @Override
2482                 public Type baseType() { return ErrorType.this.baseType(); }
2483             };
2484         }
2485 
2486         @Override
2487         public TypeTag getTag() {
2488             return ERROR;
2489         }
2490 
2491         @Override
2492         public boolean isPartial() {
2493             return true;
2494         }
2495 
2496         @Override
2497         public boolean isReference() {
2498             return true;
2499         }
2500 
2501         @Override
2502         public boolean isNullOrReference() {
2503             return true;
2504         }
2505 
2506         public ErrorType(Name name, TypeSymbol container, Type originalType) {
2507             this(new ClassSymbol(PUBLIC|STATIC|ACYCLIC, name, null, container), originalType);
2508         }
2509 
2510         @Override
2511         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
2512             return v.visitErrorType(this, s);
2513         }
2514 
2515         public Type constType(Object constValue) { return this; }
2516         @DefinedBy(Api.LANGUAGE_MODEL)
2517         public Type getEnclosingType()           { return Type.noType; }
2518         public Type getReturnType()              { return this; }
2519         public Type asSub(Symbol sym)            { return this; }
2520 
2521         public boolean isGenType(Type t)         { return true; }
2522         public boolean isErroneous()             { return true; }
2523         public boolean isCompound()              { return false; }
2524         public boolean isInterface()             { return false; }
2525 
2526         public List&lt;Type&gt; allparams()            { return List.nil(); }
2527         @DefinedBy(Api.LANGUAGE_MODEL)
2528         public List&lt;Type&gt; getTypeArguments()     { return List.nil(); }
2529 
2530         @DefinedBy(Api.LANGUAGE_MODEL)
2531         public TypeKind getKind() {
2532             return TypeKind.ERROR;
2533         }
2534 
2535         public Type getOriginalType() {
2536             return originalType;
2537         }
2538 
2539         @DefinedBy(Api.LANGUAGE_MODEL)
2540         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2541             return v.visitError(this, p);
2542         }
2543     }
2544 
2545     public static class UnknownType extends Type {
2546 
2547         public UnknownType() {
2548             // Unknown is a synthesized internal type, so it cannot be
2549             // annotated.
2550             super(null, TypeMetadata.EMPTY);
2551         }
2552 
2553         @Override
2554         public UnknownType cloneWithMetadata(TypeMetadata md) {
2555             throw new AssertionError(&quot;Cannot add metadata to an unknown type&quot;);
2556         }
2557 
2558         @Override
2559         public TypeTag getTag() {
2560             return UNKNOWN;
2561         }
2562 
2563         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2564         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2565             return v.visitUnknown(this, p);
2566         }
2567 
2568         @Override
2569         public boolean isPartial() {
2570             return true;
2571         }
2572     }
2573 
2574     /**
2575      * A visitor for types.  A visitor is used to implement operations
2576      * (or relations) on types.  Most common operations on types are
2577      * binary relations and this interface is designed for binary
2578      * relations, that is, operations of the form
2579      * Type&amp;nbsp;&amp;times;&amp;nbsp;S&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2580      * &lt;!-- In plain text: Type x S -&gt; R --&gt;
2581      *
2582      * @param &lt;R&gt; the return type of the operation implemented by this
2583      * visitor; use Void if no return type is needed.
2584      * @param &lt;S&gt; the type of the second argument (the first being the
2585      * type itself) of the operation implemented by this visitor; use
2586      * Void if a second argument is not needed.
2587      */
2588     public interface Visitor&lt;R,S&gt; {
2589         R visitClassType(ClassType t, S s);
2590         R visitWildcardType(WildcardType t, S s);
2591         R visitArrayType(ArrayType t, S s);
2592         R visitMethodType(MethodType t, S s);
2593         R visitPackageType(PackageType t, S s);
2594         R visitModuleType(ModuleType t, S s);
2595         R visitTypeVar(TypeVar t, S s);
2596         R visitCapturedType(CapturedType t, S s);
2597         R visitForAll(ForAll t, S s);
2598         R visitUndetVar(UndetVar t, S s);
2599         R visitErrorType(ErrorType t, S s);
2600         R visitType(Type t, S s);
2601     }
2602 }
    </pre>
  </body>
</html>