<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import com.sun.tools.javac.code.Types.UniqueType;
  29 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  30 import com.sun.tools.javac.tree.TreeInfo.PosKind;
  31 import com.sun.tools.javac.util.*;
  32 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  33 import com.sun.tools.javac.util.List;
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.TypeCompound;
  36 import com.sun.tools.javac.code.Symbol.VarSymbol;
  37 import com.sun.tools.javac.comp.*;
  38 import com.sun.tools.javac.tree.*;
  39 
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.code.Type.*;
  42 import com.sun.tools.javac.jvm.Code.*;
  43 import com.sun.tools.javac.jvm.Items.*;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.tree.EndPosTable;
  46 import com.sun.tools.javac.tree.JCTree.*;
  47 
  48 import static com.sun.tools.javac.code.Flags.*;
  49 import static com.sun.tools.javac.code.Kinds.Kind.*;
  50 import static com.sun.tools.javac.code.TypeTag.*;
  51 import static com.sun.tools.javac.jvm.ByteCodes.*;
  52 import static com.sun.tools.javac.jvm.CRTFlags.*;
  53 import static com.sun.tools.javac.main.Option.*;
  54 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  55 
  56 /** This pass maps flat Java (i.e. without inner classes) to bytecodes.
  57  *
  58  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  59  *  If you write code that depends on this, you do so at your own risk.
  60  *  This code and its internal interfaces are subject to change or
  61  *  deletion without notice.&lt;/b&gt;
  62  */
  63 public class Gen extends JCTree.Visitor {
  64     private static final Object[] NO_STATIC_ARGS = new Object[0];
  65     protected static final Context.Key&lt;Gen&gt; genKey = new Context.Key&lt;&gt;();
  66 
  67     private final Log log;
  68     private final Symtab syms;
  69     private final Check chk;
  70     private final Resolve rs;
  71     private final TreeMaker make;
  72     private final Names names;
  73     private final Target target;
  74     private final Name accessDollar;
  75     private final Types types;
  76     private final Lower lower;
  77     private final Annotate annotate;
  78     private final StringConcat concat;
  79     private final TransValues transValues;
  80 
  81     /** Format of stackmap tables to be generated. */
  82     private final Code.StackMapFormat stackMap;
  83 
  84     /** A type that serves as the expected type for all method expressions.
  85      */
  86     private final Type methodType;
  87 
  88     public static Gen instance(Context context) {
  89         Gen instance = context.get(genKey);
  90         if (instance == null)
  91             instance = new Gen(context);
  92         return instance;
  93     }
  94 
  95     /** Constant pool writer, set by genClass.
  96      */
  97     final PoolWriter poolWriter;
  98 
  99     protected Gen(Context context) {
 100         context.put(genKey, this);
 101 
 102         names = Names.instance(context);
 103         log = Log.instance(context);
 104         syms = Symtab.instance(context);
 105         chk = Check.instance(context);
 106         rs = Resolve.instance(context);
 107         make = TreeMaker.instance(context);
 108         target = Target.instance(context);
 109         types = Types.instance(context);
 110         concat = StringConcat.instance(context);
 111 
 112         methodType = new MethodType(null, null, null, syms.methodClass);
 113         accessDollar = names.
 114             fromString(&quot;access&quot; + target.syntheticNameChar());
 115         lower = Lower.instance(context);
 116         transValues = TransValues.instance(context);
 117 
 118         Options options = Options.instance(context);
 119         lineDebugInfo =
 120             options.isUnset(G_CUSTOM) ||
 121             options.isSet(G_CUSTOM, &quot;lines&quot;);
 122         varDebugInfo =
 123             options.isUnset(G_CUSTOM)
 124             ? options.isSet(G)
 125             : options.isSet(G_CUSTOM, &quot;vars&quot;);
 126         genCrt = options.isSet(XJCOV);
 127         debugCode = options.isSet(&quot;debug.code&quot;);
 128         disableVirtualizedPrivateInvoke = options.isSet(&quot;disableVirtualizedPrivateInvoke&quot;);
 129         poolWriter = new PoolWriter(types, names);
 130 
 131         // ignore cldc because we cannot have both stackmap formats
 132         this.stackMap = StackMapFormat.JSR202;
 133         annotate = Annotate.instance(context);
 134     }
 135 
 136     /** Switches
 137      */
 138     private final boolean lineDebugInfo;
 139     private final boolean varDebugInfo;
 140     private final boolean genCrt;
 141     private final boolean debugCode;
 142     private boolean disableVirtualizedPrivateInvoke;
 143 
 144     /** Code buffer, set by genMethod.
 145      */
 146     private Code code;
 147 
 148     /** Items structure, set by genMethod.
 149      */
 150     private Items items;
 151 
 152     /** Environment for symbol lookup, set by genClass
 153      */
 154     private Env&lt;AttrContext&gt; attrEnv;
 155 
 156     /** The top level tree.
 157      */
 158     private JCCompilationUnit toplevel;
 159 
 160     /** The number of code-gen errors in this class.
 161      */
 162     private int nerrs = 0;
 163 
 164     /** An object containing mappings of syntax trees to their
 165      *  ending source positions.
 166      */
 167     EndPosTable endPosTable;
 168 
 169     boolean inCondSwitchExpression;
 170     Chain switchExpressionTrueChain;
 171     Chain switchExpressionFalseChain;
 172     List&lt;LocalItem&gt; stackBeforeSwitchExpression;
 173     LocalItem switchResult;
 174 
 175     /** Generate code to load an integer constant.
 176      *  @param n     The integer to be loaded.
 177      */
 178     void loadIntConst(int n) {
 179         items.makeImmediateItem(syms.intType, n).load();
 180     }
 181 
 182     /** The opcode that loads a zero constant of a given type code.
 183      *  @param tc   The given type code (@see ByteCode).
 184      */
 185     public static int zero(int tc) {
 186         switch(tc) {
 187         case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
 188             return iconst_0;
 189         case LONGcode:
 190             return lconst_0;
 191         case FLOATcode:
 192             return fconst_0;
 193         case DOUBLEcode:
 194             return dconst_0;
 195         default:
 196             throw new AssertionError(&quot;zero&quot;);
 197         }
 198     }
 199 
 200     /** The opcode that loads a one constant of a given type code.
 201      *  @param tc   The given type code (@see ByteCode).
 202      */
 203     public static int one(int tc) {
 204         return zero(tc) + 1;
 205     }
 206 
 207     /** Generate code to load -1 of the given type code (either int or long).
 208      *  @param tc   The given type code (@see ByteCode).
 209      */
 210     void emitMinusOne(int tc) {
 211         if (tc == LONGcode) {
 212             items.makeImmediateItem(syms.longType, Long.valueOf(-1)).load();
 213         } else {
 214             code.emitop0(iconst_m1);
 215         }
 216     }
 217 
 218     /** Construct a symbol to reflect the qualifying type that should
 219      *  appear in the byte code as per JLS 13.1.
 220      *
 221      *  For {@literal target &gt;= 1.2}: Clone a method with the qualifier as owner (except
 222      *  for those cases where we need to work around VM bugs).
 223      *
 224      *  For {@literal target &lt;= 1.1}: If qualified variable or method is defined in a
 225      *  non-accessible class, clone it with the qualifier class as owner.
 226      *
 227      *  @param sym    The accessed symbol
 228      *  @param site   The qualifier&#39;s type.
 229      */
 230     Symbol binaryQualifier(Symbol sym, Type site) {
 231 
 232         if (site.hasTag(ARRAY)) {
 233             if (sym == syms.lengthVar ||
 234                 sym.owner != syms.arrayClass)
 235                 return sym;
 236             // array clone can be qualified by the array type in later targets
 237             Symbol qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name,
 238                                                site, syms.noSymbol);
 239             return sym.clone(qualifier);
 240         }
 241 
 242         if (sym.owner == site.tsym ||
 243             (sym.flags() &amp; (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {
 244             return sym;
 245         }
 246 
 247         // leave alone methods inherited from Object
 248         // JLS 13.1.
 249         if (sym.owner == syms.objectType.tsym)
 250             return sym;
 251 
 252         return sym.clone(site.tsym);
 253     }
 254 
 255     /** Insert a reference to given type in the constant pool,
 256      *  checking for an array with too many dimensions;
 257      *  return the reference&#39;s index.
 258      *  @param type   The type for which a reference is inserted.
 259      */
 260     int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {
 261         checkDimension(pos, type);
 262         if (emitQtype) {
 263             return poolWriter.putClass(new ConstantPoolQType(type, types));
 264         } else {
 265             return poolWriter.putClass(type);
 266         }
 267     }
 268 
 269     /** Insert a reference to given type in the constant pool,
 270      *  checking for an array with too many dimensions;
 271      *  return the reference&#39;s index.
 272      *  @param type   The type for which a reference is inserted.
 273      */
 274     int makeRef(DiagnosticPosition pos, Type type) {
 275         return makeRef(pos, type, false);
 276     }
 277 
 278     /** Check if the given type is an array with too many dimensions.
 279      */
 280     private Type checkDimension(DiagnosticPosition pos, Type t) {
 281         checkDimensionInternal(pos, t);
 282         return t;
 283     }
 284 
 285     private void checkDimensionInternal(DiagnosticPosition pos, Type t) {
 286         switch (t.getTag()) {
 287         case METHOD:
 288             checkDimension(pos, t.getReturnType());
 289             for (List&lt;Type&gt; args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
 290                 checkDimension(pos, args.head);
 291             break;
 292         case ARRAY:
 293             if (types.dimensions(t) &gt; ClassFile.MAX_DIMENSIONS) {
 294                 log.error(pos, Errors.LimitDimensions);
 295                 nerrs++;
 296             }
 297             break;
 298         default:
 299             break;
 300         }
 301     }
 302 
 303     /** Create a temporary variable.
 304      *  @param type   The variable&#39;s type.
 305      */
 306     LocalItem makeTemp(Type type) {
 307         VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
 308                                     names.empty,
 309                                     type,
 310                                     env.enclMethod.sym);
 311         code.newLocal(v);
 312         return items.makeLocalItem(v);
 313     }
 314 
 315     /** Generate code to call a non-private method or constructor.
 316      *  @param pos         Position to be used for error reporting.
 317      *  @param site        The type of which the method is a member.
 318      *  @param name        The method&#39;s name.
 319      *  @param argtypes    The method&#39;s argument types.
 320      *  @param isStatic    A flag that indicates whether we call a
 321      *                     static or instance method.
 322      */
 323     void callMethod(DiagnosticPosition pos,
 324                     Type site, Name name, List&lt;Type&gt; argtypes,
 325                     boolean isStatic) {
 326         Symbol msym = rs.
 327             resolveInternalMethod(pos, attrEnv, site, name, argtypes, null);
 328         if (isStatic) items.makeStaticItem(msym).invoke();
 329         else items.makeMemberItem(msym, name == names.init).invoke();
 330     }
 331 
 332     /** Is the given method definition an access method
 333      *  resulting from a qualified super? This is signified by an odd
 334      *  access code.
 335      */
 336     private boolean isAccessSuper(JCMethodDecl enclMethod) {
 337         return
 338             (enclMethod.mods.flags &amp; SYNTHETIC) != 0 &amp;&amp;
 339             isOddAccessName(enclMethod.name);
 340     }
 341 
 342     /** Does given name start with &quot;access$&quot; and end in an odd digit?
 343      */
 344     private boolean isOddAccessName(Name name) {
 345         return
 346             name.startsWith(accessDollar) &amp;&amp;
 347             (name.getByteAt(name.getByteLength() - 1) &amp; 1) == 1;
 348     }
 349 
 350 /* ************************************************************************
 351  * Non-local exits
 352  *************************************************************************/
 353 
 354     /** Generate code to invoke the finalizer associated with given
 355      *  environment.
 356      *  Any calls to finalizers are appended to the environments `cont&#39; chain.
 357      *  Mark beginning of gap in catch all range for finalizer.
 358      */
 359     void genFinalizer(Env&lt;GenContext&gt; env) {
 360         if (code.isAlive() &amp;&amp; env.info.finalize != null)
 361             env.info.finalize.gen();
 362     }
 363 
 364     /** Generate code to call all finalizers of structures aborted by
 365      *  a non-local
 366      *  exit.  Return target environment of the non-local exit.
 367      *  @param target      The tree representing the structure that&#39;s aborted
 368      *  @param env         The environment current at the non-local exit.
 369      */
 370     Env&lt;GenContext&gt; unwind(JCTree target, Env&lt;GenContext&gt; env) {
 371         Env&lt;GenContext&gt; env1 = env;
 372         while (true) {
 373             genFinalizer(env1);
 374             if (env1.tree == target) break;
 375             env1 = env1.next;
 376         }
 377         return env1;
 378     }
 379 
 380     /** Mark end of gap in catch-all range for finalizer.
 381      *  @param env   the environment which might contain the finalizer
 382      *               (if it does, env.info.gaps != null).
 383      */
 384     void endFinalizerGap(Env&lt;GenContext&gt; env) {
 385         if (env.info.gaps != null &amp;&amp; env.info.gaps.length() % 2 == 1)
 386             env.info.gaps.append(code.curCP());
 387     }
 388 
 389     /** Mark end of all gaps in catch-all ranges for finalizers of environments
 390      *  lying between, and including to two environments.
 391      *  @param from    the most deeply nested environment to mark
 392      *  @param to      the least deeply nested environment to mark
 393      */
 394     void endFinalizerGaps(Env&lt;GenContext&gt; from, Env&lt;GenContext&gt; to) {
 395         Env&lt;GenContext&gt; last = null;
 396         while (last != to) {
 397             endFinalizerGap(from);
 398             last = from;
 399             from = from.next;
 400         }
 401     }
 402 
 403     /** Do any of the structures aborted by a non-local exit have
 404      *  finalizers that require an empty stack?
 405      *  @param target      The tree representing the structure that&#39;s aborted
 406      *  @param env         The environment current at the non-local exit.
 407      */
 408     boolean hasFinally(JCTree target, Env&lt;GenContext&gt; env) {
 409         while (env.tree != target) {
 410             if (env.tree.hasTag(TRY) &amp;&amp; env.info.finalize.hasFinalizer())
 411                 return true;
 412             env = env.next;
 413         }
 414         return false;
 415     }
 416 
 417 /* ************************************************************************
 418  * Normalizing class-members.
 419  *************************************************************************/
 420 
 421     /** Distribute member initializer code into constructors and {@code &lt;clinit&gt;}
 422      *  method.
 423      *  @param defs         The list of class member declarations.
 424      *  @param c            The enclosing class.
 425      */
 426     List&lt;JCTree&gt; normalizeDefs(List&lt;JCTree&gt; defs, ClassSymbol c) {
 427         ListBuffer&lt;JCStatement&gt; initCode = new ListBuffer&lt;&gt;();
 428         ListBuffer&lt;Attribute.TypeCompound&gt; initTAs = new ListBuffer&lt;&gt;();
 429         ListBuffer&lt;JCStatement&gt; clinitCode = new ListBuffer&lt;&gt;();
 430         ListBuffer&lt;Attribute.TypeCompound&gt; clinitTAs = new ListBuffer&lt;&gt;();
 431         ListBuffer&lt;JCTree&gt; methodDefs = new ListBuffer&lt;&gt;();
 432         // Sort definitions into three listbuffers:
 433         //  - initCode for instance initializers
 434         //  - clinitCode for class initializers
 435         //  - methodDefs for method definitions
 436         for (List&lt;JCTree&gt; l = defs; l.nonEmpty(); l = l.tail) {
 437             JCTree def = l.head;
 438             switch (def.getTag()) {
 439             case BLOCK:
 440                 JCBlock block = (JCBlock)def;
 441                 if ((block.flags &amp; STATIC) != 0)
 442                     clinitCode.append(block);
 443                 else if ((block.flags &amp; SYNTHETIC) == 0)
 444                     initCode.append(block);
 445                 break;
 446             case METHODDEF:
 447                 methodDefs.append(def);
 448                 break;
 449             case VARDEF:
 450                 JCVariableDecl vdef = (JCVariableDecl) def;
 451                 VarSymbol sym = vdef.sym;
 452                 checkDimension(vdef.pos(), sym.type);
 453                 if (vdef.init != null) {
 454                     if ((sym.flags() &amp; STATIC) == 0) {
 455                         // Always initialize instance variables.
 456                         JCStatement init = make.at(vdef.pos()).
 457                             Assignment(sym, vdef.init);
 458                         initCode.append(init);
 459                         endPosTable.replaceTree(vdef, init);
 460                         initTAs.addAll(getAndRemoveNonFieldTAs(sym));
 461                     } else if (sym.getConstValue() == null) {
 462                         // Initialize class (static) variables only if
 463                         // they are not compile-time constants.
 464                         JCStatement init = make.at(vdef.pos).
 465                             Assignment(sym, vdef.init);
 466                         clinitCode.append(init);
 467                         endPosTable.replaceTree(vdef, init);
 468                         clinitTAs.addAll(getAndRemoveNonFieldTAs(sym));
 469                     } else {
 470                         checkStringConstant(vdef.init.pos(), sym.getConstValue());
 471                         /* if the init contains a reference to an external class, add it to the
 472                          * constant&#39;s pool
 473                          */
 474                         vdef.init.accept(classReferenceVisitor);
 475                     }
 476                 }
 477                 break;
 478             default:
 479                 Assert.error();
 480             }
 481         }
 482         // Insert any instance initializers into all constructors.
 483         if (initCode.length() != 0) {
 484             List&lt;JCStatement&gt; inits = initCode.toList();
 485             initTAs.addAll(c.getInitTypeAttributes());
 486             List&lt;Attribute.TypeCompound&gt; initTAlist = initTAs.toList();
 487             for (JCTree t : methodDefs) {
 488                 normalizeMethod((JCMethodDecl)t, inits, initTAlist);
 489             }
 490         }
 491         // If there are class initializers, create a &lt;clinit&gt; method
 492         // that contains them as its body.
 493         if (clinitCode.length() != 0) {
 494             MethodSymbol clinit = new MethodSymbol(
 495                 STATIC | (c.flags() &amp; STRICTFP),
 496                 names.clinit,
 497                 new MethodType(
 498                     List.nil(), syms.voidType,
 499                     List.nil(), syms.methodClass),
 500                 c);
 501             c.members().enter(clinit);
 502             List&lt;JCStatement&gt; clinitStats = clinitCode.toList();
 503             JCBlock block = make.at(clinitStats.head.pos()).Block(0, clinitStats);
 504             block.endpos = TreeInfo.endPos(clinitStats.last());
 505             methodDefs.append(make.MethodDef(clinit, block));
 506 
 507             if (!clinitTAs.isEmpty())
 508                 clinit.appendUniqueTypeAttributes(clinitTAs.toList());
 509             if (!c.getClassInitTypeAttributes().isEmpty())
 510                 clinit.appendUniqueTypeAttributes(c.getClassInitTypeAttributes());
 511         }
 512         // Return all method definitions.
 513         return methodDefs.toList();
 514     }
 515 
 516     private List&lt;Attribute.TypeCompound&gt; getAndRemoveNonFieldTAs(VarSymbol sym) {
 517         List&lt;TypeCompound&gt; tas = sym.getRawTypeAttributes();
 518         ListBuffer&lt;Attribute.TypeCompound&gt; fieldTAs = new ListBuffer&lt;&gt;();
 519         ListBuffer&lt;Attribute.TypeCompound&gt; nonfieldTAs = new ListBuffer&lt;&gt;();
 520         for (TypeCompound ta : tas) {
 521             Assert.check(ta.getPosition().type != TargetType.UNKNOWN);
 522             if (ta.getPosition().type == TargetType.FIELD) {
 523                 fieldTAs.add(ta);
 524             } else {
 525                 nonfieldTAs.add(ta);
 526             }
 527         }
 528         sym.setTypeAttributes(fieldTAs.toList());
 529         return nonfieldTAs.toList();
 530     }
 531 
 532     /** Check a constant value and report if it is a string that is
 533      *  too large.
 534      */
 535     private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
 536         if (nerrs != 0 || // only complain about a long string once
 537             constValue == null ||
 538             !(constValue instanceof String) ||
 539             ((String)constValue).length() &lt; PoolWriter.MAX_STRING_LENGTH)
 540             return;
 541         log.error(pos, Errors.LimitString);
 542         nerrs++;
 543     }
 544 
 545     /** Insert instance initializer code into initial constructor.
 546      *  @param md        The tree potentially representing a
 547      *                   constructor&#39;s definition.
 548      *  @param initCode  The list of instance initializer statements.
 549      *  @param initTAs  Type annotations from the initializer expression.
 550      */
 551     void normalizeMethod(JCMethodDecl md, List&lt;JCStatement&gt; initCode, List&lt;TypeCompound&gt; initTAs) {
 552         if (md.name == names.init &amp;&amp; TreeInfo.isInitialConstructor(md)) {
 553             // We are seeing a constructor that does not call another
 554             // constructor of the same class.
 555             List&lt;JCStatement&gt; stats = md.body.stats;
 556             ListBuffer&lt;JCStatement&gt; newstats = new ListBuffer&lt;&gt;();
 557 
 558             if (stats.nonEmpty()) {
 559                 // Copy initializers of synthetic variables generated in
 560                 // the translation of inner classes.
 561                 while (TreeInfo.isSyntheticInit(stats.head)) {
 562                     newstats.append(stats.head);
 563                     stats = stats.tail;
 564                 }
 565                 // Copy superclass constructor call
 566                 newstats.append(stats.head);
 567                 stats = stats.tail;
 568                 // Copy remaining synthetic initializers.
 569                 while (stats.nonEmpty() &amp;&amp;
 570                        TreeInfo.isSyntheticInit(stats.head)) {
 571                     newstats.append(stats.head);
 572                     stats = stats.tail;
 573                 }
 574                 // Now insert the initializer code.
 575                 newstats.appendList(initCode);
 576                 // And copy all remaining statements.
 577                 while (stats.nonEmpty()) {
 578                     newstats.append(stats.head);
 579                     stats = stats.tail;
 580                 }
 581             }
 582             md.body.stats = newstats.toList();
 583             if (md.body.endpos == Position.NOPOS)
 584                 md.body.endpos = TreeInfo.endPos(md.body.stats.last());
 585 
 586             md.sym.appendUniqueTypeAttributes(initTAs);
 587         }
 588     }
 589 
 590 /* ************************************************************************
 591  * Traversal methods
 592  *************************************************************************/
 593 
 594     /** Visitor argument: The current environment.
 595      */
 596     Env&lt;GenContext&gt; env;
 597 
 598     /** Visitor argument: The expected type (prototype).
 599      */
 600     Type pt;
 601 
 602     /** Visitor result: The item representing the computed value.
 603      */
 604     Item result;
 605 
 606     /** Visitor method: generate code for a definition, catching and reporting
 607      *  any completion failures.
 608      *  @param tree    The definition to be visited.
 609      *  @param env     The environment current at the definition.
 610      */
 611     public void genDef(JCTree tree, Env&lt;GenContext&gt; env) {
 612         Env&lt;GenContext&gt; prevEnv = this.env;
 613         try {
 614             this.env = env;
 615             tree.accept(this);
 616         } catch (CompletionFailure ex) {
 617             chk.completionError(tree.pos(), ex);
 618         } finally {
 619             this.env = prevEnv;
 620         }
 621     }
 622 
 623     /** Derived visitor method: check whether CharacterRangeTable
 624      *  should be emitted, if so, put a new entry into CRTable
 625      *  and call method to generate bytecode.
 626      *  If not, just call method to generate bytecode.
 627      *  @see    #genStat(JCTree, Env)
 628      *
 629      *  @param  tree     The tree to be visited.
 630      *  @param  env      The environment to use.
 631      *  @param  crtFlags The CharacterRangeTable flags
 632      *                   indicating type of the entry.
 633      */
 634     public void genStat(JCTree tree, Env&lt;GenContext&gt; env, int crtFlags) {
 635         if (!genCrt) {
 636             genStat(tree, env);
 637             return;
 638         }
 639         int startpc = code.curCP();
 640         genStat(tree, env);
 641         if (tree.hasTag(Tag.BLOCK)) crtFlags |= CRT_BLOCK;
 642         code.crt.put(tree, crtFlags, startpc, code.curCP());
 643     }
 644 
 645     /** Derived visitor method: generate code for a statement.
 646      */
 647     public void genStat(JCTree tree, Env&lt;GenContext&gt; env) {
 648         if (code.isAlive()) {
 649             code.statBegin(tree.pos);
 650             genDef(tree, env);
 651         } else if (env.info.isSwitch &amp;&amp; tree.hasTag(VARDEF)) {
 652             // variables whose declarations are in a switch
 653             // can be used even if the decl is unreachable.
 654             code.newLocal(((JCVariableDecl) tree).sym);
 655         }
 656     }
 657 
 658     /** Derived visitor method: check whether CharacterRangeTable
 659      *  should be emitted, if so, put a new entry into CRTable
 660      *  and call method to generate bytecode.
 661      *  If not, just call method to generate bytecode.
 662      *  @see    #genStats(List, Env)
 663      *
 664      *  @param  trees    The list of trees to be visited.
 665      *  @param  env      The environment to use.
 666      *  @param  crtFlags The CharacterRangeTable flags
 667      *                   indicating type of the entry.
 668      */
 669     public void genStats(List&lt;JCStatement&gt; trees, Env&lt;GenContext&gt; env, int crtFlags) {
 670         if (!genCrt) {
 671             genStats(trees, env);
 672             return;
 673         }
 674         if (trees.length() == 1) {        // mark one statement with the flags
 675             genStat(trees.head, env, crtFlags | CRT_STATEMENT);
 676         } else {
 677             int startpc = code.curCP();
 678             genStats(trees, env);
 679             code.crt.put(trees, crtFlags, startpc, code.curCP());
 680         }
 681     }
 682 
 683     /** Derived visitor method: generate code for a list of statements.
 684      */
 685     public void genStats(List&lt;? extends JCTree&gt; trees, Env&lt;GenContext&gt; env) {
 686         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 687             genStat(l.head, env, CRT_STATEMENT);
 688     }
 689 
 690     /** Derived visitor method: check whether CharacterRangeTable
 691      *  should be emitted, if so, put a new entry into CRTable
 692      *  and call method to generate bytecode.
 693      *  If not, just call method to generate bytecode.
 694      *  @see    #genCond(JCTree,boolean)
 695      *
 696      *  @param  tree     The tree to be visited.
 697      *  @param  crtFlags The CharacterRangeTable flags
 698      *                   indicating type of the entry.
 699      */
 700     public CondItem genCond(JCTree tree, int crtFlags) {
 701         if (!genCrt) return genCond(tree, false);
 702         int startpc = code.curCP();
 703         CondItem item = genCond(tree, (crtFlags &amp; CRT_FLOW_CONTROLLER) != 0);
 704         code.crt.put(tree, crtFlags, startpc, code.curCP());
 705         return item;
 706     }
 707 
 708     /** Derived visitor method: generate code for a boolean
 709      *  expression in a control-flow context.
 710      *  @param _tree         The expression to be visited.
 711      *  @param markBranches The flag to indicate that the condition is
 712      *                      a flow controller so produced conditions
 713      *                      should contain a proper tree to generate
 714      *                      CharacterRangeTable branches for them.
 715      */
 716     public CondItem genCond(JCTree _tree, boolean markBranches) {
 717         JCTree inner_tree = TreeInfo.skipParens(_tree);
 718         if (inner_tree.hasTag(CONDEXPR)) {
 719             JCConditional tree = (JCConditional)inner_tree;
 720             CondItem cond = genCond(tree.cond, CRT_FLOW_CONTROLLER);
 721             if (cond.isTrue()) {
 722                 code.resolve(cond.trueJumps);
 723                 CondItem result = genCond(tree.truepart, CRT_FLOW_TARGET);
 724                 if (markBranches) result.tree = tree.truepart;
 725                 return result;
 726             }
 727             if (cond.isFalse()) {
 728                 code.resolve(cond.falseJumps);
 729                 CondItem result = genCond(tree.falsepart, CRT_FLOW_TARGET);
 730                 if (markBranches) result.tree = tree.falsepart;
 731                 return result;
 732             }
 733             Chain secondJumps = cond.jumpFalse();
 734             code.resolve(cond.trueJumps);
 735             CondItem first = genCond(tree.truepart, CRT_FLOW_TARGET);
 736             if (markBranches) first.tree = tree.truepart;
 737             Chain falseJumps = first.jumpFalse();
 738             code.resolve(first.trueJumps);
 739             Chain trueJumps = code.branch(goto_);
 740             code.resolve(secondJumps);
 741             CondItem second = genCond(tree.falsepart, CRT_FLOW_TARGET);
 742             CondItem result = items.makeCondItem(second.opcode,
 743                                       Code.mergeChains(trueJumps, second.trueJumps),
 744                                       Code.mergeChains(falseJumps, second.falseJumps));
 745             if (markBranches) result.tree = tree.falsepart;
 746             return result;
 747         } else if (inner_tree.hasTag(SWITCH_EXPRESSION)) {
 748             code.resolvePending();
 749 
 750             boolean prevInCondSwitchExpression = inCondSwitchExpression;
 751             Chain prevSwitchExpressionTrueChain = switchExpressionTrueChain;
 752             Chain prevSwitchExpressionFalseChain = switchExpressionFalseChain;
 753             try {
 754                 inCondSwitchExpression = true;
 755                 switchExpressionTrueChain = null;
 756                 switchExpressionFalseChain = null;
 757                 try {
 758                     doHandleSwitchExpression((JCSwitchExpression) inner_tree);
 759                 } catch (CompletionFailure ex) {
 760                     chk.completionError(_tree.pos(), ex);
 761                     code.state.stacksize = 1;
 762                 }
 763                 CondItem result = items.makeCondItem(goto_,
 764                                                      switchExpressionTrueChain,
 765                                                      switchExpressionFalseChain);
 766                 if (markBranches) result.tree = _tree;
 767                 return result;
 768             } finally {
 769                 inCondSwitchExpression = prevInCondSwitchExpression;
 770                 switchExpressionTrueChain = prevSwitchExpressionTrueChain;
 771                 switchExpressionFalseChain = prevSwitchExpressionFalseChain;
 772             }
 773         } else if (inner_tree.hasTag(LETEXPR) &amp;&amp; ((LetExpr) inner_tree).needsCond) {
 774             code.resolvePending();
 775 
 776             LetExpr tree = (LetExpr) inner_tree;
 777             int limit = code.nextreg;
 778             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
 779             try {
 780                 genStats(tree.defs, env);
 781             } finally {
 782                 code.setLetExprStackPos(prevLetExprStart);
 783             }
 784             CondItem result = genCond(tree.expr, markBranches);
 785             code.endScopes(limit);
 786             return result;
 787         } else {
 788             CondItem result = genExpr(_tree, syms.booleanType).mkCond();
 789             if (markBranches) result.tree = _tree;
 790             return result;
 791         }
 792     }
 793 
 794     public Code getCode() {
 795         return code;
 796     }
 797 
 798     public Items getItems() {
 799         return items;
 800     }
 801 
 802     public Env&lt;AttrContext&gt; getAttrEnv() {
 803         return attrEnv;
 804     }
 805 
 806     /** Visitor class for expressions which might be constant expressions.
 807      *  This class is a subset of TreeScanner. Intended to visit trees pruned by
 808      *  Lower as long as constant expressions looking for references to any
 809      *  ClassSymbol. Any such reference will be added to the constant pool so
 810      *  automated tools can detect class dependencies better.
 811      */
 812     class ClassReferenceVisitor extends JCTree.Visitor {
 813 
 814         @Override
 815         public void visitTree(JCTree tree) {}
 816 
 817         @Override
 818         public void visitBinary(JCBinary tree) {
 819             tree.lhs.accept(this);
 820             tree.rhs.accept(this);
 821         }
 822 
 823         @Override
 824         public void visitSelect(JCFieldAccess tree) {
 825             if (tree.selected.type.hasTag(CLASS)) {
 826                 makeRef(tree.selected.pos(), tree.selected.type);
 827             }
 828         }
 829 
 830         @Override
 831         public void visitIdent(JCIdent tree) {
 832             if (tree.sym.owner instanceof ClassSymbol) {
 833                 poolWriter.putClass((ClassSymbol)tree.sym.owner);
 834             }
 835         }
 836 
 837         @Override
 838         public void visitConditional(JCConditional tree) {
 839             tree.cond.accept(this);
 840             tree.truepart.accept(this);
 841             tree.falsepart.accept(this);
 842         }
 843 
 844         @Override
 845         public void visitUnary(JCUnary tree) {
 846             tree.arg.accept(this);
 847         }
 848 
 849         @Override
 850         public void visitParens(JCParens tree) {
 851             tree.expr.accept(this);
 852         }
 853 
 854         @Override
 855         public void visitTypeCast(JCTypeCast tree) {
 856             tree.expr.accept(this);
 857         }
 858     }
 859 
 860     private ClassReferenceVisitor classReferenceVisitor = new ClassReferenceVisitor();
 861 
 862     /** Visitor method: generate code for an expression, catching and reporting
 863      *  any completion failures.
 864      *  @param tree    The expression to be visited.
 865      *  @param pt      The expression&#39;s expected type (proto-type).
 866      */
 867     public Item genExpr(JCTree tree, Type pt) {
 868         Type prevPt = this.pt;
 869         try {
 870             if (tree.type.constValue() != null) {
 871                 // Short circuit any expressions which are constants
 872                 tree.accept(classReferenceVisitor);
 873                 checkStringConstant(tree.pos(), tree.type.constValue());
 874                 Symbol sym = TreeInfo.symbol(tree);
 875                 if (sym != null &amp;&amp; isConstantDynamic(sym)) {
 876                     result = items.makeDynamicItem(sym);
 877                 } else {
 878                     result = items.makeImmediateItem(tree.type, tree.type.constValue());
 879                 }
 880             } else {
 881                 this.pt = pt;
 882                 tree.accept(this);
 883             }
 884             return result.coerce(pt);
 885         } catch (CompletionFailure ex) {
 886             chk.completionError(tree.pos(), ex);
 887             code.state.stacksize = 1;
 888             return items.makeStackItem(pt);
 889         } finally {
 890             this.pt = prevPt;
 891         }
 892     }
 893 
 894     public boolean isConstantDynamic(Symbol sym) {
 895         return sym.kind == VAR &amp;&amp;
 896                 sym instanceof DynamicVarSymbol &amp;&amp;
 897                 ((DynamicVarSymbol)sym).isDynamic();
 898     }
 899 
 900     /** Derived visitor method: generate code for a list of method arguments.
 901      *  @param trees    The argument expressions to be visited.
 902      *  @param pts      The expression&#39;s expected types (i.e. the formal parameter
 903      *                  types of the invoked method).
 904      */
 905     public void genArgs(List&lt;JCExpression&gt; trees, List&lt;Type&gt; pts) {
 906         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail) {
 907             genExpr(l.head, pts.head).load();
 908             pts = pts.tail;
 909         }
 910         // require lists be of same length
 911         Assert.check(pts.isEmpty());
 912     }
 913 
 914 /* ************************************************************************
 915  * Visitor methods for statements and definitions
 916  *************************************************************************/
 917 
 918     /** Thrown when the byte code size exceeds limit.
 919      */
 920     public static class CodeSizeOverflow extends RuntimeException {
 921         private static final long serialVersionUID = 0;
 922         public CodeSizeOverflow() {}
 923     }
 924 
 925     public void visitMethodDef(JCMethodDecl tree) {
 926         // Create a new local environment that points pack at method
 927         // definition.
 928         Env&lt;GenContext&gt; localEnv = env.dup(tree);
 929         localEnv.enclMethod = tree;
 930         // The expected type of every return statement in this method
 931         // is the method&#39;s return type.
 932         this.pt = tree.sym.erasure(types).getReturnType();
 933 
 934         checkDimension(tree.pos(), tree.sym.erasure(types));
 935         genMethod(tree, localEnv, false);
 936     }
 937 //where
 938         /** Generate code for a method.
 939          *  @param tree     The tree representing the method definition.
 940          *  @param env      The environment current for the method body.
 941          *  @param fatcode  A flag that indicates whether all jumps are
 942          *                  within 32K.  We first invoke this method under
 943          *                  the assumption that fatcode == false, i.e. all
 944          *                  jumps are within 32K.  If this fails, fatcode
 945          *                  is set to true and we try again.
 946          */
 947         void genMethod(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
 948             MethodSymbol meth = tree.sym;
 949             int extras = 0;
 950             // Count up extra parameters
 951             if (meth.isConstructor()) {
 952                 extras++;
 953                 if (meth.enclClass().isInner() &amp;&amp;
 954                     !meth.enclClass().isStatic()) {
 955                     extras++;
 956                 }
 957             } else if ((tree.mods.flags &amp; STATIC) == 0) {
 958                 extras++;
 959             }
 960             //      System.err.println(&quot;Generating &quot; + meth + &quot; in &quot; + meth.owner); //DEBUG
 961             if (Code.width(types.erasure(env.enclMethod.sym.type).getParameterTypes()) + extras &gt;
 962                 ClassFile.MAX_PARAMETERS) {
 963                 log.error(tree.pos(), Errors.LimitParameters);
 964                 nerrs++;
 965             }
 966 
 967             else if (tree.body != null) {
 968                 // Create a new code structure and initialize it.
 969                 int startpcCrt = initCode(tree, env, fatcode);
 970 
 971                 try {
 972                     genStat(tree.body, env);
 973                 } catch (CodeSizeOverflow e) {
 974                     // Failed due to code limit, try again with jsr/ret
 975                     startpcCrt = initCode(tree, env, fatcode);
 976                     genStat(tree.body, env);
 977                 }
 978 
 979                 if (code.state.stacksize != 0) {
 980                     log.error(tree.body.pos(), Errors.StackSimError(tree.sym));
 981                     throw new AssertionError();
 982                 }
 983 
 984                 // If last statement could complete normally, insert a
 985                 // return at the end.
 986                 if (code.isAlive()) {
 987                     code.statBegin(TreeInfo.endPos(tree.body));
 988                     if (env.enclMethod == null ||
 989                         env.enclMethod.sym.type.getReturnType().hasTag(VOID)) {
 990                         code.emitop0(return_);
 991                     } else if (env.enclMethod.sym.isValueFactory()) {
 992                         items.makeLocalItem(env.enclMethod.factoryProduct).load();
 993                         code.emitop0(areturn);
 994                     } else {
 995                         // sometime dead code seems alive (4415991);
 996                         // generate a small loop instead
 997                         int startpc = code.entryPoint();
 998                         CondItem c = items.makeCondItem(goto_);
 999                         code.resolve(c.jumpTrue(), startpc);
1000                     }
1001                 }
1002                 if (genCrt)
1003                     code.crt.put(tree.body,
1004                                  CRT_BLOCK,
1005                                  startpcCrt,
1006                                  code.curCP());
1007 
1008                 code.endScopes(0);
1009 
1010                 // If we exceeded limits, panic
1011                 if (code.checkLimits(tree.pos(), log)) {
1012                     nerrs++;
1013                     return;
1014                 }
1015 
1016                 // If we generated short code but got a long jump, do it again
1017                 // with fatCode = true.
1018                 if (!fatcode &amp;&amp; code.fatcode) genMethod(tree, env, true);
1019 
1020                 // Clean up
1021                 if(stackMap == StackMapFormat.JSR202) {
1022                     code.lastFrame = null;
1023                     code.frameBeforeLast = null;
1024                 }
1025 
1026                 // Compress exception table
1027                 code.compressCatchTable();
1028 
1029                 // Fill in type annotation positions for exception parameters
1030                 code.fillExceptionParameterPositions();
1031             }
1032         }
1033 
1034         private int initCode(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
1035             MethodSymbol meth = tree.sym;
1036 
1037             // Create a new code structure.
1038             meth.code = code = new Code(meth,
1039                                         fatcode,
1040                                         lineDebugInfo ? toplevel.lineMap : null,
1041                                         varDebugInfo,
1042                                         stackMap,
1043                                         debugCode,
1044                                         genCrt ? new CRTable(tree, env.toplevel.endPositions)
1045                                                : null,
1046                                         syms,
1047                                         types,
1048                                         poolWriter);
1049             items = new Items(poolWriter, code, syms, types);
1050             if (code.debugCode) {
1051                 System.err.println(meth + &quot; for body &quot; + tree);
1052             }
1053 
1054             // If method is not static, create a new local variable address
1055             // for `this&#39;.
1056             if ((tree.mods.flags &amp; STATIC) == 0) {
1057                 Type selfType = meth.owner.type;
1058                 if (meth.isConstructor() &amp;&amp; selfType != syms.objectType)
1059                     selfType = UninitializedType.uninitializedThis(selfType);
1060                 code.setDefined(
1061                         code.newLocal(
1062                             new VarSymbol(FINAL, names._this, selfType, meth.owner)));
1063             }
1064 
1065             // Mark all parameters as defined from the beginning of
1066             // the method.
1067             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1068                 checkDimension(l.head.pos(), l.head.sym.type);
1069                 code.setDefined(code.newLocal(l.head.sym));
1070             }
1071 
1072             // Get ready to generate code for method body.
1073             int startpcCrt = genCrt ? code.curCP() : 0;
1074             code.entryPoint();
1075 
1076             // Suppress initial stackmap
1077             code.pendingStackMap = false;
1078 
1079             return startpcCrt;
1080         }
1081 
1082         private void synthesizeValueMethod(JCMethodDecl methodDecl) {
1083 
1084             Name name; List&lt;Type&gt; argTypes; Type resType;
1085 
1086             switch (methodDecl.name.toString()) {
1087                 case &quot;toString&quot;:
1088                     name = names.toString;
1089                     argTypes = List.of(methodDecl.sym.owner.type);
1090                     resType = methodDecl.restype.type;
1091                     break;
1092                 default:
1093                     throw new AssertionError(&quot;Unexpected synthetic method body&quot;);
1094             }
1095 
1096             Type.MethodType indyType = new Type.MethodType(argTypes,
1097                     resType,
1098                     List.nil(),
1099                     syms.methodClass);
1100 
1101             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
1102                                                 syms.stringType,
1103                                                 syms.methodTypeType);
1104 
1105             Symbol bsm = rs.resolveInternalMethod(methodDecl.pos(),
1106                     getAttrEnv(),
1107                     syms.valueBootstrapMethods,
1108                     names.fromString(&quot;makeBootstrapMethod&quot;),
1109                     bsm_staticArgs,
1110                     null);
1111 
1112             Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(name,
1113                     syms.noSymbol,
1114                     ((MethodSymbol)bsm).asHandle(),
1115                     indyType,
1116                     List.nil().toArray(new LoadableConstant[0]));
1117 
1118             switch (methodDecl.name.toString()) {
1119                 case &quot;toString&quot;:
1120                     code.emitop0(aload_0);
1121                     items.makeDynamicItem(dynSym).invoke();
1122                     code.emitop0(areturn);
1123                     return;
1124             }
1125         }
1126 
1127     public void visitVarDef(JCVariableDecl tree) {
1128         VarSymbol v = tree.sym;
1129         if (tree.init != null) {
1130             checkStringConstant(tree.init.pos(), v.getConstValue());
1131             if (v.getConstValue() == null || varDebugInfo) {
1132                 Assert.check(code.isStatementStart());
1133                 code.newLocal(v);
1134                 genExpr(tree.init, v.erasure(types)).load();
1135                 items.makeLocalItem(v).store();
1136                 Assert.check(code.isStatementStart());
1137             }
1138         } else {
1139             code.newLocal(v);
1140         }
1141         checkDimension(tree.pos(), v.type);
1142     }
1143 
1144     public void visitSkip(JCSkip tree) {
1145     }
1146 
1147     public void visitBlock(JCBlock tree) {
1148         if ((tree.flags &amp; SYNTHETIC) != 0 &amp;&amp; env.tree.hasTag(METHODDEF) &amp;&amp; (((JCMethodDecl) env.tree).sym.owner.flags() &amp; VALUE) != 0) {
1149             synthesizeValueMethod((JCMethodDecl) env.tree);
1150             return;
1151         }
1152         int limit = code.nextreg;
1153         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1154         genStats(tree.stats, localEnv);
1155         // End the scope of all block-local variables in variable info.
1156         if (!env.tree.hasTag(METHODDEF)) {
1157             code.statBegin(tree.endpos);
1158             code.endScopes(limit);
1159             code.pendingStatPos = Position.NOPOS;
1160         }
1161     }
1162 
1163     public void visitDoLoop(JCDoWhileLoop tree) {
1164         genLoop(tree, tree.body, tree.cond, List.nil(), false);
1165     }
1166 
1167     public void visitWhileLoop(JCWhileLoop tree) {
1168         genLoop(tree, tree.body, tree.cond, List.nil(), true);
1169     }
1170 
1171     public void visitWithField(JCWithField tree) {
1172         switch(tree.field.getTag()) {
1173             case IDENT:
1174                 Symbol sym = ((JCIdent) tree.field).sym;
1175                 items.makeThisItem().load();
1176                 genExpr(tree.value, tree.field.type).load();
1177                 sym = binaryQualifier(sym, env.enclClass.type);
1178                 code.emitop2(withfield, sym, PoolWriter::putMember);
1179                 result = items.makeStackItem(tree.type);
1180                 break;
1181             case SELECT:
1182                 JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;
1183                 sym = TreeInfo.symbol(fieldAccess);
1184                 // JDK-8207332: To maintain the order of side effects, must compute value ahead of field
1185                 genExpr(tree.value, tree.field.type).load();
1186                 genExpr(fieldAccess.selected, fieldAccess.selected.type).load();
1187                 if (Code.width(tree.field.type) == 2) {
1188                     code.emitop0(dup_x2);
1189                     code.emitop0(pop);
1190                 } else {
1191                     code.emitop0(swap);
1192                 }
1193                 sym = binaryQualifier(sym, fieldAccess.selected.type);
1194                 code.emitop2(withfield, sym, PoolWriter::putMember);
1195                 result = items.makeStackItem(tree.type);
1196                 break;
1197             default:
1198                 Assert.check(false);
1199         }
1200     }
1201 
1202     public void visitForLoop(JCForLoop tree) {
1203         int limit = code.nextreg;
1204         genStats(tree.init, env);
1205         genLoop(tree, tree.body, tree.cond, tree.step, true);
1206         code.endScopes(limit);
1207     }
1208     //where
1209         /** Generate code for a loop.
1210          *  @param loop       The tree representing the loop.
1211          *  @param body       The loop&#39;s body.
1212          *  @param cond       The loop&#39;s controlling condition.
1213          *  @param step       &quot;Step&quot; statements to be inserted at end of
1214          *                    each iteration.
1215          *  @param testFirst  True if the loop test belongs before the body.
1216          */
1217         private void genLoop(JCStatement loop,
1218                              JCStatement body,
1219                              JCExpression cond,
1220                              List&lt;JCExpressionStatement&gt; step,
1221                              boolean testFirst) {
1222             Env&lt;GenContext&gt; loopEnv = env.dup(loop, new GenContext());
1223             int startpc = code.entryPoint();
1224             if (testFirst) { //while or for loop
1225                 CondItem c;
1226                 if (cond != null) {
1227                     code.statBegin(cond.pos);
1228                     Assert.check(code.isStatementStart());
1229                     c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1230                 } else {
1231                     c = items.makeCondItem(goto_);
1232                 }
1233                 Chain loopDone = c.jumpFalse();
1234                 code.resolve(c.trueJumps);
1235                 Assert.check(code.isStatementStart());
1236                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1237                 code.resolve(loopEnv.info.cont);
1238                 genStats(step, loopEnv);
1239                 code.resolve(code.branch(goto_), startpc);
1240                 code.resolve(loopDone);
1241             } else {
1242                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1243                 code.resolve(loopEnv.info.cont);
1244                 genStats(step, loopEnv);
1245                 if (code.isAlive()) {
1246                     CondItem c;
1247                     if (cond != null) {
1248                         code.statBegin(cond.pos);
1249                         Assert.check(code.isStatementStart());
1250                         c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1251                     } else {
1252                         c = items.makeCondItem(goto_);
1253                     }
1254                     code.resolve(c.jumpTrue(), startpc);
1255                     Assert.check(code.isStatementStart());
1256                     code.resolve(c.falseJumps);
1257                 }
1258             }
1259             Chain exit = loopEnv.info.exit;
1260             if (exit != null) {
1261                 code.resolve(exit);
1262                 exit.state.defined.excludeFrom(code.nextreg);
1263             }
1264         }
1265 
1266     public void visitForeachLoop(JCEnhancedForLoop tree) {
1267         throw new AssertionError(); // should have been removed by Lower.
1268     }
1269 
1270     public void visitLabelled(JCLabeledStatement tree) {
1271         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1272         genStat(tree.body, localEnv, CRT_STATEMENT);
1273         Chain exit = localEnv.info.exit;
1274         if (exit != null) {
1275             code.resolve(exit);
1276             exit.state.defined.excludeFrom(code.nextreg);
1277         }
1278     }
1279 
1280     public void visitSwitch(JCSwitch tree) {
1281         handleSwitch(tree, tree.selector, tree.cases);
1282     }
1283 
1284     @Override
1285     public void visitSwitchExpression(JCSwitchExpression tree) {
1286         code.resolvePending();
1287         boolean prevInCondSwitchExpression = inCondSwitchExpression;
1288         try {
1289             inCondSwitchExpression = false;
1290             doHandleSwitchExpression(tree);
1291         } finally {
1292             inCondSwitchExpression = prevInCondSwitchExpression;
1293         }
1294         result = items.makeStackItem(pt);
1295     }
1296 
1297     private void doHandleSwitchExpression(JCSwitchExpression tree) {
1298         List&lt;LocalItem&gt; prevStackBeforeSwitchExpression = stackBeforeSwitchExpression;
1299         LocalItem prevSwitchResult = switchResult;
1300         int limit = code.nextreg;
1301         try {
1302             stackBeforeSwitchExpression = List.nil();
1303             switchResult = null;
1304             if (hasTry(tree)) {
1305                 //if the switch expression contains try-catch, the catch handlers need to have
1306                 //an empty stack. So stash whole stack to local variables, and restore it before
1307                 //breaks:
1308                 while (code.state.stacksize &gt; 0) {
1309                     Type type = code.state.peek();
1310                     Name varName = names.fromString(target.syntheticNameChar() +
1311                                                     &quot;stack&quot; +
1312                                                     target.syntheticNameChar() +
1313                                                     tree.pos +
1314                                                     target.syntheticNameChar() +
1315                                                     code.state.stacksize);
1316                     VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,
1317                                                   this.env.enclMethod.sym);
1318                     LocalItem item = items.new LocalItem(type, code.newLocal(var));
1319                     stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);
1320                     item.store();
1321                 }
1322                 switchResult = makeTemp(tree.type);
1323             }
1324             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
1325             try {
1326                 handleSwitch(tree, tree.selector, tree.cases);
1327             } finally {
1328                 code.setLetExprStackPos(prevLetExprStart);
1329             }
1330         } finally {
1331             stackBeforeSwitchExpression = prevStackBeforeSwitchExpression;
1332             switchResult = prevSwitchResult;
1333             code.endScopes(limit);
1334         }
1335     }
1336     //where:
1337         private boolean hasTry(JCSwitchExpression tree) {
1338             boolean[] hasTry = new boolean[1];
1339             new TreeScanner() {
1340                 @Override
1341                 public void visitTry(JCTry tree) {
1342                     hasTry[0] = true;
1343                 }
1344 
1345                 @Override
1346                 public void visitClassDef(JCClassDecl tree) {
1347                 }
1348 
1349                 @Override
1350                 public void visitLambda(JCLambda tree) {
1351                 }
1352             }.scan(tree);
1353             return hasTry[0];
1354         }
1355 
1356     private void handleSwitch(JCTree swtch, JCExpression selector, List&lt;JCCase&gt; cases) {
1357         int limit = code.nextreg;
1358         Assert.check(!selector.type.hasTag(CLASS));
1359         int startpcCrt = genCrt ? code.curCP() : 0;
1360         Assert.check(code.isStatementStart());
1361         Item sel = genExpr(selector, syms.intType);
1362         if (cases.isEmpty()) {
1363             // We are seeing:  switch &lt;sel&gt; {}
1364             sel.load().drop();
1365             if (genCrt)
1366                 code.crt.put(TreeInfo.skipParens(selector),
1367                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1368         } else {
1369             // We are seeing a nonempty switch.
1370             sel.load();
1371             if (genCrt)
1372                 code.crt.put(TreeInfo.skipParens(selector),
1373                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1374             Env&lt;GenContext&gt; switchEnv = env.dup(swtch, new GenContext());
1375             switchEnv.info.isSwitch = true;
1376 
1377             // Compute number of labels and minimum and maximum label values.
1378             // For each case, store its label in an array.
1379             int lo = Integer.MAX_VALUE;  // minimum label.
1380             int hi = Integer.MIN_VALUE;  // maximum label.
1381             int nlabels = 0;               // number of labels.
1382 
1383             int[] labels = new int[cases.length()];  // the label array.
1384             int defaultIndex = -1;     // the index of the default clause.
1385 
1386             List&lt;JCCase&gt; l = cases;
1387             for (int i = 0; i &lt; labels.length; i++) {
1388                 if (l.head.pats.nonEmpty()) {
1389                     Assert.check(l.head.pats.size() == 1);
1390                     int val = ((Number)l.head.pats.head.type.constValue()).intValue();
1391                     labels[i] = val;
1392                     if (val &lt; lo) lo = val;
1393                     if (hi &lt; val) hi = val;
1394                     nlabels++;
1395                 } else {
1396                     Assert.check(defaultIndex == -1);
1397                     defaultIndex = i;
1398                 }
1399                 l = l.tail;
1400             }
1401 
1402             // Determine whether to issue a tableswitch or a lookupswitch
1403             // instruction.
1404             long table_space_cost = 4 + ((long) hi - lo + 1); // words
1405             long table_time_cost = 3; // comparisons
1406             long lookup_space_cost = 3 + 2 * (long) nlabels;
1407             long lookup_time_cost = nlabels;
1408             int opcode =
1409                 nlabels &gt; 0 &amp;&amp;
1410                 table_space_cost + 3 * table_time_cost &lt;=
1411                 lookup_space_cost + 3 * lookup_time_cost
1412                 ?
1413                 tableswitch : lookupswitch;
1414 
1415             int startpc = code.curCP();    // the position of the selector operation
1416             code.emitop0(opcode);
1417             code.align(4);
1418             int tableBase = code.curCP();  // the start of the jump table
1419             int[] offsets = null;          // a table of offsets for a lookupswitch
1420             code.emit4(-1);                // leave space for default offset
1421             if (opcode == tableswitch) {
1422                 code.emit4(lo);            // minimum label
1423                 code.emit4(hi);            // maximum label
1424                 for (long i = lo; i &lt;= hi; i++) {  // leave space for jump table
1425                     code.emit4(-1);
1426                 }
1427             } else {
1428                 code.emit4(nlabels);    // number of labels
1429                 for (int i = 0; i &lt; nlabels; i++) {
1430                     code.emit4(-1); code.emit4(-1); // leave space for lookup table
1431                 }
1432                 offsets = new int[labels.length];
1433             }
1434             Code.State stateSwitch = code.state.dup();
1435             code.markDead();
1436 
1437             // For each case do:
1438             l = cases;
1439             for (int i = 0; i &lt; labels.length; i++) {
1440                 JCCase c = l.head;
1441                 l = l.tail;
1442 
1443                 int pc = code.entryPoint(stateSwitch);
1444                 // Insert offset directly into code or else into the
1445                 // offsets table.
1446                 if (i != defaultIndex) {
1447                     if (opcode == tableswitch) {
1448                         code.put4(
1449                             tableBase + 4 * (labels[i] - lo + 3),
1450                             pc - startpc);
1451                     } else {
1452                         offsets[i] = pc - startpc;
1453                     }
1454                 } else {
1455                     code.put4(tableBase, pc - startpc);
1456                 }
1457 
1458                 // Generate code for the statements in this case.
1459                 genStats(c.stats, switchEnv, CRT_FLOW_TARGET);
1460             }
1461 
1462             // Resolve all breaks.
1463             Chain exit = switchEnv.info.exit;
1464             if  (exit != null) {
1465                 code.resolve(exit);
1466                 exit.state.defined.excludeFrom(limit);
1467             }
1468 
1469             // If we have not set the default offset, we do so now.
1470             if (code.get4(tableBase) == -1) {
1471                 code.put4(tableBase, code.entryPoint(stateSwitch) - startpc);
1472             }
1473 
1474             if (opcode == tableswitch) {
1475                 // Let any unfilled slots point to the default case.
1476                 int defaultOffset = code.get4(tableBase);
1477                 for (long i = lo; i &lt;= hi; i++) {
1478                     int t = (int)(tableBase + 4 * (i - lo + 3));
1479                     if (code.get4(t) == -1)
1480                         code.put4(t, defaultOffset);
1481                 }
1482             } else {
1483                 // Sort non-default offsets and copy into lookup table.
1484                 if (defaultIndex &gt;= 0)
1485                     for (int i = defaultIndex; i &lt; labels.length - 1; i++) {
1486                         labels[i] = labels[i+1];
1487                         offsets[i] = offsets[i+1];
1488                     }
1489                 if (nlabels &gt; 0)
1490                     qsort2(labels, offsets, 0, nlabels - 1);
1491                 for (int i = 0; i &lt; nlabels; i++) {
1492                     int caseidx = tableBase + 8 * (i + 1);
1493                     code.put4(caseidx, labels[i]);
1494                     code.put4(caseidx + 4, offsets[i]);
1495                 }
1496             }
1497         }
1498         code.endScopes(limit);
1499     }
1500 //where
1501         /** Sort (int) arrays of keys and values
1502          */
1503        static void qsort2(int[] keys, int[] values, int lo, int hi) {
1504             int i = lo;
1505             int j = hi;
1506             int pivot = keys[(i+j)/2];
1507             do {
1508                 while (keys[i] &lt; pivot) i++;
1509                 while (pivot &lt; keys[j]) j--;
1510                 if (i &lt;= j) {
1511                     int temp1 = keys[i];
1512                     keys[i] = keys[j];
1513                     keys[j] = temp1;
1514                     int temp2 = values[i];
1515                     values[i] = values[j];
1516                     values[j] = temp2;
1517                     i++;
1518                     j--;
1519                 }
1520             } while (i &lt;= j);
1521             if (lo &lt; j) qsort2(keys, values, lo, j);
1522             if (i &lt; hi) qsort2(keys, values, i, hi);
1523         }
1524 
1525     public void visitSynchronized(JCSynchronized tree) {
1526         int limit = code.nextreg;
1527         // Generate code to evaluate lock and save in temporary variable.
1528         final LocalItem lockVar = makeTemp(syms.objectType);
1529         Assert.check(code.isStatementStart());
1530         genExpr(tree.lock, tree.lock.type).load().duplicate();
1531         lockVar.store();
1532 
1533         // Generate code to enter monitor.
1534         code.emitop0(monitorenter);
1535         code.state.lock(lockVar.reg);
1536 
1537         // Generate code for a try statement with given body, no catch clauses
1538         // in a new environment with the &quot;exit-monitor&quot; operation as finalizer.
1539         final Env&lt;GenContext&gt; syncEnv = env.dup(tree, new GenContext());
1540         syncEnv.info.finalize = new GenFinalizer() {
1541             void gen() {
1542                 genLast();
1543                 Assert.check(syncEnv.info.gaps.length() % 2 == 0);
1544                 syncEnv.info.gaps.append(code.curCP());
1545             }
1546             void genLast() {
1547                 if (code.isAlive()) {
1548                     lockVar.load();
1549                     code.emitop0(monitorexit);
1550                     code.state.unlock(lockVar.reg);
1551                 }
1552             }
1553         };
1554         syncEnv.info.gaps = new ListBuffer&lt;&gt;();
1555         genTry(tree.body, List.nil(), syncEnv);
1556         code.endScopes(limit);
1557     }
1558 
1559     public void visitTry(final JCTry tree) {
1560         // Generate code for a try statement with given body and catch clauses,
1561         // in a new environment which calls the finally block if there is one.
1562         final Env&lt;GenContext&gt; tryEnv = env.dup(tree, new GenContext());
1563         final Env&lt;GenContext&gt; oldEnv = env;
1564         tryEnv.info.finalize = new GenFinalizer() {
1565             void gen() {
1566                 Assert.check(tryEnv.info.gaps.length() % 2 == 0);
1567                 tryEnv.info.gaps.append(code.curCP());
1568                 genLast();
1569             }
1570             void genLast() {
1571                 if (tree.finalizer != null)
1572                     genStat(tree.finalizer, oldEnv, CRT_BLOCK);
1573             }
1574             boolean hasFinalizer() {
1575                 return tree.finalizer != null;
1576             }
1577 
1578             @Override
1579             void afterBody() {
1580                 if (tree.finalizer != null &amp;&amp; (tree.finalizer.flags &amp; BODY_ONLY_FINALIZE) != 0) {
1581                     //for body-only finally, remove the GenFinalizer after try body
1582                     //so that the finally is not generated to catch bodies:
1583                     tryEnv.info.finalize = null;
1584                 }
1585             }
1586 
1587         };
1588         tryEnv.info.gaps = new ListBuffer&lt;&gt;();
1589         genTry(tree.body, tree.catchers, tryEnv);
1590     }
1591     //where
1592         /** Generate code for a try or synchronized statement
1593          *  @param body      The body of the try or synchronized statement.
1594          *  @param catchers  The lis of catch clauses.
1595          *  @param env       the environment current for the body.
1596          */
1597         void genTry(JCTree body, List&lt;JCCatch&gt; catchers, Env&lt;GenContext&gt; env) {
1598             int limit = code.nextreg;
1599             int startpc = code.curCP();
1600             Code.State stateTry = code.state.dup();
1601             genStat(body, env, CRT_BLOCK);
1602             int endpc = code.curCP();
1603             List&lt;Integer&gt; gaps = env.info.gaps.toList();
1604             code.statBegin(TreeInfo.endPos(body));
1605             genFinalizer(env);
1606             code.statBegin(TreeInfo.endPos(env.tree));
1607             Chain exitChain = code.branch(goto_);
1608             endFinalizerGap(env);
1609             env.info.finalize.afterBody();
1610             boolean hasFinalizer =
1611                 env.info.finalize != null &amp;&amp;
1612                 env.info.finalize.hasFinalizer();
1613             if (startpc != endpc) for (List&lt;JCCatch&gt; l = catchers; l.nonEmpty(); l = l.tail) {
1614                 // start off with exception on stack
1615                 code.entryPoint(stateTry, l.head.param.sym.type);
1616                 genCatch(l.head, env, startpc, endpc, gaps);
1617                 genFinalizer(env);
1618                 if (hasFinalizer || l.tail.nonEmpty()) {
1619                     code.statBegin(TreeInfo.endPos(env.tree));
1620                     exitChain = Code.mergeChains(exitChain,
1621                                                  code.branch(goto_));
1622                 }
1623                 endFinalizerGap(env);
1624             }
1625             if (hasFinalizer) {
1626                 // Create a new register segment to avoid allocating
1627                 // the same variables in finalizers and other statements.
1628                 code.newRegSegment();
1629 
1630                 // Add a catch-all clause.
1631 
1632                 // start off with exception on stack
1633                 int catchallpc = code.entryPoint(stateTry, syms.throwableType);
1634 
1635                 // Register all exception ranges for catch all clause.
1636                 // The range of the catch all clause is from the beginning
1637                 // of the try or synchronized block until the present
1638                 // code pointer excluding all gaps in the current
1639                 // environment&#39;s GenContext.
1640                 int startseg = startpc;
1641                 while (env.info.gaps.nonEmpty()) {
1642                     int endseg = env.info.gaps.next().intValue();
1643                     registerCatch(body.pos(), startseg, endseg,
1644                                   catchallpc, 0);
1645                     startseg = env.info.gaps.next().intValue();
1646                 }
1647                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1648                 code.markStatBegin();
1649 
1650                 Item excVar = makeTemp(syms.throwableType);
1651                 excVar.store();
1652                 genFinalizer(env);
1653                 code.resolvePending();
1654                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.END_POS));
1655                 code.markStatBegin();
1656 
1657                 excVar.load();
1658                 registerCatch(body.pos(), startseg,
1659                               env.info.gaps.next().intValue(),
1660                               catchallpc, 0);
1661                 code.emitop0(athrow);
1662                 code.markDead();
1663 
1664                 // If there are jsr&#39;s to this finalizer, ...
1665                 if (env.info.cont != null) {
1666                     // Resolve all jsr&#39;s.
1667                     code.resolve(env.info.cont);
1668 
1669                     // Mark statement line number
1670                     code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1671                     code.markStatBegin();
1672 
1673                     // Save return address.
1674                     LocalItem retVar = makeTemp(syms.throwableType);
1675                     retVar.store();
1676 
1677                     // Generate finalizer code.
1678                     env.info.finalize.genLast();
1679 
1680                     // Return.
1681                     code.emitop1w(ret, retVar.reg);
1682                     code.markDead();
1683                 }
1684             }
1685             // Resolve all breaks.
1686             code.resolve(exitChain);
1687 
1688             code.endScopes(limit);
1689         }
1690 
1691         /** Generate code for a catch clause.
1692          *  @param tree     The catch clause.
1693          *  @param env      The environment current in the enclosing try.
1694          *  @param startpc  Start pc of try-block.
1695          *  @param endpc    End pc of try-block.
1696          */
1697         void genCatch(JCCatch tree,
1698                       Env&lt;GenContext&gt; env,
1699                       int startpc, int endpc,
1700                       List&lt;Integer&gt; gaps) {
1701             if (startpc != endpc) {
1702                 List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypeExprs
1703                         = catchTypesWithAnnotations(tree);
1704                 while (gaps.nonEmpty()) {
1705                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1706                         JCExpression subCatch = subCatch1.snd;
1707                         int catchType = makeRef(tree.pos(), subCatch.type);
1708                         int end = gaps.head.intValue();
1709                         registerCatch(tree.pos(),
1710                                       startpc,  end, code.curCP(),
1711                                       catchType);
1712                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1713                                 tc.position.setCatchInfo(catchType, startpc);
1714                         }
1715                     }
1716                     gaps = gaps.tail;
1717                     startpc = gaps.head.intValue();
1718                     gaps = gaps.tail;
1719                 }
1720                 if (startpc &lt; endpc) {
1721                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1722                         JCExpression subCatch = subCatch1.snd;
1723                         int catchType = makeRef(tree.pos(), subCatch.type);
1724                         registerCatch(tree.pos(),
1725                                       startpc, endpc, code.curCP(),
1726                                       catchType);
1727                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1728                             tc.position.setCatchInfo(catchType, startpc);
1729                         }
1730                     }
1731                 }
1732                 VarSymbol exparam = tree.param.sym;
1733                 code.statBegin(tree.pos);
1734                 code.markStatBegin();
1735                 int limit = code.nextreg;
1736                 code.newLocal(exparam);
1737                 items.makeLocalItem(exparam).store();
1738                 code.statBegin(TreeInfo.firstStatPos(tree.body));
1739                 genStat(tree.body, env, CRT_BLOCK);
1740                 code.endScopes(limit);
1741                 code.statBegin(TreeInfo.endPos(tree.body));
1742             }
1743         }
1744         // where
1745         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotations(JCCatch tree) {
1746             return TreeInfo.isMultiCatch(tree) ?
1747                     catchTypesWithAnnotationsFromMulticatch((JCTypeUnion)tree.param.vartype, tree.param.sym.getRawTypeAttributes()) :
1748                     List.of(new Pair&lt;&gt;(tree.param.sym.getRawTypeAttributes(), tree.param.vartype));
1749         }
1750         // where
1751         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotationsFromMulticatch(JCTypeUnion tree, List&lt;TypeCompound&gt; first) {
1752             List&lt;JCExpression&gt; alts = tree.alternatives;
1753             List&lt;Pair&lt;List&lt;TypeCompound&gt;, JCExpression&gt;&gt; res = List.of(new Pair&lt;&gt;(first, alts.head));
1754             alts = alts.tail;
1755 
1756             while(alts != null &amp;&amp; alts.head != null) {
1757                 JCExpression alt = alts.head;
1758                 if (alt instanceof JCAnnotatedType) {
1759                     JCAnnotatedType a = (JCAnnotatedType)alt;
1760                     res = res.prepend(new Pair&lt;&gt;(annotate.fromAnnotations(a.annotations), alt));
1761                 } else {
1762                     res = res.prepend(new Pair&lt;&gt;(List.nil(), alt));
1763                 }
1764                 alts = alts.tail;
1765             }
1766             return res.reverse();
1767         }
1768 
1769         /** Register a catch clause in the &quot;Exceptions&quot; code-attribute.
1770          */
1771         void registerCatch(DiagnosticPosition pos,
1772                            int startpc, int endpc,
1773                            int handler_pc, int catch_type) {
1774             char startpc1 = (char)startpc;
1775             char endpc1 = (char)endpc;
1776             char handler_pc1 = (char)handler_pc;
1777             if (startpc1 == startpc &amp;&amp;
1778                 endpc1 == endpc &amp;&amp;
1779                 handler_pc1 == handler_pc) {
1780                 code.addCatch(startpc1, endpc1, handler_pc1,
1781                               (char)catch_type);
1782             } else {
1783                 log.error(pos, Errors.LimitCodeTooLargeForTryStmt);
1784                 nerrs++;
1785             }
1786         }
1787 
1788     public void visitIf(JCIf tree) {
1789         int limit = code.nextreg;
1790         Chain thenExit = null;
1791         Assert.check(code.isStatementStart());
1792         CondItem c = genCond(TreeInfo.skipParens(tree.cond),
1793                              CRT_FLOW_CONTROLLER);
1794         Chain elseChain = c.jumpFalse();
1795         Assert.check(code.isStatementStart());
1796         if (!c.isFalse()) {
1797             code.resolve(c.trueJumps);
1798             genStat(tree.thenpart, env, CRT_STATEMENT | CRT_FLOW_TARGET);
1799             thenExit = code.branch(goto_);
1800         }
1801         if (elseChain != null) {
1802             code.resolve(elseChain);
1803             if (tree.elsepart != null) {
1804                 genStat(tree.elsepart, env,CRT_STATEMENT | CRT_FLOW_TARGET);
1805             }
1806         }
1807         code.resolve(thenExit);
1808         code.endScopes(limit);
1809         Assert.check(code.isStatementStart());
1810     }
1811 
1812     public void visitExec(JCExpressionStatement tree) {
1813         // Optimize x++ to ++x and x-- to --x.
1814         JCExpression e = tree.expr;
1815         switch (e.getTag()) {
1816             case POSTINC:
1817                 ((JCUnary) e).setTag(PREINC);
1818                 break;
1819             case POSTDEC:
1820                 ((JCUnary) e).setTag(PREDEC);
1821                 break;
1822         }
1823         Assert.check(code.isStatementStart());
1824         genExpr(tree.expr, tree.expr.type).drop();
1825         Assert.check(code.isStatementStart());
1826     }
1827 
1828     public void visitBreak(JCBreak tree) {
1829         Assert.check(code.isStatementStart());
1830         final Env&lt;GenContext&gt; targetEnv = unwindBreak(tree.target);
1831         targetEnv.info.addExit(code.branch(goto_));
1832         endFinalizerGaps(env, targetEnv);
1833     }
1834 
1835     public void visitYield(JCYield tree) {
1836         Assert.check(code.isStatementStart());
1837         final Env&lt;GenContext&gt; targetEnv;
1838         if (inCondSwitchExpression) {
1839             CondItem value = genCond(tree.value, CRT_FLOW_TARGET);
1840             Chain falseJumps = value.jumpFalse();
1841 
1842             code.resolve(value.trueJumps);
1843             Env&lt;GenContext&gt; localEnv = unwindBreak(tree.target);
1844             reloadStackBeforeSwitchExpr();
1845             Chain trueJumps = code.branch(goto_);
1846 
1847             endFinalizerGaps(env, localEnv);
1848 
1849             code.resolve(falseJumps);
1850             targetEnv = unwindBreak(tree.target);
1851             reloadStackBeforeSwitchExpr();
1852             falseJumps = code.branch(goto_);
1853 
1854             if (switchExpressionTrueChain == null) {
1855                 switchExpressionTrueChain = trueJumps;
1856             } else {
1857                 switchExpressionTrueChain =
1858                         Code.mergeChains(switchExpressionTrueChain, trueJumps);
1859             }
1860             if (switchExpressionFalseChain == null) {
1861                 switchExpressionFalseChain = falseJumps;
1862             } else {
1863                 switchExpressionFalseChain =
1864                         Code.mergeChains(switchExpressionFalseChain, falseJumps);
1865             }
1866         } else {
1867             genExpr(tree.value, pt).load();
1868             if (switchResult != null)
1869                 switchResult.store();
1870 
1871             targetEnv = unwindBreak(tree.target);
1872 
1873             if (code.isAlive()) {
1874                 reloadStackBeforeSwitchExpr();
1875                 if (switchResult != null)
1876                     switchResult.load();
1877 
1878                 code.state.forceStackTop(tree.target.type);
1879                 targetEnv.info.addExit(code.branch(goto_));
1880                 code.markDead();
1881             }
1882         }
1883         endFinalizerGaps(env, targetEnv);
1884     }
1885     //where:
1886         /** As side-effect, might mark code as dead disabling any further emission.
1887          */
1888         private Env&lt;GenContext&gt; unwindBreak(JCTree target) {
1889             int tmpPos = code.pendingStatPos;
1890             Env&lt;GenContext&gt; targetEnv = unwind(target, env);
1891             code.pendingStatPos = tmpPos;
1892             return targetEnv;
1893         }
1894 
1895         private void reloadStackBeforeSwitchExpr() {
1896             for (LocalItem li : stackBeforeSwitchExpression)
1897                 li.load();
1898         }
1899 
1900     public void visitContinue(JCContinue tree) {
1901         int tmpPos = code.pendingStatPos;
1902         Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);
1903         code.pendingStatPos = tmpPos;
1904         Assert.check(code.isStatementStart());
1905         targetEnv.info.addCont(code.branch(goto_));
1906         endFinalizerGaps(env, targetEnv);
1907     }
1908 
1909     public void visitReturn(JCReturn tree) {
1910         int limit = code.nextreg;
1911         final Env&lt;GenContext&gt; targetEnv;
1912 
1913         /* Save and then restore the location of the return in case a finally
1914          * is expanded (with unwind()) in the middle of our bytecodes.
1915          */
1916         int tmpPos = code.pendingStatPos;
1917         if (tree.expr != null) {
1918             Assert.check(code.isStatementStart());
1919             Item r = genExpr(tree.expr, pt).load();
1920             if (hasFinally(env.enclMethod, env)) {
1921                 r = makeTemp(pt);
1922                 r.store();
1923             }
1924             targetEnv = unwind(env.enclMethod, env);
1925             code.pendingStatPos = tmpPos;
1926             r.load();
1927             code.emitop0(ireturn + Code.truncate(Code.typecode(pt)));
1928         } else {
1929             targetEnv = unwind(env.enclMethod, env);
1930             code.pendingStatPos = tmpPos;
1931             code.emitop0(return_);
1932         }
1933         endFinalizerGaps(env, targetEnv);
1934         code.endScopes(limit);
1935     }
1936 
1937     public void visitThrow(JCThrow tree) {
1938         Assert.check(code.isStatementStart());
1939         genExpr(tree.expr, tree.expr.type).load();
1940         code.emitop0(athrow);
1941         Assert.check(code.isStatementStart());
1942     }
1943 
1944 /* ************************************************************************
1945  * Visitor methods for expressions
1946  *************************************************************************/
1947 
1948     public void visitApply(JCMethodInvocation tree) {
1949         setTypeAnnotationPositions(tree.pos);
1950         // Generate code for method.
1951         Item m = genExpr(tree.meth, methodType);
1952         // Generate code for all arguments, where the expected types are
1953         // the parameters of the method&#39;s external type (that is, any implicit
1954         // outer instance of a super(...) call appears as first parameter).
1955         MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(tree.meth);
1956         genArgs(tree.args,
1957                 msym.externalType(types).getParameterTypes());
1958         if (!msym.isDynamic()) {
1959             code.statBegin(tree.pos);
1960         }
1961         result = m.invoke();
1962     }
1963 
1964     public void visitConditional(JCConditional tree) {
1965         Chain thenExit = null;
1966         code.statBegin(tree.cond.pos);
1967         CondItem c = genCond(tree.cond, CRT_FLOW_CONTROLLER);
1968         Chain elseChain = c.jumpFalse();
1969         if (!c.isFalse()) {
1970             code.resolve(c.trueJumps);
1971             int startpc = genCrt ? code.curCP() : 0;
1972             code.statBegin(tree.truepart.pos);
1973             genExpr(tree.truepart, pt).load();
1974             code.state.forceStackTop(tree.type);
1975             if (genCrt) code.crt.put(tree.truepart, CRT_FLOW_TARGET,
1976                                      startpc, code.curCP());
1977             thenExit = code.branch(goto_);
1978         }
1979         if (elseChain != null) {
1980             code.resolve(elseChain);
1981             int startpc = genCrt ? code.curCP() : 0;
1982             code.statBegin(tree.falsepart.pos);
1983             genExpr(tree.falsepart, pt).load();
1984             code.state.forceStackTop(tree.type);
1985             if (genCrt) code.crt.put(tree.falsepart, CRT_FLOW_TARGET,
1986                                      startpc, code.curCP());
1987         }
1988         code.resolve(thenExit);
1989         result = items.makeStackItem(pt);
1990     }
1991 
1992     private void setTypeAnnotationPositions(int treePos) {
1993         MethodSymbol meth = code.meth;
1994         boolean initOrClinit = code.meth.getKind() == javax.lang.model.element.ElementKind.CONSTRUCTOR
1995                 || code.meth.getKind() == javax.lang.model.element.ElementKind.STATIC_INIT;
1996 
1997         for (Attribute.TypeCompound ta : meth.getRawTypeAttributes()) {
1998             if (ta.hasUnknownPosition())
1999                 ta.tryFixPosition();
2000 
2001             if (ta.position.matchesPos(treePos))
2002                 ta.position.updatePosOffset(code.cp);
2003         }
2004 
2005         if (!initOrClinit)
2006             return;
2007 
2008         for (Attribute.TypeCompound ta : meth.owner.getRawTypeAttributes()) {
2009             if (ta.hasUnknownPosition())
2010                 ta.tryFixPosition();
2011 
2012             if (ta.position.matchesPos(treePos))
2013                 ta.position.updatePosOffset(code.cp);
2014         }
2015 
2016         ClassSymbol clazz = meth.enclClass();
2017         for (Symbol s : new com.sun.tools.javac.model.FilteredMemberList(clazz.members())) {
2018             if (!s.getKind().isField())
2019                 continue;
2020 
2021             for (Attribute.TypeCompound ta : s.getRawTypeAttributes()) {
2022                 if (ta.hasUnknownPosition())
2023                     ta.tryFixPosition();
2024 
2025                 if (ta.position.matchesPos(treePos))
2026                     ta.position.updatePosOffset(code.cp);
2027             }
2028         }
2029     }
2030 
2031     public void visitNewClass(JCNewClass tree) {
2032         // Enclosing instances or anonymous classes should have been eliminated
2033         // by now.
2034         Assert.check(tree.encl == null &amp;&amp; tree.def == null);
2035         setTypeAnnotationPositions(tree.pos);
2036 
2037         code.emitop2(new_, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
2038         code.emitop0(dup);
2039 
2040         // Generate code for all arguments, where the expected types are
2041         // the parameters of the constructor&#39;s external type (that is,
2042         // any implicit outer instance appears as first parameter).
2043         genArgs(tree.args, tree.constructor.externalType(types).getParameterTypes());
2044 
2045         items.makeMemberItem(tree.constructor, true).invoke();
2046 
2047         result = items.makeStackItem(tree.type);
2048     }
2049 
2050     public void visitNewArray(JCNewArray tree) {
2051         setTypeAnnotationPositions(tree.pos);
2052 
2053         if (tree.elems != null) {
2054             Type elemtype = types.elemtype(tree.type);
2055             loadIntConst(tree.elems.length());
2056             Item arr = makeNewArray(tree.pos(), tree.type, 1);
2057             int i = 0;
2058             for (List&lt;JCExpression&gt; l = tree.elems; l.nonEmpty(); l = l.tail) {
2059                 arr.duplicate();
2060                 loadIntConst(i);
2061                 i++;
2062                 genExpr(l.head, elemtype).load();
2063                 items.makeIndexedItem(elemtype).store();
2064             }
2065             result = arr;
2066         } else {
2067             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2068                 genExpr(l.head, syms.intType).load();
2069             }
2070             result = makeNewArray(tree.pos(), tree.type, tree.dims.length());
2071         }
2072     }
2073 //where
2074         /** Generate code to create an array with given element type and number
2075          *  of dimensions.
2076          */
2077         Item makeNewArray(DiagnosticPosition pos, Type type, int ndims) {
2078             Type elemtype = types.elemtype(type);
2079             if (types.dimensions(type) &gt; ClassFile.MAX_DIMENSIONS) {
2080                 log.error(pos, Errors.LimitDimensions);
2081                 nerrs++;
2082             }
2083             int elemcode = Code.arraycode(elemtype);
2084             if (elemcode == 0 || (elemcode == 1 &amp;&amp; ndims == 1)) {
2085                 code.emitAnewarray(makeRef(pos, elemtype, types.isValue(elemtype)), type);
2086             } else if (elemcode == 1) {
2087                 code.emitMultianewarray(ndims, makeRef(pos, type), type);
2088             } else {
2089                 code.emitNewarray(elemcode, type);
2090             }
2091             return items.makeStackItem(type);
2092         }
2093 
2094     public void visitParens(JCParens tree) {
2095         result = genExpr(tree.expr, tree.expr.type);
2096     }
2097 
2098     public void visitAssign(JCAssign tree) {
2099         Item l = genExpr(tree.lhs, tree.lhs.type);
2100         genExpr(tree.rhs, tree.lhs.type).load();
2101         if (tree.rhs.type.hasTag(BOT)) {
2102             /* This is just a case of widening reference conversion that per 5.1.5 simply calls
2103                for &quot;regarding a reference as having some other type in a manner that can be proved
2104                correct at compile time.&quot;
2105             */
2106             code.state.forceStackTop(tree.lhs.type);
2107         }
2108         result = items.makeAssignItem(l);
2109     }
2110 
2111     public void visitAssignop(JCAssignOp tree) {
2112         OperatorSymbol operator = tree.operator;
2113         Item l;
2114         if (operator.opcode == string_add) {
2115             l = concat.makeConcat(tree);
2116         } else {
2117             // Generate code for first expression
2118             l = genExpr(tree.lhs, tree.lhs.type);
2119 
2120             // If we have an increment of -32768 to +32767 of a local
2121             // int variable we can use an incr instruction instead of
2122             // proceeding further.
2123             if ((tree.hasTag(PLUS_ASG) || tree.hasTag(MINUS_ASG)) &amp;&amp;
2124                 l instanceof LocalItem &amp;&amp;
2125                 tree.lhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2126                 tree.rhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2127                 tree.rhs.type.constValue() != null) {
2128                 int ival = ((Number) tree.rhs.type.constValue()).intValue();
2129                 if (tree.hasTag(MINUS_ASG)) ival = -ival;
2130                 ((LocalItem)l).incr(ival);
2131                 result = l;
2132                 return;
2133             }
2134             // Otherwise, duplicate expression, load one copy
2135             // and complete binary operation.
2136             l.duplicate();
2137             l.coerce(operator.type.getParameterTypes().head).load();
2138             completeBinop(tree.lhs, tree.rhs, operator).coerce(tree.lhs.type);
2139         }
2140         result = items.makeAssignItem(l);
2141     }
2142 
2143     public void visitUnary(JCUnary tree) {
2144         OperatorSymbol operator = tree.operator;
2145         if (tree.hasTag(NOT)) {
2146             CondItem od = genCond(tree.arg, false);
2147             result = od.negate();
2148         } else {
2149             Item od = genExpr(tree.arg, operator.type.getParameterTypes().head);
2150             switch (tree.getTag()) {
2151             case POS:
2152                 result = od.load();
2153                 break;
2154             case NEG:
2155                 result = od.load();
2156                 code.emitop0(operator.opcode);
2157                 break;
2158             case COMPL:
2159                 result = od.load();
2160                 emitMinusOne(od.typecode);
2161                 code.emitop0(operator.opcode);
2162                 break;
2163             case PREINC: case PREDEC:
2164                 od.duplicate();
2165                 if (od instanceof LocalItem &amp;&amp;
2166                     (operator.opcode == iadd || operator.opcode == isub)) {
2167                     ((LocalItem)od).incr(tree.hasTag(PREINC) ? 1 : -1);
2168                     result = od;
2169                 } else {
2170                     od.load();
2171                     code.emitop0(one(od.typecode));
2172                     code.emitop0(operator.opcode);
2173                     // Perform narrowing primitive conversion if byte,
2174                     // char, or short.  Fix for 4304655.
2175                     if (od.typecode != INTcode &amp;&amp;
2176                         Code.truncate(od.typecode) == INTcode)
2177                       code.emitop0(int2byte + od.typecode - BYTEcode);
2178                     result = items.makeAssignItem(od);
2179                 }
2180                 break;
2181             case POSTINC: case POSTDEC:
2182                 od.duplicate();
2183                 if (od instanceof LocalItem &amp;&amp;
2184                     (operator.opcode == iadd || operator.opcode == isub)) {
2185                     Item res = od.load();
2186                     ((LocalItem)od).incr(tree.hasTag(POSTINC) ? 1 : -1);
2187                     result = res;
2188                 } else {
2189                     Item res = od.load();
2190                     od.stash(od.typecode);
2191                     code.emitop0(one(od.typecode));
2192                     code.emitop0(operator.opcode);
2193                     // Perform narrowing primitive conversion if byte,
2194                     // char, or short.  Fix for 4304655.
2195                     if (od.typecode != INTcode &amp;&amp;
2196                         Code.truncate(od.typecode) == INTcode)
2197                       code.emitop0(int2byte + od.typecode - BYTEcode);
2198                     od.store();
2199                     result = res;
2200                 }
2201                 break;
2202             case NULLCHK:
2203                 result = od.load();
2204                 code.emitop0(dup);
2205                 genNullCheck(tree);
2206                 break;
2207             default:
2208                 Assert.error();
2209             }
2210         }
2211     }
2212 
2213     /** Generate a null check from the object value at stack top. */
2214     private void genNullCheck(JCTree tree) {
2215         code.statBegin(tree.pos);
2216         callMethod(tree.pos(), syms.objectsType, names.requireNonNull,
2217                    List.of(syms.objectType), true);
2218         code.emitop0(pop);
2219     }
2220 
2221     public void visitBinary(JCBinary tree) {
2222         OperatorSymbol operator = tree.operator;
2223         if (operator.opcode == string_add) {
2224             result = concat.makeConcat(tree);
2225         } else if (tree.hasTag(AND)) {
2226             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2227             if (!lcond.isFalse()) {
2228                 Chain falseJumps = lcond.jumpFalse();
2229                 code.resolve(lcond.trueJumps);
2230                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2231                 result = items.
2232                     makeCondItem(rcond.opcode,
2233                                  rcond.trueJumps,
2234                                  Code.mergeChains(falseJumps,
2235                                                   rcond.falseJumps));
2236             } else {
2237                 result = lcond;
2238             }
2239         } else if (tree.hasTag(OR)) {
2240             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2241             if (!lcond.isTrue()) {
2242                 Chain trueJumps = lcond.jumpTrue();
2243                 code.resolve(lcond.falseJumps);
2244                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2245                 result = items.
2246                     makeCondItem(rcond.opcode,
2247                                  Code.mergeChains(trueJumps, rcond.trueJumps),
2248                                  rcond.falseJumps);
2249             } else {
2250                 result = lcond;
2251             }
2252         } else {
2253             Item od = genExpr(tree.lhs, operator.type.getParameterTypes().head);
2254             od.load();
2255             result = completeBinop(tree.lhs, tree.rhs, operator);
2256         }
2257     }
2258 
2259 
2260         /** Complete generating code for operation, with left operand
2261          *  already on stack.
2262          *  @param lhs       The tree representing the left operand.
2263          *  @param rhs       The tree representing the right operand.
2264          *  @param operator  The operator symbol.
2265          */
2266         Item completeBinop(JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2267             MethodType optype = (MethodType)operator.type;
2268             int opcode = operator.opcode;
2269             if (opcode &gt;= if_icmpeq &amp;&amp; opcode &lt;= if_icmple &amp;&amp;
2270                 rhs.type.constValue() instanceof Number &amp;&amp;
2271                 ((Number) rhs.type.constValue()).intValue() == 0) {
2272                 opcode = opcode + (ifeq - if_icmpeq);
2273             } else if (opcode &gt;= if_acmpeq &amp;&amp; opcode &lt;= if_acmpne &amp;&amp;
2274                        TreeInfo.isNull(rhs)) {
2275                 opcode = opcode + (if_acmp_null - if_acmpeq);
2276             } else {
2277                 // The expected type of the right operand is
2278                 // the second parameter type of the operator, except for
2279                 // shifts with long shiftcount, where we convert the opcode
2280                 // to a short shift and the expected type to int.
2281                 Type rtype = operator.erasure(types).getParameterTypes().tail.head;
2282                 if (opcode &gt;= ishll &amp;&amp; opcode &lt;= lushrl) {
2283                     opcode = opcode + (ishl - ishll);
2284                     rtype = syms.intType;
2285                 }
2286                 // Generate code for right operand and load.
2287                 genExpr(rhs, rtype).load();
2288                 // If there are two consecutive opcode instructions,
2289                 // emit the first now.
2290                 if (opcode &gt;= (1 &lt;&lt; preShift)) {
2291                     code.emitop0(opcode &gt;&gt; preShift);
2292                     opcode = opcode &amp; 0xFF;
2293                 }
2294             }
2295             if (opcode &gt;= ifeq &amp;&amp; opcode &lt;= if_acmpne ||
2296                 opcode == if_acmp_null || opcode == if_acmp_nonnull) {
2297                 return items.makeCondItem(opcode);
2298             } else {
2299                 code.emitop0(opcode);
2300                 return items.makeStackItem(optype.restype);
2301             }
2302         }
2303 
2304     public void visitTypeCast(JCTypeCast tree) {
2305         result = genExpr(tree.expr, tree.clazz.type).load();
2306         setTypeAnnotationPositions(tree.pos);
2307         // Additional code is only needed if we cast to a reference type
2308         // which is not statically a supertype of the expression&#39;s type.
2309         // For basic types, the coerce(...) in genExpr(...) will do
2310         // the conversion.
2311         // inline widening conversion is a nop, as the VM sees a subtyping relationship.
2312         if (!tree.clazz.type.isPrimitive() &amp;&amp;
2313            !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
2314             (!tree.clazz.type.tsym.isReferenceProjection() || tree.clazz.type.tsym.valueProjection() != tree.expr.type.tsym) &amp;&amp;
2315            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
2316             checkDimension(tree.pos(), tree.clazz.type);
2317             if (types.isValue(tree.clazz.type)) {
2318                 code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);
2319             } else {
2320                 code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);
2321             }
2322 
2323         }
2324     }
2325 
2326     public void visitWildcard(JCWildcard tree) {
2327         throw new AssertionError(this.getClass().getName());
2328     }
2329 
2330     public void visitTypeTest(JCInstanceOf tree) {
2331         genExpr(tree.expr, tree.expr.type).load();
2332         setTypeAnnotationPositions(tree.pos);
2333         code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));
2334         result = items.makeStackItem(syms.booleanType);
2335     }
2336 
2337     public void visitIndexed(JCArrayAccess tree) {
2338         genExpr(tree.indexed, tree.indexed.type).load();
2339         genExpr(tree.index, syms.intType).load();
2340         result = items.makeIndexedItem(tree.type);
2341     }
2342 
2343     public void visitIdent(JCIdent tree) {
2344         Symbol sym = tree.sym;
2345         if (tree.name == names._this || tree.name == names._super) {
2346             Item res = tree.name == names._this
2347                 ? items.makeThisItem()
2348                 : items.makeSuperItem();
2349             if (sym.kind == MTH) {
2350                 // Generate code to address the constructor.
2351                 res.load();
2352                 res = items.makeMemberItem(sym, true);
2353             }
2354             result = res;
2355        } else if (isInvokeDynamic(sym) || isConstantDynamic(sym)) {
2356             if (isConstantDynamic(sym)) {
2357                 setTypeAnnotationPositions(tree.pos);
2358             }
2359             result = items.makeDynamicItem(sym);
2360         } else if (sym.kind == VAR &amp;&amp; (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
2361             result = items.makeLocalItem((VarSymbol)sym);
2362         } else if ((sym.flags() &amp; STATIC) != 0) {
2363             if (!isAccessSuper(env.enclMethod))
2364                 sym = binaryQualifier(sym, env.enclClass.type);
2365             result = items.makeStaticItem(sym);
2366         } else {
2367             items.makeThisItem().load();
2368             sym = binaryQualifier(sym, env.enclClass.type);
2369             result = items.makeMemberItem(sym, nonVirtualForPrivateAccess(sym));
2370         }
2371     }
2372 
2373     //where
2374     private boolean nonVirtualForPrivateAccess(Symbol sym) {
2375         boolean useVirtual = target.hasVirtualPrivateInvoke() &amp;&amp;
2376                              !disableVirtualizedPrivateInvoke;
2377         return !useVirtual &amp;&amp; ((sym.flags() &amp; PRIVATE) != 0);
2378     }
2379 
2380     public void visitSelect(JCFieldAccess tree) {
2381         Symbol sym = tree.sym;
2382 
2383         if (tree.name == names._class) {
2384             code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));
2385             result = items.makeStackItem(pt);
2386             return;
2387         } else if (tree.name == names._default) {
2388             if (tree.type.asElement().isValue()) {
2389                 code.emitop2(defaultvalue, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
2390             } else if (tree.type.isReference()) {
2391                 code.emitop0(aconst_null);
2392             } else {
2393                 code.emitop0(zero(Code.typecode(tree.type)));
2394             }
2395             result = items.makeStackItem(tree.type);
2396             return;
2397         }
2398 
2399         Symbol ssym = TreeInfo.symbol(tree.selected);
2400 
2401         // Are we selecting via super?
2402         boolean selectSuper =
2403             ssym != null &amp;&amp; (ssym.kind == TYP || ssym.name == names._super);
2404 
2405         // Are we accessing a member of the superclass in an access method
2406         // resulting from a qualified super?
2407         boolean accessSuper = isAccessSuper(env.enclMethod);
2408 
2409         Item base = (selectSuper)
2410             ? items.makeSuperItem()
2411             : genExpr(tree.selected, tree.selected.type);
2412 
2413         if (sym.kind == VAR &amp;&amp; ((VarSymbol) sym).getConstValue() != null) {
2414             // We are seeing a variable that is constant but its selecting
2415             // expression is not.
2416             if ((sym.flags() &amp; STATIC) != 0) {
2417                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2418                     base = base.load();
2419                 base.drop();
2420             } else {
2421                 base.load();
2422                 genNullCheck(tree.selected);
2423             }
2424             result = items.
2425                 makeImmediateItem(sym.type, ((VarSymbol) sym).getConstValue());
2426         } else {
2427             if (isInvokeDynamic(sym)) {
2428                 result = items.makeDynamicItem(sym);
2429                 return;
2430             } else {
2431                 sym = binaryQualifier(sym, tree.selected.type);
2432             }
2433             if ((sym.flags() &amp; STATIC) != 0) {
2434                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2435                     base = base.load();
2436                 base.drop();
2437                 result = items.makeStaticItem(sym);
2438             } else {
2439                 base.load();
2440                 if (sym == syms.lengthVar) {
2441                     code.emitop0(arraylength);
2442                     result = items.makeStackItem(syms.intType);
2443                 } else {
2444                     result = items.
2445                         makeMemberItem(sym,
2446                                        nonVirtualForPrivateAccess(sym) ||
2447                                        selectSuper || accessSuper);
2448                 }
2449             }
2450         }
2451     }
2452 
2453     public boolean isInvokeDynamic(Symbol sym) {
2454         return sym.kind == MTH &amp;&amp; ((MethodSymbol)sym).isDynamic();
2455     }
2456 
2457     public void visitLiteral(JCLiteral tree) {
2458         if (tree.type.hasTag(BOT)) {
2459             code.emitop0(aconst_null);
2460             result = items.makeStackItem(tree.type);
2461         }
2462         else
2463             result = items.makeImmediateItem(tree.type, tree.value);
2464     }
2465 
2466     public void visitLetExpr(LetExpr tree) {
2467         code.resolvePending();
2468 
2469         int limit = code.nextreg;
2470         int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
2471         try {
2472             genStats(tree.defs, env);
2473         } finally {
2474             code.setLetExprStackPos(prevLetExprStart);
2475         }
2476         result = genExpr(tree.expr, tree.expr.type).load();
2477         code.endScopes(limit);
2478     }
2479 
2480     private void generateReferencesToPrunedTree(ClassSymbol classSymbol) {
2481         List&lt;JCTree&gt; prunedInfo = lower.prunedTree.get(classSymbol);
2482         if (prunedInfo != null) {
2483             for (JCTree prunedTree: prunedInfo) {
2484                 prunedTree.accept(classReferenceVisitor);
2485             }
2486         }
2487     }
2488 
2489 /* ************************************************************************
2490  * main method
2491  *************************************************************************/
2492 
2493     /** Generate code for a class definition.
2494      *  @param env   The attribution environment that belongs to the
2495      *               outermost class containing this class definition.
2496      *               We need this for resolving some additional symbols.
2497      *  @param cdef  The tree representing the class definition.
2498      *  @return      True if code is generated with no errors.
2499      */
2500     public boolean genClass(Env&lt;AttrContext&gt; env, JCClassDecl cdef) {
2501         try {
2502             attrEnv = env;
2503             ClassSymbol c = cdef.sym;
2504             this.toplevel = env.toplevel;
2505             this.endPosTable = toplevel.endPositions;
2506             /* method normalizeDefs() can add references to external classes into the constant pool
2507              */
2508             cdef.defs = normalizeDefs(cdef.defs, c);
2509             cdef = transValues.translateTopLevelClass(cdef, make);
2510             generateReferencesToPrunedTree(c);
2511             Env&lt;GenContext&gt; localEnv = new Env&lt;&gt;(cdef, new GenContext());
2512             localEnv.toplevel = env.toplevel;
2513             localEnv.enclClass = cdef;
2514 
2515             for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2516                 genDef(l.head, localEnv);
2517             }
2518             if (poolWriter.size() &gt; PoolWriter.MAX_ENTRIES) {
2519                 log.error(cdef.pos(), Errors.LimitPool);
2520                 nerrs++;
2521             }
2522             if (nerrs != 0) {
2523                 // if errors, discard code
2524                 for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2525                     if (l.head.hasTag(METHODDEF))
2526                         ((JCMethodDecl) l.head).sym.code = null;
2527                 }
2528             }
2529             cdef.defs = List.nil(); // discard trees
2530             return nerrs == 0;
2531         } finally {
2532             // note: this method does NOT support recursion.
2533             attrEnv = null;
2534             this.env = null;
2535             toplevel = null;
2536             endPosTable = null;
2537             nerrs = 0;
2538         }
2539     }
2540 
2541 /* ************************************************************************
2542  * Auxiliary classes
2543  *************************************************************************/
2544 
2545     /** An abstract class for finalizer generation.
2546      */
2547     abstract class GenFinalizer {
2548         /** Generate code to clean up when unwinding. */
2549         abstract void gen();
2550 
2551         /** Generate code to clean up at last. */
2552         abstract void genLast();
2553 
2554         /** Does this finalizer have some nontrivial cleanup to perform? */
2555         boolean hasFinalizer() { return true; }
2556 
2557         /** Should be invoked after the try&#39;s body has been visited. */
2558         void afterBody() {}
2559     }
2560 
2561     /** code generation contexts,
2562      *  to be used as type parameter for environments.
2563      */
2564     static class GenContext {
2565 
2566         /** A chain for all unresolved jumps that exit the current environment.
2567          */
2568         Chain exit = null;
2569 
2570         /** A chain for all unresolved jumps that continue in the
2571          *  current environment.
2572          */
2573         Chain cont = null;
2574 
2575         /** A closure that generates the finalizer of the current environment.
2576          *  Only set for Synchronized and Try contexts.
2577          */
2578         GenFinalizer finalize = null;
2579 
2580         /** Is this a switch statement?  If so, allocate registers
2581          * even when the variable declaration is unreachable.
2582          */
2583         boolean isSwitch = false;
2584 
2585         /** A list buffer containing all gaps in the finalizer range,
2586          *  where a catch all exception should not apply.
2587          */
2588         ListBuffer&lt;Integer&gt; gaps = null;
2589 
2590         /** Add given chain to exit chain.
2591          */
2592         void addExit(Chain c)  {
2593             exit = Code.mergeChains(c, exit);
2594         }
2595 
2596         /** Add given chain to cont chain.
2597          */
2598         void addCont(Chain c) {
2599             cont = Code.mergeChains(c, cont);
2600         }
2601     }
2602 
2603 }
    </pre>
  </body>
</html>