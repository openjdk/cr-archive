<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import com.sun.tools.javac.code.Types.UniqueType;
  29 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  30 import com.sun.tools.javac.tree.TreeInfo.PosKind;
  31 import com.sun.tools.javac.util.*;
  32 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  33 import com.sun.tools.javac.util.List;
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.TypeCompound;
  36 import com.sun.tools.javac.code.Symbol.VarSymbol;
  37 import com.sun.tools.javac.comp.*;
  38 import com.sun.tools.javac.tree.*;
  39 
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.code.Type.*;
  42 import com.sun.tools.javac.jvm.Code.*;
  43 import com.sun.tools.javac.jvm.Items.*;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.tree.EndPosTable;
  46 import com.sun.tools.javac.tree.JCTree.*;
  47 
  48 import static com.sun.tools.javac.code.Flags.*;
  49 import static com.sun.tools.javac.code.Kinds.Kind.*;
  50 import static com.sun.tools.javac.code.TypeTag.*;
  51 import static com.sun.tools.javac.jvm.ByteCodes.*;
  52 import static com.sun.tools.javac.jvm.CRTFlags.*;
  53 import static com.sun.tools.javac.main.Option.*;
  54 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  55 
  56 /** This pass maps flat Java (i.e. without inner classes) to bytecodes.
  57  *
  58  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  59  *  If you write code that depends on this, you do so at your own risk.
  60  *  This code and its internal interfaces are subject to change or
  61  *  deletion without notice.&lt;/b&gt;
  62  */
  63 public class Gen extends JCTree.Visitor {
  64     private static final Object[] NO_STATIC_ARGS = new Object[0];
  65     protected static final Context.Key&lt;Gen&gt; genKey = new Context.Key&lt;&gt;();
  66 
  67     private final Log log;
  68     private final Symtab syms;
  69     private final Check chk;
  70     private final Resolve rs;
  71     private final TreeMaker make;
  72     private final Names names;
  73     private final Target target;
  74     private final Name accessDollar;
  75     private final Types types;
  76     private final Lower lower;
  77     private final Annotate annotate;
  78     private final StringConcat concat;
  79     private final TransValues transValues;
  80 
  81     /** Format of stackmap tables to be generated. */
  82     private final Code.StackMapFormat stackMap;
  83 
  84     /** A type that serves as the expected type for all method expressions.
  85      */
  86     private final Type methodType;
  87 
  88     public static Gen instance(Context context) {
  89         Gen instance = context.get(genKey);
  90         if (instance == null)
  91             instance = new Gen(context);
  92         return instance;
  93     }
  94 
  95     /** Constant pool writer, set by genClass.
  96      */
  97     final PoolWriter poolWriter;
  98 
  99     protected Gen(Context context) {
 100         context.put(genKey, this);
 101 
 102         names = Names.instance(context);
 103         log = Log.instance(context);
 104         syms = Symtab.instance(context);
 105         chk = Check.instance(context);
 106         rs = Resolve.instance(context);
 107         make = TreeMaker.instance(context);
 108         target = Target.instance(context);
 109         types = Types.instance(context);
 110         concat = StringConcat.instance(context);
 111 
 112         methodType = new MethodType(null, null, null, syms.methodClass);
 113         accessDollar = names.
 114             fromString(&quot;access&quot; + target.syntheticNameChar());
 115         lower = Lower.instance(context);
 116         transValues = TransValues.instance(context);
 117 
 118         Options options = Options.instance(context);
 119         lineDebugInfo =
 120             options.isUnset(G_CUSTOM) ||
 121             options.isSet(G_CUSTOM, &quot;lines&quot;);
 122         varDebugInfo =
 123             options.isUnset(G_CUSTOM)
 124             ? options.isSet(G)
 125             : options.isSet(G_CUSTOM, &quot;vars&quot;);
 126         genCrt = options.isSet(XJCOV);
 127         debugCode = options.isSet(&quot;debug.code&quot;);
 128         disableVirtualizedPrivateInvoke = options.isSet(&quot;disableVirtualizedPrivateInvoke&quot;);
 129         poolWriter = new PoolWriter(types, names);
 130 
 131         // ignore cldc because we cannot have both stackmap formats
 132         this.stackMap = StackMapFormat.JSR202;
 133         annotate = Annotate.instance(context);
 134     }
 135 
 136     /** Switches
 137      */
 138     private final boolean lineDebugInfo;
 139     private final boolean varDebugInfo;
 140     private final boolean genCrt;
 141     private final boolean debugCode;
 142     private boolean disableVirtualizedPrivateInvoke;
 143 
 144     /** Code buffer, set by genMethod.
 145      */
 146     private Code code;
 147 
 148     /** Items structure, set by genMethod.
 149      */
 150     private Items items;
 151 
 152     /** Environment for symbol lookup, set by genClass
 153      */
 154     private Env&lt;AttrContext&gt; attrEnv;
 155 
 156     /** The top level tree.
 157      */
 158     private JCCompilationUnit toplevel;
 159 
 160     /** The number of code-gen errors in this class.
 161      */
 162     private int nerrs = 0;
 163 
 164     /** An object containing mappings of syntax trees to their
 165      *  ending source positions.
 166      */
 167     EndPosTable endPosTable;
 168 
 169     boolean inCondSwitchExpression;
 170     Chain switchExpressionTrueChain;
 171     Chain switchExpressionFalseChain;
 172     List&lt;LocalItem&gt; stackBeforeSwitchExpression;
 173     LocalItem switchResult;
 174 
 175     /** Generate code to load an integer constant.
 176      *  @param n     The integer to be loaded.
 177      */
 178     void loadIntConst(int n) {
 179         items.makeImmediateItem(syms.intType, n).load();
 180     }
 181 
 182     /** The opcode that loads a zero constant of a given type code.
 183      *  @param tc   The given type code (@see ByteCode).
 184      */
 185     public static int zero(int tc) {
 186         switch(tc) {
 187         case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
 188             return iconst_0;
 189         case LONGcode:
 190             return lconst_0;
 191         case FLOATcode:
 192             return fconst_0;
 193         case DOUBLEcode:
 194             return dconst_0;
 195         default:
 196             throw new AssertionError(&quot;zero&quot;);
 197         }
 198     }
 199 
 200     /** The opcode that loads a one constant of a given type code.
 201      *  @param tc   The given type code (@see ByteCode).
 202      */
 203     public static int one(int tc) {
 204         return zero(tc) + 1;
 205     }
 206 
 207     /** Generate code to load -1 of the given type code (either int or long).
 208      *  @param tc   The given type code (@see ByteCode).
 209      */
 210     void emitMinusOne(int tc) {
 211         if (tc == LONGcode) {
 212             items.makeImmediateItem(syms.longType, Long.valueOf(-1)).load();
 213         } else {
 214             code.emitop0(iconst_m1);
 215         }
 216     }
 217 
 218     /** Construct a symbol to reflect the qualifying type that should
 219      *  appear in the byte code as per JLS 13.1.
 220      *
 221      *  For {@literal target &gt;= 1.2}: Clone a method with the qualifier as owner (except
 222      *  for those cases where we need to work around VM bugs).
 223      *
 224      *  For {@literal target &lt;= 1.1}: If qualified variable or method is defined in a
 225      *  non-accessible class, clone it with the qualifier class as owner.
 226      *
 227      *  @param sym    The accessed symbol
 228      *  @param site   The qualifier&#39;s type.
 229      */
 230     Symbol binaryQualifier(Symbol sym, Type site) {
 231 
 232         if (site.hasTag(ARRAY)) {
 233             if (sym == syms.lengthVar ||
 234                 sym.owner != syms.arrayClass)
 235                 return sym;
 236             // array clone can be qualified by the array type in later targets
 237             Symbol qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name,
 238                                                site, syms.noSymbol);
 239             return sym.clone(qualifier);
 240         }
 241 
 242         if (sym.owner == site.tsym ||
 243             (sym.flags() &amp; (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {
 244             return sym;
 245         }
 246 
 247         // leave alone methods inherited from Object
 248         // JLS 13.1.
 249         if (sym.owner == syms.objectType.tsym)
 250             return sym;
 251 
 252         return sym.clone(site.tsym);
 253     }
 254 
 255     /** Insert a reference to given type in the constant pool,
 256      *  checking for an array with too many dimensions;
 257      *  return the reference&#39;s index.
 258      *  @param type   The type for which a reference is inserted.
 259      */
 260     int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {
 261         checkDimension(pos, type);
 262         if (emitQtype) {
 263             return poolWriter.putClass(new ConstantPoolQType(type, types));
 264         } else {
 265             return poolWriter.putClass(type);
 266         }
 267     }
 268 
 269     /** Insert a reference to given type in the constant pool,
 270      *  checking for an array with too many dimensions;
 271      *  return the reference&#39;s index.
 272      *  @param type   The type for which a reference is inserted.
 273      */
 274     int makeRef(DiagnosticPosition pos, Type type) {
 275         return makeRef(pos, type, false);
 276     }
 277 
 278     /** Check if the given type is an array with too many dimensions.
 279      */
 280     private Type checkDimension(DiagnosticPosition pos, Type t) {
 281         checkDimensionInternal(pos, t);
 282         return t;
 283     }
 284 
 285     private void checkDimensionInternal(DiagnosticPosition pos, Type t) {
 286         switch (t.getTag()) {
 287         case METHOD:
 288             checkDimension(pos, t.getReturnType());
 289             for (List&lt;Type&gt; args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
 290                 checkDimension(pos, args.head);
 291             break;
 292         case ARRAY:
 293             if (types.dimensions(t) &gt; ClassFile.MAX_DIMENSIONS) {
 294                 log.error(pos, Errors.LimitDimensions);
 295                 nerrs++;
 296             }
 297             break;
 298         default:
 299             break;
 300         }
 301     }
 302 
 303     /** Create a temporary variable.
 304      *  @param type   The variable&#39;s type.
 305      */
 306     LocalItem makeTemp(Type type) {
 307         VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
 308                                     names.empty,
 309                                     type,
 310                                     env.enclMethod.sym);
 311         code.newLocal(v);
 312         return items.makeLocalItem(v);
 313     }
 314 
 315     /** Generate code to call a non-private method or constructor.
 316      *  @param pos         Position to be used for error reporting.
 317      *  @param site        The type of which the method is a member.
 318      *  @param name        The method&#39;s name.
 319      *  @param argtypes    The method&#39;s argument types.
 320      *  @param isStatic    A flag that indicates whether we call a
 321      *                     static or instance method.
 322      */
 323     void callMethod(DiagnosticPosition pos,
 324                     Type site, Name name, List&lt;Type&gt; argtypes,
 325                     boolean isStatic) {
 326         Symbol msym = rs.
 327             resolveInternalMethod(pos, attrEnv, site, name, argtypes, null);
 328         if (isStatic) items.makeStaticItem(msym).invoke();
 329         else items.makeMemberItem(msym, name == names.init).invoke();
 330     }
 331 
 332     /** Is the given method definition an access method
 333      *  resulting from a qualified super? This is signified by an odd
 334      *  access code.
 335      */
 336     private boolean isAccessSuper(JCMethodDecl enclMethod) {
 337         return
 338             (enclMethod.mods.flags &amp; SYNTHETIC) != 0 &amp;&amp;
 339             isOddAccessName(enclMethod.name);
 340     }
 341 
 342     /** Does given name start with &quot;access$&quot; and end in an odd digit?
 343      */
 344     private boolean isOddAccessName(Name name) {
 345         return
 346             name.startsWith(accessDollar) &amp;&amp;
 347             (name.getByteAt(name.getByteLength() - 1) &amp; 1) == 1;
 348     }
 349 
 350 /* ************************************************************************
 351  * Non-local exits
 352  *************************************************************************/
 353 
 354     /** Generate code to invoke the finalizer associated with given
 355      *  environment.
 356      *  Any calls to finalizers are appended to the environments `cont&#39; chain.
 357      *  Mark beginning of gap in catch all range for finalizer.
 358      */
 359     void genFinalizer(Env&lt;GenContext&gt; env) {
 360         if (code.isAlive() &amp;&amp; env.info.finalize != null)
 361             env.info.finalize.gen();
 362     }
 363 
 364     /** Generate code to call all finalizers of structures aborted by
 365      *  a non-local
 366      *  exit.  Return target environment of the non-local exit.
 367      *  @param target      The tree representing the structure that&#39;s aborted
 368      *  @param env         The environment current at the non-local exit.
 369      */
 370     Env&lt;GenContext&gt; unwind(JCTree target, Env&lt;GenContext&gt; env) {
 371         Env&lt;GenContext&gt; env1 = env;
 372         while (true) {
 373             genFinalizer(env1);
 374             if (env1.tree == target) break;
 375             env1 = env1.next;
 376         }
 377         return env1;
 378     }
 379 
 380     /** Mark end of gap in catch-all range for finalizer.
 381      *  @param env   the environment which might contain the finalizer
 382      *               (if it does, env.info.gaps != null).
 383      */
 384     void endFinalizerGap(Env&lt;GenContext&gt; env) {
 385         if (env.info.gaps != null &amp;&amp; env.info.gaps.length() % 2 == 1)
 386             env.info.gaps.append(code.curCP());
 387     }
 388 
 389     /** Mark end of all gaps in catch-all ranges for finalizers of environments
 390      *  lying between, and including to two environments.
 391      *  @param from    the most deeply nested environment to mark
 392      *  @param to      the least deeply nested environment to mark
 393      */
 394     void endFinalizerGaps(Env&lt;GenContext&gt; from, Env&lt;GenContext&gt; to) {
 395         Env&lt;GenContext&gt; last = null;
 396         while (last != to) {
 397             endFinalizerGap(from);
 398             last = from;
 399             from = from.next;
 400         }
 401     }
 402 
 403     /** Do any of the structures aborted by a non-local exit have
 404      *  finalizers that require an empty stack?
 405      *  @param target      The tree representing the structure that&#39;s aborted
 406      *  @param env         The environment current at the non-local exit.
 407      */
 408     boolean hasFinally(JCTree target, Env&lt;GenContext&gt; env) {
 409         while (env.tree != target) {
 410             if (env.tree.hasTag(TRY) &amp;&amp; env.info.finalize.hasFinalizer())
 411                 return true;
 412             env = env.next;
 413         }
 414         return false;
 415     }
 416 
 417 /* ************************************************************************
 418  * Normalizing class-members.
 419  *************************************************************************/
 420 
 421     /** Distribute member initializer code into constructors and {@code &lt;clinit&gt;}
 422      *  method.
 423      *  @param defs         The list of class member declarations.
 424      *  @param c            The enclosing class.
 425      */
 426     List&lt;JCTree&gt; normalizeDefs(List&lt;JCTree&gt; defs, ClassSymbol c) {
 427         ListBuffer&lt;JCStatement&gt; initCode = new ListBuffer&lt;&gt;();
 428         ListBuffer&lt;Attribute.TypeCompound&gt; initTAs = new ListBuffer&lt;&gt;();
 429         ListBuffer&lt;JCStatement&gt; clinitCode = new ListBuffer&lt;&gt;();
 430         ListBuffer&lt;Attribute.TypeCompound&gt; clinitTAs = new ListBuffer&lt;&gt;();
 431         ListBuffer&lt;JCTree&gt; methodDefs = new ListBuffer&lt;&gt;();
 432         // Sort definitions into three listbuffers:
 433         //  - initCode for instance initializers
 434         //  - clinitCode for class initializers
 435         //  - methodDefs for method definitions
 436         for (List&lt;JCTree&gt; l = defs; l.nonEmpty(); l = l.tail) {
 437             JCTree def = l.head;
 438             switch (def.getTag()) {
 439             case BLOCK:
 440                 JCBlock block = (JCBlock)def;
 441                 if ((block.flags &amp; STATIC) != 0)
 442                     clinitCode.append(block);
 443                 else if ((block.flags &amp; SYNTHETIC) == 0)
 444                     initCode.append(block);
 445                 break;
 446             case METHODDEF:
 447                 methodDefs.append(def);
 448                 break;
 449             case VARDEF:
 450                 JCVariableDecl vdef = (JCVariableDecl) def;
 451                 VarSymbol sym = vdef.sym;
 452                 checkDimension(vdef.pos(), sym.type);
 453                 if (vdef.init != null) {
 454                     if ((sym.flags() &amp; STATIC) == 0) {
 455                         // Always initialize instance variables.
 456                         JCStatement init = make.at(vdef.pos()).
 457                             Assignment(sym, vdef.init);
 458                         initCode.append(init);
 459                         endPosTable.replaceTree(vdef, init);
 460                         initTAs.addAll(getAndRemoveNonFieldTAs(sym));
 461                     } else if (sym.getConstValue() == null) {
 462                         // Initialize class (static) variables only if
 463                         // they are not compile-time constants.
 464                         JCStatement init = make.at(vdef.pos).
 465                             Assignment(sym, vdef.init);
 466                         clinitCode.append(init);
 467                         endPosTable.replaceTree(vdef, init);
 468                         clinitTAs.addAll(getAndRemoveNonFieldTAs(sym));
 469                     } else {
 470                         checkStringConstant(vdef.init.pos(), sym.getConstValue());
 471                         /* if the init contains a reference to an external class, add it to the
 472                          * constant&#39;s pool
 473                          */
 474                         vdef.init.accept(classReferenceVisitor);
 475                     }
 476                 }
 477                 break;
 478             default:
 479                 Assert.error();
 480             }
 481         }
 482         // Insert any instance initializers into all constructors.
 483         if (initCode.length() != 0) {
 484             List&lt;JCStatement&gt; inits = initCode.toList();
 485             initTAs.addAll(c.getInitTypeAttributes());
 486             List&lt;Attribute.TypeCompound&gt; initTAlist = initTAs.toList();
 487             for (JCTree t : methodDefs) {
 488                 normalizeMethod((JCMethodDecl)t, inits, initTAlist);
 489             }
 490         }
 491         // If there are class initializers, create a &lt;clinit&gt; method
 492         // that contains them as its body.
 493         if (clinitCode.length() != 0) {
 494             MethodSymbol clinit = new MethodSymbol(
 495                 STATIC | (c.flags() &amp; STRICTFP),
 496                 names.clinit,
 497                 new MethodType(
 498                     List.nil(), syms.voidType,
 499                     List.nil(), syms.methodClass),
 500                 c);
 501             c.members().enter(clinit);
 502             List&lt;JCStatement&gt; clinitStats = clinitCode.toList();
 503             JCBlock block = make.at(clinitStats.head.pos()).Block(0, clinitStats);
 504             block.endpos = TreeInfo.endPos(clinitStats.last());
 505             methodDefs.append(make.MethodDef(clinit, block));
 506 
 507             if (!clinitTAs.isEmpty())
 508                 clinit.appendUniqueTypeAttributes(clinitTAs.toList());
 509             if (!c.getClassInitTypeAttributes().isEmpty())
 510                 clinit.appendUniqueTypeAttributes(c.getClassInitTypeAttributes());
 511         }
 512         // Return all method definitions.
 513         return methodDefs.toList();
 514     }
 515 
 516     private List&lt;Attribute.TypeCompound&gt; getAndRemoveNonFieldTAs(VarSymbol sym) {
 517         List&lt;TypeCompound&gt; tas = sym.getRawTypeAttributes();
 518         ListBuffer&lt;Attribute.TypeCompound&gt; fieldTAs = new ListBuffer&lt;&gt;();
 519         ListBuffer&lt;Attribute.TypeCompound&gt; nonfieldTAs = new ListBuffer&lt;&gt;();
 520         for (TypeCompound ta : tas) {
 521             Assert.check(ta.getPosition().type != TargetType.UNKNOWN);
 522             if (ta.getPosition().type == TargetType.FIELD) {
 523                 fieldTAs.add(ta);
 524             } else {
 525                 nonfieldTAs.add(ta);
 526             }
 527         }
 528         sym.setTypeAttributes(fieldTAs.toList());
 529         return nonfieldTAs.toList();
 530     }
 531 
 532     /** Check a constant value and report if it is a string that is
 533      *  too large.
 534      */
 535     private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
 536         if (nerrs != 0 || // only complain about a long string once
 537             constValue == null ||
 538             !(constValue instanceof String) ||
 539             ((String)constValue).length() &lt; PoolWriter.MAX_STRING_LENGTH)
 540             return;
 541         log.error(pos, Errors.LimitString);
 542         nerrs++;
 543     }
 544 
 545     /** Insert instance initializer code into initial constructor.
 546      *  @param md        The tree potentially representing a
 547      *                   constructor&#39;s definition.
 548      *  @param initCode  The list of instance initializer statements.
 549      *  @param initTAs  Type annotations from the initializer expression.
 550      */
 551     void normalizeMethod(JCMethodDecl md, List&lt;JCStatement&gt; initCode, List&lt;TypeCompound&gt; initTAs) {
 552         if (md.name == names.init &amp;&amp; TreeInfo.isInitialConstructor(md)) {
 553             // We are seeing a constructor that does not call another
 554             // constructor of the same class.
 555             List&lt;JCStatement&gt; stats = md.body.stats;
 556             ListBuffer&lt;JCStatement&gt; newstats = new ListBuffer&lt;&gt;();
 557 
 558             if (stats.nonEmpty()) {
 559                 // Copy initializers of synthetic variables generated in
 560                 // the translation of inner classes.
 561                 while (TreeInfo.isSyntheticInit(stats.head)) {
 562                     newstats.append(stats.head);
 563                     stats = stats.tail;
 564                 }
 565                 // Copy superclass constructor call
 566                 newstats.append(stats.head);
 567                 stats = stats.tail;
 568                 // Copy remaining synthetic initializers.
 569                 while (stats.nonEmpty() &amp;&amp;
 570                        TreeInfo.isSyntheticInit(stats.head)) {
 571                     newstats.append(stats.head);
 572                     stats = stats.tail;
 573                 }
 574                 // Now insert the initializer code.
 575                 newstats.appendList(initCode);
 576                 // And copy all remaining statements.
 577                 while (stats.nonEmpty()) {
 578                     newstats.append(stats.head);
 579                     stats = stats.tail;
 580                 }
 581             }
 582             md.body.stats = newstats.toList();
 583             if (md.body.endpos == Position.NOPOS)
 584                 md.body.endpos = TreeInfo.endPos(md.body.stats.last());
 585 
 586             md.sym.appendUniqueTypeAttributes(initTAs);
 587         }
 588     }
 589 
 590 /* ************************************************************************
 591  * Traversal methods
 592  *************************************************************************/
 593 
 594     /** Visitor argument: The current environment.
 595      */
 596     Env&lt;GenContext&gt; env;
 597 
 598     /** Visitor argument: The expected type (prototype).
 599      */
 600     Type pt;
 601 
 602     /** Visitor result: The item representing the computed value.
 603      */
 604     Item result;
 605 
 606     /** Visitor method: generate code for a definition, catching and reporting
 607      *  any completion failures.
 608      *  @param tree    The definition to be visited.
 609      *  @param env     The environment current at the definition.
 610      */
 611     public void genDef(JCTree tree, Env&lt;GenContext&gt; env) {
 612         Env&lt;GenContext&gt; prevEnv = this.env;
 613         try {
 614             this.env = env;
 615             tree.accept(this);
 616         } catch (CompletionFailure ex) {
 617             chk.completionError(tree.pos(), ex);
 618         } finally {
 619             this.env = prevEnv;
 620         }
 621     }
 622 
 623     /** Derived visitor method: check whether CharacterRangeTable
 624      *  should be emitted, if so, put a new entry into CRTable
 625      *  and call method to generate bytecode.
 626      *  If not, just call method to generate bytecode.
 627      *  @see    #genStat(JCTree, Env)
 628      *
 629      *  @param  tree     The tree to be visited.
 630      *  @param  env      The environment to use.
 631      *  @param  crtFlags The CharacterRangeTable flags
 632      *                   indicating type of the entry.
 633      */
 634     public void genStat(JCTree tree, Env&lt;GenContext&gt; env, int crtFlags) {
 635         if (!genCrt) {
 636             genStat(tree, env);
 637             return;
 638         }
 639         int startpc = code.curCP();
 640         genStat(tree, env);
 641         if (tree.hasTag(Tag.BLOCK)) crtFlags |= CRT_BLOCK;
 642         code.crt.put(tree, crtFlags, startpc, code.curCP());
 643     }
 644 
 645     /** Derived visitor method: generate code for a statement.
 646      */
 647     public void genStat(JCTree tree, Env&lt;GenContext&gt; env) {
 648         if (code.isAlive()) {
 649             code.statBegin(tree.pos);
 650             genDef(tree, env);
 651         } else if (env.info.isSwitch &amp;&amp; tree.hasTag(VARDEF)) {
 652             // variables whose declarations are in a switch
 653             // can be used even if the decl is unreachable.
 654             code.newLocal(((JCVariableDecl) tree).sym);
 655         }
 656     }
 657 
 658     /** Derived visitor method: check whether CharacterRangeTable
 659      *  should be emitted, if so, put a new entry into CRTable
 660      *  and call method to generate bytecode.
 661      *  If not, just call method to generate bytecode.
 662      *  @see    #genStats(List, Env)
 663      *
 664      *  @param  trees    The list of trees to be visited.
 665      *  @param  env      The environment to use.
 666      *  @param  crtFlags The CharacterRangeTable flags
 667      *                   indicating type of the entry.
 668      */
 669     public void genStats(List&lt;JCStatement&gt; trees, Env&lt;GenContext&gt; env, int crtFlags) {
 670         if (!genCrt) {
 671             genStats(trees, env);
 672             return;
 673         }
 674         if (trees.length() == 1) {        // mark one statement with the flags
 675             genStat(trees.head, env, crtFlags | CRT_STATEMENT);
 676         } else {
 677             int startpc = code.curCP();
 678             genStats(trees, env);
 679             code.crt.put(trees, crtFlags, startpc, code.curCP());
 680         }
 681     }
 682 
 683     /** Derived visitor method: generate code for a list of statements.
 684      */
 685     public void genStats(List&lt;? extends JCTree&gt; trees, Env&lt;GenContext&gt; env) {
 686         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 687             genStat(l.head, env, CRT_STATEMENT);
 688     }
 689 
 690     /** Derived visitor method: check whether CharacterRangeTable
 691      *  should be emitted, if so, put a new entry into CRTable
 692      *  and call method to generate bytecode.
 693      *  If not, just call method to generate bytecode.
 694      *  @see    #genCond(JCTree,boolean)
 695      *
 696      *  @param  tree     The tree to be visited.
 697      *  @param  crtFlags The CharacterRangeTable flags
 698      *                   indicating type of the entry.
 699      */
 700     public CondItem genCond(JCTree tree, int crtFlags) {
 701         if (!genCrt) return genCond(tree, false);
 702         int startpc = code.curCP();
 703         CondItem item = genCond(tree, (crtFlags &amp; CRT_FLOW_CONTROLLER) != 0);
 704         code.crt.put(tree, crtFlags, startpc, code.curCP());
 705         return item;
 706     }
 707 
 708     /** Derived visitor method: generate code for a boolean
 709      *  expression in a control-flow context.
 710      *  @param _tree         The expression to be visited.
 711      *  @param markBranches The flag to indicate that the condition is
 712      *                      a flow controller so produced conditions
 713      *                      should contain a proper tree to generate
 714      *                      CharacterRangeTable branches for them.
 715      */
 716     public CondItem genCond(JCTree _tree, boolean markBranches) {
 717         JCTree inner_tree = TreeInfo.skipParens(_tree);
 718         if (inner_tree.hasTag(CONDEXPR)) {
 719             JCConditional tree = (JCConditional)inner_tree;
 720             CondItem cond = genCond(tree.cond, CRT_FLOW_CONTROLLER);
 721             if (cond.isTrue()) {
 722                 code.resolve(cond.trueJumps);
 723                 CondItem result = genCond(tree.truepart, CRT_FLOW_TARGET);
 724                 if (markBranches) result.tree = tree.truepart;
 725                 return result;
 726             }
 727             if (cond.isFalse()) {
 728                 code.resolve(cond.falseJumps);
 729                 CondItem result = genCond(tree.falsepart, CRT_FLOW_TARGET);
 730                 if (markBranches) result.tree = tree.falsepart;
 731                 return result;
 732             }
 733             Chain secondJumps = cond.jumpFalse();
 734             code.resolve(cond.trueJumps);
 735             CondItem first = genCond(tree.truepart, CRT_FLOW_TARGET);
 736             if (markBranches) first.tree = tree.truepart;
 737             Chain falseJumps = first.jumpFalse();
 738             code.resolve(first.trueJumps);
 739             Chain trueJumps = code.branch(goto_);
 740             code.resolve(secondJumps);
 741             CondItem second = genCond(tree.falsepart, CRT_FLOW_TARGET);
 742             CondItem result = items.makeCondItem(second.opcode,
 743                                       Code.mergeChains(trueJumps, second.trueJumps),
 744                                       Code.mergeChains(falseJumps, second.falseJumps));
 745             if (markBranches) result.tree = tree.falsepart;
 746             return result;
 747         } else if (inner_tree.hasTag(SWITCH_EXPRESSION)) {
 748             code.resolvePending();
 749 
 750             boolean prevInCondSwitchExpression = inCondSwitchExpression;
 751             Chain prevSwitchExpressionTrueChain = switchExpressionTrueChain;
 752             Chain prevSwitchExpressionFalseChain = switchExpressionFalseChain;
 753             try {
 754                 inCondSwitchExpression = true;
 755                 switchExpressionTrueChain = null;
 756                 switchExpressionFalseChain = null;
 757                 try {
 758                     doHandleSwitchExpression((JCSwitchExpression) inner_tree);
 759                 } catch (CompletionFailure ex) {
 760                     chk.completionError(_tree.pos(), ex);
 761                     code.state.stacksize = 1;
 762                 }
 763                 CondItem result = items.makeCondItem(goto_,
 764                                                      switchExpressionTrueChain,
 765                                                      switchExpressionFalseChain);
 766                 if (markBranches) result.tree = _tree;
 767                 return result;
 768             } finally {
 769                 inCondSwitchExpression = prevInCondSwitchExpression;
 770                 switchExpressionTrueChain = prevSwitchExpressionTrueChain;
 771                 switchExpressionFalseChain = prevSwitchExpressionFalseChain;
 772             }
 773         } else if (inner_tree.hasTag(LETEXPR) &amp;&amp; ((LetExpr) inner_tree).needsCond) {
 774             code.resolvePending();
 775 
 776             LetExpr tree = (LetExpr) inner_tree;
 777             int limit = code.nextreg;
 778             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
 779             try {
 780                 genStats(tree.defs, env);
 781             } finally {
 782                 code.setLetExprStackPos(prevLetExprStart);
 783             }
 784             CondItem result = genCond(tree.expr, markBranches);
 785             code.endScopes(limit);
 786             return result;
 787         } else {
 788             CondItem result = genExpr(_tree, syms.booleanType).mkCond();
 789             if (markBranches) result.tree = _tree;
 790             return result;
 791         }
 792     }
 793 
 794     public Code getCode() {
 795         return code;
 796     }
 797 
 798     public Items getItems() {
 799         return items;
 800     }
 801 
 802     public Env&lt;AttrContext&gt; getAttrEnv() {
 803         return attrEnv;
 804     }
 805 
 806     /** Visitor class for expressions which might be constant expressions.
 807      *  This class is a subset of TreeScanner. Intended to visit trees pruned by
 808      *  Lower as long as constant expressions looking for references to any
 809      *  ClassSymbol. Any such reference will be added to the constant pool so
 810      *  automated tools can detect class dependencies better.
 811      */
 812     class ClassReferenceVisitor extends JCTree.Visitor {
 813 
 814         @Override
 815         public void visitTree(JCTree tree) {}
 816 
 817         @Override
 818         public void visitBinary(JCBinary tree) {
 819             tree.lhs.accept(this);
 820             tree.rhs.accept(this);
 821         }
 822 
 823         @Override
 824         public void visitSelect(JCFieldAccess tree) {
 825             if (tree.selected.type.hasTag(CLASS)) {
 826                 makeRef(tree.selected.pos(), tree.selected.type);
 827             }
 828         }
 829 
 830         @Override
 831         public void visitIdent(JCIdent tree) {
 832             if (tree.sym.owner instanceof ClassSymbol) {
 833                 poolWriter.putClass((ClassSymbol)tree.sym.owner);
 834             }
 835         }
 836 
 837         @Override
 838         public void visitConditional(JCConditional tree) {
 839             tree.cond.accept(this);
 840             tree.truepart.accept(this);
 841             tree.falsepart.accept(this);
 842         }
 843 
 844         @Override
 845         public void visitUnary(JCUnary tree) {
 846             tree.arg.accept(this);
 847         }
 848 
 849         @Override
 850         public void visitParens(JCParens tree) {
 851             tree.expr.accept(this);
 852         }
 853 
 854         @Override
 855         public void visitTypeCast(JCTypeCast tree) {
 856             tree.expr.accept(this);
 857         }
 858     }
 859 
 860     private ClassReferenceVisitor classReferenceVisitor = new ClassReferenceVisitor();
 861 
 862     /** Visitor method: generate code for an expression, catching and reporting
 863      *  any completion failures.
 864      *  @param tree    The expression to be visited.
 865      *  @param pt      The expression&#39;s expected type (proto-type).
 866      */
 867     public Item genExpr(JCTree tree, Type pt) {
 868         Type prevPt = this.pt;
 869         try {
 870             if (tree.type.constValue() != null) {
 871                 // Short circuit any expressions which are constants
 872                 tree.accept(classReferenceVisitor);
 873                 checkStringConstant(tree.pos(), tree.type.constValue());
 874                 Symbol sym = TreeInfo.symbol(tree);
 875                 if (sym != null &amp;&amp; isConstantDynamic(sym)) {
 876                     result = items.makeDynamicItem(sym);
 877                 } else {
 878                     result = items.makeImmediateItem(tree.type, tree.type.constValue());
 879                 }
 880             } else {
 881                 this.pt = pt;
 882                 tree.accept(this);
 883             }
 884             return result.coerce(pt);
 885         } catch (CompletionFailure ex) {
 886             chk.completionError(tree.pos(), ex);
 887             code.state.stacksize = 1;
 888             return items.makeStackItem(pt);
 889         } finally {
 890             this.pt = prevPt;
 891         }
 892     }
 893 
 894     public boolean isConstantDynamic(Symbol sym) {
 895         return sym.kind == VAR &amp;&amp;
 896                 sym instanceof DynamicVarSymbol &amp;&amp;
 897                 ((DynamicVarSymbol)sym).isDynamic();
 898     }
 899 
 900     /** Derived visitor method: generate code for a list of method arguments.
 901      *  @param trees    The argument expressions to be visited.
 902      *  @param pts      The expression&#39;s expected types (i.e. the formal parameter
 903      *                  types of the invoked method).
 904      */
 905     public void genArgs(List&lt;JCExpression&gt; trees, List&lt;Type&gt; pts) {
 906         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail) {
 907             genExpr(l.head, pts.head).load();
 908             pts = pts.tail;
 909         }
 910         // require lists be of same length
 911         Assert.check(pts.isEmpty());
 912     }
 913 
 914 /* ************************************************************************
 915  * Visitor methods for statements and definitions
 916  *************************************************************************/
 917 
 918     /** Thrown when the byte code size exceeds limit.
 919      */
 920     public static class CodeSizeOverflow extends RuntimeException {
 921         private static final long serialVersionUID = 0;
 922         public CodeSizeOverflow() {}
 923     }
 924 
 925     public void visitMethodDef(JCMethodDecl tree) {
 926         // Create a new local environment that points pack at method
 927         // definition.
 928         Env&lt;GenContext&gt; localEnv = env.dup(tree);
 929         localEnv.enclMethod = tree;
 930         // The expected type of every return statement in this method
 931         // is the method&#39;s return type.
 932         this.pt = tree.sym.erasure(types).getReturnType();
 933 
 934         checkDimension(tree.pos(), tree.sym.erasure(types));
 935         genMethod(tree, localEnv, false);
 936     }
 937 //where
 938         /** Generate code for a method.
 939          *  @param tree     The tree representing the method definition.
 940          *  @param env      The environment current for the method body.
 941          *  @param fatcode  A flag that indicates whether all jumps are
 942          *                  within 32K.  We first invoke this method under
 943          *                  the assumption that fatcode == false, i.e. all
 944          *                  jumps are within 32K.  If this fails, fatcode
 945          *                  is set to true and we try again.
 946          */
 947         void genMethod(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
 948             MethodSymbol meth = tree.sym;
 949             int extras = 0;
 950             // Count up extra parameters
 951             if (meth.isConstructor()) {
 952                 extras++;
 953                 if (meth.enclClass().isInner() &amp;&amp;
 954                     !meth.enclClass().isStatic()) {
 955                     extras++;
 956                 }
 957             } else if ((tree.mods.flags &amp; STATIC) == 0) {
 958                 extras++;
 959             }
 960             //      System.err.println(&quot;Generating &quot; + meth + &quot; in &quot; + meth.owner); //DEBUG
 961             if (Code.width(types.erasure(env.enclMethod.sym.type).getParameterTypes()) + extras &gt;
 962                 ClassFile.MAX_PARAMETERS) {
 963                 log.error(tree.pos(), Errors.LimitParameters);
 964                 nerrs++;
 965             }
 966 
 967             else if (tree.body != null) {
 968                 // Create a new code structure and initialize it.
 969                 int startpcCrt = initCode(tree, env, fatcode);
 970 
 971                 try {
 972                     genStat(tree.body, env);
 973                 } catch (CodeSizeOverflow e) {
 974                     // Failed due to code limit, try again with jsr/ret
 975                     startpcCrt = initCode(tree, env, fatcode);
 976                     genStat(tree.body, env);
 977                 }
 978 
 979                 if (code.state.stacksize != 0) {
 980                     log.error(tree.body.pos(), Errors.StackSimError(tree.sym));
 981                     throw new AssertionError();
 982                 }
 983 
 984                 // If last statement could complete normally, insert a
 985                 // return at the end.
 986                 if (code.isAlive()) {
 987                     code.statBegin(TreeInfo.endPos(tree.body));
 988                     if (env.enclMethod == null ||
 989                         env.enclMethod.sym.type.getReturnType().hasTag(VOID)) {
 990                         code.emitop0(return_);
 991                     } else if (env.enclMethod.sym.isValueFactory()) {
 992                         items.makeLocalItem(env.enclMethod.factoryProduct).load();
 993                         code.emitop0(areturn);
 994                     } else {
 995                         // sometime dead code seems alive (4415991);
 996                         // generate a small loop instead
 997                         int startpc = code.entryPoint();
 998                         CondItem c = items.makeCondItem(goto_);
 999                         code.resolve(c.jumpTrue(), startpc);
1000                     }
1001                 }
1002                 if (genCrt)
1003                     code.crt.put(tree.body,
1004                                  CRT_BLOCK,
1005                                  startpcCrt,
1006                                  code.curCP());
1007 
1008                 code.endScopes(0);
1009 
1010                 // If we exceeded limits, panic
1011                 if (code.checkLimits(tree.pos(), log)) {
1012                     nerrs++;
1013                     return;
1014                 }
1015 
1016                 // If we generated short code but got a long jump, do it again
1017                 // with fatCode = true.
1018                 if (!fatcode &amp;&amp; code.fatcode) genMethod(tree, env, true);
1019 
1020                 // Clean up
1021                 if(stackMap == StackMapFormat.JSR202) {
1022                     code.lastFrame = null;
1023                     code.frameBeforeLast = null;
1024                 }
1025 
1026                 // Compress exception table
1027                 code.compressCatchTable();
1028 
1029                 // Fill in type annotation positions for exception parameters
1030                 code.fillExceptionParameterPositions();
1031             }
1032         }
1033 
1034         private int initCode(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
1035             MethodSymbol meth = tree.sym;
1036 
1037             // Create a new code structure.
1038             meth.code = code = new Code(meth,
1039                                         fatcode,
1040                                         lineDebugInfo ? toplevel.lineMap : null,
1041                                         varDebugInfo,
1042                                         stackMap,
1043                                         debugCode,
1044                                         genCrt ? new CRTable(tree, env.toplevel.endPositions)
1045                                                : null,
1046                                         syms,
1047                                         types,
1048                                         poolWriter);
1049             items = new Items(poolWriter, code, syms, types);
1050             if (code.debugCode) {
1051                 System.err.println(meth + &quot; for body &quot; + tree);
1052             }
1053 
1054             // If method is not static, create a new local variable address
1055             // for `this&#39;.
1056             if ((tree.mods.flags &amp; STATIC) == 0) {
1057                 Type selfType = meth.owner.type;
1058                 if (meth.isConstructor() &amp;&amp; selfType != syms.objectType)
1059                     selfType = UninitializedType.uninitializedThis(selfType);
1060                 code.setDefined(
1061                         code.newLocal(
1062                             new VarSymbol(FINAL, names._this, selfType, meth.owner)));
1063             }
1064 
1065             // Mark all parameters as defined from the beginning of
1066             // the method.
1067             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1068                 checkDimension(l.head.pos(), l.head.sym.type);
1069                 code.setDefined(code.newLocal(l.head.sym));
1070             }
1071 
1072             // Get ready to generate code for method body.
1073             int startpcCrt = genCrt ? code.curCP() : 0;
1074             code.entryPoint();
1075 
1076             // Suppress initial stackmap
1077             code.pendingStackMap = false;
1078 
1079             return startpcCrt;
1080         }
1081 
1082         private void synthesizeValueMethod(JCMethodDecl methodDecl) {
1083             if (!methodDecl.name.toString().equals(&quot;toString&quot;)) {
1084                 throw new AssertionError(&quot;Unexpected synthetic method body&quot;);
1085             }
1086 
1087             Name name = names.toString;
1088             List&lt;Type&gt; argTypes = List.of(methodDecl.sym.owner.type);
1089             Type resType = methodDecl.restype.type;
1090 
1091             Type.MethodType indyType = new Type.MethodType(argTypes,
1092                     resType,
1093                     List.nil(),
1094                     syms.methodClass);
1095 
1096             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
1097                                                 syms.stringType,
1098                                                 syms.methodTypeType);
1099 
1100             Symbol bsm = rs.resolveInternalMethod(methodDecl.pos(),
1101                     getAttrEnv(),
1102                     syms.valueBootstrapMethods,
1103                     names.fromString(&quot;makeBootstrapMethod&quot;),
1104                     bsm_staticArgs,
1105                     null);
1106 
1107             Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(name,
1108                     syms.noSymbol,
1109                     ((MethodSymbol)bsm).asHandle(),
1110                     indyType,
1111                     List.nil().toArray(new LoadableConstant[0]));
1112 
1113             code.emitop0(aload_0);
1114             items.makeDynamicItem(dynSym).invoke();
1115             code.emitop0(areturn);
1116         }
1117 
1118     public void visitVarDef(JCVariableDecl tree) {
1119         VarSymbol v = tree.sym;
1120         if (tree.init != null) {
1121             checkStringConstant(tree.init.pos(), v.getConstValue());
1122             if (v.getConstValue() == null || varDebugInfo) {
1123                 Assert.check(code.isStatementStart());
1124                 code.newLocal(v);
1125                 genExpr(tree.init, v.erasure(types)).load();
1126                 items.makeLocalItem(v).store();
1127                 Assert.check(code.isStatementStart());
1128             }
1129         } else {
1130             code.newLocal(v);
1131         }
1132         checkDimension(tree.pos(), v.type);
1133     }
1134 
1135     public void visitSkip(JCSkip tree) {
1136     }
1137 
1138     public void visitBlock(JCBlock tree) {
1139         if ((tree.flags &amp; SYNTHETIC) != 0 &amp;&amp; env.tree.hasTag(METHODDEF) &amp;&amp; (((JCMethodDecl) env.tree).sym.owner.flags() &amp; VALUE) != 0) {
1140             synthesizeValueMethod((JCMethodDecl) env.tree);
1141             return;
1142         }
1143         int limit = code.nextreg;
1144         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1145         genStats(tree.stats, localEnv);
1146         // End the scope of all block-local variables in variable info.
1147         if (!env.tree.hasTag(METHODDEF)) {
1148             code.statBegin(tree.endpos);
1149             code.endScopes(limit);
1150             code.pendingStatPos = Position.NOPOS;
1151         }
1152     }
1153 
1154     public void visitDoLoop(JCDoWhileLoop tree) {
1155         genLoop(tree, tree.body, tree.cond, List.nil(), false);
1156     }
1157 
1158     public void visitWhileLoop(JCWhileLoop tree) {
1159         genLoop(tree, tree.body, tree.cond, List.nil(), true);
1160     }
1161 
1162     public void visitWithField(JCWithField tree) {
1163         switch(tree.field.getTag()) {
1164             case IDENT:
1165                 Symbol sym = ((JCIdent) tree.field).sym;
1166                 items.makeThisItem().load();
1167                 genExpr(tree.value, tree.field.type).load();
1168                 sym = binaryQualifier(sym, env.enclClass.type);
1169                 code.emitop2(withfield, sym, PoolWriter::putMember);
1170                 result = items.makeStackItem(tree.type);
1171                 break;
1172             case SELECT:
1173                 JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;
1174                 sym = TreeInfo.symbol(fieldAccess);
1175                 // JDK-8207332: To maintain the order of side effects, must compute value ahead of field
1176                 genExpr(tree.value, tree.field.type).load();
1177                 genExpr(fieldAccess.selected, fieldAccess.selected.type).load();
1178                 if (Code.width(tree.field.type) == 2) {
1179                     code.emitop0(dup_x2);
1180                     code.emitop0(pop);
1181                 } else {
1182                     code.emitop0(swap);
1183                 }
1184                 sym = binaryQualifier(sym, fieldAccess.selected.type);
1185                 code.emitop2(withfield, sym, PoolWriter::putMember);
1186                 result = items.makeStackItem(tree.type);
1187                 break;
1188             default:
1189                 Assert.check(false);
1190         }
1191     }
1192 
1193     public void visitForLoop(JCForLoop tree) {
1194         int limit = code.nextreg;
1195         genStats(tree.init, env);
1196         genLoop(tree, tree.body, tree.cond, tree.step, true);
1197         code.endScopes(limit);
1198     }
1199     //where
1200         /** Generate code for a loop.
1201          *  @param loop       The tree representing the loop.
1202          *  @param body       The loop&#39;s body.
1203          *  @param cond       The loop&#39;s controlling condition.
1204          *  @param step       &quot;Step&quot; statements to be inserted at end of
1205          *                    each iteration.
1206          *  @param testFirst  True if the loop test belongs before the body.
1207          */
1208         private void genLoop(JCStatement loop,
1209                              JCStatement body,
1210                              JCExpression cond,
1211                              List&lt;JCExpressionStatement&gt; step,
1212                              boolean testFirst) {
1213             Env&lt;GenContext&gt; loopEnv = env.dup(loop, new GenContext());
1214             int startpc = code.entryPoint();
1215             if (testFirst) { //while or for loop
1216                 CondItem c;
1217                 if (cond != null) {
1218                     code.statBegin(cond.pos);
1219                     Assert.check(code.isStatementStart());
1220                     c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1221                 } else {
1222                     c = items.makeCondItem(goto_);
1223                 }
1224                 Chain loopDone = c.jumpFalse();
1225                 code.resolve(c.trueJumps);
1226                 Assert.check(code.isStatementStart());
1227                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1228                 code.resolve(loopEnv.info.cont);
1229                 genStats(step, loopEnv);
1230                 code.resolve(code.branch(goto_), startpc);
1231                 code.resolve(loopDone);
1232             } else {
1233                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1234                 code.resolve(loopEnv.info.cont);
1235                 genStats(step, loopEnv);
1236                 if (code.isAlive()) {
1237                     CondItem c;
1238                     if (cond != null) {
1239                         code.statBegin(cond.pos);
1240                         Assert.check(code.isStatementStart());
1241                         c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1242                     } else {
1243                         c = items.makeCondItem(goto_);
1244                     }
1245                     code.resolve(c.jumpTrue(), startpc);
1246                     Assert.check(code.isStatementStart());
1247                     code.resolve(c.falseJumps);
1248                 }
1249             }
1250             Chain exit = loopEnv.info.exit;
1251             if (exit != null) {
1252                 code.resolve(exit);
1253                 exit.state.defined.excludeFrom(code.nextreg);
1254             }
1255         }
1256 
1257     public void visitForeachLoop(JCEnhancedForLoop tree) {
1258         throw new AssertionError(); // should have been removed by Lower.
1259     }
1260 
1261     public void visitLabelled(JCLabeledStatement tree) {
1262         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1263         genStat(tree.body, localEnv, CRT_STATEMENT);
1264         Chain exit = localEnv.info.exit;
1265         if (exit != null) {
1266             code.resolve(exit);
1267             exit.state.defined.excludeFrom(code.nextreg);
1268         }
1269     }
1270 
1271     public void visitSwitch(JCSwitch tree) {
1272         handleSwitch(tree, tree.selector, tree.cases);
1273     }
1274 
1275     @Override
1276     public void visitSwitchExpression(JCSwitchExpression tree) {
1277         code.resolvePending();
1278         boolean prevInCondSwitchExpression = inCondSwitchExpression;
1279         try {
1280             inCondSwitchExpression = false;
1281             doHandleSwitchExpression(tree);
1282         } finally {
1283             inCondSwitchExpression = prevInCondSwitchExpression;
1284         }
1285         result = items.makeStackItem(pt);
1286     }
1287 
1288     private void doHandleSwitchExpression(JCSwitchExpression tree) {
1289         List&lt;LocalItem&gt; prevStackBeforeSwitchExpression = stackBeforeSwitchExpression;
1290         LocalItem prevSwitchResult = switchResult;
1291         int limit = code.nextreg;
1292         try {
1293             stackBeforeSwitchExpression = List.nil();
1294             switchResult = null;
1295             if (hasTry(tree)) {
1296                 //if the switch expression contains try-catch, the catch handlers need to have
1297                 //an empty stack. So stash whole stack to local variables, and restore it before
1298                 //breaks:
1299                 while (code.state.stacksize &gt; 0) {
1300                     Type type = code.state.peek();
1301                     Name varName = names.fromString(target.syntheticNameChar() +
1302                                                     &quot;stack&quot; +
1303                                                     target.syntheticNameChar() +
1304                                                     tree.pos +
1305                                                     target.syntheticNameChar() +
1306                                                     code.state.stacksize);
1307                     VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,
1308                                                   this.env.enclMethod.sym);
1309                     LocalItem item = items.new LocalItem(type, code.newLocal(var));
1310                     stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);
1311                     item.store();
1312                 }
1313                 switchResult = makeTemp(tree.type);
1314             }
1315             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
1316             try {
1317                 handleSwitch(tree, tree.selector, tree.cases);
1318             } finally {
1319                 code.setLetExprStackPos(prevLetExprStart);
1320             }
1321         } finally {
1322             stackBeforeSwitchExpression = prevStackBeforeSwitchExpression;
1323             switchResult = prevSwitchResult;
1324             code.endScopes(limit);
1325         }
1326     }
1327     //where:
1328         private boolean hasTry(JCSwitchExpression tree) {
1329             boolean[] hasTry = new boolean[1];
1330             new TreeScanner() {
1331                 @Override
1332                 public void visitTry(JCTry tree) {
1333                     hasTry[0] = true;
1334                 }
1335 
1336                 @Override
1337                 public void visitClassDef(JCClassDecl tree) {
1338                 }
1339 
1340                 @Override
1341                 public void visitLambda(JCLambda tree) {
1342                 }
1343             }.scan(tree);
1344             return hasTry[0];
1345         }
1346 
1347     private void handleSwitch(JCTree swtch, JCExpression selector, List&lt;JCCase&gt; cases) {
1348         int limit = code.nextreg;
1349         Assert.check(!selector.type.hasTag(CLASS));
1350         int startpcCrt = genCrt ? code.curCP() : 0;
1351         Assert.check(code.isStatementStart());
1352         Item sel = genExpr(selector, syms.intType);
1353         if (cases.isEmpty()) {
1354             // We are seeing:  switch &lt;sel&gt; {}
1355             sel.load().drop();
1356             if (genCrt)
1357                 code.crt.put(TreeInfo.skipParens(selector),
1358                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1359         } else {
1360             // We are seeing a nonempty switch.
1361             sel.load();
1362             if (genCrt)
1363                 code.crt.put(TreeInfo.skipParens(selector),
1364                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1365             Env&lt;GenContext&gt; switchEnv = env.dup(swtch, new GenContext());
1366             switchEnv.info.isSwitch = true;
1367 
1368             // Compute number of labels and minimum and maximum label values.
1369             // For each case, store its label in an array.
1370             int lo = Integer.MAX_VALUE;  // minimum label.
1371             int hi = Integer.MIN_VALUE;  // maximum label.
1372             int nlabels = 0;               // number of labels.
1373 
1374             int[] labels = new int[cases.length()];  // the label array.
1375             int defaultIndex = -1;     // the index of the default clause.
1376 
1377             List&lt;JCCase&gt; l = cases;
1378             for (int i = 0; i &lt; labels.length; i++) {
1379                 if (l.head.pats.nonEmpty()) {
1380                     Assert.check(l.head.pats.size() == 1);
1381                     int val = ((Number)l.head.pats.head.type.constValue()).intValue();
1382                     labels[i] = val;
1383                     if (val &lt; lo) lo = val;
1384                     if (hi &lt; val) hi = val;
1385                     nlabels++;
1386                 } else {
1387                     Assert.check(defaultIndex == -1);
1388                     defaultIndex = i;
1389                 }
1390                 l = l.tail;
1391             }
1392 
1393             // Determine whether to issue a tableswitch or a lookupswitch
1394             // instruction.
1395             long table_space_cost = 4 + ((long) hi - lo + 1); // words
1396             long table_time_cost = 3; // comparisons
1397             long lookup_space_cost = 3 + 2 * (long) nlabels;
1398             long lookup_time_cost = nlabels;
1399             int opcode =
1400                 nlabels &gt; 0 &amp;&amp;
1401                 table_space_cost + 3 * table_time_cost &lt;=
1402                 lookup_space_cost + 3 * lookup_time_cost
1403                 ?
1404                 tableswitch : lookupswitch;
1405 
1406             int startpc = code.curCP();    // the position of the selector operation
1407             code.emitop0(opcode);
1408             code.align(4);
1409             int tableBase = code.curCP();  // the start of the jump table
1410             int[] offsets = null;          // a table of offsets for a lookupswitch
1411             code.emit4(-1);                // leave space for default offset
1412             if (opcode == tableswitch) {
1413                 code.emit4(lo);            // minimum label
1414                 code.emit4(hi);            // maximum label
1415                 for (long i = lo; i &lt;= hi; i++) {  // leave space for jump table
1416                     code.emit4(-1);
1417                 }
1418             } else {
1419                 code.emit4(nlabels);    // number of labels
1420                 for (int i = 0; i &lt; nlabels; i++) {
1421                     code.emit4(-1); code.emit4(-1); // leave space for lookup table
1422                 }
1423                 offsets = new int[labels.length];
1424             }
1425             Code.State stateSwitch = code.state.dup();
1426             code.markDead();
1427 
1428             // For each case do:
1429             l = cases;
1430             for (int i = 0; i &lt; labels.length; i++) {
1431                 JCCase c = l.head;
1432                 l = l.tail;
1433 
1434                 int pc = code.entryPoint(stateSwitch);
1435                 // Insert offset directly into code or else into the
1436                 // offsets table.
1437                 if (i != defaultIndex) {
1438                     if (opcode == tableswitch) {
1439                         code.put4(
1440                             tableBase + 4 * (labels[i] - lo + 3),
1441                             pc - startpc);
1442                     } else {
1443                         offsets[i] = pc - startpc;
1444                     }
1445                 } else {
1446                     code.put4(tableBase, pc - startpc);
1447                 }
1448 
1449                 // Generate code for the statements in this case.
1450                 genStats(c.stats, switchEnv, CRT_FLOW_TARGET);
1451             }
1452 
1453             // Resolve all breaks.
1454             Chain exit = switchEnv.info.exit;
1455             if  (exit != null) {
1456                 code.resolve(exit);
1457                 exit.state.defined.excludeFrom(limit);
1458             }
1459 
1460             // If we have not set the default offset, we do so now.
1461             if (code.get4(tableBase) == -1) {
1462                 code.put4(tableBase, code.entryPoint(stateSwitch) - startpc);
1463             }
1464 
1465             if (opcode == tableswitch) {
1466                 // Let any unfilled slots point to the default case.
1467                 int defaultOffset = code.get4(tableBase);
1468                 for (long i = lo; i &lt;= hi; i++) {
1469                     int t = (int)(tableBase + 4 * (i - lo + 3));
1470                     if (code.get4(t) == -1)
1471                         code.put4(t, defaultOffset);
1472                 }
1473             } else {
1474                 // Sort non-default offsets and copy into lookup table.
1475                 if (defaultIndex &gt;= 0)
1476                     for (int i = defaultIndex; i &lt; labels.length - 1; i++) {
1477                         labels[i] = labels[i+1];
1478                         offsets[i] = offsets[i+1];
1479                     }
1480                 if (nlabels &gt; 0)
1481                     qsort2(labels, offsets, 0, nlabels - 1);
1482                 for (int i = 0; i &lt; nlabels; i++) {
1483                     int caseidx = tableBase + 8 * (i + 1);
1484                     code.put4(caseidx, labels[i]);
1485                     code.put4(caseidx + 4, offsets[i]);
1486                 }
1487             }
1488         }
1489         code.endScopes(limit);
1490     }
1491 //where
1492         /** Sort (int) arrays of keys and values
1493          */
1494        static void qsort2(int[] keys, int[] values, int lo, int hi) {
1495             int i = lo;
1496             int j = hi;
1497             int pivot = keys[(i+j)/2];
1498             do {
1499                 while (keys[i] &lt; pivot) i++;
1500                 while (pivot &lt; keys[j]) j--;
1501                 if (i &lt;= j) {
1502                     int temp1 = keys[i];
1503                     keys[i] = keys[j];
1504                     keys[j] = temp1;
1505                     int temp2 = values[i];
1506                     values[i] = values[j];
1507                     values[j] = temp2;
1508                     i++;
1509                     j--;
1510                 }
1511             } while (i &lt;= j);
1512             if (lo &lt; j) qsort2(keys, values, lo, j);
1513             if (i &lt; hi) qsort2(keys, values, i, hi);
1514         }
1515 
1516     public void visitSynchronized(JCSynchronized tree) {
1517         int limit = code.nextreg;
1518         // Generate code to evaluate lock and save in temporary variable.
1519         final LocalItem lockVar = makeTemp(syms.objectType);
1520         Assert.check(code.isStatementStart());
1521         genExpr(tree.lock, tree.lock.type).load().duplicate();
1522         lockVar.store();
1523 
1524         // Generate code to enter monitor.
1525         code.emitop0(monitorenter);
1526         code.state.lock(lockVar.reg);
1527 
1528         // Generate code for a try statement with given body, no catch clauses
1529         // in a new environment with the &quot;exit-monitor&quot; operation as finalizer.
1530         final Env&lt;GenContext&gt; syncEnv = env.dup(tree, new GenContext());
1531         syncEnv.info.finalize = new GenFinalizer() {
1532             void gen() {
1533                 genLast();
1534                 Assert.check(syncEnv.info.gaps.length() % 2 == 0);
1535                 syncEnv.info.gaps.append(code.curCP());
1536             }
1537             void genLast() {
1538                 if (code.isAlive()) {
1539                     lockVar.load();
1540                     code.emitop0(monitorexit);
1541                     code.state.unlock(lockVar.reg);
1542                 }
1543             }
1544         };
1545         syncEnv.info.gaps = new ListBuffer&lt;&gt;();
1546         genTry(tree.body, List.nil(), syncEnv);
1547         code.endScopes(limit);
1548     }
1549 
1550     public void visitTry(final JCTry tree) {
1551         // Generate code for a try statement with given body and catch clauses,
1552         // in a new environment which calls the finally block if there is one.
1553         final Env&lt;GenContext&gt; tryEnv = env.dup(tree, new GenContext());
1554         final Env&lt;GenContext&gt; oldEnv = env;
1555         tryEnv.info.finalize = new GenFinalizer() {
1556             void gen() {
1557                 Assert.check(tryEnv.info.gaps.length() % 2 == 0);
1558                 tryEnv.info.gaps.append(code.curCP());
1559                 genLast();
1560             }
1561             void genLast() {
1562                 if (tree.finalizer != null)
1563                     genStat(tree.finalizer, oldEnv, CRT_BLOCK);
1564             }
1565             boolean hasFinalizer() {
1566                 return tree.finalizer != null;
1567             }
1568 
1569             @Override
1570             void afterBody() {
1571                 if (tree.finalizer != null &amp;&amp; (tree.finalizer.flags &amp; BODY_ONLY_FINALIZE) != 0) {
1572                     //for body-only finally, remove the GenFinalizer after try body
1573                     //so that the finally is not generated to catch bodies:
1574                     tryEnv.info.finalize = null;
1575                 }
1576             }
1577 
1578         };
1579         tryEnv.info.gaps = new ListBuffer&lt;&gt;();
1580         genTry(tree.body, tree.catchers, tryEnv);
1581     }
1582     //where
1583         /** Generate code for a try or synchronized statement
1584          *  @param body      The body of the try or synchronized statement.
1585          *  @param catchers  The lis of catch clauses.
1586          *  @param env       the environment current for the body.
1587          */
1588         void genTry(JCTree body, List&lt;JCCatch&gt; catchers, Env&lt;GenContext&gt; env) {
1589             int limit = code.nextreg;
1590             int startpc = code.curCP();
1591             Code.State stateTry = code.state.dup();
1592             genStat(body, env, CRT_BLOCK);
1593             int endpc = code.curCP();
1594             List&lt;Integer&gt; gaps = env.info.gaps.toList();
1595             code.statBegin(TreeInfo.endPos(body));
1596             genFinalizer(env);
1597             code.statBegin(TreeInfo.endPos(env.tree));
1598             Chain exitChain = code.branch(goto_);
1599             endFinalizerGap(env);
1600             env.info.finalize.afterBody();
1601             boolean hasFinalizer =
1602                 env.info.finalize != null &amp;&amp;
1603                 env.info.finalize.hasFinalizer();
1604             if (startpc != endpc) for (List&lt;JCCatch&gt; l = catchers; l.nonEmpty(); l = l.tail) {
1605                 // start off with exception on stack
1606                 code.entryPoint(stateTry, l.head.param.sym.type);
1607                 genCatch(l.head, env, startpc, endpc, gaps);
1608                 genFinalizer(env);
1609                 if (hasFinalizer || l.tail.nonEmpty()) {
1610                     code.statBegin(TreeInfo.endPos(env.tree));
1611                     exitChain = Code.mergeChains(exitChain,
1612                                                  code.branch(goto_));
1613                 }
1614                 endFinalizerGap(env);
1615             }
1616             if (hasFinalizer) {
1617                 // Create a new register segment to avoid allocating
1618                 // the same variables in finalizers and other statements.
1619                 code.newRegSegment();
1620 
1621                 // Add a catch-all clause.
1622 
1623                 // start off with exception on stack
1624                 int catchallpc = code.entryPoint(stateTry, syms.throwableType);
1625 
1626                 // Register all exception ranges for catch all clause.
1627                 // The range of the catch all clause is from the beginning
1628                 // of the try or synchronized block until the present
1629                 // code pointer excluding all gaps in the current
1630                 // environment&#39;s GenContext.
1631                 int startseg = startpc;
1632                 while (env.info.gaps.nonEmpty()) {
1633                     int endseg = env.info.gaps.next().intValue();
1634                     registerCatch(body.pos(), startseg, endseg,
1635                                   catchallpc, 0);
1636                     startseg = env.info.gaps.next().intValue();
1637                 }
1638                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1639                 code.markStatBegin();
1640 
1641                 Item excVar = makeTemp(syms.throwableType);
1642                 excVar.store();
1643                 genFinalizer(env);
1644                 code.resolvePending();
1645                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.END_POS));
1646                 code.markStatBegin();
1647 
1648                 excVar.load();
1649                 registerCatch(body.pos(), startseg,
1650                               env.info.gaps.next().intValue(),
1651                               catchallpc, 0);
1652                 code.emitop0(athrow);
1653                 code.markDead();
1654 
1655                 // If there are jsr&#39;s to this finalizer, ...
1656                 if (env.info.cont != null) {
1657                     // Resolve all jsr&#39;s.
1658                     code.resolve(env.info.cont);
1659 
1660                     // Mark statement line number
1661                     code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1662                     code.markStatBegin();
1663 
1664                     // Save return address.
1665                     LocalItem retVar = makeTemp(syms.throwableType);
1666                     retVar.store();
1667 
1668                     // Generate finalizer code.
1669                     env.info.finalize.genLast();
1670 
1671                     // Return.
1672                     code.emitop1w(ret, retVar.reg);
1673                     code.markDead();
1674                 }
1675             }
1676             // Resolve all breaks.
1677             code.resolve(exitChain);
1678 
1679             code.endScopes(limit);
1680         }
1681 
1682         /** Generate code for a catch clause.
1683          *  @param tree     The catch clause.
1684          *  @param env      The environment current in the enclosing try.
1685          *  @param startpc  Start pc of try-block.
1686          *  @param endpc    End pc of try-block.
1687          */
1688         void genCatch(JCCatch tree,
1689                       Env&lt;GenContext&gt; env,
1690                       int startpc, int endpc,
1691                       List&lt;Integer&gt; gaps) {
1692             if (startpc != endpc) {
1693                 List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypeExprs
1694                         = catchTypesWithAnnotations(tree);
1695                 while (gaps.nonEmpty()) {
1696                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1697                         JCExpression subCatch = subCatch1.snd;
1698                         int catchType = makeRef(tree.pos(), subCatch.type);
1699                         int end = gaps.head.intValue();
1700                         registerCatch(tree.pos(),
1701                                       startpc,  end, code.curCP(),
1702                                       catchType);
1703                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1704                                 tc.position.setCatchInfo(catchType, startpc);
1705                         }
1706                     }
1707                     gaps = gaps.tail;
1708                     startpc = gaps.head.intValue();
1709                     gaps = gaps.tail;
1710                 }
1711                 if (startpc &lt; endpc) {
1712                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1713                         JCExpression subCatch = subCatch1.snd;
1714                         int catchType = makeRef(tree.pos(), subCatch.type);
1715                         registerCatch(tree.pos(),
1716                                       startpc, endpc, code.curCP(),
1717                                       catchType);
1718                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1719                             tc.position.setCatchInfo(catchType, startpc);
1720                         }
1721                     }
1722                 }
1723                 VarSymbol exparam = tree.param.sym;
1724                 code.statBegin(tree.pos);
1725                 code.markStatBegin();
1726                 int limit = code.nextreg;
1727                 code.newLocal(exparam);
1728                 items.makeLocalItem(exparam).store();
1729                 code.statBegin(TreeInfo.firstStatPos(tree.body));
1730                 genStat(tree.body, env, CRT_BLOCK);
1731                 code.endScopes(limit);
1732                 code.statBegin(TreeInfo.endPos(tree.body));
1733             }
1734         }
1735         // where
1736         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotations(JCCatch tree) {
1737             return TreeInfo.isMultiCatch(tree) ?
1738                     catchTypesWithAnnotationsFromMulticatch((JCTypeUnion)tree.param.vartype, tree.param.sym.getRawTypeAttributes()) :
1739                     List.of(new Pair&lt;&gt;(tree.param.sym.getRawTypeAttributes(), tree.param.vartype));
1740         }
1741         // where
1742         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotationsFromMulticatch(JCTypeUnion tree, List&lt;TypeCompound&gt; first) {
1743             List&lt;JCExpression&gt; alts = tree.alternatives;
1744             List&lt;Pair&lt;List&lt;TypeCompound&gt;, JCExpression&gt;&gt; res = List.of(new Pair&lt;&gt;(first, alts.head));
1745             alts = alts.tail;
1746 
1747             while(alts != null &amp;&amp; alts.head != null) {
1748                 JCExpression alt = alts.head;
1749                 if (alt instanceof JCAnnotatedType) {
1750                     JCAnnotatedType a = (JCAnnotatedType)alt;
1751                     res = res.prepend(new Pair&lt;&gt;(annotate.fromAnnotations(a.annotations), alt));
1752                 } else {
1753                     res = res.prepend(new Pair&lt;&gt;(List.nil(), alt));
1754                 }
1755                 alts = alts.tail;
1756             }
1757             return res.reverse();
1758         }
1759 
1760         /** Register a catch clause in the &quot;Exceptions&quot; code-attribute.
1761          */
1762         void registerCatch(DiagnosticPosition pos,
1763                            int startpc, int endpc,
1764                            int handler_pc, int catch_type) {
1765             char startpc1 = (char)startpc;
1766             char endpc1 = (char)endpc;
1767             char handler_pc1 = (char)handler_pc;
1768             if (startpc1 == startpc &amp;&amp;
1769                 endpc1 == endpc &amp;&amp;
1770                 handler_pc1 == handler_pc) {
1771                 code.addCatch(startpc1, endpc1, handler_pc1,
1772                               (char)catch_type);
1773             } else {
1774                 log.error(pos, Errors.LimitCodeTooLargeForTryStmt);
1775                 nerrs++;
1776             }
1777         }
1778 
1779     public void visitIf(JCIf tree) {
1780         int limit = code.nextreg;
1781         Chain thenExit = null;
1782         Assert.check(code.isStatementStart());
1783         CondItem c = genCond(TreeInfo.skipParens(tree.cond),
1784                              CRT_FLOW_CONTROLLER);
1785         Chain elseChain = c.jumpFalse();
1786         Assert.check(code.isStatementStart());
1787         if (!c.isFalse()) {
1788             code.resolve(c.trueJumps);
1789             genStat(tree.thenpart, env, CRT_STATEMENT | CRT_FLOW_TARGET);
1790             thenExit = code.branch(goto_);
1791         }
1792         if (elseChain != null) {
1793             code.resolve(elseChain);
1794             if (tree.elsepart != null) {
1795                 genStat(tree.elsepart, env,CRT_STATEMENT | CRT_FLOW_TARGET);
1796             }
1797         }
1798         code.resolve(thenExit);
1799         code.endScopes(limit);
1800         Assert.check(code.isStatementStart());
1801     }
1802 
1803     public void visitExec(JCExpressionStatement tree) {
1804         // Optimize x++ to ++x and x-- to --x.
1805         JCExpression e = tree.expr;
1806         switch (e.getTag()) {
1807             case POSTINC:
1808                 ((JCUnary) e).setTag(PREINC);
1809                 break;
1810             case POSTDEC:
1811                 ((JCUnary) e).setTag(PREDEC);
1812                 break;
1813         }
1814         Assert.check(code.isStatementStart());
1815         genExpr(tree.expr, tree.expr.type).drop();
1816         Assert.check(code.isStatementStart());
1817     }
1818 
1819     public void visitBreak(JCBreak tree) {
1820         Assert.check(code.isStatementStart());
1821         final Env&lt;GenContext&gt; targetEnv = unwindBreak(tree.target);
1822         targetEnv.info.addExit(code.branch(goto_));
1823         endFinalizerGaps(env, targetEnv);
1824     }
1825 
1826     public void visitYield(JCYield tree) {
1827         Assert.check(code.isStatementStart());
1828         final Env&lt;GenContext&gt; targetEnv;
1829         if (inCondSwitchExpression) {
1830             CondItem value = genCond(tree.value, CRT_FLOW_TARGET);
1831             Chain falseJumps = value.jumpFalse();
1832 
1833             code.resolve(value.trueJumps);
1834             Env&lt;GenContext&gt; localEnv = unwindBreak(tree.target);
1835             reloadStackBeforeSwitchExpr();
1836             Chain trueJumps = code.branch(goto_);
1837 
1838             endFinalizerGaps(env, localEnv);
1839 
1840             code.resolve(falseJumps);
1841             targetEnv = unwindBreak(tree.target);
1842             reloadStackBeforeSwitchExpr();
1843             falseJumps = code.branch(goto_);
1844 
1845             if (switchExpressionTrueChain == null) {
1846                 switchExpressionTrueChain = trueJumps;
1847             } else {
1848                 switchExpressionTrueChain =
1849                         Code.mergeChains(switchExpressionTrueChain, trueJumps);
1850             }
1851             if (switchExpressionFalseChain == null) {
1852                 switchExpressionFalseChain = falseJumps;
1853             } else {
1854                 switchExpressionFalseChain =
1855                         Code.mergeChains(switchExpressionFalseChain, falseJumps);
1856             }
1857         } else {
1858             genExpr(tree.value, pt).load();
1859             if (switchResult != null)
1860                 switchResult.store();
1861 
1862             targetEnv = unwindBreak(tree.target);
1863 
1864             if (code.isAlive()) {
1865                 reloadStackBeforeSwitchExpr();
1866                 if (switchResult != null)
1867                     switchResult.load();
1868 
1869                 code.state.forceStackTop(tree.target.type);
1870                 targetEnv.info.addExit(code.branch(goto_));
1871                 code.markDead();
1872             }
1873         }
1874         endFinalizerGaps(env, targetEnv);
1875     }
1876     //where:
1877         /** As side-effect, might mark code as dead disabling any further emission.
1878          */
1879         private Env&lt;GenContext&gt; unwindBreak(JCTree target) {
1880             int tmpPos = code.pendingStatPos;
1881             Env&lt;GenContext&gt; targetEnv = unwind(target, env);
1882             code.pendingStatPos = tmpPos;
1883             return targetEnv;
1884         }
1885 
1886         private void reloadStackBeforeSwitchExpr() {
1887             for (LocalItem li : stackBeforeSwitchExpression)
1888                 li.load();
1889         }
1890 
1891     public void visitContinue(JCContinue tree) {
1892         int tmpPos = code.pendingStatPos;
1893         Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);
1894         code.pendingStatPos = tmpPos;
1895         Assert.check(code.isStatementStart());
1896         targetEnv.info.addCont(code.branch(goto_));
1897         endFinalizerGaps(env, targetEnv);
1898     }
1899 
1900     public void visitReturn(JCReturn tree) {
1901         int limit = code.nextreg;
1902         final Env&lt;GenContext&gt; targetEnv;
1903 
1904         /* Save and then restore the location of the return in case a finally
1905          * is expanded (with unwind()) in the middle of our bytecodes.
1906          */
1907         int tmpPos = code.pendingStatPos;
1908         if (tree.expr != null) {
1909             Assert.check(code.isStatementStart());
1910             Item r = genExpr(tree.expr, pt).load();
1911             if (hasFinally(env.enclMethod, env)) {
1912                 r = makeTemp(pt);
1913                 r.store();
1914             }
1915             targetEnv = unwind(env.enclMethod, env);
1916             code.pendingStatPos = tmpPos;
1917             r.load();
1918             code.emitop0(ireturn + Code.truncate(Code.typecode(pt)));
1919         } else {
1920             targetEnv = unwind(env.enclMethod, env);
1921             code.pendingStatPos = tmpPos;
1922             code.emitop0(return_);
1923         }
1924         endFinalizerGaps(env, targetEnv);
1925         code.endScopes(limit);
1926     }
1927 
1928     public void visitThrow(JCThrow tree) {
1929         Assert.check(code.isStatementStart());
1930         genExpr(tree.expr, tree.expr.type).load();
1931         code.emitop0(athrow);
1932         Assert.check(code.isStatementStart());
1933     }
1934 
1935 /* ************************************************************************
1936  * Visitor methods for expressions
1937  *************************************************************************/
1938 
1939     public void visitApply(JCMethodInvocation tree) {
1940         setTypeAnnotationPositions(tree.pos);
1941         // Generate code for method.
1942         Item m = genExpr(tree.meth, methodType);
1943         // Generate code for all arguments, where the expected types are
1944         // the parameters of the method&#39;s external type (that is, any implicit
1945         // outer instance of a super(...) call appears as first parameter).
1946         MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(tree.meth);
1947         genArgs(tree.args,
1948                 msym.externalType(types).getParameterTypes());
1949         if (!msym.isDynamic()) {
1950             code.statBegin(tree.pos);
1951         }
1952         result = m.invoke();
1953     }
1954 
1955     public void visitConditional(JCConditional tree) {
1956         Chain thenExit = null;
1957         code.statBegin(tree.cond.pos);
1958         CondItem c = genCond(tree.cond, CRT_FLOW_CONTROLLER);
1959         Chain elseChain = c.jumpFalse();
1960         if (!c.isFalse()) {
1961             code.resolve(c.trueJumps);
1962             int startpc = genCrt ? code.curCP() : 0;
1963             code.statBegin(tree.truepart.pos);
1964             genExpr(tree.truepart, pt).load();
1965             code.state.forceStackTop(tree.type);
1966             if (genCrt) code.crt.put(tree.truepart, CRT_FLOW_TARGET,
1967                                      startpc, code.curCP());
1968             thenExit = code.branch(goto_);
1969         }
1970         if (elseChain != null) {
1971             code.resolve(elseChain);
1972             int startpc = genCrt ? code.curCP() : 0;
1973             code.statBegin(tree.falsepart.pos);
1974             genExpr(tree.falsepart, pt).load();
1975             code.state.forceStackTop(tree.type);
1976             if (genCrt) code.crt.put(tree.falsepart, CRT_FLOW_TARGET,
1977                                      startpc, code.curCP());
1978         }
1979         code.resolve(thenExit);
1980         result = items.makeStackItem(pt);
1981     }
1982 
1983     private void setTypeAnnotationPositions(int treePos) {
1984         MethodSymbol meth = code.meth;
1985         boolean initOrClinit = code.meth.getKind() == javax.lang.model.element.ElementKind.CONSTRUCTOR
1986                 || code.meth.getKind() == javax.lang.model.element.ElementKind.STATIC_INIT;
1987 
1988         for (Attribute.TypeCompound ta : meth.getRawTypeAttributes()) {
1989             if (ta.hasUnknownPosition())
1990                 ta.tryFixPosition();
1991 
1992             if (ta.position.matchesPos(treePos))
1993                 ta.position.updatePosOffset(code.cp);
1994         }
1995 
1996         if (!initOrClinit)
1997             return;
1998 
1999         for (Attribute.TypeCompound ta : meth.owner.getRawTypeAttributes()) {
2000             if (ta.hasUnknownPosition())
2001                 ta.tryFixPosition();
2002 
2003             if (ta.position.matchesPos(treePos))
2004                 ta.position.updatePosOffset(code.cp);
2005         }
2006 
2007         ClassSymbol clazz = meth.enclClass();
2008         for (Symbol s : new com.sun.tools.javac.model.FilteredMemberList(clazz.members())) {
2009             if (!s.getKind().isField())
2010                 continue;
2011 
2012             for (Attribute.TypeCompound ta : s.getRawTypeAttributes()) {
2013                 if (ta.hasUnknownPosition())
2014                     ta.tryFixPosition();
2015 
2016                 if (ta.position.matchesPos(treePos))
2017                     ta.position.updatePosOffset(code.cp);
2018             }
2019         }
2020     }
2021 
2022     public void visitNewClass(JCNewClass tree) {
2023         // Enclosing instances or anonymous classes should have been eliminated
2024         // by now.
2025         Assert.check(tree.encl == null &amp;&amp; tree.def == null);
2026         setTypeAnnotationPositions(tree.pos);
2027 
2028         code.emitop2(new_, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
2029         code.emitop0(dup);
2030 
2031         // Generate code for all arguments, where the expected types are
2032         // the parameters of the constructor&#39;s external type (that is,
2033         // any implicit outer instance appears as first parameter).
2034         genArgs(tree.args, tree.constructor.externalType(types).getParameterTypes());
2035 
2036         items.makeMemberItem(tree.constructor, true).invoke();
2037 
2038         result = items.makeStackItem(tree.type);
2039     }
2040 
2041     public void visitNewArray(JCNewArray tree) {
2042         setTypeAnnotationPositions(tree.pos);
2043 
2044         if (tree.elems != null) {
2045             Type elemtype = types.elemtype(tree.type);
2046             loadIntConst(tree.elems.length());
2047             Item arr = makeNewArray(tree.pos(), tree.type, 1);
2048             int i = 0;
2049             for (List&lt;JCExpression&gt; l = tree.elems; l.nonEmpty(); l = l.tail) {
2050                 arr.duplicate();
2051                 loadIntConst(i);
2052                 i++;
2053                 genExpr(l.head, elemtype).load();
2054                 items.makeIndexedItem(elemtype).store();
2055             }
2056             result = arr;
2057         } else {
2058             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2059                 genExpr(l.head, syms.intType).load();
2060             }
2061             result = makeNewArray(tree.pos(), tree.type, tree.dims.length());
2062         }
2063     }
2064 //where
2065         /** Generate code to create an array with given element type and number
2066          *  of dimensions.
2067          */
2068         Item makeNewArray(DiagnosticPosition pos, Type type, int ndims) {
2069             Type elemtype = types.elemtype(type);
2070             if (types.dimensions(type) &gt; ClassFile.MAX_DIMENSIONS) {
2071                 log.error(pos, Errors.LimitDimensions);
2072                 nerrs++;
2073             }
2074             int elemcode = Code.arraycode(elemtype);
2075             if (elemcode == 0 || (elemcode == 1 &amp;&amp; ndims == 1)) {
2076                 code.emitAnewarray(makeRef(pos, elemtype, types.isValue(elemtype)), type);
2077             } else if (elemcode == 1) {
2078                 code.emitMultianewarray(ndims, makeRef(pos, type), type);
2079             } else {
2080                 code.emitNewarray(elemcode, type);
2081             }
2082             return items.makeStackItem(type);
2083         }
2084 
2085     public void visitParens(JCParens tree) {
2086         result = genExpr(tree.expr, tree.expr.type);
2087     }
2088 
2089     public void visitAssign(JCAssign tree) {
2090         Item l = genExpr(tree.lhs, tree.lhs.type);
2091         genExpr(tree.rhs, tree.lhs.type).load();
2092         if (tree.rhs.type.hasTag(BOT)) {
2093             /* This is just a case of widening reference conversion that per 5.1.5 simply calls
2094                for &quot;regarding a reference as having some other type in a manner that can be proved
2095                correct at compile time.&quot;
2096             */
2097             code.state.forceStackTop(tree.lhs.type);
2098         }
2099         result = items.makeAssignItem(l);
2100     }
2101 
2102     public void visitAssignop(JCAssignOp tree) {
2103         OperatorSymbol operator = tree.operator;
2104         Item l;
2105         if (operator.opcode == string_add) {
2106             l = concat.makeConcat(tree);
2107         } else {
2108             // Generate code for first expression
2109             l = genExpr(tree.lhs, tree.lhs.type);
2110 
2111             // If we have an increment of -32768 to +32767 of a local
2112             // int variable we can use an incr instruction instead of
2113             // proceeding further.
2114             if ((tree.hasTag(PLUS_ASG) || tree.hasTag(MINUS_ASG)) &amp;&amp;
2115                 l instanceof LocalItem &amp;&amp;
2116                 tree.lhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2117                 tree.rhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2118                 tree.rhs.type.constValue() != null) {
2119                 int ival = ((Number) tree.rhs.type.constValue()).intValue();
2120                 if (tree.hasTag(MINUS_ASG)) ival = -ival;
2121                 ((LocalItem)l).incr(ival);
2122                 result = l;
2123                 return;
2124             }
2125             // Otherwise, duplicate expression, load one copy
2126             // and complete binary operation.
2127             l.duplicate();
2128             l.coerce(operator.type.getParameterTypes().head).load();
2129             completeBinop(tree.lhs, tree.rhs, operator).coerce(tree.lhs.type);
2130         }
2131         result = items.makeAssignItem(l);
2132     }
2133 
2134     public void visitUnary(JCUnary tree) {
2135         OperatorSymbol operator = tree.operator;
2136         if (tree.hasTag(NOT)) {
2137             CondItem od = genCond(tree.arg, false);
2138             result = od.negate();
2139         } else {
2140             Item od = genExpr(tree.arg, operator.type.getParameterTypes().head);
2141             switch (tree.getTag()) {
2142             case POS:
2143                 result = od.load();
2144                 break;
2145             case NEG:
2146                 result = od.load();
2147                 code.emitop0(operator.opcode);
2148                 break;
2149             case COMPL:
2150                 result = od.load();
2151                 emitMinusOne(od.typecode);
2152                 code.emitop0(operator.opcode);
2153                 break;
2154             case PREINC: case PREDEC:
2155                 od.duplicate();
2156                 if (od instanceof LocalItem &amp;&amp;
2157                     (operator.opcode == iadd || operator.opcode == isub)) {
2158                     ((LocalItem)od).incr(tree.hasTag(PREINC) ? 1 : -1);
2159                     result = od;
2160                 } else {
2161                     od.load();
2162                     code.emitop0(one(od.typecode));
2163                     code.emitop0(operator.opcode);
2164                     // Perform narrowing primitive conversion if byte,
2165                     // char, or short.  Fix for 4304655.
2166                     if (od.typecode != INTcode &amp;&amp;
2167                         Code.truncate(od.typecode) == INTcode)
2168                       code.emitop0(int2byte + od.typecode - BYTEcode);
2169                     result = items.makeAssignItem(od);
2170                 }
2171                 break;
2172             case POSTINC: case POSTDEC:
2173                 od.duplicate();
2174                 if (od instanceof LocalItem &amp;&amp;
2175                     (operator.opcode == iadd || operator.opcode == isub)) {
2176                     Item res = od.load();
2177                     ((LocalItem)od).incr(tree.hasTag(POSTINC) ? 1 : -1);
2178                     result = res;
2179                 } else {
2180                     Item res = od.load();
2181                     od.stash(od.typecode);
2182                     code.emitop0(one(od.typecode));
2183                     code.emitop0(operator.opcode);
2184                     // Perform narrowing primitive conversion if byte,
2185                     // char, or short.  Fix for 4304655.
2186                     if (od.typecode != INTcode &amp;&amp;
2187                         Code.truncate(od.typecode) == INTcode)
2188                       code.emitop0(int2byte + od.typecode - BYTEcode);
2189                     od.store();
2190                     result = res;
2191                 }
2192                 break;
2193             case NULLCHK:
2194                 result = od.load();
2195                 code.emitop0(dup);
2196                 genNullCheck(tree);
2197                 break;
2198             default:
2199                 Assert.error();
2200             }
2201         }
2202     }
2203 
2204     /** Generate a null check from the object value at stack top. */
2205     private void genNullCheck(JCTree tree) {
2206         code.statBegin(tree.pos);
2207         callMethod(tree.pos(), syms.objectsType, names.requireNonNull,
2208                    List.of(syms.objectType), true);
2209         code.emitop0(pop);
2210     }
2211 
2212     public void visitBinary(JCBinary tree) {
2213         OperatorSymbol operator = tree.operator;
2214         if (operator.opcode == string_add) {
2215             result = concat.makeConcat(tree);
2216         } else if (tree.hasTag(AND)) {
2217             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2218             if (!lcond.isFalse()) {
2219                 Chain falseJumps = lcond.jumpFalse();
2220                 code.resolve(lcond.trueJumps);
2221                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2222                 result = items.
2223                     makeCondItem(rcond.opcode,
2224                                  rcond.trueJumps,
2225                                  Code.mergeChains(falseJumps,
2226                                                   rcond.falseJumps));
2227             } else {
2228                 result = lcond;
2229             }
2230         } else if (tree.hasTag(OR)) {
2231             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2232             if (!lcond.isTrue()) {
2233                 Chain trueJumps = lcond.jumpTrue();
2234                 code.resolve(lcond.falseJumps);
2235                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2236                 result = items.
2237                     makeCondItem(rcond.opcode,
2238                                  Code.mergeChains(trueJumps, rcond.trueJumps),
2239                                  rcond.falseJumps);
2240             } else {
2241                 result = lcond;
2242             }
2243         } else {
2244             Item od = genExpr(tree.lhs, operator.type.getParameterTypes().head);
2245             od.load();
2246             result = completeBinop(tree.lhs, tree.rhs, operator);
2247         }
2248     }
2249 
2250 
2251         /** Complete generating code for operation, with left operand
2252          *  already on stack.
2253          *  @param lhs       The tree representing the left operand.
2254          *  @param rhs       The tree representing the right operand.
2255          *  @param operator  The operator symbol.
2256          */
2257         Item completeBinop(JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2258             MethodType optype = (MethodType)operator.type;
2259             int opcode = operator.opcode;
2260             if (opcode &gt;= if_icmpeq &amp;&amp; opcode &lt;= if_icmple &amp;&amp;
2261                 rhs.type.constValue() instanceof Number &amp;&amp;
2262                 ((Number) rhs.type.constValue()).intValue() == 0) {
2263                 opcode = opcode + (ifeq - if_icmpeq);
2264             } else if (opcode &gt;= if_acmpeq &amp;&amp; opcode &lt;= if_acmpne &amp;&amp;
2265                        TreeInfo.isNull(rhs)) {
2266                 opcode = opcode + (if_acmp_null - if_acmpeq);
2267             } else {
2268                 // The expected type of the right operand is
2269                 // the second parameter type of the operator, except for
2270                 // shifts with long shiftcount, where we convert the opcode
2271                 // to a short shift and the expected type to int.
2272                 Type rtype = operator.erasure(types).getParameterTypes().tail.head;
2273                 if (opcode &gt;= ishll &amp;&amp; opcode &lt;= lushrl) {
2274                     opcode = opcode + (ishl - ishll);
2275                     rtype = syms.intType;
2276                 }
2277                 // Generate code for right operand and load.
2278                 genExpr(rhs, rtype).load();
2279                 // If there are two consecutive opcode instructions,
2280                 // emit the first now.
2281                 if (opcode &gt;= (1 &lt;&lt; preShift)) {
2282                     code.emitop0(opcode &gt;&gt; preShift);
2283                     opcode = opcode &amp; 0xFF;
2284                 }
2285             }
2286             if (opcode &gt;= ifeq &amp;&amp; opcode &lt;= if_acmpne ||
2287                 opcode == if_acmp_null || opcode == if_acmp_nonnull) {
2288                 return items.makeCondItem(opcode);
2289             } else {
2290                 code.emitop0(opcode);
2291                 return items.makeStackItem(optype.restype);
2292             }
2293         }
2294 
2295     public void visitTypeCast(JCTypeCast tree) {
2296         result = genExpr(tree.expr, tree.clazz.type).load();
2297         setTypeAnnotationPositions(tree.pos);
2298         // Additional code is only needed if we cast to a reference type
2299         // which is not statically a supertype of the expression&#39;s type.
2300         // For basic types, the coerce(...) in genExpr(...) will do
2301         // the conversion.
2302         // inline widening conversion is a nop, as the VM sees a subtyping relationship.
2303         if (!tree.clazz.type.isPrimitive() &amp;&amp;
2304            !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
2305             (!tree.clazz.type.tsym.isReferenceProjection() || tree.clazz.type.tsym.valueProjection() != tree.expr.type.tsym) &amp;&amp;
2306            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
2307             checkDimension(tree.pos(), tree.clazz.type);
2308             if (types.isValue(tree.clazz.type)) {
2309                 code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);
2310             } else {
2311                 code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);
2312             }
2313 
2314         }
2315     }
2316 
2317     public void visitWildcard(JCWildcard tree) {
2318         throw new AssertionError(this.getClass().getName());
2319     }
2320 
2321     public void visitTypeTest(JCInstanceOf tree) {
2322         genExpr(tree.expr, tree.expr.type).load();
2323         setTypeAnnotationPositions(tree.pos);
2324         code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));
2325         result = items.makeStackItem(syms.booleanType);
2326     }
2327 
2328     public void visitIndexed(JCArrayAccess tree) {
2329         genExpr(tree.indexed, tree.indexed.type).load();
2330         genExpr(tree.index, syms.intType).load();
2331         result = items.makeIndexedItem(tree.type);
2332     }
2333 
2334     public void visitIdent(JCIdent tree) {
2335         Symbol sym = tree.sym;
2336         if (tree.name == names._this || tree.name == names._super) {
2337             Item res = tree.name == names._this
2338                 ? items.makeThisItem()
2339                 : items.makeSuperItem();
2340             if (sym.kind == MTH) {
2341                 // Generate code to address the constructor.
2342                 res.load();
2343                 res = items.makeMemberItem(sym, true);
2344             }
2345             result = res;
2346        } else if (isInvokeDynamic(sym) || isConstantDynamic(sym)) {
2347             if (isConstantDynamic(sym)) {
2348                 setTypeAnnotationPositions(tree.pos);
2349             }
2350             result = items.makeDynamicItem(sym);
2351         } else if (sym.kind == VAR &amp;&amp; (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
2352             result = items.makeLocalItem((VarSymbol)sym);
2353         } else if ((sym.flags() &amp; STATIC) != 0) {
2354             if (!isAccessSuper(env.enclMethod))
2355                 sym = binaryQualifier(sym, env.enclClass.type);
2356             result = items.makeStaticItem(sym);
2357         } else {
2358             items.makeThisItem().load();
2359             sym = binaryQualifier(sym, env.enclClass.type);
2360             result = items.makeMemberItem(sym, nonVirtualForPrivateAccess(sym));
2361         }
2362     }
2363 
2364     //where
2365     private boolean nonVirtualForPrivateAccess(Symbol sym) {
2366         boolean useVirtual = target.hasVirtualPrivateInvoke() &amp;&amp;
2367                              !disableVirtualizedPrivateInvoke;
2368         return !useVirtual &amp;&amp; ((sym.flags() &amp; PRIVATE) != 0);
2369     }
2370 
2371     public void visitSelect(JCFieldAccess tree) {
2372         Symbol sym = tree.sym;
2373 
2374         if (tree.name == names._class) {
2375             code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));
2376             result = items.makeStackItem(pt);
2377             return;
2378         } else if (tree.name == names._default) {
2379             if (tree.type.asElement().isValue()) {
2380                 code.emitop2(defaultvalue, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
2381             } else if (tree.type.isReference()) {
2382                 code.emitop0(aconst_null);
2383             } else {
2384                 code.emitop0(zero(Code.typecode(tree.type)));
2385             }
2386             result = items.makeStackItem(tree.type);
2387             return;
2388         }
2389 
2390         Symbol ssym = TreeInfo.symbol(tree.selected);
2391 
2392         // Are we selecting via super?
2393         boolean selectSuper =
2394             ssym != null &amp;&amp; (ssym.kind == TYP || ssym.name == names._super);
2395 
2396         // Are we accessing a member of the superclass in an access method
2397         // resulting from a qualified super?
2398         boolean accessSuper = isAccessSuper(env.enclMethod);
2399 
2400         Item base = (selectSuper)
2401             ? items.makeSuperItem()
2402             : genExpr(tree.selected, tree.selected.type);
2403 
2404         if (sym.kind == VAR &amp;&amp; ((VarSymbol) sym).getConstValue() != null) {
2405             // We are seeing a variable that is constant but its selecting
2406             // expression is not.
2407             if ((sym.flags() &amp; STATIC) != 0) {
2408                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2409                     base = base.load();
2410                 base.drop();
2411             } else {
2412                 base.load();
2413                 genNullCheck(tree.selected);
2414             }
2415             result = items.
2416                 makeImmediateItem(sym.type, ((VarSymbol) sym).getConstValue());
2417         } else {
2418             if (isInvokeDynamic(sym)) {
2419                 result = items.makeDynamicItem(sym);
2420                 return;
2421             } else {
2422                 sym = binaryQualifier(sym, tree.selected.type);
2423             }
2424             if ((sym.flags() &amp; STATIC) != 0) {
2425                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2426                     base = base.load();
2427                 base.drop();
2428                 result = items.makeStaticItem(sym);
2429             } else {
2430                 base.load();
2431                 if (sym == syms.lengthVar) {
2432                     code.emitop0(arraylength);
2433                     result = items.makeStackItem(syms.intType);
2434                 } else {
2435                     result = items.
2436                         makeMemberItem(sym,
2437                                        nonVirtualForPrivateAccess(sym) ||
2438                                        selectSuper || accessSuper);
2439                 }
2440             }
2441         }
2442     }
2443 
2444     public boolean isInvokeDynamic(Symbol sym) {
2445         return sym.kind == MTH &amp;&amp; ((MethodSymbol)sym).isDynamic();
2446     }
2447 
2448     public void visitLiteral(JCLiteral tree) {
2449         if (tree.type.hasTag(BOT)) {
2450             code.emitop0(aconst_null);
2451             result = items.makeStackItem(tree.type);
2452         }
2453         else
2454             result = items.makeImmediateItem(tree.type, tree.value);
2455     }
2456 
2457     public void visitLetExpr(LetExpr tree) {
2458         code.resolvePending();
2459 
2460         int limit = code.nextreg;
2461         int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
2462         try {
2463             genStats(tree.defs, env);
2464         } finally {
2465             code.setLetExprStackPos(prevLetExprStart);
2466         }
2467         result = genExpr(tree.expr, tree.expr.type).load();
2468         code.endScopes(limit);
2469     }
2470 
2471     private void generateReferencesToPrunedTree(ClassSymbol classSymbol) {
2472         List&lt;JCTree&gt; prunedInfo = lower.prunedTree.get(classSymbol);
2473         if (prunedInfo != null) {
2474             for (JCTree prunedTree: prunedInfo) {
2475                 prunedTree.accept(classReferenceVisitor);
2476             }
2477         }
2478     }
2479 
2480 /* ************************************************************************
2481  * main method
2482  *************************************************************************/
2483 
2484     /** Generate code for a class definition.
2485      *  @param env   The attribution environment that belongs to the
2486      *               outermost class containing this class definition.
2487      *               We need this for resolving some additional symbols.
2488      *  @param cdef  The tree representing the class definition.
2489      *  @return      True if code is generated with no errors.
2490      */
2491     public boolean genClass(Env&lt;AttrContext&gt; env, JCClassDecl cdef) {
2492         try {
2493             attrEnv = env;
2494             ClassSymbol c = cdef.sym;
2495             this.toplevel = env.toplevel;
2496             this.endPosTable = toplevel.endPositions;
2497             /* method normalizeDefs() can add references to external classes into the constant pool
2498              */
2499             cdef.defs = normalizeDefs(cdef.defs, c);
2500             cdef = transValues.translateTopLevelClass(cdef, make);
2501             generateReferencesToPrunedTree(c);
2502             Env&lt;GenContext&gt; localEnv = new Env&lt;&gt;(cdef, new GenContext());
2503             localEnv.toplevel = env.toplevel;
2504             localEnv.enclClass = cdef;
2505 
2506             for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2507                 genDef(l.head, localEnv);
2508             }
2509             if (poolWriter.size() &gt; PoolWriter.MAX_ENTRIES) {
2510                 log.error(cdef.pos(), Errors.LimitPool);
2511                 nerrs++;
2512             }
2513             if (nerrs != 0) {
2514                 // if errors, discard code
2515                 for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2516                     if (l.head.hasTag(METHODDEF))
2517                         ((JCMethodDecl) l.head).sym.code = null;
2518                 }
2519             }
2520             cdef.defs = List.nil(); // discard trees
2521             return nerrs == 0;
2522         } finally {
2523             // note: this method does NOT support recursion.
2524             attrEnv = null;
2525             this.env = null;
2526             toplevel = null;
2527             endPosTable = null;
2528             nerrs = 0;
2529         }
2530     }
2531 
2532 /* ************************************************************************
2533  * Auxiliary classes
2534  *************************************************************************/
2535 
2536     /** An abstract class for finalizer generation.
2537      */
2538     abstract class GenFinalizer {
2539         /** Generate code to clean up when unwinding. */
2540         abstract void gen();
2541 
2542         /** Generate code to clean up at last. */
2543         abstract void genLast();
2544 
2545         /** Does this finalizer have some nontrivial cleanup to perform? */
2546         boolean hasFinalizer() { return true; }
2547 
2548         /** Should be invoked after the try&#39;s body has been visited. */
2549         void afterBody() {}
2550     }
2551 
2552     /** code generation contexts,
2553      *  to be used as type parameter for environments.
2554      */
2555     static class GenContext {
2556 
2557         /** A chain for all unresolved jumps that exit the current environment.
2558          */
2559         Chain exit = null;
2560 
2561         /** A chain for all unresolved jumps that continue in the
2562          *  current environment.
2563          */
2564         Chain cont = null;
2565 
2566         /** A closure that generates the finalizer of the current environment.
2567          *  Only set for Synchronized and Try contexts.
2568          */
2569         GenFinalizer finalize = null;
2570 
2571         /** Is this a switch statement?  If so, allocate registers
2572          * even when the variable declaration is unreachable.
2573          */
2574         boolean isSwitch = false;
2575 
2576         /** A list buffer containing all gaps in the finalizer range,
2577          *  where a catch all exception should not apply.
2578          */
2579         ListBuffer&lt;Integer&gt; gaps = null;
2580 
2581         /** Add given chain to exit chain.
2582          */
2583         void addExit(Chain c)  {
2584             exit = Code.mergeChains(c, exit);
2585         }
2586 
2587         /** Add given chain to cont chain.
2588          */
2589         void addCont(Chain c) {
2590             cont = Code.mergeChains(c, cont);
2591         }
2592     }
2593 
2594 }
    </pre>
  </body>
</html>