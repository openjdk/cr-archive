<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/javaAssertions.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/stringTable.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;
  54 #include &quot;oops/flatArrayKlass.hpp&quot;
  55 #include &quot;oops/instanceKlass.hpp&quot;
  56 #include &quot;oops/method.hpp&quot;
  57 #include &quot;oops/recordComponent.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.inline.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;prims/jvm_misc.hpp&quot;
  62 #include &quot;prims/jvmtiExport.hpp&quot;
  63 #include &quot;prims/jvmtiThreadState.hpp&quot;
  64 #include &quot;prims/nativeLookup.hpp&quot;
  65 #include &quot;prims/stackwalk.hpp&quot;
  66 #include &quot;runtime/arguments.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/init.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/deoptimization.hpp&quot;
  72 #include &quot;runtime/handshake.hpp&quot;
  73 #include &quot;runtime/java.hpp&quot;
  74 #include &quot;runtime/javaCalls.hpp&quot;
  75 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  76 #include &quot;runtime/jniHandles.inline.hpp&quot;
  77 #include &quot;runtime/os.inline.hpp&quot;
  78 #include &quot;runtime/perfData.hpp&quot;
  79 #include &quot;runtime/reflection.hpp&quot;
  80 #include &quot;runtime/synchronizer.hpp&quot;
  81 #include &quot;runtime/thread.inline.hpp&quot;
  82 #include &quot;runtime/threadSMR.hpp&quot;
  83 #include &quot;runtime/vframe.inline.hpp&quot;
  84 #include &quot;runtime/vmOperations.hpp&quot;
  85 #include &quot;runtime/vm_version.hpp&quot;
  86 #include &quot;services/attachListener.hpp&quot;
  87 #include &quot;services/management.hpp&quot;
  88 #include &quot;services/threadService.hpp&quot;
  89 #include &quot;utilities/copy.hpp&quot;
  90 #include &quot;utilities/defaultStream.hpp&quot;
  91 #include &quot;utilities/dtrace.hpp&quot;
  92 #include &quot;utilities/events.hpp&quot;
  93 #include &quot;utilities/histogram.hpp&quot;
  94 #include &quot;utilities/macros.hpp&quot;
  95 #include &quot;utilities/utf8.hpp&quot;
  96 #if INCLUDE_CDS
  97 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  98 #endif
  99 
 100 #include &lt;errno.h&gt;
 101 #include &lt;jfr/recorder/jfrRecorder.hpp&gt;
 102 
 103 /*
 104   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 105   such ctors and calls MUST NOT come between an oop declaration/init and its
 106   usage because if objects are move this may cause various memory stomps, bus
 107   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 108   failures&quot;:
 109 
 110       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 111           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 112 
 113           // Object address to be held directly in mirror &amp; not visible to GC
 114           oop mirror = JNIHandles::resolve_non_null(ofClass);
 115 
 116           // If this ctor can hit a safepoint, moving objects around, then
 117           ComplexConstructor foo;
 118 
 119           // Boom! mirror may point to JUNK instead of the intended object
 120           (some dereference of mirror)
 121 
 122           // Here&#39;s another call that may block for GC, making mirror stale
 123           MutexLocker ml(some_lock);
 124 
 125           // And here&#39;s an initializer that can result in a stale oop
 126           // all in one step.
 127           oop o = call_that_can_throw_exception(TRAPS);
 128 
 129 
 130   The solution is to keep the oop declaration BELOW the ctor or function
 131   call that might cause a GC, do another resolve to reassign the oop, or
 132   consider use of a Handle instead of an oop so there is immunity from object
 133   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 134   and thus can only support use of handles passed in.
 135 */
 136 
 137 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 138   ResourceMark rm;
 139   int line_number = -1;
 140   const char * source_file = NULL;
 141   const char * trace = &quot;explicit&quot;;
 142   InstanceKlass* caller = NULL;
 143   JavaThread* jthread = JavaThread::current();
 144   if (jthread-&gt;has_last_Java_frame()) {
 145     vframeStream vfst(jthread);
 146 
 147     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 148     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 149     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 150     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 151     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 152 
 153     Method* last_caller = NULL;
 154 
 155     while (!vfst.at_end()) {
 156       Method* m = vfst.method();
 157       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 158           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 159           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 160         break;
 161       }
 162       last_caller = m;
 163       vfst.next();
 164     }
 165     // if this is called from Class.forName0 and that is called from Class.forName,
 166     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 167     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 168     bool found_it = false;
 169     if (!vfst.at_end() &amp;&amp;
 170         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 171         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 172       vfst.next();
 173       if (!vfst.at_end() &amp;&amp;
 174           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 175           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 176         vfst.next();
 177         found_it = true;
 178       }
 179     } else if (last_caller != NULL &amp;&amp;
 180                last_caller-&gt;method_holder()-&gt;name() ==
 181                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 182                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 183       found_it = true;
 184     } else if (!vfst.at_end()) {
 185       if (vfst.method()-&gt;is_native()) {
 186         // JNI call
 187         found_it = true;
 188       }
 189     }
 190     if (found_it &amp;&amp; !vfst.at_end()) {
 191       // found the caller
 192       caller = vfst.method()-&gt;method_holder();
 193       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 194       if (line_number == -1) {
 195         // show method name if it&#39;s a native method
 196         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 197       }
 198       Symbol* s = caller-&gt;source_file_name();
 199       if (s != NULL) {
 200         source_file = s-&gt;as_C_string();
 201       }
 202     }
 203   }
 204   if (caller != NULL) {
 205     if (to_class != caller) {
 206       const char * from = caller-&gt;external_name();
 207       const char * to = to_class-&gt;external_name();
 208       // print in a single call to reduce interleaving between threads
 209       if (source_file != NULL) {
 210         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 211       } else {
 212         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 213       }
 214     }
 215   }
 216 }
 217 
 218 void trace_class_resolution(Klass* to_class) {
 219   EXCEPTION_MARK;
 220   trace_class_resolution_impl(to_class, THREAD);
 221   if (HAS_PENDING_EXCEPTION) {
 222     CLEAR_PENDING_EXCEPTION;
 223   }
 224 }
 225 
 226 // Wrapper to trace JVM functions
 227 
 228 #ifdef ASSERT
 229   Histogram* JVMHistogram;
 230   volatile int JVMHistogram_lock = 0;
 231 
 232   class JVMHistogramElement : public HistogramElement {
 233     public:
 234      JVMHistogramElement(const char* name);
 235   };
 236 
 237   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 238     _name = elementName;
 239     uintx count = 0;
 240 
 241     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 242       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 243         count +=1;
 244         if ( (WarnOnStalledSpinLock &gt; 0)
 245           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 246           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 247         }
 248       }
 249      }
 250 
 251     if(JVMHistogram == NULL)
 252       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 253 
 254     JVMHistogram-&gt;add_element(this);
 255     Atomic::dec(&amp;JVMHistogram_lock);
 256   }
 257 
 258   #define JVMCountWrapper(arg) \
 259       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 260       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 261 
 262   #define JVMWrapper(arg) JVMCountWrapper(arg);
 263 #else
 264   #define JVMWrapper(arg)
 265 #endif
 266 
 267 
 268 // Interface version /////////////////////////////////////////////////////////////////////
 269 
 270 
 271 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 272   return JVM_INTERFACE_VERSION;
 273 JVM_END
 274 
 275 
 276 // java.lang.System //////////////////////////////////////////////////////////////////////
 277 
 278 
 279 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 280   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 281   return os::javaTimeMillis();
 282 JVM_END
 283 
 284 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 285   JVMWrapper(&quot;JVM_NanoTime&quot;);
 286   return os::javaTimeNanos();
 287 JVM_END
 288 
 289 // The function below is actually exposed by jdk.internal.misc.VM and not
 290 // java.lang.System, but we choose to keep it here so that it stays next
 291 // to JVM_CurrentTimeMillis and JVM_NanoTime
 292 
 293 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 294 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 295 
 296 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 297   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 298   jlong seconds;
 299   jlong nanos;
 300 
 301   os::javaTimeSystemUTC(seconds, nanos);
 302 
 303   // We&#39;re going to verify that the result can fit in a long.
 304   // For that we need the difference in seconds between &#39;seconds&#39;
 305   // and &#39;offset_secs&#39; to be such that:
 306   //     |seconds - offset_secs| &lt; (2^63/10^9)
 307   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 308   // which makes |seconds - offset_secs| &lt; 2^33
 309   // and we will prefer +/- 2^32 as the maximum acceptable diff
 310   // as 2^32 has a more natural feel than 2^33...
 311   //
 312   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 313   // sentinel value (-1) which the caller should take as an
 314   // exception value indicating that the offset given to us is
 315   // too far from range of the current time - leading to too big
 316   // a nano adjustment. The caller is expected to recover by
 317   // computing a more accurate offset and calling this method
 318   // again. (For the record 2^32 secs is ~136 years, so that
 319   // should rarely happen)
 320   //
 321   jlong diff = seconds - offset_secs;
 322   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 323      return -1; // sentinel value: the offset is too far off the target
 324   }
 325 
 326   // return the adjustment. If you compute a time by adding
 327   // this number of nanoseconds along with the number of seconds
 328   // in the offset you should get the current UTC time.
 329   return (diff * (jlong)1000000000) + nanos;
 330 JVM_END
 331 
 332 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 333                                jobject dst, jint dst_pos, jint length))
 334   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 335   // Check if we have null pointers
 336   if (src == NULL || dst == NULL) {
 337     THROW(vmSymbols::java_lang_NullPointerException());
 338   }
 339   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 340   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 341   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 342   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 343   // Do copy
 344   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 345 JVM_END
 346 
 347 
 348 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 349   JavaValue r(T_OBJECT);
 350   // public synchronized Object put(Object key, Object value);
 351   HandleMark hm(THREAD);
 352   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 353   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 354   JavaCalls::call_virtual(&amp;r,
 355                           props,
 356                           SystemDictionary::Properties_klass(),
 357                           vmSymbols::put_name(),
 358                           vmSymbols::object_object_object_signature(),
 359                           key_str,
 360                           value_str,
 361                           THREAD);
 362 }
 363 
 364 
 365 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 366 
 367 /*
 368  * Return all of the system properties in a Java String array with alternating
 369  * names and values from the jvm SystemProperty.
 370  * Which includes some internal and all commandline -D defined properties.
 371  */
 372 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 373   JVMWrapper(&quot;JVM_GetProperties&quot;);
 374   ResourceMark rm(THREAD);
 375   HandleMark hm(THREAD);
 376   int ndx = 0;
 377   int fixedCount = 2;
 378 
 379   SystemProperty* p = Arguments::system_properties();
 380   int count = Arguments::PropertyList_count(p);
 381 
 382   // Allocate result String array
 383   InstanceKlass* ik = SystemDictionary::String_klass();
 384   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 385   objArrayHandle result_h(THREAD, r);
 386 
 387   while (p != NULL) {
 388     const char * key = p-&gt;key();
 389     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 390         const char * value = p-&gt;value();
 391         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 392         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 393         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 394         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 395         ndx++;
 396     }
 397     p = p-&gt;next();
 398   }
 399 
 400   // Convert the -XX:MaxDirectMemorySize= command line flag
 401   // to the sun.nio.MaxDirectMemorySize property.
 402   // Do this after setting user properties to prevent people
 403   // from setting the value with a -D option, as requested.
 404   // Leave empty if not supplied
 405   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 406     char as_chars[256];
 407     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 408     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 409     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 410     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 411     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 412     ndx++;
 413   }
 414 
 415   // JVM monitoring and management support
 416   // Add the sun.management.compiler property for the compiler&#39;s name
 417   {
 418 #undef CSIZE
 419 #if defined(_LP64) || defined(_WIN64)
 420   #define CSIZE &quot;64-Bit &quot;
 421 #else
 422   #define CSIZE
 423 #endif // 64bit
 424 
 425 #ifdef TIERED
 426     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 427 #else
 428 #if defined(COMPILER1)
 429     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 430 #elif defined(COMPILER2)
 431     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 432 #elif INCLUDE_JVMCI
 433     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 434 #else
 435     const char* compiler_name = &quot;&quot;;
 436 #endif // compilers
 437 #endif // TIERED
 438 
 439     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 440         (Arguments::mode() != Arguments::_int)) {
 441       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 442       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 443       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 444       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 445       ndx++;
 446     }
 447   }
 448 
 449   return (jobjectArray) JNIHandles::make_local(env, result_h());
 450 JVM_END
 451 
 452 
 453 /*
 454  * Return the temporary directory that the VM uses for the attach
 455  * and perf data files.
 456  *
 457  * It is important that this directory is well-known and the
 458  * same for all VM instances. It cannot be affected by configuration
 459  * variables such as java.io.tmpdir.
 460  */
 461 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 462   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 463   HandleMark hm(THREAD);
 464   const char* temp_dir = os::get_temp_directory();
 465   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 466   return (jstring) JNIHandles::make_local(env, h());
 467 JVM_END
 468 
 469 
 470 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 471 
 472 extern volatile jint vm_created;
 473 
 474 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 475   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
 476   // Link all classes for dynamic CDS dumping before vm exit.
 477   if (DynamicDumpSharedSpaces) {
 478     MetaspaceShared::link_and_cleanup_shared_classes(THREAD);
 479   }
 480   EventShutdown event;
 481   if (event.should_commit()) {
 482     event.set_reason(&quot;Shutdown requested from Java&quot;);
 483     event.commit();
 484   }
 485 JVM_END
 486 
 487 
 488 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 489   before_exit(thread);
 490   vm_exit(code);
 491 JVM_END
 492 
 493 
 494 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 495   JVMWrapper(&quot;JVM_GC&quot;);
 496   if (!DisableExplicitGC) {
 497     if (AsyncDeflateIdleMonitors) {
 498       // AsyncDeflateIdleMonitors needs to know when System.gc() is
 499       // called so any special deflation can be done at a safepoint.
 500       ObjectSynchronizer::set_is_special_deflation_requested(true);
 501     }
 502     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 503   }
 504 JVM_END
 505 
 506 
 507 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 508   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 509   return Universe::heap()-&gt;millis_since_last_gc();
 510 JVM_END
 511 
 512 
 513 static inline jlong convert_size_t_to_jlong(size_t val) {
 514   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 515   NOT_LP64 (return (jlong)val;)
 516   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 517 }
 518 
 519 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 520   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 521   size_t n = Universe::heap()-&gt;capacity();
 522   return convert_size_t_to_jlong(n);
 523 JVM_END
 524 
 525 
 526 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 527   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 528   size_t n = Universe::heap()-&gt;unused();
 529   return convert_size_t_to_jlong(n);
 530 JVM_END
 531 
 532 
 533 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 534   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 535   size_t n = Universe::heap()-&gt;max_capacity();
 536   return convert_size_t_to_jlong(n);
 537 JVM_END
 538 
 539 
 540 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 541   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 542   return os::active_processor_count();
 543 JVM_END
 544 
 545 
 546 
 547 // java.lang.Throwable //////////////////////////////////////////////////////
 548 
 549 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 550   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 551   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 552   java_lang_Throwable::fill_in_stack_trace(exception);
 553 JVM_END
 554 
 555 // java.lang.NullPointerException ///////////////////////////////////////////
 556 
 557 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 558   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 559 
 560   oop exc = JNIHandles::resolve_non_null(throwable);
 561 
 562   Method* method;
 563   int bci;
 564   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 565     return NULL;
 566   }
 567   if (method-&gt;is_native()) {
 568     return NULL;
 569   }
 570 
 571   stringStream ss;
 572   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 573   if (ok) {
 574     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_NULL);
 575     return (jstring) JNIHandles::make_local(env, result);
 576   } else {
 577     return NULL;
 578   }
 579 JVM_END
 580 
 581 // java.lang.StackTraceElement //////////////////////////////////////////////
 582 
 583 
 584 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 585   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 586   Handle exception(THREAD, JNIHandles::resolve(throwable));
 587   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 588   objArrayHandle stack_trace(THREAD, st);
 589   // Fill in the allocated stack trace
 590   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 591 JVM_END
 592 
 593 
 594 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 595   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 596   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 597   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 598   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 599 JVM_END
 600 
 601 
 602 // java.lang.StackWalker //////////////////////////////////////////////////////
 603 
 604 
 605 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 606                                      jint skip_frames, jint frame_count, jint start_index,
 607                                      jobjectArray frames))
 608   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 609   JavaThread* jt = (JavaThread*) THREAD;
 610   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 611     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 612   }
 613 
 614   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 615 
 616   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 617   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 618   // be null.
 619   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 620   objArrayHandle frames_array_h(THREAD, fa);
 621 
 622   int limit = start_index + frame_count;
 623   if (frames_array_h-&gt;length() &lt; limit) {
 624     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 625   }
 626 
 627   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, frame_count,
 628                                start_index, frames_array_h, CHECK_NULL);
 629   return JNIHandles::make_local(env, result);
 630 JVM_END
 631 
 632 
 633 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 634                                   jint frame_count, jint start_index,
 635                                   jobjectArray frames))
 636   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 637   JavaThread* jt = (JavaThread*) THREAD;
 638 
 639   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 640   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 641   // be null.
 642   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 643   objArrayHandle frames_array_h(THREAD, fa);
 644 
 645   int limit = start_index+frame_count;
 646   if (frames_array_h-&gt;length() &lt; limit) {
 647     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 648   }
 649 
 650   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 651   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 652                                    start_index, frames_array_h, THREAD);
 653 JVM_END
 654 
 655 // java.lang.Object ///////////////////////////////////////////////
 656 
 657 
 658 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 659   JVMWrapper(&quot;JVM_IHashCode&quot;);
 660   // as implemented in the classic virtual machine; return 0 if object is NULL
<a name="1" id="anc1"></a><span class="line-modified"> 661   if (handle == NULL) {</span>
<span class="line-added"> 662     return 0;</span>
<span class="line-added"> 663   }</span>
<span class="line-added"> 664   oop obj = JNIHandles::resolve_non_null(handle);</span>
<span class="line-added"> 665   if (EnableValhalla &amp;&amp; InlineTypeIHashCodeViaMethod &amp;&amp; obj-&gt;klass()-&gt;is_inline_klass()) {</span>
<span class="line-added"> 666       JavaValue result(T_INT);</span>
<span class="line-added"> 667       JavaCallArguments args;</span>
<span class="line-added"> 668       Handle ho(THREAD, obj);</span>
<span class="line-added"> 669       args.push_oop(ho);</span>
<span class="line-added"> 670       methodHandle method(THREAD, Universe::inline_type_hash_code_method());</span>
<span class="line-added"> 671       JavaCalls::call(&amp;result, method, &amp;args, THREAD);</span>
<span class="line-added"> 672       if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added"> 673         if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::Error_klass())) {</span>
<span class="line-added"> 674           Handle e(THREAD, PENDING_EXCEPTION);</span>
<span class="line-added"> 675           CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added"> 676           THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), &quot;Internal error in hashCode&quot;, e, false);</span>
<span class="line-added"> 677         }</span>
<span class="line-added"> 678       }</span>
<span class="line-added"> 679       return result.get_jint();</span>
<span class="line-added"> 680   } else {</span>
<span class="line-added"> 681     return ObjectSynchronizer::FastHashCode(THREAD, obj);</span>
<span class="line-added"> 682   }</span>
 683 JVM_END
 684 
 685 
 686 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 687   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 688   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 689   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 690   if (JvmtiExport::should_post_monitor_wait()) {
 691     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 692 
 693     // The current thread already owns the monitor and it has not yet
 694     // been added to the wait queue so the current thread cannot be
 695     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 696     // event handler cannot accidentally consume an unpark() meant for
 697     // the ParkEvent associated with this ObjectMonitor.
 698   }
 699   ObjectSynchronizer::wait(obj, ms, CHECK);
 700 JVM_END
 701 
 702 
 703 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 704   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 705   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 706   ObjectSynchronizer::notify(obj, CHECK);
 707 JVM_END
 708 
 709 
 710 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 711   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 712   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 713   ObjectSynchronizer::notifyall(obj, CHECK);
 714 JVM_END
 715 
 716 
 717 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 718   JVMWrapper(&quot;JVM_Clone&quot;);
 719   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 720   Klass* klass = obj-&gt;klass();
 721   JvmtiVMObjectAllocEventCollector oam;
 722 
 723 #ifdef ASSERT
 724   // Just checking that the cloneable flag is set correct
 725   if (obj-&gt;is_array()) {
 726     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 727   } else {
 728     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 729     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 730     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 731   }
 732 #endif
 733 
 734   // Check if class of obj supports the Cloneable interface.
 735   // All arrays are considered to be cloneable (See JLS 20.1.5).
 736   // All j.l.r.Reference classes are considered non-cloneable.
 737   if (!klass-&gt;is_cloneable() ||
 738        klass-&gt;is_inline_klass() ||
 739       (klass-&gt;is_instance_klass() &amp;&amp;
 740        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 741     ResourceMark rm(THREAD);
 742     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 743   }
 744 
 745   // Make shallow object copy
 746   const int size = obj-&gt;size();
 747   oop new_obj_oop = NULL;
 748   if (obj-&gt;is_array()) {
 749     const int length = ((arrayOop)obj())-&gt;length();
 750     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 751                                                    /* do_zero */ true, CHECK_NULL);
 752   } else {
 753     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 754   }
 755 
 756   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 757 
 758   Handle new_obj(THREAD, new_obj_oop);
 759   // Caution: this involves a java upcall, so the clone should be
 760   // &quot;gc-robust&quot; by this stage.
 761   if (klass-&gt;has_finalizer()) {
 762     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 763     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 764     new_obj = Handle(THREAD, new_obj_oop);
 765   }
 766 
 767   return JNIHandles::make_local(env, new_obj());
 768 JVM_END
 769 
 770 // java.io.File ///////////////////////////////////////////////////////////////
 771 
 772 JVM_LEAF(char*, JVM_NativePath(char* path))
 773   JVMWrapper(&quot;JVM_NativePath&quot;);
 774   return os::native_path(path);
 775 JVM_END
 776 
 777 
 778 // Misc. class handling ///////////////////////////////////////////////////////////
 779 
 780 
 781 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 782   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 783 
 784   // Getting the class of the caller frame.
 785   //
 786   // The call stack at this point looks something like this:
 787   //
 788   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 789   // [1] [ @CallerSensitive API.method                                   ]
 790   // [.] [ (skipped intermediate frames)                                 ]
 791   // [n] [ caller                                                        ]
 792   vframeStream vfst(thread);
 793   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 794   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 795     Method* m = vfst.method();
 796     assert(m != NULL, &quot;sanity&quot;);
 797     switch (n) {
 798     case 0:
 799       // This must only be called from Reflection.getCallerClass
 800       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 801         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 802       }
 803       // fall-through
 804     case 1:
 805       // Frame 0 and 1 must be caller sensitive.
 806       if (!m-&gt;caller_sensitive()) {
 807         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 808       }
 809       break;
 810     default:
 811       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 812         // We have reached the desired frame; return the holder class.
 813         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 814       }
 815       break;
 816     }
 817   }
 818   return NULL;
 819 JVM_END
 820 
 821 
 822 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 823   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 824   oop mirror = NULL;
 825   BasicType t = name2type(utf);
 826   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 827     mirror = Universe::java_mirror(t);
 828   }
 829   if (mirror == NULL) {
 830     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 831   } else {
 832     return (jclass) JNIHandles::make_local(env, mirror);
 833   }
 834 JVM_END
 835 
 836 
 837 // Returns a class loaded by the bootstrap class loader; or null
 838 // if not found.  ClassNotFoundException is not thrown.
 839 // FindClassFromBootLoader is exported to the launcher for windows.
 840 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 841                                               const char* name))
 842   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 843 
 844   // Java libraries should ensure that name is never null or illegal.
 845   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 846     // It&#39;s impossible to create this class;  the name cannot fit
 847     // into the constant pool.
 848     return NULL;
 849   }
 850   assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false), &quot;illegal UTF name&quot;);
 851 
 852   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 853   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 854   if (k == NULL) {
 855     return NULL;
 856   }
 857 
 858   if (log_is_enabled(Debug, class, resolve)) {
 859     trace_class_resolution(k);
 860   }
 861   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 862 JVM_END
 863 
 864 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 865 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 866                                           jboolean init, jobject loader,
 867                                           jclass caller))
 868   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 869 
 870   TempNewSymbol h_name =
 871        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 872                                            CHECK_NULL);
 873 
 874   oop loader_oop = JNIHandles::resolve(loader);
 875   oop from_class = JNIHandles::resolve(caller);
 876   oop protection_domain = NULL;
 877   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 878   // NPE. Put it in another way, the bootstrap class loader has all permission and
 879   // thus no checkPackageAccess equivalence in the VM class loader.
 880   // The caller is also passed as NULL by the java code if there is no security
 881   // manager to avoid the performance cost of getting the calling class.
 882   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 883     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 884   }
 885 
 886   Handle h_loader(THREAD, loader_oop);
 887   Handle h_prot(THREAD, protection_domain);
 888   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 889                                                h_prot, false, THREAD);
 890 
 891   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 892     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 893   }
 894   return result;
 895 JVM_END
 896 
 897 // Currently only called from the old verifier.
 898 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 899                                          jboolean init, jclass from))
 900   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 901   TempNewSymbol h_name =
 902        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 903                                            CHECK_NULL);
 904   oop from_class_oop = JNIHandles::resolve(from);
 905   Klass* from_class = (from_class_oop == NULL)
 906                            ? (Klass*)NULL
 907                            : java_lang_Class::as_Klass(from_class_oop);
 908   oop class_loader = NULL;
 909   oop protection_domain = NULL;
 910   if (from_class != NULL) {
 911     class_loader = from_class-&gt;class_loader();
 912     protection_domain = from_class-&gt;protection_domain();
 913   }
 914   Handle h_loader(THREAD, class_loader);
 915   Handle h_prot  (THREAD, protection_domain);
 916   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 917                                                h_prot, true, thread);
 918 
 919   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 920     // this function is generally only used for class loading during verification.
 921     ResourceMark rm;
 922     oop from_mirror = JNIHandles::resolve_non_null(from);
 923     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 924     const char * from_name = from_class-&gt;external_name();
 925 
 926     oop mirror = JNIHandles::resolve_non_null(result);
 927     Klass* to_class = java_lang_Class::as_Klass(mirror);
 928     const char * to = to_class-&gt;external_name();
 929     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 930   }
 931 
 932   return result;
 933 JVM_END
 934 
 935 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 936   if (loader.is_null()) {
 937     return;
 938   }
 939 
 940   // check whether the current caller thread holds the lock or not.
 941   // If not, increment the corresponding counter
 942   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 943       ObjectSynchronizer::owner_self) {
 944     counter-&gt;inc();
 945   }
 946 }
 947 
 948 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 949 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 950                                       jobject loader, const jbyte *buf,
 951                                       jsize len, jobject pd, const char *source,
 952                                       TRAPS) {
 953   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 954 
 955   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 956   JavaThread* jt = (JavaThread*) THREAD;
 957 
 958   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 959                              ClassLoader::perf_define_appclass_selftime(),
 960                              ClassLoader::perf_define_appclasses(),
 961                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 962                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 963                              PerfClassTraceTime::DEFINE_CLASS);
 964 
 965   if (UsePerfData) {
 966     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 967   }
 968 
 969   // Class resolution will get the class name from the .class stream if the name is null.
 970   TempNewSymbol class_name = name == NULL ? NULL :
 971        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
 972                                            CHECK_NULL);
 973 
 974   ResourceMark rm(THREAD);
 975   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 976   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 977   if (UsePerfData) {
 978     is_lock_held_by_thread(class_loader,
 979                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 980                            THREAD);
 981   }
 982   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 983   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 984                                                    class_loader,
 985                                                    protection_domain,
 986                                                    &amp;st,
 987                                                    CHECK_NULL);
 988 
 989   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 990     trace_class_resolution(k);
 991   }
 992 
 993   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 994 }
 995 
 996 enum {
 997   NESTMATE              = java_lang_invoke_MemberName::MN_NESTMATE_CLASS,
 998   HIDDEN_CLASS          = java_lang_invoke_MemberName::MN_HIDDEN_CLASS,
 999   STRONG_LOADER_LINK    = java_lang_invoke_MemberName::MN_STRONG_LOADER_LINK,
1000   ACCESS_VM_ANNOTATIONS = java_lang_invoke_MemberName::MN_ACCESS_VM_ANNOTATIONS
1001 };
1002 
1003 /*
1004  * Define a class with the specified flags that indicates if it&#39;s a nestmate,
1005  * hidden, or strongly referenced from class loader.
1006  */
1007 static jclass jvm_lookup_define_class(JNIEnv *env, jclass lookup, const char *name,
1008                                       const jbyte *buf, jsize len, jobject pd,
1009                                       jboolean init, int flags, jobject classData, TRAPS) {
1010   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1011   JavaThread* jt = (JavaThread*) THREAD;
1012   ResourceMark rm(THREAD);
1013 
1014   Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));
1015   // Lookup class must be a non-null instance
1016   if (lookup_k == NULL) {
1017     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
1018   }
1019   assert(lookup_k-&gt;is_instance_klass(), &quot;Lookup class must be an instance klass&quot;);
1020 
1021   Handle class_loader (THREAD, lookup_k-&gt;class_loader());
1022 
1023   bool is_nestmate = (flags &amp; NESTMATE) == NESTMATE;
1024   bool is_hidden = (flags &amp; HIDDEN_CLASS) == HIDDEN_CLASS;
1025   bool is_strong = (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK;
1026   bool vm_annotations = (flags &amp; ACCESS_VM_ANNOTATIONS) == ACCESS_VM_ANNOTATIONS;
1027 
1028   InstanceKlass* host_class = NULL;
1029   if (is_nestmate) {
1030     host_class = InstanceKlass::cast(lookup_k)-&gt;nest_host(CHECK_NULL);
1031   }
1032 
1033   log_info(class, nestmates)(&quot;LookupDefineClass: %s - %s%s, %s, %s, %s&quot;,
1034                              name,
1035                              is_nestmate ? &quot;with dynamic nest-host &quot; : &quot;non-nestmate&quot;,
1036                              is_nestmate ? host_class-&gt;external_name() : &quot;&quot;,
1037                              is_hidden ? &quot;hidden&quot; : &quot;not hidden&quot;,
1038                              is_strong ? &quot;strong&quot; : &quot;weak&quot;,
1039                              vm_annotations ? &quot;with vm annotations&quot; : &quot;without vm annotation&quot;);
1040 
1041   if (!is_hidden) {
1042     // classData is only applicable for hidden classes
1043     if (classData != NULL) {
1044       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;classData is only applicable for hidden classes&quot;);
1045     }
1046     if (is_nestmate) {
1047       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;dynamic nestmate is only applicable for hidden classes&quot;);
1048     }
1049     if (!is_strong) {
1050       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;an ordinary class must be strongly referenced by its defining loader&quot;);
1051     }
1052     if (vm_annotations) {
1053       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;vm annotations only allowed for hidden classes&quot;);
1054     }
1055     if (flags != STRONG_LOADER_LINK) {
1056       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1057                   err_msg(&quot;invalid flag 0x%x&quot;, flags));
1058     }
1059   }
1060 
1061   // Class resolution will get the class name from the .class stream if the name is null.
1062   TempNewSymbol class_name = name == NULL ? NULL :
1063        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
1064                                            CHECK_NULL);
1065 
1066   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
1067   const char* source = is_nestmate ? host_class-&gt;external_name() : &quot;__JVM_LookupDefineClass__&quot;;
1068   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
1069 
1070   Klass* defined_k;
1071   InstanceKlass* ik = NULL;
1072   if (!is_hidden) {
1073     defined_k = SystemDictionary::resolve_from_stream(class_name,
1074                                                       class_loader,
1075                                                       protection_domain,
1076                                                       &amp;st,
1077                                                       CHECK_NULL);
1078 
1079     if (log_is_enabled(Debug, class, resolve) &amp;&amp; defined_k != NULL) {
1080       trace_class_resolution(defined_k);
1081     }
1082     ik = InstanceKlass::cast(defined_k);
1083   } else { // hidden
1084     Handle classData_h(THREAD, JNIHandles::resolve(classData));
1085     ClassLoadInfo cl_info(protection_domain,
1086                           NULL, // unsafe_anonymous_host
1087                           NULL, // cp_patches
1088                           host_class,
1089                           classData_h,
1090                           is_hidden,
1091                           is_strong,
1092                           vm_annotations);
1093     defined_k = SystemDictionary::parse_stream(class_name,
1094                                                class_loader,
1095                                                &amp;st,
1096                                                cl_info,
1097                                                CHECK_NULL);
1098     if (defined_k == NULL) {
1099       THROW_MSG_0(vmSymbols::java_lang_Error(), &quot;Failure to define a hidden class&quot;);
1100     }
1101 
1102     ik = InstanceKlass::cast(defined_k);
1103 
1104     // The hidden class loader data has been artificially been kept alive to
1105     // this point. The mirror and any instances of this class have to keep
1106     // it alive afterwards.
1107     ik-&gt;class_loader_data()-&gt;dec_keep_alive();
1108 
1109     if (is_nestmate &amp;&amp; log_is_enabled(Debug, class, nestmates)) {
1110       ModuleEntry* module = ik-&gt;module();
1111       const char * module_name = module-&gt;is_named() ? module-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
1112       log_debug(class, nestmates)(&quot;Dynamic nestmate: %s/%s, nest_host %s, %s&quot;,
1113                                   module_name,
1114                                   ik-&gt;external_name(),
1115                                   host_class-&gt;external_name(),
1116                                   ik-&gt;is_hidden() ? &quot;is hidden&quot; : &quot;is not hidden&quot;);
1117     }
1118   }
1119   assert(Reflection::is_same_class_package(lookup_k, defined_k),
1120          &quot;lookup class and defined class are in different packages&quot;);
1121 
1122   if (init) {
1123     ik-&gt;initialize(CHECK_NULL);
1124   } else {
1125     ik-&gt;link_class(CHECK_NULL);
1126   }
1127 
1128   return (jclass) JNIHandles::make_local(env, defined_k-&gt;java_mirror());
1129 }
1130 
1131 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
1132   JVMWrapper(&quot;JVM_DefineClass&quot;);
1133 
1134   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
1135 JVM_END
1136 
1137 /*
1138  * Define a class with the specified lookup class.
1139  *  lookup:  Lookup class
1140  *  name:    the name of the class
1141  *  buf:     class bytes
1142  *  len:     length of class bytes
1143  *  pd:      protection domain
1144  *  init:    initialize the class
1145  *  flags:   properties of the class
1146  *  classData: private static pre-initialized field
1147  */
1148 JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
1149           jsize len, jobject pd, jboolean initialize, int flags, jobject classData))
1150   JVMWrapper(&quot;JVM_LookupDefineClass&quot;);
1151 
1152   if (lookup == NULL) {
1153     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
1154   }
1155 
1156   assert(buf != NULL, &quot;buf must not be NULL&quot;);
1157 
1158   return jvm_lookup_define_class(env, lookup, name, buf, len, pd, initialize, flags, classData, THREAD);
1159 JVM_END
1160 
1161 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
1162   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
1163 
1164   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
1165 JVM_END
1166 
1167 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1168   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1169   ResourceMark rm(THREAD);
1170 
1171   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1172   char* str = java_lang_String::as_utf8_string(h_name());
1173 
1174   // Sanity check, don&#39;t expect null
1175   if (str == NULL) return NULL;
1176 
1177   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1178   char* p = (char*)str;
1179   while (*p != &#39;\0&#39;) {
1180       if (*p == &#39;.&#39;) {
1181           *p = &#39;/&#39;;
1182       }
1183       p++;
1184   }
1185 
1186   const int str_len = (int)(p - str);
1187   if (str_len &gt; Symbol::max_length()) {
1188     // It&#39;s impossible to create this class;  the name cannot fit
1189     // into the constant pool.
1190     return NULL;
1191   }
1192   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1193 
1194   // Security Note:
1195   //   The Java level wrapper will perform the necessary security check allowing
1196   //   us to pass the NULL as the initiating class loader.
1197   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1198   if (UsePerfData) {
1199     is_lock_held_by_thread(h_loader,
1200                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1201                            THREAD);
1202   }
1203 
1204   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1205                                                               h_loader,
1206                                                               Handle(),
1207                                                               CHECK_NULL);
1208 #if INCLUDE_CDS
1209   if (k == NULL) {
1210     // If the class is not already loaded, try to see if it&#39;s in the shared
1211     // archive for the current classloader (h_loader).
1212     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1213   }
1214 #endif
1215   return (k == NULL) ? NULL :
1216             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1217 JVM_END
1218 
1219 // Module support //////////////////////////////////////////////////////////////////////////////
1220 
1221 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1222                                  jstring location, jobjectArray packages))
1223   JVMWrapper(&quot;JVM_DefineModule&quot;);
1224   Modules::define_module(module, is_open, version, location, packages, CHECK);
1225 JVM_END
1226 
1227 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1228   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1229   Modules::set_bootloader_unnamed_module(module, CHECK);
1230 JVM_END
1231 
1232 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module))
1233   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1234   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1235 JVM_END
1236 
1237 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package))
1238   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1239   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1240 JVM_END
1241 
1242 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package))
1243   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1244   Modules::add_module_exports(from_module, package, NULL, CHECK);
1245 JVM_END
1246 
1247 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1248   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1249   Modules::add_reads_module(from_module, source_module, CHECK);
1250 JVM_END
1251 
1252 // Reflection support //////////////////////////////////////////////////////////////////////////////
1253 
1254 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1255   assert (cls != NULL, &quot;illegal class&quot;);
1256   JVMWrapper(&quot;JVM_InitClassName&quot;);
1257   JvmtiVMObjectAllocEventCollector oam;
1258   ResourceMark rm(THREAD);
1259   HandleMark hm(THREAD);
1260   Handle java_class(THREAD, JNIHandles::resolve(cls));
1261   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1262   return (jstring) JNIHandles::make_local(env, result);
1263 JVM_END
1264 
1265 
1266 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1267   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1268   JvmtiVMObjectAllocEventCollector oam;
1269   oop mirror = JNIHandles::resolve_non_null(cls);
1270 
1271   // Special handling for primitive objects
1272   if (java_lang_Class::is_primitive(mirror)) {
1273     // Primitive objects does not have any interfaces
1274     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1275     return (jobjectArray) JNIHandles::make_local(env, r);
1276   }
1277 
1278   Klass* klass = java_lang_Class::as_Klass(mirror);
1279   // Figure size of result array
1280   int size;
1281   if (klass-&gt;is_instance_klass()) {
1282     InstanceKlass* ik = InstanceKlass::cast(klass);
1283     size = ik-&gt;local_interfaces()-&gt;length();
1284     if (ik-&gt;has_injected_identityObject()) {
1285       size--;
1286     }
1287   } else {
1288     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1289     size = 3;
1290   }
1291 
1292   // Allocate result array
1293   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1294   objArrayHandle result (THREAD, r);
1295   // Fill in result
1296   if (klass-&gt;is_instance_klass()) {
1297     // Regular instance klass, fill in all local interfaces
1298     int cursor = 0;
1299     for (int index = 0; index &lt; size; index++) {
1300       InstanceKlass* ik = InstanceKlass::cast(klass);
1301       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);
1302       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {
1303         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());
1304       }
1305     }
1306   } else {
1307     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject
1308     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1309     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1310     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());
1311   }
1312   return (jobjectArray) JNIHandles::make_local(env, result());
1313 JVM_END
1314 
1315 
1316 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1317   JVMWrapper(&quot;JVM_IsInterface&quot;);
1318   oop mirror = JNIHandles::resolve_non_null(cls);
1319   if (java_lang_Class::is_primitive(mirror)) {
1320     return JNI_FALSE;
1321   }
1322   Klass* k = java_lang_Class::as_Klass(mirror);
1323   jboolean result = k-&gt;is_interface();
1324   assert(!result || k-&gt;is_instance_klass(),
1325          &quot;all interfaces are instance types&quot;);
1326   // The compiler intrinsic for isInterface tests the
1327   // Klass::_access_flags bits in the same way.
1328   return result;
1329 JVM_END
1330 
1331 JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))
1332   JVMWrapper(&quot;JVM_IsHiddenClass&quot;);
1333   oop mirror = JNIHandles::resolve_non_null(cls);
1334   if (java_lang_Class::is_primitive(mirror)) {
1335     return JNI_FALSE;
1336   }
1337   Klass* k = java_lang_Class::as_Klass(mirror);
1338   return k-&gt;is_hidden();
1339 JVM_END
1340 
1341 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1342   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1343   JvmtiVMObjectAllocEventCollector oam;
1344   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1345     // There are no signers for primitive types
1346     return NULL;
1347   }
1348 
1349   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
1350 
1351   // If there are no signers set in the class, or if the class
1352   // is an array, return NULL.
1353   if (signers == NULL) return NULL;
1354 
1355   // copy of the signers array
1356   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1357   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1358   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1359     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1360   }
1361 
1362   // return the copy
1363   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1364 JVM_END
1365 
1366 
1367 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1368   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
1369   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1370     // This call is ignored for primitive types and arrays.
1371     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1372     // be called with an array.  Only the bootstrap loader creates arrays.
1373     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1374     if (k-&gt;is_instance_klass()) {
1375       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1376     }
1377   }
1378 JVM_END
1379 
1380 
1381 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1382   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
1383   if (JNIHandles::resolve(cls) == NULL) {
1384     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1385   }
1386 
1387   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1388     // Primitive types does not have a protection domain.
1389     return NULL;
1390   }
1391 
1392   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1393   return (jobject) JNIHandles::make_local(env, pd);
1394 JVM_END
1395 
1396 
1397 // Returns the inherited_access_control_context field of the running thread.
1398 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1399   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1400   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1401   return JNIHandles::make_local(env, result);
1402 JVM_END
1403 
1404 class RegisterArrayForGC {
1405  private:
1406   JavaThread *_thread;
1407  public:
1408   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1409     _thread = thread;
1410     _thread-&gt;register_array_for_gc(array);
1411   }
1412 
1413   ~RegisterArrayForGC() {
1414     _thread-&gt;register_array_for_gc(NULL);
1415   }
1416 };
1417 
1418 
1419 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1420   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1421   if (!UsePrivilegedStack) return NULL;
1422 
1423   ResourceMark rm(THREAD);
1424   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1425   JvmtiVMObjectAllocEventCollector oam;
1426 
1427   // count the protection domains on the execution stack. We collapse
1428   // duplicate consecutive protection domains into a single one, as
1429   // well as stopping when we hit a privileged frame.
1430 
1431   oop previous_protection_domain = NULL;
1432   Handle privileged_context(thread, NULL);
1433   bool is_privileged = false;
1434   oop protection_domain = NULL;
1435 
1436   // Iterate through Java frames
1437   vframeStream vfst(thread);
1438   for(; !vfst.at_end(); vfst.next()) {
1439     // get method of frame
1440     Method* method = vfst.method();
1441 
1442     // stop at the first privileged frame
1443     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1444       method-&gt;name() == vmSymbols::executePrivileged_name())
1445     {
1446       // this frame is privileged
1447       is_privileged = true;
1448 
1449       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1450 
1451       StackValueCollection* locals = priv-&gt;locals();
1452       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1453       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1454       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1455       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1456       privileged_context    = ctx_sv-&gt;get_obj();
1457       Handle caller         = clr_sv-&gt;get_obj();
1458 
1459       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1460       protection_domain  = caller_klass-&gt;protection_domain();
1461     } else {
1462       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1463     }
1464 
1465     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1466       local_array-&gt;push(protection_domain);
1467       previous_protection_domain = protection_domain;
1468     }
1469 
1470     if (is_privileged) break;
1471   }
1472 
1473 
1474   // either all the domains on the stack were system domains, or
1475   // we had a privileged system domain
1476   if (local_array-&gt;is_empty()) {
1477     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1478 
1479     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1480     return JNIHandles::make_local(env, result);
1481   }
1482 
1483   // the resource area must be registered in case of a gc
1484   RegisterArrayForGC ragc(thread, local_array);
1485   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1486                                                  local_array-&gt;length(), CHECK_NULL);
1487   objArrayHandle h_context(thread, context);
1488   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1489     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1490   }
1491 
1492   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1493 
1494   return JNIHandles::make_local(env, result);
1495 JVM_END
1496 
1497 
1498 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1499   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1500   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1501   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1502 JVM_END
1503 
1504 
1505 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1506   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1507   oop mirror = JNIHandles::resolve_non_null(cls);
1508   return (jboolean) java_lang_Class::is_primitive(mirror);
1509 JVM_END
1510 
1511 
1512 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1513   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1514   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1515     // Primitive type
1516     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1517   }
1518 
1519   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1520   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1521   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1522   return k-&gt;modifier_flags();
1523 JVM_END
1524 
1525 
1526 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1527 
1528 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1529   JvmtiVMObjectAllocEventCollector oam;
1530   // ofClass is a reference to a java_lang_Class object. The mirror object
1531   // of an InstanceKlass
1532 
1533   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1534       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1535     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1536     return (jobjectArray)JNIHandles::make_local(env, result);
1537   }
1538 
1539   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1540   InnerClassesIterator iter(k);
1541 
1542   if (iter.length() == 0) {
1543     // Neither an inner nor outer class
1544     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1545     return (jobjectArray)JNIHandles::make_local(env, result);
1546   }
1547 
1548   // find inner class info
1549   constantPoolHandle cp(thread, k-&gt;constants());
1550   int length = iter.length();
1551 
1552   // Allocate temp. result array
1553   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1554   objArrayHandle result (THREAD, r);
1555   int members = 0;
1556 
1557   for (; !iter.done(); iter.next()) {
1558     int ioff = iter.inner_class_info_index();
1559     int ooff = iter.outer_class_info_index();
1560 
1561     if (ioff != 0 &amp;&amp; ooff != 0) {
1562       // Check to see if the name matches the class we&#39;re looking for
1563       // before attempting to find the class.
1564       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1565         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1566         if (outer_klass == k) {
1567            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1568            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1569 
1570            // Throws an exception if outer klass has not declared k as
1571            // an inner klass
1572            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1573 
1574            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1575            members++;
1576         }
1577       }
1578     }
1579   }
1580 
1581   if (members != length) {
1582     // Return array of right length
1583     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1584     for(int i = 0; i &lt; members; i++) {
1585       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1586     }
1587     return (jobjectArray)JNIHandles::make_local(env, res);
1588   }
1589 
1590   return (jobjectArray)JNIHandles::make_local(env, result());
1591 JVM_END
1592 
1593 
1594 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1595 {
1596   // ofClass is a reference to a java_lang_Class object.
1597   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1598       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1599     return NULL;
1600   }
1601 
1602   bool inner_is_member = false;
1603   Klass* outer_klass
1604     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1605                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1606   if (outer_klass == NULL)  return NULL;  // already a top-level class
1607   if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
1608   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1609 }
1610 JVM_END
1611 
1612 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1613 {
1614   oop mirror = JNIHandles::resolve_non_null(cls);
1615   if (java_lang_Class::is_primitive(mirror) ||
1616       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {
1617     return NULL;
1618   }
1619   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1620   int ooff = 0, noff = 0;
1621   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1622     if (noff != 0) {
1623       constantPoolHandle i_cp(thread, k-&gt;constants());
1624       Symbol* name = i_cp-&gt;symbol_at(noff);
1625       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1626       return (jstring) JNIHandles::make_local(env, str());
1627     }
1628   }
1629   return NULL;
1630 }
1631 JVM_END
1632 
1633 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1634   assert (cls != NULL, &quot;illegal class&quot;);
1635   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1636   JvmtiVMObjectAllocEventCollector oam;
1637   ResourceMark rm(THREAD);
1638   // Return null for arrays and primatives
1639   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1640     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1641     if (k-&gt;is_instance_klass()) {
1642       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1643       if (sym == NULL) return NULL;
1644       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1645       return (jstring) JNIHandles::make_local(env, str());
1646     }
1647   }
1648   return NULL;
1649 JVM_END
1650 
1651 
1652 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1653   assert (cls != NULL, &quot;illegal class&quot;);
1654   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
1655 
1656   // Return null for arrays and primitives
1657   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1658     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1659     if (k-&gt;is_instance_klass()) {
1660       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1661       return (jbyteArray) JNIHandles::make_local(env, a);
1662     }
1663   }
1664   return NULL;
1665 JVM_END
1666 
1667 
1668 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1669   // some of this code was adapted from from jni_FromReflectedField
1670 
1671   oop reflected = JNIHandles::resolve_non_null(field);
1672   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1673   Klass* k    = java_lang_Class::as_Klass(mirror);
1674   int slot      = java_lang_reflect_Field::slot(reflected);
1675   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1676 
1677   InstanceKlass* ik = InstanceKlass::cast(k);
1678   intptr_t offset = ik-&gt;field_offset(slot);
1679 
1680   if (modifiers &amp; JVM_ACC_STATIC) {
1681     // for static fields we only look in the current class
1682     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1683       assert(false, &quot;cannot find static field&quot;);
1684       return false;
1685     }
1686   } else {
1687     // for instance fields we start with the current class and work
1688     // our way up through the superclass chain
1689     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1690       assert(false, &quot;cannot find instance field&quot;);
1691       return false;
1692     }
1693   }
1694   return true;
1695 }
1696 
1697 static Method* jvm_get_method_common(jobject method) {
1698   // some of this code was adapted from from jni_FromReflectedMethod
1699 
1700   oop reflected = JNIHandles::resolve_non_null(method);
1701   oop mirror    = NULL;
1702   int slot      = 0;
1703 
1704   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1705     mirror = java_lang_reflect_Constructor::clazz(reflected);
1706     slot   = java_lang_reflect_Constructor::slot(reflected);
1707   } else {
1708     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1709            &quot;wrong type&quot;);
1710     mirror = java_lang_reflect_Method::clazz(reflected);
1711     slot   = java_lang_reflect_Method::slot(reflected);
1712   }
1713   Klass* k = java_lang_Class::as_Klass(mirror);
1714 
1715   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1716   assert(m != NULL, &quot;cannot find method&quot;);
1717   return m;  // caller has to deal with NULL in product mode
1718 }
1719 
1720 /* Type use annotations support (JDK 1.8) */
1721 
1722 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1723   assert (cls != NULL, &quot;illegal class&quot;);
1724   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1725   ResourceMark rm(THREAD);
1726   // Return null for arrays and primitives
1727   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1728     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1729     if (k-&gt;is_instance_klass()) {
1730       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1731       if (type_annotations != NULL) {
1732         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1733         return (jbyteArray) JNIHandles::make_local(env, a);
1734       }
1735     }
1736   }
1737   return NULL;
1738 JVM_END
1739 
1740 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1741   assert (method != NULL, &quot;illegal method&quot;);
1742   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1743 
1744   // method is a handle to a java.lang.reflect.Method object
1745   Method* m = jvm_get_method_common(method);
1746   if (m == NULL) {
1747     return NULL;
1748   }
1749 
1750   AnnotationArray* type_annotations = m-&gt;type_annotations();
1751   if (type_annotations != NULL) {
1752     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1753     return (jbyteArray) JNIHandles::make_local(env, a);
1754   }
1755 
1756   return NULL;
1757 JVM_END
1758 
1759 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1760   assert (field != NULL, &quot;illegal field&quot;);
1761   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1762 
1763   fieldDescriptor fd;
1764   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1765   if (!gotFd) {
1766     return NULL;
1767   }
1768 
1769   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1770 JVM_END
1771 
1772 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1773   if (!cp-&gt;is_within_bounds(index)) {
1774     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1775   }
1776 }
1777 
1778 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1779 {
1780   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1781   // method is a handle to a java.lang.reflect.Method object
1782   Method* method_ptr = jvm_get_method_common(method);
1783   methodHandle mh (THREAD, method_ptr);
1784   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1785   const int num_params = mh-&gt;method_parameters_length();
1786 
1787   if (num_params &lt; 0) {
1788     // A -1 return value from method_parameters_length means there is no
1789     // parameter data.  Return null to indicate this to the reflection
1790     // API.
1791     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1792     return (jobjectArray)NULL;
1793   } else {
1794     // Otherwise, we return something up to reflection, even if it is
1795     // a zero-length array.  Why?  Because in some cases this can
1796     // trigger a MalformedParametersException.
1797 
1798     // make sure all the symbols are properly formatted
1799     for (int i = 0; i &lt; num_params; i++) {
1800       MethodParametersElement* params = mh-&gt;method_parameters_start();
1801       int index = params[i].name_cp_index;
1802       constantPoolHandle cp(THREAD, mh-&gt;constants());
1803       bounds_check(cp, index, CHECK_NULL);
1804 
1805       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1806         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1807                     &quot;Wrong type at constant pool index&quot;);
1808       }
1809 
1810     }
1811 
1812     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1813     objArrayHandle result (THREAD, result_oop);
1814 
1815     for (int i = 0; i &lt; num_params; i++) {
1816       MethodParametersElement* params = mh-&gt;method_parameters_start();
1817       // For a 0 index, give a NULL symbol
1818       Symbol* sym = 0 != params[i].name_cp_index ?
1819         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1820       int flags = params[i].flags;
1821       oop param = Reflection::new_parameter(reflected_method, i, sym,
1822                                             flags, CHECK_NULL);
1823       result-&gt;obj_at_put(i, param);
1824     }
1825     return (jobjectArray)JNIHandles::make_local(env, result());
1826   }
1827 }
1828 JVM_END
1829 
1830 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1831 
1832 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1833 {
1834   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1835   JvmtiVMObjectAllocEventCollector oam;
1836 
1837   // Exclude primitive types and array types
1838   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1839       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1840     // Return empty array
1841     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1842     return (jobjectArray) JNIHandles::make_local(env, res);
1843   }
1844 
1845   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1846   constantPoolHandle cp(THREAD, k-&gt;constants());
1847 
1848   // Ensure class is linked
1849   k-&gt;link_class(CHECK_NULL);
1850 
1851   // Allocate result
1852   int num_fields;
1853 
1854   if (publicOnly) {
1855     num_fields = 0;
1856     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1857       if (fs.access_flags().is_public()) ++num_fields;
1858     }
1859   } else {
1860     num_fields = k-&gt;java_fields_count();
1861   }
1862 
1863   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1864   objArrayHandle result (THREAD, r);
1865 
1866   int out_idx = 0;
1867   fieldDescriptor fd;
1868   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1869     if (!publicOnly || fs.access_flags().is_public()) {
1870       fd.reinitialize(k, fs.index());
1871       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1872       result-&gt;obj_at_put(out_idx, field);
1873       ++out_idx;
1874     }
1875   }
1876   assert(out_idx == num_fields, &quot;just checking&quot;);
1877   return (jobjectArray) JNIHandles::make_local(env, result());
1878 }
1879 JVM_END
1880 
1881 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1882 {
1883   JVMWrapper(&quot;JVM_IsRecord&quot;);
1884   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1885   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1886     InstanceKlass* ik = InstanceKlass::cast(k);
1887     return ik-&gt;is_record();
1888   } else {
1889     return false;
1890   }
1891 }
1892 JVM_END
1893 
1894 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1895 {
1896   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1897   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1898   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1899   InstanceKlass* ik = InstanceKlass::cast(c);
1900 
1901   if (ik-&gt;is_record()) {
1902     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1903     assert(components != NULL, &quot;components should not be NULL&quot;);
1904     {
1905       JvmtiVMObjectAllocEventCollector oam;
1906       constantPoolHandle cp(THREAD, ik-&gt;constants());
1907       int length = components-&gt;length();
1908       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1909       objArrayOop record_components =
1910         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1911       objArrayHandle components_h (THREAD, record_components);
1912 
1913       for (int x = 0; x &lt; length; x++) {
1914         RecordComponent* component = components-&gt;at(x);
1915         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1916         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1917         components_h-&gt;obj_at_put(x, component_oop);
1918       }
1919       return (jobjectArray)JNIHandles::make_local(components_h());
1920     }
1921   }
1922 
1923   // Return empty array if ofClass is not a record.
1924   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1925   return (jobjectArray)JNIHandles::make_local(env, result);
1926 }
1927 JVM_END
1928 
1929 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1930   bool is_ctor = (method-&gt;is_object_constructor() ||
1931                   method-&gt;is_static_init_factory());
1932   if (want_constructor) {
1933     return is_ctor;
1934   } else {
1935     return (!is_ctor &amp;&amp;
1936             !method-&gt;is_class_initializer() &amp;&amp;
1937             !method-&gt;is_overpass());
1938   }
1939 }
1940 
1941 static jobjectArray get_class_declared_methods_helper(
1942                                   JNIEnv *env,
1943                                   jclass ofClass, jboolean publicOnly,
1944                                   bool want_constructor,
1945                                   Klass* klass, TRAPS) {
1946 
1947   JvmtiVMObjectAllocEventCollector oam;
1948 
1949   // Exclude primitive types and array types
1950   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1951       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1952     // Return empty array
1953     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1954     return (jobjectArray) JNIHandles::make_local(env, res);
1955   }
1956 
1957   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1958 
1959   // Ensure class is linked
1960   k-&gt;link_class(CHECK_NULL);
1961 
1962   Array&lt;Method*&gt;* methods = k-&gt;methods();
1963   int methods_length = methods-&gt;length();
1964 
1965   // Save original method_idnum in case of redefinition, which can change
1966   // the idnum of obsolete methods.  The new method will have the same idnum
1967   // but if we refresh the methods array, the counts will be wrong.
1968   ResourceMark rm(THREAD);
1969   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1970   int num_methods = 0;
1971 
1972   for (int i = 0; i &lt; methods_length; i++) {
1973     methodHandle method(THREAD, methods-&gt;at(i));
1974     if (select_method(method, want_constructor)) {
1975       if (!publicOnly || method-&gt;is_public()) {
1976         idnums-&gt;push(method-&gt;method_idnum());
1977         ++num_methods;
1978       }
1979     }
1980   }
1981 
1982   // Allocate result
1983   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1984   objArrayHandle result (THREAD, r);
1985 
1986   // Now just put the methods that we selected above, but go by their idnum
1987   // in case of redefinition.  The methods can be redefined at any safepoint,
1988   // so above when allocating the oop array and below when creating reflect
1989   // objects.
1990   for (int i = 0; i &lt; num_methods; i++) {
1991     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1992     if (method.is_null()) {
1993       // Method may have been deleted and seems this API can handle null
1994       // Otherwise should probably put a method that throws NSME
1995       result-&gt;obj_at_put(i, NULL);
1996     } else {
1997       oop m;
1998       if (want_constructor) {
1999         assert(method-&gt;is_object_constructor() ||
2000                method-&gt;is_static_init_factory(), &quot;must be&quot;);
2001         m = Reflection::new_constructor(method, CHECK_NULL);
2002       } else {
2003         m = Reflection::new_method(method, false, CHECK_NULL);
2004       }
2005       result-&gt;obj_at_put(i, m);
2006     }
2007   }
2008 
2009   return (jobjectArray) JNIHandles::make_local(env, result());
2010 }
2011 
2012 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2013 {
2014   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
2015   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2016                                            /*want_constructor*/ false,
2017                                            SystemDictionary::reflect_Method_klass(), THREAD);
2018 }
2019 JVM_END
2020 
2021 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2022 {
2023   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
2024   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2025                                            /*want_constructor*/ true,
2026                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
2027 }
2028 JVM_END
2029 
2030 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
2031 {
2032   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
2033   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
2034     // Primitive type
2035     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
2036   }
2037 
2038   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2039   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
2040 }
2041 JVM_END
2042 
2043 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
2044 {
2045   JVMWrapper(&quot;JVM_AreNestMates&quot;);
2046   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2047   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2048   InstanceKlass* ck = InstanceKlass::cast(c);
2049   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
2050   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
2051   InstanceKlass* mk = InstanceKlass::cast(m);
2052   return ck-&gt;has_nestmate_access_to(mk, THREAD);
2053 }
2054 JVM_END
2055 
2056 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
2057 {
2058   // current is not a primitive or array class
2059   JVMWrapper(&quot;JVM_GetNestHost&quot;);
2060   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2061   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2062   InstanceKlass* ck = InstanceKlass::cast(c);
2063   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2064   return (jclass) (host == NULL ? NULL :
2065                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
2066 }
2067 JVM_END
2068 
2069 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
2070 {
2071   // current is not a primitive or array class
2072   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
2073   ResourceMark rm(THREAD);
2074   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2075   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2076   InstanceKlass* ck = InstanceKlass::cast(c);
2077   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2078 
2079   log_trace(class, nestmates)(&quot;Calling GetNestMembers for type %s with nest-host %s&quot;,
2080                               ck-&gt;external_name(), host-&gt;external_name());
2081   {
2082     JvmtiVMObjectAllocEventCollector oam;
2083     Array&lt;u2&gt;* members = host-&gt;nest_members();
2084     int length = members == NULL ? 0 : members-&gt;length();
2085 
2086     log_trace(class, nestmates)(&quot; - host has %d listed nest members&quot;, length);
2087 
2088     // nest host is first in the array so make it one bigger
2089     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2090                                              length + 1, CHECK_NULL);
2091     objArrayHandle result(THREAD, r);
2092     result-&gt;obj_at_put(0, host-&gt;java_mirror());
2093     if (length != 0) {
2094       int count = 0;
2095       for (int i = 0; i &lt; length; i++) {
2096         int cp_index = members-&gt;at(i);
2097         Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, THREAD);
2098         if (HAS_PENDING_EXCEPTION) {
2099           if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {
2100             return NULL; // propagate VMEs
2101           }
2102           if (log_is_enabled(Trace, class, nestmates)) {
2103             stringStream ss;
2104             char* target_member_class = host-&gt;constants()-&gt;klass_name_at(cp_index)-&gt;as_C_string();
2105             ss.print(&quot; - resolution of nest member %s failed: &quot;, target_member_class);
2106             java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);
2107             log_trace(class, nestmates)(&quot;%s&quot;, ss.as_string());
2108           }
2109           CLEAR_PENDING_EXCEPTION;
2110           continue;
2111         }
2112         if (k-&gt;is_instance_klass()) {
2113           InstanceKlass* ik = InstanceKlass::cast(k);
2114           InstanceKlass* nest_host_k = ik-&gt;nest_host(CHECK_NULL);
2115           if (nest_host_k == host) {
2116             result-&gt;obj_at_put(count+1, k-&gt;java_mirror());
2117             count++;
2118             log_trace(class, nestmates)(&quot; - [%d] = %s&quot;, count, ik-&gt;external_name());
2119           } else {
2120             log_trace(class, nestmates)(&quot; - skipping member %s with different host %s&quot;,
2121                                         ik-&gt;external_name(), nest_host_k-&gt;external_name());
2122           }
2123         } else {
2124           log_trace(class, nestmates)(&quot; - skipping member %s that is not an instance class&quot;,
2125                                       k-&gt;external_name());
2126         }
2127       }
2128       if (count &lt; length) {
2129         // we had invalid entries so we need to compact the array
2130         log_trace(class, nestmates)(&quot; - compacting array from length %d to %d&quot;,
2131                                     length + 1, count + 1);
2132 
2133         objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2134                                                   count + 1, CHECK_NULL);
2135         objArrayHandle result2(THREAD, r2);
2136         for (int i = 0; i &lt; count + 1; i++) {
2137           result2-&gt;obj_at_put(i, result-&gt;obj_at(i));
2138         }
2139         return (jobjectArray)JNIHandles::make_local(THREAD, result2());
2140       }
2141     }
2142     else {
2143       assert(host == ck || ck-&gt;is_hidden(), &quot;must be singleton nest or dynamic nestmate&quot;);
2144     }
2145     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2146   }
2147 }
2148 JVM_END
2149 
2150 JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))
2151 {
2152   JVMWrapper(&quot;JVM_GetPermittedSubclasses&quot;);
2153   assert(!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(current)), &quot;should not be&quot;);
2154   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2155   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2156   InstanceKlass* ik = InstanceKlass::cast(c);
2157   {
2158     JvmtiVMObjectAllocEventCollector oam;
2159     Array&lt;u2&gt;* subclasses = ik-&gt;permitted_subclasses();
2160     int length = subclasses == NULL ? 0 : subclasses-&gt;length();
2161     objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
2162                                              length, CHECK_NULL);
2163     objArrayHandle result(THREAD, r);
2164     for (int i = 0; i &lt; length; i++) {
2165       int cp_index = subclasses-&gt;at(i);
2166       // This returns &lt;package-name&gt;/&lt;class-name&gt;.
2167       Symbol* klass_name = ik-&gt;constants()-&gt;klass_name_at(cp_index);
2168       assert(klass_name != NULL, &quot;Unexpected null klass_name&quot;);
2169       Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2170       result-&gt;obj_at_put(i, perm_subtype_h());
2171     }
2172     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2173   }
2174 }
2175 JVM_END
2176 
2177 // Constant pool access //////////////////////////////////////////////////////////
2178 
2179 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
2180 {
2181   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
2182   JvmtiVMObjectAllocEventCollector oam;
2183 
2184   // Return null for primitives and arrays
2185   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
2186     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2187     if (k-&gt;is_instance_klass()) {
2188       InstanceKlass* k_h = InstanceKlass::cast(k);
2189       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
2190       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
2191       return JNIHandles::make_local(jcp());
2192     }
2193   }
2194   return NULL;
2195 }
2196 JVM_END
2197 
2198 
2199 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
2200 {
2201   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
2202   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2203   return cp-&gt;length();
2204 }
2205 JVM_END
2206 
2207 
2208 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2209 {
2210   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
2211   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2212   bounds_check(cp, index, CHECK_NULL);
2213   constantTag tag = cp-&gt;tag_at(index);
2214   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2215     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2216   }
2217   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
2218   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2219 }
2220 JVM_END
2221 
2222 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2223 {
2224   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
2225   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2226   bounds_check(cp, index, CHECK_NULL);
2227   constantTag tag = cp-&gt;tag_at(index);
2228   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2229     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2230   }
2231   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2232   if (k == NULL) return NULL;
2233   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2234 }
2235 JVM_END
2236 
2237 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2238   constantTag tag = cp-&gt;tag_at(index);
2239   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2240     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2241   }
2242   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2243   Klass* k_o;
2244   if (force_resolution) {
2245     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2246   } else {
2247     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2248     if (k_o == NULL) return NULL;
2249   }
2250   InstanceKlass* k = InstanceKlass::cast(k_o);
2251   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2252   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2253   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2254   if (m.is_null()) {
2255     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2256   }
2257   oop method;
2258   if (m-&gt;is_object_constructor() || m-&gt;is_static_init_factory()) {
2259     method = Reflection::new_constructor(m, CHECK_NULL);
2260   } else {
2261     method = Reflection::new_method(m, true, CHECK_NULL);
2262   }
2263   return JNIHandles::make_local(method);
2264 }
2265 
2266 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2267 {
2268   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2269   JvmtiVMObjectAllocEventCollector oam;
2270   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2271   bounds_check(cp, index, CHECK_NULL);
2272   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2273   return res;
2274 }
2275 JVM_END
2276 
2277 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2278 {
2279   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2280   JvmtiVMObjectAllocEventCollector oam;
2281   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2282   bounds_check(cp, index, CHECK_NULL);
2283   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2284   return res;
2285 }
2286 JVM_END
2287 
2288 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2289   constantTag tag = cp-&gt;tag_at(index);
2290   if (!tag.is_field()) {
2291     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2292   }
2293   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2294   Klass* k_o;
2295   if (force_resolution) {
2296     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2297   } else {
2298     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2299     if (k_o == NULL) return NULL;
2300   }
2301   InstanceKlass* k = InstanceKlass::cast(k_o);
2302   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2303   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2304   fieldDescriptor fd;
2305   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2306   if (target_klass == NULL) {
2307     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2308   }
2309   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2310   return JNIHandles::make_local(field);
2311 }
2312 
2313 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2314 {
2315   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2316   JvmtiVMObjectAllocEventCollector oam;
2317   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2318   bounds_check(cp, index, CHECK_NULL);
2319   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2320   return res;
2321 }
2322 JVM_END
2323 
2324 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2325 {
2326   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2327   JvmtiVMObjectAllocEventCollector oam;
2328   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2329   bounds_check(cp, index, CHECK_NULL);
2330   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2331   return res;
2332 }
2333 JVM_END
2334 
2335 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2336 {
2337   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2338   JvmtiVMObjectAllocEventCollector oam;
2339   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2340   bounds_check(cp, index, CHECK_NULL);
2341   constantTag tag = cp-&gt;tag_at(index);
2342   if (!tag.is_field_or_method()) {
2343     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2344   }
2345   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2346   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2347   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2348   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2349   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2350   objArrayHandle dest(THREAD, dest_o);
2351   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2352   dest-&gt;obj_at_put(0, str());
2353   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2354   dest-&gt;obj_at_put(1, str());
2355   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2356   dest-&gt;obj_at_put(2, str());
2357   return (jobjectArray) JNIHandles::make_local(dest());
2358 }
2359 JVM_END
2360 
2361 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2362 {
2363   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2364   JvmtiVMObjectAllocEventCollector oam;
2365   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2366   bounds_check(cp, index, CHECK_0);
2367   constantTag tag = cp-&gt;tag_at(index);
2368   if (!tag.is_field_or_method()) {
2369     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2370   }
2371   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2372 }
2373 JVM_END
2374 
2375 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2376 {
2377   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2378   JvmtiVMObjectAllocEventCollector oam;
2379   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2380   bounds_check(cp, index, CHECK_0);
2381   constantTag tag = cp-&gt;tag_at(index);
2382   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2383     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2384   }
2385   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2386 }
2387 JVM_END
2388 
2389 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2390 {
2391   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2392   JvmtiVMObjectAllocEventCollector oam;
2393   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2394   bounds_check(cp, index, CHECK_NULL);
2395   constantTag tag = cp-&gt;tag_at(index);
2396   if (!tag.is_name_and_type()) {
2397     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2398   }
2399   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2400   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2401   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2402   objArrayHandle dest(THREAD, dest_o);
2403   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2404   dest-&gt;obj_at_put(0, str());
2405   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2406   dest-&gt;obj_at_put(1, str());
2407   return (jobjectArray) JNIHandles::make_local(dest());
2408 }
2409 JVM_END
2410 
2411 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2412 {
2413   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2414   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2415   bounds_check(cp, index, CHECK_0);
2416   constantTag tag = cp-&gt;tag_at(index);
2417   if (!tag.is_int()) {
2418     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2419   }
2420   return cp-&gt;int_at(index);
2421 }
2422 JVM_END
2423 
2424 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2425 {
2426   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2427   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2428   bounds_check(cp, index, CHECK_(0L));
2429   constantTag tag = cp-&gt;tag_at(index);
2430   if (!tag.is_long()) {
2431     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2432   }
2433   return cp-&gt;long_at(index);
2434 }
2435 JVM_END
2436 
2437 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2438 {
2439   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2440   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2441   bounds_check(cp, index, CHECK_(0.0f));
2442   constantTag tag = cp-&gt;tag_at(index);
2443   if (!tag.is_float()) {
2444     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2445   }
2446   return cp-&gt;float_at(index);
2447 }
2448 JVM_END
2449 
2450 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2451 {
2452   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2453   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2454   bounds_check(cp, index, CHECK_(0.0));
2455   constantTag tag = cp-&gt;tag_at(index);
2456   if (!tag.is_double()) {
2457     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2458   }
2459   return cp-&gt;double_at(index);
2460 }
2461 JVM_END
2462 
2463 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2464 {
2465   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2466   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2467   bounds_check(cp, index, CHECK_NULL);
2468   constantTag tag = cp-&gt;tag_at(index);
2469   if (!tag.is_string()) {
2470     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2471   }
2472   oop str = cp-&gt;string_at(index, CHECK_NULL);
2473   return (jstring) JNIHandles::make_local(str);
2474 }
2475 JVM_END
2476 
2477 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2478 {
2479   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2480   JvmtiVMObjectAllocEventCollector oam;
2481   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2482   bounds_check(cp, index, CHECK_NULL);
2483   constantTag tag = cp-&gt;tag_at(index);
2484   if (!tag.is_symbol()) {
2485     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2486   }
2487   Symbol* sym = cp-&gt;symbol_at(index);
2488   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2489   return (jstring) JNIHandles::make_local(str());
2490 }
2491 JVM_END
2492 
2493 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2494 {
2495   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2496   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2497   bounds_check(cp, index, CHECK_0);
2498   constantTag tag = cp-&gt;tag_at(index);
2499   jbyte result = tag.value();
2500   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2501   // they are changed to the corresponding tags from the JVM spec, so that java code in
2502   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2503   if (tag.is_klass_or_reference()) {
2504       result = JVM_CONSTANT_Class;
2505   } else if (tag.is_string_index()) {
2506       result = JVM_CONSTANT_String;
2507   } else if (tag.is_method_type_in_error()) {
2508       result = JVM_CONSTANT_MethodType;
2509   } else if (tag.is_method_handle_in_error()) {
2510       result = JVM_CONSTANT_MethodHandle;
2511   } else if (tag.is_dynamic_constant_in_error()) {
2512       result = JVM_CONSTANT_Dynamic;
2513   }
2514   return result;
2515 }
2516 JVM_END
2517 
2518 // Assertion support. //////////////////////////////////////////////////////////
2519 
2520 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2521   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2522   assert(cls != NULL, &quot;bad class&quot;);
2523 
2524   oop r = JNIHandles::resolve(cls);
2525   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2526   if (java_lang_Class::is_primitive(r)) return false;
2527 
2528   Klass* k = java_lang_Class::as_Klass(r);
2529   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2530   if (!k-&gt;is_instance_klass()) return false;
2531 
2532   ResourceMark rm(THREAD);
2533   const char* name = k-&gt;name()-&gt;as_C_string();
2534   bool system_class = k-&gt;class_loader() == NULL;
2535   return JavaAssertions::enabled(name, system_class);
2536 
2537 JVM_END
2538 
2539 
2540 // Return a new AssertionStatusDirectives object with the fields filled in with
2541 // command-line assertion arguments (i.e., -ea, -da).
2542 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2543   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2544   JvmtiVMObjectAllocEventCollector oam;
2545   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2546   return JNIHandles::make_local(env, asd);
2547 JVM_END
2548 
2549 // Arrays support /////////////////////////////////////////////////////////////
2550 
2551 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))
2552   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);
2553   oop o = JNIHandles::resolve(array);
2554   Klass* k = o-&gt;klass();
2555   if ((o == NULL) || (!k-&gt;is_array_klass())) {
2556     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
2557   }
2558   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();
2559 JVM_END
2560 
2561 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))
2562   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);
2563   oop o = JNIHandles::resolve(array);
2564   Klass* k = o-&gt;klass();
2565   if ((o == NULL) || (!k-&gt;is_array_klass())) {
2566     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
2567   }
2568   if (k-&gt;is_flatArray_klass()) {
2569     FlatArrayKlass* vk = FlatArrayKlass::cast(k);
2570     if (!vk-&gt;element_access_is_atomic()) {
2571       /**
2572        * Need to decide how to implement:
2573        *
2574        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so
2575        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through
2576        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;
2577        *
2578        * 2) Use extra header in the flatArrayOop to flag atomicity required and
2579        * possibly per instance lock structure. Said info, could be placed in
2580        * &quot;trailer&quot; rather than disturb the current arrayOop
2581        */
2582       Unimplemented();
2583     }
2584   }
2585   return array;
2586 JVM_END
2587 
2588 // Verification ////////////////////////////////////////////////////////////////////////////////
2589 
2590 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2591 
2592 // RedefineClasses support: bug 6214132 caused verification to fail.
2593 // All functions from this section should call the jvmtiThreadSate function:
2594 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2595 // The function returns a Klass* of the _scratch_class if the verifier
2596 // was invoked in the middle of the class redefinition.
2597 // Otherwise it returns its argument value which is the _the_class Klass*.
2598 // Please, refer to the description in the jvmtiThreadSate.hpp.
2599 
2600 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2601   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2602   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2603   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2604   return k-&gt;name()-&gt;as_utf8();
2605 JVM_END
2606 
2607 
2608 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2609   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2610   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2611   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2612   // types will have length zero if this is not an InstanceKlass
2613   // (length is determined by call to JVM_GetClassCPEntriesCount)
2614   if (k-&gt;is_instance_klass()) {
2615     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2616     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2617       constantTag tag = cp-&gt;tag_at(index);
2618       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2619     }
2620   }
2621 JVM_END
2622 
2623 
2624 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2625   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2626   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2627   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2628   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2629 JVM_END
2630 
2631 
2632 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2633   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2634   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2635   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2636   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2637 JVM_END
2638 
2639 
2640 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2641   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2642   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2643   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2644   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2645 JVM_END
2646 
2647 
2648 // The following methods, used for the verifier, are never called with
2649 // array klasses, so a direct cast to InstanceKlass is safe.
2650 // Typically, these methods are called in a loop with bounds determined
2651 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2652 // zero for arrays.
2653 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2654   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2655   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2656   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2657   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2658   int length = method-&gt;checked_exceptions_length();
2659   if (length &gt; 0) {
2660     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2661     for (int i = 0; i &lt; length; i++) {
2662       exceptions[i] = table[i].class_cp_index;
2663     }
2664   }
2665 JVM_END
2666 
2667 
2668 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2669   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2670   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2671   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2672   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2673   return method-&gt;checked_exceptions_length();
2674 JVM_END
2675 
2676 
2677 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2678   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2679   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2680   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2681   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2682   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2683 JVM_END
2684 
2685 
2686 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2687   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2688   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2689   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2690   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2691   return method-&gt;code_size();
2692 JVM_END
2693 
2694 
2695 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2696   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2697   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2698   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2699   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2700   ExceptionTable extable(method);
2701   entry-&gt;start_pc   = extable.start_pc(entry_index);
2702   entry-&gt;end_pc     = extable.end_pc(entry_index);
2703   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2704   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2705 JVM_END
2706 
2707 
2708 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2709   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2710   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2711   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2712   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2713   return method-&gt;exception_table_length();
2714 JVM_END
2715 
2716 
2717 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2718   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2719   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2720   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2721   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2722   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2723 JVM_END
2724 
2725 
2726 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2727   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2728   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2729   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2730   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2731 JVM_END
2732 
2733 
2734 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2735   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2736   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2737   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2738   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2739   return method-&gt;max_locals();
2740 JVM_END
2741 
2742 
2743 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2744   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2745   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2746   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2747   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2748   return method-&gt;size_of_parameters();
2749 JVM_END
2750 
2751 
2752 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2753   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2754   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2755   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2756   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2757   return method-&gt;verifier_max_stack();
2758 JVM_END
2759 
2760 
2761 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2762   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2763   ResourceMark rm(THREAD);
2764   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2765   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2766   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2767   return method-&gt;is_object_constructor();
2768 JVM_END
2769 
2770 
2771 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2772   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2773   ResourceMark rm(THREAD);
2774   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2775   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2776   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2777   return method-&gt;is_overpass();
2778 JVM_END
2779 
2780 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2781   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2782   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2783   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2784   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2785   return method-&gt;name()-&gt;as_utf8();
2786 JVM_END
2787 
2788 
2789 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2790   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2791   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2792   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2793   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2794   return method-&gt;signature()-&gt;as_utf8();
2795 JVM_END
2796 
2797 /**
2798  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2799  * read entries in the constant pool.  Since the old verifier always
2800  * works on a copy of the code, it will not see any rewriting that
2801  * may possibly occur in the middle of verification.  So it is important
2802  * that nothing it calls tries to use the cpCache instead of the raw
2803  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2804  */
2805 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2806   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2807   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2808   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2809   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2810   switch (cp-&gt;tag_at(cp_index).value()) {
2811     case JVM_CONSTANT_Fieldref:
2812       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2813     default:
2814       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2815   }
2816   ShouldNotReachHere();
2817   return NULL;
2818 JVM_END
2819 
2820 
2821 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2822   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2823   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2824   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2825   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2826   switch (cp-&gt;tag_at(cp_index).value()) {
2827     case JVM_CONSTANT_InterfaceMethodref:
2828     case JVM_CONSTANT_Methodref:
2829       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2830     default:
2831       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2832   }
2833   ShouldNotReachHere();
2834   return NULL;
2835 JVM_END
2836 
2837 
2838 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2839   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2840   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2841   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2842   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2843   switch (cp-&gt;tag_at(cp_index).value()) {
2844     case JVM_CONSTANT_InterfaceMethodref:
2845     case JVM_CONSTANT_Methodref:
2846       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2847     default:
2848       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2849   }
2850   ShouldNotReachHere();
2851   return NULL;
2852 JVM_END
2853 
2854 
2855 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2856   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2857   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2858   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2859   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2860   switch (cp-&gt;tag_at(cp_index).value()) {
2861     case JVM_CONSTANT_Fieldref:
2862       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2863     default:
2864       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2865   }
2866   ShouldNotReachHere();
2867   return NULL;
2868 JVM_END
2869 
2870 
2871 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2872   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2873   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2874   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2875   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2876   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2877   return classname-&gt;as_utf8();
2878 JVM_END
2879 
2880 
2881 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2882   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2883   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2884   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2885   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2886   switch (cp-&gt;tag_at(cp_index).value()) {
2887     case JVM_CONSTANT_Fieldref: {
2888       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2889       Symbol* classname = cp-&gt;klass_name_at(class_index);
2890       return classname-&gt;as_utf8();
2891     }
2892     default:
2893       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2894   }
2895   ShouldNotReachHere();
2896   return NULL;
2897 JVM_END
2898 
2899 
2900 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2901   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2902   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2903   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2904   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2905   switch (cp-&gt;tag_at(cp_index).value()) {
2906     case JVM_CONSTANT_Methodref:
2907     case JVM_CONSTANT_InterfaceMethodref: {
2908       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2909       Symbol* classname = cp-&gt;klass_name_at(class_index);
2910       return classname-&gt;as_utf8();
2911     }
2912     default:
2913       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2914   }
2915   ShouldNotReachHere();
2916   return NULL;
2917 JVM_END
2918 
2919 
2920 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2921   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2922   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2923   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2924   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2925   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2926   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2927   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2928   switch (cp-&gt;tag_at(cp_index).value()) {
2929     case JVM_CONSTANT_Fieldref: {
2930       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2931       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2932       InstanceKlass* ik = InstanceKlass::cast(k_called);
2933       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2934         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2935           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2936         }
2937       }
2938       return -1;
2939     }
2940     default:
2941       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2942   }
2943   ShouldNotReachHere();
2944   return 0;
2945 JVM_END
2946 
2947 
2948 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2949   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2950   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2951   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2952   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2953   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2954   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2955   switch (cp-&gt;tag_at(cp_index).value()) {
2956     case JVM_CONSTANT_Methodref:
2957     case JVM_CONSTANT_InterfaceMethodref: {
2958       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2959       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2960       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2961       int methods_count = methods-&gt;length();
2962       for (int i = 0; i &lt; methods_count; i++) {
2963         Method* method = methods-&gt;at(i);
2964         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2965             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2966         }
2967       }
2968       return -1;
2969     }
2970     default:
2971       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2972   }
2973   ShouldNotReachHere();
2974   return 0;
2975 JVM_END
2976 
2977 
2978 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2979 
2980 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2981   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2982 JVM_END
2983 
2984 
2985 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2986   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2987   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2988   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2989   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2990   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2991   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2992 JVM_END
2993 
2994 // Printing support //////////////////////////////////////////////////
2995 extern &quot;C&quot; {
2996 
2997 ATTRIBUTE_PRINTF(3, 0)
2998 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2999   // Reject count values that are negative signed values converted to
3000   // unsigned; see bug 4399518, 4417214
3001   if ((intptr_t)count &lt;= 0) return -1;
3002 
3003   int result = os::vsnprintf(str, count, fmt, args);
3004   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
3005     result = -1;
3006   }
3007 
3008   return result;
3009 }
3010 
3011 ATTRIBUTE_PRINTF(3, 4)
3012 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
3013   va_list args;
3014   int len;
3015   va_start(args, fmt);
3016   len = jio_vsnprintf(str, count, fmt, args);
3017   va_end(args);
3018   return len;
3019 }
3020 
3021 ATTRIBUTE_PRINTF(2, 3)
3022 int jio_fprintf(FILE* f, const char *fmt, ...) {
3023   int len;
3024   va_list args;
3025   va_start(args, fmt);
3026   len = jio_vfprintf(f, fmt, args);
3027   va_end(args);
3028   return len;
3029 }
3030 
3031 ATTRIBUTE_PRINTF(2, 0)
3032 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
3033   if (Arguments::vfprintf_hook() != NULL) {
3034      return Arguments::vfprintf_hook()(f, fmt, args);
3035   } else {
3036     return vfprintf(f, fmt, args);
3037   }
3038 }
3039 
3040 ATTRIBUTE_PRINTF(1, 2)
3041 JNIEXPORT int jio_printf(const char *fmt, ...) {
3042   int len;
3043   va_list args;
3044   va_start(args, fmt);
3045   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
3046   va_end(args);
3047   return len;
3048 }
3049 
3050 // HotSpot specific jio method
3051 void jio_print(const char* s, size_t len) {
3052   // Try to make this function as atomic as possible.
3053   if (Arguments::vfprintf_hook() != NULL) {
3054     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
3055   } else {
3056     // Make an unused local variable to avoid warning from gcc compiler.
3057     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
3058   }
3059 }
3060 
3061 } // Extern C
3062 
3063 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
3064 
3065 // In most of the JVM thread support functions we need to access the
3066 // thread through a ThreadsListHandle to prevent it from exiting and
3067 // being reclaimed while we try to operate on it. The exceptions to this
3068 // rule are when operating on the current thread, or if the monitor of
3069 // the target java.lang.Thread is locked at the Java level - in both
3070 // cases the target cannot exit.
3071 
3072 static void thread_entry(JavaThread* thread, TRAPS) {
3073   HandleMark hm(THREAD);
3074   Handle obj(THREAD, thread-&gt;threadObj());
3075   JavaValue result(T_VOID);
3076   JavaCalls::call_virtual(&amp;result,
3077                           obj,
3078                           SystemDictionary::Thread_klass(),
3079                           vmSymbols::run_method_name(),
3080                           vmSymbols::void_method_signature(),
3081                           THREAD);
3082 }
3083 
3084 
3085 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
3086   JVMWrapper(&quot;JVM_StartThread&quot;);
3087   JavaThread *native_thread = NULL;
3088 
3089   // We cannot hold the Threads_lock when we throw an exception,
3090   // due to rank ordering issues. Example:  we might need to grab the
3091   // Heap_lock while we construct the exception.
3092   bool throw_illegal_thread_state = false;
3093 
3094   // We must release the Threads_lock before we can post a jvmti event
3095   // in Thread::start.
3096   {
3097     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
3098     // we operate.
3099     MutexLocker mu(Threads_lock);
3100 
3101     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
3102     // re-starting an already started thread, so we should usually find
3103     // that the JavaThread is null. However for a JNI attached thread
3104     // there is a small window between the Thread object being created
3105     // (with its JavaThread set) and the update to its threadStatus, so we
3106     // have to check for this
3107     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
3108       throw_illegal_thread_state = true;
3109     } else {
3110       // We could also check the stillborn flag to see if this thread was already stopped, but
3111       // for historical reasons we let the thread detect that itself when it starts running
3112 
3113       jlong size =
3114              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
3115       // Allocate the C++ Thread structure and create the native thread.  The
3116       // stack size retrieved from java is 64-bit signed, but the constructor takes
3117       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
3118       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
3119       //  - Avoid passing negative values which would result in really large stacks.
3120       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
3121       size_t sz = size &gt; 0 ? (size_t) size : 0;
3122       native_thread = new JavaThread(&amp;thread_entry, sz);
3123 
3124       // At this point it may be possible that no osthread was created for the
3125       // JavaThread due to lack of memory. Check for this situation and throw
3126       // an exception if necessary. Eventually we may want to change this so
3127       // that we only grab the lock if the thread was created successfully -
3128       // then we can also do this check and throw the exception in the
3129       // JavaThread constructor.
3130       if (native_thread-&gt;osthread() != NULL) {
3131         // Note: the current thread is not being used within &quot;prepare&quot;.
3132         native_thread-&gt;prepare(jthread);
3133       }
3134     }
3135   }
3136 
3137   if (throw_illegal_thread_state) {
3138     THROW(vmSymbols::java_lang_IllegalThreadStateException());
3139   }
3140 
3141   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
3142 
3143   if (native_thread-&gt;osthread() == NULL) {
3144     // No one should hold a reference to the &#39;native_thread&#39;.
3145     native_thread-&gt;smr_delete();
3146     if (JvmtiExport::should_post_resource_exhausted()) {
3147       JvmtiExport::post_resource_exhausted(
3148         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
3149         os::native_thread_creation_failed_msg());
3150     }
3151     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
3152               os::native_thread_creation_failed_msg());
3153   }
3154 
3155 #if INCLUDE_JFR
3156   if (JfrRecorder::is_recording() &amp;&amp; EventThreadStart::is_enabled() &amp;&amp;
3157       EventThreadStart::is_stacktrace_enabled()) {
3158     JfrThreadLocal* tl = native_thread-&gt;jfr_thread_local();
3159     // skip Thread.start() and Thread.start0()
3160     tl-&gt;set_cached_stack_trace_id(JfrStackTraceRepository::record(thread, 2));
3161   }
3162 #endif
3163 
3164   Thread::start(native_thread);
3165 
3166 JVM_END
3167 
3168 
3169 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
3170 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
3171 // but is thought to be reliable and simple. In the case, where the receiver is the
3172 // same thread as the sender, no VM_Operation is needed.
3173 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
3174   JVMWrapper(&quot;JVM_StopThread&quot;);
3175 
3176   // A nested ThreadsListHandle will grab the Threads_lock so create
3177   // tlh before we resolve throwable.
3178   ThreadsListHandle tlh(thread);
3179   oop java_throwable = JNIHandles::resolve(throwable);
3180   if (java_throwable == NULL) {
3181     THROW(vmSymbols::java_lang_NullPointerException());
3182   }
3183   oop java_thread = NULL;
3184   JavaThread* receiver = NULL;
3185   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3186   Events::log_exception(thread,
3187                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
3188                         p2i(receiver), p2i(java_thread), p2i(throwable));
3189 
3190   if (is_alive) {
3191     // jthread refers to a live JavaThread.
3192     if (thread == receiver) {
3193       // Exception is getting thrown at self so no VM_Operation needed.
3194       THROW_OOP(java_throwable);
3195     } else {
3196       // Use a VM_Operation to throw the exception.
3197       Thread::send_async_exception(java_thread, java_throwable);
3198     }
3199   } else {
3200     // Either:
3201     // - target thread has not been started before being stopped, or
3202     // - target thread already terminated
3203     // We could read the threadStatus to determine which case it is
3204     // but that is overkill as it doesn&#39;t matter. We must set the
3205     // stillborn flag for the first case, and if the thread has already
3206     // exited setting this flag has no effect.
3207     java_lang_Thread::set_stillborn(java_thread);
3208   }
3209 JVM_END
3210 
3211 
3212 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
3213   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
3214 
3215   oop thread_oop = JNIHandles::resolve_non_null(jthread);
3216   return java_lang_Thread::is_alive(thread_oop);
3217 JVM_END
3218 
3219 
3220 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
3221   JVMWrapper(&quot;JVM_SuspendThread&quot;);
3222 
3223   ThreadsListHandle tlh(thread);
3224   JavaThread* receiver = NULL;
3225   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3226   if (is_alive) {
3227     // jthread refers to a live JavaThread.
3228     {
3229       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
3230       if (receiver-&gt;is_external_suspend()) {
3231         // Don&#39;t allow nested external suspend requests. We can&#39;t return
3232         // an error from this interface so just ignore the problem.
3233         return;
3234       }
3235       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
3236         return;
3237       }
3238       receiver-&gt;set_external_suspend();
3239     }
3240 
3241     // java_suspend() will catch threads in the process of exiting
3242     // and will ignore them.
3243     receiver-&gt;java_suspend();
3244 
3245     // It would be nice to have the following assertion in all the
3246     // time, but it is possible for a racing resume request to have
3247     // resumed this thread right after we suspended it. Temporarily
3248     // enable this assertion if you are chasing a different kind of
3249     // bug.
3250     //
3251     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
3252     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
3253   }
3254 JVM_END
3255 
3256 
3257 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
3258   JVMWrapper(&quot;JVM_ResumeThread&quot;);
3259 
3260   ThreadsListHandle tlh(thread);
3261   JavaThread* receiver = NULL;
3262   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3263   if (is_alive) {
3264     // jthread refers to a live JavaThread.
3265 
3266     // This is the original comment for this Threads_lock grab:
3267     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
3268     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
3269     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
3270     //   looks at it.
3271     //
3272     // The above comment dates back to when we had both internal and
3273     // external suspend APIs that shared a common underlying mechanism.
3274     // External suspend is now entirely cooperative and doesn&#39;t share
3275     // anything with internal suspend. That said, there are some
3276     // assumptions in the VM that an external resume grabs the
3277     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
3278     // resolve the assumptions that exist elsewhere.
3279     //
3280     MutexLocker ml(Threads_lock);
3281     receiver-&gt;java_resume();
3282   }
3283 JVM_END
3284 
3285 
3286 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3287   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3288 
3289   ThreadsListHandle tlh(thread);
3290   oop java_thread = NULL;
3291   JavaThread* receiver = NULL;
3292   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3293   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3294 
3295   if (is_alive) {
3296     // jthread refers to a live JavaThread.
3297     Thread::set_priority(receiver, (ThreadPriority)prio);
3298   }
3299   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3300   // priority set in the java.lang.Thread object above will be pushed
3301   // down when it does start.
3302 JVM_END
3303 
3304 
3305 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3306   JVMWrapper(&quot;JVM_Yield&quot;);
3307   if (os::dont_yield()) return;
3308   HOTSPOT_THREAD_YIELD();
3309   os::naked_yield();
3310 JVM_END
3311 
3312 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3313   assert(event != NULL, &quot;invariant&quot;);
3314   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3315   event-&gt;set_time(millis);
3316   event-&gt;commit();
3317 }
3318 
3319 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3320   JVMWrapper(&quot;JVM_Sleep&quot;);
3321 
3322   if (millis &lt; 0) {
3323     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3324   }
3325 
3326   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3327     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3328   }
3329 
3330   // Save current thread state and restore it at the end of this block.
3331   // And set new thread state to SLEEPING.
3332   JavaThreadSleepState jtss(thread);
3333 
3334   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3335   EventThreadSleep event;
3336 
3337   if (millis == 0) {
3338     os::naked_yield();
3339   } else {
3340     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3341     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3342     if (!thread-&gt;sleep(millis)) { // interrupted
3343       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3344       // us while we were sleeping. We do not overwrite those.
3345       if (!HAS_PENDING_EXCEPTION) {
3346         if (event.should_commit()) {
3347           post_thread_sleep_event(&amp;event, millis);
3348         }
3349         HOTSPOT_THREAD_SLEEP_END(1);
3350 
3351         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3352         // to properly restore the thread state.  That&#39;s likely wrong.
3353         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3354       }
3355     }
3356     thread-&gt;osthread()-&gt;set_state(old_state);
3357   }
3358   if (event.should_commit()) {
3359     post_thread_sleep_event(&amp;event, millis);
3360   }
3361   HOTSPOT_THREAD_SLEEP_END(0);
3362 JVM_END
3363 
3364 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3365   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3366   oop jthread = thread-&gt;threadObj();
3367   assert (thread != NULL, &quot;no current thread!&quot;);
3368   return JNIHandles::make_local(env, jthread);
3369 JVM_END
3370 
3371 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3372   JVMWrapper(&quot;JVM_Interrupt&quot;);
3373 
3374   ThreadsListHandle tlh(thread);
3375   JavaThread* receiver = NULL;
3376   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3377   if (is_alive) {
3378     // jthread refers to a live JavaThread.
3379     receiver-&gt;interrupt();
3380   }
3381 JVM_END
3382 
3383 
3384 // Return true iff the current thread has locked the object passed in
3385 
3386 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3387   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3388   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3389   if (obj == NULL) {
3390     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3391   }
3392   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3393   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3394 JVM_END
3395 
3396 
3397 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3398   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3399   VM_PrintThreads op;
3400   VMThread::execute(&amp;op);
3401   if (JvmtiExport::should_post_data_dump()) {
3402     JvmtiExport::post_data_dump();
3403   }
3404 JVM_END
3405 
3406 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3407   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3408 
3409   // We don&#39;t use a ThreadsListHandle here because the current thread
3410   // must be alive.
3411   oop java_thread = JNIHandles::resolve_non_null(jthread);
3412   JavaThread* thr = java_lang_Thread::thread(java_thread);
3413   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3414     // Thread naming is only supported for the current thread and
3415     // we don&#39;t set the name of an attached thread to avoid stepping
3416     // on other programs.
3417     ResourceMark rm(thread);
3418     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3419     os::set_native_thread_name(thread_name);
3420   }
3421 JVM_END
3422 
3423 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3424 
3425 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3426   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3427   ResourceMark rm(THREAD);
3428   JvmtiVMObjectAllocEventCollector oam;
3429   vframeStream vfst(thread);
3430 
3431   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3432     // This must only be called from SecurityManager.getClassContext
3433     Method* m = vfst.method();
3434     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3435           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3436           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3437       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3438     }
3439   }
3440 
3441   // Collect method holders
3442   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3443   for (; !vfst.at_end(); vfst.security_next()) {
3444     Method* m = vfst.method();
3445     // Native frames are not returned
3446     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3447       Klass* holder = m-&gt;method_holder();
3448       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3449       klass_array-&gt;append(holder);
3450     }
3451   }
3452 
3453   // Create result array of type [Ljava/lang/Class;
3454   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3455   // Fill in mirrors corresponding to method holders
3456   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3457     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3458   }
3459 
3460   return (jobjectArray) JNIHandles::make_local(env, result);
3461 JVM_END
3462 
3463 
3464 // java.lang.Package ////////////////////////////////////////////////////////////////
3465 
3466 
3467 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3468   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3469   ResourceMark rm(THREAD);
3470   JvmtiVMObjectAllocEventCollector oam;
3471   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3472   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3473   return (jstring) JNIHandles::make_local(result);
3474 JVM_END
3475 
3476 
3477 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3478   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3479   JvmtiVMObjectAllocEventCollector oam;
3480   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3481   return (jobjectArray) JNIHandles::make_local(result);
3482 JVM_END
3483 
3484 
3485 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3486 
3487 
3488 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3489   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3490 
3491   MonitorLocker ml(Heap_lock);
3492   oop ref = Universe::reference_pending_list();
3493   if (ref != NULL) {
3494     Universe::set_reference_pending_list(NULL);
3495   }
3496   return JNIHandles::make_local(env, ref);
3497 JVM_END
3498 
3499 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3500   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3501   MonitorLocker ml(Heap_lock);
3502   return Universe::has_reference_pending_list();
3503 JVM_END
3504 
3505 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3506   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3507   MonitorLocker ml(Heap_lock);
3508   while (!Universe::has_reference_pending_list()) {
3509     ml.wait();
3510   }
3511 JVM_END
3512 
3513 
3514 // ObjectInputStream ///////////////////////////////////////////////////////////////
3515 
3516 // Return the first user-defined class loader up the execution stack, or null
3517 // if only code from the bootstrap or platform class loader is on the stack.
3518 
3519 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3520   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3521     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3522     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3523     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3524       return JNIHandles::make_local(env, loader);
3525     }
3526   }
3527   return NULL;
3528 JVM_END
3529 
3530 
3531 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3532 
3533 
3534 // resolve array handle and check arguments
3535 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3536   if (arr == NULL) {
3537     THROW_0(vmSymbols::java_lang_NullPointerException());
3538   }
3539   oop a = JNIHandles::resolve_non_null(arr);
3540   if (!a-&gt;is_array()) {
3541     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3542   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3543     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3544   }
3545   return arrayOop(a);
3546 }
3547 
3548 
3549 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3550   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3551   arrayOop a = check_array(env, arr, false, CHECK_0);
3552   return a-&gt;length();
3553 JVM_END
3554 
3555 
3556 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3557   JVMWrapper(&quot;JVM_Array_Get&quot;);
3558   JvmtiVMObjectAllocEventCollector oam;
3559   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3560   jvalue value;
3561   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3562   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3563   return JNIHandles::make_local(env, box);
3564 JVM_END
3565 
3566 
3567 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3568   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3569   jvalue value;
3570   value.i = 0; // to initialize value before getting used in CHECK
3571   arrayOop a = check_array(env, arr, true, CHECK_(value));
3572   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3573   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3574   BasicType wide_type = (BasicType) wCode;
3575   if (type != wide_type) {
3576     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3577   }
3578   return value;
3579 JVM_END
3580 
3581 
3582 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3583   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3584   arrayOop a = check_array(env, arr, false, CHECK);
3585   oop box = JNIHandles::resolve(val);
3586   jvalue value;
3587   value.i = 0; // to initialize value before getting used in CHECK
3588   BasicType value_type;
3589   if (a-&gt;is_objArray()) {
3590     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3591     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3592   } else {
3593     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3594   }
3595   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3596 JVM_END
3597 
3598 
3599 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3600   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3601   arrayOop a = check_array(env, arr, true, CHECK);
3602   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3603   BasicType value_type = (BasicType) vCode;
3604   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3605 JVM_END
3606 
3607 
3608 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3609   JVMWrapper(&quot;JVM_NewArray&quot;);
3610   JvmtiVMObjectAllocEventCollector oam;
3611   oop element_mirror = JNIHandles::resolve(eltClass);
3612   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3613   return JNIHandles::make_local(env, result);
3614 JVM_END
3615 
3616 
3617 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3618   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3619   JvmtiVMObjectAllocEventCollector oam;
3620   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3621   oop element_mirror = JNIHandles::resolve(eltClass);
3622   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3623   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3624   return JNIHandles::make_local(env, result);
3625 JVM_END
3626 
3627 
3628 // Library support ///////////////////////////////////////////////////////////////////////////
3629 
3630 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3631   //%note jvm_ct
3632   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3633   char ebuf[1024];
3634   void *load_result;
3635   {
3636     ThreadToNativeFromVM ttnfvm(thread);
3637     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3638   }
3639   if (load_result == NULL) {
3640     char msg[1024];
3641     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3642     // Since &#39;ebuf&#39; may contain a string encoded using
3643     // platform encoding scheme, we need to pass
3644     // Exceptions::unsafe_to_utf8 to the new_exception method
3645     // as the last argument. See bug 6367357.
3646     Handle h_exception =
3647       Exceptions::new_exception(thread,
3648                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3649                                 msg, Exceptions::unsafe_to_utf8);
3650 
3651     THROW_HANDLE_0(h_exception);
3652   }
3653   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));
3654   return load_result;
3655 JVM_END
3656 
3657 
3658 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3659   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3660   os::dll_unload(handle);
3661   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));
3662 JVM_END
3663 
3664 
3665 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3666   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3667   void* find_result = os::dll_lookup(handle, name);
3668   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,
3669                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,
3670                     name, p2i(handle));
3671   return find_result;
3672 JVM_END
3673 
3674 
3675 // JNI version ///////////////////////////////////////////////////////////////////////////////
3676 
3677 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3678   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3679   return Threads::is_supported_jni_version_including_1_1(version);
3680 JVM_END
3681 
3682 
3683 // String support ///////////////////////////////////////////////////////////////////////////
3684 
3685 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3686   JVMWrapper(&quot;JVM_InternString&quot;);
3687   JvmtiVMObjectAllocEventCollector oam;
3688   if (str == NULL) return NULL;
3689   oop string = JNIHandles::resolve_non_null(str);
3690   oop result = StringTable::intern(string, CHECK_NULL);
3691   return (jstring) JNIHandles::make_local(env, result);
3692 JVM_END
3693 
3694 
3695 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3696 
3697 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3698 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3699 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3700 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3701 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3702 
3703 
3704 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3705   VM_Exit::block_if_vm_exited();
3706   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3707   return new os::PlatformMutex();
3708 }
3709 
3710 
3711 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3712   VM_Exit::block_if_vm_exited();
3713   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3714   delete ((os::PlatformMutex*) mon);
3715 }
3716 
3717 
3718 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3719   VM_Exit::block_if_vm_exited();
3720   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3721   ((os::PlatformMutex*) mon)-&gt;lock();
3722   return 0;
3723 }
3724 
3725 
3726 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3727   VM_Exit::block_if_vm_exited();
3728   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3729   ((os::PlatformMutex*) mon)-&gt;unlock();
3730 }
3731 
3732 
3733 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3734 
3735 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3736                                     Handle loader, Handle protection_domain,
3737                                     jboolean throwError, TRAPS) {
3738   // Security Note:
3739   //   The Java level wrapper will perform the necessary security check allowing
3740   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3741   //   the checkPackageAccess relative to the initiating class loader via the
3742   //   protection_domain. The protection_domain is passed as NULL by the java code
3743   //   if there is no security manager in 3-arg Class.forName().
3744   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3745 
3746   // Check if we should initialize the class
3747   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3748     klass-&gt;initialize(CHECK_NULL);
3749   }
3750   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3751 }
3752 
3753 
3754 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3755 
3756 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3757   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3758   Handle method_handle;
3759   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3760     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3761     Handle receiver(THREAD, JNIHandles::resolve(obj));
3762     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
3763     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3764     jobject res = JNIHandles::make_local(env, result);
3765     if (JvmtiExport::should_post_vm_object_alloc()) {
3766       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3767       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3768       if (java_lang_Class::is_primitive(ret_type)) {
3769         // Only for primitive type vm allocates memory for java object.
3770         // See box() method.
3771         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3772       }
3773     }
3774     return res;
3775   } else {
3776     THROW_0(vmSymbols::java_lang_StackOverflowError());
3777   }
3778 JVM_END
3779 
3780 
3781 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3782   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3783   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
3784   oop constructor_mirror = JNIHandles::resolve(c);
3785   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3786   jobject res = JNIHandles::make_local(env, result);
3787   if (JvmtiExport::should_post_vm_object_alloc()) {
3788     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3789   }
3790   return res;
3791 JVM_END
3792 
3793 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3794 
3795 JVM_LEAF(jboolean, JVM_SupportsCX8())
3796   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3797   return VM_Version::supports_cx8();
3798 JVM_END
3799 
3800 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3801   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3802   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3803   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3804   HeapShared::initialize_from_archived_subgraph(k);
3805 JVM_END
3806 
3807 JVM_ENTRY(void, JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env,
3808                                               jclass caller,
3809                                               jstring invokedName,
3810                                               jobject invokedType,
3811                                               jobject methodType,
3812                                               jobject implMethodMember,
3813                                               jobject instantiatedMethodType,
3814                                               jclass lambdaProxyClass))
3815   JVMWrapper(&quot;JVM_RegisterLambdaProxyClassForArchiving&quot;);
3816 #if INCLUDE_CDS
3817   if (!DynamicDumpSharedSpaces) {
3818     return;
3819   }
3820 
3821   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
3822   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);
3823   if (caller_ik-&gt;is_hidden() || caller_ik-&gt;is_unsafe_anonymous()) {
3824     // VM anonymous classes and hidden classes not of type lambda proxy classes are currently not being archived.
3825     // If the caller_ik is of one of the above types, the corresponding lambda proxy class won&#39;t be
3826     // registered for archiving.
3827     return;
3828   }
3829   Klass* lambda_k = java_lang_Class::as_Klass(JNIHandles::resolve(lambdaProxyClass));
3830   InstanceKlass* lambda_ik = InstanceKlass::cast(lambda_k);
3831   assert(lambda_ik-&gt;is_hidden(), &quot;must be a hidden class&quot;);
3832   assert(!lambda_ik-&gt;is_non_strong_hidden(), &quot;expected a strong hidden class&quot;);
3833 
3834   Symbol* invoked_name = NULL;
3835   if (invokedName != NULL) {
3836     invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));
3837   }
3838   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));
3839   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);
3840 
3841   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));
3842   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);
3843 
3844   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));
3845   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);
3846   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());
3847 
3848   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
3849   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
3850 
3851   SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,
3852                                                  method_type, m, instantiated_method_type);
3853 #endif // INCLUDE_CDS
3854 JVM_END
3855 
3856 JVM_ENTRY(jclass, JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env,
3857                                                         jclass caller,
3858                                                         jstring invokedName,
3859                                                         jobject invokedType,
3860                                                         jobject methodType,
3861                                                         jobject implMethodMember,
3862                                                         jobject instantiatedMethodType,
3863                                                         jboolean initialize))
3864   JVMWrapper(&quot;JVM_LookupLambdaProxyClassFromArchive&quot;);
3865 #if INCLUDE_CDS
3866   if (!DynamicArchive::is_mapped()) {
3867     return NULL;
3868   }
3869 
3870   if (invokedName == NULL || invokedType == NULL || methodType == NULL ||
3871       implMethodMember == NULL || instantiatedMethodType == NULL) {
3872     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
3873   }
3874 
3875   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
3876   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);
3877   if (!caller_ik-&gt;is_shared()) {
3878     // there won&#39;t be a shared lambda class if the caller_ik is not in the shared archive.
3879     return NULL;
3880   }
3881 
3882   Symbol* invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));
3883   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));
3884   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);
3885 
3886   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));
3887   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);
3888 
3889   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));
3890   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);
3891   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());
3892 
3893   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
3894   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
3895 
3896   InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, invoked_name, invoked_type,
3897                                                                                    method_type, m, instantiated_method_type);
3898   jclass jcls = NULL;
3899   if (lambda_ik != NULL) {
3900     InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, initialize, THREAD);
3901     jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(env, loaded_lambda-&gt;java_mirror());
3902   }
3903   return jcls;
3904 #else
3905   return NULL;
3906 #endif // INCLUDE_CDS
3907 JVM_END
3908 
3909 JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))
3910     JVMWrapper(&quot;JVM_IsCDSDumpingEnable&quot;);
3911     return DynamicDumpSharedSpaces;
3912 JVM_END
3913 
3914 JVM_ENTRY(jboolean, JVM_IsCDSSharingEnabled(JNIEnv* env))
3915     JVMWrapper(&quot;JVM_IsCDSSharingEnable&quot;);
3916     return UseSharedSpaces;
3917 JVM_END
3918 
3919 JVM_ENTRY_NO_ENV(jlong, JVM_GetRandomSeedForCDSDump())
3920   JVMWrapper(&quot;JVM_GetRandomSeedForCDSDump&quot;);
3921   if (DumpSharedSpaces) {
3922     const char* release = Abstract_VM_Version::vm_release();
3923     const char* dbg_level = Abstract_VM_Version::jdk_debug_level();
3924     const char* version = VM_Version::internal_vm_info_string();
3925     jlong seed = (jlong)(java_lang_String::hash_code((const jbyte*)release, (int)strlen(release)) ^
3926                          java_lang_String::hash_code((const jbyte*)dbg_level, (int)strlen(dbg_level)) ^
3927                          java_lang_String::hash_code((const jbyte*)version, (int)strlen(version)));
3928     seed += (jlong)Abstract_VM_Version::vm_major_version();
3929     seed += (jlong)Abstract_VM_Version::vm_minor_version();
3930     seed += (jlong)Abstract_VM_Version::vm_security_version();
3931     seed += (jlong)Abstract_VM_Version::vm_patch_version();
3932     if (seed == 0) { // don&#39;t let this ever be zero.
3933       seed = 0x87654321;
3934     }
3935     log_debug(cds)(&quot;JVM_GetRandomSeedForCDSDump() = &quot; JLONG_FORMAT, seed);
3936     return seed;
3937   } else {
3938     return 0;
3939   }
3940 JVM_END
3941 
3942 // Returns an array of all live Thread objects (VM internal JavaThreads,
3943 // jvmti agent threads, and JNI attaching threads  are skipped)
3944 // See CR 6404306 regarding JNI attaching threads
3945 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3946   ResourceMark rm(THREAD);
3947   ThreadsListEnumerator tle(THREAD, false, false);
3948   JvmtiVMObjectAllocEventCollector oam;
3949 
3950   int num_threads = tle.num_threads();
3951   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3952   objArrayHandle threads_ah(THREAD, r);
3953 
3954   for (int i = 0; i &lt; num_threads; i++) {
3955     Handle h = tle.get_threadObj(i);
3956     threads_ah-&gt;obj_at_put(i, h());
3957   }
3958 
3959   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
3960 JVM_END
3961 
3962 
3963 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3964 // Return StackTraceElement[][], each element is the stack trace of a thread in
3965 // the corresponding entry in the given threads array
3966 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3967   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3968   JvmtiVMObjectAllocEventCollector oam;
3969 
3970   // Check if threads is null
3971   if (threads == NULL) {
3972     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3973   }
3974 
3975   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3976   objArrayHandle ah(THREAD, a);
3977   int num_threads = ah-&gt;length();
3978   // check if threads is non-empty array
3979   if (num_threads == 0) {
3980     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3981   }
3982 
3983   // check if threads is not an array of objects of Thread class
3984   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3985   if (k != SystemDictionary::Thread_klass()) {
3986     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3987   }
3988 
3989   ResourceMark rm(THREAD);
3990 
3991   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3992   for (int i = 0; i &lt; num_threads; i++) {
3993     oop thread_obj = ah-&gt;obj_at(i);
3994     instanceHandle h(THREAD, (instanceOop) thread_obj);
3995     thread_handle_array-&gt;append(h);
3996   }
3997 
3998   // The JavaThread references in thread_handle_array are validated
3999   // in VM_ThreadDump::doit().
4000   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
4001   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
4002 
4003 JVM_END
4004 
4005 // JVM monitoring and management support
4006 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
4007   return Management::get_jmm_interface(version);
4008 JVM_END
4009 
4010 // com.sun.tools.attach.VirtualMachine agent properties support
4011 //
4012 // Initialize the agent properties with the properties maintained in the VM
4013 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
4014   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
4015   ResourceMark rm;
4016 
4017   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
4018 
4019   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
4020   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
4021   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
4022   return properties;
4023 JVM_END
4024 
4025 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
4026 {
4027   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
4028   JvmtiVMObjectAllocEventCollector oam;
4029 
4030   if (ofClass == NULL) {
4031     return NULL;
4032   }
4033   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
4034   // Special handling for primitive objects
4035   if (java_lang_Class::is_primitive(mirror())) {
4036     return NULL;
4037   }
4038   Klass* k = java_lang_Class::as_Klass(mirror());
4039   if (!k-&gt;is_instance_klass()) {
4040     return NULL;
4041   }
4042   InstanceKlass* ik = InstanceKlass::cast(k);
4043   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
4044   if (encl_method_class_idx == 0) {
4045     return NULL;
4046   }
4047   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
4048   objArrayHandle dest(THREAD, dest_o);
4049   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
4050   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
4051   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
4052   if (encl_method_method_idx != 0) {
4053     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
4054                         extract_low_short_from_int(
4055                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
4056     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
4057     dest-&gt;obj_at_put(1, str());
4058     sym = ik-&gt;constants()-&gt;symbol_at(
4059               extract_high_short_from_int(
4060                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
4061     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
4062     dest-&gt;obj_at_put(2, str());
4063   }
4064   return (jobjectArray) JNIHandles::make_local(dest());
4065 }
4066 JVM_END
4067 
4068 // Returns an array of java.lang.String objects containing the input arguments to the VM.
4069 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
4070   ResourceMark rm(THREAD);
4071 
4072   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
4073     return NULL;
4074   }
4075 
4076   char** vm_flags = Arguments::jvm_flags_array();
4077   char** vm_args = Arguments::jvm_args_array();
4078   int num_flags = Arguments::num_jvm_flags();
4079   int num_args = Arguments::num_jvm_args();
4080 
4081   InstanceKlass* ik = SystemDictionary::String_klass();
4082   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
4083   objArrayHandle result_h(THREAD, r);
4084 
4085   int index = 0;
4086   for (int j = 0; j &lt; num_flags; j++, index++) {
4087     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
4088     result_h-&gt;obj_at_put(index, h());
4089   }
4090   for (int i = 0; i &lt; num_args; i++, index++) {
4091     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
4092     result_h-&gt;obj_at_put(index, h());
4093   }
4094   return (jobjectArray) JNIHandles::make_local(env, result_h());
4095 JVM_END
4096 
4097 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
4098   return os::get_signal_number(name);
4099 JVM_END
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>